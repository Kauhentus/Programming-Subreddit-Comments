Why do you want to do this?
&gt; Should I just ignore/disable the warning or is there a nice way to initialize the constructor to avoid the problem? Can't you mark `otherProp` as final? final var otherProp: String = "" Or do you require being able to override it?
Try the https://docs.oracle.com/javase/tutorial/java/generics/index.html
Wow, you're right! I was still thinking about **final** in the Java way, so basically for it to be equivalent to **val**. Thank you!
I think, that's because a subclass could override the otherProp getter and setter and the constructor you get warned about would not use the overriden setter.
thanks for the feedback but I think that in this case u/morhp suggestion is the right one to follow
&gt;sometimes I prefer to have a no-args primary constructor &amp;#x200B; Isn't a no-args secondary constructor enough for bean-like systems? &amp;#x200B;
That might work in this case however generally you'll need to pass all of the properties of the class in the primary constructor and then defaults in the no-arg secondary. For example @Entity class Test(var text: String, var date: DateTime, var custom: CustomObject) { constructor(): this("", DateTime.now(), /* What here? */) } One option to solve the issue with `CustomObject` would be to make the field nullable but this solution is very unpleasant to me because I then lose information about which fields should really be nullable and which not.
In that case deserialization should work with a class like: ``` @Entity class Test(var text: String, var date: DateTime) { lateinit var custom: CustomObject constructor(): this("", DateTime.now()) } ```
Is it expected that SQLDelight doesn't support bitwise operators such as negation? Or is there some trick to this that I've missed? Example: `WHERE flags &amp; ~:ignore &gt; 0` throws an error complaining about the syntax.
tracking here: https://github.com/AlecStrong/sqlite-psi/issues/31
It’s just so strange! 8 bits ended up becoming the convention, with 16 and 32 bit variants. Seems like they jumped the gun with that one.
Excellent article, I fully agree, data classes are overhyped when I think features like destructing are not emphasized enough!
The author complains that there are no restrictions on inheritance but this says [data classes cannot be open, abstract, sealed or inner.](https://kotlinlang.org/docs/reference/data-classes.html) I think if you are using them as anything as a POJO you are doing it wrong. &amp;#x200B; There are no more, or less magical than a POJO with significantly less boilerplate
Android Things is a pivot from Brillo. So already there you have Google having changed their mind once. I would advise to rather get an embedded GNU/Linux distribution and use standard Java or any other programming language you guys feel like using.
Don't know if the article was changed, but the article lists the "pro" that regular classes have no restrictions on inheritance in comparison to data classes.
You are totally right. I misread it.
Yeah, that's the point. It's not just Flutter. Any technology you're going to adopt is going to carry with it some risk. We have run Droidcon NYC for years, plus the big Android meetup in NYC, but the business talks to big orgs about their tech decisions, so I tend to talk to people evaluating tech from different perspectives. From a risk perspective, an individual can support something without risking much. If you're going to retrain hundreds of engineers and rewrite your apps, that's a different story. Some more free form thoughts. The developers I talk to tend to compare Flutter to native dev, but I don't think that's going to be Flutter's competition. Web components and webassembly are going to be Flutter's competition, at least in the consumer product space. Flutter, technically, is a non-standard browser, and Dart is to programming as Esperanto is to speaking. It'll be difficult to compete with web standards (web components), with a bespoke language right when the web is opening the language options up. Or not. Predicting the future is very hard. I have no idea if Flutter will "win", or die out next year. If you'd asked me in 2010 where native mobile would be in 2015, I'd say mostly gone, replaced by the web. I like the Kotlin stack because, as multiplatform matures, you'll be able to code the architectural part and have more flexibility on the actual deployment. Native, webassembly, maybe? Not sure, but you won't have to completely start over when platform blur. Predicting the future is less problematic if you don't need to.
Depends entirely on your priorities. Immutability has benefits in making code easier to maintain and reason about, but copying your data rather than mutating means you are sacrificing performance for those benefits and that tradeoff isn't always worth it. 
Thank you for your response. I was thinking copy() may be a hit on performance compared to mutable properties.
Phew, I was scared that I've managed to write something totally backwards.
If Fuchsia ever emerges, and if Google decides to put it on phones, Flutter may be an option, but it's impossible to imagine you won't be able to run Android apps or that PWA's won't be first class citizens with hardware access, webassembly, etc. Fuchsia devices would be like Chrome OS and Android OS merged into one unit, as far as app development options are concerned.
Currently there isn't any love for desktop Android apps in spite of ChromeOS integration, one just gets phone sized apps. Additionally ChromeOS is pretty much irrelevant outside the North American market. As I said, it remains to be seen how Fuchsia will evolve.
What I like about data classes, and what isn't really mentioned here, is that they really helps you to change your thinking about data and promote using immutable structures (I don't think I ever wrote data class with var). Copy method is incredibly useful as alternative to mutating state. &amp;#x200B; They also increase code readability by signaling their purpose &amp;#x200B; And restrictions in inheritance aren't really "cons", rather a feature :) 
If you're not doing it thousands or millions of times (like in a loop) it's very unlikely you will even notice this 
All good points! I did have just a couple words in there about how copy is good for immutable classes, because I didn't want to dwell on it in this post, as I was aiming to be as concise as possible while explaining the differences.
I will add to this: the benefits of immutability are not obvious but are very big, while the benefits of better performance are easy to see but generally irrelevant. It's also very easy to move from immutable to mutable, but very difficult to go the other way around. For this reasons, unless I have clear evidence that I need the performance I get from mutability, I would for copy(). If you need, you change it afterwards.
You've got some very certain perspectives. "isn't ***any*** love" is probably an oversimplification and "one just gets phone sized apps" is true, assuming "one" doesn't attempt to design their app for bigger platforms. Same issue (conceptually) with tablets. "irrelevant" is a strong word. Also, as I understand it, ChromeOS has crushed the education market. If only US, still no small feat. However, that's not my point. My point is Fuchsia devices ***would be like*** an amalgam of those platforms in the sense that Android apps and PWAs would be first class citizens. Anybody thinking they should start building Flutter apps because of concern over Fuchsia should chill out. To be cleat, I'm not saying that's what ***you're*** saying but I've heard that perspective from others.
For who's benefit? Google doesn't make money if your app does well. It's possible we'll start seeing a lot of Google apps in Flutter, but contrary to popular belief, it's been around for a while. They were pitching us to use it for clients in mid-2016. There are some internal apps, but each team picks their tech, and I wouldn't expect massive porting anytime soon. We'll see, though.
Sucks that the Kotlin Multiplatform thread became all about Flutter.
I agree with the above very much, code maintenance is very important and in most cases the loss of performance is negligible. I'd also like to add that the copy of an immutable isn't nessecarily as heavy as some people think, and on a theoretical language level, might even be faster than if you went mutable. If you go immutable, all inner data (if the structure is complex) that is not changed in the copy can be reused by reference. Kotlin, by design, guarantees the value does not change because it is immutable. Same cannot be said for copying a non immutable object. This is another reason why immutable data classes are a good idea.
Computers are very powerful in the current era, it isn't something you really need to worry about except in extreme cases. You can use the function measureNanoTime to actually get the performance difference if you want. I just did some testing with it to see how much longer it takes with copying a list of 100,000 Ints, and it is 0.5ms on my machine. The difference might matter if you are blocking the UI thread, but then again you shouldn't be blocking the UI thread.
Thank you for the input!
Thank you! I did not realize these points.
Thank you for your response. And thanks for the measureNanoTime reference, I will play around with that :)
Any java backend resource can be applied to kotlin(just changing syntax and little nullability fixes) If you want pure kotlin stack just look at jetbrains projects like ktor.
Normally I choose based on usage. As an example, I definitely take the mutable approach when working on games for side projects because I need 60 fps and can't afford to create hundreds of thousands of objects per frame. However, the fact that you're specifically asking about data classes complicates things given that the main difference between regular classes and data classes is the auto-generated equals &amp; hashcode (as well as toString, copy, and the componentN functions). So the problem is that if you store mutable instances into hashsets or as keys into hashmaps, you will run into all sorts of strange behaviour (eg. contains could return false even though the collection contains the entity because the hashcode would change). So my recommendation is to either use regular classes if some properties are mutable or you can safely use a data class if you make sure that the mutable properties are not part of the primary constructor so that they're not used by equals and hashcode (as long as it still makes sence for them to be treated as equal when the mutable properties differ). One possible solution to ensure that you never run into hashing issues and still have mutable properties in the primary constructor of the data class would be to ensure that you never use it anywhere the hashcode is used so you could override the hashcode function to always throw an Illegal state exception.
Hey, Determinant, just a quick heads-up: **sence** is actually spelled **sense**. You can remember it by **ends with -se**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
Thank you for the explanation and recommendation! :)
Just a heads up from experience, on the server side, making JPA entity classes immutable can lead to some odd behavior if the class contains any one-to-many relationships, especially if you use an immutable collection (e.g., List instead of MutableList). All hell breaks loose when Hibernate tries to hydrate the collection of linked entities before saving, as the EntityManager loses the association between the child entities and the current persistence context. You get one of those dreaded JPA cascade errors, but changing the cascade type doesn't fix it. For that situation, you're better off with a MutableList/Set/whatever. If you don't have any one-to-many relationships in the class, copy() works fine. Otherwise, you're stuck using vars.
One word: coroutines :) Just kidding. Kind of. When you’re using Spring, you’re also in a very Java oriented world, and, there’s nothing wrong with that. In fact, I’d still generally use Spring Boot for a lot of server side stuff just because it’s so well understood, documented, and that makes it much easier to bring people into the fold. But, it’s built on a lot of history, and Kotlin is still pretty new there. To push your Kotlin knowledge a bit further, I’d start diving into some of the coroutine overviews and patterns, especially when people start comparing it to Rx, for example. It’s a very different way to design asynchronous systems, and on the server side, you can throw pretty serious numbers of coroutines around. It’s very new terrain. Otherwise the ktor stuff is pretty interesting because you can see the effects of designing a framework with coroutines in mind.
I want to associate a file in the resources directory with a function
Main disadvantage of data classes in my opinion is that you can't effectively make the constructor private to enforce creation with a factory or something similar. While you can make the constructor private, copy() is always public, so anyone can create any instances they want without using the factory. 
I gathered as much, but I still do not understand the \*why\*. Nevertheless, here are a few more examples that work: val foo = {} fun bar() {} fun main() { val printIt: (InputStream) -&gt; Unit = { it.reader().readLines().let(::println) } foo.javaClass.getResourceAsStream("foo.json").let(printIt) ::bar.javaClass.getResourceAsStream("foo.json").let(printIt) ({}).javaClass.getResourceAsStream("foo.json").let(printIt) }
i don't understand your not understanding why. files need to be somewhere. java already has a mechanism for organizing resource files. kotlin allows plain functions, so i figured there would be a non-hacky way to hook into the java functionality from inside a plain function that aside, i do appreciate you taking the time to respond. thanks
Immutability becomes a pain when you need to work with generic data, deep updates or complex update logic. Before you know it you're trying to fit lenses and optics, monads and so on into Kotlin. A good compromise might be creating \`val\` only superinterfaces for your classes so you can use types to control when/where mutation occurs.
I have actually found the opposite to be true. The benefits of mutability are not obvious but can become quite significant. Going down the purely functional, immutable path inevitably means introducing layers and layers of abstraction to manage deep updates or generic data. This approach is unwieldy even in languages like Haskell that are far more equipped for it than Kotlin. Performance is a significant advantage of mutability but it isn't the primary one. Otoh the downsides of mutability are over publicised and can be managed by limiting when and where mutation is performed. This is the Kotlin way with e.g. readonly collection superinterfaces. Ditching mutability entirely is throwing the baby out with the bathwater.
You can use enum classes instead of data classes to represent state. This also solves your problem with the else in when: kotlin is able to tell when you handle all cases with an enum. It allows for some under the hood optimizations; enum values are effectively ints. So things like comparing are a lot cheaper. Another trick is to make the enum implement an interface. So you could have a State interface that and put the states for a particular state machine in an enum. The State interface could specify that each enum value must have a map of valid transitions that map inputs (could be another enum) to states. Then, a generic way to process events is simply to capture inputs, examine the current state, lookup the right transition and set the target state. You don't need a when for this and enum maps are very efficient. On top of that you can completely abstract away the business of operating a state machine, dealing with errors (e.g. invalid inputs), etc.
&gt; See if you can spot that error as well. Tests were not running the assertions at all. That's why you need to do red-green cycle for every new test.
`parallelStream` good for parallelization of computation tasks, so if you need to process billions of data points - it's very good option. But if you need to make hundreds of IO tasks like http requests, or reading files - `parallelStream` bad option/ And you rather should use coroutines for this kind of tasks. So depending on task `parallelStream` can or can't be good approach. Also, if you target JVM8+ you can use `parallelStream` from Kotlin code, so you get best of both worlds.
Firstly, thanks for taking the time to read my post! It is actually my first blog post and something I have wanted to try for a while. I don't confess to being a great computer scientist and I am certainly not an expert Kotlin dev, so I am writing these as an exercise to further my learning and expand my knowledge in both subjects. Secondly thanks so much for your feedback, I have already started working on Part 2 in which I hope we can start to refactor the DFA I have defined. I have had a few ideas around the use of enums but had not considered the interface example and going forwards is something I will try and implement. Feel free to add your comment to the post to continue the discussion there, but in any case thanks for reading. I hope you enjoyed it
I think after pool there's an extra block that shouldn't be there. In Kotlin, you put the parameters inside the block.
Did you write any medium blogs in this topics by any chance so I can read in depth?
No but if you google it, you will find a 1998 article by me on finite state machines: https://pdfs.semanticscholar.org/c27a/415f607ff75e52ec691173550af9289cd68a.pdf Cool stuff; was something that came out of my master thesis work. Enjoy :-)
Better yet, represent the state machine as a single [sealed class](https://kotlinlang.org/docs/reference/sealed-classes.html) with each state being a subclass. Sealed classes are like enums in that you can use `when` and have the compiler enforce all cases are handled, with the added advantage that each subclass can contain arbitrarily different data. (For those who are familiar with functional programming, sealed classes are similar to sum types.)
Sealed classes are better though. You get the same property that the compiler can enforce that `when` clauses handle all subclasses without `else`, with the added benefit that each state can contain arbitrarily different data. 
I do Python for a living, where everything is dynamic and mutable-by-default. When working with deep nested objects and complex logic, the downsides of mutability become far far worse. It's going to be much harder to understand complex logic when you have to take into account that everything is stateful.
This is really helpful, I will check coroutines in the meantime. Thanks.
&gt; https://pdfs.semanticscholar.org/c27a/415f607ff75e52ec691173550af9289cd68a.pdf Thanks for sharing, that looks really interesting! 
You sort of can if you're willing to tolerate some boilerplate. Here's an example: sealed class Node { abstract val name: String abstract val generation: Int fun increaseGeneration(): Node = NodeImpl(name, generation + 1) abstract operator fun component1(): String abstract operator fun component2(): Int private data class NodeImpl( override val name: String, override val generation: Int) : Node() companion object { fun create(name: String): Node = NodeImpl(name, 0) } } fun main() { println(Node.create("Baz")) println(Node.create("Foo").hashCode() == Node.create("Foo").hashCode()) println(Node.create("Foo") == Node.create("Foo")) val (name, generation) = Node.create("Bar").increaseGeneration().increaseGeneration() println("$name - $generation") } The `Node` class *looks* like a data class with two properties. It even defines the `component1` and `component2`. But it has no `copy` method and can't be directly instantiated. It also can't be subclassed (at least not in Kotlin code). But there *is* one subclass that *is* a data class. So `NodeImpl` provides implementations of `toString`, `hashCode`, `equals`, and `componentN`. It even provides implementations of `copy` and has an accessible constructor. *But*, the whole `NodeImpl` class is private to `Node`, so nobody else can invoke its constructor or its `copy` method. Is this worth it over using a regular class and implementing `equals`, `hashCode`, `toString`, and maybe `componentN` yourself? Eh, maybe not. It would certainly be better if I could opt out of the "automatic" methods and constructors that would be generated for you, like you can do in C++. Or heck, if I make my data class's constructor private, just mark the generated `copy` method private. Or give me the ability to control its accessibility.
Cool! I am impressed by the fact that this is a published paper with a clear problem statement and a clear solution. Something that is very applicable, not something too abstract or theoretical
In that case, the Node class isn't really a data class, and if you define component1 and so on manually anyway, there isn't much reason to have the private inner data class at all. It might make sense for the generation of toString, equals and hashCode, but the IDE can do that anyway and you sometimes want to tweak these implementations, anyway.
Data classes are attractive because you can use them as elements in a `HashSet` or keys in a `HashMap` without thinking about it; they just work. However, if you make your data classes mutable, then you have to start stepping carefully around hash-based data structures. Consider this: data class Node(var name: String) fun main() { val n1 = Node("Foo") val n2 = Node("Bar") val s = setOf(n1, n2) println("n1 in set: ${n1 in s}") println("n2 in set: ${n2 in s}") println() n1.name = "XXX" println("n1 in set: ${n1 in s}") println("n2 in set: ${n2 in s}") s.forEachIndexed { idx, n -&gt; if (n == n1) { println("$n found at index $idx") } } } ==== n1 in set: true n2 in set: true n1 in set: false n2 in set: true Node(name=XXX) found at index 0 We create an immutable set from two nodes. Both nodes are clearly in the set. Then we change one of the nodes by modifying its `name` property. Now that item no longer appears to be in the set. But if we iterate the set, we find that it's still there. It's both in the set and not in the set, depending on how you look for it. It's a ghost. This isn't necessarily wrong, and some Java standard library types work the same way. But it's definitely a potential gotcha. --- What are data classes *really*? Why do they exist. Especially in Java and similar languages, you can generally split the set of all classes into two categories: 1. Classes that represent values 2. Classes that represent entities (not in the database sense, but in a more general sense) Classes that represent values include things like `java.lang.Integer` and `java.lang.String`. Values are things that have no sense of identity. If I concatenate "foo" and "bar", I get the string "foobar". Similarly, if I concatenate "f" and "oobar", I again get the string "foobar". Is one of those "foobar" strings distinguishable from the other? They have the same length, and the characters in each slot are identical. For all intents and purposes, these strings are equivalent, even though they might exist as different objects. I should be able to substitute one object for the other without any apparent change to the correctness of my program. Classes that behave this way override `equals` (and therefore `hashCode`) to allow them to work in e.g. hash-based collections. Classes that represent entities include things like `java.lang.Thread` and `java.lang.StringBuilder`. Entities are things with identity. When I use the `append` method, it *really matters* which `StringBuilder` instance I invoke it on. One `StringBuilder` instance is *not* substitutable for another. These sorts of classes typically do *not* implement `equals` and `hashCode` - if the contents change in any way, then the object's hash code would likely need to change, and that is dangerous in the context of hash-based collections (as demonstrated above). As you might have guessed, there's a relationship between the "value/entity" split and the "immutable/mutable" distinction. Most classes that represent values are immutable, because as soon as you introduce mutability, you're usually dragging along identity. A `String` can be used as a value because it's immutable. A `StringBuilder` is mutable, so it doesn't make sense to consider it a value. Some Java classes fall between those two categories. `ArrayList`, for example, *does* provide its own implementation of `equals` and `hashCode`, and *does* have the problem that was demonstrated above. It's a class where identity matters (since it's mutable), yet can also be used as a value. This can be efficient: you can e.g. build a list one element at a time, then insert the resulting list into a HashSet of HashMap. That works perfectly well as long as that list is *never modified* after it's been added to *any* such collection. --- That's essentially the problem with mutable value-like classes. You can only safely mutate their instances if you can guarantee that they're not currently kept in any hash-based collection, and that's *really hard to prove* in the general case. Unless you have perfect knowledge of the implementation of *all* the code in your system (including third-party code), the only time that it's safe to do this is while the instance is "contained" in some way (e.g. only referenced as a local variable in a function, or kept strictly in a private field of some class and with no getter to access it directly). Once the instance is shared with the larger system, you can no longer make any guarantees. --- TL;DR: mutable data classes are suspect. You rarely need the mix of value semantics and identity. If you need mutability, you probably *don't* want to be overriding `equals` or `hashCode`. So if you want mutability, you *probably* just want a regular class. There *may* be edge cases where you need to mix those two concepts, but they should be really rare. 
`Node` itself isn't a data class, but because `Node` is sealed, all instances of `Node` (by which I mean all instances of subclasses of `Node`) *will* be instances of some data class. From the outside, you can use `Node` as if it was a restricted data class. You can pattern match on it. It has sensible `equals` and `hashCode` implementations. But you can't directly construct instances, and you can't call the `copy` method. Like I said, it might not be worth the hassle. It's probably not worth the hassle. But if you *really* wanted a data class without a public constructor or public `copy` method (which sort of means that the thing you want isn't *really* a data class after all), then this is probably the closest you can get. 
Basically true, I was converting those tests from Scala and probably missed that. But this was just an example.
oh :D I guess I should play a little with the new components haha
I find Kotlin coroutines \*slightly\* more complex than using Spring Reactive libraries, and the Spring Reactive stack is applied across many domains, not just Web. The coroutine context takes a little more digging to get the best performance. I spent some time doing performance comparisons between Ktor HttpClient and Spring Reactive WebClient, and they were more or less identical. Ktor itself is an extremely nice implementation of an HTTP server, but if you are set on the Spring path, look into the ever growing support of Kotlin in the Spring libraries. &amp;#x200B; I myself just started with Kotlin in the last 6 months, but I have been a Java programmer since ... Java became available ( slightly before that, actually ). Kotlin is my favorite language now. ( I have coded in about 20 since 1983 ) &amp;#x200B; I'll be putting some stuff up on GitHub soon, as soon as I figure out something worth publishing 
For those wondering what a few useful applications of DFAs like this are I always go back to embedded gpio pins (on-off states with transitions based on whether other pins are set or not) and state space explorations (useful in simple AI) Like given some coordinates and a move action where do you end up? 
Just to answer one of your questions, can you use platform specific code? Yes. The way I understand it, is in your common code, you use the keyword expected on your function, and this works like an abstract function. You will then have platform specific code, which you have to provide the same method with the actual keyword, and then write your platform specific implementation in there. 
I have experience with Android/iOS/JVM combo using Kotlin Multiplatform. From this experience I can say: \- project setup to compile for both Android and iOS was painful, not that much information can be found on the web, but it's doable \- when you use classes from the 'kotlin-stdlib' then mostly you should be fine, problems may start to arise when you want to use some other dependencies \- when you look for new dependencies be sure to investigate that all of them have platform implementations you are aiming for, it is not granted that any given dependency is available everywhere \- be thorough and investigate even the source code as some APIs might not be implemented even when dependency exists for given platform (I had examples where part of the class had its interfaces implemented and part was throwing unimplemented exceptions) \- code generated on iOS looked pretty nice, although I had to spend some time to access some of the data (for example byte arrays in my case) on the iOS side as APIs that use byte arrays of course differ and I had to manually translate from one array type to the other &amp;#x200B; All in all it has great benefits when you have a lot of business logic that you need to port to some other OS. If not for the longish setup and issues I had with dependencies it saves a lot of time in the end. &amp;#x200B; Hope this helps.
I'd like to do an android / iOS combo. I've currently got like 90% of an android app written in kotlin. I'm guessing this would be hideous to try and migrate? 
This establishes that too much mutability and dynamism is bad - not that any amount of it is bad. Where Kotlin is concerned, restrained use of mutability is a better approach than both "never mutate anything" and "mutate everything all the time."
Level of pain you might experience depends on how your code is organised. I had a separate Android module just for the business logic and it seemingly used only Kotlin standard library. The surprise was that in one of the implementation parts I was using \`java.nio.ByteBuffer\` that is, as package name states, not Kotlin/Android. So if you have all you want to port organised in some separate module then you are half way through on your way to multiplatform. So before going any further I guess it would be good to see which exact part of the code you would like to have as a separate module, go through that module and see what kind of imports are you using as Android is not only Android after all, do some research if there are apis to be replaced and then make an educated guess.
Yeah it's going to be horrific. I have mostly separated my logic out from my presentation. (I could definitely improve on this). A lot of my logic has my android context passed along so I can do database queries and such though so I think I'd have a mammoth task. I'm also not using the standard lib for everything. I guess slowly organising it better gives the project time to mature lol
If you're looking for a multiplatform test library, Kluent supports all platforms and has a kotlin-common lib
I would bold **painful**. I'm not very experienced in Gradle configuration, since I born as Android developer and Android Studio makes it very easy, it's been very painful for me, spent hours to configure SqlDelight, then other hours for configure Klock ( had to fork it ) then I gave up 2 days ago, when hat to configure Coroutines. That was a personal app, actually I stared working on a something easier, a multiplatform library that only need Coroutines, Serialization and Ktor. I'll handle that other project later, when Coroutines will support Gradle Metadata. 
The implementation was graciously provided by two community members. If you're interested in contributing, please head on over to https://github.com/tipsy/javalin
Thanks for your detailed answer, when you talk about "dependencies" do you mean libraries especially designed for Kotlin Multiplatform? Because my plan is to use the expected / actual keywords with wrapper for every platforms third party libraries. This is mainly because of the crypto algorithms we need to use. Implementing them ourselves would be a security flaw, so we need to use the best possible third party library for the given platform. Would it be possible, to define a common crypto interface with "expected" and then use third party libraries for every platform in the "actual" implementation? How do i manage third party libraries for other platforms or languages? Is this also possible with gradle?
Thanks for your answer, my problem is: can i use third party libraries in the platforms specific "actual" implementation? I need this because of the crypto algorithms, that i can't write myself. And how do i manage those third party libraries for other platforms.
Yes I believe you can use third party libraries. As for other platforms, you'd have to find a different library that does the same thing for that platform 
Nice clean code, but depression is no joke, https://suicidepreventionlifeline.org/
* `Human` constructor arguments are never assigned or used * a `Human`is only able to love everyone or not love anyone, which is probably not your intention * `doYouLoveMe`should accept the person to love * `doYouLoveMe`shouldn't cause any side effects, it should return a binary result or a ranged value expressing love, if you intended for the method to cause side effects you should consider renaming the method to something like `expressLoveTo(me: Human)` * `Depression` should not have friends, depression is a mental state of a `Human`, which should be the object to have friends. * a `Human` should not have nullable friends, consider changing the array to a list. * a `Human` should be able to gain and lose friends, consider changing friends to a mutable list. * the behaviour of `MyLife`should be encapsulated into `Human`, a `Human` has a `Life` or `"Life-Behaviour"` * consider using a `sealed` class or ranged values to represent the `mood`, matching on strings is bound to give you errors someday * `beSad`will throw an exception when the `Human` has no friends * `Mylife` ignores the result of `doYouLoveMe` which is probably not intended * `beSad` will guarantee a stack overflow by indirect recursion, consider allowing an escape out of eternal depression
&gt; Would it be possible, to define a common crypto interface with "expected" and then use third party libraries for every platform in the "actual" implementation? Yes and no. For Android it's easy, for iOS you need bindings for a third party (non-platform) library, and if it's a Swift library it needs to export to ObjC for you to be able to use it from there. Much easier is to ditch expect/actual and implement and interface from both Swift (or Objc) and the Android side, and inject this.
I get it, but it was not about the code on itself, it was a joke
But you're not using the light theme.
Just use [mine](https://github.com/michaelbull/kotlin-result). 
Maybe a dumb question but... why not just use Optional&lt;T&gt; and exception mappers?
hey a dumb question maybe, but, how does javelin compare to like http4k / tinder-scarlet ?? 
Because then you're forced to model all of your errors as exceptions. Exceptions should be used for exceptional circumstances, i.e. when a program error stops it from actually running in the way it was designed. Business logic errors should be handled by the application itself, and railway-oriented design allows you to cleanly define the "happy-path" of execution that a client request should pass through, returning early if an error occurs along the way.
Or even the one in the standard library https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-result/index.html
The Result type in the stdlib was explicitly listed as not for general use, instead tailored specifically for use within kotlin-coroutines. &gt;The class that encapsulates either a successful or a failed result of Kotlin function, which was released in preview builds of Kotlin 1.3 under the working name of SuccessOrFailure, after review and community feedback had been renamed to Result. This class is primarily used in coroutines as an argument type of Continuation.resumeWith function. There is a number of design leads for potential future extensions of error handing in Kotlin that would require us to redesign semantics of the code that uses this Result class as a return type, so, to avoid breaking such code in the future, Kotlin 1.3 compiler produces an error on such declarations with a few exceptions of standard library functions that are specifically designed to operate on Result type. See KEEP-127 for details. - https://blog.jetbrains.com/kotlin/2018/09/kotlin-1-3-rc-is-here-migrate-your-coroutines/
That's Try, not Either, though. 
Javalin is a web server library, it will help you with web server things, like creating REST/WebSocket endpoints and serving static files. Scarlet is a Websocket client, so there is 0 overlap in functionality. Javalin can *serve* WebSocket endpoints, Scarlet can *consume* WebSocket endpoints. Http4k is a "http toolkit", they do a bit of everything. They provide wrappers for multiple different servers, and multiple different clients. They also provide wrapped versions of templating and JSON libraries. The idea is that this should make things easier for end users. Javalin on the other hand tries to do as little as possible. It provides a nice abstraction layer on top of Jetty for setting up the server, but it's up to users to pick their own libraries for other tasks. JSON / templating libraries can be plugged in easily by implementing interfaces (typically by using lambdas). Javalin doesn't care what HTTP client you use, just find one you like and follow their docs.
What is the difference between your result monad and [Either in Λrrow](https://arrow-kt.io/docs/arrow/core/either/](https://arrow-kt.io/docs/arrow/core/either/) (AFAIK Λrrow is the most widely used FP library for Kotlin)?
http4k is partially based on the Twitter "your server as a function" paper, which was originally implemented in Scala as Finagle. SaaF defines that all distributed systems can be composed of a combination of Service functions (that handle the actual traffic) and Filter functions (middleware which decorate services with orthoganal behaviours such as monitoring and security). It also makes everything a breeze to test (which is one the most important things IMHO) because apps are simply functions and hence everything can be done entirely in-memory with zero test infrastructure required. Mounting an app into a running backend is mostly irrelevant to the logic expressed in the endpoints. As @javalin_io has pointed out, http4k provides a bunch of common abstractions with some plug-in modules for things like HTTP servers, clients, JSON and templating, but in no way does it force your hand in any of this - the ecosystem modules just happen to play very nicely together and this consistency helps to bring down the cognitive load of putting together apps using http4k. Everything is implemented in the most lightweight way possible - the core library has no dependencies apart from Kotlin and weighs in at approx 800k. One specific thing to highlight here is that by using the http4k Client wrappers, you'll get to take advantage of flexibility that the symmetrical HttpHandler interface that both Server and Client services expose. This has massive implications in testing because you can literally swap out an HTTP client for another http4k service - so you can either test several services at once entirely in-memory by replacing clients with services, or turn a unit test into an system test by simply switching out the app for an HTTP client. Or should you decide to ditch http4k entirely in the future then your tests aren't wasted because you can just use the same technique and simply reuse them for the new implementation. 
What's the benefit over creating the usage specific sealed classes? I think the usage specific ones are more readable (no .right or left) and allows you to add more than two results if needed.
that level of composability is bordernline insane to me..
ah thank you for the explanation, it helps me a lot. since I dont need any server functionality, it's been a bit of headache to find what I need. I looked into scarlet, but I had trouble getting it to work. then I found javalin, but wasn't sure if it could do what I want. apparently not, since I need consuming (like scarlet). right now I'm using http4k and I'm really satisfied with how it works so far. thx a bunch
thanks a lot for the explanation
Composition. You shouldn't call `right` or `left` that much. Either short-circuits on the first instance of left that is encountered. Also it should be right-biased. So in the most common use-case, if all your functions return an `Either&lt;Throwable, ?&gt;` you can chain their calls with `flatMap` like this: val result = foo(x).flatMap(y -&gt; bar(y).flatMap(z -&gt; baz(z))) when (result) { is Right -&gt; ... is Left -&gt; ... } &amp;#x200B;
I don't think theirs ships independently, so you will end up including their whole core library. I don't think theirs has the amount of utility functions mine has (e.g. operating on iterables). Haven't used it so this was after a brief inspection.
ah okay well Optional&lt;T&gt; is part of java.util, I'm fairly sure that works fine
Looks like I replied to the wrong comment, I did reply to yours already though.
I don't think theirs ships independently, so you will end up including their whole core library. I don't think theirs has the amount of utility functions mine has (e.g. operating on iterables). Haven't used it so this was after a brief inspection.
Nice overview, in particular, for the Spring users out there. It’s stuff like this that will help adoption, just because running into issues like needing open classes for Spring Boot, etc, will make some people not familiar with the ecosystem skittish. _Rubs hands_ ... maybe it’s time to impress my coworkers with Kotlin mwa ha ha 
No, you could just read a basics book. 
Try official jetbrains course on coursera (you don't need to pay if you don't need cert) https://www.coursera.org/learn/kotlin-for-java-developers
Kotlin can be learned on its own. Experience with Java will help you build a Kotlin application (Android development for example). Experience with Swift helps with Kotlin syntax.
I honestly think it would be easier to learn Kotlin than learning Java. I think part of the issue here is that when you teach Java you tend to teach the fundamentals of programming without. Like you explain what variables, loops, classes, and methods are, and then you build up an understanding of it. A lot of Kotlin resources don't go super in depth into these concepts because they kind of assume you know them. Like they don't explain the basics of object oriented programming. Trying to look for a resource, I might look into this book. Hands-On Object-Oriented Programming with Kotlin [https://books.google.com/books?id=buh1DwAAQBAJ&amp;pg=PA7&amp;lpg=PA7&amp;dq=hands-on+object-oriented+programming+with+kotlin&amp;source=bl&amp;ots=IRn8ivmpZk&amp;sig=ACfU3U3\_6L\_jS8K2W4iAhiq6Kdpjv1FEIA&amp;hl=en&amp;sa=X&amp;ved=2ahUKEwji1srrgPvfAhUQc98KHXAnBvs4ChDoATABegQIChAB#v=onepage&amp;q=hands-on%20object-oriented%20programming%20with%20kotlin&amp;f=false](https://books.google.com/books?id=buh1DwAAQBAJ&amp;pg=PA7&amp;lpg=PA7&amp;dq=hands-on+object-oriented+programming+with+kotlin&amp;source=bl&amp;ots=IRn8ivmpZk&amp;sig=ACfU3U3_6L_jS8K2W4iAhiq6Kdpjv1FEIA&amp;hl=en&amp;sa=X&amp;ved=2ahUKEwji1srrgPvfAhUQc98KHXAnBvs4ChDoATABegQIChAB#v=onepage&amp;q=hands-on%20object-oriented%20programming%20with%20kotlin&amp;f=false) I personally haven't read it, but I'm reading another book they have out and it is really good and skimming through the preview for this book it seems to cover everything really in depth and explains it out. Honestly, I'd read what they have for a preview and see if it clicks with you. I think a book is honestly the best option because with OOP and programming concepts it takes time to sink in.
why isn't this stuff built into the stdlib? its really frustrating not to have this type built in along with compose and useful things like that. I tried using `Result` but won't let you use it as a return type and I don't feel like bringing in arrow or some random project. In the end I just end up throwing exceptions ...
I have learnt Kotlin having no previous Java experience. You can learn the basics relatively easily. However when you get into more intermediate level stuff you will definitely be forced to understand Java to some level, since examples and extensions are generally still written in Java. I have been programming for over 20 years so this isn't really a problem for me (with experience you can review code in most languages and figure out what is going on), but I can see it being an issue for people new to programming. I'm not sure I would suggest Kotlin to a complete novice either. There are some complex concepts that you'll be forced to encounter fairly early on. I think it could make a great first serious language, but it'd be easier to understand some programming fundamentals first. 
I have been teaching it to highschool students on our robotics team. Previous programming experience definitely helps, but it's totally possible as a first language. There are a lot less quirks. Java was developed over years, adding features as they went. This means that it has most of the features, but they may be different depending on what kind of object you are using. For example, try streaming an array. Kotlin smoothes over a lot of these differences. 
Arrow ship as modules for Android's sake. If you bring the smallest core you get Either, Option, Try, Eval, Id, Tuple1-22, Function0, Function1, and FunctionK. Now, on top of that we ship core-extensions, and that's where all of the additional operators defined as extension functions live. For example, for Either you get all the helpers defined in [these interfaces](https://arrow-kt.io/docs/arrow/core/either/#supported-type-classes) and the ones that work on Sequences are [here](https://arrow-kt.io/docs/apidocs/arrow-extras-extensions/arrow.data.extensions.sequencek.foldable/arrow.-kind/index.html) and [here](https://arrow-kt.io/docs/apidocs/arrow-extras-extensions/arrow.data.extensions.sequence.traverse/kotlin.sequences.-sequence/index.html).
You don't need open classes for spring boot if you use the Kotlin spring plugin which is included with the Kotlin allopen plugin!
https://github.com/Kotlin/KEEP/blob/master/proposals/stdlib/result.md &gt;The rationale behind these limitations is that future versions of Kotlin may expand and/or change semantics of functions that return Result type and null-safety operators may change their semantics when used on values of Result type. In order to avoid breaking existing code in the future releases of Kotlin and leave door open for those changes, the corresponding uses produce an error now. Exceptions to this rule are made for carefully-reviewed declarations in the standard library that are part of the Result type API itself. &gt;See Future advancements for details.
noted but puttin it in with this constraint is just a big tease. its like dangling candy in front of a kid then taking it away and mocking me in the process.
I think Atomic Kotlin is the official Kotlin learning resource for beginners. https://www.atomickotlin.com/atomickotlin/ As others have said, in theory Kotlin should be easier to learn as a first language than Java. It's just a matter of if there are good learning sources out there. I've never read Atomic Kotlin but I've heard good things.
We just started using micronaut and it seems pretty decent. Also, there are workarounds for open class issue.
The more I read the proposals the more I think Arrow is definitely the way to go if you want to write functional code in kotlin.
newSingleThreadContext and newFixedThreadPoolContext are now deprecated FYI. The docs suggest using "Executors.newSingleThreadExecutor().asCoroutineDispatcher()" or "Executors.newFixedThreadPool().asCoroutineDispatcher()" instead.
I've published a small article about migrating to Kotlin. If you're using Lombok, but you're interested in Kotlin, this might be a helpful and low risk change.
Really helpful - thanks!
Checked some of the assignments, i dont agree with all solutions, but its a nice start. Also the difficulty was quite low, perhaps if it were grouped by difficulty would be good, adding some more difficult assignments as well. For me a better way to gain these general problem solving skills is to do some euler challenges (projecteuler.net) in a programming language of choice (kotlin for me)
 // file: Test.kt class Test { // ... } fun someFunc() { // ... } The class name `Test` is already taken, so what should the class created to contain `someFunc` be called?
[CInterop support](https://kotlinlang.org/docs/reference/building-mpp-with-gradle.html#cinterop-support)
This anotation is only needed if the file contains top-level variables or functions. Here's another alternative: Convert the rest of your Java code to Kotlin and you won't need that anotation anymore 😁
Disscussion at r/Java [https://www.reddit.com/r/java/comments/ai9gqt/migrating\_from\_lombok\_to\_kotlin/](https://www.reddit.com/r/java/comments/ai9gqt/migrating_from_lombok_to_kotlin/)
And inb4 inevitable "what if i don't have a class with same name in it" - you will add it, at one point or another. And then you will have to rename the class that holds loose functions. Only your Java code already references the old name that would now be taken by that new class...
If you often reference the "loose" vals and functions from Java - wouldn't it just be better to put them in objects? Then they wouldn't have the suffix
Data classes are definitely a good place to start. That's exactly where I started introducing Kotlin to my company's code base and it worked out well. It starts getting trickier when you go beyond that, though. The Kotlin compiler (or at least, the built-in one in IntelliJ) doesn't know what to do with Lombok annotations in Java code. So if you think, "Hey, these first few data classes went pretty smoothly. I'll try migrating one of the business logic classes next," and that class calls getters/setters on Lombok-annotated Java classes, you'll quickly find yourself facing "method not found: getWhatever" errors. None of the solutions is wonderful. You can move all the Java code to a separate project so it gets compiled separately (and Kotlin just consumes the class files with no way to tell the getters were Lombok-generated). But that doesn't work if you have two-way dependencies between Java and Lombok, which you will if you're migrating a complex code base gradually. You can Delombok all the Java classes that are referenced by Kotlin code. But then you're back to maintaining bulky verbose Java code. You can treat Kotlin as a kind of code virus, and when a Java+Lombok class gets referenced from Kotlin code and the Kotlin code won't compile, fix it by porting the referenced class to Kotlin too. Sometimes that's pretty painless, sometimes it turns "convert this one class to Kotlin" into a tedious exercise in transitive dependency walking. Ideally, the Kotlin compiler would learn how to deal with Java annotation processors better and Lombok would just work, no fuss required. But Lombok uses enough underhanded tricks to do what it does (calling undocumented APIs, etc.) that I'm not holding out tons of hope.
Not sure how I missed that.. Thanks!
It's quite a young project, so it will mature over time, with more tasks, better solutions as well as increased task difficulty. I would be grateful if you could share more detailed feedback on solutions. &amp;#x200B; BTW Thanks for a tip about [projecteuler.net](https://projecteuler.net)
This will never happen because it's a change that breaks binary compatibility.
Still need it for the Main Class in JARs. Still stinks to have to strip the Kt suffix there as well
Once per project shouldn't be that big of a deal
Don't advertise here.
Having to remember to do this, for every project, in an ecosystem where JVM packages are expected to interop, is bloody annoying.
You can add a secondary constructor. Like: class DBUser(val id: Int, val name: String, ...) { constructor(loginUser: LoginUser) : base(loginUser.id, loginUser.name, ...) } But why do you even have two User classes, if they share the same properties. You probably should be going for a different software design. \- Make a single User class which only holds data and make other classes implement the logic. \- Try using more composition \- etc. &amp;#x200B; If you have duplicate code, something is probably not ideal.
You have two options in Kotlin. 1. Using the *copy* method on data classes. You can create copies of the User object with some fields removed if you don't want to expose some fields to the client. See [copying data classes](https://kotlinlang.org/docs/reference/data-classes.html#copying). 2. Using [ModelMapper](http://modelmapper.org). This is a more "automagical" way of passing property values around classes. You save a lot of code if both classes properties are named equally, since it can infer the mapping by itself.
Seralise to eg json then deserialise (jk). Just make a secondary constructor as u/BigJhonny suggests.
I currently have a single class which is the return from the login response AND it's the database model, and it's all kinds of terrible. I understand duplicate code can be a smell, but a single class is definitely not the right abstraction here. From what I've heard from other Android developers as well, they typically have a different object depending if it's a db object (DAO or similar) and a network object (DTO or similar).
Be careful with secondary constructors - you might be adding some questionable dependencies to your infrastructure. Should your DBUser entity know anything about the web login request/response process? I'd assume not - by adding that sort of constructor, you're going to take that dependency with you when ever you need a DBUser. If you're going down the path of owning the code to construct instances yourself, take a look at an extension function instead. Something like: fun LoginResponse.asDBUser(): DBUser = DBUser( id = this.id, username = this.username ) fun main() { val loginResponse = LoginResponse(id = 1, username = "user@example.com") println(loginResponse.asDBUser()) // Prints: DBUser(id=1, username=user@example.com) } But that doesn't really solve your question of wanting it to be generic so you don't need to constantly keep that code in sync. As others have said, tools like [MapStruct](http://mapstruct.org/) or [ModelMapper](http://modelmapper.org/) do this with minimal effort. If you don't want to add a 3rd party library for it, it's not too hard to piece together for yourself: inline fun &lt;reified T : Any&gt; Any.into(): T { val constructor = T::class.primaryConstructor!! val parameters = constructor .parameters .map { it.name!! } .map { name -&gt; this::class .memberProperties .first { it.name == name } } .map { it.getter } .map { it.call(this) } return constructor.call(*parameters.toTypedArray()) } fun main() { val loginResponse = LoginResponse(id = 1, username = "user@example.com") println(loginResponse.into&lt;DBUser&gt;()) // Prints: DBUser(id=1, username=user@example.com) } There are a bunch of assumptions in there (only uses the target's primary constructor, blows up if there are missing properties, properties have the correct types, etc etc) but you get the idea.
If you use data classes you get a copy method to do exactly this. You can pass values in for anything you might want to change, or pass nothing to get a copy with the same values.
Using Arrow there is `arrow-generic` and the annotation `@product`. This annotation allows you to transform a data class into a TupleN, or a heterogeneous list HList and viceversa. If both classes have the same field types defined in the same order, you should be able to easily do `loginresponse.tupled().toUser()`
Copy returns a new instance of the same data class. This would only work in one direction and only if DBUser and LoginUser have an inheritance relationship. This tight coupling doesn’t seem like what OP wants.
Check out my similar post here with one possible solution: https://www.reddit.com/r/Kotlin/comments/af68ij/using_dynamic_proxy_to_implement_interface_to/
&gt; Seralise to eg json then deserialise (jk) What a terrible advice! Use Parcelable, it's much faster! (jk)
Don't need the types at all, they're inferred
yep I'm aware of that. Don't want to start a long conversation about that here but let's just say I'm not sold on the concept except for very complex types.
Well, do you want your code to be properly Kotlinized, or to correspond to your personal idea of how Kotlin should be written? Properly Kotlinized code does not declare types for String and Long constants.
valid point. I'll change to use inferred type by default
Thanks for this link. The authors seem to have a [free course on stepik.org](https://stepik.org/course/15001/) that covers the same content.
 var converted = "$someInt"
https://blog.jetbrains.com/kotlin/2019/01/kotlin-1-3-20-released
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [Kotlin 1.3.20 released \[x-post from r\/kotlin\]](https://www.reddit.com/r/programming/comments/aj428l/kotlin_1320_released_xpost_from_rkotlin/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I was so excited to see that the kapt tools.jar bug which had blocked Gradle builds with Java 11 was fixed, but of course after the upgrade, kapt started thowing ZIP-related exceptions. It's obvious that nobody on the Kotlin team even tries to do something as basic as building a Kotlin project with Gradle on Java 11.
toString is fine for kotlin! 
You need to pass a `PaymentStatus` instance to the function, not an `int`. An enum is a type, not an alias. You can build it from a string with `valueOf` Or you can add a function to return it based on the `int` value it's using, but you cannot compare a `PaymentStatus` with an `int`.
Also you can use `enum.name` and it will return you the string like `"PAID"` in your example.
Your issue appears to be that an `int` is not a `PaymentStatus`. They're not the same type, so you can't cast one to the other. If what you want is completeness coverage, then I'd recommend writing some sort of static `lookup` method. For instance: enum class PaymentStatus(val value: Int) { PAID(1), UNPAID(2); companion object { fun lookup(x: Int): PaymentStatus? = PatternField.values().singleOrNull { it.value == x } } } fun f(x: Int) { val foo = when(PaymentStatus.lookup(x) ?: throw IllegalArgumentException("Invalid x $x")) { PaymentStatus.PAID -&gt; "PAID" PaymentStatus.UNPAID -&gt; "UNPAID" } }
Thanks much, I went with a similar approach, The main reason for the problem was that I couldn’t change the signature from int to the enum, as that was an override of an android base class method in the real example. If I changed it then it woud no longer be an override which was a problem. 
There is no simple interop for top-level functions since they do not exist on the JVM. As such, a consistent convention is used and is fully predictable. Especially when most IDEs provide something similar to `Right-click &gt; Copy Reference` so you don't have to remember. Do you have proposals for alternatives on how to handle this consistently in every scenario?
What would be the benefit of this over [gradle-git-properties](https://github.com/n0mer/gradle-git-properties) which is fairly customizable and outputs a `git.properties` file to the classpath that can be easily loaded?
ｃｏｎｃｉｓｅ
What's your point? 
Is every Kotlin program supposed to hand off to Java to deal with primitives? I thought Kotlin was supposed to be a full-blown language.
No. Maybe you are using an older version of IntelliJ, depending on your version the toInt or toLong calls won't be used anymore. &amp;#x200B; But anyway... maybe you shouldn't just always trust the auto conversion of Java to Kotlin.
I don't trust it because it mangled my code and I had to manually add the toLong and toInt to get it to compile and import the bitwise operators
Why would you use `singleOrNull` instead of `find`?
first I've heard of that project! I did spend a bit of time searching too. The reason it was missed might have been because I was looking for a plugin which generate actual code and not a serialized file. I've been told that a file is better if you dynamically load class files due to JVM caching. Not an issue in any of my use cases. git-properties properties prints out easily more git info, gversion is focused on just info for the current version and includes more non-git info by default, like the build time and maven. Looks like you could write additional code to make git-properties do something similar.
You can't have a positional parameter after a named parameter in any call - constructor or not. 
Ih, I understand now, thanks. 
Fixed: @Throws(DecodeException::class) internal fun _getLong(buffer: ByteArray, i: Int, len: Int): Long { var b : Byte var shiftAmount = 0 var `val` = 0L when (len) { 8 -&gt; { b = buffer[i+7]; `val` = if (b &lt; 0) b + 256L else b.toLong(); shiftAmount = Byte.SIZE_BITS b = buffer[i+6]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount); shiftAmount += Byte.SIZE_BITS b = buffer[i+5]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount); shiftAmount += Byte.SIZE_BITS b = buffer[i+4]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount); shiftAmount += Byte.SIZE_BITS b = buffer[i+3]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount); shiftAmount += Byte.SIZE_BITS b = buffer[i+2]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount); shiftAmount += Byte.SIZE_BITS b = buffer[i+1]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount); shiftAmount += Byte.SIZE_BITS b = buffer[i]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount) return `val` } 7 -&gt; { b = buffer[i+6]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount); shiftAmount += Byte.SIZE_BITS b = buffer[i+5]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount); shiftAmount += Byte.SIZE_BITS b = buffer[i+4]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount); shiftAmount += Byte.SIZE_BITS b = buffer[i+3]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount); shiftAmount += Byte.SIZE_BITS b = buffer[i+2]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount); shiftAmount += Byte.SIZE_BITS b = buffer[i+1]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount); shiftAmount += Byte.SIZE_BITS b = buffer[i]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount) return `val` } 6 -&gt; { b = buffer[i+5]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount); shiftAmount += Byte.SIZE_BITS b = buffer[i+4]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount); shiftAmount += Byte.SIZE_BITS b = buffer[i+3]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount); shiftAmount += Byte.SIZE_BITS b = buffer[i+2]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount); shiftAmount += Byte.SIZE_BITS b = buffer[i+1]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount); shiftAmount += Byte.SIZE_BITS b = buffer[i]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount) return `val` } 5 -&gt; { b = buffer[i+4]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount); shiftAmount += Byte.SIZE_BITS b = buffer[i+3]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount); shiftAmount += Byte.SIZE_BITS b = buffer[i+2]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount); shiftAmount += Byte.SIZE_BITS b = buffer[i+1]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount); shiftAmount += Byte.SIZE_BITS b = buffer[i]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount) return `val` } 4 -&gt; { b = buffer[i+3]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount); shiftAmount += Byte.SIZE_BITS b = buffer[i+2]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount); shiftAmount += Byte.SIZE_BITS b = buffer[i+1]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount); shiftAmount += Byte.SIZE_BITS b = buffer[i]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount) return `val` } 3 -&gt; { b = buffer[i+2]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount); shiftAmount += Byte.SIZE_BITS b = buffer[i+1]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount); shiftAmount += Byte.SIZE_BITS b = buffer[i]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount) return `val` } 2 -&gt; { b = buffer[i+1]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount); shiftAmount += Byte.SIZE_BITS b = buffer[i]; `val` = `val` or ((if (b &lt; 0) b + 256L else b.toLong()) shl shiftAmount) return `val` } 1 -&gt; { b = buffer[i]; `val` = `val` or (if (b &lt; 0) b + 256L else b.toLong()) return `val` } 0 -&gt; return `val` else -&gt; throw DecodeException(IllegalArgumentException("len is out of range: $len")) }
Just put everything in the file in an `object` instead if you want this behavior.
Stylistic choice I guess. `find` would work as well. 
They're arent equivalent though, and `find` is what you really want here. Look at their implementations: public inline fun &lt;T&gt; Array&lt;out T&gt;.find(predicate: (T) -&gt; Boolean): T? { return firstOrNull(predicate) } public inline fun &lt;T&gt; Array&lt;out T&gt;.firstOrNull(predicate: (T) -&gt; Boolean): T? { for (element in this) if (predicate(element)) return element return null } vs public inline fun &lt;T&gt; Array&lt;out T&gt;.singleOrNull(predicate: (T) -&gt; Boolean): T? { var single: T? = null var found = false for (element in this) { if (predicate(element)) { if (found) return null single = element found = true } } if (!found) return null return single } `singleOrNull` explicitly stops you returning a value that matches a predicate if more than one element in the array matches the predicate. The whole point of the `value` field in the enum posted above is that they are unique values, so you will never have the predicate match more than one element from the `values()` array - therefore `find` is much more appropriate here.
That's fair. 
Good to know. Just FYI that plugin is officially recommended for Spring Boot projects and is automatically picked up by the /info actuator. https://docs.spring.io/spring-boot/docs/current/reference/html/howto-build.html#howto-git-info
You don't really need Kotlin-specific resources for 90% of the stuff since you can copy/paste all Java code examples and IntelliJ will convert them to Kotlin for you!
Since 1.3, I think it was changed to be an extension on the global coroutine scope: `GlobalScope.async { ... }`. On the JVM, the old `async` function is deprecated but works, maybe on the JS target it isn't there at all.
Or you could just do something like this: fun _getLong(bytes: ByteArray) = ByteBuffer.allocate(Long.SIZE_BYTES).apply { if(bytes.size &gt; 8) { throw DecodeException(IllegalArgumentException("len is out of range: ${bytes.size}")) } put(bytes) flip() }.getLong() It could probably also be an extension property on byte buffer instead.
you are correct in your hypothesis, thanks \^\^
but when do we get IntStream interface method access with Gradle, Rooooooooman?
This is a great presentation. It's a presentation he also did at Kotlin Conf. It's absolutely worth watching.
You can skip to 10:40 if you already know about callbacks and futures.
You want to learn Java from a Kotlin book? I could be mistaken, but I don't believe there are such books/resources. If you do not want to "skip the Java parts,' you should just buy a Java book. This is the recommended advice for people jumping into Kotlin that do not know Java. If you're targeting Kotlin Native, then ignore everything I've said. If you're doing anything that slightly touches Java, you should have an appreciation and understanding of the platform you're working on. Learn Java. 
Gosh don't you hate having to watch a whole video? Here's a summary I wrote up: [https://www.youtube.com/watch?v=hb0hfHVWCS0](https://www.youtube.com/watch?v=hb0hfHVWCS0) ## How have we dealt with concurrency? fun requestToken(cb: (Token) -&gt; Unit) { ... } Callbacks. These are bad because it leads to callback hell (callbacks within callbacks) which quickly become very difficult to read or debug. fun requestToken(): Promise&lt;Token&gt; { ... } Futures/Promise/whatever you want to call it. They're good because they're composable. But bad because you still end up with callbacks, code structure is hidden behind operators like `thenCompose`, the operators are unnatural and vary between implementations, and overall remain hard to read. suspend fun requestToken(): Token { ... } In Kotlin we recommend coroutines to make concurrency easy and readable. The code ends up readable, linear, suspend points happen as they need to. You can use regular loops, compose higher-order functions if you want to, and return data normally. ## But how do coroutines really work? Under the hood, any `suspend` function is converted to have another parameter, `cont: Continuation&lt;T&gt;`. A `Continuation&lt;T&gt;` simply has a `CoroutineContext` and the ability to `resumeWith(result: Result&lt;T&gt;)`. ## Integrating oroutines with a library There's a zoo of mechanisms for concurrency out there: libraries like Retrofit have Call&lt;Post&gt;, different Java versions, etc. Let's bridge the gap between Retrofit and Kotlin suspend: 1. suspend fun &lt;T&gt; Call&lt;T&gt;.await(): T = suspendCoroutine { cont: Continuation&lt;T&gt; -&gt; 2. enqueue(object : Callback&lt;T&gt; { 3. override fun onResponse(call: Call&lt;T&gt;: response: Response&lt;T&gt;) { 4. if (response.isSuccessful) 5. cont.resume(response.body()!!) 6. else 7. cont.resumeWithException(ErrorResponse(response)) 8. } 9. override fun onFailure(call: Call&lt;T&gt;, t: Throwable) { 10. cont.resumeWithException(t) 11. } 12. }) 13. } Line 1: Define an extension function on Retrofit's `Call&lt;T&gt;`. Use `suspendCoroutine` (a non-suspending library function) to wrap it. It receives a `Continuation`. Line 2: Call `enqueue` to start the process and register a callback according to Retrofit's requirements. Line 5: When a successful response arrives, use `cont` to resume from the suspension point with the expected data. Line 7: Or, if the response fails, promote it to an exception and provide that to `cont`. ## Integrating with synchronous blocking code `suspend` functions have the superpower of being able to suspend on their (invisible) Continuation&lt;T&gt; instead of blocking. But can't just call a suspending functions from a non-suspending function. So how do you get from here to there? You can use `GlobalScope.launch { ... }` to launch a concurrent "process", using the background thread pool: 1. fun postItem(item: Item) { 2. GlobalScope.launch(Dispatchers.Main) { 3. val token = requestToken() 4. val post = createPost(token, item) 5. processPost(post) 6. } 7. } But how do you get back to the UI thread? Line 2 adds a dispatcher for code to run in the correct dispatcher (say the UI). How does `launch` do that? It's a non-suspending function (so you can call it from ordinary code) but it receives a suspending lambda so the lambda can call suspend functions, and it returns a Job which you can cancel on, if you need to. ## async and await: the classic approach C#/Dart/TypeScript etc uses `async` as a modifier and `await` is used to allow me to call other async code: async Task postItem(Item item) { var token = await requestToken() var post = await createPost(token, item) processPost() } `async` returns a Task or Future or something. Why did Kotlin do it differently? We think the classic method is confusing because you get concurrent behavior by default and have to explicitly ask for sequential behavior (with `await`). Concurrency is hard for developers so we think sequential behavior should be the default. But there's another reason. Let's compare C#: async Task&lt;Image&gt; loadImageAsync(String name) { ... } // Makes thing concurrent var promise1 = loadImageAsync(name1) var promise2 = loadImageAsync(name2) var image1 = await promise1; var image2 = await promise2; Or a similar approach in Kotlin: fun loadImageAsync(name: String): Deferred&lt;Image&gt; = GlobalScope.async { ... } val deferred1 = loadImageAsync(name1) val deferred2 = loadImageAsync(name2) val image1 = deferred1.await() val image2 = deferred2.await() But what if image1 load crashes? deferred1.await() will throw, and deferred2 will continue on forever with no reference and we leak a process. How to solve? **Avoid futures and Deferred**. Instead explicitly define your concurrency needs with "structured concurrency": suspend fun loadAndCombine(name1: String, name2: String): Image = coroutineScope { val deferred1 = async { loadImage(name1) } val deferred2 = async { loadImage(name2) } combineImages(deferred.await(), deferred2.await()) } If the a child scope dies/throws (e.g. `loadImage(name2)`), the parent is canceled along with other children of the parent. So there is nothing left behind. Remember, concurrency is *not* the same as parallelism. Whether something actually happens in parallel should be a low-level implementation detail to your design. You might have thousands of concurrent processes running in the same thread. Parallelism is optional. ## What about generate/yield in synchronous code? `sequence { ... }` is actually a coroutine builder with suspension restricted to the current thread. All you can do in it is `yield` values to the caller. val fibonacci = sequence { var cur = 1 var next = 1 while (true) { yield(cur) // Continuation point var tmp = cur + next cur = next next = tmp } } val iter = fibonacci.iterator() println(iter.next()) // runs up to `yield` println(iter.next()) // continues after `yield` until next `yield` ## What about shared state? Operations that mess with shared state are problematic. Ancient wisdom to avoid this: Communicating Sequential Processes. Instead of sharing state, communicate it. val fibonacci = GlobalScope.produce { // Async var cur = 1 var next = 1 while (true) { send(cur) // Communicate state sequentially val tmp = cur + next cur = next next = tmp } } fun main(...) = runBlocking { println(fibonacci.receive()) } The code above allows for asynchronous behavior within fibonacci but no need to share data directly. ## Library vs Language We tried to avoid adding a lot of keywords: `suspend` is the only one, with stdlib remaining very thin. `kotlinx-coroutines` is kept separate.
Why not do this? class Monster( var name: String = "" var monsterStrength: Int = 0 var monsterHealth: Int = 0 ){ // methods in here }
I recommend you to learn Java first. Not inside and out, but having a good notion of Java will give a good notion of Kotlin
Maybe they do test but aren't reproducing your exact issue. A bug report would be about 10000x as useful as your comment if your goal here is to see the bug fixed.
Awesome write up!
Thanks. I thought the most interesting part was how concurrency and parallelism can be separated and thought of as different concerns...before this presentation it never made sense to me how `GlobalScope.launch(Dispatchers.Main)` runs on the UI thread because I saw "launch" and immediately thought "parallelism".
Thanks!
I really hate to see the hate over Gson. By my tests Gson has been faster than Moshi, pretty much Gson is a mature library so, I haven't been getting null for vars that are non nullable, parsing already existing json seemed more easy and faster than with Gson, obviously there are some reasons why Moshi exists but I don't see a big reason to switch over to it, not that I have anything against Moshi, clearly the guys did a good job with Moshi but I'm sticking with Gson for now, nice article by the way.
Hi, thank you for the feedback. No hate for Gson though, not really. It's just that Moshi is equally good at this point and it adapted to Kotlin. As for the nullable issue, you won't see it during the deserialization but when you actually try to access those properties.
I'm using Kotlin with Gson, half a year and I'm not sure why you got that issue and how but i have been able to access non nullable fields too without null pointer, maybe some hiccup on your end ?
Here's a nice article explaining the issue and Kotlin nullability in general. https://www.bignerdranch.com/blog/when-nullability-lies-a-cautionary-tale/?__s=jbzjv5et7qxje5onoozh
As i understood moshi is no different and suffering the same consequence so there's this practice that i always have, empty constructor all the way, saved me lot of pain. 
Not just Gson, but Jackson gets a similar rap these days even it deserves none of it. Especially with Jackson's Kotlin module. 
When I tried it the problem was Gson wasn't throwing an exception when parsing incoming json that didn't contain an item that the class had as non-nullable. I switched to Moshi and it didn't do that - i.e. It threw an exception at parse time. This was around a year ago, if Gson have fixed that since then yay!
Had a bit of time to look into this on the weekend, and the specific issue was JARs in classpath which had `.so`s in them.
I think part of the issue is Moshi does it's particular use-case/targeted functionality extremely well with a large amount of subtle improvements and a majority of the comparisons I've seen don't cover uses outside that scope
Unfortunately no. The issue in my case was with the latest version.
you're naming your variables 'val' and start methods with an underscore. I'm not sure you're in any position to blame an automatic code conversion tool
val as in value? it's a fantastic name for a variable containing arbitrary data. so good, in fact, that some are trying to make it a keyword! as for the underscore, how do you satisfy the compiler when you have two methods with the same signature (e.g. one public and one private)?
&gt; wow, it's impossible to convert between Byte and UByte or ByteArray and UByteArray! LOL That's completely false, I suggest you first learn a language before talking shit about its inadequacies 
if casting doesn't work and constructor is private it's not worth my time to find a back door into experimental code that should be standard
My what world you live in if you consider functions to be backdoors `UByteArray` has a `toByteArray` function `UByte` has a `toByte` function the majority of number classes can be converted to any other type just like Java, Kotlin does it with functions instead of casting. 
To me it feels like the 2nd language syndrome, that I keep seeing in every language that isn't the platform language. First talk about how easy it is to interoperate with the core platform, how it is so nice there are already a plethora of libraries, and after the community reaches a certain size, we start re-writing the world because library X isn't idiomatic, regardless how stable and feature rich it already is. And the occasional hate for the platform that allowed for the language to exist in first place. Groovy, Scala, F#, Clojure, Ceylon and now Kotlin.
is the as keyword broken for unsigned types because they're 'experimental' or is a conscious design choice to pay homage to brainfuck
This is not about being idiomatic. I recommend reading the article before jumping to conclusions (eg. see the other thread)
Faire enough.
But in this case the presented solution solves large defects that exist when combining Gson with Kotlin. So this is a valid reason to post it and I'm really glad I was made aware of these issues. We shouldn't jump to conclusions and dismiss other people's work because it feels tiring. It's one thing to ignore an article and something entirely different to add a negative dismissing comment before reading it as this will result in others not being aware of the presented pitfalls.
How are you testing? Most benchmarks make the mistake of using strings where Gson is faster because it speaks characters whereas Moshi speaks bytes (and UTF-8). Also people frequently screw up the Okio setup because they're new to it. Moshi will be faster when used correctly. Please share your JMH benchmarking harness and results.
I don't do specific benchmarks, I don't like Okio btw. I tested load via Gson and Moshi from an API of mine, Moshi lagged one second behind. Same internet connection on both, same device, same MS response time. I don't rely on benchmarks
Ok but that still doesn't address how the data is getting into the library. If you're streaming bytes then Moshi will be faster by virtue of not having to do UTF-8 decoding and not having to decode string keys. But if you're buffering to a string and then deserializing then you're handcuffing Moshi and getting slower overall performance.
Oh on the short notice i know about the creators of Gson and Moshi since I'm talking with one of them now. I guess the practice you use is Okio, you get the data and you have to process it somehow for manipulation with Strings, Files etc.. ? I'm talking about getting the data and presenting it as loaded, since that is the purpose of the api i use, fetch and load in the recycler, all of them are simple Strings, Ints and Bools ... Correct me if I'm wrong.
The string he refers to is not about the type of data in your payload but how the payload reaches the API.
That's beyond my knowledge since it's public API
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/coding] [The sieve of Eratosthenes](https://www.reddit.com/r/coding/comments/ake08b/the_sieve_of_eratosthenes/) - [/r/programming] [The sieve of Eratosthenes](https://www.reddit.com/r/programming/comments/ake0ee/the_sieve_of_eratosthenes/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
you might find something in android meetups, but I couldn't able to find anything pure kotlin here in the bay area, which is applicable for backend developers also. 
Well, introducing middle man to fix underlying platform is an effective approach, more so than breaking compatibility right away.
So your non-parallel Kotlin version is 50 times faster than C? How?
No. My version is faster than the reference version. I suspect the author's C program might be as bad as his Kotlin program. I never implied Kotlin is faster than C.
 async { for (i in range) { ... } }.await() This does not run in parallel at all. Calling await directly after an async block is useless and the IDE will even tell you so. The async (or more appropriately launch, since the result is not used) must be inside the for loop and then all the coroutines waited on **after** the loop. This could look like this: coroutineScope { for (i in range) { launch { ... } } } After looking at your source on Github I am even more confused. There it just reads withContext(Dispatchers.Default) without any mentions of async/launch. At least the Dispatchers.Default will get you more than one thread as opposed to just runBlocking as in the article. Testing the code locally I found no significant performance difference between the parallel and no parallel version. But I did not use proper benchmarking (measureTimeMillis on its own is not good enough). If I add a millisecond extra pause for each call to computeForSingleNumber I do however get a difference between the serial and properly concurrent coroutines version.
Nice project! As a tip: you can use Pair or Triple as return value, that way you can return multiple values from the same function fun something(): Pair&lt;String, Int&gt; = Pair("Hello", 0) val (str, num) = something() println(str) println(num) 
Thank you! Yes I discovered that (and am using it). I admit it is close to what I am used to in Python. I do have to use an explicit container object though, where in Python, a tuple of arbitrary number of elements is a primitive type in the language. 
There seems to be a [San Francisco Kotlin Meetup](https://www.meetup.com/San-Francisco-Kotlin-Meetup/), which is meeting next on February 7. They appear to be new, but already have 90 members! &amp;#x200B; I know it's not close, but if anybody is in Chicago, [please come join CKUG](https://www.meetup.com/Chicago-Kotlin/).
The comparison isn't to C, it's between two Kotlin versions.
I recommend setting up a Gradle build, as you'll get incremental compilation support from the command line as well. It can also help with diagnosing build times and managing dependencies, so you don't need to ship those JARs in your codebase.
Sweet! Thank you!
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/u_rabina_bra] [Documentation on coroutines in Kotlin JS](https://www.reddit.com/r/u_Rabina_Bra/comments/akihyu/documentation_on_coroutines_in_kotlin_js/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I'm asking how the raw response data is fed to the JSON library. That can make or break performance if done incorrectly.
I will look into this. Thanks for the suggestion. 
I'm reading an excellent book at the moment .. Kotlin for Android App development by Peter Sommerhoff. Writer states 'you do not need any prior experience with Kotlin or Java'. Some programming experience in any language is assumed though.
Thanks, I'll check it
Huh... so that's why I had to put a timer at the end of my programs while testing out coros! I guess that makes plebty of sense, shouldve looked a bit deeper beforehand!
I just lost a discussion at work to use kotlin over java for our new project. Because kotlin didn't support the new java 11 bytecode, please implement :p
Sorry to hear that. Why does Java 11 bytecode matter for your use case?
Ok maybe we are misunderstanding here, but from what I understand kotlin is translated to java 8 bytecode and to make use of the new garbage collection features, you need java 11 bytecode. Is this not so?
I don't think any gc-related features are tied to the new class file format. Fwiw, Java 11 doesn't seem to use these structures either, they will be used in future versions of the language 
Time to go refractor all my code... 
Kotlin for sure. It's much easier to read and write and has better type safety. If you already know java the learning curve for kotlin should be trivial, spend a day and do the koans and you should be set.
Hi, &amp;#x200B; i made a quick gradle build for you: [https://github.com/fboldog/prog8/tree/gradle-build](https://github.com/fboldog/prog8/tree/gradle-build) &amp;#x200B; A full build (with tests) on my machine takes 16s (old i7-4790T, ssd) &amp;#x200B; I not tested with examples (res folder, etc), but compiles and the gradle project works well in IDEA and command line. &amp;#x200B; &amp;#x200B;
Care to support this statement: "has better type safety"? Don't they run on the same JVM? Wouldn't that mean that they enjoy the exact same type safety?
Support of nullable. So in java a String is either a String or null. In a pure kotlin project a String is always a String. A String? is a String or null.
&gt;java 8 bytecode and to make use of the new garbage collection features, you need java 11 bytecode. Definitely not! I'm sure you use Java libraries that were compiled with Java 8 bytecode. But to go to Java 11 you don't have to recompile those libraries. Same case with Kotlin.
Type safety has to do with the language/compiler you use, not the JVM. For example, both Clojure and Groovy run in the JVM, but are dynamically typed.
Much obliged. I am not familiar with Gradle yet. though. I see you had to change the project structure for it? That means I'll have to adapt some scripts as well. Also I couldn't immediately load the project in IDEA it didn't seem to recognize the new gradle structure, but that's probably me struggling with the new tool. I'll spend some more time with this later.
It was just a quick (&amp; dirty) example for working Gradle build. Gradle configs easily configurable to your actual project structure. (tomorrow I will create a new brach with this)
Kotlin provides stronger type safety due to the stronger type system built into the compiler. If you have a nullable variable and try to dereference it, the code will only compile if the compiler can prove that it will never be null at this point (eg. If it's wrapped in a null check or if you use the Kotlin null operators such as the safe call or elvis). Now there are some caveats (eg. Calling Java code from Kotlin) but the stronger type system has made a huge difference for me. Kotlin also has more robust generics than Java (these are also a compiler trick for both Kotlin and Java hence the term "type erasure")
Can somebody explain how you start a coroutine from a thread that should not be blocked, without using GlobalScope? If I receive a request on my network thread, I want to immediately switch to running a query on my database thread, but it should relinquish any blocking behaviour on the network thread immediately (as the database thread can handle the response too in this example). I tried "runBlocking { withContext(databaseContext) { Thread.sleep(5000) } }" but that makes the thread that called the "runBlocking" sleep for 5 seconds, which isn't desired.
Shout out also to Kotlin smart casting, like not forcing you to re-cast something after checking if it is an instanceof. Also sealed classes are pretty great for writing sane “when” statements 
Kotlin is strictly superior to Java, end of story. There are two reasons not to use Kotlin: - Your company/client wants Java source code, or is stuck with Java specific tooling - You as a developer have to code Java again in the future. (It hurts me so much whenever I got to code Java at work. Since I know Kotlin, I get massive headache when ever I look at java code.)
I want to add the safety features of final/const by default via "val" and the encouragement to use immutable data structures such as list vs mutableList. 
new version up on same branch ([https://github.com/fboldog/prog8/tree/gradle-build](https://github.com/fboldog/prog8/tree/gradle-build)) * untouched project structure * installDist (./gradlew installDist) task generates p8compiler &amp; p8vm apps (scripts and jars) to ./compiler/build/install/ * opening project folder in IDEA working (just open the folder and use default gradle import settings) [https://imgur.com/a/OvDphET](https://imgur.com/a/OvDphET) &amp;#x200B; feel to free to use, change or drop :)
I'm not an expert of coroutines, so please correct me if I'm wrong, but the statement is not to "never use GlobalScope", but "Use structured concurrency, when ever possible". Your use case might be one of the cases, where launching a global coroutine is okay - but as stated in the article, you have to take responsibility of the launched resource by yourself, and not just fire it and forget it. For example you could somehow use the Job instance returned by GlobalScope.launch().
&gt;Thanks for your detailed answer, when you talk about "dependencies" do you mean libraries especially designed for Kotlin Multiplatform? Using non-Kotlin Multiplatform dependencies seems like a suicide move here maybe that's why I thought its obvious but to be entirely clear, yes - in that context I have meant Kotlin Multiplatform in mind designed dependencies. This is a still work in progress solution and has many things yet to be implemented, some platforms are supported, some aren't, risky business using that stuff but if used carefully it can still be a big improvement in shared code ratio utopia. You can always implement only parts that are shareable between platforms in the Kotlin Multiplatform fashion and implement code that cannot be shared separately and repetitively on each platform. With time you should be able to migrate more and more code into the shared module. Doing a jump from a big project to the shared code concept may prove an impossible task later on. &amp;#x200B;
https://mongodb.github.io/mongo-java-driver/3.4/driver/getting-started/quick-start/
1. use latest java driver available. 2. for object mapping and data classes you'll need a no-arg kotlin plugin. I've registered DbEntity annotation, so data classes looks like this: &amp;#8203; @DbEntity data class Task( val id: String, val version: Int, val title: String, ... ) 3. there is some magic with correct connection configuration, especially if custom codecs are required. I've end up with val pojoCodecProvider: PojoCodecProvider = PojoCodecProvider.builder() .conventions( listOf( Conventions.ANNOTATION_CONVENTION, Conventions.CLASS_AND_PROPERTY_CONVENTION, Conventions.SET_PRIVATE_FIELDS_CONVENTION ) ) .automatic(true) .build() val codecRegistry: CodecRegistry = CodecRegistries.fromRegistries( CodecRegistries.fromCodecs(InstantCodec()), /* java 8 Instant support */ MongoClient.getDefaultCodecRegistry(), CodecRegistries.fromProviders(MyClassCodecProvider(), pojoCodecProvider) /* this custom codec decodes nulls to empty collections \*/ ) return client.getDatabase(databaseName).withCodecRegistry(codecRegistry)
It's the most important if you want to do Android development. No need for other people's opinions.
Couldn’t he shoot this video somewhere else besides his car? What is the point of this?
There is a Kotlin JPA plugin which includes noarg and makes classes annotated by JPA's @Entity open and with a no arg constructor so it's more JPA friendly.
For me is really important. Actually is one of my favorite programming languages right now. I had some Android apps written initially in Java and now that I ported them in Kotlin the maintenance is a breeze. Sincerely I hope Kotlin will grow in the feature and Eclipse will have better support for it so I can also use it in SpringBoot projects without IntelliJ. Until then you can check my Kotlin apps here: [https://arpytoth.com/projects/](https://arpytoth.com/projects/)
Thank you very much I will merge this PR! It seems to work fine! One question though: my build script uses the kotlinc feature to package everything including the kotlin runtime into one jar (and I add some stuff to it manually). Is something like this possible with gradle as well?
It looks like recording random thoughts during driving is very popular nowadays. 
I have fun writing in it, so for me, very. 
It's my understanding a key motivation of creating kotlin at jetbrains was so they could use it to build their tools. That said, one might assume it is pretty unlikely eclipse will ever see feature pairity with jetbrains IDE's for kotlin since it is by them for them and most people there I would imagine prefer intellij. Maybe with serious community contribution it could be reasonably comparable? 
I had the same question. Here is the response from the developer - https://kotlinlang.slack.com/archives/C0F4UNJET/p1548220295009100
I can't access it without an account - would you mind pasting the reply?
suresh &gt;Last commit to the dokka repo was almost an year back. Is this still the tool going to be used for doc generation in kotlin? Would be great if the authors can merge this PR - https://github.com/Kotlin/dokka/pull/358 Simon Ogorodnick [JB] &gt;Dokka develop doesn’t occur in master, so consider `dev`/`dev-pre` branches suresh &gt;@semoro thanks, i didn’t check that. Any rough timeline on when 0.9.18 release is available? Again thanks for merging this PR. Simon Ogorodnick [JB] &gt;No ETA, but when bugs mentioned in milestone will be fixed
Thanks :)
Sadly I think you are right. I really like Kotlin as a language... but I can't use it in any other project beside Android apps. I work in SpringBoot and I'm stuck with Java because everything related to Spring works better in Eclipse. Or at least I am more efficient in eclipse. IntelliJ is to heavyweight and it's expensive for enterprise.
This was so brought up at KotlinConf, here: https://youtu.be/heqjfkS4z2I&amp;t=21m35s
I'm relatively sure that's not a regex. Anyways: .. Makes a range, so 'a'.. 'z' is basically the range 'a' 'b' 'c'... Or, in other words all lower case letters. all checks whether the following lambda returns true for all members of the Range. {lowercase.contains(it)} is the aforementioned lambda and returns true if the String lowercase contains the currently checked character. To summarize, this function returns true, if the input String contains all letters of the alphabet. 
Oh, I thought this would qualify to be called a regex, sort for the misuse of the name. Anyhow, thanks for explaining this to me. I really appreciate it. Have a nice day!
Dokka is my least favorite part of Kotlin right now. Time for a fork or a rebuild?
I'm learning Java so I can learn Kotlin... that's how important it is to me.
This was interesting! I've found myself using launch(Dispatchers.Default) for Room. I guess I should switch to launch(Dispatchers.IO)
This is nice, very informative!
How would this accomodate the two Int params?
Hey, AndDontCallMePammy, just a quick heads-up: **accomodate** is actually spelled **accommodate**. You can remember it by **two cs, two ms**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
fine
You don't HAVE to learn Java to use Kotlin, as Kotlin was made to... "supplement" Java, though I see it more of a replacement because of the interoperability and features that Java has lacked for a long time. It would be a bit of an advantage to be able to read Java code for the cases where you are using a Java library (kotlin and java are 100% interoperable), but it's not necessarily a requirement.
kotlin has saved my sanity in terms of typing. No more getting something from a collection and having to check if it's null thanks to nullability. No more getting something from a Java collection, checking if it's null in the current scope and then re-casting it every time I use it in the current scope thanks to smart casting.
It's simple. See the PR. ;)
Spring Boot in IntelliJ is fantastic with Kotlin
I think for many many simple cases, interfaces and delegation in Kotlin are a sufficient toolset to implement "DI" - having everything safe at compile time and with language features only is more worth than ... whatever it is that a framework gives you (and there might be some things, nothing against it). So I would prefer [https://www.reddit.com/r/Kotlin/comments/804fb5/simple\_dependency\_injection\_in\_kotlin\_without](https://www.reddit.com/r/Kotlin/comments/804fb5/simple_dependency_injection_in_kotlin_without)
Thank you for the great write up! &gt; But what if image1 load crashes? deferred1.await() will throw, and deferred2 will continue on forever with no reference and we leak a process. Why does `deferred2` continue forever and leak? My first intuition was that it would run until it either returns a success or throw an exception, but the result would be discarded immediately as it is not assigned to anything, and will be eventually GC'd. 
The word "forever" is a bit of an exaggeration, but even in this example it could be minutes while you have various objects, a thread, network resources, and remote services tied up for a result nobody needs. Put this in a loop (or worse, have `deferred2` somehow dependent on side effects of `deferred1`) and now you're in real trouble. 
Use with caution though, a dedicated data class with two or three properties will often be more comprehensible than using Pair or Triple. Most of the times I use them I end up going back and refactoring to use a dedicated class.
Great to see more data science stuff in Kotlin. One of my first Kotlin libraries provides an implementation of a nice algorithm for [isotonic regression](https://github.com/sanity/pairAdjacentViolators). Hopefully we'll see more, Kotlin is great for this kind of stuff.
yeah, its useful when you want to move some processing to another function, or when you want to return the result + a optional error
Thank you once again for helping me out. It looks simple indeed but I have never worked with Gradle before, so it's really helpful if someone shows how it is done
Sure, so long as you're not sacrificing readability for some convenience.
I thought I already knew CPU bound and IO bound operations, but the author's wonderful explanation made me understand it even better. I love it when that happens.
I tried it once but for me Spring is better with eclipse, it's faster, the autocompile works better, and eclipse is more lightweight. i know intelij is smarter, but for me Eclipse is smart enough and it's faster.
The java learning resources are more mature, but yes I agree it isn't necessary. I've moved on to Koans as of now though.
What kotlin version are you using? It works on my system. Kotlin 1.3.20
Isn't it `--include-runtime`?
&gt;!Since Koin works in the runtime, it cannot do static analysis, like Dagger does with its annotations, to see if all of the required/used definitions are available. Because of that, it can only do checks when you launch the app, ultimately throwing exceptions if something is wrong.!&lt; It's pretty much always worth the extra compile time to turn runtime errors into compile-time errors if you are working with &gt;2 people.
Yes, I am pretty sure that is what it is
I advise you to search on Stackoverflow
ZXing already exists. You could take their files and convert them to Kotlin and voila, yo have what you're describing.
Why would you take their files and convert them? You can use java libraries from Kotlin.
Same here, tested and working
OP is asking whether and how to build this in Kotlin. I'm just answering their question, not passing judgement on whether or not they should. For the record, I have re-written ZXing in Kotlin, though my aim was improved performance via coroutines.
Yep, because Oracle, RedHat , Amazon, Azul, PTC IBM,... are busy rewriting their JVM implementations in Kotlin.
If you have the database of prices, sure.
And I’m just saying that you don’t need to convert the java files to Kotlin, just include the package in your project and have fun. Is your work on GitHub? I’d be keen to have a look.
Looks like you are running `kotlin-native` if it produces an exe, while you are trying to make a JAR file which is made by `kotlin-jvm`. You can try calling `kotlinc-jvm` instead of `kotlinc` if `kotlin-jvm` is also installed.
It's not. $ kotlinc test.kt --include-runtime -d main.jar error: invalid argument: --include-runtime info: use -help for more information `-include-runtime` works however (version 1.3.20)
I get that man, but that's not what OP asked for. No, unfortunately. Hopefully I'll get the chance to open source it one day, but ATM it's too tightly coupled to my specific use case.
[removed]
Kotlin differentiates between nulls at a type level. If something is of type `T`, it's not nullable (a variable of `T` can never be assigned null), and if it's of type `T?` it is nullable. In the case from that code, even though you can't assign `null` to `agentName`, it's still null because at that time it's uninitialized. It's a sort of chicken and egg situation where you need to initialize the string with that function, but that function needs the string to be initialized to continue.
Hey, thanks for the quick reply. That makes sense. So by differentiating at the type level the compile will assume anything not explicitly declared as nullable cannot be null? I don't think I realized that by going through the docs, though I could have read them more closely. 
That's the idea, the compiler won't enforce null safety on `T`, whereas it will on `T?`. In pure Kotlin code the cases where you have a null `T` are practically nonexistant. This code just hit an edge case
From what I've read, declaring something as `lateinit` is a bit risky because of this sort of issue and is only recommended when you can be assured the value will be initialized. The compiler puts it completely in your hands to initialize the value. Using lazy delegation I think is more useful because you can always ensure that something that isn't nullable has a value. If I understand what you are trying to do in your code there, it looks like you want to use a function called `buildAgent` name to create a string, and to save on resources, if you call the function again you return the stored variable. It doesn't really seem like the `agentName` is going to change. What you could do instead is encapsulate the `agentName` into the declaration. The value would only be initialized when you use it and it wouldn't change. `val agentName:String by lazy {` `//build your string and do whatever else you want, essentially your buildAgent function` `builder.toString()` `}` By using lazy, there isn't really a need to even have the function `buildAgent` as you can put all that in the declaration. [https://kotlinlang.org/docs/reference/delegated-properties.html](https://kotlinlang.org/docs/reference/delegated-properties.html) This advice may be completely off and I'm just guessing based off what my interpretation of your code. I'm not an expert and I may be wrong, so feel free to disagree.
Kotlin. There are aspects of the language that really just help make everything easier. I really didn't like the idea of type inference at first because I like how Java is so explicit, I felt like I'd be losing some grasp of what was happening, but honestly type inference doesn't do that. It helps that IntelliJ is very smart. What really sold me was extension functions. You can literal extend any class and add extra functionality to it. For instance, I will often extend the Integer class and add a pow function that way I can use power with integers super easily. `3.power(2) //9` I recommend watching these two talks to really sell you on it: [https://www.youtube.com/watch?v=7EVXypZDOos](https://www.youtube.com/watch?v=7EVXypZDOos) [https://www.youtube.com/watch?v=X1RVYt2QKQE](https://www.youtube.com/watch?v=X1RVYt2QKQE)
That's a great tip, thanks. The logic for agentName / buildAgent is largely used as an example of significantly more expensive functions but I believe the lazy init works for those use cases as well. I appreciate the thoughtful feedback. 
How are they like static functions if theyre called on instances of the object
Yeah it looks like this guy is actually complaining about first-class functions.
Clean project and try again
Yes, they are just static functions with better syntax (chaining instead of explicit receiver passing) and inline capabilities. What wrong with that?
I think what i meant to say is I'd rather have them called for ex. String.something Rather than String.something() 
still the same error. I just setup a new Project and copy pasted the function with the khttp call. It looks like something is broken with the khttp library import/compilation
They are. They literally compile to a static function. In java you can still use them, but you have to use it like a static function. But they're absolutely brilliant. They make coding a breeze. I love them! 
I love them too. I just want to get rid off the () I think it'll be cooler
You can. It's an extension property. You just define a getter for it. Extension Properties Similarly to functions, Kotlin supports extension properties: val &lt;T&gt; List&lt;T&gt;.lastIndex: Int get() = size - 1 
Thank you, there's always something new to learn with Kotlin. No wonder i fell in love with the language on first keystrokes
They compile to static functions ...
It turns out that you're not right. Since it only takes 30 seconds to try it out. I recommend giving it a shot. Learning by doing is better than asking and memorizing without truly understanding.
The answer to your specific question is that Kotlin doesn't compile or translate into Java code. Java itself compiles to JVM Bytecode. Bytecode is not Java but rather it's a generic representation of a stack-based machine and these lower level instructions get interpreted at runtime and later turned into machine code via the JIT compiler. Some of the differences are that Java forces you to handle checked exceptions otherwise it won't compile but the JVM running the Bytecode has no such requirement (so it's a superset of Java). On the other hand, capabilities like generics are a compile-time trick in Java and there is no such thing as generics in the compiled results (eg. In the generated Bytecode that's stored in the `.class` files). So the the real reason that Java remains broken in many areas is for backwards compatibility. Pre-existing Java code that uses flawed parts of the language must continue to compile and behave in the same broken way with newer versions of Java. As an example, the funtamental flaw in Java where arrays are covariant was needed at first because Java didn't have generics from the start so they must continue to be treated in this flawed manner. Kotlin had generics from the beginning and since generics on the JVM use type erasure (compile time trick), Kotlin architected much more robust generics preventing some defects that are possible in Java.
Some of them they are. I think they just got var recently. Most of them they can't because they would need to change the syntax which could break old code. People with giant java projects get really hesitant to upgrade if something could potentially break, and Java is ruled by a number of large corporations with a lot of code, so removing and cleaning up syntax is going to be rare. 
Some early Java choices can't be fixed in newer versions without breaking backwards compatibility. Type erasure is one example. So much code has been written atop the erasure-based system that trying to replace it at this point would be difficult. I think that's why both Scala and Kotlin also incorporate erasure. Another example is custom value types, which the core Java team has been working on. They've run into a number of backwards-compatibility questions that they've been wrestling with. Android is stuck on older versions of Java not because they couldn't cope with the language changes, but rather because they haven't yet supported newer VM features. Android doesn't run the normal JVM. Rather, it takes compiled Java classes and translates them to a different form (Dalvik bytecode) which works on their VM (ART). It looks like `invokedynamic` wasn't supported until recently (possibly Android 8), and `invokedynamic` is emitted by e.g. the Java 9 compiler [in common scenarios](https://www.guardsquare.com/en/blog/string-concatenation-java-9-untangling-invokedynamic). Certainly there are *some* Java language changes which would work with ART directly because they wouldn't lead to incompatible bytecode, but that's not the case in general. Kotlin "solves" these problems on Android by having a backend which generates bytecode compatible with the Java 6 JVM, which it uses by default. The Java compiler theoretically can also emit bytecode compatible with older runtimes via a command-line switch (`-release`). Maybe you can convince your Android toolchain to compile your Java source code with this switch set.
&gt; On the other hand, capabilities like generics are a compile-time trick in Java and there is no such thing as generics in the compiled results (eg. In the generated Bytecode that's stored in the .class files). This isn't entirely correct. Think about it: if generics weren't recorded in the CLASS file, then when you compile against a library that includes generic types, the compiler wouldn't have any awareness that those library-provided types were generic. But obviously it does know, so the information must be in the CLASS file somewhere. That information is stored in something that the CLASS format calls an attribute; in particular, it stores that information in [a `Signature` attribute](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.9). The problem is not so much that the *compiler* isn't aware of this, but rather that the *runtime* isn't aware of this. There's no space allocated, in my `ArrayList&lt;T&gt;` instance, to remember what `T` is bound to. And because the pre-generics `ArrayList` is the same runtime type as the post-generics `ArrayList&lt;T&gt;` (i.e. there's no generics/non-generics split like in .NET), generic and non-generic instances need to be convertible to each other. Java took the "least common denominator" approach. &gt; the funtamental flaw in Java where arrays are covariant was needed at first because Java didn't have generics from the start so they must continue to be treated in this flawed manner This is a great example for OP's question.
Only if I think I'll learn something but the title of this post suggests it's just simple stuff
No..
I can really only think of one reason to use lateinit and that is android (or similar frameworks) for injected dependencies for classes that are created by the system. You are basically telling the compiler "trust me. By the time I call this value it will not be null" 
If you don't know Java and its standard library, I would start with doing Kotlin Koans in your browser: [https://play.kotlinlang.org/koans/overview](https://play.kotlinlang.org/koans/overview) I'm not sure about the Gradle and Kotlin support in VSCode but you're giving yourself an unnecessary hurdle. Use IntelliJ IDEA, it's great, you can always switch away later on.
Read the official documentation is all you need, those book you can buy are just addition
If the intention is for it to be used only in these very specific scenarios would it make more sense for IntelliJ to *not* tell the user that a lateinit variable is guaranteed to be non-null? Forgive me on this, I'm not sure if this is defined by Kotlin or IntelliJ (specially since they're both created by the same company), but this seems backwards to the entire concept of null safety in Kotlin; why tell a user that something can't be null if it can be null, even if that exists in specific 'edge cases'? In my mind the compiler / IDE should shut up unless it's *positive* about what it's telling the user. Thanks for the heads up on usage. I'm curious, how would you go about handling class variables that aren't initialized by all c'tors of the class? Say you have an empty c'tor for some purpose that doesn't touch any of the class variables, not exceptionally rare coming from a C++ background, maybe it is coming from Java and I just need to learn a bit more conventions in Java / Kotlin. 
You can use VSCode (or any editor) while you set gradle vía terminal, you need to create all the subdirectories (not much) there is a section of this in the gradle official page setup. And you run the tasks vía terminal also I used to do this, But yeah, is faster with IntelliJ.
I've already seen the video, but it is very good. Another good one is Functional Programming with Kotlin [https://www.youtube.com/watch?v=eNe5Nokrjdg](https://www.youtube.com/watch?v=eNe5Nokrjdg)
ViewModel is for android I believe: [https://developer.android.com/topic/libraries/architecture/viewmodel?gclid=Cj0KCQiAnNXiBRCoARIsAJe\_1crpLdZOCqzEixTaHl1PKNp5X8fgTyh3n1LzANevZRf3ToOQW38nlu0aAkLmEALw\_wcB](https://developer.android.com/topic/libraries/architecture/viewmodel?gclid=Cj0KCQiAnNXiBRCoARIsAJe_1crpLdZOCqzEixTaHl1PKNp5X8fgTyh3n1LzANevZRf3ToOQW38nlu0aAkLmEALw_wcB)
I'm talking about the generic before the function name. I don't understand the purpose of the generic and can seem to find any about generics before a function name. Only ever seen it after the name
It means any class that is a type of ViewModel
Before the function name, you declare the name and limitations of your generic; what they extend and/or implement. After the function name you define how the generic integrates into your implementation. In your case, the generic must simply be a subclass of ViewModel.
I like Gradle a lot, but it's definitely its 'own thing' to learn, and having to learn it at the same time you're trying to learn Kotlin will add cognitive overhead. VSCode is a good editor, but I strongly suggest sticking with IntelliJ for Kotlin. You can download the IntelliJ community edition, install the Education Plugin and start the Kotlin course, which will walk you through Koans (or something very similar). You can change your keybindings to match VSCode if that's an issue. Info at https://blog.jetbrains.com/kotlin/2016/03/kotlin-educational-plugin/ . If you do want to stick with VSCode and setup a project using gradle, you can get a boilerplate project up and running quickly with gradle: 1. install gradle (if you're on mac, just `brew install gradle` 2. Run gradle init with the kotlin type: `gradle init --type kotlin-application` (or whichever type is appropriate according to https://docs.gradle.org/current/userguide/build_init_plugin.html ) Then you should be able to open the generated project in VSCode and move on to the fun stuff.
ahh okay. So what ever uses the this generic must be a subclass of viewmodel got it. That helps. Thank you so much!
The official kotlin docs are pretty bad, imo. I've been trying to figure out some pretty simple things and the docs are useless. Fwiw I know my way around JS, Go, and Python so it isn't like I'm learning how to code, just learning Kotlin itself.
In Java / kotlin those should not exist or they should be nullable. I would always try to make something non nullable by default, so if you have dependencies that you inject or create in the constructor it should be made sure they are always not null. If you certain instances of your class do not need the functionality of that dependency consider using empty implementations of that dependency. I.e. A NoOpXManipulator is injected instead of a DefaultXManipulator and both have the same interface. Sometimes you will have some state in your class as fields like lastChosenItem and currentItem. In those circumstances it makes perfect sense to make them nullable. Because them being nullable has a meaning to your code. Lateinit has been introduced for use cases like Android and reflection because otherwise there would be compatibility issues with popular Java frameworks like dagger and I would discourage you from using it unless some framework can guarantee for you that the variable is initialized. As soon as you see an exception for a lateinit var it's a sign that you should have used a nullable variable or forgot to initialize something. 
Java is both the name of a framework and a programming language. You need to learn the framework, because that is what your (jvm-) kotlin code is running on. Now, most of the literature on Java uses the Java language to explain the framework. So you also want to understand that language. The good thing in all of that is that learning a language is easy, and much less work than studying a framework. And as s programmer you should learn a new language regularly anyways. So no harm done.
Seeing mutable arrays/lists, then a for loop to populate it. Kotlin embraces a more functional style and people should be using map/fold. 
Companion objects
!!
Yes, I agree. A side note what I do not like about Array#map is that it returns a List instead of an array. I don't understand why they did that. It should still be an Array after mapping.
One good reason would be that there are also many operations like `filter` of which the output size is not known in advance. So it internally anyway needs to use a growing array, so it might as well just use an `ArrayList` for example. And in that case, the method can also return it, since lists are more convenient to work with. And if methods like `filter` return a list, then `map` should as well for consistency. 
The only consistent use for companion obiects I've had are self-populars. ClassA.fromClassB(classB: ClassB): ClassA Other cases exist, but they are usually one off
!! is a big no no. 
Mind explaining why we shouldn't be using companion objects?
Apart from the obvious !! and mutable collections, I sometimes remark on too many nullable fields on data classes. I think missing data should ideally be handled on the perimiter of an application so the inner workings are cleaner with less null handling. This isn't really kotlin-specific though, but the nullability-flag makes it easier to spot.
Because most of the time, when Java people write a static method/field, what they actually want is a top-level function/variable, but that doesn't work in Java. In kotlin, it *does*. Whenever you add to a companion object, think really hard about whether it *needs* to belong to the class, or if it just needs to be in the file as a top-level.
Its more an inappropriate use of companion objects. Remember OPs question - code review red flags. In Java a method has to belong to a class, so if you have a pure function (maybe a util method that appends to a string and returns it) you had to wrap that function in a class, maybe StringUtils or something. In Kotlin, you can have a top-level function (not contained in a class). The compiler does some clever stuff to wrap it in a class when compiling to Java bytecode, but you don’t really have to think about that too much. Inappropriate use of companion objects are when developers from a Java background are looking for the nearest analogue of what they know and come up with a StringUtils companion object, but it is more idiomatic in Kotlin to have a top-level function instead. (Note that have a class called StringUtils is a problem in itself, and example above could also be better expressed as an extension method, Im just giving an example) 
I love using `generateSequence` to populate lists where I need to
Why not just make that a constructor?
How do you deal with constants?
I guess I'm tired and didn't really think. The case I mentioned is for clarity when changing from like named objects from other modules/third parties. Really helps readability receipt = Receipt(burgerKingReceipt) Vs receipt = Receipt.fromBurgerKingReceipt(burgerKingReceipt) The latter better explains that it's a type transition. Though it's certainly a style preference.
!!, var, mutable collections, nullable collections, loops
People one-line .let chains? :O
Properties files, an object shared between several classes(not a companion object), or just declared in class as a val for some Singletons. Use in a companion object can happen but the variety is large. Plus const on Strings or primitive types, while we often need BigDecimal (strategy 3 above)
Why?
To make the auto completion list all available static methods (or functions) in a specific context you have to type the complete package name to list the belonging top level functions while you only have to type the class name, if you use an \`object\`.
Since learning kotlin, I've only just realised how much I don't use loops now
I also try to review and think if the proposed changes does not produce any ugly interface for use of kotlin code from Java. E.g. JvmStatic() for the rescue.
Yes, and it's easy to fix. \`\`\` val foo = bar ?: throw IllegalStateException("At this point bar must not be null.") \`\`\`
Regular top level functions are fine for small projects but get out of control with larger projects due to namespace pollution. Namespace pollution hinders productivity due to displaying too many irrelevant options during auto-complete and it also slows down the IDE. These are my rules for when top level functions are allowed: 1. When they are private as this prevents polluting the namespace 2. Public extension functions are fine as long as it makes sense in all contexts where the receiver type is used. Consider making it internal if it only applies to the current module (and separate areas into modules to help with this). So I use companion objects for all other scenarios.
Overuse of scoping functions (let, run, apply, etc). They are very useful most of the time but you can go to far with nesting and chaining them and then code gets hard to read.
The generic definition on the left describes what T is on the right. It just reads “hey compiler, I am gonna give you a type, let’s both call it T, but just so you know T is a ViewModel. When you see T again we both know what we are talking about.” T is being used in 2 places: function parameters, and the retun value. That needs to be defined somewhere, hence the earlier defintion. T needs to be defined outside of its usage to make it consistent. This is an example of why and how it would fail if not, what is T? fun create(modelClass: Class&lt;T : ViewModel&gt; ): &lt;T : NotViewModel&gt; 
To expand on ,.. comment, the JVM,the Java language and the APIs go all together. To fully understand Kotlin semantics, how some things are the way they are, you need to understand the platform. All tools to analyse the JVM performance and security issues also assume that you are running Java. The languages that target the JVM, do so by pretending they are Java, as that is what the runtime assumes those bytecodes are coming from. It is no different than having to have some understanding about C on UNIX, JavaScript on the browser, C# on .NET, Objective-C on iOS/macOS, C++ on Windows, Erlang on BEAM,.... You can get along by ignoring the foundations of the platform, but eventually that lack of knowledge will bite you.
How about a simple extension function or property so that is more clear what is being acted on: ``` fun BurgerKingReceipt.asReceipt(): Receipt = .... burgerKingReceipt.asReceipt() ``` Or ``` val BurgerKingReceipt.asReceipt: Receipt get() =.... burgerKingReceipt.asReceipt ```
I think this is an interesting question, in part because it shows that Kotlin is, historically and at least for the near future, tied to Java. Kind of puts a double burden of anyone who wants to learn Kotlin. I feel this, and seem to continue to learn Java instead of learning Kotlin.
Isn't that the same thing with a different exception?
Is this true of all JVM languages, though? I'm interesting in Closure, for example. I don't know that much about it, but whenever I see reference material it doesn't seem to rely on knowledge of Java and the JVM in the same way that Kotlin material does.
If !! is used only once, then kind of, yes. Otherwise it centralizes the assumption. Of course you could also assign a default value instead of throwing, if that is possible. If all methods of the class assume, that a member is not null, but the member is not initialized during construction, you should use `lateinit var` instead.
Type erasure could be fixed by introducing new packages for collections and other generics using classes that are shipped with the JVM. This would allow running old compilations on new runtimes, because the old JVM included classes (that on the binary level deal with "Object" and type casting instead of having the actual type) would still be there. That's also the way MS went to introduce generics in .NET, there are the old collections in [System.Collections](https://docs.microsoft.com/dotnet/api/system.collections) that don't have the type during runtime and there is a new namespace for runtime type aware collections in [System.Collections.Generic](https://docs.microsoft.com/dotnet/api/system.collections.generic) that can be used by new code.
I guess the question comes down to coupling. Should BKReceipt know about Receipt? Or visa versa? 
Yes, it applies to all of them. In Clojure even more so, because when it blows up, you will get a stack trace from Clojure runtime library full of Java classnames totally unrelated to your Lispy code. 
I use as-extensions fairly frequently, too. I guess I was a bit vague with 'like named objects'. When bringing in packages with the same naming structures as yourself, eadability is still awkward. fun com.burgerking.Receipt.asReceipt(): com.currentProject.Receipt = ... Though the confusion would only be when people dig into the object conversinno at that point though, since when consumed it'd be val receipt = burgerKingReceipt.asReceipt()
And we all know how fun those errors can be. Ugh.
why are they bad? 
This is the first part of my two-post series. This one is rather generic and has little to do with Kotlin, but should be seen as a foundation for the next post.
It kinda is, but it allows you to write a proper exception message (which thing is null and why is that am error?). With `!!` you don't know if it can't be null because you checked that somehow before or you just want to throw an error on null for whatever reason.
Mainly because the Kotlin documentation is crap. Want to know what happens when calling `"Hello"[-17]`? Kotlin doesn't specify it, but when you run it on the JVM, you will get an `IndexOutOfBoundsException`. The Java deocumentation will tell you that. Want to know how to implement `List.hashCode` for your custom list to be consistent with other lists? Lood luck with the Kotlin documentation, but it's specified in the Java documentation. And so on.
Never seeing a let, run, apply, also, use, with, etc. These little helper functions pack a lot of power. Also: builders, in Kotlin, builders are built in with named parameters. Sometimes you have a kind of builder pattern with DSL's though.
When you don't have to attach a function to an object, I don't see the point in doing it.
`fun classB.toClassA() { ... }` is the way to go I would say
`fun classB.toClassA() { ... }` is the way to go I would say
I might be missing something because everyone here is referring to the lateinits, but regarding your question: What happened in your case is that you are accessing a field of the class itself _during the construction_ of the object. Whole kotlin by design can guarantee that the field should be instantiated with a not null by the end of construction, it cannot guarantee anything if you try to access the field during construction, which is dangerous, exactly because of what happened here. This is different from lateinits which are also not null - even after construction they may not be instantiated, though you are basically guaranteeing that they will be, only later. Unless I am mistaken, the intellij kotlin plugin will actually complain about calling a function which makes use of a field which may or may not be instantiated during construction. I've seen this type of compiler warning at least once, in a similar context.
You're right. I also hinted at that in [my other comment](https://www.reddit.com/r/Kotlin/comments/amdvk4/question_about_kotlin_features_and_java_backwards/eflbhdn/). Kotlin (or some other language) could certainly introduce its own generics-aware collection types. To overcome type erasure, the instance would need to store the actual type arguments that were picked when the instance was created. It could do that in the .NET style by literally creating a separate type for each generic specialization, or it could simply carry around the type arguments in additional fields. However, these types would be incompatible with the Java-provided collection types. .NET sorta got it right, but for example `List&lt;T&gt;` does implement the non-generic `IList`. This is great for interop with pre-generics code but terrible for compile-time correctness. 
As someone who didn't quite pay attention enough to the 1.3 announcement, it took me a moment to fully grok `CoroutineScope` usage. The article and accompanying code kind of helped me: [https://github.com/antoniolg/coroutines-sample/blob/master/app/src/main/java/com/antonioleiva/coroutines/MainActivity.kt](MainActivity.kt) And I'm not even an Android developer. :) Even though coroutines are GA, parts of it, like the [https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-actor-scope/index.html](`ActorScope`) API, are still maturing. It's taken me a little while to get up to speed. 
The JVM should do that, because it does not support reified generics. Kotlin supports reified generics for inline functions that get replaced with typed code at compile time.
Companion objects are better than namespace pollution (especially for larger projects). See a post higher up for details
I guess... But how is having a bunch of functions different from the 1000s of classes that are in the namespace for any project? I'll take your word for it since I've never used Kotlin for a large project, but I can't see it personally. I
You can also use the short hand version of that: ` ?: error("message")`
That's a style choice. Nothing wrong with having .let on one line as long as it fits.
Nesting is a code smell in kotlin. It indicates a method can be extracted. Normally you should be able to chain without nesting in almost all cases. Sometimes single nesting is OK, as long as it's easy to read. In other situations, I always write `Consider extracting a method, avoid nesting` and author fixes the problem very easily. 
LocalDateTime -&gt; instead mostly Instant and sometimes ZonedDateTime is more approporiate \`== null\` -&gt; can be expressed either with \`?.let\` or \`?:\` most of the time \`else\` -&gt; not a red flag but usually can be omitted using \`takeIf ?:\`, or \`return\` or \`when\`
This is really hard to read on mobile. There’s way too much white space surrounding the main column of content and you can’t horizontally scroll any of the code snippets - not to mention the massive advertisements. 
When do you use `.asOther()` and `.toOther()`? 
Or `checkNotNull`: [https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/check-not-null.html](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/check-not-null.html) 
An aside on the fromOther bit first. It is very useful for consuming Java classes into your kotlin classes. I find myself with asOther when there is object casting involved. And toOther otherwise.
why is your code so EXCITED
If you click on the code snippet it will give you horizontal scrolling
When do you use `.asOther()` and `.toOther()`? E.g. from the standard library: `myList().toMutableList().asSequence()`
I usually have more than 1 function per file. The average ratio is probably at least 10 to 1. Although it still needs to be imported, IntelliJ still presents it in the auto-complete drop-down (and automatically adds the import if you use it). You start to see similarly-named functions and wonder which one you should be using (or even worse, you might accidentally choose the wrong one). This reduces the effectiveness of auto-complete, slows down the responsiveness of the IDE, makes us less productive because we need to stop and think which one to use, and increases defect rates.
My point is that if you start typing any English work into Intellij, you immediately get a dropdown of hundreds, if not thousands of classes, in any project. It doesn't matter how many of them are in your project, per file, whatever. And no one seems to care about that, editors don't grind to a halt, people don't use the wrong classes, etc. If functions are causing that much trouble, it seems like an editor issue that may need to be worked out. Seems like a waste to have first class functions in a language, and then arbitrarily hang them off other objects just for your editor's sake.
Umm, doesn't IntelliJ come with its own JDK already? If you're on Linux you can download a version without a jetbrains JDK if you want to use the system's JDK. This will usually be OpenJDK 11 nowadays (or 8 if you're on an older distribution). But I believe Jetbrains made some tweaks to the JDK to improve font rendering or some such so I think it's usually best to use their own JDK that comes with the installation of IDEA
The DateTime thing really depends on the application and is not Kotlin specific.
&gt; I like Gradle a lot, but it’s definitely its ‘own thing’ to learn, and having to learn it at the same time you’re trying to learn Kotlin will add cognitive overhead. With Gradle 5.0 and its support for Kotlin DSL, the “cognitive overhead” is a lot less.
I usually install both 8 and 11. Some programs/libraries don't play well with JDK 11 so I keep 8 as a fallback.
It's a little less magical, for sure, but it's still learning an additional API/DSL while also learning a new language. I learned Groovy/Gradle at the same time back with Gradle 1.0 and sometimes found it wasn't obvious where one leaves off and another begins. Bu, you're right that it's easier now, and at least it would be in Kotlin so it could serve as good reinforcement. Sidenote: a little annoying to edit build.gradle.kts files in IntelliJ with gradle auto import enabled, hope they smooth that out.
Sometimes it makes sense to have statics.
 fun doh(it: Doh) { it.map { it.blah = blah it.etc = etc Seriously, `ktlint` should instead of investing in "prohibiting wildcard imports", they should make a lint that fails as error if you encounter `it` anywhere in the code. Quite possibly the worst feature in the language by far (if you ask me). If you have `it` in a multi-line lambda or if you have an `it` on three consecutive lines, *name your damn variable.* I don't want to read `x` everywhere in the git diff.
Thanks for the reply
Enum#fromInt for example
If (something == null) { //Run code }
Multiple people have mentioned it, but no one has mentioned it's proper name, the "hold my beer operator" - !!
In the stdlib .toOther() returns a copy while .asOther() does not. We stick the the same convention.
Yes. One of them throws IllegalStateEx the other IllegalArgumentEx. Depending on which one you intend to.
You can do it by passing compiler args in Gradle or Maven: 1. https://kotlinlang.org/docs/reference/using-gradle.html#compiler-options 2. https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-experimental/index.html
The convetion is that .toOther() returns a copy
This is simpler: something = when (etc.etc) { "etc" -&gt; "hello" else -&gt; "world" } &amp;#x200B;
If else is not a red flag for you - it shouldn't be here.
But IntelliJ IDEA doesn't come with a JDK. It comes with the JRE I think.
But the Oracle JDK 11 is not free for production right? It's a bit confusing.
Yeah, so use OpenJDK for 11 instead.
Underrated reply.
I need dat smart cast tho
Does it matter? Kotlin should work regardless. 
It requires the JDK if you want to run it on the JVM
Underrated? It's the top comment.
I'm quite new to kotlin and I don't fully know how to use it to its full potential... What should I use instead?
But at least you know that you expect this to have failed, rather than just getting a `KotlinNullPointerException` which may or may not be something you think should have happened.
Do we know when tickets will be available?
That’s gonna be an expensive trip...
This guy actually codes.
Does Kotlin use anything in JDK 11 that is not available in 8?
Damnet I dont speak copenhagish OR have the money to travel to copenhangen! Maybe 2020 will be my lucky year...
yeah but its not the TOP top comment smh it could be #0 instead of #1
Namespace pollution is my fear when scaling with top level functions. I see comments like [this](https://discuss.kotlinlang.org/t/best-practices-for-top-level-declarations/2198/3) from the Kotlin team and wonder if it's an actual concern. The auto-complete suggestion feature seems smart enough to handle this, and I haven't had issues with standard Kotlin top level functions. * They are only populated when you are in the context where you would call a top-level function. * I'd imagine if you are in that context, a lot of functions would be filtered out as you type a new character. So sometimes I feel like I'm not using a language feature properly in fear of how an IDE feature would handle it, which I haven't actually had any issues with so far. 
The alternative would be `something?.let { // run code, it is now the guaranteed non null attribute} `. But really, unless `something` is a var whose state could have changed... Both are fine.
Exactly - !! has it's place, I can't find the article now, but it opened my eyes into asking myself "can this prop be null at this point in time? if no, then yea the app should kick and scream" as opposed to silently or even gently handling these scenarios. 
Yeah I definitely used to do that. Then I realized it was kind of stupid. Main problem is you now have a bunch of random global constants that can appear in autocomplete.
Thanks
English is the second language in Copenhagen
No, you'll notice the kotlin-stdlib-jdk8 and kotlin-stdlib-jdk7 maven packages exist, but there is nothing for JDK9, JDK10, JDK11. Plus the newest Java bytecode that the Kotlin compiler can generate is for Java 1.8 so the compiler can't use any Java 9/10/11 specific features either.
Thank you very much!
What about American? Is it in the top 5 at least? 
I wish I had information on this but unfortunately I don't work at Jetbrains lol. However, I agree with your assumption, they will have to move on to a newer JDK someday.
Why the downvote? It does require the JVM.
Ok, thank you. Just one more question: Which Open JDK did you download? Oracle has one but it only gets updates for 6 months, right? So it seems to be better to use one by another vendor.
perfect, i know a bit of english! though i did grow up speaking american...
Top level functions for specific class-less functions or files containing extensions, Companions for class-specific static functions like a custom deserializer `Class.deserialize(data) -&gt; Class`.
Chances are, your `uri!!.path` at 172 is actually null. `!!` means that you're basically saying "execute, damnit!!" as opposed to `uri?.path` which would not execute if it was null. so you're not actually passing in a path to be able to open and read the file. Can you verify the value is non-null? I'm just guessing this since it's giving you an empty string instead.
Yeah, It looks like the path variable is null since the debugger is showing **file: ""** at the side. Maybe it'll work if he uses File(uri?.uriString). I'm not sure though, since I'm very new to android dev and didn't use external storage much. 
It's gonna be cold 
Even when I'm not in the context of where a top-level function is typically visible, IntelliJ auto-complete suggests all top-level functions even from other packages and they get auto-imported as you use them. &amp;#x200B; There are way too many similarly named functions in my projects so having to slow down and decide which one to use is too unproductive and error-prone if they were all top-level. &amp;#x200B; This is quite problematic for larger projects so I now avoid the problem altogether by ensuring that functions are only visible in the scopes where they make sense. Separating related chunks into modules and using the internal modifier helps. Extension functions also help since they're only visible when called on objects of the appropriate type.
I think the reason this is done is so that if the suspending function attempts to launch child coroutines it does so within the scope of the caller rather than having to define its own scope. Consider the following code: ``` suspend fun CoroutineScope.inParent() { repeat(5) { launch { delay(1000) println(”done") } } } suspend fun ownScope() = coroutineScope { repeat(5) { launch { delay (1000) println("done") } } } ``` So, what's the difference between these two? Well, if you invoke `ownScope()` it will launch 5 coroutines but the function won't exit until they complete. This is because the scope defined in the function waits for all child coroutines to complete before exiting. This is due to coroutines' structured concurrency. If you instead invoke `inParent()` the 5 coroutines are launched in the caller's scope so the suspending function gets invoked, it launches its coroutines, then the caller immediately moves on. Eventually the delays will complete but it will be after the `inParent()` function completes. Make sense?
Thanks for the answer. I understand your example, but does the `suspend fun` always initiates a new scope? I tried to implement your example without the `coroutineScope` builder and it didn't let me launch new coroutines from it. So from what I understand a `suspend fun` need to have it's sub-coroutines confined to itself in it's own scope in order to execute sequentially (but also suspending the thread), if it doesn't define it's scope, it can only execute other suspending functions. Am I getting this right? Also after I asked the question, I was researching about this and found [this article](https://medium.com/@elizarov/explicit-concurrency-67a8e8fd9b25) by Roman Elizarov that says: *"It leads to the following useful convention:* ***every function that is declared as extension on CoroutineScope returns immediately, but performs its actions concurrently with the rest of the program****"*. This makes me think that I should use the extension function when I want to initiate a non-suspending coroutine that is part of the enclosing scope, but can be executed concurrently with it, while the suspend fun should be used when you have sub-coroutines that needs to be completed before taking the next step in execution even if they are executed on other threads.
I'm not sure if I undestand your use case properly and I'm also not a guru on coroutines, but i think you can use `CoroutineScope.launch` where the coroutine scope is tied to the databaseContext. One example that i found is this [github repo](https://github.com/nickbutcher/plaid/blob/master/core/src/main/java/io/plaidapp/core/designernews/domain/LoadStoriesUseCase.kt#L34) and another one in the [CoroutineScope Documentation](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/). So essentially you would have a class (maybe your repository) that holds the CoroutineScope in a variable. and then do this: private val job = Job() private val scope = CoroutineScope(job + Dispatchers.IO) scope.launch { for (i in 1..2) { launch { work(i) } } } println("Example") I didn't test the code so I'm not sure if it works.
`suspend fun` does not initiate a new scope, it just suspends all further calculations of the `suspend fun` in the scope it is used in. ``` fun doWork(workId: Int) = println("doing work in function $workId") suspend fun suspendingFunction1() { println("starting function 1 work") doWork(1) delay(1_000) // Suspends all calculations past this in this function for 1000ms doWork(1) delay(1_000) // Suspends all calculations past this in the function for 1000ms println("function 1 completed work") } suspend fun suspendingFunction2() { println("starting function 2 work") doWork(2) delay(500) doWork(2) println("function 2 completed work") } fun main() { // shouldnt take longer than ~2000ms to complete GlobalScope.launch { suspendingFunction1() /*takes at least 2000ms to complete */ } GlobalScope.launch { suspendingFunction2() /*takes at least 500ms to complete */ } Thread.sleep(2_100) } ``` And here is what I got in the console, it makes it a little easier to see the concurrency. ``` starting function 1 work starting function 2 work doing work in function 2 doing work in function 2 function 2 completed work doing work in function 1 doing work in function 1 function 1 completed work ```
Yep, I think you're right. This is what I ended up going with, in the context of a netty channel handler: class RegisterChannelHandler @Inject constructor( @Assisted private val channel: Channel, private val coroutineScope: DatabaseCoroutineScope, private val store: Store ) : SimpleChannelInboundHandler&lt;RegisterMessage&gt;() { override fun channelRead0(ctx: ChannelHandlerContext, msg: RegisterMessage) { coroutineScope.handle(msg).invokeOnCompletion { cause -&gt; if (cause != null) { logger.error("Failed to handle {}:", msg, cause) channel.writeAndFlush(FailedRegisterResponse).addListener(ChannelFutureListener.CLOSE) } } } private fun CoroutineScope.handle(msg: RegisterMessage) = launch { /* various calls to the store variable that run database queries */ } }
What does it have to do with Kotlin?
Hi, I'have some Java background, and I'm transiting to KOTLIN, I'm about starting a project using [TornadoFX](https://tornadofx.io/) in the UI, and Spring Framework at the Back-end, and I will try to prepare a talk to share my experience, I hope it will work for me, because I'm really new to Kotlin, and I'haven't give any talk before, so that will be a huge challenge for me.
Very cool code! I've been playing around with Kotlin and Micronaut and was really impressed, but I am pretty disappointed to see the size of the lambdas when compared here. 
Openjdk; accept no substitute. Oracle is not worth the risk; openjdk is a drop in replacement. Same source code, same everything with the exception of a few tools you are unlikely to need. Especially if you work for a company, keep auditing in mind: if they so much as smell there might be money on the table you will have Oracle lawyers all over you. Oracle JDK is a 'free' download but the terms of use are hairy. Unless you know you need it, assume you don't and steer well clear of it. I've not been on a project that technically required an Oracle JDK for most of the last decade. Use something like sdk man to manage the installation.[https://sdkman.io/](https://sdkman.io/) You will need this if you want to run e.g. gradle or other tools outside of intellij. Intellij bundles its own JRE but it can work with external SDKs as well. For the java version, check what your project requirements are. Many projects are still on 8. But if you can, 11 is an LTS release and probably what you should be using for the next year+ or so. Skip 9 and 10 because they were non LTS releases.
Thank you very much. But is it better to use the OpenJDK from another vendor than Oracle? They only release updates for 6 months, right? Also, IntelliJ bundles with the JRE, but not with a JDK, right?
Yes, you are correct. `suspend fun` does not create a new scope, it just makes it so the current function can be suspended via other suspending function invocations. You can see these suspension points in your IDE via that little arrow with the squiggle that goes through it, as seen here: [https://cdn-images-1.medium.com/max/1600/1\*XzoURoKo7Lsj\_dqkt10I0Q.png](https://cdn-images-1.medium.com/max/1600/1*XzoURoKo7Lsj_dqkt10I0Q.png) Coroutine scopes are something you create manually within a suspending function via the `coroutineScope {}` builder, `CoroutineScope` interface, or any of the other builders like `launch`, `async`, etc. The difference between a suspending function and a Coroutine Scope is that a suspending function can invoke other suspending functions but cannot launch child coroutines. A coroutine scope can do both and enforces the completion of its child coroutines before it will exit. In addition, if one of the child coroutines in a coroutine scope throws an exception and it is not caught, all of the sibling coroutines will be terminated within a scope. This means that coroutines will clean up after themselves. You can override this behavior with other types of scopes like a `supervisorScope`.
You got this man, just by choosing kotlin over java you are already smarter and those people that you are giving a talk to should just give extra points for that :)
I'm an IntelliJ fan myself... I don't know what I wouldn't give if my compile speeds in IntelliJ were as fast as they are in Eclipse.
I like to also add some tests that make some incorrect assertions and expect the test to have an assertion error. I've found that this makes the tests more resistant to after the fact changes.
The whole point of Openjdk is NOT getting the JDK from Oracle because of the non open parts they bundle (i.e. not open). OpenJDK is the umbrella open source project where Oracle and other manufacturers collaborate on the JDK. There are several vendors that are not Oracle providing openjdk builds directly from there. Some of these provide support beyond the 1.5 years that Oracle promises for their LTS releases. Those OpenJDK comes minus the closed source parts that Oracle bundles, which you almost certainly will never need. Intellij indeed bundles a JDK (I think, presumably they'd need a compiler ...) mainly for convenience and so that they can avoid having to support users in the field with installing that and getting it wrong somehow. It's a version of openjdk. You can also configure external jdks/jres in intellij, which is useful if you have projects where you need to compile against a specific version so you are not stuck with whatever they bundled.
But you don't get any more coupling with extension functions than you would otherwise. Extension functions are, as far as I understand them, syntactic sugar purely.
&gt;Intellij indeed bundles a JDK But when I install IntelliJ IDEA on a new VM and try to create a Kotlin/JDK project, it expects me to pass a JDK path.
Kotlin isn't an acronym; it doesn't need to have all letters capitalized, just like "Java" should never be written as "JAVA".
I Like ```when(){ ... }.!!``` instead of the exhausted-construct :)
Sealed classes are one of my favorite features in kotlin and I actually do use them instead of Exceptions in a lot of my code.
Thank you very much for your words, that very motivating
If a CoroutineScope extension function creates a new coroutine, that one inherits automatically the the scope of the outer coroutine.
Sorry for that :( Actually I don't think of it as acronym and because my English is bad I don't make this distinction. The reason that I wrote it in all caps is that every time I write Kotlin in the correct caps I got a spelling error in my editor and this is annoying so I tried to trick the spell checker with that.
I would like to start using this approach. One risk of this, though seems to be that if you forget the .exhaustive part (or .!!) in the "non-expression" case then the error would be silently ignored if you don't have your error handling case in the when, whereas in the exception case, at least the next highest level exception handler will do something (log it, etc.). Might be worth the trade-off...
What does it do? 
Not in the standard library, no. If you use coroutines you have one in the library `kotlinx.coroutines`.
Which it does, I'm actually quite conflicted myself, You're substituting NPE with whatever Exception you are throwing at the point, neither of which will give the debugger any more clarity as to why the value was null/ illegal state was present. To be honest I don't find hashbangs that conspicuous, unless you're using Kotlin contracts, there are a lot of times when some logical non nullability is missed.
Does that get rid of the cast to Any warning if you mix return types? 
Does one catch NPEs in Kotlin? I find it extremely rare to do s. Neither NPE nor the verbose message gives the debugger any more clarity about the causation of the illegal state/null value don't you think? I find myself conflicted on the use of hashbangs. On one end I firmly believe they save visible real estate while asserting something that should be true about the codeflow. While Kotlin contracts may have made a this better and more explicit, people adopting an older version might not get the benefits.
It also works if you assign the result of the `when` expression to a var/val or return it from a function. I've found it's not that hard a habit to get in to always use the `when`
This seems like a poor man's version of a proper Either construct (https://arrow-kt.io/docs/arrow/core/either/). Those work very well with sealed classes to indicate the error, but without having to have a designated "success" value.
I am thinking the same thing. But I wonder how many developers really incorporate arrow into their kotlin project ? It's a big functional library, if incorporated , it means all team members should learn the same coding doctrine. 
Doesn’t kotlin/js development pretty much require you to also use npm libs like React?
Ok, I'm glad I'm not the only one who thinks that the Kotlin docs are pretty terrible. Like half the time I need to experiment with a function to see what it does.
You don't need to, but if you are using the JVM then you should learn some Java. If you are compiling down to something else, then it isn't as useful. People who are writing in Java don't need to know Kotlin because Kotlin never comes into the picture. When you write in Kotlin and compile to Java, then there is an important overlap. Knowing how the compiler generates its Java is important in certain instances because it makes a decent performance impact. It's good generally to have an idea of what is happening under the hood. You are going to be using a lot of Java components most likely, so it is good to understand how they work. There is less information about how to use various libraries with Kotlin, so a lot of times you have to use Java tutorials. Learning the basics of Java isn't that big of a deal. Getting deep into it is a whole different matter, but the basic syntax and functionality is pretty similar to Kotlin. With all that said, if you are wanting to learn Kotlin and not get into the weeds of Java then I think just learn Kotlin. Learn there Java where you need it, but focus on Kotlin. Maybe watch a "learn Java in 1 hour video" just a quick overview. Again, Java and Kotlin are very similar. Kotlin has a lot of extra functionality to it, and it is also a bit simpler. Java I think is still great because of how explicit it is. Nothing is magic.
All valid points, but it has a sharded distribution, so you can basically pull in Either, Try and Option, and just go with that, without having to worry about lenses and what not.
&gt;Forgive me on this, I'm not sure if this is defined by Kotlin or IntelliJ (specially since they're both created by the same company), but this seems backwards to the entire concept of null safety in Kotlin; why tell a user that something can't be null if it can be null, even if that exists in specific 'edge cases'? In my mind the compiler / IDE should shut up unless it's positive about what it's telling the user. I agree that the hint should be more accurate, they are probably using the same tool tip for non-null values. It is kind of the issue with lateinit that is hard to deal with. If you want a value that isn't a nulllable type because you know it'll be initialized for certain at some point, yeah that works. The issue comes down to how you treat the value. If you treat it like it could be nullable, while it kind of defeats the point as then you should have just used a nullable type, whereas here we are saying that "based off the pogram design, I as the programmer know that this type will not be null, trust me". The answer might be to get rid of lateinit to the possibility of an invalid null, but people like lateinit. I use it myself when I need a global variable, but need to define it in a local function. Again, we could use nullable types for these sorts of things, but by using lateinit we are trying to say that "if used correctly, the var should not be null" and I prefer that method because I don't like using question marks in my code.
Is it just me, or have things come full circle? All from the author. * "[Checked exceptions are evil](https://phauer.com/2015/checked-exceptions-are-evil/)" "We are forced to handle" the exceptions. * "Use unchecked exceptions. They enable freedom and flexibility. We decide on our own, whether and where we want to handle exceptions. Not the compiler. But this advantage demands more responsibility." * "You are responsible to document unchecked exceptions carefully." In reverse. * "The compiler won't force you to handle the error cases, because Kotlin has only unchecked exceptions." * "It's so easy to forget to catch the correct exceptions. And even if you mind that you have to catch an exception, you have to look up the exceptions name in the method implementation or documentation." "It's hard to say if we have caught all possible exceptions. It's easy to introduce a bug here." * "Sealed Classes to the Rescue!" "The compiler forces us to handle the error case" Why not just expose the appropriate checked exceptions for the abstraction layer you're working on? 
This isn't full circle. The two perspectives are consistent. The idea is that checked exceptions are a bad fit both for handling exceptional conditions and for handling variants. So: 1. If you don't need checking then unchecked exceptions are better than checked exceptions 2. If you do need checking then variant types / sealed types etc are better than checked exceptions. 
 &gt; Those work very well with sealed classes to indicate the error, but without having to have a designated "success" value. # &gt; By convention the right hand side of an Either is used to hold successful values (*from link)* I can see how an either type is useful in cases where neither the left or right type has any particular notion of good/bad/success/error, but if your going to use a type to predominantly describe either success or failure is it better to have the type explicitly state that? It's possible to have both classes in your project, they're fairly light weight to implement by themselves, and then you can use whichever most accurately describes the situation.
Idk tbh
/u/jasonab point about sharded applies. re. 0.8.2, `map`, `flatMap`, `fold` etc. are all canonical implementations, not designed APIs. Those cannot change and have been stable since the earlier versions. Changes in new versions are mostly related to the concurrency framework in `arrow-effects` and how we codegen boilerplate for typeclasses.
It "uses" the return of the when construct, forcing it to be exhaustive, much like the .exhaustive helper showed in the code and elsewhere
https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.concurrent/fixed-rate-timer.html ?
https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.concurrent/fixed-rate-timer.html ?
avoiding use of 'forEach'. as the benchmark [shows](https://sites.google.com/a/athaydes.com/renato-athaydes/posts/kotlinshiddencosts-benchmarks)
I'm using [https://github.com/kittinunf/Result](https://github.com/kittinunf/Result) for this purpose. `sealed class Result&lt;out V : Any, out E : Exception&gt; { ... }` &amp;#x200B; This is also used by the Fuel HTTP lib ([https://github.com/kittinunf/fuel](https://github.com/kittinunf/fuel)).
Why kotlin are using java.util.Timer as default? The java.util.concurrent.ScheduledExecutorService is better, isn't it? [https://stackoverflow.com/questions/409932/java-timer-vs-executorservice](https://stackoverflow.com/questions/409932/java-timer-vs-executorservice) &amp;#x200B;
The course seems to be a work in progress. Looks like it's going to be a pretty good course though. Does require sign-up. Hope it helps.
If so, install one.
Ahhh yes every once in a while people come up with error handling constructs that are equivalent to error codes, checked exceptions, or even worse. No dude, exceptions were invented for a goddamn reason. Even if Java implemented them poorly with checked exceptions that tried to mimick error codes. If you argue against exceptions then you simply have not worked with sufficiently large codebases yet. Error codes and checked exceptions lead to horrorific monstrosities that make grown men whimper. I still have Vietnam flashbacks from the terrors I have seen. If you want nicer error handling, maybe make "when" an implicit "try catch" block, with the option to branch for exceptions and specific exception types. Or something like that.
I also disappointed, but engineers from Micronaut said that version 1.1 want to have some improvements in this topic, check: https://twitter.com/wojtek_suwala/status/1092473225664172033?s=19
I expected a text-based course with some sort of interactive test. videos are not a match for a concept at this scale and also programmers with TL;DR😃 state!
Kotlin runs on the JVM and compiles to java bytecode, so anywhere java runs kotlin runs. And its just as fast if not faster in some cases.
Are you aware of an alternative?
It depends on your programming style and what you want from a language. At this point, their ecosystems are established enough such that either can accomplish your goals, so build a few small projects to get a feel for each language. Personally, after having used a variety of languages, I wouldn't use Go, but that's because it really clashes with my style. I feel forced to express my ideas at a lower level than is necessary. It's a simple language but too simple for my tastes. For a new language it feels like it's disregarded many language developments. 
Kotlin plays in the same league as java/Scala/c# and you can reuse all the java libraries for you use case. You might also want to take a look at Rust if performance is super important because it's as fast as C/C++ and offers compile time safety for parallel code which Kotlin doesn't (unfortunately). 
Thanks for your information, I'm developing a parsing bitcoin core in C++ and post parsering I will create a new data structure, than I would using kotlin because i don't load a all data in memory. &amp;#x200B; I wanted to understand if the performance of kotlin is worse than that of java or are equal or even better
Yay, it pays to complain, they actually fixed my issue.
Then I’ll take credit for modular jars :)
Webpack serving ES6/JSX is a bit outside of the scope of Kotlin. Luckily [`static` routes](https://ktor.io/servers/features/static-content.html) make serving the packed files through Ktor fairly easy after the fact.
I would say it's more a benefit than a burden. Kotlin can use existing Java libraries and also it's build tools. 
JavaFX/tornadofx is sort of stuck in a dysfunctional state right now. Oracle is dropping support for java8, and java11 requires javafx as a module. If you are a desktop developer you are kind of stuck.
I'm definitely stealing this.
https://tornadofx.io/
Kotlin generated bytecode will run on any version of jvm after 1.6 or 1.8, depending on what compiler settings you used. However, the kotlin compiler has no support for any features of jvm *after* 1.8, so no fancy modules. As for JavaFX, you *should* be able to make it work (unless it requires crazy jvm11 features, I've not used it), but like others have said, TornadoFX is the "kotlin version" and should pretty much work out of the box.
Happy cake day!
Don't go with JavaFx. It's pain in the neck.
I'll be honest, I found TornadoFX to be harder to use than JavaFX with Kotlin. On one of my early projects, I spent days on getting the simplest Task setup with TornadoFX, while it took a few hours with JavaFX. It's a really cool library, but the documentation needs more work.
What about TornadoFX? Or what do you recommend?
No Java 9/10/11 though
Kotlin is a modern language. Any new features in Java 9/10/11 are probably in Kotlin anyway.
Any specific reason you desire OpenJDK/OpenJFX **11**? Are there any specific JVM features you want to use?
Op wants to use openjdk11, but tornadofx seems to have no support for java&gt;=9 [yet](https://github.com/edvin/tornadofx/issues/899)
This was my experience also, I wrote a small application that manages a list of images that rotate the background on Gnome Desktop in JavaFX. I got so frustrated when I tried to port it to TornadoFX that I dropped back to plain JavaFX. The problem is now I have to bundle the deprecated Oracle Java 1.8 to make it work on more modern distributions that are abandoning java 1.8.
I am considering falling back to Swing, not as pleasant perhaps but at least it works without jumping through weird hoops for development/runtime.
The issue is that since JavaFX has been separated from the JDK in version 11, there is little to no support for openJFX 8. I can't even find a working development library to work with. Trying to get it to compile on Java 11 and be runnable on on java 11 is anything **but** working out of the box.
Yes, since a separate OpenJDK + OpenJFX are the future of java the only way to get JavaFX applications working, to my knowledge, is to use new features of Java modules to get things up and running. AFAIK this is one of the reasons its taking so much effort for TornadoFX to support JDK 11. My Desktop app mentioned in posts above, no longer works on Linux distributions without requiring an Oracle Java 1.8 install, which is now deprecated in favor of Java 11. So I would like a solution that is not tethered to old, deprecated technology. The only real solution I can see so far is to migrate the whole project to Swing.
Yes this is the problem, trying to look for something that will work as operating systems move away from java 1.8. TornadoFX requires an older, deprecated openJDK/OpenJFX 1.8 runtime. Frankly I can only seem to get it to work now on newer distributions of Linux by installing specifically Oracle's runtime. While I can install OpenJDK8, there is no support for OpenJFX8 since they have all moved to OpenJFX11 which will only run binaries compiled for OpenJFX11. At least it wouldn't run my jar file compiled in javaFX8 without throwing exceptions until I reinstalled Oracle Java8 (with JavaFX8)
&gt; Any new features in Java 9/10/11 are probably in Kotlin anyway. They aren't. Kotlin is more on par with Java 7, Java 8 stuff like Streams or Default interface methods still don't work really well if coupled with Kotlin or are redundant with Seqences. Newer Java stuff like modules or bytecode additions/changes aren't supported at all.
TornadoFx has terrible documentation that is useless if you aren't already familiar with JavaFx. It also uses reflection to access internal JavaFx api and thus easily breaks.
Java is more than a language, you know. There's this little thing called 'runtime'.
Na man, you can figure this out. Don't go back to swing. 
This link can help [zulufx](https://www.azul.com/downloads/zulu/zulufx/). Kotlin and javafx work really well together. My preferred stack for this is kotlin + springboot. 
Shouldn't that be `configurations.compile.collect { it.isDirectory() ? it : zipTree(it) }` ?
Just use https://plugins.gradle.org/plugin/com.github.johnrengelman.shadow
I haven't really used it for anything significant, but I have made Kotlin and JavaFX work together. I used the "Windows SDK" release from https://gluonhq.com/products/javafx/, which distributes JARs and native libraries bundled together in a ZIP file. I would think that the JMOD distribution would work just as well except that you'd be missing `src.zip`. I don't know for sure, but I'd expect that Kotlin *has* to know about Java modules and JMODs at this point, given that Java 9+ distributes its standard library as a set of JMODs (including *really* low-level types like `java.lang.Boolean` and `java.util.Optional`). If `kotlinc` didn't know anything about JMODs, how could you call into Java standard library code from Kotlin?
I tried OPs method writing spark jobs in kotlin. Seemed to work ok with spark-core but kept breaking with spark-sql. Switched to shadow and works like a charm. 
No, I've never used any of those things for my Kotlin projects. I only use Kotlin multiplatform dependencies through Gradle.
It certainly can be done. Take a look at this Gradle build script: https://gitlab.com/snippets/1812753
That doesn't build, but it did make me think to change the line in the dependencies from "implementation" to "compile" and that did work, thanks.
I did this on a Mac using adoptopenjdk11. I suspect the same will work on Linux. Added the following to my build.gradle ``` plugins { id 'org.openjfx.javafxplugin' version '0.0.5' } javafx { modules = [ 'javafx.controls', 'javafx.media', 'javafx.graphics' ] } ```
That's pretty much what I have here: https://github.com/thelastpickle/tlp-stress/blob/master/build.gradle Maybe try it with the full class with the package, like so: 'Main-Class': 'com.thelastpickle.tlpstress.MainKt' 
Ah I see, I know that Oracle is stopping JRE 8 support, but had no clue linux distros had already abandoned it. Do you happen to have a link I could use to catch up on this news?
Kotlin can only compile to Java 8 byte code, but that doesn't matter. The difference is minimal, Java 11 added a thing that could lead to more optimized byte code, but isn't yet used. Byte code is just what the JVM sees. You can use Java 11 source code and libraries and it works fine inside the JVM. The JVM can run Java 11 byte code alongside Java 8 byte code. Backwards compatibility.
java != JVM kotlin still compiles to bytecode to be run on the JVM. back in the day, java didn't support lambdas, but kotlin did. after java/JVM got lambdas, the kotlin compiler changed from compiling kotlin lambdas to what were effectively anonymous classes to java/JVM lambdas. I haven't been following kotlin and java much lately, but maybe the kotlin team doesn't see much use in upgrading JVM bytecode versions, at least until the JVM supports value types. kotlin can support language features that java can't (mostly because java is backwards compatible), but it still is JVM bytecode. 
&gt; Does that means, we cannot use anything specific to java 9-11 while we are developing kotlin ? No, you can use new APIs that comes with java 9-11. Only difference at bytecode level, but, good news, there are no major improvements since java7-8, so no need to add new bytecode level to compailer.
If you actually try to debug kotlin sequence try this plugin: https://plugins.jetbrains.com/plugin/10301-kotlin-sequence-debugger In case if java stream debugger doesn't work when you try to debug java streams from kotlin - fail an issue: http://kotl.in/issue
Question, will it support it eventually? As java is rolling out new releases every 6 months now. Utilising new kotlin versions combined with new java versions means...ultimate power! 
Just did this today, this also makes it easier to compile to native with GraalVM which I somehow got working with Ubuntu on Windows with WSL.
As /u/javaprof mentioned it doesn't matter. You can compile Java 11 code, use Java 11 libraries, and run it along side Kotlin code (compiled to Java 8 bytecode) and they will run. The JVM is backward compatible. Just run them on the latest jre. The only reason for Kotlin to move to a more recent version of the bytecode would be if there were major performance improvements or something that they would like to take advantage of. Right now the improvements likely aren't major enough to justify the effort.
Well, there are things other than bytecode. For example, a new garbage collector? 
But, I could be wrong, does the Java 8 bytecode not still use whatever garbage collector is running in the JRE? So as long as you are running it on JRE 11, you are getting any of those kinds of advantages. Or is the garbage collector not backward compatible with Java 8 bytecode?
No, just my findings when I tried Ubuntu 18.10, I couldn't get my jar file to run with any of the OpenJDK/JFX combinations available. I had to install Oracle JDK 1.8 and its dependencies in order to make it work.
I started a project 2 years ago with JavaFx. I don't care what others say, but that's a dead framework. I got all sort of nasty problems and all I could find was in forums from 10 years ago. Nobody uses javafx.
When did kotlin start using 8 bytecode (INDY I'm guessing right?). Last I heard it was still targeting 6.
&gt; Or is the garbage collector not backward compatible with Java 8 bytecode? Garbage collector is completely independent from the bytecode. You can run java 1.4 compiled jars on a Java 11 runtime and use ZGC if that tickles your fancy.
&gt; a separate OpenJDK + OpenJFX are the future of java Don't make a mistake, there's no JavaFX in the future of java. It's one of those frameworks that didn't work out, but not removed because of backwards compatibility.
It supports targeting 6, but not only 6. Been that way for a while.
Kotlin compiler doesn't produce InvokeDynamic instructions yet. See [KT-26060](https://youtrack.jetbrains.com/issue/KT-26060) (lambdas) and [KT-21147](https://youtrack.jetbrains.com/issue/KT-21147) (stringConcat). It can produce Java 8 interface default methods, though. See [@JvmDefault](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-default/index.html).
There are only 2 bytecode changes that I'm aware of post 8 that really could impact kotlin. First is class nesting. It is more of a prep for value types as I understand them, but doesn't really enable new features. https://openjdk.java.net/jeps/181 It is a required change if you want to target 11 bytecode. It SHOULD simplify things, but might involve a bit of code change. The second is Load Dynamic Constant or LDC https://openjdk.java.net/jeps/309 I'm not sure how much this will affect kotlin as it doesn't generally end up generated at runtime. However, if it were, LDC would allow kotlin to define new constants on the fly.
Completely unrelated to your point, but do you know where calling `invokedynamic` INDY comes from? I've seen it now a few times and it took me a while to realize it's that instruction.
I honestly don't know. I always assumed it was just because of **In**voke**Dy**namic. AFAIK, it is pretty old though. Seems like something that's been around almost as long as it was introduced as a language feature.
That's what I thought. Thanks for confirming.
In this situation, I also just noticed that IntelliJ will warn you about not being exhaustive, and also has a quick fix to add the remaining branches. 
It's default in Java, so Java is the hold my beer language?
There were some compiler optimizations around strings that I saw they added according to Douglas Hawkins https://youtu.be/zdz_pf22nOI he starts talking about it at about 11:10. So there are some nice reasons for being to target special facilities provided by Java 9 and beyond that are compiler tricks to make the generated byte code perform better.
Thanks! I'll give it a go.
https://www.baeldung.com/java-nio2-watchservice You didn't really bother to see how watch service works did you? 
"Right now", yes I agree. However some of the work that's coming down in the next year (-ish) will make a difference. I hope (and basically expect) that JetBrains is tracking the upcoming releases and have plans to support these upcoming JVM features. 
Did not see anything to solve it out of the box, but task seems pretty easy to implement by yourself
This might be overkill, but you could use Apache Camel. It's a Java library that provides a DSL for exactly this sort of thing. Here's all you'd need to do using Camel: ``` from("file:path/to/some/directory?fileName=yourFile") .process { println("Hey I'm processing this file change ^^") } ``` You can tweak all sorts of stuff if you really need to ([here's](http://camel.apache.org/file2.html) the docs for the file consumer), but it's pretty simple and even fun to use in my opinion.
Out of curiosity what’s wrong with using the WatchService and filtering out everything but the Modify events for that file you’re interested in?
The current state of things is that Kotlin is replacing Java on Android, turning it into a legacy language there. Android's JVM level is Java 7 (with maybe some features from Java 8). I think this weighs in heavily on where JetBrains' language development focus is, and should be. Kotlin's future outside Android is still an open question. Java is entrenched in the Enterprise and they don't have a compelling reason to change this.
#[ZuluFX](https://www.azul.com/downloads/zulu/zulufx/)
Could you elaborate about your nasty problems? It's not very popular, but it's still maintained. Maybe you should give OpenJFX 11 a go?
OK that got me closer, Thank You. Now when I try to run my hello world I am getting a "module javafx.graphics does not export com.sun.javafx.scene.layout to unnamed module" Like its not exporting the modules properly?
I think your imports are wrong... `com.sun` is not a package you should be using...
That's incorrect. Please have a look at [jdk10](https://github.com/edvin/tornadofx/tree/jdk10) branch. 
Be nice
Right now, should I use the JDK 8 or 11 for Kotlin + IntelliJ IDEA?
Kindness proportional to the amount of effort they put into the question. 
You can use either, both will work 
Thank you for your answer. And is it ok to use the AdoptOpenJDK or are there any problems with it?
Someone correct me if I am wrong, but it should not matter, since your lib will probably distributed as a jar containing java bytecode anyway. I, for instance, made a spring boot adapter for our companys internal keycloak and it works with Java as well as Kotlin Spring Boot services!
I wrote my library in Kotlin, and I sort of regret it. I love the language, but the interoperability isn't perfect (SAM interface conversion..!) so I had to write most public facing APIs in Java. And, as you mention, Java users need to include Kotlin in their project, and Kotlin users might have to deal with version collisions. There are no advantages to writing in Kotlin IMO (other than it being a nicer language).
I wrote it in Kotlin and my colleagues tried it in Java, no problems whatsoever. And to be honest I am never writing Java code again.
I'm not aware of any problems with it 
Thank you, you're a good guy
kotlin wasn't included in your jar?
What do you mean? The library has a transitive dependency on `kotlin-stdlib`.
It should be possible to write your lib with no dependency to `kotlin-stdlib`, right?
There's an experimental compiler option to enable SAM conversions for Kotlin code. I believe gradle/kotlin-dsl is using it, if you feel like digging it up.
You can include the stdlib in the jar itself, shadowing if necessary. This is not necessary for Kotlin code in most cases because there is a stability guarantee; new runtimes should be compatible with code compiled against older runtimes for the foreseeable future. The code that does break is using experimental APIs, which are pretty clearly marked and spit out lots of warnings.
Nothing really. Just want something more specific. Similar to Go, they can watch a specific configuration file for changes
I did bother. It warches a directory and sends the events of which files changed :/ did you bother reading the question?
Thanks a lot. Will take a look at it :)
Although the compiled code _is_ java bytecode, it is still dependant on the Kotlin standard library which needs to be available at runtime, via shading it in or otherwise
I had the same issue where Kotlin was required for the library I was using. Any ideas how to go about fixing it? 
Thanks, I have been considering shadowing it. It feels a lot more dirty than just writing it in Java though.
Not using the stdlib at all would pretty much be just like writing Java though?
Cool! Will try to find that, that would be a game-changer.
&gt; I am never writing Java code again. And your employer is fine with that?
Yea
It is. That's how people who use the library unknowingly end up with multiple versions of Kotlin and trying to track down the source of their dependency hell. Don't do this unless you absolutely have to.
The ambiguity here is because your variable is a `var`. When using `+=` with a `var` that is of type `List` there is only one possible interpretation, create a new list by appending the contents on the right hand side of the operator and replace the contents of `var` with the new list. When using `+=` with a `var` that is of type `MutableList` there are two possible interpretations. Do you want to append the contents on the right hand side of the operator to the existing list, or create a new list and replace the contents of the `var`? You can solve the ambiguity by changing your `var` to a `val`. 
My guess: you declared your mutable collection as var, so it's not clear whether you want to update the current list by adding an item to it or create a new list that contains everything from the old one plus the additional element. Declaring your list as Val or using list instead of Mutable list might fix the problem. Also please consider putting such questions on StackOverflow instead of Reddit where others can benefit from an answer as well. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/coding] [From Imperative to Functional Programming using Arrow \[x-post from r\/Kotlin\]](https://www.reddit.com/r/coding/comments/ap5hti/from_imperative_to_functional_programming_using/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Hi Nicolas, great article! &gt; Kotlin, with the help of Arrow, makes it possible to move from legacy imperative code to a more functional-oriented one. Maybe you can demonstrate advantages of this **functional-oriented code** in another article? It would be great! My questions: Is code become more with fp readable? (with this small example it's not obvious, I even prefer original one) Is it can be easy tested? (compare to classic OOP approach with interface mocking) What about debugging? (I wonder about Intellij debugger, and stacktraces in logs) My personal feelings, that some monads is useful (like `Try`/`Either`), but only if they used like `Option` in java. `IO` doesn't make sense in Scala/Java/Kotlin, because IO invented for haskell, as only way to do unmanaged effects in pure language. And in inpure languages, you shouldn't try to mimic pure languages, if it doesn't help to write better (in any sense) code. 
Or: From simple and easy to complex and overly complicated
That's in my todo list. I've 2 other posts in my buffer on FP. Stay tuned!
I found the original code to be simpler and easier to follow than the resulting functional code. I've read of teams switching to functional programming for over 2 years and still encountering employees on that team feeling special just for understanding snippets of code. I also asked a functional programmer to explain code that he wrote 6 months earlier and he really struggled to understand his own code because of the complexity of the functional abstractions. All this makes me feel that the push for functional just for the sake of being functional is going in the wrong direction.
I appreciate the effort behind the Arrow, but I still keep thinking that doing FP in a language not created for it, will turn out cumbersome and inelegant and in the end counterproductive for the end-user. I learn Haskell as my hobby and same things are much, much more intuitive and elegant there. Doing them in Haskell fills me with excitement. On the other hand, reading blogs with samples trying to do the same in Kotlin gives me a feeling that library authors keep fighting an alien syntax and paradigm, trying to paint the pure-FP picture over non-pure FP host language, I keep feeling this is a lost effort. I hope I won't offend anybody, it is not my intention, just expressing an opinion.
&gt; I found the original code to be simpler and easier to follow than the resulting functional code. Me as well. That's because we are more used to imperative than functional. &gt; the push for functional just for the sake of being functional is going in the wrong direction I wholeheartedly agree. FP is popular, just as annotations were popular with Java when they came out, and now, many realize we overdid it. However, I'm fully aware of that. Paraphrasing the post's conclusion: &gt; Kotlin, with the help of Arrow, makes it possible to move from legacy imperative code to a more functional-oriented one. Whether it’s relevant or not depends one on’s context. In all cases, that’s one more trick in one’s sleeve.
I don't see why an employer wouldn't be, honestly. They are both cross compatible and Kotlin is meant to be an easy transition from Java, so Java developers should have no trouble at all reading and modifying kotlin. Generally if you can read one language in a paradigm you can read most in that paradigm!
InvokeDynamic is what I really want in Kotlin. Nothing else in java 9-12 really appeal to me, just waiting for L World value types so both Java and Kotlin can benefit from such a change.
While I do love functional programming, trying to copy Haskell into Kotlin obviously does not work
It frustrates me that I cannot seem to grok Functional Programming. I can follow along with the process, but I genuinely cannot understand why it's more beneficial for business dev level software development. What problems, complications are avoided by moving to FP? Would anyone mind giving me an ELI5?
Agreed. I did a Ph.D. in functional programming, and I can't understand its recent popularity either. When I was a Ph.D. student, Haskell was just being invented. At the time C++ was the hot language and templates or whatever they called generic types were just being invented. The big problem was bugs caused by programming languages having no clear semantics. In particular, C's aliasing (having two apparently different variables being in the same memory) was completely impossible to reason about. *That* was when FP was an important breakthrough. The languages had very clear semantics, and programs could be transformed without changing their meaning. But then Java was invented, and it came with the Java Language Specification and the JVM, and then we had a mostly clear definition of how the language and the platform it ran on should behave. Refactoring editors became a thing, and eventually IDEs could tell you stuff like "you might get a NullPointerException here". And then we got to Kotlin which treats nullability as a type, and Rust where RAII means the compiler knows you won't leak memory. These are truly wonderful developments in programming languages. So now a lot of the safe semantics arguments of FP are countered by languages which have similar features. FP has also brought map / filter / fold, and other higher-order functions. These appeared in Python a log time ago, and it's now pretty standard to have higher order functions. This is wonderful, though I really think Scala takes it a bit too far. Immutable data structures are also a pretty handy idea that are becoming mainstream. All that FP has left to offer which other languages don't have is lazy evaluation and monads, neither of which help people write programs much. Lazy evaluation can allow you to write some programs more cleanly than you might otherwise, but at what cost? At the cost that nothing runs in the order you thought it did... And monads are nice in theory and best left in theory, because really no programmer needs to know that nullability and lists and exceptions are all just different implementations of the same higher-order pattern. FP now reminds of that time when aspect-oriented programming was going to save the world, and just confused most of us instead. There are some good ideas there, but it's best just to steal the good ideas and evolve the languages we know and love, rather than to turn all of the code inside out and confuse everybody once again.
As someone originally from C/C++98 background I'm quite used to checking every return value for NULL before using. Still - in Java for some reason it is very easy to overlook one or two method calls that can return null and result value isn't checked. Nulls are good for their purpose, but only if compiler enforces null-checks to be done on nullable types, like in Kotlin or in the new C#. 
my biggest problem with null is how it is used in a semantically incorrect way. say you have a type signature: fun doSomething(data: Data): Result in Java, some API writers would put in documentation that "`Result` will be null when there's an error", but that information isn't in the type signature. plus, null is implicitly built into the type system anyway, even in Java. so it's not a `String` in Java; it's always a `String?`. picking up these types of errors at compile time is the whole point of static typing.
Nulls don't compose. If you have an API returning `null` that calls an API returning `null` you can't know which one failed. `Optional&lt;Optional&lt;Bla&gt;&gt;` can. Here's one case where this has caused issues already when (de)serializing: https://twitter.com/artem_zin/status/1084972715662954496 
I made a new friend today. Say hello to Null. Is Null male or female? You tell me.
Using Optional in Kotlin is a design mistake. The compile-time null safety is lost, memory usage increases, and performance / scalability suffers.
No offense taken! The effort has been successful and we're seeing great adoption numbers and people are quite happy specially with coroutines/comprehension syntax. I believe you'll like arrow-fx, it puts Kotlin ahead of Scala in readability while keeping the same features :D
&gt; IO doesn't make sense in Scala/Java/Kotlin, because IO invented for haskell, as only way to do unmanaged effects in pure language. Little known secret, IO, rx.Observable and kx.coroutines are all the same thing, and all Kotlin codebases are using at least one of them. 
&gt; And monads are nice in theory and best left in theory Every concurrency framework in every language is written knowing these principles. Either JS, Rust, C#, Java, or C++, all of them have point, map, and flatMap as the driving principles behind Promise, Result, Future, Async/Await or whatever name they're using for it.
null is a mistake for high level languages (e.g. java and kotlin). `Optional` and sealed classes exist which really eliminate the need for null for code not using an api that may return null. sealed classes and `when` imo are the best way to handle things that would otherwise probably be null if written in java. ``` sealed class HTMLRequest { class Success(val content: String): HTMLRequest() class Fail(val errorCode: Int): HTMLRequest() } fun request(...): HTMLRequest { try { return HTMLRequest.Success(requestLibrary.request(...)) } except (exception: HTMLException) { return HTMLRequest.Fail(exception.errorCode) } } fun doSomething(...) { when (val requestResult = request(...)) { is HTMLRequest.Success -&gt; ... is HTMLRequest.Fail -&gt; ... } } ```
You compose programs out of reusable lego blocks. I know you've been promised this since the first day of uni, but in this case the promise seems to hold and there's a large body of work to prove it. Everything else on top is about which blocks you need to build your business logic faster, whether it's thread jumps, await on a series of independent operations, or add the values of a list together, there should be a helper for it.
Try [The Joy of Kotlin](https://www.manning.com/books/the-joy-of-kotlin). It's a wonderful intro to functional programming. 
&gt; The compile-time null safety is lost It's still there, as Option works the same as nullable in that you only have one way of unsafely unpack a value: `getOrThrow` vs `!!` &gt;memory usage increases, and performance / scalability suffers. *potentially*, but it depends heavily on your codebase and how many calls you're doing. Eager optimizations yadda yadda.
Great response! Such well-thought-out and captivating responses are rare these days. I'm intrigued. Do you have a blog or post articles anywhere?
Next thing you will tell me is that using SumTypes is also a mistake. This is most retarded thing I have heard all day.
&gt;All this makes me feel that the push for functional just for the sake of being functional is going in the wrong direction. It's made me more productive and allowed me to focus on shipping code and not on rewriting the same abstraction on every codebase. Understand libraries and frameworks in a principled way. From this there came several career wins, bonuses, more interesting projectes...the whole works. I want to share that path with others by removing a couple of steps that we've encoded directly on Arrow.
Remember "don't use enums?": https://www.youtube.com/watch?v=Hzs6OBcvNQE
Calling \`get\` on an optional can also throw an exception. The non-null assertion operator (\`!!\`) is not the recommended way of getting values out of nullable types. This was added to ease the Java interop so that you don't have null checks all over the place when dealing with a Java library that you know doesn't return null. Using Optional takes away the power of the Kotlin compiler as you now need to use it correctly to avoid exceptions whereas the compiler performs the proof on your behalf when using nullable types. So you lose compile-time null safety with Optional. Unlike Optional, nullable types in Kotlin do not introduce runtime checks every time they're used. However, Kotlin does add checks to validate method arguments at the boundary layers if they can be called from Java to ensure that null doesn't sneak its way in. This is the magic of the Kotlin compiler, if it infers that a variable won't be null then no checks will be performed. If it can't infer that then it forces you to add code to handle that scenario. These validations are performed at compile time. Optionals are wrappers which are allocated on the heap so it can add pressure to the garbage collector causing stutters. It also does wonders with cache thrashing due to non-local memory access which can easily be 100 times slower in hot sections of code. Optional is simply a less safe way of dealing with nulls compared to using Kotlin's type system. The reduced overhead of Kotlin's type system compared to Optional is simply a bonus. So it's not about eager optimizations, it's simply about doing the right thing.
You need a lot of Options to reach GC pressure. If you're creating and trashing tens of thousands of them per second then your program has larger issues. Once that becomes an issue, or you need speed on your hot path, when you need to optimize, you can go and fix it. Doing it prematurely...I'm not convinced.
Using words like "retarded" is very unprofessional. &amp;#x200B; Now back to the conversation at hand. The main architect of Java made it clear that Optional was never intended to be used as a general purpose Maybe type as it's not suitable for that. My other response provided specifics of why using Kotlin's nullable types is strictly superior to using Optional. &amp;#x200B; Best practices are different in Kotlin compared to Java. Here's a surprising example for you: In Java we make sure that you call the equals method instead of accidentally using \`==\` but in Kotlin using \`==\` is superior and thus preferred. Similarly, nullable types are superior and thus preferred when coding in Kotlin.
GC pressure doesn't come from a single source as it's an accumulation from hundreds of tiny areas. The last paragraph of my previous response addressed the statement about pre-mature optimizations. Optional is less safe than using nullable types and this is the main reason to avoid it in Kotlin since a superior approach is available.
I'm Kweb's creator, happy to answer any questions or listen to any feedback.
Have you thought about integrating type safe routing like the Locations feature of ktor? 
Good question! My very first attempt at routing defined an automatic mapping between URLs and a hierarchy of sealed data classes, but it was a source of way more pain in terms of complexity than any theoretical benefit of type safety. So I decided to go with something simple, modelled closely on how most web frameworks were doing it (including Ktor). That said, the Locations approach looks simple and elegant, I suspect just some simple reflection underneath. I could probably support that quite easily if there was a demand for it.
True, Null is not inherently bad. But only in a situation where T being subset of T? is enforceable on the language level. But alas, this is not the case on JVM or JS, so... Null is objectively bad in any language running on those.
I do, but it's about my hobby cloud project and nothing academic. I discovered programming was way more fun than teaching, so I do that full-time now.
So no need to arrow here, coroutines are excellent for async api integration. 
&gt; Is Null male or female? NullPointerException
If you used sealed classes instead of nullable types everywhere, you'd end up with a shit load of when statements.
Until we have value type that can instanciated on the heap it is not practical, on memory/cpu bound applications, to use optional. Even Result, Try and these kind of classes generate tons of garbage if they are not detected by escape analysis, which depends on inlining, which is not reliable.
If you care to know which operation fails in the chain, just run and check them separately or maybe use some Result type. If you use Options that way you will end up doing that with an isPresent/ifPresent anyway. Not to mention that if you end up with Optional&lt;Optional&lt;T&gt;&gt;, you're already probably doing something wrong as you're meant to use flatMap for that
This is a terrible idea, don't do this. There's really no way of knowing what will happen if you invoke constructors randomly and it will certainly not work for "any" object.
Null itself is not bad, automatically having every type be nullable is 
how about breaking the k-prefix trend? that'd be a killer feature
it's good to explain to people what are moands, what is the IO monad etc. But more important to explain (and to himself) what is the benefit of IO monad. Monads were introduced in **experimental FP language Opal** to have effectful code in pure FP. And this was motivation of monads: the limitation of **pure** FP **experimental** language. Do you need IO monad in Ocaml? No. In F#? No. In C#? No. In Javascript? No. In Clean? No. In SML? No. In Common Lisp? No. In Clojure? No. In Java? No. In Scala? No. Etc... &amp;#x200B; Sure, you can implement them as some library and to have them anywhere where you can, but they are totally redundant. But Haskell guys like to present sell point of monads under the brand of "safety". Until today no any proofs that monads like IO make something more safe (let's ignore Maybe/Either as monad, because Maybe/Option and pattern-matching is enough to use them like this happens in most FP and not FP languages).
Oh, this is great then! Thanks for pointers.
How is a nullable type where the compiler forces you to handle the null case conceptually any different than an option type?
Do you have a better suggestion?
Or you can just use `map` and `chain/bind/flatMap`.
just about anything would be an improvement. k is noise and web is vague. if it really is just a library, then a descriptive name would be good. it sounds more like a framework though, so if that's the case something creative might be a better fit
Kotlinx.coroutines is quite barebones in what it offers, i.e. you're still nesting try/catch for error recovery, and you're tied to their runtime so you have to rewrite your current app. Arrow comes with all those helper functions you normally use that make interacting with async code feel like working with something as simple as either or a list. Also, you can use coroutine's async/await syntax for any other library like RxJava or Project Reactor. Not as an adapter layer paying a penalty like having to rewrite your apis, but really just getting the syntactic sugar directly over them.
It's all about that asynchronous sequencing in concurrency frameworks. There hasn't been found any other way of chaining callbacks that's not isomorphic to a monad, so it's an awesome "blueprint" to start from when writing your own primitives. These are the same in OCaml (LWT/Async), F#/C# (Task), JavaScript (Promise/async), C++ (folly::Promise), Java (rx.Observable, reactor.Flux), Rust (async), Scala (BIO/monix.Task)...
Can you please clarify how that is related to JVM? Can I extend your argument to say that Null is objectively bad in any language that is running on CPU (where you can put 0 into memory location reserver for a pointer!) ?
Option type has to be always unwrapped to operate on its contents, while nullable type T? is conceptually a union of T and null and, when you have checked that it is not null, you can call T's operations directly (when your language support flow typing). It is not a difference only in a syntax. It is a big conceptual difference in the type-system itself.
you looked at a spring app or any enterprise java TM? most code is hard to read regardless what paradigm. 
That's what you get for taking a peek to try to find out 🤣
I would argue that almost any application you'd write today is IO bound. (waiting for API's, network, disk, etc etc etc)
ah, yes, true
I'm not sure I follow your argument or how it relates. Are you saying that most code is hard to read so it's fine if we make it even harder to read?
it relates quite easily. I read imperative code all the time that is impossible to read due to all the OOP abstractions. If you have learnt all the OOP abstractions then sure it might be easier. Likewise if you've actually learn FP abstractions it will be easier. I find it really peculiar and odd how people claim FP is hard to read when of course it is when you haven't learnt any of it and established the right mental model 
TBH, the only difference between fx approach and Scala's effects I see is that there is no `IO.` or `Task.` in from of these methods. Which is a matter of preference (`import cats.effect.IO` vs `import cats.effect.IO._`)
The app that I worked on for a previous company would regularly experience GC pause times of 30 seconds (sometimes minutes). We also had fairly frequent GC loops. Bumping up the heap size helped to deal with the GC loops but at the expense of longer GC pause times and higher memory usage &amp; operational costs. The rate of new garbage was a very real problem for us and we spent alot of time tuning the JVM parameters.
I really like the functional way to do things, but if you are calling a function that returns a value type (like optinal, either, try, etc) on your hotpath, you are going to pay the cost. Escape analysis is great, but you should it not always work and it is imposible to be sure that it is going to work on your use case. So if your application is going to be written in a functional way, be sure that the business logic it is so complex that you need functional logics to reason about that or it doen't require very high throughput or you can scale it horizontally. And try to use graal!
There's the cool feature that you can abstract over them and the F will be transparent to you until the concretion point.
If it's about whether they are required, then sure, they aren't. It's another matter about whether it is easier to reason about code with them (esp. in context of async and side effects). If I have several asynchronous functions `A =&gt; Future&lt;B&gt;` (e.g. some calling database, some calling external services) then flatMap that sticks to some contracts give me a lot of confidence that `x.flatMap(f).flatMap(y).flatMap(z)` will be also behaving correctly. For instance you can have something like getUser(userId).flatMap { user =&gt; getPolicy(policyId).flatMap { policy =&gt; if (policy.owner == user.id) { generatePDFFor(user, policy) } else { Future.failure(UserPolicyMismathError(user.id, policy.id)) } } } It is quite easy to read for happy path, and failures would be "automatically" handled for you (you stop evaluating at first error, aka. circuit breaking). Then, if you care about performance you could replace Future with some lazy substitute, that waits until you design a whole pipeline, so that it all can be run as one task on a thread pool. (In Scala that can be done with e.g. Monix Task). Another improvement would be if you could run it all in one transaction on database (so that is any of the steps fails you can rollback). Java's Hibernate uses annotations on transactional methods and SQLException to control transactions. In FP you could use something like Kleisli - you can basically create a functions `Connection =&gt; Task&lt;A&gt;`, `Connection =&gt; Task&lt;B&gt;`, `Connection =&gt; Task&lt;C&gt;` and make them be results returned from your services. Basically, you pass opened connection with started transaction as an argument and return an action. With Kleisli you can also create such: def runAllInTransaction[A](block: Kleisli[Task, Connection, A]) = { val connection = ... connection.startTransaction() val result: Task[A] = block(connection) result.runAsync.map { a =&gt; connection.commit() a }.recoverWith { error =&gt; connection.rollback() Task.error(error) } } def documentForUserAndPolicy(userId: UUID, policyId: UUID) = getUser(userId).flatMap { user =&gt; getPolicy(policyId).flatMap { policy =&gt; if (policy.owner == user.id) { generatePDFFor(user, policy) } else { Kleisli(conn =&gt; Task.error(UserPolicyMismathError(user.id, policy.id))) } } } val recipeForPDF = documentForUserAndPolicy(userId, policyId) runAllInTransaction(recipeForPDF) Sure, that make introduces a more concepts that whatever you do in a Hibernate, but this example shows, that you can achieve a lot of complex functionality, that you can still understand as opposed to some automagical annotation+reflection+exception-driven solutions, where is something breaks you have no idea why and how, and you need to rely on tons of fixures and mocks to make the code testable, because it is not simply about just passing value to a function/methods and seeing what can we tell about returned value. This is, it is hard to show the real benefits in some small isolated example, because the real benefits is about making things easier to test, reason and maintain in the scope a whole application and with imperative code it is - IMHO - easy to write code that looks simpler on a local scale, but make you end up with a more complex solution when you look at the whole project.
And was that because you were using functional programming everywhere?
I hope one day Kotlin will remove the "single-argument renamed to `it`" from the language because apparently it makes people forget how to name things in their code.
TTFI, yes. Then, you can even use some super fast asynchronous implementation for production code (Task/ZIO), and easier to run synchronous for tests (Coeval).
In ***theory*** and coming from someone who hasn't ever worked in Haskell and doesn't understand lenses; theoretically the cool thing about functional programming would be that you can represent all branches of a code in its return type and thus not have any unexpected side-effects. You move things like "this method fails if you invoke it with 0" (as mentioned in the article" into the type-system rather than just `throw IllegalArgumentException("0 is not a valid divisor")` which is like "YOLO you'll die at runtime and you couldn't have possibly known this without reading the source code of the method you're invoking". This is NEVER a problem if you expose a `Try` or more-so something that exposes the intent of `ifZero/else`, so that the call-site can handle both cases by passing in "two callbacks" which may or may not be actual functions of a class (higher-order-functions / function reference). You can of course also model the absence of a result in Kotlin as part of the type system with `fun Int.divide(divisor: Int): Int?` where you get `null` as the absence of the result. But one could argue that the `?` nullable types as part of the type system are "syntactic sugar over the `Optional&lt;T&gt;` monad, where `Int?` is actually `Optional&lt;Int&gt;`'s short-hand. Now if you consider `5.divide(0)?.let { "kweh" } ?: "doh"` then you might see that `?.` is actually `Optional.flatMap`. Once you have enough of this lambda passing you end up needing tricks to interact with parts of the system here and there (currying) or you want to replace behavior (partial application). But apparently with how many functions you need to define for this stuff, people seem to get lazy with their naming and create names like `getStrLn()` which, well, not a real function name ;) You could call it `getLineFromInput()` and it'd be readable, but NO we call it `StrLn` because I'm lazy.
&gt; What about debugging? (I wonder about Intellij debugger, and stacktraces in logs) This is something I'd love to hear about too &lt;3
&gt; where you can put 0 into memory location reserver for a pointer! Because in a language that doesn't allow you to put 0 into a T and only in T? - Null would actually be a useful short notation of Option[T]. However, JVM does not allow such restriction.
But what is has to do with JVM? Type restrictions are (and should be) enforced by a language, not by a runtime or CPU it is running on top. The only role of JVM here is to ensure safety (no core dumps). It does not (and should not) do type-checking even for Java (it does not check generics, for example). 
So I don't know of an oAuth server in Ktor personally. The client side [was quickly found on google](https://ktor.io/servers/features/authentication/oauth.html) So you'd just need to point it to your server, and impliment the other end as needed. Sounds easy but will be tricky. If you're doing this for you, look for ones written in spring and see if you can mimic the functionality, even if it's java. If you don't really want to deal with it, but feel that you have to, try looking at firebase authentication. 
Are you running on JDK 7, or a later version? If 8+, you probably need the 42.2.5 version, not the 42.2.5.jre7 version 
&gt; the push for functional just for the sake of being functional is going in the wrong direction. I think functional programming has some really great advantages, like _equational reasoning_. Functional programming leads to more testable code, because functions can be more easily divorced from their surrounding context. class Counter { private var state = 0 def incrementAndGet() = { state += 1; state } def getAndIncrement() = { v = state; state += 1; v } } This is a really simple example and for the uninitiated, it's easy to miss the inherent complexity in it. Quick, describe the result of: counter.getAndIncrement() Well, let me try ... 1. the result will be dependent on the history of `counter`, which means the history of all prior invocations of `incrementAndGet` or `getAndIncrement` 2. this code is in fact thread unsafe So if you receive a `5`, but somehow you did not expect that output, how are you going to reason about it? This is a super simple example, but such shared state is often much more complex in actual, real world applications. Compare with the pure versions: def incrementAndGet(state: Int) = (state + 1, state + 1) def getAndIncrement(state: Int) = (state, state + 1) Now the output is entirely dependent on the input and easy to test. The function invocations themselves have no multi-threading concerns either. And if you end up storing this state somewhere, like in the accumulate of a fold, or in an `AtomicReference`, because you're decoupling the storage from the business logic, you don't need to double check the business logic in case you received a `5` and you did not expect it. --- This equational reasoning also extends to `IO` data types, which are super relevant on top of the JVM as well, because compared with mainstream alternatives (like Java's `CompletableFuture`) they give you fine grained control over the order in which the tasks get evaluated. For example you're never in doubt what parts of a computation are executing in sequence and what parts are to be executed in parallel. And because an `IO` is very much like a function (instead of being a variable, i.e. shared mutable state) you can describe generic logic for IO values, like complex retry sequences with backoff, whereas with a `CompletableFuture` you can't do that just with the future reference. Haskell developers are fond of saying that Haskell decouples the evaluation order from the side effects and this brings with it the power mentioned above. Well-behaved `IO` implementations on the JVM gives you that same power. --- Now I'm sure you're well aware of the above, but as somebody that explained the benefits of FP over and over again to other people, it kind of gets tiring to explain those benefits over and over again, every time you talk of functional programming. I don't know from what exactly you inferred from this article, which is otherwise very well written, that the author wants to do FP "*just for the sake of being functional*". That's imo a mischaracterization.
The article in a nutshell everyone.
&gt; just as annotations were popular with Java when they came out, and now, many realize we overdid it I'm going to do a "well actually". If you listened to developers familiar with ML languages, you would have heard that Java's annotations suck ever since inception, because they were being added to compensate for a weak type system. In general the proponents of ML languages can predict how the landscape will look like 10 to 20 years from now. Which is about right. The garbage collector was invented in 1959, it took decades for it to become mainstream.
I'm on `JDK10`. I've tried that and it gives me the same error. The reason I used `&lt;version&gt;42.2.5.jre7&lt;/version&gt;` was because that was what I found on [Maven Central](https://search.maven.org/artifact/org.postgresql/postgresql/42.2.5.jre7/bundle).
*sigh* Because, yes, the *language* (let's say Kotlin) does not allow you to do such thing formally. But Kotlin runs on JVM and, even leaving alone the libraries written in less picky languages (Java, Groovy, etc), the stdlib of JVM itself can and will gleefully ignore such silly language restrictions. Because JVM is written with Java rules in mind.
The driver is definitely not on your classpath. Are you using any submodules? How are you running the compiled application - classpath, shaded JAR, or some other strategy?
&gt; Lazy evaluation can allow you to write some programs more cleanly than you might otherwise, but at what cost? At the cost that nothing runs in the order you thought it did... The truth is the exact opposite. Lazy evaluation decouples the evaluation order from the side effects and the result is precise control over the evaluation order. With IO data types for example you’re never in doubt which tasks are executed in sequence and which are executed in parallel, or whose result is memoized or what tasks get computed multiple times. You can’t say the same thing about about alternative, dirty (non FP) abstractions, like Java’s Future.
Or use a language like Clojure which uses real immutable data structures which avoid copying and garbage.
By necessity, FP without language support is very likely to increase memory pressure, yes.
I'll think about it.
Composability is important - especially when you are working on multiple layers of abstraction - but for the usecase of knowing "_which one failed_" I don't think nesting is the right solution. If knowing if the argument is missing or not integer is important, the API should return that information explicitly via a `Result` type or exception type, and not implicitly in a way that depends on implementation details.
Kleisli arrow makes sense when you work with monads. For example, Haskell imposes on you monad when you need IO, so you can compose them with Kleisli. You called Kleisli type argument "block". I have block in Smalltalk, without any monads and Kleisli arrows. What is the Kleisli arrow from OOP point of view? I don't need IO monad at whole. So, I should pass something callable to some function and call this something. Sure, I can have interface ICallable. Also I can work with something more high-level, for example, Query or IQueryable. Why would I want such a primitive interface as Kleisli? It's super small granulated, with very limited semantic, it's fine in CT but I don't need CT at whole, actually even in Haskell - yes (with its Hask category). So, I can avoid to use so simple and primitive "bricks" for building of my application and can use Query/IQueryable, and I don't need to wrap value in monad before to return it from the function. I mean, that Kleisli, monads - are very artificial and alien abstractions in real-world programming, they can not be avoided in Haskell only, because of limitations of Haskell's purity, but in other languages they are totally redundant
I was sick of seeing objects printed like `SomeObject@6ff3c5b5` or `SomeObject(value=7, AnotherObject(value1=Object3(blah="hi"), value2=NestingObjectDeeplySucksToPrint(hello="hi")))` so I wrote this library. It has no dependencies on anything except `kotlin-reflect` and logging frameworks. It doesn't use JSON serialization to render, and it allows you to change your indentation level, and your output stream. Feedback is appreciated. 
I don't know the implementation of clojure, but it is very difficult to create immutable data structures without creating garbage on the JVM. Even if thy do, I'm not talking about avoid copying a list when you add an element. I'm talking about avoiding the intantiation of a return value type like optionals, try, either, some, etc. No matter which kind of magic clojure does, it cannot avoid these instantiations. The most it can do is to inline the function call at compile time and even with that, you cannot be sure that the JVM will remove the heap allocation.
It was regular object-oriented code. Functional code would have been even slower as it would have resulted in even more allocations. I was just providing a real-life example of the torments of object allocation and GC pressure.
a slightly better trend than \_\_\_4j =\\
&gt; If you listened to developers familiar with languages in the ML / Miranda / Haskell family, you would have heard that Java's annotations suck ever since inception Not sure if it's an argument, since most of them think that Java suck ever since inception 😅 TBH, I don't know enough Haskell to give an opinion. However, annotations remove the need for marker interfaces (_e.g._ Serializable), for which I'm grateful.
I think you should probably revisit your comparison to Vaadin. If what you say was ever true, that is many versions and a long time ago. Otherwise interesting project :)
But isn't the whole point of Option type and null safety in general, not to check whether it's null, but rather to safely continue with computation over potential value in the context?
&gt; With Optional&lt;Optional&lt;Bla&gt;&gt; you can. That's a very bad API design and I'm glad that C#'s `Nullable&lt;T&gt;` explicitly disallows it.
listen to your username
A nullable type where the compiler forces you to handle the null case is conceptually the same as an option type *where the compiler forces you to handle the none case*. That last bit is important. You can't just tack on `Option&lt;T&gt;` like F# and Java did. You need the compiler to actually honor it.
IO does make a lot of sense even in strict languages like Scala. First of all it’s NOT more difficult to use than Try/Future. Second, been able to treat side effects as regular values is awesome. 
Are you trying to make the case that one should not attempt to do FP in any language except Haskell?
Try switching type to runtime.
Personally I'm a fan of [Validated](https://arrow-kt.io/docs/arrow/data/validated/) for those cases :D
&gt; Once that becomes an issue or you need speed on your hot path, when you need to optimize, you can go and fix it. GC pressure doesn't show up as a hot path. It's more of a tax that is evenly spread over your code base. The only way to prevent GC issues is to be consistently responsible when it comes to avoiding unnecessary memory allocations. &gt; Although we usually find UniformlySlowCode at the end of an optimizing phase, it is not necessarily optimal code for either the machine or the language at that stage. Sub-optimal, but evenly distributed, performance can result from: bad compilers, a bad mismatch between program and architecture, **or an inefficient coding style for a particular language**. In such cases **there is little you can do after the fact that doesn't involve a substantial amount of ReWriting.** 
Heh quite cool will use this!
The idea here is that I can basically design several services, each of them as independent being without any hardcoded things about the context (e.g. no need to pass already opened connection when I call the service), and I can compose those things easily to make something that will be run in transaction the moment I want it (and possible to squash these several async calls to somethings that will be run in one go on a thread pool). In the mean time most (all?) OOP solutions I saw would use global state to achieve this - use some ThreadLocal to store started transaction, introduce implicit assertions that all these aggregated services should be run in the same thread because globals are shared though ThreadLocal, handle errors and rollbacks using exceptions... - this makes it quite complicated to reason about code or tests. I was never really able to do as much as unit testing in such environment, because I was virtually forced to mock or wire half the dependencies. From that point of view I find composition based on maps and flatMaps more straightforward as all the relevant logic is handled by values - happy path, errors, async, they are just values returned from functions. Additionally it promotes referential transparency. As for why Kleisli and not direct value passing. With asynchronous code it would easily end up with: def needsDatabase(a: A, b: B, connection: Connection) = { serviceA(a, conn).flatMap { a1 =&gt; serviceB(b, conn).flatMap { b1 =&gt; somethingElse(a1, b1, conn) } } } which might make people wonder why they have to pass the same argument repetitively and add some noise, whereas: def needsDatabase(a: A, b: B) = { serviceA(a).flatMap { a1 =&gt; serviceB(b).flatMap { b1 =&gt; somethingElse(a1, b1) } } } deals only with entities and values relevant to the context - database connection, event bus and other contexts that are relevant only in one particular place can be hidden away, though in a way that doesn't introduce a global mutable state. Is is necessary? Not. But I would never again consider mainaining codebase which doesn't expressing side effects on a type-level. Still, I do not want to move into Haskell, because in Haskell I am forced to do many things - which prevents library writers from doing certain things in a low level mutable way and hiding it behind a safe functional immutable API.
Are we talking about the AbstractSingletonProxyFactoryBean? Which is something that does something but its actual use beyond "please inherit from me so I can share my behavior with you" is unclear, because it is an abstraction that may or may not be necessary? 
This qualifies as &gt; then your program has larger problems hahaha
I'm trying to make the case that you don't have to do FP the way Haskell does it. I do use Haskell, but to try to copy-paste monads, bind, etc. into Kotlin is obviously a bad idea.
I’d agree that you don’t have to do it the Haskell way. That being said, many techniques do make sense and can be adapted to other languages successfully. I think Functors / Monads are a good example of such adaptations.
my points were about monads and a specially IO monad. You mentioned "global mutable state". And you mentioned thread local storage. It's fundamental property of the architecture. And the same we find in the nature: all objects are mutable, they are not cloning on a change. FP tries to impose on abstractions which are not compatible with the things in computer, it's architecture and with the nature. And this leads to performance issues. And also to bugs. I'll show one example. You can have global mutable state in Haskell even with State monad. What does State monad do? When you use it then you can change it contents. And signature of such function shows this. And everywhere where you will need to change the state, you will use it. And you will get classical spaghetti code with... potentially (I hit it irl) inconsistent states. Imagine super simple class with getter and setter. That's all. State monad does not guard you from such errors, and it is not for protection or safety, but only because no other way to have state (actually there is, even in Haskell) in pure FP language. But such problem is easy avoided in OOP - with explicit state controlled by finite automata and transitions running by "setters" (requests). Haskell, for example, never offers such solution, but it declares that safety comes automatically if you use such monad. This is a substitution of motivations: such monads are introduced not for safety but as one workaround to have at least some state in pure FP. Another interesting example is Read monad. Actually it's just a function, where reading payload is argument of the function. And evaluation is chaining of such functions. And first problem is chaining: actually all evaluations in pure FP language is a super long chaining of functions. Many monads are structures (objects) with one field only - function and monadic evaluation means wrapping, wrapping, wrapping... It leads to complex optimization phase, non-effective code, etc. And Read monad emulate "environment" with argument of such function-field and ultimately no difference between argument-"environment" or if you create some object and pass it to functions/methods where do you need it. But 1st is very unreadable and looks weird and 2nd is simple and plain. It is the same. But motivation of Read monad is not some mythical safety but impossibility to do it in an other way in a pure FP. And last, you have mutability in F#, SML, Ocaml and even in Haskell. Problem is not with mutability - it's natural way how processes happen in real world or real computer architecture. You mentioned also that you prefer to express side effects on a type level. Why do you need to express that function does IO? Caching? Optimization? Btw, all of this exists in not pure languages too and it's done better (if we will check the performance or resulting binary size). But more interesting for me is: what is the benefit to declare IO in the body of some function on TYPE LEVEL? Btw, this leads to some practical problem: when you change signature of some Haskell function to have IO, then it is propagate anywhere in the code where it's using. In other languages I can pass argument DatabaseConnection and to understand that it's use it (ie, makes queries to DB), is not it enough? Also I can mark some argument as read-only, etc - it's supported in a lot of modern languages. In Haskell I can mark on type-level that function has multiple side-effects and to play with monads transformers and this looks more terrible then standard way in non pure languages without any benefits. And I will do it not because it makes my code safer, but no way not to do it in Haskell :) 
File an issue if you discover any problems, or think of any feature improvements. I'd like to keep it pretty small, but I feel that others have use cases I haven't thought of. 
Can you elaborate? Specifically, does Vaadin have an easy way to allow DOM modifications in response to user actions that don't require a server round-trip?
Naming things is hard. Let's see, random domains I have lying around that I could use: * locut.us * zephis.com * herat.io * propheto.org Not sure if any of them are preferable.
Can it handle circular references? For example an object contains a collection of elements and those child elements has a “parent” property references to the original object.
Good catch! I don't think it currently can (I completely missed that test case as that's not a common pattern for me in java), though that's simple to implement. What do you think it should display if it does encounter a circular reference?
I unpacked Zulufx 8 on an Ubuntu 18.10 with JDK 11. I used update-alternatives to set java and javac to zulu8 set up a project in Idea using zulu8 as the development jdk and that worked great. After that I tried the fat jar and that also worked with Zulufx 8! Nice, no need for the oracle 8 JDK/JRE. As an aside I tried setting update-alternatives to openjdk 11 and I get a NoClassDefFoundError. (And yes I have OpenJFX 11 also installed on this box, the openjdk 11 still throws the error.)
Damn right, and well written!
Not OP, but I would find out what the default does and replicate that with any nice formatting if needed. Not in front of my computer or I would check.
spitballing here. maybe the first time you detect that an object has already been encountered, you can print that object with an ID of some sort. and then the thing referring to it prints out the ID? e.g. ParentObj{id=1} ( child = ChildObj( parent = {id=1} ) )
That was kind of the idea I was having, though that means I need to perform a DFS and map out a tree before actually beginning to print, which will slow down the function. If I implement it that way I might actually have a flag that you can pass to enable cycle detection, as it's not common in the java world to have cyclic objects. Or maybe a separate function, `ppCyclic()` or something. 
If you mean, the default `System.out.println()` or `println`, then those will completely depend on the `toString()` that is implemented for the object. For kotlin `data` objects, it throws a StackOverflow, trying to create the `hashCode` function, so that's not likely to work. I can't find an example of what Java does, but I bet it doesn't do anything, I bet it also either StackOverflows, or it depends on the `toString()`.
What do you mean it's not common? It's a pretty standard way to represent a tree node
Something I would have liked to see in the article is more examples of where null is utilized well, for instance where it does make an API more elegant. I feel like null is most often used in Java as a dirty escape hatch for the type system, or a way to signal an error but avoid dealing with exceptions and writing the handling code that goes along with them. This seems to be a mistake, because null doesn't intrinsically represent an error, it represents the lack of a value. So while I agree that null has its place, that place should be to indicate a variable with an uninitialized value, and not as a lazy placeholder for an error. While Kotlin improves on null usage by making it a first-class part of the type system that can be checked by the compiler and by adding syntax sugar to make handling null cases easy and clean, I'm still skeptical that null is the correct choice for the examples cited. In the first example (from Java), the fact that list() returns null if directory doesn't exist seems lazy. The correct thing (if you buy into the standard Java exception dogma) would be to raise something like a FileNotFound exception. new File("directory").list() Similarly, in the Kotlin example given by the author the use of null signals that an error occurred, and the user is left to handle a null return instead of handling an exception. val id = args.getOrNull(0)?.toIntOrNull() ?: error("id expected") However, I wonder if all of this is really hiding the need for a cleaner , less verbose syntax for handling exceptions. If you forget what you already know, and just think about this from first principles, null doesn't represent an error, it means "no value". Using it to signify that an error occurred may be convenient, but it's not really correct. Perhaps this is an indication that we need a similarly clean and concise way to handle exceptions, or perhaps it is a more general indictment of exceptions in practice and evidence that the C/Go style of returning error codes is a better approach. 
True, and in 9 years of java programming (and three years of kotlin) I've never once seen a use of TreeNode or cyclic references in the wild. Unless you're implementing binary trees or your own data structures you're not usually going to encounter cyclic dependencies in the wild. But if you feel that it's a common use case for you I can check how much of an overhead it adds and if it's not too much I'll just add it in with no flags or extra functions!!!
&gt;You mentioned "global mutable state". And you mentioned thread local storage. It's fundamental property of the architecture. Yeah, so are things like re-ordering of memory stores/loads, instruction pipelining, manual memory management, segmentation faults, etc., at least for 90% of modern, performant architectures. That has no bearing on whether a paradigm is well-founded or not: the *entire point* of programming languages is to abstract over the hardware in useful ways. &gt; And last, you have mutability in F#, SML, Ocaml and even in Haskell. Problem is not with mutability - it's natural way how processes happen in real world or real computer architecture. Again, you're missing the point. You're making some weird naturalistic argument about how we'd all be better off assuming the natural order of programming and embracing imperative paradigms. Like saying that humans should return to primitive times and eschew mathematics and knowledge and hunt for food because that's "natural." I'll propose an alternative: we don't do that, and instead we try to evaluate paradigms based on their merits, and not treat spouting off "FP is unnatural and weird" as if it's any sort of good argument. &gt; It leads to complex optimization phase, non-effective code, etc. And Read monad emulates "environment" with argument of such function-field and ultimately no difference between argument-"environment" or if you create some object and pass it to functions/methods where do you need it. But 1st is very unreadable and looks weird and 2nd is simple and plain "It looks weird" really isn't a great argument against, especially considering that most concepts out of the main stream will "look weird" to developers who aren't exposed to them as much. &gt; Btw, all of this exists in not pure languages too and it's done better (if we will check the performance or resulting binary size). Most of your application is not going to be performance-critical: a lot of time is often spent in a small set of functions, with the rest of the codebase being mostly inconsequential from a performance perspective. With that in mind, it's usually much better to work in a language that allows you convenient abstractions for 90% of the codebase, and if you really need performance, you can always call out to a language like C with Haskell's FFI. Also, disk space is pretty cheap nowadays, and developer time is generally far more costly than dealing with larger binaries. But even if we were to just consider pure performance, you do realize that Haskell (GHC Haskell, anyway) is really performant, right? At least to the point where it will be more than sufficient for a good 90% of applications (barring embedded software and other super low-latency or resource-restricted environments). I mean, there are probably good arguments against Haskell, but you're not really making many of them.
OAuth is just HTTP. Read the spec and do it. The spec will take you a day to read through, and two weeks to implement. Still, I'd recommend just using a session token. That'll take you a day tops and won't hold you back until you're a millionaire anyway.
I don't believe they support something similar to your immediate events out of the box, but they allow you to work on components on various abstraction levels, all the way down to DOM and using popular JS frameworks is possible, so implementing your immediate events as part of component implementation would be possible. Call it optimistic rendering or similar. The part I think needs revision is the part where you imply that users are forced to use the provided components and have no control over them. Sounds like you try to talk Vaadin down, which doesn't really seem fair. Not sure if that was the intention
Awesome! I've been using Rust's !dbg() macro so heavily I'm glad that something similar is now useable in Kotlin! Thanks for your work!
Wait how can you argue that FP in Java/Kotlin is bad for performance and use a project that doesn't use it as an example. I mean I get your point in theory but I just don't find your argument very convincing. 
&gt; First of all it’s NOT more difficult to use than Try/Future It's way difficult than coroutines &gt; Second, been able to treat side effects as regular values is awesome. So in haskell you have to, in other languages it's not necessary, you can have all benifits of IO without IO, and keep your code clean 
I have seen many parent references in JPA beans (a couple of years before). even Apache ToStringBuilder couldn’t detect cycle at that time. I think it can now, so you may check out how they implemented cycle detection. Maybe cycle is not common, but it can cause stack overflow in the most unexpected places (like nulls can cause NPE), so IMHO it’s kind of important, although it will decrease performance and increase memory requirement :/
&gt; so you have to rewrite your current app to use it. Just like with arrow, meh &gt; as simple as either or a list And a lot of boilerplate around I see price of the arrow, in this articles, in conference talks and arrow docs. No, thanks. &gt; like having to rewrite your apis Just like with arrow, meh Coroutines are really much easier, in most cases "rewrite", that you scare us, is just add `suspend` modifier to functions, and wrap old sync/async apis in coroutines. Try to be honest, show us disadvantages of arrow (there are a lot of them), thing you talk like: "you have an app, with coroutines you have to rewrite, with arrow not" is marketing bullshit. If you introduce something, you have to rewrtire something anyway. I bet coroutines are winner here, "rewrite" is really easy, most of the time I even don't change function signatures (except suspend modifier) 
Very handy. If you add fun &lt;T&gt; T.pp(): T = this.also { pp(it) } then you can use it to debug-print expressions inline val foo = op2(op1(bar).pp())
This is awesome, I will never understand why something like this isn't in the standard library.
Never in production, useful for unit-testing. 
It was considered. DSL gives more freedom. https://github.com/Kotlin/KEEP/blob/master/proposals/kotlin-contracts.md
Thank you for the info. Though they are obsolete now, and I am waiting for an alternative. `Executors` are part of Java stdlib, and they do not work on JS or Native so I don't treat them as a universal alternative as I work on and support multiplatform projects.
If you read again, Arrow now uses suspend functions directly, that you can use with`fx` to create whatever wrapper you want. Double check again because there's no need to rewrite anymore.
For one, it depends on `kotlin-reflect` which is optional
I know that [JOOQ](https://www.jooq.org/doc/3.11/manual/sql-execution/mocking-connection/) has some support for this. Other than that I think mocking a JDBC connection is asking for some serious head scratching down the line. I think it does not worth it. You are better off tucking away the JDBC parts in a class and testing separately. The repository pattern comes to mind. 
Some operations are cancelable, some are not. Use GlobalScope when you don't want to cancel operation. What's the problem?
You think non-cancelability will save your app? What about Android killing the whole thing at its discretion? Your code should better be written to deal with the possibility of cancellation, that's the only way to make it robust.
You already deal with failing database writes, so why is it a problem to just add `Job.isCancelled` to your failing condition? Also `YourDatabaseCoroutineScope` that owns the write job should not necessarily be tied to the activity lifecycle.
If you don't want to make it cancellable, then run it in the GlobalScope. People say it's "discouraged" but technically there are things you don't want to cancel, so "discouraged" doesn't mean "you never should".
Just because it's cancellable doesn't mean it halts immediately. You can use [isActive](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/is-active.html) to check for cancellation, so handling it is easy.
&gt; You think non-cancelability will save your app? What about Android killing the whole thing at its discretion? That's generally not a problem because it clears out all statics, and you restore only what you do restore.
OP's example of a database operation is a problem that non-cancellability does not solve. His other examples aren't valid, I think, because cancellation normally happens when your activity is being destroyed so no GUI artefacts will linger on.
All coroutines in all languages are inherently cancellable. When a coroutine suspends itself, it is reliant on the calling code to eventually resume the coroutine. If the calling code never resumes the coroutine, then the coroutine is effectively (silently) canceled. Complaining about coroutines being cancellable is like complaining that iterators don't require you to always iterate to the end. What I just said is true of stdlib coroutines. For the coroutines that are created to handle [`sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/sequence.html) and [`iterator`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/iterator.html), there's no guarantee that the coroutine body will finish. But when it comes to kotlinx.coroutines, there is more structure. The dispatcher *should* guarantee that all suspended coroutines will be resumed. If explicitly cancelled, then the suspending function should throw [`CancellationException`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html). Your coroutine body can therefore use normal exception handling constructs to deal with the cancellation. In this way, it's similar to Java's `InterruptedException`. 
No reason to cancel a DB operation tho. If the UI observes DB changes, then there is no callback that would cause memory leaks anyway. LiveData is great.
Sorry, based on the downvote I got, apparently I gave you the wrong answer. The real answer is "monads are applicative functors that implement `flatMap` in such a way that it obeys the monadic laws, which lets you use them as `List`, `Optional`, `Future` `Eval`, and certain other things that work like monads". ELI5 &lt;3
Before you talk about rewriting existing code, now you talking about writing new code. Nice pivot. So in plain coroutines your example will look even better: ``` suspend fun greet(): Observable&lt;Unit&gt; { sayHello() val user = callNetwork() return store(user) } ``` And more performant with lower GC pressure and app size (because we doesn't use another, useless dependency)
Handling cancellation is actually very easy. Cancellation throws exception on suspending points, so if you have any suspending points, just do try ... finallly and perform any cleanup in finally blocks. &gt; Show a pop-up then close it in 5 seconds... cancellation!!! It will now hang forever. That is exactly the reason FOR cancellation. It should be supported for exactly things like opening popup for 5 seconds. Why should you waste resources and perform meaningless tasks that user does not want performed anymore? &gt; Some operations are not even cancellable by their nature Wrap them around `withContext(NonCancelable)` and you are done. &gt; Threads were not designed as cancellable because it is impossible to do it right for all cases. That is correct. But these are coroutines, not threads. Unlike threads, they do not just abort in unknown state, they handle cancellation cleanly (by throwing exception at any suspension points, allowing consumer to properly handle them)
Ok, I'll see if I can rewrite that part to be more accurate.
Android killing process is a problem that does not have relation to coroutine cancellation. Android killing process is bad, and most android problems come from this fact. We cannot do anything with it. The same with network - it can be interrupted, we cannot do anything with it, and this brings us TONS of problems sometimes. But why making coroutines cancellable, just because we do not have enough problems? "Code properly written to be interruptible" yeah, we know how to do it, but I have never seen it in real codebases of regular apps. For some reason... I wonder why...
Wow, this sounds like a valid answer, thank you! :) But dealing with coroutines as with something that is inherently cancellable... in this case application of coroutines becomes extremely narrow. Like, never do two things in one coroutine, because it can be interrupted in-between... Then why do we need them? They cannot even be lightweight threads anymore, not saying about more complex applications. 
A better design pattern is to hide your data access behind some sort of operation. So instead of having `userRepository.findById(123)`, you have an interface like: ``` interface FindUserById { operator fun invoke(id: Long): User } ``` Now you can mock it out without worrying about the underlying database.
I appreciate your answer though. Fuck downvotes
`Thread.sleep()` is interruptible. `delay()` is cancellable. `Future.get()` is interruptible. `deferred.await()` is cancellable. There are many more parallels like this. On top of that, Kotlin provides explicit constructs to prevent cancellation, as opposed to Java. So whatever complaint you have for coroutines, you've been exposed to the same situation in Java (unless your haven't worked in Java before), and the difference is that coroutines give you more, not less control. My personal experience is that I had all kinds of weird app crashes which eventually boiled down to coroutines launched in one activity, but acting upon a new one after a destroy-recreate cycle. Cancellation swept them all away.
https://docs.oracle.com/javase/7/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html
Your point?
What if user *does* want the task and it is not meaningless? Cancellability is a property of the task, not a property of the call spot. Throwing cancellation exception is not equal to correct handling of unknown state.
There are parallels, but it was industry proven that this approach is unsafe inherently.
The article you linked to has only one entry on thread interruption and explains exactly what I already said, that you can write non-interruptible code because it's a cooperative mechanism.
&gt; What if user does want the task and it is not meaningless? If user closes your application, I would argue that he wants you to cease all operations and close down. If you need to finish existing operation (such as committing to database), you can wrap it in NonCancelable. &gt; Throwing cancellation exception is not equal to correct handling of unknown state. Handling cancellation in coroutines is exactly the same as handling exceptions, since cancellation is basically CancellationException thrown at suspending site. You already need to make sure your operations do not go into undefined state if unexpected exception happens, so I don't see why is it any harder with cancellation.
Happy to hear at least you found some value in the original version :)
It is possible to write non-cancellable code, but not non-cancellable coroutines. The point of my point is that coroutines are cancelable by default, and this is a problem. Not the possibility to cancel itself. Making all code cancellable by default causes problems, and the article I referenced to, explains which kind of problems. "user has no warning that his program may be corrupted. The corruption can manifest itself at any time after the actual damage occurs, even hours or days in the future." "Couldn't I just catch the ThreadDeath exception and fix the damaged object? In theory, perhaps, but it would vastly complicate the task of writing correct multithreaded code." Replace `ThreadDeath` with `CancellationException` for drawing parallels.
Coroutines are not cancellable by default. To be cancellable, a coroutine must explicitly check the `isActive` flag and react to it by throwing a `CancellationException`, or it must call an explicitly cancellable function like `delay` without catching a possible `CancellationException`. All of the above is in exact parallel to thread interruption. The only difference that you may not be noticing is that `InterruptedException` is checked, so it's in your face every time. Kotlin doesn't have checked exceptions so they may be flying under your radar.
We're talking about coroutines being cancellable *by default*. And this is a problem because nobody will wrap with `NonCancelable` every time he/she uses a coroutine. But most of the code we write is not expected to be cancelled. Expected: not to be cancelled. No correct cancellation code was written. That's how most of coroutines are written because it is hard to write correct cancellation implementation. Reality: was cancellable and was cancelled.
"Coroutines are not cancellable by default." Wat... (reading docs and source code) Really, that's what I wanted to know. No problem then! Thank you! :)
Thanks! I was actually inspired by Ruby's PP module, which I use all the time. I was sick of not having the same thing in Java/Kotlin. 
You're going to have to provide a concrete example of what you're worried about. Sure, it's true that a suspend fun (e.g. [`delay`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html)) has the potential to throw a `CancellationException`. That's no different than the situation where an arbitrary function (e.g. [`Thread.sleep`](https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#sleep-long-) or [`BlockingQueue.take`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#take--)) has the potential to throw an [`InterruptedException`](https://docs.oracle.com/javase/8/docs/api/java/lang/InterruptedException.html). And the solution is the same: proper use of `try/finally` or (in Java) try-with-resources or (in Kotlin) [`AutoCloseable.use`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/use.html). Heck, the presence of the `NullPointerException` means that you have to be *very* careful. Sure, Kotlin helps to avoid NPEs... in your code. But as soon as you call into existing Java code, you have to be prepared for any method call to throw a NPE. In any language with exceptions, you have to be careful in cases where you need to "clean up" state. At the very least, you have to be prepared for an exception to be thrown from almost anywhere. The best way to deal with that, if possible, is to only commit to updating the state once any code that could fail has already finished running. 
&gt; Edit: There is no problem actually, I was corrected. Thank you! :) https://www.reddit.com/r/Kotlin/comments/aptkb8/are_all_coroutines_cancellable_by_default/egb9axv/ &gt; &gt; Sorry for the noise. 
Then that is the problem of documentation, not the problem of cancellation by default. But I have not experienced it personally (everything I've found handles cancellation properly).
TBH I have no none of the issues you described: tagless final to inject F into service, type classes to describe effects, low coupling to limit impact on the code base. My friends in other companies have similar experience: the more we move away from mutability and non referentially transparent code, the easier it is to maintain it. From this point of view IO is a way to easily enforce safe conventions on the codebase (especially with linting tools forbidding you to do workarounds). So far the only bugs we have are coming from the parts where we didn't put strict conventions yet or from bugs in the specification. All of that in a setup where half the devs didn't worked with backend before. I cannot imagine how we could achieve such reliably using typical JEE approach.
fantastic idea! [added](https://github.com/snowe2010/pretty-print/pull/2)!
It would be nice if it was in the std, but you'd need `kotlin-reflect`. I actually got the idea from Ruby's `PP` module, where it is in the std, so it's understandable that you want that. Thanks for the compliment though! Hope you use it!
I am working on implementing it. It's not as easy as I'd thought it would be, mostly due to the fact that I'm actually already parsing a DFS and then would need to generate a second tree to map to the first. I have to think over it a bit more, because all my current solutions will be very slow. 
Mocking classes you don’t own is generally an [anti-pattern](https://github.com/mockito/mockito/wiki/How-to-write-good-tests) . Hide your data access behind a repository class and mock your repository to test your business logic. An in-memory database, like H2, or infinitely better, using a dockerized version of your DB, can help you test your repository code in isolation using real jdbc calls. 
&gt; suspend fun greet(): Observable&lt;Unit&gt; I don't believe this is correct. You either use one or the other. Observables are deferred computations already, so `suspend` here isn't accomplishing anything. &gt;Nice pivot. Following your goalposts.
What are the major differences between a "hybrid" coding convention versus idiomatic Kotlin? In general, I'd say it's best to stick with the conventions of the language you're coding in unless there is a very good reason not to.
I think circular references should probably produce an error (ideally an informative one).
&gt; What's your thoughts/opinions? Code style is one of the stupidest things to get in a heated debate about. So long as a project is internally consistent, who cares? But I know people still bitch about it anyways. I don't buy any argument that it will either make it harder or easier for any developer to start working on a project given any sort of convention. The fact is that curly brace placement or tabs vs spaces is a complete non-issue. My suggestion, take whatever path leads to adoption of kotlin faster and push whatever configuration you chose as the "right way" into the project repo. Because, which is more important, adopting kotlin or being "right" about tabs vs spaces? See: https://whatis.techtarget.com/definition/Parkinsons-law-of-triviality-bikeshedding
How does it compare to dumping the object with a JSON serializer like Gson?
You could poll the lastModified time of the file every, say, 5 seconds and reload if it changes.
I think part of the issue is that they found some of the syntax a bit off putting due to being exposed to pure Java for so long - I did in the start as well. The major difference, I guess, will be that a hybrid convention would be less strict. The Kotlin convention is very adamant what it thinks is correct and leaves little up to the individual developer (which I personally think is a strength). I believe they feel that they can express themselves better with a looser convention which allows a developer to sprinkle the syntax with their own common sense rather following a rigid set of rules. &amp;#x200B; They had a particular huge gripe about having ") {" line after a multi-lined constructor/function deceleration/if statement... 
I guess I can see where they are coming from if they think the proposed convention is overly dogmatic. My tendency would be to defer to the developer's opinion and if they do anything crazy they can justify it in code review.
I agree with you - just go with the default. the differences in coding style are negligible compared to, say, needing to pick up on kotlin, and all your reasons for sticking with the defaults are solid IMO. The best argument really is the anti-bikeshedding argument of removing all doubt about what the correct style is - because in the end it really doesn't even matter all that much.
&gt;My suggestion, take whatever path leads to adoption of kotlin faster and push whatever configuration you chose as the "right way" into the project repo. Because, which is more important, adopting kotlin or being "right" about tabs vs spaces? Here's the thing: Its not "a project", its potentially a 100 projects, which have developers moving back and forth between them. On that scale it is important to have a set of defined conventions on how code should read. I agree with you that there are more important things, though that is beside the point. The point is that I don't want a 100 projects with their own style and set of rules that needs to be maintained.
We didn't go through the coding style, so their reaction was entirely based on the project I showed them - which completely adheres to the Kotlin convention. So it might have looked very rigid and strict, or at least come across that way. I think you're right that most will be hashed out in future code reviews :) 
My usual approach is to not fight the default settings, but get used to them. This way, your out of the box experience when onboarding new developers is much easier. With IntelliJ/Gradle I use Detekt with default Kotlin IntelliJ code style and it works pretty well. I also think the real issue for your colleagues is not the code style, but the whole language switch. They might feel overwhelmed and start bikeshedding over the code style because of it.
I really hate to see such debates, it limits the ideas and possibilities when coming from another language, you were used to Java code, then stick to Java. Kotlin is a different territory, not so different but still different for those who know what I mean. It's like now moving from Python to Java and you keeping the Python style, then what the hell will you learn ? 
&gt; This all sparked a rather heated/opinionated debate about coding styles Of course they did. Most the conventions are similar. Curious what differences they have issue with, but if they can't migrate or accept differences when moving forward, maybe they aren't ready. I'm just happy such people weren't involved in the creation of the language.
This has a lot of value in a lot of languages. In general: ( something, somethingElse ) is easier to read than ( something, somethingElse) especially as you start nesting. But it's not worth them debating over, it is the preferred way, they should move on from such trivial Java nostalgia.
Think you have a point about the language switch - for a couple of them Java has been it for most of their careers. Think I might suggest having a Kotlin introduction course - just to go over the main differences and such. Hopefully some might be more open to it that way. 
I think you might be on to something here. Kotlin is different, but not different enough to spark a "wow, we need to change some of the things we've been used to". By being so related to Java it might have the misfortune to give the, in my opinion, false idea that it also can be written as such. 
Hehe, I think a lot of very strongly opinionated people was involved with making the language - and that they probably had more intense debates over minor syntax stuff than we ever did :) Though I think Kotlin has been better for it. &amp;#x200B; That said, yes - such arguments where there are no "correct" answers can be tedious. Passion sparks such things I guess. Spaces vs tabs anyone? 
Switching to Kotlin from Java issues i never had: - Endless try catch (sealed classes are here) - null pointer exceptions, so far my apps hasn't had that crash yet - less code for classes (gets, sets ..) - extension functions and properties (man I love those) - no checked exceptions - smart casts - delegation - contracts ? Oh and the best so far: coroutines 
The removal of "this is how I think it should look" argument is appealing to me. Though some devs might think its rigid and appealing, which I disagree with, but that's neither here nor there. That said I think it matters - to a degree. When you have a bunch of different projects and a bunch of different people working on the different projects such things does matter. It won't necessarily make or break the world either way, but it will make it way easier to pick up a project in someones absence if it largely reads like the others. 
Personally I have never been much of a Java fan. Originally I came from a C# world which has had massive work put into it the last 10 years. By comparison Java feels outdated - syntactically, the language itself works fine, but I feel it lacks "grace". Switching over to Kotlin has been a refreshing experience and it's way more fun putting things together with it, due to no smart part the points you mention above :) &amp;#x200B;
I am considering that, especially due to how difficult it is turning out to do a DFS within a DFS... 
It's not really going to look the same. JSON serializers don't output the class/type (in general), and they format stuff in, well, JSON. I don't think JSON is a very good way to display objects, even though it's very good at transmitting them, which is why I wrote this library. You can actually take a look [here](https://github.com/snowe2010/pretty-print/tree/master/src/test/kotlin/com/tylerthrailkill/helpers/prettyprint) to see a ton of tests and the output from the resulting objects. 
You can use the Edutools plugin and do the Kotlin Koans from IntelliJ
Curly brace placement does matter in Kotlin because it can actually change the meaning of the code. The opening brace should always be on the same line otherwise you'll get some nasty surprizes which will be very difficult to locate.
Use the official style guide for 6 months with the understanding that all contributors will be able to vote on the topic after 6 months. Make it clear that the majority vote will win regardless of the result. You can also break down the concerns into separate votes.
Is it possible that some of your colleagues *are* quite fond of Java overall, and have been sold on the premise of Kotlin being a "better Java"? That could explain why they are on board with the parts of Kotlin that are clearly an upgrade over Java, but not with things like coding conventions that are mostly just "different" rather than objectively better.
&gt; Here's the thing: Its not "a project", its potentially a 100 projects, which have developers moving back and forth between them. On that scale it is important to have a set of defined conventions on how code should read. I disagree. I work at a company with hundreds of projects. We have a coding standard, but it is hardly universally applied (even within the same project). I've never seen anyone get tripped up because one project strictly or no so strictly follows the company style guide. &gt; I agree with you that there are more important things out there, though that's neither here nor there. The point is that I don't want a 100 projects with their own style and set of rules that needs to be maintained. Fine, so pick the style that has the least resistance to getting adopted and go from there. Nobody coming from the outside world is going to care about whatever style is enforced once it is enforced. I work at a company with hundreds of projects, many of them have different styles. And you know what? It does not impact my day to day coding in the slightest. The only time I've ever been affected by it is when some style nazi comes in on a code review and bitches about my code not perfectly following whatever style rule they want enforced in their project. Otherwise, it is a complete non-issue.
Good point. My point still stands that debating style rules is a huge waste of time.
Yeah, I think you'd need to keep track of every object visited to reach the current object, and then barf if it sees it again. It shouldn't be a problem if the same object appears twice, eg: data class Foo(val a : String, b : String) val str = "Hello!" val f = Foo(str, str) Note that the `str` object is referenced twice by `Foo` but this isn't a problem because they can be reached independently of each other.
Ok, so the output of your approach will always be valid Kotlin?
Yeah I already have a test case to make sure I handle that correctly. I don't know if I've pushed that branch yet though. I have several options, but my initial consideration is to use a DFS with the three colors, but use a nullable boolean instead. `null` if the node hasn't been visited, `false` if the node is still being processed, or `true` if the node has been fully processed. But the problem is that I need to compare objects. I can't compare by `hashCode()` because kotlin data objects will use the same `hashCode()` in many cases. I believe I have to do actual object equality, which means maintaining a list or map of all the nodes in the current branch, which will blow memory out of the water. And then recursing through to check them adds another layer of slowness. I've thought about passing a Deque of the current objects recursively down, and then comparing the current object to every object in that Deque, but that will be insanely slow... If anyone has any better ideas, I'm very open to PRs for this. 
oh no, not at all. kotlin doesn't use `[]` or `{}` for list and map creation so it would break right there. Is that a use case for you? 
For some reason people seem to take the conventions from JetBrains as gospel. On our Java projects we started from the conventions provided by sun/Oracle and tweaked a few things to make it our own. We're taking the same approach with Kotlin.
I've retired from a few decades of programming. I've never been a Java programmer and am only just starting with Kotlin for some retirement fun. With that out of the way, let me try to justify using the defaults of your editor. Every language has idiosyncrasies. Every update to language or editor introduces potential changes. Every competent developer (in my experience!) can relatively easily cope with reading and understanding code written in a reasonably consistent style even though there may be significant differences between bodies of work from different people, languages, and editors. Even great programmers can have difficulty manually maintaining appropriate styles when switching languages using an editor that has no default styles. Maintaining a coding style via custom settings in the editor is extra work. Default editor settings are usually a very good approximation of idiomatic style for the language in question. Taken together, my experience is that deviations from defaults adds work without compensating benefits. My experience is that even when people are using different editors that have different defaults, the differences are minor enough that most people can handle it just fine. If someone is using an editor that has no defaults for the language in question, set it up to match a popular editor that does have defaults and make sure the profile is saved and backed up. My 2 cents. 
First of all, thanks for arguing with different views than myself - that is exactly what I was out after. &amp;#x200B; Now, I want to acknowledged a couple of things before going on: * Somewhat seasoned developers isn't tripped up by different styles. It can take a couple of seconds if one open a horribly formatted file, but for the most part its fine. Jumping from technology to technology or style to style is, as you say, a non-issue * Seasoned developers has (for the most part) a sense of what is good code, and what is less so - both in structure and layout * I think that coding styles do matter. Code should be written in a clear, explicit and in an expected format for better readability. If we can't agree upon this then I think we might be at a deadlock :) So, this is how I interpret your comment, and sorry if I get it wrong: Its mostly fine when you/your team is doing your own thing. You get work done, not being tripped up by some of the devs' quirks/way of doing things. It is all good, unless someone else disagrees (style nazi) with how it is written/styles? Isn't that an argument *for* having a common style in the first place? With a style you wouldn't loose your ability to get work done, but if there was someone disagreeing (style nazi) you could always point them to the answer and tell them to bugger off. Sure, it might be a minor improvement in your particular case, but others might find other values in it. All in all it seems to be a positive thing. That said, what's above is the discussion of whether or not a company wide code style is even relevant in the first place - and I'd argue yes. As for your thoughts on "least resistance", that is something to consider, though I'd worry about how many of these systems will look 10 years in the future.
&gt;Curly brace placement does matter in Kotlin because it can actually change the meaning of the code. &gt; &gt;The opening brace should always be on the same line otherwise you'll get some nasty surprizes which will be very difficult to locate. Interesting. I didn't know that. Is there a simple example that demonstrates this. (Side note: I've never been a fan of languages that give syntactic or semantic meaning to typography or coding style. I'm of the opinion that the compiler should produce the same code whether it's on one line or many, indented or not. Typos are already a big enough problem, at least for me, that expanding the 'error space' seems inadvisable. That doesn't mean I can't or won't use, for example, Python, just that I think there must be a better way.)
Excellent - that is something I want to hear about! I totally agree. JetBrains isn't the factual correct answer. Java's code convention was written in the age ol year of 97. Kotlin on the other hand comes with a straight forward and extensive description about what its creators thinks is correct, and most (if not all) being reasonable. Therefore I genuinely wonder: * What are your arguments for deviating from the norm? * Is this a looser way of following the style as cogman10 describes elsewhere in this comment section, or is it a company wide change that all devs must adhere to? (Basically, is it a formal change or an informal one based on case by case?)
Hmmm, looks interesting. They also have an interactive website outside the plugin as well which can be used as well. &amp;#x200B; &amp;#x200B;
This is a bike shed. I think you are right. Using the defaults is preferable. But learning new style conventions is very easy unless they are terrible. If this conversation took more than an hour, it's already taking too long. Flipping a coin and getting back to coding would be a better use of everyone's time.
Oh, hmm, no - It's not a use-case for me right now - although there are times it would have been useful. I assumed that was the motivation behind the current syntax, but you're right - Kotlin doesn't support [] or {} in the way you're using them.
Yeah, the defaults argument has a lot of weight to it. Less fuzz to manage with more consistency. Quicker setup and less mocking about. 2 valuable cents in my eyes.
We took the approach suggested by someone else in this thread, we did things the JetBrains way for awhile, got together and hashed out what we liked and what we didn't. I don't think we ended up deviating that drastically - one thing I recall that changed from the "norm" is we don't place else on the same line as the it's closing }. That seemed to be universally disliked. No real justification for doing it besides all the devs wanted to tweak it to our liking. We did the same for Java. The conventions are shared company wide but each team within the company is free to adhere to w/e they'd like (and w/e language). I also teach a class in Kotlin. There I require that students use the JetBrains conventions.
Certainly could be the case. They seemed to have issues getting out of the "Java mindset", which is understandable if one hasn't done much in Kotlin.
Yeah I don't think I'd like to put that in, mostly because it will no longer be a 'pretty print'. I'd like to have it just be a printing library. Maybe there's another solution if someone ever needs that functionality. 
Yeah, the "} else" is complicated issue. Personally I find it okay due to the indentation making it obvious that its "doing" something different. Thanks for your thoughts though, maybe we'll do some trial with some projects and more devs and see what needs tweaking is a better approach than just throwing a standard out there :) &amp;#x200B; &gt; I also teach a class in Kotlin. There I require that students use the JetBrains conventions. That makes me very happy.
It's sad that people waste their time in such a way, because it's bikeshedding - every unexperienced person should first adopt the standard of the platform, learn enough and THAN at earliest try to adjust. Forcing a certain code style to convince people how nice kotlin is also a bit.. weird. Maybe people at your company should start being proper Software engineers and start learning new things :) I didn't experience Problems regarding a codestyle, but some paradigms that are not too easy to grasp for beginners, like using 'it' in lambdas or higher order extension functions. It took a few nice examples to convince them that those features can lead to very nice code. But my colleagues are willed to learn how it works :)
I already use the repository pattern, so I suppose I could just use that. Thanks.
I figured there has to be a better way than using a real database. Significantly faster as well too. It makes sense to test it this way, but also a little gross. 
Makes sense, I already use the repository pattern, so I figure I should use that anyway. Thanks :D
Why don’t you collect System.identityHashCode() of every object? For a thousand objects it’s about 4kB... It’s not that bad. Although it may require some time to check if an id is already in there, but i think It’s negligible compared to string operations.
In essence, kinda. At our company we have company wide code styles for each language in use. To be allowed to use a new language one has to go through a long process of getting it approved and so forth, and at some point a coding style has to be made. It is not about using a code style to convince people to like Kotlin, but its more a company policy that we need one before we can truly use Kotlin. Why it is set up this way, and whether or not that is a good policy to have is a different discussion, but also entirely out of my hands. &amp;#x200B; This started out more as a "Hey, this is how we envision things will look in the future", which they didn't respond well to. No forcing has happened at this point. That said, your point about their response being due to lack of experience with Kotlin is a valid one. 
This is going to seem a little draconian, but pick a code formatting tool that formats on save and end the discussion there (ie. something like `gofmt` for Go or `black` for Python). People will get upset over some of the choices it makes ("why does Go use tabs? aghhh"), then give in once they realize everything is standardized and that using an autoformatter is designed to preempt and end any potential conversations/whining about code styles. 
We use [ktlint](https://ktlint.github.io/) and [detekt](https://arturbosch.github.io/detekt/) to enforce a uniform code style. Developers are allowed to use `@Suppress()` annotations if they believe a style rule shouldn't apply in a certain context.
if you can't auto format you're just waiting time. 
Sure, here is a horrible example that I came up with on the spot: class Person(val age: Int) { fun age(compute: () -&gt; Int) = compute() } fun main() { val person = Person(age = 7) val age1 = person.age { 3 } val age2 = person.age { 3 } println("Age1: $age1, Age2: $age2") } So it produces different results when the brace is on a new line. There are cleaner examples but this is the first thing that popped in my mind to illustrate the point. The main issue is that semi-colons are optional so new lines can have semantic meaning resulting with the brace being treated as an unused lambda.
Well, to be honest, I have never heard of `System.identityHashCode()`. This seems like the best way though. I'll see what I can do. Thank you for the help!
1. Enable ktlint (and ideally also detekt) using defaults. 2. Enjoy not arguing or thinking about format because someone else already thought it through for me. Why bother enforcing? I want my git history to show code change. Not format change.
The Kotlin plugin ships with a predefined formatter. And a predefined Gradle [property](https://kotlinlang.org/docs/reference/code-style-migration-guide.html#in-gradle) for lint warnings when that format is not met. We could fight it and define our own formatting logic, but is that effort really worth it? When you can just rally around a common convention that was decided by people more experienced than us who have heavily researched this? It's also a mistake to expect that Kotlin code and Java code need to share a formatting style. You write Java differently than you write Kotlin. They're also different files, so it's simple to have different formats. Wherever possible, in a mixed codebase, Kotlin code should FEEL idiomatic when calling it from Java (capitalized enums). I was a huge fan of 2/2/4 formatting, but Kotlin coding conventions use a 4/4/4 formatting. (One of the reasons for this is that so properties in the primary constructor line up with properties defined in the class). I was really upset that I was going to give up my 2 space indent.... And now I don't even care. Whatever formatting you agree on, your team will grumble about initially and then completely forget this was ever an issue. tl;dr: don't reinvent the wheel, leverage the built in infrastructure around the official coding conventions 
Makes sense. Separate question: How does your library handle wrapping long lines of text?
fantastic! another test case to add. It won't handle them at all right now, though that's a good use case. Since this library works for both kotlin and java I'm not sure if using the multiline string syntax would be best, since I'm currently using the regular `""` syntax for regular strings. What do you think? 
Well, be careful with that thinking. If you invoke pretty much *any* function that would suspend your coroutine (e.g. [`SendChannel.send`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/send.html), [`ReceiveChannel.receive`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive.html), [`job.Join`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html), etc.), then you have to contend with `CancellationException`. And if you never invoke any function that would suspend your coroutine... then why are you using coroutines in the first place? Coroutine cancellation is cooperative. If your coroutine never cooperates with the cancellation mechanism, then your coroutine can never be cancelled. But if you call almost any `suepend fun` provided by kotlinx.coroutines, you will (indirectly) be cooperating with the cancellation mechanism. 
You're conflating `Thread.stop` with `Thread.interrupt`. Stopping a thread is unsafe because the thread gets no say in the matter. Interrupting a thread gives the thread the ability to e.g. release shared resources. Cancellation in Kotlinx.coroutines is more like `Thread.interrupt` than it is like `Thread.stop`.
Hmm, well - if we were following Kotlin's syntax the answer would be a """, so perhaps - where the answer isn't obvious - we should emulate Kotlin syntax?
From a very general perspective, I feel that each language should have its own set of coding styles and people should learn the coding style as the learn the language. The reason is that usually the coding style has some connection to the language itself. There are reasons for it and they often make it either more readable or it just makes things flow better. That being said if people are programming in multiple languages at the same time, I can see wanting to stick with a single standard for some things (like variable naming conventions for example). Sticking with "the standard" is good for making it easier for others who know the language to ramp up whether new staff or internal transfers. Keeping old standards is better for ramping up existing staff or when staff is working in multiple languages at the same time (e.g. working on two projects at the same time).
I will play the devil's advocate and say that coding conventions are important and worth fighting for. That's why you see more and more languages adopt a standard formatting and code style to the extent that the compiler will refuse to compile (Go, Elm). I really hope more languages do this, yes its opinionated, but it prevents all these kinds of arguments and people learn really fast not to fight the compiler.
Bought the MEAP, love it! Thanks for the recommendation.
I'm truly sorry for you, because (probably like you yourself too) don't think that this process makes any sense :) What bothers me is, that codestyle is really soooo unimportant if you talk about "how could the future look". If there's a bunch ob Java (or other platform) developers, and you show them a very reliable, sanely feature rich, readable language like Kotlin, how dare they complain about such an unimportant thing like codestyle. And even if it would be important - how could any of them ditch the standard, with no experience in the language at all. That's unprofessional.
I have figured out how to go about this. In case anyone is wondering, here is how: &amp;#x200B; `val argument = "some argument of type matching the non default constructor"` `val kClass = Class.forName("class.path.Whatever").kotlin` `val instance = kClass.constructors.first().call(argument) as Whatever`
Here's my two cents about trying to adopt some Kotlin formatting styles into Java. TL;DR – Don't try to define common code style for "similar" languages when they actually have many differences. It's more pain than having separate code styles thoughtfully designed for specific languages (with good understanding why things are formatted a certain way; I believe JetBrains put a lot of thought and community feedback into the Kotlin code style). We don't use Kotlin in our organization (yet), although I like some of the official coding conventions of Kotlin, so I tried to suggest some of the formatting styles for our Java code base as well. We do standard code-review of these things as well (code style description in Markdown and formatter config files all stored in Git), so to propose some of the formatting changes I tried to show some examples of Java code formatted with the Kotlin-like code style. It was all about the \`) {\` put on a new line instead of the last line of a wrapped block of parameters (typically method declarations). While writing the examples, I found that this formatting approach is not suitable for Java since there might be a \`throws\` clause between the closing parenthesis and the brace. The \`throws\` clause can contain several exceptions, too (not a good design, but you need to consider everything when designing strict code style). So in the end we decided not to adopt this. It's great in Kotlin where you don't declare \`throws\` on methods, but in Java it brought more formatting issues than it actually solved.
KotlinPoet can also be used to generate code: https://github.com/square/kotlinpoet/blob/master/README.md
I'll run that later, to see the effect. But as someone who got his start with BASIC on the VIC-20 and originally cursed the need for semicolons, I should have realized that optional semicolons might imply different behavior with brace position. (Of course, when I moved on from BASIC, I also cursed the braces! 😀) Thanks for the reply. And the warning!
Do you use a frontend lib like react?
What are you using this for? Reflection should only be a last resort. 
You will find some stuff to get you started here: https://github.com/jwtk/jjwt, however you should consider if you should outsource your login solution to somebody else, for example Stormpath, or Auth0, at least if this is in a "professional" business application. But the flow is quite simple: * 1. Verify username/password from a form. * 2. Generate and sign a jwt token and return this to the client. * 3. Send the token to the endpoint you want to authenticate against. * 4. Authenticate the token and validate the signature (not necessarily in that order). * 5. Optionally authorize against scopes in your token. Number 4 is what you are asking about, and 1 way of doing this is to check the signature against a published (and public) well-known endpoint. Your token signer then has to publish the public part of the signature it is using. I guess another way would be to publish the secret, and verify the token against that. 
Where did you complain? I got a compilation bug, a nasty one
I created a minimal reproducer repo, and submitted it to their tracker. Fixed in next release.
For a game's monster spawn table which will be populated from a server. So class names will basically be strings.
Ok, that sounds like a valid use case!
This will most likely be the next feature I release. Thanks for the suggestions!
Its seems to be a very complicated language compared to Python or Ruby, but it actually allows you to get more done with it and quicker rather than working out problems with a bit of a guesswork type of scenario, which can be a real headache and far less productive.
No, they dont use java, but the java virtual machine code afaik
If by *suffer* you mean that Kotlin could benefit as dev teams jump to kotlin because of their licensing? Then yes, I agree it could *suffer...*
Would the JVM suffer from that Oracle license issue since Sun owned that and Oracle got it in the deal?
Doubtful. Anyone can make a JVM. It only has to comply to a freely available specification. Several commercial and free JVMs exist. And a multitude of languages run on those, besides java.
Only those who continue to use Oracle's commercial JDK without paying the license fee. Those who pay, as well as those who use a free JDK (like OpenJDK) are not likely to suffer.
Hi! I implemented circular reference detection. https://github.com/snowe2010/pretty-print/releases/tag/v1.3.0 let me know what you think!
Hey! I implemented circular reference detection, let me know what you think!
I managed to implement it without throwing errors with minimal overhead. Let me know what you think! https://github.com/snowe2010/pretty-print/releases/tag/v1.3.0
I have merged a multiline fix, but I am not going to release it tonight. I'm working on a bit of a better solution for the multiline stuff and will see how long that's gonna take me. 
After the Google Oracle mess, I’m sure JetBrains thought this through. 
Oracle does not license java, oracle licenses their JVM
In theory yes, however Oracle still sues Google for building a product on a free JVM implementation (Apache Harmony than OpenJDK) , using the API of the JVM , which is a huge portion of the specification.
Thanks for commenting! And yes, this project is for a professional business application. I was thinking of generating a token on my own authorization server. That token will be generated by a [Java library, developed by Auth0](https://github.com/auth0/java-jwt)). During generating it, this token will be signed by some secret (or key, I am not sure what's more correct to use...) value. Then, by 'telling' this key/secret to the resource server, the resource server should be able to verify that this token is indeed generated by the authorization server, since that server is the only other server that has the same secret. The verification should also work using that same library. Does this logic make sense to you? Am I forgetting something?
It will. Just look at some of the rest of the comments here for the ignorance on the topic. The question is how much. 
Thanks for this. I’ve come across references to trampolines occasionally over the years and this is a clear and accessible explanation. 
Thanks :)
Thanks, nice read :) 1. Any reason why you don't mention [https://kotlinlang.org/docs/reference/functions.html#tail-recursive-functions](https://kotlinlang.org/docs/reference/functions.html#tail-recursive-functions) ? 2. Any particular reason you chose to use anonymous functions instead of true lambdas in your example(s?)? [https://kotlinlang.org/docs/reference/lambdas.html#instantiating-a-function-type](https://kotlinlang.org/docs/reference/lambdas.html#instantiating-a-function-type)
Thanks for reading and the questions! 1. I do mention it albeit briefly: &gt; In fact, Kotlin is capable of tail-recursion optimization but there is not always an easy way to express an algorithm with tail-recursion only. 2. Just to make it more readable for people not familiar with Kotlin :) I think the fact that lambdas are introduced simply by curlies can be quite nice once you get used to it, but it looks alien the first time you see it. The anonymous functions are easier to syntactically map onto lambdas from Python/ML/Java etc.
Sure. But the crux of that issue is not that Google uses a JVM for Android. It's that they wholesale copied Oracle's SDK API into their own API. And Oracle thinks that they own a copyright to that API (rather than the implementation, only).
Hm what do you mean “complicated”? I consider Ruby a rather non-intuitive language with lots of odd syntax choices. Python is simple but i would want to build big systems with it
If Oracle is right in that they own the API (according to the court), wouldn't that mean that Kotlin is affected?
The implementation is nice and clean, however I feel like it is missing a motivating example. I think the examples given would be better implemented either with loops our tail recursion with accumulators. Is there a good example where trampolining is the better solution?
No. There is no reason at all to use the Oracle JDK. Use OpenJDK instead.
After more researching, I decided to change ScheduledExecutorService to Quartz Scheduler. &amp;#x200B;
Minor error: "If `r` is `Suspend` then we force the suspension and set `r` to be the resulting trampoline." I think `Suspend` should be `Delay` there.
On point 2, the article uses the curly lambda syntax in the examples at the end; might be worth either switching that to anonymous functions or explaining the lambda syntax briefly (at which point you could, I assume, use it throughout).
I suppose the examples are somewhat contrived but I wanted to keep it really simple. In general, one can always hand-convert recursive code to iterative code (in a Turing complete language) but it is far from always obvious how to do so. It almost always involves manually maintaining a stack of "continuation arguments". This may be another contrived example, but the [Ackermann function][1] is nicely formulated with recursion as ```kotlin fun ackermann(m: Long, n: Long): Long = when { m == 0L -&gt; n + 1 m &gt; 0 &amp;&amp; n == 0L -&gt; ackermann(m - 1, 1) m &gt; 0 &amp;&amp; n &gt; 0 -&gt; ackermann(m - 1, ackermann(m, n - 1)) else -&gt; throw RuntimeException("impossible") } ``` As [this StackOverflow answer][2] demonstrates it is not super easy to convert it to iterative code (the accepted answer is wrong). But with trampolines we hardly have to think: ```kotlin fun tackermann(m: Long, n: Long): Trampoline&lt;Long&gt; = when { m == 0L -&gt; done(n + 1) m &gt; 0 &amp;&amp; n == 0L -&gt; delay { tackermann(m - 1, 1) } m &gt; 0 &amp;&amp; n &gt; 0 -&gt; delay { tackermann(m, n - 1) }.flatMap { tackermann(m - 1, it) } else -&gt; throw RuntimeException("impossible") } ``` Similarly, for binary trees, (inorder) `map` is elegantly formulated with recursion. ```kotlin fun &lt;A, B&gt; map(tree: Tree&lt;A&gt;, f: (A) -&gt; B): Tree&lt;B&gt; = when (tree) { is Tree.Leaf -&gt; Tree.Leaf(f(tree.item)) is Tree.Node -&gt; { val left = map(tree.left, f) val right = map(tree.right, f) Tree.Node(left, right) } } ``` While the [iterative version][3] is not super complicated either it is still far removed from the recursive formulation. For more complicated recursive structures it quickly becomes even more involved to stick to iteration for many operations. [1]: https://en.wikipedia.org/wiki/Ackermann_function [2]: https://stackoverflow.com/questions/10742322/how-to-rewrite-ackermann-function-in-non-recursive-style [3]: https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion/ 
Good catch! I renamed the constructors at a point and forgot it here :)
Yeah I guess you have a point. I've updated it to use anonymous function syntax throughout except the last example which is "code-golfed" anyway and provided at link to the documentation for the syntax.
1. Python Foundation owns Python 2. APIs are copyrightable 3. GraalVM implements the Python API 4. Python Foundation owns part of GraalVM
Kotlin just uses the API
Thanks! Trees are a good example.
No. Kotlin *calls* the Java API, just like any software you write in Java calls that same API. What Google did was something else. Google created what was essentially a new language, Dalvik, that looked exactly like Java, but compiled (eventually) to a different bytecode, which only runs on Android. Back then, Oracle charged a hefty sum of money to certify that a company's implementation was "Real Java", which was done by running a suite of compatibility tests. Google didn't bother doing that, because they weren't actually using Java, but something that just happened to look very much like Java. Oracle claims that creating a language that looks exactly like Java, but avoids the trademarked name, was copyright infringement. Google claims that interoperability is allowed as free use, thus allowing Dalvik to use the Java API. All of this is very arcane and in the weeds, and based on facts that aren't true anymore. Languages like Kotlin (or Scala or Groovy or Closure) don't need to be worried.
You can use both secrets and public/private keys, the first is simpler to implement, the other is more secure if you do it right. If you use a secret, you just need to distribute this to your other applications, and you should be able to validate. With keys you have to distribute the public certificate. Once you go down this path, you should prepare for rotating your secrets/keys, and be able to regenerate and withdraw them if you get a security breach. I also think that both Micronaut and Spring Boot come with "default" setups to do these things, so again I advice you not to do it form scratch :) Example of how to do it with Micronaut: https://guides.micronaut.io/micronaut-security-jwt/guide/index.html 
If you deploy on Oracle's JDK you will/might suffer, if you deploy on Corretto, Azul, AdoptOpenJDK or OpenJDK you will not, the same as for Java, btw. The licensing is not the language, but the JDK. 
Looks good to me, good job! :)
Thanks! Let me know if you find any bugs or think of more test cases. 
Do elaborate, please. 
Their licensing has nothing to with whether you use "bytecode" or not, yet people seem to think they are safe because Kotlin "only uses bytecode". What matter is which runtime you use. If you Google "download JDK" the first link you get is something that will cost you a lot of money if you install it on your production server and Oracle finds out, whether you run Kotlin on it or Java. This will especially hurt teams with large existing legacy applications that are tied to already deployed JDKs, but also naive companies starting a new project thinking Kotlin is "free" to use in this way because developers tell them this. It can be avoided sure, but there will be mistakes and incompetence (where someone warns about it but no action is taken), and naturally this will hurt the businesses using Kotlin that do that, and by extension this will injure Kotlin's reputation.
Right, I see your point. Of course if people actually don't know the difference between the language and the JVM, and think that Kotlin as a language is free to use regardless of JVM, then there's trouble. Maybe I'm a bit naive in thinking that professionals actually know these things. Although, I think the "Kotlin damage" is quite small whereas the "Java damage" potentially could be bigger. &amp;#x200B; My hypothesis is that since Kotlin still is very far from mainstream, people (companies) will know to use OpenJDK by the time it becomes, if it becomes, an actual choice (sure, there are projects that use Kotlin but it's really not a common option yet). And, in case of companies that want the extended support, they will have no problem paying for an OracleJDK. &amp;#x200B; So I still think that the damage for *Kotlin* will be negligible, more or less - i.e. I don't think it will play a noticeable part in Kotlin's future story. Time will tell :)
What's wrong with the `tailrec` keyword?
`tailRec` is great but *only* works for tail-recursive functions: &gt; In fact, Kotlin is capable of tail-recursion optimization but there is not always an easy way to express an algorithm with tail-recursion only. The article goes on to show how to use trampolines to express general recursive functions. In languages without tail-call optimization, trampolines can also be used to essentially achieve the same effect without compiler support.
Is Kotlin your first language or are you coming from some other background? It took couple of weeks to convert from Java 8 for us (including junior team members who love Kotlin) to learn idiomatic (shorter/neater) methods that help enormously
&gt; My hypothesis is that since Kotlin still is very far from mainstream, people (companies) will know to use OpenJDK by the time it becomes Well here we are, "far from the mainstream" in the Kotlin sub-reddit. Let's see what people are saying and voting: top comment: &gt; No, they dont use java, but the java virtual machine code afaik second comment is more helpful: &gt; Only those who continue to use Oracle's commercial JDK without paying the license fee. Those who pay, as well as those who use a free JDK (like OpenJDK) are not likely to suffer. Third also. But with 4 we are back: &gt; If by suffer you mean that Kotlin could benefit as dev teams jump to kotlin because of their licensing? And 5: &gt; After the Google Oracle mess, I’m sure JetBrains thought this through. Now imagine people having learned this, walking into their crufty IT department and announcing "we need to switch to OpenJDK!". That doesn't mean that will actually happen.
Have to say thatI really like this. It takes a boatload of the magic out of the whole test code lifecycle, and the reusability of test cases in different contexts looks like it could be really powerful given time.
Yeah, but that's actually the problem of utility functions, it has no direct relation to the problem I raised in the first post.
It's more a question of why you are using coroutines if you do not intend to suspend them. 
For me the ktor website was sufficient. On start.ktor.io you can generate the base of an application with examples of the plugins you've selected. As for best backend framework for kotlin, I like ktor a lot, but Spring (which has decent kotlin support nowadays is used in production a lot more. If you want do make a backend the kotlin way ktor is your best choice though 
i see . thanks
shameless plug, I just posted on r/kotlin, but I think it will help you: [https://github.com/ninrod/exposed-ktor-jwt](https://github.com/ninrod/exposed-ktor-jwt) &amp;#x200B;
if you don't need real time data you can just write your data to a file and feed it to gnuplot or something similar. 
Why is this not causing mass panic ?
I think (not completely sure) that reply 4 is correct. You shouldn't launch your coroutine that way on an Activity.
Can someone comment on the severity and frequency of this? Does it eventually get rid of the reference to allow the GC to reclaim it? I was getting ready to transition my side project to coroutines so any additional context would be appreciated.
Avoid global scope: https://link.medium.com/1bWYFKzblU 
There's nothing to be panicked about. There is an API in corutines to clean up resources. Read about structural concurrency and call cancel when task and it's resources are no longer needed.
Because they're doing it wrong. You should only launch a globalscope coroutine if it is *actually* globally scoped. This is like making a large global array, and then saying that it's a memory leak because it doesn't get deleted after you've used it. The compiler can't guarantee in general that a global coroutine is "over" unless it's canceled (it's equivalent to the halting problem, if my informal mental walkthrough is correct), just the same as the compiler doesn't guarantee that the hypothetical global array is never going to be used again. Okay, maybe it's a bit of a fast and loose analogy, but the point is, if you want a local coroutine, create a local scope to launch it. Any coroutine launched with GlobalScope should either last as long as the whole program or else be manually canceled.
Thank you for the explanation. It wasn't obvious from the docs. 
Seems like a simple problem. This girl uses processing to plot a graph. Not sure if it's related to your problem. https://www.youtube.com/watch?v=C_gyGXWIgHY Processing is a Java framework (hint: which means Kotlin can use it too)
You missed a framework... 
And it is. I guess people don't really catch up on best practices and then the problem is in the language 
My best advice would be to slow down and learn about the framework rather than take your project initiation through one specific IDE (even though they are the inventors of the language). Take your time and settle on something that makes sense for the usecase, doesn't necessarily focus on Kotlin especially with JS.
There's too much to debug from that one image without more information.
The issue isn't about knowing in general whether coroutine blocks are going to continue executing. The issue is that there are specific circumstances where we know for sure (e.g. end of the block has been reached) that the coroutine block has finished executing but the associated resources are not being freed. You "shouldn't use GlobalScope" just doesn't cut it. There are many scenarios where it is desirable to start tasks in a long-running background scope.
Do you have `jcenter` repo? ``` repositories { jcenter() } ```
Agreeing 100%. I am quite shocked that resources are not freed before canceling the coroutine. I mean this single drawback is huge. What if I repeatedly load big network data in my scope. Will my app crash if I don't cancel after every call?
Thanks for all the lovely GitHub new stars! I've been adding some more documentation - please let me know if what is there is understandable.
The problem here is not the global scope (even though you should be mindful of that in general). &amp;#x200B; The problem is that no matter the scope the resource is not released for garbage collection after the coroutine has run to completion. If we scope it to the lifetime of the activity there is still a memory leak as in we will get OOM if we launch it multiple times while the activity is alive all the bitmaps from previous calls cannot be cleaned up due to still being referenced. OP even provided an example of this further down. &amp;#x200B; I am by no means an expert but I would definitely not expect this behavior and do not really understand how to avoid it.
While launching it in global scope is certainly bad practice this is actually not the problem. Even if we scope it down appropriately we will still get an OOM after launching the coroutine multiple times while the scope is alive. Op even provided an amended example further down. I would certainly not expect this behavior and I am pretty sure calling `cancel` after every routine has run to completion is not the solution. Not sure this is even possible in the general case. &amp;#x200B; And what is with the downvoting of a legitimate question?
I don't understand, I've seen the linked issue on the thread but... the same thing happens if you use threads? What I'm missing, then? Would that affect short lived coroutines?
This has nothing to do with Activity leaks, as the Bitmap has no reference to the Activity. It should be eligible for GC immediately after the suspend function has completed. The Dispatcher is keeping a strong reference somehow to the coroutine after it is no longer active. I suspect someone forgot to null out a reference or clear out a Handler message in the Android dispatcher implementation.
This is not something we should have to manage ourselves when references to local variables are being held *after the coroutine has completed*. What you say makes sense if the coroutine is long-running, which is not the case here.
There is no general graphics library, most of it requires specific platforms. If you want a simple desktop one and you prefer ease of use over performance, I recommend using the java version of processing.
As others have pointed out, this is not the heart of the issue. You shouldn't launch your coroutines that way, but you also shouldn't expect object allocated in your coroutines to stick around after it completes.
How so? Objects allocated in a thread should become eligible for gc once they're no longer referenced.
That was a really interesting article. It got me thinking: where would you actually need GlobalScope? It seems to me that "withContext" makes way more sense in any use case.
Maybe you want JFreeChart? http://www.jfree.org/jfreechart/
I tested [this code] in JDK 11 with coroutines, then I changed the code to threads, both of them had the same output. Probably because the `System.gc()` is just a suggestion, it isn't getting garbage collected in time... maybe.
Do you please have a constrained example in a github repo that we could test against? I'd like to know whether this is a behavior of the suspension system, or exclusively of kotlinx.coroutines.
This is a dud, check out [Elizarov's response](https://discuss.kotlinlang.org/t/unavoidable-memory-leak-when-using-coroutines/11603/11). OP analyzed a heap dump that doesn't differentiate between reachable and unreachable objects, and didn't ensure he performed GC before dumping. There is in fact no memory leak.
It's actually nothing, a mistake in the measurement. Bitmap wasn't reachable after all.
Why is it an extension then? Why not `FooUtils.method()`?
I don't get what you mean. Kotlin has no static functions. Can you provide an example of what you want to achieve?
&gt; I don't want to call the extension function directly on the object So it sounds like you don't want an extension function. That's the entire point of extension functions. So you just want to write a static function. Here is how you'd make a static function visible to Java: https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html#static-methods
Maybe you are looking for a method defined in the companion to object in combination with @JvmStatic
This is the wrong approach. Your library should allow Kotlin usage that is as clean as possible otherwise you won't get much adoption. You're never going to have usage that's identical in both unless you try really hard to make it horrible because Kotlin usage is much cleaner and safer than Java. So instead of trying to make the usage the same, make it as clean as possible for Kotlin usage and bolt Java compatibility on top (eg. via annotations)
[https://github.com/JakeWharton/RxBinding/blob/master/rxbinding/src/main/java/com/jakewharton/rxbinding3/widget/TextViewTextChangeEventObservable.kt](https://github.com/JakeWharton/RxBinding/blob/master/rxbinding/src/main/java/com/jakewharton/rxbinding3/widget/TextViewTextChangeEventObservable.kt) &amp;#x200B; So, here he uses an extension function on TextView, right? But when you want to use this from Kotlin, you call RxTextView.textChanges(view). I'd like that same consistency for Kotlin and Java in my project. I don't know how he achieves it here though. I have the @file stuff at the top of my file as well, but when I import my library, it's still using extension functions instead of the RxWhatever way.
Extension functions aren't available in java as methods on the class, so unfortunately that approach is just never going to work. But you can still call the methods directly, as outlined here: https://stackoverflow.com/questions/28294509/accessing-kotlin-extension-functions-from-java
Yeah seems kinda weird since the injected class actually knows how it gets injected.
Looks rather like the service locator pattern than di, doesn't it?
haha Kluent?
One could argue that all major di frameworks do this at the moment though. I like the simplicity of this approach, I would try it if the author kept on developing it.
Here is the example OP provided after learning about global scope: [https://discuss.kotlinlang.org/t/unavoidable-memory-leak-when-using-coroutines/11603/8](https://discuss.kotlinlang.org/t/unavoidable-memory-leak-when-using-coroutines/11603/8) &amp;#x200B; (Disclaimer: I have not tested this myself.)
It seems a bit confusing to me despite the "simplicity".
I’ve been dealing with a data generation library, written in Java, that’s used to create nontrivial load. While I wouldn’t necessarily randomize everything like they are here, I could easily combining this approach with histogram data pulled from metrics. That should be pretty interesting for a lot of data. And fast. This is pretty awesome. Mostly because you can generate tons of nontrivial load, and it may be shaped similarly to production, but without any of the data privacy issues you get from trying to have developers analyze canaries, etc. 
it's wildly subjective.. I for one can get pretty quickly going with ruby/python kind of languages anything Java-replacing (scala, kotlin) will make me trip tenfold, and I do appreciate kotlin a lot (thanks for the concise, nullcheck, fp features). But still it's wildly less intuitive to me. I think it's due to the linguistic paradigms at hand. Tiny dynamic languages were coder ~pleasure based. - repl friendly (kotlin has a repl but jvm causes slightly too long responsiveness) - short syntax - literals - live introspection It's a different mindset.
All the major service locator libraries masquerading as DI, sure. The DI libraries certainly don't, though.
JetBrains, a pretty big company, maintains it. I have no numbers, but giving that Android officially supports Kotlin, and giving that the language is very popular, I’d say you don’t have to worry.
[At least 50.](https://kotlinlang.org/docs/reference/faq.html#who-develops-kotlin)
Kotlin is open source tho... [https://github.com/JetBrains/kotlin](https://github.com/JetBrains/kotlin)
I think in [this](http://talkingkotlin.com/libraries-with-roman-elizarov/) podcast, Elizarov said there are 6 people or something actively working on the core libraries and things, and they plan on ramping up man power on this front. I maybe wrong, but that's what I understood
From Hadi's podcast, my understanding is that not many people actually contribute.
However many engineers Kotlin has had over the last decade, Java must have had a tenth of that, if we compare the rate of progress. In 2009, when it was announced that Oracle was taking over Sun Microsystems and therefore Java, many of us feared that Oracle would strangle it for short-term business goals. A decade later we can see the fears have materialized.
That doesn't tell you anything. Java is open source, too, as are other big projects like Firefox or LibreOffice. On the other hand, there is lots of failed open source software that you never heard about and where nobody contributes. For example the Kotlin Plug-In for Eclipse or Dokka, the Javadoc-Like tool for Kotlin have very few contributors and very bad support while being open source. Do not expect people (and companies!) to contribute just because it's open source. For example the company I work in may tell me to program something in Kotlin, but when I tell them that I need to fix several bugs in Kotlin first, on company time obviously, they will be very unhappy and tell me to use Java instead.
&gt; A decade later we can see the fears have materialized. Yes, a horrible future we are living in indeed, all those projects that Oracle supports! 
I heard on the podcast that 6 people are working on Kotlin JS only. 
From that you can see there are at least 100 names that have contributed commits to it (I'm not sure if GitHub limits it to the top 100 or not though, but it seems a remarkably round number if not). And even #100 on that list has contributed 8 commits - though that's kinda tiny compared to #1's 4,405 commits! https://github.com/JetBrains/kotlin/graphs/contributors
Yeah sorry that might've been it! Not 6 people on all of Kotlin. 
Isn't this a no-brainer because with Java you're stuck with Java 7 ish?
There really aren’t a lot of downsides to Kotlin when compared to Java. If you manage to find something that is better suited for Java (I haven’t) you can still use Java and Kotlin in the same project.
If you're billing by the hour and want to make everything seem overly complex with boilerplate code everywhere then Java would be the better choice. Kotlin leads to cleaner code with fewer defects resulting in the assignment getting done sooner which might be a bad thing if you want to make an assignment last as long as possible 😁
Java is safe and robust if you ignore the NPE problem exist. Null safety makes Kotlin a no brainer, combine that with auto getters and setters for properties that eliminates a ton of boilerplate good I don’t know why you would java except for familiarity. Even then, the languages are similar enough that learning Kotlin is not a big leap. Also, if that is the title of your article you better make a decision by the end of it. Sorry if that sounds a little heated but just ran into another NPE in a java dependency that I use. 
The former will return null if it can't cast obj into Class, the later will throw an exception if it can't cast. Val s: String = "hello" (s as? Int) == null //true (s as Int?) //Throws exception 
Yes. And Dokka for example has only 4 people with &gt; 8 commits and they are all Jetbrains employees. And after June 2018, basically nothing changed at all.
Why wouldn’t you use a Kotlin sequence?