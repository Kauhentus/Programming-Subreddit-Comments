***project_kotlin***: &gt;&amp;#91;2011/12/26&amp;#93;&amp;#91;14:17:10&amp;#93; &gt;[&amp;#91;Translate&amp;#93;](http://translate.google.com/#auto|auto|A public web%2Dbased preview of Kotlin will be opened on Jan 10th, 2012. Merry Christmas and Happy New year! 'google translate this tweet'): A public web-based preview of Kotlin will be opened on Jan 10th, 2012. Merry Christmas and Happy New year&amp;#33; [&amp;#91;This comment was posted by a bot&amp;#93;&amp;#91;FAQ&amp;#93;](http://www.reddit.com/help/faqs/tweet_poster 'tweet_poster FAQ')[&amp;#91;Did I get it wrong?&amp;#93;](http://www.reddit.com/message/compose/?to=tweet_poster&amp;subject=Error%20Report&amp;message=[Oops!](http://reddit.com/r/Kotlin/comments/nra5w\)%0d%0dPlease leave the subject and this link unaltered, but feel free to add a description here. 'report an error')
Sweet. One step closer to something along the lines of val user = User.find(User::username == "john" &amp;&amp; User::password == "hunter2") 
Cool! was about to start hacking something myself, glad I checked first...
What is currently the best way to do mocking with Kotlin? My codebase normally rely on mocking practice (mockito) combine with unit test. 
It would be time to refresh the Kotlin roadmap. And indicate some sort of a timeframe when it might be usable in production.
I've used it for about a year in production (Android Apps). It works fine. I like their approach of not announcing some arbitrary timeline. Let it bake properly. There's no need to rush it to 1.0.
Kotlin aims for 100% compatibility with Java libraries. So keep using the libraries you've been using.
What about intellij built-in code analysis? 
Unless I'm missing something, the only thing I can get it to do is tell me about spelling mistakes that aren't spelling mistakes - things like it claims "springframework" is spelt wrong... Ideally though, I'd like something that can be built into the Maven build, and generate Site reports and possibly even fail the build if necessary...
I know, and I tried that, and all I got was spelling suggestions. (What I did was right clicked on the src/main/kotlin directory, then went Analyze -&gt; Inspect Code from there. If I do it from the Analyze menu then I get lots and lots of inspections on all the included Javascript, none of which was written by me...) I was assuming that these things didn't exist yet, but you don't know without asking :)
At the moment, there are [no known] (http://devnet.jetbrains.com/thread/455229) solutions for FindBugs-like static analysis for Kotlin. Although, if you have the Kotlin plugin installed in IDEA, you should be able to see a few Kotlin-specific inspections under Settings -&gt; Inspections that correspond to the inspections available in this [plugin directory](https://github.com/JetBrains/kotlin/tree/master/idea/src/org/jetbrains/jet/plugin/inspections), although they are very simple. Now with TeamCity, you can configure [failure conditions](http://confluence.jetbrains.com/display/TCD8/Build+Failure+Conditions) based on the results of any build runners. So you can use the [Inspections build runner](http://confluence.jetbrains.com/display/TCD9/Inspections) to detect IDEA-inspections, and once these Kotlin inspections are merged into the mainline [IntelliJ IDEA build](https://github.com/JetBrains/intellij-community/tree/master/plugins/InspectionGadgets), you will be able use them with TeamCity as well. You will also need the [Kotlin.TeamCity](https://github.com/JetBrains/Kotlin.TeamCity) meta-runner.
This may be resolved in the upcoming M9 release. See https://youtrack.jetbrains.com/issue/KT-5609
Did you ask on [Stack Overflow](http://stackoverflow.com/questions/tagged/kotlin)? I know the JetBrains Kotlin team regular post answers there.
Ok, for clarification: I have ``` for(f in this.javaClass.getFields()) { s.append("${f.getName()}, ") } ``` This works almost, but the "name" of the field is "$kotlinClass", which is not useful. I need the actual name of the field. I could not find any such information when looking at the object in the debugger.. Edit: I also want to invoke the "getter" for this field (which makes random values) What I found is ```val p = Person(); Person::age.get(p)```, the problem is that I need the name of the field (age in this case). I would like to do this for all fields in a loop like above..
Perhaps you should ask it here too: https://devnet.jetbrains.com/community/kotlin?view=discussions this forum is monitored by kotlin developers (while I'm not sure if this subreddit is).
Try (1L..5000000L).stream() instead.
By default all operations are eager, and our measurements show that it is fine for most typical use cases, which are mostly non-performance critical moderate size collections transformations. It solves various lazyness issues, potential memory leaks in captured lambdas, etc. When you need truly lazy operations, like when sequence is infinite, huge, or you need to have a view on collection instead of snapshot - you just add stream() and switch to lazy evaluation. And because Kotlin can inline a lot of things, it's fast.
But honestly, timestamping like this is not really good measurement technique. Try JMH, like we do it here: https://github.com/JetBrains/kotlin-benchmarks
Looks like a problem with REPL. Will investigate, thanks. Try it on the web? http://kotlin-demo.jetbrains.com/
Works fine on the web. The version on the web is : `0.10.797` while the latest release I downloaded yesterday is : `0.10.195` 
Here is another little benchmark where Kotlin does well compared to Scala: https://github.com/oplohmann/havlak-jvm-languages
What I don't quite understand: Why isn't there a direct equivalent to `static` in Java? For performance critical code, wouldn't it be more optimal to make a static reference (for example to constants). Or do object field lookups automatically become static lookups? Further, can the compiler inline the lookup if it is a static primitive constant. For example: class A { private final static int N = 10; void operation() { for (int i = 0; i &lt; N; i++) { // do something } } } ... the compiler can blindly inline the value of N since it is private, final and static. Is something like this achievable in Kotlin with class objects?
&gt; Why isn't there a direct equivalent to `static` in Java? Is this not what the `[platformStatic]` annotation is for?
This looks amazing. Especially Android development should now be much easier :)
Thanks, and it's a lot more than "would be" -- it's practically here. It's a matter of a few weeks to no more than two months before the release. You can take a look at an example of the non-finalized (but fully operational) actor API [here](https://github.com/puniverse/quasar/blob/kotlin/quasar-kotlin/src/test/kotlin/co/paralleluniverse/kotlin/actors/PingPong.kt).
I like the new init syntax, and the lambda syntax changes. One thing I still kind of dislike: Running a project from IntelliJ IDE takes a long time. It starts a `make` process everytime and that takes a long time (10-15 seconds). The IDE seems to compile the code on the fly (since it shows errors as I type). Why does it need to recompile?
I think Java 8's new type annotations do the same thing, don't they? Or should the tags available at runtime for reflection? Anyway, type annotations are used for [physical units in Java](http://types.cs.washington.edu/checker-framework/current/checker-framework-manual.html#units-checker).
We really are desperate in the Kotlin community for more tutorials. Jetbrains' support site is simply incomplete and lacks a certain educational quality. It functions more as a reference and what the Kotlin community needs are strong learning resources in the flavour that Apple has been giving Swift. Jetbrains is a smaller company but if part of their success plan really entails hooking people on Kotlin and thus being far more likely to use IntelliJ (and derivatives) then they better back it a little better than they are doing. What they offer thus far is just not comprehensive enough. In my day job I work with Kotlin extensively in a significantly-sized project so I've seen the real power that it has that I think the newbies have no sense at all of yet.
Totally agree. It´s being difficult for me to find ways to take the most out of Kotlin. I see advantages just using the basics, but I´m sure it can go far beyond from what I´m currently doing. If you had sometime, it´d be very useful for me if you could take a look at the repository I created (https://github.com/antoniolg/Bandhook-Kotlin) and tell me what you would improve or do different. Thanks!
Are you referring to Kotlinlang.org and the Tutorials section or reference? Could you give more info on what types of tutorials or learning material you'd like to see? Or maybe point to examples of what you like with Swift? 
There are many like extensions, functions as parameters, aliases in imports, null-safety, classes final by default, data classes, IDE support, but the most killer (for me) are that it is not back compatible like java and it is developed by jetbrains. Moreover, check how Kotlin handles multiple inheritance with traits http://blog.jetbrains.com/kotlin/2011/08/multiple-inheritance-part-2-possible-directions/
We have them in other programming languages such as C#, Scala, etc, they aren't new. Is there anything new?
If not the killer feature at least a very powerful one is the delegate properties http://kotlinlang.org/docs/reference/delegated-properties.html That will let you implement your own lazy semantics or other cool stuff. I'm not aware of that feature in other language but I could be wrong Type-Safe builders are really nice, but are borrowed from Groovy (but in groovy are fully dynamic not type-safe). For me the real killer feature is how well al the features work with each other, nothing seems superfluous or extravagant. No magic tricks, no overly clever compiler stuff. Just everything in place 
Awesome! Thanks to jetbrains for this! It will help migrate a lot of my projects to Kotlin! In fact, I am just about to start a new project in Scala + Scala-JS, and this news makes me reconsider using Kotlin instead. Edit: Tried this with Eclipse Mars (version 4.5). Worked perfectly fine. And running the application is much faster than IntelliJ because there is no separate `make` task required.
again, that's the not the features but rather advantages.
You can also try using a [NotNull delegate](http://kotlinlang.org/docs/reference/delegated-properties.html#not-null). This will allow you to have a non-null *var* (but not *val*)
I'm not asking about var.
Much like you cannot have field like this `final` in Java, you cannot assign value to `val` outside of constructor/init in Kotlin.
oh yea, i wasn't accurate. You can use delegate like this if its possible to get value from "context" itself in some point, like findViewById, or getArguments in Fragment, or bundle from intent in activity. But not in your case. If you want val, you can try something like(if its make sense for you): move all logic in some class with lifecycle between onCreate and onDestroy of your activity, and pass state values in constructor.
Could you show me an example?
Still that involves var, if not in one place then in another.
&gt; pass state values to an object that only exists between onCreate()/onDestroy() :) How?
Initialize it locally if it must be val... Using only vals is stateless and this is what we are trying to achieve while developing in kotlin, it's best strategy. However, often it is impossible or too hard. You should involve at least one var in your code, because onCreate() is invoked during Android lifecycle, might occur multiple times so savedInstanceState is mutable.
Here's a quick mockup of the D scope keyword. https://gist.github.com/sublixt/b9cb60db6ee3b91ae5ff
What it is doing is declaring extensions properties on the JsonElement class. Here are some links to the reference that explains it further. http://kotlinlang.org/docs/reference/extensions.html http://kotlinlang.org/docs/reference/properties.html
Try here: https://functionalprogramming.slack.com
Can´t access either.
Hey I found that exercise very helpful, I'm currently stuck on number 24, about the `with` keyword. The job is to code a similar function `with2` in order to understand the behavior of `with` but I didn't manage to do it. The resolutions are in the `resolutions` branch but for this particular case they didn't show how to write that `with2` function. Can someone help me ?
Well it seems it was finally very simple : fun with2&lt;T&gt;(o: T, f: T.() -&gt; Unit): Unit { o.f() } ```
Really pumped that this is happening. Even more pumped that M12 is imminent!
But this argument goes both ways. Kotlin is indeed a "better Java", which makes it attractive to many people. Scala and Clojure are very different, and so appeal to a much smaller population to begin with. Also, Java 9 doesn't include any changes to the Java language, only the platform, and Java 10 includes a major change to the JVM that will help all JVM languages, but probably won't change Java (the language) by much. Besides, Java will always be more conservative than Kotlin, which is good for both Java and Kotlin. 
First of all, I can understand why Groovy (with its fully Java-compatible syntax) can be seen as simply a better Java. But I don't see why Kotlin has any less identity and style than Scala. It has its own distinct feel, set of features etc. Second, no matter how much Java evolves, it's always going to remain backwards compatible. You'll always have to live with raw types, checked exceptions, first-class support for arrays and so on. By removing those features, Kotlin can be a simpler and cleaner language. Finally, many of the key features which are available in Kotlin today (such as nullability and extension functions) are not, as far as I know, on the roadmap for Java that has been announced. Of course, if Java evolves enough, anything may happen, but this is still far away in the future. As we work on Kotlin, we're trying to design a language that works well and solves real problems for people. We aren't thinking about what may replace Kotlin in the future; it's not possible to control or predict anyway, so it's much more useful to focus on things that we do have the possibility to control.
The fact that the plugin is always there is not a bug. Even if you don't have any Kotlin in the project right now, you can create a Kotlin file at any moment, and the plugin will handle this correctly. Unfortunately the Kotlin team has no visibility into the reports which are sent to Google using the Android Studio report tool. If you want us to look into the problem, please file a YouTrack issue and paste the stacktrace from the error reporting tool there.
Oh, good to know. Because I am currently sending them to Google almost every day using that built-in sender. I hoped they'd forward them to JetBrains. Next time I'll see this, will create an issue manually. It seems to have something to do with creating anonymous java classes - whenever I invoke completion when creating rx-java's 'new Func2&lt;&gt;() {' or something similar, it crashes. But not entirely sure, need to reproduce once again.
One thing to consider is that Android will probably never support JVM &gt; 7 because of Oracle and litigation. That gives Kotlin a pretty big boost, as Android is a huge market for the language, and one of the Jetbrains' main targets.
Fair! Very good point.
Congratulations! This is super great news. I'm using it with kotlin even with version 6.0.2. Let's see how things will look like in the new release. Bests
Its not the regular expression I'm having problems with. How is the $month variable pulling out the correct month value.
It's not pulling out any specific month value. It references the "val month" declared above, which is a regular expression fragment matching all possible months in the calendar.
Nice read! I created two small PRs for your project.
Just merged on of them. There are new Todo items done. Thanks
Aha! I'll definitely have a poke around with that repo. I looked forward to the book. After having played around with the language all of this evening, I'm loving it so far.
Agreed, wholeheartedly. I had a few problems with IDE support, and getting SBT to work as expected. I'm also not a fan of implicits, they seemed like... local... globals... That's the best way I could describe them anyway, so many problems brought with them. Also, some of the conventions seemed really strange. Like, getters and setters: class Obj { var _foo = "bar" // Can't be called foo, because of methods below: def foo = _foo // Fair enough, this is okay, though I'm not a fan of having to put in a different name for the variable def foo_=(value: String) = _foo = value // Wat? Is tricking the compiler a convention? This is not nice! } Then basically making: val obj = new Obj() println(obj.foo) // "bar" obj.foo = "baz" // or, what's actually happening: obj.foo_=("baz") The usage is okay, but the way you define them is so ugly, and it forces you to do things in a weird way. It was lovely to see Kotlin's implementation with backing fields/properties, and actual get/set keywords and a standard that actually makes some sense!
Sorry, I don't quite get your question. This example does not have any classes, backing fields or getters. All it has is a package-level property with a constant value.
The actor example is part of the Quasar testsuite [here](https://github.com/puniverse/quasar/blob/master/quasar-kotlin/src/test/kotlin/co/paralleluniverse/kotlin/actors/PingPong.kt). Does it work for you from the testsuite?
I tried cloning the repo, and running the tests through gradle. But, I couldn't even get them to build
Well what you want? Any turing complete language, at bottom, has all the abilities that any turing complete language has. Kotlin is just a very good blend of some features.
I think your Java installation needs to be a JDK, not a JRE with correctly set JAVA_HOME and PATH environment variables; is that so already? Also make sure you're using a recent enough Gradle.
Sorry that was a dumb mistake. I was compiling it on my work computer where I hadn't set up a JDK. But, my original problem still persists even with the tests cloned directly from the repo. [Here](http://pastebin.com/By60guzc) is the console output from the running of the kotlin actor test. And [here](http://pastebin.com/h9VQ9cSc) is the slightly modified source file, so you can see where I put println statements. As you can see, the code is never leaving the receive block, so it doesn't loop the message sending or receiving, and the pong actor always times out.
Weird. Which JDK version and flavour (32 or 64 bit) and which platform are you running the build on?
Windows 64 bit. Gradle 2.4 OpenJDK 7u80 JDK 1.8.0_25 JDK 1.8.0_45 JDK 1.7.0_79 All gave the same console output.
Thanks for taking the time to work this out with me. I'm glad that I was able to get a hold of you here because I completely thought I was doing something wrong, and probably wouldn't have submitted a bug report.
This is basically a story about us trying to integrate two rather complex systems together without altering one of them at all. Should be fun for hackers :)
Yeah I don't envy you guys that task even a little bit. Pretty neat solution.
[Kovenant](https://github.com/mplatvoet/kovenant) is pretty close.
I'm not familiar with the scala future api but perhaps rxkotlin?
Good lord, this looks amazing. Thanks! I wonder how difficult it'd be to built a promise implementation around Quasar strands...
I'm pretty sure it is possible to replace Dagger with pure Kotlin service locator pattern implementation based on delegated properties. Some boilerplate is needed but that not much. I hand-rolled such thing (didn't want to include Java just to make Dagger happy) in the context of an Android project. The biggest issue is that you loose some of the compilation time safety and have to do some lookups.
I don't think it's that difficult to built a promise implementation around Quasar. What I'm still wondering is whether it makes sense to do so? Quasar is essentially two things: 1. Lightweight threads 2. Actor concurrency Actor concurrency usually describes a stream of events or messages on which actors react and perform some task. Promises/Futures on the other hand describe a single task that is to be completed in the future. So that doesn't really match. RxKotlin is in this area too with the Observer pattern. The lightweight threads on the other hand is something that could easily be leveraged. Quasar manages a pool of threads on which "Fibers" run. A Fiber is a byte code instrumented piece of code that effectively creates asynchronous code that can be written more in line with synchronous code. It basically tries to avoid or has no need callbacks. This has several upsides like stack traces that are in line with synchronous code. Any Promise library could easily schedule all the work within Fibers, so it could easily be build on top of Quasar. The big question is, however, the use case. Any thoughts on that? 
Been killer slow for me lately too even when developing projects not using kotlin. 
Please cut out the implementation details from your post, so that we can focus on the API.
I don't know if the Kotlin team regularly reads /r/kotlin, but I _know_ they regularly answer [Stack Overflow](http://stackoverflow.com/questions/tagged/kotlin) posts, so you might like to try there too.
Thanks I'll try there if this post doesn't generate a good discussion. 
Cool, sounds interesting. I'll check it out, though I've already tried out Kotlin on Android.
Is this Team on Slack active? How can I get an invite? 
This strikes me as a very vague question at best. It's analogous to asking "which is better, apples or oranges?" What is the performance of Kotlin in _what context_? Garbage collection? Building a binary tree? I think your question is actually "Will I incur a performance penalty if I use Kotlin to write an app as opposed to using Java?" I think that's a false dichotomy to begin with; that is, you don't have to write all one or the other. Kotlin integrates with Java very nicely and vice versa. Even if it were true that you were forced to write everything in one language or the other, so much of performance is dependent on the coders' choice of algorithms and the coders' competence it's impossible to discuss performance as if it were some abstract quality. Say I were building a binary tree implementation and I had never seen a data structures book. My naive implementation of the algorithms would probably have horrid performance no matter what language I coded it in. Or maybe I'd naively stumble on the best algorithms to traverse the tree etc. etc. Impossible to say. Even if there were benchmarks they'd be measuring the performance of specific code--not the performance of the language in general which is what you seem to be asking for. 
&gt; Besides, Typesafe (the company behind Scala) from what I can see has no real revenues I think the money comes from consulting, training and commercial support in the individual bits of their software stack. They are also backed by a few investment companies.
Scala and TypeSafe get their funding from commercial users like Morgan Stanley.
I've been using Morphias interop with Kotlin without too much problem.. If you don't intend to do geospatial queries then its a pretty solid lib. You also have Jongo and the Spring Mongo libs as well.. I would just use a Java one with interop. It's not too bad if you remember to use the Delegates in your model. Delegates.notNull() especially is really helpful for models.
Awesome. First step of the compiler speed optimization. Now we're waiting for incremental compilation for Gradle. 
https://github.com/SalomonBrys/Kotson That is a Gson extenstion that make is possible.
http://pastebin.com/RsMdFc7w
Thanks! I'll take a look and get back to you tomorrow with whatever I find! 
Not exactly related to your problem but FYI, you can get rid of your `findViewById` and let Kotlin do the bindings for you. [Details here](http://kotlinlang.org/docs/tutorials/android-plugin.html). 
Might as well reccomened Anko too.. Anko is another Android Kotlin Lib from Jetbrains. I would link it but I'm mobile, but it has some nice things like soneTextView.text = "Hello World"
Right, I actually love the Kotlin Android extensions. We're using a (very primitive) custom view manager to swap out views instead of fragments. As far as I could tell, we couldn't use the extensions with this flow :( I've been looking into Anko as well. I have a hard time seeing how useful it would be for more complex views (seems like it could get pretty messy), but for smaller views it seems pretty nice (as well as the other non-view related features).
Thanks! After a little messing around, I think it might have something to do with how Kotlin translates Java scope/visibility when referencing Java code. Not sure how to work around that one, or if there is a better way to do what I'm trying to do.
You should file a bug report on https://youtrack.jetbrains.com/issues/KT. 
It's disappointing, to me, that it seems like they're sacrificing design tenets of the language due to what are essentially tooling limitations. &gt; Modifiers have a peculiar property of being available right after the parsing stage. And this is important to some performance-critical tasks (e.g. in the IDE), because they sometimes rely on knowing, for example, what’s public and what’s not in contexts where nothing is ready but a parsed text. If you have parsed modifiers, haven't you also parsed the annotations as well as the import statements, giving you fully-qualified names to work with? (Example: What's stopping the tools from treating the `kotlin.inline` annotation differently from a modifier named `inline`?) A language shouldn't be influenced by the tasks an IDE is responsible for. Rather, the IDE should be built for the language.
It's one of the primary goals of Kotlin to enable excellent tooling. And we believe it's a very good idea to have the IDE as one of the design tenets.
&gt; And a more technical, but nevertheless realistic concern: it complicates language evolution. We can’t add a new modifier “foo” to the next version of Kotlin without possibly breaking someone’s code: if some library has an annotation foo, it will clash, and the best the compiler can do is report an error. How would this issue have been handled originally with unified metadata?
Brilliant read, some really useful examples of how to practically use some of Kotlin's features. It's much easier to appreciate (as with most things) a good example than to apply the principles from just reading the documentation. Then again, maybe I'm just an idiot. Either way, thanks! 
I think the point is that you may have the FQN available but that's literally _all_ you have. You don't know anything about the annotation class or how it behaves or even its retention policy. Things like 'public' are things you need to know before you know literally anything about the classes themselves. That's how I interpreted it anyway.
Amazing!
Sounds like changing the tools is hard. It's a realistic tradeoff. If you design a language without taking into accounts the needs of the other tools, you get Scala. Or indeed .... Java :)
There are other virtual machines out there. ie. Kotlin ran/runs fine on Dalvik. Additionally, there's Android Runtime.
I'd honestly thought they (Groovy, Scala, Clojure, etc) would be Oracles next cash cow...
It's not Oracle's VM. That's why Google developed Dalvik. You can run Kotlin on Dalvik or ART with a new API. Get what I'm saying now? Bytecode doesn't have to go away for Android.
For the same reason you don't get milk out of bulls, things just don't work that way.
Oracle is consistently encouraging creating and development of many JVM languages: Groovy, Scala, JRuby, Jython. They all rely on the same VM, and Oracle seems to be happy about it. And, as someone mentioned above, we are not replicating the APIs, just using them, which is clearly permitted by the license.
Actually when you instantiate a List, it is in fact a Java list. It has a bunch of extension functions, which are provided by the Kotlin runtime and are compiled to simple static methods, but the underlying collection class is a regular Java collection.
Many thanks for that! It's another stepping stone in what is turning out to be a trickier than I expected journey. 
One small detail, b/c it's particularly confusing: IDEA IntelliJ is the Java IDE product, JetBrains is the company. 
Other libraries: [Kovenant](http://kovenant.komponents.nl) - promises for Kotlin [Injekt](http://github.com/kohesive/injekt) - dependency injection / object registry [Klutter](https://github.com/klutter/klutter) - mixed extension libraries including for Typesafe Config, a directed in-memory graph library around Netflix Graph [Jackson Kotlin module](https://github.com/FasterXML/jackson-module-kotlin) - Jackson supporting Kotlin objects more nicely
kInterest has nothing on that site but words, and investment links. Not sure why it was suggested. Ktor will be important when it is developed, and good people are working on it, but is early. Kara is good, but the site is dated and most development is done in the [fork that Jetbrains maintains](https://github.com/shafirov/kara) but they are starting to merge back into core Kara more and they are becoming closer. Spec is called "Spek". Exposed development has picked up again, NoSQL updated to M12 (partly?) but not sure how active it will be in the future. The recommendation of viewing the list of libraries from the web site is a good starting point. And I really wish those who created 1000 experiments in GitHub would delete them after they let them go dormant, out of date, and die. Its a problem with GitHub public repos that people leave crap laying around and never clean up after themselves. 
Glad to see it clicked for you! 
Edit: holy shit this got ranty, but I hate it when people question my real world experience. The point of my first post was commenting on how you compare kotlin to Scala when it is more accurately compared to Java. I think your comment exemplifies a programmer who has never written functional code, and is trying to comment on the usability of it. First off, we've had incremental compilers for years now. Poor use of your tools is not an excuse to shy away from a type system that will assure your program will run. Persistent data structures are infinitely better as soon as you move away from single core, single machine code execution. In fact, mutable data structures (and OO for that matter) don't even work once you move off a single machine. Do you remember RMI? I do, and it was awful. I thought performance of locking all your data access on a single machine was awful. then I had to lock my data across multiple machines, and half the time my threads were just sitting there waiting for data to become available. So maybe my 6 years of Scala working on swarm computing where I was running 8 jvms across 8 drones with 16 core 1.2 GHz cpus, and 7 years of java working on back-end development where I was running 100+ jvms across several data centers, and my personal work developing games means nothing. Maybe I'm just an academic who knows nothing about how real world development works. But, this academic has found that in real world programming the use of persistent data structures and a strong type system will eliminate half (if not more) of the bugs found when working on highly concurrent computing.
KDoc is gone, and Dokka will be officially released together with M13.
Yeah, all of that is correct, although I'm not sure about your last point. I have already seen that this should be a feature already, both of the following show it: * http://blog.jonnyzzz.name/2013/03/bdd-test-framework-with-kotlin.html * http://blog.jetbrains.com/kotlin/2014/02/speka-specification-framework/ Perhaps over time this functionality simply stopped working due to other changes... I don't think Spek has been getting that much love, given the documentation on their website doesn't actually work if you use it (and some of it is just plainly completely invalid code), luckily the repository and it's examples are up-to-date.
Your fears are unfounded, and -- due to no fault of your own and like many others, because there's *a lot* of misinformation out there about the trial -- you have misunderstood what the court case is about. Whether you think the court's ruling are correct or not, what Google did with Android was something very specific, and very, *very* rare these days, and that's what they were sued for. That trial -- regardless of outcome -- has no relevance whatsoever to 99.99% of current software projects (e.g. of all open source projects in the world, the ruling may be relevant to one or maybe two besides Android). Some people try to build up the case's importance to get the developer community to care about what is no more than the usual scuffle between two mega-corporations, and so they falsely extrapolate from the case to make it seem relevant or threatening to other projects. It is not. 
In Java, `List` is a Mutable interface. In Kotlin, `List` is an immutable interface and `MutableList` is a mutable interface. Kotlin allows you to define mutability and Java does not.
Okay, that's good to know I guess. If I may make a suggestion here, I would absolutely love something like Jasmine with `describe` and `it` with the `before`, `beforeEach`, `after`, and `afterEach` too. I may stick with using JUnit alone for the time being, and transition the tests over as soon as there is something more concrete available.
Regarding build tools, our primary focus right now is compiler performance. This is essential for all environments where Kotlin can be used. In the Java world, we can't live without interoperability with existing build tools (for example, Android Studio only supports Gradle, which means that even if Kotlin had an excellent native build tool, it would be of no use - they would still have to use Gradle). We have prototyped our own Kotlin-native build tool (with build scripts written in Kotlin), but we don't expect it to be a major part of the Kotlin story going forward. On the JS side, we still have to figure out our build tools story, and we're going to address this after the 1.0 release (which will be JVM focused). We don't have any plans to write our own coverage runner, and, judging by the level of interest in our code coverage tools for Java and .NET, we would not expect that a code coverage tool would attract any significant number of developers to the language.
That's quite interesting to hear about the Kotlin build tool. I understand that using one of the Java tools (i.e. as you mentioned, Gradle) is more than likely what Kotlin as a whole will stick to though. I'm primarily focused on the JVM side of things, so I'm quite glad to hear that's the main focus (not surprising though, heh). I'll have to take your word for it on the coverage tools, I can only say what would be useful for me. From what I gather, IntelliJ does have some kind of coverage reporting built in, and I have got it working with JUnit, however it's not quite as clear as a separate report - I think I'm more than likely just missing something though as I've not looked into it a great deal yet as I was hoping to explore some more familiar options (web-based, HTML generated reports). I think the last area I'd like to put my mind at ease in is with testing tools, but I'm looking into potentially solving this one myself - or waiting to see what plans you guys have for Spek, as you told me just the other day that there are some upcoming changes to that at some point. Thanks again for your responses!
Kotlin's syntax is much cleaner imo. Especially in the syntactic sugar scenarios when you can leave out parenthisis or arguments 
Yeah, perhaps it's just because I'm more accustomed to the Java8 syntax at this point. I do think Kotlin should try to stay as close to Java syntax as possible unless there is a good reason it can't.
Yes, but if Kotlin used the Java8-style syntax I'm sure it could support the same more concise notation in the case of a single parameter. I don't think this makes a case for the {.. -&gt; ..} style over the Java8 style.
But in your example the Kotlin version isn't any shorter, it simply uses {} instead of (): `.filter ( x -&gt; x % 2 == 0 ).map ( x -&gt; x + 1 )` (Java) `.filter { x -&gt; x % 2 == 0 }.map { x -&gt; x + 1 }` (Kotlin) I'm still not seeing any significant benefit that would outweigh the cost of deviating from the Java approach (which will already be familiar to most people attempting to adopt Kotlin).
All I can say is that builders and "continuations" are a very important feature in Kotlin used in numerous Kotlin projects on GitHub (e.g. anko, RxKotlin, spek, kovenant, injekt). I've picked them randomly from the high-profile Kotlin repositories [1] and nearly all of them have a code example that uses builders ~~or continuations~~ in their README file. You'll see it on first sight. If there is really need for Java 8 lambda syntax, it is required to add both `{}` and `() -&gt; ...` syntax in order to support a decent builder syntax IMO. I guess it is possible, but it could make the lexer/parser grammer more complicated. But I'm no expert on this regard. Also note that the Kotlin team has made other decisions, that deviate Kotlin from Java 8-related things like `Stream`s (an integral construct in combination with Java lambdas). It seems that `Sequence`s are recommended over `Stream`s. [1] https://github.com/trending?l=kotlin&amp;since=monthly **Update:** "continuations" are named "callSuffix" in the Kotlin grammar [2]. [2] http://kotlinlang.org/docs/reference/grammar.html#callSuffix
Just so that you know my preference is private by default, but that might be because I'm some sort of control freak who loves encapsulation and doesn't like to expose the inner workings of his classes by default. :)
"private" by default comes at a cost, make sure to read [Andrey's explanation of the current reasoning](https://youtrack.jetbrains.com/issue/KT-3240#comment=27-1110881). 
Shorter: `(1..10).asSequence().filter { it % 2 == 0 }.map { it + 1 }.count()`
I understand the reasons behind the preference of private by default. But it is inaccurate to say that "private by default" is an innovative choice. That was the default for c++, a language more than 30 years old. Actually the opposite is true. several modern principles of software design like the single responsibility principle for classes, immutability and related stuff from functional programming make "private by default" a very inconvenient default that can actually encourage bad software practices. 
My understanding of "continuation" is functionality where the state of a thread can be stored, to be resumed later (perhaps resumed multiple times, or even resumed on a different computer). It's a very rare feature in a programming language. Of contemporary languages, only Scala had continuations support through a compiler plugin, although unfortunately I believe it is now deprecated and won't be supported going forward. Are you sure you're using the term "continuation" correctly?
If you want that we'll organize a webinar on some particular theme fill free to suggest it here.
Andrey explained the reasons in the linked bug. They seem valid to me. I think encapsulation is one of those things that people often go overboard with, and end up painting themselves into a corner. My own experiences with it have been mixed: it certainly has value, but there are too many cases when code needs to access something that's marked private and you end up needing bizarre hacks in order to do so. Unit tests are a common case for this (@VisibileForTesting etc), people wanting to do things the API designer didn't anticipate, working around bugs in the code, etc. I'd like to see the Kotlin guys do a big rethink of visibility in a post 1.0 release to try and provide finer grained tools.
[removed]
For those wondering: ~~No official blog post yet~~, but the release content can be seen under https://github.com/JetBrains/kotlin/releases. **Update:** [Official M13 announcement here](http://blog.jetbrains.com/kotlin/2015/09/kotlin-m13-is-out/)
official blog post: http://blog.jetbrains.com/kotlin/2015/09/kotlin-m13-is-out/
They mention impressive speed-ups with the daemon. Has that been borne out in actual usage by folks here?
Oh for some reason I thought it was just the DSL layouts. Ok i'll give it a peep when they update to M13. Could you say one of the additional extension functions you really like? I have to say the base Kotlin android extension that auto maps variables to Views is amazing. Thanks! :)
I'm really impressed how Kotlin evolves! I hope that Kotlin will replace Java in many places. 
toast, async, asyncResult, dip for example 
You can use the javaClass extension property: input.javaClass
The KClass for a class is stored as a static field called $kotlinClass. One way to get it is to use reflection input.javaClass.getField("\$kotlinClass").get(null) as KClass
There is no need to do that: Kotlin provides a supported API for this operation.
Sure, I was wondering what peoples' impressions of that was, now that it's had some time to sink in.
Awesome, no idea this existed, and is close pretty closed to what I was looking for!
My fault. Changed it already. 
I like them both. More important to me is for Kotlin to introduce object method references like string.forEach writer::append which eliminates the clunky areas of Kotlin's lambdas.
Very nice, I've been looking for something like this.
Wow, I asked the same question here: http://stackoverflow.com/questions/32655216/kotlin-equivalent-of-getclass-for-kclass The easiest way is input.javaClass.kotlin But soon apparently there will be input::class and hopefully the same for getting method references of variables!! Like writer::append
I just don't like that it has to be const val instead of only const. 
In this webinar, Fabio Tudone shows how to use Quasar for creation of highly concurrent software. He covers basics of Kotlin syntax and shows how Quasar uses Kotlin strengths to offer concise and expressive API. 
The hardest part of using Quasar to me was trying to set it up in gradle. Kotlin + Gradle + Actors example's and web reviews all targeted different versions and made it a little difficult to play with.
It's definitely possible to develop Kotlin support for Bazel. However, we (the JetBrains team) have no current plans to work on it, and we haven't heard any interest expressed from the Bazel team at Google.
It's not that hard to write a reusable Skylark rule to offer this, assuming Kotlin has a command line compiler (been a while since I've checked Kotlin out). The biggest issue with Bazel currently (if using intellij) is generating the project files. People have a hodgepodge of shell scripts to do it, tempted to write something in Java to do it actually. 
Sure, Kotlin does have a command-line compiler.
I don't know that it would be a problem really-- it's already sufficiently flexible to support every other build system under the sun. If Bazel picks up enough steam I'm sure an Intellij plugin will come along pretty quickly.
I was actually just looking this up. Seems like you can do it: http://bazel.io/docs/external.html
There will be an IntelliJ plugin, yes, but there won't be support in Android Studio (which supports only Gradle and, among other things, explicitly removes support for Maven, which is available in IntelliJ IDEA). This will severely limit the potential adoption of Bazel among mainstream Android developers.
Reminds me of SmallTalk. 
Am I reading this const thing right? 'val' was always constant, so now we must always declare it as 'const val'??
If `const` means `static`, why not just call it `static`?
It should really be just 'const', as constants are usually static final. 
`const val` is a compile-time constant (the constant the value of which can be evaluated at compile time). only a very small number of `val`'s in a program can, or need to, be compile-time constants.
Yes, that's right.
Ooooh nice thanks for the explanation. 
Yes, you can't use `const val` on `class`-level. But you can define `const val`s on file-level and use these constants within the classes of this file just like you would use `static final` fields in Java. If you use `const val`s from other packages you just need to import them. Also: I think it doesn't make sense to have constants on class-level and have memory allocated for each instantiated object. So, it's better to define them on file-level or within a singleton `companion object`.
There isn't any particular story. You can use the APIs, but I don't think that we have any declarations for the APIs in our standard library, so you'd need to declare them yourself. We also don't have any solution for RPCs yet. Right now we're focusing on the 1.0 release which will be targeted at the JVM, and therefore aren't doing any JS work. We'll resume work on JS after 1.0 is out.
Is it possible to just write `const N = 10`?
I'm not exactly sure why it needs to be "const val" instead of just "const". It seems like unnecessarily added syntax bloat.
Nope. I think it uses `const val` to make a syntatic connection to `val`. Kotlin also uses `enum class` instead of just `enum`.
&gt; don't think I would be a fan of this change The question is why do you think it is bad? Kotlin already looks quite similar to golang code. **Kotlin:** fun foo(apple: String, banana: String) { println("$apple $banana") } **go:** func foo(apple string, banana string) { fmt.Println(apple, banana) } **simplified go:** func foo(apple, banana string) { fmt.Println(apple, banana) } Having a shorter function declaration is more pleasant to the eyes and therefore an improvement IMHO.
Personally for me, it confuses readability.
After some more digging, I found the answer. I'll leave it here for anyone else.. Notation for Platform Types As mentioned above, platform types cannot be mentioned explicitly in the program, so there’s no syntax for them in the language. Nevertheless, the compiler and IDE need to display them sometimes (in error messages, parameter info etc), so we have a mnemonic notation for them: T! means “T or T?”, (Mutable)Collection\&lt;T\&gt;! means “Java collection of T may be mutable or not, may be nullable or not”, Array\&lt;(out) T\&gt;! means “Java array of T (or a subtype of T), nullable or not”
&gt;T! means “T or T?” Yepp, that's right. I also wondered what this might mean, when I first encountered it in IntelliJ IDEA. Andrey gave a talk [1] about "platform types" (aka. flexible types) in August, where he explains them in great detail. [1] https://www.youtube.com/watch?v=2IhT8HACc2E (42 mins)
Definitely cool. How does this compare to Jetbrains' Anko, besides the support for other languages?
Kotlin has no concept of static fields. CONTENT_URI in your code is not a static field, it's a companion object property. Companion object properties are not inherited in the way that Java static fields are; you need to refer to them using the name of the class where they were defined. If the BaseColumns class in your example does nothing but define IDs for columns, there is no reason to inherit from it at all. Simply make it an object, and define column names as properties of that object.
 It doesn't make sense to inherit static things Why is that though? I'm genuinely curious.
No formal benchmaks yet, just personal observation on some of my own projects. You can try yourself: git clone https://github.com/cbeust/kobalt.git ./gradlew clean assemble ./kobaltw clean assemble You might want to try the last two commands a few times, and please report back if you do! 
The trouble with static members and inheritance is, that static members cannot be overrider but only hidden in subclasses. And since a static methods are independent from instances of the class (because they belong to the class itself), there is no reason to inherit them - they are always present in the respective class. It is therefore much clearer in design to refer to static members directly and don't abuse inheritance to do so. In the case of Kotlin you would call methods on literal objects (instead of plain static methods, like in Java).
I did some more reading after seeing what you said. I read up on the static inheriting and I see what you are saying now. I can see why Kotlin doesn't support it. Good explanations in the comments: http://stackoverflow.com/questions/16617408/overriding-static-methods-in-java
Well ideally it wouldn't matter because a static final Primitive in Java is just an inlined constant. But sadly I don't think that's the case with Kotlin. I like to put my constants into empty classes to help organize them.
The plan for 1.0 is to inline constants defined in Java code. Pure Kotlin constants will not be inlined for now, because we aren't completely sure how this interacts with incremental compilation.
Well first of all, there isn't an &amp;&amp; between both comparisons. So this wouldn't compile even IF T and U had values assigned to them. You would need T &lt; U &amp;&amp; U &gt; x for this to qualify as a valid Boolean expression.
Think of constants as if you are writing the value it's self into the code anywhere you use the constant. So like const val x = 2 var a = 3 + x Should be considered the same as var a = 3 + 2 Constants are extremely useful for ensuring regularity of values across an application as well as making it easier and less bug prone when making changes to values in code.
No, the Kotlin parser does not rely on any information from the type system. As correctly noted above, Kotlin has no syntax for comparison chains, so there is no syntactic ambiguity.
It's not quite that simple, Kotlin has a large list of symbols with which it tries to detect whether `T&lt;U` is part of a comparison, or a type argument list. It sets a mark, starts with trying to parse it one way, and if that doesn't work, it says "oh crap", rolls the parser back to the mark, and tries the other way. Because of this, it's probable that the parser for Kotlin grammar requires unlimited lookahead, due to there being symbols for which the parser can't decide and needs to keep reading. Interesting bit: The language will never be able to support the uniform access principle, because that would likely make the grammar ambiguous. Example: `foo&lt;bar, baz&gt;= fuz`
&gt; support the uniform access principle, Not quite true. You can simply distinguish the two cases by adding a space between &gt; and =. The parser can certainly handle it, and I have never seen code with the comparison operator &gt;= with a space between the two symbols 
That sounds right. Lookahead is an important feature for parsers.
I would say Kotlins closures are great for Reactive programming, which is great for very responsive applications like Android apps. If you use RxAndroid with Kotlin you can use Kotlins lambdas to make very concise code.
They definitely had Android in mind, else they wouldn't have made the Android gradle plugin and the Android extensions plugin. Apart from that, there are no *language* features that are exclusive to Android. Believe me, developing desktop or server apps is just as pleasant with Kotlin. 
Maybe they had PhoneGap/Cordova in mind which imply they also have Android in mind.
Nope not specifically for android though it's simple and a joy to use with android. I've used kotlin to replace groovy and Java in a pretty large critical system. It really was a joy using it. It's not perfect but which language is. Hth 
 Compiling 86 files with classpath size 16 Compiling 86 files ========== kobalt:assemble Created c:\Development\GitHub\kobalt\kobaltBuild\libs\kobalt-0.213.jar Created c:\Development\GitHub\kobalt\kobaltBuild\libs\kobalt-0.213-sources.jar ***** WARNING Directory c:\Development\GitHub\kobalt/kobaltBuild/docs/javadoc/ doesn't exist, not including it in the jar Created c:\Development\GitHub\kobalt\kobaltBuild\libs\kobalt-0.213-javadoc.jar ***** WARNING Directory c:\Development\GitHub\kobalt/modules/wrapper/kobaltBuild/libs/ doesn't exist, not including it in the jar Created c:\Development\GitHub\kobalt\kobaltBuild\libs\kobalt-0.213.zip Time to Build: 36242 ms BUILD FAILED: 1 gradlew worked fine though
i also tried the intellij plugin and it crashes intellij when doing the sync
In fact there are Worker and SharedWorker classes declared in Kotlin (in the package org.w3c.dom) but they are declared as is (with no any Kotlin's sugar).
How are you handling Multidex, with exopackages?
Kotlin is like Python. It's thin and minimal. When you want something small, there'll be 10 not-very-well-maintained libraries doing the same thing. If you're lucky, some of the libraries are well-maintained. But being thin and minimal is good for certain situations. Scala is like Ruby. It's fat and feature-ful. A lot of common things are in the core library. When you want something, you'll find one in the core library. But being fat is not acceptable for certain situations (maybe not good for android). The concrete example of Python vs. Ruby is how people discuss about getting the first element of an array (http://stackoverflow.com/questions/363944/python-idiom-to-return-first-item-or-none) while, in Ruby, we use .first which is included in the core library. You can imagine a lot of people has their own .first in Python because it doesn't make sense to include a library that provides only .first. The concrete example of Kotlin vs. Scala is Seq.padTo(). You will have to write padTo() yourself in Kotlin. You wouldn't include a JAR that only provides padTo(). Scala might still lack of some functions. But I feel its attitude is toward being feature-ful. That's what I feel. I'm not sure about the general attitude of Kotlin. Will it include a lot of these small things into its core library? Will it try to be feature-ful or minimal? I know this thing needs balance, but its attitude can point toward one or the other.
In kotlin isn't the thing to rely on java libraries? 
This is cool.
A big project that uses kotlin. I understand that there is a large kotlin codebase in intellij but it's not visible to the outside ( I might be mistaken). I would also say libraries but one can say that java libraries are available to the language.
I have just now started working and i will be working on a project using Java SE 7. I am just now starting to look to JVM alternatives. I am looking forward to learn scala and kotlin. Would you discourage learning both at the same time? My company is already using scala to some extent. In this sense, would you rather have me learning only scala? I love kotlin because i also love python but i noticed that scala is also extremely good.
- The Android Lint checks don't work. FindBugs on the other hand works, because it inspects your byte code - The compilation is ~2 as slow as Java. However the developers said multiple times that compilation performance will be a focus after 1.0 - Code coverage doesn't work yet and will only be fixed after 1.0: https://youtrack.jetbrains.com/issue/KT-9867 - If your library isn't compiled with the newest milestone, your build will break. Is actually already fixed with the 1.0 beta because from now on everything will be downwards compatible. 
The Kotlin project itself uses a lot of Kotlin and is OSS. However compiler code might not be the easiest code to read. 
Do you have a source for the Android lint checks not working, perhaps an issue in Kotlin's bug tracker? I'd like to know if they are working on a fix.
I don't think there is a fix. Lint works by inspecting your Java code, not the bytecode. Someone needed to rewrite all of the Lint checks for Kotlin.
That's what I feared :/
https://youtrack.jetbrains.com/issue/KT-7729
Good to hear! I interpreted the "M.next" as next milestone after 1.0
There are a few points: **Learning both is definitely good.** You should always try to compare them and think about why Kotlin is better than Scala (and vice versa). **Deciding between technology is always hard.** I choose Scala because of the ability to write shorter code while being static typed. If I didn't care about static typing, I'd go with Ruby. Also, performance is not extremely critical for my application. If the performance is extremely critical, I'd go with Java because there is less syntactic sugar (which means it's easier to optimise). Kotlin is probably in the middle between Scala and Java. **Python is not even in the static typing realm.** If you are thinking about Python, you should first think about dynamic typing vs static typing. Which realm do your team want? One more recommendation: Scala is very very flexible. If you decide to use it, you need to follow your code style religiously.
I compared it with python because both languages are fairly simple to get into, while for instance Scala is very feature oriented (thus making the language more heavy to learn). I reckon i could get productive faster using kotlin than using scala. Not sure though, this is 
I did after some more experiments. I just wanted to make sure it wasn't something stupid I was missing that caused it to behave like that. Interestingly enough, when compiling the code to JavaScript, it works as expected. Another user in the #kotlin IRC channel on freenode worked with me and found that it affects all of the interfaces from Java that have generic parameters.
I was an early adopter of Scala, but I prefer Kotlin. Scala's type system is over complicated, and I really like Kotlin's null safety and smart casts, which Scala lacks. Scala's goal was to build a functional programming language, it was ideological. In the process I think they really overcomplicated the language. Scala also has a nasty habit of creating functionality that people build on, and then deprecating it without any viable replacement (eg. the continuations plugin). It suggests that the management of the language's development is too immature for a language that many people are building upon. It's early for Kotlin, but they seem to be doing it right. Kotlin's goal was to fix what was wrong with Java. In this sense it was similar to Java, which was also a pragmatic effort to fix the problems with C++.
try talking with Jetbrains, they will probably be interested in talking to you.
I was curious, what is the current state of "pattern matching"? I know there were some discussions a few years ago regarding proper pattern matching in when expressions (in a manner similar to Scala), but it was postponed for later development. I saw an example with a binary tree and a syntax similar to "v @ Tree(\*, 5, Tree(\*, \*, Leaf))". I haven't found anything recent regarding this. For me, having lambdas, extension functions *and* proper pattern matching might be tempting enough to switch from Scala for personal projects. It would be nice to hear an official position regarding this.
I really wonder why you're calling a FAQ entry that answers the exact question you're asking "half relevant". Types on the right make it much easier to add or remove type declarations when types can be inferred. Compare: val x: Int = 10 val x = 10 The types are easy to add or remove if needed. This would not be possible if types were on the left. This is what we mean by "leave type annotations out". If you find function declarations with more than two parameters hard to read, try placing each parameter on a separate line.
&gt; I really wonder why you're calling a FAQ entry that answers the exact question you're asking "half relevant". Because it just states that the code is more readable without explaining why do you think it is more readable. If you mean that &gt; Besides, it enables some nice syntactic features, for instance, it is easy to leave type annotations out is the explanation, then I'd have to point out that explanations don't usually start with "Besides". &gt; Types on the right make it much easier to add or remove type declarations when types can be inferred. &gt; This would not be possible if types were on the left. I don't understand what you're talking about, your examples explained nothing. How is "val Int x = 10" worse or harder than "val x : Int = 10"? How is adding/removing type *impossible* in the former case? If anything, in the latter case you have to write an extra :, which makes it *harder* to write. And adding/removing an explicit type is much easier to do with IDEA intentions anyway than by typing (no pun intended) the name of the type. Please don't get me wrong, I love Kotlin, you guys are doing a great job. I'm just really skeptical about this particular syntax feature. 
Are there really any performance penalties when Kotlin is compared to plain Java? From what I read, Kotlin should have the same performance as Java, and anything written in Kotlin could be written in Java with the same performance, it would just be ugly as fuck in the latter case. All the cool things in Kotlin happen at compile time anyway, not at runtime, and I must admit that performance and memory footprint of Kotlin compiler is worse than that of Java compiler, but is does runtime performance suffer in any way?
Having a type on the right side and having a colon between an identifier and its type are independent syntactic choises. For example, Go language has types on the right but without a colon. You may like this style if you agree with the point that types can be fairly complex so putting it later reduces the depth of mental stack when you read it but still don't like colons. IMO it's sometimes confusing without colon if you write programs in other C-style languages like Java as often.
Yeah, I get it now how the position of type after the name can be useful. But I still don't buy the colon. I guess in this post I should have instead asked why is there the colon, and why do we need a colon in Kotlin if when arguments were on the left there was no need for such colon.
When you have the types on the left, you generally wouldn't need an extra keyword to indicate that you are declaring a type. This the comparison would be between: val x: Int = 10 and Int x = 10 What yole was meaning that this makes it easier (It's still possible the other way around) to remove the type information is that you can simply remove the typename from the first one to be left with val x = 10 but if you do that on the second one you get x = 10 which isn't a declaration any more, but an assignment. There's also the fact that the val and var keywords have important meanings in themselves. What you are proposing, to have the type information in between the declaration keyword and the variable name, is perfectly possible but I'm not sure I've ever seen it done anywhere. That doesn't make it wrong though, just unusual.
It could be argued that using assignments as expressions is somewhat of an antipattern (even if it can make some code a bit more compact at the cost of readability).
But there are plans for function references on objects? :D
You could write them as "tests" (i.e. to be executed with a test runner), and just not assert anything ...
Huh, I guess I've got outdated info. Thanks for mentioning, although it doesn't solve the problem.
That's still a lot compared to how you declare and run unit tests. I guess the best option would be to write such an IDEA plugin myself...
KDoc supports embedding samples, incidentally - https://github.com/Kotlin/dokka
I for one really enjoy the types being after the name. It's just like UML style.
The feature is still planned. However, right now we're focused on finalizing the 1.0 release, and we don't plan to work on any new language features until after 1.0 is released.
Wasn't this fixed recently? Like, last week
I would try [JMockit](http://jmockit.org/), which is a more powerful framework in any case.
Using something like mockito feels flakey. Your other options are to design with testing in mind using delegate classes. Also, check out the spek library (unrelated to mocking).
Great job! The language is already becoming the première choice on the JVM in my mind.
Of course. In a small project however, it seems overkill to create interfaces for _every_ class you want to inject somewhere.
Can't wait to use some new language features after 1.0 :D
Because the foreach fn doesn't have the infix modifier, which is required now. Add a . before foreach and you're good to go.
So the `a forEach f` syntax is discouraged now?
It's not just discouraged - it will become an error in 1.0.
I feel Kotlin has a little edge because you can write package functions, it has less ritual.
You read my mind. :) Checking out the first few chapters!
From my personal experience, Kotlin is much easier to learn than Java. It's less ceremony and more expressive. Moreover, if you know Kotlin, you have to just get Java syntax to start programming on Java. There are no new concepts in Java agains Kotlin. At the same time Java programmers often have troubles to get new concepts from other languages like extensions, lambdas, delegation and so on.
A big part of the kotlin story is the Java interop. You'll soon be using Java libraries and need to know how to mentally translate between the two. Intellij IDEA has a Java -&gt; Kotlin converter that mostly works, but It's not perfect. Good for taking simple Java sample code and seeing the equivalent kotlin. 
The code in the screenshot computes the number of possible binary search trees for `n` nodes. Before Kotlin, I would've probably used Python to compute this, but thanks to package-level functions, lambdas, sequences, the when-expression and type inference, Kotlin is now my favorite choice for tasks like this.
I feel that Kotlin lacks an official code style guide. There are so many great features in the language that some developers are destined to misuse them which would result in inconsistent codebases. For example, it is inconsistent to define a "fun &lt;T&gt; maxOf(vararg arg: T)" when other similar functions (particularly, maxBy) are defined as extension methods. Something like "fun &lt;T&gt; Iterable&lt;T&gt;.max(): T" would make much more sense.
By the way, looks like all you need is the good old java.lang.Math.max(Double, Double)
That's interesting. Thanks for the insight. I remember being terrified of boilerplate code in C# of all languages, because even then it was confusing! "What's a class?" "Why do I need to put my functions in one, I'm only running a main function." "Public? Static? What?" Throw in having to get familiar with Visual Studio having only ever used Notepad++ and it was a recipe for stress in my class at school. None of us had ever used IDEs before. I feel like Kotlin may have an edge there. There's the online tool linked to from the main website, which means there's no need to learn about IDEs or even command line compiling. One could use Kotlin as an introduction to programming from scratch and ease into OOP and IDEs like IntelliJ later when they want to advance their skills. I just want to be careful. If people ask me for guidance as they learn programming, I don't want to set them on a bad path. As you remember, when programming is fun it's easy to learn.
I tried out ::println, but it didn't compile for me. 
Did you fall in love while writing the code, or while reading someone else's old code?
You're welcome to comment on https://youtrack.jetbrains.com/issue/KT-9329 with suggestions on the specific information that you expect to find in the style guide.
Not OP but I did compile and run a Kotlin app yesterday in 2.0.
I also got that error. Going back to the 1.5 Gradle tools plugin didn't help. People are saying disabling Instant Run helps, but wouldn't Instant Run be disabled on &lt;2.0.0-alpha1 plugin anyway?
It needs to be `(1..3).forEach {}` And yes, [repeat()](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/repeat.html) seems to be the way to do it.
Yeah the IDE is buggy but kotlin itself seemed to be fine
Hey, have you been reading the book? How is it? I've been thinking about getting it myself but I'm not sure if it would help me that much, the preview is really limited.
I've been very busy with school so far and haven't had time to look at Kotlin in depth. I'm planning on reading the first five chapters after my exams are over in mid-December. If I like it I'll buy his whole book.
Swift is interesting but I don't like the Apple environment. As mentioned by yole, Kotlin was announced far before Swift. I feel there were definitely some areas where Swift borrows from Kotlin's syntax although I don't see why that's a bad thing =)
I'm new to Kotlin (been playing around with the koans a bit)... I've tried googling and I see that "!!" is a unary expression, but I'm not sure what it does. Explanation would be appreciated... :) 
&gt; About the origins of both, I would imagine neither had any idea of the others existence until swift was released to the public Swift was publicly announced three years after Kotlin so it's pretty obvious the Swift team knew about Kotlin but not the other way around.
I know, but I wouldn't say it's obvious that the creator of Swift knew about Kotlin. First Apple is pretty notorious for not paying attention to things other than Apple and what's close to that, second Kotlin isn't very well known to begin with especially when they started making it.
I was not referring to any specific issue. I'm just saying that premature "release announcements" are not helpful.
Start with the [Idioms](https://kotlinlang.org/docs/reference/idioms.html) Also, if you like hands-on learning try [Kotlin Koans](http://try.kotlinlang.org/koans) For more consistent and complete dipping into Kotlin it's better to read [the books](https://kotlinlang.org/docs/reference/#books) and [the reference guide](https://kotlinlang.org/docs/kotlin-docs.pdf) 
Try this one: http://hadihariri.com/2013/12/29/jvm-minimal-survival-guide-for-the-dotnet-developer/
I haven't, but I will now. Thanks for the tip!
Don't forget to use coupon code 39jemerov for Kotlin in Action book. It's 39% discount.
I'm also liking Kotlin much more than scala. Even after a year of scala, I still feel confused a lot of the time. It's because of implicit conversions and DSLs everywhere. The DSLs mean I have to consult documentation heavily every time I use a new library. Implicit conversion means I still don't know where a good chunk of the methods I can call on a seq come from. They aren't in the docs even when they're set to their widest scope. I can usually find them using Google, but then I still can't tell how they're being resolved. I've never had problems like that in any other language. There was a void of pragmatic, modern, statically typed languages and Kotlin along with swift have finally filled it. 
Commenting now to add that (IME) Compilation and IDE errors mentioned are no longer a problem, and it compiles faster than *c* now(C what I did there) 
That is fair, this might be less a useful library and more a proof of concept of how powerful kotlin is that you can extend it to do things so idiomatically similar to other languages. That said, I do think swift's optionals are flat out better-handled than kotlin's except when used in generics -- the syntactic sugar around if-let and guard is very preferable to me. That is why I created this snippet. 
So I would need to explicitly wrap it in an instance, or is there a "Kotlin way" to do it? EDIT: Made a workaround with an invoke() method on a companion object to "cast" it to the interface.
Even better: fun findPairless(a: IntArray): Int = a.reduce { a, b -&gt; a xor b }
Care to share an example?
Interesting idea, for a performance benefit perhaps offloading the function to a "global" library that lazily creates the first instance and thereafter returns the same object. This would be great for performance reasons!
Even less reason to fret about a function interface wrapper I only instantiate at bootstrap time :D.
C# extensions are contained within static classes so I thought that the same conventions applied here, but now that I think about it I guess it doesn't really make sense. Thanks.
I've been using this pattern... interface Handler { fun handle(context: HttpContext) } fun handlerOf(body: (HttpContext) -&gt; Unit): Handler { return object : Handler { override fun handle(context: HttpContext) { body(context) } } } Then use it in the class that consumes the SAM like so... class Consumer { fun consume(handler: Handler) { // .... } fun consume(body: (HttpContext) -&gt; Unit) { consume(handlerOf(body)) } } But really, I've just stopped using SAMs as they aren't needed in Kotlin, even less so when type aliases come in and we can stop repeating the function signature everywhere.
The danger here is that if mayBeNull shouldn't be null, then if it is (eg. due to a bug), this will fail silently, just not executing doSomethingWith(it). In many cases this will not be the desired behavior, and could lead to hard-to-find bugs, so it's worse than using !!. (because at least then you get an NPE and know something is wrong)
Just goes to show how powerful extension functions are.
I agree. I like it though, because if you do find you need to bypass it (though I can't think of a reason), it forces you acknowledging the risk. It also brings the risk to the attention of the readers as well.
True. There are situations where the smart-casting doesn't figure out that something can't be null even when it really can't be null, such as with more complex boolean expressions in if/else constructs. I guess Kotlin's compiler will get smarter about this with time.
Is this what you are looking for? @Entity class Conversation(@Id var id: Int, var user_id: Int) : Serializable This is a shorthand for this @Entity class Conversation : Serializable { @Id var id: Int var user_id: Int constructor(id: Int, user_id: Int) { this.id = id this.user_id = user_id } } If you want default values and a parameter-less constructor, do as /u/thisisamirage suggests and set default values. @Entity class Conversation : Serializable { @Id var id: Int = 0 var user_id: Int = 0 } 
&gt;Properties can be used as parameterless function objects &gt;Example: in Kotlin `String::length` is a property, not a function, but it’s convenient to be able to use it where a function is expected, e.g. &gt; val lengths = strs.map(String::length) &gt;So, we now allow this. In other words, whenever some API expects a function of type (R) -&gt; T we can use a reference to a property of R whose return type is T. FINALLY
&gt; * yield is reserved as a keyword &gt; * sealed is reserved in front of “when“ &gt; * typeof is reserved as a keyword. In JS, use jsTypeOf() &gt; * async is reserved in front of “{” and “fun“ FUCK YEAH
After spending some time trying to learn Scala, the biggest weakness of Scala that I've found is its complexity. Onboarding can be difficult, and managing a large software project is also hard. Throw in Scalaz, and you're going to be spending more time in code reviews than anything else. This is what I think the biggest weakness for Scala is. Developer productivity includes the whole process, not just the typing on a keyboard part.
Yes I wait for C# like async await
He can also go this way: @Entity class Conversation(@Id var id: Int = 0, var user_id: Int = 0) : Serializable From java point of view this class with have 4 different constructors.
Are you talking about the implicit return a lambda can do? Using your example, I believe its not a yield but this that is happening. private val netVars by lazy { val map = HashMap&lt;Int, NetVar&gt;(16500) var clientClass = ClientClass(firstClass) while (clientClass.readable) { clientClass = ClientClass(clientClass.next) val table = RecvTable(clientClass.table) if (table.readable) scanTable(map, table, 0, table.tableName) } return@lazy Collections.unmodifiableMap(map) }
Check out what it does in python. You can basically have something like this: fun f(): Sequence&lt;Int&gt; { for (i in 1..10) yield return i; } 
Thanks for the info!
Lateinit is the language level equivalent to notNull, it has less overhead and confuses reflection based libraries less because it doesn't create all the delegate stuff. 
Looks really useful, thank you! I'll have to check it out when I have time to explore using Kotlin with Android.
Nice summary, Nat. &gt; I decided to have a look at some other “post-Java” JVM languages. Personally, I refer to Kotlin and Ceylon as "post-Scala" languages (since I consider Scala to be a post-Java language). &gt; There’s no way to define the following function for any type that has an add operator method. Yes. I think Kotlin gives you 90% of Scala with 10% of the baggage but that's part of the 10% you don't get. Maybe a way to add type classes and/or higher kinds to Kotlin would be to generalize the idea of extension methods to types ("extension types"?). For example, I could define an adder interface: interface Addable&lt;T&gt; { fun add(a: T, b: T) } and then specify that the existing class `Int` implements `Addable` via an extension mechanism. For example using this made up syntax: override class Int: Addable&lt;Int&gt; Once you have this, you can write your `add` function on all types that belong to this type class. The parallel with extension methods should be obvious: extension methods let you add methods to classes that are already defined, extension types would let you add interfaces to types already defined. 
See /u/yole's post for the general answer but in this particular case, you could simply if (! x.failed()) x.result().send(...) No need for `return`. 
Best workaround I could find so far is wrapping the fold with an [IIFE](https://en.wikipedia.org/wiki/Immediately-invoked_function_expression), but this feels hackish to me. Any better ideas? val firstEvenSum = fun(): Int { array.fold(0, {acc, n -&gt; val sum = acc + n if (sum % 2 == 0) // returns from anonymous function, not from lambda return sum sum }) throw NoSuchElementException("No partial even sums") }();
Yes, that would be awesome. That's pretty much how Rust's traits work (they're quite different from traits in Scala, closer to type classes in Haskell or Purescript). After using Rust for a while, I've started to miss its traits when writing in languages that do not have something similar.
Have you considered using the "to" infix function that Maps have in Kotlin? I think it'd be a lot better than the arr setup you currently have in menuitem
I love it... makes me wish we had ":" for Pairs (instead of the `to` extension, and [] for arrays though.
Thanks for the feedback! &gt;Why GPL for a utility library? A project like this is just a coin for thought. I believe it should be able to be used without having to make your codebase libre. License has thus changed to the MIT license. &gt;Have you considered using the "to" infix function that Maps have in Kotlin? I think it'd be a lot better than the arr setup you currently have in menuitem May you expound? If you're suggesting using an infix function "to" to map values then I made this change. Using "to" to mark an array value doesn't make sense to me. Before choosing to use "arr" I tried implementing an extension function of a lambda for "unaryPlus" but I had trouble with it. ``` operator fun &lt;O&gt; (KTON.() -&gt; O).unaryPlus() { arrays.add(kton(this)) } ```
This is getting there - I might look at marshalling to Jackson... Having to mark each item in an array seems odd. Better to map the name to a function that creates an array? "menuitem" to arrayOf { {"value" to "New"; "onclick" to "CreateNewDoc()"} {"value" to "Open"; "onclick" to "OpenDoc()"} {"value" to "Close"; "onclick" to "CloseDoc()"} } 
That's a great suggestion, I didn't even think about this mechanic possibility in Kotlin. I'll see what I can do.
Hey, I attempted some stuff. I first tried using your suggestion. Unfortunately you cannot use varargs as infix past 1 argument.. so the code ended up looking like this: "menuitem" to arrayOf( { "value" to "New"; "onclick" to "CreateNewDoc()" }, { "value" to "Open"; "onclick" to "OpenDoc()" }, { "value" to "Close"; "onclick" to "CloseDoc()" } ) Which is cool I guess but IntelliJ's formatting seriously disagrees. I believe it's not worth the trade-off because users would then need to configure their formatting. I then attempted my old shorthand using `unaryPlus`. I don't think it's possible to use `unaryPlus` with this function without explicitly stating the type (as in `+{ k: KTON -&gt;`): ``` operator fun &lt;O&gt; (KTON.() -&gt; O).unaryPlus() { arrays.add(kton(this)) } ``` So I then attempted a numeric cursor system. It seemed to work fine but I then realized that the system would no longer support multi-dimension arrays. Here's the prototype: https://gist.github.com/Jire/6ecb8315a963ec653b14
I'm surprised the array formatting isn't happy - I'm guessing that it's having ; separated items is the problem? I guess a friendly format should use either inferred semis or commas, but not both in different contexts. 
Ah sorry. The formatting goes crazy when I tried to make an extension function on `String` called `arr`, so I could use it like this: "menuitem" arr( { "value" to "New"; "onclick" to "CreateNewDoc()" }, { "value" to "Open"; "onclick" to "OpenDoc()" }, { "value" to "Close"; "onclick" to "CloseDoc()" } ) I also came up with another potential style (that doesn't have formatting problems): arr("menuitem", { "value" to "New"; "onclick" to "CreateNewDoc()" }, { "value" to "Open"; "onclick" to "OpenDoc()" }, { "value" to "Close"; "onclick" to "CloseDoc()" } ) **UPDATE!! (NEVERMIND: Formatting goes out of control with this)** I think I found a solution! To build an array: operator fun invoke(vararg bodies: KTON.() -&gt; Any) Then can use it like: "menuitem"{} ( { "value" to "New"; "onclick" to "CreateNewDoc()" }, { "value" to "Open"; "onclick" to "OpenDoc()" }, { "value" to "Close"; "onclick" to "CloseDoc()" } ) In the meantime I came up with a cool hack for making varargs anywhere: class Varargs&lt;T&gt;(initial1: T, initial2: T) { val list = ArrayList&lt;T&gt;() operator fun rangeTo(t: T): Varargs&lt;T&gt; { list.add(t) return this } init { list.add(initial1) list.add(initial2) } } operator fun &lt;T&gt; T.rangeTo(t: T) = Varargs(this, t) Can be multilined: `val vargs = "hi".."this".."is".."cool!"`
This isn't my project, but I'm interested in it because I often have the need to represent values in tests. Having a way of laying these out so they are easily readable, compile, syntax highlight etc would be a win
It's a fancy way to build a string to value map. It is significantly faster to access because there is no initial disk read... but I don't think the speed is important. What is important to me is it shows what you can do in Kotlin. It gives you an easy syntax to build the string value map (like JSON) but in pure compiled language code. As seen with Kara web, imagine having a whole ecosystem where the only language you use is Kotlin. This could be a part of that and that ecosystem I'm talking about is something I'd love to see.
Thanks for the link to JMockit - looks interesting.
Wouldn't waiting until after, break compatibility? Right now you have the benefit that you can break whatever you want, so it's prolly best to get it right before you're stuck with it forever 
No, we've taken steps to ensure that this change will not break compatibility.
[`@Transient`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-transient/)
Replace the new Callback.... With a lambda and it should clean it up a lot.
Something like this: (warning, I haven't tried this): firstNameCol.setCellValueFactory { p -&gt; p.value.firstNameProperty() }
Ah, I see that in the interop page now. Thanks, I get why it's needed now. 
Well they [explained in their blog](http://blog.jetbrains.com/kotlin/2011/08/why-jetbrains-needs-kotlin/) that Kotlin was created partially to increase their own productivity and full Java interoperability was necessary so they could use Kotlin with their existing code base, so I'd guess now that the language is nearing 1.0 they are starting to use it more internally.
I'm upset that this isn't called KotLINQ.
Does kotlin have any code quotation features that would enable linq to SQL? 
On android there's anko. It has something like that 
global functions / vals
100k LOCs of kotlin for a license server? What does that license server do? 
Are you talking about package-level functions / vals? They are not quite global. Or is there something REALLY global i've missed?
Using function types for everything. Interfaces still have their place. Inlining methods without lambdas or reified generic parameters for "performance" reasons without measuring.
While on this topic.. Is instead of if (thing not null) { big block}, using the let syntax and the safe call operator? It'd actually be making an additional function, yeah. Wonder what that's like in a hot loop. Assuming I'm concerned about nothing at all
It would, and that is the idea. Often times you'll have if (not null) do thing kind of logic. Especially true in games. Null or not, is often a representation of state. (actually it's used pervasively in apps too) 
I don't understand the hate this comment is getting. I've actually found it useful to use object classes for namespacing. There are very few functions I would consider important enough to pollute global autocomplete.
That's only registering an Array, not the kotlin equivalent of an Object[]. The latter is the error I am getting, that Object[] isn't registered.
In the situation you describe its usage would be fine, the danger is that people use it as an alternative to !!.
I'll preface this by saying that I like this guys blog, but I *may* disagree w/ him on the if/let choice. (why 'may disagree'? because my mind isn't made up, I'm not sure which is better). There's an easy way to still have an "else", you can use a return from w/in the let portion of the code (excerpt from some code I'm playing around with): ... request.asString().body?.let { if( log.isDebugEnabled ) { log.debug("Post return: '$it'") } errorChecker.checkResponseForError(it) return responseHandler(it); } throw StockfighterAPIException("Could not parse the response.") } ... So if you are keeping your methods short (and you should be keeping your methods short), then you probably shouldn't need any code after the if/then/else/endif // let/null. So the above code works, and with short methods (and only with short methods), it is still very readable and shouldn't cause any maintenance problems.
Tried register( Array&lt;Any&gt;().javaclass) But kryonet doesn't seem to think it's registered still. Still says Object[] isn't registered 
I agree but I wish there was some way to convert to SAM types!
Isn't the point of let to actually not use a local variable? By using a local variable you can only discard the object at the end of the function scope (providing you don't manually null it, which is silly, especially if it is not nullable). If you instantiate an object and immediately use let on it, the gc can swipe it much earlier. If you have a large number of those temporary objects, and if they are of different types, you need to have as much local variables as you have types. This polutes the environment and you need to come up with meaningful names. You also end up with code that looks "flat". To fix this, you have to use code blocks, which would make this suspiciously similar to a let construct, but less convenient. If you have temporary variables that "depend on each other", meaning you only use some for calling methods on others, you need to use the same code blocks in order to restrict the scope of the depending variables. The let construct is perfect for that use case. I really see no reason not to use let for most use cases. However if you only need to check for null, by all means do an if. Using let only for this is definitely not KISS.
&gt; By using a local variable you can only discard the object at the end of the function scope (providing you don't manually null it, which is silly, especially if it is not nullable). If you instantiate an object and immediately use let on it, the gc can swipe it much earlier. I'm not sure, I have a feeling this would make no difference in practice, since the GC doesn't clean up objects the moment they are no-longer used, it's more efficient to do it in batches later. Only benchmarking would convince me one way or the other though, but trying to "help" the GC is normally a waste of time because it's smart. I thought that the point of let is to convert a mutable field into a local var, so that smartcasting works (smartcasts can't work on a mutable field because they can't assume the field won't change mid-way through).
I would argue that let doesn't hinder readability. On the contrary.
Any construct can be misused.
I would go with extension functions. They're there for a reason :) it feels idiomatic
Would you mind elaborating? I forget what polymorphic means :)
Ah, gotcha. Are there any benefits of object methods beyond the ability to be overridden in a subclass?
Note that this post is about `let` on nullable references, not `let` in general (which I use a lot in my code). 
Fine then. I misunderstood.
Also read the higher order functions page 
Polymorphism lets you avoid duplicating code by writing logic once that can be applied to many different types of object.
Yeah, that would have been my option aswell. Thanks :)
In general case, the answer is no. In this particular case, the Kotlin standard library has its own extension methods that make it unnecessary to use commons-io. https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-reader/index.html https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/index.html
Serving licenses
http://wolframalpha.com/input/?i=%28100%2C000+*+100%2C000%29+mod+2%5E32&amp;x=0&amp;y=0
try ctrl+shift+p on the expression after the assignment operator EDIT: ctrl+q on the variable name should also give you the inferred type
Ah, cool - although it doesn't seem to work on a variable declaration, only when the variable is used.
Apologies, I edited my comment before your reply.
No problem :D
Why should we use this over RxJava?
RxJava is an amazing library. In my experience using RxJava (and Akka, Play Iteratees), the sweet spot with RxJava is with Streams and not one shot Observables. That's when you can take advantage of things like a reactive subscriber (with back pressure). If all you want is a one shot Observable, and perform some more computation asynchronously, Promises (Futures) libraries are better suited., because of the low cognitive overhead of the interface. This library is trying to do exactly that (and not having to blow my method count budget on Rx - on Android). 
Thanks for your explanation.
&gt; If all you want is a one shot Observable, and perform some more computation asynchronously, Promises (Futures) libraries are better suited., because of the low cognitive overhead of the interface. I would still use RxJava for one shot observables, you haven't really explained why Futures are superior.
Interesting. I haven't done nearly enough programming with futures so the fact that you can flatMap them together actually really piqued my interest. Any examples of future-based programming in any language? I don't get much free time so I don't know when I'll be able to play around with them.
I have linked to the Scala version in my post (it's part of the Scala standard library). Twitter has a bunch of extensions which are pretty cool. Java 8 has a CompletableFuture which should have looked more like a normal future (alas has very weirdly named methods). Google authored a ListenableFuture which is quite popular (The Java 8, Google's LF is more imperative than functional though, so no sugar like flatMap). Also check out [Reactive Streams] (http://www.reactive-streams.org) which is something the guys from TypeSafe, Netflix et. al. are collaborating on. They are modeling consistent core APIs that all Stream implementations can depend on, so they can talk to each other easily. 
Code posted. The error [is documented](https://kotlinlang.org/docs/reference/operator-overloading.html#binary-operations), so its not exactly that I don't expect it, but I'm wondering if there's a way to get around it.
These tasks don't even seem to compose, why would I use this over Rx?
No, it is not complete. It is a working in progress. 
&gt; It is now Java8 based. Java6 is still possible, but I see no reason. 95% of my customers are on Java8 and Android will support Java 8 soon. Do what you've got to do but that is very false. Even if OpenJDK makes it into Android N, you're still looking at 1-2 years before even a majority of android devices support it.
What are you trying to accomplish? Kannotator has no use for recent versions of Kotlin, because the external annotations that it can generate are no longer supported by the compiler.
hmmm pity they didn't mention that in readme.md - I'd hoped it was some kind of automated way to ensure I had the right kotlin function signatures for a binary library (java jar)
We just pushed an updated readme.
Draft changelog: https://gist.github.com/abreslav/f60fc0de060e7ed721c9
Anyone know how to copy a (possibly-null) map to MutableMap now? I previously used `val newMap = map.toLinkedMap()` and `val newMap = map?.toLinkedMap() ?: linkedMapOf()` but `toLinkedMap` is now deprecated and an error. `LinkedHashMap(map)` is an NPE. Do I just need to write some Map.copy() style extension function and put it in all my projects?
On deprecated declarations You can call quickfix, for `map?.toLinkedMap()` You'll get `map?.let { LinkedHashMap(it) }`.
I agree.. Macros have their place, where annotations can't fit in. In some cases you really *need* them to do things optimally. Sure they can be abused but so can any feature. 
Is anyone else having trouble with Intellij? It keeps telling me that I need to configure Kotlin for my project. I didn't have this problem before. 
Aren't inline functions enough for that use case ?
Not even close. With macros you got programs that write programs. You can abstract away basically any repeated pattern in code.
The documentation on the Web site is not an "overview of some of the features"; it actually covers all the features in the language. It's not a tutorial, in the sense that it does not explain you how to start programming in Kotlin, but it does give you all the details that you will need to use the language. For a more step-by-step experience, please try the Kotlin koans: https://kotlinlang.org/docs/tutorials/koans.html Also, have you tried the book? https://manning.com/books/kotlin-in-action
haven't tried the book, thanks for the links
Can't you make a delegate out of this ?
Well, returning a new array would be concat. `a + b` is a concatenation operation to me (does not modify either a or b).
Right. I will admit the wording in the title is inaccurate, but it seems you didn't read the text.
It's inaccurate wording on my part. I'll redo the post.
How did you solve the problem? Do you know the solution to both alternatives? Please post them if you do!
Why don't you use add all? Probably makes it clearer
If anything this was an oversight on the JDK side and Kotlin fixed it using compiler magic. Usually you would design your API to specifically prevent these kind of signature clashes. 
Perhaps. But it is quite tricky to figure out. It could help if a Kotlin version of the SDK javadoc was present somewhere. In that version ideally the inaccessible method would not be around. 
Thanks for the feedback guys, I just updated it to support camelCaseNotation :-)
If this is okay to you, why were you using DI in the first place? I don't see how companion objects make DI more or less useful in kotlin 
What you describe is just a classic singleton pattern that holds dependencies. There is no actual dependency injection nor inversion of control which is a big win and the primary reason you use a DI library. Phrased another way: do you need to change dependencies based on some condition (e.g., I need a different OkHttpClient for tests or when connecting to staging)? If yes, then companion objects (just like singleton dependency holding in Java) will not work well.
This logo wouldn't look as good as the current one in black/white. I'd prefer the current logo, although I have to admit that the shown loge fits better with the new branding.
I like the shape, but I don't like that middle orange line have gradient that looks weird when around blue.
As of right now, I don't. But I could see that changing in the future. Rebuilding my app in Kotlin, plus gaining a better understanding of Android's activity and fragment lifecycles have lessened the amount of objects I have to inject. (Went from 15 to 3). I was most concerned about the activity lifecycle, which is one of the many reasons to not use pure static singletons in Android. Since companion objects are actual objects at runtime, it seemed like a simple way to get "global" objects. But what you described makes sense too. Thanks!
not necessarily a replacement for dependency injection, but I have been using context objects object Context { val dataSource: DataSource by lazy (mode = LazyThreadSafetyMode.SYNCHRONIZED) { val ds = HikariDataSource() ds.username = "root" ds.password = "password" ds.jdbcUrl = "jdbc:mysql://localhost:3306/search_engine" ds.driverClassName = "com.mysql.jdbc.Driver" ds.maximumPoolSize = 10 ds.minimumIdle = 10 ds } val executor: ExecutorService by lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED) { Executors.newFixedThreadPool(10) } val dbi: DBI by lazy (mode = LazyThreadSafetyMode.SYNCHRONIZED) { DBI(dataSource) } } //later access Context.dbi 
This is fantastic news! Congratulations to everyone involved with bringing this to life. Android and many other systems will be so much better from now on.
Congratulations!! Thank you Kotlin community and team!
if you write val price = 30.0 kotlin will automagically determine it's a Double
val/var determine whether the thing is immutable this is a separate concern from the type also, it's trendy to put the type after the identifier and a colon 
&gt;Double explicitDouble = 30.0 Is `explicitDouble` mutable or immutable?
ahh I see the point, didn't realize this until chillaxtian's comment
"val/var determine whether the thing is immutable" - didn't realize this, thanks for pointing it out. Still don't understand the point of the ":", it uses an extra character. var Double size = 30.0 // two less characters ": ", plus you have to press shift for the colon
I want to make a suggestion to the author / community that the kotlin for android book should be made free if they want to make it popular among the developers. Congratulations to the team on the release.
Tooling: I want a Kotlin Worksheet similar to the Scala Worksheet (from the Scala plugin). It's really useful in just writing and testing out random code
I'm with you on method references. This needs to happen.
async/await
Incremental grade compilation over anything else. This would boost my productivity tenfold. 
&gt; Scala Worksheet it looks similar to Kotlin REPL (See Tools -&gt; Kotlin -&gt; Kotlin REPL) but with completion, isn't it?
Koans is a great way to try the language, I recommend it
The extension methods aren't in the standard library, but in a separate library called Anko: https://github.com/Kotlin/anko
Aaaawesome! Thanks for that! Have to say, I'm loving Kotlin so far!
This rebranding that Jetbrains is doing, including the new Kotlin logo, reminds me of dated '80s graphics and logos. :/
* REPL +with completion+ * fix support for android databinding https://youtrack.jetbrains.com/issue/KT-8007
The only thing needed to fix Android databinding is for the Google team to recompile the databinding compiler with Kotlin version 1.0.
The whole thing called "type-safe builders" and is kinda [described in Kotlin docs](https://kotlinlang.org/docs/reference/type-safe-builders.html). 
Type conversions/promotions are not supported intentionally, and we don't plan to introduce them in later versions. Your example is trivially rewritten as `val d = 10.0`, which does compile, and in practice many other cases where you'd expect to need type conversions also work.
1) It's like this because this is how Java implements the `toString()` function on arrays. You can use the `joinToString()` function to print a nicer representation of an array: `array.joinToString()`. Another option is to use collections instead of arrays - collections do provide a proper implementation of `toString()`. 2) Declaring any variable as `val` means that this variable cannot be reassigned to a different object. It does not prevent you from modifying (mutating) the object referenced by this variable. This is not specific to arrays; this applies to any object. The `final` modifier in Java works in exactly the same way. (And once again, if you use collections instead of arrays, then you'll be able to use `Collection` for collections that you don't want to mutate and `MutableCollection` for those that you do want to mutate.) 3) There is no magical solution here. If the Java code uses annotations such as `@Nullable` and `@NotNull`, then Kotlin will let you know where you need to check for nulls and where you don't. If the Java code doesn't have such annotations, then it's up to you to check when a Java method can return `null`, and to add appropriate checks.
Okay thanks for info yole. You helped me! Can you also explain me where the benefit of data classes is? I know it implements methods like getters and setters and some others but how do I save time writing code with them if I mostly need conditions for the setters? Is there a way to see if I access variables directly because of visibility or if I'm using getters/setters? This isn't clear to me.
Data classes are primarily intended to be used for small immutable data structures. If you have a class which has properties with setters, and if you have custom logic in those setters, then this class should not be a data class. For any class that you define, any code outside of that class will use getters and setters to access the values of the properties. The backing fields storing the values of the properties are always private to the class and cannot be used outside of it.
Cheers! Ye, still need to spend some time going through the docs. Basically just googling stuff as it comes up at the moment!
Kotify. The -lin is inferred. 
Aren't data classes also supposed to be used in pattern matching, ala ADTs? At least when sealed traits are fully implemented I suppose.
https://kotlinlang.org/docs/reference/control-flow.html It states "If you want to iterate through an array or a list with an index, you can do it this way: for (i in array.indices) print(array[i]) Note that this “iteration through a range” is compiled down to optimal implementation with no extra objects created." I think this is standard with most languages that use an iterators in loops. 
They closed an issue reporting this problem, saying that it is Kotlin's fault. https://code.google.com/p/android/issues/detail?id=200466 Are we stuck?
I vote for *Kotlify*.
OK, so it says that this particular form of iteration does not create an object to represent the `Range` value returned by the `indices` property. It does not say anything about the iterator object in other forms of iteration. For reference, here's the code that generates bytecode for various forms of `for` loops: https://github.com/JetBrains/kotlin/blob/master/compiler/backend/src/org/jetbrains/kotlin/codegen/ExpressionCodegen.java#L556
The best thing to avoid NullPointerExceptions when using Java code is to use the [Checker Framework](http://types.cs.washington.edu/checker-framework/).
But but I cant change the title, but the question was not about the title of the question :P, is about how to use mockito in a "kotlin way". Anyway thanks for the comment :)
I'm failing to see which benefits a wrapper class gives you in this case. You could just put all the extension methods in 1 file and it'd be exactly the same without creating a new class. I guess one thing to keep in mind when using extension functions is to not make them global if their semantics aren't understandable in every context. For example, in my Sudoku class, I had an extension function Integer.row() to convert an int to its corresponding sudoku row (a char). I made sure to define this extension function private within the Sudoku class, since it wouldn't make any sense outside the Sudoku class.
IntelliJ will highlight them differently and you have to explicitly import them to use them. I don't really see, how you could not tell where they come from.
``` bar::foo // can't, refs to methods of instances aren't supported ``` ``` messages.forEach(::println) // can't, idk what variant of println to call ``` Afaik rest of references already work, but there two are the most useful, so it's kinda not fun without them. 
I use Android Studio for kotlin development and it detects is displays refactoring inspection **Alt+Enter &gt; "Convert concatenation to template"** which does the thing. Another option in any tool is to use regexp. In Intellij Idea you need to replace **\" \\+ (\w+) \\+ \"** with **\$$1** (optionally add brackets **\$\{$1\}**)
There is really [no overhead](http://stackoverflow.com/a/256861) using foreach. 
Oh, memory overhead. Okay. Still, *never* using foreach is premature optimization. Obviously if an area is "hot" steps should be taken to cool it down. But unilaterally ignoring foreach across the board could lead to some frustrating to read code with no substantial performance benefit. 
Oh neat! Thanks for your hard work.
var explicit = 30.0 also works. It just needs the assignment to know what the type is. If you didn't want to assign the value yet you would need the type. Like this: var price: Double
I get some error now about property having a backing field, although I defined it as a property... i don't understand how to fix it. `private val RAISE_MULTIPLE : Int = 2`
You need to post more code than a single line, there's not enough context 
well, that's the thing... there isn't really much more - that's why I can't figure out this error message. There are 3 of these constants, all fairly similar with different names of course. They're in a class and there are a few other methods (2 in the class, 2 in an inner class) that don't relate to these constants, none of which have any syntax problems.
You could also use Qualified Returns (https://kotlinlang.org/docs/reference/returns.html).
So if the lambda was passed down three function calls, and then actually used, would those stack frames all the way to the original function call of the closure be discarded, or just the one where the lambda is called?
Does not sound like an error message to me. Could you please post the complete message and a code snippet? 
Makes sense, thanks.
Or anonymous functions. (https://kotlinlang.org/docs/reference/lambdas.html#anonymous-functions) While uglier than lambdas, they do support returns without the label syntax.
I'd like extension methods for different instantiations of a generic type to work without having to annotate them with @JvmName. E.g. if I have a type `Statistics&lt;T&gt;`, currently I cannot define two extension methods `Statistics&lt;Double&gt;.toJson()` and `Statistics&lt;Int&gt;.toJson()` without getting the error: Error:(46, 1) Kotlin: Platform declaration clash: The following declarations have the same JVM signature (toJson(LStatistics;)Lcom/fasterxml/jackson/databind/JsonNode;): I have to use the @JvmName annotation to give them different JVM signatures. But extension methods are bound statically, so it should be possible for the compiler to distinguish between these methods, and generate distinct names for them.
but what happens when there is a field of that name in a subclass or an subclass of the subclass, etc? will code that checks that subclass field still work? e.g. A extends B (B is java class), B extends C (also a java class)... C also has .x - so if code in C does if (x == 5) check and some other code before that does A.x = 5, will this check return true?
If `x` in `C` is private/protected, you'll need a getter/setter in `B` or `C` anyway, to access `x` from the outside. `a = A(); a.x = 5` will use the Java setter method and `if (x == 5)` in `C` will use the Java field. You can easily experiment with different use cases. To study them, just write these classes yourself, try to access `x` within and outside of `A`, and follow the object reference you IDE gives you. IDEA also has a Java bytecode viewer for Kotlin classes (Tools &gt; Kotlin &gt; Show Kotlin Bytecode). `a.x = 5` just generates a call to `a.setX(5)`. 
You sure it's an error? IntelliJ highlights properties that have a backing field - this is not a bad thing. By the way, if you want to add constants, use companion objects. class XYZ { companion object { const val RAISE_MULTIPLE = 2 } fun doStuff() { fooBar(RAISE_MULTIPLE) } } 
or, treat inline functions with lambda parameters as code blocks.
I've had issues when running executables. If the main method is outside of a class you need to make sure the class path is pointing to the generated file e.g. com.example.MainKt if it's in a class put it in a companion object and add a @JVMStatic to it. I'm on a phone so take this with a grain of salt.
And I also entirely missed that your using an eclipse plugin. I use intellij so my answer is probably a bit off base.
[**@joewalnes**](https://twitter.com/joewalnes): &gt;[2016-02-22 15:25:52 UTC](https://twitter.com/joewalnes/status/701790012476682240) &gt;Which alternative JVM language are you betting on? ---- [^[Mistake?]](/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/47i82j%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
`defer` keyword to run a function after the current method-scope exited. ([golang explanation](https://golang.org/doc/effective_go.html#defer))
Their first example with the equals could be cleaner. Due to automatic casting you can just have fun equals(other: Any?) = other is Task &amp;&amp; other.id == id
Great tip. Thank you. I will correct that right now. 
What was it like before you changed it?
I'm finding myself writing DSL-like APIs as infix extension methods that extend functions and extension methods. Maybe that's going too far. Only time will tell.
Surely the person who wrote the book should be paid for their efforts, no?
It's odd seeing C++ and C# lumped together like that since Java is much, much closer to C# than C# is to C++.
Yes, the author could be paid through donations or better the author should be sponsored by JetBrains. Just saying that there is only one book for Kotlin(for android) and is not free.Making it available for no cost would bring in more developers. 
That's matter of personal preference, I believe. I always preferred placing { on the new line, since I was a student. Nothing to do with C#. I simply prefer more space in between different logical pieces of code. However I don't mind changing if someone explain to me why it is better :) 
Not really. There's good reasons for the existence of style guides and coding conversations. That is why some languages even force parts of it(indentation in python). Consistency is the biggest reason and that if others are going to read Java/kotlin they expect it. Google, coding conversations and you'll get tons of good reasons. Python has a good section explaining some of the reasons: https://www.python.org/dev/peps/pep-0008 My suggestions is to run autoreformat in AndroidStudio and you'll see a lot of things moving. For some reason it's only C# coders that seem to wanna keep their style guide. I have seen this several times before with C# coders. Could be a coincidence though. Not having a style guide is c++'s biggest flaw IMO, and I otherwise like c++11 and forward.
Kotlin "supports" anything written in Java. Right now I'm making a game engine in Kotlin targeting desktops using a Java binding for OpenGL.
I know it's possible to use anything on JVM.. But that won't be idiomatic to Kotlin. This is like saying you can use any mature web solution written in Java when using Scala or Clojure. But Scala has Play and Clojure has Ring. What does Kotlin have for web? I had a look at Kara, doesn't feel like safe enough to invest in.
The difference between Kotlin and some other JVM languages is that if there's a Java library that does what you need and you want to use it in an idiomatic way, you don't need to throw it away and rewrite it from scratch. Instead, you can adapt it to idiomatic Kotlin style by building extension functions that exist side by side with the existing code. https://github.com/MarioAriasC/KotlinPrimavera is an example of a set of such extension functions for Spring, but it's very easy to build your own set of such functions, tailored to your personal taste and requirements. All the existing Kotlin Web frameworks (Kara, Ktor, Kovert) are small and easy to modify, so you can be certain that you'll be able to adapt them to your requirements. Of course, none of them are as mature as Spring, for the simple reason that Kotlin 1.0 was released two weeks ago.
True, but the amount of boilerplate that is already gone in exchange for that is quite impressive. Still, we can always hope for better :-) 
&gt; However I don't mind changing if someone explain to me why it is better :) Your approach wastes a line of code, meaning that less code can fit on-screen, impeding readability. It's not a great argument, but that's the one I've seen. In the Java world the "same line {" convention is widespread, from what I can tell Kotlin has inherited this. If you don't mind switching, you'll probably find that the "same line" convention will make your's and other's lives ever so slightly easier.
I guess it's time to test again :)
One thing is that apparently kotlin doesn't have incremental building yet - it's in the works. 
this means that gradle will resolve dependencies every time too??
No, that's not affected. Only the actual compilation of the source files.
Take a look here http://makingiants.com/blog/fasterboost-gradle-builds_2/, it helped to make it faster.
Sorry for my late reply! I consider Kotlin's beautiful, simple, and predictable syntax to be its bread and butter (okay okay, along with the awesome Java interoperability :P). The ability to return from lambdas was something I had simply expected and was surprised to see not available. Why wouldn't we want this in the language? Does it just boil down to difficulties in implementation? Edit: I see in another reply that this is actually a JVM limitation, that explains it all!
Kotlin *is* another JVM language, but it was one designed from the ground up with clean and easy Java interop in mind. For instance, if you have a javabean type class with getFoo(), setFoo() methods, then this appears in Kotlin like a property (obj.foo = "etc"). Ditto for isFoo() methods, they become a read-only boolean property. Kotlin uses JDK collections like ArrayList, LinkedList etc, but it uses some compiler magic and lots of extension functions to significantly upgrade them without needing to modify the JDK itself. And so on. So ... just use a Java web framework.
Yup
No, `getName` is only accessible through other JVM languages like Java. If the variable is private, Java nor Kotlin will be able to access it.
For private properties, no getters/setters are generated because you won't be able to call them from other class anyway (since they're private). Thus the `getName` function declaration was technically fine in that case.
IIRC kotlin compiles to Java compatible byte code. With the intellij plugin you can see the generated byte code.
You can use decompiler e.g. [online decompiler service](http://www.javadecompilers.com) Just write some Kotlin code, compile it, assembly into jar and upload it. You'll be able to see Java equivalent to Kotlin code. For example this code below fun cases(obj: Any) { when (obj) { 1 -&gt; println("One") "Hello" -&gt; println("Greeting") is Long -&gt; println("Long") !is String -&gt; println("Not a string") else -&gt; println("Unknown") } } will have following Java equivalent public static final void cases(@NotNull Object obj) { Intrinsics.checkParameterIsNotNull(obj, "obj"); Object object = obj; if (Intrinsics.areEqual(object, 1)) { ConsoleKt.println("One"); } else if (Intrinsics.areEqual(object, "Hello")) { ConsoleKt.println("Greeting"); } else if (object instanceof Long) { ConsoleKt.println("Long"); } else if (!(object instanceof String)) { ConsoleKt.println("Not a string"); } else { ConsoleKt.println("Unknown"); } } Of course there will be a lot of calls to the Kotlin runtime.
yep, just cmd+shift+a and start typing 'bytecode', should get you there.
A comment section sounds like an improper solution to this though. Harder to moderate, bound to single maintainers, hard to review and revise. 
There is no such thing, yet. Kotlin is pretty new language. 
That's possible with [IntelliJ from the command line](https://www.jetbrains.com/idea/help/running-inspections-offline.html), too. 
And, by the way, the CI server Team City comes with all the IntelliJ IDEA inspections. But this wouldn't be an option for you in this case.
Went ahead and ran it just to be sure I wasn't missing something; it throws an NPE just like you would expect.
Kotlin assumes that you "probably know" what you are doing and lets you pull that off :)
For contrast, you could try writing it in a full functional style. Make Circle and Soldier data classes with only val properties. Convert the methods on circle to top level functions. And just for kicks, I've started writing test function names on back ticks, removing the need for underscores: @Test fun `test find next living soldier`() { ... }
You might want to take a look at using the `withIndex()` function with for loops, to clean up the while loops in your `circle` class. See the bottom of [this](https://kotlinlang.org/docs/reference/control-flow.html#for-loops) section of the kotlin docs. 
I would use a sequence to create a lazy circular stream and use that to find the last surviving position. [Something like this!](https://gist.github.com/snorbi07/f978685e21b88c574815) Note, I did not verify whether I'm off by one of not ;)
A lot of Android libraries will have a "noop" artifact to have functionality for release builds, like leakcanary. This requires having stubbed out versions of the main classes that must be kept in sync with the main artifact. I wrote this simple library to be able to generate these "noop" artifacts, such that they will always be kept in sync.
I looked hard at JavaFX as a wide platform for game deployment, alas there seems to be no way to use shaders which limits it use greatly...
Is this new info? I think they've been talking about Jack and Jill for a while. But I'm also curious if Kotlin will be able to plug into Jack as well and how that would work. I guess Jack will have its own IR, Kotlin would have to compile into?
I thought it's google who make Android Studio, jetbrains only provide Base Idea platform but don't commit much into android plugin?
Oh its on by default now? I wasn't aware. Thats pretty awesome tho. I hope we hear something soon about Kotlin then for sure.
It will be on by default on android studio 2.1 which was published to canary channel earlier this day. 
Especially since Kotlin had its 1.0 release, I would expect a compiler similar to Jack which inputs .kt files and outputs .dex or .jack files and also does the shrinking/obfuscating/multidexing Jack does. However, even if such a compiler never exists, the linker (Jill) will still be able to take .class files and integrate them into your build. 
jill it's jack ​ and jill​ jill supports classes therefore Kotlin will always just work besides, neither .jack nor .dex are closed source proprietary formats. a Kotlin compiler can be made to emit .jack files. https://kotlinlang.slack.com/messages/android/
Yep. Couldn't have said it better myself.
It's pretty obvious at this point that the kotlin code will go through jill for now, but will there be plans that it will go straight to jack (and perhaps java 1.8 bytecode...) with its own toolchain or using the android toolchain? The compiler is open source ;3
Is the kotlin basics presentation also about using kotlin for android? Can you share a link?
Yeah, sure. I did it about a month ago. Here's the link: http://www.slideshare.net/BartoszKosarzycki/kotlin-developer-starter-in-android-projects 
I use Maven because IntelliJ's Gradle plugin is buggy.
I use Maven, but I use Kotlin on a Java 8 JVM for webapp and server-side development, not Android.
Gradle, but watching Kobalt be developed. Doing server side stuff and not Android.
* [Kotlin Koans](http://try.kotl.in/koans) * [Official Documentation](http://kotlinlang.org/docs/reference/)
Thank you, I had already been using the official documentation.
I used the online version when I started. Thank you though.
Thanks for this, I have already done my own app and converted it to Kotlin. I am learning as I go, and have done some stuff with the database.
Some of the slides are controversial
Read the entire documentation. Seriously. It doesn't take long. Then do kotlin koans. Then work on a project using only kotlin. You will be very comfortable after these steps.
Isn't the bind example just: x?.let { ... }. I suppose you save a character when typing :)
Yeah it's nice not to have to do a nullable member access `?.`, but definitely good to know, thanks! I also updated the post to have a terser implementation based on let (thanks @daniil_vodopian on twitter)
No, the Kotlin compiler can't compile Java code. BTW: The title and your question ask two different things.
You can't put Java and Kotlin code in the same file. However, you can have Java and Kotlin files in the same project and call Java methods from Kotlin and vice versa. EDIT: See here https://kotlinlang.org/docs/reference/java-interop.html
As to your first question, this is easy enough to just test in the Kotlin REPL... class Greeter(val greeting: String) { fun greet(who: String) = println("$greet, $who.") } fun test() { println("ACK!"); return "test" } Greeter("Hello").greet(test()) ACK!Hello, test. (null as? Greeter)?.greet(test()) null As you can see, not only was greet() not called at all, but even the arguments to it weren't evaluated. The compiled Kotlin code first did the null check, then wrapped the rest of the code in an conditional. As for your second question, I'm pretty sure that's just a member property accessor (personalInfo) being used as opposed to the getter method (getPersonalInfo).
&gt; As for your second question, I'm pretty sure that's just a member property accessor (personalInfo) being used as opposed to the getter method (getPersonalInfo). Thanks! I think your right, but if client? evaluates to a non-null object, wouldn't that object in this scenario have the getPersonalInfo method on it? Would't we be able to call it if so? EDIT: I (think?) I figured it out: &gt; Methods that follow the Java conventions for getters and setters (no-argument methods with names starting with get and single-argument methods with names starting with set) are represented as properties in Kotlin. http://kotlinlang.org/docs/reference/java-interop.html So for Kotlin using those Java classes, there is getPersonalInfo method. I presume other methods can be used with the `?.` sytax.
When do we get an updated Eclipse plugin for this?
Did you make this?
Good to hear!!!
Looks really slick. Is there an operator for matching against hamcrest matchers? 
kotlin does have immutable vs mutable collections. they are enforced by an interface however, not by val vs. var https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html 
Because you're creating an immutable reference to a mutable list. That variable can not be assigned to any other list object. If you want to have an immutable list, use listOf(). The concept of an immutable variable and immutable object are two different things, because a variable is only a reference to the object. 
To achieve this efficiently they would have to implement a new set of data structures, I guess. You'd be wondering then why you didn't use Scala in the first place.
~~Kotlin already has the immutable data structures.~~
It doesn't (at this time, at least). Kotlin uses the standard Java collection classes, which are not immutable. The distinction between read-only and mutable collection interfaces exists only at compile time.
One of Kotlin's key objectives is good / easy interoperability with standard Java. Interoperability as in calling java code from kotlin code or vice versa and having that easy / seamless. If you design new and fully immutible collections in kotlin then interop with java will become problematic. Scala has done this, and you have to convert or use magical implicits to work with java codes, its annoying / confusing for new people. So its more of a pragmatic decision / approach ~&gt; sensible compromise to reuse java collections to make Kotlin code work nicely with java. However they have written some stuff to extend upon the java collections, so with respect to your code, use the standard lib / collections stuff they have written / take a look on their doc's about it. They have a "read only" interface you should use -&gt; you cant mutate a list unless you do something dodgy like cast or using the array list directly, i.e. effectively immutable in kotlin code but still with seamless java interoperability. As far as I am aware they are plotting maybe a new immutible collection set in the future as an additional lib. One of the use cases / selling points for Kotlin is writing kotlin code within an established java codebase to get the extra productivty of a safer + more expressive language without having to rewrite the whole project (impossible to do in most cases). For that to happen kotlin and java have got to work seamlessly and have a low learning curve so an existing team of java developers can pick it up easily and safely and use it with the same codebase. Jetbrains I believe experimented with Scala for this years back with their java projects but ultimately it didnt interopt nicely, they still had null / many runtime issues and the learning curve for scala isnt that easy. -&gt; they designed a language to be a better fit for working with java / established java teams whilst given a step forward in safety/expressiveness rather than the approach most other JVM languages took which is just to reinvent the wheel at the cost of interoperability . That being said, it was also designed to work well with android and be a solid language for a new project, i.e. they put alot of thought / consideration about how a language would be used in real world in projects / products rather than just making arbitrarily feature rich language. 
listOf() returns a Java ArrayList behind the scenes. If it leaks into Java code then it may be mutated as the type system won't stop you (and you can also cast away the immutable view). However, listOf() could start returning something like Guava's ImmutableList in future, I guess. The problem, I guess, being Android's stupid method limit. Adding stuff to the standard library causes Android users to complain :(
Because it claims to be immutable, but really isn't.
 var current = this@Stack It's var, mutable property. It's setter looks like `fun setCurrent(value: Stack&lt;T&gt;)` which puts T into `in` position. You can make it `private`, which solves the issue. 
Scala (and Java actually, with `final`) has the same idea, it comes from the difference between what an immutable/mutable data structure is (`list` vs `arrayList`) vs reference immutability (`val` vs `var`). 
I haven't used them, but maybe the two libraries in the desktop section of this page will help you: http://kotlin.link
Stop everything and use electron by github. Electron.atom.io
Thanks. Now when I look at it closer, it seems TornadoFX does provide a way to write properties in a shorter way. I think I'll try that approach.
I heard that [NW.js](http://nwjs.io/) relaxes this difference between *server* part and *client* part. You might want to take a look and compare the two approaches.
I'm only aware of extension **methods** and not constructors but you can still create a package function which mimics a constructor: fun Window(name: String): Window = Window().apply { setName(name) } And call it like this: val window = Window("some text")
As an alternative, if you want some may be better encapsulation, you can use `companion object` and `invoke` operator.
Support for class diagrams will appear in Kotlin fairly soon, so you don't need to use this weird roundabout way. (There are no Kotlin to Java converters; the only option is to use a Java decompiler on Kotlin-compiled .class files.)
cool, would you also know is there any kind of plugin that supports counting of kotlin classes (as a metric) ?
This is not a JVM limitation. Without too much fuss, you could have a `::type` operation on reified type params. List&lt;String&gt;::type Would inline to: object : TypeLiteral&lt;List&lt;String&gt;&gt;() { }.type This would greatly increase the power and flexibility of reified parameters. For example: deserialize&lt;List&lt;Int&gt;&gt;() // deserialization arbitrary&lt;Set&lt;String&gt;&gt;() // generating random data for testing purposes provides&lt;Processor&lt;CreditCard&gt;&gt;() { /* dependency injection */ }
That's a Guava thing that forces a subclass to be created to make a type parameter survive erasure. That's not performant, it's not compatible with the standard JDK (one of Kotlin's core principles is to be lightweight, and Guava is anything but), and it's a hacky workaround. So yes, it's still a JVM limitation. There are ways around that limitation but they require baggage that, thankfully, Kotlin is not willing to take on. 
I could see it being useful if they roll their own `TypeLiteral` definition for sure. I think that it being generated statically at compile-time would be the way to go for sure, because it having a runtime cost would be less than optimal.
To be honest, I would just use intellij idea. You won't get a better ide. And AFAIK you can configure emacs key bindings of you need them. 
My problem with IDEs is that they take too long to start. If I want to modify a program just a bit, I don't want to wait a minute for the IDE just to start. But if you work on a larger project, an IDE can be a better choice. Since my question I've found a kotlin-mode for emacs that I customized a bit. It's available [here](https://github.com/jabbalaci/kotlin-mode).
Dope
How does it compare to [Spek](http://jetbrains.github.io/spek/)?
FYI you can use Java's Optional class
 bar()?.let { f(it) } 
But remember, the objective isn't to cram as much logic in as small space as possible, it's to make the program as obviously correct and maintainable as possible.
Nice job but I wish you spent more time talking about your experience with Kotlin to write a game than describing the game, which makes your post a bit off topic here... 
&gt;fun, var Sometimes a bit more verbosity is needed to improve the code structure. In the first two code examples I can see immediately that the first one is a function declaration and the second one is a variable declaration. In the last two examples I don't. Also it beautifully aligns the identifiers. A keyword for variable declaration is needed anyway, because we want to distinguish read-only and mutable variables &gt;identifier: type Seems identifiers are more important, than types, when reading Kotlin code. Also it supports type inference -- type information for local variables and lambda parameters is in most cases optionally -- so it might be better to append types, instead of prepending them ~~(this convention can be seen on different places. varargs are appended in function parameter lists, lambda functions as last function argument can use the special {} syntax, borrowed from Groovy)~~. fun inky() = "" var pinky: BigInteger = BigInteger.valueOf(42) var blinky: String = "" val clyde = 42 // versus String inky() = "" BigInteger pinky = BigInteger.valueOf(42) String blinky = "" final var clyde = 42 I used a "var" for type inference in last examples, because it is proposed in JEP 286: Local-Variable Type Inference. Also, golang uses the same convention (identifier type) but without the colon.
&gt; var name : String = "skjlfhd" I think type inference is preferred in Kotlin: var name = "skjlfhd" var item = BigNameItemClass()
Saviour! I had tried **arrayOf** but didn't think to exclude the '@'. It now works, thank you :-)
Yes, an extension function is what I meant. The neat thing about Kotlin extension functions is that they don't have to be declared at the top level. You can create an extension function for Cursor inside your own class. https://kotlinlang.org/docs/reference/extensions.html#declaring-extensions-as-members Receiver just refers to the type that the extension function is called on. 
&gt; Java functions I think require the scope specifier for private, kotlin I believe defaults to it No. Defaults to public. There was a long discussion about that. 
Defaults to package.
Ohhh I was referring to Java.
Repo is here: https://github.com/edvin/tornadofx Been using it lately. Good stuff, surprised not to see it mentioned here already.
So you think they just don't think its worth it? I don't think Kotlin is trying to stay totally syntactically aligned with Java
I think you either need the braces around the code block, or the parens around the condition. Having both optional makes it hard to know where one starts and the other stops, particularly with infix functions: if a matches b c foo d Vs If (a matches b) c foo d Vs If a matches b { c foo d } 
yea so this is kinda the reason I thought. Thank you.
Interesting, could you just elaborate a little bit what made things hard in Scala? Would be interested in some inbiased Scala experience report.
I prefer the parentheses; I think it enhances readability, especially if you have multiple conditions under test.
I don't think either is anymore readable then the other. However I have begun writing null checks as if (value == null) return This is amazing. I think the requirement to have parentheses to allow one liner if statements was a smart design. This might seem obvious to you, but I've been heavily in the Swift domain for the last year~. Where such things aren't possible and its drifted from my consciousness. -edit- taking it a step further val value = someFunction() ?: return
&gt; that immutable code is the only sane way to write programs but they are very, very, very wrong Why are they wrong? Genuinely curious.
Wow, looks neat! How easy do you think it would be to port an existing JavaFX app written in Kotlin to this framework? 
A certain amount of alignment is useful. Keep in mind that the same project can mix Kotlin and Java code. Keeping *some* things similar helps Java people grok what's going on, because it's familiar. 
Dammit, if the aim isn't to make every function a single expression, I don't want to play. 
This looks very nice! I thought that [JMockit](http://jmockit.org/) would be more or less the successor of JMock (latest release from 2012!). Why did you, the author, chose JMock and not JMockit?
Inertia! I've been using JMock for so many years (and am a not-very-active committer) so I know how to make it do what I want.
I like the use extension methods, made a jmock test look human readable :O However, one problem I have with JMock in general is the blur between stubbing + expectations. In the codebases I've worked with JMock tests its been my experience you'd change or refactor some code which will perhaps alter the which method calls happen -&gt; loads of test failures as the expected calls have changed. However... fix the expectations in the test and everything is fine again, i.e. the actual behavior / end result of what was happening in the class hasn't changed... -&gt; somethings wrong here, the code wasnt broken / a bug was'nt introduced but test failures happened -&gt; brittle tests + wasting time maintaining them, tests should ultimately catch bugs and facilitate refactoring, not lock down the code for stability. So Mockito for me has much a better definition / separation of concerns with stubbing, expectation/verification -&gt; helps create simpler / more robust tests, especially when paired up with hamcrest matchers and making them focus on the functionality over verifying method calls (i.e. using assertThat more often than verify) Thankfully kotlin can make working with Mockito a bit nicer as well :)
If you're having that much trouble, just get a local copy of kotlin-mode.el and M-x package-install-file El-get isn't all that great, hopefully having it crap on you for an hour has demonstrated that.
I use Emacs + Kotlin-mode and IntelliJ at work, if I have some refactors and other things that the IDE is good for I use [this][emacs-intellij] Also from IntelliJ I have the following setup as an external tool. # Emacs Client command: emacsclient arguments: -n +$LineNumber$:$ColumnNumber$ $DirName$/$FileName$ Which I can use to open the current file into Emacs and have the cursor located at the same point. [emacs-intellij]: https://github.com/ocodo/.emacs.d/blob/4ee41e847027dcb0a79509714cf0d6363396dc3a/custom/handy-functions.el#L791-L800
[Javascript support has been postponed](http://blog.jetbrains.com/kotlin/2016/04/kotlin-post-1-0-roadmap/): &gt; JavaScript Support &gt; &gt; When we started finalizing the 1.0 release, we decided to suspend work on JavaScript support and to focus on the JVM as the main supported platform for the release. Now that 1.0 is out, we’ve resumed work on JS, and we’re moving towards our goal of letting you write the business logic of your application only once and to run it both on the backend and in the user’s browser.
Exactly same problem two days ago, I was trying to setup unirest for android and my app threw error like this, no idea how to fix it
I have maybe bad idea here but: In your application class you could create something like this: class App() : Application() { lateinit var xxx: XXX override fun onCreate() { super.onCreate() xxx = XXX(this) } } then you have your XXX class: class XXX(val app: App) { val database = Database(app) ... } And so you can do something like this: val Context.xxx: XXX get() = (this.applicationContext as App).xxx val Context.database: Database get() = this.xxx.database haven't had time to test it so go ahead if you wish to. I am not saying it is good but might work :) 
Did you see my edit? Check that none of your overridden functions returns a different type than the required super type.
I have thought of this but I need some research to see if it is a good idea to pass Application for context in ORMLite. Anyway thanks
Could you tell us the compilation time differences?
Yes, but I saw that if I didn't resize the heap in both places, it made no actual difference.
I suggest you to try it and see for yourself. Of course, as with anything, YMMV. I just wanted to share my experience.
I've already done it. We have a multi-module project (5 modules), so build times are naturally increased by that. `./gradlew clean build`, once the Gradle daemon is running, takes approximately 40 seconds. `./gradlew clean assembleDebug` takes about 20 seconds. `./gradlew assembleDebug` takes 13 seconds or so. I just ran `./gradlew clean build --profile` and you can see that it's really all the plugins we use that are doing it though. It's death by a thousand cuts. Each one makes the build just a little longer: https://dl.dropbox.com/s/x6ti9rd10y3xzyj/Screenshot%202016-05-05%2012.55.08.png?dl=0
In case anyone's thinking "why would I want to do *that*?", one reason why we might want to have lenses is that they compose to form pointers into nested data structures. Suppose we add a `+` operator to our `Lens` definition: interface Lens&lt;T, V&gt; { fun get(t: T): V fun set(t: T, v: V): T operator fun &lt;V1&gt; plus(next: Lens&lt;V, V1&gt;): Lens&lt;T, V1&gt; = object : Lens&lt;T, V1&gt; { override fun get(t: T): V1 = next.get(this@Lens.get(t)) override fun set(t: T, v: V1): T = this@Lens.set(t, next.set(this@Lens.get(t), v)) } } We can then do this: data class Inner(val ping: String) data class Foo(val bar: String, val baz: Inner) fun main(argv: Array&lt;String&gt;): Unit { val foo = Foo("xyzzy", Inner("ping")) val barLens = Foo::bar.lens() val bazLens = Foo::baz.lens() val pingLens = Inner::ping.lens() val bazPingLens = bazLens + pingLens val foo2 = barLens.set(foo, "quux") val foo3 = bazPingLens.set(foo2, "pong") println(foo) // Foo(bar=xyzzy, baz=Inner(ping=ping)) println(foo2) // Foo(bar=quux, baz=Inner(ping=ping)) println(foo3) // Foo(bar=quux, baz=Inner(ping=pong)) } 
It it certainly possible, btw, to cache a map of property names/KProperty1s for each class, and use it to map the properties of the input object straight into the constructor without having to build an intermediate map. But what I'd really like is a way to use the `copy` method, supplying only the substitute parameter...
Have you tried using property initializer rather than a customer getter? `val Context.databaseHelper = DatabaseHelper(this)` The initializer is invoked only once when the property is created.
Now on [github](http://github.com/poetix/klenses), and in [maven central](http://search.maven.org/#artifactdetails%7Ccom.codepoetics%7Cklenses%7C0.3%7Cpom).
Or, you know, you just do `bar.foo.foo2 = "pong"`. But I agree, it's a bit too readable. 
This is for immutable objects...
 data class Outer(val outerValue: String, val inner: Inner) data class Inner(val innerValue: String) val bar = Outer("outer value", Inner("inner value")) // Without lenses fun innerValueSetter: (outer: Outer, newValue: String): Outer = outer.copy(inner = outer.inner.copy(innerValue = newValue)) val modifiedBar = innerValueSetter(bar, "replaced inner value") // With lenses val innerValueLens = Outer::inner.lens() + Inner::value.lens() val modifiedBar = innerValueLens(bar, "replaced inner value")
Maybe if you have objects with property values that you ultimately want to be changing, immutability isn't what you want.
A common pattern in FP is to model state changes as a series of translations from an immutable value to an immutable successor value. When working with record-like values (e.g. data classes), we often want the successor value to be a copy of the original value with just one property changed. [This is what lenses are for](http://eed3si9n.com/learning-scalaz/Lens.html). Suppose, for the sake of explicitness, we define our Lenses without magic: val innerLens = Lens.of( { outer -&gt; outer.inner }, { outer, newInner -&gt; outer.copy(inner = newInner) }) val valueLens = Lens.of( { inner -&gt; inner.value }, { inner, newValue -&gt; inner.copy(value = newValue) }) It is useful to be able to compose lenses - so we can write: val innerValueLens = innerLens + valueLens rather than having to explicitly write the longer and more convoluted val innerValueLens = Lens.of( { outer -&gt; outer.inner.value }, { outer, newValue = outer.copy(inner = outer.inner.copy(value = newValue)) } Finally, it's useful to be able to write var innerLens = Outer::inner.lens() as a shorthand for the explicit definition above.
Given data class Outer(val value: String, inner: Inner) data class Inner(val value: String, otherValue: String) val outer = Outer("outer value", Inner("inner value", "other value")) what's the easiest way to create a copy of `outer` with `inner.value` replaced by some other value? Here's an explicit method: val newOuter = outer.copy(inner = outer.inner.copy(value = newValue)) And here's a method using lenses: val innerValueLens = Outer::inner.lens() + Inner::value.lens() val newOuter = innerValueLens(outer, newInnerValue) It looks like you're suggesting something like this: data class Outer(val value: String, val inner: Inner) { fun setInner(newInner: Inner): Outer = copy(inner = newInner) } data class Inner(val value: String, val otherValue: String) { fun setValue(newValue: String): Inner = copy(value = newValue) } and then val newOuter = outer.setInner(outer.inner.setValue(newValue)) which is not a great improvement, and furthermore means writing explicit setter functions for all the values you might possible want to update. The "indirection" of lenses is a way to get generic, composable setters across *all* properties without having to write these functions; the "extra code" is a library.
The update case is also worth considering: val newOuter = outer.copy(inner = outer.inner.copy(value = outer.inner.value.toUppercase())) or, given explicit setters on the class, val newOuter = outer.setInner(outer.inner.setValue(outer.inner.value.toUppercase())) versus val innerValueLens = Outer::inner.lens() + Inner::value.lens() val newOuter = innerValueLens(outer) { toUppercase() } And note that `innerValueLens` is *reusable* - it packages up the logic involved in "reaching in" to the structure to access that particular nested property, into a form that can be passed around, further composed with other lenses, and so on.
Given some additional operator overloading, we can actually simplify the last to: val innerValueLens = Outer::inner + Inner::value val newOuter = innerValueLens(outer) { toUppercase() } or even val newOuter = (Outer::inner + Inner::value)(outer) { toUppercase() } which admittedly looks a bit alien.
Speaking of modern (UI/web) frameworks, here's a quote [1] from the documentation of Facebook's React: &gt;We strongly believe that components are the right way to separate concerns rather than "templates" and "display logic." We think that markup and the code that generates it are intimately tied together. Additionally, display logic is often very complex and using template languages to express it becomes cumbersome. &gt; &gt;We've found that the best solution for this problem is to generate HTML and component trees directly from the JavaScript code such that you can use all of the expressive power of a real programming language to build UIs. yole already gave an answer about anko; I thought it could be interesting to look at other frameworks. I personally have no preference (external template language files, custom DSL methods, or barebone GUI class constructing). [1] https://facebook.github.io/react/docs/displaying-data.html#jsx-syntax 
&gt; It's not always possible to tell in advance. You're right, it's not. We go by intuition to weed out what's worthwhile and what's not.
My understanding is that most languages simply suck at DSL-making so JS/XML thing is forced on them. Kotlin is more expressive so you don't have to look at two places at once if you don't want to. It is just more convenient that way
I think data class inheritance will be in 1.1: https://blog.jetbrains.com/kotlin/2016/04/kotlin-post-1-0-roadmap/ 
Kotlin does not support sealed interfaces because there is no way to prevent Java classes from implementing the same interface. Therefore, it's not possible to obtain the exhaustiveness guarantee that sealed classes provide.
Please note, OP, /u/yole is on the Kotlin team at JetBrains and is co-authoring the Kotlin in Action book, so this is a pretty final nail in the coffin for the idea of sealed interfaces (unless something changes in Java, which is highly unlikely). :)
/u/yole is a [top-10 Kotlin contributor](https://github.com/JetBrains/kotlin/graphs/contributors) that works at JetBrains.
Yole is a member of the Kotlin team. 
https://www.reddit.com/r/Kotlin/comments/4j5kmf/kotlin_102_is_here/d33zpo1
Oh, I see now. That was stupid.
I think they're slowly migrating over to Google Cloud, but I'm sure they'll provide a smooth migration path. They're still signing up new users for it, which seems unlikely if they had a plan to end-of-life it. But Google does have a reputation for killing projects that people rely on, still though, they're not behaving that way with GAE.
Yes, from the Kotlin website: "Interoperable: Leverage existing frameworks and libraries of the JVM with 100% Java Interoperability." (https://kotlinlang.org/)
Missed opportunity of calling it Kradle
Maven also has plugins, lots and lots compared to gradle. Will take a while 
Jet Brains claims 100% compatibility. In my experience it's more like 99.9% compatibility. - Java code with Lombok annotations in the same source set as Kotlin doesn't work. You have to build them separately in that case. - Kotlin properties don't override java getters/setters but do have the same JVM signature, so can't be used when they would clash. - I was unable to convert a particular Java enum class to kotlin, when the java enum class had declared a particular field (name?). - Kotlins strict runtime null checks break Mockito. Mockito.any(Class&lt;T&gt;) will return null sometimes. There's a Kotlin wrapper library that solves this, but it was confusing. Most of these happened as I was converting existing java code to Kotlin, file-by-file. For new code, java interop has been great.
And all because most languages suck at declarative programming (Java I am looking at you).
Any improvements with the JVM will improve Java, Scala, Kotlin, and Groovy, and any other language that targets the JVM, so it makes it all an even playing field. The only massive difference between those languages is simply on the syntax side of things.
True, and I'm not disputing that fact. The JVM is the JVM. Everything that runs on it has access to the same facilities. I was merely mentioning that even though it doesn't do much by way of optimisations around final right now, it potentially could on the future... And, as you say, if it did then everyone benefits. Though JVM languages that make final the default - e.g. kotlin - will likely benefit a bit more than those that make open the default - e.g. Java - simply from the fact that there will be less changes needed to take advantage of it...
Swift? They're both similar languages and swift is native. Personally, it doesn't matter to me that kotlin runs on the jvm, but if it matters to you, then it might be worth checking out swift or even rust. 
It's effectively bound to the jvm until someone writes another implementation.
Well it does work for JavaScript as well. However, my point was that we can expect to see it running in other runtimes. It's a natural progression of a language.
The only difference at noticed is that warning and errors are displayed with the internal name of the diagnostic. 
This option is used by the Kotlin developers; it enables some additional assertions, debug information and IDE actions to help diagnose problems or verify certain assumptions.
I don't think your code is correct. There should be no `new`, why did you put the `val` into a `init`-block? And what is `T`? Also, but that's just nitpicking, your `Die(6)` rolls numbers from 0 to 5 which is slightly weird.
interface Rollable { fun roll(times: Int = 1): Int } Why use generics?
Would you really win much with Kotlin on .NET? There's not much wrong with C#.
I hope the Kotlin team takes a look a Scala-native to see what it's taking them to pull it off. Kotlin is on a great growth curve, and I think Gradle's adoption of Kotlin will be big. In Scala-land it has turned out to take some rejiggering to make a lib compatible with Scala-native and Scala-js. It would be amazing if Kotlin's library ecosystem was largely JS/JVM/native compatible.
I agree that modern C# is in a much better place, but remember: Unity is stuck on a very old version of C# and .NET. I'd also make the argument that Kotlin still edges out modern C# (at least once it picks up coroutines).
You're right. I created a child class for only 6-sided dices (and still be able to inject my random).
I agree. I think they are looking in that direction, but that is just a hunch from my side.
Use the Flexible environment with Google App Engine. Its actually awesome while the original sandboxed Java GAE is annoying a number of ways. I'm building a seed project starting with JHipster/Spring Boot, currently re-writing the front end in Angular 2, and new backend code is in Kotlin. https://cloud.google.com/appengine/docs/flexible/java/#apis--reference
I'm no expert, but since gson relies on reflection, defining a class is going to be the only way. It doesn't work with anonymous objects.
Readme still isn't too descriptive ,I don't understand what it is
Perhaps instead of defining the extension methods on Double they should be defined on Number - that way you get Float, Byte, Int, Long, BigDecimal, BigInteger, and Short for free.
Starting interfaces with "I" is C#. Don't do that in Java or kotlin. Also why does the interface use nullable types. Looks like bad design. The factory probably should use better error handling and less reflection. 
- You should rename it Kotbot. :) - [You have functions that are named in UpperCamelCase](https://github.com/jamesmoriarty/kotlin-robot/blob/master/src/robot/commands/CommandFactory.kt#L5). Use camelCase. - [Parens are not needed here, you can just use the braces](https://github.com/jamesmoriarty/kotlin-robot/blob/master/src/robot/commands/MoveCommand.kt#L9) - Your [NullCommand](https://github.com/jamesmoriarty/kotlin-robot/blob/master/src/robot/commands/NullCommand.kt#L5) doesn't need to take args. And if you're going for a null-object pattern here, you could replace the `class` keyword with `object` to get a singleton pattern for it right off the bat. - Have you considered making things like [PlaceCommand](https://github.com/jamesmoriarty/kotlin-robot/blob/master/src/robot/commands/PlaceCommand.kt#L7) a `data class`? Instead of passing a bunch of strings to it as varargs, pass the actual x, y, and direction. You can still have the exec method in there since data classes can implement interfaces! And then you get `.equals` implemented automatically for you. In general actually, I'd probably just parse the args in the `CommandFactory` and then pass them to the constructors for each command that you wanted so you can make the `ICommand` implementations all `data class`es. - [I might be wrong on this, but does `.exec` need to have `Robot?` as a nullable type? Can it just be `Robot`?](https://github.com/jamesmoriarty/kotlin-robot/blob/master/src/robot/commands/ICommand.kt#L6) - Why not [open up braces after your `Robot` data-class](https://github.com/jamesmoriarty/kotlin-robot/blob/master/src/robot/Robot.kt#L5) and put the `isOnBoard` method inside there? So you can call `robot.isOnBoard` instead of `isOnBoard(robot)`? - Why are you [declaring your variable with a null value at the top of your main function](https://github.com/jamesmoriarty/kotlin-robot/blob/master/src/main.kt#L7)? You could just declare it all in one line and then use a `val` to store it. `val robot = command.exec(null)` does exactly the same thing and is cleaner to read. And as stated elsewhere, *use `val` unless you need mutability*. Nice work overall. You can write things a bit more idiomatically, but it always takes time to get into the groove of things and understand the idioms of a language when you're first starting!
 * I recommend you learn &amp; use a dependency management tool like gradle or maven * in your factory method, I would define all the command strings as an enum, then use a `when` statement to switch between them. You can then give a lot more helpful info to the user as to what the valid commands are 
Something minor in addition to everything else that's been said: since your `Robot` is a data class, you can use the built-in [copy](https://kotlinlang.org/docs/reference/data-classes.html#copying) function to create new instances in your LeftCommand, meaning the code could become just it.copy(direction = rotatedDirection(it.direction, 1))
Thank you for spending your time on this. I'll incorporate the feedback.
There is a difference between "internal" code hygiene and "external" code hygiene. If you write a library that other people (me for example) should be able to reuse, then I don't care about camel case for your internal variables or if you use val or var in your functions. But I will care about the naming of the classes/interfaces/public methods that I have to use in my own code. And they should be using the standard code conventions unless there is some important reason.
Actually, that's a very important point. I'd forgotten that the way the command interface was designed was for it to be reimplemented to extend the REPL.
I started working on the Kotlin track after listening to Exercism's creator talk about the project on the [bikeshed](http://bikeshed.fm/65) podcast. Sdavids has been great at pointing out better ways to use language features with references to the official docs.
Greetings /r/kotlin community, Balin is a browser automation library for Kotlin. It's basically a Selenium-WebDriver wrapper library inspired by Geb. Right now it's a personal project and is not production-ready. Although, any feedback is welcome. Thank you all for your time.
Nice, that will make for better Java interop. Hopefully data class properties can also override getters/setters in base class too. 
We might be getting native Kotlin?
The await keyword looks really interesting. I've been absolutely loving working with Kotlin these past 6 months or so, and it really makes me happy to see how much traction the language is getting. Thumbs up to the whole Kotlin team. 
I'm hoping the sealed class as a parent allows for the same checking for missing 'when' clauses that Scala can do with sealed/case classes.
No they won't.
Nope, bogus article
Would love to see some type of extension mechanism on data classes like AutoValue's extension system
I'm not convinced, Gradle 3 will have Kotlin support. 
Databinding was also originally written in Kotlin! Not that it matters for the most part, I'm not sure what we would gain with official backing other than what we have already from the excellent team at JB.
That's true. And I also think that we're going to do fine with just what JB and the community offers us in terms of support. I mean, if we all did just what was Google-blessed, we'd all be using AsyncTasks inside of our Fragments to modify a few of the 9000 fields on each of our 20000-line-long classes (and all of those fields would be written in Hungarian notation, of course). :) So I think we do pretty well without Google's support. It's not like the frameworks they provide are particularly great.
Groovy is dying? what about Gradle and Grails? I don't think Groovy was ever huge, but it fills a niche: it's a scripting language that runs on the JVM. unless JRuby is taking over, and I don't see that, I think we need Groovy in some places. I'm no expert though. and I'm not familiar with Scala, but I'm curious what its criticisms are? I hear it's a hit with the functional crowd. 
I s'pose it is. it seems to hit both the Groovy and Scala use cases pretty well. still, the community seems pretty invested in Gradle for the time being. and I think, with maturation, we could see some pretty robust Kotlin web frameworks. so who knows what Groovy's future holds. maybe we'll see a Kradle or Krails some day. for now, I'll mark Groovy as "down but not out."
It does that already no? Just requires regular classes instead of data classes in Kotlin 1.0
Gradle just got [(experimental) support for Kotlin](http://gradle.org/blog/kotlin-meets-gradle/), and as they said, official support for using Kotlin on Gradle is coming in 3.0 (the next major release). I think that the writing is on the wall for Groovy. 
Have you read the actual post?
Bad title
wow. I thought you meant plugin support. this is the real deal. yeah, depending on how it's received you're probably right. 
Yeah, Kotlin is officially a first-class language on Gradle. Considering that the biggest usage of Gradle right now is probably Android, and the same can be said of Kotlin (though I now use Kotlin and Gradle whether I'm writing Android code or not...), I think most Gradle users will start to move over to Kotlin. Every Android dev I've worked with has been frustrated that Groovy syntax is pretty much pure magic to them, and since Groovy is dynamically-typed, the IDE is so bad at helping you out that it's impossible to know what to do with it. Kotlin will help people get into Gradle, which will help people get into Kotlin in return. :)
Yep, same here. Really loving Kotlin on Android and for other personal projects. I was going to use it for a libGDX project, but sadly, I want the HTML5 export option, and the GWT backend that libGDX uses to generate JS works off Java *source code*, not Java *bytecode*, so it won't work on Kotlin. :(
Please read carefully https://github.com/nfrankel/slf4k/blob/master/README.md
Log4J already supports this feature: https://logging.apache.org/log4j/2.0/manual/api.html // Java-8 style optimization: no need to explicitly check the log level: // the lambda expression is not evaluated if the TRACE level is not enabled logger.trace("Some long-running operation returned {}", () -&gt; expensiveOperation());
Things as they come up - on an iPad so hard to collate sorry... It's an good start, you obviously have ambition. Don't prefix your test method names with test- the annotation is enough. And you can use back ticks to add spaces &gt; @Test `is on board top`() The Command pattern is good, but reads wrong. You could add an extension method &gt; fun Robot.execute(command: Command) = command.exec(this) I haven't seen a single nullable type that should have been. Make everything not nullable by default and code will fall away. exitProcess in your main loop is unnecessary - just break or return. You'll get a method you can test then as well. CommandFactory is mighty confusing because it's capitalised, so we think it's a class.
That's great, but I have to build against the slf4j api. 
Raise a feature request for SL4J. 
Logging statements must be free of nasty side effects.
i wish.
Their roadmap specifically says yes. http://blog.jetbrains.com/kotlin/2012/01/the-road-ahead/
Late to the convo here, but out of curiosity: Do you have any concrete example of this? 
That's pretty nice, well done! The only improvement I could recommend is to somehow get rid of the nullable `Robot?` type, and just use `Robot`. Not sure if that's possible though. Also, maybe pull the regex out of the loop so you aren't creating it every time you run the lambda.
I've been trying to use `reduce` but been struggling with the generics signature / syntax. At least I know I'm not crazy.
Looks cool. I like how the join just gives you access to the two separate tables. Where is the connection to the database initialised?
Awesome. Separating query generation from execution and data mapping! 
Very exiting roadmap...
&gt;, Kotlin is insanely popular right now. Probably the most promising alternate JVM language around. I didn't know it is that popular already. Do you have a source? I would really like it to be true.
I didn't mean to imply that it's the most widely used. That's still Scala. But Scala took forever to get to the level of popularity that Kotlin already has a few months in. And with good reason; Scala is cumbersome and hard to use. The C++ of the JVM and all that. 
You can look at Rust, it is not designed for JVM.
Rust is interesting, but it lacks garbage collection and the whole borrow checker is too anal for some people.
It is both a bug and a feature depending on what you want to do.
Looks a little like the FRM library for scala, slick.
I use this: https://github.com/gregghz/kotlin-mode (in melpa too)
Change the first three lines to (mind the case): --langdef=kotlin --langmap=kotlin:.kt --langmap=kotlin:+.kts
I think this additional level of nesting is not that bad. But you get more readable test names and use usual language features instead of annotations and reflection of magic strings. JUnit and TestNG are somewhat limited in this regard. 
Did you mean '?'? 
Yes, let's annoy /r/kotlin by using one of their features
I never understood people who get so invested in a language or tool as I call it will be offended by threads like these :)
Any word on release date?
Android will transition to Swift.
Kotlin was made by Jetbrains just to sell their IDE. It has no future.
Kotlin doesn't have pattern matching in case statements? :(
Persistent collections, lower bounded types, implicit parameters, type composition, pattern matching. Kotlin has these to an extent, but they aren't as clean or complete as in Scala. Kotlin has Dexx for persistent collections, but there are(were?) problems with the use of high order functions returning ArrayList rather than the proper collection. Lack of lower bounds and implicit parameters makes certain aspects of functional programming harder and less concise. While still possible to get lower bounds, it usually involves extension methods which don't translate to inheritance very well. Type composition and pattern matching is just completely lacking in Kotlin. The problem with comparing Kotlin and Scala is that they don't have the same goals. I use Kotlin as a better Java; not as a Scala replacement. If you go in thinking that you're going to be doing Scala things in Kotlin, then you're going to be really disappointed. But, if you want a 1-1 better Java, then Kotlin is the right tool.
Good to know. . . I've been itching to try out Kotlin on something real. 
I never understood people who don't! :)
haha! 
How much extra are you paying in practise for JVM startup on AWS Lambda, compared to, say, Python?
Honestly I'm not sure, we haven't begun integrating with Lambda yet.
Thanks for your feedback
Unhappily, @ExtensionMethod in Lombok currently only works with eclipse, but not with IDEA. It is also an experimental feature only. Pitiful, because @ExtensionMethod would really rescue the show. I believe Groovy would be the better Lombok ...
I like the idea of making preferences properly namespaced. I have an init function for the preference delegate that I use currently that removes the need to pass context, but I can really only have one namespace.
The fact that you got downvoted means that you pissed them of good. Have a downvote!
Not available, but keep hunting! We're out there! Exciting to see another startup using Kotlin.
+1 for a Kotlin worksheet like Scala's. There are similar features, though: * Tools -&gt; Kotlin -&gt; Kotlin REPL * Tools -&gt; New Scratch File...
The existing ones [here](https://github.com/andrewoma/kotlin-script) and [here](https://github.com/andrewoma/kotlin-scripting-kickstarter)
This is all just guessing but I don't expect many companies to hire pure Kotlin devs yet. You might get to use it in smaller places where you get a say in the tech stack used in a project. I think Kotlin is indeed mostly used by Android developers since we are (for now) stuck in the Java 6.5 wasteland. People really dislike anonymous inner classes.
I think the term "Kotlin developer" is not very useful. One of the biggest draws to Kotlin is that, unlike Scala, someone who is comfortable in Java can go from zero to comfortable in Kotlin in under a week. If someone writes good code in Java, they will write great code in Kotlin. But if what you're saying is "are there any places I can get paid a salary to write Kotlin?", as /u/winian said, it is more for smaller places, where they started from the ground-up more recently and thus got to make decisions about the stack more recently (since Kotlin is not that old). On that note, I'm currently the only person working on Android at my company at the moment, and our app is about 70% Kotlin. As for our hiring plan, a few parts are moving around at the moment within our org, so I'd rather not say "we're hiring", but the chances that we will be in the near future are pretty good. :) I know that other companies are friendly to the idea of using Kotlin. Square uses it in some plugins like SQLDelight, and has the go-ahead to use it in apps, but I think that Jake Wharton mentioned once that they haven't seen a need for it yet, so no app they write has code running on your device that was written in Kotlin. I'm pretty sure someone from Lyft posted once in the hiring thread here and said that they're Kotlin-friendly, though I'm not sure what that means for their codebase. They're out there, but they don't tend to advertise it as explicitly as Scala shops, for example, because the learning curve is so easy. I know I personally don't look for Kotlin experience in people I interview. If they've worked with RxJava even a little bit, for example, they understand functional programming enough that I'd be confident they could write idiomatic Kotlin within a week or two. Also, to answer your second question: yes, it's mostly used on Android right now, because most of us have such a low minSdkVersion that we can't even use Java 7 features. But it could be used anywhere.
Probably about 5. Maybe 6.
How does it remove the need to pass in a context? Why not just store an instance of the preferences?
v plain old Junit
I am a little bit wary of "fixes" like this. Obviously it's surprising when you find out the variable you were expecting to be 0.2 is equal to 0.20000000000000018, but when you deal with floating-point arithmetic you need to understand these details. To illustrate, the first BigDecimal example has the same behavior because floats are still used - the author used the BigDecimal(double) constructor. However, JavaDoc clearly states this: &gt; The results of this constructor can be somewhat unpredictable. One might assume that writing new BigDecimal(0.1) in Java creates a BigDecimal which is exactly equal to 0.1 (an unscaled value of 1, with a scale of 1), but it is actually equal to 0.1000000000000000055511151231257827021181583404541015625. This is because 0.1 cannot be represented exactly as a double (or, for that matter, as a binary fraction of any finite length). Thus, the value that is being passed in to the constructor is not exactly equal to 0.1, appearances notwithstanding. On the other hand, once developers understand these nuances extension functions like .toBigDecimal() make a lot of sense. And Kotlin already provides the necessary operator functions: https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/java.math.-big-decimal/
Thats what it does, when the app is created it will setup the shared preference object that is used in the delegate. The library op linked needs a context when you create each preference, but allows you to namespace the preferences. class SharedPref&lt;T&gt;(var defaultValue: T, var onChange: (() -&gt; Unit)? = null) : ReadWriteProperty&lt;Any, T&gt; { companion object { var prefs: SharedPreferences by Delegates.notNull() fun setPrefSettings(pref: SharedPreferences) { prefs = pref } } @Suppress("UNCHECKED_CAST") override fun getValue(thisRef: Any, property: KProperty&lt;*&gt;): T { val name = property.name when (defaultValue) { is Boolean -&gt; return prefs.getBoolean(name, defaultValue as Boolean) as T is Float -&gt; return prefs.getFloat(name, defaultValue as Float) as T is Int -&gt; return prefs.getInt(name, defaultValue as Int) as T is Long -&gt; return prefs.getLong(name, defaultValue as Long) as T is String -&gt; return prefs.getString(name, defaultValue as String) as T else -&gt; throw UnsupportedOperationException("Unsupported preference type ${property.javaClass} on property $name") } } override fun setValue(thisRef: Any, property: KProperty&lt;*&gt;, value: T) { val name = property.name val editor = prefs.edit() when (defaultValue) { is Boolean -&gt; editor.putBoolean(name, value as Boolean) is Float -&gt; editor.putFloat(name, value as Float) is Int -&gt; editor.putInt(name, value as Int) is Long -&gt; editor.putLong(name, value as Long) is String -&gt; editor.putString(name, value as String) else -&gt; throw UnsupportedOperationException("Unsupported preference type ${property.javaClass} on property $name") } if (onChange != null) onChange!!.invoke() editor.apply() } } You have to init the preferences, before you can uses it SharedPref.setPrefSettings(getSharedPreferences("com.example.droid.appprefs", Context.MODE_PRIVATE)) But once you do you can setup a preference delegate anywhere in your app. var appToken by SharedPref("") Only handles non-nullable values by design and you can only have one namespace. But its easy to setup and use. 
I work in a mostly scala shop (JavaScript and typescript for front-end) and right now we have exactly two people doing kotlin dev because it's a great language for Android. We don't hire for scala devs or JavaScript devs or java devs or kotlin devs. Smart people are good at all of those things. I would suspect that larger corporate places would be slower to adopt non-java, but decent smaller places are usually open to using newer things if they fit the problem space well enough. For reference, i'm at a place of about 100 people, with about 40 engineers.
That's pretty good, I've heard this said about scala as well. It's infuriating in both contexts.
I'm not sure how useful this article is. Some of the suggestions seem to be rather bad. &gt; Using constructors changes nothing, one has to use the static valueOf() method instead. &gt; &gt; BigDecimal a = BigDecimal.valueOf(5.8d); Please just use the String constructor... &gt; Note that in Kotlin, floating-points numbers are doubles by default. In Java too, so what's the purpose of this statement? &gt; val a = 5.8.toBigDecimal() Wouldn't recomment that. First it looks weird, secondly converting doubles to BigDecimal isn't a good idea in general. Better would be &gt; val a = "5.8".toBigDecimal() which as far as I know is already in Kotlin or at least is a proposed feature that will likely be added in 1.1.
Still imprecise because 5.8 as double isn't exactly "5.8". Also 5.800000000000000000067.toBigDecimal() would also result in a BigDecimal of "5.8" and that would be confusing. It's just bad style to mix floating point numbers and BigDecimal. 
Ugh. Knocking the wind outta me 
I must admit, I've tried out both Spek and KotlinTest and I end up going back to JUnit. It works really well with Kotlin, and when coupled with EasyMock and JUnitParams covers just about everything I want from this level of testing really easily. The next step beyond this I like to use Cucumber for, which also works really well with Kotlin. This gives me the business-level verification tests of the entire application, as opposed to unit- or integration-tests of parts of it.
What was the reason to leave Spek and KotlinTest?
Some of it was just personal preference. Others were lack of functionality - though this was generally quite minor. The biggest missing functionality was the lack of support for JUnit @Rules, but you can generally work around that instead.
Thanks for the feedback. :)
Make me want more! €15 is a pretty steep price for an epub of which I'm not sure if it'll be useful or not. Give me an introduction to the framework, show me why Kotlin is superior to Java, give me a taste of why I would choose this above PHP or what have you. And then slam me with the payment page. 
You could try out Konsent for me! https://github.com/dmcg/konsent
Looks interesting. Though is it just for Browser testing? Or can it be used for arbitrary acceptance testing - e.g. at the API level?
Is anyone else as excited about coroutines as I am? `yield` is the thing I miss most from Python, and this is that and so much more.
I am but I've no idea what they're for or how to use them, so I'm kinda waiting
Absolutely, particularly if they are serializable, it will open up some amazing possibilities for [distributed computation](http://swarmframework.org/).
Thanks for your comments: &gt; Given what happened to the previous Scala support as noted on the project's page, wouldn't it be more reliable to build something either higher level or entirely custom instead of relying on implementation specifics of another project? Just my initial concern, that's all. I did think about building an entirely new programming language for this, but that's a lot of wheel-reinvention. I have more confidence in the Kotlin team than the Scala team when it comes to not deprecating features that people depend on. The continuations compiler plugin for Scala never really had the support of the core team, that's not the case for coroutines in Kotlin, and I think it's fairly clear that it will become a key language feature pretty quickly. &gt; AFAIK, this would implicate that the code for a given application must first be copied to every machine before you can run it as mentioned in the video. If I understand correctly, you're essentially just waiting to receive over the wire the state to enter into a coroutine's state machine. That's exactly correct. &gt; Maybe that is a reasonable restriction, but it seems very brittle to me since out of date deployments could silently create problems. That doesn't seem like a difficult problem to avoid, nodes would be configured to automatically update in the event of a modification to the software's bytecode. Map-reduce implementations must deal with this too, and I don't believe it poses a significant problem there. &gt; It seems to me that you could instead pass the function's instructions itself (not necessarily JVM bytecode for that matter) over the wire. I'm not sure how that would work - you'd need to transfer a lot of code because it would be impossible to know how much code must execute on the remote machine before it gets transferred somewhere else. I think you'd end up having to transfer all the bytecode anyway. &gt; Just my 2¢. Appreciate it! 
What'd you have to do to get async/await to be available in Intellij?
&gt; I did think about building an entirely new programming language for this, but that's a lot of wheel-reinvention. True, it would be more effective to adopt a pre-existing language and associated ecosystem than to have to start from scratch in that respect. That or define a protocol and make it language agnostic, but that is easier said that done and takes things in a different direction. &gt; I have more confidence in the Kotlin team than the Scala team when it comes to not deprecating features that people depend on. This is also what I had in mind, I maybe cut a few too many side comments out of my already longish comment... Given that async/await and generator support will depend the coroutine implementation, like you're saying, I seriously doubt it would be deprecated in the future. It's just the implementation details to worry about. &gt; That doesn't seem like a difficult problem to avoid, nodes would be configured to automatically update in the event of a modification to the software's bytecode. [...] I don't believe it poses a significant problem there. I think you mentioned having some sort of hot-code swapping which could probably solve this. I'm sure there has to be monitoring, logging, and the whole nine yards there anyways which makes my point basically mute. Either way, if a server goes down for whatever reason, don't you have to then deal with local data that is stored on that machine which is rendered inaccessible? I assume this would involve dealing with the same concerns and tradeoffs a distributed database would have to make. &gt; I'm not sure how that would work - you'd need to transfer a lot of code because it would be impossible to know how much code must execute on the remote machine before it gets transferred somewhere else. I think you'd end up having to transfer all the bytecode anyway. True, I certainly did not think that through enough. Sending functions over the wire would either require sending all possible future calls to coroutines along with it. And this ends up sending essentially all the bytecode anyways like you stated. Instead with the bytecode on the machine already, this seems more analogous to how multithreading works where the code is all the same but each thread is just executing at a different position and might have different thread-local state. Except each thread is a different Swarm server. And then you have map-reduce running in parallel... &gt; Appreciate it! And the same as well! But given your [track record on Github][1] alone, I probably should not be the one here talking about distributed systems... [1]: https://github.com/sanity/ 
&gt; Either way, if a server goes down for whatever reason, don't you have to then deal with local data that is stored on that machine which is rendered inaccessible? I assume this would involve dealing with the same concerns and tradeoffs a distributed database would have to make. Yes, I think data will need to be stored redundantly to deal with node failure, although the importance of that will depend on the application. &gt; But given your track record on Github alone, I probably should not be the one here talking about distributed systems... Ah, way too many unfinished projects I'm afraid!
I think IntelliJ is able to run from the commandline and generate a code coverage report.
Haven't found anything for Kotlin yet. Hoping SonarQube adds support some day.
Kotlin already has immutable collections
Why does each JVM language need its own immutable collections library? Can't we just adapt Guava or some other common implementation to work well in Java/Scala/Kotlin/Clojure?
I had the same-ish reaction when someone brought this proposal up in the Kotlin Slack channel... what does this bring us over just using the Guava immutables?
Mostly because the design goals of the collections are very different. How Clojure's persistent collections are implemented would make no since in a Scala program, and vice versa. You'll never create an implementation that will fit all languages because every language has different idioms, goals, and syntax that makes a great implementation in one language terrible in another.
No, it doesn't. It has mutable Collections that also implement an interface without mutation methods. val mutable = mutableListOf("Hello", "World") val notImmutable = mutable as List&lt;String&gt;; // notImmutable.add("Foo") Doesn't work mutable.add("Foo") // But this does :-( print(notImmutable) // prints [Hello, World, Foo] Which means, as long as you hold a reference or you explicitly cast them, you can mutate most lists.
There are some functions like `toList()`, but they only create a copy and don't use immutable implementations. Creating a copy isn't the same as being immutable. The whole point of immutable collections is that you don't need to defensively copy them because they are immutable. Without a real immutable implementation you can never be sure if you need to copy the collection or not, because at runtime you're unable to know who else holds references to the collection.
you are probably talking about `.plus()`, but that does a full copy operation, while this library will make use of persistent data structures to do its work (if I understand correctly)
Wouldn't it be pretty simple to, like Guava, return the current instance when `toList()` is called on a non-mutable list. Or is there more to it than what I'm missing?
Jacoco can be adapted to work with Kotlin. But to be usable the output needs to be massaged a bit: https://discuss.kotlinlang.org/t/gradle-code-coverage-report/390
Check out [dexx](https://github.com/andrewoma/dexx) (presents an idiomatic Kotlin interface for persistent collections) or [javaslang](https://github.com/javaslang/javaslang) which is just Java 8.
Both reuse class names from the `java.util` package which seems to be very bad design for me, as it gets confusing really fast. Also they don't implement regular interfaces like `java.util.Collection` (or the kotlin equivalent). I didn't test them, but I think I much prefer Guava immutable collections.
https://github.com/x2bool/kuery was posted here a while ago. Maybe it is was you are looking for.
I'll give it a go, but I was hoping that I wouldn't need to create lots of extra classes to represent the database tables. Basically, something like: val query = select() { field("name") from("employees") where() { field("id").equals(1) } } As opposed to needing to create a new ```object EmployeeTable : Table("employees")``` that represents the database schema, on top of having created the database schema And created my internal model objects that also represent the data that ultimately ends up in the database.
Note that you don't need the empty parens: val query = select { ... where { 
Oh cool - I'm actually not surprised but I didn't realise that one. :-) I'm getting tempted to write a SQL builder using exactly this pattern now, since it's quite readable and obvious to use, and - hopefully - has very little over head. (Though I'm sure I'll find out soon enough why nobody else has done so yet!)
If you dont provide a Schema, then no IDE can help you, and you cannot prevent querying fields that dont exist or tables that dont exist. You can already use JPA Criteria API with Strings, so your idea would be an Criteria API for native SQL. I couldnt find anything on the web, so maybe there is a need out there for that. Would prevent ugly SQL String concatenation abominations when you need to create your statements programatically. 
Maybe application can get the schema from database when application connects to database? That way you don't have to duplicate schema in code and errors can be found on startup? This would actually be a great use case for macros. Macro could connect to a database on compile time and generate necessary classes to represent a schema.
In Paris, since I mentioned Kotlin on my LinkedIn, I received a pretty good amount of offers for position using it. Look's like it's a criteria that prove you are an "updated" developper. Also, I know some people that are using Kotlin in big companies and it is not problem at all for the new devs. It's like a natural evolution, not at all comparable with objective c and swift.
There is the Kotlin documentation of course: https://kotlinlang.org/docs/reference/generics.html But if you have no idea about generics at all I would recommend doing a Java or C# tutorial about them first. 
&gt; [...] Also implicit conversions let you wonder what has happened to your code when new libraries are linked in &gt; [...] I don't seem to know that much Scala as I think. Yes.
Well let's break down the function signature you pasted. First, it is an extension function which can be called on any Object that is a Collection that holds objects of type T. This is a type variable, you can think of it as some kind of placeholder. Not specifying an actual type allows you to say "This function will work no matter what Type takes the place of T when when you use the function". Therefore, you can apply this function to a `List&lt;String&gt;`, or a `Map&lt;RandomObject&gt;`, doesn't matter. Let's go to the parameters now, and let's start with the third one as it's the easiest for now. The third parameter has to be a function that takes one parameter of type T, and returns a Boolean. Remember T is just a placeholder for what you actually have at the call site, so if you call this function on a `List&lt;String&gt;`, T will be replaced by String, and the third parameter will have to be a function of Type `(String) -&gt; Boolean`, otherwise the compiler will throw an error. Now T also appears a third time. To use a Type variable like T, you have to declare it before the function in this way: `fun &lt;T&gt; foo(bar: List&lt;T&gt;)` This function delaration does not have much use yet, you could just as well have declared it as `fun foo(bar: List&lt;Any?&gt;)`. But you might want to actually use T, for example if the function should return a specific element from that list without using Any? as the return type: `fun &lt;T&gt; foo(bar: List&lt;T&gt;): T` This way the return type is the same type as the things inside the list, and you've declared that **without knowing** what types of objects you will eventually deal with. Now in your example, there is a second Type variable called C. C is also declared before the function, but with an additional restriction: `C : MutableCollection&lt;in T&gt;` means that just like T, it doesn't matter what C actually is - except it has to be a descendant of a MutableCollection that stores objects of the before declared Type T (Ignore the `in`-part for now). And now the first two parameters of the function are easy, the declaration just says that the parameters `first` and `second` have both to be of Type C, which in turn as previously declared has to be anything that is a MutableCollection which takes objects of Type T. The return type works in the same way, the function will return a Pair of two objects of Type C, whatever that is on the call site. How does this work now? If you call this function like this: val list = listOf("a", "b", "c") val partitions = list.partitionTo(ArrayList&lt;String&gt;(), ArrayList&lt;String&gt;()) { it == "a" } the compiler can infer some things here. First, you're calling it on a List&lt;String&gt;, which is a Collection&lt;String&gt;, therefore T has to be String. That means that it can also infer that the first and second parameters have to store objects of Type String as well. If one of the ArrayLists were parameterized with, say, Int instead, the error would throw a compiler, because the type ArrayList&lt;Int&gt; is no subtype of MutableCollection&lt;String&gt;. I hope that did give you an appropriate overview over what generics basically do and I didn't miss something important. Feel free to ask away if anything is unclear. Edit: formatting.
This looks a lot like `Delegates.vetoable()`. 
yes, almost the same. All hail the standard library!
yes, it has slf4j features
Yeah I'd much rather have string interpolation in inline lambdas than the string formatting SLF4J does. log.info { "How awesome is this? ${awesomeness}." }
AnkoLogger seems nice and probably easier to embed if already using anko. The usage is pretty similar. on the other hand it looks it might consume more resources: the `loggerTag` is a property in AnkoLogger. every log call is calling that getter and that might increase method calls. in kotlin-logging the logger is actually a singleton member in each using class. of course performance needs to be checked to validate if any difference at all.
If logging is turned off in production builds, then performance issues are nonexistent
not 100% the same but you can inherit from`KLoggable` interface and call `logger` each time. more details here: https://github.com/MicroUtils/kotlin-logging/wiki
Looks nifty! It seems useful for validating configuration values or command line arguments. You could probably make the validation syntax a bit nicer though. I would do something like this: fun validate(key: K, errorMessage: String, validationFunc: (V) -&gt; Boolean) { validators.add(Triple(key, validationFunc, errorMessage)) } Then the syntax would look like this: mapOf("foo" to "bar", "foo2" to "bar2").validate { validate("foo", "errorMessage") { value -&gt; value == "bar" } validate("foo2", "errorMessage2") { it == "bar2" } // implicit parameter name } You could even get fancier and add an operator extension function. class Validator&lt;K, V&gt;() { // rest of the class definition operator fun K.invoke(errorMessage: String = "Error validating $this", validationFunc: (V) -&gt; Boolean) { // uses the validator function I mentioned above this@Validator.validate(this, errorMessage, validationFunc) } } Then the syntax could look like mapOf("foo" to "bar", "foo2" to "bar2").validate { "foo"("Explicit error message") { it == "bar" } "foo2" { it == "bar2" } // default error message: "Error validating foo2" } Also, you probably shouldn't use `com.github` in your package name. That usually indicates that the package was created by github. It's common practice to use the url of your website backwards if you have one, but if you don't you can just do something like `com.joelws.valin`.
Made the changes to package name and now is com.joelws.valin Changed from forcing user to use Triple and now takes anon function as last parameter.
So what does the failures method mean if Either is unbiased? 
You're right... for validation Either must be taken as a right biased monad.
I would say look into it. If you need something where Java is used (X-Platform, Android, or other) try Kotlin. The best comparison I've found is Kotlin is to Java what Swift is to Obj-C Edit: Typo
But also objective c is way worse than Java.
This. When I introduced kotlin to my android developer colleague, our iOS developer chimed in with "you sure you're not talking about swift?"
I don't understand your point. If you saw Kotlin, what don't you seriously consider converting to Kotlin instead of Java?
Kotlin isn't really "on top of Java" any more than C# is "on top of" VB.net. They're distinct languages that both run on the JVM, similar to how .net languages run on the CLR.
Most people got the point I hope. And it is not sole JVM, package ecosystem as well.
&gt; It is a technology on top of java That is absolutely not true. Kotlin can exists without Java. It can, however, coexist with Java code, but that is a totally different matter. And Android's Java doesn't have linq equivalent. 
This doesn't quite work, even explicitly doing `select(8);` doesn't work. Stack Overflow has a solution to call (T obj) by doing `select(departureHourChoice as Int?)` but I need the one that calls `(int obj)` rather than the other.
How does it not work? Did you make sure the name the extension function something other than 'select'?
Any code ends up being a processor instructions so you can, the question is how?
That is why I wrote except syntax. So I meant JVM and the ecosystem. Plus X-platform support.
Some more things are possible with [KotlinTest](https://github.com/kotlintest/kotlintest/), like proper test parametrization. 
thank you
The lack of preprocessor directives in Java is generally viewed as a good thing. 
I didn't even know that sort of thing was possible, nice.
Hav you seen [Spek](https://jetbrains.github.io/spek/)? It allows doing the same a bit more neatly.
Interesting, thanks
I don't believe this is possible in Kotlin.
This was a fresh project started after upgrading to the newest IntelliJ/Kotlin versions. To clarify, debugging works fine if I write a JUnit test and set breakpoints inside the code being tested, but when attempting to debug code when execution begins in the Kotlin `main` function it does not stop at any breakpoints.
Without proguard I don't need an empty constructor. So I shouldn't need it with proguard either. I am sure I can find a workaround solution but I shouldn't need one. 
Does your project use other java libraries? You might be better off just rewriting the code to be honest. 
No other libraries but I guess I'll have to rewrite it in c#. 
I had s similar problem with a static constructor. My guess is that proguard removes the constructor since no one is using it. Try adding a proguard rule to keep all your constructors. Something like (I have not tried this): -keep public class you.package.** { public &lt;init&gt;(***); } In my case I needed: -keep public class you.package.** { public static *** ***(***); } 
BTW, the IntelliJ IDEA autoconversion is far from perfect. I suppose it's fine with pretty simple business logic, but when I converted a pretty math-heavy algorithm implementation class, it got the precedence and narrowing rules wrong, borking the algorithm.
May be you should submit that to the kotlin bug tracker : https://youtrack.jetbrains.com/issues/KT
I tried to narrow down the case, but couldn't get it done inside the window I had available for it.
Sign up? Yea fuck that.
My suggestion is having the content public with a reminder to allow email subscription. I did sign up for the record, and have yet to receive any content. In all honesty it's not a good sign to make people sign up without having any content available yet...
I just wish the JVM started up faster like something like Go, then I'd probably be on board with the "every aspect" part. ;)
Agree with pretty much all of the points. Particularly the ones dealing with static fields and functions. Those are a bitch to implement and the language definitely needs a static keyword.
I'm guessing the author hasn't seen the amount of broken code that exists because hashmap and ArrayList are non-final but not designed to be extended. If you want to design your class to be open, those four letters really don't hurt. 
In my experience, some attention is needed when the library itself does "hacking" - using a lot of reflection or (byte)code manipulation. But in most cases @JvmStatic and knowledge how get/setters are generated and annotated is enough. Even things like Spring Boot and Hibernate work if you know what they expect - and learning how your library works is not really what I would consider "hacking".
I agree. The built-in suggestion NOT to extend things is a great idea. The only case when it's problematic is when you are trying to mock things with mockito. Define your interfaces I guess.. :)
I suppose i have run into some situations where i wanted to modify/fix something about a library, but it's extremely rare, and the solution was never to subclass one of the library classes &amp; override some method. Better IMO is to code to an interface (which any quality library should be doign already), then if you need some custom behavior you can implement the interface as a proxy wrapper around the library object.
Yeah of course. Infortunatly, in android development, this strategy cannot be applied with most of custom View libraries
Fair enough. I have zero android experience. 
I feel like the children property of a `Node` should be a `Map&lt;String, Tree&gt;` and not a `List&lt;Pair&lt;String?, Tree&gt;&gt;?`. I especially don't understand the need for nullable values here (and then the author uses `!!` everywhere...).
Can somebody elaborate on the semantics of "by map"? From what I understand, it's a wrapper around "map[name]", but why are the properties not declared as nullable? What happens if I call the (map) constructor with one of the property keys missing?
It will throw a NoSuchElementException unless you pass in a map created with `.withDefault`.
Original Poster here (kloudmark). I think `Map&lt;String, Tree&gt;` is a far better approach. Will try it out and update the blog. Thanks! I used `!!` everywhere because the DataPoint class is being used both for training and categorisation. During training we expect that the `val result: Boolean?` is never null hence the `!!`. During categorisation the result will be null (and that is expected). An alternative approach would have been to create two classes. 
Post update http://cloudmark.github.io/Decision-Trees/ to use `Map&lt;String, Tree&gt;`. Thanks for your feedback. 
Yes, reducers should be on the UI thread. http://redux.js.org/docs/basics/Reducers.html They are pure functions and therefore should run synchronously, which means that they will not hold up the UI thread. &gt;Given the same arguments, it should calculate the next state and return it. No surprises. No side effects. No API calls. No mutations. Just a calculation. Asynchronous actions belong in middleware. Here are some middlewares I've ported, including one for async logic (redux-observable-kotlin): https://github.com/pardom/redux-kotlin#middleware I'm a bit unsure what you're asking in your second question, but I think maybe your state shape is incorrect. Did you read through this? http://redux.js.org/docs/introduction/ThreePrinciples.html If you elaborate a bit on your second question, perhaps I can help.
&gt; I'm a bit unsure what you're asking in your second question, but I think maybe your state shape is incorrect. Did you read through this? http://redux.js.org/docs/introduction/ThreePrinciples.html That answers my second question perfectly. Thanks for the useful feedback!
Great, no problem!
[removed]
For this case, what /u/jimschubert said. But just for reference, in cases you actually do need something static, the correct equivalent for that in kotlin would be to create a companion object that holds the value, and to use it from Java easily you can additionally annotate it with the @JVMStatic annotation. That way it will behave just like a static value both from kotlin and from Java.
Gotcha, thanks a lot!
Let's violate the equals/hashcode contract. What could possibly go wrong. 
Well, the conventional way for non- 'equals', 'in', or 'is' checks requires an empty 'when' spot, and that you repeat the name of the variable in every check. So, it saves on some typing. Also, it supports more complicated checks. Granted, one could always write a function to accomplish the same thing. The main point of this article isn't so much about providing a GOOD idea as it is to help those who want pattern matching in Kotlin get something a little closer.
Really a good convention is having a naming convention that indicates there's mutation. For example, "setFoo(value)" updates the object, but "withFoo(value)" returns a new copy with a different foo.
duh
If you want immutability, use a type that is immutable.
Ah, misread that.
So plain Java getters also does not guarantee that.
Stay away from Hungarian notation, people.
i like
Agreed, and I will often put a statement like that on a single line anyway: if (x is String) { println(x) }
You're welcome. That was a really quick review.
I don't think there is a way short of declaring T as being non-nullable as well. I mean what would you expect head() to return if the head exists but has the value null? An empty Option wouldn't make sense, since the head and other nodes are there, but you can't return an Option with the value null either.
Likely you are stripping off the `*.kotlin_module` files that are output to the `META-INF` directory by the kotlin compiler. Those are needed to read parameter names of the constructor when no default constructor exists. WIthout those files, part of Kotlin reflection shuts down. An important part for this module.
If I do that, then Option will allow nullable types. The idea is that it cannot have a nullable type as a generic parameter.
This might be possible with extension functions. data class Optional&lt;out T : Any&gt;(val value: T?) class MyList&lt;T&gt;( val backing: MutableList&lt;T&gt; = arrayListOf&lt;T&gt;() ) { fun insert(value: T) = backing.add(value) internal fun findFirstNotNullImpl() = backing.firstOrNull { it != null } } fun &lt;T : Any&gt; MyList&lt;out T?&gt;.findFirstNotNull() = Optional(findFirstNotNullImpl())
Doesn't compare projects using kapt, else this would be a much different story
One thing I was wondering is does the Java build use Gradle? I have found Gradle to be slow(compared to Maven or Ant or raw Javac) we might be hitting Gradle startup times as a hard limit on the compile time here.
For Kotlin app: https://gist.github.com/mazurio/589c5d1d0717d6111a23076d10526d30
Pretty much the same as a Java stack trace. Kotlin stack trace are as readable as Java ones.
But what about method names and line numbers, will everything match with the actual source fikes or does Kotlin generate wrapper classes and everything will be referenced to the runtime.
The only thing I've found that result in some oddities are inlined methods.
YouTrack issue: https://youtrack.jetbrains.com/issue/KT-13071
Try increasing the max memory for IntelliJ. Check idea64.vmoptions or similar. 
Yep, it's happening in my project too (not using Anko though). Very frustrating!
Thanks
Thanks for the feedback! I've filed an issue to clarify the documentation: https://youtrack.jetbrains.com/issue/KT-13867
I only found issue with the article posted here which omits "in the sense that we can call member functions and properties...", not the documentation. I believe the documentation makes it clear enough that everything is not necessarily a java Object. The documentation does not (and probably should not) specify how they are optimized to JVM primitives.
Yes. A type alias is just an alias for use in functions or classes like `fun doThing(name: Name)` If your alias is a Pair, you'd want to use `key to value` or make it a class My most common use case for type alias is for lambdas that have long definitions.
Feedback welcome :) Hat tip to /u/mbuhot for the initial implementation
Yes, well done and useful measurments there. Thanks! I just wonder whether Kotlin incremental compile was also compared to Java incremental compile (f.ex. eclipse has an incremental Java compiler). Some measurements with Maven would be most welcome, because lots of non-Android development is done with Maven.
The primary use case is programmatically building up the query at runtime with full type safety and no meta model code generation required. If you have only a static query with some simple parameters then JPQL is probably simpler. 
Even in dynamic use cases it felt safer, more transparent and was less buggy to manually build the jpql. 
That's just wrong. There's nothing insecure about building JPQL strings manually as long as you don't inject user data into the string directly. In fact, building JPQL is *exactly* what the hibernate criteria implementation does. And it does it in a way that is buggy, clumsy, hard to debug and hard to work around when issues do arise. I'd stay away from it whenever possible. It feels to me like type safety is the only benefit, and that's just not worth using it for.
There's a Brisbane Kotlin users group?
Fair enough. I guess I've only seen string based query building done poorly in old VB apps where parameter values were interpolated directly into the query 😱 I can see the appeal of avoiding the indirection and having a pretty good idea of the final SQL just by looking at the code. Got a link for the bugs you ran into? It's been a while since I've used it, but from memory it became complex to manage criterias involving more than a simple join relationship. 
Yeah yeah :P It's actually something that we're still keen on (and our office is well suited/located for a meetup) and I'll probably try and get off the ground next year. Haven't you embraced elixir and forgotten all about kotlin anyway??
Heh, been two years here too. They were bugs where case statements with mixed with more complex statements would produce syntax errors because of missing parentheses. Don't know a bug report link unfortunately. Just made the api feel like an afterthought, which is really unfortunate :(
Awesome! I need an excuse to work on the Elasticsearch DSL too. Elixir allows for even more DSL nonsense with macros, for added job security :-)
What I expected: report from Kotlin developers about progress. What i got: tons of speculations from one of Kotlin users. P.S. I think Android returned JIT only to avoid recompilation of all installed apps on every monthly updates.
&gt; tolerance for overheads is minimal May Scala or Kotlin be the correct answer?
If the overhead is low, then why not? There are many useful libraries out there in Java/Kotlin/Scala, and the productivity in these is much higher compared to the low-level languages such as C/C++.
The JIT compiler is just what it sounds like . It compiles under execution. This means that it has the possibility to generate native code that is optimised for how the process is being used and also for matching the cpu registers of the actual machine. If you built a JIT for C you could see it as delayed compilation. You compile it when needed and when you do that you know more about the environment and the runtime behavior where you compile which means that you could potentially archive better or same performance. What I'm talking about here is just the JIT part that can be faster. In a jvm you have less control over memory than C and also garbage collection which both contributes to slower speed. But if the JIT was made for the C language without GC it could produce equivalent or faster code than pre compiled binaries. There is of course no benefit of doing that because the added performance would not be worth having a JIT compiler being distributed. 
Interesting, NetBeans now belongs to Apache, it's bad sign https://www.infoq.com/news/2016/09/oracle-netbeans-apache Jetbrains has it's own IDE, I doubt you can expect first-class support anywhere expect of their own product
Oracle has only proposed the move. Nothing has actually happened yet. Even tech sites getting into clickbait garbage titles now too... ugh.
The issue ended up being fixed in 1.0.4 thanks to some responsive devs over at JetBrains. Thanks guys!
Awesome work from the Jetbrains guys yet again. Glad to see more incremental build improvements and integration with Gradle. _Really_ looking forward to 1.1 with coroutines, scripting support, and Java 8 support. Can't wait!
What are some situations in which it would come in useful? The way I see it, the static keyword is itself a workaround when your language forces everything to be an object/class, like in Java.
"static" is actually a heritance from C times and doesn't fit well with object orientation.
Hmm, I see. Well, I don't know how the Kotlin compiler works so I can't really say much. But as I understand it, files are compiled to their own classes (accessible in Java with FileNameKt.member), so I assume that package-level functions and properties are compiled as static... but like I said I don't know how to compiler works so it may as well be doing something completely different.
Actually I don't understand all the pushback against this idea below. There are use cases for static members which aren't covered by top-level functions and properties. Some of these use cases can be expressed fairly cleanly, others require the use of the `@JvmStatic` annotation, which is indeed clunky. We are discussing the possibilities for improving the situation, and while nothing is planned for 1.1 at this time, it's likely that there will be related changes in the 1.2 timeframe. 
Allowing `const` in non-objects would be cool so I don't have to declare a `companion object` just to have a place for constants.
That's good to know. Top level functions and vals are fine in Kotlin land, but interop with Java libraries that require static members is a pain.
Yes, but the object oriented counterpart is an ... object! In the case of Kotlin (and Scala) called companion object.
Absolutely agreed. Everything is great on the language level while the tools could use some more attention. I repeatedly experience errors in IntelliJ. Sometimes the refactoring tools just won't work. Sometimes they work incorrectly. Sometimes the IDE crashes completely. Hopefully these issues can be ironed out eventually.
Kotlin / IntelliJ / gradle integration is driving me nuts. I spend about a quarter of my time trying to figure out what stupid thing either IntelliJ or gradle is misunderstanding about my project.
It helps with sharing constants as well, which does fit into "OOP".
Isn't that the expected behaviour? Accessing non-final / non-private methods within a constructor in java has the same pitfalls (which is why it's recommended to avoid doing this). Just like in kotlin, in java the super constructor (along with the superclass initializers) are executed before the initializers and constructor of the subclass. Not sure if this behaviour is documented as part of the Java language or as part of the JVM, but it's probably the reason it wasn't specifically documented in kotlin.
The jvm spec actually allows assigning fields before super constructor calls, but not accessing members. The decision to do initialization after the Super call probably was made to keep it consistent with fields that depend on other fields or methods in initialization. But either way, this is why leaking 'this' in the constructor (either directly or by calling a non-final method) is bad practice - you end up with half-constructed objects and fun concurrency implications. 
Does this work with verifying lambdas within method arguments? e.g, in mockito, I'd write a verification like this: verify(mock).method(lambda); which currently fails, due likely to how lambdas are compiled / how their types resolve. I'm wondering if an analog of this would work in amock?
Where can we watch the presentation?
So you want to verify that a method that takes a lambda parameter is called with a given value of function type?
Wow, that's a sophisticated problem you have there! Turns out it does work though. https://github.com/dmcg/amock/blob/master/src/test/java/com/oneeyedmen/amock/LambdaParametersTests.kt
Interesting. Ok. I'll give it a shot :)
I appreciate the feedback, I was in two minds whether to use truthy as the function name but decided groothy was something different. I guess I could change it to truthy...
I'm still undecided whether to change the function names to a more meaningful name or just create extension functions which delegate to the groothy functions.
1.1 now includes extension functions and no more groothy functions
Glad to hear that! But why didn't you use extension properties? Instead of fun CharSequence?.isTrue(): Boolean { return !this.isNullOrBlank() } You could write val CharSequence?.isTrue: Boolean get() = !this.isNullOrBlank() And use it so then: "".isTrue // instead of "".isTrue() 
The reason I didnt was because other checks such as isEmpty is a function call and not a property, just following convention more than anything.
Yes, in the end it is preference since technically both options are more or less the same. But using property syntax is idiomatic Kotlin. The Kotlin compiler even makes some Java methods like Getters available as properties. See for example this litte example from the [idioms](http://kotlinlang.org/docs/reference/idioms.html) page: val files = File("Test").listFiles() println(files?.size) Besides that property syntax removes some clutter from the code. See also the [Coding Conventions "Functions vs. Properties](http://kotlinlang.org/docs/reference/coding-conventions.html#functions-vs-properties).
Thanks, I didnt know them. Kara is a complete web framework, it is not what I am looking for as I already have the backend and I prefer to have a rest API with a front-end framework. Yested it is not as complete as Angular but I will take a deeply look. What I wanted is an example of kotlin in Angular. Angular uses typescript and compiles it to JavaScript, so I guessed there is a way to use something different like kotlin.
Is the code somewhere out there ? I'd be very interested in seeing the project setup and some "messy" Kotlin code to see how it holds up.
This looks neat! I'll be sure to look more into this once I start work on my pet project's front end (which uses LibGDX). One tiny observation, could be a bit important: &gt; ... you likely want to support legacy Android devices and WebGL (through __GWT__), you're stuck with Java 6 or 7. __Switching to Kotlin__ - ... - __certainly helps__. GWT actually compiles Java _source code_ to JavaScript, so switching to Kotlin doesn't directly help there. At least that's how I've understood it. IIRC there's a successful PoC (or even a stable library) of a TeaVM backend for LibGDX. TeaVM compiles Java _byte code_ to JavaScript, so that could be useful. Hold on, doesn't Kotlin compile to JavaScript as well? Hmm... a Kotlin backend for LibGDX, could that work? That could be a fun and educational spike.
&gt; GWT actually compiles Java *source code* to JavaScript, so switching to Kotlin doesn't directly help there. At least that's how I've understood it. You're right, Kotlin does not work with GWT out of the box. Well, you could try decompiling Kotlin classes into Java and *then* compiling them with GWT, but I'm not sure it's worth the effort. As far as TeaVM goes, its LibGDX backend is currently incomplete, but I [actually plan on finishing it some time](https://github.com/czyzby/teavm-libgdx). It's not that easy though, as LibGDX uses some native code, reflection and unsupported classes. Kotlin does compile to JavaScript, but there are existing LibGDX Java sources that would have to be compiled to JS first. Not sure if it would be easy to interact with those.
Won't use of this library impede readability in many situations, since it is far from intuitive that a non-empty collection, or a non-empty string should be true? Seems like a bad idea to me.
This project was made to help me learn Kotlin while making something fun and interesting to me. It is however completely functional, although not the final vision I have for this kind of thing.
I disagree with this article. Extension functions are a great way to abstract and factor common code and write cleaner code afterwards.
exactly this, thank you! I guess I should've somehow explain this distinction more clearly. It's a bit subtle I guess and judging from comments not everyone seen this point. I've yet to learn how to explain things to a wider audience :)
Oh, I thought the Android landscape was messed but well... JS is even worse. That's a jungle of competing technologies. And only the strong survives.
Very cool. This would probably be useful in conjunction with mockito-kotlin
I've misused extensions to emulate F# |&gt; operator a.foo().bar().baz() Vs foo(a).let { bar(it) }.let { baz(it) } 
No, only the hyped.
Thank you, I'm flattered. If you can salvage any utilities that would fit in KTX, I'd appreciate the pull requests.
It seems like Javascript just has a lot of activities. Its not a nightmare. You are just caught up in the idea of there having to be an obvious single best solution. How does proposing Kotlin to this equation change anything.
&gt; It seems like Javascript just has a lot of activities. Its not a nightmare. You are just caught up in the idea of there having to be an obvious single best solution. Did you read the linked article, or have you tried to use JavaScript yourself lately? Trust me, it is a nightmare. &gt; How does proposing Kotlin to this equation change anything. Because, unlike JavaScript, Kotlin is a well designed language which, so far, has a tradition of well designed tools.
You just described functions in general.
This is the best tl;dr I could make, [original](https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f) reduced by 96%. (I'm a bot) ***** &gt; I need to create a page that displays the latest activity from the users, so I just need to get the data from the REST endpoint and display it in some sort of filterable table, and update it if anything changes in the server. &gt; Haskell guys had been calling it for years, -and don&amp;#039;t get me started with the Elm guys- but luckily in the web now we have libraries like Ramda that allow us to use functional programming in plain JavaScript. &gt; It does in the next version, but as of version 1.7 it only targets ES6, so if you want to use await in the browser, first you need to compile your Typescript code targeting ES6 and then Babel that shit up to target ES5.At this point I don&amp;#039;t know what to say. ***** [**Extended Summary**](http://np.reddit.com/r/autotldr/comments/55z3k9/how_it_feels_to_learn_javascript_in_2016/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ "Version 1.65, ~110316 tl;drs so far.") | [Theory](http://np.reddit.com/r/autotldr/comments/31bfht/theory_autotldr_concept/) | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr "PM's and comments are monitored, constructive feedback is welcome.") | *Top* *keywords*: **need**^#1 **library**^#2 **JavaScript**^#3 **fetch**^#4 **React**^#5
 val tape: Tape = Tape() tape.setInitialTapeState(input) Pass this in the constructor, no need for a setter here. tape.currentCellValue() currentRule.getNextState() Should be properties. tape.applyRule(currentRule) tape.printTape() tape.movePointer(currentRule.getDirection()) I use `with(tape)` whenever I see code like this, simpler. return stateMap[firstCommand[0]]!! Find a way to remove this `!!` (and others). class State(stateName: String) { private var stateName: String private var ruleMap: HashMap&lt;CellValue, StateRule&gt; init { this.stateName = stateName this.ruleMap = HashMap(3) } Why not simply case State(val stateName: String) { private val ruleMap = hashMapOf&lt;CellValue, StateRule&gt;() That's just reading the first few files. 
Ah you are right. I would have loved it if the choice would have been to treat all platform types as nullable. Especially in Android I can still get null pointers when handling a platform type (although I think it's a lint warning now)
I think that would force you to use !! too much and then you get used to it and then something like op's original code is the result. The current behavior probably makes sense. Idea should still warn you, yes. 
Sorry, but I disagree enough to have written a blog post ;-) http://www.oneeyedmen.com/extension-functions-can-be-utility-functions.html
I think it should force you to handle the platform types as a nullable types. No !! needed, just cast to a non nullable type if you are sure. I honestly think a type system with non nullable types should have no escape hatches like !!. The only route from nullable to non-nullable should be checking for null.
Are there other languages that have extension functions?
I know C# has them.
yeah, I guess the title was bad. All extension functions you've demonstrated make perfect sense to me. I didn't want to say that extension functions shouldn't add utility to the classes they extend. I wanted to say that you should take care to add them in a such a way that they look right semantically, so that they are meaningful. In my post I kind of formulated a check you can run to see if this is the case (i.e. if you pass `this` to other function inside extension function, then _probably_ you are doing it wrong) - and notice that none of functions in your post are doing that. So they are good ones :) I guess I just didn't give enough thought to come up with the right terminology and so messed up a little - word "utility" can mean several things in our programmers' lingo :) **EDIT:** I updated post title a bit, dunno if it's any better.
Have you tried dart ?. Here is my comment on another [js article!](https://www.reddit.com/r/programming/comments/554wvr/javascript_in_2016_isnt_horrible_its_just_going/d88w341) . By the way i love kotlin too ;-)
Not too familiar with C# so I'm not sure what you're referring to. I know that, for example, LINQ functions are extension functions, and the standard library's collections don't have those functions as part of the class.
Scala has basically the same thing via implicit classes.
I believe in D any function that can be called with something like f(a, b) can also be called with a.f(b). JavaScript allows you to add methods to objects at runtime. Related, but slightly different.
Yea... Gotta disagree with this article. Adding a toAddress method to JsonNode is exactly the kind of module boundary crossing the other article wished to avoid. A toAddress method has no business polluting the JsonNode namespace like that. 
I hate it when reasonable people listen to each other and end up in violent agreement ;-)
Surely it would be Address.from(node).inUK
hahaha :)
Only if you've added a context specific Address.inUK extension function. QED
Importing isn't really something you should consider imo - just look at people still using java.awt.List by accident :)
Ah that is easier - things do progress!
You can share parts of your business logic with Android.
What if I make an `Option&lt;SomeClass, SomeClass&gt;` and want to call the first one without using the returned value? How would it tell which I wanted to use?
i think you meant: data class State...
I would imagine the call site would define the behavior. If you assign to a variable, it's the method returning a value; otherwise it's the Unit. In a situation like the one you posted with the same two types, I would say it's a case of "Just because you _can_, doesn't mean you _should_." I'd suggest always using a throwaway variable when calling a function that returns a value which you don't intend to use. This will help while debugging, and can save hours of head scratching when that throwaway ends up being relevant. 
What does "Intention to convert loops to lambdas" mean exactly? Like a while loop would be implemented via an inlined lambda?
That would be my guess too, if the condition of the loop is only use in particular ways. For example, if your doing an op on each element in an array, it's easy to convert into a lambda instead of a while loop. 
I think it refers to taking a for loop and converting it to a foreach call. e.g: `for (i in things) i.doStuff()` can be converted to `things.forEach { it.doStuff() }` I believe that currently there's only an intention for doing it the other way around. Maybe it can even be smart and automatically figure out what can be made into a .map() or .filter() call, for example.
Good god man, your bullets...
Is there something wrong with them? They look fine to me. 
I love how Kotlin can make it more convenient and less error prone to use "low level" API's like this. P.S. Please advise if there's a more appropriate place than this sub to share this kind of thing.
This is the place. You should try creating a library and publishing it to Maven or JCenter, that way it'll be easier to use.
Casting is something I want to keep to a minimum and as such, I'd rather not create synonyms that will make it harder for me to locate all these casts in my code base later. Besides, the `as` line is really not that much worse than your `cast` version, in my opinion. 
besides, the post was a joke:p It means to state that Kotlin is so funny and nice that even if you dislike something in the language, you can still make your personal arrangements.
Nice, reminds me of the C# IEnumerable Cast: https://msdn.microsoft.com/en-us/library/bb341406(v=vs.110).aspx
Will Kotlin allow a varargs function with a trailing closure? `conn.execute(sql, arg1, arg2) { result -&gt; ... }`
Is this really a good [implementation](https://github.com/dbacinski/Design-Patterns-In-Kotlin#builder--assembler) of the builder pattern? It doesn't even build anything! It just invokes (essentially static) methods on a class that has already been instantiated
I'd say it is not a good implementation - it may follow the shape of the Builder pattern, but it's not good Kotlin. Kotlin uses not-nullness and primary constructors to ensure that objects are created in a state which as close to useable as possible. Class Dialog DOESN'T EVEN HAVE ANY FIELDS, so it's impossible to comment on whether the goal of correctly initialising the instance has succeeded or not. It's also impossible to say whether those fields were intended to be variable or nullable. It's much better in Kotlin to write this: class Dialog(val title: String, val message: String, val bitmapBytes: ByteArray?) {} val dialog = Dialog("Title", "Message", file?.readBytes()) Kotlin makes all of the hoohah about whether parameters have been provided or not much more explicit - if it's declared as a String then there's jolly well going to be a string there or it won't compile, and if the parameter is optional then the type will say so. However I do agree that using .apply {} to fill in optional parameters is a good pattern.
Needing to cast in the first place is a code smell.
You know that meme with the burning house and a dog going "this is fine"? That. Except the house is very very smelly.
Nice article. Just noticed one thing I don't like about Kotlin. Why is it val numbers = listOf(1, 2, 3) and not val numbers = List.of(1, 2, 3) the latter would be pretty much the same to type, would match Guava immutable collections nicely, and it would be much clearer, which type is returned instead of having a weird "global" static function.
Because Kotlin isn't a pure OO language probably. Why constrain how we express it?
An IntelliJ auto-refactor that will take a for/while loop where possible and convert it to a forEach style syntax.
I don't see what that has to do with anything. With that logic you could have named the function quasdgj().
Should also include the `to` keyword for pairs and maps!
Kotlin varargs don't have to be in last position so that API should be possible. https://kotlinlang.org/docs/reference/functions.html#variable-number-of-arguments-varargs I used a builder instead because I didn't want to work with List&lt;Any?&gt;. It's more boilerplate than I'd prefer but is strongly typed and still vaguely resembles a list if you want to keep it on one line. https://kotlinlang.org/docs/reference/type-safe-builders.html
&gt; How is Kotlin more OO than Java? Primitives working like objects (having methods and so on) for example. Arrays working more similar to the usual collection objects. Companion *objects* instead of static stuff.
Hmm, good point. Regarding companion objects though, usually I find that what used to be a static java method or property can be removed from the class altogether and made into a package-level method/property. But yeah a lot of the low level stuff is abstracted as classes and objects
You can create an extension function for this which will have exactly the behaviour you want
I know, it's not a big deal, just a little thing that I think could have been designed better. 
That's not better. I'm not sure if it's worse, but it isn't better.
You don't want a situation where people use data structures just because they have nice syntax. That has happened in a lot of languages that have convenient syntax for privileged data structures.
It's a function, not a keyword.
I dont understand, how can it be better? You have the listof() way and you can create the function List.of() in one line of code and use it everywhere.
Kotlin doesn't really do ternary, at least not with a simple ? and : At best you can do `val something = somethingElse ?: someOtherThing` But that only checks if the left side is null or not, whereas ternary checks for true/false.
That's the elvis operator, which is _not_ the same as the ternary operator (can't tell from your post if you meant this or not). As you said, the elvis operator branches on null, but the ternary operator branches on a provided predicate. Edit: I'm glad Kotlin doesn't use the ternary `? :` because it's a little too cryptic for my taste. The elvis operator is somehow OK to me though, I dunno 
I'm not suggesting this syntax exclusive for List. It could be val arr: MyArray = [1, 2, 3] which would be rewritten as val arr = MyArray(arrayOf(1, 2, 3))
When we have a full control over object that we want to create then we do not need to use Builder pattern in Kotlin. I have assumed that Dialog class is provided by external library or framework and we cannot change the API. Please have a look on improved example and share your thoughts: https://github.com/dbacinski/Design-Patterns-In-Kotlin/pull/7/files?diff=split
Oh I see, you're doing a Builder which starts knowing everything and has to spray the values into a variety of methods. The way I'd write that would be: fun main(args: Array&lt;String&gt;) { val dialog = Dialog().apply { setTitle("Dialog Title") setMessage("Dialog Message") setMessageColor("#333333") showImage(File.createTempFile("image", "jpg").readBytes()) }.show() } which still doesn't use a Builder object. I think the reason you can't present a really good example of the Builder pattern is that Kotlin has many features which cause it to be not needed any more. For example, default values for parameters decrease the number of constructors needed for complex classes, to the extent that Kotlin insists on exactly one primary constructor which must be called, and it's not the parameterless one. The .apply method is also wonderful. And if you're concerned about setting one property and not another that should be set with it, you can write an extension method like this: fun Dialog.setMessageData(msg: String, color: String) { setMessage(msg) setMessageColor(color) } which lets you then create the dialog like this: val dialog1 = Dialog().apply { setTitle("Dialog Title") setMessageData("Dialog Message", "#333333") showImage(File.createTempFile("image", "jpg").readBytes()) }.show() Rather than write Builder classes in Kotlin, I'd probably tend towards writing extension functions which fix the API that caused the problem.
Yes, Clojure/Swift protocols and Kotlin extensions are very similar. Here is an example of using Protocols to solve the expression problem http://eli.thegreenplace.net/2016/the-expression-problem-and-its-solutions/ You can do the same with Swift Protocols and Kotlin Extensions. I think this blog post is a better example of when extensions should be used. It focuses on how to conceptually tackle a problem vs syntax issues and how "nice" something might look or not. 
Release will be this year? 
I don't know, but judging by how fast these guys are making progress, it wouldn't surprise me.
The more I see of Kotlin the more I like it, and most all the stuff in this presentation looks good... but here are a couple of items that come to mind looking at this presentation. Coming from clojure, one of the most absolutely great things are the immutable data structures. Are the data classes immutable with structural sharing, or could they be made so? That would be an absolutely killer feature especially if they were the default and if there were some clean way to specify that a particular data class I want to be mutable for performance. Bonus if data classes could be "mixed" rather than using inherited. These 2 features would give Kotlin a real positive differentiation over Java. STRONGLY DISLIKE the "Member reference" syntax. It introduces a new way to represent a concept and seems like syntax for syntax's sake which adds nothing. I feels like it's a first step down the path to a scala'ish complex syntax. Kotlin designers please show some restraint. 
Member references in Kotlin are implemented in exactly the same way as in Java 8. They are not a new feature in 1.1; they existed in 1.0, and 1.1 added support for references to members of specific object instances (AKA bound references).
On the following slide there's an example of a bound member reference with parameters. `registerCallback(this::handleEvent)` 
Also destructuring would be nice
This was happening on 2016.3 eap as well
Nothing compiles (no imports work), and the ctrl+click code tracking doesn't work at all. No expressions are recognized, and they infinitely loop trying to be recognized.
Looks like an anti pattern, in Kotlin you should use dataclass with named parameters to build an object. 
Binding.scala looks very interesting to handle both front and back. I think this kind of framework could be written in Kotlin too : https://github.com/ThoughtWorksInc/Binding.scala
&gt; in my opinion persistent vectors doesn't look really interesting Please don't discount them to quickly. Once you use them it's hard to go back to mutable(except for performance). Persistent mean never having to worry about a class reference being mutated out from under you by another method or thread and gives a far more stable base to reason upon.
Very interesting, thanks for the link.
Does the new Kotlin plugin update fix the issue for IDEA EAP?
I agree with your opinion about read-only data structures, even so this algorithm implementation on JVM may not be very efficient,
Just a hint: when { firstName == "Dan" -&gt; person.team = programmers lastName == "Dihiansan" -&gt; person.team = designers else -&gt; person.team = others } can be replaced with the following because when can be used as a statement to assign values: person.team = when { firstName == "Dan" -&gt; programmers lastName == "Dihiansan" -&gt; designers else -&gt; others }
Take a look at JetBrains Exposed. It's basically JPA through delegates if you use the DAO and ridiculously scalable!
Yeah Exposed is cool - I've been stealing DSL ideas from it. We're using flyway for DB migrations though, so we couldn't use the DDL features.
I agree, there appear to be several ways to do very similar things. Sealed classes can have different fields in each subclass and enums can't. Enum instances are singletons, whereas sealed classes need to be instantiated. I'd say use enums if you can as they are probably more efficient. I wonder about the difference between global object instances and companion objects. I tend not to use companion objects in Kotlin, they seem to be an unnecessary Javaism.
Yes, however DL4J doesn't have a well-designed API.
Oh I just assumed, sorry. 
JVM itself will happily inline your functions, so you don't have to do it just because you think that your function is small. On the other side, if your function has lambda parameter, then without Kotlin inlining, there's an extra object creation (object which will contain that lambda code, all captured variables, etc) and JVM isn't smart enough to get rid of it. But with Kotlin inlining, there won't be any extra object at runtime, everything will be inlined. So main point of Kotlin inlining is getting rid of unnecessary objects carrying lambda code. Also inlining allows to use reified generic parameters, that's awesome sometimes: when you have to pass Class&lt;T&gt; in Java, Kotlin will figure it out "automatically". 
The way I see it, in goes in, meaning we consume the type, but never return it. On the other hand, out goes out, meaning we only produce it, i.e. return it. 
in is where you can still 'put things in', meaning use the type as a parameter (javas super). out is where you can 'take things out', meaning use it as a return type (javas extends). 
I was wondering the same but managed to find it in the documentation: https://kotlinlang.org/docs/reference/generics.html
Sure, Spek is also a good example. The main goal of the post was to show how easy it is to define your own :-) If you want more powerful stuff, I believe Scala can help you. 
Kotlin In Action has a chapter dedicated to constructing DSLs. And Kotlin.html is a good open source example of implementing a DSL.
Yeah definitely! I've made kind of a bad attempt at building a DSL for Android Wear Watchfaces (unreleased, it's embarrassing, lord help me). I realized halfway through the project that it's not necessarily clear exactly how best to approach making a DSL look the way you want it to while also capturing the workflow of an underlying Java library.
Yeah, I would say though Anko is closer to a practical example of building a DSL out of a preexisting Java library. Which I think is maybe what I meant in the first place: design patterns for adapting existing libraries to declarative Kotlin DSLs.
You might be interested in http://martinfowler.com/books/dsl.html
PECS -&gt; Producer Extends, Consumer Super. POCI -&gt; Producer Out, Consumer In. Just think of the chocolate stick snacks called Pocky.
See http://kotlinlang.org/docs/reference/
[Kotlin in Action](https://www.manning.com/books/kotlin-in-action) is pretty good. 
Seconded. It's written by two of the main developers of the language, so it will be difficult to get closer to the source without reading the bytecode yourself.