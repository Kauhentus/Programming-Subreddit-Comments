Usually i'll use val by default and only change it to var if need be.
It's _so_ trivial, and if you think it's complicated and has so many moving parts I don't know what to say but that's a big sign of incompetence. If you can't handle this trivial problem how are you going to write anything even remotely more complicated? &gt; so many moving parts, inefficiencies, and latent bugs. Give me a fucking break! The reason my comment is downvoted is because beginners (and even some intermediate people) have a phobia of writing code that manipulates data. Another answer in the thread recommends _sorting_ the array, and then _reversing_ it, and that answer does not have negative score despite being obviously slower and more verbose, etc.
has very little kotlin content!
I feel dirty when I use var 
Why do I have to repeat myself? Here I'll just inline my previous comment: The snippet was not meant to be complete, but was meant to show how to do this kind of basic logic without holding up and waiting for a "standard" solution. There's nothing wrong with using loops and conditionals. You think an 'if' condition inside a 'for' loop is confusing or juggling too much data? 
Basically, I plan on making a [JVMTI](https://docs.oracle.com/javase/9/docs/specs/jvmti.html) agent to do a couple of things in the JVM (I have [done so](https://github.com/cretz/stackparam) in other langs before). So I built this proof of concept to prove it can be done. There were many hurtles and the minimal result shown is whittled down from lots of research and trial+error. This same approach can be used for JNI too. You can expose [JNI_OnLoad](https://docs.oracle.com/javase/9/docs/specs/jni/invocation.html#jni_onload) and call things like [RegisterNatives](https://docs.oracle.com/javase/9/docs/specs/jni/functions.html#registernatives) to call Kotlin Native from the JVM.
&gt; var a = a Does that actually work? Wow
&gt; If you can't handle this trivial problem how are you going to write anything even remotely more complicated? It's not about inability to handle the problem it's about efficiently writing expressive code, a principle you shouldn't forgo just because the problem is simpler. If you're not interested in idiomatic kotlin nor functional programming and come here to insult people shouldn't you go back to C?
I'm glad Kotlin doesn't. While they're sometimes the best choice, they're generally anti-pattern. I'd kotlin had static methods, we'd see a ton of unnecessary static methods as people ported java code. It forces devs to rethink "should this really be a static method in a functional language?" Granted, people do the same and just dump shit in the companion object {}
&gt; The documentation of Kotlin recommends that you should use package-level functions if you want to follow DRY. This might seem a little odd if you have worked with Java because it’s not there in Java! What's a function? :S Are people really confused because languages other than Java have a thing called "function" that does not have to be attached to a class? This is one of the most bizarre reaction I see among people who are new to Kotlin.
Allthough they did a really great job hiding the bad parts of java, java legacy is the answer to many questions that naturally arise when using kotlin. Since java is obviously closer to the jvm bytecode than kotlin, it is always an advantage to know java and jvm stuff. Additionally, if you understand what java equivalent is produced by a kotlin Feature, you have a better understanding of the overall platform, your program and so on. If you don't Want to gain such a complete knowledge, than learning kotlin first is okay, but i don't have good tutorials for this purpose, sorry :)
&gt; The reason my comment is downvoted is because beginners (and even some intermediate people) have a phobia of writing code that manipulates data. I think you've been downvoted as you did come across as a little condescending and now also a little arrogant. &gt; [...] something trivial like this, you should be able to write yourself. I think this makes a sweeping assumption on OP's profiecency in Kotlin. We all started somewhere, what might be trivial to some is a complex problem for others. I think there's a little lack of respect in that statement which I am sure you did not intend. &gt; Don't always wait for something to exist in the standard library What you suggested is a perfectly valid solution, but I guess really it boils down to the fact it isn't the most 'Kotlin'-esq approach, *especially* with `maxBy` in the standard library for all to use. If it is there, you shouldn't hesitate to use it, there is no need in this case to re-write a library function. 
For non-android development I can't say as much, but if that's what you're goal is it's definitely really easy to go straight into Kotlin. For all of the udacity tutorials I did, I'd take the first exercise of the lesson and then turn it into to Kotlin code (there's an option for this on Android Studio), then work on that first file through the rest of the lesson. It's really easy to translate once you get into it a little. I am graduating soon so I have a little bit of experience with other languages from class/ side projects. All in all, I definitely prefer Kotlin to Java but to each his own. Try it out and if the lack of documentation is a problem for you then by all means just learn Java first. Good luck and remember that any language has a learning curve, debugging shotty code is the best way to really learn a language. A master programmer has failed more than a beginner has tried.. or something along those lines 
mutable static state is bad, pretty bad. But there is nothing wrong with static functions. In Java, you can conveniently put related static functions in the same class with a meaningful name that can describe them (eg, StringUtils for static functions dealing with String). In Kotlin, you either need to use companion objects (and be more verbose than Java), or use package-level functions (and lose information, as the package name is used also for other classes that might not be directly related to those functions). I love Kotlin (its my main programming language), but the lack of a "static" keyword (for methods, NOT mutable variables) is a limitation (which I hope one day they fix). 
I wish Udemy would just cut the 90+ percent crap and sell things at their intended low price.
Yeah, that. The Java static methods is actually a weird workaround for Java not having ordinary functions! Unfortunately it seems there are a lot Java devs who grew up in the Java world without any notion that things might be different in the rest of the world. When you need to explain there is something called a “function” that and refer to it as a special kind of method, there is something really wrong with the devs. This is just sad. Note that I’m a long time Java developer.
I always recommend total newbies to start with Java but I don't think that this is necessary for people with basic knowledge in programming. IMHO: You can start with Kotlin and learn the necessary Java bits on the way. Knowing Java and its problems is just a nice-to-have skill, that helps you to understand the design decisions behind Kotlin and make it easier to use Java libraries.
--ps please don't feel any pressure to answer my question if you don't want to. No problem - answering questions is kind of expected if you put yourself out there! :) --Why Jackson over other JSON libraries such as GSON or Moshi? Also why Jackson over something like org.json? Mostly we want something with auto-marshalling - which we use for translating JSON messages between services. This comes in really useful for writing CDC-style tests when creating fake HTTP services (which you can then test bad network behaviour with). GSON was considered to heavyweight, and we only recently started supporting Moshi in http4k! :) FYI, we use [this tool](http://http4k-data-class-gen.herokuapp.com/) to auto generate our data class definitions from JSON messages, so that reduces the amount of boilerplate you need to write manually. --Working off 1. Is it easy to do specific JSON replies with Jackson? For example someone requests information about user 1, if the user is user 1 themselves I return more information about the user than if they were user 2. Not really sure what you mean here TBH - but using the generated data classes, you can simply mark fields as nullable and then populate them or not, depending on the use-case. --What about parsing arbitrary JSON? We fall back to using either the native JSON library node type (JsonNode or JsonElement etc) - which is supported in each of the messaging modules, or maps in the some instances. --What system do you use for restful authentication? Do you use any libraries to help with that? Lots of our services aren't secured, but for the ones that are, you can use signed JWT tokens which are passed between services using the same Filter mechanism that we support for the Zipkin tracing headers - although that code isn't actually released it's pretty easy to write. The signing code is also hand rolled (using a variant of the AWS signing algorithm - which you can copy from the http4k-aws module) and the actual auth can also be simply applied using a http4k Filter. There's a [presentation](https://www.http4k.org/server_as_a_function_in_kotlin/assets/player/KeynoteDHTMLPlayer.html) that we gave at the London and Sao Paulo Kotlin meetups which shows a lot of how we do service composition and e2e testing. We're also generally on the Kotlinlang slack if you want to hit us up with more questions. Also, if you want a *really quick start*, there's a [repo](https://github.com/http4k/http4k-bootstrap) which will create a fully automated http4k app CD pipeline (Github -&gt; Travis -&gt; Heroku) in one line of bash. :)
OP: &gt; Learn in 2 minutes Medium: &gt; [3 min read](https://i.imgur.com/OW6RYeC.png)
Fuck off spammer.
Can someone TL;DR Tony Hoare's complaint about null pointers? To me they seem extremely useful. E.g. how do you do a linked list without null pointers?
`Optional` is one approach.
Why this over [kotlinx.serialization](https://github.com/Kotlin/kotlinx.serialization)?
Right, but then you are allowing null pointers. It seems Hoare is mostly complaining about pointers in general, or possibly the ability to assign arbitrary values to pointers...so maybe the problem is not so much null pointers, which have a meaning and can be explicitly checked for, as it is random garbage pointers.
It's specifically null pointers, or more properly null *references* (by opposition to the random clusterfuck of C-style raw pointers). [You can get it in his own words as they're perfectly clear](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare), here's a short and sweet quote from the hour-long "Billion Dollars Mistake" presentation: &gt; I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.
&gt; Is he making a pointer/reference distinction that I'm missing? The entire point of references (in the ALGOL W context) is to be type-safe. You can't just convert any reference to any other nilly willy. And null references break that type-safety, because while a nullable reference to a `Foo` can't actually point to a `Bar` (assuming disjoint types) it *can* point to a `null`, which is not actually a `Foo`. &gt; The innumerable errors have mostly been caused by unchecked array bounds in C. Nullable references cause numerous bugs in languages which do have bounds-checked arrays (which is pretty much all of them except C these days).
What do you mean by pointer vs. reference? By "reference" I meant the C++ idea of a pointer-ish thing, except it can only be initialized by pointing to an actual object, so it can't be null. Algol W, and Pascal and other pre-C languages, only have what we would call pointers, and they can be null. Now I would say that Pascal had type-safe pointers, but it did allow null pointers. What breaks type safety is void * pointers and casting of pointers. It seems to me if you say "pointers can't be null", then for something like a linked list, you would make a rule that rather than the end element being null, it points to its own element. Just as easy to code against, but if you make the mistake of not checking properly you still get a bug...except now instead of a null pointer dereference you get an infinite loop. Is that better? Nullable is now becoming more popular for non-pointer types, so things are going in the opposite direction. And I don't think people consider nullable to violate type safety. I realize that the Algol W crew thought that Algol 68 was too complicated and would probably think Swift was an abomination, but I never understood the objection to null pointers specifically.
&gt; What do you mean by pointer vs. reference? I mean the difference between an unmanaged raw pointer and something which the language handles at a somewhat higher level e.g. Java references, or Python's, or (according to Hoare) Algol W's &gt; By "reference" I meant the C++ idea of a pointer-ish thing, except it can only be initialized by pointing to an actual object, so it can't be null. I'm obviously not talking about that considering I'm *quoting Tony Hoare who talks about nullable references*. &gt; What breaks type safety is void * pointers and casting of pointers. That breaks not just type-safety but also memory safety. Null references break type safety because it's possible for the reference to not point to an object of the declared type (namely by pointing to nothing at all). &gt; It seems to me if you say "pointers can't be null", then for something like a linked list, you would make a rule that rather than the end element being null, it points to its own element. Of course not what kind of nonsense is that? You wrap the reference in a "nullifying" container (either a builtin or a bog-standard option type). The point is to separate "reference" and "possibly null" such that nullability is not *ubiquitous*, and nullability checks can be *statically enforced*. The billion dollar mistake is that *every reference may or may not be null, the developer has no bloody idea and the tools can't help*. &gt; Nullable is now becoming more popular for non-pointer types No they are not. They are going into the direction of separating the concepts of "can be absent" and the concept of references. Ignoring raw pointers, Rust doesn't have null pointers. It has (smart) pointers, and it has an Option type. &gt; And I don't think people consider nullable to violate type safety. Of course not, the entire point of option types it to provide type-safe nulls, by lifting nulls outside of *every reference type* and into its own.
&gt; You wrap the reference in a "nullifying" container (either a builtin or a bog-standard option type). The point is to separate "reference" and "possibly null" such that nullability is not ubiquitous, and nullability checks can be statically enforced. The billion dollar mistake is that every reference may or may not be null, the developer has no bloody idea and the tools can't help. I think I'm starting to get it. First of all, that not EVERY pointer can be null, only certain pointers that you mark as such; and second of all, that you can require that you write a handler for the null case in your code, otherwise it won't compile. Like what Swift does (not familiar with Rust, I assume it is something similar). Although Swift still lets you say "I promise, this pointer will never be null"...although maybe it restricts when you can do that to places where it can verify that it's true. HOWEVER this is beyond any language concept that was floating around when Tony Hoare was working on Algol W. There were barely any languages with exceptions, and pointers were unusual. I think he really just meant, "We should force pointers to always be non-NULL", and I'm not sure what he proposed as an alternative.
Huh? Didn't Spring 5.0 add Kotlin support? The WebFlux stuff seems pretty kotlin-y to me... They also manage optional query parameters with nullability in Kotlin
Yey, *enthusiasm*
Hi there, you can have only one companion object per class. But I would like to know, why would you need multiple ones in a class? Maybe I can suggest a better way to that use case. thanks.
Java would be better for StackOverflow(shrug)
Love Kotlin's data classes. Just a couple of caveats for anyone starting a Spring Boot + Kotlin project, or migrating Java Spring MVC code... Hibernate and Jackson both have a handful of janky implementation details that will bite you in the ass while using data classes. First off, there's the (generally) obvious "no-arg" constructor problem, which you can solve as part of your Maven/Gradle build. This is well-known, and therefore, well-documented. What is *less* well-known is that data classes' auto-generated equals(), hashCode(), and toString() methods will fail catastrophically in the event that you have two Hibernate entity data classes with a bidirectional reference (e.g., OneToMany on one side with ManyToOne on the other). The workaround for this involves overriding these methods on the "child"/ManyToOne side of the relationship so that the "parent" entity is not considered as part of the equality/hash code/string implementation. I usually end up doing this with a private data class that omits the "parent" field and a constructor that takes the entity instance as an argument, and then essentially pass the entity class's equals/hashCode/toString methods off to the private data class. Hibernate also chokes on immutable collections in data classes. If you try to either convert the collection to a mutable instance and add an element, or re-assign (via entityClass.copy()) the collection reference to a new collection of the old collection plus a new element, it won't persist. As for Jackson, it (currently) has problems with deserializing immutable Boolean fields. For a request entity, these always have to be var instead of val, even with no-arg constructors. Sooooo other than the three or four rusty bear traps in the middle of the living room floor, data classes are great!
Things like that are what kept me off Kotlin. I write a lot of Swift code in addition to Java, and thought Kotlin would be a great way to get some “Swiftiness” in my Java EE applications. But the sheer number of caveats I would have to account for made it too much of a hassle. 
To be fair, there aren't *too* many, and the framework dev teams are doing their best to patch up a lot of these issues all the time. Spring+Kotlin is far less half-baked than, say, MEAN stack, but there are definitely some impedance mismatches between Kotlin core features and Spring Framework. (Configuration property classes come to mind; they can be data classes, but all fields must be mutable and either nullable or have a default.) Thus far, I'm inclined to say that the reduction in boilerplate and the streamlined lambda syntax has outweighed the caveats versus using pure Java in terms of both productivity and maintainability. Performance differences are pretty negligible for what I'm doing, since it's all enterprise CRUD apps. For Android, I'd be a little more cautious about the extra allocation/reallocation/garbage collection overhead for all-val data classes.
You can call $name instead of ${name}. You only need brackets when you're using multiple variables like ${num1 + num2}
I just wish there was an annotation to be able to omit a property from equals() and hashCode() at compile time. 
I love the Monadic style of programming. It's weird, but this has given me the same impression as Haskell so far, in that when I finally got the damn thing to compile, things "Just Worked" ®
Awesome! Can't wait to work it into my Android development.
Good work! Suggest you add your link in hackr.io for broader reach.
Thanks! Will add the link there.
The doc UI is very pleasing for an open source project manual... anyone know if that's custom or something that can be found somewhere and reused?
You'll need to talk to /u/raulraja. It's been definitely heavily designed by 47deg, and is similar to the one they use for other docs so they'll know better.
You'll most likely find Kotlin jobs in the Android market, as that's where Kotlin has seen the most growth.
Kotlin is extremely interoperable with Java. The two languages can exist in the same codebase in harmony. During your interviews for java jobs, maybe you could ask them about innovations that they're working on and bring up introducing Kotlin to their codebase.
I miss it so much. I think any sane developer can handle this, although I can see the reason why they disable it.
I do not miss the insanely slow compile times caused by this feature.
For consultancies, the lack of implicit conversion will result in a tragic decrease in billable hours.
This causes slow compile times? Don't doubt just didn't know.
Unfortunately, not every co-worker is sane.
Hell no: “Scala--pack your bags; Kotlin is coming!” @OhadShai https://medium.com/@OhadShai/scala-pack-your-bags-kotlin-is-coming-5169f737cfe8
Congratulations to everyone who is making this! This is what we need.
Implicit conversions? Not at all. Implicits in general? maybe. But I think it's not worth the hassle. As soon as I have to work with other people on the project, it's better for me and them if the code - and what it actually does - is explicit.
Not every sane developer is willed to handle it, even though he's able to. The term "better readable" is highly subjective, and being explicit has advantages too. For me for example, except for some rather rare cases, it's better to be explicit when doing conversions. Often there are alternatives as well, for example just using extension functions or a typeclass construct equivalent with kotlin's scoped extensions.
There were a few situations were implicit conversions would have been a real time saver. On the other hand it is completely insane what the Scala community does with this feature, so all in all I'm glad it is not in Kotlin.
Oh damn I was waiting for this title to start using it, too bad! jk, I'm using it everywhere I can 😍
TIOBE is an absurd irrelevance 
Uh, Kotlin was never going to be number one anyway. I absolutely love it but to think that it could overtake the likes of C in any index (even one as unreliable as TIOBE) is delusional at this point in time.
Sometimes, but then all the complexity and different ways to write it like shorthand for implicit parameters... Nope, nope, nope
Has anyone got build.gradle.kts to *not* be completely highlighted in red? I see it mentioned so rarely that I feel like I'm the only one, but this article mentions it too. I'm on 2017.1.3 and no matter how I try to get the kotlin Gradle script, it's always highlighted completely in red complaining that it can't resolve imports or whatever. Even if I go New Project -&gt; Gradle (Kotlin DSL).
Yes, I'd recommend upgrading to 2017.3.3 and not using the New Project generators. Honestly, I've always found IntelliJ's build tool integration to be a little flaky and prefer to just drop down to gradle / maven for project creation. $ gradle -v ------------------------------------------------------------ Gradle 4.4.1 ------------------------------------------------------------ Build time: 2017-12-20 15:45:23 UTC Revision: 10ed9dc355dc39f6307cc98fbd8cea314bdd381c Groovy: 2.4.12 Ant: Apache Ant(TM) version 1.9.9 compiled on February 2 2017 JVM: 9.0.1 (Oracle Corporation 9.0.1+11) OS: Mac OS X 10.13.2 x86_64 $ mkdir foo $ cd foo $ gradle init $ rm build.gradle $ echo ' plugins { kotlin("jvm") version "1.2.10" } repositories { jcenter() } dependencies { compile(kotlin("stdlib")) }' &gt; build.gradle.kts $ ./gradlew build Then open the project in IntelliJ, make sure "use gradle wrapper (default)" is selected, and do Build Project.
&gt; Implicit conversions? Not at all. Implicits in general? maybe. Yup, that's where I'm at. I am tired of passing contextual state explicitly to every function that needs it. I've taken to using a lot of with/apply/run and hoping I don't need "this" state from before. Extension functions have obviated my need for implicit value classes.
I wish some effort would go into Dokka. Seems to be getting left behind.
Who won the Twitter contest!?
@lingen was the winner: https://twitter.com/kotlinconf/status/953654946695655425 
Yea, bothered me a lot too. After I updated everything IDE-related to the latest version, cleared the caches and built the project on console, restartet IntelliJ, it finally worked somehow....although I don't know exactly why. Was super enthusiastic about the topic, but kotlin gradle scripts didn't work well from my point of view.
CFP is now open https://sessionize.com/kotlinconf/
&gt;Type parameter T in above declaration does not have any variance modifier (**our** or in) You mean out?
Good article, definitely helped me wrap my head around the in and out modifiers a bit, or at least why they're important. 
And I'm still confused!
I think I've done each of those things several times over and still no dice... I'll just wait for better IDE support, I can live with groovy for the time being.
You misunderstood. In Scala you can have, for example, a local variable of a certain type, and if a function needed it, it could be an implicit param that you don't have to pad explicitly. 
This is not about a place in rank, it's about the most growth in a year.
Exactly what my conclusion was after the bad experience.
You'd have to write GTK bindings (I don't know how that works with Kotlin Native). It's not ready to be used in general.
There's this guy name Victor Kropp who made a GTK bindigs. But even he's using gradle.
Is there a reason you don't want to use Gradle?
Gradle need JDK?
got to say I went in a bit skeptical, but this is fantastic, and i can't wait until all the docs are complete
If you're tryng to use Kotlin for desktop applications why don't you try [TornadoFx](https://github.com/edvin/tornadofx)
Absolutely not, TornadoFx uses JavaFx which is not what i want to use. I want to use Kotlin/Native with Gtk+ :D
Hoping I don't need it is so I don't have to constantly qualify it. 
Define "memory constrained"?
Be careful not to fall victim to premature optimization, the JVM can optimize away a lot of things that might appear inefficient superficially.
I totally agree that “premature optimization is the root of all evil” but in my own experience I’ve seen that it can’t be used as a blanket statement either. Throughout and latency indeed get affected by design and implementation detail choices. 
https://youtu.be/ExkNNsDn6Vg TL;DW: Kotlin's language features may sound expensive, but they rarely have any performance impact, and when they do, the impact is extremely small. You shouldn't have any problems.
Without much context, I can say that autoboxing should only happen if you're using nullable primitives. If you want to keep them primitives, keep them non-null. For anything else, there's probably an article by someone who already analyzed it. And if you're really fine tuning, you can take a look at the bytecode, and compare it to equivalent Java bytecode, but that's also probably in the article :)
I don't think that being wary of premature optimization means that you should ignore the effects of design choices, I just think it means you should have an example of performance issues being directly caused by a generally accepted language/framework before writing it off. If you do have those examples then it's not premature, it's just optimization.
I agree, any application that can run in 4G ram in Java will have no problems in pretty much any jvm language.
I actually have been burned by the auto boxing thing. If you pay attention it's not too hard to spot. I do wish there was a mode that made it explicit.
Can you give us an example?
Yeah. Break your server first. Then optimize. 
What is the error you get? 
Don't use spring?
Ah, now I understand. But that has nothing to do with other sdk functions like with/apply/run.
I've use Kotlin and Spring together every day and while I do sometimes run into issues it's never been anything that couldn't be resolved. The vast majority of people would probably never have any problems.
I've been using Kotlin with Spring Boot for almost two years. Recent releases have made it much easier and I haven't had to revert to using Java in quite a while. But one of the best things about Kotlin is you can mix in Java classes any time you need to. Are there any specific concerns you have? I have an experimental project on Github if you want to check it out. It is what I used to learn Spring and Kotlin integration and continue to throw in new tech rather than concentrate on finishing the project. https://github.com/irotsoma/cloudbackenc-parent is the parent project but code is in the submodules it links to.
If you ask an actual question it might be easier for people to help you.
I wouldn't call this a quirk but rather basic Android and Java programming knowledge. I'd recommend reading the app doc for the classes you're using and Android developer docs for resource handling.
This is helpful, thank you.
Did you experience problems with AOP or Injecting a value that is Kotlin primitive wrapper (I don't know what the word for it is, ie: Int)?
 Canvas::class.java.getResourceAsStream("fieldDiagram.png")
Spring 4 works nicely with Kotlin in my experience. The only gotcha I've run into along the way is that Kotlin classes are final by default which causes Spring to be unable to wrap classes in proxies, but [there's a plugin for the Kotlin compiler](https://kotlinlang.org/docs/reference/compiler-plugins.html#spring-support) that neatly takes care of that.
Those functions change the implicit "this" hence you don't have to explicitly provide the qualifier in the same way you don't have to implicitly provide the param for implicit parameters. The similarities being how they make DSLs and other non-explicit code appear.
First of all, your User example is the perfect anti-pattern for using a data class. A domain model is either an entity, solely identified by its identifier (your I’d field in this case), or a value object, meaning it is immutable and can only be compared against other via structural equivalence. That aspect taken apart, the fact that you want different forms of projection of the same content indicate that you either have a poorly performing database, or, with more luck, that you are in fact trying to apply some form of CQRS. In the latter case, I would suggest you keep your query model completely decoupled from you command model. 
Sorry I should've been a bit more specific. I'm bulding a simple REST API where there is an endpoint for the user's profile (**/users/me**) and an endpoint for the user's contacts (**/users/connected**). I need to display the complete user details in the profile endpoint but only the id and name of the user's contacts in the second endpoint. Currently I've got a listConnected() method in the UserDao that returns the list of ConnectedUser that only contain the required data. interface UserDao { ... fun listConnected(userId: UUID): List&lt;ConnectedUser&gt; ... } data class ConnectedUser(val id: UUID, val name: String) But I don't know if creating a separate method and data class for every use case is a good solution. I was thinking of something more generic for the DAOs. Please correct me if my design is an anti pattern.
It is C and it was always be C. Because all the Tiobe index does is count hits in search engines (a weighted average of a bunch of them) and the long tail of irrelevant search results contains a ton of hits on Arthur **C** Clarke, Objective-**C** and Vitamin **C**. "C programming" gives 17.500.000 hits according to google. Now go and try to actually go visit hit number 17.500.000. You can't. Guess why?
I feel like it's important to know Java to fully utilize Kotlin, since then you know Java's limitations and Kotlin's solutions to them and you would also more familiar with jvm possibilities, but in the end it all comes down to practice. You should start with a project, google things you don't know, maybe even solve problems suboptimally just to come back later with more experience (e.g. knowing that something can be solved by a single line higher order function etc).
&gt; Make all the fields nullable in the data class and populate only the required ones. Definitely not. &gt; Create a separate data class for each unique projection. When necessary to address proven perf/scale issues from the third option, just below. &gt; Don't use projections at all, populate all the columns and just ignore the unwanted ones. Usually, working around the overly wasteful cases by using the second option, just above. &gt; Don't use data classes at all, use something like a HashMap. Perhaps if I was just going to feed the object into a templating engine or similar, but probably not even then.
&gt; As someone who hasn't worked extensively with Gradle This has nothing to do with Gradle. There are two ways to read in a file, you can read it in from the filesystem, or you can read it from the classpath. If you are planning on making the images available in your artifact (like a jar or war) then you need to read it in from the classpath. If you are going to make the files available on the filesystem, then read them from the file system. The example code you provided is reading the file from the file system. To read it from the file system you need to provide the correct path (either relative or absolute). In your example the PNG would need to be in the working directory of your app. If you are running from an IDE the working directory is configurable in your IDE, usually IDEs default to the top-level directory of the project. If you want to read from the class path you need to use getResourceAsStream from the Classloader and then make sure the directory the PNG is in is on your classpath.
This is a totally worthless answer as it neither explains anything and is potentially completely wrong if they are wanting to read from the filesystem instead of the classpath. Their example suggest they want to read from the file system.
Sounds to me like you need a DTO/viewmodel. You can just fetch the entire object and use something like modelmapper to transform the entities to your DTO to return the results.
Very inefficient though.
Reusing a partially filled model is especially troublesome if your model allows NULLs. Later in some other code you can't be sure if the data was completely fetched or only partially, which makes you distrust your foundation. I create a separate class for each unique projection because that's the only way to use the language's type system as a help, rather than hindrance. To reduce typing I use helper libraries like [sqldelight](https://github.com/square/sqldelight).
I tried doing this too, but it screwed with me that my static methods were above my non static properties. Now that I "said that out loud" I realise that the companion could have gone under non static properties, but hey.
Hmm, what do you mean by personal database? Sounds an interesting project.
I've only ever used Springs @Autowired-notation for DI. What is special about dagger/what makes it better? Do people use dagger in Spring or instead of?
Oh? Don't know that, if it's true I can't use Kotlin/Native like you said...
Like say you want to organize music files by their filetype, genre, etc. Or images by size, filetype, quality, etc. Both you could some data from the files and write that to a CSV file, and then parse that CSV file (like you're querying a database) to print out to STDOUT. Or if you want to do it another way you can. 
I'd like to direct you to a blogpost I wrote: http://galex.co.il/2017/07/12/how_to_get_started_with_kotlin.html
It's already fixed in both IDEs. So yeah.
the documentation for combiner is "A function that accepts two partial results and merges them. The combiner function may fold state from one argument into the other and return that, or may return a new result container." So it could produce the result by mutating one of the arguments. More efficient in my case since it saves a new allocation. Thanks for reading and commenting! 
I have seen that problem resolved by having two user classes, User and a UserDetails, since most of the time you only need basic info about the user you can use the the simple version. 
Link is dead..
Works for me
I like the idea behind this series, but... Does anyone feel like this slight difference in terminology ever really matter?
So something like this ? val lines = input.split("\n") val res2 = lines.fold(listOf&lt;StringBuffer&gt;()) { acc, line -&gt; if(!line.startsWith("=")) { acc.last().append(" $line"); acc } else { acc + StringBuffer() } }.map { Foo(it.toString().trim()) }
I'm doing a survey to discover how developers around the world are using Kotlin in their works and personal projects, what resources they are learning it. I intend to collate and release the results in a report that will help spread adoption and convince more people and organisations to try it out :) Oh, and get a chance to win a trip to KotlinConf in Amsterdam in October! 
There are a few oddities - for example the question: &gt; What are your favourite features of Kotlin? Says: * Pick 3 * Choose as many as you like
what would you suggest as an alternatieve to spring? im planning on building a rest api
It does indeed. It's a "feature" in Typeform. I'd like people to pick only a few, but the form doesn't allow that to be done in an easy way.
Netty
It says "Oops, something went wrong!" when I press &lt;Submit&gt;. Response is: {"error_code":"submit-error"} Any idea what it could be? I have answered all questions (and rather not doing it again), and is using Chrome on Win10.
yeah that works too. The custom collector lets you do the fold logic inside accumulate and the map inside the finisher. 
Sorry it's not working for you! The survey is run on Typeform and I've no power to debug it :( I can try checking if it's submitted if you DM me the email address you used? Could be it was just a temporary glitch.
I was wondering why do you mix and match Kotlin and Java? On Reddit you call it "Functional Kotlin" and the Medium-Post is called "Functional Java". Inside the Post you say "I’ll show how a functional solution with code written in Kotlin using the Collector API in Java 8.". So basically you use the Kotlin syntax with a Java API. Why didn't you use the functions that Kotlin already provides?
The combiner-Interface is just a contract, it doesn't say anything about whether you write it in a functional style. Functional programming heavily relies on immutability.
How do you define which News and Articles are popular and which not?
Found this talk pretty cool and wanted to try it out. So I went to the Github page with coroutines examples that he recommended (kotlinx github repo) and found the actors category since it interests me the most as I want to implement an actor in my project. There I saw: &gt; A simple actor can be written as a function, but an actor with a complex state is better suited for a class. but I could see an example with a class that implements actor? As far as I understood I should implement the ActorScope interface, this would allow me to use my class as an actor, but is it the correct way?
What do you mean? `listOf` literally returns a `List`, just like `mutableListOf` returns a `mutableList`, and `arrayListOf` returns an `arrayList`... This is exactly the point
That's phenomenal*
you can't access the "it"... but you can rename the "it"... let { outer -&gt; outer.let { inner -&gt; (/* here you have both 'inner' and 'outer' */ } } something like that
Check out https://blog.kotlin-academy.com/mocking-is-not-rocket-science-mockk-features-e5d55d735a98 for a couple tips on mocking.
On the topic, is there a way to call return@let the outer let from the inner let?
https://kotlinlang.org/docs/reference/returns.html You can use labels, I have never tried this for let but works for a variety of other blocks, don't see why it wouldn't work a let. Although I don't really see why you would need to do this.
Awesome. I have their docs pulled up all day but I missed it. Thanks for being more thorough than myself
You cannot call return from inside of let. Let returns the last statement of the block.
Okay, I see what you mean, but changing `listOf` to fit a different type is simple and transparent, whereas type inference or whatever mechanism you'd use to achieve the same functionality with a literal is naturally going to be much less clear
This is getting quite ridiculous tbh 
I'm not sure what you think I'm arguing other than that `listOf(...)` and literal syntax (e.g. `[...]`) are equally ambiguous and less clear than something more explicit, but we're already down that path...
I am starting my first libGDX and my first real Kotlin project right now. Should I use this or understand pure libGDX first?
If you want to keep your code Kotlinesque from day one, I'd say you can go with KTX directly. Some LibGDX APIs are plain ugly when used from Kotlin - especially anything involving passing `Class` instances around or GUI building. On the other hand, it's always good to know and understand your framework, so if you want to go with pure LibGDX to understand its quirks (and why KTX was written in the first place), gradually converting your code to KTX-powered Kotlin also seems like a good idea.
I get that a lot - Kotlin can significantly improve LibGDX APIs, so it seems that many Kotlin devs unaware of KTX reimplement most of this stuff in their projects. ;) Feel free to create an issue or make a pull request with your personal utilities if you think anything is missing from the libraries. Cheers.
Two things: First, while `if (x == null) return` does replicate `guard let x = x else { return }`, it does not replicate `guard let x = Int(y) else { return }` (though `val x = y.toIntOrNull() ?: return` would, but it doesn't support `guard let y = z as? String, let x = Int(y) else { return }` or any other long chains that you might do to set up multiple variables) Second: `guard` forces you to leave scope from its `else` (with a `return`, `break`, `continue`, `fatalError()`, etc). Given how many times I've had the compiler remind me that I never `return`ed after logging an error message, I'm very glad `guard` exists.
Awesome. Thanks for this :) Btw, if someone is looking for a simple spring-boot kafka-pipeline, I created an example a couple of months ago: https://github.com/bastman/codechallenge-watermark-service-kafka
Thanks for the comment :) What phone are you trying it on?
typo at &gt; // You can replace firt with firstOrNull, self-explanatory should be first I guess instead of firt
You should not commit the build, .idea and .gradle folder!
Okay so: * `main` doesn't need to be inside an `object`, or even the `JvmStatic` annotation. You can just define a `fun main(vararg args: String)` at package level. * The sorted map by value makes no sense. Maps don't have an order (even if the underlying implementation has) by definition. That's why you need to create a list to be able to sort it, it's not "missing" by chance. * `when` is much more than "an equivalent of a `switch`" * Most of your code isn't following the Kotlin style guide * Infix notation should be used sparsely. It doesn't magically make the text more readable. (In particular your example is a bad one. Using an extension fun would be more readable) In general, this needs a lot of work. It claims to be "a curated list of..." but it needs to be actually curated. I'm by no means an expert and I caught quite a few mistakes. Trying to sort a `Map` is the worst of them though. 
&gt; `Map`s don't have an order (even if the underlying implementation has) by definition. But `SortedMap` does, and `toSortedMap()` exists (for the JDK stdlib).
you've got my my input
Short answer: No...it isn't going to replace Java because : 1. It offers no 10x advantage over Java writing your app in Kotlin 2. It's still somewhat buggy. 3. Chances are the people who are getting into App development already know Java to some extent. 4. Google isn't trying to replace Java as opposed to offering an alternative to Java w/r to Native Android development...and as such...most Java developers are not going to make the switch. We know that Java is battle tested and it works.
 &gt;But sometimes, you have particular cases in which you have a Map, and you need to have kind of a "sorted" one. Of course, but your snippet is incorrect either way: the order of a `Map` is not predictable, even if you call `toMap` on a sorted collection. You should use a `List` or a `SortedMap` for this. 
Thank you once again ! You're absolutely true -&gt; Corrected within 10 mins :)
In fact I didn't even notice the ending .toMap() ... My bad hahaha, dumb error
This is a great little starter tut. Thanks for posting this.
How can you do anything with ktor given there is no documentation for it.
So if someone who knows both programming languages to write his app were to ask you which language to use for writing his Android app you'd suggest using Java?
It was documented well enough for me to get everything up and running, only the jpa part is giving me a bit of a headache
PSA, some Game of Thrones Season 7 spoilers in this article
What documentation are you reading?
java docs of methods
&gt; Trying to sort a Map is the worst of them though. The map does not get sorted, but the values of the map are exported into a list. Maybe it could be more efficient to use a PriorityQueue, so the value insertion already happens ordered.
Yeah... Wasn't expecting that
This is a partnered link, this means by default you'll be giving money to the '**indiekings**' partner. If you don't intend to give money to this random person visit: https://www.humblebundle.com/partner and opt out. Additionally posting partner links without disclosing that it is a partner link is a violation of Humble Bundle's partner program and you can report this partner by filling out a quick ticket here: https://support.humblebundle.com/hc/en-us/requests/new
Honestly, using Hibernate outside of a Spring project is a giant PIA. If you are using a greenfield library such as Ktor, then might be a good opportunity to look at some other db libraries e.g. exposed or squash
Actually I already figured it out and it was actually quite easy. I have looked into other libraries but nothing seemed as mature as Hibernate to me.
By the way, it's "tl;dr"
Why is maturity a problem when you're using ktor? There are pretty big changes made pretty much every week and it isn't even at 1.0 yet.
Oh never mind then. I was hoping for similar kind of documentation you can find on other frameworks.
http://ktor.io/quickstart/index.html
Someone who can point out what books that are really awesome? 
lots of pages in the official documentation are blank
I know, it's far for complete. But it was good enough for me to get my Rest API + Integration Testing up and running
Reified type is unnecessary, but I do something very similar all the time. You just need javaClass.simpleName
Hmm, not sure I follow. Can't access the class literal without reifying, right?
Hi, this is my very first blog post about anything, really. Feedback appreciated!
I didn't say "best way", I only said most elegant (probably less memory efficient for example). I get why you say it though. If you read the article, you will see that I defined the problem to solve very narrowly and put it in context and for that, I believe this to be the most elegant solution. If I am wrong and someone can correct me, even better.
I used kotlin in action for the most part. The DSL chapter was most useful. Also the official docs and API. Although it seems like intellij does a pretty good job of teaching by auto converting from Java and correction hints.
Do you have any specific resources about Kotlin in context of microservices? This seems to be my main line of work these days.
I never thought of this I'm definitely using this in my next project
I know Java very well so I just opted for Kotlin koans and practice. I’d say it’s enough. 
I've found the Javalin tutorials to be very helpful: https://javalin.io/tutorials/
Pretty decent libs included, but i can't image using them all every project. I have a similar setup, but with way less stuff.
Very nice :) That's what makes working with a platform pleasant.
When i saw announcement, my first thought was "Why such name? What will now happen with KTX for libGDX?" https://libktx.github.io
Being the author of KTX, for a second there I thought they are promoting my library on their blog. :) I think the name stands for "KoTlin eXtensions". I'm biased, obviously, but I think it's a really good name for a Kotlin project. Anyway, Google search for "Kotlin KTX" will soon stop showing our repository, so I think we'll rename the library to ~~Android~~ ~~Guava~~ LibKTX, since it's already the name of the GitHub organization (`ktx` was taken), and it's kind of similar to LibGDX. I hope it won't be much of an issue.
What is the relationship with Anko? Does this replace it? Are they meant to be used together?
This is exactly how android apps communicate with servers which may or may not be a java application. What you have to consider is what is the communication medium? Http? If it is, the most common way to de/serialize objects is to use the JSON format
No, I send my data via UDP. No other layers above it.
If your Java DTOs are compatible, yes
It's a function taking `Char` and returning `Boolean`. `it` is the implicit name of a single-parameter lambda. Therefore, something like `{it.isDigit()}` fits the bill.
How can I compare DTOs? 
What do you mean, compare? Just use Gson: https://github.com/google/gson Kotlin data classes can help you too
There's only eleven or so hours left on it, though.
I would suggest not to use Java serialization for network communication. One day you might find yourself in situation when you want to receive data in Swift/Python/Whatever application. So use something platform independent like JSON, protobuf, etc.
There's other important reasons not to use Serializable for this as well. 
&gt; // after applying 'apply' (pun very much intended) That's... that's not a pun.
Another challenge you might take on that would speed this up a lot is something called [memoization](https://en.wikipedia.org/wiki/Memoization). You could make the Fibonacci function recursive, and use memoization to cache results rather than having redundant calculations. In regards to how you might achieve this idiomatically in kotlin, [this](https://stackoverflow.com/questions/35304864/memoization-function-in-kotlin#35308944) would probably be some help. If you'd like to see how this is implemented in another language, [this](https://mike.place/2016/memoization/) is a great write up about it in python. 
Look for Java tutorials on LibGDX, gradually refactor to Kotlin. You might find [LibKTX](https://github.com/libktx/ktx) useful: it's a set of non-invasive Kotlin DSLs and utilities on top of LibGDX. Basically unofficial Kotlin support for the framework.
For general 2D games, how big a difference in time/effort is there between using something like LibGDX versus doing your own graphics/sprites, input, sound, etc. via Android API calls? Intuitively I want to do as much as possible myself, but if the difference is big I'll use a library. Really I'm trying to get a feel for what a typical Android game developer uses, as well as how to approach learning the API, Android Studio, Kotlin itself, etc. simultaneously.
A fuckload. Like 90% difference in effort.
Kotlin offers a tool to convert from Java to Kotlin, so all of those tutorials are perfectly valid. That said, I might try [this one](https://developer.android.com/training/index.html), that has Kotlin code included in the tutorial.
If your goal is to develop games, then use framework like libGDX, or engine like Unity. If your goal is to learn Android development, then Android SDK is your choice.
Go with **`Java`** first. **`Kotlin`** fixes a lot of Java flaws and provides many Java-compatible solutions to those. Without knowing the flaws, you probably would have a hard time understanding the solutions. Also, since 99% of online examples on the beginner side will be in Java and learning two language on top of Android will be a lot. However, there is no need to master Java before you begin learning Kotlin, but currently being able to convert between the two is still a requirement for effective development. Kotlin simply makes your life easier as a Java developer.
I think that you see it too much boilerplate because the project is really small. While the project gets bigger, you make the sacrifice of having boilerplate but a more maintenable code. 
Pretty much what u/WindWalkerWhoosh said. You'll end up constantly reinventing the wheel and writing generic enginey stuff that has nothing to do with your particular game. That said, if your goal is to learn Android SDK, frameworks like LibGDX might abstract too much of the platform's original API to prepare you to write actual mobile apps. Still, if your goal is to _finish and publish a game_, go with LibGDX/LibKTX - the ability to quickly test the game through the desktop version is worth it alone. If you want a 3D game, Unity is probably the best bet, as 3D LibGDX API is pretty low level.
I daresay start with Kotlin and ignore Java as much as possible. If you start with Java it will fuck up your idea of programming. You should not start on Java until you have a clear understanding of what good code looks like.
I would say that it's a good idea to learn Java too, but you can focus on Kotlin. Even if you are not going to code in Java, there is a great chance that you will use some Java libraries and it's very good to understand their code. 
Mathematically Squares are rectangles tho. All tests for rectangles should pass for square if the rectangle in case is a square
I had no experience with Java when I started to learn Kotlin. In my experience, most resources for learning Kotlin spend a lot of time comparing/contrasting Kotlin with Java to the point that you almost have no choice but to learn at least a little Java. You'll pick it up as you go, I wouldn't go out of your way to learn Java before Kotlin. 
I feel like that's similar to saying "Before you learn Java you have to learn C, and before you learn C you have to learn Assembly". Java will probably be easier to learn because everything is fairly explicit, however I wouldn't learn Java first just to understand why Kotlin was built the way it was.
Those benchmarks aren't surprising. From the looks of it you turned an O(3N) into an O(N) operation.
Is your choice of using tail recursion here to be able to calculate larger numbers?
From one hand yes, but language's features such as method reference can slow down the performance
Thank you for looking at the code. I was looking at feedback for my kotlin usage. Did I use it well, is there something I can improve, etc.
I see you're not often using `?.let { }`. It helps you get rid of multiple repetitive null checks.
Here is a rather comprehensive (86 videos) playlist on "Kotlin for Java Developers". I am working through it so I can figure out what @JakeWharton is talking about in some of his presentations. It is the only video series I have found that goes from basics to advanced Kotlin patterns in a rational way. And yes you have to learn both languages, but I find Kotlin to be more fun.
Try this video playlist - 86 videos from basics to advanced topics. It is the best Kotlin training I have found so far. "Kotlin for Java Developers" https://www.youtube.com/playlist?list=PL_RzKMPCc5z5qdsXMtynMDzpwDazNi7pS 
In this tutorial, create a simple to show images using ImageView in Kotlin on Android 
Yes, you learn java first, and you should learn through short examples, short tutorial.
It can but you're still using as many references here as you were before, I believe: map(::x).map(::y).map(::z) is 3 references map(::z + ::y + ::x) is still a minimum of 3 references. Then internally, you're creating NEW functions by returning { this(f(x)) } So if anything, I think composition might incur even more of a penalty through method refs. Not to mention (unless I missed something) the kotlin stdlib will inline all those method refs to map if possible (given they are not bound references) I still think the tradeoff is that you're not looping through your list 3 times, you're only doing it once now.
Thank you!
Yes, your suggestion is spot on. The main goal of function composition in this sample is using single map function instead of 3 map functions and increase readability without performance issues.
Is memoization faster than a linear for loop? Anyway, if speeding up is needed, I recommend using the Golden ratio.
Actually, method references won't slow performance. They're simple dynamic virtual method lookups. Most of the time JIT will just shove these lookups into the calling code if it can. Profiling the jvm is hard.
Please look at this issue https://github.com/KucherenkoIhor/CompositionOfFunctionsInKotlin/issues/1 It shows that a lot of methods and anonymous classes generated. They can impact performance
One excellent option if you do not intend to go the full Hibernate way, I would recommend [Jdbi](http://jdbi.org/). It's a lightweight interface sitting on top of JDBC, amazingly easy to use, and integrates pretty damn well with Kotlin. As an example, assuming you wanted to insert a `Person` object into a table, without wanting to make said object a model of your database, you could go about it this way: interface PersonInsertions { @SqlUpdate(""" INSERT INTO person (name, age, awesomeness, type) VALUES (:person.name, :person.age, :person.awesome, :type) """ fun insertAwesomePerson(@BindBean("person") person: Person, type: Int) fun insertAwesomeClient(person: Person) = insertAwesomePerson(person, PersonType.Client) ... } As an example, inserting your POJO
For the record - I agree with you, and I immediately thought that your article would be a great response to his [posts](https://www.techyourchance.com/jetbrains-invented-promotes-kotlin/) that he adds here every once in a while. I'm pretty sure you wouldn't change his mind, though.
Nice article. Can you give more detail on (1) using Kotlin for DSL's, and (2) how robust is the third-party ecosystem for Kotlin libraries (understanding you can use Java libraries freely)?
Thanks for sharing. My projects use a very similar architecture. It’s nice to see different implementations of clean arch. In particular I like how you represent current view state using a single variable as a sealed class.
The purpose of layers decoupling is the ability to make isolated changes to one layer without affecting others. Swap out the api call for Firebase, new Android versions, instant apps, rewrite GUI etc.. There is no free lunch though. It has a upfront cost.
I spent two weeks with Java and then switched to Kotlin happily. But need to say I dont consider myself a beginner.
This goes from 0 allocation to one per property which is unfortunate. We really need inline delegation. You're also not doing an == check before invalidating which means you needlessly invalidate when the same value is set which is common for view model usage.
Thanks for the input Jake. I went ahead and updated the code to remove the needless updates. Could you expand on the "allocations per property"? I am assuming you mean that this pattern creates an additional object for each property when it is compiled. Would "inline delegation" conceptually remove that extra class and instead inline the setter and getter to the class that the property belongs to? Also, if you don't mind me asking: Are you saying that this syntactic sugar is a bad idea in general, or that a user of it should be aware of the cost?
It's just a wrapper for Retrofit? 🤔
Thank you for the long and helpful response!
nice jobs!
The other comment addresses the allocation. No I'm not saying that this is bad! We just need to be aware of the costs so that as consumers of delegates (and other language features) we can make semi-informed decisions about whether their benefit is worth that cost. Are 3 of these fine? Sure. Are 10? Maybe. 20? Probably not. It's a bit ironic because the more properties you have the more boilerplate you kill but it comes at a heavy cost at that size.
I would want it would inline them into the property's getter and setter, not all the way to the call sites. This would have no downsides as it's what you would otherwise get from Java or writing get/set funs manually.
I will just echo what has been said already lol. I think you can learn Kotlin without learning Java (a big BUT). Unfortunately Kotlin is still taking off, there are few materials to learn it and these tutorials are based on flaws of Java you might find yourself frustrated and eventually learn Java. But if you have a background of strong object oriented programming then you are good. Kotlin is pretty neat if you can read Java tutorial and translate it to Kotlin you will learn a lot. Goodluck DNT GIVE UP ;) 
Manita arriba hermano
&gt; It seems as though you would always want to use inline? Not really. You want to use inline functions * to optimize short lightweight extension/toplevel function (like run, let, ...) * when you need refied generics inside the function * when your last parameter is a lamda/function that should be inlined, too (again, like run, let, ...) Otherwise you should avoid inline, as it * makes interfacing with other code harder (someone inlining your function and might still have inlined your old function after you provided an update) * makes debugging harder (the debugger might not show the state inside the inlined function correctly as it is really in the outer function) * public inline functions can't call private funtions * incompatible with interfaces or overridable functions * can make code slower if inlining larger blocks
Inlining is practically equivalent to copy and pasting the contents of the function to every place it's called. That lets you circumvent some type system niggles (type erasure) because generics never really come into play since you're dealing with concrete types. It's also *marginally* cheaper to "call" an inline function because function calls do have a small overhead. The majority of the time however, the Java JIT should inline functions at runtime where appropriate, and it's often a better judge of when it's appropriate than you. Excessive inlining can blow up the amount of bytecode generated which can hog the instruction cache, potentially making your program slower. As the other comment says, only use inline for keyword-like control flow extensions similar to apply, let, run, etc., and if you need to reifiy (get the concrete type of) a type parameter.
Just from some skimming, looks pretty nice. Some quick feedback, your `Response` class could probably be a `sealed class` and then rather than handling success/error with 2 lambdas, users could handle it in one and do a `when(it) { is Success -&gt; { ... } is Error -&gt; { ... } }`. Feels more Kotlin-y than `Response` having all these nullable fields based on which type it might be.
That sounds like what I said, yes, since you would have to do that when implementing the functionality manually. The same problem exists with `inline` functions which thus require its judicious use. With Kotlin 1.3's `inline class` feature hopefully we can keep it rolling to get something like this for property delegates into 1.4.
Can you explain what you mean by “heavy”? Is the concern primarily the memory cost of the additional stateless objects?
This. Also, higher-order functions (functions which take functions as arguments) tend to benefit the most, especially those which model looping constructs. If you look in the standard library, you’ll see examples of this everywhere such as `Iterator.forEach`.
Great, I'll add some information to the Readme to make people aware that there is a cost to the approach.
Have you had a look at Kinesis Client Library? It’s a OSS library maintained by Amazon that takes a lot of the pain and boilerplate away from managing and leasing different shards and so on, and is generally recommended over the standard client. https://docs.aws.amazon.com/streams/latest/dev/developing-consumers-with-kcl.html
It will still have a few of the original problems: fun shards(streamName: String, kinesis: AmazonKinesis): List&lt;String&gt; { val sequence = buildSequence { var desc = kinesis.describeStream(streamName).streamDescription desc.shards.forEach { yield (it.shardId) } while (desc.hasMoreShards) { desc = kinesis.describeStream(streamName, desc.shards.last().shardId).streamDescription desc.shards.forEach { yield (it.shardId) } } } return sequence.toList() } I wonder how languages such as Erlang and Haskell that don't support mutable variables allow programmers to implement this?
I miss something? tailrec fun shards(streamName: String, kinesis: AmazonKinesis, exclusiveStartShardId: String? = null): List&lt;String&gt; = with(kinesis.describeStream(streamName, exclusiveStartShardId).streamDescription.shards.map { it.shardId }) { when { isEmpty() -&gt; emptyList() else -&gt; this + shards(streamName, kinesis, last()) } }
Might overflow the stack if you have too many items. Do Java or Kotlin do automatic tail rec optimization?
As far as I know Java doesn't but Kotlin has [tailrec](https://kotlinlang.org/docs/reference/functions.html#tail-recursive-functions) modifier. The shards function in given example is not tail recursive though: it has concatenation as last operation. Usually adding an accumulator to the function parameters fixes the problem.
you need to use the `tailrec` keyword (e.g. `tailrec fun shards(...)`) to get tail-recursion. also, this isn't tail-recursive because the list append has to come after computing the recursive result, so the recursive call can't be the last operation. the cleanest way i know to do this is with a helper function and a state argument: fun shards(streamName: String, kinesis: AmazonKinesis, exclusiveStartShardId: String? = null): List&lt;String&gt; { tailrec fun helper(exclusiveStartShardId: String?, listState: List&lt;String&gt; = emptyList()) = with(kinesis.describeStream(streamName, exclusiveStartShardId).streamDescription.shards.map { it.shardId }) { when { isEmpty() -&gt; listState else -&gt; helper(last(), this + listState) } } return helper(exclusiveStartShardId) }
`compileKotlin`, as it says, compiles the Kotlin sourcesets. You should have output in build/kotlin/compileKotlin, but mostly caches and build history. Your compiled files should be present in `build/classes/kotlin` If you're trying to build the binary, you should invoke `gradle build`. Generally, you don't want to invoke `gradle compileKotlin` on it's own.
A stream usually has less than 200 shards, so the stack depth will usually remain below 20 (if we assume each call returns 10 shards). I think in most extreme cases a stream will still have less than 10,000 shards so the call stack for this operation shouldn't ever become an issue.
Strangely enough, I've just been looking into that myself!! Have just updated my unofficial Kotlin Burp API repo with a fix that should work for you: https://github.com/bao7uo/burp-extender-api-kotlin
&gt;Important: this will make the backing field exposed in Java code via get() and set() methods. To disable this, annotate the variable with `@field:JvmSynthetic` - this will apply the synthetic modifier via bytecode, preventing it to be accessible in Java code. What? Why not just make it `private` instead?
I oftentimes find myself wishing for something like lateinit for val instead of var. The fact that such a thing does not exist probably means that there's an obvious good reason why that would be impossible, but I can't see why. I just want to have an immutable value that's not initialized by me. 
Usually these are set from outside the class, so private doesn't work. 
Maybe something about setting the val after declaring?
Yes, I think that might be it.
I want the same thing - lateinit seems equally unsafe for var and val, and I’d personally like the reference immutability.
As EmmanuelMess wrote, this doesn't work because if you declare a val as a class variable, it has to be initialized via the constructor. And this is the point of lateinit - to have variables that are initialized somewhere outside (meaning after) the constructor.
I imagine it's just that `val`s are equivalent to `final` right now but if it were possible for them to be `lateinit`, that relationship wouldn't be so straightforward. They'd have to be indefinitely mutable Java-side so `val` wouldn't guarantee immutability.
[This StackOverflow answer's point 1](https://stackoverflow.com/a/36623703/3124150) explains it.
Hey guys! Take your time for reading how this really useful API works internally for redirecting an email address to the user's profile picture totally written in Kotlin using libraries like: - Ktor - Spek - Retrofit And can be used as an API or as a Java/Kotlin library. 
Why the down votes guys? Are questions bit welcome here? Our have I demonstrated some failure to RTFM?
You probably haven't put your source into the correct folder. Per [the documentation](https://kotlinlang.org/docs/reference/using-gradle.html), the kotlin plugin expects your source to be in src/main/kotlin 
This was a problem at first, then I realised I had to change my sourceSets. Thats fixed now.
One of the things I like that landed is `CName` which is the analog to `JVMName`. So you could add `headers = jni.h` to your `c_interop/jni.def`, then have a top-level function like: ```kotlin @CName("Java_my_pkg_MyClass_doSomething") fun doSomething(jniEnvPtr: CPointer&lt;JNIEnvVar&gt;?, cls: jclass) { println("Yay") } ``` Then in Java: ```java package my.pkg; class MyClass { public static native void doSomething(); } ``` Or use external in Kotlin. And if you have loaded your lib, it will run (or something like that, I didn't test each thing that I typed here). I have successfully used this approach to create Kotlin native functions that are callable from the JVM quite easily (and much more).
A lateinit var is null under the hood to start. Works because it can be reassigned. A lateinit val would always be null
Kotlin has no special support for `ByteBuffer`, so I don't think there is anything more idiomatic than the straightforward translation produced by the Java to Kotlin converter.
The asterisk is required to pass an array to a function that takes a `vararg` parameterer. You can rewrite this code without using an asterisk if you use a different API: thing = mContext.resources.getStringArray(R.array.Things).toList() 
&gt; This course is FREE until Feb 21st, 2018.
I don't know if it's the most ideomatic Kotlin code ever, but how about something like this: data class Tweet(val prefix: String, val id:Long) fun Tweet.toByteBuffer() { val prefix = prefix.toByteArray(StandardCharsets.UTF_8) ByteBuffer.allocate(prefix.size + java.lang.Long.BYTES) .put(prefix) .putLong(id) } val tweet = Tweet("TWEET", 123L) val tweetBuffer = tweet.toByteBuffer() I didn't take a too close look at the semantics, but you get the idea. Having a simple data class enables multiple conversion, for example to ByteBuffer, to byte array, to json or whatever as an extension, so you can data oriented design. Additionally, you have a nice immutable, self describing class....so, any criticism so far?
Lesson 2: Referential Transparency I think they got this quite wrong. It is not about explicit return types. . A function returns the same result in any context.
Boy it would be nice. Actually, what would be nicer is a small stdlib for all sorts of LE/BE byte conversions and buffering (as separate things) that works well cross-platform (can be backed by ByteBuffer in JVM, Uint8Array in JS, just a byte array as a fallback including for native). I suppose we will wait for the community to step up, but it's pretty essential.
It took me an hour and a half of reading and doing tutorials to start feeling comfortable with Kotlin. And more than that, the more I learned about Kotlin, the more excited I got about what it could mean in my day to day. I've been showing samples to some of my co-workers to try and spark a bit of curiosity in them. I probably won't get the OK to ever use Kotlin in production but for all of my prototyping and sand box type work? All Kotlin and it lets me do a hell of a lot more in way less time and with way less code. 
Great video! What's that color scheme?
Check out this guy... https://www.youtube.com/channel/UCmjXvUa36DjqCJ1zktXVbUA There is a lot of good stuff in there but I really like the tutorials before FXGL. I watched the following mine sweeper video several times. https://www.youtube.com/watch?v=JwcyxuKko_M 
I don't understand what, if any, advantage video of an inherently text based medium provides.
Some people find audible content easier to focus on
I’m enjoying the course, but wonder if the target audience exists. If you’re not an experienced functional programmer I suspect it is way over your head, and if you are it doesn’t just explain how to do things in Arrow. That just leaves people like me, using this and lots of other resources to try to make sense of FP and happy to put up with what we can get. 
Please format code by prepending 3 spaces.
It isn't inheriting by instance, you are just supplying some default values for its superclass constructor. https://kotlinlang.org/docs/reference/classes.html#inheritance &gt; If the derived class has a primary constructor, the base class can (and must) be initialized right there, using the parameters of the primary constructor. Hypothetic usage: fun main(args : Array&lt;String&gt;) { open class ColoredPoint( val x: Int, val y: Int, val color: String ) { override fun toString(): String { return "${color}-colored point with coordinates ($x, $y)" } } class RedPoint( x: Int, y: Int ) : ColoredPoint(x, y, "red") class BluePoint( x: Int, y: Int ) : ColoredPoint(x, y, "blue") println(RedPoint(3, 7)) println(BluePoint(5, -4)) }
Those screen state classes should be data classes 
I'm not an expert but I'm sure that this code is against some principle because baz() is functionally aux(5) but defines its own class without adding different functionality. The author of this code should've used some kind of factory pattern for pre-defined values of input. 
[Try](http://arrow-kt.io/docs/datatypes/try/) seems like a better option for error handling. 
I feel like this blog post has a good focus, but misses a lot of points. It starts by saying that we'd "ideally" catch all exceptions. (You should only catch exceptions that you are able to recover from, and the statement that you should catch all shows possible poor error handling practices.) After that, it mixes concepts of optional results, presenting nullable values as an error in processing. Then, the hand-rolled Either type is implemented as having Success/Error, which isn't common Either structure. Either has Left/Right properties for a good reason, you're calling a function that can only return one value or the other. Standard Either types in other languages don't consider either side an "error" by default, but more like normal and abnormal results or a tuple where the elements are mutually exclusive. It's _useful_ for representing error conditions, similar to the node.js continuation passing style convention of passing `err` as the first callback argument-- but like node.js, that's just convention. Either can be used to present Validation, Value where Validation isn't necessarily an Exception or Error. Either is also helpful to expose info about why your right side would otherwise be a null (example: `Either[String, Int]` in place of `Int?`). Lastly, in many implementations of Either, Either is a Right-based monad (in Scala, this wasn't true until 2.12). It's this way to support the Right-means-success concept presented in this blog post. But I don't think it's intention is to force Left to be considered an Error.
&gt; It starts by saying that we'd "ideally" catch all exceptions. (You should only catch exceptions that you are able to recover from, and the statement that you should catch all shows possible poor error handling practices.) I'll add that bit there. I do mention this in the coming paragraphs as a solution: ("Another solution to this problem is to avoid try/catch entirely for exceptions that the application can recover from. If the exception is fatal, the application should rightfully crash."). &gt; Then, the hand-rolled Either type is implemented as having Success/Error, which isn't common Either structure. Agreed. I do mention about this in the blog post: "This Either type can either have a value Left (Error/Failure) or a value Right (Success)". The `Either&lt;Error, Success&gt;` here can be represented as `Try` in [Arrow](http://arrow-kt.io/docs/datatypes/try/) but Try is more than that. This is more close to `Either&lt;Throwable, Success&gt;`.
I guess I should clarify that by "misses a lot of points", I meant that there was opportunity for clarification and not that it's missed the mentioning of these things. I apologise that it reads as the latter. The mention in the post that you've called out above regarding errors doesn't seem to authoritatively say _how_ to do error handling. It reads as "drop all exceptions, even if the application can handle them", and I think it may be a typo ("can" should be "can't"). This, coupled with the comment that we should catch all exceptions, is the reason for my aside about error handling practices. Your quote of the post's Left/Right mention, again, equates Left to an Error which isn't really the intention of an Either type. I felt like you were aiming for Left as an alternative result rather than Error after the mention about optionals (nullable types), but it seemed to me throughout the entire post that you've only considered it to be an error. Conceptually, there's nothing won't with that. My point was more about matching consumer expectations about what Either usually contains, and matching the common API. A different was of putting this would be that a custom List implementation would be expected to have methods like add, remove, head, etc-- queue and dequeue could be reasoned about but may not be intuitive. `Try` really would be the ideal type to represent that something has potentially failed without throwing. I haven't looked at arrow other than a cursory glance of their intro blog. If they have a Future type, that would also be ideal to mention for asynchronous operations and exception handling. If they don't have a Future type, it would be interesting to evaluate the use of Java Futures and/or error handling in Kotlin coroutines.
The code pieces are huge on mobile, you might want to adjust that.
Sorry, you can't claim that your approach is better with this kind of code: ``` fun &lt;T&gt; attempt(vararg args: Either&lt;Any&gt; ``` Where the `Any` leads to loss of typing: ``` val helloCombined = attempt(helloAshish, randomInt) { echo((it[0] as String) + (it[1] as Int).toString()) ``` You can solve this solution with exception or functional returns without any loss of typing. 
The loss of typing is only because `attempt` handles both String and Int value types. You can put restrictions on it to handle only a single type and this problem won't arise. Or you could use a sealed class for multiple possible values. It is not possible to do the same thing in Kotlin with classes that are marked final (String/Int/Long) currently because there are no union types. Why this approach doesn't feel problematic to me is that because the type of both the success values are very well known to us.
I really hate having to sign up to these things just to keep viewing. What ever happened to just creating a youtube playlist... 
Can you please explain why the OP's' method is an "abuse" of get/set and why the new method is less "abusive". Below you still recommend not to use this method. Yet it leads, in my opinion, to a more terse syntax. Just compare these two lines. print(list[2..4]) print(list.slice(2 until 5).joinToString()) 
Agreed. I'm not a fan of Python as a language - I'm kind of surprised that it's so widely used in data science, given that it's undeniably slow, tricky to parallelize, and not the easiest language to learn by far. However, as much as I don't like it, its ecosystem is much greater when it comes to scientific computing. Some algorithms are simply implemented only in R/Python. That said, I tried using CoreNLP + DL4J + Kotlin to solve a text classification problem in a commercial project. It wasn't that bad, but I honestly would have done it faster with Spacy + Keras + Python. Not because of the language features or IDE support, but because of the frameworks. (I do miss good Kotlin support in Jupyter, though.) As a language, Kotlin could probably replace Python - especially Kotlin/Native, with its seamless native libraries interop. However, unless some major companies invest _a lot_ in it, we're unlikely to see that happen.
&gt; I do miss good Kotlin support in Jupyter, though. It's working pretty well with [beakerx](https://github.com/twosigma/beakerx). No autocompletion though last time I checked.
Is this what you're after? https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/slice.html (note: I'm not a Kotlin developer, so I actually have no idea) 
Does it copy?
I should have said "full Jupyter support". Jupyter without auto-completion feels like a huge step backwards.
https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/sub-list.html
You can use the List.subList function, which does not copy: https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/sub-list.html
I want to see an article that shows how to create an angular 5 project in kotlin. After that i woul be all in with kotlin. 
Be the change you wish to see in the world! 😅
Just published this library after using it for a while in a private project. Would love feedback if anyone tries it at some point!
I FAILED TO DO IT 😀
Are you using the DAO or the SQL API directly?
Try to using DAO, which i thought is simpler to use I get Something Like an Iterator Object back
Are you using Eclipse or Intellij? If the issue occurs in the constructor call, maybe you need to increase the memory to the JVM? This is purely a guess but the constructor is where new memory is allocated so maybe? My only other advice might be to call the kotlin interpretor from the command line and see if it gets past the constructor, then it might just be a config issue. 
Learn java first. Your success in Kotlin is going to depend on leveraging java libraries so learning the program structure of java applications, how to manage dependencies, run java from the command line, etc. Then start learning Kotlin and not only will it enable you to get up and running with Kotlin quickly, you'll come to appreciate it so much more for what it can do that strict Java cannot. 
I’ve been using the DAO as well. The way I handle this is with a `toMap` method on the DAO. Which I then pass to a JSON writer. That makes it easy to restrict or alter the properties that are being serialized. 
Stackoverflow.com might be a better place for such questions
I'd like to see a comparison between kotlinx.html and this library.
I'll try to create a wiki page with some examples in both libraries 👍
You could use a factory method: ``` class ImageFileNameBuilder(val sessionUid: String, val taskUId: String, val position: Int) { companion object { fun fromFileName(fileName: String) = fileName.split('_').let { ImageFileNameBuilder(it[0], it[1], it[2].toInt()) } } } ```
No, this is not possible; this is a JVM restriction. A call to a super constructor or another constructor of the same class is required to be the first operation performed by a constructor.
I'm using intellij, and memory should NOT be a problem. The heap is allowed to use up to 2gb, but the project so far has never used over 1gb.
AFAIK you cannot do that, but I'm not 100% sure.
Understood, thanks for your input! at least I know that door is shut and that I'm not missing something in the syntax.
Hi Reddit! I converted the best Kotlin snippets on Stack Overflow Documentation to create this free Kotlin PDF book, any suggestions for improvements are appreciated as it will help me improve the PDF book; which will then benefit everyone 😊
Nice work!
Very similar to this example https://spring.io/blog/2016/03/20/a-geospatial-messenger-with-kotlin-spring-boot-and-postgresql
https://github.com/JetBrains/kotlinconf-app is another good example
Free? Thank you so much!
Thanks but Download link doesnt seem to work on reddit mobile?
If you need to use your Kotlin class from Java it can still be useful because Java cannot make use of the default and named arguments. Otherwise, I think named/default args cover the main use case.
 There is a 'sneaky' way to simulate it using a `companion object` + `operator fun invoke`: ```class ImageFileNameBuilder(val sessionUid: String, val taskUId: String, val position: Int) { companion object { operator fun invoke(fileName: String): ImageFileNameBuilder { val (sessionUid, taskUid, position) = fileName.split('_') return ImageFileNameBuilder(sessionUid, taskUid, position.toInt()) } } } fun main(args: Array&lt;String&gt;) { val builder = ImageFileNameBuilder("sessionUid_taskId_1") } ``` But IMHO the explicit factory method is cleaner
Makes sense. Thanks
&gt; you can't chain calls to copy(), for example I haven't tested it, but I'm fairly sure that you can: person = person.copy(first = "Jane").copy(last = "Smith") Not very efficient though as it's creating an intermediate object that's discarded immediately.
Yeah, you're right. Brain shorted out for a second.
Same as in Java, add an ActionListener on it.
First, please don't post code in reddit. The lack of syntax highlighting makes it difficult to understand and discourages people from understanding your issue. For convenience here's a gist of your code https://gist.github.com/wightwulf1944/33c97f91b0cd5bc06b67705832f5e200 Second, always separate business logic from view/presentation. What this means is you need to build a "model" of the game using plain java/kotlin code. The model of the game represents the state of the game such as what items are on the board, where each `X` or `O` is on the board, who's the active player, and checking if the game has been won or is a draw. The game's model may also have additional function such as a `forfeit()` function to end the game early. In your code above you've mixed Android/View/Presentation code with business logic. The model should be built in a way that the **presentation layer** can be changed and the game should still behave exactly the same. So how would I build a model of the game? This is where programming becomes more art than science. --- Let's list down the elements of the game. * Board - has cells, holds the pieces * Piece - has two types `X` and `O` * Player - can have 1 of 4 states `win` `lose` `draw` `playing`, may have a name, has two types `X` and `O`, and generates pieces of the same type. * Rules - the only thing that can change the state of any of the three objects above. Maintains a list of players, who the active player is, checks if someone has won after a turn by inspecting the board, has a function to reset the game. Many game developers hold an opinion whether a Rules/Arbiter object is really needed. But for simplicity let's just say we need it. The **Board** can be represented by a 2-dimensional array. This can be wrapped in a class and that class can have 3 methods `checkIfEmpty(int x, int y)`, `placePiece(Piece piece, int x, int y)`, and `Piece checkPieceAt(int x, int y) The **Piece** can be represented by a char constant. For readability this should be wrapped in a `Piece` class. It doesn't really do anything for now. The **Player** can be represented by integer definitions for it's win state, the name can be a String, the types can be a char constant. It has functions `Piece getPiece()`, and `int getState()` The **Rules** will then have a reference to all the objects above and coordinate between them. It will find the active player, take a piece, check the cell on the board, and place the piece there, then checks if the player has won. If not, then move onto the next player. The android UI events should only communicate with the Rules. And any changes on the elements above will then change the views. For example when a cell is clicked on the screen then a rule function should be called which would move things around, and then the views should be updated based on the new state of the game. This is called model driven design and is the basis for game development
Awesome! I'll be giving this a read. However, the first page I opened (the beginning of chapter 3) has a type. In Kotlin strings are compared with == operator which chect for their structural equality
You can always construct object via apply(). Like Person(). apply { name = 'John' age = 40 } and it will return you person with those parameters. Pseudo builder
There are some cases where builders are more complex than just setting fields. But yes, "normal" builders are unnecessary in kotlin.
Type signature of your lambda should be MouseAction -&gt; Unit, not () -&gt; Unit.
Did you try (Consumer&lt;MouseAction&gt;) -&gt; Unit ?
Username checks out
Until someone comes up with Kotlinscript...
I'm still baffled by the decision to have the transaction manager as a thread local. Sure it allows you to have the nice clean syntax without passing your db object everywhere, but I can see it causing problems down the line. Especially strange considering the great coroutine support which as well. I had a look into using Squash as well. I think I prefer the syntax a bit but the complete lack of documentation means I couldn't really get far. Seems like a bit of a trend for the Jetbrains libs (ktor anyone?)
I don't find performance overhead for Java 8 Streams significant. Sure, lambda functions are objects under the hood but the JVM is optimized to handle such short-living objects quite well. However in Kotlin things are a bit different. Most collection-transforming functions in Kotlin are inlined by the compiler. So in Kotlin there's no runtime overhead e.g. by writing `list.forEach { println(it) }` instead of using an ordinary for-each loop. See: https://kotlinlang.org/docs/reference/inline-functions.html BTW: In Kotlin there's no need for using Java 8 Streams API, instead you would use Sequences. Sequences are lazy just like Java 8 Streams but more powerful and simpler to use (e.g. no .collect(...) boilerplate). See: https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/index.html
Strange, shouldnt kotlin convert the sam interface to a lambda?
Agree... that was a big eyebrow raiser. It seems like a huge mistake. Also agree that JetBrains library docs seem to be... severely lacking. I tried using Ktor and gave up and switched to Javalin.io
To expand on this a bit: Kotlin will implicitly convert (wrap) its functional types like `() -&gt; Unit` and `MouseAction -&gt; Unit` to an instance of a Java SAM interface (like `Consumer&lt;MouseAction&gt;`) when you pass a Kotlin function to Java code. This only works when crossing the Kotlin -&gt; Java bridge, it will not do that under other circumstances. The function arguments still have to match though.
Their documentation is pretty much the sample projects, which admittedly can get the job done. Still not ideal when you're trying to gain traction for the language, but I guess the libs haven't reached v1.0 yet. 
From a performance perspective, they've been found to 1) not be as optimized by the JVM as traditional loops, and 2) multiple functions chained together (ie, filter(), flatMap(), etc) result in multiple iterations. So when I'm referring to performance optimizations, that is what I mean.
It does, just double-checked. I was responding to the question which suggested that it didn't. Edit: And it does not in this case, as the library is written in Kotlin
Same. The DSL seems real nice to work with. But then I realized there is an implicit static connection and immediately starting looking for alternatives. It seems like they are now aware that it is a big problem, but are hesitant to change the API that only works in the simple case.
So the biggest reason that Java 8 lambdas are going to suffer over a loop is that you have to do a dynamic dispatch (they use invokedynamic under the covers) for each lambda operation which the JIT can't optimize away. Also since the looping that occurs during the Stream's terminal operations is going to be non deterministic there is little to no optimization that can be provided by either javac or the JIT. As @winterbe was saying kotlinc helps in that it inlines the lambda so the dynamic dispatch penalty is negated as much as possible, and using a Sequence for handling collections makes it lazy so it will be faster than Java 8 streams, but still not as fast as a loop. So it depends on what type of system you are building. If it is some sort of high frequency trading then having the mechanical sympathy of a language level construct of a loop is what you want. If you are writing a more traditional CRUD app then I'd say go with the more readable lambda or kotlin collections library methods. Because in that case developer time is much more expensive than CPU time.
Do you think it is a good enough reason to fork?
You can [do that in Java](http://www.codejava.net/java-core/the-java-language/java-8-lambda-listener-example) too!
I think the multidb change will not totally replace thread local if I am not mistaken.
Whether to convert to a Sequence or just call map, filter etc on an Iterable and suffer the creation of intermediate Lists will depend on the details of your algorithm and the size of your data. In my testing I found both generally faster than using Streams, unless you are using primitives, where Kotlin can suffer boxing overhead. You could check out my talk at KotlinConf https://www.youtube.com/watch?v=ExkNNsDn6Vg for some results and how to measure for yourself. 
I don't think this is a Kotlin specific problem. ~~Try r/androiddev~~. INB4: "Because Samsung!"
Do you use Glide/Picasso?
4k is basically only used for 4k videos
No.
But at least those things are related, unlike Java and Javascript.
People said the same about Objective-C and look what Swift did to it...
Ah, I didn't know that, i thought it was written in Java. Thanks for clarification.
I did not think that was possible - nice solution (agree its cleaner to be explicit though).
In which we repeat the mistakes of scala.
DSLs add further to the confusion that is reading scala code.
Yourclass::class.java?
We have a production server written in KTOR. The documentation is lacking but it's not a 1.0 release yet. So far I've been very pleased with it.
I don't think that case qualifies as "control flow" as much to be frowned upon. It's a simple error recovery - if you can't parse an int, result is null. What other possibilities would you have available, in this case? *Throwing Exceptions* as a sort of response mode is the thing that "exceptions as control flow" is about (and in general leads to surprising code - specially in languages w/o checked exceptions, which is the case for Kotlin): http://wiki.c2.com/?DontUseExceptionsForFlowControl 
But what is your take on it. Is this a proper way to write code in Kotlin. If you look at my other answer with the example: val result:Customer? = try { CustomerService.getCustomer("xyz") } catch { CustomerService.createNewCustomer() } Doesn't that seem wrong ? Wouldn't you want to write the code in a more secure manner ? I'm still trying to understand why it's okay to use try-catch as a control-structure, when everything I have learned says that you shouldn't do that. And I see it as a very clear anti-pattern, where developers will misunderstand what is going on -- and this is going against the whole idea of Kotlin being more simple. 
I'd rather not use an exception on that case of yours, as there can be multiple failure modes (a "catch all" isn't a good fit - eg a connection failure, a network failure, etc). If you're really bothered by the catch case on parsing a number, you can do catch(e: NumberFormatException) only. Keep in mind that's a Java API, not a Kotlin one - throwing an exception is a Java idiom, the same way returning an err is a Golang idiom. Kotlin has its own APIs for parsing numbers that'll return null. TLDR: this is not a big deal at all IMO, nor it is a Kotlin language pattern, nor it is using exceptions as flow control...
The documentation says "try is an expression". And so my example is perfectly valid. And that's why I am trying to understand what is a general pattern here. If you look at the "customer" example, how would you approach it in Kotlin ?
The Kotlin way is simply returning null. I'm not sure where you get the idea that we should use try catch for every control flow out there in Kotlin. The one in the example is simply due to the fact that `Integer.parseInt` is implemented in Java and actually throws exception. *Just because you can do it, doesn't mean that you should.* Also, when dealing with mixed Kotlin and Java interop, try catch is far more common since Java loves to throw exceptions for everything. Kotlin-wise its just a nullable value. Or the idiomatic sealed Result class. Plus, there are so many ways to handle it in Kotlin and they are always far more preferable than try catch. Your example can even be written into: `val customer: Customer = Service.getCustomer() ?: Service.createNewCustomer()` No need to use a nullable `Customer` and try-catch, as it won't ever be null after that. 
probably return null? That's one of the idioms (and works for suspend functions as well). You might still want to have exceptions for _exceptional_ cases, though. What would you return if the network failed, for instance?
&gt;probably return null? That's my general question. I have the understanding that try-catch and exceptions should not be used as a control-structure. If we take my above example and rewrite it to C#, it would be something like: try { var customer = CustomerService.getCustomer("xyz"); if (customer == null) customer = CustomerService.createNewCustomer(); } catch { //some exception occured } An here it is very apparent that some exception has occured. And this is where I am not understanding the Kotlin way of expressing it.
&gt;I'm not sure where you get the idea that we should use try catch for every control flow out there in Kotlin I'm arguing for the exact opposite infact :) I'm trying to understand how to properly use try-catch in Kotlin, as opposed to how it is used in Java and C#. The example I used is exactly to show that a developer doesn't know what is thrown from the service as an exception, and that is why try-catch in that example is not a safe structure to use, and why it shouldn't be used as a control-structure. I still don't understand try-catch as an expression in Kotlin. IMHO try-catch should never be used as a control structure.. but apparently no-one can explain why it's acceptable in Kotlin.
Personally, if there's reason to recover this simply, there's a good chance there's a missing abstraction. `toIntOrNull` will do the heavy parsing only once (as opposed to `if (canParse(input)) parse(input)`, which does it twice) and still support getting rid of what feel like improper try-catches. You generally have three options. I'll use your customer example for reference. **Check-Do** - `if (customerExists("xyz")) getCustomer("xyz")` - **Allows a caller to check without doing the work.** - Runs into the classic TOCTOU race: `if (exists(file)) /* file gets deleted */ readFile()` - It can still be worth checking. For example, indicating that the user can currently send an email without actually trying to send it is useful, even if it's not perfect. - Provides a straightforward API for indicating whether something is accessible. Can be useful for UI buttons and such. - No real way to ensure the caller checks first. **Try-Throw** - `getCustomer("xyz") // If you didn't get it, something's up` - **Handles cases where there's a clear unexpected outcome** (e.g., the customer *should* exist and didn't, the database is corrupt, etc.). - Avoids TOCTOU because either it succeeded or there's an exception. - Gets rid of boilerplate checks for outcomes that either can't be recovered from or are handled farther up. - Adds boilerplate for outcomes that are expected (e.g., the customer not existing is reasonable in this context). **Try-Return** - `getCustomer("xyz") ?: createNewCustomer()` - **Provides easy handling of common outcomes.** - Also avoids TOCTOU for the same reason. - Reduces boilerplate for common outcomes, but adds more for propagating uncommon outcomes to where they'll be handled. This is often reduced with language magic like `try`, `?`, and `do` notation. - Return type is often a monad. - Makes all failure cases explicit in languages without checked exceptions. --- While options 2 vs. 3 have lots of debate, given that this is Kotlin, any of these three options could be suitable for your scenario, but based on the recovery, 2 doesn't seem very appropriate for the outcome of the customer not existing.
Kotlin has to interact with Java code, Java code tends to heavily use exceptions - the existence of the try/catch expression is there to provide an idiomatic solution to deal with them similar to a when statement when it makes sense (return a cached value when you fail to update a list or something from the internet using a Java library that throws an exception on network failure). The other reason is simply so you can use type inference and val with return values from methods that may throw, working around scope issue. &gt; val customer = try { &gt; getCustomer(customerId) &gt; } catch (e: NoResultException) { &gt; throw CustomerNotFoundException(e) &gt; } Without try-catch as an expression you’d have to do this like in Java, declare the variable and then assign it - you can’t do this with val’s in particular since they must be assigned when declared. Personally I’d clean this up some by doing something similar to how people wrap Error types in Rust, but there are benefits to exceptions that you simply cannot get with types like Result (stack traces, in particular) so it would be situational.
&gt; Without try-catch as an expression you’d have to do this like in Java, declare the variable and then assign it - you can’t do this with val’s in particular since they must be assigned when declared. There's another solution getting more popular in C++ nowadays: IIFEs. I'll use the anonymous function notation for the sole purpose of mirroring the `return` behaviour. val customer = fun(): Customer { try { return getCustomer(customerId) } catch (e: NoResultException) { throw CustomerNotFoundException(e) } }() In C++, this lets you use `const` while working around the lack of `if` etc. not being an expression. Of course in Kotlin, this would rarely be useful.
Still lose the type inference, can see it being useful in C++ though.
Sorry, forgot to mention it's also mainly used with `auto`. For example, `const auto value = [] {if (condition) {...; return 2; } else { return 3; } }();` The only reason the type inference is lost in my Kotlin example is because of the anonymous function. You could still do this in Kotlin with a lambda while using actual `return`s instead of relying on things being expressions: val customer = { foo@ try { return@foo getCustomer(customerId) } catch (e: NoResultException) { throw CustomerNotFoundException(e) } }()
Even if your opinion is that try should not be used for flow control, there is no good alternative for the parseInt use case.
&gt; IMHO try-catch should never be used as a control structure.. but apparently no-one can explain why it's acceptable in Kotlin Because it’s pragmatic, allows easy interop with Java, and, unaccountably, the language designers either didn’t know your opinion, didn’t agree with it, or both. 
That is the “Kotlin way” of expressing it if you write it in Kotlin that way.
&gt; I'm of the general persuation that try-catch is not intended to be used as flow control, and certainly not when other possibilities are available. The other possibilities in this case seem worse, except for `toIntOrNull()`. Look at its implementation: public fun String.toIntOrNull(radix: Int): Int? { checkRadix(radix) val length = this.length if (length == 0) return null val start: Int val isNegative: Boolean val limit: Int val firstChar = this[0] if (firstChar &lt; '0') { // Possible leading sign if (length == 1) return null // non-digit (possible sign) only, no digits after start = 1 if (firstChar == '-') { isNegative = true limit = Int.MIN_VALUE } else if (firstChar == '+') { isNegative = false limit = -Int.MAX_VALUE } else return null } else { start = 0 isNegative = false limit = -Int.MAX_VALUE } val limitBeforeMul = limit / radix var result = 0 for (i in start..(length - 1)) { val digit = digitOf(this[i], radix) if (digit &lt; 0) return null if (result &lt; limitBeforeMul) return null result *= radix if (result &lt; limit + digit) return null result -= digit } return if (isNegative) result else -result } There is nothing wrong with using a try in cases like this, you get very readable code and you don't have to think about the implementation of whatever you calling. If it works you get your int, if it doesn't you get null.
Actually, it is not implemented with exceptions. [Here's](https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/text/StringNumberConversions.kt#L215) the source.
It's interesting that JetBrains should reimplement it. I guess that they can reuse that code in Javascript and native, but at the same time it means that the behaviours of `Integer.parseInt` and `Integer.toIntOrNull`may differ. Ah the trade-offs in engineering.
I'm interested to see part 2 of this. Part 1 focuses solely on DI, while the title makes it sound like the goal is IoC. An important part of IoC is inverting control of the dependencies to some external entity, which is something I don't readily see possible with this Typeclass DI approach. For example, if I've released an artifact that creates and injects a default metrics or tracing service, how would my consumer override this with hard coded typeclasses?
&gt;if I've released an artifact that creates and injects a default metrics or tracing service, how would my consumer override this with their own code that replaces the hard coded typeclasses? Oh, you're in for a treat. The idea of typeclasses is that when writing a library, you don't provide the concretion by default. You always code to the abstraction API. You give the API (the typeclass interface) and the tests that it has to pass (the laws), and you let the user define the concretions in their client code. Then, with this style, the user provides the concretions. You *may* provide some concretions, but they're never wired. In our case for example we ship 3 different "concurrency" implementations: IO, Rx, and kotlinx.coroutines. Soon we'll add a 4th in Reactor. All of them behave exactly the same for the typeclass abstractions, but each still retains their singularities to be used in client code.
We're using kotlin at Investopedia. We've have some public repos soon. Sorry no pre-sauce links at this time. 
&gt; The online tutorials always seem to be using some third party crap like Javlin. is it necessary? Sort of. Javalin uses Jetty underneath (almost all JVM web-frameworks use Jetty, Netty or Undertow). Dealing with connections is complicated, you don't really want to do it yourself. What is the reason you don't want to use third-party libraries?
I would be interested in how and what kotlin could make simpler in your scenario. Examples would be nice :)
I'm not sure what exactly you mean, but this is definitely not a Kotlin-related question.
How Can I Implement Real-Time Location Tracking in Kotlin, is That A nice / Clear Question?!
Find a Java library that accomplishes what you need and use that.
&gt; I don't fully understand what i was learning because they don't explain it. It was a guide on javalin website so i assume they were probably teaching me to use their framework without me knowing. 2 months later when i understand, i would have been like why the fk i was learning this. But that's the point of abstractions, to hide this complexity that you don't really need to know. If your goal is to learn how to do network programming in Kotlin, your approach makes sense, but your posts states *What will i need to build an online web chat.*. I made Javalin so you wouldn't have to do your own network programming, and Javalin uses Jetty, because I don't really want to do network programming either. 
Now some people will confuse Kotlin with Kotlin.
Looks good so far! I'd recommend checking out the Fuel HTTP library for future work on this as well as changing your async code from using CompletableFuture to using Kotlin Coroutines since they write so similarly to blocking code. Here are links to resources for these libraries: * Fuel: https://github.com/kittinunf/Fuel * Kotlin Coroutines library on GitHub: https://github.com/Kotlin/kotlinx.coroutines * Coroutines walkthrough from that GitHub: https://github.com/Kotlin/kotlin-coroutines/blob/master/kotlin-coroutines-informal.md * Coroutines talk from KotlinConf 2017 (this one just talks about how Coroutines compare to other async libraries): https://youtu.be/_hfBv0a09Jc
I think the point people are trying to make is that there likely isn't a Kotlin specific library to work with Google's GPS tracking. However, there likely is a Java library that works with the API Google's exposes. But there is nothing special about Kotlin that would make interacting the that library any different that working with a different Java library.
The latest release of the standalone kotlin compiler also provides support for .kts which is kotlin script. 
Yep that's what i want. Once i can do that they i can use framework for parge scale programming
Does that even work? "latitue" to "30.307182",
Thanks, its a readme file typo. The call to yelp.search( ... ) takes a map and encodes the items a query param arguments. Its up to you to not send the wrong arguments, as the api supports many of them. This lib does not care how you name the query params. However, yelp will care and send back a json msg with corresponding error. In short, its just a typo in the readme file. :) 
I read these when I was deciding between implementing my own WebSocket handler or using Jetty: * https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers * https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_a_WebSocket_server_in_Java
That seems incredibly unlikely in the forseeable future. Java has been adding features, but not at an especially rapid rate. Kotlin has the advantage that a significant amount of their code is written in Kotlin, so they can iterate faster. Additionally, Kotlin is not locked into legacy decisions anywhere the extent that Java is.
Could just use a Calendar object similar to how you would in Java.
Great. Only works once though. Can't seem to open it after signing in and closing it. 
Same as in Java. Maybe get a YearMonth for the month after your target, then a LocalDate for the first day of that month and subtract one day. Or maybe there is a simpler way already in the API.. 
What the fuck that's a thing? Why am I still using Java?
I have got it, I used var monthlength :Int = Calendar.getInstance().getActualMaximun(Calendar.DAY_OF_MONTH) 
This is one of the smallest embedded webservers I have found that also supports websockets: https://github.com/NanoHttpd/nanohttpd Works fine with Kotlin, here is an example project that actually uses it: https://github.com/rnentjes/simple-password-manager 
Oh I might have been confusing. YearMonth is part of the java.time package that came in 1.8 so you can use that in plain old Java.
If I got you right, you're talking about platform types (since for Kotlin, you cannot override a nullable type with a non-nullable type). Those are types coming from Java, not from Kotlin, for which no information about nullability is given. You can decide on your own, if you want to treat those values as non-nullable, even though you can't nesure this, since Java can do things the Kotlin compiler wouldn't allow.
Thanks for the reply, see my reply to /u/spamthemoez as they replied first I think.
I'm not sure if you overlooked it or if you don't distinguish for simplicity, but there's a difference between catching everything from getCustomer and CustomerService.createNewCustomer, or everything from getCustomer solely. In your example, it would be better to use two try-catches....one around every call to CustomerService. Furthermore, I don't think we're talking about control flow at all here. We're talking about an exception that we are forced to handle. In the very first example, the answer is simple: It seems that we want to show the user of our method, that we can either handle the input or not... if not, we don't give any reason WHY, because we catch all exceptions. This is done because we don't want the user of our method to think about possible exception types. So having this said, it's all about how we write what we wantfor ourselves only. The parsing exception isn't under our control, so we have to catch it somehow. Semantically, it makes no difference if we use try-catch as expression or not: The semantics are: if exception give null, else give parsedResult. The only thing that differs is the elegance of the code to express this semantic: The expression based approach doesn't need local mutable variables, so I think it's clear that it's better from a code perspective. It's also more concise and takes fewer lines of code. This is comparable to a function declaration that solves this purpose like public &lt;T&gt; calculateOrNull(Callable&lt;T&gt; callable) { T result; try { result = callable.call() } catch(Exception e) {} return result; } But if we extract such an abstraction, we have to carefully design what this function does at all...for example maybe you want to log the exception...or return the exception optionally or something. Makes things more complex and probably not suitable anymore for the given problem, if the abstraction is to opinionated or strict. If we want to really change the control flow, we coooooouuuld take a look at functional programming, that works with Try data types. But I wouldn't want to give this advise in general, because I know not everyone likes functional programming and does want to open pandora's box. But to be honest, those constructs are the kind-of-ultimate abstraction over ways to handle exceptional behaviour.
 fun main(args: Array&lt;String&gt;) { val array = intArrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) println(array.contentToString()) // Prints: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] array.shift(5, 3) println(array.contentToString()) // Prints: [1, 2, 3, 6, 4, 5, 7, 8, 9, 10] array.shift(2, 8) println(array.contentToString()) // Prints: [1, 2, 6, 4, 5, 7, 8, 9, 3, 10] } fun IntArray.shift(oldPos: Int, newPos: Int) { val tmp = this[oldPos] if (oldPos &lt; newPos) for (i in oldPos until newPos) this[i] = this[i + 1] else for (i in oldPos - 1 downTo newPos) this[i + 1] = this[i] this[newPos] = tmp }
Thank you this is what I was expecting.
Thank you.
I would not modify the array, but create a new result array: fun main(args: Array&lt;String&gt;) { val squares: Array&lt;Int&gt; = Array(10) { i -&gt; i * i } println(squares.shift(3, 5).contentToString()) println(squares.shift(2, 8).contentToString()) } inline fun &lt;reified T&gt; Array&lt;T&gt;.shift(srcIndex: Int, dstIndex: Int) = if (srcIndex &lt; dstIndex) shiftUp(srcIndex, dstIndex) else shiftDown(srcIndex, dstIndex) inline fun &lt;reified T&gt; Array&lt;T&gt;.shiftUp(srcIndex: Int, dstIndex: Int) = Array(size) { i -&gt; when { i &lt; srcIndex -&gt; this[i] i &lt; dstIndex -&gt; this[i + 1] i == dstIndex -&gt; this[srcIndex] else -&gt; this[i] } } inline fun &lt;reified T&gt; Array&lt;T&gt;.shiftDown(srcIndex: Int, dstIndex: Int) = Array(size) { i -&gt; when { i &lt; dstIndex -&gt; this[i] i == dstIndex -&gt; this[srcIndex] i &lt;= srcIndex -&gt; this[i - 1] else -&gt; this[i] } }
For lists of **Int**, use: listOf(1, 2, 3).sum() If you have a lust of **supertypes of Int** (e.g. List&lt;Any&gt;), and want to get the sum of all Ints present on this list: listOf("a", 1, "b", 2) .filterIsInstance&lt;Int&gt;() .sum()
What does this more than start.spring.io?
You can just call the flatten() function on a list if all the sublists also contain the same type. If its a mix of different types eg. List and Int then you will need to either use flatMap {} on the list or filter the lists and ints and sum them accordingly. Prefer not to use the flatMap {} as it creates lots of short lived Lists when it finds an Int. val list = listOf(listOf(1,2,3), listOf(4,5,6), listOf(7,8,9)) val sum1 = list.flatten().sum() val list2 = listOf(listOf(1,2,3), listOf(4,5,6), listOf(7,8,9), 10, 11) val sum2 = (list2.filterIsInstance&lt;Int&gt;() + list2.filterIsInstance&lt;List&lt;*&gt;&gt;().flatten()).sumBy { it as? Int ?:0 } println(sum1) println(sum2)
I'd not call the method `shift` though as this usually refers to prepending. Maybe `reinsert` or `move`.
This will be much slower than the other posted solution.
They probably want you to use reduce or whatever it's called in the Kotlin stdlib.
You should just always use `kapt`. `kapt` is the Kotlin annotation processing tool. If you make something `annotationProcessor`, that will not run on `.kt` files. It doesn't understand how to. So if you make a Dagger module in Kotlin, for example, it won't be processed. That's where `kapt` comes in. Make your dependency `kapt`, and `kapt` will run the Dagger compiler on any `.kt` file it sees, and it will basically pass-through to the `annotationProcessor` behavior for any `.java` file. tl;dr: When using Kotlin, just `s/annotationProcessor/kapt/g`.
`inputList.fold(0, { sum, val -&gt; sum+val })` 
Nice post. My company is considering it in the near future. Could you tell me what you compile times are like and what your compiled js file size is?
&gt; The report of ~~my~~ Kotlin's death was an exaggeration No, I don't think Kotlin on Android is going anywhere. It took many years for Google to add first class support for *any* language and even then a lot of people were surprised, because any officially supported languages require long-term support. &gt; If flutter becomes the new standard for writing android apps Just because they released a beta version of Flutter doesn't mean it's even close to becoming officially supported - let alone "the standard". I think you may be confusing "made by Google" (the not TM version) with "officially supported".
Yeah it isn't actually that hard setting up a Kotlin (JavaScript) project. Just create a project with Kotlin/JS, create a class with `main` (like how you would do in Kotlin/JVM), create a html file referencing the Kotlin runtime/your project JS files, call it from your page and that's it!
You could try [libGDX](https://libgdx.badlogicgames.com/) with Kotlin extensions library [KTX](https://github.com/libktx/ktx).
Did you look at TypeScript? Any reason to use Kotlin JS over TypeScript?
I rewrote one of our Kotlin/AndroidArchitecureComponents apps with flutter in like 3 days. I way prefer kotlin to dart but despite this flutter makes things way easier. Plus I get iOS support also. Considering abandoning Kotlin when it comes to Android development company wide. Depends on how my other developers feel. So not feeling that things are looking good for Kotlin. We only use Kotlin for Android development.
Don't get me wrong, I'm not saying Flutter isn't good or that *nobody* is going to move from Java/Kotlin to Flutter. Just that it's insane to suggest that the Java/Kotlin Android SDKs are going to be deprecated within any meaningful timeframe. You will need to rewrite your app six times for other reasons before deprecating the Java/Kotlin SDKs even becomes a remote possibility.
That's so handy
Thank you!
Ok, thanks dude! (Or.. dudette, I don't judge)
My little brain still doesn't really understand how this all works, but then, I've never tried to write an application in JavaScript, only the basic jQuery and validation stuff. Does anyone have a github link of a working Kotlin JS app?
I have done some stuff with kotlin and libGDX. I have been busy lately, but going to get back into it soon. https://youtu.be/8S-fLv5gtsE
Video linked by /u/BinaryMonkL: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [demo play](https://youtu.be/8S-fLv5gtsE)|BinaryMonks|2017-10-21|0:00:06|0+ (0%)|10 &gt; Small snippet of the 1st demo with Jenjin --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/BinaryMonkL ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=dv291tj\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v2.0.0
Same reason as people like using JS on the backend with Node (one language end-to-end), but in this case Java/Kotlin.
Flutter is pretty much a last ditch attempt to save Dart at this point outside of Googleplex. Even if it does gain some popularity, it's not going to impact the advantages that Kotlin has (interop with Java which is very useful for library support or integrated into existing Android apps).
I think this is something that you should probably ask JetBrains themselves via an official channel, rather than asking the community on reddit... because some people will start to answer what they **think** might probably happen or what they **which* to happen. I think it would be more efficient if you start a language enhancement, link it, so that people could upvote it, if they were interested in that feature as well.
You could do import package.ClassName as ClassAlias
I can do it without twilio in about the same, assuming it's a phone.
Very cool! You got a blog post or repo showing that? Would love to see how you do it.
That's cool, but the idea with the code above is so it runs on the backend, that way you can trigger that from your backend applications or have mobile apps in any platform trigger it via an HTTP request.
Well, I did say if it's on a phone. The article is specifically about an app after all. For backend you'd need a gateway service of course. 
This would still be on a file scope and would not allow for generics
We're using Twilio for login and are moving away because it's prohibitively expensive and unreliable for login in Belgium. We're using multiple SMS gateways just because often one of the messages doesn't go through even though the gateway say they do. Not recommended imo, but maybe recommended if you live in the US because it's almost free to send a text there and Twilio doesn't really care about Belgium. /endrant
Nobody know the future of Fuchsia. 
You can have typealiases that are private to a file. 
Well let me tell you. It can generate a monolith or a microservices application with both front and backend. It has full fledged angular cli + react app generator with webpack4. It has all ci / cd deployment options for leading cloud vendors / cloud tools. JDL for your db configuration and many more. I heard that it has 26k varieties or combinations to generate an application. 
`swapPositions` sounds like a better approach
No, that doesn't describe the semantics, read the description again.
You should check the logs to see where exactly it crashes. But i assume it's here. dayofbirth.text.toString().toInt() If one of those fields is empty it's either null or "" and converting that to a number would cause problems
 What do you mean by that? 
I honestly think that company advertisement should be forbidden in this sub
How? Could you please provide a snippet of code? :)
An IF is a logical operator, you set a condition and perform something depending on that, so the question makes no sense. :) Can you please rephrase it?
Well, IF is also a value returning statement in Kotlin, although that's not what OP means :)
Depends. If it's a terrible third-party code that throws `IllegalStateException` given valid input, handling the error is completely justifiable. If it's a solid third-party code, you should definitely look for the root cause in your own application and fix it. If it's both your code that throws the exception and causes it, then yeah - it might be a good practice to avoid catching standard Java runtime exceptions. It's like an NPE: you shouldn't catch that, you should avoid passing nulls around in the first place.
It's especially tooling and multi platform architecture. Also noteworthy is, that you can not write awful JS code in Kotlin (although you can write typeless), while TypeScript additionally allows everything else that people hate about JS.
What is javalin? The webside dont says it
What do you mean exactly? Are you saying you're reading https://javalin.io and that you don't understand what Javalin is/does?
Sorry man, missed the first page. Great project by the way. Would this run on android? 
Good question, I don't really know enough about android to answer that. You could just create a project and see what happens? I'd be very interested in the results.
Will do and let you know
&gt;Initially we could think that `meow!!` will not trigger a null pointer exception, because `meow` is a non-nullable property of `Cat`. And about this we are right, but in Kotlin, every child object of a nullable object will inherit that nullability. &gt;So the `meow` property will become effectively a `String?` if an ancestor is of a nullable type, also if in our `Cat` object it’s defined as `String`. This wording feels a bit misleading. It sounds like this is a property of the "objects" and that it has to do something with "inheritance" and "ancestors". I think it would be much cleaner to explain that this is how the [safe call operator](https://kotlinlang.org/docs/reference/null-safety.html) works, that it propogates nullability and that it's the entire expression together `(maybeACat?.meow)` that's nullable, because it returns `null` if the left side of the operator evaluates to `null`.
&gt; What do you think? Really nice! I'm impressed.
A new version of the plugin (0.0.2) supports Android Studio as well. But there are some pre-requirements: the version of Kotlin plugin should be at least 1.2.30 and used Android API Level should be 27+
https://github.com/Kotlin/js-externals/tree/master/externals/react-native That is a link to a JetBrains repo with wrapper libraries for React Native. I can't attest to how effective it is or whether it even works because I haven't used it but it seems like it's possible. 
It seems silly to not define a concrete interface before hand.
Heh, any more to that comment? If you have a lot of independent implementations, definitely. If you have a single implementation, but need the interface(s) for delegation, mockable injection, etc...
An Interface should give you a clear Vision of the contract you Want to satisfy. It is the public api for something that is a private Implementation detail, even if you use it internally. The Interface should be completely decoupled from Implementations, hence it looks Like a Bad idea if you somehow put it in your Implementation class. Since interfaces mostly have to be backwardscompatible, they should be static and designed at the very first.. so inherently, they have to be written before the Implementation ist done.
🤔 I see your point. I’m not sure I am that much of a purest, but it’s good to call out the “Ian Malcom” scenario (could vs should). I think of it as a shorthand for defining the interface in subset of cases where a interfaces are required. SOLID should still apply. Someone using it *could* do “bad things” faster... But truthfully, I’m already going to do it ☺️. I’m more looking for: * has it been done * has anyone else thought about doing something similar * are there suggestions given the usage example 
I like the idea. That way you don't have to write the interface by hand, but still reap the benefits. But all the annotations kind of defeat the purpose. I'd implement it the other way around - every method that is public without @NotInterface is part of the interface. Also are you sure that you need to support generating multiple interfaces from a single class? 
Ah, the false abstraction antipattern. A Java classic. Slightly inflating your code base by introducing a completely unnecessary layer of abstraction for no good reason other than that it feels like a good practice. There are certainly way worse antipatterns though. 
I've been fairly happy with Javalin since I switched from Spark. 
Very nice. I was not aware of Jetbrains Exposed until now. Definitely something I will investigate further. Thanks.
The article is misleading and the explanations are incorrect. Non-null properties do not inherit nullability. I recommend updating the article with proper explanations of what the safe call and non-null assertion operators do. Even the value of the "meow" property is written as if it's trying to make the example more confusing.
A fan and professional user of kotlin, you are using kotlin with bad patterns. 
Thanks a lot for the hint. I removed the utils.UUIDEntity . This is now provided by exposed.
Thanks, hope you'll have chance to use exposed in one of your next projects.
Please do and let us know about your findings. I played around with quite a few sql clients the last couple of weeks (e.g. jooq, querydsl, jdbi, requery). After all, I felt most comfortable with Exposed. I'm going for it in my next project. Btw, it may make sense to investigate rx-jdbc and DbOom (provided by Jodd microframework) as well.
This is really cool! 
It's not just var, but immutability in general. It's gross kotlin. Just do Java at that point 
Hi guys, I’m the author of this article. Yee, title should be val, it’s my mistake, like typo in „FramworkMap” ;) Please notice, it’s just a simple example. Production code shouldn’t look like this :) I would never use mutablelist as page list. Book should be a data class and if I want to edit this book, I would use copy() method ;) But anyway, thx for your feedback. Next time I will create more „real life” examples ;)
I don't like that the logic is happening in the controller. Why don't you move it to the service? Other from that or looks good, thank you :) 
Turns out this isn’t really possible with kapt at the moment. It’s possible to generate Kotlin source files, but not to read them. Because kapt uses the java annotation processor underneath, it sees elements as java elements and information (properties) gets lost in translation. For properties, you could make a guess based on the existence of java get/set methods, but it seems fragile. Also, it breaks on methods with default parameters. And there’s no way to detect that the method has defaults to skip it.
I'm sorry, I'm not sure if I got you right, but if so, your comment is complete nonsense :) False abstraction only shows over time, because an abstraction is always done with an intention in mind (which could be false or may not apply anymore sometime later). A false abstraction can be undone, you know? I'm aware that this happens rarely, but this is an whole different story. Undoing can only happen when the abstraction turns out to be a bad decision though. Further, I can't see **any** reason why you think about a false abstraction here. The author is talking about delegation. This is for example used when you have a (simple?) implementation for something that is usually fine, although there are other implementations. Let's be happy that Kotlin allows this with nearly no overhead. Introducing an interface for this happens out of need, because the delegating class has to have a small contract that it wishes to fulfill. If there wouldn't be an interface, we could as well use multiple inheritance and just merge everything into everything. For me, it seems that the athour wants the benefits of those abstractions, but without accepting the consequences...which is kind of strange for me, but hey, let him try, I'm curious :) Has really nothing to do with "just because it feels like good practice", but rather with people having a lot more experience what gives a solid codebase when the project grows larger. Loose coupling, high cohesion. Sure, if you just code for yourself, you can do whatever you want and what you think is good code. But if you code in a team and for products that has to be backwards compatible, easily expandable, easily testable, then there are some things that make more sense, than if you just think about code in 3 lines blocks. Not a Java problem though... languages like C++ or Scala do it the same way, slightly different, but for the same reasons. There are reasons people do it why they do it - and that's not always because they don't know better, which is what I assume you assumes :P @Topic: I got that you (the author) sees "technical" requirements as different requirements then the use cases where you would naturally introduce interfaces because of how you want your code to be used.... since it seems that you aren't interested in understanding WHY this is a bad idea, I'm curious if your effort pays out for you from a long term view :)
What about using (at least for start) art from Micropolis which was licensed under GPL? https://community.linuxmint.com/img/screenshots/micropolis.png http://www.donhopkins.com/home/micropolis/ Or maybe old version (2d) of Lincity ? https://upload.wikimedia.org/wikipedia/commons/6/66/Lincity.png
Firstly, bookend this with I am not an artist and can barely draw to save my life. I did think about it... but a few things were on my mind: * The old art style is bad... I was thinking "MacOS". Simpler, clean, high-res buildings so zooming looks as nice as possible. * I want this to be a "clean room" implementation -- no reused assets from SimCity * Until an artist can be found that wants to contribute I will keep the look as minimal as possible, as not to offend the eyes.
Or use a phone as your backend machine :))))
That... was very long 😊. I can see you’re a fan of verbosity 😆.
Code generation isn’t a bad idea. The intent is clear. The result is the same. If I had made a statement like: All classes should come with implicit interfaces accessible via `Foo::class.interface`; then we would have room for a philosophical debate, rather than the semantic one(s) we’re having now. Also, you may find people more receptive if you avoid phrases like “you don’t understand”, and “that’s a bad idea”. But if reception is not your intent, or you have experience that says otherwise, do what works for you ☺️
While Flutter has made great strides since last time I looked at it, I don't see it replacing the standard Android API (Kotlin or not). First of all, it introduces a new way to write the UI *without relying on the platform UI system*. Your Flutter app effectively becomes something akin to an OpenGL game. Secondly your app isn't just UI, it has networking, storage, peripherals to handle, none of which Flutter helps you with.
Hmm... there is a ray of hope. This library may hold the secret to reading Kotlin metadata from a Java class: https://github.com/Kotlin/kotlinx.reflect.lite
funny you should say that because i was really taking a look at it the past days, doing a tutorial and i browsed the project structure. I found the typical android java app structure within it and like 2 java classes. I'm like....???? So.... flutter is just UI? I mean I know you can do whatever comes with the dart language, io, networking, etc. But is flutter pretty much strictly for building UIs? And can I intermix my java code and flutter? Because it seems like you write your application business logic within your dart files and I don't see any sort of "bridge" for communicating between the flutter and java code.
Right here: https://flutter.io/platform-channels/ Reading the Flutter FAQ, it is explicitly stated that "Flutter gives developers out-of-the-box access to *some* platform-specific services and APIs from the operating system". Emphasis on *some* not added by me. 
It makes sense if you consider that Google invented Dart but not Kotlin. 
aaaaaah. awesome. thank you!. so there definitely is interoperability. makes me wonder if it's even worth using flutter since i can just use anko with kotlin.
What are your thoughts/experiences with jooq? It's syntax looks compelling to (FP enthousiast) me; it's license makes me less excited though.
Thanks for the tip... I'll be using stock art until I can find an artist that takes pity on me.
Here’s something that might be better, suggested by someone on the Kotlinlang slack domain: https://github.com/Takhion/kotlin-metadata
I just pushed an example for working with postgres custom enum types, e.g.: CREATE TYPE TweetStatusType AS ENUM ('DRAFT', 'PENDING', 'PUBLISHED'); CREATE TABLE Tweet ( (...) status TweetStatusType NOT NULL DEFAULT 'DRAFT' ); see: api/tweeter/db/tweetsTable.kt object TweetsTable : Table("tweet") { (...) val status = enumerationByNameAndSqlType( name = "status", sqlType = "TweetStatusType", klass = TweetStatus::class.java ) }
We'll I think you can use jooq with postgres / mysql without any licence issues. I prefer jooq over hibernate. The typesafe sql dsl for querying data is very nice and powerful. And Lukas Eder (jooq) is a very smart guy and quickly responds to issues created on github. But I faced a couple of things I did not like too much, but maybe I just got them wrong: 1. The codegenerator can generate immutable java-pojos from a running database (e.g. postgres in docker), but: - the generated models do not provide any nullability related information derived from your schema - the java pojos are no kotlin data classes (lacks the power of "copy", "name parameters") 2. Somehow working having jooq + kotlin in IntelliJ makes Intellij very slow. Intellij (kotlin) seem not to like the varargs and dozens of overloaded method signatures jooq creates. 3. Saving / Mutating data. Well, jooq uses some kind of ActiveRecord approach. It feels better to me than jpa's ORM entity graph's. It's closer to SQL. (I guess, I can expect a backend developer has at least some basic knowledge of sql). The drawback with ActiveRecord for an FP guy still is mutability. Passing around mutable datastructures is not really "Effective Java" imho. Therefore, I wish they could focus on providing better support for FP-style (immutable data classes) within their next releases. If you feel like playing around with jooq, I have created a simple starter repository: https://github.com/bastman/spring-kotlin-jooq 
Thanks! Great info
Depends, I'd use Flutter if the app was for example predominantly UI-based and wanted it to work on iOS and Android with little overhead. I'm also slightly biased as Kotlin is one of my favourite languages and I don't know much Dart yet to compare. Kotlin is definitely going to be a good bet if you just want to focus on Android
Okay let's sum this up: - I gave a nice and honest answer why it's generally not a good idea to couple interfaces (no matter how they are used) to the implementation (first comment from me). This was answered by the author with "Someone using it could do “bad things” faster... But truthfully, I’m already going to do it ☺️." This shows the mere ignorance and that the author seems to not be interested in honest feedback for me. I'm such a douche. - You are arbitrarily throwing in "false abstraction" here, which literally has nothing to do at all with what I wrote. I invested a piece of my lifetime to give you a detailed answer why your comment was misplaced, which the author honored with a form of "tldr". Oh, what a douche I am. Honestly, I'm not interested in being your mother and treating you with velvet gloves and I don't think you're worth more of my time. Here's the douche.
&gt; I'm such a douche The only well-informed statement in there
The game: https://github.com/AlmasB/FXGLGames/tree/master/SpaceInvaders The framework: https://github.com/AlmasB/FXGL Basic mobile app demo: https://github.com/AlmasB/FXGL-MobileApp The mobile support work has started very recently, so there are some rough edges. These will be fixed in upcoming weeks. It's 100% open-source, so contributions are very welcome.
The game is in Java, though you can use Kotlin. The framework itself is a mix between Java and Kotlin. Java is typically used for high-level interfaces, while Kotlin is for low-level implementations. As the mobile support improves, more of the codebase will move to Kotlin, as certain Java 8 API are not available on mobile.
Honestly with Kotlin I am not sure why would you want to use Java at all.
Agreed. I started the project a few years ago when I wasn't familiar with Kotlin. Since then I've been doing manual conversions to Kotlin, as I don't yet trust the Java-&gt;Kotlin auto-convert from IDE. Would be great to get more contributors, even if just for code conversion.
One of the primary benefits would be re-using code between a Java/Kotlin server and your JS front-end, especially since Kotlin added multi-platform projects.
Does Swift have ways of creating DSLs?
"Popular among Android users who have to use Java" uh kind of like Kernel devs have use C or incure the wrath of Linus?
Kotlin has first class support on Android
What do they mean by "have to use Java"? Someone should tell them about C++ too. 
"Kotlin is now the second fastest growing language we have seen after Apple’s successor to Objective-C."
You can use C++, but then you are losing on the whole Android API.
Swift had the "big launch day" AND the sponsorship of Apple since day one while kotlin didn't... Very impressive by our little K!
Last year's Google I/O was a pretty big push for Kotlin.
Yes, but by that time, Kotlin had already a relatively big user base
&gt; This is the exact inverse of Kotlin, which performs well on GitHub, but whose relative community traction outside of Stack Overflow under-represents the language on that axis. Likely because half of the Kotlin questions people might ask or find on Stack Overflow are answered by Java questions/answers.
Or maybe kotlin is so easy ti learn and use that no One needs ti ask questions about It! ...maybe I am a bit too enthusiast 😁
On my team, we're doing a library in Kotlin and Swift. We use lots of generics, and it's a breeze in Kotlin and a nightmare in Swift. Either our iOS dev team did something wrong with defining the types and generics or Swift's type system is significantly worse. I'm talking about things such as casting a sub-type to a supertype which won't compile, the "cyclomatic complexity" warnings in XCode, etc. Anybody else noted anything similar?
http4k author here. You can use the contract module in http4k to define typesafe http contracts and then automatically produce swagger API docs from them. Details of the contract functionality [here](https://www.http4k.org/cookbook/typesafe_http_contracts/) or an example of the contracts in action [here](https://github.com/http4k/http4k-contract-example-app). Any questions, just pop into the #http4k channel on the Kotlin slack. :)
I'm converting a Java project of my spare time too (20k lines or so?) and I have no problems at all using the automatic code conversion. It works for 90% of the cases without further adjustments needed. Of course there are some things that are not as optimal as they could be if you wrote it from scratch by hand, for example nullability is translated to !! sometimes...but in general, I would advise to revisit your workflow, and check if auto-conversion and "code review" wouldn't be better solution, regarding the fact that you would even delegate the conversion work to another person. I really do it on the fly with a minimal amount of effort to make it "really nice".
As a solely JS dev I completely relate, I'm very impressed on how easy it is to get things done with Kotlin. It's been a pleasure to work with it.
MVP: https://github.com/ChrisAckerman/efface
Thanks!
Yes! You just need to create modules for: 1) The common code (code that will be used in both the JS and Java programs) 2) The JS code 3) The Java code [Check out this repo](https://github.com/MarcinMoskala/KotlinAcademyApp), it has a good structure on how to write the gradle scripts for each module. 
Android? Look for adapters e.g. [ArrayAdapter](https://github.com/codepath/android_guides/wiki/Using-an-ArrayAdapter-with-ListView), or the more recommended [RecyclerView](https://developer.android.com/guide/topics/ui/layout/recyclerview.html). That CodePath site also had a whole section on it: https://guides.codepath.com/android#adapterviews
There probably aren't any yet to be honest. Great thing about kotlin is that it can still interface with any java code. You can probably use any existing Android barcode scanner (zxing looks like a good place to start). If you encounter any example code just copy paste it into a kt file and intellij will convert it for you to somewhat decent kotlin code. The way you call it might feel more "java" then "kotlin" but it will definitely work just as good.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/androiddev] [Background service examples (Kotlin)](https://www.reddit.com/r/androiddev/comments/83f74x/background_service_examples_kotlin/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Here is a Kotlin example, but you can just follow the JobScheduler guide in this medium blogpost: https://github.com/googlesamples/android-jobscheduler https://medium.com/google-developers/scheduling-jobs-like-a-pro-with-jobscheduler-286ef8510129
You can create a [jobService](https://developer.android.com/reference/android/app/job/JobService.html) and use a [jobInfo](https://developer.android.com/reference/android/app/job/JobInfo.Builder.html) to set your repeating criteria. 
I'll check zxing then. The reason I chose kotlin was to avoid java. But it seems like there is no other option.
You can interface with the java classes provided by a library just like you would with any other kotlin code. The only thing is that null safety is not guaranteed anymore, so keep an eye out for that. If you check the return type in kotlin it's probably something like type! Which means it might or might not be null ( like type?) , but kotlin isn't going to force you to check it. Unless the library is properly annotated with @nullable or @nonnull, then you are golden.
Why did you want to avoid Java in the first place? 
Why do you feel that the first example has a bigger expectation of return a value than the second? I'd say they are pretty much equivalent. 
Kotlin style guide says that single line expressions should only be used for expressions that actually return something
I aggree... sort of. For me (too), the single-expression format “fits” when it actually contains an expression. If it’s a single function call, then call that function directly. If the intent was to make some default parameters, or hide the actual implementation etc, then use a proper “abstracting solution”. But... if we approach this as a code readibility problem, well, “function output equals println with some value” is totally readable and understandable for me, so I can live with it :)
&gt; But... if we approach this as a code readibility problem, well, “function output equals println with some value” is totally readable and understandable for me, so I can live with it :) Readability can also suffer. Consider the following: private fun updateDatabase() = writeToDisk() What is being returned here? It might be Unit, or it might be Boolean. Your guess is as good as mine.
Do you have a link? I don't see this clearly stated in the official Kotlin style guide.
What if it returns Unit?
Technically... fun update() = {total += lastCharge}()
I think you're right, but the issue is that `println("Hello")` is actually an expression in the Kotlin language. The link you post also confirms this: &gt; Note that in Kotlin every function returns at least Unit, therefore every function invocation is an expression. For this reason, anybody arguing against me could say that the style guide, as it's written right now, is fully supporting `fun output() = println("Hello")`. It seems to me that the only way to solve this problem is for the guide to say something like, "Do not use single-expression functions when the return value is Unit."
&gt; The one function's "something" is just as good as the other function's "something", so returning one or the other does not make any technical or semantical difference. I disagree. There's a big semantic difference between `fun print() = println("Hi")` and `fun add() = a + b`. The first one returns nothing of interest, while the second returns a value that is intended to be used.
Doing comparisons on a project level is just too complex, so nobody feels like doing it... The more common way to compare such things are microbenchmarks. Although one has to be careful with microbenchmarks, comparing two methods can often be done correctly. There are some mb that compare coroutines to akka, but I have no idea about how the result looks like. https://github.com/Kotlin/kotlinx.coroutines/tree/master/benchmarks/src/jmh/kotlin/benchmarks Besides that: Kotlin's coroutines are statically compiled to a state machine that reuses functions. That means way less objects are created than with other techniques (callback stuff for example). This should make a large difference in gc pressure, depending on the amount of threads/coroutines/callbacks you use. Compared to techniques that acutally block a thread...with coroutines, you don't block, as the article describes. So that is not faster in the means of time, but it doesn't block, so the ressources can be used by other threads/coroutines. And since there are not threads involved for scheduling, there's no overhead with context switching. Everything is happening in your Java code. That's faster by definition. But I have no numbers at all, so I can't prove anything here. Maybe the kotlinx benchmarks do, let us know what your results are :)
 fun updateDatabase(): Unit = writeToDisk()
 fun update() = total += lastCharge // THIS WON'T COMPILE fun update() = { total += lastCharge }() // now it will I kid, I kid.
Beat me to it! I've actually done this...once...definitely going to hell
Because I don't know Java. I started directly with Kotlin. I have invested a lot of time in Kotlin.
The expression does return something. It’s type is called `Unit`. It’s an object reference by the name of `Unit`. Further, there is no such thing as a statement in Kotlin. Everything is an expression.
&gt; Further, there is no such thing as a statement in Kotlin. Everything is an expression. What about `total += x`? And yes, there are statements in Kotlin, even the Style guide mentions that for `if`/`when`... https://kotlinlang.org/docs/reference/coding-conventions.html#using-conditional-statements I should've worded it a bit different: &gt; the purpose of an expression is to create a value (with some possible side-effects), while the sole purpose of a statement is to have side-effects. https://fsharpforfunandprofit.com/posts/expressions-vs-statements/ `println("Hello World")` only does side-effects without returning a meaningful value.
&gt; Note that in Kotlin every function returns at least Unit, therefore every function invocation is an expression. Oh, I actually think the author is wrong here. (Just skimmed throught the blog post before I posted it here ^^) IMO an expression produces a meaningful value, whereas a statement (even if it returns Unit) only does side-effects and doesn't return a meaningful value.
&gt; When a function returns a single expression, (...) There are functions that return multiple expressions?
I really don't think there's a real problem here. Single line functions are cool, but if you think one is confusing, refactor it to use the longer syntax. In my own experience, I don't find single line functions returning Unit particularly confusing. YMMV
You missed my point, because you exluded one sentence of mine before the cited one: Unit is not only "technical" - it means here's returned really just "something". Instead of comparing two functions that return different results and asking which one has a more relevant return value (I which is pointless), you should ask whether `fun print() = println("Hi")` and `fun print(): Unit { println("Hi") }` makes a difference. As said, Unit is really just one value, it exists only once. That means it makes no technical and *semantical* difference from where it is returned, it solely exists to just return "something". You said several times, that the return of print is nothing of interest. That's right, but it's the same uninteresting thing that every function returns if not stated otherwise, so there's nothing wrong with returning it - explicitely, chained, implicitely, doesn't really matter.
I have sub-second compile times in my test project using Gradle.
That's nice to hear how large is your app? 
Your opinion on what is a *useful* expression aside, Kotlin does consider functions returning Unit to be expressions.
`fun update(): Unit = ...` not work?
I stand corrected! Kotlin _does_ in fact differentiate between statements and expressions. Specifically, it appears that `if` and `when` have both statement and expression forms and that variable-assignment is always considered a statement. _Nothing else in the programming language is a statement, including methods that return `Unit`. Methods that return `Unit` are expressions._ Thank you for helping me refine my understanding of the language.
Yes, but I've never said that `println("Hello World")` isn't useful, just that from a semantic point of view it feels more like a statement because it doesn't produce a value that you work with.
&gt; Methods that return Unit are expressions And here starts the confusion. From a semantic point of view `fun add1(x: Int) = x + 1` is very different from `fun log(msg: String) = println(msg) `log` feels more like a `void`-Method from Java, because usually you ignore the return value
My confusion was actually that I assumed assignment operations _also_ returned `Unit`. If the language had been designed that way, assignment would _technically_ be an _expression_, just one which resolved to `Unit`.
You can throw exceptions in common models I think, but not Java specific ones.
From the compiler perspective you are absolutely right. Everything that returns something *is* an expression. From a semantic point of view `fun log() = println("Hello World")` just feels like `void log() { System.out.println("Hello World")` because neither return a value that you work with 
To be honest, I see Go wining this area, specially given its UNIX roots. Kotlin/Native is still an experiment and it will take years to match the performance and GC quality of both its JVM variant and other native languages.
Not very common, but not unheard of. I write a fair bit of internal systems tooling in Kotlin but I also use a healthy dosage of Python. I'm not sure what to really call the phenomenon but so I'll call it the "ecosystem effect" is very strong with Python and Go in the ops and cloud-systems engineering spaces... there's just a ton of momentum already there in the form of existing projects and libraries that it is hard to justify using something else because you're often standing at the ground floor when everyone else is already thirty floors above you thanks to existing code. The requirement for a JVM to be shipped or installed along with the tools is a small but understated inconvenience at times. I'm really interested in Kotlin/Native and Java's future AOT compilation for this reason. 
Found this. Trying to understand. https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md
&gt; I see Go wining this area Am I the only one shocked to see Go quoted in a decent manner? I should quit /r/programming
I suggest you take any intro course to C (or read an intro book). Pointers and (static) functions are very basic components of the language and it's best to learn them in the context of the other basics. 
I am critical of some of their design decisions, but when it is getting used by devops teams around the globe, with Amazon and Microsoft contributing to Go, it would be foolish not to acknowledge its adoption rate.
Even in /r/programming it's not uncommon to see Go recommended for sysadmin/devops tools because of its benefits as a GC'd language that produces static native binaries. In my opinion, the oft-cited criticisms for Go aren't really relevant to that type of work. It plays the same role as bash or python, letting anyone quickly write a script or utility and get it out the door. 
Serialising JSON payloads from network requests into Kotlin classes. The secondary use-case was teaching me how to Kotlin. This is my first major project in the language and I don't think I can ever go back to Java!
Nice work! - if you stick it into Bintray (or Maven god help ye), I might nab this to replace the (data class generator)[http://http4k-data-class-gen.herokuapp.com/] that we wrote for http4k :) ps. I know what you mean about Java.. 
This: https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md
Kubernetes is mostly written in Go.
I've messed around with them a bit; if you have concrete questions, I might be able to answer.
No you don't, only in OpenJDK's case. Since the early days of Java, the commercial JDKs have supported AOT compilation, just like other compiled languages. The problem is that many aren't aware of them, as they don't educate themselves about what is available in terms of Java tools.
A plugin exists for intellij that also serves this purpose. https://plugins.jetbrains.com/plugin/10054-generate-kotlin-data-classes-from-json
&gt; OpenJDK That's what I meant, when he said he's looking for in the future, means he's not interested in current solutions.
Thanks for the example, those are being grouped together because of the name field. May need to update that to be a bit less sensitive/naive.
Thanks, looks good. 
I only see JVM there, which would imply any JVM implementation, just like when I write C or C++ I am not referencing to a specific C or C++ compiler. As for the future, I understand it as referring to Kotlin/Native. &gt;Hi, &gt;I'm working at a webhosting company which mainly use Go for internal tools. Do you have any feedbacks on using Kotlin is this area? With Kotlin/Native the last barrier of the JVM needed on our servers seems to be broken. I know that Kotlin/Native is in Alpha but it seems to be near the production release. Like JavaScript dev can do anything, from back to front, from Web to Desktop and Mobile apps, I would love to see a bright future for Kotlin like that, as a professional System Engineer and an amateur Android dev. 
In this day and age I can see that being pretty accurate.
Modern functional JavaScript is actually pretty nice. It's a diff beast than 90s JavaScript we all grew to loath
I haven't met anyone on Android who wanted to go back to Java after using Kotlin. 
I use the [coroutines guide](https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md) quite a bit and find that really helpful. Roman Elizarov (coroutines project lead) gave two talks at KotlinConf 2017, on coroutines. Spend 2 hours to watch these and you'll have a better understanding of what they do and how they work under the covers. I thought I understood them before attending these sessions, and I really learned a lot. Totally changed my understanding. * Part 1: [Introduction to Coroutines](https://www.youtube.com/watch?v=_hfBv0a09Jc). * Part 2: [Deep Dives into Coroutines on JVM](https://www.youtube.com/watch?v=YrrUCSi72E8). [Kotlin Slack](https://kotlinlang.slack.com/). There's a #coroutines channel in there that is active and helpful. Project members and heavy users hang out there and provide useful advice when asked.
Same. I've only talked with people who refuse to even try Kotlin over on /r/androiddev, or people who think you have to go all-or-nothing with Kotlin, not realizing (or even listening to those of us who tried) that you can migrate to Kotlin at your own pace. Typically the only naysayers I still see today about Kotlin are those who just haven't tried it yet.
Here's a sneak peek of /r/androiddev using the [top posts](https://np.reddit.com/r/androiddev/top/?sort=top&amp;t=year) of the year! \#1: [LPT: Drag up and down on process windows to accelerate gradle downloads](https://gfycat.com/VigorousPleasedHuman) | [50 comments](https://np.reddit.com/r/androiddev/comments/71xljr/lpt_drag_up_and_down_on_process_windows_to/) \#2: [As a developer of a free game, people like this grind my gears](https://i.imgur.com/nQRdRR2.png) | [161 comments](https://np.reddit.com/r/androiddev/comments/736tf5/as_a_developer_of_a_free_game_people_like_this/) \#3: [Kotlin is officially supported on Android](https://np.reddit.com/r/androiddev/comments/6bqlds/kotlin_is_officially_supported_on_android/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
Did they actually remove the bad parts, or have people simply learned how to avoid them?
We've made enough improvements to JavaScript that good practices make bad practices obsolete.
Bad practices never go obsolete, that's why they're bad.
As someone who mostly stopped using JavaScript about 10 years ago, what are some of these improvements that have been made to the language? Did they fix all of the "wats"?
With all the talk of Vim vs. Emacs, it surprises me that Emacs is in the low single digits, while Vim is 25% of all respondents. It does not surprise me that it is 40% (and #1) amongst sysadmin/devops practitioners.
I haven't wanted to go back to most languages once I've really gotten started with Kotlin. 
Top of my head, there's proper classes, fat arrow functions (which help a bit with the `this` confusion, proper `async`/`await`, and the rise of gulp/webpack/babel making using all of these new features possible in (almost) any browser.
well, this is a very newbie question, but how should someone learn kotlin? Just read the tutorial https://kotlinlang.org/docs/tutorials/ and do projects?
It would be quite a bumpy ride. The C code that runs in the kernel does not make use of libc, rather there are other utility functions adapted to the special needs of kernel code. So, first issue would be to have a Kotlin/Native version, with a minimal runtime able to execute on kernel space, only linking with kernel level libraries. Secondly, Kotlin has automatic memory management, which doesn't play well with UNIX kernels. On the OSes implemented in GC enabled systems programming languages, Lisp Machines, Oberon, Singularity, Midori,... the GC is a kernel service. Even to use C++, with its close relationship with C required quite a few kernel customizations as shown at the talk [Making C++ and the STL Work in the Linux / Windows Kernels](https://www.youtube.com/watch?v=uQSQy-7lveQ) on CppCon 2016. So as an experiment it might eventually be possible, but be prepared to put the effort to actually make it work. 
'proper classes' were available before in the sense that you could define functions as pseudo-classes with the same prototypical inheritance. The new syntax doesn't hoist definitions, can't be defined twice, and is exclusively block scoped (maybe other things too) but... Well, I would say it's mostly syntactic sugar and you've always been able to write practically the same code. Otherwise I agree entirely, JS is getting a lot nicer. I'm not crazy for `class` but I don't hate it either.
I feel that the language is very easy, its like a combination of javascript and java
I'm not sure what your experience is but I'd say that using the documentation to make your own project is the way to go.
This seems like a good argument to avoid Spock :/
That's what I did and it worked well for me; I think.
Uhm, not really. The functional bits of Javascript existed since the beginning. Also, Javascript development nowadays is often way too complicated with all the libraries and frameworks and compilers and transpilers and packagers and minifiers .. and npm.
Wouldn't it be more natural to test a Kotlin system with tests written in Kotlin? This is how one of the examples would look like with [KotlinTest](https://github.com/kotlintest/kotlintest/): "should validate age" { val testData = table( header("age", "result"), row( 0, Error.INSTANCE), row( 17, Error.INSTANCE), row( 18, Ok.INSTANCE), row( 19, Ok.INSTANCE) ) forAll(testData) { age, result -&gt; sut.validate(age) == result } } 
&gt; Management feels moving to Kotlin might make it harder to hire Java devs. Goddamn, I had the same problem. I moved to a different job where all the new stuff is in Kotlin and we're moving the old stuff over to Kotlin as well. And for me, the disapproval came from our "Systems Architect", who should know how easy it is to pick up Kotlin for any decent dev. He told management that it was a bad idea. I had to get 3 approvals just to put a request in, so after convincing 3 people, I failed at the fourth. Same problem with including RxJava and Dagger. I guess he didn't want to learn new technologies or something (DI isn't even new). &gt; I feel it might make it easier to hire the type of devs we need. I agree.
I know of one...not had the chance to ask them why they went back though. They had one problem with some library...
&gt; And for me, the disapproval came from our "Systems Architect", who should know how easy it is to pick up Kotlin for any decent dev. He told management that it was a bad idea. Ugh. Not related to Kotlin but: Recently I had a run-in with an 'architect' (non-programming) who behind my back convinced our non-technical CTO that my idea of using Postgres over Cassandra for a strongly relational model was a bad idea because it introduced 'risk'. Fuck these types of 'architects'. Kotlin really isn't a separate language, it's basically a better Java. In my experience most developers picked it up in just a few days. For us as back-end dev it also saves a ton of time and hassle because we don't have to deal with Lombok anymore for example. But on the other hand the Ops team can just muck about with Go without any repercussions for not dealing with quality aspects. 
Even big projects without affecting build times?
Yeah this is definitely unfortunate. I think a lot of people think that Kotlin is going to be a completely different language akin to writing everything new in Scala or something. I can how thinking that would raise red flags but the reality is, as you said, the interop is seamless and any reasonable Java dev can (and in my experience will want to) pick up Kotlin in a few days.
That's my experience too. Even for myself; I did Scala, Groovy and a bit of Ceylon before Kotlin. Kotlin is the only language I felt was seamless and actually solved the problems I wanted solved without introducing new ones. Unfortunately this enthusiasm is hard to keep to yourself so Kotlin fans can be seen as a but preachy / advocaty in discussions with Java devs (many of which really don't even want to learn the new Java 8 stuff, let alone a 'new language'). 
Jinx is a new product for writing Excel Add-Ins in JVM languages: https://exceljava.com It works by embedding the JVM in Excel and exposing annotated Kotlin (or Java, Scala etc) functions to Excel as UDFs. You can download the current beta version for free: https://exceljava.com/download.html. I'd be interested to hear any feedback you might have! If you have any problems getting started please let me know and I will help you. It's intended that when out of beta it will be free to use for personal/non-commercial use.
They're not the same internally. It's similar to the difference between a nested class, and a static nested class, in Java. In the first case the nested class (or companion object) is a member of the outer class, but in the second case, it stands alone. (But might still be located within the same file/class as the outer, for organizational reasons.) Generally a companion object should be used in cases where you want to share a static instance of a contained type, within all instances of a particular nesting type. A good example of this is a logger class: class ServiceManager { fun registerService(service: Service) { ... LOGGER.info("Service registered: $service"); } companion object { private val LOGGER = LogManager.getLogger(ServiceManager::class) } }
&gt; Kotlin is close enough to Java that this is a non-issue. You might even get more or better applications, because you stand of the crowd. This is exactly the point we're making. Thanks for the link though; never heard of that one :)
 val jsonResponse = " {\n" + " \"id\": 1,\n" + " \"name\": \"Joao Alves\",\n" + " \"username\": \"joao.alves\",\n" + " \"email\": \"joao.alves@example.com\"\n" + " }"
Yep you're right just updated that in the article. I literally just copied the Json in between the quotes and didn't care much about it but makes sense.
This is the best tl;dr I could make, [original](https://insights.stackoverflow.com/survey/2018) reduced by 96%. (I'm a bot) ***** &gt; Our estimate of professional developers comes from the things people read and do when they visit Stack Overflow. &gt; The median number of developer type identifications per respondent is 2, and the most common pairs are combinations of back-end, front-end, and full-stack developer. &gt; Bootcamps are typically perceived as a way for newcomers to transition into a career as a software developer, but according to our survey, many participants in coding bootcamps were already working as developers. ***** [**Extended Summary**](http://np.reddit.com/r/autotldr/comments/84jcg4/stack_overflow_releases_their_developer_survey/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ "Version 2.00, ~296386 tl;drs so far.") | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr "PM's and comments are monitored, constructive feedback is welcome.") | *Top* *keywords*: **Developer**^#1 **respondent**^#2 **response**^#3 **apply**^#4 **select**^#5
If you're developing for android, how about the Android Mobile Vision API?
https://proandroiddev.com/kotlin-backend-yes-its-possible-953388acffc3 `runServer()` here could use multiline strings as well.
Thanks for the link. Thats a good tutorial but it doesnt show how to edit the names of the list within the app? Do you know of anything which teaches that?
Thanks for the link theres some good info in there. Specifically i want to edit the list/recyclerview while in the app. E.g. add in tasks for me to complete. Do you know anything which shows that?
When it comes to adapters, its pretty much: 1. what you do with your dataset 2. notifying the adapter that the dataset its holding has changed. e.g. A view onClick will invoke `list.remove(item)` and then calling `adapter.notifyXchanged` where X can be `dataset`, `item` etc. Check the adapter you are using for its proper notify methods. If you need search terms, then `Android notify list/recycler adapter`. The default nuclear trigger is simply calling `adapter.notifyDataSetChanged`. For RecyclerView you can the [these](https://guides.codepath.com/android/Using-the-RecyclerView#notifying-the-adapter) (also read using the DiffUtil below it). Also, this is not really Kotlin related and /r/androiddev or StackOverflow is more proper.
Here's a sneak peek of /r/androiddev using the [top posts](https://np.reddit.com/r/androiddev/top/?sort=top&amp;t=year) of the year! \#1: [LPT: Drag up and down on process windows to accelerate gradle downloads](https://gfycat.com/VigorousPleasedHuman) | [50 comments](https://np.reddit.com/r/androiddev/comments/71xljr/lpt_drag_up_and_down_on_process_windows_to/) \#2: [As a developer of a free game, people like this grind my gears](https://i.imgur.com/nQRdRR2.png) | [161 comments](https://np.reddit.com/r/androiddev/comments/736tf5/as_a_developer_of_a_free_game_people_like_this/) \#3: [Kotlin is officially supported on Android](https://np.reddit.com/r/androiddev/comments/6bqlds/kotlin_is_officially_supported_on_android/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
Oh update the code in the project but forgot to update that gist, only updated the 1st one. Thanks for reporting it, will fix it.
If you're running "gradle build" in the terminal, how exactly is this "using Gradle in vs code"? Don't get me wrong, kotlin native and writing kotlin/groovy in VS code is cool... But you're just running Gradle from the terminal and I hardly call that integrated.
None at all! I did it for fun, it's not an attempt to replace the standard regex library. Other people are free to chip in if they have any ideas they'd like to try out - I think the code is reasonably easy to read and extend. To my knowledge, there's no other Kotlin regex implementation on GitHub, besides a DSL that wraps the standard library.
Is this a joke ?
Do you know javascript? Then you know Typescript. 
Ok I'm going to go on the good faith that this is an honest question. Whether you decide to use Kotlin, or Typescript, or any tool for that matter, should first depend on what problem you are trying to solve. Kotlin and Typescript we're designed for different reasons, and while you can use both in certain situations, it really does usually depend on the greater context of your problem. Kotlin is an excellent alternative to Java for JVM related development. Typescript is great for large JavaScript projects that would benefit from the added type safety. Moreover you should consider your prior experience with either platform as well. Not to say that there isn't benefit in learning something new, but you're going to get less out of it, both in terms of what you build and the experience you have while doing it, if you're trying to break a problem down and explain it to a computer in a language you're unfamiliar with at the same time. That being said, if you would like to learn more about either language their official websites/docs are the best place to start. As far a Kotlin goes, while gaining a lot of traction it's still rather new so I don't know ow of any excellent tutorials thus far on that outside possibly browsing YouTube. If you aren't familiar with regular JavaScript yet, learn that before taking on Typescript. Once your familiar with JavaScript, you can probably pick up typescript in a couple days just off it's official docs.
You just add an item to the array and then call a methode that updates the list, like that : yourArray.add(YourObject) yourRecyclerView.adapter.notifyDataSetChanged() you can use this code in the onCreate() or anywhere you want , you just need to have access to yourArray and yourRecyclerView. And also if you want to show like int or strings there is no need to create a custom adapter or view handler. Finding a tutorial that explaining those things in Kotlin is hard, because the language is new (in the android world), but if you can read java it will help you solve your problems because they use the same SDK. I actually found out how to do that by reading java code.
Hi there, it seems that you haven’t read the post entirety but have just picked up the parts interesting for making your statement. Don’t get me wrong, but I have not claimed to show a perfect integrated solution for Kotlin/Native with VSC. I showed how to get started with the topic and referred to follow up posts where I will push the integration further. There are many more topics to cover, like debugging inside VSC and such. But I made that clear in the post. Best wishes, Martin
&gt; Typically the only naysayers I still see today about Kotlin are those who just haven't tried it yet The ego's ability to staunchly hold an opinion on a subject while at the same time being fully aware of it's ignorance on said subject never ceases to baffle me.
It's not as robust as I would like &amp; the documentation is poor, but I'm using it in one of my apps in prod now so decided to share it here. There's a typed and untyped DSL, hoping to target JavaScript for using with React eventually.
someone says &gt;how you decide on any tool for that matter should first depend on what problem you are trying to solve * maybe 50% of the time yea, maybe 50% of the time no * depends on if soemone's goal is to learn or not (see main post) &gt;while you can use both in certain situations, it really does usually depend on the greater context of your problem. * again it depends on if the person's goal is to learn or not &gt;you're going to get less out of learning something new &gt; * both in terms of what you build &gt; * and the experience you have while doing it i do not agree with this at all, i have always gotten more out of learning something new (depending on what it was) * when it comes to making things * and when it comes to my experience but again it depends on the goals of person, if they're goal is to learn or not /u/megaboy101
As it's written in the documentation https://kotlinlang.org/docs/tutorials/javascript/getting-started-gradle/getting-started-with-gradle.html
someone says &gt; new langs tend to not have good resources * that's helpful to know, and thanks for reminding me of this basic lesson/point /u/megaboy101 
Your post is misleading. You got that learning thing wrong and you're quoting people out of context. Quality of resources on TypeScript will be better in terms of *frontend web apps development*. Kotlin is hands down better for *mobile and server-side*, with official support on Android and multiple web frameworks like Spring of Vert.x. It's just that *KotlinJS* (Kotlin-to-JavaScript transpilation) is still not widely used, so - compared with TypeScript - you'll find less resources on developing for the web. Anyway, comparing Kotlin to TypeScript and Go is kind of like comparing apples to oranges - each language is trying to solve different issues. Kotlin is seeing the most adoption as a "better Java", so it's safe to say you can try it anywhere you'd use JVM. About the static vs dynamic - it all depends on the use case. When I'm hacking a quick run-once-and-delete script or prototyping a machine learning model, I can go with with Python and sacrifice some safely to get the job done sooner. When I'm building a more complex system, I'd rather not discover simple type errors as runtime exceptions. Static typing gives you some guarantees about your code, making it easier to reason about it and having to write less tests. To be honest, I'd rather work with static typing whenever I can, but there will be people defending both approaches and saying both are better. Comes down to the best tool for the job, I guess.
&gt;like comparing apples to oranges yea well for many things in life this is the best we can do with the current progress of tech, innovation, etc. so just gotta make do there's no better way of doing this 
&gt; static vs dynamic - it all depends on the use case ok well if someone is able and equipped to afford analogies to everyday life on a conceptual level of a ELI5, that would be good would like to understand this key and main part of the question/post this reply wasn't using analogies so it was pretty confusing and vague, but im sure that this question would get answered by someone
the way of going about it via 'based on the problem' is already said in the main post, * and i understand taht viewpoint as already expressed as for the opinion on 'vague questions' my reply is that someone that broadly knowledgable would be able to answer those questions sufficiently * this is evidence in the quora link, and many many many other similiar 'supposely vague' questions which makes tons of sense to other ppl * tho i understand its not a good fit for certain other ppl and therefore those ppl would be unlikely to be able to help with those types/kinds of questions 
on the point of 'context', my simple reply is that there are many many types/kinds of questions that seem like they're 'without context', * but in my experience, they actually have tons of context but perhaps you dont have the umm 'right'? kind of person making the interpretation, and they likely had missed all the context * every single question is defintely answerable in some helpful form or another (at least based on what i've seen)
just to be clear...[in an earlier thread you asked](https://www.reddit.com/r/Kotlin/comments/84ltdj/deciding_between_kotlin_or_typescript_going_to/)... "deciding between Kotlin or typescript: going to base it on learning resources. what's the most helpful learning material on the web?" My exact response... "So if the **amount** of learning resources is really what you are basing your decision on then hands down go TS." My response was not referencing the **quality** of learning resources but the **amount/quantity** of learning resources. I also was speaking specifically towards learning resources focused on using Kotlin for web development - which is what I assumed you were asking about since you were comparing Kotlin against TS which is used primarily for web development. Hope that helps to guide you towards a better decision, good luck!
[Read this story](https://testing.googleblog.com/2010/07/code-coverage-goal-80-and-no-less.html). You are the third guy. There is no simple universal answer.
&gt; The way you create threads is confusing. agreed, almost sounds like an AI bot
What am I doing with my life? Enough Reddit for today, good luck searching for answers.
that good link, um (havent looked fully at it yet so shouldnt say that), seems like a good link i meant, fairly recent 2 months ago, ill take a look over it and maybe others have more to add * my impression says it seems liek its a good link tho i dont actually know --- as for 'basic concepts', lots of 'basics' are shown and explained on reddit, --- lastly for the 'question assumes' s-type is better than d-type, that again is factually erroneous statement. here's why: * asking a question presupposes nothing * it is always the interpretation that makes the assumption onto someone elses question * i am the author/maker of the question so im the primary source of any direct assumptions made or given * in this particular/specific case, a question does not bear any assumptions until someoen else inaccurately or accurately assumes it, again, onto the question * if it is your opinion that s-type is not better than d-type, then the simple answer coming from you or related would be simply 'it is not better' * but however that would be not be a helpful answer to the question * but it was explained or shown why its not better, that could add some insights * but in almost every case in this universe, this is typically/usually/tending towards a better * so while it may not be the case on this sub-topic/question, when it comes to better and best, it is the case for the majority of cases out there across all topics in this universe * in the event a person doesnt know the answer, or know how to find a helpful answer, it's typically better if they dont reply * tho again, like you said, finding if X is better than Y and/or Z is commonly a difficult process/thing/action * and that applies across the levels of abstractions (yes that's me explaining a basic concept of communication, specifically on the subtopic of assumption, right before)
Why don't you just use an [EnumSet](https://docs.oracle.com/javase/7/docs/api/java/util/EnumSet.html)?
that good link, um (havent looked fully at it yet so shouldnt say that), seems like a good link i meant, fairly recent 2 months ago, ill take a look over it and maybe others have more to add * my impression says it seems liek its a good link tho i dont actually know --- as for 'basic concepts', lots of 'basics' are shown and explained on reddit, --- lastly for the 'question assumes' s-type is better than d-type, that again is factually erroneous statement. here's why: * asking a question presupposes nothing * it is always the interpretation that makes the assumption onto someone elses question * i am the author/maker of the question so im the primary source of any direct assumptions made or given * in this particular/specific case, a question does not bear any assumptions until someoen else inaccurately or accurately assumes it, again, onto the question * if it is your opinion that s-type is not better than d-type, then the simple answer coming from you or related would be simply 'it is not better' * but however that would be not be a helpful answer to the question * but it was explained or shown why its not better, that could add some insights * but in almost every case in this universe, this is typically/usually/tending towards a better * so while it may not be the case on this sub-topic/question, when it comes to better and best, it is the case for the majority of cases out there across all topics in this universe * in the event a person doesnt know the answer, or know how to find a helpful answer, it's typically better if they dont reply * tho again, like you said, finding if X is better than Y and/or Z is commonly a difficult process/thing/action * and that applies across the levels of abstractions (yes that's me explaining a basic concept of communication, specifically on the subtopic of assumption, right before)
&gt;towards learning resources focused on using Kotlin for web development - which is what I assumed you were asking about since you were comparing Kotlin against TS no it's just a question out of ignorance pretty much, i also seen that qusetion somewhere but the previous question was pretty much answered sufficiently enough so that was taken care of
Good suggestion, thank you.
I love things like this. It's like confirmation for the tools and languages I already use and a shopping list for the ones I need to look into.
Its a matter of preference -- I like the easy to read flow that results from chaining; reduction in callback boilerplate and freedom from callback hell. 
Still at the core you are using the same concepts and building additional library introduces overhead by creating a wrapper at the cost of "better" readability. In the end it's just calling the same methods but through different chains which results in worse performance in the end even if the numbers are insignificant.
to be honest, I know it'd be more idiomatic, but I don't like the syntax in Kotlin: `val noneOf = EnumSet.noneOf(Permission::class.java)`
Also, the experimental async/await feature in Kotlin is not unlike that in JavaScript; syntactic sugar over executors &amp; futures, but cleans up code, makes it easier to maintain. 
I don't personally see the value of re-inventing the wheel by adopting a new framework written in Kotlin. Purism? You're going to be pulling in Java libraries anyways. We've been writing Dropwizard services in Kotlin for over a year now and get the benefit of a well documented &amp; maintained platform with the awesomeness that is Kotlin.
Hi there thanks for commenting. It's not about re-inventing the wheel or anything like it. I started using Kotlin sometime ago for Android and after starting writing about it always got the idea of write one article about backend implementation. Did some research and this framework came up and looked nice so decided to give it a try. Not saying it's better or worse than A or B it's just nice and was easy enough to understand at least for the purpose of my article which is a very simple example. Coming from Android being able to set it up so quickly with just a couple of gradle dependencies attracted me plus with that can have it running easily inside an app. I'm sure there are other frameworks out there that can do the same or even better, it was about picking one that I liked and did the job for my article.
I wasn't meaning to throw shade at your blog post, sorry if it came off that way. I agree Kotlin is great on the back end. I just find it weird that all of these from the ground up Kotlin frameworks are popping up. 
Not really was just trying to explain my choice as well. I guess it's a natural process you'll get people try to build all type of things with new languages, frameworks is just one of them. It's good I think, the more options the better and you end up finding nice things sometimes.
No man no one's being a dick. Thanks for commenting in the first place it's good to have other perspectives
What's the use case for this over say, Kotlin coroutines?
Fair enough.
Might be . Some people have no clue how Reddit works and how to reply to people tho. I've experienced it a few times
I rather put all those parameter in a data class and make it parcelable either via Kotlin `@Parcelize` or something like AutoParcelable (I'm liking this one, a lot), PaperParcel, Parceler etc. But if you don't want to go that route, just create the Intent serializer or deserializer yourself. In your current implementation, it's still fairly brittle since your companion object had to know what to put in there and mangle it all the way through on the call site. Instead of doing all that, just deserialize the intent properly and decide what is what from there. Embrace nullability. Kotlin turns null as a first class citizen. Your situation is the right time to use it.
Here's the story: We are building Android and iOS app. We prepared the whole system specification in BDD style. I wanted to have tests results output exactly as BDD stories, so made cosmetic changes and prepared helper class to provide Given, When, Then methods within Spek scopes. Lately I was about to use extensions in another project and decided to make code public. I'll be glad for any feedback.
I'm not following, how would those approaches help deal with the issue of an optional parameter that can be **either** a String or a ResourceID?
This newIntent function looks pretty complex already. If you really need this flexibility you can incapsulate logic in class like this: sealed abstract class Resource { companion object { val empty: Resource = Complete("") operator fun invoke(text: String): Resource = Complete(text) operator fun invoke(id: Int): Resource = Contextual(id) } abstract fun inContext(context: Context): String data class Contextual(val id: Int) : Resource() { override fun inContext(context: Context): Resource = context.getString(id) } data class Complete(val text: String) : Resource() { override fun inContext(context: Context): Resource = text } } And now your function will look like this: fun newIntent(context: Context, title: Resource = Resource.empty) = Intent(context, TYPE).apply { putExtra(TITLE, title.inContext(context)) } Usage: newIntent(context, Resource(id)) If you don't like magic with overriden invoke functions in companion you can simply replace them with normal functions: fun new(text: String): Resource = Complete(text) newIntent(context, Resource.new(id)) Or just call constructors directly: newIntent(context, Resource.Contextual(id))
It doesn't. Those approaches precisely do not deal with that. In those approaches, you put them both as a valid property in the data class. data class FragmentRequest( val resourceId: Int? = null, val title: String? = null, val otherStrings: String ) : Parcelable Hence, your newIntent is a single: fun newIntent(context: Context, fragmentRequest: FragmentRequest) : Intent { // put into extra etc etc } At deserialization site, you get to choose the defaults in case of null/blank etc etc. fun onCreate(){ val request: FragmentRequest = getIntent()/getArguments().getParcelable() //display based on request } I don't see a reason why the need to deal with ambiguity at all. 6 months and maybe a year from now, you'll be asking yourself the same question when looking at multiple `newIntent( insert more and more parameters )` and wondering whether all 'states' is correct passed or not. I strongly suggest to save yourself the headache and simply do it in proper OOP.
Actually if I flip the null default it gets me the blank title functionality: fun newIntent(context: Context, a: String, title: Int? = null, b: String? = null) = newIntent(context, a, title?.let { context.getString(title) }, b) fun newIntent(context: Context, a: String, title: String?, b: String? = null) = Intent(context, MyClass::class.java).apply { putExtra(A, a) title?.let { putExtra(TITLE, title) } b?.let { putExtra(B, b) } } 
I tend to disagree here. Suspending functions are more than syntactic suger because they do things the language user can not do. Also, there are no usage concepts introduced in first instance. The async await stuff is built upon this and has really nothing to do with futures.
Good article, though I find the use of `check` a tad unintuitive to read, having a syntactic familiarity with `if` statements: check(aBool) { // Enter if aBool is false } Compared to if(aBool) { // Enter if aBool is true }
This factory is for a library where I don't want ambiguity. You either specify a title using a string, or a resource id, or you don't specify a title. Being able to specify both a string and a resource id is exactly what I want to prevent. In the Java world I used a builder pattern with two mutually exclusive interfaces (one that allowed a string, and one that allowed a id), I'm trying to replicate the functionality in Kotlin. 
Then you have to go with /u/Meztihn solution. Encapsulate the parameters in multiple data class and utilize a sealed class. The library user can just check the type via `when`.
I stand corrected. Coroutines (and async/await) are much more light weight than threads (and futures) given the language level support (w/dispatchers), ironically bring them closer to the JavaScript execution model where a few threads can achieve high concurrency (when they're largely IO bound).
Hm, maybe i'm ignorant as always, but i don't get why it would be better for anyone to have a es compatible solution done by whoever on github, while there are coroutines that fit perfectly into the language, have compiler support and give the best performance. "Experimental" state of coroutines does Not mean they are some kind of beta or anything. They are meant to be used in production, but jetbrains wanted to be able to introduce design changes (which now are very very unlikely to Happen, though, they are present since 1.1) more easily.
I don't see why writing a backend in Kotlin wouldn't be possible so I feel that the title of the article is kind of weird. If you take a look at the direction of prominent backend technologies in the Java world it is obvious that Kotlin adoption is growing rapidly. Just to name a few: - [Introducing Kotlin support in Spring Framework 5.0](https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0) - [Spark Kotlin Released](http://sparkjava.com/news#spark-kotlin-released) - [Server-side Kotlin with Eclipse Vert.x](https://developers.redhat.com/blog/2017/10/13/server-side-kotlin-eclipse-vert-x-javaone/) A lot of backend libs are being adapted to be used from Kotlin and most of those folks are really enthusiastic about the prospects of writing less boilerplate. I also agree with u/RhodesianHunter. There is no point in reinventing the wheel. I don't think that it would be useful to write a Kotlin lib for everything since the coop between Kotlin and Java is a joy to use and most popular Java tools are battle tested and well documented. Learn from the failures of Scala. In the case of [Ktor](https://github.com/ktorio/ktor) last time I checked the docs were pretty lacking and coroutines are an experimental feature. It does not perform well on the [Techempower Benchmarks](https://www.techempower.com/benchmarks/#section=data-r15&amp;hw=ph&amp;test=plaintext) either. I'm not against pioneering and innovation but for production, I'd rather use something which is well established.
While I agree that they're not needed everywhere, they should be used at entry points to logical components of a service that can be called from various locations in the service. For instance, the data access layer of a service should have checks that the overall service entry point may not verify. This also allows those checks to be invoked only if the code happens to go that route.
Yeah that surprises me. I work in C#, JS/TS, and Python, and I really really love C#, maybe even more so than JS. C#'s lower showing was kind of shocking to me.
Again for the purpose of the article which is a very simple example suited quite well with the plus of the gradle application allowing me to easily integrate it inside an app. I'm not saying it is better or worse than anything out there and already agreed that for a commercial product maybe going with something more mature is better, not that I said the opposite in the article. Regarding Ktor and other frameworks I still think it's nice for people to invest time and build them. It generates discussion about the language and tools available and we have to take the positives out of it. The frameworks you mentioned didn't born ready and stable good to use in production, someone had to make the decision of let's build this framework and then take it to the level they are now. Btw I have no connection at all with Ktor or my article was intended to advertise it somehow, I just felt it suited my article content very well so decided to go with it.
Failing fast is precisely what these checks allow your code to do. Unit tests on a particular component can be as thorough as you want, but when integrating with the rest of the service unforeseen data and control flow patterns can arise. Having these checks in place can ensure your service fails in a deterministic way.
Pfuu..just re-read my comment..thx for reading through all the typos without complaining. 👍 Failing fast is one of the greatest things but an assertion or a nullpointer will have the same value for an internal project. I'm def. not arguing a gainst this checks..what i'm saying is check when it makes sense..doing it all over the place is bad. For the most part I think we are in line and that is the important part.
Java isn’t a terribly difficult language to pickup though. There is some interop depending what you want to do but for the most part you are calling Java classes from Kotlin which itself is no different from calling a Kotlin class from Kotlin.
Option 4: if it is some java library you have control over, annotate your code with @Nullable or @NotNull from jetbrains for instance, and kotlin will correctly use Object? or just plain Object types there. (And as a bonus, intellij or sonar will do smarter null checks in your plain java code as well) Complete list of supported annotations are here: https://kotlinlang.org/docs/reference/java-interop.html below nullability annotations
Also posted a comment on the article, but will post here too. Just use `fold()` from Kotlin Arrow's `Option`! result.toOption().fold({ // code if the value was null }, { // code if the value was not null }) This allows for handling the null case too.
Tbh I don't see how this is any different from using if-else.
I didn't look at the Arrow docs, but from a functional programming POV, it *should* force you to handle the null and not null case (ie: you must provide both funcs in order to call fold()) whereas you if you were relying on if/else, you could always forget to handle one of the cases. By using options, you're also being more explicit about the semantics of the code. The other benefit would be the ability to pass externally provided funcs to fold, since functions are first class citizens, rather than having to define the handling logic inline. You could do that with if/else, but it'd probably read more cleanly as something like fold(onSuccess, onFailure)
 var result = someJavaApi.doSomething() // returns SomeType! result?.let { someKotlinApi.doSomething(it) } // someKotlinApi.doSomething expects SomeType &gt; The above piece of code compiles perfectly and solves the problem with platform types. The magic lies in the fact that let will be called only if the value of result is not null, otherwise the call to it will be skipped altogether. I guess it depends on the usecase, but it seems to me that very rarely would you ever want to "do nothing" in the case that someone passed `null` to you. `someKotlinApi.doSomething(it)` presumably performs some sort of side effect (since you're not inspecting its return value), and "silently not doing the side effect" seems even worst than throwing `NullPointerException` in the vast majority of cases, morally akin to: Result result = someJavaApi.doSomething(); try { someKotlinApi.doSomething(result); } catch (NullPointerException e) { //Ignore and proceed } 
To condense the post a little, your problem is that this isn't valid: ``` interface I&lt;out T&gt; { fun get(def: () -&gt; T): T } ``` That can't work just because of how assignability for wildcard types works, you could break the type system with it. I don't know if this is possible with an instance function at all but probably not for the same reason. What you can do is write it as an extension function.
&gt; What you can do is write it as an extension function. Is there a way to write abstract extension functions? Ideally, I'd like to "declare" the function on the `Either` type, and then implement it in `Left` and `Right`.
Since it's a sealed class, you should be able to simulate abstract functions like this: fun Left.get() { /*Left implementation*/ } fun Right.get() { /*Right implementation*/ } fun Either.get() = when(this) { is Left -&gt; get() is Right -&gt; get() }
You could just remove the `out` modifier before the type parameters to make this possible. That modifier makes guarantuees that would be broken by using it like you want to do. Or do you have specific use cases that require the modifier?
Yes, you can, this is valid: abstract class Bla { abstract fun String.myPrint() } and they can be used on interfaces as well. 
Thanks :)
In Swift you can define method argument names so you could have`MyList(from: ...)` as an alternative to `MyList.from(...)`. Kotlin cannot offer this due to compat with Java though :(
I'm not entirely sure if I would use this. In their example what if I had a function called `append` defined outside and it happens to clash with one of the methods in the scoped call?
Ah you're right, I didn't read the context, sorry :)
Maybe I'm totally wrong here, but isn't this one of the problems that arise heavily when one tries to model higher kinded types? I think the problem is that one needs to introduce a second type parameter like interface I&lt;out T, in X:T&gt; { fun get(def: () -&gt; X): T } in order to not "loose" the more specific type. Please correct me :)
Do you mean named arguments? Kotlin has them, if so. You can use it like MyList(from = ...)
Ah yep named arguments is a better name :) Yep, you *can* use them but it's not mandated when calling the method/constructor so nothing to prevent others from just dropping the name. 
I wouldn't advise this, but you can do class Void { private constructor() } fun test(vararg v: Void, named: Int) { println(named) } Funny enough, it's similar to how python can force named arguments def test(*, named): print(named) where `*args` gives you varargs but just `*` forces named arguments.
Factories, yes. Static, no. Make them regular instances and have them injected via DI. 
That's a really neat trick! Didn't know about either Kotlin or Python. Agree I wouldn't use this in production code but still really cool to learn about this. Thanks!
Obviously. No one in his sane mind would transition any codebase to kotlin. The benefits are literally null.
No it won't.
Yes, this is one way to model it, allowing you to "retain" the type. But at that point you might as well drop the wildcard altogether :)
And that's a very good solution that is more a Feature than that it hast anything to do with java limitations. Most of the Times you don't need Parameter names and they Just clutter your code. They are helpful if you Want to use stuff as a DSL or when you have special parameter combinations that are difficult to follow.
Kotlin doesn't have static method on interface because Java was designed in pre-generics era and Kotlin inherited. I think that's the worst limitation from Java.
I think you misread his comment.
I think DI is created for the languages that doesn't have the polymorphism of static methods.
This is only a very tiny subset of what DI enables. 
Because static methods can't easily be tested in different environments. 
So I'd guess you'd use DI to ensure the factory is effectively a singleton?
Yes. And DI would also ensure that the factory creates the appropriate instance depending on the environment or other factors (e.g. a staging DB while testing, production DB for deployment, etc...). 
Java bytecode identifiers - as opposed to Java language identifiers - can contain some extra characters, like spaces. Kotlin exposes the ability to use these extra characters by \`: when you surround method's name with backticks, you can provide a name that would be otherwise rejected. This isn't very useful in regular app code, but it comes in handy in tests: \`this is more readable\` thanThisUsualSyntax.
What's your favourite DI solution?
It's main use is for escaping java identifiers in kotlin. Like if you're using a java class that has a method named `is` which is a keyword in Kotlin. https://kotlinlang.org/docs/reference/java-interop.html#escaping-for-java-identifiers-that-are-keywords-in-kotlin It also happens to be useful for more descriptive test methods. https://kotlinlang.org/docs/reference/coding-conventions.html#names-for-test-methods
why only in test ?
Thanks. 
I think it's more than that. In DI, You can inject dependency at constructor. &gt; class Foo(val bar : SomeInterface) But this approach may need detailed information about what Foo need for the caller to construct the concrete class of the SomeInterface. And it may need unsafe downcast even though the caller already know what it really is. &gt; val foo = Foo(SomeConcreteClass()) val bar = foo.bar as SomeConcreteClass Instead of that, you can inject type T if there is the polymorphism of static methods. &gt;class Foo＜T : SomeInterface＞{ &gt; val bar = T.create(detailedDataWhichShouldNotBeKnownByUser) &gt;... &gt;val foo = Foo&lt;SomeConcreteClass&gt;() &gt;val bar = foo.bar 
For Android, Dagger. For the back end, Guice. 
DI lets you wire all these instances automatically if that's what you want, or you can intervene manually here and there whenever you need to insert a specific instance (e.g. polymorphic) in your object tree. DI is a universally useful concept, especially since there is little reason to bake such mechanisms in the language when this can be achieved with a library approach.
Dagger 2 on the back-end &gt; Guice.
Not when you make heavy use of assisted injection. 
There's a third option: outside the class in file scope! But if you like the semantics of putting it inside the class somewhere out it outside the companion object. This is correct because think about how the JVM actually represents it. Inside the class it's just a static inner (enum) class. Inside the companion object it's a class inside an instance of an object that is itself a singleton instance of an inner class inside your object. 
You're right, putting it outside the companion object makes more sense. Also it makes it easier to access it outside the class too. I'm not sure about the third option, because ABO Groups are a part of Blood Types, I don't know if it makes sense outside that context.
But you can make the abo enum package private.
As a Java developer and Kotlin fan I say thank you. This is a good explanation of why data classes are not (only) for lazyness. I always get “are you lazy to generate those damn getters and setters?!” as a response... I’ll have to read your previous posts to understand why do you “hate” Kotlin, but I’m pretty sure that if you dig deeper, you’ll find other Kotlin features you like :)
You're welcome. I do have other Kotlin features I like already. For example, I really like the variable interpolation in strings (or whatever it is called) - missed this feature since Perl days. It is just that most of these are rather personal and small quality of life improvements and I don't think that they make a real difference. BTW, thanks for the feedback.
I think you can use a “qualified this” to disambiguate.
Really nice! I have a project in mind for this but probably won't be able to start it for a while, so I hope you keep it up! Any chance of a similar thing to expose Java objects to VBA so we can do similar tricks with outlook?
Please try again. It should be up now. Thanks
Still not working
It seems Medium was having issues this morning. Hopefully that's all sorted out now. I just tried it and it was much faster and actually loaded the images
Oh, I see. Then I'd go the "outside" way. p.s. Didn't yet write anything in Kotlin
No package privacy, sorry
And any defects that do show up tend to get fixed and are available to everyone immediately. Java fixes, well, who is on Java 9? Not everyone can move to the latest Java that easily and benefit from its latest features and fixes.
Yes, sorry. It is fixed now
Kotlin also allows named arguments. You can make class MyList(val from: List&lt;Int&gt;) // Usage MyList(from = listOf(1,2,3)) Still this are different things
Yep, but their use is not mandated unlike Swift. This makes the difference for readable code. 
I love Kotlin, but I'm not sure about some of these Java defect claims. For example: // Java // This check is accidentally circumvented by a null value if (Boolean.TRUE.equals(isSuspiciousAction)) reportToAuthorities(); I tested this over at [Java REPL](http://www.javarepl.com/term.html) and Java handled null [just fine](https://imgur.com/a/L1u79).
Not that I don't like Kotlin but the article is quite one-sided and doesn't even try to look at the other side of the coin: guarantees you lose when switching. E.g. checked exceptions. I'm sure there's more. Would have liked that and would love to see that in the promised history analysis article as well.
Huh?
The same as in Java. You don't test encapsulated functionality. You test the `AlarmManager` as a whole. See [this](https://stackoverflow.com/a/3299443/5543884) SO post.
No, Java doesn't silently handle null as false. `null` just isn't equal to TRUE in the example: ``` jshell&gt; Boolean x = true; x ==&gt; true jshell&gt; if (x) System.out.println("yes"); yes jshell&gt; x = null; x ==&gt; null jshell&gt; if (x) System.out.println("yes"); | java.lang.NullPointerException thrown: | at (#4:1) ``` The only reason you would use this super weird boolean comparison is *if* `isSuspiciousAction` could be null and you wanted some shorthand for `isSuspiciousAction != null &amp;&amp; isSuspiciousAction`
It seems like it'd be smarter to test the code I wrote rather than the Android framework, no?
I'm not. The code you had shows it. Semantically, Boolean.TRUE.equals returning false for null is the same as silently handling null as false. And you've never heard of Hibernate I'm guessing, or Spring, or a million other things where sometimes you have to use a non primitive to get things to work. Real code in the real world has Booleans, and rarely is null a meaningful value for them, but it is legal and it is the cause of issues.
Groovy with Spock can test Java private code. I think it might be able to with kotlin too?
I'm not recommending this, but to answer your question, you can use reflection to invoke private functions, and it would look something like this: val result = MyClass().let { it.javaClass .getDeclaredMethod("getNumber") .apply { isAccessible = true } .invoke(it) } ...where MyClass has a private function called getNumber(). But usually in this kind of case, I'd prefer creating a new class that can provide the alarm time by way of a public function, and pass that object into the constructor via dependency injection. Then you can mock out that joker for your tests.
That still has a more of drawbacks compared to exceptions, like more convoluted code, no implicit stack traces, no standard library support. 
Specially Android devs. Oh well, I just installed Java 10 on all my systems, except for Android devices.....
I thought Kotlin has a notion of package privacy, like java, but it hasn't
I'm surprised nobody's tried to port Guice over to Kotlin, actually. It's incredibly useful.
Kotlin unfortunately adds some new error categories, like * accidentally calling the unary plus operator instead of the addition operator because of line breaks and optional semicolons * not executing this "code block" // if(something) { bla(); } and similar stuff that works different to Java and confuses people and often has no clear IDEA inspections * not enforcing the handling of IOExceptions and so on * forgetting calling trimIndent() or similar functions because of bad literal management * beginners tend to create lots of spaghetti code because of the more functional style * abusing nullability where real exceptions with error messages and stacktraces would be more useful * confusing behaviour of the += operator with mutable and immutable lists (sometimes, it adds to the list and sometimes it returns a new one depending of declared type and var/val.
What do you mean by "better"? If you're talking about performance, 99,9999% of cases it won't even have any difference at all (remember, micro optimization is evil). Syntax-wise, it has more characters to type. If it's a constant String, you could also use: const val mode = "Example" It would make a difference if it's a class property, and you're serializing instances of that class and you don't want to include it in the result, for example...
I don't think I can use const for what I'm trying to do. E.g. enum class TrafficLight { RED { override val light get()= "Red" }, YELLOW { override val light get()= "Yellow" }, GREEN { override val light get()= "Green" }; abstract val light }
Some clarifications about this defect category: * A null pointer exception is not expected. The code will execute "normally" * This isn't trying to say that null is equal to false or that Java treats null as false * The true essence of this defect is that most boolean conditions involving Boolean wrappers are tested against the positive case (true). Because of this, having either Boolean.FALSE or null will both result in the same behavior. Here's an example that's part of the standard Java library: https://docs.oracle.com/javase/7/docs/api/java/sql/ResultSet.html#getBoolean(int) Note that this returns false if the column value was null. Everyone uses ResultSet when retrieving data from a database. This type of behavior where null is interpreted as false is very common in Java codebases.
&gt; confusing behaviour of the += operator with mutable and immutable lists (sometimes, it adds to the list and sometimes it returns a new one depending of declared type and var/val. Can you give us an example where var/val changes the meaning of the code?
And exceptions should be used for exceptional states, not for control flow
Exceptions should not be used for control flow, thus checked exceptions do not have a use-case in a modern language (apart from working with the java stdlib)
Yes, just test your own code and assume that the Android framework already has good test coverage. Refactor your NotifcationHelper class so AlarmManager dependency can be injected (lookup Dependency Injection or Inversion of Control) and mock AlarmManager so you can test for side effects (e.g. called methods on the AlarmManager mock).
Your usage of open/override is wrong. "Open val" means a subclass may "override" the implementation of the property. Enum members are not subclasses, but instances of the enum type. You can just put in the arguments like i showed above e.g. RED("mycolor")
Sure. val set1 = mutableSetOf&lt;String&gt;() set1 += "abd" var set2 = mutableSetOf&lt;String&gt;() set2 += "abd" var set3 = setOf&lt;String&gt;() set3 += "abd" The first block adds to the existing mutable set, the second block doesn't compile and the third block creates a new set and assigns it to `set3`.
&gt; Exceptions should not be used for control flow, thus checked exceptions do not have a use-case in a modern languages What? Being forced to handle IOExceptions isn't control flow, it's handling exceptional cases. Nobody says that checked exceptions should be used for control flow. Yes, checked exceptions are sometimes used incorrectly, even in the JVM core libraries, but in Java they're still useful. I can see why they don't work nicely together with the more functional Kotlin style, though.
The meaning of the code doesn't change just by replacing val/var (it won't compile anymore ^^) But the different behaviour of different Types isn't strange at all. The same can happen to you with Java 10 and local type interference. The behaviour of `var items = new ...` is different for `Stack` and `Queue`, although they share some methods
IOExceptions as I said. Say you read a file in a specific format. The low level parsing functions should just forward the IOExceptions or even generate new ones if the file isn't parseable according to the standard. And then somewhere in the GUI layer or wherever you're being forced to catch these exceptions and display an error dialog or whatever. This works much easier and less complex than piping Result-Objects through your whole method hierarchy.
You're missing my point. We have to handle IOExceptions and them being unchecked in Kotlin may introduce a new source of bugs, namely not handling them when they should be
 try { return readFile() } catch(Exception e) { createDefaultFile() return readFile() } try/catch you changes the control-flow //Inside GUI-Layer try { readFile() } catch(Exception e) { alertUser() } Again control-flow. Furthermore Checked Exceptions introduce more problems. The following code doesn't work: @Throws ArithmeticException public int div(int a, int b) { return a / b; } myList.map(a -&gt; div(a, 12) //Doesn't work, because map has no @Throws
What about Kotlin's "internal" visibility? If that's exactly what you want, it's not a bad practice. Otherwise, extract a testable unit for your alarm, alarm manager stuff and make it injectable into your using class, inversion of control style.
&gt; Again control-flow. Of course catching exceptions changes the control flow. But it's not used for control flow. When books say that you shouldn't use exceptions for control flow, they usually means something different, in the worst case something like catching IndexOfOutBoundsExceptions in a for loop instead of checking the array length.
&gt; The meaning of the code doesn't change just by replacing val/var (it won't compile anymore :D) I didn't say that. It changes by replacing var with val and by additionally using MutableSet instead of Set. &gt; But the different behaviour of different Types isn't strange at all. I think this behaviour is strange, especially as MutableSet is a direct subclass of Set. It's not intuitive that you can break the code by specifiying a more precise type for a variable. It's also unintuitive in that you need to check both variable mutability and the precise type of the Collection to figure out which += overload is used.
The second example is debatable, but the first example is using exceptions for control flow. If the program can handle the case of wrong file-format itself, how is it an exceptional case then?
&gt; If the program can handle the case of wrong file-format itself, how is it an exceptional case then? I don't understand what you're trying to say? You generally want to handle exceptional cases, so that the program doesn't crash. If you devel say a text editor (like MS Word) you don't want your program to crash when the user is reading a file from a network share that goes offline. So obviously you want to handle that, but it's still an exceptional case and not intentional control flow.
recalculate the variable? I don't follow, sorry.
For example, I have 2 values: ``` val foo = 1 val bar get()=foo*3 ``` Now the value of bar is dependent on the value of foo and whenever foo's value is changed, so is bar which is what I meant by recalculating it.
Ah, I can see where the confusion comes from. I'm not even sure it would help if they were unrelated interfaces, because they both have *Set* in their name.
There are other DI libraries available for Kotlin. By port, do you mean make it more idiomatic Kotlin, or does it actually not work from Kotlin?
Sorry, yeah I meant have a version of it that's more idomatic. I imagine that one could import it as-is like with existing Java libraries. Just curious -- what are the other dependency injection frameworks that exist for Kotlin? Do you have a choice favorite?
I haven't happened to write anything yet that will get use out of DI, but just from looking, there are a few like [kodein](https://github.com/SalomonBrys/Kodein), [koin](https://github.com/Ekito/koin), and [kapsule](https://github.com/traversals/kapsule). If I had to guess, I'd say all are lacking some useful features from a more mature library like Guice, but it's good to see the area being filled.
Great! I hope to see more of these get created as Kotlin gains credence and a wider user base. It would be amazing to see something at a production level like Guice (or Mockito).
The field should be final in the second case :)
The original condition given was "is True equal to Null" where both True and Null are in the Java type system. Java as expected returns False, as they are in fact not equal. In ResultSet::getBoolean there is a mapping of SQL types to Java types. The Java code is explicit about how it handles these different type systems, and specifies that it maps the *SQL* Null to Java's False. This example is different from the first one in that there are two different type systems invovled, and again I think the Java behavior is good. How is Kotlin any better in this example?
Java doesn't interpret a null Boolean as false. The provided code wasn't testing that either. It's testing if Boolean.True equals null. [This](https://imgur.com/a/IN396) does test that statement, and proves that Java doesn't allow null as a condition.
Ok, yes, I get that. But neither I nor the article are talking about it the way you are. We're talking about it treating null as false *in the context of the .equals call*. **Semantically**, using Boolean.TRUE.equals is the same as treating a non-primitive Boolean null as false. It is impossible to tell at a glance whether that was by intention or not. You can also use !Boolean.FALSE.equals, which at a glance seems the same, except now null is treated as true. null very rarely has a valid meaning when using Booleans, but these ways of checking the value implicitly apply a meaning to null that the programmer may or may not intend, and the next programmer to see it may or may not understand that intention. The point the article is making about this isn't about what the compiler does, but about what mistakes programmers make because these things have behavior or intention that isn't immediately obvious.
&gt; Aleksey Shipilev tweeted once about a guy who wrote Java programs instead of Bash scripts. That would probably be the extreme case of what you describe here. I'm not saying that it is always a bad idea to use a single language for everything...might work well in some cases. I'm only saying the attitude not wanting to learn or even consider using a potentially better tool for the job is bad. &gt; This is probably a matter of personal taste. For example, I don't like the elimination of checked exceptions at all. No I don't think so. It's a matter of experience and being able to recognize the short-sighted view of the feature and it's high risk to worsen codebases. But I guess you are on the "wrong" side (as I was many years ago too). Even the language designers and Java's masters tend to not recommend checked exceptions, but Java can't get rid of it because of backwards compatibility. The last 20 years showed, that checked exceptions, as a way to encode typed exceptions in signatures, is suitable only for *small* projects, but tend to worsen larger codebases (some mentionings https://www.ibm.com/developerworks/library/j-jtp05254/index.html). There's currently a discussion going on in https://www.reddit.com/r/Kotlin/comments/85s2l2/kotlin_avoids_entire_categories_of_java_defects/ . Functional programming solves the problem with result classes, go solves it with multiple return values and literally no other language than Java has checked exceptions. It's not a matter of opinion, it's a matter of experience here. I like checked exceptions in very rare cases, but to be honest THAT is a very good example for a feature that causes more harm then it gives benefits. And nearly everyone agrees, so people have to let go. &gt; That's probably a matter of personal taste too. Once in a while I encounter a use case when I say "I wish I'd have a first class function". But then I imagine how this mechanism could be abused and the realize that I prefer to write a bit of boilerplate instead. That is the kind of insane statements that make discussions about Java stuff so annoying. It's like you would say "Classes can be abused, so I prefer to not use them". Classes and functions are literally the basic building blocks of every oo language and Java already hes them. The purpose of functions is always the same, only that you can't do things as nice in Java because there is no proper notation for it. And it hurts really bad for example for those functional style things that came with Java 8. Again, Java tried to include all these things, so there's no "better leave it out" any more. The decision is done. Having functions as first class elements in the language doesn't hurt anybody - abusing functions does. And this is possible with or without first class. Those functional interfaces are workarounds for missing first class functions. &gt; For me it would eliminate just GitHub's Immutables with Data Classes. As I said. If you are honest, you don't see the benefits because you got used to solving problems the Java way. Data classes is only one aspect out of 10 that are clearly better in Kotlin. All in all I'm a bit afraid why everyone wants Kotlin to replace Java. It clearly won't happen soon and it's not nessecary - Kotlin and Java can be mixed in projects so flawless, that one can literally start using Kotlin now and everything will be fine. There is nearly (!) no risk and a ton of benefits, so why not just do it, and like everyone else....learn to love it in days and go on using it.
&gt; I meant to say that Aleksey Shipilev's tweet supports your point. In fact, he made laugh of that guy (anonymously). I think that we can safely say that is always a bad idea to use a single language for everything. Yea, I got this :) TBH I like the idea of having a limited ecosystem... for my company, it would be perfectly fine to use a single language exclusively for all projects. And I would be happy if it would be Java. Since in my company, we don't do rocket science or too complex architectures, so Java would be a very good fit. And having uniform build systems, uniform production and test vms, uniform ci tools, uniform technical support for the systems could be an advantage over having the luxury of using different languages. But hey, it's not like that anymore, so everyone has its own opinion and favorite language, and as long as I have to handle JavaScript in the backend, I have bigger problems :) &gt; So, having an option to use checked exceptions is bad, but having an option to use first-class functions is good. It comes across as a bias TBH. Functions (by default are first class citizens of languages, just not in Java) are widely accepted basic building blocks in oo languages. Checked exceptions are not, they solely exist in Java. Nowadays not even exceptions are an undoubtetly basic building block, so yes, I think it makes a huge difference. That's probably the reason why Kotlin handles this differently than Java: Because it has been proven that it's a better decision to leave them out. I would correct your quote to "Nearly everyone agrees that checked exceptions are mostly bad". I'm with you, the intention is a good one. And in limited cases where you might be the only developer in your small project, or for 0.1% of exceptional cases it makes sense to use them. But since they worsen another big, more important part of codebases (for example the functional stuff), it's a better decision to dump them. Like Kotlin seems to always decide on features: Is it the best option, despite there are some rare cases where you have disadvantages. Like Java's philosophy, it's asking for the majority of the cases, not the rare ones. So, thanks for listening and the fruitful discussion, enjoying the exchange.
Look to sealed classes for something like that
Aaaand done! https://github.com/Kevinpgalligan/Kotlex/commit/3e074c79fd43d3de2003c920e5c6533ac4ffa31f
Here you go [https://medium.com/default\-to\-open/kotlin\-tips\-singleton\-utility\-functions\-group\-object\-initialization\-and\-more\-27cdd6f63a41](https://medium.com/default-to-open/kotlin-tips-singleton-utility-functions-group-object-initialization-and-more-27cdd6f63a41)
Any idea if there is a plan to support event based, non-blocking request processing?
"TYACH KFTLII!" is a weird thing to write on a poster
How do you declare the equivalent of the following in Java then? `public final String mode = "Example";` and `public String mode = "Example";`
Something I've been wanting for a while is a way to have my Javadocs (actually KDocs) hosted such that someone using an old version can still get to the old docs. I don't want to have the computed docs actually stored in my git repo, though, just the source. The best would be if I could somehow magically have links to the docs from things like my README.md actually go to the right version of the docs. So if someone looked at the v1.2 README on github and clicked on a Javadoc link they'd get the v1.2 version of those docs. Does Orchid provide a way to do any of what I'm asking for?
 @JvmField val mode = "Example" And @JvmField var mode = "Example"
&gt; Well, dependency injection frameworks indeed became too complex. It is especially notable in Android, where I do most of my programming. &gt; However, I don't think that this is a language issue. IMHO, this is just a misunderstanding of DI in general. Many developers don't know what DI is and can't even imagine doing it without some framework. &gt; I recently published a paid course about DI in Android. In this course I show how to build pure dependency injection from first principles and it takes like... less than a hour. Some students are shocked. That's my top pet peeve with many Java projects I've worked on. Everything moved to tiny micro services with very few classes and wiring -- but people still insisted on a DI framework. Even though the 'DI' component for a Dropwizard service is about about 8 lines...
TBH, I usually recommend using a mature DI framework, unless there are very specific reasons not to. That said, if your microservices are indeed "micro" (less than a couple hundreds lines of code on average, separate codebases, etc), it just doesn't make sense to use DI framework. At these sizes, even the "standardization" argument doesn't apply - it is much easier to review the composition of 10 classes in pure DI than in all DI frameworks that I know. That's not exactly my area of expertise, but IMHO one of the main goals of "micro-services" is to raise the abstraction level and completely remove system composition concern from the system itself (delegate it to the higher level infrastructure code). Employing DI frameworks in this case is akin to saying "we are not sure we'll be able to stick to this approach" or "we don't completely understand what we do". Though, again, not my area of expertise.
I've been told Kotlin 1.2.50 is going to have some multiplatform improvements!
&gt; "Remove redundant backticks" inspection reports all names and quick fix fails for non-applicable names So glad that was fixed. I use the backticks thing for my tests and that was starting to drive me crazy(er).
Right now, Orchid doesn't support KDocs, although this is a high priority as all the official plugins are entirely built with Kotlin and I would very much like to have KDoc documentation on those. As far as having README links going to the correct version of the docs, that is definitely possible, though I haven't quite figured out the best solution for it yet. You can't really have any kind of clever logic in the links from the Github README as that doesn't allow for any kind of dynamic processing other than pure Markdown, but you could manually update the README file for each "documented release" to point to the docs at a specific version, and hosting the docs of each version at its own unique URL just for that version. I really like hosting on Netlfy, so one option, is using Netlify's branch deploys, and making a dedicated branch for each "documented release". Another option is to deploy each version to its own subdirectory, but you'd either want to host them on your own server or have part of the Netlify build script be to pull down each previous version and host them them all together. If you want to build and deploy locally to Github Pages, this would be easier as you could just keep a local directory with all the previously-built versions, and just add a new directory for the new version when you release. All of the above solutions are very easily done, as Orchid lets you set the base URL for your entire site. All pages will create links relative to that base URL, so the navigation will stay within a specific version of the docs. 
Right now, Orchid doesn't support KDocs, although this is a high priority as all the official plugins are entirely built with Kotlin and I would very much like to have KDoc documentation on those. As far as having README links going to the correct version of the docs, that is definitely possible, though I haven't quite figured out the best solution for it yet. You can't really have any kind of clever logic in the links from the Github README as that doesn't allow for any kind of dynamic processing other than pure Markdown, but you could manually update the README file for each "documented release" to point to the docs at a specific version, and hosting the docs of each version at its own unique URL just for that version. I really like hosting on Netlfy, so one option, is using Netlify's branch deploys, and making a dedicated branch for each "documented release". Another option is to deploy each version to its own subdirectory, but you'd either want to host them on your own server or have part of the Netlify build script be to pull down each previous version and host them them all together. If you want to build and deploy locally to Github Pages, this would be easier as you could just keep a local directory with all the previously-built versions, and just add a new directory for the new version when you release. All of the above solutions are very easily done, as Orchid lets you set the base URL for your entire site. All pages will create links relative to that base URL, so the navigation will stay within a specific version of the docs.
Lol then after that the unnecessary let that lint will correct for you. Just point manager?.recordStopEvent()
1.2.40-eap-16 is also out today and has some. Most notably is allowing multiple `expectedBy`s in a single platform mobile.
Thats exactly the update I was looking for! Awesome. Kotlin mutli-platform has been pretty great.
d
Wow free course! Thanks mate!
Wow thanks
have a fun ;)
Considering the whole business point of making kotlin is to sell intelliJ, use that.
Well Android Studio is just a slightly customized and re-branded IntelliJ so I'd imagine either works.
I use Intellij for the full stack my websites and other webapps including HTML, JS, CSS, Kotlin/Java backend, etc., and Android Studio for the Android stuff, but you can also just use Intellij with the Android plug in for basically the same thing. But the experience in Android Studio is slightly better due to it being configured specifically for Android. 
I thought intellij was a way to sell kotlin..
Intellij and kotlin are made by the same company
The Android plugin for IntelliJ is like 70-80% of the functionality that Android Studio offers on top of IntelliJ.
I'll never not upvote javalin 
You don't see how a language that is bad could be so popular for so long? Why not? Look at Javascript. It should not be as dominant as it is based solely on its own merits and yet, it's an unstoppable force spreading to every programming domain. And I say that as someone who loves javascript but understands that it's very problematic. All it takes to get entrenched is enough inertia to get taught in schools and not be a completely terrible language. Throw in some early enterprise adoption due to hype and you have everything you need for a language, bad or good, to be popular for decades. 
JavaScript is indeed an interesting example. However, it is completely different one. On the front-end side, JavaScript is ubiquitous due to browsers compatibility. There is simply no way to build modern web frontend without either directly writing JavaScript or transpiling into it. This is a very strong technological lock-in, which ensures that JavaScript isn't competing on just merits (whatever definition of "merit" you're using). On the backend side, node.js is all the hype right now. However, it is relatively young framework and it is too early to say whether JS will become one of the most popular choices on the backend side long term. However, even on backend JS doesn't compete on merits - since it is ubiquitous in front-end, the pre-existing pool of front-end developers who might want to become "full-stack" is huge. In summary, there is a huge bias towards JS due to browsers compatibility, but it is still too early to say anything about JS outside of web-frontend. PHP and Ruby shot to a great popularity and were very trendy for several years, but both are on decline today.
I don't know why people are downvoting you when you are speaking the truth. Here is the source https://blog.jetbrains.com/kotlin/2011/08/why-jetbrains-needs-kotlin/ and in paragraph 3: &gt; The next thing is also fairly straightforward: we expect Kotlin to drive the sales of IntelliJ IDEA. So thats definitely one of th reasons.
You can only get Kotlin/Native support, including debugging, when you buy CLion. The Kotlin support on other Java IDEs is practically non-existent.
For proper Kotlin Native support you need to get CLion as well.
Trying to do the gradle kotlin set up and I cant seem to it the import to work
Alright, but &gt; one of Kotlin's goals isn't the same as &gt;the whole business point 
Just thought I'd also post this here, because I desperately want to use kotlin/native and hours of googling around did not help. The link is my github issue, located directly at the kotlin/native repo from JetBrains. I hope this is the right sub to post this, if not please tell me where to go. 
What struggles do you encounter when you try to implement what you have learned?
I am trying to implement "no reward until 30 seconds pass" so I tried.. let's assume I got the button ID as "ButtonClick" and onClick is ClickNowButton fun ClickNowButton(view:View) val ButtonClick: view as Button (not sure if this line is correct) val time=30 if time(&gt;=30) ButtonClick:"You have completed 30 seconds" }else { ButtonClick: "Retry again later" I am not sure if these lines are even right, I am still in the beginning. 
Thanks for pointing that out.
I haven't tried the new [Kotlin multi-platform thing](https://kotlinlang.org/docs/reference/multiplatform.html) but it seems really helpful. I usually have separate Gradle scripts for each module and a top level script that builds them all or a top level script that is the app and have them include dependencies on a sub-module that is the shared libraries.
And a module has a much bigger scope
Yes but I like it better this way. I often have things in a sub package I want to access in a parent package but still keep it private in other modules. Still package private has good uses not sure why they didn't include it.
Thanks for the article. Here's a cool video from kotlin conference that uses sealed classes to build a state machine for network requests.
AFAIK, because one could mark own package as someone else's and break their implementation. Never did that, but anyway
Not trying to be offensive here, but you seem to lack understanding of basic programming stuff, not specific to Kotlin.
Thanks for letting me know how you do it. 
Yes you can do that. But also I don't write libraries other people use. When working on a large project with multiple modules and packages it's best to keep things hidden you don't expect others to use for maintenance as well as keeping code completion clean etc. In my case if I find later it would be better to be public I can make that change and ensure the class is usable as a public API or just put what I want in the actual package/module. I'm not sure if this is possible with internal kotlin classes. If not I think it's another solid benefit I hadn't thought of.
Probably search google for “implementing timer in Kotlin” would help you with this issue. 
I clicked because of the dog.... nice dog!
Regardless though, the GIF on the README doesn't render properly in Chrome for me. It's horribly slow and the colours are off. Could you make a GFY or something else available?
Sure are a lot of libs, tools, frameworks named Spark: * this one * Apache Spark -- https://spark.apache.org/ * Adobe Spark -- https://spark.adobe.com/home/ * Spark the java micro web framework: http://sparkjava.com/ 
I definitely know that... I mean, I just thought about saying that in-case someone says my code has errors.
Also not to be confused with [Robinhood spark](https://github.com/robinhood/spark)
Just an odd side note. I tend to put `super.onDestroy()` as the last line not the first. For all `Create` calls I do super first, I do it last for `Destroy` calls. Probably just paranoid but I would hate the `super.onDestroy()` to put my Activity in an odd state where objects are gone / set to null / etc.
Sample? Toc?
Okay, I will consider it 😂.
It would be interesting to see this as a Kotlin multi platform project with a shared application flow for all platform/UI components.
You get downvoted simply because your and his statements are nonesense nonetheless. Citation from the blog post: &gt; we expect Kotlin to drive the sales of IntelliJ IDEA. [...] while the development tools for Kotlin itself are going to be free and open-source, the support for the enterprise development frameworks and tools will remain part of IntelliJ IDEA Ultimate [...]. Kotlin is open source and there is a very nice enhancement process, where everyone could participate. Of course they want some business value from creating a language. Do you have any idea how complex and how much effort it is to create and support a programming language!? Having commercial support for business integrations should be totally okay. And expecting an IDE with very good language support to benefit from gains in poppularity of said language should be okay too.
I published a gradle repo a few days ago which should be pretty up-to-date: https://github.com/tipsy/javalin-http2-example It's a demo for HTTP2, but you can just delete that part if you don't need it.
Particle is called that because they were initially called Spark, but the branding was too confusing: https://blog.particle.io/2015/05/12/spark-is-now-particle/
A simple solution to a real problem. Named parameters are useful, but they don't give you the same guarantee of safety as this.
All the platform already have very good native UI support, so you can define common Kotlin components (also a common application flow, if desired) and let the different platforms use common logic and implement interfaces to be notified about changes. Creating a UI library that is so generic to be used for all kinds of applications is therefore not neccessary, if it would be another framework "of the true belief" like described here https://8thlight.com/blog/uncle-bob/2011/09/30/Screaming-Architecture.html in section "Frameworks are tools, not ways of life."
I don't quite remember, but a JetBrains official said, that Native could be used in production now, because it is close to release and feature complete.
Nice article. You mention that excessive use of inlining can lead to a code size problem and that the JVM does inlining. It's also interesting to note that excessive use of the inline keyword can hamper or halt hotspot optimizations (eg method inlining) if the method grows sufficiently large. Hotspot, by default, won't inline methods larger than 35 bytes. 
Someone mentioned this in the /r/programming thread. I think that's a great idea! 
&gt; If you are considering defining functions with more than one function type parameter you should also consider using the `noinline` keyword to mark some of those parameters Why? Is that because inlining multiple lambdas is more likely to make unnecessarily large functions? Another thing to consider with inline functions is if they're extensions or declared on a class, they can only access public members of that class. What does crossinline do behind the scenes? What restrictions does it have besides no non-local return? Does it create a class and instantiate it like a non-inlined parameter, or inline it?
I am quite sure that extension functions can only access public properties and functions of a class regardless of whether they are inline or not. 
If you have just one function type parameter on your inline function the ideal case would be to have the parameter inlined too to get the benefits of inlining. If you are using the inline modifier on an extension function, the access limitation is there because it's an extension. About crossinline: inline fun crossinlineFun(crossinline body: () -&gt; Unit) { if (Random().nextBoolean()) body() else Runnable { body() }.run() } fun main(args: Array&lt;String&gt;) { crossinlineFun { print("I'm crossinline lambda") } } Is basically equals with this: fun main(args: Array&lt;String&gt;) { if (Random().nextBoolean()) print("I'm crossinline lambda") else Runnable { print("I'm crossinline lambda") }.run() } The compiler still inlines the code of the lambda if it can. 
So inline functions are, in a sense, macros?
this really makes me want to use kotlin more and more. I always try do it in java but then question why I bother due to the boilerplate. I loved your sealed class example too, really helpful. 
Interesting. I wonder in what cases multiple companion objects would be useful.
In the sense that they're equivalent to a text substitution, yeah, but there's no CTFE, AST manipulation/DSL parsing, etc. Kotlin has plenty of sugar for writing DSLs within the type system though.
This will be even nicer when inline classes become a thing, so no value type boxing/unboxing is needed. See feature 9 in https://drive.google.com/file/d/0BwAovUlww0CmVmNQTXd4TTdKYUU/view
Finally! Thanks for taking the effort. 
It is not exactly true for the feature completeness, but regarding usability and relative compiler stability - yes, it could be used already.
Could you explain why you chose Eclipse over IDEA?
Yeah, it can seem poorly named coming from Java. It is using [Math.rint](https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#rint-double-). If you want `Math.round`, you have to use `roundToInt` or `roundToLong`.
Easy, we use customer provided images, and none of them is willing to allow externals to use customs stacks. Given my experience how resource hungry Android Studio is, I am also not keen into convincing them to buy licenses.
For me it's co-workers being used to eclipse for several years and having to use eclipse for a legacy language, so trying to sell them kotlin would mean introducing a new IDE when they're already eclipse powerusers, which won't work
It's much better than it was once. It has advantages and disadvantages. For Kotlin development one big advantage could be dealing with native components (including debugging) in a multi platform solution in the same IDE as JVM and other components.
https://docs.oracle.com/javase/7/docs/api/java/math/RoundingMode.html
That sounds like standard Gaussian (Banker's) rounding. In school, I was taught to round .5 upward (actually, away from zero, so that 3.5 would round to 4 and -3.5 would round to -4), also sometimes called 'commercial rounding'. My dad, a high-school drop-out, pointed out that if this produced a bias away from zero and showed me that Gaussian had no bias. (Actually, there is still a bias, but it's a different bias and smaller.) As a new Kotlin user, I'm glad to see that it uses this technique. I never had much luck getting away with Gaussian rounding in school and had all but forgotten it until I noticed that C# (or was it VB?) was doing the same thing you found in Kotlin. There are some interesting articles on rounding on Wikipedia.
To my understanding, part of the drive for Google behind Fuchsia and Flutter is to ditch the JVM because of legal trouble. Dart compiles to native code thus removing the need for a virtual machine. I just started looking into Dart and the general feel I get so far is similar to Kotlin... except it uses null, which I find regressive but not deal breaker.
I wonder why you'd ever need Math.rint over a normal round.
This is less about JUnit 5 and annotations and more about the author basically explaining how to making static methods in Kotlin using companion objects.
I believe Kotlin usage will grow on the **server-side** in addition to **Android**. It has a huge potential to lower costs, and simplify development by making mobile applications **isomorphic** ( same language on the front-end and back-end like javascript apps ). 
The in the latest release of KotlinTest (version 3), you can run a single test class from intellij. You can't run an individual "test" inside a test class though. Spec might be able to do that I don't know.
I'm somewhat surprised to see Dart up there, a seemingly unadvertised language that has been focusing on mobile.
no one in their right mind would use eclipse over idea but companies may impose not only a tech stack but the same tools and OS to avoid compatibility issues or as an arbitrary policy.
Damn, the last one got me :)
Funny you should mention, because I got my co-workers to all convert to IntelliJ after introducing them Kotlin while the company is mainly a Java workshop for back-end development. They just use Eclipse keybindings in IntelliJ, and they believe that the features offered by IntelliJ make development a fair bit smoother than what Eclipse has to offer.
This post is getting upvotes but it's just spreading FUD :( Since v1.7.0 DSL-JSON compile time binding works with Java and all the source is in the repository. Prior to that version you had to use the external DSL Platform compiler. You don't need to anymore.
Yes. Imagine this case: var mutableFoo = 1 val foo1 get() = mutableFoo val foo2 = mutableFoo mutableFoo = 2 println(foo1) println(foo2)
I tried to use this library (in java) but I found I couldn't represent valid json using it the dsl-json schema. IIRC is was nested arrays or nested unkeyed . For example: {"foo":[["1",2],["3",4]]} It didn't like the fact that there was no key for the values in the sub array or something. I ended up using [jsoniter](https://jsoniter.com) which actually uses all of the json parsing optimisations as dsl-json. It looks like the docs have changed a bit since last time I tried to use it so I'll take another look at it. I find jsoniter creates too much garbage.
How are you running it? Intellij, command line, ect..?
Intellij
There also is a reflectionless Kotlin serialization (JSON, CBOR, and Protobuf) library that is multi platform: [kotlinx.serialization](https://github.com/Kotlin/kotlinx.serialization)
We need more information in order to be able to help you. Like how is your project structured
class Simple{ fun main(args: Array&lt;String&gt;) { print("Hello World") } }
can i add image as reply? I am new in reddit
To make a method static for the JVM, you can write it top level (and specify a JVM class name for the file, if you don't like the automatically generated class name filenameKt) or use the @JvmStatic annotation in an object definition. So your class Simple can be written like this: @file:JvmName("Simple") fun main(args: Array&lt;String&gt;) { println("Hello World") }
&gt; can i add image as reply? I am new in reddit You can upload images to https://imgur.com/ and post the link here
Check out: https://www.programiz.com/kotlin-programming/hello-world
You can link to usernames using "/u/" rather than "@". /u/GeanyFromLamp /u/Wasabi And [link directly to a comment](https://www.reddit.com/r/Kotlin/comments/88xxah/my_first_kotlin_hello_world_not_compiling/dwo1p1w?context=100) using the comment's permalink. 
Rust is also growing.... it's basically the Kotlin of C++ (to be honest, I like Rust more than Kotlin :D)
You're right that /u/GeanyFromLamp's code is *valid*, but AFAIK it does not provide an entry point - at least not on Kotlin/JVM. In Kotlin/JVM, main methods need to either be top-level or marked as `@JvmStatic`. 
Thanks for sharing! That technique is really intriguing, but I feel like this is one of those things that you explicitly need to explain to your colleagues (or at least ref a complete article in the javadoc) 
lateinit is not the same. It cannot be val and there is no static check to avoid reading the property before it is set. In fact it is very close to what a normal attribute is on Java (but throws a specific exception on uninitialized access instead of NPE)
Neat trick indeed. Far better than a `String?` with a default value I've been doing in my app.
Can you elaborate why you chose typealias UnsavedCustomer = CustomerData&lt;Nothing?&gt; instead of typealias UnsavedCustomer = CustomerData&lt;Unit&gt; These two should behave almost the same.
Tank you for the article, did you know if there is project for a pwa in kotlin ? 
I do not know what a pwa is
That article barely had anything to do with Kotlin :-\
Sorry, I mean a framework to make progressive web apps (PWA : https://developers.google.com/web/progressive-web-apps/) like angularjs, react or vuejs
No problem. I am not aware of such framework but I would love to find one and write about it on SuperKotlin.com
This is an ad.
There is an equivalent on webassembly for c# https://github.com/aspnet/blazor 
That seems cool! However I think Kotlin has not yet that level of maturity for the WebAssembly target. But we will keep an eye on it :)
It would! I hadn't tried it that way. I suppose that I started from the idea of a null id. In the end UnsavedCustomer(Unit, ...) feels a bit more contrived than UnsavedCustomer(null, ...)?
Agreed. Heck, my team is already using Kotlin in production for one of our microservices. We love it
Well I'm not a fan of OPs dialog example, but it could look something like `Dialog(title = "Title", interaction = AcceptInteraction(acceptText = "OK", onAccept = { ... }))` where `AcceptInteraction` is one of multiple possible dialog "types".
As pointed out on r/programming, this starts as a nice introduction to named parameters in constructors and quickly turns to overcomplicated overuses of the patterns. Even if some initiation logic is required, I'd rarely consider writing a builder in Kotlin over a custom constructor, an `init` block or delegates on some properties.
Potentially useful talk, but unfortunately halfway through the audio becomes doubled up and very difficult to follow!
Check here: https://kotlin.link/
Same. Great upgrade over Java.
x2. Most of our microservices are already Kotlin! At least the classes I wrote hahaha it's really easy to support both Groovy, Kotlin and Java in same codebase with cross-compilation which is great. Cathers for everyone and all scenarios.
Kotlin In Action by Dmitry Jemerov and Svetlana Isakova is an excellent read. 
I would say that given the definition of inlined functions, they *are* your code under test. They are in all ways equivalent to as if the lined method's code was copy-pasted into the method you're testing. As far as testing them directly, they should be inlined into your test when you call the inlined method, and therefore be testable, right?
I'll second that. Very easy to read and very informative
[removed]
As far as I know Kotlin can be compiled to JavaScript
Yes, and it seems that OP is interested in learning about it. But the application in the above mentioned code repository doesn't take this approach. 
Oh man excuse me. I misread it, thought me wanted a book ON the web lol. 
Isn't this kind of late to be calling it "Android O"
It’s a nice presentation of how compact Kotlin code can be, but... wrap your whole “business logic” inside an enum?! :D
Are you the Jake Wharton who did a talk on the Java Compilation process for team realm.io?
Named parameters and default parameters make this obsolete.
That part wouldn't look much different in Java. I think it's also perfectly valid as he is just calling some library functions. It's not as much business logic as it is a connection between the UI and lib. 
Maybe "overengineered" is a better word. I have no trouble following the code examples, it's just that in some cases I wouldn't use these particular patterns. Besides, some code is not really idiomatic Kotlin (I've seen a couple of `return this` instead of `apply` blocks).
Where it at tho
It is a different subject. I don't want to make it hard for people from outside of Kotlin community so I avoid `apply`, `let` etc.
I switched and created a Java entity and had it working in minutes, thanks though, if I ever end up doing more Kotlin programming I know one thing to look out for.
I always omit writing this. When fields in class don't overlap (which they should not) then writing 'this' keyword is just redundant because obviously you are referencing the variable in the class.
I would interpret it as a "redundant" construct which should be avoided. &gt; In general, if a certain syntactic construction in Kotlin is optional and highlighted by the IDE as redundant, you should omit it in your code. Do not leave unnecessary syntactic elements in code just "for clarity". https://kotlinlang.org/docs/reference/coding-conventions.html#avoiding-redundant-constructs 
&gt; Do not leave unnecessary syntactic elements in code just "for clarity" I see. This is going to be weird for me cause I come from python with the whole "explicit is better than implicit" ordeal. Thanks for the answer!
https://vertx.io/docs/vertx-lang-kotlin-coroutines/kotlin/
Yeah, I've been using just this combination to create an implementation of mDNS service discovery (aka Apple's Bonjour). I found this combination to be a joy to work with, even without the co-routine support which I don't use (yet).
this is exsctly my dilemma too. i come from big amount of python and still do it to this day, so i do it subconsciously and project mates are always like 'what the fuck is this dude' 😂 theyve learned to deal with it
The only time I use 'this.' is when creating multiple constructors. If it's a single constructor, you can just include the definition of the property as the parameters. But when there's more than one, I like all of the parameters to be the same name as the properties, so it's something like 'this.value = value'.
I like to print them out on a sheet of A3 and get some wax crayons.
Write a fun main(args: Array&lt;String&gt;) and click the green arrow on the left gutter to run it.
Linked lists are an odd example. You would not usually use null to represent an empty linked list, it'd be wrapped in another class.
Or write psvm and let it autocomplete
Even better! That also works in Java.
Just type "main" and tab out the starter code
Yes, that's exactly what I mean - there may be a null value internally but it isn't exposed so not a huge issue. In FP you have inductive data types with Cons/Nil that do exactly what the OP describes, but it's not like anyone would use null to implement Nil in java.
Kotlin and Java feel like twin brothers. But I'm not sure about Kotlin + JS
JS is a bit tricky. If you don't have wrappers for JS functions via a library you must write them yourself to get type safety. And guessing types can sometimes be hard if the documentation is bad.
What are you using Kotlin for? In what capacity are you asking about using JavaScript?
As if there's another Jake Wharton!
With Java, it's incredibly good. There are some minor hiccups here and there, but overall you're going to have a smooth experience. I haven't worked with Kotlin JS in a few months, but our last evaluation left us feeling as though it wasn't really ready for prime time. I have some thoughts on the matter in [this](https://www.reddit.com/r/androiddev/comments/7i6y4p/people_whove_been_using_kotlin_full_timeish_for_3/dqxyuof/) thread.
&gt; I don't see any advantages to the sealed class approach (except for the fuzzy "we're not using null" feeling) Aside from the obvious benefts of null safety, I didn’t spot the article mentioning one of the largest benefits, and perhaps you might not be aware of it: The sealed classes approach enables the compiler to force you to handle all derivations in your conditionals that switch on type. Null safety is a big enough win, but the conditional code benefits are damn nice icing on top.
I should have been clearer. While I'm all for null safety in general, in this *particular* case, I don't think it really buys you anything. Kotlin makes sure that you're exhaustive in your `when` expressions whether you are using nullable types or not. I don't see much difference between this: fun LinkedList.sizeRecursively() : Int = when(this) { is LinkedList.Node&lt;*&gt; -&gt; 1 + next.sizeRecursively() is LinkedList.Terminal -&gt; 0 } and this fun NullableLinkedListNode&lt;*&gt;?.sizeRecursively() : Int = when(this) { null -&gt; 0 else -&gt; 1 + next.sizeRecursively() } Neither is inherently more safe than the other. Both rely on smart casts. It would be different if the node classes had some innate behavior, but the only behavior that differs for the two types is the `toString` handling, and that could easily be done with null references as well. My point really is that, as evil as null can be, it is still a valid concept. It would be a shame if we end up recreating 1000 different null values when the existing one would suffice.
For good and for bad, the example involved only has two cases, where one maps reasonably cleanly to absence. Add another non-absent case, or otherwise change to having two cases where neither is considered absent, and only the sealed class option will give the tooling the power to force your conditionals to cover all cases. Even ignoring the above, there’s bug-prevention power to be had in simply disallowing null to ever be an input to any of this code. I’m honestly a little surprised that anyone interested in Kotlin would want to throw that away but to each their own, I suppose.
&gt; I’m honestly a little surprised that anyone interested in Kotlin would want to throw that away Why? If I'm using Kotlin to interface with a lot of unhinted Java libraries, I'm going to have to deal with nulls. That doesn't mean that Kotlin isn't interesting to me, or that its null safety isn't useful in a lot of circumstances. Kotlin's type system already handles null better than Java. Because of that, I don't see any real need to ban it completely. Sure, there are plenty of cases where null isn't useful and, as I said above, I already use sealed classes when it makes sense. My point really was that *this* example wasn't particularly good at making the case that sum types are better than nullable types, *especially* in a language with good null handling like Kotlin. 
[removed]
I'm probably just saying stuff you already know, but the author is employing [sentinel nodes](https://en.wikipedia.org/wiki/Sentinel_node) (names vary), which are a fairly well established concept. The logic behind them is that for some operations you don't even need to consider NPEs or exception handling (eg. traversal). Then only for the operations where you need to handle them do you actually need to implement the logic. It doesn't really matter in this case, because a linked list is such a small and self contained piece of code. But as you scale your code up you always try to minimize the need to consider NPEs, which sentinel nodes do at the lowest level.
**Sentinel node** In computer programming, a sentinel node is a specifically designated node used with linked lists and trees as a traversal path terminator. This type of node does not hold or reference any data managed by the data structure. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Kotlin/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Java + Vertx 2 is somehow meh. Yes it does its job, but it has a lot of complexity. Since this there where some interesting improvments, but i have not decided yet if upgrading to vertx 3 might be the way to go. Alternatives like akka are also looking interesting. 
My company uses Kotlin for everything. Kotlin and Js can be a little rough at times but overall it works well. We use it in conjunction with React from the kotlin-wrappers library that Jetbrains maintains. All of our client-side code for our main product is written in Kotlin js and it hasn't given us much problem. 
[removed]
Yes, you can. Unless required (like in generic types), Kotlin's **Int** will *generally* be converted into Java's **int**.
Because just like standard Java most of that is optimized by the compiler.
If there is a primitive type in java, it will be the same but capitalized in Kotlin. If it's a wrapper type there will be a question mark. java int -&gt; kotlin Int java Double -&gt; kotlin Double? java byte -&gt; kotlin Byte java Char -&gt; kotlin Char?
The question mark merely denotes a null able variable. You can have a kotlin Double or a Double?.
This is mostly true except in the case when Double or any other primitive type is used as a type parameter in a generic.
&gt; In Kotlin, there are many ways to avoid using null. In this article, we will show how to avoid using null to represent the empty state. Why on earth would you do that? The point of Kotlin's nullability support is that it's absolutely safe to use `null` to represent the absence of value. The billion dollar mistake was never `null`, it's languages that accept `null` values but don't handle them properly. 
NO
If you need YES 
That was rather basic, I hoped for some more interesting insight on cases when it’s not 100% clear wether to use parameterless function or calculated property - for example how to deal with concersions - let’s say i have class Distance with 2 converters - to kilometers and to miles. Should they be functions or read only properties? 
use semantics. if it's a verb use a method if it's a noun use a property. i don't see why that's so unusual for a Java developer either. Java developers use properties in the form of getters and setters. Kotlin just does away with public members in favor of generated getters and setters, which is a great idea for flexibility and compatibility.
I think the official coding conventions are usable most of the time: http://kotlinlang.org/docs/reference/coding-conventions.html#functions-vs-properties *"Prefer a property over a function when the underlying algorithm:"* * *"does not throw"* * *"is cheap to calculate (or caсhed on the first run)"* * *"returns the same result over invocations if the object state hasn't changed"*
It sounds like that found work, might go back and try it thanks.
Also good thing to note is when you are using array of bytes for example and in kotlin you declare Array&lt;Byte&gt; it uses the object type Byte but if you want just primitive byte use ByteArray and so with other primitive types
Are you aware of libktx?
The IDE story seems confusing, what will happen to the CLion one? AppCode is macOS only sadly
Unfortunately you need a Mac OS to build native ios apps unless you use a cloud building solution
Do you have any plans to have a "multiplatform" IDE where I can develop my frontend, backend, android, iOS, other native code or I'll have to have WebStorm, CLion, Android Studio, AppCode, installed and used separately?
Just IntelliJ?
Yes, we do plan to build such an IDE, but unfortunately this is not trivial and will take some time
that is where the destructuring comes in to save the readability interactor1.getConfig().flatmap{ config -&gt; interactor1.getSomethingElse(config).map{ config to it } } .subscribe({ (config, somethingElse) -&gt; [...] }, Pokeball) //logger object or maybe real error handling :)
Oh awesome! Didn't realize you can do that thanks for the tip?
Great article!
Great article! Thanks for posting (and writing, in case it's yours) I found out about this usage of sealed classes in this article: http://arturogutierrez.github.io/2016/09/16/creating-enums-with-associated-data-in-kotlin/ It shows the general concept but doesnt go as deep as this one. I recommend using this pattern for any larger business application, especially the when-pattern introtuced here.
This is a good article and it is very useful.
No shitposting allowed in the official slack. Gotta put those memes somehwre.