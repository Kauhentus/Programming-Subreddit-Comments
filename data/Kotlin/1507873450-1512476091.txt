That's good to know. I don't think I would've made any secondary constructors anyway, but I'll actively avoid them if they're just an unfortunate interoperability necessity.
As someone who doesn't know what in heck &lt;&lt;&lt; means in the first place, ush makes a lot more sense.
Why make it easier to make arrays when arrays should be a code smell in Kotlin most of the time anyway? You'd just be inviting new Kotlin devs coming from languages like Javascript to do _bad bad things_.
You'd use this to instantiate any collection, not just arrays.
Try lambda with reciever
Good point. Yes, now it's easier to operate on unsafe arrays. But it's also easier to use them in right places. And there are places, where arrays are ok. Right way to do things is two array types: mutable and immutable. I.e. `[]` and `Mutable []`
Dude, you are still here based on a false premise!
Function type with receiver, see [What is a ‚Äúreceiver‚Äù in Kotlin?](https://stackoverflow.com/q/45875491/7079453) on SO.
I dislike Python and adore Kotlin and said so in this thread ... Do you know what a username is? You can use it to differentiate what different people have said.
I would see your point if I thought this looked nicer, or easier to write. But I think for types other than arrays it looks different, not better.
This article does a great job explaining the concept https://tech.io/playgrounds/6973/kotlin-function-literal-with-receiver The author calls it ‚Äúfunction literals with a receiver‚Äù :)
IMO using lateinit is not a good option as recommended by the article. It basically changes things back to the way they were in Java. I suppose if that's what you want, then sure. But in my opinion it's much better to use a nullable value and then be forced to code for a possible null value (even if that is to just use !!). The compiler and editor are smart enough to know that if you check for null, it no longer requires the null safety checks for any code in that path. So you can either do if(value!=null){ put stuff here without null checks } or if (value!=null){return} and then put stuff after that without null checks. Seems like this article is trying to work around null safety which is a core feature of Kotlin and should be embraced. The only time I do use lateinit is for Spring autowiring and similar. And then I always use a nullable type so that I'm forced to deal with the fact that it might be null. As for lazy, I see that as a totally different thing that's more about preventing loading of values up front to improve performance (i.e. the main reason for lazy-loading). You should still take into account whether those values could be null or not.
Lua is a good language. However, I want static typing. Also, I don't like Lua's 1-based index. Finally, I like Kotlin's language constructs, such as: class data Foo(...)
There is one important difference that lateinit has, avoiding being initialized twice. This is some added safety over a nullable type, though your other concerns are totally right. For autowiring, I recommend you look at constructor injection. In kotlin it is very simple and usually the best approach. Unless you meant circular dependencies and the like, which of course don't work with that.
I've done a fair bit of Spring Boot with Kotlin and haven't had to resort to lateinit once for injection. Just put the injected stuff in the constructor. class MyClass(@Inject val dependency: InjectedClass)
`lateinit` doesn't prevent you assigning a value to the variable multiple times.
Thanks! I'll try that out the next time I'm working on one of my Spring Boot applications.
But lateinit only works on mutable properties, right? So it could be reinitialized anyway. And thanks for the tip. /u/fojji also gave me an example. I hadn't tried the constructor injection before. I'll definitely try it out. It seems preferable to a lateinit.
You're very welcome! Another advantage is that it makes testing your classes easier, being able to insert mocked dependencies without lots of Spring magic.
For constructor injection it should look like: class MyClass @Inject constructor(val dependency: InjectedClass) Otherwise I think the annotation will apply to the field
I use `lateinit` in "scripts" where some of the options/variables are expected on the command line (and if they are not passed in, the script will die). I agree using them anywhere else seems like the same exact problem as NPE
It's still the constructor, you can just omit the keyword. Granted, it's somewhat of a blurred line in Kotlin.
Right, but your annotation is inside the constructor on the field rather than on the constructor itself. You can't use a constructor annotation in Kotlin without the `constructor` keyword (see: https://kotlinlang.org/docs/reference/annotations.html#usage)
Yeah I've read that also, but my code is working as I wrote it above :)
You can use lazy values as a simple form of dependency injection in your `main` function if you are prototyping and just want to wire a few objects together. You just specify which lazy value goes to which constructor and they will be instantiated in the right order because they are lazy.
Or even better if you use `fun`s annotated with `@Bean` and create your objects by hand. No lateinit and nulls involved.
You don't need any annotation if there's only one constructor. Spring will figure it out. 
I really like this series, and I'm looking forward to your talk at KotlinConf!
I'll upvote that ;-)
how come every other popular modern language in existence is able to use `[]` for array literal syntax and it works fine yet kotlin, which isn't exactly a paragon of cutting-edge language design decides to go it alone and leave it out? 
Actually, for construction injection spring doesn't even need an annotation. class MyClass constructor(val dependency: InjectedClass) 
You say "polyglot programming", I say "fragmented toolchain". If you have no choice but to use 3 different languages then you gotta do what you gotta do, but much better to pick one good language and stick with it.
Because lists are much more useful and popular, relative to arrays, than in other languages, so using it for arrays wouldn't be particularly helpful. Using it for lists might be confusing because people might expect it to result in arrays
I agree, title reads like satire.
If you're still having problems with runtime kotlin compilation, I have a project which I'm using it to test my results when generating code with kotlinpoet. Let me know and I'll pm you the link
Pm me it for sure, I haven't gotten around to messing with again yet but that'd be great.
Are there any benchmark results and generated assembly dumps? Some of the claims are a little dubious and it would be interesting to see what jit produces for them
One of the first sentences of the article: &gt;As ever the current state of the code to run the benchmarks is available for inspection and comment on GitHub.
The code and the results that I‚Äôm using are in GutHub https://github.com/dmcg/kostings - I haven‚Äôt got as far as profiling HotSpot. I‚Äôd welcome help in this area. 
You can take a look at jitwatch, I found it quite reasonable to set up and it can be very helpful for finding out *why* code behaves as it does
I don't really understand who the target audience for these kinds of blog posts are. The Kotlin reference explains pretty much everything with an example, so why do we need this?
Not everybody seems to read the documentation, the target audience is actually formed by those who are getting started with the language and haven‚Äôt heard of features like in this example. Also, the docs don‚Äôt always include examples, which I try to provide in such posts 
Pretty cool, reminds me of Scala a little
1. Different folks explain the same thing in different ways. Different folks find alternate explanations of the same concept, easier to understand. I‚Äôm not implying the Kotlin inference is inferior to the explanation provided in this blog post (haven‚Äôt gone through the entirety of the post). I just believe it‚Äôs completely fine for such blog posts to exist and wholeheartedly support the effort put in by the authors to share this with us. 2. Writing blog posts can be way of understanding for many people. So assuming the author already went through this process and wrote this blog post down. What‚Äôs the harm ü§∑‚Äç‚ôÄÔ∏è right? 
agreed
Totally agree! For me posting is a way of learning and also sharing the gained knowledge with others. Anyways, there‚Äôs always someone questioning that... Haters gonna hate right?!
You guys have a valid point, the title was a tongue-in-cheek expression that came to my mind when I was analyzing this project's source. Luckily, I have experience in all 3 programming languages (JS, Groovy, and Kotlin), so I could follow along. But for somebody new to this project - they'd be lost!
Java is two parts. The JVM and the language Java. The JVM allows you to run the same bytecode on any machine. The language Java is a programming language that compiles to bytecode. Kotlin is another language that also compiles to bytecode. Java as a language has been sort of criticized as being verbose and clunky but the concept of the JVM is this highly relevant so a lot of languages have popped up lately that compile to bytecode for the JVM. Examples of these are Groovy, clojure, scala. These languages often produce slightly suboptimal bytecode with a lot of added stuff for the added features of the language. This is usually not acceptable on systems like Android. Kotlin is quite a small step away from Java so the added bloat of the bytecode is quite small.
Not answering your question but a nice way to learn kotlin is by resolving koans : https://kotlinlang.org/docs/tutorials/koans.html
[removed]
"new kid on the block" might be true, but it's not very adequate and doesn't live up to its name, as Kotlin is a very mature, efficient and performant platform with major supporters already. If you like Java for what it does right - you get (nearly?) all benefits of Java with using Kotlin. But Kotlin additionally gives you language features that (mostly) are empirically proven to not harm your codebase, but give you the convenience of a modern programming language. Things that mostly dynamically typed, but nowadays also statically typed languages already offer for some years. There are some features where non-Java people say "I can't work without them". And in fact, working without features like first class functions, string interpolation, immutable collection (s interfaces at least)...it's just not up to date anymore.
I use lateinit for @Inject in EJBs and @Column(nullable=false) fields in JPA entities
It's described here (external interfaces): https://kotlinlang.org/docs/reference/js-interop.html
Three parts: language, library, virtual machine. You cannot use Java without java.lang.Object ;)
Very true. I forgot that part
I've experienced a few growing pains with learning Kotlin. A lambda function with a receiver and calling methods off the implied this: class HTML { fun body() { ... } } fun html(init: HTML.() -&gt; Unit): HTML { val html = HTML() // create the receiver object html.init() // pass the receiver object to the lambda return html } html { // lambda with receiver begins here body() // calling a method on the receiver object } This kind of syntax makes for beautiful, simple DSLs, but coming straight from Java it took me a while to become comfortable writing functions with receivers and calling them, especially when you start throwing things like optional parameters and default values into the mix. From the docs: https://kotlinlang.org/docs/reference/lambdas.html
Great explanations!
I do see it as a feature that you have to carry the ? with you the whole chain. It does show where the first null occured and it explicitly forces you to acknowledge it every step of the way. So you know which code is prone to not being executed. like a.doB().doSomethingNullable()?.doC()?.doD()?.doE() ?: "damn" 
Yea, 7 years Java here, too. Lambdas with receivers seems to be the most "complex" thing for people new to Kotlin. Although it's not very difficult at all. I think Groovy's stuff is much more brainfucked and complex than Kotlin's "equivalents"...and Groovy is very often used besides Java for build and scripting, what I experienced. But of course, those features are more complex than plain Java - did you experience any other hurdles?
The possibility to not optimize probably improves compile times which is what you are going to want when developing/debugging. I do not understand why that is the default though.
Can't remember anything else. A lot of it just makes it more natural and easy to follow best practices I often did anyway. Like immutable classes with builders in Java are a real pain to make. Or in Java I would often use guava immutable lists. I've found extension functions to be a sweet way to extend libraries I use without making some extensive wrapper or something.
I can see that being the case. Seems a bit obvious now that you mention it, but I'm not 100% convinced yet. Could be though.
When I've done it with C, it is much easier to read the disassembly if needed. Can also help when profiling to see hot spots that would normally be inline, although one should probably profile the optimized code as well (or maybe first?).
By the way, Kotlin Native is one of the biggest draws for my current pursuit of learning Kotlin. The variety of back ends is such a great option. My current goal is an agent that is easily deployable by being a single executable.
Very good lead. I'll have to look into this. Thanks, mate!
Typically compiling with optimizations turned on takes longer.
Maybe the default is for compiling while testing or debugging, which you do a lot, when you don't want to lose time with the compilation. When your product is ready for production you use this option. I am not sure.
I know, I get how you feel. Hell, I can even transpile my Kotlin code into ECMAscript 5.1 (soon enough, ECMAscript 2015 (though I'm not interested in either of these)). As for Kotlin Native, I love the idea that I can use a very sleek, modern language to target my platform directly. And if I can eventually hack onto Java applications without much learning, that's a bonus. I'm looking for a new language to supplement C. I love C, but I feel that I should get proficient at a new generation systems language: Go, Rust, Kotlin, Nim? Honestly, I'm having a hard time choosing. I think so far I'm leaning Rust -&gt; Nim -&gt; Kotlin, but every time I take a look at Kotlin I feel a sudden desire to learn it. The more I know, the better decision I can make. Thanks for your input, mate.
The best develop setting is usually the default because you use that more often. More often than not, you're only compiling releases on CI or very rarely locally
I was pleasantly surprised to find my library among the listed ones. GitHub views, Maven Central downloads and open-source projects (that I could find) give me an idea of its modest popularity, but I can't wait for the official survey results!
That is actually true
You seen surprised ;)
Was surprised to see my type of application not even listed as an option (Enterprise backend)
Which one is your lib?
I agree that it is only in C# you require additional expressiveness described in article. In pure Kotlin if you want to know if invocation chain can be stopped on specific invocation you can just check if function return type is nullable or not. But when calling methods written in java such information can be not available. Consider example from Kotlin documentation: bob?.department?.head?.name It is unclear if developer has checked department and head for null because they can be null or just because bob can be null.
Kotlin compiler does optimizations very well. In following example no boxing\unboxing will be performed: a?.foo()?.length?.minus(1) ?: -1 But still byte code will have a null-check for result of foo() method even when return type of foo is not nullable String. I don't think this will have any impact on performance, but code coverage is be affected. It would show that branch where a.foo() equals null is not covered.
[KTX](https://github.com/libktx/ktx), Kotlin DSL and utilities for LibGDX game framework.
Thanks for making this, looking to start up a new project and planning on using it.
FWIW, GCC has `-Og` for debugging-compatible optimization. 
Me too kotlin-logging https://github.com/MicroUtils/kotlin-logging
i am guessing because your when statement is return different types. Lets say T is boolean.. the when statement (without the casting) would return a double for DoubleConst, Sum, and NotANumber.. so you have to cast that into a boolean. if T is double, BoolConst and Eql would return a boolean
I wonder if the compilation was slower in the previous beta than in stable, and the improvements are on that, or if they're over the compile times of stable.
The Kotlin compiler won't figure out that a Expr&lt;Double&gt; can't be a BoolConst or an Eql. So if I split it into two functions with two different when expressions, it can't figure out that the when expressions will be exhaustive, which is a more important guarentee to me. I guess the only fully safe solution is to make eval a method of expr? I.e. something like this: sealed class Expr&lt;T&gt; { abstract fun eval() : T } data class DoubleConst(val number: Double) : Expr&lt;Double&gt;() { override fun eval() = this.number } data class BoolConst(val boolean: Boolean) : Expr&lt;Boolean&gt;() { override fun eval() = this.boolean } data class Sum(val e1: Expr&lt;Double&gt;, val e2: Expr&lt;Double&gt;) : Expr&lt;Double&gt;() { override fun eval() = this.e1.eval() + this.e2.eval() } object NotANumber : Expr&lt;Double&gt;() { override fun eval() = Double.NaN } data class Eql&lt;T&gt;(val b1: Expr&lt;T&gt;, val b2: Expr&lt;T&gt;) : Expr&lt;Boolean&gt;() { override fun eval() = this.b1.eval() == this.b2.eval() }
Hmm... I can't find the `g` optimization in the documentation. I do know there is a `-g` flag that produces debugging symbols and meta information, but I don't think that affects the assembly itself (don't really know though).
that certainly looks much cleaner to me.. in this case i dont see why you would need to use sealed classes
There's an explanation on this page: https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options
You can use [reified type parameters] with an inline function: sealed class Expr&lt;T&gt; data class DoubleConst(val number: Double) : Expr&lt;Double&gt;() data class BoolConst(val boolean: Boolean) : Expr&lt;Boolean&gt;() //data class Sum(val e1: Expr&lt;Double&gt;, val e2: Expr&lt;Double&gt;) : Expr&lt;Double&gt;() object NotANumber : Expr&lt;Double&gt;() data class Eql&lt;T&gt;(val b1: Expr&lt;T&gt;, val b2: Expr&lt;T&gt;) : Expr&lt;Boolean&gt;() inline fun &lt;reified T&gt; eval(expr: Expr&lt;T&gt;): T = when(expr) { is DoubleConst -&gt; expr.number as T //is Sum -&gt; (expr.e1 + expr.e2) as T NotANumber -&gt; Double.NaN as T is BoolConst -&gt; expr.boolean as T is Eql&lt;*&gt; -&gt; (expr.b1 == expr.b2) as T } I disabled the Sum part since you haven't included a definition of the plus operator for `Expr&lt;Double&gt;`. But other than that it compiles.
You omitted the eval call in the when's Eql case, because otherwise you can't inline,right?
Reads as though written by someone who started in iOS/swift before they looked at kotlin. A more important item of comparison in my mind is tooling followed by ecosystem, both of which kotlin excels at and neither considered here.
Yes, Kotlin doesn't support recursion for inline functions.
I think your problem is because of type erasure, making T disappear after compilation. That means you effectively cast an Object to something else, which is unsaved. reified generics could help here, but they are missing in Java and are done by Kotlin only in a limited way (for inline functions, that you can't call recursively). What about this approach instead, to eliminate the whole problem completely: interface Evaluatable&lt;out T&gt; { fun eval() : T } sealed class Expr&lt;out T&gt;: Evaluatable&lt;T&gt; interface ConstExpr&lt;out T&gt;: Evaluatable&lt;T&gt; { val value : T override fun eval() = value } data class DoubleConst(override val value: Double) : Expr&lt;Double&gt;(), ConstExpr&lt;Double&gt; data class BoolConst(override val value: Boolean) : Expr&lt;Boolean&gt;(), ConstExpr&lt;Boolean&gt; data class Sum(val e1: Expr&lt;Double&gt;, val e2: Expr&lt;Double&gt;) : Expr&lt;Double&gt;() { override fun eval() = e1.eval() + e2.eval() } object NotANumber : Expr&lt;Double&gt;(), ConstExpr&lt;Double&gt; { override val value = Double.NaN } data class Eql&lt;T&gt;(val b1: Expr&lt;T&gt;, val b2: Expr&lt;T&gt;) : Expr&lt;Boolean&gt;() { override fun eval() = b1.eval() == b2.eval() } Look how you could use abstract properties and a default method to have ConstExpressions defined with convenience in a single line. Having a common Interface, you could do something like these ones: inline fun &lt;reified T&gt; Evaluatable&lt;out T&gt;.eval() = this.eval() inline fun &lt;reified T&gt; Expr&lt;out T&gt;.eval() = this.eval() All doing exactly (?) what you wanted, but without any casts :)
Looks very clean! But what extension functions do? Seems they are redundant.
Use [BCrypt](https://mvnrepository.com/artifact/org.mindrot/jbcrypt/0.4) for all things passwords (until something better comes along)
I've been told to use [Argon2](https://www.argon2.com/) for passwords, is Bcrypt better?
Oh you know what, I think you may be right. I recently heard about an algo that's newer and supposedly better than BCrypt, and I think Argon2 may be the one. edit: ah yes, here's the blog I read, it's regarding a web framework I use extensively, talking about Argon2i implementation https://symfony.com/blog/new-in-symfony-3-4-argon2i-password-hasher
Why don‚Äôt you use something like auth0 or cognito instead of implementing an identity service yourself? You also want to salt the passwords. 
An algorithm which has a longer history of being unbroken, prefer that. Don't jump on Aragon which is "only" 3-4 years old. Bcrypt is solid. Scrypt slightly better as it guards against GPU based attack vectors. Time will tell how good Aragon 2 is. It might be better than all those which have come before it, but until it has been exposed to deliberate attempts to break it, don't believe the hype. 
No offense, really, but don't make videos about coding. I'm on my phone currently and I can't follow the video. A nice written introduction is much better.
I sympathize with your mobile difficulties watching a coding video. But, also no offense intended, that isn't really a valid reason to not do a coding video in my opinion. I think it is probably one of the best ways to convey the very basics of quite an intricate api. (even if it is very amatuerish) But...I take your point, and I will try to make some time to edit and put a snippet or two of code in there with some discription to help fellow mobile bound readers. Hopefully give you more of an idea as to wether you want to watch it when you get home :)
Thank you, and sorry for being forward, but I'm actually working with Kotlin and libgdx right now, so I was excited to see this and not being able to learn about it right away.
No dramas. I am going to add more details to the post.
I thought for the case that the eval function shouldn't be a class function but a function that can be reified and inline. The Implementation could contain a when statement again.
Even better, create a blog post and do the video based on the blog post. Two avenues of discovery for the work of one (and a half, or so)!
Ya dig it! My weekend is getting full it seems.
I'd use oauth2's password grant type to login. It returns an access token and a refresh token for you to use in future requests, and is more secure than just an access token. As for hashing algorithms, I'd use bcrypt or pbkbf2 Make sure you salt the passwords too.
Have you had a look at this? https://github.com/libktx/ktx
Ah! That looks like it has lots of usefull stuff. It sticks to providing a kotlin approach to various composable tools and libraries? Jenjin is not really a set of tools, but aims to be a complete architecture. But, I think it could probably benefit from a bunch of this stuff! Going to take a closer look tonight. The inject stuff looks immediately very interesting... Thanks for the pointer.
Coding is inherently textual, I don't see what value video adds over a well-written article. Being able to consume content at your own pace, copying code snippets and effortlessly repeating a passage are extremely valuable.
Good points. The git hub repo that is also linked has commented demo projects.
For hashing, BCrypt is pretty standard as mentioned by /u/DJDarkViper For sending the password from client to server, you should make sure your site is using HTTPS: https://www.troyhunt.com/the-6-step-happy-path-to-https/
Never heard this story before?
Ah yes SSL, he other half of the equation :) If you got full control of your server, you can at least start off with LetEncrypt for free SSL certificates to enable HTTPS relatively quickly. 
Bit late, but added some detail
Hmmm, my sarcasm sense is tingling... I guess you are right - I am not the first person to build my own game engine/framework. In fact, I am sure I am not the first person to build a Kotlin framework on libGDX. But, building tools for making games is just as fun as building games (for me at least). I am just as happy about it :) If only the people who did something first with some given tool (Blender, Java, paper and pencil) were aloud to post about it, there would be less posts. But I guess, possibly you would also be less bored..? 
Main reason is that (AFAIK) auth0 and oauth2 are used to validate accounts from other sources (e.g. Google login or Facebook login for your application) and I'd like to provide a service free from dependencies on other services first, and add those options later if possible.
[Copy Pasted from last reply] Main reason is that (AFAIK) auth0 and oauth2 are used to validate accounts from other sources (e.g. Google login or Facebook login for your application) and I'd like to provide a service free from dependencies on other services first, and add those options later if possible.
Any reason why Ok and Error are not data classes?
I think you‚Äôre missing a trick. See https://github.com/npryce/result4k/blob/master/src/main/kotlin/com/natpryce/result.kt for how map etc can avoid creating new Error instances
I‚Äôm commenting a lot, because I think that this is an important whole in stdlib that Jetbrains show no sign of plugging. As a community we may have to settle on something if we want interchangeable Results
Your app is a different service to your website
Also `===` is deprecated in recent versions of Kotline
Huh? Why would the reference equality operator be deprecated?
Absolutely not, almost every `equals` implemetation uses `===`. Do you have any source on this?
Oops, apologies, I must've mix it up with some Lint warning I once saw.
No source, apart my wrong assumptions :) I was not correct about this.
This is very interesting. I didn't know about it. Thanks for sharing.
If you're doing user management yourself: Application-wide pepper, user-specific salt, and a cryptographically secure hash with enough iterations to be computationally expensive. (what's the norm these days? 100ms on average hardware?) BCrypt includes a per-user salt out of the box.
Thanks very much for all of your feedback. I've just pushed a bunch of changes and added result4k under the list of inspirations in the README. Regarding "settling on something", I've tried to make my library as close to existing solutions from other languages. The wiki has guides showing featurity parity and consistent naming between [Elm](https://github.com/michaelbull/kotlin-result/wiki/Elm), [Haskell](https://github.com/michaelbull/kotlin-result/wiki/Haskell), and [Rust](https://github.com/michaelbull/kotlin-result/wiki/Rust) - whereas every other solution seems to have taken their own approach to naming and gotten a lot of them wrong (i.e. people naming the andThen function flatMap, which makes no sense when you consider what flatMap does in the stdlib...)
Glad you found it useful
A big downside to implementing everything as an extension function as this library does is that it can't be used in any API that might be consumed from Java. Too bad. 
The Builder pattern is obviated by named arguments unless you want a nicer Java API.
One feature of Swift that is not mentioned in the article, extensions can also make existing types [conform to protocols](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID277) (implement interfaces).
There is a warning if you use `===` with integers and a few other types.
obviated how?
I stopped reading this once I saw the builder pattern. It was like somebody didn‚Äôt take the time to understand Kotlin before writing this. 
The builder pattern allows you to create an object without specifying every possible constructor combination. In Kotlin, named arguments and default values in the constructor combine to do this as a built in part of the language. In fact, I‚Äôm pretty sure Kotlin compiles builders in java bytecode, and you can use the builder pattern when calling Kotlin classes from java. This is all native to the language and doesn‚Äôt require any companion object. 
but it may become a bloody null hell uf you just use constructors 
I guess this depends on how you view kotlin and kotlin libraries. Some people can believe "interoprability" to be a 1&lt;-&gt;1 relationship, but that isn't always the case. I admit that I could move everything inside of the Result file and not use extension functions, but I think this library was specifically written with kotlin in mind, and not Java.
Maybe someone will come along and create *another* Result library that combines the advantages yours has over the others with some interoperability. To me, your decision to make everything an extension function is form over function. I see no advantage other than a weak argument about separation of concern or something along those lines. That being said, it's your library, and you're free to do what you please, so don't mind me. You do you.
This is Kotlin. We shouldn‚Äôt be using nulls unless absolutely necessary. Use default values on arguments that are optional, and make everything non-null object types.
I have to agree with the above, I've been using one of the other result classes with Kotlin for a while now and really enjoy it as a pattern, however the lack of Java interop is really disappointing with most of them. A lot of us have to deal with existing code and are trying to bolt new kotlin bits into that, and without the solid Java introp it makes things much harder. Kotlin and Java aren't Scala and Java, it isn't an us vs them thing that seems to happen around that relationship, Kotlin has been designed with Java interop as one of its main benefits, and not trying to abide by that mentality doesn't really help much imo. It's much better to write your libs so they can be used from Java, and then add in some extension functions that make using it from Kotlin easier. But, as the above said, it's your library so don't feel like you HAVE to change if you want to keep it done the way that it is, but it would be really awesome if you did change it. Either way, looks like you put a lot of effort into it, including keeping it closer to other language alternatives, which is great, so either way, good work.
&gt; I see no advantage other than a weak argument about separation of concern or something along those lines. I disagree. Some functions simply aren't possible when converting them to be first class members of the Result type. Take this example: infix inline fun &lt;V, E, U&gt; Result&lt;V, E&gt;.andThen(transform: (V) -&gt; Result&lt;U, E&gt;): Result&lt;U, E&gt; { return when (this) { is Ok -&gt; transform(value) is Err -&gt; this } } To convert that, the first thing we need to do is remove the "out" variance on the types of Result&lt;out V, out E&gt;, making it Result&lt;V, E&gt;. After doing so, we can then put the method inside the Result class, as so: sealed class Result&lt;V, E&gt; { infix inline fun &lt;U&gt; andThen(transform: (V) -&gt; Result&lt;U, E&gt;): Result&lt;U, E&gt; { return when (this) { is Ok -&gt; transform(value) is Err -&gt; this } } } **However**, this isn't synactically valid, as shown [here](https://i.imgur.com/vSjh0Ft.png). As far as I know there is no way to avoid this issue. If there is then feel free to let me know and I'll revisit the topic. If I can convert all of the library methods to be first class members then I more than likely will do so, however I don't see how at the moment. 
They are now! Thanks for the feedback.
Same as the Singleton Pattern: `object Singleton`
For real? No offense, but this example shows literally not a single line of idiomatic kotlin code, or shows how the downsides of gui development or working with the swing api (for example using with or apply...) can be tackled specifically with kotlin's concepts.
Actually in the Builder.kt I tried to implement [Kotlin Type-safe Builders](https://kotlinlang.org/docs/reference/type-safe-builders.html) using [Function Literals with Receiver](https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver)
Am I just blind or do you call it differenlty, but I'm missing `fold` function something like: fun &lt;E, V, R&gt; Result&lt;E, V&gt;.fold(e: (E) -&gt; R, v: (V) -&gt; R) = ... And what's the reason not to call it [Either](https://medium.com/@lupajz/you-either-love-it-or-you-havent-used-it-yet-a55f9b866dbe) ? I always prefered that instead of Result as Result to me indicated that it could have more than 2 subtypes. 
&gt;Am I just blind or do you call it differenlty, but I'm missing fold Do you mean [mapBoth](https://github.com/michaelbull/kotlin-result/blob/master/src/main/kotlin/com/github/michaelbull/result/Map.kt#L51)? 
Classic clickbait, nothing remotely interesting.
Can be interesting for people who are begining to be interested in Kotlin. But yeah, these are the first things you learn about it.
On Kotlin side, I have no doubts. But how do YOU feel about it? How much experience do you have with it? I would use it in production if I could...
Yes
actually working on an IoT android app with kotlin too rn, and trust me, android has never been more convenient. 
We run Kotlin in production at a bank. It's definitely mature enough to put your trust in. Heck, thanks to the null-safety I feel more confident in Kotlin than Java.
Nice job! The DSL looks much better than Mockito's API!
Please do yourself and everybody else a favor and choose Kotlin. I did exactly that (for "normal" Android development) over 1,5 years ago and it has been a blast. Whenever I have to go back to Java I cringe. Also: join the Kotlin Slack channel. Super helpful, especially if you're just starting out.
I thought `goto` died a log time ago, no?
Remove the ‚Äú@‚Äú from front of the annotation which you are using as a parameter. 
Thanks! My imports were forcing it to pick the wrong Parameter class when it wasn't an annotation, so when I tried it earlier it didn't work either. It works now so Thanks a lot!! :) 
Why not use a top-level function?
What do you mean by that and how will it prevent a data class from being instantiated with invalid input?
Why don't you use provideDelegate for this case, as ist seems to bei the perfect fit for property validation on creation.
goto != labeled returns
Labeled returns are very different from gotos, with labeled returns you are telling kotlin from which scope to return, whereas a goto completely shifts the control flow of a program from one point to another!
Sorry for the rushed answer, it won't. It seems currently your best bet is to trust your users to not use the copy constructor (like you proposed). 
I'm not a fan of validation as in your example. Throw an exception when an invalid mail is passed, even with kotlins null checking it is bad practice to return magic values on error. You can do parameter checking on construction with an init block.
Per docs *One of the possible use cases of provideDelegate is to check property consistency when the property is created, not only in its getter or setter.* My query here is how can this encode the same semantics as a factory method which simply returns a valid `Email` or `null` unless you can encode short circuiting and returning `null` for the entire `Email` upon a single property being invalid. The examples provided in the docs seem to have a lot of boilerplate just to do what a simple factory method could do in a couple of lines. The (docs)[https://kotlinlang.org/docs/reference/delegated-properties.html] are frustratingly vague as they omit the implementation details. Are you able to provide an implementation as I am currently only evaluating Kotlin and am not really familiar with it. Also, I cant find anything in the docs that says you can delegate from within a `data class`. If delegation can only be done from within a `class` then there is no point as you still have to implement equals and friends. 
Fair point, I just wanted to avoid throwing exceptions as I hate that style of programming of try/catch ceremony but its probably the most idiomatic thing to do. I was also keen to investigate this approach to use an `Either` type explaining the errors or a valid `Email`. But I guess its not possible so throwing Exceptions is probably the next best thing. To reduce try/catch issues using `Try` from https://github.com/MarioAriasC/funKTionale or rolling your own could improve this aspect while not being perfect. 
 requireThat(result) { not(isNull()) } Should throw a `NullPointerException` instead of an `IllegalArgumentException`. See "Effective Java". Although I like if code reads a bit like a written sentence, I would prefer the shorter `check` or `require` here. requireThat(value) { not(isBlank()) } vs require(value) { not(isBlank()) }
Try is an expression in kotlin. It's fairly easy to deal with.
I get it but `label`s are frowned upon in Java as well for the same reason: they are like goto-s in a sense that by using them it creates a mental page fault when you try to follow the logic. I actually never had to use them in Java nor in Kotlin. I think it is a niche feature which is good to know about but not a best practice.
Also don't use Swing anymore. Go for JavaFX unless you have to maintain a legacy app. And if you want to write good JavaFX/Kotlin use [TornadoFX](https://github.com/edvin/tornadofx/).
Maybe take the middle road - provide the factory method, but also throw an exception when an invalid value is passed to the constructor. That way, code using the class the correct way doesn't have to deal with exceptions, and code using it incorrectly at least won't create an invalid application state.
You could insert an explicit cast to fix that.
The [most recent change to the CHANGELOG.md](https://github.com/JetBrains/kotlin-native/commit/93445f5546b66b1fec29deec94e0fe91d04215ec) says "v0.3.4 preparations". So v.0.3.4 hasn't been released yet, but will likely be released soon.
Labeled returns have deterministic outcomes. So the validity of the program can be reasoned about. goto does not.
Yea maybe the delegates dont work because of primary constructor val stuff, maybe i will check later. Why dont you use an init {} block and throw an exception there? Cleanest solution.
And then you'd need to suppress warnings on an unsafe cast - on every method like this.
True, but I wouldn't consider that a problem for a small utility library whose purpose is to "extend" the type system like this.
I was taking about something completely different. Please re-read my comment.
Its not a bad idea except you need to repeat validation logic twice and still provides a back door to get run time errors which is annoying. In the end I just wish the language supported this properly but after thinking about it some more its probably quite a difficult thing to solve. The only way I think is sound is to not provide a factory method and just throw exceptions in the init method. 
KotlinConf is next week - 2nd - 3rd November
How about only doing the validation in the constructor, and make the factory function use that by just returning mull when the exception is thrown? Not elegant, but makes it work without validation logic duplication.
Was it organized before? Are those videos available?
No, the videos from the conference taking place November 2-3rd are not available on October 25th.
He is asking about previous KotlinConf videos (if happened).
Not yet, it's first Kotlin conference.
Can someone explain why isn‚Äôt it the default practice nowadays? Is it logistics? Tech? Priorities? I mean, besides making money, what‚Äôs the real point of making a conference for a fee hundred people and not being able to share all that knowledge later on? There is a lot of conferences happening in US that so many people can not join due to distance/time/whatever. I don‚Äôt get why most don‚Äôt even offer the option for free or even paid streaming later on.
Money.
I'm going, who else? 
This will be the first one.
That's good there were a few I wanted to see that are happening at the same time in the survey.
To expand on this, if the default practice is that all sessions are available for free online, why would I pay for a ticket? These type of conferences exist to make money. Some of that is in expected future sales of products/services. While "getting your name/product out there" has some minimal value, the real draw is for the sales/account/whatever reps to press flesh with developers and decision makers at companies large and small. They want to get you on a mailing list. Find out who you report to. Get you to intro them/offer free consultation/etc. to your CIO/enterprise architects/etc. The other money maker is raw ticket sales. Yes, convention centers are expensive, but that's not the only reason that conference tickets are so expensive. Free videos detract from that.
If you have objects that don't fit inside a [`use`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/use.html) or a try-with-resources block, how do you ensure you're handling it safely? This article is my answer.
Thank you for your feedback. I will think about throwing the NullPointerException. I will add require and check as an alias in the next release.
Can you explain why you mark the instance variable as `@Volatile` even though it's only being assigned inside a synchronized block?
`invoke()` is not synchronized. So thread #1 could call `closerObject.open { ... }` but then thread #2 might immediately afterwards do `closerObject()` and get a stale answer. There are two ways around this: synchronize `invoke` (expensive) or declare `wrapped` as volatile (cheaper). See "Pattern #5: The cheap read-write lock trick" in https://www.ibm.com/developerworks/java/library/j-jtp06197/index.html.
Curious what the use case if for a factory method to create a data class? This feels like a Java-ism leaking into Kotlin but not a particularly good one (factory method on a concrete implementation). Factory methods are great for abstract types and the such where there may be logic that changes what is returned in the method call... not so much as alternatives to the constructor. Just use the constructor and an init block or providesDelegate.
The use case is DDD value objects as explained in original post which is very common. You create a type instead of using primitive values everywhere which have no semantic meaning / type safety. Its not java specific its just general good coding style. You are referring to factory methods in the traditional OO sense such as factory constructors, but a factory method here just provides a way to ensure you cannot create an illegal type without throwing ugly exceptions. Why am I thinking this is an issue? Well you have a data class, its perfect for specifying a simple type and having all boiler plate written for you. Since you cant have a factory method, you need to use a class. When you use a class you need to write out all the boilerplate yourself so you may as well just use java and drown in the noise. By using data classes you can create lots of types in the same file and makes it easier to see your domain model. If you have to now use classes you have an explosion of boilerplate code that isn't relevant to what you are trying to model which is the reason this would be nice to be able to use data classes for in combination with validation. But yes, looks like init block and throwing is the kotlin way to do this. providesDelegate method is not clear but if you can provide an implementation id love to see it to compare.
I think it would be clearer if the function passed to close accepted an explicit argument rather than being an extension function. 
Thanks for looking and for the feedback! I went with an extension function because it seemed like the most common use case is simply to operate on the object. For example, to close a thread I would use `rxThread.close { interrupt() }`. With an explicit argument it would be `rxThread.close { it.interrupt() }` which didn't seem any clearer to me.
hey eveyone please provide suggestions i have just started my channel
Here is a list of threads in other subreddits about the same content: * [Kotlin programmer dictionary: Function vs Method vs Procedure. Enjoy ;)](https://www.reddit.com/r/androiddev/comments/78u1gk/kotlin_programmer_dictionary_function_vs_method/) on /r/androiddev with 1 karma (created at 2017-10-26 15:38:25 by /u/MarcinMoskala) * [Kotlin programmer dictionary: Function vs Method vs Procedure. Enjoy ;)](https://www.reddit.com/r/programming/comments/78u0zl/kotlin_programmer_dictionary_function_vs_method/) on /r/programming with 1 karma (created at 2017-10-26 15:34:22 by /u/MarcinMoskala) * [Kotlin programmer dictionary: Function vs Method vs Procedure. Enjoy ;)](https://www.reddit.com/r/KotlinAndroid/comments/78ty3m/kotlin_programmer_dictionary_function_vs_method/) on /r/KotlinAndroid with 1 karma (created at 2017-10-26 15:12:35 by /u/MarcinMoskala) ---- ^^I ^^am ^^a ^^bot ^^[FAQ](https://www.reddit.com/r/DuplicatesBot/wiki/index)-[Code](https://github.com/PokestarFan/DuplicateBot)-[Bugs](https://www.reddit.com/r/DuplicatesBot/comments/6ypgmx/bugs_and_problems/)-[Suggestions](https://www.reddit.com/r/DuplicatesBot/comments/6ypg85/suggestion_for_duplicatesbot/)-[Block](https://www.reddit.com/r/DuplicatesBot/wiki/index#wiki_block_bot_from_tagging_on_your_posts) ^^Now ^^you ^^can ^^remove ^^the ^^comment ^^by ^^replying ^^delete!
Strange, it feels like the 90's when we were getting introduced to OOP.
Thank you - that's an excellent article.
&gt; But yes, looks like init block and throwing is the kotlin way to do this. I think one can boil down the problem to constructors in general - they are the single mechanism that creates objects. It's defined that a constructor call can't return null (and you don't want that). Has nothing to do with Kotlin at all. Exceptions are the way to signalize problems during constructor executions. Maybe there are languages that completely omit constructors (and implement kinds of factories or stuff), but all other languages have the same problem. Since it's best to have objects immutable, a copy constructor seems to be a must. If you would want to hide it (and that should really be a rare case), why don't you use an interface, as one should do with factories? class EmailProvider() { companion object { fun create(email: String) : Email? = try { SimpleMail(email) } catch (e: Exception) { null } } } interface Email { val email: String } private data class SimpleMail(override val email: String) : Email So there are "good coding styles" that can help you with, for example information hiding. Data classes and their autogenerated methods are a convenience feature, that solves 99% of the problems you have with data holders. It's Kotlin's philosophy, that not every last bits some people may need is provided with full convenience, I think. For most people, this is a good thing. Ah, and the delegation stuff wouldn't work for data classes in this case, because one has to accept vals in the primary constructor, which is not what you want if you only use regular parameters in the primary constructor.
Thank goodness. I‚Äôve been super tentative about using it for Kotlin since I didn‚Äôt know how stable the behavior was.
kotlin was actually pretty stable in 2.3.3.. you just had to download the plugin as it didnt come preinstalled
I meant more so inside of Android Studio. I love kotlin as a language, but I prefer to only use Betas for personal projects.
Yeah I was talking android studio 2.3.3. ive been using that plus the kotlin plugin for awhile now. Neither were beta
And people are still having problems with that xP The point is that this is first time explained for Kotlin
I have been using Kotlin as my sole Android programming language in AS 2.3 since March of this year. Shipped the app in May and have over 20k users on it with 40% of them using it daily. Kotlin has been stable for a long time. This is an app used by a specific set of folks, not users in general. I use Flurry for bug reporting and analytics. It has worked out great. AS 3.0 makes it better of course. Don't be afraid to get in and learn Kotlin, you will just be mad you did not try it sooner.
Lmao at this thread in /r/Android who tf are the people in that sub?
Medium and github spammers? Eww
Good bot
Good bot
Thank you welkie for voting on DuplicatesBot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
My confusion probably came from lack of familiarity with the class being wrapped. I saw the release() call, but had to go look up the class to see where it was defined. 
Where is the linked graph from?
&gt; St. Pittsburg Damn, it‚Äôs Saint Petersburg
Lots of spelling errors in the article... ID's instead of IDE's all over the place.
Fixed it
I apologize. Transcribing is little hard, I try hard to get it right. I will review the article again and fix it.
I updated the article to make that more clear (I hope)!
No worries. Still a great read. Thank you :)
I think Single Expression Functions are one of the few things I don't care for. It's confusing to explain to people who aren't familiar with the language why there are two function definition syntaxes. 
I would have liked to have seen less features that aren‚Äôt also in Scala. This post makes Kotlin look s bit like Scala-lite
For people who want to see it like that, Kotlin will always be Scala-lite. That's because there are many features that both have, many features that Scala has and only a few things that Kotlin has and Scala lacks. For me, it's not a bad thing that most features are available in Scala too. What people should be aware of, is that it can be a good thing that Kotlin explicitely DOESN'T have such a rich feature set as Scala. Someone once said that Scala gives you everything a developer wants and Kotlin everything a developer needs. Kotlin focuses on not providing features that harm your codebase in sense of complexity, maintainability and so on. Fluctuating teams and Scala's steep lerning curve are also arguments for a smaller feature set.
What I miss most is properties and how they are treated throughout the whole language...including abstract properties on interfaces for kind-of multiple inheritance and delegation as a concept alltogether.
I actually miss the new keyword. It's nice when optimizing code. Tracking down object creation can be quite handy.
That‚Äôs an interesting point, haven‚Äôt been there yet 
I just remember once I had to optimize a view in Android that did animations. Locating potential object creation in the onDraw method was a breeze since I could just grep for the new keyword. Semicolons are I guess pointless but the new keyword actually indicates object allocation.
&gt; Tracking down object creation can be quite handy. You can just use "find usages" (Alt+F7) and look under the "New instance creation" category in the results.
But that gives you were a specific class gets instantiated (I think). Sometimes you want to know what classes are being instantiated within a class/file
IntelliJ does have a feature for this, called Structural Search and Replace (with a bunch of useful templates), but ironically, it [doesn't support Kotlin](https://youtrack.jetbrains.com/issue/KT-10176) üòÉ.
I will look out for this then :) on the other hand, this requires you to use intellij.
Android Studio has it too, but that's because it uses the same base. I also don't think they'll add Kotlin support any time soon - it just doesn't seem to be on the radar.
I have worked extensively with rx and find it to be a very mature and useful tool. You can handle each CompletableFuture as a stream, then merge the streams to get foreach-like behavior. Coroutines might be a better fit if you are sequentially calling asynchronous functions (async pull). Rx is better for event-handling (async push) 
As part of your analysis, I recommend looking at continuations as an alternative to directly working with CompletableFuture. There‚Äôs a module you can pull in which helps to do this called kotlinx-coroutines-guava.
Sometimes I'd like to declare multiple classes in a single file (or one "main" class and other "top-level" members), but when I do it the file icon in IntelliJ IDEA / Android Studio gets changed to a grey boring icon instead of the pretty class/interface icon. So I usually put everything inside a companion object to keep the icons looking nice. Yeah, I know, those are my criteria :) But seriously, I feel like declaring additional classes in a single file only for small classes (like enums, interfaces, etc) which are related to the "main" class. Otherwise, each class still goes to a different file. I guess I've got used to the Java-way.
Doesn't a getter in the interface and default methods achieve the same? That part of Java 8 can be used in Android.
I don't know if there are official guidelines, but I like to group semi-related data classes in a single file, especially if they are one-liners.
rx is mature, especially the creation of the Reactive Streams standard stabilized the most basic API. However, I suggest to give [Reactor](http://projectreactor.io/) a try. It is much like RxJava, but is technically a bit more up to date, since it uses Java 8 and doesn't have legacy interfaces. Reactor comes with an additional Kotlin API.
I use coroutine everyday: it is really powerful and it is easy to integrate coroutine with rx or CF.
I'm a core team member of Swagger Codegen. I'm a maintainer of the C# generators, and I've contributed the initial implementations for the Kotlin client generator, Finch server generator, and the .swagger-codegen-ignore file support. go-swagger is it's own project. It mixes some of Swagger Codegen and Swagger Annotations. I've heard good things about it, but I'm not sure about additional features or whatever that may be missing from Swagger Codegen. Have you considered contributing a Kotlin server generator? I've tried to make community contributions a little less intimidating by providing a `new.sh` script in the root of the project to get all the files in the right places. It's cutting it a little close for Hacktoberfest, but I'd be happy to assist if you'd like to contribute.
I prefer separating everything out, unless a certain class very obviously belongs with another, in which case I make it an inner/nested (I can never remember which is which) class. If there's a lot of classes that could fit inside another, I put them all in a subpackage (this is probably the only time I miss Java's package-private accessibility).
Her presentation is on her GitHub account ([here](https://github.com/svtk/kotlin-workshop)). You can also download the slides.
IT achieves "similar" things and i use it like that but the difference here ist really how to write it. An abstract property makes using interface implementations look much cleaner. Overriding a property is nicer than overriding getters and setters too. Delegation is Not covered by Java at all so i have to write it by hand.. those are two concepts i use very often, so ist really changes how my codebase looks and if its readable easily.
For real? Which programmer doesnt understand sich a simple concept i wonder :)
it's about using kotlin coroutines in android app
Unfortunately, 1 day != 86400 seconds in all cases. And I'm not sure using doubles to store the seconds inside each interval is a great idea due to their inherent inaccuracy. At the moment I don't see this providing anything that Joda or Java Time don't with their Duration classes except maybe a more kotliny interface. On top of that, Java/joda time AFAIK are more accurate and can optionally handle these types of conversion edge cases.
Very cool, good job. I'll give it a whirl tomorrow.
The plot thickens. In this case I think I understand what Kotlin is doing, but the Java compiler is baffling.
Thank you!
Well from Kotlin back to java may be... kind of okay.... But trying from Kotlin back to JavaScript.... I gave up...
Very apt, given that daylight saving was removed here in the UK at 2am
Nice write up ! A bit off topic question : wich tool do you use to generate the diagrams ? 
if I may: * new and Semicolon: really superficial. but we can talk about the clumsy syntax of 'range' in kotlin :D * data classes: alright, although copying and destructuring may be the most missing part * local function and single expression functions: private BooleanSupplier trueOrFalse = new Random()::nextBoolean; * default Parameters: miss them * with(): would be &lt;T&gt; void with(Supplier&lt;T&gt; supplier, Consumer&lt;T&gt; consumer) * List processing: as we used to do in java. utility functions: implement map, flatMap, filter.. will do the trick taking a List as parameter admittedly other features may be annoying to substitute like extension functions
I'll group related types and functions until they start needing scrolling up and down, then pull them out to try to keep to a single screen's worth.
The only proper suggestion: **Stop spamming** You are a **spammer** according to the **reddit wide rules** [**What constitutes spam? Am I a spammer?**](https://reddit.zendesk.com/hc/en-us/articles/204536499-What-constitutes-spam-Am-I-a-spammer-) You match **two** out of three rules: + If you flood a Reddit community with posts or comments, you may be considered a spammer. Instead, post one or two times and see what happens. + If other users in a community historically downvote your posts or ones similar to yours, but you feel the need to continue submitting them anyway, you may be considered a spammer.
It looks like there's an official one as well, for [Android](https://play.google.com/store/apps/details?id=com.jetbrains.kotlinconf) and [iOS](https://itunes.apple.com/us/app/kotlinconf/id1299196584?mt=8&amp;ign-itsct=1299196584-1299196584&amp;ign-itscg=0177&amp;ign-mpt=uo%3D4)
FWIW, that page does not work well on mobile
I know what you mean. Hope this helps others. 
Those are screenshots from Google Documents - I've prepared drafts there before moving it all to Medium. Probably not the best way to do this kind of things.
But with my app you can search as well ‚ò∫Ô∏è
Cheers, unfortunately we are in an aggressive timeline thats already taking weekend days so I just don't have time / joys of securing funding. Main reason I like go-swagger is the code generated is just very simple and easy to reason over. The swagger gen stuff from my first experience is pretty painful and only supports flat models which is frustrating. I seen one kotlin generator but looks a WIP, was hoping for a simple java one but they seem mostly springy or overcomplicated / enterprisey. Maybe in a month or so I could do something, I spotted 2 bugs with go swagger and the open api stuff it depends on which is also annoying for us, so plotting to fix them sometime too.
The documentation under /docs/reference is indeed real and official, but it's not a tutorial (at least not in the sense that we understand the word "tutorial").
The Kotlin client generator in Swagger Codegen does have some work to be done, but it should be usable for many cases (I've used it). A benefit for server generation (if you decide to contribute a generator) is that the model templates are already created. I'd like to eventually create server generators for Kotlin in Ktor, javalin, spark, and Spring. The main issue I have is with getting free time, so I feel you on that one. Open API 3.0 support is still a work in progress in swagger codegen at the moment. So if you're living on the edge, this could be an issue as well.
Not sure if this is exactly what you're after, but the contract module in http4k supports generation of live swagger documentation. It might be a little opposite to what you want - you define the typesafe HTTP contract in code and then the swagger doc endpoint is automatically generated. If you also supply it with example responses and then JSON Schema models are also generated. https://www.http4k.org/cookbook/typesafe_http_contracts/ Disclosure: I am one of the maintainers of http4k, so biases included above :) 
I'd be happy to accept contributions!
 ‚ÄúYou could touch the sky by building up your own temple, floor by floor, solving problems with mindfulness. Then you could live on that temple forever.‚Äù "Peaceful, isn‚Äôt it? And also true." I'm tellin yah, these functional guys are thinly masked religious zealouts. purity, bliss, damnation, temples, "truth", all of it, and everyone else is just heathens. When you solve the problem of performance (without creating new problems) once and for all, let me know. The rest of us will be down here on earth where we don't expect perfection.
It's really subjective. What platform are you targeting? Backend/frontend/Android/Native?
You have to take into account that this is a blog series to build up to more complex code and fewer contrived examples. There are several real case projects &amp; libs, and building up more as we speak. Lemme list a couple: Ank is a gradle plugin that executes snippets in readme files and we use in our docs to validate that the code is correct and up-to-date: https://github.com/kategory/ank/tree/master/ank-core/src/main/kotlin/io/kategory/ank It currently has backends for Kotlin and Java IIRC. This is a complete app in 3 different styles Jorge is building up to: https://github.com/JorgeCastilloPrz/KotlinAndroidFunctional Pablo is working in a DSL for UI test automation: https://github.com/Guardiola31337/uiagesturegen/tree/pg-uiagesturegen-dsl/uiagesturegen/src/main/kotlin/com/pguardiola/uigesturegen/dsl It'll be difficult to just show up with any of these examples and expect anyone without any previous background to understand them. It's something you build up to, like every other pattern. As for the performance problems I'd love to see numbers on them. Real numbers that point to issues we could look into. I'm working on our effects package that's precisely supposed to be snappy! We use the same IO that scala/cats uses, which is used by banks and startups alike.
Google ‚Äúhow to X in Java‚Äù. If the solution makes use of a library, Google ‚Äúmaven &lt;libraryname&gt;‚Äù. You will find a website that lists the maven central repository. Find the most recent version of the library, you can c&amp;p the string to add it to your build descriptor file for your build tool (pom.xml for maven, build.gradle for gradle etc.). Alternatively, download the jar directly and put to your classpath, which I don‚Äôt really recommend since you need to recursively download all transitive dependencies also manually if you go that way.
I've found this isn't always great because often times Kotlin solves many of the "X" as part of the standard library.
I'm targeting backend.
&gt; By convention on FP languages, when you present error and success cases using Either , the left side is used for the error type, and the right side for the successful one. I've never understood this paradox of claiming to strive for code correctness, purity and using type systems to support these goals and then picking `Either` to represent the duality of error/success and relying on... **conventions** to achieve that effect. If you are going to put multiple locks on your door, don't leave your window open. Don't use `Either` to represent errors, it's silly. Either use exceptions (their only downside is the loss of referential transparency but in all other areas, they are a superior way to represent errors to return values), or use an explicit error carrier such as `[Result](https://github.com/kittinunf/Result)`. 
&gt; For Dependency Injection we are gonna be using something with a quite weird name: The Reader Monad. The `Reader` monad is not dependency injection: it's dependency passing. You are still passing all these dependencies explicitly, captured in the type parameters of `Reader`. And for that reason, `Reader` is very cumbersome to use, especially when you start stacking `Reader` of `Reader`, which quickly requires the introduction of monad transformers. DI costs you referential transparency but results in much cleaner code that correctly maintains encapsulation (as opposed to `Reader` which completely destroys encapsulation by exposing private implementation details of your function to all their callers).
I am an Android dev so my knowledge of backend is pretty limited. That said, there are a number of microframeworks out there like [Ktor](http://ktor.io/), [javalin](https://javalin.io/), and many of the current frameworks have added Kotlin support (they worked before but added some nice Kotlin-only stuff) like [Spring](https://projects.spring.io/spring-boot/), [sparkjava](http://sparkjava.com/), [vert.x](http://vertx.io/). Here is a giant (overwhelming) list of links related to Kotlin that may or may not help: https://kotlin.link/ I would imagine you would want some db/json stuff: json: * Gson/Jackson/Moshi db: * https://github.com/JetBrains/Exposed * https://github.com/orangy/squash testing: * https://github.com/MarkusAmshove/Kluent * http://spekframework.org/ And since you mentioned beautifulsoup you may want to check out: * https://jsoup.org/ * https://github.com/mikaelhg/ksoup * https://github.com/fcannizzaro/ksoup
Awesome work! As concise as JSON / YAML but type-safe!
Yeah ktor what we prototyped with, simple little webserver / not 3 deep annotations I liked it. Awesome, will take a look at the kotlin stuff / have a play. I'm fairly driven to get these services/documentation working well as I fully intend to be around in a few months time with this. Yeah we didn't try to support Open API 3.0, the tooling just isnt there so on Swagger 2.0. Apparently in many respects its very similar so migrating in the future shouldn't be too hard assuming the tools work. We're not doing anything pushing the bounds, CRUD type interfaces with some oath. thanks
Thanks will take a look. I've been swung quite heavily on the documentation driven design of the API / behaviours of services and given we are greenfield I think we can make this work. But something like this would be awesome if we cant achieve that as it still ends up with in sync documentation which is what we'll need when it comes to some external testing. Thanks 
Why so emotional about functional programming?
The carrier in Kategory is called Try!
Hi! First of all, thanks for your good and detailed feedback. The Either choice depends on your architecture design, IMO. I am discarding exceptions mainly because those are not able to surpass thread limits. The target is mostly Android or people working over the JVM who work a lot with threads here. If you have a computation that can fail, the error should probably be part of the return type to avoid branching strategies listening to different triggers. Exceptions split your flow since you do not check just on return type for both successful and error results. Also, as I said, it's impossible to catch an exception from a different thread, so you are forced to map it to a different system like callbacks. In the other hand, using better error handling types as Try or Validate can be a better idea. I definitely agree, but the choice depends on how you represent those errors on your domain, and how you need to check on them or react to them. If we think about the target here, that people is really used to have very similar approaches on error handling that play very well with Maybe or Either types. That would be the main reason to pick Either here, apart from improving referential transparency. It would be nice to provide alternative error handling approaches using those clased inside the same architecture to compare and give the people taking a look at the linked repo have a broader scope on FP :). Feel free to provide those if you are up to! Also, never forget the scope on this post. Mostly Oop people looking for new approaches on how to make apps become Functional and pure. This is a series and more advanced techniques like monad transformers are part of the following posts in the chain :). Thanks for the feedback!
Interesting point of view here :) Apart from the naming you want to give it, what I do here with the reader is to just prepare the bindings on the view impl and let the rest of the architecture rely on them since those are being passed by the reader "implicitly" (without having anything to do with Scala Implicits) So it's very similar to what we can do with other systems like Dagger in terms of usage. You can call it dependency passing, depency injection, or whatever. But in the end you prepare a depency graph for one scope and pass it to let the readers unfold in he whole structure. And that helps you to easily switch those Dependencies by mocks at testing time. So to me, the real point here is what you get from it, not the name you give to it. Also, dependency injection is just passing dependencies in by constructor, field or method injection. The term does not really imply using automatic frameworks or anything. The concept is much more generic.
That's just a way to get people interested on the post, mostly a writing style. FP is good on solving problems once and reuse that generic problem solution on different apps or systems. That's why I picked the temple example. Actually, my intention on the post is to be as much objective as possible indeed. No intention on going emotional. If that's the feeling overall, then I failed on something ^^. Thanks for reading! ‚ò∫Ô∏è
I asked @DoctorOverhard why he is so upset by people using/talking about functional programming. Thanks for the blog series, I'm currently trying to get the hang of haskell and being able to try out some of the concepts of FP inside a known environment (Kotlin) is helpful :)
Thanks man! Glad that it's being useful for you :). No worries, any feedback is always a benefit. It's also interesting to notice that I'm not a functional dev but an OOP Android developer trying to step forward. Being a FP non objective FP zealot can't be on my plans!
I wasn't the one being emotional.
I think the name matters, and it's important to understand the difference between injecting and passing, because the latter (as encouraged by `Reader`) leads to an explosion of boiler plate while the former (Guice, Dagger) doesn't. Let's say your function returns an `Int` and that `Int` is read from some context (e.g. a configuration file). Here is the Dagger version: @Inject var context: Context fun myFunction() : Int = context.readSomeInt() Reader: fun myFunction(...): Reader&lt;Context, Int&gt; = ... First of all, I'd be curious to see you fill the missing code for the `Reader` function, just to make sure we are talking about the same thing. But even without that, notice that the `Reader` function has leaked some important information to its callers: that it needs some `Context` in order to do its job. There are multiple problems with this: - This breaks encapsulation. The callers to `myFunction()` shouldn't care how that function do its job. All they need is an `Int` from it, that's it. - When that implementation detail changes (say the function no longer uses a `Context` to retrieve that `Int` but a `Database`, then all the callers need to be modified. - The callers need to find out how they can pass that `Context` to the function. And again, they shouldn't care. - Of course, another problem now is that the return value is not a simple `Int` which would be trivial to use for callers, but an instance of `Reader`, which callers need to `flatMap` or `fold` over if they want to use them. This introduces even more complexity in what is a really straightforward problem. The DI version of that function has none of these problems. Its only downside is that it breaks referential transparency, something which I'm quite happy to sacrifice in order not to have all the problems enumerated above. This is why dependency passing leads to spaghetti code that quickly becomes unmanageable as you start adding more and more `Reader` instances and the need to combine them arises, which requires monad transformers. 
&gt; I am discarding exceptions mainly because those are not able to surpass thread limits. You use that same phrasing in your article but I'm still not sure what that means. I assume you mean that exceptions happening in threads get swallowed unless your surface them explicitly, which is really trivial and what most thread based frameworks do automatically for you (notably, Rx). And you don't have to surface them with callbacks: nothing stops you from throwing that exception in the calling thread after catching it. So I don't find this explanation to justify eschewing exceptions very compelling. &gt; If you have a computation that can fail, the error should probably be part of the return type to avoid branching strategies listening to different triggers. I don't see why. Using return values to carry errors leads to an explosion of error handling code in all the wrong places (basically, callers who can't do anything about the error are still forced to do something about it) and to the wrapping of values in some context (`Either`, `Result`, ...) which leads to having to `flatMap` or `fold` them in order to actually use them. Look no further than Go to see how bad this can get, where basically every ten lines of code has to check for errors and abort if the return value contains an error. It's also pretty much guaranteed that when you start returning errors in result values, you are going to reinvent what exceptions give you for free: error bubbling up the stack frames. Following from that, I find that using a separate return channel to carry errors makes sense, so that when you receive a value from a function, you know that everything went right and you can focus that part of the code on the happy path. The unhappy path can be implemented in a different location where it makes more sense. Exceptions are really a great way to represent errors in a vast majority of cases. 
&gt; I'm tellin yah, these functional guys are thinly masked religious zealouts. purity, bliss, damnation, temples, "truth", all of it, and everyone else is just heathens You wouldn't call that emotional? The author didnt say anything about OOP vs FP, but you got offended already?
&gt; fun myFunction(...): Reader&lt;Context, Int&gt; = ... I believe the problem is that the dependency isn't defined correctly. You can capture Context inside a lambda and use that as a parameter without leaking the requirement.
Sry man, thanks for your responses. I am driving whole day and it's a bit hard to answer to all those but will try during the following days :). What's the exact problem on using transformers? I mean, that's the idea. You collapse your concerns on a single type, like DI, error handling or IO computations and becomes really easy to use and compose. That's what I am writing about on the next post in the series.
Wow, you really are a good little follower.
Also notice that frameworks like Dagger or Guice expect OOP and instances to inject over constructors or fields, and what I am exploring indeed tries to achieve purity and gets rid of instances at almost any level on the architecture. I mean, almost everything is defined as a pure function at a package level, which requires Dependencies to do its work, as function parameters or provided by the Reader. Did you take a look to the sample repo?
I am not sure why you are bringing up transformers since I didn't even mention them (and I'm not even sure what you mean by that). 
I find instances and classes (or more generally, modules) useful in general to store complexity in places where it makes the most sense. The FP approach of going 100% with functions leads to code that is often spaghetti like because if you really want to be pure, every function needs to receive every single instance it needs to perform its work in parameters, which leads to function signature hell. I find that DI strikes a very good balance by separating the instances that can be injected from the truly dynamic instances that enter and exit your program once it's running. `Reader`and the more general approach of passing everything in parameter undermines readability and encapsulation. In my experience, a careful blend of FP and OO works great (but not the one offered by Scala). 
Kotlin's map, filter and reduce functions will inline the passed in lambda so it will be more efficient than Scala or Java in that regard.
I've done some research back in the old java days when to use checked vs unchecked exceptions: [When to choose checked and unchecked exceptions](https://stackoverflow.com/a/19061110/4706743) sums it up pretty nicely. The problem with unchecked exceptions is, that if your method regulary throws exceptions (e.g. DB-Lookup), the compiler doesn't enforce you to catch the exception, so you always have to be sure to catch exceptions at the right place. Thats why unchecked exceptions should be used for Exceptions that the client code cannot easily recover from. And there are no checked exceptions in kotlin, so the closest replacement for checked exceptions is putting the Error in the Return Type (e.g. `Either`, `Try`). The boilerplate occurs when you use those things inside OOP/imperative code, but inside FP code with Monadic computations it doesn't look that much different than having checked exceptions. Go has no notion of Monadic computations, thats why there is so much boilerplate.
Agreed. All my "always use" libraries in Java are taken care of by the Kotlin standard library and features, like guava.
&gt; The boilerplate occurs when you use those things inside OOP/imperative code, but inside FP code with Monadic computations it doesn't look that much different than having checked exceptions. It does because putting errors in return values impacts every single caller along the stack frame, whether they can handle that error or not. This is why you see at each level a test (pattern matching, if, switch) to see if the result contains an error and then either proceeding with the happy path or returning the error to the caller. And then doing that over and over again until you reach someone who can do about it. And by doing so, you're simply reimplementing manually what exceptions give you for free. In other words, you're adding boiler plate to your code base. 
&gt; This is why you see at each level a test (pattern matching, if, switch) to see if the result contains an error and then either proceeding with the happy path or returning the error to the caller. And then doing that over and over again until you reach someone who can do about it. - In Go? yes. - In Haskell or Scala? nope 
You see `flatMap` (or `for` comprehensions) in Haskell and Scala. Not as bad as the checks I was describing but it's still boiler plate over using the naked values directly and it obfuscates the code quite a bit (not mentioning the fact that all your code might be running over values that have an error in it, meaning it's doing a lot of busy work for nothing). Kotlin doesn't have any of that since it's predominantly using exceptions to represent errors. 
&gt; Are there any resources I could see about how Kotlin does things in the backend? Sure, just look at the source code and see what's going on! **filter** public inline fun &lt;T&gt; Iterable&lt;T&gt;.filter(predicate: (T) -&gt; Boolean): List&lt;T&gt; { return filterTo(ArrayList&lt;T&gt;(), predicate) } public inline fun &lt;T, C : MutableCollection&lt;in T&gt;&gt; Iterable&lt;T&gt;.filterTo(destination: C, predicate: (T) -&gt; Boolean): C { for (element in this) if (predicate(element)) destination.add(element) return destination } **map** public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; { return mapTo(ArrayList&lt;R&gt;(collectionSizeOrDefault(10)), transform) } public inline fun &lt;T, R, C : MutableCollection&lt;in R&gt;&gt; Iterable&lt;T&gt;.mapTo(destination: C, transform: (T) -&gt; R): C { for (item in this) destination.add(transform(item)) return destination } **groupBy** public inline fun &lt;T, K&gt; Iterable&lt;T&gt;.groupBy(keySelector: (T) -&gt; K): Map&lt;K, List&lt;T&gt;&gt; { return groupByTo(LinkedHashMap&lt;K, MutableList&lt;T&gt;&gt;(), keySelector) } public inline fun &lt;T, K, M : MutableMap&lt;in K, MutableList&lt;T&gt;&gt;&gt; Iterable&lt;T&gt;.groupByTo(destination: M, keySelector: (T) -&gt; K): M { for (element in this) { val key = keySelector(element) val list = destination.getOrPut(key) { ArrayList&lt;T&gt;() } list.add(element) } return destination } Thanks to lambda inlining, there is zero overhead. It's basically impossible to write more efficient code by hand. 
Just what I was looking for
Are Scala transformations really that slow? The JIT *should* be putting short-lived objects on the stack, no matter the language. They all compile down to JVM bytecode. If you have a large collection and/or a large chain of operations, Java `Stream`s and Kotlin `Sequence`s lazily evaluate their transformations on terminal calls like `toList()`, which can sometimes be more performant. Kotlin has `mapNotNull` which is equivalent to filterMap. Might be more performant than filter + map in some situations: listOf(1, 2, 3, 4, 5).mapNotNull { it.takeIf { it % 2 == 0 }?.times(2) }
Yeah, in some cases you probably get some boilerplate, but you trade it with more safety. I don't think its obfuscating the code, but OOP people are just used to other code styles and so don't graps the meaning of FP code as easily. About the performance part: IMHO it doesn't make much of a difference. Constructing and throwing an Exception is slow (the deeper in the stack the Exception is thrown, the slower it gets). So compare that to a couple of if statements when using `flatMap`. As Alexey Shipil√´v (a Hotspot performance engineer) would put it: &gt; If you didn't want exceptions to ruin your performance, you shouldn't have used them for the regular control flow [The Exceptional Performance of Lil' Exception](https://shipilev.net/blog/2014/exceptional-performance/)
Class 'Car' in kotlin seems very strange, why not to make it data class with all defined fields in constructor? And as far as I know it won't generate you equals/hashcode/clone for such class if it's not data class
&gt; Thanks to lambda inlining, there is zero overhead. It's basically impossible to write more efficient code by hand. That's true when calling only one function. It is inlined so code will be equivalent to code written by hand. But if you call `list.map { ... }.filter { ... }` then two lists will be created while by hand you can do it with just one. There is a slight overhead.
Also there is newer version of kotlin than 1.0.4, it's 1.1.51
&gt; There are cases when working with streams is more efficient. Sure, and you can use streams (aka sequences) in Kotlin just fine: list.asSequence().map { foo }.filter { bar }.toList()
&gt; Yeah, in some cases you probably get some boilerplate, but you trade it with more safety. I don't really buy this, but happy to hear some back up evidence for this claim. Exceptions are statically checked and checked exceptions guarantee that you just can't get your code to compile until you have thought about the error case. If you show me safe code written with `Either` or a similar mechanism, I guarantee you I can provide a similarly safe code using exceptions. &gt; IMHO using Exceptions for regular code flow is slow This is heavily dependent on not just the language but the compiler you use for that language. And even so, I'd argue that exceptions stopped being a concern for performance in most mainstream languages (C#, C++, Java) years ago. &gt; If you didn't want exceptions to ruin your performance, you shouldn't have used them for the regular control flow You should never use exceptions for control flow, but that's a totally separate topic. 
&gt;streams (aka sequences) Careful with that, they're not the same thing. Kotlin Sequences don't replace Streams, and they don't use them in the background. In a lot of cases, you can replace streams with sequences, but there are some important differences, like that Streams are single use only, while sequences can be reused, for example.
Thanks, I stand corrected!
&gt; Awesome work! Thanks! &gt; As concise as JSON / YAML but type-safe! That was my intention, I was tired of writing JSON or YAML for my API Specs. Now I can do this without looking up the docs :) And since vertx.io has the OpenApi3RouterFactory it is a nice match IMHO.
&gt; I don't really buy this, but happy to hear some back up evidence for this claim Oh, I phrased it wrong. It doesn't add type safety, but it makes code overall more safe, because it enforces the code to handle the error case. In Kotlin there are no checked exceptions, so there is no guarantee that your code handles an exception. It is possible that exceptions occur in rare cases that you didn't catch and only happen to occur in production. &gt; Even so, I'd argue that exceptions stopped being a concern for performance in most mainstream languages Creating and/or throwing Exceptions are still more expensive than a couple of if-statements. &gt; You should never use exceptions for control flow, but that's a totally separate topic. How would you implement a method `login(userName, password): Boolean` that can return errors like *UserNotFound*, *WrongCredentials*, *AccountNotActivated*?
&gt; Creating and/or throwing Exceptions are still more expensive than a couple of if-statements. Technically, sure. In practice, you will probably never notice the difference. I have yet to see a profiler dump where exception throwing or creation is at the top. 
I love me some tornado FX!
There is also leap seconds to consider.
keep in mind sequences have to pass in non-inlined lambdas to transformation functions due to the nature of being lazy. 
&gt; The FP approach of going 100% with functions leads to code that is often spaghetti like because if you really want to be pure, every function needs to receive every single instance it needs to perform its work in parameters, which leads to function signature hell. You can lump items together in data classes, the same way old uncle bob recommended for OOP. There's also partial application &amp; closures to reduce those signatures.
Partial application doesn't come anywhere near being able to fulfill these requirements since it is fundamentally crippled, starting with the fact that the parameter ordering is fixed in stone, i.g. you can partially apply `f a b` as `f a` but not as `f b`. Parametric polymorphism, inheritance with delegation and function overriding, on the other hand, are extremely flexible mechanisms that have proven to be remarkably adaptable over the course of decades. 
I benchmarked map for my talk at KotlinConf. The inlining means that applying the transformation is efficient, but the actual iteration can be surprisingly slow, as it relies on iterators. 
I stand corrected, again!
Stack allocation is actually more rare than I'd like with the current jit. But short-lived allocation is pretty fast so it's usually fine.
&gt; i.g. you can partially apply `f a b` as `f a` but not as `f b`. I literally wrote a library that does that. https://github.com/pakoito/RxPartialApplication look for "apply" and "applyEnd" in the readme. Yes there's no "apply" function in the library to apply the third parameter out of nine, but you can still ad-hoc it with a simple lambda and it'll work for all functions, forever: fun &lt;A, B, C, D, E, F, G, H, I, R&gt; ((A, B, C, D, E, F, G, H, I) -&gt; R).applyThird(c: C): (A, B, D, E, F, G, H, I) -&gt; R = { a, b, d, e, f, g, h, i -&gt; this(a, b, c, d, e, f, g, h, i) } The number of such functions to cover all cases with N parameters is the sum of (N - 2) for N &gt; 2, so for 10 parameters it's 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 = 36. I can write those 36 functions in less than an afternoon and never worry about whether I can partially apply anything for all projects in Kotlin, forever. &gt;Parametric polymorphism, inheritance with delegation and function overriding, on the other hand, are extremely flexible mechanisms that have proven to be remarkably adaptable over the course of decades. That flexibility and adaptability (?) are a footgun as stated in my previous post. It needs patches in the form of frameworks and annotation processors, and cargo cult concepts like craftsmanship and engineering honor to prevent them from pointing at your feet. And you still shoot yourself more often than not. So far every single of your posts has been based on a misconception about FP, and a sweeping generalisation that reaffirms that you're just happy where you are now and would rather things never changed.
And the same applies to if statements inside the happy path. Usually they do not lower the performance that much. And even if they add a little bit overhead, I'll favour FP, bcause it not only makes the code safer, but it can give you referential transparency, better reusability and thread-safe-ness too
&gt; Moreover Kotlin coroutines works in JVM at this time, Wouldn't that always be the case?
&gt; I literally wrote a library that does that. and a few lines later: &gt; Yes there's no "apply" function in the library to apply the third parameter out of nine, So... no. You didn't literally write a library that does that. &gt; That flexibility and adaptability (?) are a footgun as stated in my previous post. It needs patches in the form of frameworks and annotation processors, and cargo cult concepts like craftsmanship and engineering honor to prevent them from pointing at your feet. And you still shoot yourself more often than not. Hundreds of millions of lines of code today are written using these features, so they are doing something right and enable us to tackle modern engineering problems. And by the same token, monads are a band aid which themselves require a gigantic machinery of additional concepts to be truly useful, such as monad transformers, sophisticated type systems with a plethora of extensions and arcane concepts (not just talking about the implicit mechanism that Scala uses to emulate them but also all the pragma that even Haskell has introduced in ghc to support them), etc... And even despite that, monads still carry heavy downsides that invalidate well established computer engineering principles, such as `Reader` breaking encapsulation and leading to an explosion of function signature hells. &gt; The number of such functions to cover all cases with N parameters is the sum of (N - 2) No, it's factorial of N. If you have a function `f(a,b,c)`, `f(a)` returns a function that takes `b` and `c` in parameters, `f(b)` returns a function that takes `a` and `c` in parameters, etc... It's actually more if you are trying to emulate the mix of named and positional parameters. Partial application is a useful functionality but only in a very limited number of scenarios because it just doesn't scale and offers nothing remotely close to the flexibility that you get from a language that supports optionally named parameters. 
https://imgur.com/Kkjmiky
For primitives in particular beware of boxing which can make expressions like that more costly than you‚Äôd think. 
yep, consider IntArray or whatever if it is *really* a problem (or if you are interacting with java code that expects int[])
You can use markdow format to include links.
True, was just a contrived example to demonstrate mapNotNull. `IntArray`s have no `mapNotNull` but they do have a method `asList` which simply wraps the original array. Would calling `mapNotNull` on that list still incur boxing?
[https://kotlin.link/](https://kotlin.link/)
What's the equivalent version of the Java library?
Or just start them with `http(s)`.
This release uses the latest `6.0.0` version of the original Java library.
`IntArray.toList()` will create a new `ArrayList` with each of the original array's items boxed
Have them make something. Sadly, that is probably not a one session thing. Maybe a cool local note-taking app? Data layer, save locally in a database, all that mvp stuff. Tell them how they can improve it later, file attachments, cloud backup (with dropbox maybe for free), implement fingerprint auth if they want. OR a timetable app, with assignment reminders. OR a combo of both.
You could enforce it at runtime through reflection but I highly doubt it's enforcible through the type system without some codegen. Annotations are for metaprogramming, which is for working around the limitations of the type system. Any reason why Id isn't an interface? This is exactly what they're for. You could do some codegen/annotation processing to have annotated classes automatically implement an interface but that sounds very unintuitive.
&gt; Any reason why Id can't be an interface? Because it's much easier to write @Id(3) class MyClass() than class MyClass():MyId(){ fun getId() = 3 }
Then that's an awful reason. Avoiding one of the core features of the language to save about 5 keystrokes? It just makes it harder for anyone reading your code to understand what's going on. Besides, for implementing overrides you might as well use Alt+Insert or Ctrl+Space in IntelliJ. All the boilerplate is done for you. That snippet is invalid, and Kotlin has properties so you might as well use them. interface Id { val id: Int } class MyClass : Id { override val id = 0 }
This link was "submitted 24 days ago by addamsson".
Why are you linking to /r/Androiddev instead of here: https://engineering.udacity.com/adopting-kotlin-c12f10fd85d1
Trying to avoid repeated links across subreddits.
But why? Reddit has a "other discussions" feature on top of the page, that groups all posts with the same link.
Can't wait to try the Kotlin Native support in CLion!
Nice thank you for sharing.
I am speechless... this is so great. Do you guys know where and when can we find videos of the conference ?
I'm stoked on the multiplatform support, finally!
This is so great! i was hoping for a CLion plugin and they did it! Thanks a lot!
They said they're going to post videos of all the sessions, so stay tuned I guess?
Fuck off.
I know to avoid most of those.
Are there any informations about how dependency management will be done with kotlin native? Will I be able to depend on artifacts from a central repository (maven like)?
World domination. I love that.
This is a weird list 1. No one needs to know github specifically. There are plenty of online remote git repos as a service like BitBucket and GitLab. Git on the other hand. Is essential knowledge nowadays. 2. No. No self respecting developer needs a GUI for git. I know designers tend to get freaked out at ‚Äútyping‚Äù commands, but it‚Äôs in no way necessary or required knowledge dealing with a dedicated git GUI. Also, what? Windows, iOS, and Linux? Did author by chance mean ‚ÄúmacOS‚Äù? 3. Stack is not a ‚Äútool that every developer needs‚Äù. It‚Äôs a site that they‚Äôll inevitably find when punching in an obscure error code sure, but not every developer needs this kind of Q and A. No, they NEED to learn to read the docs. 4. Why is this here? Slack? It‚Äôs a IM platform, one of a bajillion, and most certainly not a TOOL that a DEVELOPER, NEEDS. It‚Äôs an office or team decision and everyone will use whatever is decided thereupon. There‚Äôs plenty of active support and community channels across things like IRC as well. 5. I‚Äôve never heard of diffblue, but I also know how to sniff out tools that‚Äôll put myself further in shit land when I see anything that has to do with automating inheritantly infinitely organic things like bug fixing.. 6. Omg finally a ‚Äúthing‚Äù that could actually belong on a list like this. Certainly, CI/CD is becoming a job requirement of the modern code monkey. Jenkins may not be the best but it‚Äôs not the worst, but it is mainstream enough that it‚Äôs a gold star on a devs resume. 7. While I‚Äôm not going to argue Snorts usefulness and sure it should be in more people‚Äôs toolbelt, I‚Äôm not going to recommend it as ‚Äúevery developer should know‚Äù 8. Spark. I get it. But unless your working enterprise and big data, it‚Äôs a lot of effort for not much gain. Again not ‚Äúevery developer should know‚Äù 9 &amp; 10: two competing text editors. Interesting. ‚Äî- Here is my proposed list replacement: 10. **A micro framework**, in your preferred tech of choice. This is for knowledge and experience in building microservices and small tools. 9. **A monolithic framework**, in your preferred tech of choice. This is for experience and knowledge in building the more complex apps and tools with lots of visual output requirements. 8. **Docker** or equivalent container subsystem. Docker is pretty popular though. 7. **Jenkins** or equivalent CI/CD build system 6. **vim**. Because at some point you‚Äôre going to need to deal with editing text via a CLI for one reason or another, and knowing how to make edits and exit vim will become the norm at some point in your Developer life. 5. **A task runner** of your choosing. Things like Grunt, Gulp, Ant, etc etc all fulfill the same fundamental concepts, all executed via cli commands. Get used to it. 4. **Multiple languages** that fulfill different needs. Hey, maybe you‚Äôre a web slinger, even if you‚Äôre a front end guru who can throw JavaScript around like it‚Äôs nothing, may be useful to learn a server side language that isn‚Äôt Node. Perhaps you‚Äôre a C++ Developer, sometimes it‚Äôs nice to make little tools in Python to aid the project. The list is endless. This is more for knowledge sake than anything else. Like a mechanic knowing how to handle multiple types of of makes and models of vehicle, so too should software people understand what makes their world tick in multiple ways. You‚Äôre one language utopia is a pipe dream, and will never happen. Branch out, your career deserves it. 3. **A database system** of some kind. Knowing how to persist data and retrieve it is useful pretty much anywhere you go as a developer. Even if your job specifically won‚Äôt be dealing with databases, the knowledge of how data is stored and queried back out will help in understanding the flow of where data is coming from 2. **A http request management tool**, like PostMan. In this day and age of micro-services galore, your data retrieval needs are more increasingly likely to be through API interfaces. Having a request manager that can save queries and organize them for later will become an essential aspect of your day to day. 1. **Git**. It doesn‚Äôt matter how or why anymore. There are other SCM systems out there, but chances are pretty damn high you‚Äôll be running with a team that uses git, either in part of their workflow or in whole. It also doesn‚Äôt matter which way you use it, whether through CLI or GUI, it matters essentially that you know how to use it and understand its concepts beyond basic clone, pull, commit, and push duties: you need to know how handle git when shit goes sideways. May notice my list is pretty vague aside a case or two. That‚Äôs the thing about being a developer: the tools we use are mostly interchangeable. Nothing in this profession is one size fits all. Back end, front end, full stack, compiled, interpreted, transpiled, it doesn‚Äôt matter. We‚Äôre all writing code to solve a problem, big or small. The specific IDE or text editor I use, I‚Äôve chosen because it helps me get my job done faster in a way I like that helps me produce results I like. Like sliding into new vehicle, sometimes even if it isn‚Äôt the most sexy thing on the lot, most of this stuff is just what feels right. It‚Äôs entirely a subjective thing. Just be prepared that the next job you want may not be able to use your choice tool, and have instead opted for something else. The knowledge you‚Äôve gained from what you have used, should be enough of a stepping stone to learn the new thing, combined with an open mind of course. 
Awesom
Not cool to share this, it's not that expensive, just buy it.
Written by someone who's totally not a developer.
Sorry for reviving something so old. I have been trying to learn Scala recently but somewhat quickly realized some of those pitfalls especially since I don't have an academic background and I want to continue learning FP just to learn but I think I'll prioritise Kotlin for business value. Anyways, what are your thoughts on FP based Kotlin then? Or even with Scala, how do you find the right "mix"?
Sorry for reviving something so old. I have been trying to learn Scala recently but somewhat quickly realized some of those pitfalls especially since I don't have an academic background. I want to continue learning FP just to learn but I think I'll prioritise Kotlin for business value. Anyways, what are your thoughts on FP based Kotlin then? Or even with Scala, how do you find the right "mix"? Is FP just too much hype? etc
YES. I just dove in to Android dev and it was so easy. Now i'm on the iOS side and can barely get off the ground. I'll gladly convert this Swift codebase to Kotlin down the road. (Not saying Swift is bad, XCode is the main offender)
Stackoverflow has been 100x more important for me in my career than vim. Actually, more than that. I've had to develop some rudimentary vi and nano skills, but I consider that due to technological failings on the part of the company I worked for, not necessity. Everything else you day I'm totally on board with. Although aren't gulp and grunt a little dated? I thought all the cool kids use webpack now. It takes like 2 months to become dated in JS land. _sigh_
Congratulations, you are now clearly a better tech journalist than 98% of 'x you should y in t' writers. Put this on a website with adverts.
Yes I agree but stack is not a tool in your chain, it is a resource for help. And it‚Äôs not always going to produce results that‚Äôll help. I‚Äôve gotten the same ‚Äúhere try this‚Äù help from users in issue threads, message boards, documentation examples, README‚Äôs, repo forks, hell even Quora‚Äôs helped out sometimes. Stack is just a resource. If we wanted to argue about stacks place and whether it even deserves to be on the list, here‚Äôs my compromise: Learning proper google-fu to find the best result to your problem. Additionally that‚Äôs exactly what I‚Äôm talking about when it comes to vim. It doesn‚Äôt matter if it‚Äôs failure on the thing in question or not, you‚Äôve had to use it. And being as such that vim is quite special, you‚Äôve had to learn how to basically use it to get by. Whether it‚Äôs editing a file in a docker container, manipulating a file on a VPS, or even editing a commit message in git after resolving some conflicts: vim will happen. Secondarily I totally agree, the task runner item is a bit questionable now that some even weirder shit like webpack is here that doesn‚Äôt quite fit that description anymore. I‚Äôve even used webpack, and I look forward when too that thing becomes obsolete. Wasn‚Äôt a fan. But I used it, and will continue to use it where appropriate lol (though I look forward to the day it too becomes obsolete üòè)
Why do you want to use it with Flutter? I can't see any benefits.
I don't think this is possible at the moment and given that Flutter is still in alpha, I doubt they'll be adding this feature any time soon. However, given that Google is pushing Kotlin so much and Flutter is a Google project, I could definitely see them making Kotlin a supported language for Flutter &amp; Fuchsia. You might want to ask in r/FlutterDev.
Fair enough. And yeah, webpack has been a spaghetti filled nightmare the couple times I've used it.
Have you tried AppCode? I don't do iOS, but some iOS developers have told me that it's pretty good. 
Thats what I'm currently using, its just annoying having to switch from XCode and AppCode. Also the inspections (for swift at least) are pretty darn slow on AppCode compared to other languages on IntelliJ/WebStorm/Ect.
Good news! I just tried it with a "Hello World" example on Linux and it worked. However, the binary is 9 MB. Is there any way to make it smaller?
But in this Case Kotlin must compile to Dart and not to native. Flutter doesn't uses the OS UI components, it draws everything itself on a canvas. And all this drawing stuff is writen in Dart. If you use Kotlin/Nativ to compile to native you dan't have UI components. If you want to use the Flutter UI components you have to compile Kation to Dart to access the Flutter widgets.
You can `strip` the symbols from it. I have a binary from a project slightly larger than Hello World (~2500 LOC + 2 library interops), and the stripped size is about 850kB. Though I think it was smaller originally as well.
There was a guy on the #kotlin-native Slack channel who's been experimenting with using [flutter engine](https://github.com/flutter/engine) with Kotlin, but hard to say if it's ever going to amount to anything. Even then, there would obviously be no interop with Dart, just a similar way of writing cross-platform applications.
Thanks! With `strip file.exe` the size went down to 4.7 MB.
Still way too big.
Thanks! The release version's size is OK, it's 469 KB on my system.
Hooe it will have some support in normal intellij. all wr niw need are bindings to popilar libraries and guis
Which still seems really large for just a Hello World...
He implies that the KotlinConf talks will be made available on Netflix, which is a bit surprising. While it's better than nothing, it's behind a paywall. Not the correct way to spread the word about Kotlin.
No, I was being ironic. JetBrains have said that the videos will be public 
Alright, thanks for clarifying. You never know :)
Meh. It's about on par with the default [Rust](https://www.rust-lang.org/en-US/faq.html#why-do-rust-programs-have-larger-binary-sizes-than-C-programs) hello world. Go produces even larger binaries (1.5 MB), but those are all statically linked, so not directly comparable. As long as the size doesn't grow too fast as you add more code and libraries, it's perfectly fine for the vast majority of practical uses.
tl;dr?
Implementing the GoF Visitor pattern in Java is messy because the compiler can only resolve an overloaded `visit()` method statically. To get around this you need code in each class that can dispatch properly based on it's own type. In Kotlin, sealed classes and `when` expressions let you implement the behavior of the visitor pattern without all the boilerplate. Obligatory critique: the proposed Kotlin solution reads much better but is not as performant because it swaps a single O(1) method indirection for an O(n) search across types for each visit. Hmm someone may have to TL;DR this TL;DR.
&gt; the proposed Kotlin solution reads much better but is not as performant because it swaps a single O(1) method indirection for an O(n) search across types for each visit. At least in Scala, [that hasn't been the case for 10 years now](http://www.scala-lang.org/old/node/9777): &gt; **Martin Odersky:** Much earlier, Scala used to compile pattern matches to switches, using a compiler-generated `$tag` method. This was removed because our measurements showed that it was actually slower than a sequence of instanceof tests. See the paper "Matching Objects with Patterns", ECOOP 2007, for more details. Apparently, reasonably modern JVMs are really good at recognizing and optimizing patterns such as these.
Rust doesn‚Äôt have a GC.
I know that in Rust at least, LLVM can optimise these sorts of pattern matches on tagged unions (i.e. sealed classes) down to a jump table. Hotspot should be able to do the same thing.
And even if there were no optimizations in either the compiler or the JVM, it would still be worth the cost for code readability. I would only worry about the O(n) if there were a larger number of node types AND a demonstrated performance problem, meaning very rarely if ever.
Does this native version have the full kotlin stdlib?
That's a good thing to be aware about. Thanks!
Well I'm not surprised. Whenever I see a new article about something regarding Android programming now, even if the topic itself has nothing to do with kotlin, the examples are written in Kotlin at least half of the time. As a new android developer, you basically have zero chance now to not take note of kotlin, and not many reasons to not use it.
I am not an Android developer, but this case was interesting to me. I tried to understand this and created simple example: interface Listener { fun onEvent(i: Int) } fun bar(listener: Listener, i: Int) = listener.onEvent(i) val defaultListener: (i: Int) -&gt; Unit = { i: Int -&gt; print("defaultListener($i) called") } fun main(args: Array&lt;String&gt;) { bar(defaultListener, 1) } But I got error: `Error:(10, 7) Type mismatch: inferred type is (Int) -&gt; Unit but Listener was expected`. Then I understood that it occurs during Java interop and was able to reproduce: Java: public interface Listener { void onEvent(int i); } public class Foo { public static void bar(Listener listener, int i) { listener.onEvent(i); } } Kotlin: val defaultListener: (i: Int) -&gt; Unit = { i: Int -&gt; print("defaultListener($i) called") } fun main(args: Array&lt;String&gt;) { Foo.bar(defaultListener, 1) } Thank you.
Maybe its a bug in kotlin interop, means the complier should create only one wrapper instance to sam interface?
I defined listener in following way: val defaultListener = Listener { i: Int -&gt; print("defaultListener($i) called") } In this case variable is already instance of Listener, so when it is used no additional instance is created. And it is much cleaner than implementing interface. I guess, example in article can be implemented in following way: val onAudioFocusChange = AudioManager.OnAudioFocusChangeListener { focusChange: Int -&gt; //... }
I have all of the JetBrains IDEs, but I'm still a bit disappointed that this is locked to CLion. My favorite thing about IDEA is that I can do _everything_ in it. Is this ever going to get to IDEA? 
It looks like the problem here is not the lambda itself, but the implicit cast from the lambda to OnAudioFocusChangeListener. He probably (untested; I don't have his source code) could've avoided it with the appropriate type declaration on his variable, and still used a lambda: private lateinit var onAudioFocusChange: AudioManager.OnAudioFocusChangeListener = { focusChange: Int -&gt; ... } That way the implicit cast and object creation happens once, in onCreate, instead of every time requestAudioFocus is called.
So, Kotlin replaces Java or Android XML?
Wow, dependencies and kotlinopts in a kotlin script. This is way cool. 
I think it's safe to assume they'll be uploaded to YouTube.
It interoperates with Java so you can use both Kotlin and Java. It doesn't replace XML files. 
[removed]
Thanks!
but Jetbrains has always been successful with a lot of users
If you come to competent HR with articles list, they won't hire you. If you come with this new list, they are going to suck your d*ck as a signing bonus.
do you know how is this implementation calls or where is it described in the documentation?
found it in the java interop section: https://kotlinlang.org/docs/reference/java-interop.html#sam-conversions
Thanks! :-)
There is a library written in kotlin called Anko (https://github.com/Kotlin/anko), which replaces the XML :)
So, everything we learned about Android XML is pretty much useless?
Very interesting, but I'm not sure I agree with this: "They would only have to write iOS views and repositories. This is, in well designed application, minority of the work." Having worked natively with both Android and iOS, getting the views looking and behaving correctly is far and away the most challenging thing to get right. The business logic is easy.
There's no such issue when using references to named functions where a SAM interface is required, right?
[removed]
I think it depends on the application. In small apps it is true, but when app is growing then mostly business logic is growing. I've seen big React native app where over 90 percent was in common module. Note that Kotlin is making DSL for view creation (like Anko) and I think that soont here will be multiplatform DSL. 
To replace XML knowledge with an API is probably not a bad thing :) File it away with SOAP and EJB descriptor XML files... 
But where would you store such wrapper instance if you were compiler? As static variable? Then it will be potential memory leak.
My last job was at a company with a very old very very large app. I agree with OP, writing the view/platform specific code is 99% of the battle. Business logic is just normal logic.
What exactly are having trouble with? Just find any socket programming tutorial in Java and translate that to Kotlin. See: https://docs.oracle.com/javase/tutorial/networking/sockets/index.html
For your typical form-driven business app (even if you're now submitting form results as JSON to an API) this is true. However a lot of really interesting stuff out there can be built using more sophisticated modeling tailored to in-memory usage, which cross-platform Kotlin is great for!
That might be true for custom API's where the mobile team can get the backend team to return data corresponding exactly to views (which often has issues for backend scalability so not always the best way to go), but if you're using generic API's there's considerable business logic in apps. Also, for any nuanced application (image processing, map matching, etc) there will be significant savings. Not sure the 90% numbers thrown out are correct either way, but there's definitely value to this.
Feels like this will eventually become a Xamarin alternative.
Especially this part: while ((bytesRead = inputStream.read(buffer)) != -1) { byteArrayOutputStream.write(buffer, 0, bytesRead); response += byteArrayOutputStream.toString("UTF-8"); }
What result are you getting? Is it an error? How is this different from what you expect? It's hard to help when there is so little info about what the problem is.
Just write it a little bit more verbose. Use while(true), then val bytesRead =... and then if (bytesRead == - 1) break
Anko really closely corresponds with the xml nodes, so no, it isn't worthless.
 import android.os.AsyncTask import java.io.ByteArrayOutputStream import java.io.IOError import java.net.Socket import java.net.UnknownHostException class Client(private val addr: String, private val port: Int) : AsyncTask&lt;Void, Void, Void&gt;() { private val size = 1024 var response = "" override fun doInBackground(vararg p0: Void?): String { val socket = Socket(addr, port) val byteArrayOutputStream = ByteArrayOutputStream(size) val inputStream = socket.getInputStream() val buffer = ByteArray(size) var bytesRead: Int try { while (true) { bytesRead = inputStream.read(buffer) if (bytesRead == -1) { break } byteArrayOutputStream.write(buffer, 0, bytesRead) response += byteArrayOutputStream.toString("UTF-8") } } catch (e: UnknownHostException) { e.printStackTrace() } catch (e: IOError) { e.printStackTrace() } finally { socket.close() } return response } } Basically, I have this now. I want to make this idiomatic Kotlin.
so basically we have the choice between JetBrains, JetBrains or JetBrains or text editors
Surprise!
I actually thought that JetBrains developed an Eclipse plugin...
Yes but compared to IDEA's Kotlin support, it sucks. The last time I used it couldn't even automatically import classes.
They did: https://github.com/JetBrains/kotlin-eclipse
what do you mean? That thing where you paste java into a kotlin file and you get very java-ey kotlin? Then you can tell all your friends you are doing kotlin?
The article forgets to mention that JetBrains has so called "fallback licenses". Aka for every minor version (i.e. X.Y.?) you paid for for 12 months you get a license key that allows you to use that version even after your subscription ended. Commercial usage included. You simply won't get any updates. Official info on that: https://sales.jetbrains.com/hc/en-gb/articles/207240845-What-is-perpetual-fallback-license-
Can't you also use Kotlin in the Community Edition?
No (but it also doesn't have that) You can't use ALT + ENTER to automatically import stuff, you need to write manually ("import com.google.gson", etc)
I think so, I haven't used community in 2 years (student access to ultimate). My comment was more aimed at people who might want to use IntelliJ commercially.
You realize Kotlin is made by the same people who make intellij right?
No I don't think so. At least for me, it works. Did you use a very old version?
Unrelated to your question.. but AynscTasks are frowned upon in Android nowadays because it can lead to some memory leaks. 
I tried the eclipse plugin and I think it works good enough - I didn't encounter any problems, but my work with it is limited to "try out mixed language project". Every basic feature, like autocompletion, auto import and so on worked for me. I also tried the Netbeans plugin, which worked good as well. Basic features covered - but I wasn't able to use multiple languages in a single project. Since it didn't work for Groovy and Java, I don't know if this is a Netbeans limitation or not. Yea, best IDEs are IntelliJ, surprise. They have the best IDEs for many languages...Maybe it's because everything is else is community driven and nobody wants to pay for anything.
Hmmm maybe? The last time I used Kotlin for Eclipse was in ~July I think, after getting stressed that it didn't work I just switched to IntelliJ IDEA, the migration process was hard, but it was all worth it at the end since IDEA is better than Eclipse for Java/Kotlin development IMO
you can use the community edition commercially &gt; Community Edition is open-source, licensed under Apache 2.0. Projects like Android and Swift use Apache 2.0, so you're in good company. It can also be used for commercial development. and yea you can use kotlin in the community edition
Seriously, why would anyone use Eclipse over IntelliJ in 2017? It's like they _want_ to make coding harder on purpose.
What do people use nowadays? 
Looks interesting, I'm using spark with java extensively at the moment - any insights how this is better / improved / different?
For those who understand, no explanation is needed. For those who don't, no explanation will be given.
[removed]
It's dependent on what you're doing. I'm playing around with a socket application myself right now and am using [OkHttp - a library from Square](https://square.github.io/okhttp/3.x/okhttp/okhttp3/WebSocket.html). So mine code is something like val client = OkHttpClient.Builder().readTimeout(0, TimeUnit.MILLISECONDS).build() val request = Request.Builder().url("some_url").build() val ws = client.newWebSocket(request, someWebSocketListener) client.dispatcher().executorService().shutdown() above *someWebSocketListener* is a class that implements WebSocketListener, which has a function override fun onMessage(webSocket: WebSocket?, text: String?) { ... }
You can.
Could Andrey Breslav do an AMA perhaps?
Woah, we have a genius programmur here who writes perfectly idiomatic code from day 0.
lol, yes that is exactly what I was saying... sigh this place is getting to be worse than /r/javascript 
Here's a sneak peek of /r/javascript using the [top posts](https://np.reddit.com/r/javascript/top/?sort=top&amp;t=year) of the year! \#1: [Pass by reference !== pass by value](https://media.giphy.com/media/xUPGcLrX5NQgooYcG4/giphy.gif) | [303 comments](https://np.reddit.com/r/javascript/comments/6hz7o6/pass_by_reference_pass_by_value/) \#2: [Can you help me allow my router to accept üí© as the SSID?](https://np.reddit.com/r/javascript/comments/5zcb8m/can_you_help_me_allow_my_router_to_accept_as_the/) \#3: [GitHub's ElectronConf postponed because all the talks (selected through an unbiased, blind review process) were to be given by men.](http://electronconf.com/) | [901 comments](https://np.reddit.com/r/javascript/comments/6f8u2s/githubs_electronconf_postponed_because_all_the/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
&gt; javascript That explains why you don't know what auto import is, or class for that matter.
Kotlin/Native is coming (right now still in beta)
I have a dream of a *declarative* web framework where requests are just POJOS, responses are POJOS, and handlers are just functions translating requests into responses. No magic, no annotations, no code generation, just simple code and simple testing. Javalin is a step in the right direction, I guess. 
Honest question: why use javelin over something like spring boot?
I'd have a few reasons to use vertx or spark over spring boot. Hard to say where this fits in. Looks just like spark.
Care to share your opinion about vertx and spark and where those two outshine spring boot?
Ok, but this is research- not real-life based at this point. I dislike how opinionated Spring is and how much magic is happening in the background. Maybe [this article (not mine)](https://blog.softwaremill.com/the-case-against-annotations-4b2fb170ed67) sort of represents that opinion. Another argument could be that Spark and vert.x appear to be more light-weight. I base that on [this article](https://craftsmen.nl/memory-usage-6-popular-rest-server-frameworks-compared/). OTOH, Spring also has its strengths. I need to find time to experiment.
Try to use "use" instead of "try" for any "closeable" https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/use.html
Great video. Really does an excellent job of bringing the user along from the beginning and showing the reason sealed classes and when obsolete the visitor pattern. (Also good riddance to that pattern)
You're always going to need some "magic" for routing at least if you don't want it to be a huge pain in the ass.
I'll copy-paste a bit from my previous responses to this question: &gt; I have been using Spark professionally for three years. During those three years I've noticed some things that I don't like (the static api, the req/res pair, the inconsistency of having return-types in route-handlers vs no return-types in exception-handlers, uploads, etc). Javalin is my attempt at fixing these annoyances. &gt; In Spark you're supposed to use return for routes (but not filters). In Javalin I removed returns in favor of only allowing explicit mutating of the response via functions, because that's a lot more "honest". When you use return in a lot of web-frameworks you're just setting a temporary result that can be altered before it's written to the client. I wanted this to be clear in Javalin, so I decided to have a function for setting the result instead (I also thought it would be good to keep before-, after-, endpoint- and error-handlers all consistent). 
Javalin is a very lightweight wrapper on top of the Java Servlet API. It's a very small abstraction compared to anything Spring. All in all it's just 3000 lines of code. Spring is more than 1 000 000 lines of code. If you already know Spring and you're productive using it, there's probably no point in switching. But Spring Boot is a framework for a framework. There are a lot of things there that you might need to know and understand at some point.
Definitely don't want to thread jack over the good work here of tipsy/@javelin_io, but for that exact thing, may I suggest you check out (http4k)[http://http4k.org] ? :)
Sadly, I didn't have the possibility to use it in many projects until now. I used it for a utility for build automation, developed together with only 1 collegue. Was a overall good experience, we both liked it. Additionally, I added Kotlin to a really big spare time project of mine (3d game engine), which is comparable to a production project in many regards (for example size and complexity, performance, build etc). I already replaced a lot of central architecture comoponents and my general answer is, that Kotlin can be used everywhere Java was used before from my experience.
Kotlin can be introduced like a gateway drug. Start with writing your domain objects with it. Using the data classes. Then expand to things like small methods and replace them with functions. It should start to roll from there.
I've just started looking at it and I have to say I like it so far. I've had to research a few libraries and write a couple of little prototypes to test them out and have been using Kotlin for stuff like that.
I'm writting Gradle plugin with it or small dev tool.
A friend of mine is working in Kotlin on backend services at his job. Many of us are using it for Android development, but anywhere you're using Java for an application, Python for a script, JS for a website, and now even C++ for native, you could use Kotlin.
Been using it for server side development for nearly a year now. Currently in a Spring Boot project.
Lol, nice job bot proving what a den of iniquity r/Javascript is!
IMHO, there should be no reason to *not* put Kotlin anywhere you run Java on the server. A lot of our dev teams (at least 50% of our 100+devs) have transitioned from Java to almost exclusively Kotlin, hosting a vareity of apps, including the main website for the company (a global academic publisher) which gets approx 10-20mhpd - not "webscale" but respectable enough. Our standard project looks something like this: - Web: (http4k)[http://http4k.org] + Handlebars, on embedded Jetty or Undertow - Testing: JUnit + (Hamkrest)[https://github.com/npryce/hamkrest] + (OkeyDoke)[https://github.com/dmcg/okey-doke] - Build/Deploy: Gradle + Docker + GoCD + CloudFoundry That I know of, we've suffered precisely zero problems that could be attributed to the language switch, and obviously gained from the features such as null-safety that prevent runtime errors. We've also reaped the well-documented benefits of the language such as conciseness and a decent Collections API, and generally *couldn't be happier. The native stuff is quite exciting and whilst new, JetBrains are pushing hard with it - we'll see how much it is polluted by the hideousness that is iOS dev. :) * - well, a standardised Either/Result type would go down a treat if you're reading this JB! :)
Using it for backend REST services with Spring Boot as a base. Couldn't be happier.
I've used Try / Either in Scala for error handling, it's quite comfortable. Can you recommend a community-developed library for Kotlin that contains these types? Remember seeing several, but not sure which one is the most used.
I don't ¬Ø\\_(„ÉÑ)_/¬Ø I would love to though.
Holy shit, that's like a dream come true to me.
Started using it with Spring Boot at my last job. At my new job I'm currently writing a REST API client with it using Retrofit2. Hoping to get more adoption, but most of our services are written in the Play Framework which makes things a bit more complicated.
Yes - it's annoying that there isn't one, which means that everyone rolls their own. As for libs, there's about a million**, but we use [result4k](https://github.com/npryce/result4k). If you want something which has an entire underlying functional layer then there's [Kategory](https://github.com/kategory/kategory) or [Funktionale](https://github.com/MarioAriasC/funKTionale). Personally, I'm loathe to fall back into the "stdlib+religion" pattern which Scala has fallen into, hence the frustration. **possibly not that many 
Because if there's one thing that simple things need, it's something complicated, just to teach you a lesson. ;)
One thing to be worried is that it seems they are all evaluated eagerly. If you need to chain multiple operations together, you would better off with java8 stream API or kotlin coroutine sequence API.
I know I'm not answering your question, but what Kotlin native resources can you recommend? 
Started using it over a year ago. Basically all backend is kotlin. 
There is a first sample ptoject from Jetbrains showing a multiplatform Kotlin native app: https://github.com/jetbrains/kotlinconf-spinner
This is not a fault of the programming language but of their memory management. You have the same problem invoking C from languages like Python or Nim, since their _strings_ look to you like constants but are usually garbage collected objects. So you either create copies (seems to be the choice for kotlin) or for the sake of efficiency you use some kind of low level APIs to _mark_ or prevent garbage collection for certain objects so that the C side can work on the data and return without it having been freed for as long as you need. Consider also that kotlin (or the jvm) might have its own choice of string encoding (say UTF-16) but for interoperability they always export UTF-8 strings. You would not avoid a copy here. Another fun thing to do in C to other languages is get their `const char*`, cast away the constness and override the data, then see how the other language deals with that (not a problem if they make a copy). Rather than `const char*` I would be interested in looking at kotlin's `char*` interoperability if they have one, that requires a lot of trust between parties.
I've been looking at the [samples](https://github.com/JetBrains/kotlin-native/tree/master/samples). I also found the [Gradle plugin](https://github.com/JetBrains/kotlin-native/blob/master/GRADLE_PLUGIN.md) as a good way to start, and the [interoperability document](https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md) for interacting with C libraries. Unfortunately there's no one document that'll tell you everything you need for programming in Kotlin Native.
We use it as we would use Java. So basically on anything. My team developed a data pipeline with it for instance. 
Backend server development since late 2015.
Currently it's around android. However awhile back i rewrote their esb and other middleware backend, from java to kotlin. Back then it was still alpha, it was worth the risk, as it was fairly stable and the amount of crap i cut out. Fun times.
I have used Kotlin to write a Java EE 7 application with Jersey (deployed to tomcat so had to include Jersey as a dependency). Only issue I had was Jackson and Kotlin didn't get along when unmarshaling data classes (works fine for marshaling them). So had to use Java for classes that needed to be unmarshaled by Jersey, the rest is Kotlin.
Currently working on an internal tool using TornadoFX. Hopefully, if I can continue to evangelize, I might get to do more.
Thanks!
Did you use some framework or was it just your custom code?
Not able to do it, because the choice of programming languages on our projects is defined as part of the requirements document. In all these years of alternative JVM languages, all our customers always require Java source code for JVM projects. Also given the sad state of Eclipse support (last update 2017-03-14), it is very hard to sneak it in on our official development images.
I use it for small internal apps, like support tools or quick "edit this line in a database" kind of things.
Customers may be thinking that finding Java developer to support a project is easier than Kotlin / Scala one. And they may be right, but the situation is slowly changing.
Do you mean UI apps? If so, do you use some wrapper over JavaFX?
The reason is quite simple, a `const char *` static string is a C concept. Each programming language has its own semantics for string handling. Even on languages with manual memory management, strings know their size and accesses are checked. So when you have `"a string"`, it is usually a kind of fat pointer that knows its bounds. Which is why most type safe languages have C style strings on their libraries as a way to minimize conversions, e.g. PString in Object Pascal.
God, no! Spring Boot w/Thymeleaf
Got it.
Kotlin. Not even once.
Yes, that is the usual deal. Since we do enterprise consulting, customers tend to look for easily replaceable delivery companies.
Have you had any experience using Kotlin in Android development, when you have Java based SDK's in use? Any issues there?
Haha, I know, right? It's a very small start up, so I have a lot of influence in the tech decisions, tho it comes with small start up pay too, so nothings perfect!
Not in particular, just libraries for some things, or jackson por xml and json parsing. But our colleague is using spring for his backend stuff
What kind of issues did you have? I'm using data classes for Jackson serialization and deserialization and it works fine. Did you register the [jackson-module-kotlin](https://github.com/FasterXML/jackson-module-kotlin) with your object mapper? 
Backend service with Spring Boot. Text data classification with Deeplearning4j.
I just gave a talk that probably touches on a lot of what you're looking for at KotlinConf. :) https://speakerdeck.com/kevinmost/idiomatic-interop
tl;dr: Article author was attempting to implement a listener using a lambda that had the same signature as the Listener (Int) -&gt; Unit. private val listener: (Int) -&gt; Unit = { p -&gt; // doesn't work } Instead, declare the Listener interface you are implementing: private val listener = AudioManager.OnAudioFocusChangeListener { p -&gt; // works! }
Exactly :D
&gt; Did you register the jackson-module-kotlin with your object mapper? I ran across the jackson-module-kotlin library when I was researching the issue. I didn't want to jump through all of those hoops just so I could deserialize Kotlin data classes (that is a dirty hack at best). So just used Java for the classes I wanted to deserialize. Serializing kotlin data classes with Jackson didn't require any jumping through hoops so classes I just serialize stayed Kotlin. 
&gt; https://speakerdeck.com/kevinmost/idiomatic-interop That's exactly what I was looking for, thank you. I'm using the DJI Mobile SDK for one of my final senior projects and was curious about being able to use Kotlin with it. Unlikely to happen at this point, but still wanted some clarity. This just what I needed.
just in android, but gonna implement it on some web apps
Yep - we use automarshalling heavily with Jackson + kotlin module for http4k's message lenses. It works generally great, apart from various issues with capital field names (which are overridable/fixable with annotations)
This is an awesome talk by Pablo Guardiola about creating a new kind of DSLs that separate definition from execution, and come with sequencing and parallelization for Free.
I'm at a large org, and my team has embraced kotlin for all out webdev needs. I love it. Only thing that bites me in the ass is remembering *registerKotlinModule* for Jackson Kotlin.
I use it sometimes when I want to quickly test code. I've found it pretty useful.
By &gt; jump through all of those hoops you mean add one dependency and call one method: ```val objectMapper = ObjectMapper() objectMapper.findAndRegisterModules()``` On your objectMapper? I'm not really sure how that is a dirty hack. It should result in much less code and higher quality code, at least if we all agree that the Kotlin versions of those classes you're leaving in Java would be safer and shorter.
No issues. Kotlin is spreading like wildfire in the android dev community. You do know Google officially support it on android right?
&gt; I want to save a new book. With Java I could just create the book, create an Author inside book with just the Author's ID. Make every Author's field nullable, except ID? Or provide default values for them, or both?
Of course. In this case I'm more concerned with whether or not DJI will support it. 
We're doing core IT systems for a major telecom in the country. Leaving Java was a blessing.
[removed]
Definitely not the easiest way to incorporate Retrofit in a project. Looking at the source code there was a lot of functionality implemented that Retrofit gives you as part of the library.
My favorite mocking approach is : don't mock Or really as a last ressort like if you need to mock one method from a stupid Android framework class with hundred of methods. =&gt; Interface + Implementation + Fake
Why not just use EntityManager.getReference(type, id) to get a reference without db query to an already existing record?
My tip is: don't use it! This piece of software is so buggy, that it is to frustrating for more than "hello world" examples. After trying my luck with the Kotlin REPL for some time I switched to the classic `main` method approach. However, I hope and expect that the Kotlin REPL gets better.
Some nice features :) I don't know some languages you used like Dart too well, but can connect most of the listed features to something Kotlin offers :) - Why didn't you write a Kotlin version of #5? - Achieves similar things like Kotlin's let extension function - I don't understand the return type in #9 xD - #10 could get a Kotlin version too
I updated the curry example, to make more clear what is going on. I'm not a Kotlin expert (yet :)), if you show me a gist how to do #5 and #10 it in Kotlin, then I will add it to the post :) 
The beauty of Kotlin is that none of your SDKs need to know you're using it. They don't have to build specifically for Kotlin consumers or anything like that. While there are some things they can do to help us, like annotating nullability on their public members, I've never seen any issue with any Java library and Kotlin. The exception, of course, is weird Java tooling that actually transforms source code (I think GWT for example?). But any normal library or library that works on bytecode works perfectly. 
&gt; you mean add one dependency and call one method? When I first skimmed the documentation it seemed more involved than that. I will revisit the documentation. 
#5: https://gist.github.com/anonymous/a0f970110292dd925d55729a8a30cb18 #10 is from https://medium.com/@tpolansk/the-difference-between-kotlins-functions-let-apply-with-run-and-else-ca51a4c696b8 class MyClass { fun test() { val str: String = "..." val result = str.let { print(this) // Receiver print(it) // Argument 42 // Block return value } } } :)
I'm using lateinit vars for non-nullable fields in my entity classes. That works when loading entitys from hibernate. But i'm not so sure what happens if you just fill the id and then let hibernate cascade the changes.
The pipeline operator is a standard feature in Standard ML, OCaml, and F#. The fact that it's in Reason is a "coincidence" of the fact that Reason is just alternate syntax for OCaml. OCaml docs for it here, under "Composition operators": https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html
So, 6 could be something like this in Kotlin querySelector('#button').apply { text = 'Confirm' classes.add('important') onClick.listen { confirmedAction() } }
That'd be useful for when you're already in the service, but the issue is when deserializing from the JSON, you're going to have some non-null fields that are actually null.
Take a look at https://kotlinlang.org/docs/reference/compiler-plugins.html#no-arg-compiler-plugin This Plugin creates no-arg default constructors for @Entity annotated classes. Comes handy on kotlin data classes.
Yeah, I imagine lateinit vars would "solve" the problem, but then I lose out on all of the stateless immutable object reasoning benefits that data classes are intended to be used for. Probably just an issue of I can't have my cake and eat it to. Either I have mutable fields and it's easy to send and receive partially complete models, or I have immutable objects and I need to create entirely different classes to translate to and from. It actually makes me wish for a feature like Typescript's Partial. A way to have a Data Class with all non-nullable immutable fields, but declare "I want to make a version of this class where all fields are nullable and mutable." That way you could deserialize from JSON as the Partial, build the proper version of the class, then convert it from a Partial to the normal version.
I'm using the plugin `org.jetbrains.kotlin.plugin.jpa` which I'm guessing uses the no-arg-compiler-plugin for me.
What language is the .re extension?
ReasonML
I sense that the desire for well-formed immutable value types, and the requirements of de/serialization, commonly create friction. if you're getting your data over the wire from JSON, you can't be sure that every field is there unless you've validated the object. But if you have an object doing the validating, then that object cannot itself be the final value type. The way libraries like [Immutables JSON serialization for Java](https://immutables.github.io/json.html) get around this is by creating _three types_: 1. The actual immutable value data type. This type never has null fields anywhere. 1. A builder for an immutable type. The builder is allowed to have nullable fields, but it cannot build data classes unless all the nullable fields are initialized. 1. Optionally, a Json deserializer for Jackson, which can accept possibly underspecified JSON, marshal it into the builder, and then help the builder validate the type. Similarly, in your case, you want the benefits of the type system for an immutable value type without null fields. But you cannot _know_ that such a type is possible to build without e.g. having a builder type ahead of it. You'll either need to lean upon `lateinit` (which is a nice compromise), or maintain dual classes.
Yeah, you're right. For now I'm just making additional immutable data transfer classes. Makes for a more succinct json anyway.
Take a look at my example: https://pastebin.com/sWGBaXAt This is possible with the no-arg-compiler-plugin
It only warns you in cases where the match *must* be exhaustive, i.e. non-null assignments and return statements.
`when` has to be used as an expression for it to enforce exhaustiveness. sealed class Thing object SomeThing : Thing() object OtherThing : Thing() fun usesThing() { val thing: Thing = SomeThing val illegal = when (thing) { is OtherThing -&gt; 1 } } results in an error `'when' expression must be exhaustive, add necessary 'SomeThing' branch or 'else' branch instead`. fun usesThing() { val thing: Thing = OneThing when (thing) { is OtherThing -&gt; println("Is OtherThing") } } doesn't, because the when statement is only used for its side effects.
I extended the example from the official documentation (https://kotlinlang.org/docs/reference/sealed-classes.html). Worked in my case, couldn't compile this :) sealed class Expr { class Const(val number: Double) : Expr() class Sum(val e1: Expr, val e2: Expr) : Expr() class Bla() : Expr() // as soon as you comment this out, it works object NotANumber : Expr() fun eval(expr: Expr): Double = when(expr) { is Const -&gt; expr.number is Sum -&gt; eval(expr.e1) + eval(expr.e2) NotANumber -&gt; Double.NaN } }
Your `when` has to be used as expression meaning `val something = when(sealedClass) { ... }` This will give you autofix in IDE to generate all cases. If you want to use your `when` as a block you can trick it into returning `Unit` type in such a way: `val &lt;A : Any&gt; A.unit get() = Unit` and so you can use `when(sealed) { ... }.unit` I'm not sure how F# pattern matching works for union types but in Kotlin you can also add cases for abstract classes into your `when` expression next to your sub types of sealed class. Meaning you compiler will not protest against having case for types like androids `Activity` or even `kotlin.Error`
Oh, thank you. This is what they meant! Nice
Thank you, guys. All of you. :) Pretty convinient to know. Yes, I didnt use when as expression. My bad.
Idea Community contains all of the features that you might need to develop Kotlin projects - Ultimate Edition gives you extra language support and a variety of other plugins. You've evidently managed to create your project incorrectly. Try deleting the .idea directory and starting again. :)
Cannot really speak for community edition , but those options are present in ultimate edition. Source: I use ultimate edition
Maybe I don't understand what your missing features are, but if you want to add a "package" (which is the same in Kotlin as in Java) than why don't you do a right click and use "add package"? Maybe it's because I am used to the fact that you can only add packages and Kotlin files....but I don't miss something here. Most often I add a package, create a Kotlin file, write two or three one liners for interfaces (this isn't possible in Java, so you need files and IDE support here), add another Kotlin file to the package, add some classes, functions and stuff I need. Although I agree that one has to carefully check if it makes sense (and it makes sense often) to put multiple things in one kt file, it often eliminates the need for an IDE completely.
I don't have the option to add a package. I have only options to create new directory or file. I will try what tarkaTheRotter suggest and delete the .idea directory and see what happens.
Then you are most definetly trying to add something to a non source folder. Either your project structure is broken or your source folders are configured wrongly.
Yep, I added src as source root and all worked fine. Thanks :)
No autocompletion and source highlighting make the REPL pretty much unusable at the moment. I wouldn't be surprised if they ditch the REPL altogether.
Have you used reason. 
I was reading this and immediately went "yeah, forgot to mark it as a source folder."
Yea I find mocking very helpful and convenient. Does android support mockito? 
If you look into the alternatives just comparing the value to true isn‚Äôt that bad. The second best alternative in my opinion is to unwrap the string or give it a default value if it‚Äôs null using the elvis operator. So you‚Äôd do something like val unwrappedDescription = description ?: ‚Äú‚Äù Then you could check the unwrapped description and do whatever else you needed.
You have to define what to do with null (true or false). I usually add an Elvis operator with whatever you want null to be. In this case my if would be (description?.startsWith("foo") ?: false). This will translate properly to a non-nullable Boolean.
I like this alternative to == true but not sure which one is more readable in an if: if (description?.startsWith("foo") ?: false) { } or if (description?.startsWith("foo") == true) { } 
Just do the same as in Java, it's the most clear. Don't need to use kotlin operators for this
Thank you very much u/javalin_io, gonna try it with kotlin now.
I do mainly business applications and I almost never come across simple use-cases where one would simply unserialize objects directly to the database (= basically a trivial CRUD application). As the application grows new validation rules, business rules and actors are gonna gome into play, so you need a good architecture anyway, which begins with user input mapping (= DTOs). Another aspect is, that CRUD-style applications only work when your model or user input forms map exactly to the database. In DDD your domain model is not guaranteed to directly map to the database! If you predict that your application is gonna grow anyway, why not embrace a good layered architecture with DTOs from the start?
By definition your model maps to the database with JPA. I do carefully separate the repositories, services (business logic) and rest endpoint definitions. But for the most part my models do map to the views I use. I've started just making DTOs on an as-needed basis. I don't want to shove a square peg in a round hole, but I also don't want to make DTOs before I need them. (Which would violate YAGNI and KISS.)
Yeah. I just prefer that way because I like to have all of my ?. match with a ?: throughout the program (unless null is a valid value and thus unhandled). Kind of an OCD-like thing I guess. But the == true is probably more readable and is the way that the IDEA plugin would auto-correct.
I use Kotlin to write a streaming big data application on top of Storm.
pretty sure thats what data classes generate. If you dont want them to show up you shouldnt use data classes
This looks very cool. Where was the talk given? Will there be video? Some of the functional stuff looks a bit intimidating. For example: inline fun &lt;reified G, A, B&gt; List&lt;A&gt;.traverse(crossinline f: (A) -&gt; HK&lt;G, B&gt;, AP: Applicative&lt;G&gt; = applicative&lt;G&gt;()): HK&lt;G, List&lt;B&gt;&gt; = foldRight(AP.pure&lt;List&lt;B&gt;&gt;(emptyList()), { a: A, lglb: HK&lt;G, List&lt;B&gt;&gt; -&gt; AP.map2(f(a), lglb, { it.b + it.a }) }) Those variable names... Looks like it might be time I read Learn you a Haskell.
The talk was given at DroidconSF. There will be video, I just don't know when. It'll definitely be posted into kategory.io once available.
In IntelliJ (which Android Studio is based on), if you control-click (Command-click on Mac) on the method you are using, it will decompile the code. It will also give you an option to download the source code for what you are using. After that, the IDE should know the parameter names and will provide them for you in autocomplete. 
You can enable them by pressing CMD-SHIFT-A, and typing in "Toggle parameter name hints" (probably substitute CMD for CTRL if you're on Windows). Also, if you press CMD-P with will list the parameter names for a given function.
How about using a test framework so it won't mess with your main method. I usually create test method just to check for small stuff. By doing so I don't need to do something like comment/uncomment main method
I don't find the inheritance example `One`, `Two`, `Three` particularly helpful for understanding. Why don't you pick an existing hierarchy like `Any`, `CharSequence`, `String` instead?
You probably don't have the sources downloaded for the platform you're using. Check for it in SDK manager.
Autocompletion and highlighting works fine here Kotlin 1.1.51
There's a difference between coroutines using Threads and coroutines using fibers. You should read more about what fibers do and how they can optimize parallel code because it's coming to the JVM at large: http://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html
1) you may have existing code that uses Quasar. 2) that blog post was written before kotlinx-coroutines was announced or released.
Oh, having your language being talked about by Venakt is a huge milestone. Congratulations :)
"it's coming". Yes, in 5 years.
Would it be possible to switch to a real build system like gradle? I personally have no eclipse experience, so I can't really help there.
Uhmm... Perhaps as soon as next fall will the new release cadence. 
I know they want to move faster now. I was exaggerating when I said 5 years, but that feature would require quite some work and I'm not sure they could deliver that within a year. 
It's not clear from your post, but do you know that Kotlin coroutines are implemented with fibers? It makes things kind of awkward because it's not really compatible with normal Threads. For example, you don't want to use Thread.sleep(xx) with coroutines, but use the special delay(xx) command, which does the same, but takes advantage of fibers.
I did not know about Quasar, but it looks very similar to Kotlin coroutines. However coroutines are supposed to become part of the core Kotlin language at some point, so that would be one reason to use that instead of Quasar. Kotlin coroutines is about much more than just the channel/actor programming model (streams); and it seems the same with Quasar. One of the main point of coroutines is that parallel code looks more like normal sequential code rather than streams (RxJava), although the channel/actor model (streams) is part of some sub-library. Look at this [answer](https://stackoverflow.com/questions/42066066/how-kotlin-coroutines-are-better-than-rxkotlin#43783215) from Roman Elizarov who is one of the creators of Kotlin coroutines.
/u/pron98 is Quasar's creator, AFAIK he was informally consulted by JetBrains for advice on coroutines implementation. There are subtle differences on both approaches but also Kotlin coroutines are integrated with Quasar https://github.com/Kotlin/kotlinx.coroutines/tree/master/integration/kotlinx-coroutines-quasar 
Agreed, even something like Animal &gt; Mammal &gt; Dog or Polygon &gt; Rectangle &gt; Square would work too. Numbers make for a confusing example of inheritance. Regardless that was a fantastic talk. She is very good at taking complex stuff and breaking it down to simple explanations.
What is the difference between "Extract required libraries into generated JAR" and "Package required libraries into generated JAR"? The main difference between a pure java and kotlin project is that the kotlin project will have a dependency on the kotlin runtime (and the stdlib most likely). It obviously won't run without its dependencies, so you need to make sure those are included in the final jar.
Thinking the same. If a language comes under Venkat's radar. It's a milestone and great validation.
Adapters ?
I am Quasar's main author. The main difference is that Quasar also supports Java code, while Kotlin coroutines can be used on the Javascript backend. Once [Project Loom](http://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html) (of which I am the Lead) adds continuations and fibers to the JVM itself, Quasar will switch to using the Loom implementation, as, I can only assume, Kotlin's coroutines when targeting the JVM backend.
By autocompletion I mean something like TAB-completion.
Strg + Space works fine here. It even creates an "import path.to.the.class" line automatically when I've selected a class
Didn't know that, thanks!
Sorry for the late response - the aforementioned app did use generic APIs that needed to be formatted. I could see for image processing/map matching etc apps the logoic taking a long time to develop (i.e. coming up with the correct algorithms) but I can't imagine it'd take too long to duplicate it. The problem that I see with this is as soon as you step out of normal display-5-things-in-list apps creating the correct view structure/animations ends up taking for-fucking-ever. It's taken me multiple days to get a single transition properly working (on both iOS and Android, though its much more predictably brutal on Android) and that, in my eyes, wipes out the extra time it can take to write logic.
Yea, I don't know why exactly, but I love this guy.
+1 for switching to Gradle and letting Eclipse build through that. Gives you IDE independence, and deployment reproducibility is no longer an human error-prone concern. :-)
Does anyone have any experience using the Kotlin to JavaScript compiler?
IÔ∏è did this as an experiment. https://github.com/m410/sandbox-kotlin IÔ∏è tried to pack it with as many hibernate features as possible to see if IÔ∏è could find any deal breakers. IÔ∏è would feel comfortable using it for production. 
I'm also curious to hear experiences. I don't know of any other statically typed language that is officially designed to both run on the server side and transpile to JavaScript. Since this language was also designed by the best IDE makers out there, I suspect it is the most productive language to make websites in for many projects/teams.
I'm using TypeScript right now to compile to Node.js JS and the web browser JS that runs on the pages. It's worked well so far.
nice, now if you could get on with that eclipse plugin...
Could asSequence help you here? https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/as-sequence.html
People still use Eclipse?
ah another toxic programming community, how original
Hmm. Judging from the Kotlin source code, `kotlin.sequences.Sequence` is a plain interface with an `iterator()` method. You shouldn‚Äôt have any problems using that (i.e. implementing it) from Java.
The JS interop is pretty poor when compared to TypeScript. Kotlin's type system cannot represent all the various structures commonly used in JS code, so you have to fall back to the untyped `dynamic` way too often.
The eclipse and netbeans plugins are meant to be updated by their respective communities after the initial release Jetbrains made. This is the way open source communities do that...it's funny that people expect Jetbrains to maintain plugins for competitive products, even after they built the foundation and made an initial release....and in fact do all the work developing the language and platform for everyone. Sometimes I get the impression that people don't appreciate the effort of other people. What are your problems with the current plugin? I used it for a short time and it worked well for me. Did you create tickets for the bugs and missing features you encountered?
Looks really nice... Trying it out now... thanks for submitting this.
Hi. Library author here - we thought we'd commemorate our v3.0.0 release - which adds AWS Lambda as a as a server(less!) backend - with a self-congratulatory post. We hope you like our stuff :) As you might have guessed from the version number, http4k isn't actually that new - we've been using it in production with significant traffic since March so it's thoroughly battletested in the wild. AMA.
Is there an ETA on when the videos will be available?
Soon‚Ñ¢
Hmm. That's annoying, but I guess any language not largely based on JavaScript is likely to have this problem? Also, if I understand you correctly, this is only a problem when you want to work with other JavaScript code such as libraries you might want to use? Do you think it would be possible for people to write browser libraries directly in Kotlin instead and thus avoid that problem? If course that is not really practical, but just trying to understand the options.
Hey, on the post you mention API contact generator for OpenAPI/Swagger. Does this refer to the metadoc presentation stuff that looks like Scalatra's meta swagger stuff, or is there a code generator? I'm on the Swagger Codegen core team, which is why I ask. If you don't have a generator implemented, I'd like to add an http4k generator to Swagger Codegen.
That is a good example of another language that does this, and something I hadn't given serious thought to. We are trying to pick a new language. How is the refactoring support in your IDE/editor of choice?
In order to get generated OpenAPI docs, you currently need to use the http4k-contract module (see: https://www.http4k.org/guide/modules/contracts/ for an example ). Basically, you define the expected routing "contract" for several endpoints and give it an OpenApi renderer, then define the description definition of each endpoint using the Lens API - this includes querys/headers/body formats and responses. At runtime, a documentation endpoint is made available at the root of that contract, and this is where JSON schema models are generated. You can optionally add named descriptions for the endpoints and each part of the request which fill in the OpenAPI docs.
JetbrainsTime‚Ñ¢
This looks promising: https://github.com/jean79/yested_fw
It's only a problem when using existing JavaScript libraries. I guess it could be dealt with by writing wrapper libraries in Kotlin, instead of just type definitions, that would expose a more Kotlin-friendly interface to the JS library underneath. But that's a lot of work and I don't think people are going to do it - except for maybe the most popular libraries. You can try it out yourself with the [ts2kt](https://github.com/Kotlin/ts2kt) tool, and see how it converts some existing TypeScript declarations. There are things in TypeScript such as [union types, intersection types, mapped types, string literal types](https://www.typescriptlang.org/docs/handbook/advanced-types.html) and more, that accurately represent the working of JavaScript libraries, plus the whole structural typing thing. I personally just use TypeScript for frontend code, even though I miss some of Kotlin's features. I imagine the Kotlin JS target could be useful if you have a library that you want to use both on the frontend and the backend (and mobile), so it will allow you to share this code between platforms. I wouldn't use Kotlin for the entire frontend though.
I started with JetBrains WebStorm and it worked really well. Refactoring worked as well as Visual Studio does with C#. It knows about your code everywhere it's used. I'm a bit of an open source nut and my student discount is ending soon because I'm graduating soon, so I'm weaning myself off JetBrains IDEs. I'm using Visual Studio Code right now for TypeScript. Its support is pretty good except refactoring doesn't seem to work as well as WebStorm. I've run into problems with it renaming a class or other symbol across the whole project. I'm hoping it improves more.
Also, we will probably just create typed wrapper classes around JavaScript libraries anyway. We already tend to make wrappers for 3rd party libraries anyway, even if the typed thing wasn't an issue.
Looks like server didn't succeed in handling reddit-effect :)
I've been meaning to take a peak at Http4k. What's the story with Kotlin/Native?
Not sure whether to take you seriously :) The main http4k website is running from Github pages, so I hope that's not gone down! :)
yeah, it's real toxic around here, you should stick to r/aww.
We are currently reliant on a few JDK classes such as InputStream. If those got replaced/ported the there is absolutely so reason why we couldn't produce a Native version, as the core of the library is mostly pure Kotlin. Ditto for JS. 
Didn't Jetbrains say it's too early to use Kotlin/Native for performance? Has that changed?
So, the buzzword "serverless" appears more and more often. Could you briefly motivate why I should use that over a "standard" application with REST endpoints?
I'm sure that there are better qualified people on the internet to answer that question in a general way than us, but the words "infinitely scalable" and "pay per usage" would probably be in there somewhere. :) Mike Roberts wrote a series of articles on the subject which is a good primer.. https://martinfowler.com/articles/serverless.html From an http4k perspective, AWS Lambda (for instance) is just another container - albeit one with a rather more immature operating/deployment model than something like Jetty on EC2 or ElasticBeanstalk. It will be interesting to see how this develops if and when Google and MS get in on the action, and if it's viable to expose your REST apis via an API gateway -&gt; Lambda bridge instead. If it truly is the future, then threading models for this type of app may change significantly because you'll get a new thread for each request.
Well I know what I'm messing around with this weekend.
I find it rather amusing that probably the main reason that TypeScript got such a powerful type system is due to how horrible Javascript is when it comes to guarantees. At least we got something out of it :) It'd be great to see some of these implemented in Kotlin in the future. And who knows, maybe the problematic mapping of Javascript into a typed language helps Kotlin advance too.
Thanks for helping me confirm/round out my understanding. As far as wrapping JavaScript libraries in Kotlin, I agree people are probably not interested in maintaining a complete library mapping. I suspect would maintain our own wrappings of parts of libraries as we learn to use them. This is a technique I use to help me learn libraries. As I begin to understand how to use it, I encode that understanding into classes that wrap theirs that are named after how I think and after how they are being used in a particular project. The idea is not to create a complete wrapping even of any entire class, but just to repackage the parts of it that we want to use in a more convenient interface. Actually that is a clean code technique recommended by Uncle Bob that also helps insulate your code base against changes in third party libraries or frameworks you are using that can also make it easier to swap out that library for an alternative internally if desired. In this case it would have the nice side effect of the wrapper being fully typed.
:) If you stumble on anything at all then please let us know. Turns out that docs are hard to write when you know it all...
Thanks for the reply. Just a little piece of advice. I too went down the open source nut rabbit hole. I started out using all Microsoft products. Now I'm running a Linux distribution, and using Neovim for everything. I have been continually improving my setup over the years. But I never found open source products to work quite as well as IDEs when it comes to real productivity. The real power of IDEs is that everything is designed to work together to provide a complete experience. In these other tools you have to wrangle lots of little plugins and things and try to get them all cooperating well, and it just never ends up working as well for stuff like really smart completion, jump to definition, and refactoring. So now I'm going back to IDEs, or at least trying that out again. Uncle Bob talks about how programmers are quick to jump at the newest shiny language just because it is incrementally better. But you can actually be insanely productive in Java just because of the IDE support, and he doesn't understand why people are willing to give that up so easily. I do think using the open source tools forces you to learn and understand the underlying technologies better, and they are good to learn and use, but I think a more balanced approach is to still use IDEs as your main development environment and know you can quickly jump into one of those other tools as needed for certain things.
Currently using it for a pretty hefty pet project. Really good library!
I agree with you there. :) Nothing beats productivity. I actually fell in love with IntelliJ IDEA and its related IDEs, and the only reason I'm giving Visual Studio Code a serious try is that it feels like the only open source solution that can compete. It actually feels more like an IDE than a text editor. I'm sure that if I end up too frustrated, I'll end up seeing the value in other IDEs, which may cost a bit, and pay for the productivity.
Where the fuck are the videos?
[removed]
Google have already got in on the action. https://cloud.google.com/functions/
FINALLY
Hmm interesting. It would be really nice to have a ready to go http framework when Kotlin/Native gains some maturity. 
From the (relatively) mainstream statically typed languages Scala is probably your best bet when it comes to compiling to JS (Scala.Js). It's considered production ready since version 0.6 I believe. On the server you can use Play, Http4s, Finagle, Finch or any JVM Framework. Downside: compile times. In large projects I happily pay for correctness with compile times (due to more powerful type systems), but most of the time I do small stuff and hate it.
I mean, do you use eclipse? It‚Äôs what turned me off of Java when I first took a class on the language. 
No details are given on how to compile iOS application in Kotlin native. This link may be helpful for someone. http://developine.com/kotlin-native-ios-development-multiplatform-project/
Unfortunately our message around multiplatform development must have been quite confusing, because this article gets many things wrong: - The multiplatform project support announced in Kotlin 1.2 allows to reuse code between Kotlin/JVM and Kotlin/JS. Sharing code between Kotlin/Native and other Kotlin target platforms is not supported at this time; it will be made available in the future. - The backend of the spinner app does not use ktor and does not depend on the common-jvm module (there is no such module in the spinner app). It's a native application using the microhttpd framework. - The website of the spinner app does not use Kotlin/JS or React. It is built using WebAssembly. - There is no Date class in the spinner app. There is actually a completely separate application, the conference schedule app (https://github.com/jetbrains/kotlinconf-app), which does have a backend in ktor and a frontend in kotlin/js and react, and does use the multiplatform project support in Kotlin 1.2.
ooops i used this article also for knowledge. and mixed its sample app with spinner app. http://hadihariri.com/2017/11/10/multiplatform-projects-with-kotlin/ Let me correct. Thanks alot.
Check Now. I have made corrections. I hope no issue now. Thankyou
If you'd like to ask "okay, but how does this solve any of my problems", [Jorge](https://twitter.com/JorgeCastilloPr/)'s talks and blog series covers the architecture side really well: [Architectures using Functional Programming](https://www.youtube.com/watch?v=qI1ctQ0293o), [blog series](https://medium.com/@JorgeCastilloPr/latest)
The intro music is way too loud for many of the videos.
Thanks, I'm looking into Gradle now. I was trying to avoid adding yet another unknown, but it sounds like I may be better off (I know basically nothing about Kotlin, just helping out at a project where someone incorporated it).
To be honest it's going to be a struggle at first but you'll be so much better of in the long term.
WebAssembly support?! Yes, there is interest!
Great article! Fantastic read for understanding the different functions. Going to bookmark. 
Sounds pretty advanced ‚Äî not sure this kind of thing is around yet
Convert the swift to Kotlin once and maintain that to target iOS with [Kotlin/Native](https://kotlinlang.org/docs/reference/native-overview.html) and android with Kotlin/JVM?
Why not use the official slack managed by jetbrains?
It's weird you don't use directly the elvis operator: var myString : String? = null ‚Ä¶ val myNonNullString = myString ?: return "" 
Why do people keep saying that I should just use a text chat site (slack) instead of making a voice chat server (Discord)? They aren't the same thing at all. Text chats make me crazy because I have to stop what I'm doing, take focus away from AS to answer and then go back to AS and try to remember where I was. But with a voice chat I just hit a button and say what I want to say, without my eyes ever leaving my work. No jumping between desktop apps, it's a lot faster and far less disruptive. It's also a lot easier to explain things that would take several minutes to type out in enough detail for people to understand. So no, you can't just say to use slack instead of discord.
&gt; let.{ it } Doesn't do anything. Let me explain in pseudo code. If myString is null, call function let, passing myString as the argument, which returns myString. If myString is null, return. Otherwise, assign myString to the constant myNonNullString. You'll notice you actually only need the last part
Interesting, but many typos 
If the return type of event.get() is Any/Object then cast it as soon as possible since you have no business with those types. By using smart casts instead of casting during assignment you leave val qpsA as type Any/Object which means you will need to smart cast every time you want to use it. This is because qpsA is only a JSONObject inside the if block. If you are using org.json.JSONObject I believe they have methods to coerce the value you want like so &gt; val qps = event.optJSONObject("queryStringParameters") qps is now of type JSONObject?
Thanks, yes I definitely don't need it, I wasn't aware about those opt methods which are more typesafe than get, thanks. Actually just checked and they are not in the library I am using... com.googlecode.json-simple:json-simple:1.1 org.json.simple.JSONObject So the more general rule is to cast in assignment using as? it seems, which I think results in neater code, thanks.
Isn't this exactly what the elvis operator is all about? AFAIK the main use of such a thing is for checking the length of arrays and such. This is only because myArray.length could potentially return null if the array has no elements. IE: var theLength : Int? = 0 // I always initialize, even if nullable. YMMV theLength = myArray.length // Will not cause your machine to loose it's magic smoke in a null pointer exception 
Just to check, is there any way to chain the cast in Kotlin, like in Java you would... String time = (String)((JSONObject)event.get("queryStringParameters")).get("time"); is there any equivalent in Kotlin, because obviously you can't do... event.get("queryStringParameters")?.get("time") because the compiler doesn't know the type for the 2nd get.
Thanks for the explanation :)
To be perfectly honest, I don't know why I didn't use that immediately. I think the challenge of being able to write something similar to `guard` was too enticing! 
Now imagine how this situation looks for someone who actually has to respond to questions raised on such a chat. Quite a few Kotlin team members are active on the Slack, but please don't expect us to join your voice chat.
Is it possible to join without a @jetbrains.com email? Sorry, I haven't used Slack before
I'm **guessing** you can by wrapping the cast in parenthesis val qps = (event.get("queryStringParams") as? JSONObject?)?.get("time") I'm not familiar with this because it's not something I would do. For readability, place the cast value into a temporary val then work with it after that I would recommend not using google's simple json if it's not capable of what you need. If you must use simple json, you can also make extension functions for it mimicking the opt methods
Extension functions is a great idea! I don't have to, it's just a non production example thing, agree with named val approach being best. Thanks for the help! 
Actually if you just add a `if (myString == null) return` after that line kotlin will immediately derive that myString is not null.
Yes, you can use any email.
When I pressed to join it gave me no option but to enter a jet brains email, the text box was only for the first part of the email and @jetbrains.com was hard coded after it. 
https://imgur.com/azhbRwd
Sorry, apparently you have to use this link: http://slack.kotlinlang.org/
Thanks, easily confused! 
Thanks, that looks promising. It doesn't support x64 so building for simulators might be out of question for now. If it interops smoothly with Swift then that is a good candidate 
Does anyone have a link for the previous post he mentions? &gt; In a previous post I covered some essential Kotlin tips like Singleton, Utility &gt;Functions, group Object Initialization, etc‚Ä¶,
And this is why people don't write books of this quality anymore. Do you post locker combinations online when you see them too? üôÇ
First of all, I want to say that I am glad that I bought this book and I like Kotlin, it is good and sexy language. I published this post because I am so confused to see copy of this book on github. Specially, after that when I bought it =). But in my opinion authors of this book don't mind seeing this book in free pirate access, because it is one of way of distribution Kotlin language and IDEA. I think they knew about this resource, otherwise we cannot see this book there =).
I'm always blown away when software developers, whether professionals or hobbyists, think it's alright to share clearly copyrighted material.
&gt; But in my opinion authors of this book don't mind seeing this book in free pirate access That's not your decision to make. 
You do not know the authors and cannot speak for them. I can assure you from meeting them authors are not rich and living a glamorous life. They work very hard and do not expect to give their work away for free anymore than you do.
I said it is my opinion, OK? And it is not my repository, I've just found it in the Internet. If it was my repo, I must be the last man in the world who publish it on the official reddit channel of Kotlin. I did not want insult people from JetBrains, I understand that they work hard and I respect them. I just want to show, that other people distribute pirate copy of propitiated product via github. I am sorry for misunderstanding.
That was on Windows right? 
Yes, but there shouldn't be a big difference on other platforms. The `gradlew` command is actually written in the UNIX style. On Windows you would execute `gradlew runDceKotlinJs --continuous`.
Nice article. How would you build the extension for redistribution? Is it still the xpi (zip) format? I guess you would take the compiled js files and the manifest and put them in the xpi file, but the paths to the js files would have to be adjusted. That sounds not too hard, but it would be nice to include that in the post.
I haven't actually gotten around to doing that. I suppose you would follow https://developer.mozilla.org/en-US/Add-ons/WebExtensions/Publishing_your_WebExtension
I never "expected" anything. I was asked why, and I answered. And why do you think anyone ever *has* to respond to questions that are asked? I never said any such thing. I really never understood why some people are so resistant to the idea of talking instead of typing. And yea, I am imagining how it looks. To me, it looks like I'm one of many people who like the idea of chatting, hanging out with small talk and being able to help each other in real time, via voice. It looks like I'm having trouble with being disrupted every time *I* answer someone else's question because I have to stop what I'm doing and type it all out. Yes, I answer questions too; and being able to just tell them the answer or discuss things with them without needing to stop doing what is in front of me is something I find very appealing. Apparently you don't, and that's fine. If you don't want to join, don't. But please don't expect the rest of us who do like the idea to not do it just because there are others who refuse to.
Is there any plan to have a built in logging module?
There is custom built in logging already, and as of five minutes ago there are plans to allow custom jetty-handlers: https://github.com/tipsy/javalin/issues/100. Once this is done you could add a jetty *RequestLogHandler*.
`apply` is a better choice for most of the cases in this article. `let` returns a new value, which you don't need if you're just doing a `null` check. `let` also makes this construction downright dangerous: ``` property?.let { fancyPrint(it) } ?: run { showError() } ``` ...because `showError` will _also_ run if `fancyPrint` returns `null`. Probably not what was intended here.
 val value = property?.let { it } ?: return This can be simplified: val value = property ?: return
I don't see anything wrong with long descriptive names, I'd rather verbosity over ambiguity and I believe that although not all will agree with me, most will. We spend more time reading code than writing it (for the most part) so it's nice to see understandable and legible code. I hate seeing stuff like: ArrayList&lt;String&gt; a = new ArrayList&lt;&gt;(); since that literally doesn't tell me anything about it.
I'd much rather see the verbosity of java than the overly short and ambiguous c++ style of using names like "atoi", or god forbid linux's "pwd", "cd", "fsck", etc....
Writing the first one kind of chose that you did not really understand `let`...
Everything has its place, I rather use cd than write "change directory" everytime I need to change dir.
Use Intellij IDEA community edition. Android Studio is a fork of IDEA created specifically for Android development and not suited for this kind of tasks.
Is the interface and editor close enough to the AS Fork that if I spend time learning that one then I can just move over to AS when I am ready to start App development?
It's the same interface, but you can use it not only for Android apps, but for any Java/Kotlin program. With AS you can only create Android projects, with IDEA you can create Gradle/Maven/Idea Java/Kotlin programs. You can also create Android projects in IDEA, AS functionality comes as a plugin. tl;dr it's the same program but you're not limited to Android projects with IDEA.
Interesting thanks.
For C++, you could try: #define anyToInt atoi or #define parseInt atoi etc.
This. Verbosity really isn't as big of an issue as people make it out to be, and it's great for people reading your code
People seem to be going off in two different extremes here. There is a middle ground between a single-letter variable named `a` and `MatchingServiceResponseDtoToOutboundResponseFromMatchingServiceMapper.java` Something like that could just be called `ServiceResponseMapper` and put in an appropriate package. The reset of the information being conveyed in the name isn't really important to the function of the class. One of Kotlin's design goals is to be **concise.** The exact definition of concise is worth looking up: **concise** adjective ‚Äã /k…ônÀàs…ë…™s/ *Giving a lot of information clearly and in a few words; brief but comprehensive. Expressing what needs to be said without unnecessary words; short and clear.* This is not the same as "terse" (although they are often used interchangeably) **terse** adjective us ‚Äã /t…úrs/‚Äã *Using few words. short, brusque.* Naming is hard. You want to convey the most important thing about the class/function/variable without overloading the next developer with useless info. Names also can clue you in to when a Class or function is doing too much. `MapperAndConverter` for example, is possibly something worth breaking into a `Mapper` and `Converter` In Kotlin, the language is more concise and expressive, this will help some. But we as devs still need to learn the balance and trade-offs of verbose vs terse names. 
I think long variable names are also disliked by those working with dynamic languages, as you no longer have a compiler to tell you your `matchingDatasetsToMatchingDatasetsDtoMapper` doesn't exist when you meant `matchingDatasetToMatchingDatasetDtoMapper` and you have to validate it yourself. That being said though, I really like them and consider them as one of the virtues of using a statically typed language.
yeah this problem is pretty much non-existent if you're using an IDE like Intellij IDEA
Code needs to be read much more often than it needs to be written, and that is the reason that Java prefers verbosity over conciseness. A little extra effort when writing pays off massively. 
How to develop restful web service in Kotlin programming language using spring boot tutorial.
Unfortunately this approach makes the resulting code _harder_, not easier to read. A competent C programmer will have made peace with `atoi`. Not so with `parseInt`. What are it's weaknesses compared to atoi? How many of these foreign abstractions can you keep in your head as you read the code? There's a lot to be said for embracing the native idioms of the language you are in.
Why are you using kotlin in this tutorial? Don't get me wrong, I really like the language, but you are clearly following the java paradigms while skipping everything useful that kotlin has to offer
As someone who is learning Kotlin and Spring Boot, what should be done differently when using the two together? 
There is no need for ‚Äû@Autowired lateinit var userRepository‚Äú. You can add it to the constructor of the RestApiController. class RestApiController(val userRepo: UserRepository). Spring will take care of autowire for you.
As for resources to learn - I would suggest starting with spring.io, they have wonderful quick tutorials on pretty much everything spring related. Here is the one I used to get going myself: https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin Once you are comfortable with the regular stuff, you can look into the awesome features that Spring 5 brought for kotlin: https://docs.spring.io/spring/docs/current/spring-framework-reference/languages.html#kotlin &amp;nbsp; About OP's post: The biggest anti-pattern seen here is that ```lateinit var``` is used literally everywhere alongside an explicit constructor. This is easily avoided, especially for the @Entity classes, by utilizing Kotlin's ```data class``` For example this (taken from OP's post): @Entity class UserFeedback() { @Id @GeneratedValue(strategy = GenerationType.AUTO) val id: Int? = 0 lateinit var email: String lateinit var stars: String lateinit var feedback: String lateinit var fcm_token: String lateinit var deviceId: String constructor(email: String, stars: String, feedback: String, fcm_token: String, deviceId: String) : this() { this.email = email this.deviceId = deviceId this.fcm_token = fcm_token this.feedback = feedback this.stars = stars } } can easily be done like this: @Entity data class UserFeedback( @Id @GeneratedValue(strategy = GenerationType.AUTO) var id: Int = 0, var email: String, var stars: String var feedback: String var fcm_token: String var deviceId: String) (probably with Long instead of Int for id and val instead of var for immutability). Also, please don't do this... val n = User(name, email) n.name = name n.email = email 
Sorry, this was a bit unwarranted. The community is of course welcome to organize in any way, and there is no expectation that anyone from JetBrains has to participate in everything that is going on. I just imagined what my life would become like if I had to respond to such a chat (and we do _have_ to respond to YouTrack issues and forum posts), and felt that it would be a nightmare. 
If the verbosity is so essential why do we only tend to find it in Java and it's copycat C#? Other languages get by just fine with reasonably concise method and class names.
It's not great for me, I can assure you. Give me Ruby or Python conventions any day of the week.
The number of responses by Java devs favouring verbosity over conciseness confirms my worst fear - that Kotlin's concise expressiveness will matter little when Java devs turn to Kotlin importing their hideous naming culture. I, for one, will not adopt Kotlin if most of the code I'm going to be reading is just Java with different syntax.
The same applies to Ruby, Python, C++, Rust, C &amp; Scala so that doesn't explain why verbsoity tends to be Java's speciality.
That's really usefull! Thanks!
It goes both ways. I'm a Java dev who loves how concise kotlin is, but yes I do prefer code that is a little more verbose if it is also a little bit readable. There is a tradeoff there. Give me static types and clear variable names any day over "do whatever you want" JavaScript.
I wouldn't give up hope just yet. It may just be a natural response to a question about an oft repeated criticism of Java that isn't always valid (although your link is not only valid, but hilarious). Luckily the Kotlin language itself already helps by being concise and expressive. Getting people to change their ways however, requires a bit of advocacy and time :)
Brian Goetz explained it very well in his talk at Devoxx this year, If it improves readability it may get in to Java, but if it only improves conciseness it will likely not be. 
Gotta love this gem (from the cited source): public MatchingServiceResponseDtoToOutboundResponseFromMatchingServiceMapper(MatchingServiceAdapterConfiguration configuration, MatchingServiceAssertionFactory outboundAssertionFactory, AssertionLifetimeConfiguration assertionLifetimeConfiguration) { A contender for the Java Verbosity Prize, surely.
Yeah, that is a little intense. I believe in names that have enough length to be clear, but there is a point where they get too long that they're not easily readable. Either extreme is wrong.
I like this and totally agree with you, perhaps in my example I was a little extreme (but it's not like I haven't seen it) and perhaps the example OP has given is also the other end of the extreme. Your response is basically the ideal, but the schools of thought are many, and what I find reasonable (long and descriptive or verbose) someone else may not. But I completely agree with you, the most description in as few words as possible without being too verbose but also without being too terse, the sweet spot.
Concise do not mean hard to read. Verbose do not mean simple to read. String concatenation using + overload is not hard to read. Anonymous inner class is not simpler to read than lambda.
The Kotlin way to do this is: var myString : String? = null // myNonNullString is a String, not a String? val myNonNullString = myString ?: return I'm pretty sure the Kotlin community would never agree to add a `guard` statement since this is already addressed in the language first-class with the elvis operator.
Thank you!
No sweat, I can imagine how disruptive to your own day it would be to *have* to stop what you're doing with every question. But no, that's not at all what this is about. I used to hang out in the study room of my physics class. It was where a bunch of us would go during our off time between classes and we'd shoot the breeze or help another student if they had a problem... *Or we'd just let someone else help them because we had our own work to do.* But the vast majority of it was hanging out and every five minutes or so someone would have a "tiny question" such as: "what's the symbol for the gravitational constant again? Was it big G?" Three of us would say "yea" at the same time and go right back to chatting about whatever. And to me, that's the point. A little bit of a social factor would be nice for those of us sitting in a room alone and being able to give and get answers in a few seconds rather than take a bunch of time to type it all out. But also don't forget that a lot of people are in cube farms or other such office spaces, so they can't do the voice thing. In that case, the existing chats such as Slack and here are definitely better. Have a great holiday!
Nice!
Copy pasting the error here would be a good 2nd step. First one being paste it into Google.
&gt;Kotlin &gt;Rx &gt;Dagger Get wet
You need to create a multiplatform project with JS and JVM modules, and then to add a regular Android module which depends on the JVM module.
That's exactly what I was looking for, thanks
I've added more information about the errors I'm getting.
How do you specify this dependency?
You can't use the version 3.0.0 of the Android Gradle plugin in a multiplatform project (because of the "requires Studio 3.0" error). The KotlinConf app uses version 2.3.3: https://github.com/JetBrains/kotlinconf-app/blob/master/android/build.gradle#L10
Because it's not essential, it's just better. Code is meant to be read, not just written.
Thanks for the idea! Scala is right on point because it does support static typing, and it does support JavaScript transpiling. As you pointed out, the transpiling is probably more mature as it has had more time to mature. I have a question about your comment about Idris. Are you saying Scala does have an Idris like type system? Does Kotlin also support this? It's possible that might end up being really important for me, but I guess I will have to experiment to find out. Probably not matter what, switching to a Java based server is the right way to go, as it would allow us to experiment with different JVM languages...
the medium post is almost as good as the readme
No, I should have made that clearer. That was only a wish from me, since I prefer more powerful type systems (I know I'm only a average programmer, so I prefer the typesystem yelling at me if I screw something up) but also want to have fast compile times. From what I know about Idris, Idris is more powerful than Scala, but I'm not good enough with either, so take that with a huge grain of salt. ;o) Yeah, that sounds like a good choice. In the end Kotlin might turn out as the perfect middle ground (not as powerful as Scala but more powerful as Java, backing from Kotlin, already successfull in the Android space, designed for good Ide support etc.). Also of intereset regarding scala might be this (if you don't already have seen it): - https://www.reddit.com/r/scala/comments/7e7i6i/so_whats_wrong_with_sbt/ - https://news.ycombinator.com/item?id=15738550
I could tell you were veering off into a random wish rant, but it caught my attention because I already had my interests peaked by Idris and dependent types. I've done a little more research now and it does seem Scala has some support for dependent types, although not as sophisticated as Idris. Kotlin does not seem to support this at all. Basically I'm now under the impression that Kotlin is basically a better version of Java or C#. It stays clear of getting overly complex and remains mainstream enough for normal programmers to use it comfortably. Scala is more complex, sophisticated, and convoluted, while still clinging to being somewhat mainstream, at least compared to the fully functional languages. I have heard Kotlin has better IDE support. I have this problem where I can't seem to write even simple code I consider clean and clear, especially if I write the backend and frontend. I know Kotlin will get me closer to it. I wonder if Scala will get me even closer, but I question if the added complexity and more advanced type system will actually make the code clearer, safer, and cleaner, or if it will just cause me to make too many types and constantly explore new rabbit holes in search of a "better way"... Ultimately part of the appeal of dependent types for me is trying to achieve the right balance. I want to have code that has as little duplication as possible, is providing as much static verification as can be done without polluting the clarity, DRYness, and reasonable brievity. I think it might help with this by constraining how a specific class can be used under different circumstances without having to create a bunch of confusing inherited classes to achieve it. I hope to combine dependent types with the concept of roles from DCI. I believe each class needs to be both flexible and rigid, especially if you want to reuse it across the entire stack. I don't agree with the "clean code" concept of creating lots of alternative versions of classes that objects get converted to at each layer or hardware boundary. That is way too much busywork and duplication to maintain. I like that DCI is focused on reuse without convolution via roles. I also like that it is focused on keeping to code clear and readable by representing the features directly in the code and encouraging you to base the code model on the end user mental model and the model implied by the UI.
The documentation for this library is terrible (most of the pages are still blank) which is a real shame and must be limiting uptake. If you want to find out something you have to figure it out from one of the sample projects (which are all uncommented themselves). Seems to be actively worked on, but please JetBrains provide some documentation!
I noticed that last night when I tried to get started. Most of the "Getting Started" steps are missing key pieces of information (like which libraries to include). It's frustrating for someone who's trying to pick up Kotlin, but wants to primarily use it for a back end server. I think it'll be a really nice library once it gets a little more love, though. It's definitely got the right ideas.
I was thinking of starting a toy project with this framework but the lack of documentation turned me off. Looks very interesting though and I hope the documentation matures.
_StackOverflow question style intensifies_
Some links please monsueir!
It is something similar to AspectJ
This is the closest thing I could think of: class Decorator(val function: (Int, Int) -&gt; Int) { operator fun getValue(decorated: Any?, property: KProperty&lt;*&gt;): (Int, Int) -&gt; Int { return { a: Int, b: Int -&gt; println("I'm going to run fun next.") val returnValue = function(a, b) println("I have finished running fun. Will stop running") returnValue } } } class Test { companion object { val myAddFunction: (Int, Int) -&gt; Int by Decorator { a: Int, b: Int -&gt; a + b } val myMultiplyFunction: (Int, Int) -&gt; Int by Decorator { a: Int, b: Int -&gt; a * b } } } fun main(args: Array&lt;String&gt;) { println(Test.myAddFunction(2,3)) println(Test.myMultiplyFunction(2,3)) } Basically you can delegate the property (or function) definition to a decorator which takes itself the real function as a constructor parameter. Due to the type enforcement, you do end up needed different decorators depending on the function you want to decorate (to keep parameters and return value.
I would be interested in something like this, too. But I'm afraid the closest thing to Django's ORM in the Java field is Hibernate. Things like JDBI and Jooq provide nicer access to your DB but are quite different from the complete package that Django gives you. 
What you're asking is just wrapper code. AOP (aspect oriented programming) does that, specifically AspectJ. Kotlin, nor any other JVM language I can think of, does that. Probably because it's not a language feature, is rarely needed and can be done using 3rd party libs like AspectJ or Spring Framework.
I'm not sure I agree that languages do not support wrapper code or that we need to use AOP for OP's usecase. It sounds to me that he's looking for a convenient way to "redefine" his function without having to modify the code of the said function too heavily. Hopefully the solution I suggested with delegates to define the function in the first place will do what they're after. It also has the advantage of being able to be defined at runtime (the delegate) for more flexibility while still not impacting too much the original function definition. But I agree with you that what OP's after is a wrapper (that's what a delegate is)
 Kotlin has different tools to solve problems that are solved in Python by decorators. If you state the exact problems people can suggest a good way to solve it in Kotlin.
 inline fun dec(crossinline f: ()-&gt;Unit) { println("before") f() println("after") } fun printy() = dec { println("fun") } fun main(args: Array&lt;String&gt;) = printy() It can be tried at https://try.kotlinlang.org/
I really like this one. I'm a bit biased in favour of the use of delegates (syntactic sugar) of the `by`, but this one is more efficient post compilation.
You cannot. Kotlin type parameters are erased, just like Java's. That type parameter will not exist at runtime and `return DerivedType(...)` will return to a type that does not exist.
What pattern can I use to instantiate an instance of the derived type then?
Same as you would in Java. If it's an abstract class, make something like `abstract fun createDerivedType(): DerivedType` and have the implementations override it. Or take a factory function in the constructor if it's a non-abstract class, like `class A&lt;DerivedType: BaseType&gt;(private val createDerivedType: () -&gt; DerivedType)` and invoke that function whenever you want a new type.
Hmmm that really isn't that elegant :/, thanks for your help!
Thanks a lot. i will definitely make improvements. :) 
Thanks alot Dear. I will make changes accordingly. purpose was to give an idea how one can develop rest web services in kotlin. and how spring boot can be used for this purpose. :)
The question is what you consider "similar". I would give [Hibernate](http://hibernate.org/orm/) or [EclipseLink](http://www.eclipse.org/eclipselink/) a try. 
It's not that bad, you would create the class as A( { SomeDerivedType() }), for example. Another way would by actually providing the class, such as A(SomeDerivedType::class.java), after which you can create an instance of that class (https://stackoverflow.com/questions/6094575/creating-an-instance-using-the-class-name-and-calling-constructor).
Yay type erasure...
You can create an inline function and call it from there. Inline functions support reified type parameters, which means you *can* instantiate the generic type. For example: fun &lt;reified T&gt; create(): T { return T() }
That isn't valid syntax (there's no way to restrict the type parameter to classes that have a visible default constructor). You can get the class reference from the reified type parameter &amp; instantiate it reflectively, though.
Holy shit you aren't kidding. The framework looks super cool and very much functional, but man, the documentation really needs to improve. I mean, it literally took me thirty minutes to find out which dependencies to include in my gradle config to get a simple hello world running.
I also found [Ebean](http://ebean-orm.github.io/) which looks like a simplified version of Hibernate and seems to be quite similar to Django's orm.
I'm not sure about the performance of the implementation but the whole idea behind Sequence is that it's a *lazily*-evaluated iterable/collection, similar to Stream. It's only iterated once per terminal call (groupBy, toList, etc.) The equivalent methods on List/Array are eagerly evaluated. They would iterate twice.
There's a plugin that allow you to decompile the Kotlin bytecode and see some equivalent java code. Its not perfect, but it should help.
The compiler inlines all the operations automatically iirc
Filter, map and so on are sequence decorations. They are compositions, so more objects are involved and the data goes once through such a composition until something that requires all of the data like e. g. "sorted" is reached.
So is what you're saying that the compiler sets up these functions so that, as it iterates through the collection, it runs all the various functions against it as necessary, during a single iteration?
So basically functions that return another Sequence (ie, not terminal) can be chained together without a performance hit, but functions that return something else (ie, terminal) can't be chained without causing multiple iterations? Which would make sense, but I'm just trying to make sure I follow you here.
yep, as a professional java dev that has been pissing me off since forever... Very early on in my career I decided to myself "there just MUST be a way around this." A few days later, I finally gave up. lol
&gt;apply plugin: 'kotlin' &gt;apply plugin: 'application' AFAIK to run both Android and kotlin together you need to apply the plugin kotlin-android
I'm not using Kotlin for Android, though. It's just a normal application.
Can you please put the project in a repo on github? I can take a look and tell you whether it's your computer or not.
Your dependencies probably cant bei found because you did Not add the repositories where they are deployed to. Take a Look at https://github.com/kategory/kategory and copy their repositories to your build script. The gradle build should then work (please try it in the command line, Not the ide). Afterwards, you can Go to intellij's project structure and chose an appropriate kotlin sdk for the project. Or reimport the whole thing as a gradle project and IT will work i guess.
Yes, however it's not so straight forward in terms of performance. Lazy iterators like Sequence have a fairly considerable overhead per `next` call. If it's a hot code path you should benchmark, because eager operations might actually be faster.
I was thinking, you may need to add our bintray repo directly too `maven { url 'https://dl.bintray.com/kategory/maven' }`
https://medium.com/@tpolansk/declarative-kotlin-lists-sequences-and-rxjava-7301da36bc52
Yes, a Sequence always iterates only once, a List iterates `n` Times for `n` Operations and creates `n` Temporary Lists
Here is a blog post about when to use Sequence rather than Lists https://proandroiddev.com/sequences-a-pragmatic-approach-9d4296086a9d
I think that did it. At least it works for now. Thanks!!
Is there a significant performance cost for converting from list to sequence and vice-versa? Just wondering, since this is going to make me want to switch between them under certain circumstances?
Why another one? Isn't kategory enough?
To get the entire uncompiler class as a String? I don't think this is possible in *any* compiled language, which includes Kotlin.
Not Sure if i understood what you are searching for, but does this answer the question https://stackoverflow.com/questions/442747/getting-the-name-of-the-currently-executing-method ?
I think you could get close, but it'd require a lot of work and you wouldn't be able to get the method definitions. You could essentially create a class printer that tries to use several reflection attributed to get class/method names and parameter information.
All Kotlin and Java code is compiled to intermediate bytecode, the original source code is not kept.
That's close, but not much... thanks ... I guess I will have to create a special class to do that.
Nice tip, thank you. 
Question: What is your position on Entity Component Systems?
I mean... you could technically hack it in Java by getting the class name via reflection, searching recursively for the file with that name in your working directory, and using a reader to read in the literal contents of that file as a String. But yes, I doubt there's a true programmatic way of doing what the OP wants. I'm sure a similar thing could work in Kotlin (except it maybe a little harder, since the title of a file doesn't have to be the same as the name of the class contained within it).
Why don't you start documenting the framework or writing a getting started post? ;)
Because by no means am I a good backend developer, nor do I know how the framework works. I mean don't get me wrong, I'm all for contributing to oss, but I wouldn't like to be spreading misinformation.
Why do you need to get the code as a String?
funKtionale was created before kategory
Exactly. This feels like a [XY problem](http://xyproblem.info).
IIRC no, there isn't a huge performance cost. List.asSquence only creates a Sequence instance that wraps the list without iterating the list. Sequence.toList() iterates over the list, applies all operations and puts the resulting items inside a list. 
Why are other cars in the world? Isn't honda civic enough? 
I'll start my own just to spite you. 
Exept that for open source projects it will mean double effort and double number of bugs.
Another abandoned project on GitHub. We need that.
I haven't used the traditional ECS much. In general, I prefer a modified version of ECS that I use in FXGL: ECC (Entity Component Control). In ECC: * Entity is the same as in ECS * Component is a pure data structure that uses JavaFX properties (these properties are essentially like value wrappers but can bind to other properties and can be bound to. In addition, they can be a part of a bigger expression). This allows us to easily communicate between components, e.g. pseudocode `view.xy.bind(position.xy)`, where `view` and `position` are components. * Control is a behaviour. An instance of a Control is attached to an Entity to perform some action per frame. For example, `LiftControl` can be added to make an Entity move up and down. Splitting data and behaviour, as well as making each behaviour modular (ideally a Control does only one thing), adheres to the Single Responsibility Principle. Furthermore, the ability to mix components / controls demonstrates scalability, thus making ECC (ECS) a powerful pattern. Hence, it's likely to be more suitable (with respect to game objects) than the Object-Oriented approach. Having said that, without a specific context it is not as obvious.
But the core purpose of Flutter is it's supposed to create a iOS build at the same time as an Android build, no? Is there no React-like that does similar?
Because I will be "automating" ( or simplifying ) lots of processes such as file writing, file reading, db connection, etc, etc, etc. For example, a developer wouldn't need to create a function to accomplish such task, the dev would just need to input: file_name: C:\\user\\Myfile.txt create_dir: true append_content:false Obviously, there will be more options and rules, but that's just an example. When the dev has input all the necessary information, he just presses "finish", and at the end, you get a nice writeToFileFun.kt ready for production. I'm already doing it but i have bee using lots of strings. First, replacing the variables with the input, and then writing the whole function as String so it can be written to writeToFileFun.kt. This is just part of another even much bigger process which would make developement faster Thank you 
You should simply use DSL in Kotlin
I have bee looking into Xtext, and ANTLR, but I think they are complicated than what I actually need... any other you would recommend?
None based on Kotlin as far as I know. That's not surprising - until recently, you couldn't get Kotlin to run on iOS, except with solutions like RoboVM (now discontinued), Multi-OS Engine, etc., which brought a lot of their own issues. For other languages, there is of course React Native, which can also be used with TypeScript. But I'm pretty sure someone will create a library like that once Kotlin Native reaches a production release.
You should write a DSL for compile the following code to your specific use case: writeToFile { fileName = """C:\user\Myfile.txt""" createDir = true appendContent = false } If this is a acceptable option for you then you should consider some advantages: 1. It is pretty fast to compile, you don't need to run you own compiler. 2. It is a regular Kotlin code, so you can use regular Kotlin syntax. 3. It is easy to update: you can update the implementation as a regular maven dependency, you don't have to recompile all invocations. 4. It is easy to debug: final line reference and variable are effectively referred in .class file.
I think that would work, I just found some tutorials regarding kotlin DSLs
Ah okay now i got got what you searching for, you Want to access the source code of a class. Since the source code is Not available because only the bytecode is, you have to do veeery much magic to achieve thus i think. You could package your apps source code in the jar file and use a special claasloader as your only claasloader. This cl can load all resources and make them available per method. All classes can access the class loader and Cast it, to access the source code. But the whole thing is probably way to ugly and costly.
Yeah, after learning Kotlin and then reviewing my iOS colleague's use of `guard` in Swift code, all I could ask is "why does this exist? why have they introduced this weird new concept of an `if(x == null)` check". They should really adopt the way Kotlin behaves and deprecate `guard` imo
https://blog.jetbrains.com/kotlin/2017/06/kotlinnative-v0-3-is-out/
The comment that I left to this article: Great article! Please allow me to play devil's advocate though. Concurrency is hard to implement, challenging to quantify and impossible to test reliably (heisenbugs). Concurrency bugs can be present in codebase for months and even years before they manifest themselves, and then it can take months to find and fix them. Given all that, concurrency is, probably, one of the most complicated and dangerous topics in software. It is not something that should be taken easily or discussed shallowly. The current standard intraprocess concurrency approach on JVM is to use threads. Some JVM languages already have coroutines, but it looks like coroutines in these languages became a very niche thing. Threads have been around for decades, which allowed us to gather a great deal of experience with them and establish a set of common best practices. While not bulletproof, experience and best practices mitigate the risks imposed by concurrency to some degree, thus allowing us to have relative peace of mind while writing concurrent software. Let's now review Kotlin's coroutines in light of the above discussion. Coroutines introduce completely new approach to concurrency. Since this approach is new and very different from the standard multithreading, our experience and best practices are largely irrelevant in context of coroutines. This means that adoption of coroutines expose us to huge risks related to concurrency bugs, which, as we said earlier, can take months to identify and fix. Coroutines are not a direct substitution to the classical multithreading. Therefore, new developers coming into the field will need to learn two different approaches, which substantially raise the barrier to entry and ramp-up time. Why would anybody agree to tolerate all these risks and complications? Performance!? What percentage of developers who write code for JVM have ever experienced issues associated with performance or memory limitations under heavy multithreading? 1%? 0.1%? 0.01%? Not many anyway. And even in these rare cases, it is much cheaper and safer to just upgrade the hardware either vertically or horizontally, than to attempt to optimize the code using coroutines. For behemoths like Facebook or Google such an optimization might be worth the hassle, but for the majority of us it is totally irrelevant IMHO. 
Sure, but no Linux -&gt; Windows cross compilation. https://blog.jetbrains.com/kotlin/2017/04/kotlinnative-tech-preview-kotlin-without-a-vm/#comment-43461
Good!
I've been working with reauery recently and like it. They have support for rxjava baked in. The only downside is the documentation isn't stellar.
Constructing an object through reflection is absolutely not elegant or clean. It's a brittle design and passing in a factory lambda is better.
Java retains generic type information at run time. Check out the reflection APIs. "Type erasure" is not a real problem. In generic APIs that use reflection, it is better to pass type information around explicitly and avoid relying on instances to carry around type information (e.g. avoid instanceof and getClass). It would be nice if functions could reference their type parameters but in practice it would mostly be syntax sugar for passing types as variables (easily achieved in Kotlin with `&lt;reified T&gt;`).
I guess coroutines are useful if you're compiling to JavaScript as well, but for running on the JVM I'll stick to threads, because as you say, I've had all those bugs before.
Ha ha ha ha ha ha.
I agree, a lambda is much better, I just gave an example of what is possible.
Coroutines are useful for *avoiding* concurrency. It is not uncommon to be using a single thread for a network connection in java, for example. However, this sometimes requires you to basically build a state machine in your code to save state between event loop invocations. Coroutines are an alternative to that, while still avoiding concurrency.
Thank you, you know, I think I'm gonna go with DSL .. lets see how that turns out. Thank you!
funKTionale author here. funKTionale is older than kategory, is almost as old as the first usable version of kotlin. funKTionale and kategory have some overlap on monad types, but there are specific features on funKTionale that aren't cover on kategory such as function composition, partial application, currying, memoization and others. There is also kategory features that aren't cover by funKTionale. Cheers
&gt; Coroutines are useful for avoiding concurrency That's exactly what I'm talking about. Thanks for a quick demonstration. If there is one thing that should be kept in mind at all times, it is this: COROUTINES ARE CONCURRENCY CONSTRUCTS. By thinking that coroutines somehow avoid concurrency you basically set yourself on a straight path to concurrency bugs. We have already had one attempt to "avoid concurrency" in Android - AsyncTask. We all know how it worked out. 
Did you ever talk to /u/pakoito about joining the efforts to build just one great library?
I have good relationship with the kategory team, but never discuss anything like that. https://twitter.com/dh44t/status/870251774178885633 (back when kategory was named katz) Both projects have different goals, philosophies and markets. funKTionale is very modular so it can be used in a project with kategory with no problem. I'm thinking that some translation layer can be useful, e.g. `toKategory()` and `toFunKTionale()` in the monad modules
It is significantly easier to avoid concurrency issues with coroutines. Your concurrency points are well-defined (though not explicit without an ide) so it is much much simpler to ensure consistent state. And all this while still having the fluent writing style so typical of a threaded model.
funKTionale complements kategory perfectly! we don't want to get into function helpers, Mario already did a great job there :D For the Monad part we can align sometime. We already have an initiative called [KindedJ](https://github.com/KindedJ/KindedJ) to interop even with Java libraries. It's not deployed yet, I got sidetracked and never registered the org in Maven. Will have to do it at some point.
I assume that Kotlin/Native can provide a C ABI function callable from the JNI, but I'm not sure.
At least one of the code examples are depressing. There are some very obvious race conditions.
Do you mean the increment snippets? Technically, the value of the counter is never used, so even though the value could change from one execution to another, it does not matter. There is no race condition. Each execution yields the same outputs. 
https://i.imgur.com/FiiZByx.jpg
It is indeed a race condition, no doubt about that whatsoever. If the value of the counter is not meant to be valid, then why have it in the first place? I find your comment here even more depressing than the examples.
I dislike the example in the blogpost as much as you do. I'm just pointing out that it is not technically a race condition. From wikipedia: &gt;A race condition or race hazard is the behavior of an electronic, software, or other system where the output is dependent on the sequence or timing of other uncontrollable events. Here (if we are talking about the same snippets), the output is the same at each run, independantly from the order stuff gets executed. So technically, it is not a race condition. If we add a println(counter) at the end, there definitely is a race condition.
Regarding the dislike, fair enough, I misunderstood you. Regarding the race condition and the technical definition, if we have to get technical like that ( :-) ), one could assume that the examples are snippets in a code, and it would be natural to assume that the variables would be printed, though that is indeed one interpretation, an interpretation that would be clear if there were added something like "..." or "[...]" to the (start and) end of the code examples.
Another issue regarding the examples are that of memory consistency. But I do not know how Kotlin handles that regarding local variables. For fields, it seems to have the same semantics as Java, namely that you can add `volatile` to the field (in Kotlin using the annotation `@Volatile`).
Captured local variables used to be volatile in Kotlin, but no more. There is definitely no guarantee of what value you read from a thread. People should use a val with an AtomicReference, or even some manual locking for example. I'm not sure if the author of the article is aware of the problems in his snippets or not. Could be that he tried to make the example as small as possible. But I still think that in any case, the article is dangerous because people may assume every snippet is correct.
Is it just me or does the list of language improvements in 1.2 seem rather ... pedestrian? In other words, surprisingly mature for such a young language. Bravo!
It looks like only Android Studio and IntelliJ IDEA support Kotlin so far. Any word if this will end up on PHPStorm and Webstorm also?
We plan to build a plugin for WebStorm too. Don't know whether it will be available in PhpStorm too; we definitely don't plan any Kotlin&lt;-&gt;PHP integration.
It seems silly to need 2 different IDEs for front and backend work. Javascript and PHP are 2 sides of the same coin, and it'd be nice to do Kotlin for the front end and PHP for the backend. As long as it's a second-class citizen, I can't see investing my time into it.
I noticed a couple functions are missing from kotlin.math, like `Math.cbrt`. Will this be added in a later release?
If you're considering using Kotlin at all and you have a PHP+JS project, I would really strongly suggest to consider using Kotlin for the backend first, not for the frontend.
Possibly. Please file a YouTrack issue for the functions that you'd like to be able to use.
a new *process* for each request? For low values of new.
That might be possible sometime in the distant future, but I guarantee that no company I'm likely to work for will rewrite their entire backend for a new technology just because it seems like it might be nicer. However, being able to incrementally add it to the workflow *is* possible, and since Kotlin can be compiled to JS (and thus interact with existing JS), I could probably convince people to at least experiment with it in the near future. But not if we need to buy multiple IDEs to even consider it. In the end, I seriously doubt we'll end up with Kotlin on both sides anyhow, as one of the things they like is that PHP is easy to host anywhere. I can't say the same for the JVM or Node.
Have they said anything about distribution of common libraries? Like write a library in "plain old kotlin" and make it somehow available for external js, Java and native projects? Something like the way gradle does it
Then buy Intellij ultimate.
Right now we use Maven repositories to distribute common libraries, but it's possible that we'll have a different solution in the future.
Is there some guidance in the docs or do maven artifacts just work and it won't be the official recommended way in the future? Can I push it to bin tray (because it's no jar?) and use it in a kotlin JavaScript project via gradle?
Doesn't this only apply to Java code that can't benefit from the null check?
Hi yole! I've been wondering this as well. I've been waiting for this release to churn out some common pure kotlin cross-cutting concern libraries and want to know what the best practice here. Do you have an example? 
The last I checked, JetBrains, the creators of Kotlin, did not make a language server for it Kotlin. Anyone else is free to make one. In order to avoid alienating the community by having Kotlin be overly tied to a single IDE, JetBrains did make a version 1 of a plugin for Ecliplse. Now they want the community to take over that effort, since Eclipse is a competing IDE. You can also use Kotlin in the community/free edition of JetBrains IDEA, or you can pay for the Ultimate edition to unlock all the features.
Kotlin was developed for 4-5 years before 1.0
The main reason I hesitate to use Kotlin is that it doesn't have good support in Eclipse (which is my choice of poison). I understand that Eclipse competes with Jetbrains products so there is little incentive for Jetbrains to keep it updated; the onus lies with the community. However, there are some pull requests from the community which are not being merged / reviewed and that saddens me.
There is nothing wrong with calling `null.apply{...}` so the problem is obvious. Also I don't see how the new version is improved. The if makes the purpose of the code much more clear that the weird append chain. 
There is a jar, or rather three jars (one with .class files for the JVM, another with .js files for JS, and another with .kotlin_metadata for the common part). And you can depend on such a jar from a Kotlin/JS project built with Gradle. There are no docs at this time, but we'll provide them soon (and they will describe the current Maven-based approach).
The best example at this time is probably the kotlinx.serialization library: https://github.com/kotlin/kotlinx.serialization
Indeed, and I feel sorry for the Swift devs I know. In contrast they had to change their code from Swift 1 to Swift 3 every time.
Kotlin was first revealed in 2011 after being in development for a year, 7 years is not a lot of time for a language to reach a state of maturity
So, how it compares to https://github.com/Kotlin/kotlinx.html ?
I checked out examples and i must say that i prefer https://github.com/Kotlin/kotlinx.html DSL instead of passing props and children as function parameters.
That's what I thought, although I understand that the behaviour can be confusing for someone who hasn't used Kotlin a lot. Usually, people help themselves with a function like fun Any?.notNull(f: ()-&gt; Unit){ if (this != null){ f() } } But I somehow have the feeling that such a function should have been in the std :)
That's exactly what ?. already does. A function would be relatively useless. 
Yea I know, and if(x == null) does exactly the same, hence the ?. would be useless, too? Seemingly, there are people who think that using ?. is not explicitly enough, but using something like ifNotNull { bla() } is nicely readable and therefore can be an improvement. Since people already started to write such functions for themselves, having it in the std would prevent people from using apply in the wrong manner.
&gt; Yea I know, and if(x == null) does exactly the same, hence the ?. would be useless, too? if is not chainable. The `?.` operator makes sense because it allows much shorter code. I'm sure people write all sorts of functions, but your `x.ifNotNull{bla()}` does the same as `x?.run{bla()}` or as `listOfNotNull(x).forEach{bla()}` and I don't really see the need for another function.
also Scala was also there, so it's was easier I guess.
Yes, I got it that you don't see the need - and you can keep thinking whatever you want. My only argument was, that (although I personally have no problem with it) people seem to find x?. worse readable than x.ifNotNull. And I can agree here to a degree, although I got used to it. Still arguing with "but it's shorter" seems outdated, since we're not searching for shorter code, but for better readable code. None of the alternatives with run or forEach is better readable than ?. or ifNotNull. And that's why people write forms of this function in their projects, resulting in a non standard way circumventing a problem that clearly exists for people (irrelevant if it exists for you or for me). It would be less harm if such a function would simply have been added to the std.
What is the benefit of using coroutines instead of executing runnable tasks using thread pool?
A coroutine can suspend without blocking its thread.
Oh alright. Makes sence, thanks.
Yes but IDEs are so overweighted I rather simple editors
On the surface of it, I totally agree. OP, maybe you could expand on why one should your framework over kotlinx.html? The use cases seem to be overlapping.
The `?.` and `?:` operators are part of the language. If you've reimplemented a crippled form of a standard operator, you've made your code less readable (no matter what you name it).
You yourself said you want IDE like features. You can't have it both ways. One of the main advantages of using a statically typed language is the tooling support an IDE can offer you. Language servers don't offer much compared to what a full IDE can provide, especially in the way of refactoring.
I quite like the way rustfmt formats complex rust signatures. Would be something like this in Kotlin: internal fun &lt;T, A&gt; configuredStub( qproperty: GraphQlProperty, enumClass: KClass&lt;T&gt; ): EnumStub.ConfiguredQuery&lt;T, A&gt; where T : QEnumType, T : Enum&lt;*&gt;, A : ArgBuilder = EnumConfigStubImpl(qproperty, enumClass) However the Kotlin formatter isn't customisable enough for that. The default style looks good enough to me though. An aligned style can look nice too and I think the formatter retains it: internal fun &lt;T, A&gt; configuredStub(qproperty: GraphQlProperty, enumClass: KClass&lt;T&gt;) : EnumStub.ConfiguredQuery&lt;T, A&gt; where T : QEnumType, T : Enum&lt;*&gt;, A : ArgBuilder = EnumConfigStubImpl(qproperty, enumClass)
I also carriage return each bounds declaration, looks quite nice. I think I should start using aligned style, because my main issue is being able to immediately see ***this is a function named "X" -&gt; returns type "Y" -&gt; (then read through the parameters)***. The example I posted is an example of losing track of return types because it blends in with the parameters.
...and electron based editor isn‚Äôt?
kotlin.test provides annotations and asserts, but it doesn't provide a test runner or an overall framework for test execution. Which is why you still need JUnit or something like it.
A framework like [KotlinTest](https://github.com/kotlintest/kotlintest/) provides some more things: * DSL with several styles to write tests * Matcher DSL for readable assertions * Generation of test data (property based testing) * Table-driven tests * Configurable parallel execution of tests * Grouping of tests and selectively running these tests * Interceptors (before/after testcase, spec or suite) * Auto closing ressources
Damn. I'm new to kotlin. Wasn't aware of that library. I was messing around, making vdom looking api for html templating in serverside kotlin.
Except this calls an arbitrary function instead of a method on the receiver.
For that you can just do just `?.apply{}` or `?.run{}` or whatever. But a method chain without using the previous part of the chain is confusing, and you should just use `if`. Whats wrong with the original code: if (someObject != null &amp;&amp; status) { doThis() } ???
Because it's not "idoomatic" Kotlin, I guess, even though I'm totally your opinion in this case, why not just leave it as it is. That's what bothers me most in regards of Kotlin already. The community tends to go in the scala direction. The language was meant to give people a tool to make code better readable. If there are people who say an operator is a "trap" or simply prefer a utility function like I wrote above because it is better readable for them (and many others who have to use other languages maybe), I think it should be fine for them to do so. Same goes for "shorter" code or one-liners.
No matter what you call it, if people agree that it's better readable, then it should be fine for them to do it. The confusion in this example came from the combination of the safe call operator and two std functions. The choice between safe call + non-null-aware function and null-aware function should be the user's choice. Nothing about crippling anything. Justa bout to be open for people's opinions.
Personally I prefer things like spek http://spekframework.org YMMV
I can only see two PRs that are currently open. Since I only tested Kotlin in Eclipse for a few minutes with a Java+Kotlin mixed project, I'm curious about what the problems with Eclipse and Kotlin are? I didn't have any. Just curious :)
Yea, wrap all the things in runtime constructs!!
Android nowadays has partial support for Java 8, what you can use depends on which versions you want to target. In any case even with Kotlin you should refresh your Java. It won't go away from Android anytime soon. It is like targeting UNIX or the browser, regardless of the opinion about C and JavaScript, that is what the platform APIs make use of.
You're right, it's the developer's choice. The compiler won't stop them. But I'm saying *you* should. If you've learned Java, this is perfectly clear: String result = (x == null) ? "null" : x If you've learned Kotlin, you know this is better: val result = x ?: "null" If someone refuses to learn all of Kotlin, they might introduce `ifNotNull` (because woo! extension functions!) and end up with this: var result: String? = x x.ifNotNull { result = "null" } Does it work? Yes. Is it clearer than either of the two examples above? No, because it forces the next code maintainer to learn what "ifNotNull" is, when better choices are already available. A say "better" because, for example, here `ifNotNull` forced me to use a nullable `var` when I only need a non-null val, and/or to assign twice when I only need one assignment. The abstractions Kotlin picked are good. A lot of thought went into them, much more than went into `isNotNull`.
Anyone else hate some of the inconsistencies in kotlin.test vs vanilla JUnit? let me explain. In JUnit, assertEquals() can have three arguments: message, expected, actual. In kotlin.test, it's the same three arguments, but a different order: expected, actual, message. This wouldn't be a huge deal. However, let's look at assertTrue(). For this, to make it functional (assertTrue {...}), it moves the message to the first argument. So assertTrue has message as the first argument, assertEquals has message as the last argument, and that just bugs the hell out of me. That's it for my rant. Thank you all for listening.
Kotlin 1.1 will have type aliases which should help simplify things as well.
Although your examples are odd because we haven't talked about assignments at all, you guys are right. People should Just use Safe call and (Safe) call it a day. Let's all get more used to the basic operators, wiser choice.
absolutely. each java version update bring game changin features that one must catch on
Android is huge there probably, and programmers there are always on the lookout for the new big technology that is likely to get them jobs?
Well with 1.3 Billion people, India is the 2nd country with the most population on earth so right there, stats are on there side. It workers also speak English. There is as much or more Indian programmers than Americans. https://www.computerworld.com/article/2483690/it-careers/india-to-overtake-u-s--on-number-of-developers-by-2017.html
It just seems like it's not like that in other languages, or not as much anyway
I don't think this article really answers the "What problems do coroutines solve?" question. It says that it simplifies asynchronous programming, but that just begs the question, "What problem does async solve?". Generally speaking, when you have a web server, the naive way to implement it is you listen for requests on a network socket (aka port), when a request arrives, you run code to generate the response to the request, and you send the code, then you start waiting again. This works fine when you have low traffic. But when you have large volumes of requests coming in at the same time, you don't want to finish servicing a request before you can listen to other requests. Instead, you want to respond to the request in a background thread, and have the main thread continue listening for new requests. You can launch a new thread for every request, but then a new problem arises: if you need to do a lot of network i/o before you can decide how to respond to a request, you will have a situation where you have thousands of threads all waiting for I/O. Threads are not really very expensive normally. If you want to launch twenty threads, it's practically free. Most applications don't need that many threads anyway. At most, you probably want as many threads as CPU cores. But if you have to launch ten thousand threads, things get complicated. In particular, each thread is initialized with 1MB of ram, so if you have thousands of them, you're running out of memory very quickly. In addition to that, threads are pre-emptively scheduled by the operating system. Apparently it doesn't perform very well if it has to schedule tens of thousands of them. So the solution to this is "fibers" which have lower memory requirements and not managed by the kernel. Some times they are called "green threads" or "coroutines". Although I would argue that if you have to spend a lot of time waiting for network I/O before you can service any request at all, you're not doing things properly. Sadly, this is the default mode of programming these days. No one wants to cache any data in the server process. Everything has to come from the database, which means every page has to make several network requests before it can do anything. If you have more than 10k requests coming in every second, you don't want to spawn 10k threads to respond to them because of the memory and scheduling overhead mentioned above.
I studied with lots of guys from India here in Germany (all very lovely people btw) and from what I found so far it's because first of reputation and second because they are much more used to online learning
1.2 is already out. Am I missing anything?
Gradle is still the most popular build system and probably the one I'd go with. It now supports writing the build file in Kotlin, which is good because Groovy jumped the shark years ago. Other than that, Kotlin has its own take on Lambdas, streams (called "sequences"), and various other features that were new in Java 8 - so I'm not sure you'd gain much advantage by learning the Java 8 features and *then* learning Kotlin. Best just to jump straight to Kotlin.
We're working on it, but unfortunately, I can't give you any estimate on how long it will take.
Understood, keep up the good work ;)
I moved to writing my own infix functions wrapping those. Much more readable and domain specific
&gt;It is like targeting UNIX or the browser, regardless of the opinion about C and JavaScript, that is what the platform APIs make use of. Good point.
Kotlin (and other similar languages) helps in that you can write just val coolNames = mutableListOf&lt;String&gt;() and it's not necessarily less characters to type than that Java example, but it tells so much more. And, of course, it's the developer who has to come up with the val name. No language can help with that.
The C/C++ names are partly of the UNIX legacy, too. Newer langs name stdlib functions better. Also, remember the olden days of Hungarian notation where the names indicated the types.
Not a kotlin feature, just a fluff library. Cool. But not specifically a kotlin feature.
Thank you Simon! I look forward to reading this. I am quite excited about using the Kotlin Gradle DSL, but so far I have not found so much guides about using it instead of Gradle. 
It's a first-party compiler plugin augmenting the bytecode generation. While it maybe not strictly be a feature of the language, it's far closer to one than a "fluff library". Would you say the same about kotlinx.serialization? What about the allopen plugin? They're effectively the same thing.
...or the jre libs provided directly from Jetbrains. I feel like that "fluff" comment is a result of not skimming the article, or not understanding what it is used for.
Those libraries can apply to any kotlin project; this library in particular is for Android only. Clickbaity titles get my goat. It's not that it isn't a novel approach to something that historically has been tedious, but the title of the post sets reader's up for a fail.
Lib author here for abuse or questions.. :)
Nice write up! I'm excited for the Gradle Kotlin DSL but can't currently justify switching our team to it due to the lack of official documentation. This isn't official, but it's great to see people writing about it. I love your examples, too. They're very clean. 
It doesn't look like either the regular or WS version of the core HTTP service function are coroutine-based. Any plans for this in the future? What I'd like to see is: typealias HttpHandler = suspend (Request) -&gt; Response 
You might be interested in my project, [Pronghorn](https://github.com/pronghorn-tech/server). It supports that api. It‚Äôs still under documented, which I‚Äôm working on, but is all coroutine based. I‚Äôll be posting some blog posts about it in this subreddit in the next few weeks.
Thanks, I'll have a look. I've also looked at Ktor, which while at least async, it's only coroutine-based under the hood and not in the handler function, which gives you a callback to invoke.
I'm a professional Java developer who does Kotlin in my spare time. In my opinion, just dive into Kotlin. Here's why: - Java 9 doesn't have too much for you to worry about. The modular classpath is the only big thing, and it's not that essential for development unless you're dealing with a truly massive codebase IMO. - Java 7 &amp; 8 don't factor too much into Kotlin. Many of the Java 7 language features have either been re-implemented in Kotlin (try-with-resources -&gt; use {...}) or don't exist (multi-catch blocks). And Java 8, the big addition was functional programming, which Kotlin re-implements in a (IMO) better way. So just dive right in and enjoy. As long as you feel you had a decent level of competency in Java at the Java 6 level, you should be fine. There will probably be some things like the expanded NIO API that you might be missing, but those are small fries.
Possibly/probably. We'll see how it all develops when the coroutines exit experimental status. The absolute most important thing to us is that everything remains simple and easily testable. :)
[Check this out](https://developer.android.com/guide/components/intents-common.html), you can use intents for both.
Thank you. That's pretty straightforward. &amp;nbsp; I case someone else has the same question, this seems to be enough: val wa_Intent = Intent(Intent.ACTION_SEND) wa_Intent.setType("text/plain") wa_Intent.setPackage("com.whatsapp") wa_Intent.putExtra(Intent.EXTRA_TEXT, "The text") startActivity(Intent.createChooser(wa_Intent, "WhatsApp")
You could use a library like opencsv, Apache Commons CSV, JavaCSV etc. You could *also* transform the CSV to a two-dimensional (constant?) array. You could *also* convert your CSV to another format like JSON and read it like an object, depending on the contents of the file.
Spek is a single BDD style approach while KotlinTest is a multiple testing style framework. It looks like KotlinTest is a better choice, but you will need to do more to cultivate a standard team style than you would with Spek.
If you're planning to build that data into your app, generate Kotlin code which builds that array as a normal Kotlin data structure.
Not to take all the fun out of it, but I would make a tab-separated file, then run something like this: val table = File("strings.txt").reader().use { it.readLines().map { it.split("\t") } } // Validate the input, then access directly: System.out.println(table[5][20]) 
[Annotation processing](https://kotlinlang.org/docs/reference/kapt.html)
Can you share your point about Algebraic Data Types? Can this feature be useful in kotlin? May be your team already have some plans to introduce ADT in future releases?
With Java adding more features that Kotlin has (e.g. auto type inference), is there a concern that Java will sideline Kotlin going into the future? In other words, are you concerned that Java would eventually render Kotlin irrelevant if it continues down the same path? 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [Kotlin Team is doing AMA right now on r\/Kotlin](https://www.reddit.com/r/programming/comments/7hozqj/kotlin_team_is_doing_ama_right_now_on_rkotlin/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
When can we write Kotlin JVM code that calls Kotlin native code without JNI? Pretty please?
Given that now WebAssembly is available on all major browsers: 1. Will there be a toolchain to compile from Kotlin to Assembly? 1.1. If yes, when? 1.2. If yes, do you intend to deprecate JavaScript compilation?
I'd love to see union and intersection types like Ceylon has. What are your thoughts about adding them to Kotlin?
Hi all, as a relatively new adopter of Kotlin for Android development it has been really exciting to see the language creep its way into my maintained apps and improve them significantly. However, my question is as a new Kotlin user, what are some common mistakes that might impact performance without being immediately obvious to the programmer? And do you have any cool tricks/tips to share?
Is it possible to use angular 4+ instead of react in kotlin multiplatform project? If so can you point to some example projects or snippets? Will you provide similar wrapper for angular as you do for react?
Kotlin already has ADTs (see `sealed class`)
Any plans on bringing Kotlin/Native to IntelliJ IDEA (and/or Android Studio)?
Prototyping in Python with Jupyter is neat. Which will come sooner: Jupyter type functionality in Android Studio, or Kotlin functionality in Jupyter? P.s. I know there exist some early attempts at the latter on GitHub, but am interested in the Kotlin team's take
What is the one best thing about Kotlin that is different then any other programming languages? 
Plans for a Kotlin Conf in Europe?
How best Kotlin can support Selenium Webdriver?
First question: What's the long-term plan for Kotlin multiplatform support, especially regarding iOS? Will it eventually be able to compete with Xamarin and its toolchain, including remote debugging support etc? Second question: Seems like JetBrains is investing a lot into Kotlin development. Do you have a long-term plan for development funding and/or monetization? 
Electron has gained huge popularity despite the performance issues (cough Slack). With Kotlin Native, when we can we get started building native desktop apps and how does the team plan to make it an attractive option for developers. Thanks for all the great work!
Why do you think I should switch from Java to Kotlin?
https://kotlinlang.org/docs/reference/comparison-to-java.html
How do you think the popularity of Flutter with Dart will influence the adoption of Kotlin as the de-facto way on developing Android apps? Do you think there's a future of Flutter with Kotlin?
There are lots of MVP/MVVM implementation references for Android that utilises rxJava or other asynchronous patterns. It is hard to find similar using coroutines. I think it would be a great boost for coroutines to showcase it in a live application/architecture. Do you have plans in this direction?
Do you think Kotlin will be a supported language in the new fuchsia os?
Kotlin object for anonymous class is really bad. I never get the right one in suggestion. Any plan for a better support? Or should I avoid using them by using inner class? 
Taking into account the direction Kotlin is going for now (cross platform support), aren't you guys concerned that language might become too complex and bloated over the time? For instance, trying to conquer low-level domain where other languages like Rust (which has been designed to operate on that level) already exist. My point is that Kotlin is a great language for JVM, but might not be the best tool for the job within other domains. Do you see JVM as a main platform in the future or you want Kotlin to become first language to "rule the all"?
Do you think Kotlin can replace React Native in the future to write cross platform apps for Android and iOS?
Do it for the `when` keyword 
In the context of pushing Kotlin for DataScience, could there be compatibility layers for Python and R libraries from JetBrains? I know about community experiments on that front with JPython and Renjin. What's your take? Can we expect a complex solution like with C libraries, with docs and IDE support and everything?
I work on a React Native app. I was thinking if it would be possible to write JavaScript code that uses RxJS and that can be converted to Kotlin so I can run purely on the native side (e.g. for background tasks). Not sure if that is possible.
What new features we can expect in the future releases of Kotlin?
&gt; Can this feature be useful in kotlin It would be useful if _any_ language. They are incredibly powerful constructs. Typed checked code paths are extremely valuable.
But it's no comparison to e.g. Ceylon in that regard.
Are you planning to support collection literals outside of annotation? class MyView:ViewGroup{ fun someFun(){ val childView = this[0] val childView = [0] //Not supported } }
What features can we expect to be targeted for 1.3 release ? I mean any of those which were voted for at 1.1 event. Also is there going to be same vote prior to 1.2 release ? 
Wish list : * kotlin ? "yeah" : "booo" * Kotlin iOS as simple as Android
WHAT THE FUCK IS KOTLIN
Is it possible to have ARC without cycle collection introducing strong and weak references?
Are there plans to support ConstraintLayout in Anko?
Which domain would you like Kotlin to become popular in? I mean, it's already pretty successful for mobile and backend apps - I wonder if there are other areas where you'd like Kotlin to be competitive. I'm personally rooting for Kotlin in data science. Are you willing to support popular open source Kotlin projects financially or with commits from the official team?
I think Kotlin Native [already supports](https://blog.jetbrains.com/kotlin/2017/11/kotlinnative-v0-4-released-objective-c-interop-webassembly-and-more/) WebAssembly (experimentally).
Why did you opt to use `{ x -&gt; x*x }` syntax for lambdas instead of `x -&gt; { return x*x }` as in other languages like java or javascript? For me calling a function to set a listener like this: view.setOnClickListener(v -&gt; { //do something }) or like this: view.setOnClickListener(v -&gt; //do something) is more intuitive than this: view.setOnClickListener { v -&gt; //do something } I have to disclaim that I'm just a beginner in Kotlin but I've been coding in Java for a few years already and that approach seems weird to me.
Automatic formatting in IDEA and Android studio for kotlin lacks a lot of functionality. Do you have it on roadmap to be able to autoformat code according to Jetbrains or Google kotlin style guidelines?
Do you have any plans for more "syntactic sugar" features in the language? Like the bracketless if's and fors in Swift, or global infix functions or other similar features?
There's plenty of free resources that teach Kotlin to experienced developers, but it's hard to find resources that teach Kotlin to beginners. Do you have a plan to prepare that kind of content? A collaboration with Udacity/Google would be awesome.
I mean you do have an elvis operator for assigning the value. E.g. `val value = nullable ?: otherIfNullableIsNull` If you need ternary operator you can just use an if which is extremely compact in Kotlin E.g. `val value = if thisIsTrue trueValue else falseValue`
If you use anonymous classes a lot, adding a custom Kotlin-esque wrapper/DSL seems like a good idea.
[removed]
The future of kapt? (Or the plans of meta programming) Will the compiler plugin have public APIs?
[removed]
Did you try adding an issue on GitHub?
Have you decided on collection literals? Are there any specific proposals to discuss? 
I'm a Clojure dev flirting with Android/Kotlin. I don't mind types or the different syntax but one huge problem (with any non-lisp language) I have is: I love the REPL. I use Cursive Intellij Plugin and I can super quickly get feedback about code. It allows me to develop a simple data transforming function in a fraction of what I'd need in other languages. Two questions: - Will a good REPL find it's way into IntellJ Kotlin? I mean with support of sending/evaluating forms in a running JVM. - Could Kotlin/IntelliJ support something like Figwheel (Demo: https://www.youtube.com/watch?v=KZjFVdU8VLI )? It's an amazing tool. If I had something like this for Android development it's make me 5x more productive.
What if Google takes Kotlin as a *weapon* against Oracle ? Is any way for Oracle to ban kotlin code running on JVM ? Any plan to support PWA ? 
Are there any plans to have an officially maintained Kotlin version of the BaseLanguage in MPS to allow for rapid prototyping of new Kotlin language features by the community?
Please this!
Do you guys also believe that everything will eventually be Javascript? https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript Also, what were the main challenges of making Kotlin compile to Javascript?
Any plans to support structs and other concepts from C, at least for the native compilation target?
[removed]
The process of [creating libraries for kotlin](https://kotlinlang.org/docs/tutorials/create-library-js.html) is rather frustrating, and its often not clear how to install 3rd party libraries. Even then, if can be hard to know what flavor of kotlin (eg. native) a library runs in. Are there any plans / what can we see in the future on this? 
There already is one: https://github.com/Kotlin/anko/issues/210
The {x -&gt; x*x} syntax is only syntactical sugar for passing a function into a method whose final parameter is a function. You could actually use the view.setOnClickListener({v -&gt; //do something}) syntax instead.
&gt; First question: What's the long-term plan for Kotlin multiplatform support, especially regarding iOS? Will it eventually be able to compete with Xamarin and its toolchain, including remote debugging support etc? In short - yes. There‚Äôs important nuance though in how we see it differently from Xamarin - regardless of completeness of unifying API surface one should always be able to directly call platform APIs (iOS, Android) directly. This will allow to build ‚Äòmostly‚Äô cross-platform apps that benefit from unique platform traits.
What I meant is why `{ x -&gt; x*x }` and not `x -&gt; { x*x }`. Why does the whole thing must be in curly braces?