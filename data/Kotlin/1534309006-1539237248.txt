What does native support mean in practice? If Kotlin is 100 % interop with Java, it means Spring should automatically work with Kotlin.
Tldr, a type is worth a thousand tests
T.() operates as if you are a T - it's an extension function, and it has access to other things in the T as if they are instance fields / methods. () operates as if you are just a wild function with no object attached.
&gt;T.() operates as if you are a T - it's an extension function Thanks for clarifying what that meant. I couldn't figure out what the author meant by that statement. üòÄ
Look at `ktor`. It‚Äôs a Web Framework that IntelliJ is working on. I have built a couple of apps with it now and I quite like it. 
You can use it without Kotlin support and it works 100%, but Kotlin has some nice upgrades over Java, as others have stated below, so that's about it.
I'm working on a new release for my Tile engine / Text GUI called [Zircon](https://github.com/Hexworks/zircon). I'm doing the final polish parts, and also a tutorial game project which uses the library (dogfood).
Does this increase every year? IIRC last year a type was only worth a hundred tests? Are we in an era of test inflation?
Spring manipulates the Java byte at run time, using special class loaders. So not all Java constructs can be used with Spring. Scala for example emits byte code that doesn't work any more when Spring patches it at run time. Same was true for Kotlin in the past. See [Kotlin #5537](https://github.com/spring-projects/spring-boot/issues/5537) for more details, but the main point was that Kotlin made many classes final at default, so CGlib could not generate proxy classes for Spring AOP. Additionally Spring changed some of its APIs so they work with idiomatic Kotlin code (nullable, pandas, type erasure, ...)
Nice finding :)
Mostly talking about immutable
Same here! It's why it took me a bit to figure out the cause of the issue. 
Unfortunately he's wrong about what this is. It's called a function literal with receiver: http://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver
I just wish the documentation was better. It has improved over time, but it still needs to be fleshed out more. 
It's definitely significantly better than it used to be, but you still have to go delving through the example projects every now and again.
Okay, I understand. Thanks for the detailed answer!
That's an okay way to explain it's behavior, and he clearly knows how to use it and what it does, but he literally calls it an extension function in his post (wrong) and links to the documentation for extension functions (wrong).
The provided example is not truly exceptional (throwing an exception that oil is needed when attempting to aim). I try to limit exceptions to scenarios that arise from incorrect programming rather than control flow.
1. Kotlin is still very new and doesn't have much specific documentation. 2. There are not many. You can use the Java ones, and there are a few Kotlin specific ones like Arrow. But there isn't much Kotlin GUI stuff for example, except TornadoFX (which is still relatively unstable and I wouldn't recommend it) 3. JS is not a static typed language and thus more difficult to debug and easier to write bad code. Many people will prefer more "safe" languages like Kotlin over JS. An additional advantage is writing logic in Kotlin and then using it both inside the backend of a webserver and at the client (in a browser).
1. I recommend having an actual goal, an actual app to create. This will drive your googling and you'll be learning fast and focused. 2. There's no central place for Kotlin-oriented libs. The best-quality and richest libs are still in the Java world, though, and they are usually quite nice to use from Kotlin. There are often 3rd-party libs that add more Kotlin convenience over the core Java functionality. 3. Your premise is wrong. JavaScript looks less complex because it's dynamically-typed language. A lot of actual complexity is just hidden from view, but it hits you in production as soon as your codebase grows. With rising code complexity, especially with a richer domain data model, you start losing track over which types of objects are passed where. Kotlin and other statically-typed languages allow the complexity to rise much further until you start getting lost.
&gt; write, without consulting any resources, a thread-safe singleton lazy init idiom enum ThreadSafeSingleton { instance; };
Exceptions are great for a lot more than catching programming errors. Network connections fail, user's data can be invalid, domain entities get changed during your optimistic transaction, etc. If you model all these without exceptions, you're missing out on a lot. 
Agree! Network connection fail: yes, exceptional. Invalid User Data: Depends. If reading from a source (eg: DB) where I hope only valid data was expected to be written, then yes, exceptional. If the user is directly providing the input, maybe not, IMO. Domain Entities changing during transaction: yeah, exceptional. But not very sure what this is - I‚Äôve always thought Domain Entities must never change once initialised. But I digress. I had a recent case when I had a discussion at work to see if a credit card payment failure was an ‚Äúexception‚Äù. My stance was that it wasn‚Äôt. The TL thought it was. We went with the exception flow, but I‚Äôm still not very convinced. I‚Äôd love to hear your opinion. 
Oops, my Kotlin is rusty!
Well, I have an actual goal but the problem is I don't know how to start, at all. As soon as Android Studio generates the activity for me, I'm totally lost. Even looking at the reference I don't know which API features do I need. So a decent series of tutorials or something would be nice.
A Kotlin book should help: https://www.amazon.com/s?k=kotlin&amp;ref=is_s Kotlin programming by example: https://www.amazon.com/Kotlin-Programming-Example-real-world-applications/dp/1788474546?keywords=kotlin&amp;qid=1534373452&amp;sr=8-13&amp;ref=mp_s_a_1_13
"Exceptional" might be subjective. I have once heard an opinion that if an action described by function/method name did not happen, then it was exceptional. So if you had a .payWithCard method, and after calling, due to some failure, "paying with card" did not take place, then it was exceptional. But then how could we name that method to express it may not pay at all? "tryPayWithCard", or maybe "payWithCardOrFail"?
Spring boot is good enough for Kotlin.
Yes, exceptions are also great for scenarios which are out of your control like IO issues. I was mostly trying to emphasize that the use of exceptions shouldn't be designed in such a way as to expect to encounter them as part of a regular / normal workflow (like the scenario of notifying the user of the game to add oil when attempting to aim)
http://javalin.io/ or https://jooby.org
For Android development, possibly. I can see, at least, a hybrid approach. But, the Java ecosystem is enormous. So as a whole, no. 
Hmm just curious but why is Kotlin gaining popularity so fast for Android Studio users? What are the pros vs cons of Kotlin compared to Java? From what little I've dabbled in Kotlin, Java is still the more refined language and has support for most, if not all, features. 
I think you may be going about your learning wrong. You should learn Android development not Kotlin Android development. The language doesn't really matter. Knowing about activities and fragments and their lifecycles is the difficult part I'd recommend http://developer.android.com and https://codelabs.developers.google.com, both are great resources and I know have good introduction tutroials.
Yes.
I think it's mostly about conventions. If you really want to be explicit, you can usually use `return@context` - for example, `listOf(1, 2, 3).filter { it &gt; 1 }`.
A simple case where I'd want to do this would be if I had a conditional and the lambda should return different values from each conditional branch. Particularly if each branch does many things before returning. Is the idiomatic approach to just declare the return value as the final line in each conditional body? 
return@lambdaName list.map { if (flag) return@map true false } contrived example
I would say yes if no alternative than Kotlin, and yes only for Android Native Developers. but not entire Android, I don't think so google replace all java code to Kotlin, but sure new SDK. and I see google new samples in Kotlin, so I think they will mandate kotlin for developer, but will not remove Java soon form their AS Wizard. &gt;And according to Kotlin library update, I felt, they are restricting on lots of things, so user won't write badcode. I used Kotlin 1.2.31 in one project, but when I updated to 1.2.60. they have removed lots of unnecessary null check and added where its needed. For eg. `onCreateViewHolder/onBindViewHolder`. in 1.2.31 it has null(?) check, when you are taking holder and parent in `onCreateViewHolder(holder:ViewHolder?,parent:ViewGroup.....` but in 1.2.60, they removed null check, so it must have some values. because it cannot be null. 
My style is to omit any `return` keyword when there's only a single expression within the block (e.g. `{ true }` or `{ if (condition) true else false }`) but include it if there's multiple expressions, or it's otherwise more ambiguous.
The last expression evaluated is what will be returned. It can be weird but that‚Äôs how it is ü§∑üèº‚Äç‚ôÇÔ∏è 
It's easier to work with to be honest. I work for a fortune whatever company and we have a shit ton of code. Mutability has introduced so many issues, we moved to autovalue. This increased our build times and the complexity. Kotlin makes our life so much easier. We reduce the amount of code and while a lot of it is syntax sugar, it's more readable and maintainable. The only benefits Java provides us over kotlin are performance and approachability. Kotlin however lets us reduce our lines of code, readability, handles nulls, extensions, sealed classes, and it's far more expressive.
On what point?
I code my PC software in Kotlin.
no
No. Way to many stupid people who won't even consider using it or learning why they should.
Kotlin is more accessible than Java, which is a very very very verbose language. Kotlin also handle NPEs, which is a must. Since it's officially supported by google, people are moving to it, because it reduces the code size, and make the code more readable. Nobody enjoys coding in Java, if there's a better option that has the same features and more, and can make use of its gigantic library or libraries, then people are gonna move to it. Java is just used in corporate software suites and Android nowadays. Python does prototyping and small scale uis better, and C# is more performant, Java is losing popularity fast. Also, it's the same as Swift vs Obj C on iOS.
finally, a well thought response instead of random downvotes for asking a question lmao thanks for that
Not at all, that is like asking if language X will replace C on UNIX based OSes.
If you want to reach the wider set of Android devices you are stuck with Java 6. There is partial support for Java 7 and 8, but that reduces the amount of Android versions you are able to target, give than the whole lack of updates story and not all new language features can be backported into older ART/Dalvik versions. Then there is the radio silence if Android will ever support anything newer than Java 8, meanwhile Java 11 is already around the corner. So the only way to move forward on Android is to adopt Kotlin.
&gt; Nobody enjoys coding in Java, if there's a better option that has the same features and more, and can make use of its gigantic library or libraries, then people are gonna move to it. I enjoy coding in Java and actually what I would enjoy even more would be to pick any random Java SE library and be able to use on Android, specially post-Java 8 ones. Given that Java is frozen on Android, and if I want to use all Java 8 features I cannot target all devices, Kotlin it is.
Don't try to give some philosophical reasoning whether an outcome merits the word "exceptional" or not. Exceptions are a pragmatical mechanism that allows you to achieve centralized handling of a condition that you may detect in any of the methods on the call path. If you even find yourself writing boolean foo() { if (!bar()) { return false; } } and then again, in the caller, if (!foo()) { return false; } or any variation on this pattern, you should realize you need exceptions for this logic. I gave a few examples where this regularly happens: a series of request/response cycles over a connection that may fail at any point; complex validation logic factored into many simple methods; a long chain of actions in an optimistic transaction that can at any point detect a concurrent change and should roll back; 
Fair enough. I was leaning more towards a CreditCardPaymentResult back then Maybe Golang ruined me with that error handling. 
It's not about whether the flow is normal or not. We use exceptions for a condition that we must check over and over again and, wherever we detect it, we must abort what we're doing and report it. If you look over my three examples in this light, you'll see they're all instances of such logic.
Thanks! This was informative. TIL. 
I don't see a reason not too... We adopted Kotlin as the primary back-end language used (after having used Java up until that point) - any new code written was in Kotlin - developer productivity, ease of use, and code readability were far better than in Java, whilst we enjoyed the JVM and the many OSS packages/frameworks the Java eco-system has to offer.
For your PC software development, possibly. But, the Java ecosystem is enormous. So as a whole, no.
On android, absolutely. Already devs like myself will choose work based on betting able to use Kotlin. As for server side, I think it will become an important segment, maybe even rivalling java in a few years.
Yes, I'll get right to converting our 150k+ codebase to kotlin. Sounds like a smart idea that couldn't possibly backfire. 
&gt; I don't see a reason not too... Momentum. There are far too many Java devs, and companies who couldn't care less about Kotlin being objectively better. Java desvs with years of experience are basically a dime a dozen now days. In corporate software development, you'll find that most people haven't even heard of Kotlin, and they have zero interest in moving to something that they don't know. Something that would require training whole teams in a new language. As mentioned above, I can see Kotlin replacing Java for Android, simply because it's still new, and it's what Google wants to focus on. For corporate, where you will find the majority of Java code, and where Java completely *dominates*, it's extremely unlikely Kotlin would even get a significant market share. That said, I would still recommend learning Kotlin, if for no other reason than working in corporate being absolutely soul killing and your love for programming.
Also when you will have basic Kotlin and Java knowledge you could learn from Java tutorials and implement it in Kotlin way.
Here are the slides: [https://sydkotlin.space/materials/2017-10-11-2/one-type-thousand-tests.pdf](https://sydkotlin.space/materials/2017-10-11-2/one-type-thousand-tests.pdf)
Students during last few years were already confused with the thought whether to shape their career as an Android or iPhone developer. Ever since the Google I/O keynote, developers have been wondering whether they should stick to Java or start focusing on Kotlin. So find the details about Sticking With Java Or Shift To Kotlin: What Should Android Developers Do in our current blog post. 
Lambdas simply evaluate to the value of the last expression without having to use the return keyword. Note that unlike Java, most things are expressions in Kotlin such as if/else, try/catch, when, etc. There's a deeper reason for this decision. In Java, the return keyword has 2 meanings depending on context. The first meaning is that it returns from the innermost method / function which could be a regular method or an inner method when declaring an annonimous inner class. The second meaning is to return from the innermost lambda. The distinction is important to note because braces are used for both lambdas as well as regular constructs like for-loops. However, the return keyword has a single meaning in Kotlin to always return from the innermost function. This could also be an annonimous function or a function defined in an object block (ie. annonimous inner class). This quality is especially important to preserve because of the last argument lambda calling convention where you can specify the lambda outside of the parentheses. This almost seems like you're creating new language constructs (eg. your custom inline loop function) and use the return keyword as you would in a regular language construct without having to think about context (because they look similar) so this is extremely valuable. In order to guarantee the single meaning, the return keyword is only allowed in inlined lambdas. Lastly, you can also use a labeled return.
You can also supply your own labels! ``` listOf(1, 2, 3).map myLabel@ { return@myLabel it + 1 } ```
As a library/backend developer , after migration to Kotlin since end of 2017 , I never looked back to Java anymore. IF , I mean IF , Spring or Hibernate start replacing their core code to Kotlin (and sure , provide Java interoperability ) , that will be the bombshell. That's will be the moment Oracle getting nervous.
Will individual shops switch from Java to Kotlin? Sure! (Though there are at least 2 cases I've run into where I had to write Java shim code.) But no, Kotlin won't replace Java completely nor will it replace JavaScript completely. After all, C++ didn't replace C. One challenge that Kotlin may have is that Oracle seems increasingly willing to make improvements to the Java language and to the JVM. For example, it will be interesting to see how Kotlin handles value types when they get added to Java. 
Kotlin is interop with Java and gets all of the same ecosystem advantages, so I'm not sure how this is an argument.
FWIW, Java never really caught up to Scala. But Scala was alien enough that it never *quite* established a foothold, and now Kotlin has come along and scooped up all the people who wanted a better Java but didn't want to deal with Scala's oddness.
Yes that is true. I think Java "cought up" a bit with the introduction of lambda functions and the stream api, which was good enough for many to forget the hassle of embracing Scala. Kotlin is somehow closer to Java and indeed might be more successful in convincing Java developer to switch (I'm one of them) but could be that Java introduces few features (the var keyword for example) which will convince some developers to stay.
Java takes a couple of weeks to get comfortable with the syntax and language idioms. Learning the tools and becoming proficient with them takes years. The perceived cost is loss of productivity and therefore revenue for a company. :( It's sad, but that's life. 
With regards to JVM Kotlin (I'm not an android dev): I wish I could say yes for frontend applications. Unfortunately, TornadoFX is a polished turd at best, so Kotlin lacks a good native UI library. However, for things that don't need a UI, Kotlin can be used interchangeably with Java for pretty much everything. I slapped together a quick-and-dirty CD platform in under 150 lines with Kotlin. It's extremely powerful.
Said this in a separate comment, but TornadoFX looks pretty from the outside but is a rotting pile of garbage once you start actually using it. Until Kotlin has a native UI library (one with documentation, and that doesn't spit out reflection failures incessantly), it can't completely replace Java on the desktop/server frontend.
Is it "more accessible" though? I think there's more to learn and there's more rope to hang yourself with. 
But see, that's exactly what I'm saying. Kotlin is not a whole different language, it's just a better Java. None of those skills are lost when you move over.
I recommend http://sparkjava.com Don‚Äôt let the name mislead you, started out as a light weight Sinatra like DSL for java, after which they forked for Kotlin as-well.
It has for me I dont write java anymore its too verbose
excellent article and exactly what I just needed!
There is so much inertia at my work I can't ever see the change happening. Moving build scripts from Apache Ant to gradle faced serious opposition, i can only shudder at the thought of the resistance changing language would generate 
I am currently trying to move the company I work for to Kotlin and I know exactly what you mean. It is scary. And I don't know whether or not I will succeed. But I am trying very hard and after some time of rejection, my persistence seems to finally pay off. things are moving. Very slowly, but moving nonetheless. I feel quite hopeful right now :)
That's an interesting insight, i actually saw this effect on TIOBE, which showed a rebound effect on Swift's share.
It's fascinating to see people adopting the new like Kotlin, yet sticking with the ancient like Hibernate.
What do you advise to use?
While it's not written in Kotlin, Kotlin is a first call citizen in Spring Boot.
Learn SQL. It's not a tool developers have any excuse to be ignorant of. Then use JDBI, Jooq, or whatever libraries work for you.
I'm 100% with you. Explaining that fact to non-technical management is a whole different game. :)
[Exposed](https://github.com/JetBrains/Exposed) provides a type-safe SQL DSL as well as Entity-like classes.
Second this. JDBI is great.
Well you didn't say where the error happens and I'm not going to analyze your code, but you can always use a connection pool type of deal. Keep a count of how many active calls you have going on and wait if that number is too high.
&gt; It has no plans to ever move beyond version 7, which means Java programmers don't even get to use lambdas. This is just plain wrong. Lambdas, method references and a few other features are backported to any API level and there are other feature available from API 24. Official source: [https://developer.android.com/studio/write/java8-support](https://developer.android.com/studio/write/java8-support)
TornadoFX is defintely not unstable. Its is an amazing framework around javafx. I have used it for a relatively large project and have zero complaints.
fuck I hate hibernate and ORM's. Using it in kotlin has so many issues. It defeats the purpose of using kotlin if you cant define entities with data classes so may as well use java which matches the ugliness of hibernate so the 2 pair well. 
Maybe it's just me, but I didn't see any explanation about why you wouldn't use data classes with JPA, only a statement that a data class would provide a different hash result after being saved thus getting a new id, which seems like what you would want/expect to happen. Am I missing something? I've used data classes with Spring Boot JPA for a long time now and not run into any issues once using the jpa plugin.
thank you
Creating a new thread for 500+ calls is not a good idea. You can use a [thread pool](https://docs.oracle.com/javase/tutorial/essential/concurrency/pools.html) to limit how much is going on concurrently. Is there any way you can reduce the number of calls you are making? That seems like a lot. Don't know how much control you have over the api.
You don't need to convert a Java codebase to Kotlin to start using Kotlin in that project 
Is barely documented and is using reflection and private api internally a lot and it breaks a lot when you update the jvm for example because of that. Also it's interfaces are not stable and often change between versions. It also has lots of bugs. If you call that stable you have really low expectations. Not that it's a bad project, it's a fine open source hobby project or something like that, but it's not comparable to the jvm or say Google Guava, which are supported by large companies, have stable versioning and very little bugs in practice. 
I don't think you got the main point: it may support the _syntax_ of lambdas, but it doesn't implement the fundamental _mechanism_ of the `LambdaMetaFactory` which uses `invokedynamic` and is key to reducing the explosion of classes implementing the lambdas. This is far more than "desugaring", it involves changes to the bytecode format. And anyway, as the page you link to explains, it's just a few features and no plans to ever get to being compatible with Java(TM) 8.
[Jooq can generate pojos](https://www.jooq.org/doc/latest/manual/code-generation/codegen-pojos/).
Using 2 languages with 2 different philosophies in one project is as far away from good practices as you can get. 
That's interesting, thanks!
Kotlin isn't just "somehow" closer to Java, you could almost say it _is_ Java, the language Java was supposed to involve into had it not been for the catastrophically poor stewardship and glacial pace of evolution. Oracle is now feeling the heat, they have completely remodeled their release cycle and seem to be pumping out features at a pace not seen since the days of Java 1.2. Many feel that Scala is a history lesson that only the na√Øve refuse to apply to Kotlin, but the difference is truly fundamental. Not only is Scala a total departure from Java's paradigm, a completely new and never-validated-in-practice hybrid of Haskell and OOP, its tooling has never, even after 15 years being public, reached the level of Java. Scala has nominal interop with Java, but it only goes one way. Scala constructs are either a huge pain or impossible to use from Java.
1. ..I will skip this as I am using Kotlin mainly on the backend 2. You don't usually download packages, you reference them in your build file and they will be downloaded automatically. As for how to discover them, I recommend the [Awesome Kotlin](https://github.com/KotlinBy/awesome-kotlin) repository which keeps a list of notable libraries. Still, when you have a specific need I'd still recommend fishing around for a Java library, too: the selection is much bigger and while people are quick to start porting libraries when a new language appears, many of them could turn out to be still incomplete or even abandoned as people move on. Java libraries are for the most part totally painless to use in Kotlin so ask around before settling on a library just because it's 'made for Kotlin', people will generally be more than happy to share their experience. 3. Javascript, oh Javascript. How we love you, how we hate you.. First of all I strongly disagree that Kotlin is less readable than Javascript! Fine, the latest versions of JS/ECMAScript have come a long way to reduce some of the verbosity and craziness but there's still a zillion competing libraries to do things most languages have in their standard library, the callback hell is still annoying without Kotlin's coroutines (or similar) and knowing the variable types when reading a piece of code is just common sense (otherwise TypeScript wouldn't be a thing, right?) - I could probably go on. But there's also code reuse: in a web application we put data transfer classes and validation functions into a common lib that's used both on the server and in the browser - you'd do something like that if you used Node.JS for example, only here we can keep Javascript the hell away from the server (the main browser code can still be in native JS if we wanted). And for URI paths, we have a Kotlin `object` that then contains other objects for a nice hierarchical tree of URI paths which are then also compiled into Javascript and we can share them in plain code on both sides, which is pretty nice. And in the end you could also produce WASM code from your Kotlin, whereby some performance may be gained. Note that in general I agree with you - I wouldn't write a huge code base in Kotlin _just_ to compile it into Javascript. Reusing code or writing smallish works in a programming language I know and like much better however are perfectly reasonable scenarios for me.
I've tried to use it in a personal project a while ago, but the documentation only covered simple cases. Has it improved by now?
HashSet, HashMap, and any other collection that hashes its objects expects that hash code to remain constant through the object's lifetime. There's an example in the link that shows what happens when that's not true: // MyEntity is a data class set up as an entity val set: Set&lt;MyEntity&gt; = HashSet() val ent: MyEntity = TODO("However you create your entity") set.add(ent) println(ent in set) // true ent.persist() // sets its ID, changing its hash code println(ent in set) // false (!!!) When you change the hash code, you change which bucket the set looks in to see if it has your object, which means it won't find your object at all. This is also true if you use your object as a key for a HashMap.
WHOA THANX!
Thank you! You're right, I was creating way too many threads. I cleaned it up and now it's running much better! :)
&gt;As a starter, it feels appropriate to provide a generic base class for our entities that defines an auto-generated identifier and, based on that, implements equals and the constant hashCode. Pls no. How hard is it to define an id property in your entities?
If you had read more carefully you would have noticed that the main purpose of this class is not abstracting the ID 
I think you are trying to solve a problem where there isn't one. There is no need for some magical hashCode and equals methods that use only the ID. Your example why you shouldn't use data classes is a bit contrived. Just persist the entity before you put it in the set.
When using raw SQL what is the solution for cross database support? I have always just barely tolerated Hibernate and would prefer not to use it; however, at my current place we support several different databases with our product and Hibernate does encapsulate that problem away (mostly...Oracle can be a little bitch).
Right, but what does that have to do with JPA? Further, if you change an object by adding an ID to it you would *expect* it to have a different hash than an object without an ID or else you could unexpectedly have unsaved objects wiping out saved objects and vice versa, no?
I think beginners need these kind of excercices. Make a barebone app with tests and let the student make the tests pass by coding the barebone app. Is there any place where I can find such excercices for different kind of languages?
You should not be basing equality of your entities based on an auto-generated identifier (surrogate keys). Equality should be based on business equality. https://vladmihalcea.com/hibernate-facts-equals-and-hashcode/ 
Do you mean safe-check, like `stack?.pop()` or the idgaf check like `stack!!.pop()`? Or the Elvis Operator?
Is this question possibly falling into the [XY Problem](https://en.wikipedia.org/wiki/XY_problem) trap, or are you just interested in this type of feature? Because we might have similar solutions using Option's if you want compile time guarantees of existence/non-existence of objects. But if you're just trying to scratch this itch of remembering this, unfortunately I don't recall seeing anything like this, but I'd be interested in how this worked if someone else had an answer!
That sounds like assert messages in dart. I could see those two languages getting mixed up. Do you have any experience with it?
Are you looking for something different to Spring? Spring (Boot) is normally considering a go to solution for these kinds of things - including both the API and consumer. There are definitely plenty of alternatives out there and a few written in Kotlin as well. Depends on what kind of project you are working on and if you want to completely change. If you already have your API written in Spring, then I don't see much of a reason to change.
I remembered it because I thought it might help me, but now it's just a quest to find it. It looks like I might just be crazy, maybe it was a different language.
I'm not super deep into it yet. I didn't really shop arround before hand so mostly curious to whats out there. When it comes to setting up a web app for the front end I'd like to use something else if theres a better alternative.
I just discovered Micronaut today. No experience with it whatsoever, but it supports Kotlin and looks nice. http://micronaut.io/
Every now and again I toy with things other than Spring, have fun getting them working. Then I want some other feature and have to go find and evaluate libraries and wrestle with integration to library A. By the fifth time doing this I wish I'd just used Spring: everything's already integrated. As for your browser webapp, vue.js or react are popular client-side. Production deployment of those are just static html/js/css files so host them wherever you want - inside your Spring app is fine if the server won't be overloaded. Alternatively you could use a server side webapp framework like thymeleaf or JSF but they're not as popular and it's probably harder to deliver a slick dynamic UI. Doing a client side webapp creates a convenient split should you want multiple developers on the project. If you do that I recommend autogenerating your REST API documentation in swagger - see springfox.
I'm thinking of creating a second server/client for the front end. Mostly for easier caching of data it needs, rather than having to call the main server all the time. Probably not even a database attached, mostly just things held in memory for easier lookup. I eventually want to add mobile apps into the mix, so kinda want a similar framework for the web. 
&gt; So when you tried to put a zero length string in to a function you would get a compile error what was basically a stacktrace telling you that a method 15 layers deep calls get[0] == ‚Äòa‚Äô to see if it starts with an a, so you need to check the size before then. You‚Äôre stumbling into the arena of dependently typed programming languages and formal theorem provers. Idris, Agda, or Coq are great examples of languages that allow you to do just that. 
Sure. Spring MVC can be your REST API which returns JSON. Then your JavaScript webapp and mobile apps can all consume the API's JSON. (Spring has managed caches if you need or you can just do it yourself) I have a project that's similar but the (unauthenticated) JSON responses are cached by an upstream webcache/CDN (CloudFront) so there's no load on our servers.
Try Vert.x, it's fun to work with and is a good match for API work. 
Dropwizard is great. There's a dropwizard-kotlin project which helps tighten it up a little when using it with Kotlin, but it's not 100% needed. Also check out Javalin, which looks quite promising. Until it shows up in TechEmpower I might be a little hesitant to use it on anything large scale.
Javalin uses Jetty, the same server as Dropwizard. The abstraction layer in Javalin is a bit thinner, so performance should be a bit better. We have an issue for adding a TechEmpower benchmark, but it's low priority compared to finishing version2. Javalin handles about 125 000 requests per second on my dev machine, so performance is not something most people should be worried about.
You can use Spring Boot as just an api and have your web app run on a separate (usually node) server. You can also bundle/webpack your front end and use spring to serve the static html/css/js files out of `src/main/resources/static`
My orignal plan was to use something like Angular, but it doesn't seem to play with kotlin well. I'm also not a huge fan of node personally, but that's just me.
Angular plays with Kotlin great! TS and Kotlin syntax is pretty similar. Its actually the stack we use at work. Just use webpack or angular-cli to compile your files and move them to the static folder, unless you're looking for something like SSR. 
no nothing like that. I used to work on a java and angular web app. Wanted to kinda copy and paste that. Might look at webpack. Sorry what's TS? I'm mostly a backend programer working in an old c++ code base so the web isn't super familiar to me. 
TS = Typesscript. Superset of Javascript that includes types, inheritance, ect. Angular 2+ requires you use it. Are you talking Angular 1/AngularJS or Angular 2+? You should be able to port your Java over (IntelliJ can even do it for you), but Kotlin introduces many paradigms (Optionals, extensions, ect.) that could change your Java code's structure and make it more solid and safe. 
Well this is a new project so I can do whatever I want. What I've done in the past was for a previous job so that's their problem. 
I'm surprised nobody has mentioned Ktor yet. It's pretty barebones and unopinionated but once you apply some structure it is actually pretty nice to work with
Do not forget about the cancel methods too
The "Kotlin in action" book is excellent
If you like the Kotlin Koans you could try to implement the kotlinplayground-calculator: [https://github.com/LostMekka/kotlinplayground-calculator](https://github.com/LostMekka/kotlinplayground-calculator)
[https://www.http4k.org/](https://www.http4k.org/)
Okay, there's one problem I have with vert.x that many people don't know about: Using netty. Netty is a great framework for an end-user. I've used it in many projects and I have contributed to it. But it is *not* a framework you should use as a transitive dependency, because **it does not provide binary compatibility** over minor versions. This is fine if you use it only once in your project (for example only vert.x uses it) but if you need any other library that uses netty, you're out of luck and need to resort to very dirty build hacks (shading with relocating) to make the two work together. I am not very familiar with vert.x, but I don't understand why it is necessary to use netty as its network backend. Netty is great when using it directly but it is pretty opinionated and there are alternatives that are faster and lighter (like xnio) though a bit harder to use, which is a fine if you're not exposing it to the user anyway.
The problem is that this is simultaneously a good article, and utterly baffling. From MonadError on down the type signatures made the code an unreadable mess. I love my types me, but they have to add value - I and my colleagues have to be able to see the algorithm for the syntax. 
I'd say that what you have already is enough. Don't spend too much time reading, after each chapter try to apply what you learned - with silly examples + writing unit tests for those.
You could always write your own stack to get this kind of behaviour. Have Stack and NonEmptyStack, make pop a method on NonEmpyStack, and define Stack.asNoEmpty() to return a nullable result. 
Take a look at the Techempower benchmarks. Vert.x plus Postgres are pretty much king as far as performance goes. As for the binary compatibility problem, can you give an example of a library you're trying to integrate that causes the problem? 
I'm sorry, but the Techempower benchmarks are pure, unadulterated bullshit. The particular binary incompatibility I have had issues with before is documented in [this issue](https://github.com/netty/netty/issues/6936).
Do you mean things like check, assert, etc? If so, [so here](https://www.bignerdranch.com/blog/write-better-code-using-kotlins-require-check-and-assert/). 
Depends on your needs. The main ones which I usually use are [vert.x](https://vertx.io/) and [Spring](https://spring.io/projects/spring-boot). I'd suggest taking a look at the [techempower benchmarks](https://www.techempower.com/benchmarks/) as well.
You say that they are bullshit but you have zero backing for your claims.
I really like Ktor but its still a bit early - breaking changes to adapt to and documentation is still being written. It has a LOT of potential though. I use it with Jetty (Jetty is an all-round king imo). Http4k looks more polished but I haven't used it (yet). Vert.x is indeed fun - and I looked through the Techempower benchmark setup and I believe a significant benefit is drawn from the actual Postgres driver - which you could plug into any other framework.
- They often aren't written by people with actual knowledge of the projects they test - They do not serve representative work loads - They are often optimized towards speed (if their author was in any way competent), which isn't usually something you optimize a real application for - they do not test "general" speed when writing normal code - They push more specific frameworks into roles they were not made for
Do you mean like when you have a method that's required to use a try/catch (such as writing to a file) and Android Studio makes sure that you have it before you can compile? 
maybe [stack.takeIf { it.isNotEmpty } ?.pop()](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/take-if.html) ?
You could create a series of classes so that you only have access to a method after calling a prerequisite method which would return an instance of the next class in the chain. You could create your own SafeStack which doesn't have the pop method. Once you call isEmpty(), it would return an inner class which has the pop method if it's not empty. So it would look like this: safeStack = safeStack.isEmpty() when (safeStack) { is NonEmptyStack -&gt; ...//pop now exists else -&gt; ... //pop method doesn't exist } The last tricky bit is that calling pop would return an inner class that has a single value property and the isEmpty method without the pop method in order to force you to repeat the cycle.
Sure, but you don't need these benchmarks to have some idea that PHP or Python is usually going to be slower. Of course data is nice, and when there's a 100x difference then yes, you don't need a good benchmark to measure it. Where these benchmarks really fail is the same-magnitude comparisons that people quote way too often.
No it isn't just assumption. Compare the vertx and undertow benchmarks for example. In the list the only difference listed on the site is the actual framework. What they don't tell you is that the undertow test uses the official PG drivers and Jackson (both in blocking mode!) while the vertx test uses a reactive pg driver. It's completely idiotic to compare the results from those two tests, because of-fucking-course using blocking mode with undertow is going to have different performance characteristics. And this is just one example. The quality of these tests varies so wildly that it's useless for the comparison they are supposed to provide.
&gt; I learned some basic and advanced C about a decade ago, but I'm rusty. You mean like /r/rust rusty? ;)
I think kotlin(and java) lacks a type-safety server template engine , which checks all error (ex : path , resources , and reverse routing ) at compile time. True , IDE may help. But it's best accomplished by compiler, which makes the whole webapp more robust.
Thanks, right away !
Thanks for the book suggestion!
I've been recommended to do the Kotlin Koans (once here) and I haven't yet. Thanks for helping me stake the guide posts though!
Nothing to it but to do it! Thanks!
Jooby is pleasure to work with.
I've put together my own Kotlin "cheatsheet" during our migration from java. You may find it useful. [http://www.slatekit.com/kotlin101.html](http://www.slatekit.com/kotlin101.html)
The issue isn't specific to JPA, but it's a problem you will encounter if you use data classes, so it's included in the article. I most certainly wouldn't expect a set I created and inserted 1 item into to still report a size of 1, but not contain the original item (or *any* item, for that matter, because anything that would compare equal to the data class with its ID would have the new hash code and not be compared with things in the old hash code bucket). If you ignore that, sure it makes sense, but it causes glaring issues that make absolutely no sense unless you know what's going on.
I stumbled upon this a month ago, saved it, and am just now returning to see nobody commented. Let me at least say that this is very cool. Thank you for sharing it.
Do you have to use their sign in form?
Spring security can handle oauth2
LWJGL is also replacing core pieces with Kotlin.
Yea they do support oath2 though the documentation might be lacking. Look at their GitHub project under the oauth2 folder.
That's generally the use case for using oauth2. What is it you're trying to do, exactly?
I want to have my own login username and password. So not just a client but a provider.
If you just want to do normal authentication for your own site, you probably don't need a full oauth2 implementation. Oauth2 would be what you want to use if a) you wanted to allow users to login to your site using their Google/Facebook/etc account so that you don't need to store username/pw (e.g. oauth client), or b) you want to allow users to login to a different website using the username/pw they created on your site (e.g. oauth provider). If the user account is entirely contained on your site, it's not necessary to use oauth. For a basic explanation of the what/why of oauth, I'd take a look at https://developer.okta.com/blog/2017/06/21/what-the-heck-is-oauth
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/cloudfoundry/uaa) - Previous text "UAA" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
So later down the road if this idea becomes more of a thing it will turn into a suite of products. I'm also going to need to prove that it's secure to handle personal information to the government at some point. Between those two running my own OAuth made the most sense to me. I also hope to make native mobile apps for this as well. Ended up with KeyCloak.
For Authorization Code grant, yes. But you can theme it pretty easily. For Password Grant, no. 
I was successful. I didn't have any strategy or sth. I'm in a **product** devision of my company, not a **project** division. I think that matters a lot, because from my experience, projects are best as homogeneous and easy accessible as possible. Homogeneous means switching languages is very difficult and easy accessible for most (young) developers is Java. Not my opinion though, but my experience. Point 2 is: My two principals trust my expertise very much and the expertise of all my department's colleagues equal as much. They are interested in having good, maintainable, safe codebases. So I don't have to persuade them from anything - I just have to clarify all circumstances and discuss possible consequences. For example my team is willing to adopt Kotlin because we have experience with other languages - adopting Kotlin doesn't cost us that much in terms of learning. My principals were developers too, with a C, PHP whatever background, so it's not a problem for them to understand the bunch of advantages Kotlin gives us. For most of Kotlin's killer features, you need to have a understanding of code, in order to be able to see the advantages. If you show your principals data classes, first class functions, first class delegation and null safety, showing them the best Java interop, it's either they got it, or I am afraid that you won't succeed.
Worked for me. I showed it to them in a demo and basically was like "Here is some Java code" - "Okay, now here is the equivalent kotlin code". I also showed how good the transpiler between the two languages was and that more or less sold it. I'd recommend trying to provide some information on how much time you spend dealing with nulls and maintaining garbage boiler plate, then saying this can all be saved. Meaning more features and stability faster. You should also point out that almost no time at all will be lost to training since it uses the same tools and ecosystem, and it's very easy to learn as a java developer taking only 1 - 2 days for competency, and a week for good productivity. 
I was an intern at one of the many Toronto-based tech companies (I'm still in university - undergrad right now), and I convinced the company to switch to Kotlin (as well as IntelliJ over Eclipse, haha) by comparing the key points. I talked about how it's quick to write compared to Java (syntactic sugar for less verbosity), very easy to migrate if you are already a Java developer, and talked about the null-safety system built into the Kotlin compiler to avoid NPEs. Full interop with Java code and the abundance of libraries in the JVM ecosystem was also a major factor that played into successfully convincing my team to test out Kotlin in an incubator project, after which all the developers loved using it over Java and have since then decided to use Kotlin for all future projects, while slowly converting old Java code to Kotlin if necessary. Keep in mind that this was for ENTERPRISE backend usage. Around the same time, the Android team at the company also started to pick up on Kotlin after hearing about it from Google's IO talk show from last year. But as for me, I was working with Spring and backend microservices, and even then it was not difficult to convince my team to switch to Kotlin. It took about a week on average for my team members to be fully comfortable using Kotlin in an idiomatic way, and only a few hours to understand how to read and write Kotlin without having to constantly check documentation for syntax and standard library functions. In addition, as a requirement in my engineering program in university, we had to do a 15 minute presentation on a technical topic, so I did mine on "A comparison of Java vs. Kotlin"; you can get the PPT here (keep in mind though, this was made last year in May 2017): https://drive.google.com/open?id=1j2hHV9xEqc4TvUILzYVHXRkJJPss9wiS
I don't think it makes sense at this point to use Kotlin in enterprise software. There are just too many issues currently with the language. Just a few random issues: * [Map implementations are inconsistent](https://youtrack.jetbrains.com/issue/KT-24390) * [Overload resolution is worse than with Java](https://youtrack.jetbrains.com/issue/KT-11359) * [Another overload resolution issue](https://youtrack.jetbrains.com/issue/KT-3884) * [Overload resolution with property references](https://youtrack.jetbrains.com/issue/KT-24175) * [Annotations are sometimes simply ignored](https://youtrack.jetbrains.com/issue/KT-15453) * [Lambda syntax can be confusing](https://youtrack.jetbrains.com/issue/KT-17658) * [Bad optimizations cause wrong behaviour](https://youtrack.jetbrains.com/issue/KT-23626) * [Bad type inference](https://youtrack.jetbrains.com/issue/KT-3850) * [Bad type inference with functions](https://youtrack.jetbrains.com/issue/KT-4113) * [Bad type inference again](https://youtrack.jetbrains.com/issue/KT-5464) And these are just base language issues and not IDE problems or so, which also exist. Also, there is lot's of missing documentation and undefined behaviour compared to the JDK and it's base classes. For example just compare the Javadoc of the classes String, CharSequence, List to it's Kotlin equivalents. The Kotlin List documentation is just "*A generic ordered collection of elements. Methods in this interface support only read-only access to the list; read/write access is supported through the* ***MutableList*** *interface."* and the methods have one-line-documentations. The Java documentation has over 500 lines in total and describes basic stuff like the computation of hashcodes, that inserting a List into itself can be problematic, allowed types, possible exceptions and so on.
I decided to start small: 1. make a side project (that management didn't care about how it was made, just that it worked) in Kotlin instead of Python as originally suggested 2. demonstrate how much better it is (good syntax, type safety, proper OOP support) 3. show that it's interchangeable with Java and write bigger Java project component in Kotlin. &lt;== I'm here
The sad thing is, all your points are completely valid and correct and still you're downvoted because apparently it's not allowed to say something against Kotlin here. Go to /r/java on the other hand, and the voting will be completely reversed.
After successfully presenting Kotlin to our managers and then clints, my team of 15+ developers have been using the language across a couple of enterprise-scale projects over the last two years. It has gone with without a hitch and I honestly cannot identify with a single one of your criticisms! Given that we've had a marked productivity boost though using Kotlin and no drawbacks, I say: It *does* make sense to use Kotlin for enterprise software.
I think by in large the kotlin versions are superior in terms of code quality. I don't think kotlin's documentation is nearly as bad as you are making it out to be. Scala is losing a lot of ground to kotlin, and a big part of that is because scala notoriously suffers from shit, misleading documentation. In terms of it being standalone, sure, but no one really treats it as a standalone language yet. Only teams who were previously java devs use it, really. I respect your opinion but I strongly disagree; using kotlin at work has increased productivity and reduced the amount of bugs. That is my experience, maybe yours differs, but I don't currently see how.
I don't disagree that there are real problems with using kotlin in enterprise but these aren't it. Using kotlin has been a pretty smooth experience for me and these issues are all edge cases that will likely never be encountered by a user (and Java has some of these too). I *have* encountered language bugs before in kotlin, but these are usually easy to work around and I've seen similar problems with Java. The actual problem lies with finding people familiar with the language, the relative lack of tooling (though this is far better than many other jvm languages) and having to support a code base for many years.
for JVM, my strategy is always the same: write my unit tests in the language i am trying to push, and promoting the development speed and or expressiveness or whatever. Over time, people start doing the same, and the organization "is infected".
Isn‚Äôt this leading to a pretty unmaintenable Test Suite? Just asking out of curiosity 
not really, as long as you start small and steady, and keep the test writing on par with the "evangelisation". brownfield projects may not be the best option, if those already have a comprehensive test coverage written on the "legacy" language, but greenfield and poorly covered projects are the ideal candidates.
I think people don't get that he doesn't actually tell us **his** opinion, but tells us what the opinion of others probably is (does he? :)) So I have to support hackometer here (disclaimer people, I'm the Kotliner prototype) - even though every single mentioned argument is extremely weak, those are the arguments people bring when asked about Kotlin. For example if really anyone on this planet believes Java's somewhen coming type inference is even somewhere near Kotlin's, then he is clearly wrong. Same and even more for function types.
I think you'll find the goals are quite distinct and separate. They are handled separately in their own projects; their two main focuses at this point in time appear to be the JDK implementation and the android implementation. Native and js are coming down the pipe at some point. I certainly have not suffered from a lack of documentation. I get that some developers are quite reliant on it but it's just not a pain point I have so there are no mutual feelings there. I'm pretty confident that Kotlin will have a steady future, I don't think it'll kill Java by any means, but I don't think Java will be able to catch up to kotlin either unless some serious work is put into doing so. Maintaining backwards compat is a big blocker for Java and it's the reason why lambdas in Java look ridiculous. Of course Java is more stable, that's the entire focus of the language; but to imply that kotlin isn't stable is quite false. It's been around a much shorter period of time, and it's quite usable frankly. Far more so than Java. Writing Java feels like programming in 2005. We've learned how to do things better than that at this point. 
&gt; Conciseness? "We don't believe in it." For me, this would be a withering one to hear if I was lobbying for using Kotlin. These are great things to think about how to handle. 
It was withering when I heard it, too :) The worst is when you're lost for words trying to explain the obvious (to you) advantages of concise code. Me: "You don't have to write getters and setters, equals and hashCode" Them: "So what, we have code generation". Me: "You don't have to write all the null checks by hand" Them: "We don't like these cryptic operations like `?:`, we prefer to see it all written out". And so on.
There are actually two reasons for inlining - performance gains which as you've mentioned are valid in specific situations, but also inlined functions can retain generics, which allows many use cases not possible otherwise - for example factory methods where you don't need to pass class instance and instead can use return type (which can often be inferred) 
Some of Kotlin's features can be replicated with Project Lombok and annotations (@Data, @Delegate, @Getter, @Setter) everywhere, but I don't find it as nice as just using a language meant for that. 
Looking good.
When you spend every week writing code for a living, syntax starts to matter more than just flashy tutorial code. Kotlin's syntactic sugar is very well thought out. Java looks like a dinosaur. So when it comes to personal projects/any new projects I work on, I find my self starting with Kotlin.
Single-Expression functions. It just feels and looks good to have a small, concise function written in a single line. In Java they look as clunky as every other method.
This is what my TL did. Introduced it in a small project.. then got the confidence of the team, did interop and then pushed for an all Kotlin team. 
I haven't gotten a chance to try javalin outside of play projects but it looks really great. Appreciate all effort put in engaging community and answering questions honestly.
Absolutely sealed classes. Love that shit.
What would you argue are Javalin's best attributes when compared against [Ktor](http://ktor.io/)?
Fun question. I haven't built any real apps in ktor, and I'm obviously biased, but here goes: * Javalin has a v1 (and now v2!). Ktor has been 0X for a very long time now. * Javalin works great from Java (you can easily port your app, just have to add some semis and parens) * Javalin doesn't wrap libraries. Ktor has "ktor-gson" or "ktor-jackson", etc. Javalin uses functional interfaces (ex `ToJsonMapper` and `FromJsonMapper`), and you provide your own implementation (there is an *optional* implementation using Jackson included in the core). * Javalin is just simpler. It keeps most of its functionality contained to two core classes, `Javalin` (the server) and `Context` (everything you need to handle a request). All the ktor examples have ton of imports, ex: import io.javalin.Javalin fun main(args: Array&lt;String&gt;) { val app = Javalin.create().start(7000) app.get("/") { ctx -&gt; ctx.result("Hello World") } } vs import io.ktor.server.netty.* import io.ktor.routing.* import io.ktor.application.* import io.ktor.http.* import io.ktor.response.* import io.ktor.server.engine.* fun main(args: Array&lt;String&gt;) { embeddedServer(Netty, 8080) { routing { get("/") { call.respondText("Hello, world!", ContentType.Text.Html) } } }.start(wait = true) } There are several cases where Ktor is a better choice than Javalin, but since you didn't ask about that I will pretend that there aren't (I can expand on this tomorrow, but it's late here now. Maybe one of the ktor contributors can step in and comment). 
Thanks for the answer. I certainly agree that Javalin is _simpler_ - and I do like that a lot. I've done 1 _very_ simple project using Javalin (1.x), and none using Ktor so I have no experience using Kotor. Indeed, the most experience I have is using Play 2 - but I would really like to move away from having to cope with Scala and SBT. One thing that does interest me in Ktor is that there seems to be a good number of 'capabilities' [ 1 ] that come out-of-the-box for various things. You want to use cookies for a session? Sure, turn on that feature. You want to hash the cookie data to prevent tampering? Sure, turn on the session transport transformer. Want JSON transforming using Gson? Sure, turn on that feature and configure the Gson instance if needed. Authenticate access to certain URLs? Check - configure and you're away. Really, what I'm trying to do presently is weigh up and down whether to use Javalin 2 or Ktor for my next project - and determine one can achieve feature parity with Play 2. [ 1 ]: [http://ktor.io/features/index.html](http://ktor.io/features/index.html)
The whole data classes + named parameters + default parameters shtick is really nice for storing data. In my Java code I use lombok for this (value + builder), but it's not nearly as polished and you can't specify required parameters with compile-time safety for the builders.
Newb Ruby refugee here. Features that make me choose Kotlin over Java in a project: - Top level functions. Makes stating the purpose of the function much clearer. - Conditional/try as expression syntax. Especially combined with `val` (vs. `var`), this can make values much easier to track origin and improve readability. - Properties: A value should be treated as a value, as long as there are minimal side effects in the assignment. - Operator overloading: If a number and a string can have `+` mean different things, other objects should definitely be able to take advantage (very, very sparingly) of that same mechanics that might make better sense. Currency is the first example that pops into my head. Although I do wish all operators could be overloaded rather than all non-equality comparisons being collapsed (it can just make for some very interesting DSLs). Invoke is a definite favorite, especially for builders/factories. - Extension functions: possibilities of abuse not withstanding, so much easier to customize to a specific context without allowing for modifiable classes. - Ruby/Groovy style last arg lambdas/blocks: I don't know why I prefer the ability to pass a lambda outside the parens, but that ability seems to be so much more readable in multi-lined lambdas. - Ability to specify receiver of lambda: This has a huge potential for abuse, but for the right use cases, it's invaluable. Spek's DSL is top notch. - Type inference: I've never really used Java's type inference, but I'm assuming it doesn't have generic type inference. - Default arguments: As long as they aren't mixed with overloading, it makes code much, much easier to clearly state/read what is going on. - Named parameters: makes passing options so much more precise. Note this really only works well with default arguments. - Inheritance by delegated encapsulation: A little bit flashy, but much more clear than having to either directly inherit from a class or provide proxy methods for all the methods. Also helps to encourage proper boundaries in encapsulation rather than traditional superclass inheritance.
For me it's really a "the whole is more than the sum of it's parts" deal. I can't name one single thing that makes 'the' difference for me, it's just that Kotlin is so damn convenient. You can really tell it's made by developers for developers who took all the good ideas from a ton of languages and integrated them all seamlessly into the language. So when I go back to Java I don't mis one big thing, I miss all the small things. 
Not a direct answer, but an interesting introspective observation: I often forget I'm not writing Java but actually Kotlin. I have to literally stop to look around the code and find a proof that it's Kotlin. Yet when I _actually_ write Java, it keeps reminding me of that fact. Kotlin is what Java was supposed to be.
If you want super flexibility you might want a document store rather than SQL. Although in my NoSQL experience we still end up listing property names/structure somewhere (e.g. a schema document) so at that point you might as well auto generate and version control POJOs if you can.
Neither really competes with Play on a feature level, but ktor is closer than Javalin is. Javalin requires the user to have a bit of knowledge about the JVM ecosystem if they want to build non trivial apps. The things you mentioned aren't hard to do in Javalin, but they might require a bit more setup than ktor.
&gt; I'm just wondering if I can bypass using an extension function for this. It looks like I probably can't but wanted to double check. Assuming you mean, can yo make an instance member on a class/interface that is accessible when the class/interface is null, the answer is no.
Yup that's what I was wondering. Thanks for confirming this for me :)
Let me see if I can explain a little bit. Sounds like you might need more background to understand them clearly, but I'll give it a try. **blocks**: a block is just a bit of code, either a single statement or a group of statements surrounded by { } s. **conditionals**: if and when are conditional statements. They *might* execute some code, depending on the value of their condition. **loops**: for and while are loops. They execute the same block of code (usually) multiple times, possibly in slightly different contexts each time. --- **if**: if is a conditional that takes one condition and one block of code. *If* the condition is true, it executes the block. It can also have an else clause, which executes if the condition is *false*. **when**: when is a more complicated conditional statement, but in its basic form, it takes a list of conditions with blocks, and then executes the *first* block whose condition returns true. There are several other forms of the when statement as well. **while**: while is a loop statement that, like if, takes exactly one condition and one block. Unlike if, while will keep executing it's block for as long as it's condition stays true. Also unlike if, while loops can't have else blocks. **for**: for is a loop statement that takes a variable, a collection, and a block. It executes the block once for each element in the collection, and the "current" element is bound to the loop's variable. --- Each of them is used for different things, even though they syntatically look similar. It is actually possible to duplicate a when statement using an if, else if, else if, ..., else chain. Similarly, it's possible to duplicate the for loop using a while loop. For and when are considered "important" enough that even though they can be duplicated with the other two, they get their own names and syntax (note: not many languages other than kotlin have a when statement, but pretty much all have for loops.) you'll need to learn to use all of them to become a fluent programmer.
Ktor here :) I don't want to go into comparison because I think that it can be done only by people who worked with both frameworks, but I'd like to clarify a few points. Ktor is not v1 for a simple reason ‚Äì it is heavily based on coroutines (and is top to the bottom asynchronous framework), and they have experimental status in Kotlin currently. We plan to release 1.0 Beta sometime around Kotlin 1.3 which lifts experimental status from coroutines. Otherwise, it is iterating over 0.9.x versions regularly, bugs are fixed, features are added. A lot of people using it in production. Ktor doesn't "wrap" libraries, it makes it convenient to use. If you look into `ktor-jackson` module, you'll see a single interface implementation with two methods, plus a helper DSL for configuration, that's it. As for `imports`‚Ä¶ Well, I don't remember when I last expanded the collapsed imports section in my IntelliJ IDEA :) That's kinda strange argument for "simplicity". Having fewer lines of code for trivial example doesn't mean the framework is simpler. Simplicity is important when you have a bigger codebase, and you still can understand it. Composability is key here, and ktor (in my opinion) is very good here. As for Java, that's true, you can't use ktor from Java because of heavy reliance on Kotlin features, such as DSLs and coroutines. 
I‚Äôll have to try that tomorrow, didn‚Äôt think about going that route. Thanks!
Why not just make an extension function? `fun Stack&lt;Any&gt;.popSafely() {` `if (isNotEmpty()) { pop() }` `}`
at the very least you could say you know java. As for "well", you could say it if you feel comfortable with the Jvm ecosystem like libraries and tooling. The worse thing that can happens is that you have to solve some problems that are non existence in kotlin because of it's advanced language features, like implementing builder to make up for lacking named constructor params, or implementing a decorator instead of delegate to private props. If you know how to do those thing in java, then you know it well I think.
This library demonstrates how you could decouple analytics libraries from your business logic code, effectively allowing you to: * Add &amp; remove analytics services quickly * Add &amp; remove events quickly * Change event names and parameters according to the required kit Let me know if there are any questions or feedback!
That would work but the user can still call the pop method when the stack is empty. He wanted something that wouldn't compile if you try to use it incorrectly
In that case, I'd create a lint check to show an error when user tries to call `pop()` directly to fail the build that way. 
Calm down and use whatever you want.
Remember that the usage of the stack can be intermixed with arbitrary logic of any complexity so it's impossible to prove that the usage is correct. Even attempting to make verification that can prove that generic code completes is impossible (not even attempting to prove correctness)
Take a look at my [Kweb](http://kweb.io/) library. It allows you to create rich interactive webapps in pure server-side Kotlin. It also lets you do crazy stuff like bind part of the (in-browser) DOM to server-side state and it will stay in sync automatically, and it all plays very nicely with Kotlin's coroutines. Kweb is built on Ktor.
Let's say you work at a Ruby shop. And you want to move to Scala. You need to convince your team because it's a change of tooling, the overhead of new libraries - functions you knew the names of off the top of your head now require you to check the documentation - probably a change of IDE, and learning new idioms. And you can't really intermix source files. So you have to find some part of the project you can hive off into a separate service and that's what you write in the new language. You probably need to get some kind of go-ahead from a project manager as you'll be using development time to make these non functional changes. But using Kotlin from Java? This isn't an either or. You can mix the two. If you're using Java, you're likely using maven or gradle. So you simply add the Kotlin dependencies to your build, and update intellij with the Kotlin plugin. Now you start writing some code in Kotlin. Your CI doesn't need to change so your devops don't need to be involved. Your IDE doesn't need to change if you're already on Intellij which is likely. Your project manager isn't going to care because you don't need to spend a week of everyone's time teaching new tools. You don't need to find a new project or part of a project you can hive off, you just start using Kotlin for new code in the existing code base. In many ways I view moving languages on the JVM as very similar to changing libraries. No one creates a topic called "How to convince my company to use Jackson". Now of course, in many people's eye's switching / adding a new language is seen as more of a big deal than changing some library or other, but if you can frame the discussion in the above manner, many potential doubters will have less of an issue with it. &amp;#x200B;
It's not possible as there wouldn't exists an object on which you could call the function ;). &amp;#x200B; Extension functions with nullable receiver (nullable this ) are possible because in fact they are static functions which get receiver (this) as a first parameter - you can see how it looks if you choose Tools/Kotlin/Show Kotlin bytecode/decompile - Kotlin is not really adding this function to extended object, it just makes it seem like it's part of it. 
The ktor framework is a lightweight framework for developing web applications obviously with 100% support for kotlin intended to only be used with kotlin. Spring boot is a massive framework with some adapatations to make kotlin feel more native, however it can still feel clunky at times. It has all the same quirks as using spring with java , plus the addition of language interop quirks. If you are looking for simplicity , I would suggest ktor. There is also a prototype on github for ktor-swagger for rest api documentation. 
Ty for answering. I gonna write a simple Api for a raspberry pi and now I'm decided to use ktor. Ty again
I'd be interested in seeing a Very.x Ktor showdown. I'm pretty early in my project and Ktor looks really good so far.
One huge advantage, in my view, is coroutine support.
When I looked into ktor I choose not to use it because documentation was simply non existant. This may have changed since then however. I have used Spring with Kotlin to create REST apis without any trouble at all and would recommend it.
There is a fair amount if documentation on how to use ktor now , however i dont believe there is a full set of kdocs yet, check out ktor.io
Since you are looking for reactive framework, check http://micronaut.io , really amazing with very good doc and small memory footprint. JWT - http://guides.micronaut.io/micronaut-security-jwt/guide/index.html
I had exactly the same question but I just switched to MutableList&lt;T&gt;.shuffle() because this also does the job for me. 
Ktor lacked proper documentation when I was considering using it, so I can't say anything about it. &amp;#x200B; It is a bit out of the context of your question but I am currently working with Vertx and I can recommend it. &amp;#x200B; It has coroutine support and some specialized coroutine stuff via `vertx-lang-kotlin-coroutines`. I don't know if it was only for me, but the learning curve is really low and it has lots and lots of documentation.
I wrote a rather big API with Ktor. I'm a big fan. It's lightweight and only comes with the really necessary parts. I dislike Frameworks who want to force you their logging Framework, ORM, Dependency Injection on you, Ktor doesn't have any of it. It's very compareable to express in nodejs. What's also cool is that Http dispatching is nonblocking (per default uses netty, but can be changed) and uses korotines.
Personally I wouldn't use frameworks that aren't somewhere at the top here https://www.techempower.com/benchmarks/#section=test&amp;runid=06753cdf-6519-4569-b9ea-c3ca36c9b07d&amp;hw=ph&amp;test=json
I've found the peeps on the #ktor Slack channel (https://kotlinlang.slack.com/) to be really helpful too.
There are a bunch of things which are very painful not to have: - extension functions - null safety - keyword arguments - destructuring - data classes - The simplified "stream API" These are the things which I use every day all day and I hate not having them in Java.
Those benchmarks are BS as there is no clearly defined way in which to implement each scenario. It often depends on whoever implements it to optimize as much as possible. You then end up with some frameworks whose benchmarks have had a lot more work put into them to get up the list - hardly relevant to actual real world projects. Just look at Spring in that list at #170 - yet many very large systems have been built with it. 
I'm always partial to side-by-side idiomatic examples, like file upload, routing, template rendering, form handling, JSON request/response. Perf comparisons are nice, but if I start with them I'll sometimes end without a library that I don't like or is hard to use.
So...this is advertising.
Nothing can stop you.
If I want to develop a library across all three Kotlin platforms, which IDE do I use? (a seemingly innocent question really just a roundabout way of saying it's frustrating using multiple pieces of software to develop multiplatform libs... including one that I have to pay for which is the rare case of a language's primary development environment for one of its primary targets requiring payment)
Doesn't the cradle integration make this a possibility? I've still not tried. On another note, needing IntelliJ ultimate to run unit tests in the ide for the js backend is not cool either.
This sounds interesting. Do you have any links to more information about this?
You mean besides IntelliJ?
They've been hinting that better multiplatform IDE support is in the works. I'll be surprised if there's not a major announcement at KotlinConf about either a new IDE or full multiplatform support in IDEA
Is there a way to distribute pure kotlin libraries (e.g. common or native) yet which makes it possible for others to consume them? Like publishing to bintray and consuming in Gradle?
I hope they don't call it Kotland
I thought that was Intellij?
The official documentation usually lists the Kotlin code next to the Java code: https://developer.android.com/training/basics/firstapp/ Nevertheless, keep in mind that most discussions about Android (e.g. on Reddit, Stack Overflow, IRC etc.) are centered around Java, so you will still need basic Java knowledge for android development.
For the JVM, nothing can beat JavaFX (imho). There‚Äôs [TornadoFX](https://github.com/edvin/tornadofx) which makes it more pleasant to use from Kotlin.
Tool, as in Kotlin + [apt](https://docs.oracle.com/javase/7/docs/technotes/guides/apt/index.html) (but not that specific deprecated tool)
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://docs.oracle.com/javase/7/docs/technotes/guides/apt/index.html) - Previous text "apt" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
Makes sense, thanks. It's been bugging me for awhile.
Start with Java. I really enjoyed The Busy Coder's Guide to Android Development, by Mark Murphy. I went through it page by page and did almost his entire eBook project step by step. I learned so much and I really like his writing style. I made a project in Java and THEN converted it to Kotlin - I recommend that you do the same.
Its stands for tool
That's interesting. May I ask how did they hint this? Any blog post post?
IntelliK :)
I think that `this::class.java` just loads a class ref from the constant pool, whereas `this::class` would need to construct a KClass
What was your experience with keycloak like?
Not to bad. Right now I'm under using it. But I do have plans for it. Adding it into spring boot security wasn't that bad. 
How cool would it be to have QT bindings for Kotlin??!!
Besides what others have said: The collection API is much more handy. Generics are better. The unified type system makes many things easier. String templates and multi line strings are pretty practical. 
Alibaba uses Spring and Spring boot as well. This is so
One downside is, that you have to write some boilerplate code by yourself, like wrapping your ResultSet in custom objects. There are ORM wrappers that do that for you, some use annotation processing and compile-time code generation, so you don't lose any performance. I prefer working with thin ORMs for medium- and bigger projects. But if your approach works for you, I don't see anything wrong with it. It is definitely better than using heavy ORMs like Hibernate; They are IMO worse than plain JDBC. They are full of leaky abstractions and you see DB-related exceptions popping up when you don't expect it and due to all the magic working behind the scenes it can be a pain to debug.
I mean... what's the *benefit* over something like JDBI? The JDBC API is still pretty terrible to use and this goes beyond the simple not-being-able-to-iterate-a-resultset. There's lots of warts there, and there's little good reason to deal with them when JDBI exists.
I come from the .NET world where the current trend is towards microORMs like Dapper. The only similar thing I've found in JVM world is sql2o (https://www.sql2o.org/) which I've used in a few personal projects. Current work (in a modern online bank) uses jOOQ. I'm not a massive fan, but it's miles better than Hibernate IMHO.
Fair point, I'll try that.
&gt; The only similar thing I've found in JVM world is sql2o (https://www.sql2o.org/) which I've used in a few personal projects. That also looks like it will play very nicely with Kotlin. Do you have a few queries you could show?
jOOQ is just a thin generated code (with some vendor-specific fixes) over plain jdbc. I like it, because it gives strongly typed queries with same performance as plain jdbc. Also, i don‚Äôt need to keep in mind all field names for all tables all the time :) If you have few tables, and you (and your team) can maintain all the queries when the db changes (with tests for example), you can go with plain jdbc
Great list! Some more of the [best Kotlin books &amp; tutorials](https://reactdom.com/kotlin)
I've tended to use Auth0. Free and simple to use, if you're a Spring guy they have a plugin -- otherwise you can just make the 2 calls yourself.
&gt; Scala is losing a lot of ground to kotlin, and a big part of that is because scala notoriously suffers from shit, misleading documentation. I'd agree for the Lightbend products I've used in the past, but I feel the same way about Spring! Scala is really for a different group of people. If you just want "better Java" then Kotlin is for you -- and in the commercial world, that is a good selling point. Scala is more expressive, but that can be a bad thing.
I'm finding that these micro-ORMs often seem to be lacking in the "relational" aspect, and I'm struggling with Exposed for that very reason. I'm not experienced with SQL (I can use it, I've never been an expert) and I really do want a Kotlin-friendly tool to assist. I thought that was Exposed, but your code above doesn't look much more complicated than what I'd have to write with Exposed. I fear I may return to Hibernate soon...
I'm really not sure that the same could be said of Spring. I think we could argue about the difference all day, and that it wouldn't matter, I'd just say that I would disagree the quality of documentation of spring is in precisely the same category as Scala's.
In my experience, Spring documentation is great for simple things. Once you start going deeper, I find the documentation to be lacking (wide but shallow documentation). Play is similar, but fails at an even shallower level... When I used it, the Play documentation didn't even show you how to parse a form from a request.
This is great as a way to approach an API you have no control or influence over such as a third party that you are consuming. However I feel the problem needs to solved at source (i.e. the API itself) if you do have control or influence over it. It's a problem with consistency and implementation of the contract that is at fault and should be solved. Anyways, interesting approach nonetheless.
I'm daft, what does it do? Does it check the dependency you've declared in your gradle file or is there another purpose?
Thank you, however as a German I have to say that you shouldn¬¥t abbreviate Kotlin with Kot
Because an object is already an instance of something, while a class has to be instantiated, in your example. Also a class is like a template - if you don't need a template because you only need one instance, you can use an object, much simpler.
What would you say about the name in general? Is this connection strong enough?
It's not pronounced the same way, but it's still something every German person probably thinks about when hearing it and imagining how it's written, but they would keep the thought to themselves
I guess It's not very self explanatory. or the README just sucks I have another library, called *kotlin-analytics* \- and I wanted **THAT library**, to check for its latest version on the repository every time it's initiated, so that the library could alert the developer that he's using an older version of the library (via console). So I setup **THIS library** that does just that. You pass in the *GitHub* or *Bintray* repository name, and you get the latest version of that package / repo.
The idiomatic way of creating a singleton is through the use of the object keyword. The author decided to use a singleton instead of a class in that case.
Clear. üëç
Will there be any performance difference or is it just a syntactic change?
It's a late answer, but I just confirmed what I've been saying. fun start(): String? { val isNotNull: String? = "some value" val willBeOK = isNotNull?.let { // this block gets executed because `isNotNull` contains a value null } ?: run { // but this block will also be executed because the previously executed block returns [null] "OK" } // `willBeOK` is a String with the value "OK" return willBeOK } To confirm you can copy the code example and paste it here: https://try.kotlinlang.org/#/Kotlin%20Koans/Introduction/Hello,%20world!/Task.kt
Your initial snippet does not return null in let so run will never be executed. The example that you provided above makes no sense and has no real world usage.
I didn't provide an initial snippet and of course it has no real world usage because it's supposed to demonstrate something. But hey, whatever floats your boat if you're that desperate to be correct on the internet.
Sorry, completely lost track of this thread, thought that you were op. Now that I‚Äôve read everything again I have to admit I didn‚Äôt read the first comment attentively. It does make sense that the second block will be executed if first returns null. Even though I never thought of this use case this might be a potential source of bugs if some function in let returns nullable type.
Definitely. For readability it would still be better to use an easily understandable "if-else" instead of the "var?.also {} ?: run {}" construct.
So does this release fix https://github.com/square/moshi/issues/509 ?
[removed]
I know object is an instance of a class, but in this case it is called object declaration and it's just a keyword, it does not mean that it is an instance of a class as explained here: [https://blog.kotlin-academy.com/kotlin-programmer-dictionary-object-expression-vs-object-declaration-791b183ad16b](https://blog.kotlin-academy.com/kotlin-programmer-dictionary-object-expression-vs-object-declaration-791b183ad16b) &gt;\&gt;In [previous part](https://blog.kotlin-academy.com/programmer-dictionary-class-vs-type-vs-object-e6d1f74d1e2e), we‚Äôve already described what is an [object](https://blog.kotlin-academy.com/programmer-dictionary-class-vs-type-vs-object-e6d1f74d1e2e). The problem is that Kotlin introduced an object as a keyword. This causes some confusion in the programming community. &amp;#x200B;
When you use the object keyword you are declaring a **singleton** in your application. That means there is only one instance of it... **ever**. And the instantiation of it is handled by Kotlin. When you use a class you can have multiple instances unless you define it using the singleton pattern. Here's a good explanation that shows you exactly what is happening under the covers: [https://medium.com/@BladeCoder/kotlin-singletons-with-argument-194ef06edd9e](https://medium.com/@BladeCoder/kotlin-singletons-with-argument-194ef06edd9e)
Guess this is something similar to https://start.spring.io/?
&gt;https://start.spring.io/ Please have a look at the sample "Petstore Kotlin Spring Boot server stub": [https://github.com/OpenAPITools/openapi-generator/tree/master/samples/server/petstore/kotlin-springboot](https://github.com/OpenAPITools/openapi-generator/tree/master/samples/server/petstore/kotlin-springboot) &amp;#x200B; And here is the specification describing the Petstore REST API: [https://github.com/OpenAPITools/openapi-generator/blob/master/modules/openapi-generator/src/test/resources/2\_0/petstore.yaml](https://github.com/OpenAPITools/openapi-generator/blob/master/modules/openapi-generator/src/test/resources/2_0/petstore.yaml) &amp;#x200B;
Could we have the same but with Exposed DAO please?
Are you talking about the Android development libraries for Kotlin? Those shouldn't be on desktop apps anyways.
This generators differs in that you can provide a specification of your API and generate models/endpoints. That's not something supported by the `start` app provided by Spring.
I thought the question was a beginner question, hence I tried to give a simple, easy to understand answer :)
I'm talking about when you can inject a method into an existing class. E. G. fun String.myMethod() { return "my Method is being executed on string $this" } 
To be honest, Kotlin is not really the natural choice of language for this set of tooling...
The problem with the DAO approach is that you are no longer dealing with standard Kotlin (probably data) classes, but instead with custom entities tied to the orm. This makes it less attractive to pass down into the service layer (or anywhere else) and also web frameworks only really expect to work with plain 'POJO' classes anyway. You end up having to create another set of DTO classes which can be near copies of the entities - kind of defeats the point to me. My preferred approach is to use the easier DSL approach which is really just a micro-orm above sql. Handle all of the data access in your own dao and then spit out standard Kotlin data classes. A bit more to do in the data access layer (but the Exposed DSL is easy to use and can cut out a fair bit) and there are definite benefits elsewhere as you don't have to start worrying about if your relationships have loaded yet (a common annoyance with Hibernate et al). Plus the web framework can deal directly with your entity classes with no extra effort. 
It should work on any platform, there might be something wrong with your project setup.
I really like how this website explains the features, they explain how it works, show examples and so much more, way better than other tutorials on the internet.
Wonder if they have the same isssues that Scala has with its value types and collections 
So you can't use them for vectors ? no such thing as ```kotlin inline class Vector3d(val x: Double, val y: Double, val z: Double) { fun normalize() : Vector3d = ... } ``` seems like a missed opportunity :(
Not sure which issues you refer to, but these inline classes do have boxed forms and will be used where needed.
Maybe you can have the value of the inner class be a Triple?
How would that be implemented on the JVM?
But would that inline it like I suggest in the [above comment](https://www.reddit.com/r/Kotlin/comments/9b921i/introduction_to_inline_classes_in_kotlin/e51l7uv/) ?
I did run into a couple of issues along the way, like KT-26052 and KT-26120. The Kotlin team resolved those tickets very quickly (although the builds that include them haven't been published yet). Might be worth submitting a ticket for the issue you found, if there's not one already!
Not sure, but from the article, an inline class is a wrapper over a single value. So, having it be a wrapper around a triple might work? But then again I'm not sure what value you would be getting then.
That would work for local variables, but it wouldn't work for parameters/return types - at least, not without a wrapping class, at which point the benefit of inline classes is pretty much moot.
TIL Java byte code has instructions for [returning a method with a value](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.8). Back when I had to write some Assembly in school (can‚Äôt remember the architecture) I had to fetch my return values from the stack myself. Maybe that way you could return multiple values. But I don‚Äôt know enough of the JVM machine ops (yet, at least) to say, and it could be untranslatable to Java code (Scala does that IIRC, but Kotlin does promise certain degree of interoperabily). And maybe Java‚Äôs value types will be of interest? I have only glanced at them, so I‚Äôll leave with a comment from [a blog post I found while writing this post](https://www.beyondjava.net/java-8-types-revamping-javas-type-system): &gt; Of course you can implement tuples and multiple return types on the JVM. Scala does so. But it's not really efficient. You can't simply put the return type (int, int) in two CPU registers, or put it on the stack. You have to wrap it in an object. Value types, in turn, can be put on the stack, making it possible to implement multiple return types in a very efficient way.
Isn't this a reinvention of Guava's [LoadingCache](https://google.github.io/guava/releases/19.0/api/docs/com/google/common/cache/LoadingCache.html)?
The inline class would be replaced by the Triple, but because Triples have more than one field and can't be inlined, it would still be stored on the heap.
It is never a bad thing to learn a new programming language. Seeing different paradigms and thinking about code in different ways can help you out even if you don't end up using that language in your career. &amp;#x200B; Personally I believe Kotlin is going to be the Android language going forward. More and more companies are adopting it quickly and developers love it. &amp;#x200B; Server development is traditionally more resistant to change but Kotlin has a lot of neat features that would really help out server development so I hope it finds more adoption there too.
By testable unit you mean a separate class right? But then it should also be a private class since it shouldn't/needn't be accessed from anywhere else right? And then its again not testable
By testable unit you mean a separate class right? But then it should also be a private class since it shouldn't/needn't be accessed from anywhere else right? And then its again not testable
&gt;Yeah but internal is basically public in a single module project and would violate encapsulation the same way right? &amp;#x200B;
Like [MockK](https://mockk.io/)?
And here is a link to the outcome: https://github.com/jasync-sql/jasync-sql
Old post but cool! I'll check it out.
There are no guarantees. That being said, I'm using Kotlin on the server side and really enjoy the language. If you're doing Android development, you'll still have to learn the API and development tools regardless of language. If you already know some Java, give it a try. You should be able to understand the basics pretty quickly with minimal time investment.
Amazing article! I'm really looking forward to the next one.
Has anyone performed any clean-build compilation benchmarks versus Java with a recent version of Kotlin? The only comparison I could find was with Kotlin 1.0.2
Kotlin will be the prominent language for Android development without a doubt. Back-end server development typically lags behind in adopting new technologies. However they very much care about correctness, defect rates, &amp; productivity and Kotlin helps with all 3. Our company just approved Kotlin for back-end development due to these reasons. Since Java developers are so plentiful, this adds downward pressure on salaries. I'm seeing much higher salaries for Kotlin postings.
We use Kotlin a lot as a server side language with Spring boot and it's awesome. Truly better Java. We like it.
Inlined class is such a great feature. It's an interesting move as well. As I think it will harm the Kotlin -&gt; Java story a bit. I would love to see an inlined Color class for Android.
Thank you, that's a very useful summary. I was certainly struggling with the DAO approach and had far too many classes and objects with similar names for the different layers for my application. I think the DAO approach is the unloved child of Exposed; the tests written by Jetbrains are more expansive in DSL than they are in DAO (there's no test written to cover updating a row in the DAO! [https://github.com/JetBrains/Exposed/tree/master/src/test/kotlin/org/jetbrains/exposed/sql/tests/shared](https://github.com/JetBrains/Exposed/tree/master/src/test/kotlin/org/jetbrains/exposed/sql/tests/shared) ). I'm not a huge fan of Kotlin's "DSL everywhere" approach though, it's a little bit too much magic and it's much less clear what parameters are passed where. Especially true when every parameter is a function taking and returning some generic type... I might try again with DSL, once I've unwound and destressed myself from it.
Yeah I would probably agree there, to be honest I see little reason to use the DAO approach apart from in the most simple of circumstances. I can easily see the maintainability issues it would introduce. I guess there is no silver bullet here. You can either get a lot of magic in the syntax or you go to the more simpler (probably annotation driven) approach where the framework itself hides a lot of magic and it becomes difficult to understand what it's actually doing behind the scenes.
I think it doesn't have to do with Java interop mainly. As soon as you have a method boundary, it's going to be a problem - because the wrapping type is not erased. Many parts of the documentation relate inline classes to primitives where boxing happens. If conditions are met that require boxing, there is no chance to do anything, only if inlining can be a resuce but... I don't think this is/should be the use case for inline classes. I think JetBrains knows that sooooomeeewhen in tha far far future, value types will arrive on the JVM.
I'm going to file a report after I tested the latest release, thank you.
I read about value types on another comment. Sounds cool, I hope to see it in my lifetime :)
The Triple would be inlined bur you would still need to allocate the Triple.
as a non-german, why? is it a slur?
Why are you afraid of learning? Becoming proficient with Kotlin if you're familiar with a similar language (Java or C#) will take you 2-3 weeks. And if Kotlin is your first language, then the knowledge you've learned from Kotlin will transfer just as easily to other similar languages.
It means shit (less formal version) in German
Purely anecdotal, but here goes. If anything, my experience with Kotlin so far has increased my knowledge of Java and the JVM. I've learned some of the rationale behind certain language decisions and how Kotlin as a language improves over Java in many scenarios. In general I find working in Kotlin a lot like working in Java if the book "Effective Java" was made part of the language rather than best practices attached to the language. That along with the much cleaner syntax and the features that I believe truly set it apart from Java (extensions, coroutines, inlining, delegation, better generics, experimental inline classes, etc.) make it a language that makes JVM programming more fun for me and that encourages me to learn and explore more. So tldr I guess is that even in the worst (and imo case unlikely) Kotlin becomes no longer viable and you have to fall back to Java skills, I believe positive experience with Kotlin will help you understand and write better Java.
For some tutorials please take a look at https://kotlinlang.org/docs/tutorials/native/basic-kotlin-native-app.html and others. Regarding Android+iOS development take a look at https://github.com/JetBrains/kotlin-mpp-example 
Thank you! I'll take a look at those. Have you done any KN development? I'm interested in hearing first-hand opinions.
Nah I know what objects and singleton is, but I just got confused by the syntax of a singleton class in kotlin, since it is way different in java. But its fine anyway, thank you!
Well, I did some Kotlin/Native development, being Kotlin/Native team TL, so my first-hand opinion may be a bit biased ;).
Please join http://kotlinlang.slack.com/ - there are many people who could share their experience/pitfalls with you. 
Oh, awesome. Didn't know about that. Thank you!
Sorry, never mind. Found out how to get an invite.
Oh wow. I just wanna thank all of you at the kotlin team for actually participating with the community. I had seen some kotlin team flairs around, but I rather figured they were just "community involvement staff" or something silly. I love that you all are here, doing stuff like this and answering questions for us. This is why kotlin is my favorite language (among many other reason)
A tiny addition: we have just published the fresh Kotlin/Native support plugin for CLion with Gradle support. https://blog.jetbrains.com/kotlin/2018/08/kotlin-native-0-8-2/
Oh, nice! I'll take a look at this. I just upgraded to the All Products license, so I have CLion now. Keep up the great work! 
As someone who makes hiring choices. If I had two candidates in front of me with roughly equal experience but one knew kotlin and the other didn't it would be the deciding factor for sure.
Oops, missed that from the post. I am quite amazed at the lack of modern high quality MySQL async JVM client libs out there. If my company used MySQL, I'd write it for y'all because I enjoy it :-) But alas we do not...still be careful porting over that low quality code.
Is there any plan to be able to use Kotlin Native outside of CLion? 
It's not about "learning" it. It's about making a career choice and looking to become proefficient in this tech instead, let's say, Java, just to find out noone I won't be using it but for personal projects. It's about the correct allocation of time. I'm not in a very good position right now; time is crucial.
God that's verbose having to write all those functions like it's the 90's. Has anyone tried using standalone gorm with kotlin? Be curious to see how that works.
Java is an open specification. Google has copied code though. However this isn't the case in terms of Kotlin.
While I don't know much about multiplatform Kotlin, here are the things I need: - full crossplatform co-routines support - co-routines to support Rx's featureset (cold observable behavior) - ADTs when consumed by Swift (sealed classes in Kotlin). AFAIK obj c doesn't support this, so idk how Swift could. Then we'd be talking!
Creating their own language is different from reusing one.
Interesting read... check other comments here ;) [https://www.reddit.com/r/Kotlin/comments/9b921i/introduction\_to\_inline\_classes\_in\_kotlin/](https://www.reddit.com/r/Kotlin/comments/9b921i/introduction_to_inline_classes_in_kotlin/)
I think the overloading problem has already been adressed in the latest release [https://blog.jetbrains.com/kotlin/2018/08/kotlin-1-3-m2/#more-6347](https://blog.jetbrains.com/kotlin/2018/08/kotlin-1-3-m2/#more-6347) The other points: Ah okay, yes, those are the usual problems, most of them just the same as with primitives. I'm not too sure about the question if all usages with methods lead to boxing, I don't think so, but correct me. A generic use case is described as well in [https://github.com/Kotlin/KEEP/blob/master/proposals/inline-classes.md](https://github.com/Kotlin/KEEP/blob/master/proposals/inline-classes.md) but I have no idea about the current state of those usages. For me, delegated properties is a very important use case for inline classes, if they'll work as I expect, but the linked document shows this use case :) 
&gt; I think the overloading problem has already been adressed in the latest release https://blog.jetbrains.com/kotlin/2018/08/kotlin-1-3-m2/#more-6347 Ah, okay. Scala doesn't mangle anything, so an analogous example wouldn't compile. I wonder if loss of reflectivity when using Java-oriented libraries is worth it though. We'll see. 
When is the expected release date of 1.3? Anyone know if there is an M3 planned?
I‚Äôve yet to fully digest this, but it looks like a really interesting idea. 
I saw in a talk that they are planning to release a Kotlin IDE that ties in all the platforms Kotlin is used on. Not sure on that status or if it's underway yet.
Touchlab had written the droidcon app in Kotlin native : https://github.com/touchlab/DroidconKotlin/blob/master/README.md They also have a video in their YouTube channel. Take a look. 
Oracle wants to go after to the Big Fish. This case Google. If Oracle succeed, they can go after to the smaller fish.
Dude. Fucking google. Jesus.
You said it, man.
If you accepted 1/3 precision, you could break the 64 bits of a long into x,y,z. But otherwise a true value type would be compatible on the jvm. 
Interesting! Do you have a link to that talk at all? 
UPDATE: the "kotlin-spring" generator has been included in v3.2.3 released yesterday (Aug 30th). Please refer to the tweet for more information: [https://twitter.com/oas\_generator/status/1035200785066254336](https://twitter.com/oas_generator/status/1035200785066254336) 
Yeah, it was this one: [https://www.youtube.com/watch?v=4K3Vb2hGhoI](https://www.youtube.com/watch?v=4K3Vb2hGhoI) I'm pretty sure it was in the Q&amp;A at the end. Can't remember exactly though.
Awesome - thank you :) 
You're not wrong, Walter, you're just an asshole.
Please let them call it `JustKode`.
A meringue? 
How does the bot know it‚Äôs you Dave?
LMGTFY: [https://www.cakesolutions.net/teamblogs/2011/12/19/cake-pattern-in-depth](https://www.cakesolutions.net/teamblogs/2011/12/19/cake-pattern-in-depth) &amp;#x200B;
What's wrong with it? By declaring `inline class Username(val value: String)` you get additional type safety to prevent a `UserHash` being passed to a function that expects a `Username`.
I know of cake (although as I said, I‚Äôve yet to fully digest it ;-)
Am I wrong = a meringue. Maybe I‚Äôve been listening to too much Hamish and Dougal.
They're very promising, hope the syntax will shortened, maybe using annotations like @Contracts.Run.ONCE
Somewhat like but not exactly, apparently the approach has merit by itself. I'm not the Scala expert in the house, but I know Ra√∫l Raja has been pushing it in their community.
If you're trying to become a better engineer, learning a new language ‚Äî any language ‚Äî and spending the time to think about how it relates to your primary language and what lessons carry over from one to the other is never a waste of time. On that front, Kotlin has the advantage that it has plenty of industry adoption, but the disadvantage that it's sufficiently similar to Java that it won't push you _that_ far out of your comfort zone. Ultimately, though, the question is ‚Äî What's the alternative? What else would you be doing with your time instead of learning Kotlin? E.g. maybe getting really familiar with some DB would be better if you want to go backend. 
Really looking forward to it as contracts will greatly improve smart casts and further reduce clutter (eg. !isNullOrEmpty() implies it's not null)
Very cool, is this the closest thing we've seen yet to a practical implementation of [dependent types](https://en.wikipedia.org/wiki/Dependent_type)?
&gt; maybe using annotations I hope not! 
They considered it, look [here](https://github.com/Kotlin/KEEP/blob/3490e847fe51aa6deb869654029a5a514638700e/proposals/kotlin-contracts.md#prototype-description) number 2 under "alternatives considered".
With regards to the Jitpack implementation, afaik Jitpack is backed by a github repo, so could you extract the git repo from the Jitpack url?
I consider myself to be experienced in Kotlin and I still had to look at the last example for some time to understand the single line. Great example though of how not to use Kotlin. 
I recommend learning the basics of Java and then read the book "Kotlin in Action"
&gt; https://stackoverflow.com/questions/7860163/what-are-some-compelling-use-cases-for-dependent-method-types Inheritance &amp; dependent types. Yikes. No wonder.
Language is a tool that allows us to show the data we use as we want it. After learning the data structures and OOP, the web page of the language we want to learn will suffice. [https://kotlinlang.org/docs/reference/android-overview.html](https://kotlinlang.org/docs/reference/android-overview.html)
I'm totally agree with you. It's why I'm trying to do this everyday (clean code). It was just a question. No it's pretty clear for me :)
Thanks, I guess I'll learn the basics of Java first!
There is Kotlin Programming by The Big Nerd Ranch. It doesn't make any assumptions about the programmer having Java experience. https://www.bignerdranch.com/books/kotlin-programming/
I've read most of the books on Kotlin since I have free Safari books through works. I'd probably get the Big Nerd Ranch or Head First Kotlin book, I don't think it is out yet but I've read some of the rough cuts. . 
Free Kotlin Book link: [https://books.goalkicker.com/KotlinBook/](https://books.goalkicker.com/KotlinBook/)
They sure are iterating Java fast nowadays. IntelliJ already has support for Java 11!
Thank you for an update on the correct terminology.
Parentasis `{}` just by themselves are treated as a lambda. So your example is just a lambda that returns lambda that returns result. val cnt = data.items.flatMap {x-&gt; { val result = x.subitems if (result != null) return null return result }}
&gt; if (result != null) return null return result You mean just return null? :p Of course in kotlin normally you'd use null safety. If you don't want x.subitems to be null then don't declare it as capable of that, so you don't have to keep testing everywhere. 
Thank you for the comment. What is difference between this (correct) val cnt = data.items.flatMap { x-&gt; x.subitems} and this (incorrect, why ?) val cnt = data.items.flatMap { x-&gt; return x.subitems} &amp;#x200B;
`return` without a label always returns from the enclosing function, not the lambda. If you wish to return from the lambda, you must specify a label.
Oh I haven't heard of lables. Thank you letting me know. So this is correct val cnt = data.items.flatMap { x-&gt; return@flatMap x.subitems} &amp;#x200B;
There seem to be a few non-native English speakers here, so just for information: Parentheses: ( ) Brackets: [ ] Braces: { }
This doesn't affect jetbrains, as they're in Europe which isn't subject to the new US laws making APIs copyrightable (and has previously ruled the exact opposite). 
RTFM is almost never a helpful response to a question, especially for a beginner. Documentation provides comprehensive information but OP is seeking clarification for a specific problem. Even great documentation can be overwhelming and frustrating when you don't know where the problem lies, not to mention OP is ESL
thank you &amp;#x200B;
I would recommend against returning labels in general practice, its better to use the shorter syntax.
The short answer to your question is, multiple statements simply come after the `-&gt;`, one on each line. Early returns are written as `return@filter shouldFilter` The documentation has a number of examples that show exactly this: &gt; Therefore, the two following snippets are equivalent: &gt; &gt; ints.filter { &gt; val shouldFilter = it &gt; 0 &gt; shouldFilter &gt; } &gt; &gt; ints.filter { &gt; val shouldFilter = it &gt; 0 &gt; return@filter shouldFilter &gt; }
In some languages lambdas are for quick one lines not blocks. I'm still learning Kotlin too but I think what you're looking for is anonymous functions. They work similar and can be written in one line or in blocks.
What about a guy like me who has years of experience programming python, JavaScript, C#, Scala, and even lisp but has never written a single line of regular Java? In general I hate the idea of needing to learn another language just to learn a language. I really liked Scala because I could start working without almost no previous Java knowledge.
Even that's US-centric. I believe they call `()` "brackets" in the UK. I'm in the US, and I refer to `[]` as "square brackets" just to avoid confusion. 
Ok, English is not my native language. I did read documentation, I did do kotlin koans, I did know how to write it correctly (my first post) but I did not understand why. Not everyone is capable to read documentation do tutorial tasks and remember every detail and every example from every page of documentation and understand all correctly. That's why I asked. I'm sorry if I bother you, but that's how it is. Therefore I appreciate /u/snaftyroot comment. And yes I'm completely new to kotlin however I'm not completly new to c# and javascript and maybe that's reason why I could not understand kotlin lambda since it's quite different. I would also like to thank all people comments it helped me to understand it better.
In general, when you make a lambda, the syntax is: { param0, param1, ... -&gt; expression expression expression } The lambda will automatically return the value of the last expression in the body. If that's something that has no return value (e.g. `println`), the returned value will be `Unit`. A lambda can have zero parameters. (For that matter, it can have no body, in which case it just returns `Unit`.) But most importantly, the parameters go within the curly braces in Kotlin. That's just the Kotlin syntax. If you declare no parameters to a lambda, and the compiler sees that it *should* take one parameter, then you will have a variable called `it` available within your function. These are identical: listOf(1, 2, 3).map( { a -&gt; a + 2} ) listOf(1, 2, 3).map( { it + 2} ) If you want to pass a lambda to another function, you can pass it as a regular argument, intermingled with other arguments: someFun( someObj, { a -&gt; a + 5 }, "foo") There is *one* kind of syntactic sugar that might be tripping you up. If the lambda is the last argument to a function, then you can move it outside the function's parentheses. These are equivalent: someOtherFun("foo", { a -&gt; a + 5 }) someOtherFun("foo") { a -&gt; a + 5 } And if your function takes one function parameter, then you can pass the lambda without using any parentheses. These are all equivalent: listOf(1, 2, 3).map( { a -&gt; a + 2 } ) listOf(1, 2, 3).map() { a -&gt; a + 2 } listOf(1, 2, 3).map { a -&gt; a + 2 } It's idiomatic to move the lambdas out of the parentheses and to omit the parentheses if possible. You should get used to this style, and you should use it yourself. --- If you really want to use explicit returns, there are two ways to do it. One is to use [anonymous functions](https://kotlinlang.org/docs/reference/lambdas.html#anonymous-functions): listOf(1, 2, 3).map(fun(a: Int): Int { return a + 2 }) The other is to use [labeled returns](https://kotlinlang.org/docs/reference/returns.html#return-at-labels) in your lambda. These are equivalent: listOf(1, 2, 3).map foo@{ a -&gt; return@foo a + 2 } listOf(1, 2, 3).map { a -&gt; return@map a + 2 } Explicit returns shouldn't be used unless completely necessary. Recall that things like `if` are expressions in Kotlin: listOf(1, 2, 3).map { a -&gt; if (a &gt; 2) -a else a } // [1, 2, -3] Explicit returns from lambdas are most useful for early returns, but if your lambda is so complicated that you need early returns, maybe it should be a named function instead. --- Even in JS, [arrow functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions) can omit the `return` keyword. If the arrow function's body uses braces, return is necessary, but if braces are omitted, then the `return` keyword can't be used. And in JS, if you can use the shorter form, you should.
Yup, we call them () brackets, [] square brackets and {} squiggly brackets. 
While I do agree that Kotlin documentation is very good and in most cases easy to understand, but this specific case wasn't covered really And this thing can be confusing also. For example in Java such standalone parenthesis would create a new scope so this would work (just variables declared inside this scope wouldn't be visible outside). In Kotlin it created a new lambda that wasn't "fired" - in some cases you would get compilation error or things would just fail silently (like in example with onClickListener - this code will compile but will do nothing, as it would just create some lambda and nothing else) 
I would say that your experience with JavaScript and Scala would fill the spot that people in this thread are recommending you fill with Java. The big thing you get from Java knowledge is the knowledge of Java libraries, which you should have a pretty good handle on from working with Scala. As I mentioned in my top level comment, Atomic Kotlin looks like a really good book, and has a fast track for experienced developers.
I wrote the bulk of that stuff, if you have any questions. Gave a talk a few weeks ago about status: https://youtu.be/oeREzhXx7uw
But you would also understand parentheses to mean (), right? US-centric seems to be more compatible. 
I think most developers would be familiar with them as parentheses but not the average British person. 
Right, but there is no conflict of definition with a bracket. 
The `DefaultDispatcher` used within all the major coroutine builders (`launch`, `async` etc) uses the CommonPool thread pool by default. You can confirm this yourself by looking into the source of `launch` for example. The dispatcher is a default parameter. You can override this behaviour as you want. By default the coroutines will run in this common thread pool, but you can also tell them to run constrained to one single thread or on your own custom thread pool.
I am not familiar with android, but I think that Extra works like a Map. You could create a Extension Function similar to this: /** * You could change the Map type to the desired type. */ operator fun &lt;T&gt; Map&lt;String, T&gt;.get(enum: Enum&lt;*&gt;): T? { return this[enum.toString()] }
Why do you need the String version of the enum at all? If you really just need some constants, then those are really the methods to do that. You are going to need a field name and value every time - unless of course you use reflection to fill in the value based on the field name, but please don't do that.
coroutine builders (like \`launch\`, \`async\`) by default use the \`CommonPool\` unless you specify a different dispatcher (coroutine context).
This is the answer: https://www.youtube.com/watch?v=_hfBv0a09Jc JetBrains guy who clearly helped define the feature stepping you through threads -&gt; async -&gt; promises -&gt; co-routines. It's an awesome vidoe.
If you are comfortable with Java, I recommend you look at [this talk from 2016](https://www.youtube.com/watch?v=4W3ruTWUhpw) on the *implementation* of coroutines. Knowing how they work will help you get a very clear idea of what they can and cannot do. Thinking of coroutines as somehow related to threads is misleading. They aren't, not really. There are APIs that can be used to make the two interact in useful ways, but that doesn't mean the two are intrinsically linked.
You can't avoid using threads in concurrent software ‚Äì either you or the runtime will have to handle them. Coroutines simplify your interaction with threads by doing most of the work for you ‚Äì you mostly just need to specify which thread/pool to use and the framework will take care of everything else ‚Äì which differs a lot from Java where you have to do all the work manually. **Disclaimer**: I am the author. I recommend you this book for people wanting to understand concurrency and coroutines better: https://www.packtpub.com/application-development/learning-concurrency-kotlin 
 class C(v: Int) { val v = -v }
Will we be able to use it on idea community edition?
I feel like with all the work on the Kotlin Native and the multiplatform (including native) Gradle plugins lately, they're closing in on a more cohesive build, which hopefully translates into Native in IDEA.
Still, it means buying CLion for a productive GUI debugging experience.
Yeah you forced to use Clion which ain't free and also one more program to install, conf. While free/ultimate intellij should be perfectly capable for this.
It is your business and your decisions. From my point of view you should equate how well that decision holds against C++20 + (Eclipse CDT, Qt Creator, VS Community, VSCode, XCode, Android Studio). After all it is not only grammar and semantics that weight when choosing a programming language.
When IntelliJ makes a suggestion like this, you can press Alt-Enter, and it will apply the suggested change automatically. The suggestions are tools to help you improve your code, not quizzes on how to perform some operation in Kotlin.
Well, yes, the other vendors have other sources of income, and JetBrains is a tools company, and selling tools is our only source of income. In terms of long-term sustainability, I think it makes more sense to trust Kotlin when it's clear what the business model behind it is, and not when it's just a huge investment into giving everything away for free.
I know that Kotin/Native is not mature yet for benchmarking, but how is this release comparing to Go (because it's also garbage collected) for example?
So will the official Kotlin Native IDE stay CLion or will there be another product in the future? Depending on this I would start licensing CLion (next to IntelliJ), but not if there will be a new product out soon ...
There will not be a new product out soon. Kotlin/Native development is fully supported in CLion and AppCode.
How about Ultimate?
What's your point in asking this question? "Not ready for benchmarking" means "no effort has been put into optimizing the performance of generated code". Therefore, if you make any conclusions based on the performance of the code generated by the current version, these conclusions will become invalid very soon.
I bought the ultimate version (1 year personal sub) so I was a littlebit disappointed. Idea had a plugin for native kotlin, but the development stopped at February. Now I have to pay extra for clion. This is alpha tech and the customer like me have to pay even more just to try it out. I know you guys have to make money and I will probably buy IDEA in the future, but removing this feature from the ultimate version is just kinda a dick move. Also its hassle too. The user have to install an other IDE instead of a plugin. 
I can't say anything at this time.
So the Eclipse plugin also won't support Kotlin/Native and Kotlin/JS?
You don't need to pay for CLion to try out Kotlin/Native. This offer is still valid: [https://blog.jetbrains.com/kotlin/2017/12/kotlinnative-plugin-update/](https://blog.jetbrains.com/kotlin/2017/12/kotlinnative-plugin-update/)
I wish the same thing could be done with data classes. 
This is fucked up. It will never reach the critic mass, and you are missing a huge opportunity here. You should give basic integration and plugin to community edition, and then sell the extra stuff with clion. The reason kotlin itself exploded was android and the free and great support for idea community edition. Make yourself and the world a favor, release the beast from the cage 
It depends on what type of company you want to work for. If the geographical area you want to work in. Software companies understand that a good programmer is a good programmer. Non-software companies don't get that and will want you to know a specific language and have lots of experience with it. If that's all that's available in your area then you're better off sticking to whatever language is predominantly used.
It will definitely not support Kotlin/Native debugging. As for basic support of Kotlin/JS and Kotlin/Native, this will likely be added at some point, but not soon.
Hello, this is possible, please use the following syntax: ``` &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt; &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt; ... &lt;configuration&gt; &lt;args&gt; &lt;arg&gt;-output-prefix&lt;/arg&gt; &lt;arg&gt;/path/to/prefix.js&lt;/arg&gt; &lt;/args&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; ```
Let's say I have a microcontroller that works with C/C++ via GCC and want to compile Kotlin native for this target, how do I make sure the target is correctly supported? It is an ARM target with a custom distribution of Yocto Linux.
We don't share time estimates, sorry.
Sick intro too.
Generally, linux_arm32 target is supported, and even almost OS-less configuration based Zephyr RTOS support is implemented. For existing C libraries interop layer can be automatically generated. Likely some additional work in supporting such configuration could be required.
The project I'm currently working on uses this SoC: [https://www.sierrawireless.com/products-and-solutions/embedded-solutions/products/wp8548/](https://www.sierrawireless.com/products-and-solutions/embedded-solutions/products/wp8548/) Basically it is an Arm cortex A5. The manufacturer provides a GCC-based toolchain that is generated through Yocto for their target architecture. Do you have additional documentation, or exemples I could follow to eventually add some components in Kotlin Native to my existing project? I would really love to eventually ditch C/C++ in favour of Kotlin but idk where to start.
Very cool! I haven't dug into building anything in Kotlin/Native yet, but I'm liking the vision. I'm very interested to see the long term impact of being able to integrate Kotlin/Native code into my existing Java/Kotlin work.
Will this compete with Rust?
Rust is a systems programming language, while Kotlin is an application development language. There are no short-term plans to go into systems-programming niche. 
That might be true. But one can learn another language or several at the same time without having to sacrifice anything. When it comes to Android, I'd say the language is the small part and the SDK and how to build apps the time consuming but part. Since it's the same SDK for Kotlin and Java it doesn't hurt learning both.
Thanks for the response!
I would think the closest comparison would be Graal Substrate VM? Am I correct in thinking the target uses cases would be serverless functions, short lived containers, command line utilities and mobile?
Thanks, I would have never gotten that myself.
Thanks, probably some extension function would be the best solution.
I prefer enum instead because I do not need to write the same thing twice.
Try Rx and if that doesn't do what you want then I recommend try the new Android JetPack Worker API, but I don't think that works for non-Android projects if that's what you have. 
OP asked how to do it with coroutines, not what other technologies he can use instead of them.
This is exactly the concern of the continuation interceptor. BTW [your crosspost on Stack Overflow](https://stackoverflow.com/questions/52216814/kotlin-implementing-a-central-call-stack-for-async-coroutines) for reference.
I think writing a custom continuation interceptor based on CommonPool would be a good idea. Do you know where I can find out more about this? The official docs on the continuation interceptor or the coroutines life cycle is quite... terse. More specifically, I need to know which function receives "onSuspend", and how to ensure that "onResume" on the suspended coroutine occurs before "onComplete" of the awaited coroutine.
I hope this doesn't come off as too jerkish, but come on at least Google this stuff: https://github.com/Kotlin/kotlin-fullstack-sample
With a risk of being downvoted.... instead of doing what you are talking about have you thought about ways to simplify your process? Maybe adding a record to an in-memory data structure, or to a file/db? Using the java.concurrent latches or atomic counters. Using a queue and pushing work into it. etc etc. &amp;#x200B; Trying to chain together async functions with any tooling/language always feels like a bad idea to me. The number of failure points becomes high and you have many different combinations of things that you will need to check for and be aware of.
There's some talk about what IDE's Kotlin/Native will be done in and I was just thinking that since Kotlin has all these different branches (JS, JVM, Native, multiplatform, and Gradle plugins, and even Gradle scripts done in Kotlin, and Kotlin debuggers, etc) I was just thinking that perhaps there could be a single IDE that is made specifically for Kotlin. But of course, it would probably have to be mostly just JVM and JS with paid extensions for various other features, especially if you want people to use kotlin, you could definitely create an IDE to promote Kotlin by putting it all into one thing right? And maybe that way, kotlin development could also be a lot faster (compiling, intellisense, code analysis, debugging, building, deployment, etc) since the IDE is specialized for kotlin while WebStorm is specialized for web development and then there's PHPStorm which is specialized for PHP when you could just do that in WebStorm as well. I dunno just a thought.
Nice what do you use for the UI?
Nice what do you use for the UI?
Nice what do you use for the UI?
Nice what do you use for the UI?
the real question is, can it crack [this sudoku puzzle](https://www.telegraph.co.uk/news/science/science-news/9359579/Worlds-hardest-sudoku-can-you-crack-it.html)
I don't think you can do exactly what you're asking, you could use a reified type parameter to accomplish it. BUT here's the question: Why? What are you trying to accomplish? Because it would just be simpler to use a constructor with your code or mine? If you said what you are trying to accomplish, we might be able to give you some other suggestions. abstract class AbstractItem class FirstItem: AbstractItem() inline fun &lt;reified T: AbstractItem&gt; newInstance() = T::class.primaryConstructor!!.call() fun x() = newInstance&lt;FirstItem&gt;() 
sounds like an XY problem. what's your use case? the answer to your problem will probably be to use some form of dependency injection.
\&gt; i would have a server backend \&gt; An HTML/JS client for the front end yes, pretty much the way i'm currently using &amp;#x200B; \&gt; look into Progressive Web Apps will take a look, thanks
Companion objects are not inherited. However, they're objects, which means \*the companion object can use inheritance\*. What you're trying to do is called a "factory pattern." You can actually just use an interface instead of an abstract class. ``` interface FactoryCompanion&lt;T&gt; { fun newInstance(): T } class FirstItem { companion object: FactoryCompanion&lt;FirstItem&gt; { override fun newInstance() = FirstItem() } } ```
TornadoFX, a Kotlin desktop UI framework built on top of JavaFX [https://github.com/edvin/tornadofx](https://github.com/edvin/tornadofx)
Affirmative, it takes about 2 minutes though.0 I uploaded a video here and thanks for posing a challenge. [https://www.youtube.com/watch?v=BVNiZzvCHnw](https://www.youtube.com/watch?v=BVNiZzvCHnw) &amp;#x200B; &amp;#x200B;
I'll trust you on that, though the related youtube videos pop up with about 22 seconds left and block off the solved board.
Removed the popups, sorry.
thanks, that's awesome man I made a sudoku java thing myself a few months back, but that Finnish fella's puzzle was beyond me.
Have you already tried suspendable functions for this? They are exactly as cumbersome as using a blocking API. Most users don't even know they are making blocking calls, the same applies to `suspend fun`s. Error handling works through the good old `try-catch`. The only gotcha if you're working on Android (or any other GUI framework) and launching coroutines from event handlers, is that the ordering you got used to (all handler code completes before anything else happens) is fundamentally gone once you go async. You must deal with your code having become concurrent.
[Here's a good resource](https://stackoverflow.com/questions/51566006/how-to-suspend-a-coroutine-at-a-specific-point/51568707#51568707) on Stack Overflow that can help you understand the under-the-hood perspective. It's incredibly lightweight and non-magical, it really pays off to understand it. In a nutshell, when you declare a `suspend fun`, Kotlin compiles it to Java bytecode so that it takes another implicit argument: a continuation object. Calling `continuation.resume(result)` is just like returning `result` from your function: the code that runs is exactly the same as the code the calling function will run after getting your result. The compiled `suspend fun` always has `Object` as the declared return type, this is because it may return a special marker object, `COROUTINE_SUSPENDED`, which signals to the caller that you got suspended. The caller will react by suspending itself and returning the same marker to its caller, and so on all the way to the `launch` or `async` statement that started the coroutine. In the sample code on the Stack Overflow answer I linked to you can see how the `suspend fun` saves the continuation object and makes it accessible to other code that can resume it later on, with the effect of jumping right back into the point where it got suspended before.
The library is https://github.com/jasync-sql/jasync-sql. The main goal for this project is to implement simple, async, performant and reliable database drivers for PostgreSQL and MySQL in Kotlin. This is not supposed to be a JDBC replacement, these drivers aim to cover the common process of send a statement, get a response that you usually see in applications out there. So it's unlikely there will be support for updating result sets live or stuff like that.
No, but logically performance is lower but development speed is higher..
Why "logically performance is lower"? Can you please elaborate or provide a reference.
There was a post on this sub that talkrd about performance, and the TL;DR is that Kotlin is slower (but not by much) if you use the things that make it differrnt from Java. For example, `for(i in 0..10)` is optimized to a standard for-loop, but `range = 0..10; for(i in range) /* ... */` isn't, because Kotlin needs to create that range object to define `range`. Also, companion objects with private functions (including property getters/setters) introduce synthetic methods so that the containing class can access these now-inaccessible methods, which adds overhead. Ultimately anything you lose in performance by doing things a Kotlin-y way can be solved by rewriting it into the Kotlin that generates the same bytecode as your Java (lots of `@JvmStatic`). Development speed should be at least as high as Java, since terse readable code is one of the language's central features. Source any of the testimonial blog posts here from companies who have switched. Kotlin rids you of most NullPointerExceptions and makes the remaining few it can't catch easier to debug by giving them actual informative messages. Safety is definitely a plus. Language future? JetBrains doesn't look like it's going to fold anytime soon and Google has introduced first-class support for it, so Kotlin is certainly not dying. 1.3-M2's inline classes and the newtype pattern they enable are performance and safety boosts, respectively, so you can expect more along those lines in the future. The learning curve for Kotlin is very shallow, especially for existing Java devs. I would expect an experienced Java dev to be able to complete the Kotlin Koans and be up and running with a good-enough understanding of the language in an afternoon.
Could you please share links to companies experiences? 
&gt;companion objects with private functions (including property getters/setters) introduce synthetic methods A synthetic private method inserted into the call chain induces almost no overhead in anything except a 100% interpreted runtime. Even an ahead-of-time compiler will trivially catch the opportunity to inline such a call. It's a non-virtual call site. About your example with the `range`, there's a flip-side, too: you can use `list.map()`, `list.forEach()`, etc. as zero-cost abstractions due to `inline fun`s which are guaranteed by the language semantics that they'll inline your lambda code. Therefore no lambdas will be created. Any such idiom in Java will create a lambda creation site, involve a synthetic lambda factory, the creation of an actual lammda instance, etc.
You may have gotten your view from seeing some other examples of higher-level languages that pay their beauty with performance. It's definitely the easiest route: just dream up some cute abstraction and then let the "future advances in compiler technology" take care of performance. Kotlin is an example of the opposite: very carefully chosen abstractions that capture the best practices distilled over decades of experience with Java. `inline fun`s, specifically, are an abstraction that brings a _speedup_ compared to Java's higher-order functions and lambdas.
Here is an article that compares safety (note that safety is a language concern in this case so all points apply equally to Android &amp; backend): https://proandroiddev.com/kotlin-avoids-entire-categories-of-java-defects-89f160ba4671 Regarding performance, it depends on which features you use. The spread operator is slow (if you use varargs alot) and lambdas (especially inlined ones) are much faster in Kotlin and lambdas are used all over the place. Source: https://sites.google.com/a/athaydes.com/renato-athaydes/posts/kotlinshiddencosts-benchmarks This article compares development speed: https://proandroiddev.com/kotlin-a-massive-leap-forward-78251531f616
[Here's](https://sites.google.com/a/athaydes.com/renato-athaydes/posts/kotlinshiddencosts-benchmarks) an in-depth review of Kotlin's performance, a critique of an earlier writeup, which shows that Kotlin is on par with Java and in some cases beats it.
Oh inteesting, the article implied synthetic methods were heavier on performance in some way. Thank yoy for the clarification.
What about competing with Go? I find Kotlin to be a far superior language (obviously), but what worries me about KN is the build speed, which seems really slow.
Android is kind of special here though. Its runtime performs differently especially on old versions, and reducing method counts is a good idea in general
I want to touch on language future because a senior dev who interviewed me made an interesting point and I want to see what others think. He asked me, why did you use kotlin for this side project? I told him no real reason, nice syntax and was sick of writing Java at the time. He said he‚Äôs asking just because he sees all these boutique languages popping up and he‚Äôs not sure why they‚Äôre necessary to use. He made the point that he wrote Java code on some server almost 25 years ago and that it‚Äôs still running today. That Java is our generation‚Äôs COBOL. He said that our responsibility in software is to longevity and legibility for future devs. He said, show me a Groovy developer in 30 years, let alone a compiler. But he knows there will be a Java one. Thoughts?
Personal experience - team of one - corporate app. I have not seen any performance issues but I am doing standard CRUD development. Make REST call, show data, edit etc. Retrofit + OKHTTP for REST calls. Development speed. I feel I am faster. Can't measure that feeling. Language is just easier to write what I am thinking. The more I learn the faster it goes. Co-routines make many things so much easier and cleaner than any Java code I wrote. Extensions are a big bonus as well. Safety. I really like the much easier null checks, var vs. val, etc. I write more defensive code because the language provides so much of the null checking for "free" if needed at all. My Flurry / Play Store logs show things running very clean. Language Future. Always a crap shoot here. I was using Kotlin before Google officially announced it as a first class language. There is always another language around the corner. Kotlin has solid support, I use it, if I have to switch again I will. Not like I totally forgot how to use Java. Not like I will never need to learn another language. I can also read the Swift code the iOS dev writes as it is similar to Kotlin. Can't say that as much about ObjC -&gt; Java. I have done both of those as well. Learning Curve. Started new job doing new Android project which was make an Android version of existing iOS project. I gave myself 2 weeks to either be decent at Kotlin or go back to Java as they needed the conversion done fast. I have been in Kotlin for the past 18 months. First version was very Java like but I have converted to be more Kotlin pure (don't know how else to say that) as time as gone on. Still more for me to learn. Started out doing Java to Kotlin conversions of code, did not take long to just type Kotlin code from scratch. Sure has heck don't miss typing semicolon anymore.
Those are all good points but at some point java was the hot new language and why would you write in java instead of c++/Perl etc 
Did you wrap XML layout for your activity in &lt;layout&gt; tag?
I think calling Kotlin a 'boutique' language underestimates JetBrains influence, their existing achievements and intent for the language. Kotlin has already gone beyond niche status with first-class language support for Android and tight integration into two of the most popular IDE's today (IntelliJ and Android Studio). The integration with the Java ecosytem is so well designed that developers who I've introduced to the language do not quite believe it could be that seamless until they've used it.
Well, Kotlin functions are objects regardless of personal background. Looking at them as such is just another angle on the subject, one that I (coming from Java) find useful. &amp;#x200B;
That was my response to him, actually. Still made me consider ‚Äúwhy kotlin‚Äù?
Look up Java 8 functional interfaces. Basically this mechanism is so that you can use lambdas or function references and have them act as legacy interfaces that match the requirements of a functional interfaces (an interface with only one method defined). I am not sure if this makes it easier for someone familiar with OO, but it makes lambdas and function references backward compatible.
The JVM doesn't support standalone functions/lambdas, every bit of code has to be inside a class. Lambdas/Top-Level functions are just syntactic sugar. The same applies to extension functions
Well, they're syntactic sugar optimized by the escape analysis tool, to be fair
Good article but the author fails to mention where scoping functions really shine: Interfacing with Java code. \`apply\` e.g. makes working with Java Beans a breeze: public class Person { private String firstname; private String lastname; // more fields // getters + setters } Calling this from Kotlin Person().apply { firstname = 'Ash' lastName = 'Williams' } &amp;#x200B;
Because on Android, at least, you're stuck with ancient version of Java. It's very different using outdated version like 1.6 or 1.8.
Didn‚Äôt realize that. 
It is a bit more interesting then that. The following is valid and not JVM specific object f : (Int) -&gt; Int { override fun invoke(n: Int): Int = 0 } This means that the machinery for class/object definition can be used for defining functions. You don't **have** to use it but it is there for you. For example, here is a function that implements two interfaces: object g : (Int) -&gt; Int, (Int, Int) -&gt; Int { override fun invoke(n: Int): Int = n+1 override fun invoke(n: Int, m: Int): Int = n+m } and you can call: g(1) g(1,2) 
I'm not sure how I feel about this, although it'll probably benefit me in the long run.
If you decompile the code (using their provided tool in IntelliJ) you will find (Int) -&gt; Int is a subclass of Function&lt;Integer, Integer&gt; which makes sense they way they let you have a reference on them or invoking them, and the sample code you provided is a subclass with multiple interfaces inheritance 
Nice! I had to write multiple extension functions to do the same, this will make things much simpler. He did not talk about exception handling, can a coroutine scope define it's own exception handler 
Is this going to be live when the experimental flag is removed?
I'll come back on stable release, Rxkotlin works well
Yes
Stable release is coming soon.
what about supervision and other advanced use cases, specially on actors? I had to chose between Akka Typed actor and coroutine actors and prefer yours because it is easier to use blocking code safely on coroutines and they are obviously easier to write in kotlin, but there are some patterns that I miss (mainly adaptors and supervisors)
I commented something about that here: https://www.reddit.com/r/androiddev/comments/9f8arr/_/e5vhop2
I saw the global scope stuff, but I'm more curious if my current method of making coroutines lifecycle sensitive is okay until I can use the new scopes. 
I was talking about the example in the docs. I was using something similar to your method, but switched to implementing `CoroutineScope` as well as using a parent `Job` and it's been working well.
Thanks for the links. This really makes me sad. 
Nice thought, i wasn't aware that it is, but yes, it seems so :)
Try https://github.com/s1monw1/KtsRunner - run it under the standard java script engine? 
Isn't this a bit old? IIRC Android Studio now supports Kotlin out of the box......
We are working on better and more powerful actors. Please, post your use-cases to https://github.com/Kotlin/kotlinx.coroutines/issues to make sure we take them into account
This account seems to be spamming the sub with low-quality vids.
I'm somewhat surprised that they're doing another 1.2.x version when they've already released a few 1.3 milestones.
If non-breaking changes are ready, why not ship them? 
Super happy to see them doing incremental fixes for 1.2 when they have 1.3 in roadmap
I just figured they'd probably be rolled into 1.3, since it seems to be well on its way to release.
\[Official release notes\]([https://blog.jetbrains.com/kotlin/2018/09/kotlin-1-2-70-is-out/](https://blog.jetbrains.com/kotlin/2018/09/kotlin-1-2-70-is-out/))
I'm still waiting for the override functions to get proper naming instead of position to be named p0
I'm just saying that I'm somewhat surprised that these were released as a separate 1.2.x version instead of releasing them with 1.3.
I wouldn‚Äôt expect a merge like that to get messy even if it were giant as there wouldn‚Äôt be many 1.2.x changes that won‚Äôt be in 1.3
&gt;Without a doubt these improvement will also be part of 1.3, I don't see what you're getting at? &amp;#x200B;
I was replying to a previous comment. 
Many, any... either way there‚Äôs no reason for there to be any ‚Äúmessy‚Äù merges as the comment I was replying to indicated. If you have two independent branches of code both with lots of changes, over time, merge conflicts can be introduced. However (and this is what I was getting at) that doesn‚Äôt apply here because it‚Äôs an incremental version. There‚Äôs no reason to introduce functionality in 1.2.x that won‚Äôt be in 1.3 so even if 1.3 couldn‚Äôt be rebased on top of the 1.2.x branch for some reason, there‚Äôs no reason why the merge would be ‚Äúmessy‚Äù
Awww!!! isn't it? I found it quite useful for beginners that's why I am sharing it with them. But.... Look at you who you are..!! And remember one thing whenever you point one finger towards someone than there are three fingers towards yourself.
That happens when you don't have the sources of the overwriting functions.
But variable names are still stored in bytecode, right?
No not always - only since Java 8 with a parameter that is enabled by default afaik. If they are missing, nothing can be done.
does it introduce compile times of less than 10 seconds for hello world?
I'm a bit sad that JetBrains doesn't improve the REPL. It could be a useful tool -- and it is in other languages like Ruby, Python, Scala ... and even Java -- but the quality is so poor that it is hardly usable.
Great read! Thanks for sharing :)
Tailcall?
Dont know Kotlin but love puzzles. Let's try )
Tailrec?
Does the puzzle have the answer already or it is open ended? :)
The article starts by explaining the challenge and then walks through the thinking process and iterates towards the solution. However, you can stop at any time to try to solve the rest :)
I'm not positive but wouldn't it run f() then that will return true which isnt null so it just goes with it...
Right, that is indeed what appears to be happening. `(g() ?: h())` is never evaluated, despite the outer parentheses. So, given that, I'm curious, what is the appropriate terminology to describe the associativity (?) of the Elvis operator? 
The elvis operator only evaluates the right side if the left side is null. The intended purpose is to compute a default value only if the left side is null. If you want to test the order of evaluation of chained Elvis operators, try making every function return null so that it's forced to attempt all possibilities. fun printAndNull(s: String) { print(s + " "); return null } println(printAndNull("a") ?: printAndNull("b") ?: printAndNull("c")) // a b c null println(printAndNull("a") ?: (printAndNull("b") ?: printAndNull("c"))) // a b c null println((printAndNull("a") ?: printAndNull("b")) ?: printAndNull("c")) // a b c null
Thanks for your reply, but my question is really about terminology. Given what you describe, is it correct and proper to say that the Elvis operator is "associative?"
I'm not sure associativity is the correct word... it always evaluates the left and if its null it will do the right
Yes, `(a() ?: b()) ?: c()` and `a() ?: (b() ?: c())` evaluate the same way (both in terms of return value and side effects) for any a, b, and c. - If a() is not null, only a() is evaluated and the result is a() either way. - If a() is null, then the right-hand side (`b()` in the first case, `(b() ?: c())` in the second) is evaluated. If b() is not null, then a() and b() are evaluated and b() is returned. - If (and only if) a() and b() are null, either way, all three are evaluated left-to-right and c() is returned.
Thanks, that was enlightening to learn that in the case of `(f() ?: g()) ?: h()`, it's actually the second Elvis operator that's evaluated first.
I understand, i play the game :) 
Toolset is rapidly growing. In one point in the life programmer finds out he cannot keep up any more. He finds the job to support outdated codebase. This is the way to protect his status quo. It just happens. &amp;#x200B;
Okay, i've read the intro. I think you want to use some sort of macros, inline or the compiler plugin.
accidentally read to the first solution. That's smart ) thanks god i don't need to do such low level solutions IRL ) If the database(or something highly optimized) developer job was so fun as task like this, i would go for it for sure
OP. thanks, it was fun )
That might apply in general, but Java is not outdated. You‚Äôre being a hipster
You can perhaps find [http://www.vaadinonkotlin.eu/](http://www.vaadinonkotlin.eu/) to your taste. It's generally two things: Kotlin bindings for Vaadin, and support for storing stuff into the database. There's a tutorial which will guide you slowly from the very beginning: [http://www.vaadinonkotlin.eu/gettingstarted.html](http://www.vaadinonkotlin.eu/gettingstarted.html)
The opposite of `desaturate` is `saturate`, not `brighter`.
I mostly agree with him. In order to entertain themselves developers put in boutiqie languages that entertain themselves but cause a nightmare for the next developers who have to work on it. Kotlin is a bit better for 2 reasons: - It starts out trying to be Java but improved, rather than completely changing the paradigm code is written like other langiages. In other words "java but cleaner". - It's officially endorsed by google for android development so the odds it will be around decades from now go up dramatically. It's still a concern though, and ehy I've been dragging my feet regarding starting a new project with it. No ststic methods and the approach of trying to throw everything including the kitchen sink into it are drawbacks to me. I don't like languages where there's 8 ways to do the same thing. 
&gt; I don't like languages where there's 8 ways to do the same thing. Especially when intellij prompts you to change it to one way, and then prompts you to change it back to the way you had it before.
Kotlin has an excellent framework to build cross platform desktop apps, it's very nice to use and built on JavaFX. Link to the project : [https://github.com/edvin/tornadofx](https://github.com/edvin/tornadofx) Docs: [https://edvin.gitbooks.io/tornadofx-guide/content/part1/1.%20Why%20TornadoFX.html](https://edvin.gitbooks.io/tornadofx-guide/content/part1/1.%20Why%20TornadoFX.html) Happy coding.
I don't see that anywhere on the github page. Are you sure you are looking at the right project?
Second tornadofx I had an issue and asked a question on stack overflow ( it was a rare time a question on SO wasnt called a duplicate lol ) and the creator replied and made quick fix to the framework to fix my issue. Really amazing team behind it
the way you talk about nosql makes me question your decision to use it. when you say you prefer nosql, do you really mean you have more experience with mongodb than sql databases? are you sure it's the right decision for what you're doing?
SQLite is the way to go for local storage, or even just a txt file in AppData would work depending on what you're doing
This is very much work in progress, so I'd welcome feedback
What do you need to store? It entirely depends on that. Using MongoDb to store user settings is a complete waste of time and resources.
This is bit of a convoluted way to do Pagination. The presence or absence of a link in the payload to the next page would prevent an unnecessary network call to get an empty list. And storing a session with the last called ID in order to calculate the next page is not exactly stateless. If you just return links to the next page or use offsets that are actual numbers there‚Äôs no need to do this.
As I stated in the post, this is just one of many ways to implement the basic concept. Based on the real-world trade-offs, different things will make sense for different setups. I agree, that a flag indicating if it's the last page would probably be worth it in any case, as it's not much more complexity and is guaranteed to save at least 1 additional call. I added a paragraph for why the ID is actually important this morning and why offsets can be problematic. If you just use offsets, you could get duplicates or lose entries, if in-between two calls a delete or an add happens. So you would need to either snapshot the whole data first (or at least the id's) and keep that state, or find another way to tackle this issue.
Well, I haven't used Mongodb, which is why I'd like to try to use it. I want to be more familiar with it. But I haven't decided yet, just looking into options and possible integrations here. I may end up using AppData or sql
Now at v0.2.0 supporting immutable fixtures
There is some [official doc](https://github.com/Kotlin/kotlinx.coroutines/blob/master/reactive/coroutines-guide-reactive.md) about this.
Good point. Thanks, everyone!
Unless I am missing something how is this solving those issues with offsets. The cursor value you are storing against the UUID is basically just the offset anyway. You would still get similar issues if you were to remove users from the list mid-scroll.
Inference is lying to you: ``` val list1: List&lt;Array&lt;Int&gt;&gt; = listOf(arrayOf(1,2,3)) val list2: List&lt;Int&gt; = listOf(*arrayOf(1,2,3)) val list3: List&lt;List&lt;Int&gt;&gt; = listOf(listOf(1,2,3)) ``` So when you go and do these the types don't match: ``` class IntList2(vararg values: Int): List&lt;Int&gt; by listOf(values) // List&lt;Array&lt;Int&gt;&gt; class IntList4(vararg values: Int): List&lt;Int&gt; by listOf(arrayOf(1,2,3)) // List&lt;Array&lt;Int&gt;&gt; class IntList5(vararg values: Int): List&lt;Int&gt; by listOf(listOf(1,2,3)) // List&lt;List&lt;Int&gt;&gt; ``` Now, this one I don't really know, it may even be an error in the compiler because it cannot determine the size statically or something: `class IntList3(vararg values: Int): List&lt;Int&gt; by listOf(*values)`
You're absolutely right about the rest-part. It's not stateless, so it's not REST - It's just such a habit to put things in such a schema, so I didn't even think about it when I wrote the example :D That's what I meant in the post when I said that there is a decision to put the state on the client or the server. If you want guarantees on not missing anything by deletes, one of the sides needs to remember an identifier.
Technically I would understand coroutines as one level below reactive. So it would be possible to implement the scheduling of reactive frameworks with coroutines. But rxjava offers much more than that and depending on what you use it for you might not be able to replace it completely 
It really depends on how you use it but it has the capability of replacing reactive. 
Make sure to read this official guide https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md
This looks great! Bookmarked to read with my morning coffee, in the hopes that some of my control engineering degree comes back to me... :-D Thanks! 
This is pretty awesome.
You can execute code in scratch files now. Would that be a good alternative for you?
I did an experiment: `class IntList3(vararg values: String): List&lt;String&gt; by listOf(*values)` That is valid. So the problem isn't the spread, just that `vararg` of int is `IntArray`, which is a different type than `Array&lt;out Int&gt;` because the former is an unboxed basic type. tl;dr congrats, you found and edge case of the compiler
It‚Äôs a shame when the conclusion is ‚Äúthis is good thing, but not enough people use it, so neither should you,‚Äù but in this case I think it‚Äôs fair. I‚Äôve just spent 5 hours trying to get publication to Maven working with the DSL, hampered by lack of examples, breaking changes between versions, and just plain bugs. 
Scratch files are not much more useful than usual Kotlin files for me. A good REPL, that could be started independent from IntelliJ what be really useful.
Did you reach your goal then finally? A detailed example with code would be nice :)
Thanks for sharing your experience! My experience so far is also not the best - the IDE performance is not really good, things sometimes hang for 1-2 seconds, although I didn't encounter your minutes-long import times. Code completion is a bit worse than regular Kotlin projects, but nothing I would complain about after struggling with groovy autocompletion since ever. From my point of view, if someone is able to understand the groovy concepts of how gradle dsl works, it's very easy to translate them to Kotlin - as soon as the person is profound in Kotlin as well. Of course, with gradle one has to read source code of the gradle API very often, but hey, why not this way. Consuming a java API is as easy with Kotlin as it is with Groovy (And most things in gradle are somehow mapped/extended for Kotlin). Anyone other experiences here?
You can make a fat jar that has all the dependencies, and you can also make native packages using `javapackager`. I just made a mac app with tornadofx, so I can point you to my pom.xml (assuming you're using maven), or there might be better resources now that you have a starting point for googling. Also TornadoFX has a very friendly and helpful slack channel. I don't make GUIs very much and they went above and beyond to help me out.
This is definitely going to be a superb tool in the future but I have a pragmatic approach and I also optimize on time so I'll pick this up when Gradle 5 comes out.
My point was that I'm already proficient with Groovy + Gradle and when I'm not there are tons of example codes on the internet. This is not (yet) the case with `kotlin-dsl` which will definitely change! So I'm planning to take another look after Gradle 5 comes out. I'll definitely adopt `kotlin-dsl` in the future, that's what I was trying to say.
And now with a much better readme, so it may make sense now
looks very similar to r/https://spekframework.org/core-concepts/
I find the `plugins` section still inconsistent. It is okay to have a abbreviations for built-in plug-ins, but to have a completely different syntax outside of the _plugins_ block doesn't make sense to me! plugins { java application } apply(plugin = "checkstyle") Why not something like this: plugins { java application plugin(id = "checkstyle") plugin(id = "jacoco", version = "1.2.3") } The syntax to create tasks involves to much magic just for being DSLy: val docZip by tasks.creating(Zip::class) { archiveName = "doc.zip" from("doc") } This leads to especially strange code in the `bootJar` example: tasks { "bootJar"(BootJar::class) { archiveName = "app.jar" mainClassName = "com.ninja_squad.demo.Demo" } "bootRun"(BootRun::class) { main = "com.ninja_squad.demo.Demo" args("--spring.profiles.active=demo") } } Why not simply use an object or factory method to creat tasks? object docZip : Zip(archiveName = "doc.zip", from = "doc") val docZip = task&lt;Zip&gt;(archiveName = "doc.zip", from = "doc") Further configuration could be added in the object body or passed as an anonymous function to the factory method. However, I appreciate the move to Kotlin, since the Groovy DSL allows way to many strange things.
What I miss from your article is, that you softly critisize that some code snippets can't be just copied and pasted and work and one has to take a look at documentation and interfaces and code of plugins - the reason is most often groovy's dynamic nature that comes with a big price, namely missing compile time safety and easy to understand logic. Converting existing groovy code to Kotlin may be some work, but it's not just conversion...it's enhancement, because you now have static compilation. This is the single most important difference and the reason why switching to Kotlin makes sense here. But I'm nitpicking here, sorry :)
You can make type safe DSLs quite easily in Groovy (using `@DelegatesTo`) but yeah Gradle doesn't use that. Maybe because it was only added 5 years ago (Groovy 2.1) and Gradle is almost as old as Groovy itself.
I must say that I disagree with the conclusion presented in the article. After having moved our production projects for Android and Java/Kotlin development to Kotlin DSL the experience so far was way better and cleaner than with Groovy. Disclaimer: I have not encountered the unresponsiveness issues you describe and building speed is not much different from Groovy times. The main disadvantage of Groovy as a DSL language is that it is dynamically typed. This is the very reason why the IDE cannot support it well since it has no way of figuring out what black magic is gonna happen at runtime. This is also the reason why copying code from the internet to solve issues is very hard for Groovy. There are 15 ways to express the same thing and 15 different things can be written using the same syntax. This means that every person writing Groovy has a different style. Thus when you take code from the internet you are forced to refactor it or risk an unmaintainable Frankenstein of a build script. Just reading the code is also a chore because the freeform syntax + dynamic nature does not lend itself well to making assumptions and reason about the code. In my experience I would have to read source code anyway because just looking at the usage was not enough to understand it. In conclusion the powerful features and support for Kotlin are inherent to the fact that Kotlin is statically typed. The amount of time saved during build script maintenace by using Kotlin DSL for Gradle is already noticeable. And it helps understand what the script is doing and how it can be extended. The only pain point I have encountered so far is the interop with Groovy because you have to jump through some hoops when mapping dynamic features to be used in static code. This is the reason for all those ugly \`by\` constructs. In my opinion \`kotlin-dsl\` is production ready and has several major advantages compared to Groovy. The docs were just enough for us to make the transition and will only improve from here on out. Not everybody will be happy porting any sized project right away but I encourage you to try it at least when starting a new project. PS.: Here is a better and more in depth explanation by a Gradle principal engineer why they are embracing Kotlin: [https://melix.github.io/blog/2016/05/gradle-kotlin.html](https://melix.github.io/blog/2016/05/gradle-kotlin.html) 
Yes, I know that. But every of Groovy's attempts to be a static language feels awkward and their users usually tend to not use this paradigm, whereas with Kotlin this is the default and no way around it. It also feels much more natural, for example in Kotlin there's no need for this annotation because it's already in the Java types as it should be. Kotlin's gradle DSL also adds a lot of typing with generics etc which makes **your script** safer, regardless of what plugins etc you use. So I think that's a big difference in this regard, although I understand that theoretically gradle itself could have been enhanced in order to support better groovy, instead of/additionally to Kotlin support.
Good point well made! This [https://github.com/dmcg/minutest/blob/master/build.gradle.kts](https://github.com/dmcg/minutest/blob/master/build.gradle.kts) is currently working against Gradle 4.8, but I think that 4.10 breaks it.
Yeah, I agree with the gist of what you say. There's little point in using a duck typing language if you want 100% type safety. But, even just making the base Gradle DSL typesafe would have given you a lot of the features people mention though (like better IDE assistance). Which syntax is more "natural" for declaring/using the DSL is a matter of taste, while you might dislike having to type `@DelegatesTo` (and most would agree with you) I think there are certainly times Groovy has Kotlin beat as well. 
Nice! Thank you very much for sharing you point of view on this subject. It is very interesting.
I have no programming experience with Android. Maybe that's the difference? But anyway, fair enough. Different people have different tastes. I'm not saying that `kotlin-dsl` is crap per se, far from it! I'll definitely use it in the future.
I'd suggest opening some issues for them. The project is [on GitHub](https://github.com/gradle/kotlin-dsl). Maybe they will see that this is a better approach.
In my **opinion** "bolding" **random words** is **annoying**. Seriously, tone the word boldness a bit down, while using bold words to highlight phrases is good, if you highlight almost every "important" text, then nothing will be deemed "important".
You're right. My bad :) 
Thanks. What is it that breaks?
Well, that's a good idea!
But if you *italicize* words you get the required emphasis **without demanding too much attention**.
Im having some real joy with [javalin](https://javalin.io) For more full fat and high performance go [jooby](https://jooby.org/)
Was hoping it was gone, but still there. I stopped reading after the second paragraph, sorry about that.
What prevents you from using a simple while-loop? This would resolve the recursion, though I don't have an idea why the execution stopped.
There was a ton of changes between 4.9 and 4.10. 4.10 is rc3 of kts support. The Gradle community has been rallying to update docs to include sample parity with groovy. Lots of bug fixes have come of it. Get out there and give it a try. It really is a great experience once you break your brain enough to get things working. But be sure to bring up pain points, it's all up in GitHub and there is a gradle-community slack to talk as well.
What do you want to tell us with this statement? :) Writing Java is exactly what Gradle users don't want - they want a nice-to-write (for them), concise language... which is groovy. Or Kotlin :P That's the whole point of it.
both branches of your if statement result in calling initEmailer... so its never going to exit out of the function causing a stack overflow. With recursion you need a branch that actually returns
 We use this Gradle Script plugin for all our Android projects. 
pretty awesome doesn't even begin to describe working with ktor! fun, easy, reliable, performant
+1 for jooby !
+1 for javalin
Spark is the simplest of your options, it pretty much only does routing. I'm one of the maintainers of Spark, and I'm working on a similar project called [Javalin](https://javalin.io) which has a lot more features. Vert.x is an event driven and is very well suited for applications where performance is critical. It's more complicated to setup than Spark, so IMO it's not worth it for your 50 users. Vaadin is very different from the two other options. It's a framework for writing rich web-apps completely in Java (Kotlin), so you don't have to create a HTML/JavaScript frontend yourself. This is often a bad idea, you should only use Vaadin if you know that it's a good fit for your project. 
We use this library for all our Android projects.
good job. thanks 
https://www.http4k.org/
I've been knee deep in multiplatform recently and there's quite a radical change coming with 1.3, check out [https://github.com/h0tk3y/k-new-mpp-samples](https://github.com/h0tk3y/k-new-mpp-samples) &amp;#x200B; Best part I think is the ability to distribute multiplatform libraries via maven, in fact im working on one now: [https://github.com/TeamHubApp/RxKotlinMultiplatform](https://github.com/TeamHubApp/RxKotlinMultiplatform) \- not on maven yet but goal is to expose the rxjava interface for Kotlin code that will 'just work' in JS by plumbling into rxJS 
Yes :) We will update the project to use the new multiplatform project model as soon as we can. Other great feature is the ability to "share a part of code between only some of the targeted platforms rather than all of them (for instance, there can be one part for JVM, JS, and Native and another piece shared only between JVM and JS in the same project)"
Seems I'm *really* late to this thread, but perhaps you'll see this anyway, and this thread shows up pretty high on google. If writing a new REST API using Spring (which seems to default to Jackson) would it be worth the switch? I'm pretty new to both Kotlin and the JVM as a whole, so still getting used to many things. It just seems that Jackson is unnecessarily verbose even when serializing tiny objects, like a map with a single key-value pair.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [Kotlin 1.3 RC is Here: Migrate Your Coroutines! \[x-post from r\/Kotlin\]](https://www.reddit.com/r/programming/comments/9hhjnh/kotlin_13_rc_is_here_migrate_your_coroutines/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Great writeup! My one critique is that the wording, particularly this bit, would lead one to believe that a property has to always have a field: &gt; * read-only property = private field + getter &gt; * mutable property = private field + getter + setter In reality, you can easily have a property that doesn't have a backing field at all: fun calculateText(): String = "Hi" class Foo { var bar: String get() = calculateText() } The fact that everything is getters in setters, and fields are only actually compiled in when needed, is part of why Kotlin is so great to work with!
Coroutine launch is shown deprecated. What's up with that? Which coroutine version is compatible with this version? 
&gt;https://medium.com/@elizarov/structured-concurrency-722d765aa952 I didn't get what is the downside of using `GlobalScope` inside an object. Maybe cause to invoke our suspend function in a wrong thread?!
The compiler will error on functions that return `Result&lt;A&gt;`, but not on functions that return a `Generic&lt;Result&lt;A&gt;&gt;`
Most of these are libraries, not sure if it helps: https://github.com/KotlinBy/awesome-kotlin
The point is to properly scope them. So you make all your variables global?
Yes the second way allows to model domain better, but assume that I have some error types which is same among all entities. So to avoid extra boilerplate, I make an object that wraps my result value and error types: ```kotlin sealed class Result&lt;out T : Any&gt; { class Ok&lt;out T : Any&gt;(val value: T) : Result&lt;T&gt;() sealed class Error : Result&lt;Nothing&gt;() { object NetworkError : Error() sealed class FeatureError: Error() { } } } ``` So, now I'm doing the second way but It's not have such different with first way.
Thanks Andrey!
Yeah, [Awesome Kotlin](https://kotlin.link/) is a very nice resource. The _Projects_ section might be the most interesting for you. You should keep in mind that Kotlin ecosystem is much younger than Python's though, so don't be discouraged if you find less open source projects in general.
I can't think of a case where this applies. The resulting type of your variable is Int, not Int?. So if you don't cast it wildly or save it into another variable, this type doesn't change. Example code fun main(args: Array&lt;String&gt;) { val movieIndex: Int = 4!! fun myFunction(input: Int) {} myFunction(movieIndex) } works perfectly. Additionally, I have to say, that you don't need the double bang (!!)... you already use an int primitive, which is not nullable. IntelliJ emits a warning here too. I assume that you are a beginner in Kotlin, if not, I apologize - don't use the !! operator. There is almost always a better way (for example safe calls or explicit null checking). If you need help avoiding this operator, feel free to post your problem or write me a PM :)
This one example looks like an Either to me, yes. As you spend more time modeling with sealed classes you'll see which ones are with wrapping and which ones aren't.
Oops, previous post had the wrong URL, this one should be fine!
Website is shit. It would be an interesting read if you didn't have to fight with "contact us" shit in the way.
That was a nice explanation, thanks. Question: does throwing Exception for null value not have exactly the same effect as NullPointerException in Java. You have just bypassed all the things Kotlin compiler provides to prevent runtime exceptions?
[KotlinConf 2017 - You Can, but Should You? by Mike Gouline](https://www.youtube.com/watch?v=ihdEjDoXOgc)
Indeed, you could also for example use the `!! ` operator there as well and have that throw a KotlinNullPointerException for the null input. This way you have the chance to handle it however you'd like to, for example you could use your own Exception type that you catch and process somewhere already. Or perhaps crash the application, but provide a well worded Exception message that describes what happened and why instead of the generic NPE. The point is that it gives you options for neatly throwing an Exception - whether this is the right error handling for a given case will depend on the specific case.
I don't see it. Maybe the site is broken for you?
I think it was broken earlier or rendering incorrectly, seems to be working now. Earlier, the text was stretched to the width of the page, and the green box on the left saying "contribute to the blog" and the "hire us!" bits on the were covering a bunch of the text and scrolling with the page, keeping the beginning of each line concealed.
Weird.
Thank you very much for your investigation, I'm very interested in any information about performance comparisons with coroutines :)
Any thanks. I'll look into. Can I ask...is Kotlin really that closely related to Java? I just have this thought that the similarities are only noticeable to advanced coders and programmers.
I don‚Äôt really know, I‚Äôm an iOS developer looking to learn Kotlin and android 
It's executed on the same thread the value is changed on, so synchronously.
It's still interoperable, it just won't show up as a property in Kotlin. Instead it'll show up as a method. You'll still be able to access the setter only. Idk why Kotlin doesn't support write-only properties. 
A setter only is not a property
What are you all using for database support in non-android Kotlin projects?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/coding] [Typical Kotlin (a guided tour of Kotlin's type hierarchy) \[x-post from r\/Kotlin\]](https://www.reddit.com/r/coding/comments/9hy3zr/typical_kotlin_a_guided_tour_of_kotlins_type/) - [/r/programming] [Typical Kotlin (a guided tour of Kotlin's type hierarchy) \[x-post from r\/Kotlin\]](https://www.reddit.com/r/programming/comments/9hy3y6/typical_kotlin_a_guided_tour_of_kotlins_type/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Thanks
It was posted a day ago.
Properties are a way to treat the object as data rather than as a functional thing. Write-only "properties" don't conform to that interpretation.
Makes sense as a design decision. TIL
Use IntelliJ
I haven't used ktor before, but I'll take a stab at what's most likely happening here. `PipelineContext` has a property `context`, and `get` takes an *extension lambda* `PipelineContext&lt;*, ApplicationCall&gt;.() -&gt; Unit`. That syntax is a little odd, but it means the passed lambda will be usable as an extension method, and inside the body you can reference `this` (a `PipelineContext`). Then, storing that lambda in a property and calling it every time a request is recieved allows you to get a unique `PipelineContext` every time. In short: how it gets the call in the first place? Implicit reciever for the passed function. How it gets a new one each request? The function is called on a different context each time.
Thanks! You've put me on the right track. I see now that these lambdas I'm passing to the functions "embeddedServer", "routing", and "get" have types like configuration: Routing.() -&gt; Unit and PipelineContext&lt;TSubject, TContext&gt;.(TSubject) -&gt; Unit Do you know what this type of function signature, with the .() syntax is called? I'd look it up, but I don't know how to search for it. 
[Function types with receiver](https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver)
Generally speaking it's better to keep lies simple, and to not put them in writing.
I didn't know they had an Andorid app, good to know 
If you have a terminal in eclipse, you can open the command line REPL by running the `kotlinc` command.
They are the backbone of any ‚ÄúDSL style‚Äù kotlin code you‚Äôll see in the future. They‚Äôre really cool, open up a lot of possibilities.
This is called "Kotlin DSL" (domain specific language). The idea is that you call a function with a lambda parameter that extends another class. If you use these extension functions you can use fields and methods from this class as if you were in the class itself.
In your edit, the problem is that `throw Exception()` isn't a lambda. ``` val a: () -&gt; Int = if (true) { { 0 } } else if (true) { { 1 } } else { { throw Exception() } } ``` works fine
`val a: () -&gt; Int = if (true) { { 0 } } else { { throw Exception() } }` That should typecheck
It's not ideal, but if you still want a one liner with type inference you can create a variable in the if block and return that. i.e. val a = if(true) {val n = {0}; n } else { throw Exception() } 
...but it changes the semantics of the code, so it's not a valid solution to the problem at hand.
This error is caused by a bug inside the compiler and you should report it inside [youtrack](https://kotl.in/issue)
Unless you are using Java and Kotlin together I'd recommend you to use functions everywhere, SAMs (Single Abstract Methods, a.k.a single method interfaces) to use lambdas are just a solution to a limitation of Java that Kotlin solved with functions as first class citizens. (showNotNativeEnglishSpeakerDisclaimer()) 
As UMBR4NOX said, function types for pure Kotlin. I would extend that to "pure Kotlin and Java 8+" as well, as I'm fairly sure you can create lambdas for Kotlin's function types in Java. If you need to support Java 1.7 or lower, I'd recommend single-method interfaces and use double-colon method reference syntax if you need an instance of a function type.
Adding to this, certain language features are unavailable when using single-method interfaces, like efficient inlining.
You should consider that you can document custom single-method interfaces way better than lambdas or prefab interfaces (like function, consumer or supplier). Sometimes the meaning of your lambda-argument is blatantly obvious e.g. ```listener: Consumer&lt;Event&gt;```, but sometimes it is worth it to declare your own interface, especially if it is used in mutliple methods. 
We need more code to be able to help you
To give a bit of context, I develop Android application for about 2 years (I am a freshly graduated student). I applied for a job that develop in Kotlin and wanted to create a very simple game to get familiar with Kotlin. The code is super basic but I wanted to know if I was developing correctly or if there is some errors (in the way I implemented certain function in Kotlin, not really the code itself) &amp;#x200B; If you guys have the time to check my code and give me a small feedback it would be awesome :) Thank's in advance to anyone who take the time to read what I have written!
Definitely lambdas as that allows me to use the "inline" keyword. I try to use "inline" whenever possible for small functions which accept lambdas as this reduces pressure on the garbage collector, reduces memory consumption, and improves performance.
First of all: Very good that you chose to gather feedback, that's the way you will learn a lot! I have no idea if yours is good code regarding your experience, or if it is bad code regarding your experience. I can make it short, I take a very glimpse look at your project and it took me minutes to figure out some things: &amp;#x200B; 1. You seem to not use a build tool like maven or gradle. With Kotlin, use gradle. Experience with and knowledge about build tools is one of the most important skills in professional projects. 2. Your package names and folder structures are somewhat weird. There's a well established standard for Java/all JVM projects, that have a project root with src/main and src/test folders. Then, packages have a well established convention as well, you can read this up for Java, as it is the same for Kotlin. packages like "obj" really tell me nothing :) 3. One of the worst things - regardless of object orientation or functional style - is making mutable things global. Your GameConstants holds a mutable list of tanks. This should be avoided at all costs. I'm sure you can find another context object that you can pass around with parameter passing and/or dependency injection. 4. You should avoid the package util alltogether. Kotlin is very capable of removing such util thingies. For example GameManagement. This is not a (small) util class, it could reside in its own package as well. 5. All in all, your code is not too bad. You use when statements properly, you sometimes have nice names for functions, your variable names are good, your function sizes are okay...not too much to critisize here. All in all, your project shows me, that you are capable of outputting your thoughts into Kotlin code. I would recommend you to add a build tool, fix your package names and you are good to go for a junior job :)
Don't know if this is the sort of thing your looking for, but Arrow uses suspending functions for monad comprehension. The example uses IO, but you could also use synchronous monads such as Try, Option, etc. [Documentation](https://arrow-kt.io/docs/patterns/monad_comprehensions/) [Some of of the implementation](https://github.com/arrow-kt/arrow/blob/master/modules/core/arrow-typeclasses/src/main/kotlin/arrow/typeclasses/MonadContinuations.kt)
Could you add an [README.md](https://README.md) file in order to explain how can a complete beginner could achieve the same output as you did? Thanks :)
The [`buildIterator`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/build-iterator.html) and [`buildSequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/build-sequence.html) functions allow creating iterators that run a suspending function until the next [`yield(someValue)`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/-sequence-builder/yield.html) or [`yieldAll`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/-sequence-builder/yield-all.html) call, similar to Python generators. (Note that calling other suspending functions in the body is disallowed via the [`RestrictsSuspension`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/-restricts-suspension/index.html) annotation.) Interesting that Python coroutines are built on generators, but Kotlin's generator-like feature is built on the building blocks originally made for coroutines.
I've noticed a few things: &amp;#x200B; `private fun userInputInt (message: String): Int` This signature tell us that this function always returns an `Int` which is false. In case of an exception you return the **default** value `-1` It would be better to return `Int?`, so it returns either the `Int` or `null` if something went wrong. Because Kotlin is null-safe, you don't have to worry about NullPointerExceptions. &amp;#x200B; In Kotlin most of the control flow constructs (if, when, ..) are expressions (unlike java, where those are all statements) and those can return a value, e.g: &amp;#x200B; `return try {` `val userInputStr = readLine()!!` `userInputStr.toInt()` `} catch (e: NumberFormatException){` `println("You did not entered a number!")` `null` `} catch (e: Exception) {` `println("Unhandled error") println(e.printStackTrace())` `null` `}` &amp;#x200B; or `val list = mutableListOf&lt;String&gt;();` `File(Constants.GameConstants.fileNameTankList).useLines { lines -&gt; list.addAll(lines) }` could be `val list = File(Constants.GameConstants.fileNameTankList).useLines { lines -&gt; lines.toMutableList() }` &amp;#x200B; And finally you have `var hp: Double, var isAlive: Boolean` inside your `Tank`. That means its possible to have a Tank that is both alive and has a negative HP. &amp;#x200B; You could use a sealed class instead that tells you whether the Tank is alive and what HP it has or that it is dead: `sealed class TankStatus {` `class Alive(var hp: Double): TankStatus()` &amp;#x200B; `class Dead(): TankStatus()` `}` `class Tank (val name: String, val country:String, var status: TankStatus)`
I already changed it to a data class, this is way better like this :) Thank's for your feedback!
Thank you very much for your feedback! This is more advanced that I am used to, very interesting to read :) The way I handle the userInput method is by looping (in the askUserToEnterAInt method) while the value returned is -1, with your change I have to loop while the value returned is null, is this a better way to implement it or is it the same as before? I did not know how to proprely handle exception in this method. I want to ensure that the user enter an int and not a letter for example. Thanks for the list workaround, I must try to place a . after more elements to find what I can do, this is nicer and easier to read in my opinion :) I will also investigate the sealed classes. I am not used to create object like this but I will definitely look into it! Once again, thank you very much for your complete feedback :) 
My comment is related to using git/github specifically. You shouldn't have compiled object (.class) files in your source repo, or IDE configs (.idea), they should be in your .gitignore file as to not clutter up your source repository, after all it's a source repo. You can checkout the recommended gitignore config here https://github.com/github/gitignore/blob/master/Java.gitignore 
Thank you very much! I did not expect to learn something about github. &amp;#x200B; You are absolutely right, I did not put a .gitignore file and it was messy, I fixed that by using \[this website\]([https://www.gitignore.io](https://www.gitignore.io/api/kotlin,intellij)), the file I used is \[the following\]([https://www.gitignore.io/api/kotlin,intellij](https://www.gitignore.io/api/kotlin,intellij))
I cannot thank you enough! This really helps me, and this is really nicer way of doing it. I knew that my method was flawed, thanks for providing an amazing answer :)
* add a `.gitignore` file and exclude the directories `.idea`, `out` and the file `kotlin.iml`. * [Conststants](https://github.com/flavienbonvin/tanks_experiment/blob/master/kotlin/src/res/Constants.kt) should be _constant_, so don't use `var`. And you should avoid mutable object (`val ENEMY_TANKS: MutableList&lt;Tank&gt; = mutableListOf()`). * Separate resources like `tanksNames.txt` from the code, following the Maven conventions (src/main/resources). You can leave out `return` in single-expression functions. Instead of override fun toString(): String { return """ Tank information: Name: $name, Country: $country, HP: $hp, Is alive: $isAlive """.trimIndent() } ... you could write: override fun toString() = """ Tank information: Name: $name, Country: $country, HP: $hp, Is alive: $isAlive """.trimIndent() } However, I would let the compiler generate the `toString` function in this case ("&lt;class&gt; information" doesn't add much).
I still have one question, I use mutable object in my constant file, I do not find another way to use immutable objects since I have to update some of the fields of those constants. Do you have a resource online or something that could help me?
Thank you very much for your feedback, I added a gitignore file [(this one)](https://www.gitignore.io/api/kotlin,intellij) and everything looks better :) &amp;#x200B; I totally understand why the mutable list is a bad idea in the constants file. But I do not know how to correct this problem. I create the tanks at the game initialization and I do not know how to make them not mutable, I don't know if a lateinit would work (but it will become a var instead of a val). Do you have some resources I can follow? &amp;#x200B; I also moves the text file to its own resource folder, this is better :) &amp;#x200B; Thanks again for your help, I really appreciate it!
Agreed on compiled files, but I think IDE configs can be argued about in source control - it is rather convenient to check in code style settings, run configurations etc. to share them with the team. Just need to be careful about what to check in specifically and exclude settings that should be developer- or device-specific, but at least in Intellij's case there is a guide from jetbrains that details what makes sense to check in and what should better not be checked in.
It's quite a different approach, but you might take a look at [Kweb](http://kweb.io/).
Be sure to say hi on [Slack](https://kotlinlang.slack.com/) and ask questions there if you have more :)
Do you have a package statement that mirrors the directory structure?
It would be with pleasure the I join but I do not have a [Jetbrains.com](https://Jetbrains.com) email account :)
Perfect, thanks a lot!
Yes. Kotlin runs on the Java Virtual Machine, relies on the Java Standard Library, and has perfect interop with Java in the same projects. 
That shouldn't matter, classes with "wrong" package declarations are allowed by the language as a feature.
Your applications consists only of functions and a few global variables. I suggest that you learn about object orientation, to improve the structure of your applications. For example a "Game" would be an object then and could hold related state.
What did you like most ? 
Your ENEMY\_TANKS variable itself can be a mutable list, this is fine - but it doesn't have to be global. Global means that every part of your application can freely change it - for example arbitrary code could clear the whole list. This makes it hard to reason about the code. A first step would be to have your whole game an object. The tanks list could then be a mutable list, but a property of your game instance. In your tests, you could then use a game instance per test and work with your tanks list on a per test basis, while you don't need to fear that tests change/clear/add things to the same list of tanks. In order to implent this, you have to think about what defines your game - make a game class and start by putting your tanks list in there as a property. then, you will have to implement many functions as methods for this game class. This will lead you in the right direction :)
Right my opinion as well! After so many experiments on the JVM with groovy, Xtend, Ceylon, Scala, which all lack several important things compared to java, preventing them from being a replacement for Java in real projects, I'm very optimistic, that the answer is finally found with Kotlin. From my point of view, there is no other choice on the JVM that is as fast, pleasant, stable, backed, flexible, interoperable, supported, accepted, concise and yet easy as Kotlin. Really advanced features like first class coroutines, inline classes, js and native support etc. are brought with high quality, constantly and fast. This makes it easy for me to overlook some small, unimportant compromises or quirks in the language.
KAwesome
Are you using Java 8?
I've been using Kotlin for a year and I still occasionally stumble across something cool with Kotlin. Kotlin 1.3 will have even more surprises which I'm really looking forward to (eg. there are probably neat new ways of using inline classes which we'll discover over time). The more you look, the more pleasantly surprised you'll be.
I‚Äôm a Ruby on Rails developer planning to switch to Kotlin/Java development in the future. I had Java classes in university but that‚Äôs some years ago. Can you guide me to some resources I should know in order to get up and running with Kotlin?
Yea, I am in love with Coroutines.
Was a rails developer two years in the mid of my career as well - you will have a looooot of fun with Kotlin. especially lambda and extension lambda stuff will absolutely be a boon for you, because of static typing :) I recommend you to just do the Kotlin koans - If you have some Java background and know ruby, this should work. [https://kotlinlang.org/docs/tutorials/koans.html](https://kotlinlang.org/docs/tutorials/koans.html) I recommend using IntelliJ for it.
Thanks for the link, I‚Äôll take a close look! I‚Äôm really looking forward to working with Kotlin as I‚Äôm getting tired of the dynamic part of Ruby. I‚Äôm already using RubyMine so being able to use IntelliJ is great! Would you recommend Gradle or Maven? And which web framework should I begin with? There is definitely knowledge I‚Äôm lacking in the Java world. 
Easier to ask forgiveness than permission...
Definetly gradle. Far superior build tool in every regard. If you are just a little brave, you can use gradle with kotlin as your build language. Sometimes a bit sloppy in the IDE and Not lightning fast, but it's nice to work with a single lang in Project and build and you avoid groovy, which also has the problems of dynamic languages. Web frameworks is complicated - java makes quite a shift currently towards microservices. Tldr: use ktor, it's build by jetbrains (kotlin creators) and has best kotlin Support, is easy, fast, and should feel familiar for someone who maybe has seen sinatra or other other Frameworks.
Thanks a lot!
I used the [Google Drive API Client](https://developers.google.com/drive/api/v3/quickstart/java), however, instead of authenticating using the *user's* Drive I set up a [service account](https://developers.google.com/identity/protocols/OAuth2ServiceAccount) to automatically connect to my drive. The basic code being: private fun getDriveService(): Drive { val httpTransport = NetHttpTransport() val jsonFactory = JacksonFactory() val scopes = listOf(DriveScopes.DRIVE_READONLY) val credential = GoogleCredential.Builder() .setTransport(httpTransport) .setJsonFactory(jsonFactory) .setServiceAccountId(config.get&lt;String&gt;("service_account_email")) .setServiceAccountScopes(scopes) .setServiceAccountUser(config.get&lt;String&gt;("user_email")) .setServiceAccountPrivateKeyFromP12File( File(config.get&lt;String&gt;("service_account_cert"))) .build() return Drive.Builder(httpTransport, jsonFactory, credential) .setApplicationName(config.get&lt;String&gt;("app_name")) .build() } 
It is well documented here: https://kotlinlang.org/docs/reference/ 
It's a very nice language. I've spent years doing mainly Java and it was a relief to get rid of all the pointless verbosity. I was trying to push Kotlin internally at work but ended up moving projects and using Typescript before I got very far.
Thanks, this is super useful.
No problem! Let me know if you have any other questions.
I use spring boot with kotlin. Others might have different opinion but I think it's the best web environment I've worked with. I've done Java/spring, RoR, and php. None of those come close to how much quality code I'm writing in such little time with my current setup. 
I have been looking for a Java replacement for years. None of what I tried were satisfactory (Ceylon, Clojure, Groovy, Scala) until I tried Kotlin. Been programming with it ever since. Started it before 1.0 and I'm not looking back!
I love coroutines too but i'm fearing the jump 1.3 has in store for us. It seem to be quite a bit of a shift in design. 
Sadly, maven central, et al are blocked; we have no access to unapproved libraries :(
Not
Is the Kotlin Stdlib on the classpath?
Kotlin needs your anonymous object to implement Iterable for this to work. &amp;#x200B; `class Test` `{` `fun foo() = object : Iterable&lt;Int&gt; {` `override operator fun iterator(): Iterator&lt;Int&gt; =` `object : Iterator&lt;Int&gt; {` `var current = 0` &amp;#x200B; `override fun hasNext() = current &lt; 7` &amp;#x200B; `override fun next() = current++` `}` `}` `}` &amp;#x200B; `fun main(args : Array&lt;String&gt;) {` `val t = Test().foo()` `for (i in t) {` `}` `}`
Thank you that worked indeed!
Ask the publisher.
If they are a perfect match I don't want to use Kotlin anymore
Saw this discount on informIT book website, 40% discount on book and ebook: http://www.informit.com/store/kotlin-programming-the-big-nerd-ranch-guide-9780135161630
Check the sidebar, there is some nice info there -&gt;
Got no response yet. Was wondering if anyone has the book too.
Thanks for the tip! I just took YouTube class and it looks really promising.
I know they just recently released a new edition. Maybe it's not been updated?
my guess is kotlin conf next week
seen. thanks for the response
The Kindle version? If so doesn't a page size and count depend on the font size?
Where do you see that there's a new edition? On their website there's only the first edition.
Thank you! I'm not an experienced Java developer and this book seems to be geared toward veteran java developers. I bought the book and some Java for beginners books. Hopefully this time next year I'll be writing some full stack Kotlin!
I have friends who work at Big Nerd Ranch.
My version has 384 pages
\`val manager = activity.supportFragmentManager\`
`val manager = activity.supportFragmentManager`
thanks a ton
Great list! I would recommend Glide over Picasso. Although the implementation for them is very similar, I've seen major issues with Picasso in recycler views in the past. Plus if I remember correctly Picasso sat stagnant for a while with no updates to the library. And for JSON I've been using Moshi and found it very efficient.
Yeah and honestly read the docs on the official website. I spent about a week or more reading every single page on it. Then started building things with it.
Oh. I was reading this: https://medium.com/@elizarov/structured-concurrency-722d765aa952 . I only gave it a cursory glance. I still have to read more into the changes.
Glide and Picasso could not be more different in their implementations. Glide has an order of magnitude more code. Picasso is 90% of the features for 10% of the size. Feel free to file bugs on Picasso for RecyclerView problems with a small sample or test case that demonstrates the problem. Well happily fix.
Thanks for the tips! I've heard of Moshi but haven't looked into it yet. I've also noticed some problems with Picasso in recycler views lately so I might try Glide and see if that fixes the problems. Thanks!
From [.getDeclaredFields](https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getDeclaredFields--): &gt; The elements in the array returned are not sorted and are not in any particular order. You could inspect the .class file directly but I don't think there are any guarantees there either. Thus, there's no way to honor ordering.
Yeah I doubt any order is preserved from class fields. I've done something like this with OpenCSV before but I don't remember the specifics. I think I generated the headers in the order I wanted, then used MappingStrategy (HeaderColumnMappingStrategy), with @CsvBindByName annotations on my fields.
Have you looked into kotlin's coroutines? It seems like you found a couple of libraries for asynchronicity, but coroutines probably already so what you want. The advantage of coroutines is that it's made by jetbrains; no need to worry about whether the maintainer will drop off the face of the earth.
I have, and I'm still trying to get my head around them, but as far as I can tell they're just for managing threads, right? Promises wrap asynchronous tasks and give you a promise you can act on immediately, so you can write asynchronous code as if it were synchronous. They also let you do cool stuff like act on the result of several asynchronous tasks when they're all complete, or when at least one is complete. Do coroutines do all that? I'll definitely look into them if they do, I just had the idea they didn't.
Coroutines are technically for managing threads, but writing async as if it were sync and waiting on multiple async calls to act on their results are some of the stated goals of coroutines.
the example is here: https://github.com/oshai/jasync-meets-ktor
Yep, coroutines can do all that. I'll try to remember to give you some more info when I get to work and am actually awake.
I think we need a new ORM for these projects to take off. 
I made a starter project which has the pattern I've used in a large-ish project: https://github.com/raharrison/kotlin-ktor-exposed-starter It's a simple example but pretty broadly replicates what I've also done on most large Spring projects.
I'll take a look, thanks!
Thanks! I saw a write-up of using coroutines alongside promises that made me think they must do different things, but I'd love to learn more about the overlap.
Oh I did totally forget. Alright, let's take a swing... [Kovenant example](http://kovenant.komponents.nl/): task { //some (long running) operation, or just: 1 + 1 } then { i -&gt; "result: $i" } success { msg -&gt; println(msg) } Coroutines launch { println("result: ${1 + 1}") } I think that the Kovenant example is supposed to demonstrate chaining together async calls, but...if they need to be executed in sequence anyway, why bother chaining them? Just write the code normally, but on a background thread. or a slightly less contrived example launch { println("result: ${calculatePrimesTo(9999999) + calculatePrimesTo(234353)}") } Looks about the same. I am pretty sure that this will not parallelize the two long-running methods. Async is another thing Coroutines do: suspend fun methodThatRunsAsync() { val primesA = async {calculatePrimesTo(100000) } val primesB = async {calculatePrimesTo(999999) } println("result: ${primesA.await() + primesB.await()}") } and then when you call this function, you could do launch { methodThatRunsAsync() } or runBlocking { methodThatRunsAsync() } Note that `suspend` is a keyword that sort of means "this function will return its result async". You can do pretty much anything with them. Was there anything specific I could point you towards?
If you do that it has a type other than object which means you can call iterator on it. With the anonymous class the main function see a class of type Object which doesn't have an iterator method.
Thanks for the examples! I think I'll need to look into this further to see if coroutines will handle everything I get from promises. Here are some examples of what I use promises for often: 1. When chaining a bunch of tasks together, I can create a single fail lambda and anything that fails along the way will be caught there, so I only have to handle errors once. I can also do this between classes, for example: `classA` calls `promiseFunction` on `classB` which calls `anotherPromiseFunction` on `classC`, and if something inside `anotherPromiseFunction` in `classC` fails, the error bubbles up to the call site at `classA`. 2. Possibly this is what's happening in your last example, but I'm not sure. With promises, I can wait until multiple async tasks are done, and receive the results of all of them to act on at once, when they're all finished. I can also wait until at least one of a set of async tasks is done. 3. Related to 1., with promises there's often a function included that lets you access the result of an async task without stopping the chain, so in my example above, `classB` could access the result of the async task it called on `classC`, and do something with it, while still passing along that same original result to `classA`, and still bubbling up any failures to `classA`'s call site. It may just be that I'm used to how promises work, so I need to do some more reading to understand how to do these same things with coroutines. I'll definitely keep exploring. Thanks!
Thanks for the examples! That helps a lot. I think I'd prefer to have the errors bubble up the chain to be handled once, rather than using multiple try catch blocks, but I see how that works now. Am I right in thinking, then, that promises vs. coroutines is really just a matter of personal preference for implementing the same kind of thing? For number 3, I didn't explain correctly, sorry. I meant it would either pass along the result after acting on it, if the async task was successful, or pass along the error if the task failed. Thanks again for the in-depth responses, it's really helped me get a better idea of coroutines so I can keep looking into them further.
&gt; I think I'd prefer to have the errors bubble up the chain to be handled once, rather than using multiple try catch blocks You could just not use try-catch blocks, too. Then any exception will get propagated up and you can use a single try-catch at the 'parent' level. Yeah, promises and coroutines are a matter a personal preference for how you want to handle async logic. You could also look into RxJava (despite the name, it works even better in Kotlin), which seems very similar to what you're used to (promises), but is much more popular in the Android world. Kotlin Coroutines are still fairly new (just graduating from experimental status this month). However, since Coroutines are first-party and have excellent language integration, I would recommend them to somebody who doesn't already have a preference and they are what I'll be using, going forward. Happy to share my take on it. Have fun!
Yeah, I like the idea of getting my head around coroutines, as it seems to be the most Kotlin-y approach, so I'll stick with it. Thanks for your help!
Kweet and YouKube are good samples. For modularity, you have several options: - You can break the routing into multiple files (ktor samples: Kweet and YouKube) - You can create a new Application.module (and load particular features including routing) in separate file/package than the Main.kt and import it in application.conf - Combination of the two above. i think you can also load features and routings from modules in separate jars. 
Kweet looks great so far, thanks
This is worth the 45 mins: https://www.youtube.com/watch?v=_hfBv0a09Jc JetBrains guy who clearly helped define the feature stepping you through threads -&gt; async -&gt; promises -&gt; co-routines. It's an awesome video.
A junior programmer who has a knack for learning new things and can take criticism is a no brain hire for most companies. The sad truth is that for fast moving companies, seniors with 2 year old knowledge might as well be stuck with COBOL. They make good architects due to their experience, but bad programmers. So eeuhm yeah keep at it I guess. :)
Thanks! I found the slides for that and actually did find it really helpful. I might watch the video too, to get some more context.
File-level variables and functions are static.
Every class has a companion object. That's contains what would be static fields and methods in Java. companion object { val test = 0; }
Yes, `@JvmStatic` companion object methods will become static methods. https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html#static-methods
Condy would be great. Also nest mates for sealed and generally nested hierarchies.
In theory, in kotlin-only code, you don't need @JvmStatic. The annotation exists for interop. In kotlin, you'd use companion objects or top-level members in place of static.
The metadata already lives in the constant pool, all strings referenced in the class live in the constant pool so those used by an annotation will be there too.
Right, but being a dynamic type allows you to have a custom deserializer in the form of a bootstrap method (and like invokedynamic, the result may be memorized, I haven't checked).
Don't expect too much, the Kotlin REPL is buggy and slow (over time) compared to REPLs in other languages.
One reason might be that Kotlin can compile to other things than Java that don't have a concept of static. So a companion object in Kotlin is an atual (singleton) instance of the \[inner\] class Foo.Companion. You could use all of the Object/Any methods on it like equals, hashCode and toString (although it makes little sense to do so).
DL4J is the Java TensorFlow [https://deeplearning4j.org/](https://deeplearning4j.org/)
But I guess everybody that wants to use the library has to? What about providing two different versions: - A small jar without the Kotlin runtime. For everybody that bundles Kotlin Runtime itself - A larger jar containing everything that is necessary for the Ant-users out there.
Read through this thread (and search for others on that site, there are probably more): https://discuss.kotlinlang.org/t/what-is-the-advantage-of-companion-object-vs-static-keyword/4034/19 
`position()` for the getter and `position(...)` for the setter? Should have just made it a `var` then.
I wanted to have functions instead of a property. This is not the point of the article anyway.
What is the hard part? You don't need `@JvmStatic` if you program in Kotlin, you only need that if you'd like to call that function from Java. There are quite a few advantages of having `compainon object`s including the ability to implement an `interface` in them.
Thanks for pointing that out, I'll fix it!
You can also [relocate the Kotlin runtime](https://github.com/randombyte-developer/holograms/blob/master/build.gradle#L57) so you won't have this problem.
I have to agree with flaghacker here - your article is very nice, why devalue it with non idiomatic kotlin code? In my opinion, the examples would have been even better if you used properties only, because that's something Java lacks and where Kotlin really shines. Nevertheless, thanks for stressing that delegate to a var is broken - I fear this is sth. many people are unaware of and I really have no idea why the compiler allows such a thing :)
I got your point, I'll fix it. 
What prevents you from using Kotlin with Java 11? It's compatible. This post is about making use of the new features in the class file format that are not required, just an opportunity for optimization.
Sorry, this is partly due to my own misunderstanding because Java 11 is an ambiguous term meaning something different for the JDK (and its internal APIs), the JVM and the compiler. Java 9 introduced the "release" term. So if I have a hybrid project, I could use source 11, target 11, release 11 for the Java part with jvmTarget 1.8 for the Kotlin part with modules and all that jazz?
Happy cake day!
But if the library was compiled against a specific version of the stdlib that will still cause the same hard to find bugs that cause headaches if the consuming project bundles the wrong version of the stdlib, right? I'd rather have the stdlib bundled with the library so I can see what version it expects, and use my build system to force me to resolve conflicting library versions manually.
What is your overall programming experience? Spring is a battle tested framework and if you don't know how to do something, chances are there is an answer on Stackoverflow for you. Personally, I would say knowing Spring makes you more employable than knowing Ktor. If you just want to do something for fun and do things the Kotlin way instead of the Java way, then there is less reason to use Spring imo.
thank you, yeah I was looking for both fun and employability, fortunately, Spring 5 supports Kotlin, so you can have some of Kotlin styles.
I used it because it's leightweight and only gives you the necessary stuff nothing more. I become to hate bloated frameworks like Play or Spring which (kind of) force me to use their logging, their DI, their ORM, their routing, their Testing framework, ec. ec. I came to like slim frameworks like express or ktor much more, which only really do the http request dispatching for me nothing else. 
I am currently working on a REST APIn built using Spring Boot, written 100% in Kotlin. I orgininally looked into Ktor, but at the time there was almost no documentation on anything beyond very basic functionality. Like the other guy said, Spring is tested, works well, and has prebuilt libraries for just about anything, SQL, noSQL, other weird databases, security features, etc... I would suggest Spring. Maybe after you have done a lot with Spring and are more comfortable with the functionality and concept of RESTful services you could build a project using Ktor. 
Right on. I feel the same way. Any good conventions to follow when building out your own web backend with a minimal framework? 
Depends on a lot of things like your needs, your background, the project you are working on...can you give us some more info?
Two libraries compiling against different versions of the stdlib will actually work fine as long as **the stdlib is not bundled with both of them**. The reason being, that the stdlib is designed to have binary compatibility across versions, meaning that method signatures and class names for public methods/classes do not change across stdlib versions. So since the library still sees the same function/class names, the library will still work. Now envision what happens when both libraries bundle different versions of the stdlib with them. The libraries are still able to talk to the stdlib. But the two stdlibs **merge/morph together**. **The classes from one stdlib will overwrite the classes from another stdlib**. However, not all the classes are overwritten, only the classes that are present in both versions of the stdlib. Let's visualize this, the arrows are function calls/object creations: - `A`: Library 1 (uses stdlib v1) - `B`: Library 2 (uses stdlib v2) - `trim`: Example Kotlin stdlib class - `TrimBuilder`: Example Kotlin stdlib class (new in stdlib v2) - `trimInternal`: Kotlin stdlib function (that isn't public, assume trim uses this function internally) Initially, the two libraries are separate, all is well: ``` A --&gt; trim --&gt; trimInternal B --&gt; TrimBuilder --&gt; trimInternal ``` Now the libraries are merged. Assume the classes from the library A JAR take higher priority over library B: ``` A --&gt; trim -&gt; trimInternal (from stdlib v1) B -&gt; TrimBuilder -&gt; trimInternal (from stdlib v1) ``` Overall, it looks like nothing has changed, everything is fine. But if you look closely, you notice that **`TrimBuilder`, a v2 stdlib class, is calling `trimInternal` (from stdlib v1)**. If **`trimInternal` was modified between stdlib v1 and v2 to add some more features that `TrimBuilder` needs, `TrimBuilder` will CRASH!** Also, `trimInternal` is not public, that means it is able to do this as it can change however it wants between stdlib versions (since libraries will never call it directly). Ok, that's the end of the explanation. I know it's really long. But the morale of the story is, never ever merge two versions of a library /stdlib together. The above scenario is just one example of what could go wrong. There are also problems with stdlib version downgrades (functions getting removed, bugs getting *unfixed*, etc...).
Yeah when we picked Kotlin, we did a spike between Spring Boot and KTor. Spring Boot won, due to its extensive documentation (KTor even had missing pages), and Spring also was battle tested and I must admit.. has more employability value. 
I feel the same way, however I will say that I chose Spring Boot over Ktor for the reasons others suggest: it's battle tested in production environments and has native Kotlin support. I had to do a couple of things like create a Kotlin extension to unwrap Option types into native Kotlin non-nullable types, but that was actually an excellent learning experience into how to Kotlin. I feel like it's got a light enough insistence on their own frameworks and libraries that you can disassociate from the ones you truly don't like in favor of something else fairly easily. For instance, I _hated_ Jackson, and ripping that out to replace it with Gson was a few lines of extra code. With that said, I was shocked at its auto reflection with regards to repositories. It's neat, but it bothers me not knowing what's going on under there. Still don't know how I feel about the Reflection 
Ah okay, I see what you're saying now, if the library versions are actually merged then that will of course create problems. But in the context of modern build tools, does that actually happen? I was under the impression that, when using gradle for example, and I depend on two libraries each depending on a different version of the Kotlin stdlib, gradle will pick one version of the stdlib (the more recent one, I think?) and only pull that as a transitive dependency. But I guess the stdlib in that case is technically just not called "bundled", as it's not actually in the dependency jar but resolved transitively by the build tool instead, right?
Your goal should be to make your application testable. There are some conventions to make this easier like using Dependency Injection and a ORM. Personally I have built my api with ktor, hibernate orm, kodein DI, Junit + Mockito.
Yeah I totally see your points. I also hate when I don't understand what's going on under a framework. If suddenly weird issues pop up it makes it more difficult to debug not fully understanding your project. But I also agree about Ktor not beeing battle tested. I personally made the decision to use it anway, but then at least go for battle tested hibernate as orm.
I choose plain Akka HTTP. It is just what you want, but easy to test and typesafe. Its even elegant to mix it with coroutines. The not that good part is that your application is going to be heavier, as you have dependencies with Akka actor and Scala
Yeah, that's not bundling, that's just called declaring a dependency. And that's perfectly fine because that's how you are supposed to do it.
I heard about Akka before and that it's very fast and scaleable. Personally I'm quite of a Netty fan, have been using it for quite some time with great success. I also thought about just using netty alone, without ktor but I was lacking little bit if netty knowledge for that.
Yep, I'm using IntelliJ and it's been great so far. The Udacity intro course is good as well -- it doesn't try to explain what a loop is but has you do simple exercises that reinforce the syntax.
&gt;it was a relief to get rid of all the pointless verbosity Exactly. &amp;#x200B;
I used them in C# while scripting for Unity3D (which I never want to do again -- what a mess, at least at that point) and definitely enjoyed them. I'm confident I'll have a similar experience with Kotlin coroutines, although I haven't looked into it at all. I've barely started looking at it and then life got in the way.
Native coroutines support. That is by far the biggest one.
Netty is great, but it is very low level. Other tool are built on top of it. In fact Ktor and Akka http use Netty under the hood. Akka is bigger than Ktor. Akka Http depends on Akka actor which depends on Scala. But you don't need to know anything about actors to use Akka Http. In fact both APIs are quite similar, but in my opinion Akka Http is more stable, tested and typesafe. Play is built on top of Akka Http (or, more precisely, Akka Http was created a from the Play http stack)
I'm the author. I hope this doesn't count as self-promotion and I know I'm probably preaching to the choir here. But I hope it might help some of you who might run into troubles convincing some of the more conservative Java devs in your organisation to have them give it a shot :) Any feedback is more than welcome ofcourse :)
So we were actually talking about different things, thanks for the clarification!
Thanks for your effort! Nice article that repeats and sums up a long list of aspects one probably has read elsewhere, but nonetheless a good read. Problem is, I fear, people that are not already convinced by Kotlin lack interest, knowledge and experience, and your article won't change this :)
Interesting article! Read a lot about contracts and it certainly improves what the compiler can do for the user. Only I am afraid about that contracts are unchecked definitions...if the type system would have been used instead of contracts, it would have been more cumbersome and verbose, but it would have been compile time checked.
Yeah, probably :) It's also more of an "off my chest" thing than anything else. Like I described at the start; it caused a bit of a problem for myself where I didn't feel like doing hobby projects (the stuff I normally blog about) in Java even though my blog's focus is Java. Thanks for the compliment!
Great summary of things to love about Kotlin
&gt;Regarding your library, I'm curious about it :) As far as I know RxKotlin are "just" a number of extension functions to the RxJava library. So, it will not work in JS. Are you planning to create a common interface to bind both RxKotlin and RxJS? How about native? Or you have a completely different idea? Yes a common interface to bind to both which matches RxKotlin/Java as closely as possible so you can just 'swap-out' RxKotlin for the multiplatform version when you want to get a JVM based project working in JS &amp;#x200B; As for native - I have no need yet to port code to iOS but the same principle would apply for RxSwift
Java dev here. I have recently switched to Kotlin also and honestly love the language. I have started using it with all my Spring Boot projects instead of Java now. 
It's perfectly possible to add compile-time checking to the current implementation of contracts; the fact that they aren't part of the type system does not make this any harder (and makes contracts dramatically easier to add to the language).
The omission of val in Java is because of how var is shoehorned into the language. var is a reserved type name, not a reserved keyword. So anywhere you see var, it is an alias for an actual type the compiler replaces it with. Reasoned this way, val can not be a reserved type name, because it represents both a type and a modifier. To make val work they would have to make it a reserved keyword such as if, else, class, etc. But doing that would break a lot of existing code with variables simply named val. Why Kotlin can do this is because under the hood Kotlin replaces it with final &lt;type&gt; and Kotlin didn't have the baggage Java has.
Yes, and it's also (and imho even more) awesome from the perspective of a JavaScript or a TypeScript dev and that seems to be harder to explain, because these devs are more afraid of overhead for web solutions while Kotlin DCE (dead code elemination) and the gradle continous compilation features (including hot reload code) meanwhile allow quite small bundles and also nearly instant code modification reactions.
You should have a look at the apply, let etc family, they allow you to do cool stuff especially when interoperating with plain Java code. If you have an object with a bunch of setters, say a POJO that you want to initialize easily, you can do `var myThing = Thing().apply { prop1 = 1 ... }`
can't say I like the longer building times and worse performance of idea.
Does anybody else have problems with Jackson forcing all Kotlin classes to have a no arg constructor? I had to add kotlin-noarg plugin with a custom annotation on my model classes which goes against my desire to keep the model separate and pristine. 
Oh yeah, I know. Use them often. But the post was already getting rather long :)
That's fine of course; I still think they are worth mentioning, because one of the biggest concerns is "how does it work with plain Java?" and these little helper functions make working with plain Java so much easier.
Definitely going to consider them for a 'part 2'. Thanks!
Thanks for stating a negative example, as they are important too. But seems very subjective. I personally didnt experience a difference between the two languages regarding the IDE responsiveness. And i really do a lot of kotlin and Java. The build times... Same game. This article also kind of invalidates what you say about build times https://medium.com/keepsafe-engineering/kotlin-vs-java-compilation-speed-e6c174b39b5d
I recently started to use kotlin and it‚Äôs fun, sounds a cliche but it‚Äôs like that. Nice post! Some of your Kotlin examples contains semicolons, you can remove them ;)
Thanks. Good to look into. 
Haha. Thanks; stupid habits of Java developers :)
What is everyone looking forward to this KotlinConf? :) 
https://twitter.com/kotlinconf/status/1041727575792537601 What do you think it will be? Something big and new (like Kotlin for CLR) or something which already we know like release of Kotlin Native 1.0 ? 
My build times are considerably worse too. I write a lot of tutorials where the same problem is solved in both Kotlin and Java, running the Kotlin version always takes longer.
Greatings from Amsterdam ;-)
I'm definitely going to watch all the coroutine-related talks.
Regardless of it is going to be kotlin or sth Else, i would never ever again do a project thats larger than a single file in a dynamically typed language. Since kotlin offers many of Pythons advantages and gives you static typing - of course take kotlin, what a dumb question :) what a dream If you don't have to care that the only languge your collegues know is python! Because that is most often preventing usage of new or other languages.
In my humble opinion if you want to automate web browsers you pretty much left with one choice, but its a good one and that is selenium. And the java selenium client/webdriver is probably the most stable one. (probably js version is on the same level, someone can confirm that pls). Sometimes other official language bindings(like C#) are a few version number behind. Don' t quote me on that, but if I remember correctly google uses selenium for crawling websites. It's support all major web browsers and it's rock solid. [https://www.seleniumhq.org](https://www.seleniumhq.org)
Yea, never said or implied anything else :) but as of now, there is no implementation, which makes contracts less safe then static typing. Looking Forward to the day this changes, thought.
Instead of (odd, even) you could just call it nums and use nums[0] for odd and nums[1] for even. Or you could create a small data class to hold the two
Yes but its exactly this I want to avoid if possible =) "I am currently working with a zipped list and having the index without refereeing to the list[index] all over the place would be very nice."
 val a = listOf(Pair(1, 2), Pair(3, 4), Pair(5, 6)) for ((index, pair) in a.withIndex()) { println("$index, ${pair.first}, ${pair.second}") }
I would assume Pair is a class that only holds the attributes first and second, is it also possible to access them with an index at the same time? Or do i have to choose either index access, or name access? 
Thank you for replying =)
It was the conference live-stream.
Yeah - I'm aware of that. Also already using Selenium. My question was more of Kotlin vs Python for actually doing the task.
My shop uses like 4 different languages. Python is just kind of thrown in there. But I have the chance of converting the project into a language of my choice and I figured this would be a good chance to get Kotlin under my belt. Just wanted some opinions on it.
ps. there's readme in English as well
Spring Cloud Netflix = Dependency Hell
If you use forEachIndexed you should be able to destructure things so it is super easy to read. 
It depends on what your expectations are from the framework, I just started working on my project and I decided to go with spring, it does take some time to set up initially but once it is done and you are familiar with how spring works, you save a lot of coding time by using existing solutions. Once in a while you might get stuck when you decide to use a new library let's say for authentication, but everything feels pretty natural. I would say write down your requirements and think about where you want to be creative (do you want to spend time creating custom solutions ?)
Interesting. I'm not using maven any more, so I can't tell. With gradle, I see no difference, but my projects are not always of exact same size and complexity, so I can't really prove. Do you use incremental compilation? Do you have any numbers from your projects? Would be a good opportunity to write a blog entry and show a comparison between Java and Kotlin. Otherwise, people like I will believe old articles from 2 years ago that show only minor differences :)
If you are using Maven, incremental compilation is not activated by default, other than in Gradle - I don't know the reasons for that, but this slows down your build heavily. I don't know why an age of 2 years makes an article less relevant? We're talking about a comparison between two compilers - I'm pretty certain that they are evolving quite slow compared to other things in IT and that one of the two compilers evolve even slower than the other, so if the picture changed at all, chances are high that it's the Kotlin compiler getting better, not the Java one. Additionally, the article doesn't omit anything - it clearly compares clean compilation as well as incremental compilation. I don't know why you think otherwise, but compiling parts of a project is the far more important part here, not clean compilation. I tend to believe a clean blog entry that can give me numbers more than "someone on slack said it", I hope that's understandable.
If nothing else work I'll fall back to this. Much appreciated.
Ah okay, so that's an easy case. In general, such a decision has to be done carefully and is influenced by soooo many things.... One last aspect: With python, people are used to just throw in a script and execute it with "python blah". There's not yet such (completely equivalent) thing in Kotlin. What there is, is Kotlin script. Did you take a look at it? I think it's still marked experimental, but upcoming 1.3 release of Kotlin will do things here. The other option would be regular project based, compiled and executable stuff. Or using compilation to native executables, would fit for automation as well.
you're the one doubting my statement. in that case you should &gt; I'm pretty certain that they are evolving quite slow compared to other things in IT and that one of the two compilers evolve even slower than the other, so if the picture changed at all, chances are high that it's the Kotlin compiler getting better, not the Java one. just like im pretty certain that the performance of kotlin in general is worse. &gt;Additionally, the article doesn't omit anything - it clearly compares clean compilation as well as incremental compilation. I don't know why you think otherwise, but compiling parts of a project is the far more important part here, not clean compilation. I tend to believe a clean blog entry that can give me numbers more than "someone on slack said it", I hope that's understandable. i cant check the source. i dont think you can take a benchmark seriously without source anyway. regardless the article should have tested changing 5-10 files as well, not just one (for incremental compilation). if it had tested 5-10 files as well I/you could maybe say that something is wrong with my setup. but changing only 1 file and compile is hardly the case at all when I compile.
 val pairs = listOf(Pair(1, 2), Pair(3, 4), Pair(5, 6)) pairs.forEachIndexed { index, (odd, even) -&gt; // ... } or the infix form val pairs = listOf( 1 to 2, 3 to 4, 5 to 6 ) If the number positions actually represent something specific, it might be more readable with a custom data class instead of the generic `Pair`, e.g. data class UserStats(val age: Int, val postCount: Int)
Hello internet again - I get the impression that you really haven't read the article completely and just try to win an argument here. The article clearly compares clean builds with incremental builds that involve inter file dependencies, which is the same thing as changing more than one file. I don't know what else to say, here - if you still have problems trusting the article and prefer sticking to your own experience (however it may be made up), than please let us stop here.
hell yes :) Discovered that there is an implementation on their branch already :) Going to test it this evening or so.
I'd write `listOf(1 to 2, 3 to 4,...)` to keep it short 
You can't access a Pair by index because it holds two different types, much how like how the python tuple is supposed to be used. However in python you can access a tuple using indexes because types are dynamic. In a static language, how would I know if `Pair(1, "hello")[i]` is an int or a string? 
Probably you should remove that part if you are not sure. It would be a serious pitfall to string multiple `map`s together if they are eager as it would be quite costly performance-wise.
&gt; Probably you should remove that part if you are not sure. I'm going to figure it out and then change it, just haven't gotten the time yet. Probably tomorrow. 
[here you go](https://pl.kotl.in/r11SEqmcX) val list = listOf(listOf(1, 2), listOf(3, 4), listOf(5, 6)) list.forEachIndexed { index, (odd, even) -&gt; println("$index, $odd, $even") 
You are using `listOf` in your example, but then you want to [destructure](https://kotlinlang.org/docs/reference/multi-declarations.html) the values into exactly two variables, which means that you *do* expect them to be pairs. You cannot destructure a list in Kotlin, because Kotlin doesn't keep track of lists' sizes at compile time - the type `List&lt;Int&gt;` represents a list of arbitrary size. That means a Pair is a much more specific description of what your data actually represents. As mentioned, a specific data class would be an even more specific, better description of that data. When you work in a statically typed language, you're supposed to have a kind of *schema* of your data structure, and if you think about it, an actual list of lists is very rarely useful in practice (usually there's a list of some other data structure that may *contain* another list, but rarely list of just lists without any additional data).
You are using `listOf`, but then you want to [destructure](https://kotlinlang.org/docs/reference/multi-declarations.html) each value into exactly two variables. That means a `Pair` is a much more specific description of the data you expect to have there. As mentioned, a custom data class could be an even more specific, better description of what the data represents. The type `List&lt;Int&gt;` usually means *a list of arbitrary size*. In this tiny example it doesn't matter, but in real code you want to provide a kind of "schema" with your types, a written representation of what goes where, what is expected, and what people working on the code can rely on. If I see a function that expects `List&lt;List&lt;Int&gt;&gt;` as an argument, I'm going to have to go into the documentation or implementation and try to figure out what I'm supposed to pass there. If the function takes a `List&lt;UserStats&gt;`, it's much more obvious, plus the compiler will check it for me, I can refactor it to add more fields, etc. 
Ah man, thought they would be announcing 1.3 GA not another RC
They've been production ready for ages, just the API has changed a bit over time.
Thank for the explanation, and yeah then I probably do have a list of pairs without knowing it =b
&gt;without knowing it If you mean that you called `zip`, but don't see the resulting type anywhere, you can always select any expression (or place the text cursor somewhere) and press `Ctrl+Shift+P`, and it will show you the type of the selected thing. Similarly `Ctrl+Q` (I think on Mac it's `Ctrl+J`) will show the quick documentation for any function, variable, class, etc.
They're constantly prompting everyone for feedback and still gonna be making changes based on that. I for one applaud not rushing a release just because the conference time came around.
Well you never mentioned Selenium. You should stick to Kotlin, but honestly we are on kotlin reddit so what did you expect ? :) 
They mentioned this plugin which could help developers to learn Kotlin: https://kotlinlang.org/docs/tutorials/edu-tools-learner.html Going to try it out myself for sure.
From my experience the build system and dependency Situation on the jvm is much more mature. But if it's typescript vs kotlin, i think the decision should be done based on what knowledge exists in the company and how satisfied everyone is with the current Situation and projects, that are maybe already done with typescript. Cannot say much about kafka with kotlin, but i think kafka usage is pretty much the same for every Platform.
This made me actually laugh out loud from a restroom stall at work. *Bravo*
Christina Lee
Kotlin for ParrotVM?
Then use the research that found that typed languages reduce bugs. Also, compare spring-kafka and the Kafka npm package. Spring -kafka especially&gt;2.0 is really nice!
Thanks for that, I‚Äôll have a look over spring Kafka today 
I don't really know what is officially supported, but a wide range of clients is mentioned here [https://cwiki.apache.org/confluence/display/KAFKA/Clients](https://cwiki.apache.org/confluence/display/KAFKA/Clients) so i doubt you will have any problems in this regard on any platform. I think JavaScript developers are more accompanied to the build systems and ecosystem of TypeScript - my opinion is, that the JVM world is more mature. If you can persuade your colleagues to learn a new platform and build system, than Kotlin might be fine. But you will need their support if you don't want to have a lot of stress and bad moods. TypeScript will be easier to establish for you, I guess :)
If this is for a personal project, why not try both? That way you get a feel for each and can judge each on their merits. If you design your project keeping it framework agnostic you can "plug" them in after your business logic is in place, reducing the duplication of effort.
You were right. A quite test made this very clear and I've updated the content. Thanks a lot for spotting that error!
Thanks for spotting that. A quick test confirmed this and I've updated the post!
That's cool. Can I embed this in my own app?
I agree but he asked about why *not* to use Node.
You can embed code snippets with the "share" button. 
FYI, I know it's not exactly what you're looking for, but you can "ignore" the other fields using underscores when destructuring: \`val (\_, \_, c) = Something(a = "test", b = 8, c = 3.14)\` Might make it a little nicer. I agree that this would be nice to have but I can live without it. It's one of my favorite features of Clojure though :)
Features that are useful get used all the time and features that require boilerplate just don't get used, or we find other ways to do things. Destructuring is never strictly needed and obviously there's other more verbose ways to do it. I think it's telling however that in both Clojure and Javascript I use destructuring all the time and in Kotlin I just pretend it's not there. 
Cool, thanks.
There is idomatic language usage and there are people that try to solve problems in every language in the same way. I believe you got used to heavy destructuring because it is much more necessary in languages like clojure or Javascript. Kotlin doesn't support n-tuple coding and this decision has reasons. If you have webservices and endpoints you dont own, then even better, because you can parse their response into data classes that you do own. And this one can very well be a nested one, what would likely be more ideomatic kotlin code. It would be hell of a lot easier if you would give us a code example - i have the impression that there's a Chance that there's No real need for any destructuring at all. If you provide us code, We will improve it and suggest additional ways to solve your problem. I'm sure kotlin can do Something nice about it :)
&gt; If you never need eight of your ten properties, implement componentN methods for two of them and you are good. This seems like a good way to really confuse the next person to read through your codE
Well he mentioned that his team isn't looking for typescript.
This doesn't sound like a good idea. Local variable names affecting program behavior? No thanks.
Both. Declaration order is different because it also affects constructor invocation order. It makes sense if you see data classes as tuples wrt to destructuring (which is where the syntax comes from).
&gt;What I end up with is a val c holding the value of the first declared field a (e.g. "test"). It's important to mention that this will also emit a warning, so it's not like it can happen by accident.
I'm wondering how hard it would be to implement names on destructuring, something like ``` val (prop1 = c, prop2 = a) = Something(a = "test", b = 8, c = 3.14) ``` where you can then use `prop1` and `prop2`. Though this would overload the meaning of `=` even further.
Short and concise! You deserve more upvotes.
Thank you! :)
Feedback ist Not coming to reddit and say a nice feature (and it certainly is) was "completely useless". Or asking why a feature cant be more generic and more like in language x. Kotlin enhancements almost always Happen with a user giving his real world example where he thinks he cant solve the Problem adequately. Veeeery often there will be suggestions how to solve the given Problem with ideomatic kotlin and the Problem becomes nonexistent. We could do this with your code too, maybe leading to a Situation where you realize that the kind of destructuring you want to have can be replaced with other constructs that leads to better code. As i said, there might be languages, especially dynamically typed ones Like Javascript, where the urge for destructuring might be bigger because other concepts don't work nice and the "Loss" with this feature is not too relevant. So yes, i got it. You have no Problem - but then again we cant solve it for you. If you just want to be kotlin Like language x, because of reasons, we wont get any better here.
Chances are slim. Behind the scenes destructuring works using operator functions that are generated based off position for data classes. Unlike JS and Clojure, where object keys are reified, in Kotlin you cannot access fields by name except if you use reflection. Reflection is slow and a bad default, so it'll be very hard to improve. As someone mentioned below, using `_` like you would in OCaml's tuples is your only option.
It doesn't need reflection at all, the compiler can choose the right getters for each variable at compile time. It's a question on whether local variable names should affect the behavior of the program.
Yes, it's field access by name, as in `variable["fieldName"]` that can only be emulated with reflection.
You are so right xD
If you need one field out of a data class, couldn't you just do val c = Something(a = "test", b = 8, c = 3.14).c That does turn less elegant if you need to extract multiple fields, but like others have said, the names of locals in your code really shouldn't be tied to the names of the fields, because it makes refactoring that much harder. If you need multiple parts as a one-off, just use the underscores val (_, b, c) = Something(a = "test", b = 8, c = 3.14) And it you need it multiple times, just make a function. There's really no need to use something as fragile as name-based bindings. 
No it isn't, because the name is known at compile time
Thanks for the reply. I appreciate the explanation for why this might work in Clojure but not Kotlin. 
It can always been known at compile time There is no technical issue here, it stays completely static
How does it compare to Spek?
Written in a very Java-like style, I have two suggestions: - Format the code according to the Kotlin style guide (`Ctrl+Alt+L`). - Use immutable lists and initialize the objects on construction, instead of creating them empty and then adding things to them later. In Kotlin, the "default" way is to make things immutable, and only add mutability if there is a concrete need for it.
I guess that‚Äôs normal when you try to run tests on the device ;-( 
These weren't even instrumentation tests, only regular unit tests that run on the local JVM.
Sigh. I have tried not to couple too heavily to JUnit, but you do of course need a test runner that both your build system and IDE support. My logic is that everything has to support JUnit 5 in the end, but maybe we aren't there yet. 
&gt;My logic is that everything has to support JUnit 5 in the end I think that's a good assumption. I don't know why we aren't there yet, but the list of expectations I have for test framework tooling is not that huge. I just need a thing that: - Has a *complete* step-by-step guide on how to get it to work in Android Studio. Spek has [this doc](https://spekframework.org/setup-android/), but it misses a few steps, like how do I run the tests? Which run configuration do I create in Android Studio? Do I just run a gradle task? Do I need the IDE plugin? Etc. The [Android-JUnit5](https://github.com/mannodermaus/android-junit5) readme doesn't help much either. Then when something doesn't work, I don't know if I did something wrong, or if that feature is just not supported (e.g. go-to-test on double-click from the test runner UI). - All the usual IDE features just work, i.e. breakpoints, navigation from the test runner, no bugs like the stop button thing, running individual tests/groups, etc. Seems pretty basic to me. I guess the people who write these things just aren't Android developers, or there would be more attention paid to it.
`myClass[Math.random().toString()]`, `myClass[myByteBuffer.toString()`... there are many way to make the keys unresolvable (or impossibly complex) at compile time.
But this isn't the case here, it's a local variable name which is fixed
Are these talks online anywhere?
How does it compare to ktor work Kotlin? I would be biased towards a framework that supports coroutines out of the box rather than something slapped on. 
I am assuming this is about an Android app? You may have more luck asking in an Android specific forum. 
Javalin is all about that Java/Kotlin interop, so async is done via `CompletableFuture`. I'll look into coroutines once they're no longer experimental, but I doubt they will be introduced. It's not clear to me why they would be better than `CompletableFuture`, unless you're writing something async from scratch.
Thanks, I'll try that next - I wasn't aware people used this language on it's own outside of android development.
Oh yeah sorry I probably should've lead with that, this is for making an app in AndroidStudio. I'm not entirely sure what JVM means, but I googled it and I think the answer's a yes?
You have a pretty big hump to get over to get into Android programming. You need to learn Kotlin or Java first by writing some console apps before you can get into it. It's a little bit too much to try to learn it all at the same time.
Heyo! I'm one of the maintainers of Spek. Firstly, this is really good feedback. Spek 2 is currently on its first RC release, from this point up to the final release the main focus would be improving the docs. The current android docs for Spek is sh\*t, I'm not an android developer so I was hoping someone from the community would help out with that. I could use this as guide to improve the docs, thanks! [https://github.com/spekframework/spek/issues/507](https://github.com/spekframework/spek/issues/507) &amp;#x200B; &amp;#x200B;
I had issues with Spek before so I created my own test framework (KSpec). In the end, our goals are the same so we decided to team up and just focus on a single project. Minutest is quite similar with Spek the only major difference (other than how the tests are built) is its focus on Android. It's quite apparent on the tight coupling to JUnit - I guess this is for reusing existing tools/libraries built for Android?
Use an elvis operator and a run block at the end of your assignment
On the contrary, I don't focus on Android, as I don't know how! My aim simplicity and composeabilty of tests - if I can get that from Spek I'd like to learn. 
I mean... This is a month old, and is only the Release Candidate. Or am I missing something?
Because description is a simple string and from can take a method body, as per the groovy DSL. I don‚Äôt think that‚Äôs at all arbitrary. The majority of the quirks come from them designing the DSL to almost match identically the groovy DSL. I suspect that experimental warning setter is actually using the setter defined in the plugin written in groovy and it‚Äôs not following the naming syntax required for Kotlin to smartly replace explicit setter access with the equals operator function. 
Because you can register multiple `from` sources.
`version` is an infix function. The only way to possibly achieve this with `id` would be to do `this id "com.android.application` version "3.1.0"`, and that doesn't look very nice.
like so: val account = bookingAccountService.findOne(id) ?: run { res.sendError(HttpStatus.NOT_FOUND.value()) return ModelAndView() } `account` will have the non-nullable type after this. Note the `return` exits the outer function as a whole and not the `run` block.
Yes that is correct
FYI: I've written about this topic in August: [here](http://the-cogitator.com/2018/08/29/gradle-kotlin-dsl-first-impressions.html). TL;DR Kotlin DSL is nice, but it is not yet ready for prime time. Seems like that Gradle 5.0 will change that soon though.
Yep, this was discussed here before.
But both could have been usual parameters: plugins { plugin(id = "com.android.application", version ="3.1.0") }
Just some UX notes: It is really annoying that there is a sidebar on the right which takes up a lot of screen real estate and I can't dismiss it. It is not useful, and it also makes the text appear on the left side instead of being centered. I'd suggest to fix this issue.
&gt; Because description is a simple string whereas from can take a method body, as per the groovy DSL. I don‚Äôt think that‚Äôs at all arbitrary. Ok, but why not using functions then in both cases for the sake of consistency and simplicity? 
But it would be possible to assign a list to the property.
No one thinks RxJava should be rewritten with coroutines. The point is that it *can* be rewritten with coroutines. Going even farther, no one cares about RxJava's implementation. They care about what it abstracts over and the API it provides against that abstraction. This is trivial to accomplish with something written on top of coroutines. Moreover, it's necessary in contrast to RxJava for multiplatform use.
Is it possible to return the outer function as well?
But that's not how the Groovy DSL works, which is what they are attempting to match in feature parity. The groovy DSL has `from` that takes a `Closure` ([source](https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Copy.html#org.gradle.api.tasks.Copy:from(java.lang.Object,%20groovy.lang.Closure)).
Right now the order of field declaration affects program behavior. Which is even worse in my opinion. You reference your properties by name and not by order. `val something = Something(a = "test", b = 8, c = 3.14)` `val (a, b) = something` is a shortcut for: `val a = something.a` `val b = something.b` On the other hand it's pretty weird to reference your properties by declaration position: `val a = something.component1()` `val b = something.component2()` Most languages (Erlang, C#, Javascript) destructure objects/structs by name and not position. &amp;#x200B;
Your claim that you must go "digging into the source code of [a plugin]" to find a task's type is not accurate: $ gradlew help --task bootRun &gt; Task :help Detailed task information for bootRun Path :bootRun Type BootRun (org.springframework.boot.gradle.tasks.run.BootRun) Options --args Command line arguments passed to the main class. [INCUBATING] --debug-jvm Enable debugging for the process. The process is started suspended and listening on port 5005. [INCUBATING] Description Runs this project as a Spring Boot application. Group application 
&gt; Coroutines tend to have a cleaner, more understandable programming model compared to CompletableFuture I don't disagree with that, but in the case of Javalin all you have to do is hand it a `CompletableFuture`, the library takes care of the rest. It seems the potential gain is pretty limited. There are already libraries (http/DB) which return `CompletableFuture`, so it should be plug and play.
Wait, aren't you creating Kotlin classes for your JUnit tests? The point of using better tools isn't to make your life more difficult.
You can use any classloader for that. For example system class loader: [https://docs.oracle.com/javase/9/docs/api/java/lang/ClassLoader.html#getSystemResource-java.lang.String-](https://docs.oracle.com/javase/9/docs/api/java/lang/ClassLoader.html#getSystemResource-java.lang.String-) And if you don't wrap your test functions into a class, then they will turn into static methods and your tests won't work.
Hey, thanks for pointing that out. I didn't know about that when I wrote the article. This doesn't change the gist though. I *will*, however, use the Kotlin DSL when Gradle 5 comes out. I'm not a pioneer type, but you are cool if you use Kotlin DSL right now.
I fail to see your point. How is creating Kotlin classes helping me locate resource files? My train on thought being: * is using Java-esque `[...].getResource()` family methods the only way to retrieve the path to resource files? * In which case, that code must be wrapped in a class (is there no other way?) * Then ultimately should all my test classes inherit from a base class in charge of retrieving the path to test resources? I am probably too naive to expect either Kotlin or Gradle to provide me with more straightforward way to address these file locations.
&gt; This doesn't change the gist though I think the suggestion that you have to find the source code (if its public), and then trawl through it to find the relevant task configuration is a considerably worse picture you're painting, and it's one of your two major criticisms in the "downfall" section of your article. It comes across as unnecessarily harsh criticism given the Gradle's teams efforts.
It returns from the outer function by default. If you only want to return the run block, you need to write return@run or something like that. 
Thanks for the questions. Let‚Äôs address the easy ones first. * I don‚Äôt have an assertion library, but see that as a feature. * You can run tests with coverage, if you can run tests at all Minutest relies on JUnit 5 as a test runner. That means that there is no need for a plug-in, but it doesn‚Äôt work with non-JVM projects. I‚Äôd be interested in looking at providing another runner, but Spek seem to be in a world of pain with that strategy. 
Okay, thanks for the info!
`description` _is_ a method. That's kotlin syntactic sugar. The Java class backing the task has a setDescription function that kotlin simplifies to description. 
&gt; But that's not how the Groovy DSL works This sums up why the Kotlin DSL feels like a waste of time to me. It's technically Kotlin, but with hacks to make it look as much like Groovy as possible. The plugins also have Groovy-styled APIs, which I can't really blame them for, but it's the reality. The Kotlin DSL ends up being in this uncanny valley of looking more like Groovy than idiomatic Kotlin. You can't use normal "Kotlin reasoning" to figure out what's going on because of the hacks (eg: getters that actually set things and over-use of infix methods), and it's also different enough from Groovy that the vast majority of Gradle examples out there won't quite work. Pretty much worst of both worlds. I love (most of) Kotlin, and I've felt that the Groovy DSL is the worst thing about Gradle ever since I started using it, and yet switching to the Kotlin DSL seems like more downside than upside to me. I'll probably be sticking with the Groovy DSL.
What should be different in a "RxKotlin"? By the way: [Reactor](http://projectreactor.io/) has more modern APIs (Java 8 baseline and not Java 6 as in RxJava) and it comes with some Kotlin extensions out of the box.
I agree, there is too much contortionism going on to try and chain everything at all cost. A normal null check can be the most readable choice, like in OPs case.
I think the gradle groovy dsl is not the best part of groovy either, just as the kotlin dsl is not the best parts of kotlin... from my point of view their usage is very similar and there are not too many cases where the kotlin dsl would be a problem. this means you have very few or no (? depends on experience i guess) downsides and the positive side is you get better api navigation, static typing and you can write kotlin.
I just copy and paste Java code into the IDE, and look at the differences between the original and the Kotlin translation! I use the ItelliJ based Android IDE, and it will prompt you if you want to convert the pasted code into Kotlin. You don't really need a tutorial. 
Honestly I haven't wrote Java before. I come from PHP specifically Laravel side and many web based frameworks. I'm not interested in writing Java I'm interested in the modern niceties that Kotlin offers. I like how it reads and am trying to pick it up because of all of those reasons.
Look at Udemy.com. There are a few on there but pay attention the the ratings/# of ratings. You can watch preview clips of the material too. And don't pay $100, these tuts go on sale for $12 every other day (if not every day)
Not finding what you're looking for here? https://github.com/search?utf8=%E2%9C%93&amp;q=kotlin+android&amp;type=
Any you'd recommend before I go looking through them?
how to learn a platform: * skim the official docs * hit a wall, find a tutorial or 4 for climbing that wall * use the tutorial(s) to make sense of the official docs * repeat until you pick a new platform
How do I join the kotlin slack?
http://slack.kotlinlang.org
it took me about a day
Seem really nice, thanks for sharing. See you at KotlinConf 2019!
You can't use JVM dependencies with Kotlin native.
interesting that the events of last year are considered history
We use [https://mockk.io/](https://mockk.io/) quite extensively with junit and assertj, it is a great kotlin mocking library, making it a pleasure to write tests in. Also a shout out to [http://wiremock.org/](http://wiremock.org/) for testing methods which make http requests.
Thanks for your answer and the link! So the story is that some guy had the idea of using Kotlin on Adroid and JetBrains accepted the challenge and made it happen. When Kotlin wasn't developed for internal purposes and also not designed for Android, what was it designed for? What was it, that other JVM languages like Scala were missing?
I use it as the basis for [Kweb](http://kweb.io/), a higher-level web framework that handles browser-server communication transparently. It was the best HTTP library I could find, but expect to run into bugs. I spent days trying to fix a websockets problem but in the end switching from Netty to Jetty back-end in Ktor was the only workaround I could find.
Initially we designed it as a mainstream, general-purpose language for the JVM. We believed that Scala wasn't the only possible way to build a modern JVM language, and that a language built on a different set of values and concepts could also find its audience.
This [2017 talk](https://www.youtube.com/watch?v=YrrUCSi72E8) explains it a lot better.
As I understand it the CLR is a difficult platform to target because of its generics model.
meaning - the latest version on GitHub is always the latest one on JitPack? If so, then a GitHub implementation would take care of that.
&gt;Very open. So is OpenJDK. Oracle's Java is not at all necessary for any Java development.
imm and mut (immutable and mutable)?
Was hoping like, a change in the language since the Kotlin lead designer is a moderator here üôÉ
You might consider submitting a ticket https://youtrack.jetbrains.net/issues/KT
I like that they're not the same length, makes it even more obvious they're different. 
Mutability in Java/Kotlin usually refers to whether the state of a class can be changed, not if the reference is final.
Why did you editorialize the title? These are just tools, no need to get tribal
as an english native, `val` and `var` are annoying for me too. i can't imagine how it is in another language. It seems like it would've been such a glaringly poor decision early in the meantime, vote for this feature: https://youtrack.jetbrains.net/issue/KT-21498 
My advice - try to only use var in exceptional circumstances. You‚Äôll find you can almost always do without it, your code will be better, and the confusion will be lessened.
IMO this is the best answer, and I believe the designers of the language did this intentionally. Rather than defining `let` and `var` or something I think they intentionally made them lexically similar so that `val` could more easily become the default (‚ÄúOh, I don‚Äôt need this as a `var`, I‚Äôll just leave it as `val`‚Äù)
Tribal? Maybe. I didn't intend that, but there you go. But, this is Oracle's doing. Now, there's this whole ecosystem, and it is ostensibly built on the JVM. That's true, so what is the next step? By default, Oracle will have the ear of enterprise and others. Some will subscribe and pay up. Some will support the Oracle JVM. They will be the rightful inheritors to the "crown" after all. And they will pay for it, from the wallet. Eventually, they will also pay for it from the freedom of source code. But, there's OpenJDK... and Kotlin. Now, is it completely beyond the pale to consider that there will be a fork? Ok, I get it.... no one sought confrontation with Oracle. But the playing field isn't necessarily over Java. That's the means. And, since Oracle shifted to a primarily to be profit driven; that's the motive. And now, since Oracle has taken this fork in the road, that's the opportunity. So... which way will the much longer FOSS trend? Will it favor Oracle? That's not "tribal" is it? That seems a little more strategic.