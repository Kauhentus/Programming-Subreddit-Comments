It’s actually an intern for java dev. But since I have no experience in developing backend system for mobile app, they put me in front end first, and slowly go into backend. I stumbled on the offer in a Facebook group (Out of all place, I know) So Im a little lucky there
car2 was always a Car object, it's just that the jvm needs this kind of "confirmation" of its type to properly call methods upon it
Is there a difference from kotlin-logging: https://github.com/MicroUtils/kotlin-logging
If its open source and its made with kotlin, I personally think it would't hirt seeing it here. Kudos to OP for sharing his project!
The readme doesn't even explain how inline classes are used? Why should I use this over any of the other 100 logging frameworks? Lazy log messages are really an old hat by now, so that's no argument. And the Readme doesn't show any other advantages.
They might have a caching system for Java as it's one of the most used language on their platform
Yep, as described in [this issue](https://github.com/MicroUtils/kotlin-logging/issues/34), none of their functions are actually marked as inline, nor is the class itself. Therefore each function ends up compiling to an anonymous class, which isn’t cheap at all as shown by the poster of this issue. With the InlineLogger being both an in-line class and using inline functions, there is truly minimal overhead.
The README very clearly shows how the class itself and the functions are inlined when compiled - the decompiled java demonstrates this. As for why it’s better than other solutions, I was previously using microutils kotlin logging until I learned that [none of their functions are inline](https://github.com/MicroUtils/kotlin-logging/issues/34). As you can see in this issue reported by another user, this means that if you analyse what it’s actually compiled to you will realise it isn’t cheap at all. On top of that, the usage of an inline class avoids unnecessarily instantiating a class that wraps the slf4j logger, therefore resulting in truly minimal overhead.
&gt; I am not exaggerating when I say that Kotlin produces code that is 100x slower than hand written javascript. I hope it gets fixed soon, even if it is against the "language specs".
This is absolutely fantastic! It's super nice I don't have to pass a lambda to initialize the logger like in kotlin-logging! Also, the deprecation annotations that automatically replace SL4J calls are a nice touch!
Thanks! I was hesitant to add those deprecated functions, since the `InlineLogger` itself doesn't necessarily need them (as it doesn't inherit from slf4j's logger, just delegates to it) - however I thought that anyone wanting to migrate a codebase that already has hundreds of slf4j calls would have an easier time if they weren't forced to fix hundreds of compilation errors, they can progressively adopt the `InlineLogger` over time.
Something for the UI. Current react+redux+typescript is a huge step back forgetting the KISS principle
Maybe something has changed or there is a bottleneck in their code somewhere, but last time I used the js backend it was 5-10 slower compared to running on the JVM. This is pretty much in the ballpark of my expectations, and nowhere near the 100x slower claim. Throughput/performance was a guiding principle for the project too. Used loads of immutable data classes - so plenty of short-lived objects.
Wasn't trying to suggest that it was innappropriate or that it should be taken down, just that he might get more visibility in the android dev spot.
I would like to see Spring Data JPA in non-nullable and coroutine version
Not the first time I have heard this. I am curious shy you think the html dsl is an even worse step back? To add a little context, we do angular+ts frontend and a spring+kotlin backend. I would have thought that a dsl in kotlin would be much more awesome than angulars html with its klunky extensions (`*ngIf` etc)
It's actually a cross post from r/androiddev :)
Because it means having to learn a proprietary DSL that feels wrong, it is hard enough to convince management to try kotlin without making things more exotic. We are having trouble finding good react/vue developers, something even more exotic would go down like a rock. Compare modern complicated js frontends, with simplicity of using serverside templates (such as twig or thymeleaf) with small bit of javascript/jquery on client.
I sure hope they have. I'm looking into implementing a multi-platform IO library at work - a 5x slowdown I can sell as the price to pay for keeping everything in one language; a 100x showdown is definitely going to be a deal-killer.
I'm interested. I don't have a use for it at the moment, but I think it's cool.
The generated JS is actually pretty concise and easy to follow, especially if you've ever had to endure debugging GWT code. Here's a bitset in kotlin and the same compiled to js (actually, the js is probably marginally outdated). I know some people have experimented with kotlin-native + webassembly. Not mature yet, but maybe an alternative for the future. In any event, I'd be interesting to hear about any perf-related things you discover, if you're going with kotlin for the library. Iirc, _dynamic_ is mostly for making it easier to interop with other js code(?). The web-end of our project integrated with an angular app - don't recall the specifics, but occasionally _dynamic_ just made some things easier.
Also web dev here and also starting to learn Kotlin more. But I do come from a more traditional language background (Java, C++) &amp;#x200B; Sorry things are frustrating :( I certainly understand the feeling. For example I started learning Clojure awhile back and I had(and to some extent still have) some frustrations in wrapping my head around functional programming and the Clojure syntax. &amp;#x200B; If Javascript is the only thing you've known, there's quite a bit that's going to take some adjusting to when it comes to a more substantial language like Kotlin. I think your example though is more indicative of how Android is structured vs the language itself. It has been some time since I've done Android work I'll admit so I could be totally wrong here; but that looks roughly what you'd have to write even in Java; I wouldn't get discouraged about things just yet in regards to Kotlin itself! &amp;#x200B; I know it's tempting to try diving into things with an actual project but it sounds like it might make sense to take a step back and take the time to learn about the language a bit more - Kotlin is pretty much interoperable with Java; I might start with some simple Java tutorials or if you're more visually minded, I started learning Java through [Processing](https://processing.org/) , used Kotlin and Processing to pull down some images from Mapbox for a personal project a couple months ago.
thank you for your answer my friend. I will look into that.
If you look at Google codelabs and then filter for Android they have some fun things you can try. Besides that, I find that most of the Kotlin learning content online is for Android specific. Though I'd recommend learning kotlin as a language first then learning the Android it makes it easier, at leased for me.i don't know your capability or level but in general Kotlin is a very easy language.
Definitely interested
Probably easier to do it in Java because most of the stackoverflow questions about Android are in Java. If you need it in Kotlin, IntelliJ can convert Java to Kotlin and back automatically
Fuel http, well documented
I've found [exercism](https://exercism.io/) to be really helpful. It's a series of practical practice problems that you can try to solve in any language. I found it a bit more intuitive and user friendly than kotlin koans. Also you can see how everybody else approached the problem and compare. For you, it might be useful to compare solutions in JavaScript and kotlin because the problems are the same and there are answers available in virtually every language.
I can't give you a web-developer perspective but since I'm a junior Android developer I think I can share some insights on how to better yourself on this journey since I was just at that point a few months ago: I know that right now the syntax and the way of doing things in Android are a lot different from those in web-development( I have the exact same issues right now when I try to code my portfolio website), but I can assure you that Kotlin made our lives in the company a lot easier since we switched from Java and it's worth learning. From what I can tell, you don't necessarily have a problem with the syntax, but with the patterns and the overall architecture and way of writing code on Android. I'd suggest reading into things like different architecture patterns and look over a few simple and sample apps that utilise Kotlin to try and familiarise with the language first. It's so important to understand why you do what you do in order to improve the way you write the code so you can adjust it to your needs. There are also plenty of codelabs available for pretty much any topic regarding Android development. &amp;#x200B; If you have any question feel free to message me and I can help with learning materials. &amp;#x200B; One last thing, and I know it will sound easy and I vet you heard it before but we have all felt that imposter syndrome at some point in our careers, hell, I even feel it now even tough I', doing this for more than a year, but I found that more than anything **practice** and **perseverance** gets you through it. So keep going! :)
For what?
Horribly formatted. Just post a link to code next time. But you need to put the ReadLine and all that logic inside your while loop.
You are probably better off scratching in the dirt with a pointy stick.
go fuck yourself, i came here for help, not sarcastic, 3 inched, single, not bathing for three months straight, pot addicted fucktarded niggas like you
If you want help, post something that you actually put some effort into. And cut the attitude. Nobody here owes you a thing.
Ah, so you're a racist as well as a crappy coder. Noted.
excuse i have an n word pass
Part 1 is available here: [Writing 'Finite State Machines' in Kotlin (Part 1) — DFAs](https://medium.com/@spaghetticode/finite-state-machines-in-kotlin-part-1-57e68d54d93b)
Either Arrow or TornadoFX, although Arrow isn't necessarily "easy" unless you like functional paradigms. &amp;#x200B; I also like Spek for testing
Thank you this is exactly what I needed to hear. I love your idea of just looking at Kotlin projects and understand the moving parts. Cheers
Code: import java.util.* fun main(args: Array&lt;String&gt;) { whatday() } fun whatday() { var day: Int = Calendar.getInstance().get(Calendar.DAY_OF_WEEK) print (day) var dname = when(day) { 1 -&gt; return "Sunday" 2 -&gt; return "Monday" 3 -&gt; return "Tuesday" else -&gt; return "Day not Specified" } print("Today is $dname") }
Not entirely sure about syntax, as i'm quite new to kotlin, but try removing returns from when's body Edit: also docs are your friend they are really helpfull and imo well written :) https://kotlinlang.org/docs/reference/control-flow.html#when-expression
The return statements in the when block are for the entire whatday function. And whatday has a return type of Unit (basically the equivalent to void in c++). That is why the error message says "Type mismatch: inferred type is String but Unit was expected" I am pretty sure this code will compile if you just remove the returns.
you don't need "return" in your when statement var dname = when(day) { 1 -&gt; "Sunday" 2 -&gt; "Monday" 3 -&gt; "Tuesday" else -&gt; "Day not Specified" } is enough
[Holy Shit! That worked. Thanks buddy.](https://i.imgur.com/lWGDDZ8.png) Reddit is awesome!
Now use vals a bit more :D
And no * imports!!!
I really like Spek, because it allows to write clean and readable tests with its DSL. I also enjoy using Detekt to detect issues in my code. I use some custom rules in Detekt. So I really praise the extension capabilities.
So they're making it freely available before they go dark?
Only standard is free as far as I know.
Very cool to see! But I feel like I am missing something. With `Flow`isn't the language supporting this functionality first hand? This is coming from an ignorant perspective. I am much more familiar with Rx than Flow
Congrats on getting this out there, and also on making it multi-platform! I also have the same question as one below, can you compare/contrast this with RxJava and Kotlin flow? Thanks.
&gt;This is coming from an ignorant perspective. I am much more familiar with Rx than Flow \`Flow\` is kinda same as Rx \`Observable\` but there are some issues with it at the moment. The most serious is that coroutines are single-threaded in K/N. Plus not everyone like coroutines and such a dependency might be unnecessary. Interop with coroutines is straightforward.
How many times will this question be asked on this subreddit? This is such a cheap question with no purpose. There is no real way to define which language is better, because each language has its own purposes. Just try it out and see for yourself if its good for what you want to use it for. If you really want to read something about Kotlin vs. Java please refer to: https://www.reddit.com/r/Kotlin/comments/928ve5/why_kotlin_better_than_java/ https://www.reddit.com/r/Kotlin/comments/9yqim6/java_vs_kotlin_which_one_is_better_for_android/ https://www.reddit.com/r/Kotlin/comments/8lwe25/is_kotlin_better_than_java_10/ https://www.reddit.com/r/Kotlin/comments/97nryk/will_kotlin_replace_java/ https://www.reddit.com/r/Kotlin/comments/be6s1d/is_kotlin_the_programming_language_i_desire/ https://www.reddit.com/r/Kotlin/comments/9bddag/is_kotlin_worth_the_time/ https://www.reddit.com/r/Kotlin/comments/8xzfvp/kotlin_before_java/ https://www.reddit.com/r/Kotlin/comments/a33jb3/kotlin_vs_java_which_one_you_should_choose_for/ https://www.reddit.com/r/Kotlin/comments/9vw8at/what_is_the_main_purpose_of_kotlin/ ^I ^do ^not ^take ^responsibility ^for ^what's ^in ^these ^posts. ^I've ^just ^googled ^them ^5 ^minutes ^ago.
This is huge! My team could really use this to transition our well established RxJava/Reactive thinking into Kotlin/MPP land - it is, in fact, the major thing holding us back from doing so. One question: Are the schedulers and underlying concurrency model co-routine based or have you built upon Threading, according to each platform?
Glad to hear that! You could start using it and help us deliver it faster. Regarding your question: Reaktive does not use coroutines and the only dependency at the moment is stdlib. In JVM it uses ScheduledExecutorService and in K/N it uses plain Workers.
If your interest in native regards iOS, you may want to consider that the state of coroutines on iOS supports only the main thread, so you will necessarily be doing all network handling and processing on the main thread. This may not be a problem for simpler Apps, but it's currently a major limitation for certain kinds of application. A related question I currently have is what's the feasibility of using Ktor's Client Code outside of coroutine contexts; such that requests can be run by background Workers (native's chosen concurrency abstraction). This path could lead toward interfacing Ktor with Badoo's 'Reaktive' implementation of Rx ([released today](https://www.reddit.com/r/Kotlin/comments/bz32de/reaktive_beta1_release/)!).
Here are over 25 advantages: https://proandroiddev.com/kotlin-avoids-entire-categories-of-java-defects-89f160ba4671
Hi /r/kotlin! We’re very pleased to announce the release of Javalin 3.0. The most important changes are: * Support for OpenAPI (Swagger) with Swagger UI and ReDoc * Re-implementation and simplification of WebSocket API (`wsBefore`, `wsAfter`, `wsException`) * Complete rework of configuration * Improved support for running Javalin on a non Jetty servlet container A huge thanks to Tobias Walle ([GitHub](https://github.com/TobiasWalle) who contributed 99% of the OpenAPI implementation, as well as all the other people who have contributed to the release. If you want to get involved, please head on over to https://github.com/tipsy/javalin
interesting question. i hear a lot more and see a lot more kotlin, so naturally id expext kotlin to be more popular than rust.
maybe because [discuss.kotlinlang.org](https://discuss.kotlinlang.org) exists?
So does [users.rust-lang.org](https://users.rust-lang.org/).
Kotlin never had Steve Klabnik to work his community magic
Why is this named 'javalin'?
It was either that or Kotva (Javalin = *Java* + Kot*lin*).
My guess is that Rust is used a lot more for personal projects. And Kotlin is used more for work projects. So people don’t want to check out Kotlin in their free time.
Kotlin programmers write code in their companies, while Rust programmers write to reddit :)
So this library integrates Java and Kotlin in some way that any other Java library doesn't?
It's being built with interoperability in mind. Most other frameworks are either Kotlin first (no/limited support for Java), or Java first (+ maybe Kotlin wrapper). If you look at the examples in the release notes, you'll notice that the code examples are identical (except for syntax differences). Javalin is written partly in Java and partly in Kotlin to ensure that it remains great to use from both languages.
There's a lot of reason for anyone doing systems work to be excited about Rust. It's a paradigm shift, and it vastly improves the development experience, from the perspective of the language itself as well as the surrounding tooling. Compared to C and C++, it's heaven (imo). Kotlin, on the other hand, is yet another JVM language. It doesn't stand out nearly as much from its environment. I think it's great in it's niche, but it has its shortfalls—I still prefer to use Scala when I can, personally. Kotlin has achieved its goals admirably, but it's just not very exciting, conceptually. Rust has also had the language development in the open, actively encouraging contributions to the compiler and stdlib, for a long time. The language is really community-developed (or it feels that way). Kotlin feels like a largely JetBrains-owned project.
Ha ha so true! Gotta go.. manager is coming.
Why do you want to know? Reddit popularity it not a good measure for general popularity. E.g. the Angular subreddits have become quite silent compared to 1 or 2 years ago. But at least in my area (Germany, enterprise) Angular is booming as hell.
Well.. I write Kotlin at work and in my freetime because I really like the language :-)
This vulnerability also impacted JetBrains and the Kotlin compiler.
Anyone know how this framework compares with Ktor? Except, obviously, Java support.
I use Kotlin for my side projects
I know, but I'm heading off now. I'll answer tomorrow after work, unless someone else does.
Swagger is great news!
Who fucking cares?
When you're learning Rust, you need every single resource available. When I started in Rust, I read the scratches on bathroom stalls just to see if any of them solved my latest lifetime management issue.
&gt;I don't want to start a flamewar. cross-posts to both subreddits...
I've been interested in trying to make a desktop GUI application. The quality of the Jetbrains GUIs has made me consider doing so with Java
Happy Rake Day Cake mans!
We’re too busy getting work done and not begging for help on reddit.
If you're going to make a desktop application then I recommend Kotlin + JavaFX (or TornadoFX)
Of course I did. It is only natural to know opinion from both side. The opinions are pretty civic as most people do understand what and why I was asking.
imo the really low boilerplate\ceremony and low-null is a big up to kotlin vs java in terms of dev time and reducing mistakes. honestly, i cant find a reason i would ever voluntarily write my own code in java ever again. i can do all java can do in kotlin in less time. less thinking required to write kotlin equivalent to most java code `data class` * java: you have to write getters and setters for each thing, you have to write `hashCode` properly (or let IDE auto generate, which you have to do again every time you change the class), `toString` (same problem as `hashcode`) and `equals` (same problem as `hashCode`). or you could use lombok, but that comes with some quirky problems of its own. `record` types are hopefully on the way. *kotlin: `data class` does it all for you. getter and setter patterns * java: rewrite the getter and setter for each variable you use it for * kotlin: don't have to write getter and setter, and custom getter and setter take a lot less typing in kotlin if you do want to. also delegates exist for identical getters\setters `abstract` vs `open` classes * java: you have to make an abstract class implementation * kotlin: `open class` lets you make an inheritable class while also being usable itself. nice mix of interface and regular class imo extension functions * java: doesnt exist * kotlin: does exist, makes functions more clear in usage and feels more natural. null * java: Anything but primitives can be null at any time. * kotlin: you get to decide what can and cant be null. allows for nice things like `inline class` singleton * java: Memorize singleton pattern * kotlin: `object` instead of `class` generics * java: Theyre alright, nothing fancy * kotlin: Reified generics (you can access the actual type), `in` and `out` for covariance named parameters * java: does not exist, easy to break api back-compatibility if you arent careful. * kotlin: does exist, easy to preserve api back-compatiblity. primary constructor * java: does not have per-se, you still have to define everything inside the class * kotlin: very nice to be able to quickly write a constructor without any constructor function or extra needless declarations
 when (somePet) { is Dog -&gt; println("Dog") } I wouldn't ever do this, I would sooner factor out a `petName` variable: val petName = when (pet) { is Dog -&gt; "dog" is Cat -&gt; "cat" } println(petName)
It has been documented already ([https://blog.karumi.com/kotlin-android-development-6-months-into-it/](https://blog.karumi.com/kotlin-android-development-6-months-into-it/)). I think the proper name for it is \`exhaustive\`, though.
Is there any tools that can detect and fix these issues automatically
Your `if` statement is missing a condition. It has to be an expression that, once evaluated, determines whether to execute the code or skip to `else` You can't just leave it empty.
Lambda starts with and ends with curly braces.
For detecting, yes, there is! [https://spring.io/blog/2019/06/10/announcing-nohttp](https://spring.io/blog/2019/06/10/announcing-nohttp) For automatically fixing, supposedly Pivotal is working on another tool for that but it's not in a state they are currently happy with.
username with dot at end, I think is it
You have a second if statement but no condition inside it. You just have an if() you need a condition inside the parentheses you have it correct above the empty kne. Also hovering over the error will tell you what the problem is. If you tell me what you're trying to do I can tell you what exactly what to write but I don't know.
Oh and when doing a readline, just create the var where you want the readline to be.
Also in a real world app you will want to ignore case when comparing or looking up username. So many mobile users auto correct have the first letter capitalized.
Just to clarify - because I was confused at first - you're suggesting this syntax in order to convert the when to an expression instead of a statement so that the compiler checks for exhaustiveness, right?
Yeah
Any reason Not to just use when{...}!! ? I saw this somewhere in the kotlin repository and think it's nice :)
It's definitely shorter. But then somebody could come and delete it, since he doesn't understand the purpose. The function or property can be documented though.
!! gives a warning.
 fun main() { println("Guess a number between 1 and 100") val number = (1..100).random() do { val answer = readLine()!!.toInt() println(when { answer &lt; number -&gt; "too small" answer &gt; number -&gt; "too big" else -&gt; "Yeahhh!!!" }) } while (answer != number) }
Their [logo](https://pbs.twimg.com/profile_images/699217734492647428/pCfEzr6L.png) reminds me of the [European Barn Swallow](https://upload.wikimedia.org/wikipedia/commons/d/d3/Barn_Swallow_%28Randunica%29.jpg) with the colors and the open mouth. Also close to Swift's swallow-like logo.
&gt; I still prefer to use Scala when I can So you're the one still using Scala! ;)
Well that was a better answer than I expected.
I have also thought of a bird. The [Common Kingfisher](https://en.wikipedia.org/wiki/Common_kingfisher) would also match the colors pretty well.
**Common kingfisher** The common kingfisher (Alcedo atthis) also known as the Eurasian kingfisher, and river kingfisher, is a small kingfisher with seven subspecies recognized within its wide distribution across Eurasia and North Africa. It is resident in much of its range, but migrates from areas where rivers freeze in winter. This sparrow-sized bird has the typical short-tailed, large-headed kingfisher profile; it has blue upperparts, orange underparts and a long bill. It feeds mainly on fish, caught by diving, and has special visual adaptations to enable it to see prey under water. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Kotlin/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
This is a pretty bad comparison. There are no numbers listed - How much slower is the build in kotlin vs java? The numbers are out there and its not that significant. Why is writing an android app "smoother" in java? I've heard the exact opposite. How does kotlin give "computational complexity"? You need to define your terms, back them up with measurements, and use less fluff when stating your opinion. "Feels better" is meaningless. Is the code clearer in A or B? Can we make a statement about safety in A or B? What about performance? Build tools? Signal to noise in the language? is it easy to understand idiomatic constructs? These are some of the questions people MIGHT care about. Not what was written here.
I can highly suggest Reddit search or Google. The best entry point to start.
TL;DR; if you like to **suffer**, your obvious choice is **scala**
https://kotlinlang.org/docs/tutorials/getting-started.html would be one option for a first step. This tutorial does link to some minimal survival guides in the first paragraph. You will probably want to check those out to get Intellij (the editor I would recommend) and a JDK installed. After that it shows you how to get a "hello world" program running, which is simply a program that prints some text. It's not much, but its good to get your environment set up for more complex tutorials, many of which assume you know how to set up a Java Dev environment.
Kotlin is like the good parts of Scala.
I consider Scala more like a language between Java and Groovy, and Kotlin is a total replacement for Java, so Scala is also like halfway between Kotlin and Groovy.
It’s a naive comparison. The thing people forget about Scala is that it has HKT. It’s got way more functional programming abilities than kotlin. There is the arrow library it has a weird syntax and more like a dsl.. kotlin doesn’t even have function compose built in. That is weird as hell if you ask me.
Scala is the obvious choice for those that committed serious sins and need to live a life of torture. Repent of your wickedness and Kotlin will accept you with open arms.
True, very naive comparison. I only meant to say that Kotlin and Scala don't really occupy the same space IMO. And I don't really consider Scala as a Java replacement like Kotlin. I feel like it's more of it's own thing and that thing leans in the direction of the space that Groovy fills.
You can also try... https://superkotlin.com/kotlin-mega-tutorial/ If you are wanting to learn Kotlin for Android I would suggest the Udemy course by Tim Buchalka (this is the one that I used to start with), you can usually get a discount for his course through his website https://learnprogramming.academy/courses/android-kotlin-development-masterclass-using-android-oreo/ I ended up purchasing "Kotlin in Action" and "The Joy of Kotlin" from the Book Depository as well as a couple from Packt to fill in the blanks and advance my knowledge. Antonio Leiva also has some good articles and a course that is acknowledged by JetBrains, however it is expensive. https://antonioleiva.com Hope this helps.
Yes it was helpful. Thanks.
 X,wxdywq the app guys top t
Nobody uses Scala so the answer is not hard.
But... RxJava is much more expressive than coroutines. This is like saying you are using basic asserts rather than an assertion library...
Writing in scala with some brand new multitheading frameworks feels like someone is trying to wreck your arms appart. But then you finish it and it works, it looks very cool.
Lol, so funny! ... cause it's so true :-)
The article mentions how flowables allow you to observe changes to data. How is that happening with suspend functions now?
&gt; Outside the Android world, Kotlin is still not as useful or applicable as Scala. We've been bringing up a Spring-based microservice using Kotlin and the Spring functional APIs and have found it a joy, largely. ¯\\\_(ツ)\_/¯
You can leverage `ReceiveChannel&lt;T&gt;` or `Flow&lt;T&gt;`
Kotlin is great but can still learn from Scala. Full fledged pattern matching (with destructuring!) Would be amazing for example. I find myself reaching for that fairly often - like if you want to pattern match on a Pair&lt;String,String&gt; to write fizzbuzz if you're being silly. Rust and Scala and erlang really got this right. Any other features you'd love to see from Scala?
Yes, but in the example article that's not done. Seems like some functionality was lost in the conversion from rx to coroutines.
I value my time which is why I switched from Java to Kotlin in the first place. Much less typing than java, very similar compile times. Scala has some cool features that I'd like for Kotlin like the pattern matching and the better support for big number math, but the compile times are insane!
Same
https://imgur.com/a/4UaeE
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/TRPOFT8.jpg** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme)^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20eqzphfb)
&gt; The problem with the above code is that if one of the sources throws an Exception then the app would crash. In RxJava we could handle possible Exceptions using the OnError callback, but that’s not possible here. One possible solution to this it to wrap each of our calls in a try-catch block, but that would make our code ugly and mostly unreadable. Why? I don't think wrapping code in try catch is that ugly. With regards to imperative programming I think it is a good approach to error handling.
Could you please provide an example for the person who never used RxJava but uses coroutines?
Your comparison is lacking IMO. RxJava is also much harder to read and reason about in my experience. And you only need a fraction of its features in any given app so its wealth of operators is less of an advantage than it seems on first glance. Coroutines shine in certain circumstances where Rx devolves into hard to understand code quickly. One example I had in a recent app was: Every X seconds, while a condition C holds, show a view with some promotional text, hide it again after Y seconds and show one of a list of texts in round robin. That's just a while loop and some delays in coroutines. Very easy to understand and modify IMO.
I'm not really a fan. I can see the use case, but plenty of workarounds already exist. More keywords makes the language wordy and extension functions on Any? pollute the namespace.
I learned and fell in love with scala first, and later kotlin, and I have come to find kotlin to be \*almost\* just the nicer, better version of what I get out of scala, and close enough for \*almost\* every purpose, but just not quite there. And it it is nicer. Kotlin is more pleasant to work in and less confusing than scala, for me (not that scala is that bad... though the things people do in it...) But I've had to do some deep soul-searching lately about my dream stack for a webapp, and as it stands, I fully intend to start a project using both languages: kotlin for the everything else, and scala for the database access layer. As clunky as scala's interop with other jvm languages can be, I have searched far and wide for anything in the java or kotlin ecosystem that can come remotely close to competing with the glorious [slick](http://slick.lightbend.com/) or even [sqlytyped](https://github.com/jonifreeman/sqltyped) I got to use in scala. All of the so-called "type-safe" database access libraries for kotlin are just a pile of... erm... not quite up to the very high standard I got myself spoiled with. Not a single one of them, for example, can so much as flag at compile time that I am missing a non-null parameter with no default value when inserting a row. I am pretty sure that these failings come down to the inability to implement something like [shapeless](https://github.com/milessabin/shapeless) in kotlin, though really, I'm no type system expert, I just use the stuff. I am also pretty sure this sort of thing is at least possible to implement via kotlin compiler plugins, so fingers crossed. In the meantime... I'm actually comfortable with the idea of a mixed scala and kotlin project, and I hope it doesn't scare away any possible contributors (it will), and it would of course be a crime to do this for an android app, but if you're writing a webapp, database access is a pain in the friggin ass and you deserve the best, and frankly scala-slick is unsurpassed by a huge margin. jOOQ is probably the closest thing, and it's not close.
That's true, I'm often wondering why people forget about HKT, as it's crucial for "proper" functional programming and really makes the difference. I also don't think that arrow is a proper competitor here currently. Otoh Kotlin aims to be "more functional", not "pure functional". The latter is one of the reasons people find programming with Scala and Scala as a language complex. That's also a reason (std) Kotlin doesn't give you all the functional concepts and doesn't urge you to program this way, which I like very much. For me the most important thing is that functions are first class citizens, in contrast to Java. Regarding function composition, this is therefore very easy to implement ([https://try.kotlinlang.org/#/Examples/Callable%20references/Composition%20of%20functions/Composition%20of%20functions.kt](https://try.kotlinlang.org/#/Examples/Callable%20references/Composition%20of%20functions/Composition%20of%20functions.kt)). &amp;#x200B; The funny thing is, that non-functional programmers rarely need this kind of function composition - for most developers writing a function, applying two other functions in there is (arguably) cleaner code. That's why Kotlin doesn't adopt it to his std. And this happens with many other features that kind of gave evidence that they worsen a codebase. Of course this depends on the point of view. But for nice Scala you need experts.
Just remembered a couple more that may help and are free. [https://www.udacity.com/course/kotlin-bootcamp-for-programmers--ud9011](https://www.udacity.com/course/kotlin-bootcamp-for-programmers--ud9011) [https://www.udacity.com/course/kotlin-for-android-developers--ud888](https://www.udacity.com/course/kotlin-for-android-developers--ud888)
I think, in the big picture, coroutines and Reactive streams are complementary, and not something that should supplant the other. With the new Flow API, which is basically Rx with a simpler design thanks to coroutines, it is even easier to mix them. One example where RxJava/Flow will shine is an autocomplete feature : In pseudo code, you can write something like : (sorry I am on mobile, so I will keep the snippet short) Inputs.debounce(duration).switchMap(fetchResult).map(formatResult) This is very expressive, and handle a lot of things for you, like handling time and cancellation of previous inflight request in case input change. Using raw Coroutines, it is feasible but would require more boilerplate and involve explicit state management (keeping the previous request, so you can cancel, if something new appear) On the other hand, Rx can be quite complex, and from my experience, most Android apps will only use it like glorified “Promise” using only Single or Maybe types and side effecting to the presenter/view mode. In this case rewriting with coroutines will make the code easier to read. I personally like the idea of reactive UI, where the output is a function of the user input materialized by a Reactive circuit, since IMHO it avoids a lot of issue with mutable state and allow testing techniques like marble testing. But most devs will be familiar with a more imperative style.
And kingfisher begins with K 😊
Yes, it has a lot of operators and they are greatly optimized while it's hard to implement new operators with back pressure and so on. With coroutines implementing your own operators with back pressure support is much easier.
I think in the original code, the author used Flowables with a single value, where he should have used a Single. If your codebase use a lot of Single/Maybe it is sensible to use coroutines instead. However if you would like a more functional style for handling data updates RxJava can be indeed a powerful tool.
&gt; Kotlin brought great compilation times ...no?
I struggled reading "The Joy of Kotlin". What did you think about it? I suspect I am not the target audience, and would not put it in the hands of pure beginners.
Same here, awesome experience!
I guess that you can represent them with literals such as "str" for strings and 'c' for chars.
does it give you a compiler warning, or just in the ide? but yes, you're right, may not be the best solution. problem is that the other options pollute the global namespace and it's not included in the std lib, so it will be questioned many times in code reviews. &amp;#x200B; What about just using the feature as it was intended? Use it as an expression and work with returns or local variables that explain themselves with names etc.
These are the "basic types", https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html
That's interesting. So it's basically "All the primitives + String because it's so common" But Kotlin's page also lists Arrays there.
Oh yes this makes sense too
If you get the time I'm still curious :)
Ohh yeah. Alright. Meant no harm. Peace!
Thanks was looking for an alternative to Jackson
Benefits over `kotlinx.serialization`?
&gt; And this happens with many other features that kind of gave evidence that they worsen a codebase. I don't think function composition or, say, proper pattern matching can possibly worsen a code base. I think the reason Kotlin developers don't think they need them is closer to the [Blub Paradox](http://wiki.c2.com/?BlubParadox).
Deep pattern matching through the DSL, and Either/Option-based safety, so no runtime exceptions.
!! Gives a compiler warning. I agree polluting the global namespace isn't good. In the article linked in the original post they also propose `.javaClass` No pollution, no warning but hard to read. So maybe `javaClass` plus a comment is the way to go?
Yup. The problem is that I don't know what to put there.
Yup. It's because I don't know what to put there. I planning to compare the array order of the user and password (2nd item in the username = 2nd item of the password). If the order in both arrays are the same then, it can be said that the username that was inputted coressponds to the correct password.
Try, if(inputed_password.equals(password.toString), false)) {} The .equals with the false at the end makes sure that it does not ignore case, this may work however it's bin a minutes since I've used it so I might've wrote it wrong bc I'm on mobile rn. Let me know and if you'd like, later today I have some time and I can show you a much more compact way of doing what you're trying to do
You misunderstood, this is not a suitable case for the Blub paradox. Nobody asks the question which language is more powerful and why - I even gave the hint that I'm also wondering why people tend to ignore the lack of HKT and what it means for advanced...or as I call it: **proper** functional programming. &amp;#x200B; Also, don't put all missing features in the same basket, the reasons for missing generic pattern matching may be different from the ones for missing reified generics, different from the ones for missing function composition. Let's stick to function composition. &amp;#x200B; Also, I just want to be constructive, so please don't understand this as offensive, but if you can't see function composition worsening a code base, than you lack the ability to take other people's perspective. There are multiple programming paradigms, each of them with strengths and weaknesses... From an imperative programmer's point of view, function composition is hard to debug for example. So if Kotlin would have added functions for composition or even language constructs, their usage would be more prominent, making Kotlin harder to adopt for people from non-functional programming backgrounds. Regarding the JVM, most people have Java background. Sometimes, there is no universal **better.** If code is better or worse depends on your experience, on your education, on your preferences and even on your habits.
You could return an instance of a function and instantly invoke it without requiring any extension function: when (somePet) { is Dog -&gt; { { println("Dog") } } }()
Regarding the DSL - are varargs still unperformant in Kotlin? I remember reading about how you should stray away from varargs because the spread operator is super slow. For example, I tend to avoid the builtin collection functions because they use vararg pairs (like you do in your example). ``` HashMap&lt;String, String&gt;().apply { this["abc"] = "123" this["raggle"] = "fraggle" this["foo"] = "bar" } // as opposed to... mapOf( "abc" to "123", "raggle" to "fraggle", "foo" to "bar" ) ```
Forgive me if I say anything wrong, I'm entirely going off memory, but; The spread operator is only really used when you're taking a vararg parameter and passing that vararg parameter to another function which also requires a vararg parameter (sorry if that explanation is confusing). The reason it's "slower" is because (at least on the JVM side) the spread operator will use System.arraycopy to create a backup of the array from the vararg parameter, however, the difference in speed is *generally* negligible, and it's better to use the factory functions provided by the standard library than doing what you showed in the first example. Also, I'm *pretty* sure that the factory functions in the standard library do not make any use of the spread operator, because they're just converting the array that you get from the vararg parameter into the respective structure.
Neither contributes to readability nor does it show the intent.
I think the reason why they didn't provide their own File implementation is for the sake of Java interop, so you don't need to convert between Kotlin File classes and Java file class. &amp;#x200B; As for whether or not they're planning to add their implementation, I remember listening to a [Talking Kotlin](http://talkingkotlin.com/) episode with the lead dev (?) for the Kotlin std-lib, and he was talking about maybe implementing their File api and Date api what with Kotlin native getting more "ready".
Yes, it can be a little hard, &amp; not for beginners. Kotlin in Action is probably better, if maybe a little outdated. I only started learning Kotlin about 6 months ago so I'm no expert. I'm struggling to understand some of the information, however I have found that if you leave some of the concepts and then come back to them, they get easier. Also, don't accept a single source of information. If you don't find the explanation very clear, look it up elsewhere. With these types of books just being introduced to a concept that you didn't know about is enough to begin with. You can will learn how to implement it later.
Also, the "spread operator" is when you do this: fun varargs(vararg test: String) { ... } val array = arrayOf("Hello", "World!") varargs(*array) // Spread Operator (*), performance impact here! varargs("Hello", "World") // This isn't a spread operator, so it won't have a performance impact (I think, please correct me if I'm wrong!") I think /u/SirBraneDamuj is thinking that the `varargs("Hello", "World")` call is also called `spread operator`, however the spread operator is when you use `*` on a array to "spread it", allowing a array to be used in place of varargs.
I think I mischaracterized the issue - it is less to do with varargs and more to do with the `Pair` creation for each individual vararg. For example, Google's `ImmutableMap.of()` factory method uses varargs but takes each pair of args as key/value pairs instead of wrapping each pair in a tuple. https://stackoverflow.com/a/48727053/757888 According to this answer, and confirmed by [my own reading](https://kotlinlang.org/docs/reference/constructing-collections.html), the *mapOf* factory methods should not be used in "performance critical" code for that exact reason.
Yeah I mistyped that, my bad
Sorry, I had so many notifications when I came home from work yesterday, I forgot about this. This is a modified version of something I wrote earlier when asked to compared Javalin to http4k (another framework). Javalin is a Java/Kotlin web server library, it will help you with web server things, like creating REST/WebSocket endpoints and serving static files. Ktor is a pure Kotlin "http toolkit", they do a bit of everything. They provide wrappers for multiple servers, they have a http client, and they have wrappers for templating and JSON libraries. The idea is that this should make things easier for end users. Javalin on the other hand tries to do as little as possible. It provides a nice abstraction layer on top of Jetty for setting up the server, but it's up to users to pick their own libraries for other tasks. JSON / templating libraries can be plugged in easily by implementing interfaces (typically by using lambdas). Javalin doesn't care what HTTP client you use, just find one you like and follow their docs.
In Java, primitives + String + arrays are the special types for which special operators and literals are defined.
Is it not multiplatform?
You should remove the inner if/else. If your first if is evaluated positively, I suppose you just want to print "hello inputuser"? Your else stays the same. Some other tips: \- you don't have to specify the type of the array here since Kotlin can infer it. \- you can declare and assign your inputuser and inputpassword variables in the same line here, and make them a `val` instead of `var` since you're not reassigning them anywhere else. \- In Kotlin, you can simply compare strings using == (as opposed to Java, where the correct way is with `equals()` method. &amp;#x200B; Hope this helps!
The first if/else statement checks if the input is present in the arrays of both vars The second if/else checks if the input has thevse order in both arrays ( userinput order is x &amp;&amp; userpassword order is x) then correct combination of user and pass else, wrong combination. Thank you for the tips though. I'll try to change it once I get home after 2 days.
Maybe I can message you after 3 days? Currently not in home as of the moment. Thank for the advise though. I'll try to use it and get back to you when something happens.
Sure, that's fine just lmk :)
fun main() { val pass = "p4$\\$w0rd!" val user = "username" *println*("Enter a username: \\n") val userinput = *readLine*() *println*("Enter a password: \\n") val passinput = *readLine*() if (passinput.*equals*(pass, false) &amp;&amp; (userinput.*equals*(user, false))) { *println*("thats right") return } else { *println*("thats wrong") return } } &amp;#x200B; This is what I did, it works.
But Android IDE would still use cmake right?
The best kotlin book for beginners I have found is head first kotlin. Most other books either assume you know oop programming or spend way too long comparing each and everything with java
The bootcamp is nowhere near beginner level. Especially not for no programming experience ones.
Appreciate the honesty on performance
Android Studio uses Gradle, not CMake
For it: `(Foo) -&gt; Bar` For this: `Foo.() -&gt; Bar`
I don't exactly get what you mean, `it` is the implicit name given to a one-parameter lambda's argument, if no other name is provided. E.g. `(1..10).filter { it % 2 == 0 }` is the same as `(1..10).filter { num -&gt; num % 2 == 0 }`. On the other hand, `this` can be shadowed in lambdas if they have a [receiver](https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver).
Yes. Receiving `it` is slightly easier. All lambdas that take one parameter can refer to that single parameter as `it`. For example, both of these are equally valid: listOf(1, 2, 3).forEach { x -&gt; println(x) } listOf(1, 2, 3).forEach { println(it) } It's the same `forEach` function in both cases. The compiler just provides this convenience to callers. Receiving `this` is a little more complicated. But fortunately `with` is implemented in pure Kotlin code. [Here's the source](https://github.com/JetBrains/kotlin/blob/v1.3.31/libraries/stdlib/src/kotlin/util/Standard.kt#L60). I'll boil away the unnecessary details: public inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R { return receiver.block() } In particular, look at this type: T.() -&gt; R This is sort of hard to read. Start with this: () -&gt; R You know that - it's a function that takes no arguments and returns `R`. Now look at this: T.() -&gt; ... This represent a function that takes no parameters *but whose receiver is T*. The `T.` that got glued onto the front is the part that determines the type of `this` within the passed-in `block`. Finally, look at this in isolation: receiver.block() That looks like a function invocation. `block` could be a member function or an extension function... we can't tell from the call site. So here's how to put it all together. `with` takes a parameter called `block` with a complex signature - the signature includes the type of the "receiver". Because `block` specifies that its receiver type is `T`, we can use `block` *as if* it was an extension function on `T`. And that's exactly what we do when we call `receiver.block()`. This pattern - taking a function with a receiver type - is essential to Kotlin-style DSL construction. [Here's a writeup on that pattern](https://kotlinlang.org/docs/reference/type-safe-builders.html), which also might help you understand `with`.
```kotlin // Equivalent of standard library "apply" function, just simplified to String fun String.withThis(block: String.() -&gt; Unit) { this.block() // block(this) would also work } // Equivalent of standard library "also" function, just simplified to String fun String.withIt(block: (String) -&gt; Unit) { block(this) } // The block in this example gets two arguments, as "this" AND "it" fun String.with(number: Int, block: String.(Int) -&gt; String): String { return this.block(number) } fun main() { "foo".withThis { println(this) } "bar".withIt { println(it) } println("foo".with(42) { this + it }) // prints "foo42" } ```
I think OP is talking about kotlin-native
Check out this 50 minute talk from GOTO Chicago 2019 by Roman Elizarov, Kotlin Libraries team lead at JetBrains. The full talk abstract can be found below: &amp;#x200B; Kotlin was designed as a general-purpose programming language and with coroutines writing server-side code is a easy as never before on JVM. We'll dissect scalability and reliability problems of a traditional thread-based stacks and discuss the process of mitigating those issues by introducing asynchrony with Kotlin coroutines. We'll see how coroutine-based design naturally avoids common pitfalls of traditional asynchronous programming such as resource management, error handling and request cancellation, producing safe and reliable code using a concept of structured concurrency.
Ahh. Yeah, that'd make sense.
I may have started doing Android app development a week ago, But I made a note to self that the main build tool is Gradle. I was just asking to see if anyone would like to add support to Meson for command-line usage and to share Kotlin with Meson users. If not then Gradle is pretty cool.
Android developers can use CMake in Android Studio? With Kotlin?
Nice talk! Just one question though, currently what are the recommended servers that go well with coroutines? I think for now only vertx has built in coroutines support, right?
I recommend kotlin/kotlin-koans on GitHub to solve some exercises. Furthermore, there is a GitHub repo currently on development with a collection of snippets that shows the features of kotlin :) You can give a look on HTTPS://github.com/nnunes10/LearnKoltin.
If you want to make meson to support build an Android APK, I think it would be complex work. You may need to define a lots of variables which Google has done that for you and update them with Google API version.
In my mind "performance critical" aren't your network calls or your socket connections but your render loop. Please don't parse/create JSON on your render loop 🙇‍♂️
Use IntelliJ.
Thanks
And Ktor. Vertx has more community and extensions. Ktor is simpler and focused on doing http with coroutines
For anyone not watching the video, it's worth mentioning that during the talk Roman mentioned that the next minor release of the spring framework (spring 5.2) will support coroutines and suspending functions as part of the framework's ongoing kotlin support.
Look up "coroutines", they're the proper solution to this problem. Failing that, you can use a mutex.
Oh yes, ktor too. But both of these are more than just web servers since they provide a lot of other functionalities too. Is there any project like tomcat, netty, grizzly, etc that supports coroutines out of the box? For projects that don't really require all the functionalities of ktor and vertx.
up for netty
netty is lighter than vertx or ktor (in fact they are built on top of netty) but definitely lighter than tomcat. An they are modular, so you can use, load and distribute just what you want It is quite easy to use coroutines on top of netty by delegating on channels.
I found this solution searching to access all `componentN` fields of a data class without prior knowledge of which specific class is and without using Reflection: https://stackoverflow.com/questions/47730421/is-there-any-way-to-iterate-all-fields-of-a-data-class-without-using-reflection The actual problem that I solved in an Android app was to recursively iterate through a tree of objects to find specific instances of class X. The tree looks something like this: ``` sealed class Component { data class A(val action:Action): Component() data class B(val c: C): Component() } data class C(val action: Action, val other: String) ```
Civet - because they eat java (coffee beans).
Ktor is quite modular so you can pull in only the functionality you need, e.g. just netty + coroutines
That's nice 😊
Can you add more detail to what you are trying to do?
I wish to know how to make a button, switch etc do the task I want it to do. Such as reveal a text or transfer the user to another page.
It sounds like you are just starting out with Android development. Have you gone through any tutorial videos or courses?
great talk, but i disagree with Roman's bikeshedding on project loom vs coroutines. his "shared threadpool solution" is great, until you can't share. loom will have the benefit of the runtime enforcing who shares what. i think the marriage of the two (project loom + coroutines) is going to be epic, especially in the web server space. Writing non-blocking "reactive" code is hard. really really freaking hard. it forces you to deal with every edge case (which is amazing, don't get me wrong). structured concurrency is so much nicer (imo)
I am, and yes I have watched many online videos and have learned a bit but not necessarily what I am trying to learn.
Starting with the [Button docs](https://developer.android.com/reference/android/widget/Button), and also a random search into [Stack Overflow](https://stackoverflow.com/questions/44301301/android-how-to-achieve-setonclicklistener-in-kotlin), it should be as simple as: `button.setOnClickListener {`
 fun A(): B { val callback: () -&gt; B = object: Callback&lt;&gt; { onSuccess() //get one possible return value here onFailure() //get another possible return value here } return callback.invoke() }
How do you link a button to an action
What do you mean by "action"?
Forgive me I'm slow... Can you make a button have a text appear or make the color of the screen change....how do you write the code to make stuff happen(started learning 3 days ago)
Schedule only schedules something once if you only use `delay` parameter. Make sure to read the documentation! To make it recurring, you want to add another parameter of type `Long` above 0, which is `period` and repeats your task every `period` milliseconds. ``` fun main() { val timer = java.util.Timer() val task = object: TimerTask() { var timesRan = 0 override fun run() = println("timer passed ${++timesRan} time(s)") } timer.schedule(task, 0, 1000) } ```
Jesus dude you're trying to sprint without knowing how to walk. Follow some basic Android tutorials and take it slow
Interesting question, a roundabout way of asking: "Why choose Kotlin over C# for server side development?" I'm a C# dev myself, but I would say that you would choose it because: * You have an investment in JVM languages (your company or personal expertise is here) * You want to use some libraries or frameworks not supported by .NET Core (Spring for example) * You want to deploy whatever you're building on Linux (or just !Windows) * (Personal opinion) Web Hosting / Cloud costs for open source stuff is cheaper than windows stuff * You can write mobile apps (Android for example) in the same language you use for your server code These are just my opinions, somebody else with actual kotlin experience would likely have better insight.
The questions you are asking for are really basic, which is OK! But it also means this probably isn't the best forum to get answers from. It will just take too long. If I were in your shoes, ideally I would want to find a mentor / tutor who could actually stand by my side and help me learn to code an Android app. But not too many people can have access to someone line that, so instead, just go through more tutorials. Here's a course created and offered for free by Google: https://eu.udacity.com/course/android-development-for-beginners--ud837 Looks like it basically goes over building layouts, which is what it seems like you are really asking about here.
Thank you
That pic tho...
 suspend fun &lt;T&gt; awaitEvent(block: (h: Handler&lt;T&gt;) -&gt; Unit): T { return suspendCancellableCoroutine { cont: CancellableContinuation&lt;T&gt; -&gt; try { block.invoke(Handler { t -&gt; cont.resume(t) }) } catch (e: Exception { cont.resumeWithException(e) } } } Sorry for the shitty formatting, I'm on mobile. It's plucked out of Vertx courouting helpers that you can check here: https://github.com/vert-x3/vertx-lang-kotlin/blob/master/vertx-lang-kotlin-coroutines/src/main/java/io/vertx/kotlin/coroutines/VertxCoroutine.kt Checkout also awaitResult in that same file for the complete picture Here's how it's used: Message&lt;String&gt; reply = awaitResult(h -&gt; eb.send("someaddress", "ping", h));
What I've always enjoyed about kotlin is how nice it is to check out the actual implementations of these methods you're talking about. For example, in most IDE's you can just view the implimentation of with. and you see the block parameter is T.() -&gt; R Which gives you 'this'. Seeing the implementation of also, we see it's block is (T) -&gt; Unit Notably you can also see the implimentation of also also uses 'this', it does so because it is an extension function T.also Kotlin is VERY accessible in this regard and you can learn a lot by looking at your favorite functions.
If the server already has a solid async support (promises, reactive, etc), adding Kotlin coroutine support yourself is really not hard. I implemented coroutines for the Ratpack server in 38 lines of code (which includes comments and imports - it's around 10 significant lines actually) and it's been working great in production for over a year now.
TinyLog is a tiny logging framework with quite some features. It can be used in Android or standard Java applications, and this post goes into some of the features and how to use it.
It's the avatar of the person who wrote the library. I find it cute
&gt; Support for OpenAPI (Swagger) with Swagger UI and ReDoc How much of the complete spec does it support for now? I'm guessing security schemas are not yet supported as I couldn't find any option in the source.
The main disadvantage of Kotlin is that most people will need counseling: "Hi, I'm Bob and I'm addicted to Kotlin" One dose of Kotlin and your eyes will become open, your senses activated, your very soul awakened. Your journey of adventure begins. You are at peace.
I'm not sure. You'll get a better answer by opening an issue on GitHub and tagging @TobiasWalle :)
&gt; you'll get a better answer In Soviet Russia, a better answer'll get **you**! ^(this post was made by a highly intelligent bot using the advanced yakov-smirnoff algorithm... okay, thats not a real algorithm. learn more on my profile.)
If Kotlin had better pattern matching and for comprehension I would be a happy dude.
Sorry very new to Kotlin, I assume I put the main function in the MainActivity class? And if so do I need to call the main function?
Thank you &lt;3
Yes. @jimontgomery you should try to use \`coroutines\`. Here is the example from [Roman Elizarov](https://stackoverflow.com/users/1051598/roman-elizarov) a member of Kotlin team. [https://stackoverflow.com/questions/48552925/existing-3-function-callback-to-kotlin-coroutines/48562175#48562175](https://stackoverflow.com/questions/48552925/existing-3-function-callback-to-kotlin-coroutines/48562175#48562175) &amp;#x200B; If you can't use kotlin coroutine (for some reasons) =&gt; you can try use RxJava/RxKotlin. \-- For theory, if you don't want to use any library there is a solution by using Thread &amp; Lock. The code looks like: class Demo { private val lock: Lock = ReentrantLock() fun A() { val callback = object : Callback { var result: Any? = null override fun onSuccess() { result = "ResultOk" lock.unlock() } override fun onFailure() { result = "ResultFailure" lock.unlock() } } runWithCallback(callback) lock.lock() println("Here is your result: ${callback.result}") } }
Thank you for the great library :) I love lazy log feature. &amp;#x200B; Also, here is the github repo: [https://github.com/pmwmedia/tinylog](https://github.com/pmwmedia/tinylog) , right ?
How would I go about making it so that override fun run() = runFunction() because it is saying void is not a subtype of override (my runFunction function just runs a debug and returns null)
How would I go about making it so that override fun run() = runFunction() because it is saying void is not a subtype of override (my runFunction function just runs a debug and returns null)
I didn't write the library, I just wrote about it ;-) And yes, that's the repo, the main site is here: https://tinylog.org/v2/
I'm not sure what your runFunction's signature is but if you are returning null then that could be causing a mismatch with TimerTask.run which is (): Unit If you are returning null from runFunction, then try something like this: val task = object : TimerTask() { val count = 0 override fun run() { runFunction() } } timer.schedule(task, 0, 1000) Or, if runFunction doesn't really need to return anything, then change its signature to void.
&lt;3 &lt;3 &lt;3 &lt;3 Thank you
The biggest disadvantage of Kotlin is Gradle. At least it gave me a hard time and is still guess work here and there.
You can also use Maven with Kotlin. I used Maven for a couple years (back in my dinosaur Java days) and find Gradle to be much better. I had issues with local dependency management which required blowing away the maven cache but haven't had any issues with Gradle. Also, custom maven plugins were a pain to get right. Maven is easier at first and then it becomes a constant bottleneck. The slightly larger up-front cost for figuring out Gradle is definitely worth it.
These are qualified returns which you defined with a label. You can used them to o return from an outer function and they are especially used to return from lambda expressions. The following video explains this concept with some examples [https://www.youtube.com/watch?v=sU-Jy3RaKWM](https://www.youtube.com/watch?v=sU-Jy3RaKWM)
I have tonnes of Kotlin experience and I know all the advantages of it as a language. I have little C# experience. I was hoping for more of stuff like security concerns or other things that I can find on C# that may be hard to replace with Kotlin (as far as Server side logic goes).
Gradle is fine imo. Especially since you can use Kotlin DSL.
It's not really the language itself (C# or Kotlin) that has advantages or not, they both are largely capable of the same things. So it's more implementation that matters at that point. Also do you want to be on the JVM or on the .NET Runtime. I know from working with Java that [Type Erasure](https://en.wikipedia.org/wiki/Type_erasure) on the JVM drives me up the wall. C# Reflections are so powerful and useful compared to Java. Kotlin probably suffers from this too because it's a JVM language. Type Erasure and poor ability to reflect on the code metadata is the main disadvantage I can think of compared to C#. Syntactically, I think that C# is just a better language than either Kotlin, or Java (pure opinion though). I also think that .NET is faster than the JVM in general. I think the tooling in .NET world is better than JVM world (thats highly subjective though).
**Type erasure** In programming languages, type erasure refers to the load-time process by which explicit type annotations are removed from a program, before it is executed at run-time. Operational semantics that do not require programs to be accompanied by types are called type-erasure semantics, to be contrasted with type-passing semantics. The possibility of giving type-erasure semantics is a kind of abstraction principle, ensuring that the run-time execution of a program does not depend on type information. In the context of generic programming, the opposite of type erasure is called reification. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Kotlin/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
For rich web apps, [https://docs.kweb.io/](https://docs.kweb.io/) relies on coroutines for efficiency.
Yeah, I guess it's a personal thing with Gradle and me ... :-) Probably I refuse to invest some brain cycles to learn a build tool.
1) When something is loaded eagerly it's done when the call is first made. When something is done Lazy it's done when called upon. So when the filter is called, it filters all the items right away. Lazy would be when the list is when you try to use the filtered list. 2) A List holds all the elements at once, where sequence only holds what's been called upon. Meaning you can call List[2], and just get the third object in the list, where a sequence will only hold things in sequence. Meaning you have to go through 0 and 1 to get to 2. 3) The map function will iterate through everything in the collection (the super type for list and sequence), and run the specified function. In this case print the element. So What would happen for an eagerly filtered list. It would print out all the elements with the starting letter P. A lazy filtered list will filter when the map function is called. In this case when nothing has been filtered yet, there's nothing to print. When using a sequence, it only contains the first element so far, so it only prints one thing. Then once you've iterated over all the list, you've completed the filter, and then you'd print everything.
It’s a shame that this isn’t built into data classes. It would be even more useful it it populated a map of property values, then the names would be available as well.
Re. the Arrow bits we're replacing `Try { }` with `Either.catch { }`. This catch will allow (and require!) suspension to handle lazy + exceptions. Either is the same API as Try except for the constructor that was primarily used inside coroutines already, so for us it was just unnecessary duplication.
Looks pretty interesting. Couple of questions for you: What's the purpose of the config? It's unclear just by reading the readme. From what's there it looks like that value could be defaulted unless custom implementation is needed. Can this use reflection or some kind of schema lookup to create random values accordingly?
Clojure is worse. Once down that rabbit hole you'll never be able to look at OOP code again.
Just use intellij
You could use a lambda function.
Spring does everything I've ever needed to do and to me it's pretty easy(once you learn it). Beware of Vaadin which is the worst java library I have ever used.
I'm curious, what would you use the name of the properties for?
Writing my own generic toString, serialising to JSON, writing lists as tables... Lots of places where I would otherwise use reflection.
I guess the docs are not that clear :-/ Basically config contains random number generators. The lib contains some implementations included, but people can implement their own and provide them in config.
----- When something is loaded eagerly it's done when the call is first made. When something is done Lazy it's done when called upon. ----- Not that clear. Or perhaps my understanding of english "make a call" vs "call upon something" is not accurate. ----- So when the filter is called, it filters all the items right away. Lazy would be when the list is when you try to use the filtered list. ------ A word or phrase is missing to make things understandable.
Kotlin has a REPL. You don't like it ? Not fast enough ?
You cannot load arbitrary files, or external repositories, or reload existing files.
May I suggest considering [kotlin-result](https://github.com/michaelbull/kotlin-result)?
What, after I specifically said that Result4K was only worth considering because it no longer called its types Ok and Err ;-? kotlin-result looks a fine library, but really no library gives me something that I couldn't roll for myself (see the rest of the articles in the series) unless it is adopted as a standard. So whatever you use now had better be easily refactored into \`kotlin.Result\`.
Is Kotlin-result available in any widely used package repo? Artifacts existing solely in personal bintray package repos alone aren't going to fly as acceptable at many-many enterprises. MavenCentral is definitely a total arse to be sure, but it does provide certain immutable guarantees to the end-user. :)
Very nice! ✌️
I also sent the same "bug report" (I'm still not sure if this is a bug or not) on Kotlin's Slack channel. Restarting the JVM magically fixes the issue, until after a few days it stops working again. Using JVM 12, Kotlin 1.3.21 + Coroutines 1.2.1 (Yes, I know, it is outdated, I didn't update yet because I couldn't get Kotlin's script engine working on 1.3.31... if reeeally needed I can update, but I decided to ask here before I do it to figure out if anyone knows *what* could cause this issue (or if it was already fixed)) Here's a GIF showing the issue, the code is evaluated, executed buuut it gets stuck on the `delay(...)`, no matter what dispatcher I use. https://cdn.discordapp.com/attachments/393332226881880074/589923294916902961/SayRQ1OGN5.gif Of course, maybe it is a issue on my end... but I can't figure out what would cause this issue because restarting the application fixes the issue (until it breaks after a few days...).
Oh shit I just wanted to use delay in a new program to delay a coroutine for several days...
Are you sure that it's not your program that end before the coroutine can do its job?
No, it isn't, look at this GIF: https://cdn.discordapp.com/attachments/393332226881880074/589923294916902961/SayRQ1OGN5.gif The application is still up and running, but the code never finishes. :(
Sounds like a leak. I would get a memory dump and see if you can pinpoint what's leaking.
Have you proven it's not an issue in context.sendMessage, rather than the delay itself not resuming?
Yes, it isn't an issue there because if I remove the `delay` (or set it to `0`) it works fine.
What's the advantage in having a wrapper around moment.js rather than using kotlin's multiplatform date functions in the standard lib? I assume moment.js has more convenience functions but those could be implemented as a multiplatform lib if not in one already?
Can you output logs in your setup? I.E. can you shove a log line after the delay and see that it definitely does not print? No race condition where something is cancelling the parent job / whatever is evaluating the code you're sending it and only happens to occur when there's a delay of some sort?
I will try doing that later, but that's a last resort to me that I will only do if there isn't any other way to debug the issue, because the memory dump will be big (~36GBs) and opening big memory dumps on my poor laptop is hard. Also, why a memory leak would cause that issue? I mean, sure, if something never unsuspended would cause a leak, if it was never unsuspended, then that code would just reuse the thread and continue from there, which isn't what is happening here.
Yes I can, also repeating what I found out later: What *looks* that it happens is that after a veeery long time (way more than the specified delay), the coroutine does continue. Here I executed the code: https://cdn.discordapp.com/attachments/392476688614948897/589958622000185549/unknown.png And after almost one hour later... the code was executed. https://cdn.discordapp.com/attachments/392476688614948897/589958706410553356/unknown.png Very strange, as I said it isn't that there isn't available threads to process the requests, because launching tasks works, only `delay` seems to have that strange issue. (even suspending functions works fine, except if they call `delay`)
And you've run the log test to make sure code after the \`delay\` isn't executing? Agreed it looks strange, I'm just going from the angle where I assume I'm doing something wrong/missing something before assuming the framework is buggered. There's a lot going on in the examples you're showing, it looks like what you're working on is a bot that evaluates code and optionally send messages to a channel on a discord server. All of the examples of delay not working is using the discord API to send messages which is a pretty loaded example with a lot of room for external issues. Personally I'd spam the shit out of my code with logs, because I'm slack about using the debugger, to make sure nothing I've done is halting unexpectedly. Then I'd tell everyone I solved my issue using something more complex than log statements so I look smarter. Here's some info on debugging coroutines. You can probably google to find some better info: [https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/debugging.md](https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/debugging.md)
So I assume that delay uses some data structure under the hood to keep track of what's pending. If that keeps growing it'll take longer and longer to traverse. So yes a memory leak can definitely lead to long execution times for a function. Are you doing anything that would cause "delays" to pile up faster than they can be resumed?
If you want a real life example, here's where it gets stuck on a "real code": https://github.com/LorittaBot/Loritta/blob/master/loritta-core/src/main/java/com/mrpowergamerbr/loritta/modules/WelcomeModule.kt#L180 Yes, enabling TRACE only shows the log before that... `[18:52:37.313] [Coroutine Executor Thread 149520/TRACE]: Member = MB:🎮Moon🎧Gamer🎮(U:🎮Moon🎧Gamer🎮(550552970690035712) / G:Apartamento da Loritta 🌇🌃(297732013006389252)), Waiting 500ms for net.dv8tion.jda.api.events.guild.member.GuildMemberLeaveEvent@541a16b7 before processing member quit messages... (audit log delay)` `[21:24:59.188] [Coroutine Executor Thread 155608/TRACE]: Member = MB:🎮Moon🎧Gamer🎮(U:🎮Moon🎧Gamer🎮(550552970690035712) / G:Apartamento da Loritta 🌇🌃(297732013006389252)), Waited for 500ms for net.dv8tion.jda.api.events.guild.member.GuildMemberLeaveEvent@541a16b7!`
&gt; So I assume that delay uses some data structure under the hood to keep track of what's pending. If that keeps growing it'll take longer and longer to traverse. So yes a memory leak can definitely lead to long execution times for a function. Are you doing anything that would cause "delays" to pile up faster than they can be resumed? Ohhhhh that's a good point, maybe that's the issue. I can't run it with less memory because that's the main instance of the application, I will try reproducing on a test instance (it happened before there).
nothing is noble about forcing yourself to suffer unnecessarily!
Hm, maybe delay is using system.nanotime, which overflows after some time and the delay method can't handle that?
Learn it, Shakespeare! You loose nothing.
Learn it, Shakespeare! You loose nothing!
Thank You very much! That was helpful
&gt; Binary search is a primitive example of a *divide and conquer* algorithm. Where is the 'conquer' part of this algorithm?
I think it's the value that the field is set to. &amp;#x200B; On a separate note, this will be an infinite recursion, as the setter calls itself. Additionally, using = to replace \*= is just going to confuse users.
`num1` is defined on line 14. You don't need to specify a type because it must match the variable's type.
you write a setter for volume and num1 ist the argument you pass into the setter. Also, you cant use volume because this will call the setter again and therefore you get an infinite recursion. Also I would suggest to always use value as the argument for your setters so you dont get confused. &amp;#x200B; val volume: Int get(){ return width*height*length/1000 } set( value ){ field = field * value }
If you use Create React Kotlin App, there is no possibility to use nothing that is not in a NPM package and Kotlin JS Date is a bit limited (its just the copy of JS Date), but primary reason why I wrapped this library is just for Ant Design DatePicker and other components depending on it. Another possibility is to create a Web in Kotlin JS without Create React Kotlin App, using it with JetBrains frontend Gradle plugin, but needs more configuration and in practice is less productive, although you can use Ktor Client for HTTP requests thats is very cool (I hope they publish it to a NPM package, recently is an issue in Ktor GitHub).
it seems you're pretty early on in your path to becoming a programmer. you might should visit /r/learnprogramming
Additionally, looking at this code, you would want volume to be a val and to remove the setter since it is calculated. Users shouldnt be able to set volume without changing height, width or depth.
What you have here is a custom getter and a custom setter. The setter is a way to redefine what writing volume = 100 means, in this case num1 would get the value 100 and it would take itself times 100. But, as EntropySpark said, you're introducing recursion here as you are setting it again inside the setter. You're also not using the set value in your getter, so anything you set volume to will be ignored in the current implementation. You can read more about getters and setter here: https://kotlinlang.org/docs/reference/properties.html
My irst thought would be to grab a thread dump during the period of time where delay isn't "finishing"....you might locate some unexpected deadlocks that expire/release some time later.
I dare you not to learn it. I bet you won't be able to stay away from Kotlin now that you peeked in Pandora's box.
Good info thanks! You must lose some kotlin features by transpiling (e.g. Ktor) to js first then publishing. Might it be better for Create React Kotlin to accept multiplatform kotlin packages somehow (?) so the entire app can be transpiled together?
As I know, when you use Kotlin JS in a multiplatform project, the Gradle plugin is transpilling Ktor Client to js in a form that frontend Gradle plugin can use it, using Webpack under the hood and having the possibility of managing NPM packages, so being all in same Gradle project NPM package is not required. Create React Kotlin App use Webpack under the hood, same as frontend Gradle plugin, so my question is why Ktor Client already have not a NPM package, maybe JetBrains wants to promote the use of Kotlin multiplatform and the use of Kotlin for Web in a Gradle project with frontend plugin?, I don't know haha.
When talking to Roman Elizarov on Kotlin's slack channel he did tell me to do the same thing as you said, but he didn't notice anything unusual on the threads (aside from my executor having a lot of created threads, but nothing that would 100% prove that there is something locking up)
Ah yeah, now I see what you mean. I hadn't really ever thought about the performance impact of it, but creating those pair classes to just be discarded immediately after would definitely have some sort of impact.
x.forEach { print(it) }
It's not a garbage value, it's the object reference of the character array. The default implementation of toString of an object. Use Arrays.toString(charArray) to get the string value or print it each character separately like the other guy here commented.
I have a larger code where I took a String as input, converted it to CharArray and perform several operations on it. Now I want to reconvert it back for printing as a capitalized string, but it gives a garbage value. Code: fun main() { var x = readLine()!!.toCharArray() print (x.toString().toUpperCase()) }
Converting an array to a String with `toString()` always results in Garbage on the JVM (because arrays don't override `toString`). Use for example `String(charArray)`.
That's what a char array looks like as a String. `[` representing an array, `C` because it's a char array, then `@aec6354` which I think is its location but I'm pretty sure isn't defined. If you want to create a String from those characters, use `x.joinToString("")` or `String(x)` or `java.lang.String.valueOf(x)`
If you're using Kotlin, why wouldn't you use [Moshi](https://github.com/square/moshi)? Anyone have any experience leading them to prefer Jackson?
Thank you kind sir ! x.joinToString("") worked like a charm
&gt; then @aec6354 which I think is its location but I'm pretty sure isn't defined. aec6354 is the hashCode of the array in hex. (Note that the hashCode for arrays doesn't depend on the content, it uses the identity hashcode from Object)
It decouples the language level from the backend VM. If the JVM gets a feature that would help Kotlin's bytecode performance, I assume they would just release a new target and we would all change our kotlinOptins.jvmTarget to the new version.
No, it would have said so on https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/associate.html
Thanks!
Actually starting from version 1.3.30 kotlin supports bytecode targets 9-12 (see [this blog post](https://blog.jetbrains.com/kotlin/2019/04/kotlin-1-3-30-released/#more-6991) for the details).
Nice! That was news to me
Will do , and thanks for getting the Shakespeare reference.
Because of Kotlins ability to be as addictive as chocolate cake. Both in syntax and fetchers, I would not be winning that dare anytime soon. So to peek in Pandora's box ones more.
Conquer in the context of divide and conquer means that you have a great improvement over processing performance. Binary search has average and worst case O(log n) time completely. It's a lot faster than searching something by a plain iteration O(n). Although a requirement for binary search is that the elements are sorted.
Awesome !
The only real change is this: [https://openjdk.java.net/jeps/309](https://openjdk.java.net/jeps/309) This allows potential future optimizations, but I don't know if it's actually used by a compiler already.
No experience with the alternatives, but nevertheless my reasoning: My decision to use Jackson was driven by "taking the save road". I know Jackson is very battle tested and mature and I want serialisation to just work. (JVM only)
From [Wikpedia](https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm): &gt; A divide-and-conquer [algorithm](https://en.wikipedia.org/wiki/Algorithm) works by recursively breaking down a problem into two or more sub-problems of the same or related type, until these become simple enough to be solved directly. The solutions to the sub-problems are then combined to give a solution to the original problem. The latter part ('combined to give...') is the 'conquer' in divide and conquer. Binary search is not a divide and conquer algorithm.
So no support for the string memory optimizations I take it?
Ok never heard that it has to be a combination of the results but I would still consider that as divide and conquer. The actual meaning of that is if you divide your problem size you get faster processing times. I actually never heard that really specific definition like in Wikipedia.
No but you can use `lazy` for that
original author here. &amp;#x200B; Basically we were doing classical java+springboot microservices, and we just recently switched to kotlin. As I was afraid of dumping too many new things on my team at once, we kept springboot. Jackson is very well integrated into it, and you have to touch relatively little, specially if you don't have esoteric needs. &amp;#x200B; I have been slowly trying to try kotlin native alternatives for common libraries (detekt, mockk) as I become more familiar with the whole ecosystem. I'm taking a note to check out the ones that you proposed :)
I'm about to propose converting our micro microservice setup to Kotlin. Did you find any good libraries to replace common tasks? I'm currently considering using a kotlin native DI approach (maybe koin), and replacing Jersey. Also, have you seen any immediate advantages over java? Management wants me to discuss why kotlin would be a better choice than java 10/11/12.
thus far we have been very careful with adding extra libraries. I really like mockk, we are using atrium for assertions although that one seems less established. I want to try Arrow and ktor, although I'm afraid it might be a bit too much for us. &amp;#x200B; For us the strategy of replacing java with kotlin while staying on mostly the same basics has worked quite ok to get used to the language. One drawback is that many java libs don't annotate nullable values properly so we had a few surprises. &amp;#x200B; I have been thinking about advantages and wanted to build some slides for that, but haven't gotten around to it. Some points I would have: \- null safety: A good chunk of the errors we had in old services were unhandled null values. This is a \_lot\_ easier to deal with in kotlin \- immutability: I am a very big proponent of immutable objects, and kotlin makes it a lot easier to build that in (we were using a combo of lombok and guava before) \- compactness: Our backends do a lot of moving JSON stuff around, and compared to similar services written in java, we just have a lot less code to maintain (while keeping readability high) &amp;#x200B; in the end it is fairly subjective, but I am extremely happy to be able to work with kotlin, and my impression is that our team didn't have a hard time transitioning. I personally used to work a lot with Ruby, and Kotlin gives me a similar feeling in terms of how terse the code is, with the bonus that types are there as a failsafe (and they do a very good job of keeping them out of the way)
Another thing, your get() function doesn't access the backing field (just the word field as mentioned in other comments) Setting the volume = 30 might change the backing field, but because your get() function doesn't use "field" -- setting the value will not change the get variable so if you said volume = 30 println(volume) // outputs "6" (10*20*30 / 1000) if you want the ratios to change with the volume it would look like this &amp;#x200B; var volume: Int get() { return width*height*length/1000 } set(value) { val volTemp = volume val change = cuberoot(value/volume) //idk cuberoot function width = width * change height = height * change length = length * change } This code is just an example of what the setter field will do. Now if I do volume = 30 println(volume) // outputs "30" println("width = $width, height = $height, length = $length") // --&gt; "width = 17, height = 34, length = 51" so setting the volume would change the width, height, and length Now I don't think it's very good practice to change other variables within a setter unless it's obvious that that should be the consequence--but that's just my opinion. This code will also have trouble if any of the width, height, length are 0. I just wanted to demonstrate the power of these fields.
Thank you for the answer! This will help me. I have also looked at ktor and Javalin. Arrow is unknown for me. I'm not sure what I will go for there, as I assume devs want something with an approach close to the old way (Jersey). I need to do some more research there.
What you can use already are `private`, `protected` and "package" visibility on classes and methods. Java defines package visibility by omitting the specifier, eg `void hello(){ ; }`. Kotlin has it's own take on this called `internal`.
Wow that is a noisy api. Drowned in all the types and annotations to have any idea how to grok it.
Those should just work because they happen at the library level.
Hmm ok. I was thinking there was some Java 10+ compiler tricks and "hidden?" methods that helped with String usage in my code, but I could have misunderstood it.
If I understand it correctly, a Kotlin String is mapped to the underlying language's string equivalent, so in this case a JVM String, correct? Which would mean that if you run a Kotlin application on a Java 9 or higher JVM, you get the benefits of [https://openjdk.java.net/jeps/254](https://openjdk.java.net/jeps/254)?
I'm already done with a problem using that code. What I was planning to do was use 2 String arrays for pass and user (using the vars that you used) qhich already contains some values. I know that it can be using not an array and then use if-elseif statements but, I wanted to create a condition where it checks the order (from the array) of the values inputted by the user and if it has the order then it is correct; assuming that the inputs are present in the arrays. If not, it shows "wrong user or pass"
Maybe something like: /* ... */ = description for the wanted code which I don't know if ( /* user input is present in user array */ &amp;&amp; /* pass input is present in pass array */ ) { if ( /* order of the user input from the user array */ = /*order of the pass input from the pass array */) { println "correct"} else { println "wrong user/password combination"} } else { "user/password is not present"}
Hmm I'm going to bed rn but tomorrow I'll get back to you because my brain is not functioning properly.
No problem. I'll also try to find my own solution to my problem :)
Yep!
If person is null it'll just pass in null avoiding a null pointer exception when accessing "null.phone". If you want an empty string you could do "person?.phone.orEmpty()"
When you use ? in an expression (person?.phone in your example), if the variable it's put on is null the expression will evaluate to null immediately, else it will continue on with the expression as if it weren't there
Got it. So it prevents an NPE when accessing a null, but it probably will pass a null. Didn't know about the \`orEmpty\` method. I'll definitely look into that.
`?` makes sure that the value to it's left is non-null before trying to access it to avoid `NullPointerExceptions` So, in your case `person?.phone` can also be written, in Java, as `(person != null) ? person.getPhone() : null` Fartbarder provided some info about how to get an empty string :)
In general, when you have `x?.y`, it's the same as `if (x != null) x.y else null`, except `x` is only evaluated once. For Strings you can use `.orEmpty`, but in general you can use `?:` if you want to turn a `null` into something else. eg: person?.phone ?: "either person or person.phone was null"
The question mark doesn't make it more probable to pass a null value, it's just a safeguard to save your program from crashing if you do encounter a null and leaves you with the option of using a default value in that case.
Does this work if you have a long chain? &amp;#x200B; person?.phoneTypeWrapper?.number ?: "either person or person.phoneTypeWrapper or person.phoneTypeWrapper.number was null"
And the default value is given with the elvis operator?
Correct. I've seen a few possibilities that I'll summarize for you. The first option you're already using: `intent.putExtra("phone", person?.phone)` which will use the value passed to it, or pass null with no meaningful way to deal with the problem. &amp;#x200B; `intent.putExtra("phone", person?.phone ?: "default value")` will allow you to set a default value if a null is passed. &amp;#x200B; `intent.putExtra("phone", person?.phone.orEmpty())` The orEmpty() extension function will set the value to an empty string `""` if a null value is passed, according to [https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/or-empty.html](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/or-empty.html)
Yeah, that's sort of the point of it.
You've got it! I think the thing that occasionally throws people off here is that getting a `null` at the end can mean any of the points along the chain was `null`. Sometimes people will erroneously do stuff like: person?.phone ?: "value for when person is null" and forget that the `?:` can also be triggered if `phone` is `null` (obviously not an issue if `phone` isn't actually nullable, though). The `?.` and `?:` operators are really more for when you need to treat nulls anywhere along that chain in the same way.
I don't believe that is possible. (see [https://kotlinlang.org/docs/reference/delegated-properties.html](https://kotlinlang.org/docs/reference/delegated-properties.html) ) You would need to declare the delegated property inside of the class, like class SomethingChangedEvent(foos: Collection&lt;Any&gt;) { val foos by ReadByCopyProperty(foos) } If thats how your delegated property class is set up
Perfect. Thank you so much. I am glad I asked the question even though I thought it was little dumb even after I've been using it for a bit.
Heh, `.orEmpty()` is actually more characters than ` ?: ""`. OP: both work and are equivalent to each other.
Personal preference. You do get code completion help with orEmpty though which is nice.
There's no dumb questions man, that's how we learn.
im not sure if this is the answer you're looking for, but you can always check the generated java code to see what it is translated code
Imo https://github.com/JetBrains/kotlin-native/issues/2423 is the biggest blocker in distributing libraries with kotlin native. You can only have one kotlin native framework in your app so you lock out your clients from using kotlin native themselves or using another dep that uses it. You can distribute the kotlin dep directly of course but then the client has to set up the kotlin native project themselves.
Its divide and conquer since splitting a list in two until the list is of size one is the divide, and finding a particular element in a size 1 list is conquering
Thanks for information!
I was wondering more about kotlin support for this https://dzone.com/articles/jdk-9jep-280-string-concatenations-will-never-be-t
If you know Java, every time you're wondering what a Kotlin code does, you can (at least in IntelliJ) go to Tools-&gt;Kotlin-&gt;Show Kotlin Bytecode, and then in the opened view click "Decompile". You'll see a pure Java code. Perhaps this will help you in the future.
Why do you have an Android app in there?
In regards to nullability: &gt; not doing anything will make the parsing fail with an exception, which I actually find a good thing. Does that mean that Jackson will fail if non-null field is not present in JSON? Wow, It thought Moshi was the only 3rd party lib supporting this.
I suggest you stick with the same libraries you use in Java to have me familiarity during the migration. Also, just Google for slides from Kotlin presentations and you will find lots of benefits over Java. I think this article is pretty compelling also: https://proandroiddev.com/kotlin-avoids-entire-categories-of-java-defects-89f160ba4671
https://projectlombok.org/ ?
Leftovers from Android studio. This was part of an app initially
Cool!
The main benefit of Lombok is that it does its work at compile time. The disadvantage is that you need an IDE plugin to work with it.
my understanding is that when it tries to create the data class, a field that is not nullable is not set and that triggers the error, but I actually don't know the specifics
Can you integrate Moshi or kotlinx.serialization with Spring? I thought it was hardcoded to use Jackson.
Very cool! I see one issue off the bat: if `Foo` extends `DataClass` and `Bar` extends `Foo`, comparing two `Bar`s as equal won't consider `Foo`'s fields. This is because `getDeclaredFields()` doesn't include fields declared in superclasses. For the same reason, `Bar`'s `toString` won't include `Foo`'s fields either. You could solve this by walking up the class hierarchy in `getFields` and concatenating each class's fields, or by disallowing inheriting from data classes like Kotlin does (throw an exception in the constructor if this class's parent class isn't `DataClass`?). Aside from that, it's great to see this feature implemented without the need for pre-processing/extra tools at compile-time (e.g. Lombok).
I like that this is kept pretty simple and doesn't have crazy inheritance hierarchies with an interface and three levels of base class just to render a view. If you are using Android Studio, though, you should make heavy use of the `Reformat Code` command - Option+Cmd+L on Mac. This strictly enforces syntax rules like spaces on both sides of equals signs, opening braces being on the same line as the statement they open, that sort of thing. It makes your code a lot easier to read and makes it look much more professional.
Nice README!
I prefer (foo == true). I cannot explain why though haha
Ktor?
Fwiw, the [official page of Kotlin idioms](https://kotlinlang.org/docs/reference/idioms.html#consuming-a-nullable-boolean) says to use `foo == true`.
It's on my to-do list, although I may be a bit out of my depth.
Is the Object.equals() method missing?
I believe those do different things. foo == true, checks if foo is not null and is true food ?: false, only checks if foo is not null
Not a fix at all but you might consider handling the orientation config change yourself.
Yes, they do different things. But in this context they would behave the same, i.e convert a nullable boolean into a non nullable one.
I'm not sure what you could mean by that... And is there something wrong with .onsaveinstancestate ?
No nothing wrong, but if you don't want the activity to get destroyed with an orientation config change check out https://developer.android.com/guide/topics/manifest/activity-element#config
Oh, that's interesting... Thanks
Join the club on that one buddy. I read the JEP and I am pretty sure my brain shutdown for the day
I meant implementing it in the Kotlin compiler is on my to-do list. If you want to learn about the feature watch this talk: https://www.youtube.com/watch?v=wIyeOaitmWM
Gotcha
Right. I sometimes do get a warning like "replace elvis with eq check". But only when a use as \`if\` condition. and not when I do like \`val bar = foo ?: true\`
The Kotlin npm integration is great
This is a bad idea. Even if you handle rotation, there are still many other reasons for configuration change to happen
Is anyone already using Kotlin/JS to build largish frontend applications? I'd love to be able to go full Kotlin to replace my Angular apps.
Yes! Reified KType literals!
It’s good to see that even Haskell is still finding its feet with error handling -https://www.reddit.com/r/haskell/comments/4xi3is/not_all_partial_functions_are_bad/
Why? What's the added value compared to the current communities on GitHub, Reddit, Stackoverflow, Medium, official site etc.?
What does this mean, practically? Sorry, I always have to spend an hour studying generics every time I deal with them
You should use generics on your OperationCallback interface to not have tu check for result type and avoid things like List&lt;*&gt;
Say you have a function to parse some kind of data (ie JSON) into arbitrary objects. In Java, the signature would look something like this: public &lt;T&gt; T parse(Class&lt;T&gt; type); since Java doesn't know the type of T inside the function. Kotlin has reified types as a workaround: inline fun &lt;reified T&gt; parse(): T = parse(T::class.java) You can also do a lot more fancy stuff with it. Now, let's imagine you want to parse a list of numbers. The problem now is that T::class get's rid of any generic type parameters. So, if T is List&lt;Double&gt;, T::class just gives list. There are workarounds using some Java trickery, but those don't work properly with the kotlin reflection library. This is where the update comes in. typeOf&lt;List&lt;Double&gt;&gt;() returns a KType which also holds the fact that the list has Doubles as elements.
Either way: | input | output | | --- | --- | | true | true | | false | false | | null | false |
I prefer `?:`. If I saw something like: if (isFoo == true) { and didn't realize that `isFoo` was nullable to begin with, I'd probably assume that the code was overcomplicated. I've seen *many* cases of people doing this sort of thing with boolean expressions over the years. I've lost track of how many times I've seen stuff like `x ? true : false` in Java. On the other hand, if (isFoo ?: false) { makes it clear that `isFoo` is nullable and that we're dealing with 3 possible values. Using elvis also seems more consistent with the way I'd deal with other types. Say I had a set of nullable values read from some message, and I want to pass them on to something that needs non-null values, so I need to pick a default for each: val name = msg.name ?: "anonymous" val size = msg.size ?: 10 val isTemp = msg.isTemp // what goes here? Using `== true` seems glaringly inconsistent I this scenario. Are there any situations where using `== true` is more consistent? I don't think either is objectively easier to read than the other, but I can't really think of any arguments in favor of using `== true`.
This statement is incorrect: As functions are instances of objects and since each instance requires heap allocation, using functions introduces an overhead.
Yes null is the same as false in this case
I'm not saying to override all configuration changes, but I often override orientation changes.
Yes, but even if you do so, you still need to be able to handle activity recreation for the changes you don't handle.
Outside of orientation and keyboard what are you concerned about?
We use it at JetBrains, but I can’t show the actual code, so I’ve made demo application https://github.com/mkraynov/kfsad Now it’s 1.3.21 (old kotlin-frontend-plugin), but I am going to merge PR updating it to 1.3.40 (new js gradle plugin, multi module).
The problem with checked exceptions is mostly the fact that you're forced to deal with them at the immediate call site even when that's not logically where you'd want your error handling to live. Instead, the default behavior could be to let them bubble up to the caller (in Java terms, add an implicit `throws` clause with the union of all checked exceptions thrown by callees) unless a function declares that it throws no checked exceptions or only throws a specific list of them. That would give you the benefits of checked exceptions -- visibility and documentation -- without the obnoxious code clutter that caused people to abandon them in Java for the most part. Allowing the compiler to infer the list of checked exceptions would also solve the problem with first-class functions, since, e.g., it would be able to infer that `collection.map(func)` would inherit `func`'s checked exceptions.
Hmm, the Java package integration still seems broken. I filed a bug for this, but it was closed as fixed and I'm confused as to why this code doesn't work... maybe someone here can explain it: ``` import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.GraphTraversal // ERROR: __, ___, ____, ... are reserved in kotlin // WARN: Remove redundant backticks. import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.`__` // WARN: Remove redundant backticks. import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.`__`.properties // Works fine. import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.`__` as US import org.apache.tinkerpop.gremlin.structure.Vertex var g: GraphTraversal&lt;*, *&gt;? = null fun main() { g?.V("1")?.union( properties&lt;Vertex, String&gt;("a").value(), // redundant backticks warning `__`.properties&lt;Vertex, String&gt;("b").value(), US.properties&lt;Vertex, String&gt;("c").value() ) } ``` (the package in question is `org.apache.tinkerpop:gremlin-driver:3.2.10`, if you're curious)
&gt; That would give you the benefits of checked exceptions -- visibility and documentation -- without the obnoxious code clutter that caused people to abandon them in Java for the most part. Visibility yes - documentation no. Look e.g. At a lot of the .NET framework APIs where MS just lists the exception classes that can be thrown. That's not documentation. I care about when and why that class will be thrown as a consumer. Otherwise: how am I supposed to know how to handle it? Just listing the exceptions in a lot of cases just causes me to catch Exception in C# because I can't sensibly handle them any different anyways. So there's little value in just auto-listing them with the compiler.
Ah, excellent. That's still really JetBrains-specific though, but I guess the community has to start from somewhere.
&gt; Allowing the compiler to infer the list of checked exceptions would also solve the problem with first-class functions, since, e.g., it would be able to infer that `collection.map(func)` throws `func`'s checked exceptions. That's incorrect. collect or any other terminal operation will throw that exception, which I'm sure the compiler can't infer either way. Map and other intermediate operations on a stream don't actually do any work until you call a terminal op on the stream.
https://developer.android.com/guide/topics/manifest/activity-element.html#config Anything in here can restart your activities at any time. If you don't handle that properly, your app will either crash or be left in weird state, causing bad UX.
The compiler does infer the list of checked exceptions, it then just insists that you explicitly repeat the information! Wouldn’t your solution mean that if I manage to make more functions total, I have to add more declarations that they do not flow. And that I loose information about how a function can fail, because the actual type of errors is not specified?
I'm not saying that `throws` eliminates the need to write real documentation; clearly you want to know what the various exceptions mean. But for example: public String methodThatThrowsRuntimeExceptions() {...} public String methodThatThrowsCheckedExceptions() throws FileNotFoundException {...} Even in the absence of additional documentation, you know more about the behavior of the second method than you do the first because the `throws` clause documents one aspect of its behavior that would otherwise be unknowable without reading the implementation.
With new version of Kotlin 1.3.40 all is changing to use Gradle for Web developing. "We are working hard to port all the features of the kotlin-frontend-plugin plugin into our Kotlin/JS plugin and Kotlin/Multiplatform plugins. Some of the features are already included as experimental. We plan to deprecate the kotlin-frontend-plugin when this work is complete." I will update wrappers as soon as possible to adopt this new form.
Yep I have been waiting for this for ages. Goodbye `object : TypeLiteral&lt;T&gt;() {}`
Okay, so I just tested this. The kotlin side works nicely! However, converting to a java type using KType.javaType does NOT work. It's marked as TODO though, so hopefully we get that with the next release.
Just keep all the data in viewmodel. Use databinding to provide view-viewmodel communication. In your fragment you should just inflate the layout.
As I got further I was (internally) screaming, remove that test duplication and let it show you the patterns. Particularly when mobbing, the group looses its sense of code because only one person can navigate to see things. Density becomes important because it allows more of what is there to be accessible to the group. In these situations I also split the editor so that the test is in one pane and production in another, again so that non-drivers can choose what they want to be looking at.
Should the bore model be getting destroyed ? Coz that is when I lose the data , when the view model is destroyed and rebuilt
Viewmodel won't be destroyed. You are using ViewModelProviders class to keep the viewmodel instance when the fragment is destroyed. This is the main feature of the "viewmodel arch component" :) that's why you shouldn't keep the data in fragment, because on orientation change the fragment will be recreated, but your viewmodel will survive.
Interesting project but not to be taken seriously as using reflection is a huge no-no in terms of performance critical use cases.
Jackson has the best performance so far in comparison to Moshi or kotlinx.serialization.
Well I'm clearly doing something wrong , because the viewmodel "on cleared" is called when the activity or fragment it's held in is destroyed...I thought that was destruction.. I'll have a look into that...
I have also wondered if Java might have been able to infer the exceptions thrown from higher order functions. A problem is that you would have to distinguish between a function that will will invoke its parameter before it returns (and hence is liable to the same failures) and one that will store it for later invocation, and so isn't.
Here is another example with another approach: (https://github.com/rnentjes/simple-password-manager) This uses a very simple helper library to use the static html builders: (https://github.com/rnentjes/komponent)
It works only on JVM currently, not on JS...
I'm working on a threejs application with a little bit of jQuery. Besides of finding good wrappers for libraries (threejs in this case - had to do my own) (hoping dukat will help here) it's really nice. What I find troubling (before this release) was the tooling stuff. Frontend gradle plugin looks good but is stale and will now be deprecated according to to the 1.3.40 release notes. I switched to my own toolchain with yarn, package.json and webpack config written by hand, compiling and executing via gradle. But its not great either, and, I don't know how to handle MPP, so switching to something jetbrains provides would be great. And the compile performance is a sorry state of affair, but this release should improve this as well... Here is an example workspace with various configurations: [https://github.com/nimloth05/kotlin2js-examples](https://github.com/nimloth05/kotlin2js-examples) Will this now update for the new release and do some tests... All in all I can recommend it, but you need to be aware that the tooling is not so smooth as it is on the JVM side.
Better use RxJava then. It perfectly implemented exception handling. The checked exceptions are often things that don't have to do with programming errors rather than wrong usage or unpredictable behavior that just must be caught (IOException for example)
Very happy with Javalin: https://javalin.io/tutorials/jetty-session-handling-kotlin
But if I have to go read the source anyways to find out the undocumented "why" and "how" of when that exception is thrown - did I really gain anything? Because that's the information I really want.
Will be awesome to have Angular support, replace TS by kotlin
Really eager to see large app since we evaluate fullstack kotlin too
I'm really surprised that Kotlin doesn't have any kind of exception checking at all. For all this "I like safe code", "Let's have a Result monad", and "I only write pure functions" talk, having totally unchecked exceptions ruins all of it. I prefer when languages don't have any exceptions at all, such as Go and Rust. Being a JVM language, Kotlin can't really do that, but Swift takes a decent middle ground where you don't have "checked exceptions" in the Java sense, but you *do* have to mark any function that throws exceptions: `func foo() throws`. That seems way better than just pretending that exceptions aren't a thing, especially when you're sitting on top of a language (Java) that absolutely does encourage throwing exceptions as normal control flow.
Sorry we made you scream internally :) I personally was fully aware that we duplicated lots of tests but was ok with it (probably because it's not a very complex problem). It is an interesting idea to split the screen for non-drivers' accessibility (or even viewers' accessibility, I guess I always assumed the split was for myself). Maybe we could pair sometime and you will show the right way to do fizzbuzzwoof?
Do you really need to know the "why" and "how" of a **FileNotFound** exception?
Are all your Exceptions FileNotFound exceptions? Lucky you!
It’s interesting that the discussion here is all about how hard it is to represent and handle errors. Does anyone agree with my thesis that we should therefore jump through (low) hoops in order not to have this pain?
Thanks for the thorough explanation. Where would you use that in your JSON parsing example?
GSON, for example, has two methods to parse a JSON string into an object: &lt;T&gt; T fromJson(java.lang.String json, java.lang.Class&lt;T&gt; classOfT) &lt;T&gt; T fromJson(java.lang.String json, java.lang.reflect.Type typeOfT) If I want to preserve generics, I'd use the second method: inline fun &lt;reified T&gt; Gson.fromJson(json: String): T = fromJson(json, typeOf&lt;T&gt;().javaType) Unfortunately, as mentioned in my other comment, typeOf&lt;T&gt;().javaType doesn't actually work yet. We'll likely have to wait for the next version if we want a fix. Workarounds are possible, obviously. I hacked together a bit of untested code I can share if anybody is interested.
Thanks!
non-blocking IO, for one.
It's probably an order of magnitude faster and you'll get the Java ecosystem if that is important for you (better XML and ms office support for instance)
According to [Techempower](https://www.techempower.com/benchmarks/#section=data-r17&amp;hw=ph&amp;test=json), the JSON serialization performance would be similar to Node.js (which is single threaded) and has NPM and Yarn ecosystem and Go. Also if speed was the main criteria, Vert.x would be a better choice. One order of magnitude faster would mean 10 times faster (due logarithmic scale), which is not the even if you compare with Flask/Sinatra/Express.js. Furthermore requests/s (i.e. speed) was already stated in the question. The real question is: will a 2x speed gain pay of all other engineering functionalities already provided by other technologies?
I think the future of microservice frameworks for the JDK ecosystem are gonna center around GraalVM and might beat out spring in this area. You have Red hat, OC, and Oracle all with "Spring killers" focused on docker and Kubernetes friendly native cloud frameworks. They might not be production ready yet but I've had fun messing around with Micronaut [https://micronaut.io/](https://micronaut.io/) and Quarkus [https://quarkus.io/](https://quarkus.io/) and Helidon [https://helidon.io/](https://helidon.io/#/) look promising as well.
Spring team has said they will support ahead of time compilation on graal in the future
Noone else can answer that question for you, given that we know nothing about your team (experience, skills, etc.) or your current tech stack. I develop systems that handle millions of requests per second and so this is never even a choice for me. It's JVM, Golang, or C++. At 10's of thousands you're probably better off going with whatever your team is most familiar with unless low latency is a killer component of whatever you're building, as your ability to get shit done quickly will outweigh the small performance differences.
Take a look at [Kweb}(https://docs.kweb.io/).
&gt;Node.js (which is single threaded) Not 100 % sure but I think the Node.js benchmarks at Techempower all use the cluster feature. &gt; will a 2x speed gain pay of all other engineering functionalities already provided by other technologies? Depends ... At work I get VMs to run my stuff on. Cost don't matter. Superfast networking, moderate to low traffic, well it's low I must say. In that case 2x speed doesn't matter. Time to customer matters much more. But say you've got an website running on AWS speed and memory consumption tranlaste to cost.
I've used and loved Python and Flask. Kotlin is like the next gen Python with static typing and other great enhancements. Language-wise I'm sure you'll love it. The Java ecosystem is huge. Sometimes too many choices ... However, regarding your list, Ktor checks a lot of your points, but not all. Community size (reach, matureness) is not close to Flask. Don't know about GraphQL. But there are alternatives which are in this regard way ahead of Flask: The most used and feature rich Framework would be Spring. Coming from Python maybe a bit hard to learn (getting started is trivial, but really understand what's going on is harder). My personal choice would be Vert.x. Don't know about the social-login stuff ...
Check out the Either and Try objects in the excellent Arrow library, they solve pretty much all these problems in a really nice way.
I cannot make the npm integration work with kotlin dsl Would someone have an example?
I really don’t think that they they do. As the article says, returning an Either type (Try is deprecated) forces callers to deal with errors which in turn pollutes their callers all the way to the top of the stack.
Techempower benchmarks are laughably bad. They mostly compare the time the benchmark author spent on optimizing the benchmark. You see comparisons like "undertow vs vertx" in that list and somehow vertx makes it out on top - what the list doesn't tell you is that they also use different serializers and db drivers and such.
Not sure wether it's been posted before, but I think this is great talk on the topic.
I’m not sure about the right way, but if you’ll make do without the woof, I do have 3 blog posts on the topic! http://oneeyedmen.com/tdd-v-testing-part1.html
This talk is a little bit outdated, because coroutines are growing pretty fast (channels, flow, etc.). But personally, what I really like in projects like Reactor or RxJava is they were designed to do reactive programming and nice threading abstraction is just the side effect. In coroutines I feel they were designed to provide nice way to handle asynchronous tasks and now they trying to add reactive programming on top of that. I really like coroutines, but in my opinion comparing them directly to reactive programming is just wrong.
It's a compiler that uses the llvm compiler tools to allow the use of Kotlin on any platform those tools work. It's purpose is to have Kotlin on any platform. Here's a short list of where you'd be able to use it: \- Native desktop apps on Mac, Windows, Linux. \- Serverless computing \- Browsers via WASM \- Native Android and IOS applications
The main reasons would be co-routines, which are a really nice way of doing asynchronous stuff, (i.e. much nicer than anything Javascript, Ruby, or Python do on this front), a nice strongly typed language, and mature tooling to go with that. And yes, most of the things you list should be doable and if they aren't that's likely to be fixed at some point. If that's somehow a show stopper, you get pretty much all of this using e.g. Spring Boot and Kotlin. I'm considering replacing Spring Boot with Ktor currently. The main obstacle is migrating a lot of legacy code. I want to do it but it takes a lot time.
What if the input is `"false"`?
You can technically use Kotlin with a lot of the existing JS frameworks. But IMHO it makes little sense to do that because you'll be dealing with a lot of interoperability issues. That's fixable but Kotlin is just not a first class citizen in that ecosystem and you are kind of going against the flow here. A pure Kotlin approach ultimately requires Kotlin specific frameworks. There are a few of those but they are relatively new and obscure at this point. Kvision is one of the more popular Kotlin specific frameworks. Y If you want to give this a quick try, parcel actually supports kotlin out of the box now. That's probably the easiest way to get started but not necessarily the best way. You can have a hello.kt printing to the browser console in no time at all. Ignore the Kotlin Frontend plugin for gradle; it's still stuck on 1.3.21 and has not been updated in months. I think it's pretty much dead. Besides, it relies on webpack and IMHO a large reason for wanting Kotlin on the frontend is to get away from that messy ecosystem. It also assumes you'll be doing react, which in my opinion is actually exactly what I'm trying to get rid off. Gradle with the kotlin-js plugin and the kotlin-dce plugin actually remove most of the need for that and you can get some other tools via the moo plugin to run whateever you need from the npm ecosystem if you want e.g. some less/sass processing. Sticking with gradle means you can pull in the cross platform kotlinx stuff as well as third party kotlin libraries targeting js via maven dependencies.
But they really don't. If you want to do something with the response, call map. If you want to try something with the response, call flatmap. If you want to turn it into a single thing, call fold.
Do you know more realistic benchmarks site?
Kotlin (and RxJava) would benefit Vert.x, Spring Boot and Ktor :-) But how much stuff would you have to rewrite that is already provided by Spring Boot?
&gt;know about GraphQL. But there are alternatives which are in this regard way ahead of Flask: If you have a Python background, what not using Django REST? Uber started with a Python backend and moved slowly to Go only when it was not scaling anymore.
&gt;the Node.js ecosystem is non-blocking from conception and reactive programming is available to Python and Ruby as well. Most *advantages* adverted are comes from Kotlin itself, not Ktor
One solution could be to have a kotlin annotation that gives a warning for functions that may throw exceptions. Maybe that would be easy to implement on my own projects so haft to look up annotations and lint a bit more. But preferably it would be in the standard set of annotations instead of custom.
The team I am has a pure heart and no previous experience on backend, so they are willing to code in something Kotlin flavor due their Android mindset. I am experienced in write on large microservice bases in Python (Django, Flask), Node.js (hapi.js and Express, Apollo GraphQL), and also mobile apps (Android in Kotlin/Java/React Native). In my early day as a developer, I had a long experience that teams **adopted broken (or unpopular) technologies**, consequently instead of focusing only on the business cases problems we would also have to circumvent (fork-n-fix, pull request a fix, or just a wrapper hack) in order to keep using 3rd party libs. The reason for using it was it **is faster and non-blocking**. IMHO we should must understand our destination (i.e. what is the **problem we need to solve**) and fill our backpack with stuff that make our journey pleasant (i.e. **choose a (micro)framework relevant to the problem**). We always can make stops during our trip to buy or drop stuffs ;-)
I'm already very comfortable with Kotlin and Spring / Vert.x. So no need to use Python ... Kotlin is a better language than Python. But more importantly the JVM and ecosystem are much more poweful than Python. Python (and Django, Flask, etc.) are great, but Kotlin (and Spring, Vert.x, etc. ) are greater. :-)
Spring has already endorsed Kotlin. Co-routines are going to be supported with 2.2 so you don't have to deal with their flux stuff directly.
FWIW Kotlin is the best development experience I have had. However, I was very familiar with Java when I picked it up so that made the learning curve very gentle.
That sounds pretty interesting! I gave your 'hello world' repository a try, unfortunately it fails on gradlew build (build/kotlin-js-min/main/output.js:5:36: Cannot resolve dependency 'kotlin') and I have the feeling that that's currently the status of most of the Kotlin/JS ecosystem :) Is there anything specific I'd need to do to get this to compile?
Kotlin is better than Python? Python is better than Kotlin? Greater considering which criteria? I am searching for facts that corroborate Ktor advantage that are not biased due opinion based. Saying an ecosystem is much more powerful is vague and one may say the same about any ecosystem.
Spring Boot is great, the problem was the learning curve considering the team will build several microservices and not a single monolith. I personally dislike Spring, but it would be the most cautious choice due the pletora of stable integrations with databases, queues, mail services, etc.
Ah cool. For anyone else, he's referring to this: [https://github.com/jillesvangurp/kotlin-js-gradle-parcel-hello-world](https://github.com/jillesvangurp/kotlin-js-gradle-parcel-hello-world) &amp;#x200B; You may have to remove .cache, .gradle, and your build directory. This stuff is indeed flaky but it seems to build fine on my machine. I'm actually looking to get rid of the parcel dependency in there since it seems to be redundant. BTW. just updated the repo to 1.3.40.
No. Benchmarks are hard to do fairly since frameworks carter to different audiences. It's not like it matters much anyway - for most use cases the performance does not matter.
Not disagreeing with you. I'm familiar enough with Spring to know what bits to avoid but I agree that it is a bit of beast to learn. Dependency injection done right is actually really nice in recent versions of spring and only involves a bare minimum of annotations, or even none at all if you for for their kotlin dsl. That stuff has come a long way since people were doing crazy stuff with xml files. But I hear you; hence my desire to replace it with KTor. It mostly already has everything I need and I'm pretty sure I could make this work. For server less and microservices, native could be very interesting as well.
Totally agree about crazy XML files (so did Google when they moved from Eclipse to Android Studio + Gradle). I think Ktor will be the Express.js for Kotlin as the community and project become more mature.
Hmm, still not working. It's complaining that my version of Node (12.3.1) is too old and I should probably upgrade to a newer version, like 11 :) So I guess there's maybe an incompatibiliy there... I'll try to do some more hacking when I have a bit of time. What would you replace Parcel with, btw? It's doing more than just the Kotlin bundling, I suppose? (also bundling, etc)
Right, node is likely the problem. It should actually use its own node version and install it in the .gradle directory. For me it puts it in .gradle/nodejs/node-v10.15.3-darwin-x64. The kotlin-dce plugin actually minifies quite nicely; so parcel actually does not do a lot I need. Probably a good idea to have some tool to combine the minified libraries into 1 big file. I actually did that manually and ended up with a smaller file (using the cat command) than what I get from parcel. So whatever parcel is doing there is probably wrong/redundant. I suspect it does some shit with polyfills that are not actually needed. I have not quite figured this out just yet.
I'm seeing it create the nodejs folders but it doesn't actually put anything in there. Oh well. Still cool you have this demo up and running! I'm having a hard time finding some decent documentation, though. A lot of projects are using Gradle &lt; 5 (or no Gradle at all - just using IntelliJ to build!), or using the frontend plugin which is apparently now obsolete? Hopefully everything will mature a bit in the next few months.
I replied to your original question. Then you asked me why I was not using Django Rest? What? Why should I? Then I told you politely that I'm using Kotlin. You have asked us for personal opinions. I gave you mine. What did you except? "Oh, I used to use Python but now I'm using Kotlin because it's worse..." If you're familiar with Python have a look at [https://kotlinlang.org/docs/reference/](https://kotlinlang.org/docs/reference/) and you'll soon see that Kotlin is as elegant and concise as Python but much more powerful. Static typing, threading, coroutines, extension functions, null safety, the collections and stream API, runtime performance ... Or have a look at the Spring docs and compare the features to Django or Flask. Nobody here will write an essay.
That *is* dealing with errors. You may be used to it, but choosing to map, flatmap, fold etc is horrendous compared to invoking code that cannot fail.
This has inspired me to install your WIP plugin and try the same exercise
tl;dr "Make Illegal States Unrepresentable"
I'm currently (attempting to) use it to make a communications test program that can be run with the c++ program that runs on another device. Being able to reuse the app code is proving to be really helpful but had not been without little gotchas. Since the app is already 3 years into development we used lots of java things that kotlin provides because we didn't really know any better. We also thought we would be changing to a platform that we'd have a reliable java 8 tool chain and ended up not. There have been a couple posts lately showing off how to put kotlin native to good use for reusing code in iOS and Android, which is pretty cool too.
IMO the coroutines approach is the ideal one, because the lack of a solid concurrency primitive makes implementing and composing operators extremely painful and error-prone. That said, the Rx approach is more agnostic to the underlying concurrency mechanism.
I'd take issue with states, but otherwise fair
Ah, I see now the case is being made that it's preferable eg to call head on a list that is guaranteed to not to be empty rather than wrapping a call to head on a regular list in a maybe type? Fully agree about that, it's one of those things I would like I used more. It's a shame there aren't basic classes like PositiveInt, NonEmptyList etc I'm the standard library.
They did the needful. What was discussed? Anything interesting?
The event was kicked off about an hour back, the agenda as below, https://info.jetbrains.com/kotlin-everywhere-bangalore-2019.html
Was this advertised anywhere? I would have gone if I knew.
I had got a mailer from jetbrains, I suppose they also advertised it on popular Android meetup groups.
Yes, especially as one of the problems with the technique is combining calls to 2 libraries with different representations of restricted types. We are gaining unsigned types courtesy of inline classes.
Kotlinconf != Kotlin/Everywhere
Oopsy
Kotlin/Everywhere Is not at all the same as Kotlinconf
I’m gonna try this at work with someone else where we already TDD everyday. Seems like a fun variation!
I got to know about this in reddit itself from some user. Thanks to him🥳
Cool. How about libui rather than JavaFX, would allow for native desktop apps: https://github.com/msink/kotlin-libui
I did not know it, thanks dude, I'll take a look
I've been wathing it and seems to be in an early stage of development, also bindings to C libs makes a non idiomatic Kotlin syntax. I'm very familiar with JavaFX, and making apps with Kotlin and TornadoFX framework is a pleasure, and I can target Windows, Linux and macOS platforms. Also, Kotlin Native have not much more or even less performance that application running on the JVM. Anyway thank you for your reply :D
&gt; to the underlying concurrency mechanism. I'm assuming you mean things like events, coroutines, threads, etc. correct?
Micronaut does compile time DI, as well as other compile time checks (e.g. path variable name matching). Does Spring offer anything like that?
&gt; Is there a way to setup a Kotlin JVM project so it has a Gradle script in IntelliJ IDEA? IDEAs new project wizard will ask you the type of project you want to create. Select gradle.
&gt;private var movies = mutableListOf&lt;Blog&gt;() Some copy paste mistake... Blog is treated like movie all over the article. :D
The problem you have here is that the ViewModel is actually not transforming the Model(Blog) to something consumable by a binder. The idea of the ViewModel is to hide your domain Model(Blog) and only expose the data interesting for views. I.e. a viewmodel. I. Your case this happens in the adapter but I'd argue it should happen before in the view model.
There is a GitHub repository with a list of all popular libraries built with Kotlin, and there is more tha one for Android. https://github.com/mcxiaoke/awesome-kotlin/
Any practical examples of this?
If any of you see any errors or ways to "improve" this, feel free to stick a fork in it and make the PR. ᕕ(ᐛ)ᕗ
lmgtfy
Actually makes debugging fun.
I’m not an Android dev, but I’m glad that someone else is questioning this code. It would seem to me that the repository should be used to update a single LiveData that the UI is rendering?
I don't get it ,(
I assume that stack traces are not preserved, but in this context I guess it's ok ;)
Hmm... ( ಠ ಠ ) I think I have an idea. `Hold my beer and watch this!`
Done. Time to finish that beer... then sleep.
눈\_눈 Seriously?
Love it
🍻
Sure! I can give you one later tonight
Working with these would make an excellent interview question 😁
Then you're doing the same mistake I'd say. You need to transform the data from the repository before the binder/view can consume it. The binder part is usually missing or not mentioned. In this example the adapter is the binder but I think creating a binder makes more sense. Which is what happens in Android's databinding library. The important part is that your ViewModel should not expose the domain Model only consume it. I think I'll create a small example later today. Small changes makes a lot of difference here. However, it's sometimes hard to put in words. The Wikipedia article on MVVM is really good though. You just have to ignore the parts about XAML.
Yes, make sure IntelliJ is up to date. Then when you create a new Project, on the left-hand side make sure you select from the Gradle category - NOT the Kotlin category!
Interviewer: How would you handle a user passing `null` for this function? Candidate: try { //... } catch (npe: NullPointerException) { throw TheDamnTable } Interviewer \*under their breathe\*: *damn that's good...*
I wasn’t saying that the repository should know about the model, but that the model should fetch data from the repository to update its LiveData. I’ve been playing with Android UIs a bit and trying to fathom why the patterns are as complicated as they are!
Ah I see what you mean. Yeah that makes perfect sense :)
Forgot to put the commit of the change... https://github.com/pablobaxter/frybits-wtf/commit/b15a30799bf07464d9223e5f9576fce8a6122ffd Moral of this story: if you plan to get something done well, get some good sleep in first, then make sure you have more than one beer stocked.
Jersey wrapped in Reslience4J is fine for making REST calls. Jackson can parse JSON from/into Kotlin data classes (no annotations needed) using the Jackson Kotlin module. Arrow is great for error handling and functional programming.
Thanks mang! It doesn't have to be anything crazy, just curious if there is a domain model class and a separate view model class, with some left-right translation to convert the domain model to the view model.
tldnr yet but "The dispatch() function is the single entry-point to a class" and "Classes provide the messages they are able to handle in their dispatch() implementation" sounds like the actor model to me (and I like actors).
In the Actor model, I think you don't use the return value, but you trigger other messages
Yeah that's right. But in my mind there isn't much of a difference. Actors are like methods (or functions if we are speaking Kotlin instead of Java) which don't get broken by concurrency (concurrency breaks the encapsulation of oop, actors fix that).
I think that the "return value" vs the "trigger a new message" is a lot more important than you might think. With a real messaging system, you don't need to keep a reference to the actor, which means you can kill it and spawn a new one without any issue. This is not possible when you use a return value.
I'm not sure why it's not possible with a return value but I assume that you are right. Maybe I'm missing something but you can't always kill an actor since they can contain state (as said before I didn't looked at everything in the text but maybe the private lateinit var filename: String could be something that ends inside a actor if you realise it with across). But it's not shared muttable State which is great, because accessing state becomes intuitive again (you don't need to think about other threads accessing it, using locks and volatile and losing track what actually your code does to just be surprised that it sometimes doesn't do what it should).
This is... beautiful. Well done.
Hi Nicolas, Big up for your always very interesting and well written blog ! Cheers from Geneva ;-)
Thanks for the nice words, appreciate that!
As for regular expressions, every time you introduce state to solve a problem, you've now have 2 problems. It was the case for Stateful EJB, it's the case for Docker StatefulSet, etc. I try to avoid state when I can.
thank you very much for sharing this link
I usually use this libraries: Ktor Client for HTTP request Kodein for dependency injection Gson for JSON serialization/deserialization ArrowKt to extend Kotlin stdlib functionalities For asyncs aspects I avoid to use RxJava/RxKotlin, personally I think is better to use coroutines. Also, If you pretend to develop a desktop application check TornadoFX, a framework for JavaFX
I've been using \[Kweb\]([https://docs.kweb.io/](https://docs.kweb.io/)) for web development, it lets you work in pure Kotlin, automates server-browser communication, and there wasn't much a learning curve because I wrote it ;)
Definitely checking this out, web without needing JavaScript sounds VERY appealing!
I've been looking at your project and I have some questions: How about web sockets security? How about of the lack of UI component libraries and have to reinvent the wheel? Since JetBrains is focusing developing it to have a good ecosystem for web, based on wrappers over existing JS libraries, what do you think about using Kotlin JS? How about testing?
I use Vert.x for HTTP requests, HTTP server, managing workers/threads, encoding/decoding JSON, websockets, asynchronous promises, and basically everything. It's also really fast.
Well done. I'm new with web dev, will i be ok for small personal projects just with by the docs?
Those are some of the most annoying mistakes to make, the ones that are due to having to keep your project code and article code synced up. It's also why you get an editor if you can ;)
Hopefully. Give it a try, you should be able to get something simple up very quickly and that will give you a sense of how it is to work with. Let me know if you have questions, happy to answer here or in our [chat room](https://gitter.im/kwebio/Lobby).
&gt; I've been looking at your project and if I not wrong, what you are doing is creating a Ktor server rendering HTML from the server and comunicating with the client via websockets with JSON, isn't it? Yes, that's correct. &gt; How about web sockets security? Since Kweb uses Ktor underneath, if you configure Ktor to use HTTPS then the WebSocket messaging should be encrypted, is that what you meant? &gt; How about of the lack of UI component libraries and have to reinvent the wheel? We avoid reinventing the wheel by supporting plugins for JavaScript component libraries. We [support](https://docs.kweb.io/en/latest/style.html) a library called [Fomantic UI](https://fomantic-ui.com/) which integrates nicely with Kweb. Plugins for other UI libraries like Bootstrap, Foundation etc can also be created with relative ease, it's mostly just a question of understanding the framework well enough to create a good Kotlin DSL for it. &gt; How about testing? Pretty good although it could always be better. In particular we [use](https://github.com/kwebio/kweb-core/blob/master/src/test/kotlin/io/kweb/demos/todo/TodoDemoTest.kt) Jupiter/Selenium to test Kweb's browser integration.
I've created [KVision](https://github.com/rjaros/kvision). It allows to build web apps in Kotlin with full-featured UI components library, and also contains bindings for Electron (desktop apps), Cordova (mobile apps) and RPC interfaces for Ktor, Spring Boot and Jooby to create full-stack apps. Of course it's surely not an "industry-standard" library ... yet ;-)
How do I know if it's being built with Gradle and not just being ran with Intellij IDEAs configuration magic?
You'll see Gradle build logs in your build output as well as Gradle files in your project.
Ok that sounds now more like the functional way to me. I made good experiences with avoiding state completely except inside of actors (which means no fields with var in classes). But you must know I'm not that experienced anyway. I think as long as encapsulating works, state is not a problem at least in my use cases. But I'm sure if you have something completely stateless, you can be more sure that it does what it is supposed to do.
Don't worry, I'm not that experienced either. A lot of trials and failures!
Take a look at [KVision](https://github.com/rjaros/kvision), my open-source framework. It helps you create fullstack web apps with pure Kotlin.
The idea behind the project is nice, in .NET the same idea is currently in development, Blazor is the project, but it has two variants: 1. Using Web assembly (wasm) in the client and comunicating with the server as you want, REST, RPC etc. 2. Rendering HTML templates from the server like your framework and comunicating client and server with SignalR that uses different protocols under the hood, one of them is websockets. Have a look on Blazor and you can take some ideas from there if you have some knowledge of C# language. Also, currently I'm wrapoing some JS libraries to be used with Kotlin JS like JetBrains Kotlin JS wrappers. I like your project, when I have some time I will make some plugins of Bootstrap or Material to power Kweb. Thanks for asking my questions!
Check out [https://docs.kweb.io/](https://docs.kweb.io/).
I would go with Kotlin+Spring Boot and build some microservices with REST APIs for back-end and as front-end an independent SPA built with a modern JS-framework like React or Vue.
&gt; I'm lost: Where to start? How do I structure my application? How to generate HTML (template engine, or via Kotlin DSL?) Which javascript framework to choose (angular, react) ? Or is it possible to use Kotlin also on the browser side instead of JS ? Which framework on the server side, etc. The stack /u/vilpo1 is suggesting (Spring Boot backend, React/Vue frontend) is the industry standard. If you want to learn a skill that will matter to employees, this is the way to go. The other two suggestions you've gotten are for their own personal projects. While they might be fun to experiment with, no one will hire your for that knowledge.
You need to look on javalin.io
Vaadin if you don't want to waste too much time designing front-end stuff. As a backend-dev that sometimes need to create an interface or two, that's my choice.
I had trouble finding an answer to this, even 5 months later. So thought i'd post it. There are answers for this but they are lodged amongst other junk and just not entirely clear. If you get one of these issues from your Kotlin gradle DSL \- gradle cannot find method kapt() \- kapt call gives this error: Type mismatch: inferred type is String but Action&lt;KaptExtension&gt; was expected Make sure your gradle code has these things, in this order: plugins { kotlin("multiplatform") kotlin("kapt") } kotlin {//Must be before dependencies block android() } dependencies {//Kapt dependencies must be in top level block "kapt"("your-dependency") //Must use quoted "kapt" otherwise you get some other incorrect method with the same name -&gt; org.gradle.api.Project.`kapt` }
The team I'm in consists of devs who grew tired of Spring and switched to DropWizard (which has way less magic), then started working in Kotlin and now we're on the fence as to whether we should just switch to a Kotlin native framework like Ktor or if we should use VertX. VertX certainly seems like the best of the currently available Java web frameworks (especially given that it's not really a framework, more like a library) but not having to deal with nully stuff is a minus. How are you finding it?
You might want to try over at /r/androiddev
Jetpack Compose is in a super early "pre-alpha" state. There's no tooling support for previews yet.
You can use Create React Kotlin App too.
It has Kotlin extensions, which makes it really easy to use in Kotlin. In one project I'm using Kotlin Vert.x and in another I'm using Java Vert.X. But yeah, null stuff does exist. I like it a lot. I think if I wasn't using Vert.x in Kotlin I'd probably use Javalin. But Vert.x is my first choice.
Desktop application... Meaning a GUI? I'd look at TornadoFX
Map of remainder to word for more flexibility?
Wait, so I can now do type inference in lambdas? I'm not home for another few days, but if I have say a class ``` interface SomeClass&lt;A, B&gt; { val value1: (A) -&gt; B val value2: (B) -&gt; A } ``` and a builder ``` class SomeClassBuilder&lt;A, B&gt; { lateinit var value1: (A) -&gt; B lateinit var value2: (B) -&gt; A fun setValue1(func: (A) -&gt; B) { value1 = func } fun setValue2(func: (B) -&gt; A) { value2 = func } fun build() = object: SomeClass&lt;A, B&gt; { override val value1 = value1 override val value2 = value2 } } ``` I could do this ``` fun &lt;A, B&gt; buildSomeClass(bldr: SomeClassBuilder&lt;A, B&gt;.() -&gt; Unit) = SomeClassBuilder&lt;A,B&gt;().apply(bldr).build() buildSomeClass { setValue1 { ... } setValue2 { ... } } ``` and it would infer `A` and `B` for me?
Do you have a onContextItemSelected? Thats where you put the intent code for pressing the item override fun onContextItemSelected(item:MenuItem) : Boolean { var info = item.menuInfo() when (item.itemId()) { R.id.my\_only\_option -&gt; {//start Intent return true; } default -&gt; { return super.contextItemSelected(item) } } (might be a bit off, not doing it in an editor) Does this answer your question?
Yes i have it. But seems i was forgetting to return true
Thank you
Sorry for not having replied yet. I'll still doing it, just got a bit swamped at work this week. Will reply later in this week with a proper answer.
Oh that explains why my IDE prompted me to remove stuff and why the compiler started complaining right after. I already thought it was super weird.
floats and ints are fundamentally different stuff, i dont see why they should be treated like they're the same
Potentially, if the bldr argument is marked with @BuilderInference. At least that's how the experimental mode on 1.3.31 worked.
Think of the Kotlin primitive types as if you'd be using the Number-object-types in Java - it wouldn't work with them either.
I tend to see D and Rust as C++ and C replacements, respectively. In the middle, there is Nim. Interesting language (about to reach 1.0 in few months)
So you have to explicitly shoot yourself in the foot. Haven't tried, this might work: ``` operator fun Float.plus(other: Int): return this + other.toFloat() ```
Looks very cool! But I'm also wondering if a libgdx port to pure kotlin would make more sense, since I guess, a lot of people are using libgdx today and could then just switch? I mention this, because libgdx is somewhat struggling - in my perspective - with compiling to iOS
At first when I saw this on my feed I thought" oh God why..." and then I saw it's from Kotlin! This is actually a thing that is missing in the Kotlin ecosystem right now. Hopefully it is or will be as powerful as other engines (Unity, Unreal, etc)
This is probably for safety. Automatic conversions are not very safe, and it’s good to force a programmer to explicitly call a function to do the conversion, so they’re aware of what’s going on.
Korg would be my guess. You can actually develop games in Kotlin with libgdx though I haven't done extensive work myself.
In that particular case, widening an Int to a Float is a lossy widening. At the upper end of the range, there are Ints that can't be perfectly represented by Floats. When promoting such an Int, you would get a meaningfully different Float. In the general case, I don't know. Some promotions *are* safe. I guess they are going for consistency. &gt; why not add something like the custom add operation methods, but for converting I don't know what you mean. Things like `+` work [by essentially having a bunch of overloads](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/plus.html). You could do the same thing. If you want your function to also accepts Ints, create an overload. You'll quickly run into combinatorial explosion (what happens if they pass an Int and a Float, or pass a Float and an Int?).
Kotlin Native does not require manual memory management
Word is that's [not going to happen](https://github.com/libgdx/libgdx/issues/5418#issuecomment-432015765).
Someone with a lot of time on their hands can port it.
&gt; Map of remainder to word for more flexibility? Yes, sounds good to me.
&gt; Using Web assembly (wasm) in the client and communicating with the server as you want, REST, RPC etc. Kweb currently uses JavaScript in the browser (internally), but it could probably transition to using WASM without substantial API-breaking changes. I'm not sure there would currently be much practical benefit to that today, but it's an option. &gt; I like your project, when I have some time I will make some plugins of Bootstrap or Material to power Kweb. That would be great! Please let me know if I can help.
[https://stackoverflow.com/questions/9689793/cant-execute-jar-file-no-main-manifest-attribute?page=1&amp;tab=votes#tab-top](https://stackoverflow.com/questions/9689793/cant-execute-jar-file-no-main-manifest-attribute?page=1&amp;tab=votes#tab-top) &amp;#x200B; Does this not answer your question?
I thought it was korj. Like forge but with a K because Kotlin.
i am confused with command line usage .
Is it an exectuable jar and is the attribute in the manifest?
as it described in the doc i've generated the jar file using the following command. kotlinc sample.kt -include-runtime -d sample.jar.
Yeah, he is lying to you. There's no manual memory management in Kotlin Native/Multiplatform. And Kotlin is a much nicer language than C++, so even if you had to manage memory Kotlin would still be a clear winner IMO.
Are you using gradle?
no gradle only command line tools
Ah, got it. Sorry, I was confused. I would definitely suggest gradle in the future. It can make things easier Check out this answer for running Koltin classes from the command line (and other ways). They're more eloquent than I will ever be. [https://stackoverflow.com/questions/14733566/how-to-run-kotlin-class-from-the-command-line](https://stackoverflow.com/questions/14733566/how-to-run-kotlin-class-from-the-command-line)
&gt; floats and ints are fundamentally different stuff,
they're just both numbers, same way both dogs and cows are mammals. you wouldn't milk a dog tho
Oh sorry - I wanted to write something about Int and Longs also being treated differently (even though widening Int -&gt; Long wouldn't technically cause problems), but decided not to - seems I accidentally pressed enter before I wrote anything.
Why port when you could redesign.. LibGDX is usable from Kotlin currently, but contains a lot of historical cruft and cumbersome API:s that could do with some modernization.
Enterprise here, spring+kotlin for web app backends and various microservices and cli utilities. No android. It's been great 2 years...
I'm just investigating the same thing for a personal project. I understand that a popular stack for Kotlin backend web development is Ktor + Exposed + rdbms (as popular as Kotlin nowadays can be...). Spring is a very complete framework and maybe it's the only one that has that feature you need. But on the other hand if you need something simpler you can go lighter and probably be more "kotliner" using Ktor for managing HTTP and adding other specific solutions for data access or any other need you have.
Where does it say it's by the Kotlin people?
Doing Ktor + exposed also for a web app for my university. Really straight forward to program.
You said you're trying to avoid dupe classes but maybe try Sealed classes? https://kotlinlang.org/docs/reference/sealed-classes.html ``` sealed class DataRecord(val date: Date? = null) { data class V1(val date: Date? = null) : DataRecord(date) data class V1(val date: Date? = null) : DataRecord(date) .... More versions } ``` Then you can easily use a when statement to check the versions
With your model, you can't use non-null types for any app specific values (you can't have a `val date: Date` property), and you don't prevent consumers of the code from doing whatever they like with that field (app3 could happily start using "date" to store created when you're using it for updated elsewhere, etc). You also need to implement that validation logic somewhere - if the version is Version2, you need to verify that a date is supplied (assuming it is required), if it's Version1 you need to verify that date is NOT supplied. This is going to get into a lot of switch statements and code duplication. Why are you trying to avoid interfaces / implementing classes? The problem is well suited to solving using the type system: common properties defined in an interface, base implementation of that and context (application) specific variations via other implementations. If it's just a case of wanting to avoid duplicated fields, you can use [Implementation by Delegation](https://kotlinlang.org/docs/reference/delegation.html#implementation-by-delegation) to reduce boilerplate and make code easier to maintain ```kotlin // in app-common interface DataRecord { val foo: String data class Base( override val foo: String ) : DataRecord } // in app-1 data class App1DataRecord( val base: DataRecord, val date: Date ) : DataRecord by base // in app-2 data class App2DataRecord( val base: DataRecord, val username: String ) : DataRecord by base ``` Using them is a little bit clunky (because of needing to instantiate the relevant `base` values: ```kotlin val base = DataRecord.Base(foo = "bar") val app1 = App1DataRecord(base = DataRecord.Base(foo = "bar"), date = now()) val app2 = App2DataRecord(base = DataRecord.Base(foo = "bar"), username = "jimmy") ``` But you can clean that up with type aliases or aliased imports, etc: ```kotlin typealias Base = DataRecord.Base val core = DataRecord.Base(foo = "bar") val app1 = App1DataRecord(Base(foo = "bar"), date = now()) val app2 = App2DataRecord(Base(foo = "bar"), username = "jimmy") ```
Yeah, I use it for our web servers with the javalin framework.
Same here except (only) since the beginning of this year.
https://libktx.github.io/ not a port, more like a wrapper, i think. but still, I use it for some time, and like it
Not really enterprise but I'm a freelance software developer working for some clients in Kotlin + Spring Boot and I'm building a SaaS startup also with the same stack. I believe Kotlin + Spring Boot is one of the best combinations right now to do backend/web development in. A stable mature framework coupled with a very modern language.
Kotlin + Vert.x + Hibernate (ewww.)... It's bit over a year. Very happy so far with Kotlin but I do have qualms about compile time now that the project is large-ish. I can't get incremental compile and kapt incremental to work reliably. &amp;#x200B; Kotlin stats for the main back-end: &amp;#x200B; \`\`\` \------------------------------------------------------------------------------- Language files blank comment code \------------------------------------------------------------------------------- Kotlin 290 12429 21776 37120 ... \`\`\`
I used and use Kotlin for backend development instead of Java with Spring, Kafka, gRPC, ... Companies include trivago and N26. Much better than Java because it's less verbose, especially to write code that handles null correctly. Of course all the JVM shortcomings are still present.
Enterprise here. Spring + coroutines + kotlin works really well.
Please check my playlist bro. [https://www.youtube.com/playlist?list=PLEuPkF3cr7ADCPE6n78zbBHGdjWIEFbqv](https://www.youtube.com/playlist?list=PLEuPkF3cr7ADCPE6n78zbBHGdjWIEFbqv)
Vert.x has a lot of extensions that goes much beyond simple serving web stuff. The fact that it's build around a service bus makes it very easy to achieve patterns that would require additional package grafting on other server. For example on our micro-service platform is was a breeze to retrofit a real time event notification system just by sending event on the bus and bridging them to the websocket server so they would be available to the web-client. All our API is generated by an openapi 3 schema that is parsed by vert.x All our services run inside "Verticles" so if we have a bottleneck on the image preview generator we can simply start five more and let them register into the cluster and the event bus. And I don't want to pretend that running a cluster is as simple as adding "--clustered" to the command line but it basically is. It also abstract the cluster manager so whoever manages the infrastructure can pretty much choose whatever they want. Developers need not to care. The kotlin extensions are pretty good, the vert.x team uses a code generator so nearly all the asynchronous method have both the callback pattern and a suspendable function that is coroutine friendly. Even the core objects like Verticles have a coroutine version. There's a Json helper built on top of Jackson and they even added a DSL just for Kotlin users to make json building slightly less unpleasant than it is in Java. I'll need to check but I think they are good at marking the values @NotNull or something in java when they can be so Kotlin's compiler knows. Most of the API is fluent and they have or generate functional version, so in most place you can pass a class or a function/lambda without issues. They also have extensions to Junit to allow testing asynchronous code. And as much as it can grow, a basic http server with a router and a handler is still three lines of code if you need it without having to import all the stuff mentionned above. You could very easily use vertx in a ktor application if you just want to use it for the service bus. Or you could run ktor in a vertx Verticle. It's really an excellent framework
Big thanks for taking the time to write such a detailed reply, I will share it to my team!
Hey :) I try to learn Kotlin but I don't need basic knowledge like loops, ifs or how to make a Funktion. Do you plan to get to the specifics for android development? Like how to make REST, how to make a notification, how to make an action to specific times ( for example: always at 8 O'clock make a notification) ? I really search for something like this :p
Oh is that so? Actually that is on my pipeline. I just started my series this month. Actually I am targeting those specific features to be developed on android using Kotlin. Anyway, thank you for the tips. I will definitely do that, maybe 2 to 3 months from now after I finish the basics of Kotlin.
That would be so cool! And I will definitely save this post for me for later ;D
No problem bro, and thank you for the support.
Remind Me! 2 month "time to learn!"
Also, can you provide other specific topics that you want to learn?
Definitely programming paradigms, security and lifecicle of an app with a Database (what is the best time to write to the dB for example). Notifications is really important to me and how to make a scheduled action like every morning send a notification. Fragments would be a topic too.
RemindMe! 2 months "time to learn!"
Wow, those topics are so advanced. In my work, we are doing those features everyday, but currently we are doing it on Java. I am definitely gonna include those on my tutorial. Maybe dividing the android development between basics and advanced but pure Kotlin perhaps? What do you think?
I will be messaging you on [**2019-08-27 09:12:42 UTC**](http://www.wolframalpha.com/input/?i=2019-08-27 09:12:42 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/Kotlin/comments/c632sy/i_create_a_tutorial_for_basic_kotlin_programming/es5suib/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/Kotlin/comments/c632sy/i_create_a_tutorial_for_basic_kotlin_programming/es5suib/]%0A%0ARemindMe! 2 months ) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
I think to split them is a good idea. And to be coherent Kotlin would be the choice :) But if you split it and make it modular there should be no problem to switch to Java if you prefer this. You can use Kotlin and java in the same project.
Neat idea! Ok, I have a lot of work to do with my tutorial. Thank you very much for giving me a push to be creative.
And thank you when I'm able to realise my app ideas when I watch your tutorials! :)
Hhahaha, that would be nice. We did a "rubber-duck debugging" kind of thing subconsciously....
I suggest starting with [Kotlin koans](https://github.com/Kotlin/kotlin-koans). It is a useful tutorial which focuses on use standard library. If you are looking for useful links, you could start with [awesome list](https://github.com/KotlinBy/awesome-kotlin).
Advertisement
Interesting. Can these tools be used to add better Kotlin support in other IDEs (e.g. VS Code)?
The important question is: What is the type T used for other than the callback? &amp;#x200B; For example if it is only used in the callback, you can make it non-nullable: \`fun &lt;T:Any&gt; foo(bar: (T) -&gt; Unit)\`. Otherwise, you would have to change the nullability in the other place where T is used, for example like this \`fun &lt;T:Any&gt; foo(input: T?, bar: (T) -&gt; Unit)\`
Those solutions do not work unfortunately. The function is a delegate factory. T appears in the parameters and the return type, and must be consistent there. Basically, the signature is like this: fun &lt;T: Any?&gt; foo(initial: T, cb (T-Notnull)-&gt;Stuff): ReadWriteProperty&lt;Any, T&gt;
Interesting idea! I think such integration would require some extra work. For example, there is an Intellij IDEA [SonarQube plugin](https://plugins.jetbrains.com/plugin/7238-sonarqube-community-plugin) for integration with SonarQube inspections. It checks local project code against rules on SQ server and highlights incorrect code in IDE text editor. I imagine, it's entirely possible to implement similar plugins for VS Code, that would run detekt or ktlint or other tool in background or on a remote server. Right now, I am not familiar with such projects for other IDE's. But I know, that VS Code plugins are pretty easy to implement, and while this integration is possible - it might require writing some tools or plugins from scratch.
The kotlin subreddit. Sorry, I should've written clearer.
I don't know why you can't do fun `&lt;T: Bar&gt; foo(initial: T, cb (T)-&gt;Stuff): ReadWriteProperty&lt;Any, T?&gt;`. What do you mean by "have to be consistent"? Maybe I don't understand, but I think it depends on the rest of the factory method and/or the class it is defined in how you can do it.
Because I want to be able to pass initial=null (or any nullable variable). However, I also want to use the function to create non-nullable delegates.
&gt; OkHttp is an HTTP client for Java and Android. Until today the library itself was all Java. With version 4 we’ve switched to Kotlin, replacing 25K lines of .java with equivalent .kt. Was there any reducing of LOC?
It _should_ be an approx reduction of 40%. but only if they actually converted java based systems with kotlin equivalents (eg lombok annotated classes to kotlin data classes, Singleton code to object in kotlin etc.)
There aren't any data classes or singletons really so the line number reduction isn't as dramatic as an application project. See https://publicobject.com/2019/05/13/metrics-for-okhttps-kotlin-upgrade/
Motivation to switch to kotlin? It seems the binary got bigger...
anything that can be improved with DLSs?
[https://github.com/square/okhttp/issues/4723](https://github.com/square/okhttp/issues/4723)
So you want to Pass in null at first and have it produce a non-nullable delegate nonetheless?? Because you know it is set somewhen before access?? Depending on the method body you could as well take a nullable init value in my example. If you want the delegate type nullability depend on the init params nullability but sometimes it should not correspond, then no, this is Not possible i think. And it also doesnt make sense, i think xD because the delegate would have a completely different behavior, so it should be another factory.
Were you able to generate javadocs with Dokka? We had hard time with our library written in Kotlin. We gave up leaving only the Kotlin docs.
Reducing LOC is not a goal in itself. If it's idiomatic Kotlin now there's no reason to add DSLs just to reduce code size
Nice Info, thanks! Since compilation takes ... A lot longer do you have any comparisons of incremental compilation? For lets say changin 1 to x files?
Fuel http is what we use extensively. Had memory leak issues with okhttp in past
Got a link to an issue about it?
Have compared klint to all of the inspection the IDE offers or just to the default oney? I have read somewhere that many are turned off and that they are supposedly very good.
Totally wrong, as mentioned by others. Worse, on the JVM side, C++ will need to go through JNI, so you'll have ugly (ish) interop with performance concerns.
Won't compile, replace \`: return\` with \`=\`.
Only Kotlin docs are generated at present. I don't think we even tried Javadoc.
Java does implicit widening conversions even if the conversion is lossy. int -&gt; float is a lossy conversion. [Link](https://docs.oracle.com/javase/specs/jls/se10/html/jls-5.html#jls-5.1.2) Kotlin does not implicitly do any widening conversions, regardless if they are lossy or not. [Link](https://kotlinlang.org/docs/reference/basic-types.html#numbers) Personally I would allow widening conversions if they are lossless and require explicit widening when potentially lossy. This would prevent verbosity when it is safe and mark unsafe conversions explicitly, calling them out. In both the Java and Kotlin implementations you don't know from just looking at the conversion if it might cause a problem or not, you need to think about the types involved and their behavior in relation to one another.
I think there's lots of things they're planning to improve in the next version and beyond. But this version was about just converting to Kotlin and otherwise maintaining binary compatibility.
Up-voted the youtrack ticket and added a comment on it. I would encourage everyone to do the same.
Indeed!
You can try the Android Developers Codelab website which will show you some of the things you will need for your app, like Architecture Components, Room Database, RecyclerView and Connecting to the Internet. You can download the code and pull it apart or work through the examples in the labs. https://developer.android.com/courses/kotlin-android-fundamentals/toc
You can try... https://superkotlin.com/kotlin-mega-tutorial/ What are you wanting to develop with Kotlin? Android, Web, Desktop or other solutions? The above site will give you an introduction, however you won't really learn anything useful until you start building projects.
Thank you.
Try not specifiying nullability on type parameter itself, but on the usages. So not fun &lt;T: Any?&gt; fname(param: T) : T //Each T is Any? but fun &lt;T: Any&gt; fname(param: T?) : T //param is Any? but return is Any so i guess in your example instead of fun &lt;T: Bar?&gt; foo(initial: T, cb (T-Notnull)-&gt;Stuff): ReadWriteProperty&lt;Any, T&gt; try fun &lt;T: Bar&gt; foo(initial: T?, cb (T)-&gt;Stuff): ReadWriteProperty&lt;Any, T&gt; initial can now be null, while the cb has a non nullable parameter of type Bar.
Doing JavaEE backend on jboss in kotlin since before release successfully. Just dont forget to use "all-open" compiler plugin, because default final classes messes with many Java frameworks.
Exactly! 👍
It's one of the most widely used http libs around, including in many high performance applications. If you had memory leaks I would start by assuming they were in your code, unless proven otherwise.
Is there any reason why I should use OkHttp instead of Volley or Ktor?
I would not encourage everyone to add a comment unless you have something substatial to add. YouTrack mails people when something about an issue changes, and I've got lots and lots of mails about "me too" and "+1" comments.
I'm not missing package private that much, since i prefer subprojects, where internal visibility is nice (nicer??) and sufficient, although i understand that that can leak. I also prefer explicit api with interfaces and an api artifact people can compile against that simply doesnt contain anything implementation related. I sometimes have a hard time arguing in this way with colleagues, so can anybody tell me (seriously) what it is that makes people need package private so badly? Disclaimer: I'm not against it, but one of the arguments in the issue is that one can't say it's better with or without package private, so it should be added. And i am against this argument, because this attitude leads to feature creep and yet another possibility of visibility.
This test doesn't show you what you think it does. Hint: if you swap the two measureNanoTime() lines in your test, you'll see opposite results. You need to use JMH for proper benchmarking.
I haven't compared current rulesets content. I think this comparison will become obsolete with new releases of each projects. While all those rulesets have differences, there is of course an overlap, especially in simple basic rules, such as wildcard imports, redundant semicolon, unused variables, etc. I'm using IntelliJ IDEA 2019.1.3 right now and most of the Kotlin inspections are enabled by default.
The call order doesn't affect the result, obviously the difference can increase or decrease but not significantly
You also can't measure anything when you do a single iteration. Right now you're measuring mostly classloading performance.
I'm pretty sure `listOf` is defined as fun listOf(vararg elems: T): List&lt;T&gt; = mutableListOf(*elems) as List or something along those lines. Maybe it's due to there is just one extra function call level.
 Average 1000 runs -&gt; listOf: 8975 Average 1000 runs -&gt; mutableListOf: 7425 Fastest run -&gt; listOf: 200 Fastest run -&gt; mutableListOf: 400 Slowest run -&gt; listOf: 6391700 Slowest run -&gt; mutableListOf: 5226300 After 1000 runs on average listOf is a bit slower on average but if you compare run by run you see that most of the time listOf is faster by a lot. But sometimes it's way slower. Don't really know what happened there. &amp;#x200B; import kotlin.random.Random fun main() { var mutableListOfA : Long = 0.toLong() var listOfA : Long = 0.toLong() var fastestmutableListOf = 99999999.toLong() var fastestListOf = 99999999.toLong() var slowestmutableListOf = 0.toLong() var slowestListOf = 0.toLong() for( i in 0 until 1000) { val v1 = Random.nextInt() val v2 = Random.nextInt() val v3 = Random.nextInt() val v4 = Random.nextInt() val v5 = Random.nextInt() val mutableListOf = measureNanoTime { mutableListOf(v1, v2, v3, v4, v5) } val listOf = measureNanoTime { listOf(v1, v2, v3, v4, v5) } if (mutableListOf &lt; fastestmutableListOf) fastestmutableListOf = mutableListOf if (listOf &lt; fastestListOf) fastestListOf = listOf if (mutableListOf &gt; slowestmutableListOf) slowestmutableListOf = mutableListOf if (listOf &gt; slowestListOf) slowestListOf = listOf mutableListOfA += mutableListOf listOfA += listOf println("Run #$i -&gt; listOf: $listOf") println("Run #$i -&gt; mutableListOf: $mutableListOf") } println("Average 1000 runs -&gt; listOf: ${listOfA / 1000}") println("Average 1000 runs -&gt; mutableListOf: ${mutableListOfA/1000}") println("Fastest run -&gt; listOf: ${fastestListOf}") println("Fastest run -&gt; mutableListOf: ${fastestmutableListOf}") println("Slowest run -&gt; listOf: ${slowestListOf}") println("Slowest run -&gt; mutableListOf: ${slowestmutableListOf}") }
[It's not](https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/collections/Collections.kt#L75)
&gt;Should be better to work only with mutableListOf and then pass, when necessary, the result as read-only list? Assuming `mutableListOf` is actually faster. Does your code actually need that extra performance? If not you should stay with `listOf` since it signifies the list is meant to be immutable. As Donald Knuth said, "Premature optimization is the root of all evil".
Offtopic: Instead of 5.toLong(), you can use 5L to get a Long number :)
Thanks didn't know that :D
Neither Volley nor Ktor are HTTP clients, but instead are HTTP client wrappers. If you're using Volley, you can and probably should be using OkHttp as the client which backs it.
The main reason for having package-private is that with proper separation of concerns, you often have classes or functions that are only intended to be visible to a small subset of classes and creating a subproject / module for each of these subsets is detrimental as it goes too far. I should mention that I'm a big proponent of using modules to separate key sections of the project. It's just that I wouldn't want to have hundreds of modules that only have 2 or 3 classes per module.
I don't need package modifier as such BUT package+it's subpackages visibility would be really useful. So, class in \`com.a\` would be visible in \`com.a.b\` too.
Can you give a more precise example on what I cant do with either Volley nor Ktor that OkHttp provides?
Hm, okay, I have never been in such a scenario - most often in Kotlin I use file level private, make everything that is an API public and things i really do need to access from elsewhere in the module internal, ignoring that the rest of the module caaaan potentially use the internal stuff. But I'm also not afraid of extracting a 2-3 classes module if I really really don't want internal classes to be used in another module or sth. &amp;#x200B; package private feels a bit like a module in a module - but I'm already at a point where adding a gradle subproject is not an effort for me any more, and since I know that others are likely not at this point, I can understand why people want package private "back". thanks for your insight.
You could create two extension functions for that.
Yeah, probably overlooked. Here is the extension if you want it for Ints: private operator fun IntRange.component1(): Int = this.first private operator fun IntRange.component2(): Int = this.last If you want this for all closed ranges, you could do this: private operator fun &lt;T:Comparable&lt;T&gt;&gt; ClosedRange&lt;T&gt;.component1(): T = this.start private operator fun &lt;T:Comparable&lt;T&gt;&gt; ClosedRange&lt;T&gt;.component2(): T = this.endInclusive
I’d probably question this in a code review, because destructuring a list like thing as `(a, b)` is usually means `(thing[0], thing[1])` and not `(thing[0], thing[n])`
Yeah, for some reason they didn't base it at 0. Kinda weird with everything else based at 0.
I see different results with Kotlin 1.3.40 and Java 11.0.2 Average 1000 runs -&gt; listOf: 16056 Average 1000 runs -&gt; mutableListOf: 32641 Fastest run -&gt; listOf: 600 Fastest run -&gt; mutableListOf: 1900 Slowest run -&gt; listOf: 13935300 Slowest run -&gt; mutableListOf: 19646900 I'm not surprised to see `listOf` being faster. The vararg `listOf` does almost no work. It ultimately just calls `Arrays.asList()` or `Collections.emptyList()`. On the other hand, `mutableListOf` will call the `ArrayList` constructor that takes a collection; that constructor will do an `Arrays.copyOf`.
It’s tradition! Tuples have traditionally been ordinally numbered because they are an abstraction. Arrays are 0 based and cardinally numbered because they were original mappings onto pointer positions. Ranges to me are iterables/listlike though, and when restructured I would expect them to conform to the way lists restructure.
I believe there should be next to no difference since they are both backed by Java ArrayList. Creation of the mutable list does and extra step of creating a collection around the parameters then going .toArray() and using that in the ArrayList ... so it should be slightly slower considering the array creation and Collection wrapper. I also added list concatenation for interest. Just for giggles I ran the JMH test below and found there was no notable difference between the 2 as expected from above. ``` Benchmark Mode Cnt Score Error Units ListJMHTest.measureConcatenateList avgt 25 71.894 ± 3.805 ns/op ListJMHTest.measureConcatenateMutableList avgt 25 82.354 ± 13.480 ns/op ListJMHTest.measureCreateList avgt 25 15.666 ± 0.550 ns/op ListJMHTest.measureCreateMutableList avgt 25 21.371 ± 0.352 ns/op ``` As expected the measureCreateMutableList is a bit slower but the concatenation overlap in the error margin so we cant really draw much of a conclusion also there might be some effect from the static mutable lists continuously growing (although I believe jmh would clear this). &amp;#x200B; ```kotlin package io.kware.jmh import org.openjdk.jmh.annotations.\* import java.util.concurrent.TimeUnit private val *mutableListA* = *mutableListOf*(1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15) private val *mutableListB* = *mutableListOf*(1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15) private val *listA* = *listOf*(1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15) private val *listB* = *listOf*(1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15) @State(Scope.Thread) @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.NANOSECONDS) open class ListJMHTest { @Benchmark @CompilerControl(CompilerControl.Mode.DONT\_INLINE) fun measureCreateMutableList(): List&lt;Int&gt; = *mutableListOf*(1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15) @Benchmark @CompilerControl(CompilerControl.Mode.DONT\_INLINE) fun measureConcatenateMutableList(): List&lt;Int&gt; = *mutableListA* \+ *mutableListB* @Benchmark @CompilerControl(CompilerControl.Mode.DONT\_INLINE) fun measureCreateList(): List&lt;Int&gt; = *listOf*(1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15) @Benchmark @CompilerControl(CompilerControl.Mode.DONT\_INLINE) fun measureConcatenateList(): List&lt;Int&gt; = *listA* \+ *listB* } ```
Yeah but it's not the kind of boilerplate you usually want in your codebase. I just felt it was quite obvious to be included in the framework, but actually as some fellows explained in this thread, Ranges are seen list-like and destruction on lists doesn't work the way I expected it on Ranges.
I think you've misinterpreted my statement. Neither Volley nor Ktor are HTTP clients themselves. They don't _speak_ HTTP. They delegate that responsibility to some other actual HTTP client. Let's look at Volley. Volley has a concept called `HttpStack` which is the mechanism responsible for actually speaking HTTP to a remote server. There are (or, were, I haven't thought about Volley for like 6 years) two built-in `HttpStack` implementations in Volley: one which talks to `java.net.HttpURLConnection` and one which talks to `org.apache.http.HttpClient`. These are both HTTP clients that actually speak HTTP. Volley merely creates request objects, manages a request queue, and delegates to the chosen `HttpStack` to fulfill those requests. Now because of this `HttpStack` abstraction, you can use OkHttp as your implementation. [Here's a 6-year-old tweet from me about it](https://twitter.com/JakeWharton/status/336658228345700353). [And a newer one](https://twitter.com/JakeWharton/status/390607762918367233). [And a newer one](https://twitter.com/JakeWharton/status/568821973909766144). If you are using Volley, you should probably be using OkHttp as your `HttpStack` since it's a better and more modern HTTP client than `HttpURLConnection` and Apache's `HttpClient`.
Oh yeah I've read before that you could use Volley with OkHttp, but at cost of app size... I get it now
Is it vert.x or Hibernate that you dislike? &amp;#x200B; I've been a big fan of vertx + jooq, but haven't used it in a large code base.
Everything is at the cost of app size. Volley reimplements things like caching that are built-in to OkHttp allowing you to likely get rid of Volley altogether and just talk to OkHttp.
Hibernate.
If you are already a Java (or any other OOP language) programmer then this free course will be helpful [https://www.youtube.com/playlist?list=PLMB3ddm5Yvh3ojb2nipVmv1alFYRhdZj1](https://www.youtube.com/playlist?list=PLMB3ddm5Yvh3ojb2nipVmv1alFYRhdZj1)
What this needs is tons of material. Like tutorials on YouTube, answered questions on stackoverflow, source code example's for small games.
Google say their crawlers do proper client side JS rendering. As I remember back in the day it introduced, some people did experiment with the capabilities and it still had some issues. They might fixed it. Still unsure about other crawlers if you're concerned about. For modern browsers it shouldn't be a problem but keep in mind that a lot of enterprise machines still uses IE only.
You say your SSR (server-side-rendering) is done in JavaScript, but unless you're running a node server, I guess you meant "rendering" ? The main benefit of SSR is speed, you do 1 get request and the response already has the DOM/app ready for you. Without SSR you make 1 get request, then additional requests for JS files, then the browser has to go parse the JavaScript and make additional requests for data. Then it can finally render the view. When you're working on localhost this seems fine, and for most fast connections it is. However, if you're in an area where you only have 3G, it can be very frustrating. You can test this with the "Slow 3G" setting in the Chrome dev tools. You'll proabably get more answers if you ask this in /r/webdev or /r/javascript.
Very important, you might output non-js based powered pages - cms, blogs, forums whatever. You will not want to do your SSR with nodejs then. It will be way more efficient to do all the queries on Kweb side and just render the results.
Congratulations! You have a huge number of downloads compared to your website visitors and stars. I have way more website visitors, and a few more stars, but only like 10% of your downloads.
Could I use Kweb with a framework such as Spring to replace React and templating libraries?
Yes, mostly. Kweb is designed to solve the same problem as React and templating libraries, just in a simpler and (IMHO) better way. Why would you like to use it with Spring? Is that for dependency injection?
The JavaScript is generated by the server and then executed in the browser to render the page, it is just one HTTP request as you say. The question is whether it would be better to render the initial DOM state as HTML and send in that format, rather than sending JavaScript instructions. I'll try those other subreddits, thank you.
Because the website I am working on is using spring for backend and I am looking for a good and efficient solution for the front end part, ideally in Kotlin.
Kweb can work with any Java or Kotlin library, although I'm not personally too familiar with Spring (Kweb is built on the Ktor HTTP framework).
Well, the advantages of spring is that it’s a full featured framework made of many components that ca be used for everything you need. If I can compare, Ktor is to spring what flask is to django or what Sinatra is to rails.
Gotcha. I think Kweb might be right for your needs. My suggestion would be to try creating a very simple site with it to get a feel for it. I'm happy to assist in any way I can.
I’ll give it a try Monday then!
Great! I'd really appreciate your feedback, positive and/or negative.
Thank you, I had heard that about Google crawlers, but also that enough other crawlers don't support it that it's worth doing.
How does Kweb render the page? If you could include the finished HTML in the GET response, then that's objectively better than building HTML with JavaScript.
If you take a look at the source of [this demo site](demo.kweb.io:7659/) you can see what it looks like. &gt; If you could include the finished HTML in the GET response, then that's objectively better than building HTML with JavaScript. This is really the heart of the question - why is it objectively better, given modern browser design?
&gt; why is it objectively better, given modern browser design? If the response body contains HTML, JavaScript can never fail to generate it. The client won't have to spend time building the HTML. Browsers that don't support JS will still see *something*. Overall it probably doesn't matter much, but it seems pointless to give the client the data and the ability to generate the HTML, if you could just give it the HTML to begin with.
It was just way easier from an implementation perspective. The initial page-build is just the beginning of a "conversation" that the browser has with the server. It keeps things simple if the language remains the same. That said, I'll probably do it because I'm a perfectionist - but I may not prioritize it as highly if there is no significant practical benefit. Appreciate the discussion.
&gt; It was just way easier from an implementation perspective ... I may not prioritize it as highly if there is no significant practical benefit. Simplicity is a valid concern, so that's a good way of looking at it. I would but this at the very end of the backlog. Only touch it if anyone complains :)
We're on the same page then :) If you have a chance to take a [closer look](https://docs.kweb.io/), I'd greatly appreciate any feedback you have, positive or negative.
I guess some people misinterpreted your comment as being mocking (no pun intended) when it seems you instead tried to offer praise regarding the high download count; due to the wording, I can see why someone would think this though.
That makes sense, thank you. I'll see if I can word it better.
Mockk is legit
What you are experiencing is called JVM warmup. In short. Programs running on JVM start slower and gets faster as JVM optimizes its hotspots. To measure execution time more relyably you either have to do warmup manually or use performance testing library such as JMH.
9 7 8
Hey there, what's this?
I just wanna say that I Iove your project :) keep up the good work
Thank you!
Kweb can't really coexist with NodeJS as they both serve a similar purpose (Kweb managed both the browser and the server, making them appear like a unified system to the programmer).
Oh, do objects using reflection, that's a fun exercise :D
That’s a coincidence.
&gt;They both are quite similar, apart from the this reference in JavaScript. This is not possible in Kotlin, as there’s no way the lambda can reference objects other than by their name Wouldn't it be possible using `with(foo)`?
I'm not sure I understand your point. Perhaps you could check by yourself and if your proposal works, post a larger snippet?
*with* works better with an existing object, not for initialization. It'll allow you to address the object with *this*, but it won't return the object at the end. Something like... val foo = mutableMapOf&lt;String, Any&gt;() with(foo){ this["bar"] = "bar" this["baz"] = { this["bar"] } } To get that single initialization statement without reusing the object name, this works... val foo = mutableMapOf&lt;String, Any&gt;().apply{ this["bar"] = "bar" this["baz"] = { this["bar"] } } println(foo["bar"]) // prints "bar" println((foo["baz"] as () -&gt; String)()) // also prints "bar" The *apply* function (*also* also works in this case) allows for one to reference a object with *this* (or *it*), and then returns that object for further use.
Have a look at Gradle or Maven.
Sorry for manipulation. This is shown for Group Id which actually make no sense. Real stuff is io.mockk:mockk. And then everything make more sense. I am going to add it now to post and later update picture with inforgaphics.
Hey reddit. When I came to publish a library myself I had a lot of trouble doing so (many hours of trial and error as documentation is sparse), so I decided to make this. This is my first blog post, be kind :)
If you're using intelliJ, create a new project, select a grade project and tick java / kotlin support. Then you'll have a build.gradle file. You add a line in there like implementation blah:1.0.1
Ok, got your point. I didn't use any of the stdlib to actually map with JavaScript and later with the Python version.
I've never used either, but [kweb](http://docs.kweb.io/en/latest/gettingstarted.html) for kotlin looks similar.
that's the issue i find with most game engines. the lack of quality material (documentation, tutorials) is huge.
From first impression it looks like a worse version of \[kotlinx.html\]( [https://github.com/Kotlin/kotlinx.html](https://github.com/Kotlin/kotlinx.html)).
So much bloat..... When will they finally work on their own package manager ? Look at how easy it is to publish a crate with rust: https://doc.rust-lang.org/cargo/reference/publishing.html
kweb does much more than just generate HTML, it allows you to execute code on javascript events as well
I absolutely agree!
Add it to your build path as a dependency
A lot of configuration demonstrated in the article is optional or unnecessary. 1. POM metadata is only necessary for syncing to Maven Central 2. Some of Bintray package metadata is optional too 3. There is a newer and more convenient [DSL](https://docs.gradle.org/current/userguide/publishing_maven.html#sec:modifying_the_generated_pom) for modifying POM 4. `gradle-bintray-plugin` can be applied in one line using plugins DSL 5. Creating a package manually is unnecessary because it'll be created by plugin automatically on upload. 6. `bintray { publications = ["myPublication"] }` can be used instead of modifying task graph.
You can use gradle or maven (preferred way, gradle and maven are p good) or while your project isopen, put the lib somewhere in your project, right click it and down near the bottom it should say "add as library"
That's cool, do you know where people are learning about it, primarily?
Thanks for the feedback. I'll update the post.
This is weird, I haven't really noticed this as a thing because I haven't enabled type hints with the new type inference. It looks like the answer to your question is yes with caveat. The compiler won't allow you to do this when operating directly on the `Array&lt;{Comparable&lt;{Boolean &amp; Int}&gt; &amp; java.io.Serializable}&gt;` but will let you when you cast it to `Array&lt;Any?&gt;`. And this only applies when you have new inference enabled in the IDE and the compiler (flag is `-XXLanguage:+NewInference`), otherwise it will complain in the ide but compile okay. ``` val mixedArray = arrayOf(true, 1) mixedArray[0] = "hi im string" // compiler and ide should say no no (mixedArray as Array&lt;Any&gt;)[0] = "hi im string" // this is fine and has no problems ```
Here are a few articles. * [Basics](https://blog.kotlin-academy.com/mocking-is-not-rocket-science-basics-ae55d0aadf2b) * [Expected behavior and behavior verification](https://blog.kotlin-academy.com/mocking-is-not-rocket-science-expected-behavior-and-behavior-verification-3862dd0e0f03) * [MockK features](https://blog.kotlin-academy.com/mocking-is-not-rocket-science-mockk-features-e5d55d735a98) * [MockK advanced features](https://blog.kotlin-academy.com/mocking-is-not-rocket-science-mockk-advanced-features-42277e5983b5)
Besides that, I like [https://www.youtube.com/user/gosuddr93/videos](https://www.youtube.com/user/gosuddr93/videos) regarding TDD(which are using mockk) by Ryan Kay. &amp;#x200B; More links here [https://mockk.io/#examples--articles](https://mockk.io/#examples--articles)
Thank you! Do you think people are learning about MockK for the first time through these articles?
Sweet article! Glad to see another big company contributing to the community
Maybe not everybody, but stats are good as well. After all, it is just a mocking framework, not rocket science :smiley: Some hard things exist for advanced cases, but generally very simple idea.
You can check this channel : [https://www.youtube.com/playlist?list=PLEuPkF3cr7ADCPE6n78zbBHGdjWIEFbqv](https://www.youtube.com/playlist?list=PLEuPkF3cr7ADCPE6n78zbBHGdjWIEFbqv)
KotlinJS is an extremely rapidly moving target right now from a tooling perspective so there really hasn’t been a moment where it could be fully documented. It seems likely that sometime in the not-too-distant future most of the functionality from the KotlinFrontendPlugin (which is now deprecated) will be fully baked into the proper Kotlin/JS plug-in and things will stabilize.
Flutter needs a Kotlin strategy. As long as Google is dancing around that topic, it will be a hard sell and it's mostly because of the unfortunate choice to lock the platform down to a single language. I understand why Google is doing this (not invented here syndrome), but that doesn't necessarily mean that it will work that well. You can tell a lot by what Google talks about in their Flutter marketing. Dart does not come up a lot because they know it's a hard sell. Check their [flutter.dev](https://flutter.dev/), the word Dart is not mentioned anywhere. This tells me everything I need to know: Dart is considered a weakness not a strength of the Platform.
The article seems to miss one point: in a lot of apps, there's little "logic" to be shared crossplatform, and writing the views (and their animations and interactions/syncing) is the real pain. This article seems to dismiss that. OTOH, they're spot on that Dart is Flutter's weakest point. I still don't get why the Flutter team chose to go with it (yes, I've read that article .Still doesn't convince me)
They are copying Apple. Their own language...
Dart is not a bad languages. But Kotlin is much more advanced. Google has to work on the image of dart. In my opinion, features like extension function, coroutines, null-safe types and Kotlin like collections and sequences could really help.
As far as i remember, dart was made to replace JavaScript but coffescript then and now typescript has taken the market. Flutter should have gone with kotlin. Why would a dev learn dart when ts or kotlin are doing a lot more.
Kotlin has number 1 support now on android. Also the language itself received a very positive feedback from developers so far. Also it clearly has a bigger userbase also growing. I just dont understand why they are pushing dart that much. I dont like dart (syntax) neither typescript but I rather use ts because at least that language clearly has bigger support and userbase.
Instead of downgrading Android Kotlin developers to Dart they should upgrade Flutter to just properly support Kotlin native as an alternative to dart.
Except, Swift is a pretty nice language and comparable to Kotlin. So, Dart is hard sell for users of both those languages, i.e. the vast majority of Android and IOS developers.
True that. If they went with Kotlin it would have been the best situation for them
There is a new project to build UI written in Koltin, Compose. Sure, it is for Android at the moment, but I heard it will be soon possible to extend it to support other targets (HTML has been mentioned). An article should be released in the coming weeks with more details. From what I understood, the Compose team may not support other target, but will let the possibility. I guess they keep Fuchsia in mind?
Great article! Have you tried building SwiftUI layouts in Kotlin? Is the interop sufficient? I think we're really rapidly approaching a world where we can write our UI code once in Kotlin and have it map to the appropriate Jetpack/SwiftUI layout code.
Platform types is just a compile time augmentation related to nullability annotations. Any non-primitive type without nullable or not-nullade will be replaced with platform type. So you can infer platform type if any such annotation is missing using reflection.
Do you mean using Kotlin and accessing SwiftUI APIs? That doesn't work atm and I also think that this won't happen anytime soon. However, I think that once Compose is released, the support for other platforms such as iOS will be implemented quickly. First by the community and maybe by the Compose team in the future. But that's not sure.
Well-explained and a fair comparison! :) &amp;#x200B; It might be worth mentioning how both SwiftUI and Jetpack Compose can both be mixed with "legacy" code — SwiftUI can host UIViews with UIViewRepresentable, and be hosted inside a UIViewController with UIHostingController, while JetPack Compose @Composables can be annotated with @GenerateView to allow them to be used in XML.
Nothing constructive here. Kweb looks amazing 😍😍😍😍
Thank you! If you have a chance to try it and have any feedback, let me know.
Will do! I'm finishing up the backend for a project right now and it could use a front-end that doesn't use JavaFX. I'll keep you in the loop.
I tried to read and understand your thoughts on those two articles, but I can not get over a few things: * By extending Map interface, you inherit all those properties of a map and you have to implement them. I have no idea why you would want to do this, but I think it's a result of your decision to use a map-like data structure, so what really seems to happen here is leakage of things. * It looks like you aim for a heterogeneous typesafe collection (correct me), and again, I'm asking myself why you would want to do have this here. All evil seems to origin in the fact that you want the properties of your base log entry data class to be inherited from the other classes. Why not use delegation instead of inheritance and use your already defined base interface in the style of \`\`\` data class IPEntry(val basicEntry: LogEntry, val index: Int, val interfaceName: String, val address: String ) : LogEntry by basicEntry \`\`\` * Furthermore, you could implement a service class that is your parser, which takes a file and returns a collection of out LogEntry. If you make your LogEntry class a sealed hirarchy, you can easily parse a LogEntry implementation out of a given line without nasty default-try-things * You dismiss reflection, although I can only see guesses that it is slower than your map implementation - you could just cache a simple map containing KProperties for a given class of said sealed hierarchy in another service class (FilterService or sth.). Given a string from the command line, you could just filter for class instances on the collection. It would be very interesting how such a solution performs compared to the map implementation * You could implement the hasProperty function like this \`\`\` inline fun &lt;reified T: Any&gt; T.hasProperty(name: String, value: String): Boolean { return this::class.*memberProperties*.*any* **{** kCallable **-&gt;** name == kCallable.name &amp;&amp; kCallable.getter.call(this).*toString*() == value **}** } \`\`\` because there is a difference between this::class.memberProperties and this.javaClass.kotlin.memberProperties, although I don't have time to look at the details right now. * All in all, I cannot see a proper design process in your two articles. Using Map and exposing map functions everywhere makes everything less typesafe, whereas there doesn't have to be any undefined behaviour anywhere here at all. If you really really want it, you could just do the following thing: Parse each line in a bag of properties, aka a map. Use this map as a delegate and use delegated properties. Write one convenience method that is implemented by all sub classes, which indicates if a property is in the map or not...and ditch all wrappers, map interfaces and so on :)
Unfortunately I don't think that Google has intention (at least for now) to implement Compose for other platforms. In [Kotlin Slack](https://slack.kotlinlang.org) core members of the development team said that they have no intention for creating cross-platform tool at this stage but they can show some kind of support for community members that want to do it.
I'm quite skeptical about articles that compare something in very early eager-for-feedback state (Compose) and beta-state product (SwiftUI). Thank you for making it more like overview, not comparison (bonus point from me). &amp;#x200B; Let me put some suggestions (e.g. soft critique). It would be nice to add more details: what this frameworks can and can't do and how they work under the hood (e.g. Compose is build around Kotlin compiler plugins - it's not mentioned in article but it's very important I think because of some magic and limitations this approach has). Adding a link to [great Leland's article](http://intelligiblebabble.com/compose-from-first-principles/) is also nice thing to do (this article can help understand motivation behind the composable approach).
The closest alternative I can think of is [Vaadin](https://vaadin.com/) (it has free opensource and payed pro features). Alternatively, you can write apps with Kotlin using [React](https://github.com/JetBrains/create-react-kotlin-app), [Vue](https://github.com/nosix/vue-kotlin) etc. Or use [kotlinx.html](https://github.com/Kotlin/kotlinx.html) / templates for simple web pages.
https://reddit.com/r/Kotlin/comments/brkwch/kotlin_tutorial_for_beginners/
Thanks for the detailed reply. I wrote the articles because I had been studying the way that Clojure developers model data. They love maps because they have a consistent (if unsafe) view of data which they can manipulate and introspect on in consistent ways. Perhaps this wasn’t the best use case to demonstrate the techniques - I was keen to find an example that I could approach from both the data class and map approach, but should maybe have just chosen different examples. I do stand by my points * You should default to modelling data with data classes in Kotlin * There are times when modelling data with maps is better * SpaceBlanket can be used to provide a map view of data class instances for when that is more convenient * Phantom-typed PropertySets can be used to bring some type safety to map-based data.
Yes I asked several of the devs at Google I/o and they're focusing is strictly for Android at the moment. But who knows maybe down the road it'll be more open
I totally agree, I write dart and kotlin. dart isn't a well-designed language.
I think your article should also mention Flutter, even though it's not using Kotlin
Managing device power is a concern of the **Android Framework** and has *nothing* to do with Kotlin the language. *"But I write it in Kotlin!"* you say, *"...it must do!"*. Well no, it really doesn't; any more than I can safely assume that you, as an English Speaker, are a top-class expert in world Politics - just because that's also regularly written about in English. The point is, a **subject** and it's **language of expression** are separate; and you my friend are asking about the **subject** of power management. Once you know the Android API for that, the language of final expression is merely incidental. If you can't separate the two; I'll happily be *that annoying guy* who suggests working to improve your understanding of this *before* solving your problem at hand. Is this something you could have done in Java? If so; same thing - why not ask a different question in that case: give use the Java code fragment and ask where you're stuck in translating to Kotlin. But don't come onto a Kotlin sub and just ask for Android advice; it happens a lot, and yes: it's annoying.
TL;DR go ask in r/androiddev
Some things are done very differently in kotlin then in Java because of the expressiveness, coroutines and DSLs. So you can't generally say it doesn't depend on the language how stuff is implemented. But in this case the question from the poster seems like he actually doesn't know the difference.
Your putting a String in the map values when the type of the map values is MutableList&lt;String&gt;. Your bucket0 line is the correct way to add to your map. If you want to make the last line correct you would have to make an extension function
`bucketsById[1]` isn't a string but a `MutableList`.
It's confusion on the operator level. Try '.plusAssign' instead of '+=', or as is more commonly done use '.add'. It works well unless you use the operator.
Please explain what specific difference this makes.
Ok, I was on my phone and just tested this in intellij. Ignore what I said above. Looks like the compiler is trying to figure out what method to call, either `Collection&lt;T&gt;.plus(element: T): List&lt;T&gt;` or `MutableCollection&lt;in T&gt;.plusAssign(element: T)`. You might need to specify which one you want to use, because they have the same signature but do different things.
 public operator fun &lt;T&gt; Collection&lt;T&gt;.plus(element: T): List&lt;T&gt; { val result = ArrayList&lt;T&gt;(size + 1) result.addAll(this) result.add(element) return result } // vs public inline operator fun &lt;T&gt; MutableCollection&lt;in T&gt;.plusAssign(element: T) { this.add(element) } Do you see how these can both be called on a MutableCollection, but do fundamentally different things? The first creates and returns a new list while the second just adds to the current list.
Ignore that and look at what zennaque said. The compiler cannot pick between those two methods and you need to specify which one you want to use, as they do different things.
Yes but if you just call mutableListOf&lt;String&gt;() += "test string" it does not face this ambiguity. The problem only arises when the get operator and plusassign operator are used together.
I am away from my main computer but played with it using play kotlinlang. To investigate something like this, the approach would be to write some sample code in intellij and view how it's converted to java.
Typescript would be a better choice for marketshare but I don't see them adopting a microsoft tech so officially.
&gt; write some sample code in intellij and view how it's converted to java. Or use the debugger so you don't introduce peculiarities that the converter *might* have
Problems with the operator precedence seems to be most likely for me. Is there a reason why get should not be the first operation?
https://kotlinlang.org/docs/reference/operator-overloading.html#assignments lays it out fairly plainly that they do it completely intentionally. The confusing part is why this doesn't happen with just a mutableList, ie val test3 = mutableListOf&lt;String&gt;("one") test3 += "two" is not subject to that rule. The large problem is probably that your statement can validly go to two different forms, and there is not a precedence for index operations. x[1] += 1 is confusing because it can be x.set(1, x.get(1) + 1) or x.get(1).plusAssign(1)
This one!
Hmm. This seems to be it. Btw putting parenthesis around the get method does not change anything.
map[0] can return null. Maybe plus Assign is only implemented on List and not List?
Maybe map.getOrElse{ mutableListOf()} +=... Would work
It can't since the method was overridden to return V instead of V?.
Oh, right!
Actually, they will not work on other platforms, but it will be possible to extend Compose to other platforms and they will share documentation about it.
As others pointed out, as soon as you can apply both `plus` and `plusAssign`, Kotlin raises operator ambiguity. Now, to understand why `bucket0 += "string"` is ok but `bucketsById[1] += "string"` isn't, the key observation is that `bucket0` is a `val` and therefore `plus` isn't applicable because assignment isn't applicable to a `val`. You can't write `bucket0 = bucket0 + "string"`. In technical terms, `bucket0` cannot be an `lvalue` but `bucketsById[1]` can. If you change `bucket0` to `var`, you'll get a symmetrical situation and the same compiler error. Note that none of the above has anything to do with operator precedence, contrary to some other comments made here.
Extension functions and null-safe types are currently being implemented
Ebean ORM ( https://ebean.io ) might be something you want to try at some point. It is aware of Kotlin non-nullable types on entity beans, doesn't require default constructors and has support for Kotlin "query beans".
Please show a code example somewhere.
There is a [sample application](https://github.com/felipecsl/kales/tree/master/sampleapp/src/main/kotlin/kales/sample) in the Github repo
thanks
How does it compare to [Kweb](https://kweb.io/)?
Oh I didn't know kweb, will take a look, thanks!
Because you can’t assign anything back to the left hand of that statement. In the case of `mutableList[1] += “xx”`, you could also assign back to the left hand side, causing be ambiguity.
Using Graal native-image is an approach but it also means we no longer run on the JVM (and are using Substrate instead). So we lose things like: - The profiling aspect of the second JIT compiler (less top end performance?) - The more mature GC options of the JVM - The JVM is now cgroup aware (So arguably easier wrt docker container cpu and memory allocation? The JVM automatically adjusts based on the docker resource limits) - Unsure wrt future project Loom (where all Java IO becomes non-blocking) - Unsure wrt future project Valhalla (Value types) What micronaut, quarkus, dinject ( https://dinject.io ) additionally do is "Ahead of time dependency injection" (much like Dagger2 use for Andriod development). They use Java annotation processing to generate source code or bytecode for dependency injection at build time. This means at runtime there is no reflection, scan for annotations, creation of dynamic proxies etc. So with this we get much faster startup and lower memory consumption for DI even without native-image. We get a fast startup and can chose to stay on the JVM runtime. Starting a JVM service with 0.5 cpu and 100m can be sub-second - the implication is that the "sweet spot" for using the JVM runtime goes a lot lower than many people currently think. A lot of people think we HAVE to go native but maybe that isn't really the case.
Enterprise app with Spring + JAX-RS + Kotlin + Ebean ORM. My preference today would be Javalin + DInject Controllers + Ebean. The Javalin + Dinject option would be simpler / lighter option. It still has Dependency injection and "controllers" so similar to Spring + JAX-RS.
This is pretty much an English sub, so since this article was so short I went ahead and did a low-effort (read: very literal) translation. It keeps the writing quality of the original article fairly well intact, though 😅 --- The exception that you find most in logs of Java applications is NullPointerException, and this is expectable as Java doesn't provide mechanisms for checking nulls. Only the if, but this is very manual and when an object isn't null, it's very cumbersome to have to check for nulls with an if all the time. However, kotlin has learned from this and has implemented various mechanisms to prevent NullPointerExceptions. Firstly, we cannot assign null to a normal type, it won't compile: var a: String = "abc" a = null // error de compilación We have to expressly indicate that the type allows nulls: var b: String? = "abc" b = null // ok print(b) Now if we call a method of b and we don't check that it's not null, it won't work: val l = b.length // error: variable 'b' can be null It throws a compilation error. We must check that it isn't null: val l = if (b != null) b.length else -1 Now, this is just the first look. In later posts, we'll look at the antinull operators.
Looks like kweb rolls its own HTTP server and DOM manipulation library, while Kales uses ktor and its built in HTML builder, which is a well maintained and very popular kotlin web library. Sounds like a more solid foundation, however kweb has been around for longer, so it might be more mature in terms of stability. Also it doesn't seem to mirror the same APIs as Rails, unlike Kales does. So, overall, both seem pretty different :)
I had tried that also, I don't believe parenthesis will do anything to disambiguate get vs set in the end. It doesn't 'force' the scope to get or anything. Really the proper method with what you were trying to do above is use add instead of +=, but it was an interesting scenario.
[Kweb also uses ktor](https://github.com/kwebio/kweb-core/blob/master/build.gradle), but the similarities end there. /u/sanity is the creator of Kweb, so it's a bit weird of them to ask you this question, they should write their own comparison :^)
What extra does this provide over the official documentation?
Why not use spring boot?
We're at the stage where the technology is maturing (slowly) but a lot of common code is missing. You've got here an amazing opportunity to come up with your own framework and share it with the world!
Hi, I love the idea and this project would make my dream true. I know we ( the kotlin community ) have a long way to go before getting most of what rails has out of the box but I believe this project is a step in the right direction &lt;3
Good information! Thank you.
Sounds awesome to me
Yeah, seems like a post written by someone who finished reading the official Getting Started guide himself...
Because spring boot is not automagical enough and you can still know what's going on.. a true framework hides as much as possible from the developer
&gt; /u/sanity is the creator of Kweb, so it's a bit weird of them to ask you this question, they should write their own comparison :) I thought it was fair to ask since Kweb has been around for a while ;)
As /u/tipsypants said, Kweb is also built on Ktor, using it for a HTTP and WebSocket transport. You are correct that Kweb doesn't follow the Rails approach, rather it leaves the architecture mostly up to the programmer (since it's vanilla Kotlin). Thank you for checking it out.
Finally, I have Ant Design for React enterely wrapped to be used with Kotlin. There are features of some components that are not available since depends of external React libraries that also have to be wrapped, I will do so, but for the moment I think it's okey. I would appreciate some feedback.
Thank you for your kind words :)
To @Zatara7's point, Spring Boot still requires a lot of up front set up and configuration. I'm not aiming for "automagic" also because that's what makes Rails confusing and hard to maintain. Nothing should be "magic", no monkey patching and you should always know where that method you're calling is coming from :)
Fair enough! :)
Given that it's a compiler error, I don't think the debugger would help.
Isn’t the real question here, why don’t we make spring boot easily available in Kotlin.
oh yeah huh
Well, I *did* say my translation preserves the writing quality... I guess I should also have noted that it also preserves the insightfulness of the content... (I need to take spanish again next semester after a three year break, okay? I wanted some 'real world' practice... this is just what came up)
return@fizzbuzz
Thank you very much. I'm having hard time understanding this lambda expression topic :(
A prompt to download? Nty
Shitty site, bunch of popups, even had a Nsfw picture pop up. Don't post this again.
Lambdas are pretty much just functions without a name. Where you could use a function, you can just type `{inputs -&gt; &lt;code-which-manipulates-the-inputs&gt;}` instead, constructing a lambda expression without having to define a specific function with all the usual bells and whistles. https://kotlinlang.org/docs/reference/lambdas.html
Wow, I've been writing Kotlin for awhile and never realized you could do this. There's even something similar in Java, which I've also never seen or used before looking it up just now.
This is a function `fun doubler(value: Int): Int{` `return value*2` `}` &amp;#x200B; This is an anonymous function, which can be passed as though it were a string or int or object `val doubler = fun(value: Int): Int{` `return value*2` `}` &amp;#x200B; This is the lambda form of that function `{ value : Int -&gt; value * 2 }` &amp;#x200B; Normally you pass values to a function and it performs some action on it. Lambdas and anonymous functions enable a sort of reverse behaviuor. The function you are passing to will generate some value internally, and you provide it a lambda that describes what to do with that value. &amp;#x200B; For example a calculator may have one function each for adding, subtracting, dividing and multiplying 2 numbers and then displaying it on screen. An alternative approach is to have a single function which takes 2 numbers, and a lambda explaining what to do with them e.g. multiply so the main function only has to handle printing.
Oh, I'm sorry! My comment wasn't about your translation at all, but about the pointlessness of the actual blog post...
Thank you very much u/CabbageCZ I forgot to check their official documentation.
Thank you very much u/Global_Information it was a great explanation of lambda expressions :D
I was curious about *Kotlin*, mainly because it is also a programming language. I saw a Codeforces coding contest naming Kotlin Challenge I think. So I started learning it for like 10 days now. *Lambda expressions* are quite fun. But I just need to understand it first to implement in the future.
The presenter doesn't seem to know idiomatic Kotlin. The entire page of text at 8:33 into the presentation can be replaced with these 3 lines: class Dog(var name: String?, var age: Int?, var breed: String?) { constructor() : this(null, null, null) } Now mind you that I wouldn't have made those properties nullable or used `var` for the breed and would have used an enum for the breed but I wanted to post identical code.
The last thing I remember about Cordova was a company politely begging me to rewrite their Cordova app in "native" Android because they had a few small layouts that ended up making the app upwards of 30Mi (native rewrite was about 3Mi without proguard). I'm all for Kotlin everywhere, but has Cordova gotten any better since I last checked? (2ish years ago).
I use ktor + koin + exposed for rest APIs and it's a great solution
Maybe do that first next time?
Hey great! I just got the brilliant idea to make a rougelike in kotlin yesterday!
Not just brilliant but very timely I should say!
Do you guys have Twitter handles? I'd really like to give a shout-out when I mention this tutorial!
Very cool
Very neat, I'll check this out!
 It seems interesting
OP is @addamsson, and they're collectively @_hexworks: https://twitter.com/addamsson/status/1147627624707084288
Or even more "idiomatic" ``` class Dog(var name: String? = null, var age: Int? = null, var breed: String? = null) ```
Have you tried reading the docs? [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/RegExp/test#Using\_test()\_on\_a\_regex\_with\_the\_global\_flag](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test#Using_test()_on_a_regex_with_the_global_flag)
Hey, thanks /u/zsmb!
Just go with logic if (x &gt; 100) sum = 100×5 + (x-100)×8 else sum = x×5
Thank you
Of course not. There are more interesting things to do than reading about the strange and unnatural way how global modifier works in some programming language. That's actually the part of the reason I'm looking for the change. It's ok to make mistakes. The problem is when you stop seeing mistakes as mistakes or even worse advertise it as the right way.
One other way to look at it is that you need to compare pairs. So, given a list of numbers, can you turn it into a list of all possible pairings of those numbers? And then you'd be able to compare each of those.
Got to part 3. My only complaint so far is that I think Kotlin often allows nicer DSLs than what you can get with just fluent interface. Like [here](https://kotlinlang.org/docs/reference/type-safe-builders.html) and [here](https://github.com/Kotlin/anko). But I haven't read the whole thing yet.
My man ! Holy shit... That's exactly it ... Thanks
I've got the final step down a beautiful one line map operation, which is amazing, but the only way I know to convert a list of int to a list of pairs is with a nested for loop , which doesn't scale very well (if I've understood Big O notation) am I overlooking a built in? Or should it be some sort of recursive function?
You're right, brute forcing it won't scale well. You don't have to test all pairs though. You can simply iterate through all numbers, and for every number check whether the corresponding number that would add up to k exists, using a set.
Yeah, that's cleaner. I added the no-argument constructor in case it needed to be created by a framework that needs that in order to preserve the same behavior as the original code.
Ahhhhhh , amazing ... Maths is so cool xD
Convert the list to a set and see if any of the elements has a corresponding pairing element in the set (`k - element`)
That's what I ended up doing , much cleaner and 1/3 of the lines of code xD I love kotlin !
You can do this with a combination of `flatMap` and `map`. This'll result in a Cartesian product of both lists. ``` listA.flatMap { a -&gt; // every element of listA listB.map { b -&gt; //every element of listB Pair(a, b) } } ```
I want to thank you for completing a tutorial series. There's so many unfinished ones and it's great to see that you took it to conclusion. Will definitely check this out, probably later today. Do you know if the used libraries will work with KotlinJS / Kotlin native?
let's start with something that works: basically, you `flatMap` your list to `Pair`s of an element with each of the ones after it in the list (to avoid going through a pair twice), then `find` by the predicate val list = listOf(1, 2, 3, 5) val k = 4 val lastIndex = list.size - 1 println( list .withIndex() .flatMap { (index, value) -&gt; ((index + 1) .. lastIndex) .map { Pair(value, list[it]) } } // .onEach { println("debug" + it) } .find { (a, b) -&gt; a + b == k } ) Now if you uncomment the debug line, you'll see a problem with this, which is that even the result is the second pair we try, we still wastefully generate all possible pairs. If we implemented this using nested `for`, this would not be a problem since we would be able to `break` the loop. The solution is actually pretty simple, convert your data structure (`List`) to a lazy one such as `Sequence` list .asSequence() // &lt;- here .withIndex() .flatMap { (index, value) -&gt; generateSequence(index + 1) // &lt;- here { (it + 1).takeIf { it &lt; list.size } } .map { Pair(value, list[it]) } } .onEach { println("debug" + it) } .find { (a, b) -&gt; a + b == k }
Oh my god, amazing , withIndex() is exactly what I was looking for, but thanks for the deep explanation, that's arguably more overall useful as it's clear how that will apply to more situations. Thanks again :)
As I recall, the fastest solution to this is to sort the list. Then, beginning with the first and last indexes, compare the sum of the numbers at those indexes. If it's equal to k, you're done. If it's greater than k, decrement the larger index If it's less than k, increment the lower index. Additionally, you terminate if the upper index ever becomes lower than the lower index. Unfortunately, this faster structure avoids most simple operations on the list. To keep something like this functional, I tend to do a generateSequence with each member of that sequence being that 'state' at that point in the loop. Namely a data class or pair with the current upperIndex and lowerIndex to check.
Thanks for the kind words! The libraries used for this tutorial ([Zircon](https://github.com/Hexworks/zircon), [Amethyst](https://github.com/Hexworks/amethyst), [Cobalt](https://github.com/Hexworks/cobalt)) are all *multiplatform projects* so they can support KotlinJS / Kotlin Native as well. For Zircon there is only a JVM target right now, but 95% of the codebase is `common` code and it is relatively easy to add support for other targets! Amethyst and Cobalt is 100% `common` code I just didn't add the targets yet. I'm tasked to capacity right now so I can't tell when will I have time to implement them though.
Your solution has time complexity `O(n * log(n))` due to sorting the list of `n` elements. There is a better solution that runs in linear time.
Javascript sucks so bad. I can't understand how a terrible language like this gained so much popularity.
JS has beautiful core and powerful semantic but sadly it's a raw prototype. Its main problem is that it never got a chance to have a proper testing and polishing before going into production. In terms of flexibility and power JS (TS) kills Java on the spot. I would never traded JS (TS) for Java. Kotlin is another story and is a reasonable choice for the switch.
Let's see, that'd require a set number of passes over the list. With the last pass being capable of answering, 'for x in the list, have I see y such that k - x = y' So it'd require a data structure with constant placement and lookup time, which a hash set will have if there's enough initial space allocation. In fact, it could be done with a single loop of the list. Doing it functionally then just becomes where in the debate of 'what is functional' you are. Thank you for making me think and striving for better performance.
Cordova is all about being cross-platform. There is no real advantages if you just want an Android app. But if you want **one** application code for both Android and Apple - there are no real alternatives and any inconvenience simply needs to be accepted.
Cordova is all about being cross-platform. There is no real advantages if you just want an Android app. But if you want **one** application code for both Android and Apple - there are no real alternatives and any inconvenience simply needs to be accepted.
Shazaam: var cost = usage * 5 if (usage &gt; 100) { cost += (usage - 100)* 3 }
Why are you trying to upload raw bytes as UTF8?
Interesting. I love roguelikes. &amp;#x200B; Unfortunately, I get a blank screen when running a simple project (like the PROJECT\_SETUP git tag) on my Mac. Same thing happens when I try to run the latest release (2019.2.0) from [https://github.com/Hexworks/caves-of-zircon/releases](https://github.com/Hexworks/caves-of-zircon/releases) . &amp;#x200B; I'll have to get some more free time to dig into that.
I will check all of each article. The series are pretty damn good to try
The above solution is not going to work. Corrected: val cost = if (usage &gt; 100) {100*5 + (cost - 100)*8} else usage*5
I don't know about anyone else but code like this just proves to me how much more complex than Java Kotlin can be. Multiple modifiers for parameters is just one example of how Kotlin can end-up more verbose than Java. The multiple constructor madness also adds to the clutter.
Don't be too quick to judge. Please provide an example input where my solution won't work.
Kind of brute force ```kotlin list.map { k - it }.filter { list.contains(it) }.isNotEmpty() ```
Thanks. I suggest you get the book too
While that is written in a more functional style, it doesn't avoid the O(n^(2)) time complexity that OP asked about.
a "functional" attempt to @Determinant 's solution [https://pl.kotl.in/J7zxOmzsi](https://pl.kotl.in/J7zxOmzsi) I got bored at lunch :)
Ha, that's dense... from reading it , seems to all work correctly. Well played
Thank you! I was looking for some tutorials on this!
Oh, I missed that there was a book. Here it is for my fellow sleepy heads: [Exercises in Programming Style](https://www.amazon.com/Exercises-Programming-Style-Cristina-Videira/dp/1482227371) by Cristina Videira Lopes
(Perhaps my subtlety was too subtle. I just didn't wanna *explicitly* say anything bad about the post. You're right, of course, that it adds absolutely nothing over the official documentation, and with worse writing quality. I guess there's no official documentation in spanish though, so that's *one* thing)
The way you're doing it right now means that jobNames might not have a value when you need it. You need to wait for the thread to finish then do your processing. That or you can just move all the processing in the thread as well, just note that if you do that you will need to switch to ui thread if your manipulating any user interface items. This is just speculation based on your current code
text.split('/n')[2]
`text.lines()[2]` deals with different line endings better.
Yes, that's way better
Is there a “correct way” to wait for the thread to finish? As I am currently doing it I just have a timer to delay the thread from completion. *i tried co-routines and it didn’t want to connect to the DB. *i also have never done this before
You can call `Thread.join()`, coroutines are the same you call `Job.join()`. When you call the join function it will block the current thread/coroutine at that point and will only resume when the target thread/coroutine is complete or cancelled. Though I'm kind of curious as to why coroutines are not working for you. You can always read about those functions in the javadocs:[https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html](https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html) [https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/)
Honestly I am somewhat perplexed why they are not working either... I try implementing a coroutine and it simply says “cannot connect to DB”. I use a thread instead and it works. Thank you much for your explanation. I am a CS student and, for lack of a better word, am trying to brute force my way through this. I will give that a shot... thank you :)
The JVM is a massive memory hungry beast. This is the one issue I have with their IDEs. All JVM languages just get turned to bytecode anyway that is ran on a JVM. You're saying this is not the case with Kotlin? That it can be slimmer?
Wrong sub? try /r/androiddev
don't know of any resources but for constructors you can use the `constructor` keyword in the body of the class or give your main constructor default values for its arguments
Udacity
I went through the Lynda course (my library gets me a subscription)
[Kotlin Koans](https://play.kotlinlang.org/koans/overview) is what you're looking for.
Wow this looks great! What are koans?
The answer by u/waicool20 is correct. I just want to give a little bit more of clarification: You have two parallel threads writing to the `jobNames`, the main thread and the other thread that you created. When you start it, the main thread will not wait for the database result, so `jobNames` will be empty. You can see an example using threads [here](https://gist.github.com/edujtm/486f4db07ac5c8662ecd84da8e739f96#file-thread-kt). I implemented it using only a main function so you can reproduce it. If you use `Thread.join()`, the thread in which you called the function will block (meaning it wont do nothing else) until the other thread complete, then you will have. You can see an example using `join()` [here](https://gist.github.com/edujtm/486f4db07ac5c8662ecd84da8e739f96#file-threadwait-kt). I also did an [example using coroutines](https://gist.github.com/edujtm/486f4db07ac5c8662ecd84da8e739f96#file-coroutines-kt), but they are harder to understand for a novice. I'm not the most experienced on Android, but from what I know, you should just launch the coroutine and schedule the part of the execution that returns the database data to execute on the main thread and change your RecyclerView data from there (only if you are not using recommended patterns: MVVM or MVP) Other recommended way to do asynchronous work on Android is by using RxJava, but it's also not easy to understand. You could use AsyncTask to read the data, but they are a bit outdated and are [known for having a lot of pitfalls](https://blog.danlew.net/2014/06/21/the-hidden-pitfalls-of-asynctask/). Still, it doesn't hurt to know.
That looks perfect, thank you!
All of the info helps. Can’t thank you enough!!
Vouch for this
What are the advantages vs the regular approach?
The advantagevis that you can now use all the features of the KotlinTest framework. The idea to write this article was that I observed people writing KT tests for unit tests and JUnit for integrated. This enabled a full KotlinTest suite
I've been waiting for this
Wow, a picture. So impressed.
I actually thought i deleted this one. My bad Its here [https://www.reddit.com/r/Kotlin/comments/cbtftu/basic\_recyclerview\_using\_component\_architecture/](https://www.reddit.com/r/Kotlin/comments/cbtftu/basic_recyclerview_using_component_architecture/)
[Kotlin in Action](https://www.manning.com/books/kotlin-in-action) is the best Kotlin book I've found, since it was written by some of the people who worked on the language itself.
This is the one to get.
Kotlin Programming: The Big Nerd Ranch Guide
In my opinion I love this book for every programming language, its fonts and style looks pretty elegant and doesn't hurt eyes when reading for long run. And a plus point is that this is free book. Book: [https://goalkicker.com/KotlinBook/](https://goalkicker.com/KotlinBook/)
Missed a trick not calling it Bouncy Kastle 😁
Staying on both grounds: TypeScript / Kotlin. I'm not so experienced in Kotlin but I can already say that for front-end TypeScript is more flexible and better conforms dynamic nature of JavaScript. Also it's much easier to consume/interop with front-end ecosystem (with Kotlin it may be really painful). Where Kotlin may be a real thing - multiplatform/isomorphic projects where you can share code between clients/backend and potentially provide seamless (client-server) data flow.
You're not closing any if the streams in Kotlin. Try calling .use {} on the streams instead of assigning them to vals.
Thank you for sharing
Sweet
If I clone your project and import it into IntelliJ I get "Could not determine java version from '11.0.3'.".
You need to use the gradle wrapper by running `./gradlew` instead of running the local Gradle on your computer (with `gradle`). With this way we can control the Gradle version we use. Did you bump into some other problems?
Xamarin apps look and feel pretty good, and are even more cross-platform than Cordova, no? If you really needed to program in Kotlin, there is a JVM implementation on .NET that would let you use Kotlin too and the binary would still probably be smaller.
I used the gradlew included in IntelliJ. If I run ./gradlew it gives me the same error. &amp;#x200B; I can't run the code that I check out via the tag "2\_VIEWS\_SCREENS\_INPUTS" - a parameter 'game' is missing in WinView, StartView and LoseView.
Has anyone tried this plugin with Kotlin? I'm curious about your thoughts on it
You are right, Xamarin is an option for cross-platform apps. But I don't think it's an option for Kotlin. At least I haven't found anything but some simple experiments with ikvm.net, which is a dead project now. On the other hand, KVision with Cordova module let's you build cross-platform apps with full power of Kotlin language (including coroutines), as Kotlin/JS is fully supported by JetBrains.
You are right, Xamarin is an option for cross-platform apps. But I don't think it's an option for Kotlin. At least I haven't found anything but some simple experiments with ikvm.net, which is a dead project now. On the other hand, KVision with Cordova module let's you build cross-platform apps with full power of Kotlin language (including coroutines), as Kotlin/JS is fully supported by JetBrains.
ikvm certainly isn't dead. The last stable release was in April. The last company I worked at used ikvm in an "enterprise grade" application too. It was good enough for them to integrate Jython with too. All Kotlin needs is a compliant JVM. Jetbrains doesn't need support from Jetbrains so long as the JVM works to spec.
Most people on Reddit understand English so I recommend English articles for best exposure.
These companies mentioned they've adopted some Kotlin on the backend * Bird Scooters * Khan Academy * American Express
[Corda](https://github.com/corda/corda) is a large open source blockchain project written in Kotlin. Personally I've used Kotlin + Spring Boot in production for a year now with a small team, it's been great. And its really easy to use both Kotlin and Java together, so the risk of picking the wrong language is low.
&gt; Kotlin or Java for our backend servers. Both in the same project is super easy. It all gets compiled down to JVM bytecode anyways, the interop story is great
I introduced Kotlin into an 11 million line Java monstrosity at my previous company (we had over 100 teams working on different parts of the project). The only issues were some static analysis tools that expected to analyze Java code. So it was quite successful. I'm currently working on a project that's a quarter million lines of code with a 60 / 40 split between Java and Kotlin. We're also actively converting Java files to Kotlin as that makes us more productive and reduces defect rates. Kotlin feels pretty amazing to work with. New developers ramp up quickly (code reviews really help) and we feel more productive in Kotlin.
We are small startup and I started the new project in Kotlin (backend only) about a half year ago. So far - no any problem. I really don't see any reason to start a new project in Java in 2019
Which framework are you using?
My guess would be Spring.
We use Jersey. Also, we use Guice for dependency injection.
Wow this sounds impressive. Would you choose to go back to Java after using Kotlin?
If anyone says yes to this question they haven’t used Kotlin enough, or java enough. If you have the choice, go Kotlin. Most people don’t get the choice, or otherwise have to prove it out and build existing infrastructure just to support Kotlin
We, [Niphtio](https://nipht.io), are a small startup, and we're using Kotlin. The main issue with using Kotlin for backend (or really most non-Android stuff) is that most of the documentation for JVM libraries/frameworks will use Java. In practice it doesn't seem to be a big deal, as it's pretty easy to mentally translate from Java to Kotlin. I also have mixed feelings about the way exceptions work in Kotlin. Overall, I think Kotlin is a big win: code is easier to both read and write. The null safety is also great, though sadly many Java libraries don't use nullability annotations, and so you don't get any compile time null safety where you interact with them. (The AWS SDK is a major examples of this for us).
100%. After using Kotlin and using it heavily, I can never go back. I love me some Kotlin.
At my previous company we used Kotlin for a various range of components. Ranging from our entire nlp/ML modules, to misc services, to map/reduce processors, to Elasticsearch plugins. Zero problem. I loved Kotlin so much that I rewrote my libGDX game, which was in early stages, in Kotlin (from Java). It’s been years and have had zero regrets. I also use Kotlin for all side projects. My new startup I also decided to use Kotlin exclusively for our platform’s backend. Currently it’s being used for all our data science code as well as our spring web service/api. I hope to see Kotlin gain even more popularity.
Use different name for outer loop or use labels.
This would be more clear to me if it was written like: string1.toCharArray().zip(string2.toCharArray()).count { (a, b) -&gt; a == b }
Could you explain more how could I do that?
Using it is actually shorthand for: .forEach { it -&gt; someFunction(it) }
After the curly brackets you can write the lambda parameter name followed by an arrow -&gt; For example: list.foreach { element -&gt; println(element) } This way you can use different parameter name in each nested lambda
I introduced Kotlin to our company roughly a year ago and we have now approximately 15 teams out of 20 using it for their backend Microservices. Not a single team wants to go back to Java.
I'm still struggling with the concurrency != parallelism stuff. Why would you do concurrency if not for parallelism?
Same. It’s been amazing.
Tenable (owners of Nessus scanning software) has started to embrace Kotlin for their backend, which was predominantly Java and Groovy before. We had some issues with interoperability with Groovy, but other than that everyone has loved using Kotlin. Kotlin is the new standard for microservices at Tenable.
Because you are waiting for something e.g. a server response. If you are limited by computing power your answer is parallelism. If you are limited by IO your answer is asynchronicity.
We are using Kotlin at Erste Bank for our online banking solution. It started with one backend, but has now become the preferred language for new services. I think migration to Kotlin is pretty risk free: As a Java developer it is easy to pick up, and new hires often mention Kotlin as a reason they applied to our job offer.
Firstly i want to thank you very much for this repo its very useful. I have two questions , Old places API from google is going to be shut by end of July, will this repo keep working ? &amp;#x200B; and how is the cost ? you know that using maps makes google charge us for money if some options are used
I work in finance and my team builds every new micro-service in Kotlin + Spring Boot. It's frankly a joy to work with and we have had no issues, only benefits.
Kotlin for the backend is a total no-brainer. We are seeing major pickup for London-based projects in a lot of areas (Banking/retail/publishing). Projects that might have been in Scala (because it was a "better" java) are now being started in Kotlin. Personally, I've worked on a major (top 1000 by traffic globally) website which is now almost exclusively Kotlin in the backend - with zero Spring to boot 😉. Now working on building a neobank for which the chief tech is Kotlin. I'd also echo other comments regarding Devs absolutely NOT wanting to go back to java/Scala after a stint in kotlin.
What are you using instead of Spring?
Startup, we've built REST API and batch in a mix of Kotlin and Java using Spring Boot/Spring Batch. The mix is fine, if someone prefers or there is a reason to write in Java they go ahead, no reason not to. There's the odd time when Java is needed such as annotations on interfaces (can't remember the details for it, it's an accepted bug) and when we need to extend autogenerated JPA entities. I'd consider not using Spring now because I'd like to experiment with native binaries for small, fast startup and consider deploying to lambda. For smaller projects ktor works with Kotlin/Native and larger projects Micronaut works with graalvm's native-image. Spring support is in the works but not ready yet.
Also you can paste working Java code samples into a Kotlin file (in IntelliJ), and it'll auto-convert whatever you paste to Kotlin
Constructors.
Corda is using kotlin in backend.
&gt; and reduces defect rates. In what kind of defects do you see rates go down, other than perhaps NPEs?
Any DI libraries? And what server are you running?
Kotlin prevents many categories of defects that are possible in Java in addition to NPEs. Here is an article that shows about 25 categories of Java defects that are prevented: https://proandroiddev.com/kotlin-avoids-entire-categories-of-java-defects-89f160ba4671 So switching to Kotlin has had a significant impact on defect rates in general. Another huge win is that the code is so much simpler and easier to understand and this allows us to move much faster than in Java.
Makes sense. Though Java already has `switch` expressions now, and is getting `records` (i.e. `data class`es in Kotlin), as well as pattern-matching :) The other still hold I suppose.
No, definitely not. To be honest, I would be depressed and look for a new job if I was forced to go back to Java. For context, I used Java for about a decade and co-workers would often come to me when dealing with advanced portions of the language. So I felt very comfortable with Java but I would never go back since Kotlin is such a huge improvement. The more advanced you become in both languages, the larger the gap between them becomes as you start to see very many flaws with Java. Whenever I see someone refer to Kotlin as just Java with prettier syntax &amp; null safety then this is a giveaway that they are a beginner with Kotlin since it's so much more than that.
We find that constuctor injection works absolutely fine so have no need for DI. But that's another rant 🙃 For backend, we use http4k (with the Undertow backend by default, although occasionally Jetty if we need websockets).
I'm working in a company hiring over 700 devs, at least half of them use Kotlin on backend with Spring Boot.
You are my man. I've been working to convince people you don't need spring for a couple of months since I joined this company. I'm slowing starting to win. I even call it compile time dependency injection. A playful joke as it's just constructors.
ShopRunner.com uses Kotlin for all it's JVM services. Based in Chicago mostly.
What's doing the injection?
What framework do you suggest for someone with no experience with server development trying to get familiar with backend?
Totally. I even believe that DI might have been a concept that existed before spring... In secure environments, the prospect of spring boot just scanning the classpath and starting up any old code that it finds is just terrifying. And that's before we talk about startup times etc.
The code. You don't need a container to do Dependency Injection. Use the code Luke! 😉
The code. You don't need a container to do Dependency Injection. Use the code Luke! 😉
My Google-fu is failing me, everything about Injection is pointing to some library... Can you give me a pointer please?
There are more as well. I started enumerating them and so far I found 50 categories of Java defects that Kotlin prevents. Java has maintained backwards compatibility for 25 years now so they will continue to allow defective code. The Java language is fundamentally broken unless they break backwards compatibility and fix the many design flaws.
Are you able to share the list? I'd be interested to see it :)