If you're remotely familiar with Java or almost any other language, the Kotlin docs should be more than enough to get you started. Part of the appeal of Kotlin is its flexibility and the ease of learning it!
Spoiler: it's longer than 10 minutes. Videos should be up early next week from this event.
For those unaware, [Kotlin](https://kotlinlang.org/) is a language developed, released, and maintained by Jetbrains. It compiles to Java bytecode and Javascript, and can be used to replace or add on to existing Java files in an Android project. It has been in development for years and I have been using it for the last year; the end result for me is that Java is downright painful to use. Kotlin makes me feel like a ninja and enables code that would be unfeasible or impossible to write in Java (at least Java 7). So, some examples? Let's take a look. ##### Filtering a list /** Returns a subset of {@code list} containing only the items where {@code someBool == true} */ public final List&lt;MyClass&gt; filterList(List&lt;MyClass&gt; list) { List&lt;MyClass&gt; ret = new List&lt;&gt;(list.size()); for(MyClass item : list) { if(item.someBool) { ret.add(item); } } return ret; } This straightforward method should look familiar, because you've probably written some variation of it many, many times before. Nine lines, excluding whitespace and comments. And the same code in Kotlin? /** Returns a subset of `list` containing only the items where `someBool == true` */ fun filterList(items:List) = items.filter { item -&gt; item.someBool } // or { it.someBool } One line. Also note the difference in comments; you can use ticks to designate code, as in markdown. Let's break it down quickly. `fun` defines a `function`. You'll notice that a variable's type is declared after the name, instead of before. And what's up with the `=`? This is shorthand for `{ return }`. It looks like a variable declaration, but it uses a parameter like a method. Also notice that the compiler automagically figures out the function return type and it isn't declared. Lastly, the beautiful `.filter` method and lambda. If you have used C#, Java 8, or another modern language, this will be familiar. Rather than give [a full explanation here](http://winterbe.com/posts/2014/03/16/java-8-tutorial/), let's just admire its conciseness and move on. ##### Getting a value (or null if missing) /** Gets the second character in a string or, if not possible, returns some default value (which may be {@code null}) */ @Nullable public final String getSecondCharOrDefault(@NonNull String str, @Nullable String defaultVal) { return str.length() &gt; 2 ? str.get(1) : defaultVal; } `@Nullable` and `@NonNull` are awesome annotations for Java that *will* save you from `NullPointException`s if used properly. They work by giving your IDE the information it needs to warn you when something could be null - but they aren't actually supported directly by Java and are instead something that works on top. /** Gets the second character in a string or, if not possible, returns some default value (which may be `null`) */ fun getSecondCharOrDefault(str: String, defaultVal: String?) = if(str.length &gt; 2) str[1] else defaultVal Kotlin, by comparison, has these built directly into the language. All variables are, by default, not allowed to be `null`. Appending a `?` indicates that `null` is an acceptable value. Kotlin will, in fact, fail to compile if you violate these rules. We again use the shorthand function declaration, which is allowed because `if` statements can return values (in lieu of the standard ternary (`? :`) operator). ##### RxJava Two more examples. First, some [RxJava](http://www.thedroidsonroids.com/blog/android/rxjava-production-line/) code. Naturally ugly in Java 7, better in Java 8, and glorious in Kotlin. /** First prints "one dish", then "two dish" */ public final void printRxJavaStuff() { Observable.from(Arrays.asList("one fish", "two fish", "red fish", "blue fish")) .filter(new Func1&lt;String, Boolean&gt;() { @Override public Boolean call(String s) { return s.contains("one") || s.contains("two"); } }) .map(new Func1&lt;String, String&gt;() { @Override public String call(String s) { return s.replace("fish", "dish"); } }) .subscribe(new Action1&lt;String&gt;() { @Override public void call(String s) { Timber.v(s); } }); } 21 lines. /** First prints "one dish", then "two dish" */ fun printRxJavaStuff() { Observable.from(asList("one fish", "two fish", "red fish", "blue fish")) .filter { it.contains("one") || it.contains("two") } .map { it.replace("fish", "dish") } .subscribe( { Timber.v(s) } ) } Six lines. And far more readable. The `it` keyword stands for "the temporary variable in scope for this expression". For example, in a standard `foreach` loop `for(String str : strings)`, `it` would be the same as `str`. ##### Declaring a data class Let's wrap this up with a `class` declaration. Java: /** Example of a {@link Class} declaration */ class MyClass { private boolean someBool; public MyClass() { } public MyClass(boolean someBool) { this.someBool = someBool; } public boolean getSomeBool() { return someBool; } protected void setSomeBool(@NonNull boolean value) { someBool = value; } @Override public String toString() { return "someBool:" + someBool; } // not shown: .copy override // not shown: .hashcode override // not shown: .equals override } Kotlin: /** Example of a [Class] declaration. */ data class MyClass(var someBool: Boolean = false) Yep. Those are the same thing. You can declare a constructor with the `class` declaration and if you use `var` or `val` (`val` = `final`), then it will keep it as a field. The getter and setter is auto-generated, as with C#. It handles `toString`, too, if you mark it as a `data class`. Finally, note the `[Class]` syntax, compared to Java's `{@link Class}` syntax. And that's it. You can try Kotlin for yourself here: http://try.kotlinlang.org/ You can drop it into an existing Android project and it has full interopt with Java; that is, you can write one class in Kotlin, another in Java, and they can both use each other without issues. Happy coding! Last note: Java 8 has, to an extent, hugely improved on Java 7 and Kotlin doesn't have as many advantages over Java 8. However, using Java 8 on Android remains problematic because of performance issues with Jack and it being only natively supported on Nougat and up. Kotlin is just as fast as Java 7 (compiled and compiling) and works on any version of Android you'd want to support. All code samples can be found here: https://gist.github.com/davidwhitman/5d7bde79a3967b27d9e25a74bccfdad7
Kotlin appears to be totally awesome, just like Scala, but you don't need the main method to be enclosed in stupid singletons. 
Yeah, I wouldn't consider that a useful comparison. I think Scala being overly complex and suffering from severe feature bloat in the name of expressiveness (which increases code review / ramp up friction) are the biggest downfalls compared to Kotlin, at a high level. Here's to hoping Kotlin stays as simple as possible and Jetbrains are able to continue avoiding feature/complexity bloat pitfalls in the future.
Oh, that is awesome to hear. I haven't gotten around to hanging out in the slack but I'm very happy to hear they have that philosophy in mind! Sounds like a best-case scenario to me. :)
Preface: This is all my opinion and some will disagree. Scala has a lot of *expressiveness*, but the sacrifice to get there was taking on a huge amount of complexity and feature bloat ([example](http://stackoverflow.com/questions/8000903/what-are-all-the-uses-of-an-underscore-in-scala)). For projects with a small number of people that have already undergone the ramp up and are fully familiar with all the features, it's just fine. For others, namely where onboarding and code reviewing are in constant cycles, it's common to see Scala introduce a lot of friction to this process because of the feature bloat and language complexity. Kotlin achieves *close* to the expressiveness of Scala, but with significantly less complexity. There's less "magic" and the ramp up and readability for other Java developers is comparatively lightweight. This alone makes it more valuable in a professional setting, in my opinion. And note, that's not even taking into consideration the null-aware type system of Kotlin, which is the strongest feature of the language. EDIT: Further reading: [Yammer's explanation about why they decided to move their codebase away from Scala.](https://gist.github.com/anonymous/1406238)
Thanks for asking this, would also like to know the same.
I've never actually used Scala, so I can't give any good feedback. For Android, Kotlin was more or less built and has great Android Studio integration, so I'd definitely choose it over Scala. For normal Java dev, your call is as good as mine. Scala is more mature, but Kotlin is very stable. Probably either are good.
I'm an Android dev (I think I put that in the post, might not've), and we don't have access to Java 8 yet, unless you're only supporting Android Nougat and up, which will get you less than 5% of the market share, so nobody is. The only other way to use even a subset of Java 8 features is to use Google's "Jack" compiler, but it's extremely slow and memory-intensive (even worse than the default, which is impressive). Or Retrolambda, but that's only for lambdas. So, for almost all Android devs, Kotlin is a valid alternative to Java 7, and Java 8 is not. Whether their company will want them to use Kotlin (they won't) is a different question. edit: Also, because I'm an Android dev, I have barely even touched Java 8 in my two-ish years of writing nothing but Java code. I wouldn't be able to write a very good comparison.
I can recommend dropwizard for serving web stuff 
FWIW: I introduced Kotlin to the backend at our company and it's been a mostly pleasant experience. I work with mostly non-JVM engineers (Pythonistas) and while they grump about having to deal with the JVM at all usually they're much happier to use Kotlin over Java. 
&gt;and while they grump about having to deal with the JVM Out of interest: What are their main gripes?
Is it just me, but it seems more like a kotlin idea support release rather than a language one? 
&gt; just released Kotlin 1.0.5, which continues the series of bugfix **and tooling** updates [Language-related fixes](https://github.com/JetBrains/kotlin/blob/1.0.5/ChangeLog.md#compiler)
How does this work with generics? I've tried to implement automatic currying and partial application and I could never get it to work with functions involving generic types.
Yeah, let's not try to be too much like Scala
also when you add scala to your project you have to add MultiDex or setup proguard because scala std is so big.
Yeah we lost mic audio due to a hardware problem. The sound is actually from the laptop! I think it sounds great compared the alternative: silence.
The underwater effect is me adding background noise suppression as best as I could. The raw audio is 3x more hissy :-/
I found that the presenters had a bit of overlap. Which is not necessarily a bad thing, shows that many people are figuring out best practices as they go. Definitely going to push for Kotlin adoption at my company, have a project coming up that is probably going to involve Spark.
Basically it allows you to refer to the T with "this" because your lambda that is passed in becomes an extension to the T. You can even leave the "this" keyword out and just refer to functions and properties of the T as if your function was part of its implementation.
Nope, R and T can be the same type. If you want to return the thing that you're using the function on, you could also use `apply` instead though, which does that automatically for you.
This is awesome. Thanks again. 
Convert Java to Kotlin https://github.com/fvasco/pinpoi/commit/4464952263e8998195242229dacc443972609812
I'm pretty sure that Mockito 2.1 can mock final classes. Also Powermock or other mocking libraries can I believe.
We just define constants initialised to the sensible defaults and use `copy` and other methods to create specialisations for specific scenarios.
Mockito has that concept, it's called a Spy. Kind of the opposite of a Mock in that library: http://www.baeldung.com/mockito-spy
Unless I'm missing something, that still requires you to instantiate the object yourself, and it just lets you see when it's accessed. I was wanting to replace: val user = User( id = "UserId", version = "Version", created = Instant.now(), updated = Instant.now(), username = "sazzer", realName = "sazzer", email = "sazzer@example.com", banned = false, approvalCode = null ) with val user = instantiateTestObject(User::class.java) And have it call the above constructor with suitable values for every field, so that I can then use this ```user``` object as parameters and/or return values from other mocks.
 File("file.txt").readText() So simple, but makes me so happy every time I use it.
I would always write that method for myself in a lot of my java projects. Annoying. I also like scala's Source.fromFile("file.txt").getLines().foreach{ line =&gt;
For me, it would probably be the beautiful builders like: #Android override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) verticalLayout { padding = dip(30) editText { hint = "Name" textSize = 24f } editText { hint = "Password" textSize = 24f } button("Login") { textSize = 26f } } } #HTML fun result(args: Array&lt;String&gt;) = html { head { title {+"XML encoding with Kotlin"} } body { h1 {+"XML encoding with Kotlin"} p {+"this format can be used as an alternative markup to XML"} // an element with attributes and text content a(href = "http://kotlinlang.org") {+"Kotlin"} // mixed content p { +"This is some" b {+"mixed"} +"text. For more see the" a(href = "http://kotlinlang.org") {+"Kotlin"} +"project" } p {+"some text"} // content generated by p { for (arg in args) +arg } } } #JavaFX (with TornadoFX) class MyView : View() { private val persons = FXCollections.observableArrayList&lt;Person&gt;( Person(1, "Samantha Stuart", LocalDate.of(1981,12,4)), Person(2, "Tom Marks", LocalDate.of(2001,1,23)), Person(3, "Stuart Gills", LocalDate.of(1989,5,23)), Person(3, "Nicole Williams", LocalDate.of(1998,8,11)) ) override val root = vbox { tableview(persons) { column("ID", Person::id) column("Name", Person::name) column("Birthday", Person::birthday) column("Age", Person::age) columnResizePolicy = SmartResize.POLICY } } } 
Almost every feature or idiom that's implemented as part of the standard library instead of an actual language feature. Goes to show how flexible it is. :) `use` as try-with-resources: ``` File("foo.txt").use { file -&gt; ... } ``` `synchronized` is just a function: ``` synchronized(this) { ... } ``` `let`, `run`, `apply`, etc.
I would only use it for your own custom types. Don't use it for stdlib or other library types. 
I'll like to use them to alias complex generic types, for example something like Map&lt;Triple&lt;A, B, C&gt;, D&gt;. 
I use typealiases to give a deeper semantic meaning to the the code I'm writing. I really like [this blog post](http://artsy.github.io/blog/2016/06/24/typealias-for-great-good/) because it gives a bunch of good examples as to where typealiases would be useful. Here's a choice quote that encapsulate the writer's thoughts (which I agree with): &gt; I used the new JWT type throughout the code as a hint to other developers about what kind of string it is. This gave it some semantic meaning on top of being a string. Neat. Only later, when we needed to start decoding the JWT itself did this really come in handy. Take a look how other communities are using typealiases. Swift, Rust, and Scala are all good starting places.
This might article have some helpful pointers: https://praveer09.github.io/technology/2015/12/26/writing-test-data-builders-made-easy-with-kotlin/
Oh man anko is a beautiful thing.
I think that it's too early to talk about best practices, given that typealiases haven't appeared in a stable version of Kotlin yet. When we designed typealiases, the primary use cases that we had in mind were abbreviating long generic types and (especially) giving descriptive names to function types. Using typealiases for primitive types is misleading in a way, because typealiases do not create new types: you can still assign any `Double` value to a `Score` type. It's possible that a future version of Kotlin will support value types, which will make it useful to define such wrappers around primitive types too.
I think you're looking for "real" types anyway instead of aliasing a "base" type -- e.g. would it make sense to add a Score and an Average together? You can make that "illegal" if you use types, not if you alias Double. 
Glad I am not the only one who loves builders!
If no one here can answer is bring it up w. The JB guys in the kotlin slack channel
Well, You're using development versions in your project. I'm using the stable version (1.0.5) with no issues. You can change with version to test updates with in the menu Tools -&gt; Kotlin -&gt; Configure Kotlin Plugin Updated
It's the identity function. 
I tried doing that and it says I'm on the latest version (dev) even though I selected stable. I solved the problem by refreshing Gradle, I'm using a dev build of kotlin with that but not the version that the plugin uses, seems to be working fine now. 
Uninstall the Kotlin plugin, it should then update to the latest stable.
Cool! Just as a reference, here's a couple of implementations of Either from FunKTionale. * [Either](https://github.com/MarioAriasC/funKTionale/blob/master/src/main/kotlin/org/funktionale/either/Either.kt) * [Disjunction](https://github.com/MarioAriasC/funKTionale/blob/master/src/main/kotlin/org/funktionale/either/Disjunction.kt) The difference between Either and Disjunction is that Disjunction is right-biased (map/bind affects the value on the right) and Either is unbiased. More information in the [project wiki](https://github.com/MarioAriasC/funKTionale/wiki/Either).
Yes, I've seen this, been meaning to look through it :) thanks
People still program in Java lol? Kotlin is 👌
Non-nullable types are reason enough to switch.
 private static final String s3 = "my string 3"; val s3 = """my string 3""" Does `"""` really translate to `static`?
I don't think so, "static" would have to be on an object/companion object. The real value of the raw string is that it can have any special character in it, including newlines: val sql = """ select firstName, lastName, salary from Employees where ... """
So very edgy.
:P ... I'll agree with the Oracle part. I don't think they're doing much to help Java at all!
You can use Kotlin library from Java code, so even writing library for Java should be possible with Kotlin. Kotlin runtime dependency is not that big, anyway.
Not quite. Without open, they're specified as final. Sealed is a different concept :)
My apologies. I looked up sealed at the kotlin language ref so I now know the difference. Non open class can not be extended while a sealed class is like an enum type.
Semantic highlighting works beautifully for Java projects, but apparently not for Kotlin projects. Am I doing something wrong?
I wonder if IDE supports text shadows (like browser renderer). That way there would be much more color combinations for variables.
Semantic highlighting support for Kotlin is planned for a future version of the plugin. You can vote for https://youtrack.jetbrains.com/issue/KT-12629
Should be visible now.
I fall more in love with Kotlin every time I use it. At my job, I flip back and forth between Java 7 (in a very legacy platform) and Kotlin (in a shiny new microservice), so the benefits are very apparent because of the stark contrast. Extension methods, data classes, null safe types, tuples, and the collections library are probably my favorite language features. That last one especially, which brings me to this: val (staffUserPair, staffContactList) = service.getStaffInfo(code) .blockingFirst() .asSequence() .filterNotNull() .filter { it.isInactive } .map { val user = UserDto( firstName = it.firstName, lastName = it.lastName ) val staff = StaffDto( staffNumber = it.staffNumber, user = user.id ) val contact = ContactDto( label = ContactLabel.STAFF, firstName = it.firstName, lastName = it.lastName, email1 = it.emailAddress, user = user.id ) (user to staff) to contact }.unzip() Stuff like this is really simple and elegant in Kotlin and I'm that much off better because of it. It's not *hard* to do in Java, it's just tedious and looks ugly.
In Kotlin, bitwise operators are implemented as functions. For &amp;=, the function is called and. Go [here](https://kotlinlang.org/docs/reference/basic-types.html) and ctrl-f for "bitwise and", you will see a list of all the bitwise operators in Kotlin. Hope that helps.
We published an update to 1.1-M03 plugins which resolves this issue (Kotlin 1.1-M03-release-&lt;platform&gt;-2). Sorry for the inconvenience.
:( Well, I suppose they could implement that eventually. Now that browsers have it.
I'm not aware of any plans for that. The effort required is significant, and the benefit isn't clear.
Well, in this case benefit is that you have much more color combinations. Say you have 25 distinct colors. Now add to that 24 different shadows (same foreground and background should not be used as will just look smudgy). 25*24=600. Less conflict.
One chat program that I used utilized similar system for usernames. Only it was a rectangular background instead of a shadow, so it was a bit inelegant. And yes, it made usernames very distinctive. http://celestiaradio.wikia.com/wiki/KVIrc
I usually prefer `apply` over `with`: return User("First", "Last").apply { age = 18 } 
But you will have problems using a Kotlin library in Scala. Best bet for interop is still Java.
Why? Kotlin generates standard .class files which are indistinguishable from Java .class files with the same ABI. There will be problems, if you want to combine Kotlin and Scala sources in the same project. But if they are in the different projects, it should work fine. 
Here is one specific issue: https://youtrack.jetbrains.com/issueMobile/KT-14069
Yeah, I'm excited for 1.1 for that and many other reasons.
Oops, meant to remove the [shitpost] tag before submitting. 
Don't forget that all those string methods have an ignoreCase! No more `toLowerCase` crap everywhere :)
Another great one I had over the weekend was accidentally using `to` correctly. `myList.associateBy { it.key to it }` is a super clean and readable way to make a map. I had used `to` before but couldn't remember if it worked like this, so I tried it and, lo and behold, it worked.
One I've discovered recently val nullableList: List&lt;Any&gt;? = null val size = nullableList.orEmpty().size // 0
Wow, didn't know about that one. Nice!
Eh... Oracle has made more improvements in recent years than Sun was making at the end of their reign. I think it took a few years of money wasted on lawsuits to realize they had actually bought a product and needed to keep it up-to-date to make any money from it. But there's basically no way I can see Java catching up to Kotlin.
No, """ is for multi-line strings. i.e. ``` val x = """Something long etc""" ```
No doubt that Java cannot and will not catch up with Kotlin in terms of feature set. However, Java has almost too much traction to be displaced by Kotlin any time soon.
OP, why you not using standard folder structure for kotlin? I'm pretty sure that it's your problem with tests. And why not github? I even can't send you an PR :(
In Gradle, when it is not used a standard folder structure, there is to use the directive `sourceSets` like I'm using int the [project](https://gitlab.com/fastchemail/fastchemail-kt/blob/master/build.gradle#L12).
&gt; There is to use const val to define a constant instead of const &gt;&gt; This seems fairly subjective, Kotlin uses val for values and var for variables. Just because you might be accustomed to const for constants from some other language doesn't mean that it's a problem with Kotlin. Right! But since you only can use `const val` (non `const var`) then I think that a simple keyword could be better used for that proposal. &gt; There is no a tool to create a basic project that is well integrated with both build tool and testing framework. &gt;&gt; &gt;&gt; Gradle? &gt;&gt; &gt; No official package manager with dependencies management &gt;&gt; &gt;&gt; Maven/Gradle/Ivy (all of which are interoperable). The great problem for a developer that does not comes from Java world is that he has to looking for (a) to choose and (b) setup those external tools for that could work with Kotlin. &gt; No packages host &gt;&gt; &gt;&gt; Don't know what this means. A site to hosting Kotlin packages so people could search and install easily such packages like it happens in [Rust](https://crates.io/) or in [Dart](https://pub.dartlang.org/).
This isn't specific to Kotlin but you're abusing exceptions. Just define a Success and Failure classes that extend Result or something, and return that instead of the dozen of Exception sub-classes with throw everywhere. Also what's the point of try { checkAsciiPrintable(address) } catch (e: Throwable) { throw e }
http://mvnrepository.com is great for searching libraries.
&gt; Just because you don't know the Java ecosystem, it doesn't mean that there is no dependencies management tool or "packages host". That's the reason why I wrote: &gt; If you work with Java, it is a great replacement. But it will be hard for people who have not used the JVM environment since there is to deal with external tools to build something basic. 
Not overusing exceptions is a principle that is pretty common among languages :) You're right about the language reference, however there's a short paragraph about sealed classes, that would fit this use case.
But what you wrote is simply not true. I'd argue that you can learn language basics and build something simple [in the browser](http://try.kotlinlang.org). IntelliJ is more than helpful when setting up projects using Kotlin: a few clicks here, and there and you're good to go. Minimal Gradle config file with Kotlin support and basic dependencies is literally a few lines (that you can generate or downright copy from one of many tutorials), and IntelliJ comes with build-in support for Gradle and Kotlin anyway. Does it really matter that Gradle (or Maven, or any other standard Java build tool) is not specific to Kotlin? It's not like you never have to learn any tools when switching a new language. Some languages you described use arguably worse and more complicated build tools and package managers. You _can_ learn and use Kotlin without _any_ previous Java knowledge.
No, it's mainly for libraries that run on JVM. It doesn't really matter if you used Java, Kotlin (or even some other language like Groovy), it can be pushed to Maven Central and used by others. That's the beauty of Kotlin: you can use any existing Java library with Kotlin and it _just works_.
So, this would be the only language (between all languages examined in such post) where you need to use an editor to setup a Kotlin project. &gt; Some languages you described use arguably worse and more complicated build tools and package managers. This is really not true. Tell me about those languages.
Sure! It's ok for developers related to JVM
Well, yeah, Kotlin is a JVM language.
typing println instead of System.out.println is like magic
Everything great that I was using in groovy and Scala + coroutines :)
I got in trouble in /r/java for pointing out that Kotlin already has that stuff and that Java getting it will be too little too late. I have loved the Java programming language, and I do love the Java platform, but 24 years of evolving practice and fashion has left Java as a language which is only mediocre at being able to express the sorts of things we like to say in Java. I'm sure the same thing will happen to Kotlin one day as well, if it becomes mainstream.
That's interesting! What did they complain about? To me Kotlin is a natural progression av Java. I wonder if java will evolve that much more. It's basically in a similar state to C. It does it's job pretty well, but it's not really evolving much. It's talky but predictable and that has some benefits too of course. Personally, I think Kotlin is a more elegant solution a Java v2 if you will.
Apparently they're sick of being told that Kotlin is completely compatible with Java and much more awesome because it has great features already. Kotlin's compatibility with Java is an absolute master stroke. I remember when Java beans were invented, thinking "yes that's all very cute but it demands many more lines of useless code". Nevertheless it was a reasonable idea, and so getters and setters took over, even in cases where they were completely useless. But, until that pattern and fashion emerged, language designers didn't know to cater for it. From then on, Java was lumbered with this verbosity. Many things in Kotlin are recognition of the practices of Java programming, but built into the language so that there's no need to write code for the rituals. I guess some people like their rituals.
No, you got put in your place because you made a pointless comment that had no relevancy to the discussion at hand. As pointed out to you, this kind of infantile fanboyism does the Kotlin community no credit.
Oh, I see now it wasn't really trouble, it was just you with your chronic Kotlin hate trying to pick a fight. And here you are in the Kotlin forum spreading infantile irrelevancy...
You can use the same way synchronized in java.
It had relevancy, you just didn't like it being there.
Just found another one! :) val s = " " s.trim().isEmpty() // true s.isBlank() // true
Are you ever going to get over Cedric?
How do you feel about languages like Swift and Kotlin being OOP but having functional features? Do think they can be blended or does functional programming only work when it is pure?
Yes, we got burned by this as well. Really sucks to have to disable it. Even after, we're plauged by intermittent compilation errors on our CI server. These things make it feel like Kotlin isn't yet ready for the big leagues. 
I love those languages - well, I love Kotlin, I haven't looked at Swift. I use higher order functions in Kotlin. Maybe it's the FP background, but that feels perfectly normal to me and is just plain old OOP. Java 8 streams are lazy, and that's starting to feel a bit like functional programming. However lazy streams in an OOP language are really asking for trouble, e.g. filter and withFilter in Scala: http://alvinalexander.com/scala/examples-shows-differences-between-strict-lazy-evaluation-in-scala So the blending works to a point, and then it starts getting nasty. Programmers don't need their languages to be nasty, programming is hard enough already. As for pure FP, I don't recommend it for serious programs. as Erik Meijer points out here: http://queue.acm.org/detail.cfm?ref=rss&amp;id=2611829&amp;utm_content=bufferb88da even Haskell is not pure. This is because pure FP is a long long way from programs we actually need to write. I'm generally in favour of OO languages getting higher-order functions - after all, Python and Ruby have had them for years. However I'm not in favour of the trend towards functional purity, because I think that approach will just swap one set of problems for another.
I asked the presenters: https://twitter.com/dh44t/status/808720231745077249 looks like they will be available soon
&gt;Kotlin's compatibility with Java is an absolute master stroke. Not sure that this is a "master stroke." This is true of most JVM languages. For exampel, up until Java 8, any Java program could be compiled as valid code by the Groovy compiler. edit: readability
I used simpler approach: extension method `Any.log` which creates logger and returns it for receiver class. I checked performance and logback was very fast (it caches loggers), so there was very little difference between accessing static field and asking logback for a logger. And it's very easy to use, just put `log.info(...)` in the class and it works without any additional declarations. What I miss is the ability to send unevaluated string template. I have to write `log.info("a={}", a)` instead of nice Kotlin syntax `log.info("a=$a")` if I don't want to always evaluate `.toString()` (and that method definitely could have cost). 
Yes. Bytecode. I don't know where he got the idea that Kotlin is translated to Java from. 
Actually, he's not the only one who says something like that, e.g. this blog http://bananaqualitytester.blogspot.com/. I think it's just a question of terminology.
It's a master sadness stroke too. Everytime I use clojure I realize how java is bullying my neurons. IO, reflection, safety, ... everything seems simpler. I appreciate java breadth, history and context but seriously it fails as a language.
"Fails" is a harsh description. I switched from C/C++ to Java in 1996, and it was an absolute breath of fresh air. However there have been many advances and complications since then, and Java is now just old and tired.
Fair point, but was it Oracle will or just competition ?
&gt; I don't much like the way that code says that all the fields of the Person are nullable, but I don't know anything about Spring Boot to understand why that may be. My guess is interop with Java code that is written in such a way that it lacks a concept of non-Nullability. Thus the expectation is that everything is nullable.
&gt; What are the things that doesn't work nicely? My company is using Kotlin in production for quite huge backend API service (with vert.x, redis etc) for like 9 months now and we had zero issues with kotlin or interop. We hope we'll migrate our Android app from Java to Kotlin in future.
Use a constructor property: class Test(private val map: HashMap&lt;String, String&gt;) : Map&lt;String, String&gt; by map { override fun get(key: String) : String? { return map[key]?.capitalize() // want to access original HashMap method } } Example usage: fun main(args: Array&lt;String&gt;) { val originalMap = HashMap&lt;String, String&gt;() val test = Test(originalMap) originalMap["key"] = "value" println(test["key"]) } Prints: Value If you really care about every instance of `Test` having it's own map instance, make the main constructor private and define `fun newInstance(): Test` in a `companion object`. Example: class Test private constructor(private val map: HashMap&lt;String, String&gt;) : Map&lt;String, String&gt; by map { companion object { fun newInstance(): Test = Test(HashMap()) } } For future questions: - read the [reference](https://kotlinlang.org/docs/reference/) - [stackoverflow](http://stackoverflow.com/questions/ask?title=Kotlin:%20&amp;tags=kotlin) is better suited for QA than reddit, but put effort into your question(s).
Cool article. I found selling a new language is difficult, so something like Lombok is a good compromise. Plus with the IntelliJ plugin you can expand any Lombok annotation into its equivalent Java code to see what is really going on.
I think it's a great idea! I would definitely listen. Not really sure about what you mean by sustainable... For names, I think the Kotlin podKast is pretty nice... Some other names that I thought of: pragmatiK programmer, Kotlin Kast(s maybe?)... I'll add more if I think of any EDIT: fun Kast()
Oh I see... What were you thinking about talking about?
I'd like to formally cast my vote for this.
Hi Jire, what code doesn't compile?
I'm interested in such podcast. Please do it.
Be more specific. 
Plenty of language oriented podcasts around (elixir fountain, cognicast, cppcast, ruby rogues, ...) so I'm sure you'll be fine for topics.
It would be really nice if someone built a small Kotlin wrapper atop of Spring (Boot).
All my code works perfectly on 2016.3.1 upgrading from M03 to M04 except for a single typealias. You gonna need to be more specific on what is _not_ working
If you care about performance, consider 'for (i in 0..range) {...}' otherwise declarative style forEach is good. P.S performance consideration kicks in when you filter/collect before calling forEach. Otherwise it's inlined. 
Will get to it when I get the chance!
Very right! Already made a few but the codebase in the current state is gonna need some modifications to actually be testable, no problem though.
&gt; No collectible objects are created Yes, this won't add any pressure to jvm gc.. but if you are going to use it instead of data classes, still somebody wants to free up that native memory allocated by Strukt..rt? 
You bring up a lot of nice points! There are plans for pass-by-value, which to my knowledge would make them actual value types, since I don't think value type necessarily has to be immutable. But you're right, I think a better term would be pass-by-reference structs for the JVM, but let me know if you think of something more catchy than that. :)
TIL that all these years I've been pronouncing *null* wrongly :(
Lol, just looked it up, turns out I was saying it [wrong](https://www.google.ca/search?safe=strict&amp;ei=ZnRcWImiOeXNjwTd4omICg&amp;q=null&amp;oq=null&amp;gs_l=mobile-gws-serp.3..0i67k1l5.2728797.2729635.0.2730138.6.5.1.1.1.0.303.834.0j2j1j1.4.0....0...1c.1j4.64.mobile-gws-serp..1.5.743.3..0j35i39k1j0i131k1.tt0vy2eR_FY) too 😂
Do the forEach with the lambda. It reads easier and prevents having to type parens, and since there is an intention (IntelliJ intention) to switch to the lambda I believe that is the idiomatic way to go.
I don't really see the benefit over object pooling. These aren't real value types
Question: how do you know when you can remove the migration code?
When I won't see active users on 4.x 😁
Feedback welcome BTW
How is it used from java?
Yeah, that makes sense thanks. One more question though: how did you rewrite the app? Did you start a new project in Android studio or did you just delete all the classes and write new ones? I'm asking because I'm thinking about completely rewriting an app of mine, but have no idea how to start.
In my experience, project lombok is an almost equally hard sell though. I've managed to sneak some kotlin into the boundary of production code, but never made any work project adopt lombok.
It creates an iterator over IntRange. Unless we have value types on the JVM and iterator becomes a value object on stack, it'll be allocated on heap. So in principle, for (i in range) is more efficient than range.forEach {}
If you want to make this more type safe and pragmatic, you should definitely check out [kotlinx.html](https://github.com/Kotlin/kotlinx.html), I think you'll find it quite nice...
Inlining saves vlookup(s) (and also allow non-local returns) but it doesn't mean they can't allocate objects when they need to. The construct ```(0..10).forEach { print(it) }``` doesn't translate to ```for (i in 0..10) { print(i) }```. It instead translates to the following: Iterable var1 = (Iterable)(new IntRange(0, 10)); Iterator var2 = var1.iterator(); while(var2.hasNext()) { Object var3 = var2.next(); it = ((Number)var3).intValue(); System.out.println(it); } Yes the compiler converts integral type ranges to Java's indexed loop without extra overhead. That's why I said, consider using ```for (i in 0..range) {...}``` because that's the case when Kotlin converts to Java's indexed loop.
Thank you for your article! I have decided to try out Pitest for "mutation testing" on my library.
I'm new to Kotlin still, but I believe you can use `.apply` to get a sort of combined `let` and `with`, like so: user?.apply { nameLabel.text = fullName } The [docs for apply are rather sparse](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/apply.html). **Edit:** Yeah, [this worked great, check it out here!](http://try.kotlinlang.org/#/UserProjects/ckbfocbffjmc2f4jothnjloc0v/s6r5vnf38lqdknfuj8669p263p) **Edit 2:** If you need to use the result of the block, use `run` instead. [This article](http://beust.com/weblog/2015/10/30/exploring-the-kotlin-standard-library/) has some good details on the differences between the three.
Bingo!! thanks man
It won’t compile. `receiver?.block()` returns an `R?` but your function only declares to return `R`.
Unfortunately we're still missing something like kotlinx.css :P
But still the approach of `map(...).map(...).map(...)` is easier to understand for someone new to the project.
The composition example would be greatly improved using something like `andThen` from [funktionale](https://github.com/MarioAriasC/funKTionale/blob/master/src/main/kotlin/org/funktionale/composition/namespace.kt). As it is in the article it's strictly worse for readability and maintainability.
'andThen' and 'compose' are just a verbose notation. The result will be simply f(g(x)) and g(f(x)). IMHO the latter is much cleaner and quite natural. That's how we write it in elementary math too isn't it. 
I haven't used Play personally, but your approach seems pretty reasonable. Choosing Kotlin first, then moving to trying out Scala, also seems pretty sensible, though you might just get hooked on Kotlin like the rest of is here. One thing I will argue for is avoiding the microservices until you really need them. There's a good argument for that here: http://martinfowler.com/bliki/MonolithFirst.html. IMO it's just too much of a head ache for most simple applications, and if you start out trying to learn a language AND do microservices you'll probably get frustrated and bail. I would. For web frameworks I've had really great experiences using Kotlin with the Spark Framework. It'll get you off the ground really quickly, and has no extra crap that comes with a lot of frameworks.
Watch Vert.x, or Sparkjava. Drop Play
Vert.x for sure. We've been using it for production workloads for several months now and it is outperforming our older Jersey/Jetty services. In addition, we get a lot more done faster. Win-Win.
Just take Spring Boot and you'll be fine
Doesn't it use netty? Netty can cause huge issues with binary compatibility of minor versions, which can be problematic when using netty in your own application as well 
Could we not replace builders with constructors and named arguments? Easier to enforce mandatory parameters as well.
Indeed...
No, not at the moment. The reasoning for not doing this was that writing tests is also part of practicing. I created this issue anyway https://github.com/dkandalov/kotlin-99/issues/9
Am I missing something? Surely the only extra object allocation for the non-inline case is one for the action? I can imagine the indirect invocation costing some performance, but not the allocation itself?
That's not the way I read it - &gt;Everything was great except a performance. I accidentally forgot to inline my function so my code was creating redundant objects. This is a common mistake in designing extension functions.
Take a look on Ratpack. It's REST framework without templates, ORM or any paradigm. It's fast, async and easy to use 
Have you benchmarked this yet? From reading the source I expect that the toString implementation will be on the slow side but handy for some uses and that the equality implementation will be stay-away hellaslow. You should never allocate in your equality implementation, but the source shows multiple allocations, across both caller and callee. And did I spot reflection in there, or was that just my crap kt / mobile phone reading skills? ;)
No, but I definitely plan to! It's pre-release/PoC right now because of that, but I don't think performance will be terrible (famous last words I know). Remember that this is all in-lined as well. The `superToString` and `superEquals` lambdas were a necessary evil, as you can't call super from an extension function. They can't be inlined, so I expect performance to be worse when using them. The only real reflection is deriving the class name in `toString()`. `KProperty`s are a grey area. I haven't seen a benchmark comparing using them vs standard reflection. My hunch is that they perform better (they don't use standard java reflection), but at the cost of extra allocation (each KProperty use has a singleton instance in the compiled class). The main goal of the library was to remove the boilerplate and make `equals()` and `toString()` maintainable. Ideally this could be a lombok-style compile-time feature (considering they've just released the open and noargs plugins, maybe that's actually possible in the future?), but for now this was the best I could come up with! Thanks for the feedback - you raise some good points :)
Much better to use data classes if you can (and if you can't, think hard about why that is).
I agree, but there are times you just can't (i.e. polymorphism - data classes can only implement interfaces, but not extend other classes). This is for those cases. 
Indeed, but the post says that because he hadn't inlined, there were many redundant allocations. I don't see them. 
The author has exaggerated a bit for this particular example. Because there's only IntRange object instantiation (followed by it's dereferencing of course), some unnecessary casts (which are already reported to JetBrains and are being worked on) and a method call involved.
I've just released version `0.1.0-rc.2` which incorporates these changes (both `kotlinEquals()` and `kotlinToString()` avoid unnecessary object creation now.
True. You might want to make this clear in the docs though, in case less experienced devs use your library inappropriately.
Doh, I sit corrected :)
Here are links to the related issues. Sorry for the extra post, I couldn't edit the original. https://youtrack.jetbrains.com/issue/KT-15313 and https://youtrack.jetbrains.com/issue/KT-15218 
Great work. Thanks!
This is really great. I am so happy about this :)
 Kotlin 1.0.6 now provides a kotlin-spring plugin that open classes and their member functions by default for classes annotated with Spring annotations.
Yea - I've just read about that. Will make life a lot easier :) Though I've also noticed that IntelliJ flags up when I forget to make them open as well, which is useful. Not sure if that came at the same time or not.
Thanks! Hope it helps :)
Don't forget, Kotlin 1.0.6 added the `kotlin-spring` plugin, which lets you get rid of all the `open` declarations on your Spring `Component`s. With this plus the other stuff in Spring 4, you can already make a hell of a Spring app in Kotlin. Excited to see better Spring Data integration coming up!
Just use JAX-RS (I like the implementation Jersey best). Spring Boot is mentioned regularly these days, but I think the HTTP/REST abstraction in JAX-RS is much better. Somehow the Spring guys seems to think that REST means Json - nothing could be more wrong! The strange REST intpretations shows up in strange names like `RequestMapping` (instead of `Path`) or `RestTemplate` (whatever a "REST template" should be).
[removed]
Let me suggest you something practise https://github.com/JetBrains/kotlin-examples/tree/master/gradle/hello-world/src
[removed]
I think it really shows the advantages of declarative language features.
I’ll definitely be checking that out once Kotlin 1.1 is final. :)
Top-notch work!
Ouch. Thanks for the info. Here's the non-mobile link for that issue, in case anyone else goes looking for it: https://youtrack.jetbrains.com/issue/KT-15318
Thanks! I'm looking for volunteers to help - interested?
Nice article, but don't overplay it too too much. &gt; We reduced the lines of code needed from 47 in Java to 7 in Kotlin, resulting in a huge productivity boost. Consider that at least IntelliJ has an code generator for this pattern. And more importantly, don't conflate "productivity" with "typing". All in all though, a nice overview of these features.
Yeah, I've heard the arguments; I'd like to see some studies. Otherwise it's all navel gazing. I agree with the theory; don't misread me. Just not sure of the actual real world evidence. Lots and lots and lots of productivity have come about with verbose languages. Just like your native tongue; when you start to read you look at letters. As you get better, words, and whole sentences. I don't see code as a whole lot different; verbosity only makes a substantive difference as you're learning. But that's also a theory, and a gut feel, and I have nothing to back that up either other than the evidence that people that are more experienced in a language seem to not have "productivity" issues as much as those who are not.
That's why my argument for kotlin is totally subjective. It's more fun to use! Can't fact-check that one. To expand...there are lots of little methods that make your day just a little brighter. Things like `list.isNotEmpty`, or `str.isNullOrEmpty`, or any of the many collection transforming methods. Whether or not I've saved time by writing `str.isNullOrEmpty` instead of `TextUtils.isNullOrEmpty(str)`, I *feel* like I've saved time, which is really [what drives engineers](https://xkcd.com/1319/) at the end of the day, right?
Update: To illustrate how easy it is, here are the beginnings of a simple JQuery plugin: * [Implementation](https://github.com/sanity/kweb/blob/master/src/main/kotlin/com/github/sanity/kweb/plugins/jqueryCore/JQueryCorePlugin.kt) * [Use](https://github.com/sanity/kweb/blob/master/src/main/kotlin/com/github/sanity/kweb/demos/jquery/jquery.kt)
[removed]
Would only work if name is `var` though 
[removed]
Because.
I am not sure if this is a good idea. I want to know what code goes to browser so I don't accidentally reveal some part of business logic. But I don't completely understand what this is so, maybe I am wrong.
The code that goes to the browser is the minimum required to modify and query the DOM. It won't reveal any business logic.
[removed]
Oh man, Uncle Bob is really losing it. "Why should we improve our cars ability to steer and brake!? What we really need is more guard rails!"
I have experienced some of this with Scala too. Fuck, that compiler is a bitch, but by the time you've wrangled it into submission over your function, by damn, that function works! I like compilers as being pre-written test suites that help me do things right. I hate the idea of writing all those tests over and over again for every function I write, to test whether it sometimes returns null. What a waste of time.
Exactly! I was implementing some chatbot which did a non-trivial stuff like parsing json, doing some logic in response and sending a request to another server. Was juggling that Haskell code for an hour or so, considering me being noob and all. Without running it. Then I got to some safe point and compiled and ran it. It worked right away! I was amazed :) I am thinking similarly: I wouldn't ditch tests at all, but I would very much like test only important stuff, business logic stuff rather than writing tons of tests which check for correct nullability of return values/arguments o_O
&gt; Where they have a saying that "if it compiles it is 80% that you have a correct code"... And I actually already experienced this while playing with Haskell. Elm is a pretty great gateway to that, it's a purpose-specific language and has a fairly simplistic type system (which allows for tremendous help messages even for beginners), but the "standard library" has almost no bottom[0] and match completeness can't be disabled, so once you get the compiler to accept your code there's a very high chance it'll work and it'll work reliably. [0] for instance `List.head` returns a `Maybe a`[1], but Elm's maybe *does not have a `isJust` or `fromJust`*. You can patter-match it (fully), `withDefault` it (~ `fromMaybe`), `map` it (~ `fmap`), you can `andThen` it (~ `(&gt;&gt;=)`) but it won't blow up the way `Data.List.head` does unless you specifically and explicitly decide to call `Debug.crash` in a match arm [1] somewhat oddly `List.tail` returns a `Maybe List a`
I agree, Elm is a quite nice language to start learning functional programming...
Anachronism at its finest. Sorry, Uncle Bob, I respect you, but it's about time you retired. If not, get on with the times.
Thanks! I tried searching for it but there were no results, I almost resorted to listening from SoundCloud. 
I'm with Uncle Bob on this one mates. I have seen WAY too many people pushing Kotlin/Scala/whatnot and their code becomes unmaintainable quite quickly. When your flashy new language project has survived 3 complete team turnovers, 17 different major version releases, and 10 years in production; tell me then how great it is. Most of the hipster language projects I have seen never make it past 1 or 2 major versions before everyone gets fed up and starts a rewrite. Just my 2 cents. 
Kotlin has been in development for 7 years, and the people behind it are experienced and respected programmers. It's not some fly-by-night "hipster language".
I like Uncle Bob's videos, but he is way off-base with both of his criticisms of Kotlin here. The rationale behind final-by-default, which comes straight from the very respected "Effective Java", is that a class intended to be subclasses is often much harder to write properly than a class that isn't. Having to type an additional 4 characters is a small price to pay to remind the programmer of this. It makes perfect sense to default to the safer option. And his criticism of Kotlin's null-safety is even more bizarre, this is one of Kotlin's best features! The whole point of statically typed languages is to catch errors at compile-time rather than catching them at runtime. Why would anyone **not** want to use a language that would do that for them? His argument against it, which is "you shouldn't need it because your tests should catch that" could be used against **all** of static typing.
&gt; [1] somewhat oddly List.tail returns a Maybe List a Out of curiosity, why would you consider this odd?
&gt; and their code becomes unmaintainable quite quickly. I'd like to see some evidence of this. Shit code can be done in any language. I'm not sure that the features that are referenced in the article necessarily lead to said shit.
Makes sense then. I will check it out.
No, but lack of testing CERTAINLY does. 
If programmers create bugs, and the same programmers create tests...
I'd much rather have the language enforce null safety than write the same fucking test cases over and over. I'm not paid by the hour, so I'd much rather get actual work done.
And this is why I'm very happy to surrender some responsibility to my compiler overlords. They can test a lot faster than I can and let me focus on whether a result of 6 is correct or not.
I don't agree with his arguments but I am not sure final classes by default is the correct decision. The pain is mostly in testing.
kill.myself()
You had zeros! We would have thought we'd died and gone to heaven if we had zeros. We had to make do with letter Os. 
I imagine the problem is indeed the Kotlin call to JavaClass.join("&lt;br&gt;", *array) can be interpreted by Kotlin as join(String...) or join(String, String...) or what you expected: join(CharSequence, String...)
I agree with the verbosity point but I actually had a problem mentally parsing the expression when I reached the "!= null" part, so I initially parsed like Kotlin :P and the verbose unambiguous answer for me is the same OP wrote test?.bool ?: (nullable != null)
I totally agree that tests are still important and he goes in great detail to convince that type systems are not tests in his reply: http://blog.cleancoder.com/uncle-bob/2017/01/13/TypesAndTests.html Well, the same can be argued in opposite, unit tests for nulls or strings in places where you expect an int and all possible permutations of types and exceptions are **not behavior** tests, you just changed where the check is done but the test is exactly the same: rather than done by the compiler, it'll be a test case written by a human. Imho they are all tests/checks just with different objectives consistency, behavior, performance, etc... This discussion for me is just a simple question: Who do you want to write your type/exception tests: the compiler or the human developer? Because you have to write them, we all agree on that 100%. At the end, it's just a personal preference and I personally prefer automated tools that remove tedious work, but it's totally fine to do things manually too.
Cool that you like my post! Thanks for your valuable input! Definitely helps me with writing part 2 :)
Yeah, I'm a bit sceptical about this too. It makes sense for data classes, but they aren't extensible at all in Kotlin. For other types, I'm of the opinion that if you want to subclass then it's on you to make sure it works properly. I've had a lot of headaches over the years from not being able to extend/override things that were broken in frameworks.
Yeah this list doesn't seem too accurate
*if you're using the spring framework. 
That's right!
I had a similar symptom, and it was caused by enabling font liguratures in Android Studio on Windows. There's a warning about it now, but there didn't used to be. Solution was to switch to Linux Mint. Or turn off font liguratures. 
it seems like isn't indexing everything, you need to ask to index your repos explicitly
Switching to Linux Mint is the solution to most problems under Windows.
Controversial points, only 39% users of subreddit understood the joke ;) It is original, not an edited picture. UPD. 50% upvote ;) Some people in slack#random found where is that lighthouse
Or wading through StackExchange posts (I still love Mint though!)
iirc using the Jetbrains JDK also helps with that issue right?
Yeah but I could never get that working on Windows.
Just a suggestion: "Kotlin native" will mean some other thing in future ;)
Kotlin Island https://www.google.com.sg/maps/@59.9843525,29.7623692,3a,75y,233.97h,96.39t/data=!3m8!1e1!3m6!1s-AuZ56OQwQmY%2FVg_tQZ75eaI%2FAAAAAAABKeE%2FQgP3m0wj1sEGcj6O1hqsfQ7Buca78gKcwCJkC!2e4!3e11!6s%2F%2Flh3.googleusercontent.com%2F-AuZ56OQwQmY%2FVg_tQZ75eaI%2FAAAAAAABKeE%2FQgP3m0wj1sEGcj6O1hqsfQ7Buca78gKcwCJkC%2Fw203-h100-k-no-pi-0-ya170.4714-ro-0-fo100%2F!7i5656!8i2828
Did you draw the anime? Where did you find it?
I don't think he's on reddit 😔
Love the Java fang trinket.
No, but I had a talk with Kotlin team on a conference two months ago, they are working on it. Obviously, they'll have to add descructors in language for that platform.
He/she's professional and working on his patreon page opening soon :) But seriously, describe a background and character for your project, make references to other artists works, throw some money and they'll do it. You can ask me for contact when you'll need it. Its strange that IT people dont make those kind of requests for artists and animators.
very dangerous service when unprotected. see: https://github.com/derveloper/kiny/issues/1
If only Uncle Bob had actually used Kotlin for longer than a quick demo, these fears would go away. &gt; who's job is it to remove fear from a programmer? the programmer's. Kotlin is a very small language overall, and having used it daily since January, 2013 I have seen it solve its own issues, and sometimes actually shrink to be more streamlined. The language grows conservatively, by study and never by accident.
Excellent, I really like the improvements tornadofx provides. Keep up the great work! 
You can just create an `object Constants { //constants } ` in its own file. It doesn't need to be in a class. You can also have multiple `object`s the same file.
Just put your constants at top-level, you don't need class or object for it. If you want to additionally namespace them, use object. 
Looks good, but I have a question Would be possible to use operator overloading to somehow replace this code: db.select("User", "name") .where("(_id &gt; {userId}) and (name = {userName})", "userName" to "John", "userId" to 42) with something somewhat closer to this: db.select("User", "name") .where {_id &gt; 42 and name == "John"} If not that, what's the best that could be done w/o using strings? 
If it is an app we're taking about then most of this stuff can be stored as XML resources
According to [this](https://kotlinlang.org/docs/reference/comparison-to-scala.html) value types are probably going to be in Kotlin soon™
Thank you for your help!
Yeah but I had no idea. and I think other people don't either. 
Thanks. Hope to hear from you. I suspect the closest would likely be something like: db.select("User", "name") .where {(col("id") &gt; 42) and (col("name") == "John")} But I am by no means certain
That makes sense, thanks.
It helps if you visualize it differently. foo()?.bar() is the same as if (foo() != null) foo().bar() else null (with the call to `foo()` being only done once, of course). So if `bar()` returns a `T`, the complete expression with still return a `T?` because of `foo()` returning `null`.
Annoyingly this is the opposite of how it works in C# where the null-conditional cascades :(
C# got this right. The first ? short-circuits the rest of the expression. Any additional ?s are entirely inappropriate for that sub-expression. The top-voted comment frankly performed the wrong manual code transformation.
so yes, your intuition is correct there.
Upon reflection, it seems pretty clear that this should be a **function**, not a property, considering that I'm using `String?.isNullOrBlank()` directly from Kotlin's SDK and it's a function. "Convention" is still not a super compelling reason, but it's better than nothing. 
It might short-circuit evaluation, but it evaluates to NULL. So the type becomes nullable, and there's still things which you can validly call on a NULL value: data class Foo(bar:String) val foo : Foo? = null print foo?.bar.orEmpty() Since orEmpty() is an inline extension function this appears to be legal, and work. However, this is not legal and needs null-safe access: print foo?.bar.length Should instead be: print foo?.bar?.length Or: print foo?.bar.orEmpty().length 
Do you mean [Kotlin Android Extensions](https://kotlinlang.org/docs/tutorials/android-plugin.html)? I actually stopped using those and moved to Android Data Binding. I still have some best practices questions, but it feels like the future.
Function because it's more of an action than data... I don't really know how to word it better
No, that makes sense. What if it were named `thisOrNullIfBlank`, though? That feels like a property that's a projection of the data, rather than an action. I have my answer, just creating discussion at this point. 
I disagree. The way Kotlin handles this fits much better in a functional language. `foo()?.bar()` is an expression which returns a value (that can be `null`). If you short-circuit on `null`, you no longer have an expression. Another way to think of it is, as QshelTier pointed out, it is equivalent to: ``` if (foo() != null) foo().bar() else null ``` But in Kotlin, `if` statements are also expressions, so we can do: ``` val bar = ( if (foo() != null) foo().bar() else null ).baz() ``` And it is clear we are calling `.baz()` on the result of an expression that might be null, so we must use `?.` edit: an interesting blurb about statements vs expressions: http://fsharpforfunandprofit.com/posts/expressions-vs-statements/ 
A property shouldn't start with the word "get", that is confusing. When converting Java getters to Kotlin properties the get is removed for example. But as you already noticed, this should be a function anyway. 
That's better but still rather weird. If you imagine I'm a String then my length or my character data are properties but "myself or null if I'm blank" isn't really a property. 
&gt;&gt; I don't want to start a language war, but I'm wondering why Scala isn't supported like Kotlin &gt; I guess its because kotlin seems to be growing somewhat faster than scalas Wild SCALA is hurt by its burn!
String.emptyToNull()
It should be function imo, just because it is not a property (as in the English meaning of the word) of the original string. For example, length is a property of the string
The value type parameter on `KProperty1` is covariant, so `KProperty1&lt;*, String&gt;` is a subtype of `KProperty1&lt;*, Any&gt;`. This means that `withCriteria(Employee::name, 123)` can be fulfilled inferring `R=Any`. I can't think of any way to make this work with `val`. If you use `var` and `KMutableProperty1` instead it will work as expected. Otherwise you could define `withCriteria` for a predefined set of types: fun withCriteria(property: KProperty1&lt;T, String&gt;, value: String) fun withCriteria(property: KProperty1&lt;T, Int&gt;, value: Int) fun withCriteria(property: KProperty1&lt;T, Long&gt;, value: Long)
[removed]
You might want to take a look at the [Kotlin JPA Specification DSL](https://github.com/consoleau/kotlin-jpa-specification-dsl) for ideas. Edit: sorry, it doesn't enforce this either - though intellij does suggest the correct type You can specify the type explicitly (though that sucks): spec.withCriteria&lt;JobRole&gt;(Employee::job, "CEO") // Doesn't compile Or only use `withCriteria()` internally and expose criteria-specific methods on your specification (which will solve the type-safe problem, but not the underlying generics issue): abstract class Specification&lt;T : Any&gt;(val klass: KClass&lt;T&gt;) { protected fun &lt;R&gt; withCriteria(property: KProperty1&lt;T, R&gt;, value: R) { // do stuff } } class EmployeeSpecification : Specification&lt;Employee&gt;(Employee::class){ fun withName(name: String) = withCriteria(Employee::name, name) fun withAge(age: Int) = withCriteria(Employee::age, age) fun withJob(name: JobRole) = withCriteria(Employee::job, name) } fun test() { val spec = EmployeeSpecification() spec.withName("Jo") spec.withAge(25) spec.withJob(JobRole.CEO) // Should compile spec.withJob("CEO") // Doesn't compile }
Nice to see some missing functions! Does anyone know when you should use `apply` vs `also`? I would use `apply` when modifying the object and `also` when needing to do something more. However, the example that they provide uses `also` where I think `apply` should be used. Example of `also`: data class Car(val brand: String, var color: String? = null) fun test() { val price = Math.random() * 1000 if (price &gt; 500) { Car("BWM") } else { Car("Volvo") }.also { println("I like ${it.brand}") } } vs `apply`: data class Car(val brand: String, var color: String? = null) fun test() { val price = Math.random() * 1000 if (price &gt; 500) { Car("BWM") } else { Car("Volvo") }.apply { color = "red" } } 
Mostly just if you want it to be clear and not override the this scope. I've had situations where I had to do that and then you have to do the this@... Syntax. As opposed to just using it.
apply and also both return the receiver object. The only difference is that `apply`'s lambda has the receiver as its receiver, while `also`'s lambda has the receiver as a parameter.
I'm embracing the dark path and am on the way to sith lord :) Typo: If we try to call the function with ~~add(1, "2")~~ add(1, null)
You are right, but as long as "foo()?.bar()" is called once only and the result is then used multiple times in the corresponding method, a member variable does not centralize the result (and the coupling) any more than a local variable. Also it looks better than "foo()?.bar()?.baz()".
gut! 
Is there an mp3 version of the podcast? SoundCloud is really annoying and non standard for podcast distribution. 
link [https://api.soundcloud.com/tracks/304578745/download?client_id=cUa40O3Jg3Emvp6Tv4U6ymYYO50NUGpJ]
Really? There's an RSS feed you can throw into any podcatching app and it just.... works.
Hey now, they actually did give a reply: &gt; We had a Spring Scala effort a few years ago: https://spring.io/blog/2012/12... &gt; &gt; However, the Scala ecosystem didn't show enough interest, and neither did the Spring community. So we decided to re-invest into Groovy support in Spring Framework 4.0 instead; and now, we're aiming for a similar story with Kotlin in Spring Framework 5.0. &gt; &gt; Groovy and Kotlin are both well aligned with Java API conventions, so they are arguably a better fit with Spring and other Java-oriented programming models to begin with. Though, arguably, the "scala ecosystem" kind of has a default "not invented here" issue, where in order to use scala, everything really wants to be done in some scala-special way. OTOH I've experienced that you really don't have to wait for spring 5.0 to use kotlin with spring; just start using kotlin. The spring 5 changes are really just kinda nice. It really didn't take much drudgery to do a full spring boot stack in Kotlin at all.
The problem isn't static typing. The problem is that most static languages are verbose and about as expressive as a dead cat (I am primarily looking at Java, but C# is different in degree, not in kind). Kotlin is better because it is expressive and succinct enough, for the most part, although I would still love to have macro system.
Nice to see a webapp in kotlin. How was your experience developing SPA in kotlin? 
The javascript support was seriously lacking, but I haven't tried the new 1.1 beta yet which supposedly fixes a lot of it.
Some thoughts off the top of my head from my experience so far: - **Using kotlin from java.** I tried using kog from java and quickly realized that it's not very easy. I couldn't even figure out how to use my type-safe [SafeRouter](https://github.com/danneu/kog/blob/master/src/main/kotlin/com/danneu/kog/SafeRouter.kt). Is it even realistic to try to use a kotlin library from java or do you have to give up too many niceties to make it pleasant in java? Seems lame to have to use stuff like `Function1` in java. Any good kotlin libraries out there that show how it's done? - **Hot code reloading**. I saw that [ktor](https://github.com/Kotlin/ktor) (web framework by jetbrains) implements hot swapping, but boy did I have trouble following along. Right now I'm doing the `nodemon` approach of restarting the server when source files change, so it's at least as pleasant as node development is, but it seems like hot reload would be killer for development. I'm not sure what the easiest way is to go about it. I suppose I need deeper knowledge in java to pull it off. But it's definitely on my todo list. - **Cannot extend existing classes with interfaces**. This is something I took for granted in swift. For instance, in swift, I would probably make it so that you can set the response body to anything that implements the `ResponseBody` interface. That way the user could have more control. But since you can't do that in kotlin, my solution so far was to create a `ResponseBody` sealed class with members like: - `ResponseBody.None`, - `ResponseBody.String`, - `ResponseBody.File`, etc. which wrap underlying kotlin/java objects. Here's the code: [ResponseBody.kt](https://github.com/danneu/kog/blob/master/src/main/kotlin/com/danneu/kog/ResponseBody.kt) It'd be cooler if you could do something like `conform File : ResponseBody { // conform to interface }`. - **Reflection is slow**. I always hear this mantra, but I experienced it first-hand when I was first building my type-safe [SafeRouter.kt](https://github.com/danneu/kog/blob/master/src/main/kotlin/com/danneu/kog/SafeRouter.kt) with the naive approach of using reflection to dispatch each request. I got more than a 10x speedup by moving the bulk of the reflection to boot-time. - **Build tools are hard**. I have no clue what I'm doing in my [build.gradle](https://github.com/danneu/kog/blob/master/build.gradle) file. The most I can say for it is that it compiles, runs, and can be pulled into other projects from JitPack. I read the gradle docs here and there, but I feel like I need to take a course on it at a community college to pay back some technical debt and figure things out. This is probably the hardest part of kotlin for me coming from tools like clojure's leiningen and node's package.json.
What's it with three-letters names?
[removed]
Yes it is possible. I'm not really sure what you need more help on.
like any tutorial, example app kind of.
Sorry, could you elaborate?
I think your question is better phrased "is there tooling ready that makes a React Native app with a Kotlin-based web app development easy"? The answer is basically no, the tooling isn't there yet. Everyone saying "sure it's possible" is being flippant. My short response is: I'd use gradle. More info: I *have* used gradle (which supports Kotlin too) to basically manage node, which is key for real-world react workflows, using the "com.moowork.node" plugin. This was for a webapp, so the react tools launched a javascript dev environment that a spring server would redirect to for development node only. Inspired by this blog article: https://geowarin.github.io/spring-boot-and-react-hot.html (Note: *inspired* is important. The tooling for react changes frequently as it's a very active ecosystem.) I'd expect you'd likely have to develop some kind of react native plugins for gradle to ensure the `react-native` scripts are behaving. But it's pretty damn easy to write "npm tasks" in gradle with that node plugin: task bundle(type: NpmTask) { args = ['run', 'bundle'] } (Note: that's groovy code, not kotlin in gradle.) There's a number of gradle xcode plugins as well, so I'd suspect you could wire this all together easily enough.
thats cool to look into
thanks for the explanation.
yeah, this looks great. the mapping option is very nice. I might take a gander at it for my next cli :)
Ha! I've never even heard of Click. Reading their FAQ's "Why not Argparse", it's interesting (to me, at least) that the two problems with argparse that they mention are both things I tried to correct in kotlin-argparser. I never liked argparse's somewhat magic behavior, and so tried to come up with generalized parsing logic, and then have convenience methods built on top of that for the common cases. Disabling interspersed arguments was pretty easy (and originally I almost went the opposite route and disallowed interspersed arguments entirely). As for the name, I almost went with "Kargo" (Kotlin Args and Options). I decided against a cute name because I'm kind of tired of trying to remember what all of these randomly named libraries do, and just wanted something descriptive.
On a side note, how come Kotlin doesn't use &amp;, |, \^, &lt;&lt;, &gt;&gt;, etc. But rather just uses the functions by name? Why not add a few more operators?
Java does have bitwise operators and I'm surprised that Kotlin doesn't. EDIT: After rereading the article, Kotlin has bitwise operators for Ints and Longs but for some reason maybe not for Bytes or Shorts.
Agreed. This is one of my gripes with Kotlin. For bitwise operators, it's ironically more visual noise with text than with C like sigils.
It's interesting, Java doesn't have bitwise operators for bytes and shorts either. Check it out. Everything needs casting to int or long. Java handles that conversion implicitly while Kotlin is explicit. 
Which isn't really a problem, since the result should be upgraded so that the entire range of the result can be represented in an unsigned datatype. 
We'd be more than happy if somebody from community draw a lovely one! ;) 
Why should those rarely used functions have special treatment over other functions? If you believe that symbol based function names is bad form then it should be applied to the standard types to. Addition + exists in the real world, but &amp; didn't exist before C type languages (not sure if C was first, but hopefully you get my point) 
Klippy!
I agree that abusing operators like that is something that should be avoided at all costs, however: 1. Other operators can be overloaded and nothing is forcing anyone to use them "properly". So why be extra cautious with bitwise operators? 2. Maybe you want to just avoid misuses of the bitshift operators, but &amp;&amp; and || exist, so why not &amp; and | ? 3. &lt; and &gt; are treated as a single "compareTo" operator function, why not do something similar with bitshifts? I can see the unsigned shift being an issue, true.
How would this be special treatment? The logical/boolean &amp;&amp; and || operators are there, why not the bitwise ones? And those symbols were introduced in C as well, presumably because their real world counterparts aren't available on US qwerty keyboards.
not too long ago someone posted an anime personification of kotlin 
How about this one? https://www.reddit.com/r/Kotlin/comments/5ob11m/hello_is_this_an_anime_channel/
My wife made me a Kotlin Kat for Christmas. So at least I have a personal one. http://imgur.com/a/4UaeE
&gt; Does this library support unix style arguments `foo -b --file test.dat` or more Java style arguments like `foo -b -file=test.dat` or both? Especially looking at the equals sign. Excellent question. This is something I haven't gotten around to properly documenting yet. kotlin-argparser supports POSIX and GNU style arguments: - Short options start with a single hyphen. If they take an argument, the argument can either be appended, like "-oARGUMENT" or can be the following command-line argument, like "-o ARGUMENT". Argumentless short options can also be appended to each other without intermediate hyphens, eg: "-xyz", or even "-xyzZARGUMENT" (ie: the last one can take an argument). - Long options start with a double hyphen. If they have an argument it can either be delimited with an equal sign, "--foo=ARGUMENT", or can be the following command-line argument, "--foo ARGUMENT". Multi-argument options are even supported, though not by any of the convenience methods. For those, option-arguments after the first must be separate command-line arguments. The difference between POSIX and GNU style is that in GNU mode (the default) options can be interspersed with positional arguments, but in POSIX mode the first positional argument turns off option processing for the rest of the command-line. In either mode "--" can be used to turn off option processing for the rest of the command-line. &gt;The library I currently use has nice convenience functions that let you specify that you for example expect an Integer in a certain range or a Duration or a Date (like a LocalDateTime) or a File or even an Enum value of a given Enum without the requirement to specify your own conversion methods and error handling. Which is really nice for quick prototyping and could be added to your library as well I think. That's a good idea. The conversion support is pretty bare-bones at the moment. It shouldn't be too hard to hard to make up a bunch of conversion functions. For numbers and enums, having these in the core library seems fine. For stuff like dates I wonder if it makes sense to have it split into a utility library, to avoid pulling in dependencies not everyone will want/need. (Does anyone use the date support in java.util anymore?)
I like this! If cats can take over the internet, maybe a Kat mascot would help Kotlin take over the language world? 
&gt; Yes, better documentation would be great here. I ended up using my previous comment as the basis for an addition to the README.
&gt;I'd mostly personally like to integrate the new Java nio and date API like Instant, LocalDateTime, Duration, Path and so on. That should be all in the standard library unless you target Javascript or old JDK versions, so no additional dependencies. But I could understand if that's out of scope. Interesting. I hadn't really kept up with the library changes in Java 8, so I didn't even know about java.time. Right now I'm only depending on Java 6, but given that this isn't something one it's likely to use on Android, perhaps bumping up to 8 would be reasonable. Thanks for your suggestions!
&gt; should be rewritten to use JMH [JMH shows much the same](http://benchmarksgame.alioth.debian.org/sometimes-people-just-make-up-stuff.html#jvm-startup-time) (give or take a few tenths of a second).
&gt; a significant amount of time Significant if the overall time is tenths of a second. &gt; not how a real-world application actually runs Except for when: it is how a real-world application actually runs ;-)
[removed]
[removed]
I'm not sure I follow. Couldn't you just take the existing "and"/"or" functions and turn them into operator functions? Same with shl/shr. The names would stay the same, just that now you can use symbols in place of the function calls, just like with plus() and +
"Effective Java" influenced a lot of things. Its an influential text in multiple ways.
These are a bit far-fetched... Effective java has certainly influenced kotlin but it's still a book on java and doesn't really talk about "it would be nice if the language did this". And some things like "don't use raw types" are just common sense. 
Awesome. Maybe Kotlin is more suited to a cat mascot as it has cat-like attributes - agility, grace etc. 
It's just hard to take library posts when they're full of superlatives and sound like ad spam. I have no doubt you worked hard on it, but your way of advocating for it is pretty tone deaf and reads like an XDA teenager post.
[removed]
Hi! I'm using Vertx with kotlin 1.1, I think I can help, but you didn't even post links to these examples and I'm lazy.
[removed]
Yeah, this is a problem I encountered while developing my form DSL and I found out `@DslMarker` but at the time Kotlin 1.1 was still in alpha. I will integrate it for sure when the last version of the language will come out of beta! If someone wants more info about it: https://kotlinlang.org/docs/reference/whatsnew11.html#scope-control-for-implicit-receivers-in-dsls
There's also an Avian Gradle plugin: https://github.com/ReadyTalk/gradle-avian-plugin
Wow Avian looks pretty cool! Does it have limitations?
Interface `LocationProvider`, implementations `AndroidLocationProvider`, `FakeLocationProvider`, `StubLocationProvider`, et cetera. 
Isn't Kotlin Native something that Jetbrains is already working on? I wonder how it will compare.
That's an interesting question. The "Java way" you're talking about works nice within Java because we separate the superclass from the implemented interfaces via keywords "extends" and "implements", making it clear for the readers what is a class and what is an interface. However, Kotlin do not use "extends" and "implements"; rather, it does the same as C#: separate the class header/signature with a ":", and put the superclass AND the interfaces after. Because of this, it is a standard within C# to prefix interface names with a "I", so that readers can know right away what is a class and what is an interface. Examples: IDictionary, IList, ... Still, since Kotlin is all about interoperability Java, and even the interfaces in the Kotlin's stdlib are named the same as way as Java, then it's better keep the naming standard the same as Java.
Just name them logically. Is my interface one for something like, say, an entity? Call it "Entity" and all subclasses are "Player" or "PlayerEntity" or what have you. Conventions that strictly prepend or append strings to code tend to end up being cargo culted to the point of losing meaning.
Yeah, that is a good point. I was not thinking in terms of interoperability because I am an extremist who says burn down all Java and plant the seeds of Kotlin in their ashes... but that is a bit... Well, good point. 
I like these. How do you feel when you take Java interoperability into account like mentioned in BloodShura's comment?
I have it so that class names are blue and interface names are green in intellij/Android studio so I can tell them apart without having to resort to clunky naming schemes. However, my interfaces are often nouns based on verbs, or adjectives ending in -able. E.g. "Provider" or "Resizable" and I don't think there's much ambiguity, usually.
Doesn't matter. `xxxxImpl` is just as stupid in Java. 
This really is a personal taste argument. In the case of classes in android that don't give you control of creation such as activity, fragment, intent service and friends. The late init is your first good option. Because of this it becomes natural to follow this pattern in many other places. But in reality you should prefer constructor injection because it allows for more clear and explicit declaration of dependencies. Immediately this pays off in writing tests because you can quickly setup your instance under test. The consumption is just more clear with constructor injection. Also as you said it forces you to consider if you should really be adding so many dependencies and may help you stick to the single responsibility principal as a result.
From what I've seen until now, yes, it's classpath library lacks LOTS of classes (like NumberFormat, BigDecimal, Java 8 APIs, Atomic*, obviously AWT/Swing/JavaFX, and whatelse not). Following the instructions on Avian's GitHub, we can build with the OpenJDK source code, using it's class library (complete), but I'll try that tomorrow.
How about people reading **your** code?
I've always used the same convention in my Java code as well. But it's just a naming convention, it doesn't affect interoperability. Naming interfaces with an I at front used to be a convention in Java as well, years ago. To me it just looks bad however. Really, the code using the interface or class usually doesn't care, that code looks worse (in my opinion) when all types start with an I just like it looks worse when all strings start with str, integers with int, etc. And when it does matter, it's quick and easy to look up and find out.
Honestly, that's the problem of the people if they're not using intellij to read code. 
Good point. I should start testing my code. Sadly I don't have the time at work to :( but.i want to start.
A lot of people read other people's code in a browser.
Sure but until you really start developing the difference between interfaces and abstract classes for example isn't really relevant. 
I just started to use this in a new project at work and I love it! 
I could have kept going for a while longer :)
I don't know if you noticed, but my `sum` example function is not tail recursive. I was aware of it while I wrote it, but decided to leave it as is to keep the example simple. In fact, I didn't even know about the `tailrec` keyword until now -- it's pretty cool that you can have the compiler guarantee that tail call optimisation actually happened. That said, I don't think it's nearly as big a deal as, say, extension functions. Tail recursion is only essential in _pure_ FP, where you are forced to use recursion for basically every nontrivial operation. I think Kotlin strikes a good balance here as well, by allowing you to just write a while loop if you want a while loop. You can have pure functions that still have mutable local variables on the inside, and it's often more readable in my opinion. YMMV!
I don't have the book handy to quote it verbatim, but I'm pretty sure it laments the fact that classes aren't final by default, among other things. A number of Kotlin language features, including "final by default" classes, are explicitly attributed to Effective Java by the Kotlin docs. The author should change the title of his article, there is no *may* about it, Effective Java definitely influenced Kotlin's design.
Thanks for the info! What still confuses me from the article is that it implies that companion objects are created and GC, unlike static things in Java that are created once and stay in memory all the time with no extra allocations. Do you know if the behavior of "object {}" is like Java statics?
Thanks a lot! Well explained and it makes sense that optimizations in compiler and in JVMs are different between Java and Kotlin. What confuses me on the article is that it mentions the cost of creating the "object" object and then using it inside the onDraw method, but the fact that onDraw is called many times should have no impact on the fact that it's using a companion object. In the article's example of using a companion object(1) Vs a class field(2), I imagine the main differences are that (2) consumes more memory than (1) and maybe the number of method calls required to access the integer might differ based on inlining and optimizations.
Honestly, this article is fairly miss-informed. I wouldn't pay much attention to it, but to answer your questions: The 'cost' of creating the companion object is a single allocation. This is pretty much free, as it only happens once, and is extremely inexpensive. The further costs of using the companion object field, other than the lack of inlining, is that Kotlin's fields are accessed via getters/setters, so to get the val, it involves a method call, unlike the instance variable which can directly access the field. This method call can be removed by annotating the field with @JvmField. This will mean that the field of the companion object is accessed directly, without a method call, exactly the same as using an instance field (but probably still a little slower, since its stored in a separate object). Once again, on desktop JVMs the method call would probably be removed during runtime, not so much on Android (although this is one of the simplest optimizations that a JVM could make, so I'd be surprised if Android didn't). The massive CPU usage difference the author gets is mostly due to that method call, but also because with Java's static final, the value is inlined by the compiler. Once again, this can be achieved in Kotlin by using `const`, or even by using both @JvmStatic and @JvmField, however `const` guarantees that the value will be inlined.
Actually, nothing. It was a lucky guess :)
[removed]
I prefer D&amp;H https://github.com/f2prateek/dart
Seems very interesting, is the audio available somewhere?
Couldn't find one. You probably have to ask the presenter (Twitter handle on the first slide)
[removed]
Sequences look like Java 8 streams. 
They do. Kotlin doesn't support parallel sequences at the moment. So, I do believe you'd have to get the java stream instead. I haven't tried it yet.
Anko: https://github.com/Kotlin/anko/blob/master/doc/SQLITE.md
Try this: https://github.com/requery/requery
http://spekframework.org
Spek doesn't work with Android instrumentation tests because Android instrumentation tests must extend from `InstrumentatiomTestCase` while spek requires you to extend from `Spek` base class rendering the two inoperable together. http://engineering.pivotal.io/post/setting-up-kotlin-with-android-and-tests/
You do not have to extend InstrumentatiomTestCase, Android jUnit test rule can be used instead. Not sure thou if Spek supports it. I was able to make it work with Groovy-Spock.
That'd be really nice. I assume the option to generate Java will still be there for those who don't want the Kotlin stdlib as a dependency?
Yep
Could you please file a YouTrack issue (https://youtrack.jetbrains.com/issues/KT)? This definitely looks like a bug and not an intentional change.
I've addressed the problems pointed out in the initial release here: https://www.reddit.com/r/Kotlin/comments/5v3si0/komprehensions_functional_do_comprehensions_for/de4rk8i/
Thanks, I'll see if I can create a repro project for you and create an issue later today.
[removed]
[removed]
`Node!` means the method is non-Kotlin so there's no guarantee that it's nullable (`Node?`) or non-null (`Node`).
[removed]
`T!` is a so-called platform type; the Kotlin compiler has no way to know whether it can be `null` or not. This is the case for all unannotated Java code. Platform types cause the compiler to simply ignore the fact that a value might be `null`, pretty much analogous to how Java handles variables. If you are in control of the Java code, add `@Nullable` and `@Nonnull` annotations to methods and parameters; the Kotlin compiler will treat those as though you had specified `T?` or `T`. When using values from Java code that should always be non-`null` you can add `!!` to an expression to let the compiler verify at runtime that a value is not `null`. private val serviceMock = Mockito.mock&lt;Service&gt;()!!
Thanks for the explanation. This is the first thing about kotlin, that feels weird to me. Actively, having to think about, if I am calling a kotlin method or java method. 
Without compile time type checking I see little use for this, id much rather create a data class
&gt; But it's still way better if performance is unimportant. Very true, but it's worth mentioning as a use case. A (perhaps misguided) example: I do hobbyist game development , and it's common to use an `Int` primitive as an ID, and these IDs are referenced thousand times per frame. I've started using `ID` as a typealias for `Int`, which is a nice way to document intent without extra overhead. &gt; Kotlin will also afaik get value types in the future which will remove the performance overhead Agreed! I'm pretty excited about this actually. 
You don't really need to think about it. You only need to think about if a Java method can return null or not, which you must do anyway (even in Java). Kotlin has no way of knowing which Java methods return null and which don't and always assuming nullable values would be too annoying.
Nice! Finally :)
Is this the standard troll on Kotlin posts now?
[removed]
The official support for javascript scares me. 1. Javascript is already a cool and established language so why write in another language to compile in JavaScript. (Dart and Typescript are not getting that traction) 2. GWT previously tried to compile Java into Javascript. And failed miserably. Nothing good was ever written in GWT but legacy stuff 
Kotlins JavaScript support does not try to translate the whole java standard library like gwt does, it is significantly lighter. It also makes integration with js libraries easier than gwt. The idea of a single, statically typed language powering the whole stack and still getting the best of both the js and java ecosystems on front- and backend respectively is very appealing. That said, I agree there are issues with kotlin js support. JS API integration could be better (though this was improved in 1.1 and I have not tried this yet) and build system support is lacking. But it is definitely worth trying and I do not believe it is holding back the language much. 
It seems to me like always assuming nullable values, unless annotated otherwise, would make the most sense. Any idea why that's not the case?
Maybe look into ClojureScript / Elm instead of GWT. The world has moved on.
Even scarier, Jetbrains are trying to maintain a Kotlin native branch at the same time. Talk about spreading resources thinly at a crucial juncture.
The wicked smart Scala community has devolved into a bunch of petty trolls. Sad!
Yes, it's this way so that you can refine the nullability AND so that you know that a type's nullability has not yet been annotated. Everything-can-be-null is one of the the biggest failures of Java, not something you want to repeat. Though Java is trying to migrate to a fix with @Nullable and @Notnull. If you want everything from Java libraries to be nullable, you can simply treat them as such. But since you think this is an upgrade, it doesn't seem like you realize that nullability is somewhat uncommon in APIs even if Java would allow null values.
Because Java methods aren't annotated and most methods don't return null. Like all the new file and time and date api almost never returns null, a lot of the collections methods never return null and so on. Having to use !! everywhere would be annoying and would teach wrong habits. 
Technically primitives can't be null :). The Platform type is a small price to pay for java-interop. Another option would be to generate a compiler warning, whenever you are assuming a plattform type can't be null. But that does not seem too useful.
You probably could've hit 'invalidate caches", unless you didn't update your dependencies properly
But then you have to use Elm\Clojure... Here you can just use kotlin and you're good.
I can get behind the idea that people using !! everywhere would encourage bad habits. Thanks for the rationale!
Use the [no-arg plug-in](https://blog.jetbrains.com/kotlin/2016/12/kotlin-1-0-6-is-here/) (look for the string "noarg"). 
 class MyTextView: TextView { constructor(context: Context, attrs: AttributeSet, defStyle: Int) : super(context, attrs, defStyle) { // ... } constructor(context: Context, attrs: AttributeSet) : this(context, attrs, 0) {} constructor () : super (null,null,0) } Kotlin can't have both primary and secondary constructors when extending a class that lacks a non empty constructor. Edit: Using default parameters is more idiomatic. The above can become class MyTextView(context: Context? = null, attrs: AttributeSet? = null, defStyle: Int = 0): TextView(context, attrs, defStyle) {}
Although correct, no View _ever_ should be initialized without a context. Every View needs a context. Your app will crash if you allow this view to be initialized with no or a null context.
&gt; To be honest, I find your example to suffer from poor readability. No worries. Not my example; just grabbed it from the Swift documentation. :) I can sympathize with your poor readability argument but say I was doing something like this: findUser(id)?.let { getPhotosForUser(it)?.let { findMostPopularPhoto(it)?.let { // do work return } } } // did not succeed so handle error I think this would be more succinct to write with a Swift-like mechanism where there is a single block for success and another for the error-case. My example doesn't really let you switch on where the failure is so perhaps it's not totally practical. Anyhow, definitely not trying to start a holy war; was just curious about it since Swift borrows a lot from Kotlin. Thanks for sharing! :) 
Oh nice!!
True, but with less pleasant syntax.
Also, some libs have seperate artifacts so you don't pull in Kotlin unless you want it
[removed]
Also take a look at the elvis operator. You could rewrite the code like that: val user = findUser(id) ?: return val photos = getPhotosForUser(user) ?: throw Exception() //you can throw an Exception too if needed val mostPopularPhoto = findMostPopularPhoto ?: return
Just to start off the thread, the first non-async thing I can point out is the GeoIP library itself. I am still not sure what will happen to my coroutine when GeoIP library goes for disk IO. I am also not sure if the File object itself will yield the coroutine or will it block the thread forcing rest of coroutines to be scheduled on other threads (possibly causing more threads to spinoff). 
What exactly do you mean by "not all Java libraries work with Kotlin"? Which libraries and what issues do you mean exactly? We (the Kotlin development team) are not aware of any libraries that don't work.
Mockito gave me some trouble (http://stackoverflow.com/questions/34773958/kotlin-and-argumentcaptor-illegalstateexception/35100208#35100208) Also kotlin properties can't implement getters and setters defined in Java interfaces makes migrating existing Java code more work. All the Java interop issues I encountered had workarounds, but made it feel like 99% Java compatible, rather than 100% :)
Those look as static methods
[removed]
For those wondering: &gt; Kobalt is a build system inspired by Gradle and Maven. It reuses the best concepts from these two successful and popular build systems while adding a few modern features of its own. Kobalt is written entirely in Kotlin and its build files are valid Kotlin files as well. Thanks to IDEA's top notch support for Kotlin, writing Kobalt build files automatically benefits from auto completion and all the other features that you are used to when writing code with your IDE of choice. Features &gt;Clean, minimal syntax for build files &gt;Build file auto-completion in your IDE &gt;Incremental tasks &gt;Intuitive plug-in architecture
You should solve the Kotlin Koans. After that, if you are trying to solve a problem, google for the solution in Java and translate and optimize it, if you want to write something yourself, else just adopt it (Kotlin has very good Java interoparability). Kotlin Koans: https://kotlinlang.org/docs/tutorials/koans.html
Wondering how many people are using it in production? 
I'm surprised i++ doesn't work
Create a range, filter its items based on the condition, then apply forEach on the remaining items.
Yep, this seems to be the solution. Thanks!
you can actually hear it if you concentrate a bit
I find automatic update a bit scary... usually I wouldn't update to the latest alpha/beta/RC version. so, in Maven, I would use "mvn versions:display-dependency-updates", and then modify the versions manually. Unless they are minor x.x.v version updates, I would even run each regression test for each single library update. I have seen so many weird bugs related to library updates, that I would never use an automatic one (unless it can automatically avoid alpha/beta/RC versions, and re-run regression suites automatically for each library change) 
What does context composing do?
Just found out this list: https://kotlin.link/ I assume it somehow reflects the libs adoption 
Me either. It's a nice feature.
+1 for Spring Boot. The additional Kotlin stuff in Spring 5 will be nice, but Kotlin is also very usable with the current version of Spring Boot.
Talking about when, is there a good workaround to do fall through?
You can generate a Kotlin project using Spring Data JPA and Hibernate right now and have it working basically out of the box. Use Spring Initialzr to generate the project and pick Kotlin and read this: https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin
This look real good and its by the GreenORM guy so i may give it a go.
https://github.com/greenrobot/ObjectBox/issues/9 hmmmm
Would very much like to see the list monad implemented in a similar way.
Yea. We know.
Looking at the code it looks like kotlin should give you some warnings when you compile. Is that true?
That's not strictly true - data classes are a little special because they're final, which goes against Hibernate's [recommendations](http://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#entity-pojo-final). It means Hibernate can't perform lazy loading (something you might be relying on!) because it can't proxy the entity class. Though you may be able to get it to work with the new bytecode enhancement features instead.
I've been using it for over 1 year. Before 1.0 there were some bumps on the road but benefits outweighed them. If you're not using spring or android, you'll love Kobalt. If you're using Android and can help maintain the plugin, you can have a nice solution.
Hey all, we're actively looking for contributors to the project. Kweb is easily extensible but there is a lot of work to be done (see [here](https://github.com/sanity/kweb/issues)). If this interests you please drop by #kweb on the kotlin slack (see [here](http://kweb.io/contribute/community.html)).
This looks really nice. Is there a more "real world" example? Like user login + database interaction, like a blog or something.
Not yet I'm afraid. Kweb doesn't tie you to any particular persistence layer, but we do need to establish some recommended patterns to handle things like auth and persistent state, perhaps taking inspiration from React or other frameworks. Kweb is particularly well suited to keeping state synchronized between client and server in realtime, which makes it easy to do the kind of realtime updates that you see in websites like Facebook. But we need to establish good patterns to keep client DOMs in by-directional sync with (possibly persistent) server-side state, in a way that is modular and composable. The best way to do that is to actually build stuff on top of Kweb and experiment with different ideas, which is what a number of us are currently doing.
Thanks!
An important one is missing: The builder pattern.
Builder pattern does not cope with verbosity. Especially in that case. Plus it is quite tedious to create proper builders without relying on external tools such as Lombok. 
I added it :-)
I do not
How is your dependency on the library configured?
Why isn't it KotlinCon? Conf is used more for configuration
Because it's a conference and not convention.
Or KoCo
I see where you are coming from. I still believe Kotlin has too good a momentum in the community now. At least this will not lead to the Android community discarding Kotlin in favor of Java 8, if that is what you fear.
You may need a build tool. If you use an IDE (IntelliJ or Eclipse), they handle the builds. But I'm using sublime and the command line, so I've had to learn some [gradle](https://gradle.org/)
People have been able to switch to the new Java on Android for a year, using Jack. During that year, the adoption of Kotlin has increased significantly. I'm not sure what changes now.
I already have IntelliJ, and have it set up for Kotlin, I'm more looking for guides that are oriented​ to learning Kotlin coming from Python
Transpiling Kotlin to JS will not give you access to the Android APIs on iPhone.
because it is Java?
Oh gosh. For the same reason that functions in Kotlin are called "fun" and not "func" or "function" or "fn". Because we like that name.
that's very true... what I tried to mean is that, once your business logic is in Kotlin, switching to another API (eg, Ionic vs Android native API) should be easier than supporting the same app in two different languages (ie, Java for Android vs whatever is currently used now for iPhone)
Because Kotlin is fun not sad! Yes I realize my question was kind of stupid...
In case anyone is wondering where this is going, the idea is to allow something like [this](https://www.youtube.com/watch?v=0Q-BUldFZjA) but with [Kweb](http://kweb.io/).
Because it's safer and (most) companies hate risk. 
I still like kotlin better for those reasons and now it too can be updated for Java 8 hopefully
You could already build react native apps on kotlin. Not that I tried but kotlin to JS works surprisingly good for node.js projects. 
Kotlin Native? Do you have a link with more info on this? I haven't heard of it.
I plan to stick with Android for a while, and I hope to never write Java again. I have the hope that when I change jobs I can either lead the team and thereby choose the language, or make a compelling argument to the team lead in favor of writing all new code in Kotlin. And updating legacy code as tech debt. The one thing missing from the above advantages is complete interop with Java code. They fucking nailed it. Your argument is not unreasonable: many projects in production right now can argue that introducing a new language should not be high priority. But I think Kotlin and Clojure are the best things the JVM has going for it right now, and there aren't enough good reasons to choose Java 8 over Kotlin in any new Android project.
There was always going to be a solution for Kotlin + Jack, an interstitial gradle step that reconciled the bytecode.
Actual JSON parse works good: unspecified fields should have default value. You should write your own JsonParser to support your semantic.
We still don't know exactly the details, but they recently created the kotlin native channel in slack http://slack.kotlinlang.org/ Some people found this document on gist, it's few month old, and it's written by a guy from the native team https://gist.github.com/abreslav/217e1f960b52c8b77bebf58ed1ab299b
ok, I've read your post like 5 times and now I get a problem. Check solution below @JsonIgnoreProperties(ignoreUnknown = true) data class SomeObject @JsonCreator constructor( @JsonProperty("someField") val someFieldNullable: String?) { val someField: String = someFieldNullable ?: "default_value" }
I don't quite get what this accomplishes. There is already listOf which constructs an immutable list, where is the difference? 
Came here to ask the same :) Ahh, there's some information linked in the announcement: https://github.com/Kotlin/kotlinx.collections.immutable/blob/master/proposal.md
Are you using the latest version of `jackson-kotlin`? I haven't had any issues with using default values on mandatory properties. The biggest downside to using Kotlin with Jackson is that it fails fast - as soon as your JSON has one missing field (for a mandatory property without a default) then deserialization fails, unlike with Java where everything is nullable, so bean validation can detect multiple missing properties. There's an open PR which might help with this: https://github.com/FasterXML/jackson-module-kotlin/issues/58
Ah I see, I thought those were immutable already :) 
I am very excited about this. This is one thing I loved about Clojure and Immutable.js. Yes, Scala and other languages have them, but I have not used those languages (much). Woohoo!
No, it makes a simple list that you can't alter. ArrayLists are mutable. That's the main difference between `listOf` and `mutableListOf`
My understanding is that for small collections, the persistent versions are too heavyweight for the job and don't necessarily save you time. Maybe I'm wrong and they'll make `listOf()` default to the immutable/persistent versions in the future. 
Well the brilliant thing about listOf et al is that they're functions! I can hope... Or maybe just submit a PR...
The problem is you can alter it if you cast it and the bigger problem is, that a class/function that gets this List as an argument has no way to decide if it really is a immutable one (there is no specific interface implemented that would indicate that), so if you want to implement an immutable class containing a list you always have to create defensive copies which defeats the purpose and is bad performance wise.
I'd assumed that the immutable collection types were already PCollections or something like them under the hood - surprised to find they weren't!
Making something a kotlinx package doesn't increase the size of Kotlin's runtime in any way. kotlinx packages are optional and not included in a project by default.
I think Kotlin's greatest point is Anko. I (personally) hate Android XML GUI design (especially for not-huge projects).
But then won't readonly collections suffice?
Great, but that still doesn't answer my question. If you do not mutate a mutable list once initialized - what is the difference?
MutableCollection requires synchroniaztion in multi-thread context. Collection should be used "safe" in multi-thread context. Immutable Collections are "always" safe in a multi-thread context. Moreover Immutable Collections can be more optimized.
Nice use of type alias. I expected alias to clean up some function signatures but using it to provide an alternative name for constructors is neat.
Mokito in production?!?
The difference is that immutable collections perform better than readonly collections. For example, to append to a readonly collection you have to copy everything, whereas for an immutable collection you share the same elements and structure as the original collection but there's no danger. If you ever work your way through the FP in Scala exercises you get an idea of how a simple immutable list works early on and a lightbulb should go off: https://github.com/fpinscala/fpinscala/blob/master/answers/src/main/scala/fpinscala/datastructures/List.scala
The difference is that immutable collections perform better than readonly collections. For example, to append to a readonly collection you have to copy everything, whereas for an immutable collection you share the same elements and structure as the original collection but there's no danger. If you ever work your way through the FP in Scala exercises you get an idea of how a simple immutable list works early on and a lightbulb should go off: https://github.com/fpinscala/fpinscala/blob/master/answers/src/main/scala/fpinscala/datastructures/List.scala
\* Used for testing in a code base that's been in production.
I'm not sure about the performance of Scala collections or if they're even implemented as persistent immutable data structures or just read only, but it doesn't really matter. I was just linking to the FP in Scala example because it's simple and illustrates the basic concept of data sharing and how it can be a performance improvement for some operations. PCollections, which is what the Kotlin implementation is based on, has favorable performance characteristics compared to traditional collections when appending, removing or updating elements because it doesn't need to copy anything. Just consider these an idiot-proof, always safe for concurrent use, and faster in some cases, set of collections. Not everybody will need them, but they're handy when they fit your use case. If they remained an auxiliary library I wouldn't be surprised.
That looks pretty good… …except for the underscores. Every style guide for Java bans underscores into the realm of capital-letter constant names, and for good reason (their ugliness). Please don’t make Kotlin look like C. :)
Why couldn't this just be an enhancement and implementation detail of the read-only collections. Collections already have a "plus" extension function that provides a returns a new read-only collection. Just make it use pcollections under the covers. Why a new package and set of interfaces?
QueryDsl didn't understand Kotlin classes iirc, so we ended up using a DSL over Criteria API (https://github.com/consoleau/kotlin-jpa-specification-dsl) Spring boot required classes and methods to be declared open. I think this is fixed now with version 5 (https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0) Not being able to implement Java getter/setter methods using Kotlin properties. (http://stackoverflow.com/questions/29268526/how-to-overcome-same-jvm-signature-error-when-implementing-a-java-interface/35100736) Had some trouble porting some Java code that was overriding Enum.name. I generally tried to stay away from frameworks that do a lot of reflection or dynamic byte code generation. Kotlin provides better compile time abstraction capabilities making many uses of very dynamic constructs unnecessary. 
Also, Marshmallow(6) was the last big Android release **without Java 8 support** and a lot of hardware (e.g. Samsung and Sony) will be stuck with Android 6 for many years to come, I bet 5 at least. Just look at the adoption rate of Android 7, it's not such a big deal for consumers and brands to upgrade the phone from Android 6 to newer versions. That is a long time to wait for the limited features of Java 8 to be standard, compared to Kotlin available today.
The first could possibly be "simplified" to this. I don't know that I would do so though, as it might be less readable. The third could have something similar done to it, but not the second. @Test fun assignmentAsResultOfIf() { val newSearch = false val searchQuery = "leonardo &amp;&amp; raphael" val res = (if (newSearch) searchNew else searchOld)(searchQuery); assertThat(res.type).isEqualTo("old") }
Everyone has a testing environment, some are just lucky enough to have it be different from their production environment ;) 
[http://vertx.io/](http://vertx.io/) is a great library/framework with a lot of that already built in. I've used it for basic rest services.
Netty my dude https://netty.io/
Kotlin does not have language support for threading, you need to do it through libraries. Your standard Java libraries will work fine. E.g., you can just make your class extend `java.lang.Thread`, implement a `run()` method, and then call `yourClass.start()` to start the thread, like you usually would in Java.
thanks will have a look
will have a look thx
cool thx
thanks for that
Cool, gonna check it out 
I don't think it's ready just yet, the documentation is lacking. Did you start this from scratch or just wrapped around an existing JS library? By the way, a Kotlin equivalent to LibGDX would be nice - write once, deploy to mobile, desktop and web using Kotlin JVM/JS compilers. I wouldn't mind contributing to a project like this.
I'm getting error on Tetris example http://pastebin.com/9BEpsBiD
thanks for the lead! I've thought about publishing my extensions, but I'd rather contribute to something already in the works. 
GWT cannot compile Kotlin sources, so you cannot target the web with Kotlin + LibGDX. An engine written 100% in Kotlin - without any JVM-specific parts in the core library - could be easily compiled to JS. That would be the main advantage, I guess. Debugging GWT is a pain, the compile time is a joke, the errors are often cryptic and it doesn't always work smoothly on each browser - so you just kind of compile your LibGDX application and pray it will work. I wouldn't mind having a pure Kotlin alternative to that. Also, the Kotlin Native might be a superior to RoboVM, MOE and other projects when it comes to iOS support. Hell, it might be better for desktop applications as well. Anyway, a lot of LibGDX APIs beg for a rewrite - lack of proper interfaces, public fields usage, poor modularity, reflection overuse are only some of its issues. There's a lot of legacy code, and it really shows once you get past the simple game examples. I still think this is the best game framework in the JVM ecosystem out there, but I'd say that refactoring some of its APIs might actually be a good thing.
You must be using a very old browser. But no worries, I started up windows and got it working on IE11. I hope that solves your problems. Thx for the heads up.
Doubt it. I might be wrong, but it seems that the main contributors and maintainers are not as active as they used to be. A rewrite to Kotlin would mean a _lot_ of work, but also breaking most of the existing applications and losing most of the users who just wanted a _Java_ game framework. It might not be worth it from their perspective.
And I don't want to sound condescending to using a "Java style" in Kotlin. It's still great, since most people are just trying to mostly get the painless null safety which is really, really nice in and of itself. I just like to point out that there are these subtle features like class and property delegation, that when used, can actually make things easier to debug, or remove direct framework dependencies, etc. Kotlin projects can be much "cleaner" which makes them wonderful to manage at scale.
Since nobody has replied (and I don't know the answer), I suggest asking in #dokka in the [Kotlin Slack](http://kotlinslackin.herokuapp.com/).
Please do not extend `Thread`. Instead, implement `Runnable` and then call `new Thread(runnable).start()` to start the thread. Or even better, use an `Executor` or `ExecutorService` to automatically manage threads in pools.
Yeah, that's probably a better idea. Edit: Pinging u/Apfelmann for visibility.
What is a proper REST abstraction?
An API that reflects key concepts of REST is a proper REST abstraction. JAX-RS, for example, has the concept of a resource, what is essential in REST. Another example is proper support for content negotiation and data conversion. Take a look at the [Jersey documentation](https://jersey.java.net/documentation/latest/index.html). 
Then we do have a **proper REST abstraction**: - http://jooby.org/doc/#routes-mvc-routes and here is a Kotlin example: - http://jooby.org/doc/lang-kotlin/#kotlin-examples Even more, we do have a [tool](http://jooby.org/doc/spec/) for APIs. This tool can export your application to [Swagger](https://github.com/jooby-project/route-spec) or [RAML](https://github.com/jooby-project/route-spec). 
The Java API looks decent. Actually I like it better than the Kotlin counterpart although I like Kotlin much more than Java. I prefer, for example, to have a resource class and no [route group](http://jooby.org/doc/lang-kotlin/#kotlin): route("/api/pets") { get {-&gt; // List all pets } get("/:id") {-&gt; // Get a Pet by ID } post {-&gt; // Create a new Pet } } How do I perform content negotiation with this API?
Taste mostly. On small apps I prefer the *script* programming model. Medium size apps? use *script* for UI rendering and *resource* for business logic. Content negotiation looks like: ``` Results .when("text/html", () -&gt; Results.html("viewname").put("model", model)) .when("application/json", () -&gt; model) .when("*", () -&gt; Status.NOT_ACCEPTABLE) ``` It is documented [here](http://jooby.org/doc/#routes-content-negotiation)
So does this mean we can use kotlin for iOS development?
Coming soon. 
Yea... I want the version they are going to release in two years now!
omg, can't wait! :D
True. I didn't realize that Kotlin had a full wrapper around the Java package tho.
kotlintest's related repository is **[lambda-behave](http://github.oldjpg.com/repository/20582138)** &gt;A modern testing and behavioural specification framework for Java 8
It uses LLVM garbage collector Edit: https://discuss.kotlinlang.org/t/question-concerning-kotlin-native/1875/6
I think it'll be pluggable to use either Ref-counting with cycle detector or a particular GC. Nothing official on this though. 
Actually, Kotlin has not a full, but a partial wrapper, only most generic things collections, sequences, text utils and types system. As Andrey Breslav said on Kotlin Event they don't want to include all JVM features to stdlib
How does that compare to JVM one?
Does this get them in any patent troubles with Oracle? Like the patent issues Android has been facing.
Almost official comment from Breslav about memory management https://youtu.be/QQKdFFRqamg?t=5457
Wow thats amazing. That seems like exactly what you want.
Would it use Cocoa APIs for OS X? Or would it use an abstraction layer like Qt/Gtk?
Why use a sealed class instead of a Kotlin data class to represent an optional?
Sealed classes allow for exhaustive checking in `when` clauses, which ensures that both branches of the optional (`some` and `none`) are handled. If a branch is *not* handled, we'll get an error telling us that we've forgotten a case.
They already said it multiple times, they hired a complete dedicated team for Kotlin Native, so progress of Kotlin as a language won't be affected in a negative way
:O!
Who said they work for free, i start to believe you are just a troll
This is only the case when the when is being used as an expression (returning a value) FYI
Blogspam isn't appreciated.
Looks like a pretty solid guideline to me. Only thing I noticed was that the Leverage Value Object example would be better solved with type aliases.
Good article. But, I would rename the section "Destruction" to "Destructuring" 
I think the term is "destructuring", not "destruction". Good article though.
Agreed. Helpful and nice reading.
So, I've worked with both. Scala's syntax isn't cryptic or hard to read, but it does support features (higher-kinded types, typeclasses via implicits) that do have a learning curve. You don't need to understand those features to be productive in the language, but I've found that understanding them has made me a *far* better programming. On a day to day basis, I've noticed that I don't really need frameworks like Spring or Hibernate—certain ideas are just easier to express. I think the the problems you describe is a problem inherit with FP, not Scala. I think that as a community, we can do better in teaching. Languages like Elm are great examples of languages that introduce functional programming in an accessible manner. One more thing—you're completely capable of learning functional programming! You already program! Plus, the ideas of functional programming are remarkably simple (that are dressed up in fancy mathematical language).
I'm with the author on their Value Objects example. Type aliases are great for hiding long class names or types with generic parameters. They weren't intended for basic data types.
Oh, good to know! For what it's worth, I think pattern matching is best used in its full potential in an expression context anyhow!
No source, but look at any story like [this](http://beust.com/weblog/2014/06/02/swift-apples-new-language/) from when Swift was introduced and observe that every single one of them mentions Kotlin, the fact that Kotlin is 3-4 years older than Swift, and the fact that both, as you say, are designed to have interop with a more verbose, older language. Sorry if you interpreted this to mean they share any implementation; I very much doubt this. Especially since Kotlin compiles so much faster than Swift. However Swift's syntax is clearly inspired by Kotlin.
Store your values as Double so you don't need to convert when you call the other library?
If it's a method you use a lot, you could always write an extension function that takes a double and calls the int version for you. fun ThirdPartyLib.theFunction(value: Int) = this.theFunction(value.toDouble()) 
I don't understand this syntax: a + b shouldBe result Is this a function call? Can I write it as shouldBe(result, a + b)? How is shouldBe defined? What is the name of this construct? I'd like to read more about it.
Cool idea, thanks!
I would cringe if I saw this in a code-base. :)
So if I've understood things correctly, this won't also "convert" 3rd party dependencies to native, meaning if I depend on let's say Guava then I can't compile to native and run it outside a JVM right?
You're right, compilation just for kotlin code 
just joking: one could recursively convert all java dependecies into kotlin and then try to compile)))
Might just be crazy enough to work! 
I need the !! always for getting values out of maps where i know the key is present at the time to avoid ?. afterwards. val value = map[key]!! val x = value.a.b.c Somebody knows of a clearer way to do this?
https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/get-value.html
nice, thanks. NoSuchElementException &gt; KotlinNullPointerException too. 65 occurrences... thats manageable 
&gt; Kotlin/Native can compile your Kotlin program into native executable, thereby completely eliminating the need for Java Virtual Machine. Beautiful! &gt; By leveraging LLVM, Kotlin/Native compiles a Kotlin program into a self-contained executable for iOS, macOS, and Linux (Windows support will be coming later). macOS? How? What kind of UI controls it uses? I'd love to make macOS apps with Kotlin. Pointers please! Kotlin will take the programming world by storm and I want to be ready for the deluge.
&gt; You'll have to interface with the native libraries for UI. How? Any link to a simple program? I'll do the rest. Thanks.
https://github.com/JetBrains/kotlin-native/tree/master/samples straight from the post. Couple of examples of using native libraries (SDL and opengl)
This is awesome.
I can't tell you how popular it is, but it's definitely there. We use it as a Java replacement in the back end.
Change `val` to `var` for the field(s) you want to modify (in this case `lives`). Then just do: `players[0].lives--`. 
I work devloping backend services and after introducing Kotlin a year ago, about 80% of new projects are written in it. No android in house either. We treat Kotlin like the best version of Java.
We use Kotlin for both Android and non-Android development. Kotlin + Spring works awesome.
Ah, yeah, thanks for the correction. I kind of jumped the gun replying immediately, but these threads seem to get overtaken with "can ah write a mac app and run it on the androidz" sort of thing. Just wanted to try to redirect the flow, so to speak. 
Neat! I hope this turns out well and they do this in the future
Were end-exclusive ranges in this poll?
This already exists in the form of `until` infix function (e.g. `0 until 10`).
That's just a shorthand for `0..it-1`. The ranges are still closed. That's why there is no `until` for Float, Double and no generic Comparable version. I am quite disappointed by Kotlin's choice of inclusive ranges as they are clumsy and unconventional. `[a,b)` ranges are as fundamental as 0-indexed arrays and it was the first thing Djikstra established in his famous [argument for 0-indexing](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html).
I wish they'd implement most of the proposed changes, to be honest. Not sure about static members and access to private members, though. Package-level functions seem to do just fine when it comes to "static" methods and access to private variables/methods seems like an excuse to write poor API, which is hard to test otherwise. Inlined classes with a single variable aren't much better than extension methods + aliases. I wish they'd expand aliases syntax so that it would allow to write more type-safe code instead of just basically renaming existing classes with no compile-time checks whatsoever. SAM conversions suffer from the same problem: seems like aliases to regular functional types would be enough to solve the issue. Don't create your custom `Action` interface, rename `(Event) -&gt; Unit` instead. Ability to add extra methods is not an excuse, since you'll likely break existing API either way.
coroutines are great for c100k problems, especially when you have a lot of nested asynchronous calls within If-else.
Obvious question, but why this over the official slack? Do any JB employees go here? 
This is not over the official slack, it is just for people that use/love discord and want a community over in this network. I highly recommend going to the official slack as this is not associated with JB in any way, it is only a community. We came across a lot of kotlin enthusiasts all over the discord api programmer communities and thought this would be a nice concentration of people and a good environment to learn and share
It is my understand that by having mutable field the class itself is then mutable. In any case it does make sense. I guess in the future I will have a User class and then some mutable class within it which will contain lives and number
Take it a few steps further, though, and you hit Haskell's [Quickcheck](https://hackage.haskell.org/package/QuickCheck), which is an absolutely amazing tool.
Littleodie914, yes, i agree with you. The real use is to use that data to fill your objects instead of putting: "abc", 123, "lalala", etc. About Quickcheck, we plan to create something related to Quickcheck, stay tuned! And thanks for your comments.
Kotlin in action is good. But it is not Android specific. And also agree with the other redditor that the official documentation is really good and more beginner friendly that any Java docs I've seen. 
I don't think so. You can find most Kotlin highlighters and plugins at https://kotlin.link/ under "Syntax Highlighters" and "Editors" sections.
To be honest, I'd use such editors only to quickly view Kotlin files from outside of my projects. Nothing beats IntelliJ in terms of Kotlin support.
Mine's pretty much like that, except I put the closing parenthesis on the next line for consistency: class RxDriveApi( apiClientDescriptor: ApiClientDescriptor, vararg scopes: Scope ) : RxPlayServicesApi&lt;DriveApi, Api.ApiOptions.NoOptions&gt;( apiClientDescriptor, ApiDescriptor(Drive.API, Drive.DriveApi, null, *scopes) ) { ... }
Class header formatting is covered in the [Coding Conventions](https://kotlinlang.org/docs/reference/coding-conventions.html#class-header-formatting) section of the kotlin docs. I was surprised to see it suggests putting each interface on a new line - I don't do that. FYI there's a [Kotlin Style Guide](https://github.com/yole/kotlin-style-guide) project in progress which addresses this [issue](https://github.com/yole/kotlin-style-guide/issues/2) - it's still open so I'm not sure what that means. I believe typically the issue is discussed here before moving to the coding conventions page. I don't use do android development, but I typically use the format in your last example (with parenthesis as in dodoburd's answer) - that single blank line seems to really help.
Hungarian notation in Kotlin makes me sad.
You can install openjdk on Raspbian (or maybe it was already there, I can't remember), and then anything that is compiled to JVM byte-code will run there. I have a project I'm working on that is written in Kotlin and uses a library that lets it interact with the GPIO. So yes, Kotlin + RPi works fine.
Hungarian notation in general, honestly. With an IDE like IntelliJ (or really any IDE...) the syntax highlighting makes it abundantly clear whether an identifier refers to the class's field or to a local variable. If another program (e.g. repository web page) being used to view that code does not make that distinction, I see that as a shortcoming of that program and not of the programmer's coding style...
I think he is just using CSFML which are the official C bindings to SFML. 
Oh ok thank you
i use "constructor" keyword: internal class ImageAdapter : RecyclerView.Adapter&lt;ImageAdapter.ViewHolder&gt; { private val mParent: AppCompatActivity = mParent private val mAlbum: PostAlbum = mAlbum private val inflater: LayoutInflater = LayoutInflater.from(mParent) private var mParent: AppCompatActivity? = null private var mAlbum: PostAlbum? = null constructor(mParent: AppCompatActivity?, mAlbum: PostAlbum?) : super(){ this.mParent = mParent this.mAlbum = mAlbum } }
It's the reality, though. Code is viewed in many more places than your IDE, e.g. web browser, diff tool, even shell terminals. There is some value in putting hints of what a variable does in its name, for example the convention of using `i`, `j` and `k` as loop indices. Another good example is when you have multiple types to represent the same value, for example a name: `name` as a `String`, `nameTf` as the text field that holds it, etc... There is a correct way to do Hungarian notation, and [Joel Spolski captured it very well](https://www.joelonsoftware.com/2005/05/11/making-wrong-code-look-wrong/). 
This is an excellent intro to what's actually there. In the past I've felt there's been a bunch of confusion as to what Kotlin Native really will let people do, and some have thought of it as something like another "multiplatform application dev kit". I'm pretty sure after reading this you won't be asking questions like "so my android app will run on windows now right?" Anyhow, I'm excited for when I don't have to fumble with my text editor so much and IntelliJ just knows what to do. 
Side note, why would you ever pass the adapter a reference to the activity? You have a ViewGroup in onCreateViewHolder to get a context from. I think the less code that has strong references to your activity... The better.
That would mean the primary constructor is an empty args constructor. Not that I'll make the mistake of using that, but this is just one example of a problem that may arise beyond the situation I showed
https://kotlinlang.org/docs/reference/exceptions.html Do the same thing you do with if statments? 
The braces are required, actually and sadly. I'll keep it outside the constructor just to avoid it being too verbose, but it's kind of a toss-up. edit: After a 5 second reflection period, I've surmised that the braces are intentionally required because ignoring the results of a `catch` block is generally considered a Bad Thing. JetBrains doesn't want to make it *easier* to do something that could bite you.
Everything in Kotlin is an expression, which is an incredible feature :)
Very elegant. I've yet to write an inline function, seems like a good time to start though. 
Exception: assignments seem not to be expressions. No such thing as val x = this.y = Foo() Sure, you can use apply, run and co, but I sometimes missed something like this :/ An example is something lazy that needs to be initialized on the first access but depends on some input parameter. return (this.x ? this.x = X(y)).bar
I think the reason for this is syntactic ambiguity with named parameters. And, well, the fact that it's often considered bad practice. 
Why can you only obtain the value inside `exec`? Why can't you just return it? Can you give us a bit more about the way it works? 
It could, and I considered that - but for my use case they may need to return several values - so that would get cumbersome (i'd probably need to wrap in a data class).
I honestly think that this isn't good design, these assignments in a dsl look confusing. I'd opt for another design, for example building the dom simply without assignments and then later get the objects you want with a simple query language. Or assign ids to your objects in your dsl and later fetch them using a hashmap or whatever with the id as key. 
Either of your suggestions would work, but now you're dealing with querylanguages and adding a lot more complexity. I've been playing with `new {}` returning the value returned by the closure. So far in my experiments this seems to look ok.
Inspired by the same Installcert java util but written in kotlin with some enhancements.
`lateinit var`? 
Noticed the same behavior. Although it works sometimes if you hit Ctrl+Space after pressing dot super fast.
How I'd design around this is by defining `para` ahead of time, and then providing a way to attach an element at the current location: val para = p().text("This is a paragraph") doc.body.new { div().new { h1().text("This is a header") attach(para) } } div().new { val anotherHeader = h3().text("this is another header") doStuff(para) }
To return several values, one can actually wrap them in an anonymous object: val xs = 123.let { object { val x1 = "$it"; val x2 = "$it".reversed() } } println(xs.x1) println(xs.x2)
Depends on which framework you want to use. If you want kotlin written libs then Wasabi is your best bet, but it is still a tad immature. Otherwise you can go and use Java written frameworks like Jetty. It is fully viable.
Ah, nice - I thought that only worked if the object was declared at the class level, I didn't realize you could declare one locally.
Thanks. The work team doesn't know neither js nor kotlin, so no preference. But anyways js has a better ecosystem for the frontend. So maybe we'll have to split teams. Or do everything in ts. 
I like Kotlin a lot, but I do front-end development at work and I'd definitely stick with JavaScript/TypeScript for now on the front. I haven't seen anything particularly compelling otherwise. For the JVM there's no question, but for front-end I don't see it. 
Ah, very interesting idea, particularly now that local variables can have delegates as of 1.1. Thanks for the suggestion.
When planning your application architecture, you have to take into consideration your planned lifecycle, which would probably be 5-10 years for your distributed backend components, and 3-5 years for your frontend sections. Your objective would be to optimize for business feature delivery speed, cost of business use of the application, opex, and development capex. Your team size sounds like many dozens of people over those ten years. Because of this scale, you should pick technologies which are well integrated into their respective ecosystems, so that you don't end up dedicating a large part of your effort into building auxiliary support for your application development process, rather than concentrating on directly producing value.
Yes. And yes. That's exactly what I'm researching. I've used Kotlin on te JVM since the first milestones, mostly in Android. But I feel like it's green on the JS side. One of the concerning points of the research is the possibility of using one lang for everything. So I thought asking to people with more expertise is the way to go. So my conclusion is that Kotlin is a possibility only on the server side. I'm also considering TS, Dart, Go and Elixir. If you think I'm missing something I'd appreciate you pointing it out. Thanks! 
What means semantic highlighting?
https://www.youtube.com/watch?v=8WRH59PQ5Dk
&gt;[**Semantic Highlighting in IntelliJ IDEA 2016.3 [1:54]**](http://youtu.be/8WRH59PQ5Dk) &gt;&gt;See how your variables and parameters can be coloured to give you more information at a glance &gt; [*^IntelliJ ^IDEA*](https://www.youtube.com/channel/UC4ogdcPcIAOOMJktgBMhQnQ) ^in ^Education &gt;*^5,161 ^views ^since ^Nov ^2016* [^bot ^info](/r/youtubefactsbot/wiki/index)
Getting access denied.
"in" is also part of a for statement.
...Oh right.
Ya dun goofed!
Opera house makes any logo awesome 👍 The F# Sydney logo is similar (https://secure.meetupstatic.com/photos/event/6/1/4/6/highres_389784902.jpeg)
Also in works with every type that has a contains (extension) method, not only collections. 
Yeah that logo is awesome - you guys want to do one for Brisbane meetup?
Thanks, it will be fun! 
Not the same guy you're responding to, but I have used Vert.x and Kotlin together and written quite a bit of code using both... I don't like Vert.x anymore. Initially I loved Vert.x because of it's simplicity, async nature, and fully customizable architecture but as I wrote more and more code I realized I didn't need the async performance benefits and the way Vert.x wants you to structure your program to be async-first was in deep conflict with how I want to build and maintain services. I've switched over to using Sparkjava for the time being which for my use cases (lightly used utility services) is good enough.
I used Polychromatic in Xcode before they dropped the plugin support. Its a really nice feature and I miss it every day. Having something like that in Android Studio would be the best! I hope it can be tweaked as some of the colors are not very distinctive.
how will it be better than typescript?
At the bottom of https://github.com/libgdx/libgdx/wiki/Using-libGDX-with-Kotlin you can find three games written in kotlin using libGDX, altough only one of the games is a real android game (SplinterSweets).
Wonder if they can implement text shadows, so there are two colors per variable.
What does it say about me when i don't understand most of the points being made :-\
The main goal of Kotlin's frontend support is to allow you to reuse the same business logic code between the backend running on the JVM, the browser frontend, and Android mobile apps. For pure frontend development, Kotlin does not offer any strong advantages compared to TypeScript at this time.
I was the original poster of the gist, but I intentionally didn't spread it. I'll give some feedback though... &gt; He seems to prefer the code being brief and elegant over people actually being able to read his code and quickly understand it without issue I think you can have both and it's sad that you present them as mutually exclusive. If Kotlin required types be explicitly placed in function returns or var decls and I complained about that verbosity, I guess I would be chided that I don't care about readability. There is a level of pragmatism you have to apply. &gt; Dear Lord that is just terrible. I'm glad kotlin warns, that's just awful, increases complexity. There is a reason why most compilers for any language warn when this happens. It's more about scoping IMO. Most compilers warn when the scopes clash. In fact, Kotlin does let me shadow vars without warning as lambda param decls which is common. It is inconsistent to say the least. &gt; And the suggestion about having shorter stdlib syntax is useless to most people as well [...] This isn't "let's see how many characters we can reduce each statement to" language Sigh. You are misunderstand specific points with your hand-waving dismissal. I do not argue for character reducation and you don't see me requesting function name shortening or sigils or anything. I argue for consistency, reduced overload count, etc. There is a serious lack of consistency. I have one Kotlin dev telling me that they have shortcut-looking overloads where they can have specific optimizations, another saying they use the do-we-use-it-a-lot-ourselves test, and yourself telling me it's not about character reduction. Ug. Several different forms of map, some others of flatMap, etc. I did not point out every inconsistency in the stdlib, but there are a TON and it's frustrating because there is a lack of intuition. I was just giving this feedback as first impressions when writing a project.
Aside from preference, maintaining a file with thousands of lines is a nightmare.
I'm not entirely convinced that having the package in one file makes reading or navigating the code any harder. I think the opposite is true, actually. That said, I can see how bigger files could make PRs more difficult, and so I think you have convinced me that slicing it up is probably the better tradeoff. I'll report back here once I've had a chance to try this out.
Awesome. I'll pop in.
Definitely beautiful.
I'm curious as to what the performance penalty is. Could you do a JMH benchmark using your inline functions vs stdlib?
Great! See you there!
ITT: OP does not take code review lightly.
I've gone ahead and split the source files up. The largest is still about 600 lines, even after pulling out the private and internal nested classes. Thanks for your feedback!
From [this Stack Overflow question](http://stackoverflow.com/questions/42698001/what-does-header-keyword-mean-in-kotlin) it sounds like it's some internal thing, possibly the mechanism by which Java collections are wrapped by their Kotlin equivalents.
Here are some hints: http://stackoverflow.com/questions/42698001/what-does-header-keyword-mean-in-kotlin Nothing official tho, seems to be internal (for now?) for multi platform development. It makes sense from the linked Collection source from the OP, since those are Kotlin classes which might be interchangeable with the platform (e.g. Java) classes and compile time 
This has nothing to do with collections. It's a currently internal mechanism for writing multi-platform modules that can be referenced from both, kotlin on the jvm, kotlin-js as well as kotlin-native.
Ok. I was just going off of what was in the SO question I linked to.
I've made a few mobile games with LibGDX and kotlin (not KTX though) and it works great. LibGDX is an amazing framework!
Happened to see someone complain about the same thing in Slack and they created an issue: https://youtrack.jetbrains.com/issue/KT-17597
&gt; Using a declaration with a name consisting entirely of underscore characters now always requires backticks. (KT-16264) Who told them about my underscore-only variable naming scheme?
I'm also getting a failure on Travis CI after upgrading, but not when I build locally. The error I'm getting is "Failed to apply plugin [id 'kotlin']". https://travis-ci.org/xenomachina/xenocom/builds/225782318 Edit: it turned out my failure was caused by using an older JDK. Kotlin 1.1.2 requires JDK 8 to build.
 class `(╯°□°）╯︵ ┻━┻`
┬──┬ ノ( ゜-゜ノ)
You can also use spaces and commas in kotlin method names if you enclose the method name in ticks. fun `test that method, given certain params, does the right thing`() { } is valid code. It says that it doesn't work in Android, but you can still use it in Android unit tests or non-Android projects.
Data class doesn't fit your use case? https://kotlinlang.org/docs/reference/data-classes.html Kotlin misses of Self type https://discuss.kotlinlang.org/t/self-types/371 https://discuss.kotlinlang.org/t/this-type/1421
Is there a way to force implementations of an interface to be data classes? I intended to do something like this: public interface SomeInterface&lt;C&gt; extends Copyable&lt;SomeInterface&lt;C&gt;&gt; Would I be able to do this with data classes? And the Self type is indeed exactly what I needed, that's unfortunate.
eh i give the guy credit for coming up concerns of his, this post sounds like he's evil for trying! Even if there are only a few good ones in a sea of not so good ones at least he's giving feedback which is valuable to any designer to know the thoughts of users
here's a hug *hug*
I use IDEA with IdeaVim, but vim is configured as external tool and bound to keyboard shortcut
How about the IDEA Vim plugin?
Do you know there is a specific vimrc file for Idea Vim plugin? And it can even load some of the native Vim configurations.
You probably still want to write a Builder if you want to expose the data class to Java, don't you? I mean you don't *have* to, but you want to.
Both Kotlin and Java don't have a self type and thus it's impossible to implement this correctly. For example you could subclass your Example class above and not override copy, and then copy would return the wrong class. But it sounds weird that you need a copyable interface. Instead of copying objects everywhere the better strategy often is to use immutable objects.
I've one saw some Stats module in H2 database and it's awesome! For each column they compute an approximate histogram and deduct all the properties from it. I guess, descriptiveStatistics does something like that? Does it iterate only once for all the properties? 
very good presenter, and excellent video 
It's great to see the commitment to community engagement and the willingness to kill off bad ideas with a sensible migration strategy (deprecation + automated refactoring). Long live Kotlin!
Upvote for lateinit.
Seems like in this case, they are checking for null and if it's null they skip the upload. If it is null, then they just do nothing, which probably isn't ideal in the first place, but I won't go into that. The likelihood that some other thread or something changed the value between the evaluation of the if and the execution of the statement is very, very low, but if it did, I guess it comes down to what you would want to happen. Would you like to continue on with a snapshot of the value (it won't fail silently, it has a copy) or would you rather have an NPE? In this case, I think it doesn't matter because there's only a single reference to the value and that is the first statement that will be evaluated. If there were more code inside the braces, I'd almost always prefer an NPE, and thus the if, but again, it depends on the use case. If that value is changing often and you expect it to change often, you might want to keep that snapshot of the value using let. In this case assuming the value is set via a bound form field that the user might change before the page loads but after the button was clicked, I'd probably want the let rather than the if so I could get the value at the moment the button was clicked. I would also assume that the let would take slightly more memory and processor ticks since it's copying the value, so if this is a repeating function that is memory and time sensitive, you might go with if.
Couldn't `in` be an infix function for that case?
What annoys me about lateinit is that it doesn't work for vals. If you read a lateinit property before initialization it's just supposed to crash, so I don't see why it would be restricted to vars.
No... the type of "a in As" is boolean, and a for loop doesn't know what to do with a boolean. It's conceivable that something like "a &lt;- As" could be an iterable of some sort, and the for loop could traverse it, but that would be a different language.
It used to be a easy way to spot vendor astroturf marketing accounts on programming subreddits.
I'd recently (December, 2016) replaced Java and Clojure with Kotlin to be the main language at my company, and the response has been overwhelmingly positive. It's been such a freakin' breath of fresh air, when your stuck on the JVM. I honestly can't go back to Java after getting what Kotlin has brought. It's made everything, and I mean everything, we code more enjoyable. I dread the idea that I may one day have to find new employment and I'd be forced into writing Java again. I'd been coding in Java since 1999. So, I'm not just some troll being mean to it. I just can't stand it anymore after seeing what other languages and platforms have. I'd rather go back to writing Objective-C over plain Java.
I replaced various Clojure projects with Kotlin over the last 6 months. It's just a lot easier to maintain a project you don't touch very often when it's statically typed. Not to mention, I haven't used Clojure as my daily-driver for years. I think it says a lot about Kotlin (like it did about Clojure) that I like to work with it even though I have no pre-existing ties to the JVM. It's something I choose to use on my own. For me it feels like a server-side-ready Swift. :)
Do you mean property delegates, or do you actually want to know about those interfaces? The interfaces are just for convenience -- you can actually create property delegates without using them. If it's property delegates in general you're interested in, you might want to take a look at [Kotlin-argparser](https://github.com/xenomachina/kotlin-argparser). I originally wrote it to explore what's possible with property delegates, and it's turned out to be a useful library. It lets you write something like: class MyArgs(parser: ArgParser) { val v by parser.flagging("enable verbose mode") val widgetName by parser.storing("name of the widget") val size by parser.storing("size of the plumbus") { toInt() } } ...to parse command-line arguments. The values returned by `parser.flagging/storing/etc` are property delegates (or sometimes property delegate providers, which in turn create property delegates).
It would be nice if you added a unit test for the tweet repo.
I see that most programmers are using single-expression functions together with if instead of when. I prefer when or recurrence while it is breaking in a nicer way and it is easier to extend. For example, these implementations of Fibonacci number counter are giving the same results: fun fib(i: Int): Int = when { i &lt;= 2 -&gt; 1 else -&gt; fib(i - 1) + fib(i - 2) } fun fib(i: Int): Int = if (i &lt;= 2) 1 else fib(i - 1) + fib(i - 2) But which one is easier to change? Let's suppose that we want to change initial values (for first and second element). In when it is just: fun fib(i: Int): Int = when { i &lt;= 1 -&gt; 1 i == 2 -&gt; 2 else -&gt; fib(i - 1) + fib(i - 2) } Or we want to throw exceptions when illegal arguments: fun fib(i: Int): Int = when { i &lt;= 0 -&gt; throw Error("Illegal argument. $i must be bigger then 0") i in 1..2 -&gt; 2 else -&gt; fib(i - 1) + fib(i - 2) }
The stack depth will be between log(n) and n. If it's a problem I believe there are better ways to choose a pivot.
Don't leave us hanging, what is the time? What about memory usage?
sorry, i aint get your point. One could simply write like this: constructor() : super() { } constructor(mParent: AppCompatActivity?, mAlbum: PostAlbum?) : this() { this.mParent = mParent this.mAlbum = mAlbum }
Check it yourself :) Here is my measureTime function: fun measureTime(f: () -&gt; Unit): Long { val startTime = System.currentTimeMillis() f() val endTime = System.currentTimeMillis() return (endTime - startTime) }
In my machine this are results: Sorting 100 lists of size 10 by Java standard library sort took 3ms Sorting 100 lists of size 10 by functional quickSort took 5ms Sorting 100 lists of size 100 by Java standard library sort took 6ms Sorting 100 lists of size 100 by functional quickSort took 14ms Sorting 100 lists of size 1000 by Java standard library sort took 46ms Sorting 100 lists of size 1000 by functional quickSort took 100ms Sorting 100 lists of size 10000 by Java standard library sort took 411ms Sorting 100 lists of size 10000 by functional quickSort took 596ms Sorting 100 lists of size 100000 by Java standard library sort took 2311ms Sorting 100 lists of size 100000 by functional quickSort took 8462ms In my opinion, this are quite a nice results when you are comparing 8 line, simple function and some big monster optimized in thousand ways, different ways of sorting for handling list sizes and native code optimizationsxP
Kotlin has `measureTimeMillis` built in which does the exact same thing. I am more interested in memory usage, but I don't know how to do a proper analysis.
Ow, it does. When I implement this function then I didn't found it, but it was about 2 years ago so probably it wasn't there yet xP About memory usage: http://stackoverflow.com/questions/19785290/java-unit-testing-how-to-measure-memory-footprint-for-method-call
Good question! POSIX and GNU command line option syntaxes are ambiguous unless you know the complete set of options that exist before you start parsing. For example, given the command-line: command -xyz foo Without knowing what options are expected, this has multiple possible parses, including: - `command` takes three options, `-x`, `-y`, and `-z`, plus a positional argument `foo` - `command` takes three options, `-x`, `-y`, and `-z`, where `-z` takes one argument, `foo` - `command` takes two options, `-x`, and `-y`, where `-y` takes one argument, `z`, plus a positional argument `foo` - `command` takes one option, `-x`, where `-x` takes the argument `yz`, plus a positional argument `foo` Long options are slightly less ambiguous, but still have ambiguities unless you know how many arguments each option expects. So the parser needs to know the complete set of options and the arguments they expect before it begins parsing. Using delegates lets us build up the parser's configuration incrementally, and defer the actual parsing until the end. You could do something similar without delegates, but have a `get()` method to lazily trigger parsing: class MyArgs(parser: ArgParser) { val v = parser.flagging("...") val widgetName = parser.storing("...") val size = parser.storing("...") { toInt() } } ... createPlumbus(myArgs.size.get()) But using Kotlin's delegate syntax makes this much more concise, and also lets you do things like implement a straigtforward interface: interface Config { val v: Boolean val widgetName: String val size: Int } class ArgsConfig(parser: ArgParser) : Config { override val v by parser.flagging("...") override val widgetName by parser.storing("...") override val size by parser.storing("...") { toInt() } } This might be handy if you wanted support multiple sources for arguments, like say, a config file in addition to the command-line.
Oh, you totally misread my tone. I am very curious to see how it will work with that new library. That is all. I like your code. I am a Kotlin fanatic! Maybe I will give it a try. I just couldn't do that earlier because I was at work. 
Thanks for the response! I didn't realise about ambiguities. Does your lib handle telling the user about an ambiguity if they typed one?
I used that yesterday the tooling for kotlin is some of the best I've seen in my career to date 
Also makes it super easy to find solutions on stackoverflow without a massive Kotlin community, you just paste the java code you want and viola! 
It is great tool but i found doesn't like onActivityResult. https://celiktemha.github.io/2017/04/30/hi/
There's an issue tracker for things like this. https://youtrack.jetbrains.com/issues/KT
As well as answering my specific question, I'd be really interested to hear about other people's experiences with trying to reduce the boilerplate in all of their gradle projects. I've found Netflix's Nebula Plugins to be a great examples of how to write Kotlin plugins for Gradle (and I'm using quite a lot of them, or forked versions), but there's not a lot out there about putting it all together with custom distributions etc, and best practices.
BDW this function comes from my library I've already published on Reddit Kotlin group: https://github.com/MarcinMoskala/KotlinDiscreteMathToolkit
I've seen React Native in Kotlin: https://github.com/andrewom Elektron should be possible too.
The main issues I'd think you'll encounter are workflows, especially the build system. Electron is very node-centric. For Kotlin apps, even KotlinJS stuff, you're _very likely_ going to want to use Gradle. (You'll notice there's no "building kotlin JS apps with grunt/gulp/etc" tutorials). Edit: looks like the Kotlin blog has an example of react on the front end: https://blog.jetbrains.com/kotlin/2017/04/use-kotlin-with-npm-webpack-and-react/ This uses their kotlin-frontend-plugin: https://github.com/Kotlin/kotlin-frontend-plugin Other approaches I've found: https://github.com/srs/gradle-node-plugin So I suspect you'll start by basically having a gradle wrapping system dump js files somewhere to be picked up by the electron tool. In the end, I don't think there's any "easy electron + kotlin js" toolchain just yet. But there's similar enough plugins for Gradle that should be an easy start.
Why it have 0 rating? It is not interesting? I have more nice functional-style functions written in Kotlin, but if you don't like it then I will just keep them to myself :/
Kotlin is such a beautiful language I wonder why google doesn't promote it. It should be part of the Google Cloud language options by now.
Try to be less sensitive to Reddit voting, people are rarely rewarded for complaining about downvotes. Even with a vote of 0 plenty of people will still see your work. Also you got 22 votes when you posted this library just 5 days ago, so people may have felt that this post was repetitive. Is there any way you can use [tailrec](https://kotlinlang.org/docs/reference/functions.html#tail-recursive-functions) to make your function more efficient?
Nice article!
It is. As any JVM language, as long as you provide the runtime, it should work. 
Thanks :) It is possible to use tailrec on this, but it would have to be defined differently: fun &lt;T&gt; Collection&lt;T&gt;.powerset(): Set&lt;Set&lt;T&gt;&gt; = powerset(this, setOf(setOf())) private tailrec fun &lt;T&gt; powerset(left: Collection&lt;T&gt;, acc: Set&lt;Set&lt;T&gt;&gt;): Set&lt;Set&lt;T&gt;&gt; = when { left.isEmpty() -&gt; acc else -&gt;powerset(left.drop(1), acc + acc.map { it + left.first() }) }
hi, There is a already bug report about it. https://youtrack.jetbrains.com/issue/KT-9995 They said: When you override a Java method, it's your responsibility to specify correct nullability for the parameters, because Java does not keep track of whether the parameters are nullable or not. Requiring you to always use a nullable type when you override a method is unfortunately quite inconvenient, because it would force you to write meaningless null checks when the method is never called with null arguments. 
I'd rather just use a singleton object, though. I don't want to use the static keyword at all.
Yep. Anywhere that you can run JVM code, you can run Kotlin. I have deployed an Amazon Echo Skill to AWS Lambda that I wrote in Kotlin, and it works a treat. 
Companion object is a singleton object that's associated with a class (statically)
You can introduce a type parameter with some generic constraints, like this: fun &lt;T&gt; a(val b: T): Unit where T : UpperLevelStandardClass, T : myInterface { .... } It's documented at the bottom of this page: https://kotlinlang.org/docs/reference/generics.html
You can link to the sections directly: https://kotlinlang.org/docs/reference/generics.html#upper-bounds
Nobody in the whole world is more anxiously waiting for Kotlin Native than me. Such a beautiful language without the Java baggage.
Just in time to play with it during the weekend. Thanks!
I've been using IntelliJ for years and did not know about this. 
I'll start, here is the header: http://i.imgur.com/R33DHvC.jpg
All for this, just please don't go nuts with the css, some subreddits are ruined by that.
Oh wow, [Tensorflow](https://github.com/JetBrains/kotlin-native/tree/master/samples/tensorflow) for Kotlin is **huge** for machine learning. Python is a dinosaur and Scala jumped the shark years ago, the machine learning world needs to coalesce around a modern, well-designed language.
Post my first ever Reddit thread: immediately spot the typo in the title. Gah.
It actually works very well. For example I created a [password manager](https://github.com/rnentjes/simple-password-manager) with it, and it's a joy to use Kotlin to manipulate the dom. I think the static html builders work very well to. Compared to your scala remarks: * Building with gradle is easy and incremental compile is fast * The generated javascript is also pretty big though (212 kb in that example). There has been some discussion about this on the kotlin forums and I hope there will be a tool in the future to strip anything not needed out of the stdlib. * Performance hasn't been my main concert but I haven't encountered any problems. I have also been working on a [online music tracker](https://www.music-tracker-online.com/) written in kotlin js and until now that performs pretty good. 
I used it to make a simple chrome extension and it worked quite well.
I'd recommend to try TypeScript for JavaScript development. It's just plain JavaScript + structural type system on top + transpiler all in one. One drawback that you'll need to write some code generation from your backend language for static typing RPC style communication.
Moshi still needs code generation to construct Kotlin data classes without reflection, and then I'll be able to fully replace auto value Moshi. But still, awesome. 
I prefer with screenshots as I'm a junior developer
https://github.com/square/kotlinpoet
Why do you use ugly java-like builders when you can create pretty DSL?
I learned it from their [website](https://kotlinlang.org/docs/reference/basic-syntax.html). I found their walkthrough of language features to be enough for me to get started. My own [article](https://medium.com/@magnus.chatt/why-you-should-totally-switch-to-kotlin-c7bbde9e10d5) from last week might also work as a starting point. It includes a bunch of links at the bottom, which might be interesting for beginners. Good luck! :)
Besides the usual references, you can paste Java Code in a Kotlin file and intellij will try to compile it for you. Sometimes this is a surprisingly easy way if you're stuck. You may also want to tak a look at [Anko](https://github.com/Kotlin/anko) for a Kotlin-style Android Development.
To me, Kotlin is not language that you necessarily have to learn. It's more of an experience of transition from Java to Kotlin. I never felt like I needed to know Kotlin inside and out, since it was so similar to Java. However, once you start learning the intricacies you can start applying cool things like extension functions with lambdas and receivers.
Thank you for this, I looked at JavaPoet a few months ago and really wished for a Kotlin equivalent and now we have it!
From the book https://www.manning.com/books/kotlin-in-action I'm reading the chapter and it's really well explained, it goes way deeper than the official documentation, the combination of `function-literals-with-receiver` with `invoke()` is really nice 😮
I bough this book weeeks ago and had issues with my download link. Despite what's listed online there is absolutely zero customer support for that site. It's a shame since I'm really interested in the content
What a pity, thanks for sharing your experience.
I was literally screaming of joy
Hello there, fellow trend settlers.
Yeah, freaked my dog out myself. Was not expecting anything huge this year 😀
Best news ever. All we need is Kotlin Native to feel in heaven. Kudos to the Kotlin team and their vision of an easier life for coders. We salute you.
It's out now. https://developer.android.com/studio/preview/index.html
it wasn't when I posted that. :) but yeah, downloading now!
That's a huge vote of confidence from Google in Kotlin. Exciting! 
So it's basically like a new variation of Java? It it a better language or something?
You know Android Studio basically *is* IntelliJ, right?
Android Studio has the latest Android features as they're developed. They take some time to port back into IntelliJ's Android plugin. It all depends how desperately you want the future or how Android-centric your development is. 
LWJGL 3 is the way to go, LibGDX will work too. Development wise it's the same with Java but less verbose. I don't think it's wise to add kotlin wrappers for OpenGL, but wrappers for LWJGL memory/buffer APIs will be nice.
Best news of the month I am freaking excited kotlin and swift for the win 
Also: https://trends.google.pl/trends/explore?date=now%207-d&amp;q=kotlin
I'm so frigging pumped, almost jumped out of my seat.
It's sad to see this post getting so less up votes here and getting so many upvotes on /r/android 
LWJGL 3 is still has a Java-based API, the kotlin stuff you see there are from generators (responsible for generating wrappers for native code).
JVM is far superior to CLR and supports all of the platforms. Additionally C# is close to Kotlin in syntax so I dont think It will ever happen. 
Pardon? JVM is superior to CLR? Ha ha ha ha ha ha ha. Hilarious.
JetBrains has no plans to work on Kotlin for .NET at this time.
Running the Kotlin compiler requires Java 8. Make sure that your JAVA_HOME environment variable points to a JDK 8 installation.
Is the std of kotlin native different from jvm version? Or is the jvm code converted to native? Also is there a GC? I think Kotlin native has great potential to replace Go
Exactly this.
Can you talk a little about why the jvm is superior. I'm not disagreeing with you. Just for learning.
. . . you're sad that a subreddit with 3k people is upvoting something less than a subreddit with 780k people?
Just watch: https://www.youtube.com/watch?v=oH4_unx8eJQ None of It happens on CLR. And there will be more optimisations like that to come when graal is going to be released: https://github.com/graalvm/graal Thats why applications written for JVM are slower to start but after some time they beat .NET applications in performance. Additionally there are far more libraries for JVM and they are much higher quality. Some benchmarks from Microsoft (.NET and Java Web Frameworks) https://github.com/aspnet/benchmarks as you can see Java frameworks are up to twice faster. 
Congrats from your friends over at /r/swift :)
From Russia or Czech?
This was it. For some reason that error message confused me into believing it was not suppose to be 1.8 (and from what I had read kotlin compiles to something similar to the older versions of Java bytecode). But I also didn't reset the JAVA_HOME env var. Thanks!
Russia. Another Putin's weapon to take over the world, lol.
Start with Java first. After you know Java well enough you will be able to learn Kotlin extremely fast. 
If you're developing for android, and you're learning android as well, then start with java since most android documentation is in java. Otherwise Kotlin
Would say if you want to develop for android choose kotlin. Otherwise java 
Fuck yeah !!
Well I would like to say, learn Kotlin, it's more efficient and more safe than Java. If you have experience in other programming language, it should be easy to move to Java (as many people said, a lot of Android doc, and more generally JVM doc, is in Java). However, in the facts, I would recommend you to do a quick jump in the Java world to get the basis and then move to Kotlin. Too much stuff use Java and when coding in Kotlin, you'll assuredly need Java stuff.
What's your reasoning? /r/wightwulf1944 is right, almost all the documentation for android development right now is Java
Learn enough Java to be able to read the docs. Learn Kotlin to write code.
A shorted sited comment. The CLR is clearly better in some aspects (e.g. tail calls, real generics, memory usage, startup time), where the JVM is better in others (eg GC, JIT). I would argue that we are moving to a world where it's AOT and memory usage (android, serverless) are most important.
You wont. Kotlin is basically C# from years ago without linq, but cleaner syntax.
It just provides convenience, so that you can access your property without having to deal with possible null values. It's there for use cases when you can't initialize a property in the constructor, but you know that it will be initialized before it's used anywhere.
Maybe it's because there are already two good solutions to it. Eclipse kotlin plugin and intellij. The most kotlin/java developer develop servers or android so they already living in one of these ide. 
Lateinit is mostly there for field dependency injection (the main reason it was introduced). It does not provide any additional safety and is in general less safe since it can throw an exception if you forget to initialize it. In your case it looks like lateinit is an okay choice, since dealing with nullability when you are sure the field will always have a value is annoying.
It's nice to know what code does and how to write at least the basics without an IDE.
A rule of thumb: use `lateinit` if you cannot initiate the variable through the constructor, but you are 100% sure it will not be null after full object initiation. Both `?` and `lateinit` would throw an exception when treated as non-null objects while being `null` at runtime. Examples of `lateinit` use cases include field dependency injection, assigning objects that are created by the constructor, but not present in scope of nested inline functions, for example (think nested DSL blocks) or usage of some framework-imposed methods like `create()` or `initiate()` that fully construct the object.
I'd say it doesn't really matter. Do what you're comfortable with. Java is a simpler (dumber) language than kotlin, so it may be easier to learn. But it also has some pitfalls that kotlin avoids. I'd say learn enough Java to understand documentation and example codes at least. Like how to call methods and so on. These basics are very similar in kotlin anyway. 
With `lateinit` you just defer property initialization without affecting nullability, though your variable will remain mutable since `lateinit` can only be used with `var`. What I do if I want to initialize a `val` in an init method is use `by lazy`. For example: val myProp: PropType by lazy { PropType() } override fun init() { myProp } 
I mean the ability to hot swap changes in android apps without restarting the app
You probably can since the output is the same
Of course it's trending! I'm kinda sad I didn't learn about it earlier. Much easier to write than Java and I dont have to worry about missing a semicolon in a long program
so .NET is better for client applications (where memory usage and startup time is important) and Java is better for server side where raw performance and good GC matters
My bad, after all the fuss about instant apps, I assumed you were talking about these. Instant Run would indeed be nice.
As a beginner, Could I skip learning groovy and learn gradle scripts with kotlin directly. Wish 1.0 comes out sooner and my dream came true :)
You've valid points but you look at it from your perspective (someone who actually knows all this things). Even if someone manages to write a Java-comparisons-free Kotlin documentation and some tutorials for Effective ~~Java~~ Kotlin coding, you'll need to learn to read Java code when you want to use some libraries. Don't get me wrong. I don't think Java is such a fundamental skill but practically you'll will encounter Java code everywhere whenever you write Kotlin apps for the JVM. Starting with Kotlin today will force you to learn two languages at once. I learned Java first and switched to Kotlin afterwards. While learning Kotlin I understood, that behind every little nuance of the language is a higher sense (like the unchecked exceptions) and became a much better programmer. 
But isn't it enough to know Java syntax to read Java documentation? Syntax is learned very quickly, if you know the paradigms and learning paradigms with Kotlin imho should be faster than learning them with Java.
That's a really good way to put it. Also fits with the history of Microsoft being a client(windows) focused, and Sun being a server(solaris) focused company. Also .NET had the benefit of second mover and was able to change some design issues that JVM found from experience, and perhaps a bit more able to evolve the platform because of smaller community and more controlled by MS. That said, I think they are both pretty amazing and going through a bit of transformation lately. Hard to say which is better positioned for growth over next 20 years as we move to cloud world where resource usage and startup time matters. Golang(AOT with embedded GC) really is the right deployment model for the future I suspect. 
That's cool, because the main difference is "Type name" vs "name: Type". In Kotlin you have many additional syntactic sugar possibilities that are not available in Java, but that is ok, because as a Kotlin programmer, you know more than every paradigm, that Java supports.
I know some other languages. At least basics of them and basics of OOP. Many of the comments essentially say - "learn java enough to understand the code" - Interesting. 
Now we get to be the cool kids who knew about Kotlin before Google s announcement.
And many Java programmers essentially do not do OOP. Please read http://www.yegor256.com/tag/oop
dat clickbait
Marketing bait taking advantage of Kotlin hype. This is basically the same process for any app JVM or not on Kubernetes.
Yes. https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin
I have been using Kotlin in android for over a year now. I absolutely love it. I don't start any new "java" project with java anymore
Well it is supported now! 
Gradle and many others on kotlinlang website. Me too (Lightstreamer :). Kotlin is the next big thing.
I'm using it for a new backend service, instead of Java. I think I have read that Netflix use it for their backend, but I'm not sure. 
In his talk [How Agile Can Language Development Be](https://mixitconf.org/en/2017/the-future-of-kotlin-how-agile-can-language-development-be-), Andrey Breslav mentioned that the split between Android/Server development is actually much closer to 50/50. I'm not sure what data this is based on, but it contradicts the belief that Kotlin usage is much higher in Android.
I've used it for a few drop wizard based micro services...
I've been using it in spring since pre-1.0, and it's always worked well. The only trick is any classes that are managed by Spring AOP - @configuration, @transactional, etc - need to be open.
Jetbrains?
I do a lot of paid POC projects with a single-year lifecycle, and started using Kotlin in those after 1.0 came out. Kotlin grows more slowly and steadily than Scala did, because its user base is more conservative and less prone to making unsubstantiable claims.
Then? Who is that?
What unsustainable claims did Scala make?
What testing and orm frameworks do you guys use? JUnit and hibernate?
I built a backend system with Gradle + Spark Framework and *mostly* Kotlin. It was a nice experience, great interop with Java (as expected), and easier, cleaner code.
Does IntelliJ understand this yet? Back when I last tried it, I kept getting errors running things in the IDE because the plugin wasn't invoked properly...
I haven't had any trouble with it that I can recall. I'm using 2017.1.3 currently, but the 2016.X.X versions I used late last year didn't give me issues either. 
What if you have 5,000 employees? ;)
I use for game development bi libgdx. It can build for iOS, Android, PC. 
My team at New Relic uses kotlin for writing very high throughput data processing services.
What's the name of the service? ;) 
It's a mostly internal microservice at the company I work for. Not really public. FWIW, we didn't get cute and name it something with a "K", unfortunately.
Did you enable coroutines for the kotlin facet in your project settings? http://imgur.com/a/H8RhE
^(Hi, I'm a bot for linking direct images of albums with only 1 image) https://i.imgur.com/rzqUNJC.png ^[Source](https://github.com/AUTplayed/imguralbumbot) ^| ^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^| ^[Creator](https://np.reddit.com/user/AUTplayed/) ^| ^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^| ^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dhtqc8t) 
Ops, seems it was just me that forgot to set the API version to 1.1
Happy to hear New relic is not a Ruby shop anymore. As I attended a talk couple years ago and the speaker from you said Ruby is awesome and the whole company use Ruby.
It's been quite a while since New Relic was an all-Ruby shop. Java has been in heavy use for several years, and Go is starting to gain a foothold as well. I'm doing my best to spread the joy of Kotlin wherever possible.
It's used for a number of different purposes, including data processing services.
Java is going to have Value Type in the future.
I work for a fair sized company in Australia. We're using Kotlin to write our Android Apps but I'm also personally undertaking a proof-of-concept to rewrite the UI layer using TornadoFX, and JFoeniX to try to efficiently create Desktop versions of these Apps as well. I guess it's a fairly natural thing for a mobile Developer to have a soft-spot for rich-client Apps over web; and given that our App is a business tool, I'm hoping some of our customers might appreciate a Desktop client too.
I'm working on a web framework called [Kweb](http://kweb.io/). It's a fairly novel approach, combining state binding through an observer pattern (similar to TornadoFX), while hiding the boundary between web browser and web server (similar to Vaadin, but lighter-weight). The approach to routing (almost always a source of headaches) meshes very nicely with the state binding. Kweb is still at an experimental stage of development, probably 2-3 months away from production use. I'm actively looking for help with it, so if anyone is interested please join #kweb on the Kotlin Slack (see [here](http://kweb.io/contribute/community.html)). While it's still a work-in-progress and this file needs to be broken up, [this](https://github.com/kwebio/kweb-demo/blob/master/src/main/kotlin/io/kweb/demo/joker.kt) gives you a taste of how it all meshes together. Note that this gives you routing almost for free (bookmarkable URLs that capture the state of the page so that you can return to it). I've also created a simple persistence library called [Shoebox](https://github.com/kwebio/kweb-demo/blob/master/src/main/kotlin/io/kweb/demo/joker.kt). It supports multiple back-ends (currently in-memory and filesystem), and powerful observer semantics such that it facilitates the "single source of truth" architectural principle, combined with state binding in Kweb.
Do you use kotlin with libgdx?
I didn't use kfx. Straight libgdx.
I wrote a few classes in Kotlin and put them in production as an experiment. The sentiment was "it's cool, but I don't want to write everything in it". Maybe important: I was the only one who wrote code, so no one else actually experienced it first-hand, but rather through looking at what I had done. Did you experience anything similar, or did most people feel it was valuable enough to move forward with? What's the biggest advantage you've seen over Java? 
I think when people get first hand experience they will probably sway. Not everyone see the value directly and there are many developers who are afraid of new things. So, there's ton of advantages from my experience. In short; You can be more expressive and write more concise code. But I have tons of situations where it just makes things so much better. In my team I think we're pretty progressive and they were fast at testing it and no they don't want to go back. Just the fact that Null is modeled as a first class citizen should be enough to sell it. You can't do that with Java and the nullable interface is nothing the compiler enforces.
Why would you want to? The reason to use lazy is to avoid incurring the overhead of looking up something that you may not need. But when you use anko to create your layout, you already have a reference to each element - there is no overhead.
Heh, I'd rather not mention it, as I don't want to link myself here with it. :-)
If you have 5000 developers, and can't afford a couple hundred $ for an employee's tooling (an insignificant percentage of employee cost), then something is wrong. I firmly believe the language will pay for any costs via productivity gains, reduced bug count, not to forget employee happiness, in a very short amount of time anyway. You can always use the free IntelliJ community edition, Eclipse with the Kotlin plugin, and even Vim or emacs for die hards. The compiler is not tied to IntelliJ. :-)
I yak-shaved my own kotlin web framework (https://github.com/danneu/kog) and have a simple JSON api for it in production. :)
&gt; But when you use anko to create your layout, you already have a reference to each element You won't get NPEs... Anko layouts are created immediately and in your code, and so the ref you get back from the Anko methods will not be null.
I know, I was being facetious. My point was that $500/year per developer racks up quickly, and it's almost pointless not to bump to the $650/year for all Jetbrains tools. I actually think 6 figures for software tooling is nothing for most companies. Consider how much engineers get paid and how many meetings or side conversations can be eliminated by the proper tools, and it pays for itself.
Okay thanks , very excited
Why not both?
Kotlin also runs on the JVM.
It's not generally immutable, however it has conventions that push you towards having less and less mutable parts in your code.
List and Map interfaces are immutable in Kotlin, requiring you to opt-in to the Mutable versions. Manipulating data with filter/map/fold extension functions in Kotlin encourages immutability.
I have the same exact question. I'm not experienced in Java, but I want to learn Android app development with Kotlin.
I understand. I have always just bought my own, personal, license. It's a tool I find completely worth it. I've been using it since version 2. So I might be a bit of an Evangelist. Visual Studio's pricing model confuses me too, but I do believe it does cost more. Not to mention that your pretty much a Windows developer if you use it.
Woow
Part of learning Kotlin will involve the Java standard library along with the Java ecosystem, so while it's technically possible to learn Kotlin the language without knowing Java, you are eventually going to encounter Java code. It's important to know not just the syntax of a language but also its idioms and its APIs (both standard and third-party). So I think it would be difficult to learn Kotlin without learning Java, but that doesn't mean you have to stop what you're doing and learn Java first. If Kotlin excites you, I'd focus on Kotlin, because your motivation is going to play a large role in determining how quickly you pick it up, but don't ignore Java. Both languages share a lot of concepts so I think it's totally possible to learn both simultaneously. For example, take the Comparator. You will encounter this concept in both languages, so understanding it in one language makes it a lot easier to understand it in other languages. If I were in your position, I'd start studying Kotlin and once I understood a concept, I'd jump over to the Java docs, Google, or a good book to revisit the same concept in Java. If you're writing small programs for fun, try writing them in both languages. This will at least give you a decent amount of exposure to Java code and help you understand why Kotlin is such an improvement on it. 
They're not *really* immutable actually. Lists and Maps have Read-Only interfaces and can be cast to MutableList and MutableMap types. There is a proposal (KEEP) for a truly immutable collections library: https://github.com/Kotlin/kotlinx.collections.immutable/blob/master/proposal.md 
Do you know why Kotlin is the most popular in Poland? Because there is ketchup with the same name: http://static.wirtualnemedia.pl/media/images/2013/images/Kotlin-ketchuplagodny-starenoweopakowanie.png so 90% searches of Kotlin in poland are ketchup ones
as a beginner, you should stick to java for now, there is much more support online for it, so it'll be easier learning the intricacies of java and then switching to kotlin when you're more experienced with object-oriented programming concepts
What do you want to do with this, for fun projects or to professionally do Android? If you want to professionally do Android then 100% you should learn Java first. Most companies are going to have a large majority of their code in Java and it would be best if you can work with legacy code as well as potentially write new code in Kotlin
Lovely. Exactly what I wanted to build myself but never got the time.
mostly for fun but i'm hoping to be a software engineer in a few years so i should probably learn java i suppose 
fair enough il do that then, thanks!
I contributed to this. I've been reading up on Kotlin and watching presentations about it since the announcement and I'm loving it so far.
Yeah see that's the thing. After doing a little kotlin and Java, kotlin seems to just be better in every way.
This is one of the best presentations on Kotlin I've seen. The speaker is really great and it shows off some of the great features of the language. It got me really excited to learn it, anyway!
"I love it when people crap" - Hadi 2017
Looks a lot like https://github.com/JetBrains/Exposed/blob/master/README.md - any relation?
They do look similar, and both are by JetBrains people so perhaps one of them might see here and shed more light on them.
Exposed is a much larger library. Squash is used in Jetbrains implementation of Thinkter. Very elegant
You'll have a shorter learning curve with kotlin because it shares more concepts with python than java. It also depends on what your goal with learning Kotlin/Java is. If it's for personal projects then go for Kotlin. If it's to find a job, well then java is still a requirement I'd say. However, I think this will change in a matter of years now that Kotlin is officially supported. I generally think, the more languages you know the better. 
Well that's not how trends work though :P I'm assuming the amount of ketchup seekers stay somewhat the same over time :D 
I'm sorry but I think you're mistaken. In Java you create an array using `int[] myIntArray = {1,2,3};` or more generally as an expression using `new int[]{1,2,3}`. It has little relation to the `[...]` syntax. In addition, in most languages the syntax creates a list (for example Python, JS and most functional languages). Sidenote: JavaScript is a bit of an exception as it actually does create an Array, but an array in JS actually behaves like a mutable list :/. So I'd rather call it a list. 
2016?
Yeah, that's a nice little library to show what Kotlin could do for us :) Unfortunately, multiplication of units is just the top of the iceberg of problems there; the domain is rather complex by itself AND very confusing because of many century-old human mistakes and historical traditions. Heck, there's the whole Metrology thing. While "km/h" in your library is not related to "km" / "h" in any way, it is still quite practical and I wrote a similar library for my real project. For impression you might want to check documentation on Frink (especially their text file with definitions) and several awesome Haskell libraries.
&gt; However, I think this will change in a matter of years now that Kotlin is officially supported. I have received some job offers, now there are few jobs on Kotlin but I feel that something is happen. Tomorrow smart company will look about Kotlin programmers, who are prepared? Feel the wind, stay tuned ;)
Thanks! I'll check it out. Yeah it really was just a quick experiment, never intend it to go any further.
[Frink data file](https://frinklang.org/frinkdata/units.txt) reads like a poem! 
I've been using java for 16 odd years, so i'm a little bitter ;)
Really love it, thanks for sharing the video. I learned some more language feature straight from his talk. Here is some of language features with couple of notices I got from what he mentioned in the talk (allow me to add here in case someone else might want to look at) * data class * all class marked with final by default (limit to be inherited by others), use open to relax this, or sealed but for nested class * Unit is like void, but there's also "Nothing" which we generally don't need to get involved with it lol (see this [comment on SO](https://stackoverflow.com/a/22655381/571227) by Andrey himself explaining Unit, and Nothing * Extension class * Infix function i.e. 10 shl 1 (shift 1 bit to the left of 10), just mark with "Infix" in front of function declaration * Split vertically (android studio), another way is not to open up Action popup, but you can set up keymap. Just Properties-&gt;Keymap then search for Split Vertically. *Edit*: format text
Fair enough :)
https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0 Spring has support for it. I just got into Kotlin and am planning on using it for my next server side project.
Crossplatform game development is not really a good field for Kotlin. The lack of stack allocated Structs leads to a lot of allocations and therefore a lot of work for the GC. Minecraft is a prime example for that. From what I know it uses objects for immutable vectors and matrices which needless to say generates a lot of garbage.
Kotlin/Native...
Spring is the safest choice, but [Kara](http://karaframework.com/docs/overview.html) looks pretty cool.
I liked his font that replaced some of the character sets with symbols. Anyone know what that was?
I use Sparkjava http://sparkjava.com/. 
Spring might be too heavy/complex depending on the needs of the app, especially if you're contrasting to something lighter like Flask. Kotlin plays nice with Dropwizard which has support for JDBI, Hibernate, and JOOQ, so you have a lot of options for interfacing with SQL. I've also used Vertx w/ Kotlin successfully, if your app will fit a responsive/async architecture better
For what it's worth, there is something called Spring Boot which can help simplify working with Spring, it automates a lot of the configuration aspects (no messing with .xml files) and helps you get a POM set up that has only the components you need. Still a bit daunting IMO because you have to know what those components are, but does relieve some of the insanity. There's also the Play! Framework which is much more "Rails-y", but I haven't tried Kotlin with it yet, and it tends to favor Scala, but does supports Java, so should also be possible to use Kotlin. Good luck!
Could you specify what you think the problem is or where you're failing? This doesn't provide a clear problem description imo.
In Swift, which supports the [] syntax, a [5, 2] is represented as an ArrayLiteral, then concrete types can implement the ExpressibleByArrayLiteral protocol (a protocol is an interface in Java) which defines an initializer (constructor in Java) which takes an ArrayLiteral. Built types Array and Set for example implement ExpressibleByArrayLiteral. Swift uses Array by default unless Set is specified. To create a Set you would do: let set = Set([5, 2, 3]) // or let set2: Set&lt;Int&gt; = [5, 3, 2] The same concept could maybe be applied in Kotlin?
It would be helpful if you provided example inputs, what the program is actually computing, and ideally some test cases. This would make compiling the program and hence refactoring the program to make it immutable a hell of a lot easier.
That's more of a theoretical problem, not a practical one. The most popular cross platform game development engine in use today has atrocious GC performance.
You would do pathArray.map and output your distance then use sum to get the total. More generally, you could use reduce. 
Basically eliminate any var. Looks like dist is your ownly one. Consider using fold instead of a for loop.
The plus and minus calls were just attempts that I made to make the code immutable and then didn't bother to change, please ignore that.
Something like this? var dist = pathArray.map({ pastTurns.add(it[0]) when (pastTurns.groupBy { it }[it[0]]?.size?.rem(2)) { 0 -&gt; it.substring(1).toInt() * -1 1 -&gt; it.substring(1).toInt() else -&gt; 0 } }).sum()
Minecraft is a prime example of lousy Java code. RuneScape is a 3D _MMORPG_ written in Java that runs smoothly, funny that nobody ever mentions that in such discussions. With some object polling and native code to optimize the problematic parts, you can achieve comparable performance to the C++ engines. JVM is a beast. Hell, LibGDX outperforms Unity and Unreal on mobile devices. In the end, it's mostly about the quality of your code and optimization of the algorithms - the "10% that runs 90% of time". You can create an amazing game with Java/Kotlin, just as well as you can create a shitty game in C/C++/C#. Kotlin is viable for game development, it's just that there aren't many frameworks/engines that use it yet.
Well, the reason why people consider mutable state bad is because it makes it difficult to figure out what the program is going to do at any given moment. Say you have this somewhere in your code: // Let's say `user` is something global, or something inside an object that can be changed from outside if (user.id == requestedId) { doSomething() } If `user` and `user.id` are mutable, you now have to think about what is going to be their value at the moment when this is called. What if something changed their value between two different calls to this function? Can such a situation happen? Do I have some code that counts on them not changing between two calls? Do I need to put a check there? etc. In contrast, if `user` and `user.id` are immutable within the object that has this function (and can only be different if you re-create the entire object from scratch), you have no such worries. It significantly reduces the amount of possible code paths you have to think about. You don't have to keep the state in your head. But if you only use a `var` as a local variable inside a short function, then you obviously won't have this problem, so it's not a big deal in those cases. Also, immutability is not just about `val`/`var`. Having a shared list that you add things into at different points in time also counts as mutable state.
&gt;Has anyone here had experience of coming back to a Kotlin code base after a long period, did its potential brevity cause issues (comments can only tell you so much!) I have, yes. I learned a few things from it. - Just because you don't need to declare the return type for your methods, it doesn't mean you shouldn't. You probably should. It's easier to read and it prevents accidentally changing the return type when refactoring. - Same with inline methods, or whatever they're called. Just because your method is one line, it doesn't mean that you shouldn't use the block `{ return x }`syntax. I find it easier to read, and I've been using Kotlin for well over a year. - Javadocs are less verbose in Kotlin. Write them!!! It helps to visually distinguish methods from each other, plus of course your methods will be documented. It took me maybe a month or two to be comfortable with Kotlin's syntax, but I wasn't immersed every day. If there's one thing I would fault Kotlin on, it's having *too* many ways to do one thing. However, this is what style guides are for. Decide on how/when to explicitly declare types, when to use named params, when to use a property vs a function, when to use braces, etc. and you'll be fine. &gt;Please I have no interest in "bashing" either language, if you can't avoid hyperbole don't bother... Those are the things I've learned about Kotlin, but I still 100% believe that it's a 1000x better language than Java, and if you prefer Java over Kotlin, it's like saying you like Eclipse over IntelliJ. ninja edit: As always, there are exceptions! Writing short methods with shortcuts just makes sense, like `fun String.isNullOrDuck() = this == null || this.equals("duck", ignoreCase = true)` No need for a return type + curly braces here.
As far as immutability goes, yes. I don't know about your inner logic of calculating the distance though. I would probably make that a separate function. 
&gt; While many are happy to bash Java for the assumed disadvantage of verbosity, I've found it actually extremely vital for comprehension especially after not seeing a code base for a long time (even years) This is false, verbose means verbose, not readable. A longer to read code doesn't imply easy of understand. Java's lambda avoid a lot of boilerplate, is an anonymous inner class a better choice? I started using Kotlin one year ago and I feel it easy to write and simple to read. Sometimes I add some optional code (like variable type) to enhance readability but often the type of "user" variable is "User", so it is better to imply. Try Kotlin for a week ;)
I personally find Kotlin easier to get back to than Java, precisely because of the reduced verbosity: The whole language pushes you towards a slightly higher-level approach to writing code that focuses a little bit more on the "what" and less on the "how". It's worth noting that Objective C was, originally, precisely "a set of short cuts implemented with a pre-processor", yet it's still a very different language from C. Kotlin compiles to the JVM, so there's a sense in which it's roughly equivalent to Java. Even if you could implement Koltin as a preprocessor hack of some sort (which I don't think you can), I would consider this question a confounding factor you shouldn't care about. If you're targeting the JVM, you can call into Java classes completely transparently, and vice-versa. The only gotcha is that Java won't have nullability information by default. Kotlin specifically tries to be seamlessly interoperable with Java, so does use erasure for generics. That said, you can use reified generics in the context of inline functions, which allow for some cool tricks. As for negatives, the interation between inline functions and non-local returns from lambdas can be a bit weird at first, and even once you understand it, it's a slightly opaque feature that forces you to check method definitions every once in a while to make sure you're using right. Took me no time flat to "start thinking in Kotlin", but that might be partially because I am very much a programming polyglot, so several of the idioms were familiar from elsewhere. For me there's a few killer features that make Kotlin a superior choice to Java: * Data classes. I don't want to write a bazillion getters and setters. I don't even want the IDE to handle generating those for me. I just want that whole thing to be gone. Kotlin provides this for me, and more, via Data classes. * Better handling of nulls. Not only does this prevent bugs, it also forces a bit more design up front. * Inline functions. Inlining lambdas is pretty neat, but it's reified generics that really do it for me. * Receiver functions. All sorts of features that would be implemented as syntactic sugar at the language level become available as method calls with a very lightweight syntax. 
Fuck java
thank you for you intelligently considered and insightfully constructed input. 
Hey we just opened up our Treehouse [Kotlin for Java Dev course](https://teamtreehouse.com/library/kotlin-for-java-developers) for free. Come check it out!
Thanks for this, will definitely check it out.
Thank goodness for the spoiler tag
Omg thank you for this 
I don't think they've decided yet how the memory management in Kotlin Native will work. They plan to support iOS so there will be reference counting but what about the other platforms?
And Square.
Yeap! Totally agree.
ah gottcha, I need to find some accompanying text, as its expecting me to fix stuff its not taught me about !! rather odd tutorial !
Meh, if it ain't broken, don't fix it.
It is not obvious at all what "$$" or "=&gt;" would do, so code would become unreadable really quickly.
You can use spring even without special kotlin support. Made a kotlin spring 4 portlet just today without any problems
Thanks for this! I'm going to start a project for college and I want to use kotlin + spring, this will be useful!
Yeah I messaged one of the mods about this a while ago. They said they're interested. I guess you can reach out if you wanna help? It was /u/mushishi btw
If you want to try something innovative but not yet fully-baked, check out [KWeb](http://kweb.io/). It runs as a library only - you set it up and it's serving pages immediately. Communication between client and server occurs very smoothly, as most responsibilities stay with the server. It also means that if one piece of information changes, it will be automatically updated wherever it is. We've got a lot to do with it and could use any help we can get.
I made the simplest change to have that image. I hope someone with the skills comes forward.
Yes, if someone improves the styling, I'll update the css. I just added the user group logo to make this subreddit at least somewhat personalized.
A machine learning lib I created : https://github.com/sanity/pairAdjacentViolators I wanted to ensure it is super-robust, so I used mutation testing to verify that the tests are detecting issues.
Ktor is awesome. Check it out. It's used and built by Jetbrains and the Kotlin team.
I don't think this relates closely to or make any difference to the things I pointed out.
It's a nice example. Thanks for sharing. My 2 comments: Just to avoid spreading bad practices: having actions like "add" in URLs is not RESTful. REST is explicitly limited to the HTTP verbs. See this example from [MainController](https://github.com/hllink/KotlinSpringbootGradle/blob/master/src/main/kotlin/br/com/testkotlinboot/pocKotlinBoot/controller/MainController.kt#L25): @RequestMapping(value = "/rest/cities/add", produces = arrayOf("application/json")) In this case `POST /rest/cities` would be appropriate. There is, by the way, no good reason to include "rest" (or "api" as seen in many other examples) in RESTful URLs. Have you tried to put the parameters of entities in the primary constructor? In your [city](https://github.com/hllink/KotlinSpringbootGradle/blob/master/src/main/kotlin/br/com/testkotlinboot/pocKotlinBoot/entity/city.kt) class I'd prefer class City(name: String, country: Country?) { ... protected constructor() : this("", null) } over class City() { ... constructor(name: String, country: Country?) : this() { this.name = name if (country != null) this.country = country } } This would be preferably because as a programmer I want to use the primary constructor and the auxilary constructor for JPA should be hidden (as far as possible, what is `protected`).
Have you tried to follow the tutorial from the official Web site explaining exactly how to compile and run a Kotlin application from the command line? http://kotlinlang.org/docs/tutorials/command-line.html
The idea of Kotlin's restrictions on operator overloading is to avoid situations when it's unclear from reading the code what an operator does. Adding operators that do nothing is in direct opposition to that idea.
You would use a data class with constructor parameters and default values. then you can basically do the same.
I think the kotlin should generate that for java compatibility.
Data class should work for Kotlin, there's no need to make a default constructor, only thing is that you need to tell spring to use the Kotlin.module. I was doing some stuff with Spring and Kotlin as well. I'll link you to the source of where I found this information. Edit: couldn't find the exact source but adding this to your dependency should work as well. Didn't test it myself however. com.fasterxml.jackson.module:jackson-module-kotlin
Yeah, this is doing the same thing as the implicit groovy map constructor, a syntactically nicer way of doing it in Kotlin is: class Person @JvmOverloads constructor(var name: String? = null, var age: Int? = null) Note that you need to add the constructor keyword before the ctor arguments so that you can annotate it with [@JvmOverloads](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-overloads/). You could also add the data annotation to the class if you wanted hashcode, equals and toString. Then you can instantiate it in numerous ways (including with no args for spring data): &gt;&gt;&gt; Person() Person(name=null, age=null) &gt;&gt;&gt; Person("dave",12) Person(name=dave, age=12) &gt;&gt;&gt; Person(age=12) Person(name=null, age=12) &gt;&gt;&gt; Person(name="dave") Person(name=dave, age=null) &gt;&gt;&gt; Person("dave") Person(name=dave, age=null) &gt;&gt;&gt; Person(name="dave", age=12) Person(name=dave, age=12)
okay after a frustrating hour with an ide (ideas) I gave up and implemented what I needed with ant in less than 5mins I have a simple libgdx application working, so I have something I can start experimenting with...
Any JDBC libs are completely interoperable. Not PG, but I've had no issues using Kotlin + Hibernate + MySQL as well.
its nice, but doesn't focus much on android development. Mainly focussed on code syntax. Don't get me wrong, its a good course but not exactly what the ts asked.
Hi.. I realize what you said.. I've made a mistake.. But unfortunately, I fell ill today. Give me a day, I'll fix it. Thanks for pointing out. :)
If you have a lot of static stuff, i think you should consider using top-level functions instead of object. See this: https://discuss.kotlinlang.org/t/best-practices-for-top-level-declarations/2198
I see, when is Object useful then?
A class where all parameters have default values gets a parameterless constructor automatically; this does not require a compiler plugin.
never used kobalt, don't like the way gradle takes for ever and leaves 100 copies of itself all over my development drive, maven similarly using a bomb to crack a nut...
Is your aim mobile or desktop? You can look at Jython to allow interaction between Python and Kotlin.
Thanks for the suggestion, The code examples motivated me to buy the book to. 
When you want a [singleton](https://en.wikipedia.org/wiki/Singleton_pattern). In an existing Java project these might look like an enum like this: enum Singleton { INSTANCE; // other methods and what not on the instance go here }
Singletons are fine if they're simple enough and immutable. Think things like Collections.emptyList(). You can also test these just fine if you really want. 
Yeah my statement was probably too broad. Collections.emptyList is actually a good example.
I found ktor documentation to be somewhat lacking or confusing when I looked at it a few months ago. Specifically, locations in routing were odd. Look for related tests, and they'll answer most of your questions.
Is this going to be a trend to say a Java library is meant for both Java and Kotlin when saying so is redundant? I could understand if there was also a Kotlin add-on to the library to take better advantage of kotlin-only features, but his library contains absolutely no Kotlin code at all. It's pure Java.
Is there a way I can use .filter() then to omit the possible null values?
This works for me: fun test(): List&lt;Calendar?&gt; { val times = HashMap&lt;String, String&gt;() val things = times.map { (str, _) -&gt; val dateFormat = SimpleDateFormat("HH:mm") try { val date = dateFormat.parse(str) val cal = Calendar.getInstance() cal.time = date cal } catch (e: ParseException) { null } } return things } Performance tip: It's definitely not a very good idea to create a new DateFormat for each value!
I think so. You transform needs to return `Calender?` and then call `filterNotNull()` (returns a List). I don't think you need the specific parameter on the `.map` call. In the end the function is: val things = times.map { val dateFormat = SimpleDateFormat("HH:mm") try { val date = dateFormat.parse(it) val cal = Calendar.getInstance() cal.time = date return@map cal } catch (e: ParseException) { return@map null } }.filterNotNull()
Much thanks! Good catch, I moved it out to the parent class. I found .filterNotNull(). confused me at first because in js filter means exclude, but it does what I need for getting only the not null results.
&gt; typealias post = String &gt; post Who did this? Capitalize your typealiases folks.
What techniques are you using to minimize "translation" issues?
Keep static members out of usual classes
That's not always a simple task. Imagine a simple "Book" class that contains an ISBN. What is its default value. It can't be "null". What if it were a val and not a var? This isn't easily solved with defaults as there is no default for this. You then find yourself trying to use then "null object" pattern hack that you do in Java. It just doesn't work well. The plugin helps a lot when you are using ORMs and such. This is why it was developed. Anyway, I was just linking to actual Kotlin solutions, it's valid.
Just say it's for the JVM
Damn, completely forgot the name of that podcast. Thanks for that and I'll definitely be tuning in if this happens.
Hidden feature: Works well with Groovy too ;).
Mostly mobile, but I would like to be platform independent as much as possible. With Kivy I also successfully build for Windows, but if I can compile it to JavaScript, I could target desktop users through the web. Jython seems to be limited to Python 2.7 and the last update is May 2015? I'm managing a lot of Japanese characters, so I rather avoid unicode trouble and stick with Python 3.
Maven is 12 years old, Gradle is 10 and Ant is 16 years old, when does a program go from new to not new? I think we have wastly different ideas of what new and heavy weight means :)
You are exactly right. My example was actually dumbed down for simplicity. The real problem I was experiencing was instantiating new objects when they are extended from a superclass that use @Inheritance, etc... Thanks for explaining better than I did.
This is very useful! Thank you.
Idea was to demonstrate specific issues that will arise in more complex scenario without overloading the reader with unnecessary stuff. In any case, I think separation is cleaner because: * entities can be converted to simpler form to control what is transfered over the wire * different protocols can use the same repository (e.g. JMS) * protocol-specific security configuration can be moved to separate class. While it is possible to put everything in the same class, it would be hard to maintain it and hard to separate it if needed. It might be a different story for Spring, though. 
You may also want to check out Javalin. I haven't done more than check out the tutorials, but it looks very promising. https://javalin.io/tutorials/vuejs-example
Had my generator merged today. I thought I'd share in case anyone is interested in providing feedback or whatever. There are a few missing things for minimal API client usage, specifically enums (as top level classes or inline/nested classes) and default responses aren't currently handled. I have a pending PR to handle array serialization more easily. I consider this one less of a problem, but it currently only supports JSON APIs plus Form Data and File inputs. I'll need to find an XML serialization library with a small footprint since this is targeted more for Android first. I'll look into an Android switch to the generator to use built in Android libs as well. My list of todos is tracked by https://github.com/swagger-api/swagger-codegen/issues/5730 if anyone's interested in contributing.
I cannot speak for the whole Kotlin community nor the devs. Judging from the talks I've seen and the recent announcements, they intend to co-exist with Java in the JVM space (re-use all existing libraries) and at the same time, go to places where JVM doesn't want to go, ie. Native Kotlin on embedded or possibly even IOS devices. 
Overall, I think they want to have kotlin support all platforms. Most languages don't go near the JVM, but the JVM is still the biggest platform. Kotlin can support JVM, Web, Mobile, and Native. I don't think any other language can support all four major application platforms, other than Scala. 
I understand the arguments against IDEs, but I think Kotlin in particular benefits greatly from learning through the IDE, with it being made by a company that first and foremost produces an IDE! If you insist on learning through the command line, I'd recommend opening up your code in IntelliJ every once in a while and seeing some of the suggestions it gives you. It's really smart at showing off more efficient ways you can be doing things. Just my opinion!
Also ask on stack overflow
Actually I don't mind extension functions much. The real killer are extension function literals.
you should use constructor injection
You don't even need the `filterNotNull` as `mapNotNull` exists
Why don't you capture a memory snapshot to see exactly where the memory is being used?
T::class.java only works in reified inline functions
How do you do that? I'm running the newest version of IntelliJ...
Why didn't you use Intellij and auto convert ;)
In your first example, your `random` parameter can only be accessed during instance initialization. In your second example, `val` declares `random` as a property of the class, which can be accessed any time. The Java equivalent is generating a `String getRandom()` method
Thanks, I already read that. But part II promises a part III. That's what I'm looking forward to :)
As u/ZakTaccardi pointed, the second example creates `random` property, which you can think of as equivalent Java `private final String` field and public getter. Just wanted to say that if you know Java reasonably well and you're using IntelliJ, I advise you to use `Tools &gt; Kotlin &gt; Show Kotlin Bytecode &gt; Decompile` every once in a while. It really helps you to understand the generated bytecode.
I would have assumed that getter and setters are created only if you make a data class?
I completely forgot that was an option! Thank you
The example was abusing Utils classes (and he admits this in the article), but fixing that isn't at all related to the use or abuse of extension functions.
Do you plan on eventually making articles on DL4J? You could probably even use one of other popular frameworks running outside of JVM now that Kotlin Native is there.
&gt; Though the majority of progress has been made on Java and Android, it's not a Java/Android language. That sounds a little vague, and makes me wonder what needs to be done yet. 
You can use an intellij idea intention to generate it. 
fixed. Also, came across a weird scenario which took a while to figure out. Posted a SO question here. Thanks for your patience. https://stackoverflow.com/questions/44276695/is-jsname-annotation-required-for-every-method
Thanks! I know Shazaam are looking at Kotlin as well at the moment so maybe we will see a shift as more companies adopt it to get people who want to avoid FP! :D
I worked with a team that transitioned from Java 7 to Kotlin 1.0 for building web services with Spring Boot. Everyone was happy to make the switch. I believe the IntelliJ tooling is what made the learning curve so easy. Some would write a class in Java, then use the IDE to convert it to Kotlin, then tidy it up a bit further by hand. Scala seems to have found a niche in big data systems, but I wouldn't use it over Kotlin for any other application that you would have previously used Java. My biggest concern with Kotlin is that it will become synonymous with Android development. It's a great language for any JVM platform.
Hi Joe, since you're London/NY based you might have read that R3's Corda is written in Kotlin, I think this sums things up pretty well: https://www.corda.net/2017/01/kotlin/ As a Scala developer myself I'd always prefer a Scala job though. You get used to powerful tools even if they make shooting yourself in the foot easier. Also it means I work with people who are willing to deal with more powerful tools, even when it adds some (reasonable) complexity. I don't think the demand for Scala developers will go down anytime soon. You probably how hard it is to find experienced people. That said I'm sure Kotlin will see a solid uptake. It's already the case in the Android space, and many Java shops will realize it can be a gradual, drop-in replacement.
Then you should not use Kotlin. It has a lot of magic over java. Oh wait, you should not use java. It has a lot of magic too! Garbage collector, array bound checking... In fact, you should only use assembly. Only way to be safe against that evil implicitness! More seriously, that kind of ideological statements is worth nothing. If the OP toString method is used to show stuff to his users, then I would agree that this kind of "magic" would be bad. But if it's for his application logs / debugging, then Lombok is perfectly fine. code generation is also fine.
You should ask the same question on /r/scala :) 
Not sure if this is breaking post rules but if you would like to transition into Kotlin then feel free to ping me a direct message! Like I said I have a few clients who use it which is why I'm trying to get my head around it!
I am based in Poland, not sure if it fits you.
Sure you can entirely misunderstand my statement, but you ignoring the kind of implicitness I was referencing that should have been obvious. With the example here it can be relatively simple to defend using the magic annotation, but then where does it end? The more methods you get from annotations the less you can directly find when your looking for how a method works. Sure, well understood libraries that depend on annotations can be understood well enough, but at some point you should draw a line. Is it really so hard to write a toString? At least hard enough to pull an entire extra dependency just to have one generated for you? I'd say no. Not at all. 
What sort of things are you looking for that would convince you that it will work on the server side? There are already Spring plugins to use Kotlin. Jetbrains themselves makes several web tools (ktor - web framework, exposed - ORM) and there are a ton of testing libraries available.
Won't work yet if the object is extended from another one. Does not give you the super fields to choose. I hope they fix that. But I rather automagically.
I get it, it's easier. But then when you add that sensitive data field down that road and you're no longer thinking about your magical toString that does it all it's suddenly dumping this sensitive information into all of your logs -- which could have been avoided by having the extra step of having to manually add new fields to toString, which can very much be the flow of adding a new field. 1. Add new property 2. Update toString if necessary 3. ???? 4. Profit
Do not forget 100% interop with Java. That really cannot be understated. As we're seeing with large institutions refusing to rewrite COBOL systems, being totally inter-operable with Java allows for gradual adoption and will ensure that Kotlin will thrive everywhere Java does now and into the future.
Think of all the MMORPGs that came before World of Warcraft. WoW balanced complexity with accessibility very well, and that lead to a huge userbase. Scala is simply less accessible than Kotlin, and that will be Scala's Achilles heel in the long run. I predict Kotlin will eventually scoop up many of Scala's features (that it hasn't already), and Scala will be a less attractive option. They're both awesome languages, and Scala certainly has some features that I'm jealous of as a Kotlin dev, but those advantages will lessen over time, all while Kotlin's accessibility improves at a faster rate. And now with Google officially embracing Kotlin, it's a pretty big deal.
The [documentation](https://kotlinlang.org/docs/reference/control-flow.html#if-expression) addresses this directly. &gt; In Kotlin, if is an expression, i.e. it returns a value. Therefore there is no ternary operator (condition ? then : else), because ordinary if works fine in this role. Note: This page is the first result when you search of "kotlin ternary".
I am aware that documentation addresses this, but as I said in my edit that you might've missed I don't actually understand why they decided to get rid of it. Ternary is way more compact and it's one thing that I wish that Kotlin would have. My personal bet is that it's way to similar by first glance to the elvis operator ?: and it could create confusion.
I think, one can not say that Scala is better than Kotlin or vice versa. Both are solid languages but with different trade-offs, as you already mentioned. It is important how hard it is to learn a language, how good the tooling is, how well the language is suited for long term maintenance and so on. 
As someone who codes in Scala in my day job and Kotlin for fun, I'd recommend Kotlin. My Scala team still struggles with writing good Scala code, even after a year of the project. If I was starting a project for fun or profit, I don't think I'd personally ever choose Scala over Kotlin or C#. Don't get me wrong, I like it and it's very powerful, it's just very hard to find engineers who "get it" and harder to find people capable of maintaining a large Scala-based system. 
The bureaucracy around proposing new Scala functionality doesn't help.