You cannot use suspend functions in code like this: sequenceOf(1).map { nonSuspendFunction(it) } And, afaik, there are no parallel sequences
Thanks for the quick response
I don’t think it’s fair to have the number of developers working on something as a con. I’d rather take a few really experienced and committed people over an army of well intentioned but unskilled ones. I look at how Kotlin is evolving, the humbleness and clear smarts of the brains behind it and am thoroughly happy with Kotlin.
Unfortunately new project wizard can be misleading sometimes. This is not the way how one creates a multiplatform JVM/JS project. Try creating it with Kotlin -&gt; Kotlin (JS Client/JVM Server) new project template instead.
I was excited to try using Graal to build compact [native images](https://www.graalvm.org/docs/reference-manual/aot-compilation/). Graal doesn't support coroutines but there is a [workaround](https://github.com/HewlettPackard/kraal). While the workaround allowed me to make progress - I wasn't able to make a simple [Kweb](https://docs.kweb.io/en/latest/intro.html) app due to it tripping over various classes it didn't like. I gave up after about an hour of tinkering. Hopefully it will improve to work more reliably - being able to compile a JVM project to a compact native executable would be super-useful.
In my experience intensive use of mocking libraries like Mockito is a serious code smell
Checked out kodein di?
Great stuff. Is there complete code posted?
Has anyone seen a library for in app subscription using multi platform?
How many gradle files are you dealing with? This is almost absurd. It should take less than an hour for most projects. Less than a day for HUGE ones. 
I'm pretty sure there are Kotlin wrappers for React but I'm not sure how updated that is going to be. To me... Having Kotlin target JS is really not needed. I consider it an interesting addition, but if I'd rather use Typescript with React. Kotlin/Native -&gt; WebAssembly would be pretty neat though
Yes: [https://github.com/jeremyrempel/multitest](https://github.com/jeremyrempel/multitest)
Yeah, they have wrappers quite a few actually for css react router , react, react dom etc etc already. I was just curious if anyone else out there is using it
Paying a stranger to do that for you is probably not the best idea because you'll be stuck if you encounter an issue with it in the future. Taking the time to learn it yourself will pay dividends over the long haul.
&gt; Android officially supports Kotlin as do Spring and Gradle
You are talking directly to my heart at this very moment. &amp;#x200B; I wish Kotlin/JS + react was more used/widespread as well. I think it's mainly awesome used in conjunction with Kotlin Multiplatform because you get to share code with other clients (Android, iOS) like the domain and network layers for example. &amp;#x200B; What annoys me is that it's not as simple as Android in terms of gradle dependencies and that hurts it a lot IMHO. To have transitive dependencies be deployed to JS as well [I had to do something that feels like a hack](https://github.com/cfnz/muirwik-starterapp/issues/2) so that all js files I depend on will be included in my bundled js file. &amp;#x200B; Also, you can go with Gradle [or without it](https://github.com/JetBrains/create-react-kotlin-app), but it's not clear what is advised to do from Jetbrains. If we go without it, how are we supposed to use it with MPP then? What about other libraries not wrapped yet by Jetbrains? How do you build one? &amp;#x200B; I wanted to use [Material-UI](https://material-ui.com/) and got lucky and found [this project.](https://github.com/cfnz/muirwik-starterapp) but I am stuck on an issue with kotlin-dce-js and I have no lead on how to solve it right now. I love using Kotlin to write the app but I have a sour taste in my mouth about the whole experience of deploying this app so far.
Or if it's such a hassle just don't convert them... Or start by doing one or two lol
I don’t think I’ll be stuck as I know kotlin, just don’t really have the time to do it
Less than 10. I might take a groovy/kotlin expert leas than an hour but I wrote quite a few custom tasks which I really don’t fancy having to rewrite 
Woow! Thx. 🤘
You mean using Kotlin in react? i'm fine with TypeScript but would be awesome, though
If you're considering this because you find it tedious, check out this Kotlin DSL converter: [https://github.com/bernaferrari/GradleKotlinConverter](https://github.com/bernaferrari/GradleKotlinConverter) 
So are we facing a better alternative to ReactNative for multiplatform solutions or what?
Kotlin.
If you're building rich webapps in Kotlin you might also want to take a look at [Kweb](https://docs.kweb.io/en/latest/). It's not built on React but it's designed to solve quite a similar problem. (Disclaimer: Kweb is my project)
You're welcome! Sorry for the formatting I'm on mobile.
TransactionsModel vs TransactionModel
one is a var List&lt;TransactionModel&gt; the other one is a MutableList&lt;TransactionModel&gt;
Also it's `TransactionsModel!` with a bang
React Native, Flutter are inherently flawed imo as they either introduce additional abstractions, languages, layers or attempt to reienvent the wheel. KN is a much more pragmatic solution to code sharing with less friction.
Also the first one will fail when `obj` is `null`, the second one will succeed.
Also you can integrate as little or as much as you would like in your team's project. If you want to just test it out with utility classes, you can do that. If you want to share the network layer, not an issue. Cross-platform tools require full adoption, and often in a language not often familiar with mobile devs. 
Why do you have to rewrite them at all? The Gradle team have said that the groovy DSL isn't going anywhere.
Are there any issues if the "common library" is in a separate repository, and just want to import it?
So it’s easier to maintain, I don’t want to learn any more groovy that the amount I’ve already acquired by hacking together what I have already 
So it’s easier to maintain, I don’t want to learn any more groovy that the amount I’ve already acquired by hacking together what I have already 
Nice I’ll check it out - was looking for something like this but the one I found didn’t look like it was being maintained 
I think I've seen enough normal projects that are covered with Unit tests + Mocking. And don't see anything "generally wrong" about it. &amp;#x200B; Problematic may be too intensive use to do something simple or strange things. &amp;#x200B; I believe all these advanced features are called "advanced" because they should be used additionally to the simple mocking pattern (specify behavior, call, verify) only when it is really needed. &amp;#x200B; Anyway, I don't like ideology and I actually think it is good that there are many opinions. So welcome to have your own. &amp;#x200B; I call MockK library because it does not set rules and other limits. I think every approach should be critically reconsidered for the exact project/task. If you won't really use the brain(but rather a set of ideological rules) nothing will help you, not frameworks nor best practices.
So if you haven't used create react app yet there is a kotlin version to get you setup super quick. When you need to make webpack changes you can eject out and do so or even see how they configured everything. It was really insightful because I knew about this for react but not for a kotlin build. If you want to know how to wrap or build one you should look at what they did for smaller packages. The facade pattern is what it's called. Yeah, I feel like most kotlin developer are probably Android devs so it's just in jetbrains rocket fueled team to through some extra sugar out there haha.
You can have dependencies on common libs
Haven't tested it, but I think you could go with something like this: enum class ENUMD(override val desc: String, override val XX: Int) : Thing { D1("DERP 1", 10), D2("DELTA 2", 20), D3("DROP 3", 50), D4("DIG 4", 100) } enum class ENUMQ(override val desc: String, override val XX: Int) : Thing { Q1("QUACK 1", 99), Q2("QUACK 2", 80), Q3("QUACK 3", 50), Q4("QUACK 4", 30) } interface Thing { val desc: String val XX: Int } private inline fun &lt;reified E&gt; test(myenum:Enum&lt;E&gt;) where E : Enum&lt;E&gt;, E:Thing{ enumValues&lt;E&gt;().forEach { println(it.name + "," + it.desc ) } } fun main() { test(ENUMQ.Q1) }
Can I use this for multiplatform projects? 
 interface Describable&lt;T&gt; { val desc: String } enum class ENUMD(override val desc: String) : Describable&lt;ENUMD&gt; { D1("DERP 1"), D2("DELTA 2"), D3("DROP 3"), D4("DIG 4") } enum class ENUMQ(override val desc: String) : Describable&lt;ENUMQ&gt; { Q1("QUACK 1"), Q2("QUACK 2"), Q3("QUACK 3"), Q4("QUACK 4") } inline fun &lt;reified T&gt; test() where T : Enum&lt;T&gt;, T : Describable&lt;T&gt; { enumValues&lt;T&gt;().forEach { println("${it.name}, ${it.desc}") } } fun main(vararg args: String) { test&lt;ENUMD&gt;() test&lt;ENUMQ&gt;() }
Thank you!
Thank you!
 &gt;So, am I doing something horribly wrong Not horribly wrong. But always use expressive names for your classes that would prevent that. About RxJava maybe there is RxKotlin? 
Cheers, I hadn't thought of looking into RxKotlin I agree with expressive names, but my intention for these Result and Error classes was to represent generic Result and Error base classes that would be used throughout all domains of the application (perhaps BaseResult and BaseError are in order?). In any case, perhaps I'm just having these problems because I'm starting a new project, but I'm also slightly concerned about what other class names exist in the stdlib which will take precedence in the future. Thanks for your comments!
I personally like to prefix them with the app name. Then the names are probably unique. 
Exactly!
What is thw link to Kotlin? 
What does this have to do with Kotlin?
I've not touched it in a while. But I had ported material-ui to kotlin. &amp;#x200B; [https://gitlab.com/AnimusDesign/KotlinReactMaterialUI](https://gitlab.com/AnimusDesign/KotlinReactMaterialUI)
I'll have a look, thank you!
I'm in this boat right now. I'm working on a very UI heavy personal project right now. For basic crud apps I was using Kotlin React, plus personal bindings for material-ui and data fetching via XML http request. I've moved on though, this is an interesting read. [https://gist.github.com/sdeleuze/0da8c3d6a43c659977a16e017020503b](https://gist.github.com/sdeleuze/0da8c3d6a43c659977a16e017020503b) &amp;#x200B; When I stepped outside of xml http request and material-ui. I was spending alot of wasted time trying to back port type script bindings. Or fixing weird bugs. I found multi platform beautiful. Working a full stack of backend, desktop, web, and mobile was absolutely gorgeous. There were pain points, lack of hot reloading, larger bundle sizes etc. &amp;#x200B; However there was something I hit my head against, and caused me to stop working on my react ports. It was graphql and the gql tag. I've become a big fan of apollo and graphql for react. That was just something I had trouble with. But even on the JS side, unless the server is also in JS it can be hit or miss. &amp;#x200B; I moved back to java script and native react, and have felt like I'm bashing my head against the wall. There are these minor warts that I find very annoying. Create react app has subpar support for typescript, unless you eject and make modifications. Tyepescript is also missing pattern matching, which is a killer feature with graphql. Reasonml was good, but niche and I encountered a number of fringe bugs as well. Flow is not as active to my understanding. It was my preference for react as well. Internally a lot of Facebook appears to be on ReasonML. &amp;#x200B; I want to check out kweb next. But I'm also very curious about web assembly. Looking at blazor from C#/dotnet core, makes me really want something similar. If we could target web assembly that would be ideal. I don't really see winning over the JS crowd at this point over typepscript. While I see a number of missing features between the two. Type script is often also used as the backend as well as the frontend. Most JVM shops I see with job listings are using angular, jsp, or google web toolkit. &amp;#x200B;
is this r/programmingcirclejerk ? oh no it's not even that, just a shitty scam, lame
It's true, my answer wasn't complete! I'll edit it and reformat that ugly mobile text!
Kotlin for Android developers,the book or articles by Antonio Leiva, plus the guy has an online course, but I don't know if it's good or not.
Just like Kotlin for iOS devs.
Java 8 if you can ignore Android M and lower. Other than that it seems Android will never catch up with Java, specially now that Java adopted 6 month releases and we have radio silence regarding 9 - 12 support. There seems to be some work going on on AOSP, but you need to go read Gerrit review comments and tea leaves to figure out about future Java support.
Is this lack of support for Java 9+ due to the copyright case of Oracle and Google about API infringements?
I think there are bunch of courses available in udemy. I completed this free course and It helped me to learn basic stuff of kotlin. If you are know android development with Java I think this basic stuff will be help to get start with kotlin. It really interesting language and you will enjoy it. [https://www.udemy.com/kotlin-programming/learn/v4/overview](https://www.udemy.com/kotlin-programming/learn/v4/overview)
No idea, there are AOSP commits already regarding Java 9, just radio silence. As usual I should note, that plenty of commercial JVM vendors don't have any special issues being part of the community, instead of doing their own thing. https://en.wikipedia.org/wiki/List_of_Java_virtual_machines#Active_2
I wish there was more heat behind it as well... I love it. Once i got the hang of writing custom bindings its is beautiful...
Somebody did it for go https://github.com/therecipe/qt Maybe a similar approach for kotlin?
You either use val input = async { B() }.await() or val input = suspendCoroutine { it.resume(B()) } probably the second if it is a dialog you are waiting for.
Function `b` should be defined as a suspending function, and `c` should take the output from `b`: ``` suspend fun b(): String { ... } fun c(input: String) { .... } ``` Then, in `main`: ``` launch { c(b()) } ``` What happens: 1. main calls `b()` 2. `b()` suspends until output is received 3. `c()` is invoked with the output from `b`
You can use channels, here is an example [https://gist.github.com/schwiz/c4aaabb1b99fe7199c03def5cd51c300](https://gist.github.com/schwiz/c4aaabb1b99fe7199c03def5cd51c300) &amp;#x200B; &amp;#x200B;
FYI, I've updated the above to demonstrate both compile-time `test&lt;ENUMD&gt;()` and runtime reflection `test(ENUMQ.Q1)`.
What's the use case for something like this? I don't get why you wouldn't just give them proper names in the first place. 
Have you learnt kotlin yet? Kotlin/js is pretty straight forward if you know kotlin and JavaScript 
Yes I mainly use kotlin/jvm in backend and android.
Well the JavaScript section on kotlin.org teaches you pretty much all you need to know 
Why don't you just use packages?
I'll check it out. Thanks.
Bear in mind that the lack of type libraries for kotlin/js can make it a pain to use compared to Typescript.
You should never use val input = async { B() }.await() You should use val input = withContext(IO) { B() } Kotlin's `async` is only to be used for concurrency, of which there is none here.
" But one can learn another language or several at the same time without having to sacrifice anything. " With the power of ubiquity?
Your "opening a dialog" function should look like this: suspend fun b() = suspendCoroutine&lt;String&gt; { cont -&gt; val dialog = ... dialog.onOK { cont.resume(extractResult(dialog)) } dialog.onCancel { cont.resumeWithException(DialogCanceledException()) } }
&gt;Bear in mind that the lack of type libraries.... Did you mean type-safe libraries? Can you elaborate on that?
A folder in kotlin is essentially the same as a class file namespace in Java. in java ``` PackageName (folder) -- ClassName.Java ----ClassName (class) ``` is the same as kotlin ``` PackageName (folder) --ClassName (folder) ----ClassName.kt ------ClassName (class) ```
I mean type definitions for the JavaScript/typescript libraries you want to call. Lots of JavaScript npm modules come with type definitions for use with typescript. The lack of something similar for kotlin makes it less pleasant for JavaScript development, at least in my experience.
you can learn kotlin by online courses or if you don't want to pay for online courses, there are so many tutorials that you can read and learn
I mainly use kotlin/jvm in backend and android.
They are helper classes meant to be used only within given file, why should I bother giving them unique name? My current use-case is subclassing ItemDecoration for recycle view. Each list view in application can have different implementation of ItemDecoration, but they are private to that view and I see no reason to come up with a fancy name for each.
Both files are part of the same package.
So if I put this intermediate folder, "ClassName", in, there will be no conflict even if I do not change package name in any way. Do I understand this correctly? 
So can you just nest the helper class inside the class that needs it? Or do something like create an interface and have the class implement it directly 
You cannot have the class in the same namespace as a package with the same name despite access modifiers. `src.packageName.TestClass` class name will collide with `src.TestClass` class name. You can put them in separate packages however and it would work fine.
I don't know why I gave that alternative at all. I don't use that anywhere in any of my coroutine code. suspendCoroutine is what i would use in this case. 
 val input = suspendCoroutine { it.resume(B()) } This code is exactly the same as val input = B() but with more cruft added. If the `B()` call is blocking, then the entire expression will be blocking as well. The coroutine will never actually suspend. If the `B()` call is non-blocking, then it makes no sense to pass its return value to `cont.resume()`.
I work 99% in Android. All non custom dialogs work by callback, so it is the way I think. Now I would probably have made the suspendCoroutine in B() instead of having it outside. But there would still be a need to have it. Unless I have missed another way of handling callbacks? 
Yes, you can't just resume the continuation with the return value of `B()`, you must register some callbacks. I outlined it in [this other comment](https://www.reddit.com/r/Kotlin/comments/assena/how_can_i_execute_a_coroutine_which_is_dependent/egy28rt).
That's the problem. You can't define 2 non-nested classes with the same name in the same package. You could move each file to a sub-package.
There are two questions here: 1. How do I mock a `lateinit var`? 2. How can I make my example code more testable? I don't know enough about Android to say how you should refactor your Android code, so I'll focus on the first question. If you want to change the value that gets stored in a `lateinit var`, then you need to change the code that writes to the `var`. Note that `lateinit var`s aren't write-once; you can write a value to them and then later write a different value to them. If you want to mock an *access* to a `lateinit var`, then it's worth mentioning that a `lateinit var` in an implementation class can be the backing for a plain `val` or `var` in an interface. Your problem seemed to be more along the first (wanting to change the value stored in a `lateinit var`). And to that end, yes; if there's a way to change your Android activity so that it's not constructing the `UserManager` on its own, that would be preferable. Either be OK with your test using a real `UserManager` or change your class to allow any client code to specify its own `UserManager`. 
There are no dedicated books at this moment on Kotlin.js, and it's not even mentioned in the Kotlin in Action book. As someone who really likes Kotlin and programs in it daily, I'm not even sure if you should pick Kotlin.js above Typescript. Kotlin on the backend, Typescript on the frontend is something I'd recommend. I wrote a small comparison article on it here: https://www.jworks.io/dart-vs-typescript-vs-kotlin-js/ Any reason why TypeScript doesn't 'do' it for you?
I explored this topic a few months ago and decided against using kotlin-js based on the notion that the whole ecosystem feels a bit in flux/immature. I'm also a backend developer (using Kotlin of course) and I ended up having to reaarchitect our frontend. There are a few issues I see. * The kotlin-frontend plugin was only updated for Kotlin 1.3 recently (i.e. this month). Meaning that for the past 3 months there was no workable solution to using that with co-routines and all the other stuff that got released with 1.3. Fixing this seems to have been low priority. * Kotlin native and wasm are happening but kotlin-js is also happening, it's not clear what is the future or vision here. Kotlin native is close to release but the wasm part of that feels a bit sketchy still. * It seems there are currently two ecosystems around kotlin-js, one is gradle centric and one is npm centric. In the gradle ecosystem all your dependencies are going to be other kotlin-js libraries that you pull in via maven. In the npm world, you are basically using kotlin-js as a drop in replacement for typescript and you use e.g. webpack for transpilation and depend on non kotlin dependencies via npm. My main issue is that the message on frontend kotlin in the browser is very mixed right now. You could do this, you could use that, you might want such. There seems to be no strong opinion either way. It's all a bit uncertain/unpolished right now. I've seen the kotlin react stuff and walked away from it. Basically it solves nothing. Webpack is a configuration nightmare, react tooling seems to assume world + dog uses typescript. Going against the flow in an ecosystem that messy is a non starter for me. I have good hopes for this to settle soon. Kotlin is on paper awesome for supporting Android, IOS, and web with one code base. Looking at the Rust ecosystem they are now very ambitious on the wasm front and it is not about doing cute little rust wrappers around react/elm/whatever but just completely rebuilding a new ecosystem from the ground up with rust everything. My view is the same needs to happen with Kotlin and kotlin native + wasm is the place where it needs to happen. This requires some work on the browser front to figure out garbage collection, threading, efficient access to the dom, etc. This means in my book, kotlin-js is a stop gap solution until that happens. &amp;#x200B;
That was so insightful. I spent the last 4 hours being overwhelmed by the complexities you've mentioned. Thanks!
Thanks. It's not that I hate Typescript, I just prefer kotlin, and I think it's more mature. However I've only been using kotlin/jvm, so...
https://www.bignerdranch.com/books/kotlin-programming/ https://www.manning.com/books/kotlin-in-action
I've read Kotlin in Action, it only covers kotlin/jvm.
I don't think any special powers are required to learn a new programming language. Maybe if it's Haskell 😆
I am in same boat, kotlin on backend in great, then i look at your react/js/typescript mess in the front and I despair :(
&gt;It seems there are currently two ecosystems around kotlin-js, one is gradle centric and one is npm centric. In the gradle ecosystem all your dependencies are going to be other kotlin-js libraries that you pull in via maven. In the npm world, you are basically using kotlin-js as a drop in replacement for typescript and you use e.g. webpack for transpilation and depend on non kotlin dependencies via npm. &amp;#x200B; It looks like kotlin frontend Gradle plugin allows you to use npm dependencies from Gradle. [https://github.com/Kotlin/kotlin-frontend-plugin#setup-npm-dependencies](https://github.com/Kotlin/kotlin-frontend-plugin#setup-npm-dependencies) &amp;#x200B;
Thank you!
Dependency injection. Inject your UserManager and use the application context object and then set up your DI framework to inject a mock in your test. How you do this varies, but I'd suggest Koin for simplicity or Dagger if you need a more robust solution.
Is there any sort of UI lib that gives people a declarative/reactive way to build UI? I never want to go back to imperative UI building (e.g. jQuery because it) *sucks shit*
Rey wenderlich is nice and professional. 
We use Kotlin React at work. It works wonderfully. However, I hope they soon fix the issues with false warnings like [https://github.com/JetBrains/kotlin-wrappers/issues/92](https://github.com/JetBrains/kotlin-wrappers/issues/92)
if you indent with 4 spaces, your code will be parsed as a code block
Thanks for tip :)
That's exactly what Kotlin delegation is made for imo. You should do it
Ill still use @JvmOverloads anyways, but good to know that it might cause issues, for if i ever run into any. Thanks for the read.
No, I don't really need bloated libraries with zounds of dependencies to do my daily job. Kotlin supports the W3C api which I can use from Kotlin code so this is more than enough. I can implement anything else I need on top of that. I also use some Kotlin multiplatform libararies (like Cobalt) which have some functions I need (like data binding).
There is extension funtion for Executors, something like `.asCoroutineContext()` sorry im on mobile atm and i dont remember exactly its name.
[https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.util.concurrent.-executor/as-coroutine-dispatcher.html](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.util.concurrent.-executor/as-coroutine-dispatcher.html)
It's not hard to check the parent class to see whether this will be an issue, and then you can use @JvmOverloads where it's safe to cut down the boilerplate.
How exactly would I use this? The docs seem...Spartan...
Thanks! I ended up hacking a gradle config based on what Intellij created (converted to kotlin DSL) Putting it here asking for feedback or if anyone needs it: [https://gist.github.com/shivawu/75d3bc34851ad15d562a530c89cba761](https://gist.github.com/shivawu/75d3bc34851ad15d562a530c89cba761)
Thanks for answer, now I need to sold this refactor to my superrior :)
I found the article somewhat misleading. Typically, when comparing the pros and cons of 2 options to decide which one to take, you would list these pros and cons as they relate to each other otherwise it becomes meaningless. Here's a meaningless example comparing the pros and cons of cars vs. airplanes: Cars Pro: You can travel much faster than running This pro is a true statement but doesn't help us decide between cars and airplanes. If I didn't know any better, this statement might make me think that choosing cars is better if travel time was a priority.
 val es:ExecutorService = Executors.newFixedThreadPool(4) async(es.asCoroutineDispatcher()) { ... }
The parent class could change this internally at any time though.
Super!
This isn't the best way to use it, it should be val es = Executors.newFixedThreadPool(4).asCoroutineDispatcher() Also, you probably won't need `async`, but `withContext(es)`. If you truly need concurrent background jobs, then you must use `async` within a `coroutineScope`, otherwise an exception within `async` will bring down the entire coroutine.
Which would you do? private suspend fun execute() = withContext(es.asCoroutineDispatcher()) { Thread.sleep(1000) // simulating a slow command 1 } or private fun execute() = runBlocking(es.asCoroutineDispatcher()) { Thread.sleep(1000) // simulating a slow command 1 } I'm quite new to Kotlin as you can probably tell.
The behavior of your second example is identical to this: private fun execute() { Thread.sleep(1000) return 1 } So definitely don't use that. `runBlocking` is to be used just to establish the infrastructure that allows you to start coroutines. It's never a part of business logic functions. I'd rewrite your first example to private suspend fun execute() = withContext(es) { Thread.sleep(1000) 1 } because I'd make `es` a coroutine dispatcher and not an executor service (as I showed in the comment you replied to).
Ok, thanks! What libs should I use to avoid having to wrap blocking operations for, for instance, HTTP requests? Something like this? https://github.com/korlibs/korio
How about something like this: ``` data class Version( val major: Int, val minor: Int, val patch: Int, val qualifier: String ) { companion object { operator fun invoke(version: String): Version { val regex = "(\\d+)\\.(\\d+)\\.(\\d+)-?(.*)?".toRegex() val matchResult = regex.find(version) return Version( major = matchResult?.destructured?.component1()?.toInt() ?: throw IllegalArgumentException("Major not found"), minor = matchResult.destructured.component2().toInt(), patch = matchResult.destructured.component3().toInt(), qualifier = matchResult.destructured.component4() ) } } } ``` By using a data class you get nice `equals()` and `hashCode()` for free (and a `toString()`, but you can override it). Also, having the version parts in the primary constructor seems more semantically correct, since that's what you ultimately want to store and refer to. By using an operator function in the companion object, you can still create instances as if it were a constructor (eg: `Version("1.2.3-4")`), but you get to still use the primary constructor and a single Regex instance. Some other ideas would be do add default values for `minor`, `patch`, and `qualifier` so they're not required. You could also try something like this to destructure just once: ``` val (major, minor, patch, qualifier) = matchResult?.destructured ?: throw IllegalArgumentException("Major not found") return Version( major = major.toInt(), minor = minor.toInt(), patch = patch.toInt(), qualifier = qualifier ) ``` Is this what you're looking for?
Not sure it helps you, but I did actually write a [library](https://github.com/ed-george/VersionKontrol) to handle version codes in Kotlin. It's been a while since I looked at it, but it might give you a few ideas
Multiple constructors tend to not be a possible solution since the call to the primary constructor must come first. Instead, you can create a factory method to parse the string and return an appropriate Version object. Also, as the destructed name suggests, you can use destructuring to cut down the lines of code. See here for a working example: https://pl.kotl.in/ryDjJ7y8V
It's possible, I've changed a little your example: [https://pl.kotl.in/BJOXK7kIE](https://pl.kotl.in/BJOXK7kIE). The only thing to note is that there are four calls to parse() function instead of only one call like in your example. I'm not sure about Kotlin, but in pure functional languages parse() function would be optimized to only one call. 
I agree, this does seem possible.
This answer is most likely what the OP is looking for.
With Kotlin you should use factory functions instead of raw constructors. At least in the standard library, it is idiomatic to name your function identical to the class (like constructors in JavaScript). So this is something you can write: class Version( val major: Int, val minor: Int, val patch: Int, val qualifier: String ) { override fun toString(): String { return "$major.$minor.$patch-$qualifier" } } fun Version(version: String): Version { val regex = "(\\d+)\\.(\\d+)\\.(\\d+)-?(.*)?".toRegex() val matchResult = regex.find(version) return Version( major = matchResult?.destructured?.component1()?.toInt() ?: throw IllegalArgumentException("Major not found"), minor = matchResult.destructured.component2().toInt(), patch = matchResult.destructured.component3().toInt(), qualifier = matchResult.destructured.component4()) } 
"IDEA is bitching to me" just made my day. Thanks for the laugh!
This is a really neat solution, thanks for sharing!
How didn't I think about that before? &amp;#x200B; That is so simple and idiomatic indeed.
That's a good solution, but I still have some gripes: * Your IllegalArgumentException's message isn't really helpful. You should rather go with something like "&lt;$version&gt; is not a valid semantic version qualifier". I like to use delimiters around injected strings in this case, totally subjective though. * I think the regex has a tiny error. (\d+)\.(\d+)\.(\d+)-?(.*)? accepts both 1.0.0-SNAPSHOT and 1.0.0SNAPSHOT. I assume we don't want the second input to be accepted. This can be fixed with a non-capturing group: (\d+)\.(\d+)\.(\d+)(?:-(.*))? * I'd definitely overwrite the toString method to reconstruct the version string 
Try kts it's a kotlin scripting language
Thanks for sharing
Thanks. Comparing to other languages the constructor limitations seems a bit of a shame. Is it so? Or am I thinking about it the wrong way?
Interesting points, thanks.
So basically constructor overloading has been replaced by factory function? Is that nice? Or just a way to overcome a limitation of the language?
That is indeed what I'm looking for! Lots of good points. Thanks.
Thanks a lot
It is a long-established best practice not to treat constructors like general functions. It is especially ill-recommended to write constructors that may fail with exceptions. Furthermore, in languages that do treat the constructor like just another function, you have to write tons of boilerplate that does the obvious — transfer the parameters to the properties. The design of constructors in Kotlin isn't a language limitation, but a carefully designed feature that eliminates boilerplate and separates the concern of object initialization from that of any computation necessary to produce the initial object state. 
&gt; It is a long-established best practice not to treat constructors like general functions. It is especially ill-recommended to write constructors that may fail with exceptions. Does that mean you find it bad practice to use an operator to achieve my goal as suggested in other comments? &gt; The design of constructors in Kotlin isn't a language limitation, but a carefully designed feature that eliminates boilerplate and separates the concern of object initialization from that of any computation necessary to produce the initial object state. SOLID comes to mind.
Using an operator fun to turn a companion object into an invokable function definitely looks awkward to me and in the end achieves exactly the same thing, but in a roundabout way. The standard library uses the idiom I've shown, which is far more straightforward. I struggle to see any benefit in the companion-operator combo.
That make sense! Thanks
&gt; issues when not supplying the qualifier Ah, I see. The problem is that `regex.find(version)` allows a partial match, so in the case of "1.2.3-" the hyphen is not matched at all. You can just replace `find`with `matchEntire`. &gt; added a bump method. Is it still good? Looks like it's doing what it's supposed to do and the implementation is concise and elegant. &gt; Any suggestions for further improvements? Sure! There is always room for (premature) optimization! For starters you might want to add the convenience method `isSnapshot()` is that specific qualifier may be special. You could also make your class [comparable](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-comparable/index.html). Qualifiers may mess up the semantics a bit here, if you allow anything apart from SNAPSHOT: We know that `1.0.0 &lt; 1.2.0` and `1.0.0 &lt; 1.2.0-SNAPSHOT &lt; 1.2.0`, but what about any other qualifier? You could be more strict about your input - stuff like `00.001.0--_%` is a valid version by your definition. It's also still lacking documentation und tests ^^ I don't know what your context is so take my recommendations with a grain of salt - they may not make sense for your project.
As hackometer has already mentioned there are some advantages in using factory methods. In fact Effective Java (a must read for any Java developer imho) has as item one "Consider static factory methods instead of constructors". Bloch lists several advantages, but also disadvantages so please read them. I especially find the named argument compelling in that naming your factory gives it more meaning. In my example I have named it parse (akin to something like Integer.parseInt). It is clear that the string will be parsed and needs to adhere to a certain format. When using the more "fancy" invoke approach my first reaction on seeing the call site would be: This must be a class Version(version: String). Of course this is all superficial and proper documention would solve all of it, but that was my reasoning for my solution. As to it being a limitation in Kotlin, I am thought so too when I started but firstly multiple constructors aren't actually that frequent I find, and secondly factory methods (either in companions or as top level functions) offer a compelling alternative and finally I enjoy having a canonical primary constructor.
Does this integrate with `spring-rest-docs`?
Just do two constructors. Also, I'd use expression syntax there: override fun toString() = "$major.$minor.$patch-$qualifier" And: matchResult?.destructured?.apply { major = component1()?.toInt() ?: throw IllegalArgumentException("Major not found") minor = component2().toInt() patch = component3().toInt() qualifier = component4() } ?: throw IllegalArgumentException("Destructured Match result is null") Also, wouldn't your code (and mine) crash if component2, 3, 4 are not given (or 2 and 3 not ints?)
Nice use of invoke, this is how you can make a secondary constructor without needing to call the primary constructor immediately
 launch { ... } yield()
Try this one: https://pl.kotl.in/rySpLRxLV ``` val result = input.map { it.length }.max()?.let { m -&gt; (0..m).associateWith { 0 } }.orEmpty() + input.groupingBy { it.length }.eachCount() ```
yield() doesn't make any sort of guarantees that the launched code will be run. It's extremely likely, yes, but you're still relying on the scheduler implemention and queue state.
That's true. The only really safe way to do it is `launch { b() }.join()`...but this is equivalent to simply calling `b()` directly.
I can't imagine any use case where you'd need to immediately launch a coroutine on the current thread instead of just calling the code normally. Having to do something like that feels like there's a deeper design issue with that code that should be resolved instead.
Thanks! That makes my point: you shall know all available library functions.
Why not use a secondary constructor instead?
In general that example is not very good. **Warning: Super opinionated view**: You should not have activity implement CoroutineScope unless you want to repeat the passing a activty everywhere problem. Instead you want a variable scope that is the scope then you pass that. Next, don't do this in the activity instead you should do it in a view model or presenter. If you need the scope in your activity you'll still be able to do `viewModel.scope.launch{}` and use the scope from your viewmodel. If you really need to have your activity/fragment own the scope you should at the very least make sure that the job will be hooked into a lifecycle. Here's a perspective PR that would actually make it a feature of Android [https://android-review.googlesource.com/c/platform/frameworks/support/+/904593/4/lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt#39](https://android-review.googlesource.com/c/platform/frameworks/support/+/904593/4/lifecycle/common/ktx/src/main/java/androidx/lifecycle/Lifecycle.kt#39) Seems like the android team is making this public so that they can get feedback. TLDR: Either put your scope in a viewmodel or make it lifecycle aware so that you can do scope.launch{} without sad leaks. 
The obvious argument is that you'd have to the primary constructor immediately. Not sure about the specifics in Kotlin, but in Java you'd prefer a static create method as it doesn't have the constraint that you have to return a brand-new instance of this very class. If you don't use a constructor you can reuse objects and return a subclass
Hooking the job into the lifecycle is covered by the example down in onDestroy. So as long as the Activity lives the scope lives which seems OK to me. As for hooking the scope into a LifeCycle that sounds fine. My question is not really Android-specific though: is there any legit reason to create a new CoroutineContext every time, or can we get away with a single one per CoroutineScope?
I use a single coroutines context inside of a viewmodel and it works well
You should not use \`lazy\` with a \`var job\`. Using a getter that creates a new (cheap) CoroutineContext based on the \*current\* value of \`job\` is way better than 1) using a doubly checked synchronized lock and 2) potentially storing a reference to a \`job\` that has been cancelled by the activity receiving the \`onDestroy\` hook potentially being reused.
Not just that, but all those pros (except #6, which is pretty much widely agreed to be false, and is certainly very subjective) apply to kotlin *too*! Also, I can't help but point out that little slip-up of saying that in 32 bit C ints are 2 bytes wide. They just... Aren't. On a sensible compiler anyways. 
Aha! This is the answer. `job` could change. Thank you.
Let’s format this beautiful code https://pl.kotl.in/HkzzayfIV
A little note on lamdas, you CAN specify the return type if you explicitly type the lambda. `val double: (Int) -&gt; Int = { num -&gt; num * 2 }`
Being an http server, routing is a built in concept to ktor. What does your library do aside from presenting the existing routing capabilities?
I'm not sure of ktor's routing capabilities (read the doc just now about routing), nor how it does route matching (I'll check it out in the code), but as far as I know it's not a standalone routing component you can plug into any other framework or application, is it? This is more of a pet project for me to learn Kotlin, really. I don't see it as a competition to ktor. If you have any time to have a look at the source code and can think of any improvement to make it more Kotlin-friendly, I'd be happy to listen! Thanks for the comment
Here's how you can do it in a simpler way: class MyActivity : AppCompatActivity(), CoroutineScope { override val coroutineContext = Dispatchers.Main + job override fun onDestroy() { coroutineContext[Job]!!.cancel() } } This much simpler idiom behaves only slightly differently to the original from Kotlin docs: it creates the job immediately, before `onCreate`, and you can't recreate it. The difference is of theoretical significance only because Android won't re-initialize the same `Activity` instance and it won't run any code in it before calling `onCreate()`.
I only feel right with parentheses.
I also got used to not using parenthesis in if statements, because of Go, it seems "old" to me too.
Because Kotlin allows if-else branches without braces, you can write eg.: print(if (a != 0) a else b) If it did not require parentheses, such expressions could be ambiguous and thus hard or impossible to parse (would `if a == 1 -3` mean `if (a == 1) { -3 }` or `if (a == 1 - 3)`?). Some other languages, like eg. Rust, handle this by requiring the braces, thus in Rust you can write: println!("{}", if a != 0 { a } else { b }); without the parentheses around the condition, but you must use braces around the branch expressions. But Kotlin chose the other, more familiar to C and Java, way.
&gt;parenthesis in if statement and imo the readability is very important. Which can only be achieved with parentheses .
I myself find the Rust way more readable, as the branches typically are much longer than the condition, so it seems quite natural to me to always wrap the branches in some kind of parens (braces in this case), and not the condition (which most often is very breve and readable on its own), but both ways are the way they are to avoid ambiguity by delimiting the condition from the branch.
``` val coordinates = arrayOf(5, 10, 15) val (x, y, z) = coordinates ``` Destructuring declarations don't work on arrays, do they?
There is nothing "modern" in an `if` without parentheses. The syntax is actually older than the parenthesized `if` that C introduced.
They do work! There are extension operators defined for all array types and List in the standard library. For example: https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/component1.html
Ah, you're right - thank you.
https://www.udemy.com/devslopes-android-kotlin/ 4/5 stars I highly recommend this course on udemy. It goes into the foundation of kotlin although kinda short, I find very helpful for you to navigate back to for some things you may forget. Also has a part about GitHub and version control, which was a nice bonus information I didn't think I needed now I'm glad I know about it. It goes over layouts activity lifecycle and recyler views. there is also apart about publishing the apps with is just as important as development. Take a little bit to get through everything but it was enjoyable. Now I need is to learn a few design techniques and I will be golden on my career path in Android. 
Your explanation is great, thank you. I more like how it looks in Rust and Go too.
I can't think of any reason to use anything other than Kotlin for a new Android project.
Honestly I've been using it for absolutely everything so far. It's got a very large ecosystem behind it (by being able to use Java), but it also has great language specific libraries. 
I convinced my team at work to write new code in kotlin and slowly rewrite old code as time permits. Also I do a few leetcode problems in kotlin each day
I usually start by defining the core problem I'm solving and look at what tools exist to solve it best in my opinion. If that tool is written in kotlin, I use Kotlin, if it's php, i use php (hah jk can you imagine?).
Performance critical: rust or c++ Machine learning/ data science/ scripting: python Easy backend: python Complex backend: kotlin Workflows: nextflow Everything else: kotlin 
Pretty slick! Thanks!
Kotlin's tooling is top notch for Android/Backend Services projects. And you use it for the build language too. When you step away from that, like JS or a native application, you'll just be confronted with less consistency with tooling and frontend work. But you can make it work in most cases, it's just more of a pain in the butt. For example, I still kinda punt on doing much with Kotlin/Native mostly because I usually run into something stupid with the gradle plugins. They're all kinda "prerelease". It just doesn't seem worth my time yet to figure out if I should stick with monkeying with konan or the multiplatform approaches. So, I end up sticking with cat-ing a bash script on a fat jar and boot! I have a "console application".
So, first of all, unless you have some very strict constraints (performance, cpu architecture, memory limitation, soft/hard real time, life critical...), choosing the language you love/know best for a *personal* project is usually a totally valid approach, as you’ll benefit from all your knowledge, experience and tooling you’re already familiar with, and that’s a huge gain in terms of cognitive load. Now, if you work in company, unless you’re the CTO or have very strong arguments, it’s more a matter of risk management : How is the market of developers in that language? Who do I want to attract? How easy is it to get support ? Who does it integrate with my existing systems ? What is the ecosystem I can benefit from ? And from this perspective, Kotlin has some strong selling points, but the shortage of experienced developers is a key aspect that still need to be improved for "mainstream" adoption. TL;DR: Since you seem to be a student, don’t worry about it, yet. Take the one your gut feeling tells you to. 
I agree with that. The fact that it's completely compatible to Java side by side makes this an easy choice. My company (around 30 android devs) moved to kotlin and no one is unhappy about it. It's just a better language imo. Our backend devs took a bit longer but they are also writing everything in kotlin now. 
It depends what I do. If I create web applications, I usually go with PHP because I need to support managed servers or shared hosters. If I write desktop apps, it depends again. On Windows I use C# and WPF on Linux Qt with C++ or GTK3 with Vala. When mobile I always go native, so Kotlin it is for Android. Commandline tools usually get the language I want to learn next or the one that compiles without dependecies, which usually ends with Go. For Web frontend I actually stick with ES6 and Vue.js. Sometimes I create CGI/FastCGI apps, they are usually just testing around and then I pick a language I want to learn something about.
In addition to what other people already said, Kotlin is a good candidate if there is some reason that sharing code between different platforms/technology layers would be particularly advantageous for a project. Kotlin can run on desktop/server computers, Android, and can transpile to JavaScript. Often sharing code between these different layers sounds much nicer than the benefits it actually brings (it can actually make things much worse), yet it is theoretically possible to get huge benefits from code sharing.
First decide if you think types are important. If so you've got C/C++/C#/Go/Java/Scala/Kotlin. If not you've got node.js/Python/PHP. (TypeScript isn't quite there yet). Then consider language conciseness, developer friendliness, consistency, runtime environment, and library/framework ecosystem. I like types, so IMHO: C and C++ aren't as developer friendly as the others. C# is very Microsoft oriented - sure there's the mono runtime but that isn't as mature and supported as the JVM. I don't know much about Go, how does its library/framework ecosystem compare to the JVM? Again I don't know much about Scala but it's a different coding style to the others. Take a look; remember you'll have to get other developers up to speed too. Between Kotlin and Java, Kotlin takes the lead with its conciseness, composability, null safety and DSLs. For large server apps we use Spring Boot on Kotlin because Spring does everything. There's usually an integrated module for whatever you want to do, along with best practise for performance and security. Where there isn't a module and you look for random libraries there's a good chance it will have a 'how to use with Spring Boot' section. For little tools, experimental apps and bash-scripts-that-got-too-big we've been using kscript and the ktor http library. Very quick to knock up and easy for others to see what's going on, and after kscript is installed you can just run it like a bash script. Currently there's some debate over whether JVM code runs as fast as native C code, some say it does due to extensive optimisation which improves as the code runs and 'warms up'. But on top of this new things are emerging: GraalVM's native-image precompiles to native and has a drastic impact on startup and runtime performance. There are multiple efforts at addressing how we manage blocking IO and concurrent CPU load without creating lots of Threads: reactive, coroutines, fibers from Project Loom. Kotlin/Native is not just for mobile apps. As 'pure kotlin' library support grows we'll be able to take your kotlin app and compile it directly to native without need for a JVM.
Depending on where you are, there might be a Kotlin meet-up nearby that you could attend. Take a look at [https://www.meetup.com](https://www.meetup.com).
Hypothetically kotlin could be in the future a contender for performance critical with native compilation though right?
1. Just do it - seriously. Quit obsessing over what to use and just try using it. You'll learn more by doing than by endlessly reading about others doing. 2. Do it opportunistically on small projects just to see how far you get and learn. Worst case you learn something without producing a result. Best case you learn something and become productive. The point is learning something is valuable. 3. When starting a new project allow yourself to take only a handful of risks and stick mostly to what you know. So choosing a new language that you have never used before is highly risky. If you then also pick a framework you've never used before and a few other completely new technologies, you might as well give up on the project right away. Risk doesn't accumulate, it multiplies. Now regarding Kotlin. It's less risky if you already know Java as it is pretty much a drop in replacement that can co-exist within your existing Java code base. This is not a myth; you can take any Java project, get the kotlin compiler hooked up and maybe a few classes converted in about 1-2 hours. That made using Kotlin for me a very low risk choice early last year when I basically started a java project and then decided to switch it to Kotlin. Since then I've converted a few more projects. This ability to seamlessly switch has made learning Kotlin really easy. There's also Kotlin native. This includes wasm so you can do web with it. And there's Kotlin-js which also allows you to do web with it. The best way to think about Kotlin-js is as a way nicer typescript. Kotlin native is currently optimal for IOS/Android native development. Kotlin JVM is used for backend stuff with e.g. Spring Boot, Ktor, or some other web framework. Kotlin for Android is quite obviously the main thing as Google was an early adopter of Kotlin. You end up using a lot of the same libraries between Android and Kotlin for the JVM as Android is basically just a variant of the JVM. So, pretty much full stack. More so than Javascript (which I'd argue is less than optimal outside a browser and arguably no longer optimal inside one) and less so than Rust which is frankly amazing in the sense that people do browsers, browser applications, operating systems, firmware, servers, and more with it. IMHO you can't go more fulls tack than Rust. Kotlin is getting close though. &amp;#x200B; &amp;#x200B;
The DroidCons I went to also got some Kotlin content, maybe look into them.
Bruce Eckel (author of Thinking in Java) writes eBook about Kotlin — Atomic Kotlin. It’s not ready yet. But there are several chapters online — https://www.atomickotlin.com
Will this be as e regular book , maybe Kindle format , or hard copy on amazon ? And when is it predicted to be launched fully ? 
Did you click the link?
yes of course
Docs bro.
I'm really enjoying Venkat's "Programming Kotlin". It's still currently in BETA though https://pragprog.com/book/vskotlin/programming-kotlin
Then you know as much as the rest of us!
Amazing , i was interested in * Using Coroutines :) Thanks
It's still in beta so it's not fully fleshed out yet. I think the chapter on co-routines just came out but still might not be complete.
I'm gonna have to dig deeper :P 
I don't believe there will be a hard copy, my guess is that when you buy it you would get a bundle with a few common formats.
This is a great book. It should be noted that while Bruce is certainly the big name in terms of a well known author, he is working closely with Svetlana Isakova who worked on the Kotlin compiler team and is now a Kotlin advocate and teacher working for JetBrains.
If you're interested in coroutines, they did a webinar on them not so long ago... [https://www.youtube.com/watch?v=FAhR\_sqlUy4](https://www.youtube.com/watch?v=FAhR_sqlUy4) Have a look. :)
Thank you &amp;#x200B;
Kotlin in Action, by the lead devs of the language is a great one, and not in beta. https://www.manning.com/books/kotlin-in-action
Released literally days after upgrade on Nano Ledger S decreased number of apps it can store to 3.
What does this have to do with kotlin!?
Yes but I need something that has info about coroutines also . 
You can overload the [indexed access operator](https://kotlinlang.org/docs/reference/operator-overloading.html#indexed) by implementing `operator fun set(idx, value)` and `operator fun get(idx)`. Then you can use them by the indexing syntax: yourObject["index"] = newValue // calls yourObject.set("index", newValue) val foo = yourObject["index"] // calls yourObject.get["index"]
Thank you man!
r/lisp is waiting for you
Thanks a lot!
Thanks for your feedback. Truly appreciated!
This documentation is slightly obsolete, will fix i soon. The most idiomatic way (in 1.1.0+) is to use \`MainScope\` and delegation: &amp;#x200B; class MyActivity : AppCompatActivity(), CoroutineScope by MainScope() { override fun onDestroy() { cancel() // Extension on CoroutineScope } } &amp;#x200B; This example was written mostly for demonstration purposes when \`CoroutineScope\` concept was new and unexplored.
This documentation is slightly obsolete, thanks for pointing it out. The most idiomatic way (since 1.1.0) is to use `MainScope` and delegation: &amp;#x200B; class MyActivity : AppCompatActivity(), CoroutineScope by MainScope() { override fun onDestroy() { cancel() // Extension on CoroutineScope } } &amp;#x200B; &gt;My question is not really Android-specific though: is there any legit reason to create a new CoroutineContext every time, No, there isn't any apart from demonstration purposes. This example was written when \`CoroutineScope\` concept was new and unexplored just to demonstrate the general idea
`Array&lt;Byte&gt;` compiles to `Byte[]` and `ByteArray` compiles to `byte[]` so the latter is more efficient
&gt; but why is there 2 types in the first place because Kotlin is based on the JVM and there are also 2 byte array types: `ByteArray == byte[]` while `Array&lt;Byte&gt; == Byte[]`. &gt; Also when should I use which? `ByteArray` is generally more efficient, so if you don't need the generic `Array&lt;*&gt;` type, use that.
can you elaborate on the difference between `Byte` and `byte` ? I'm not that familiar with JVM (im mostly working with Kotlin/Native at the moment)
My pleasure! DM me if you have more questions or just want to brag with your final product 
`byte` is a primitive data type that is just 8 bits or a quarter integer. `Byte` is a standard reference/object type that contains a `byte` attribute and makes it able to use bytes in places where generic standard objects are expected, like a `List` of bytes.
can you elaborate on the difference between `Byte` and `byte`? I'm not that familiar with JVM (im mostly working with Kotlin/Native at the moment)
`Byte` is a boxed `byte` (that is, a pointer to a heap-allocated object holding a byte). Thus Kotlin `ByteArray` (which is `byte[]` in Java) is just a contiguous memory region holding an array of bytes while `Array&lt;Byte&gt;` (or `Byte[]` in Java) is an array of pointers to bytes that live somewhere on the heap. Hence `ByteArray` is more cpu-cache friendly, and doesn’t suffer from pointer indirection for all member accesses. The same is true for all primitive types.
Kotlin uses Int and, correct me if I am wrong, uses the primitive type und the hood if possible. why does this automatic conversion/improvement not work on arrays?
Yes, Kotlin will, if possible, use primitive `int` for its `Int`, and the same happens with Kotlin `Byte`. But `Array&lt;T&gt;` is a generic type. Generics are erased during compilation to the JVM (the virtual machine has no idea during runtime about generic types), thus, for example, any function that accepts a generic array: `fun &lt;T&gt; consumeArray(arg: Array&lt;T&gt;)` (of `&lt;T&gt; void consumeArray(T[] arg)` in Java) will get compiled to the same thing as `fun consumeArray(arg: Array&lt;Any?&gt;)` and `void consumeArray(Object[] arg)` would. Because of that Kotlin cannot use primitive types as generic parameters and all `List&lt;Int&gt;`, `Sequence&lt;Byte&gt;`, `Array&lt;Long&gt;`, etc. use the boxed type, so that it can get compiled to `Object`.
Thank you very much! Makes sense!
&gt; Performance critical: rust or c++ &gt; &gt; Machine learning/ data science/ scripting: python &gt; &gt; Easy backend: python &gt; &gt; Complex backend: kotlin &gt; &gt; Workflows: nextflow I would argue for using Kotlin || Java for all of these. Easy backend: Kotlin + Spring. Complex: Kotlin + Java. Workflow: Take your pick of 1 of 10K java libs for that. I don't know how the myth that the JVM isn't good for performance critical code, but that's nonsense. A lot of automated HTF algorithms are written in Java. The JVM backs Kafka. Hot spot is a beast when it comes to optimizing hot code, and if you know how to optimize you code for hot spot, let's just say... She's fast enough for you old man.
Sure, `byte` is a primitive type which takes 1 byte (8 bits) of memory. `Byte` is a class which contains a `byte` variable. When you have an instance of a `Byte`, it's stored on the heap (except for some rare scenarios where escape analysis optimizations take place). A `Byte` instance takes 8 bytes for the object header plus 1 byte for the byte variable itself and then padded to the nearest multiple of 8 bytes. So a single `Byte` instance takes 16 bytes of memory. Additionally, the reference (/pointer) to that instance takes another 8 bytes on a 64bit JVM (which is common) or 4 bytes on a 32bit JVM (or also with a 64bit JVM with compressed oops enabled). In addition to using much more memory, the largest impact on performance is due to pointer chasing and non-cache-friendly memory access. Essentially, using `Array&lt;Byte&gt;` can be 100 times slower than using `ByteArray`.
Great insight, thanks!
That is a fantastic use of delegation right there and I plan to start using that idiom immediately. Bravo!
This is a minor complaint I have on Kotlin. I think it should only have `Array&lt;Byte&gt;` and the compiler should just choose he most efficient implementation possible. This is what it already does for types that have primitives like `Byte`
Typescript not there yet? Care to elaborate? It's very widely used, and very mature. What else would it need to be "there?
[removed]
welcome to Java's bloated legacy
I am not that familiar with JVM, so anything below might be completely wrong, but I think your calculations are a bit misleading. First of all, I have seen somewhere an experiment to figure out memory overhead of the object header. Was it empty object, or Intejer(same as Byte, but for int), I don't remember. It doesn't change much, however. The result was, that the header was about 20-24 bytes. Even though, the situation is not that bad. JVM uses cache for Byte(and similar). So, if you won't construct it directly(i. e. call the constructor explicitly), you won't have many instances. Only one(maybe a few for cache/thread locality) instance of Byte object for each byte value. Essentially, the following lines are equivalent ```java Byte a = 42; Byte a = (Byte) 42; Byte a = Byte.valueOf(42); // gets object from cache ``` For larger types like Integer, the situation is worse. JVM, by default, caches only small integers. And it will create instances for large values. 
So when would you want to use Byte over byte ? It looks like a no brainer but for sure it can't be that easy ?
Hi, I have sent you a private message talking regarding this topic... Hope I can help.
100% compatibility with all libraries, frameworks, build tools etc. I jest, that's a pipedream! But seriously it's great until you hit some edge-ish case caused by x not getting on with y where you uncover a github issue that's been around for 2 years with 'any fix for this yet?' comments popping up every few weeks. JS developers I respect have told me they've tried it and ditched it because it was causing them more effort than it's worth. This isn't even a conversation for all of the typed-from-birth languages which do have that 100% compatibility.
Yeah, just thought about the same.
primitives can't be null and aren't boxed.
No, I don't think that's possible. The compiler doesn't magically know which "java equivalent" Byte or byte to use for your Kotlin Byte. Kotlin Byte == Java byte, whereas Kotlin Byte? == Java Byte because primitives cannot be null. If you want it to be null, hence Byte?, it would translate to a boxed Byte container.
Then what happens if you want to pass your Array&lt;Byte&gt; to a function that expects an Array&lt;T&gt;? It wouldn't be possible. For singular primitives like Byte this is not a problem cause it can add the code to do the boxing at the call site, but this is not possible for arrays, cause arrays are mutable.
In addition to if-else branches without braces, being able to move lambdas outside function call argument lists would cause this to get ambiguous, especially if the lambdas are optional arguments. if obj.foo() { bar() } { baz() } could potentially mean if (obj.foo({ bar() })) { baz() } or if (obj.foo) { bar() } { baz() }
No. It's hard to see a reason to do this when the IDE makes the root package behave like a single folder already. I do not do this, and I have a hard time seeing a world in where I would. Not to branch too far on a tangent, but it's also why I don't think anyone should use star imports ever. The IDE manages the import list and it folds the entire list into a single `import ...` line. Individual imports make clear which functions are being used in code review because they participate in the diff, but you never see or worry about them in the IDE. So who is the star import for? It just makes it harder to browse code in diffs and on GitHub. I'm sure people who use text editors enjoy star imports and shallow folder structures. I use an IDE, though, so I don't need those features. It's a really nice IDE, too!
I guess the Book by Pierre-Yves Saumond The Joy of Kotlin soon to appear should be interesting
Does it contain coroutines?
&gt; So who is the star import for? For things that really don't matter. How valuable is it to have various `import java.util.thing` in the diff? Or is it really necessary to break `import kotlinx.android.synthetic.main.activity_main.*` into individual imports? Also for enums: sometimes it's incredibly convenient to just say `THING` instead of `SomeRandomLongEnum.THING`, especially when it's obvious what `THING` is from context.
&gt; How valuable is it to have various import java.util.thing in the diff? Well if I reference those types then it's valuable. It disambiguates it from library types in any of the hundreds of potential other packages. The whole point of the package system is to disambiguate an otherwise global namespace of simple names. At least with JDK types they're fairly well known and often unique. But I'm not really interested in guessing for library types and single imports mean I don't have to. &gt; Or is it really necessary to break import kotlinx.android.synthetic.main.activity_main.* into individual imports? Easy fix: don't use this plugin. &gt; Also for enums: sometimes it's incredibly convenient to just say THING instead of SomeRandomLongEnum.THING, especially when it's obvious what THING is from context. This is a language feature request. Java got it right.
I agree with star imports, don't use them either, but decided to try the `src/main` thing. Now I have a project with many modules, but if that bug will keep staying unfixed I might go wild and introduce `com/example/stuff` back across this whole project.
I stopped worrying about Star imports when I learned that the bytecode isn’t affected by them. So I just do whatever makes sense in the moment, and that generally means 5+ and enums get starred. If I’m “confused” then I just command click or hover. We’re past the days that we even joke about writing java outside of an ide anyway. For the folder structure, I’m just sticking to maven/gradle defaults until the wind changes.
I use text editors when writing certain other languages. Star imports are even worse in them - they make it harder to track down the source of an imported function. "No star imports" is always one of the first linter rules I make sure to enforce.
Your comment about type erasure doesn't apply to arrays on the JVM. They had to make an exception for arrays because of the compromise of treating arrays as covariant in Java (which Kotlin addressed). To test this in Java, have an array of Strings, reference this array as an array of Object and then attempt to set an array element to an instance of a non-string. Unfortunately this compiles in Java but it will be caught at runtime.
I tried to do it. But ide support is broken for it, so I gave up.
I like your approach. I also want to stay out of npm hell. Cobalt looks cool but doesn’t seem to have much of a community (or even a readme). How did you even find it?
You are right that array types are not erased in runtime (and they are not a generic type in Java), my bad. But my main point – about generic functions accepting arrays of a type T still stands – such functions will get compiled to accept arrays of `Object` because generics are erased, and because of covariant arrays it works – every `T[]` is a subtype of `Object[]` if `T` is not a primitive type. And because of that Kotlin cannot special-case arrays of primitive types.
I'm starting to think I'll give up too :)
Yeah, I do this with my projects. For me, it doesn't update the package name when I move files though, and then I have to go through every file and hit the quick fix suggestion for the package name (it comes up with the full one, and the cut off one for me, obviously choose the full one there). A bit annoying, but I don't move files that often, and if I do, it's not much, so it's fine imo
I see. We work on a project with a team and it's annoying for each team member :) We got used to it, but I wonder if it's really worth it. I wish IDE would back up the official recommendations, but this didn't happen, so maybe it'd be better to step back.
Yeah, I agree that the support for this definitely has to be better. It's too janky for something that has been the official recommendation for a while, and the official IDE made by the same company as the language.
I think someone mentioned it on /r/roguelikedev. I'm not sure about its current state though.
Hey, Cobalt dev here. I was also commenting on this thread above. To answer your question: I'm working on [Zircon](https://github.com/Hexworks/zircon) which is a multiplatform Kotlin library and I've developed Cobalt (and some other libs) to support the things I'm doing. I've released it as open source but I haven't really talked much about it apart from /r/roguelikedev. I'm gonna switch to Cobalt soon though since I'm nearly done with my other lib and I gonna start application development in a Kotlin multiplatform environment. I'm going to post a full readme and a cut a first non-preview release when the ideas click together. Things I'll add soon: databinding for collections, thread safety with coroutines (including coroutine API), RPC-like communication between server and clicents, additional data structures (like persistent collections) which are missing from Kotlin common right now. All of these are going to be written in Kotlin common so they will be usable from all Kotlin-supported platforms (this means JVM, iOS, browser, etc).
Here's a sneak peek of /r/roguelikedev using the [top posts](https://np.reddit.com/r/roguelikedev/top/?sort=top&amp;t=year) of the year! \#1: [Roguelikedev Does The Complete Roguelike Tutorial Again - Starting June 19th](https://np.reddit.com/r/roguelikedev/comments/8ql895/roguelikedev_does_the_complete_roguelike_tutorial/) \#2: [Procedural generation at work](https://imgur.com/yPZGKdt) | [17 comments](https://np.reddit.com/r/roguelikedev/comments/av6sp1/procedural_generation_at_work/) \#3: [I also got Magic Mapping working!](https://i.redd.it/lis9e9duoyt01.gif) | [35 comments](https://np.reddit.com/r/roguelikedev/comments/8epz7c/i_also_got_magic_mapping_working/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/afd0dd/blacklist/)
Why use Eureka when docker stack provides DNS-based discovery for free? It's more efficient too as it's in the network layer. What advantage is the configuration server giving us? How is the configuration set? Do the server nodes automatically pick up and apply config changes at runtime without restart? It's worth mentioning to Spring fans why they might want to look at Micronaut: great performance boosts from AOT, GraalVM, and native image :-)
Thanks Perfect timing. I was hit by message to big in websocket just yesterday. Looking forward to try the config option on Monday.
Please open an issue if you run into any trouble :)
Why use JPA? I'd recommend using jOOQ instead of that obsolete monstrosity. The persistence context, weird caching, string-encoded names which can be broken by a simple refactor, no control over the sql which gets generated... it is also incredibly hard to do things which where not thought out properly when they designed JPA for example `json` fields in databases. All these things are almost trivial with jOOQ.
This is really useful love to see content like this. Simplifying my Gradle builds has become a passion 
This is a feature that just had not been implemented. Such properties are possible, and it's likely that they will be added in the future 
&gt;Easy backend: python I see no reason not to use Kotlin with Ktor or Javalin. Doesn't get easier. Python was my first language and I loved it. But Kotlin is in every aspect superior. &gt;Performance critical: rust or c++ Depends on the application. JVM can be extremely fast for long running stuff. But generally agreed. &gt;Frontend: TS (kotlin is nice here, but not quite there yet) \+1
I'm still stuck between this one (Venkat is such a great teacher) and Joy of Kotlin from Manning Press. Who am I kidding....I'll probably end up buying both.
I fell in love with flask, but yeah, I could use kotlin here as well. 
What would be the use case for a suspended property? Maybe I'm blinded by years of Java, but if it's worth suspending, shouldn't it just be a function?
My unqualified concern about JOOQ is: are companies that use non-open-source databases happy to pay for the JOOQ license, or are they more likely to tell their devs to use some other library instead?
This is the best part of Gradle: just moving common configuration into plugins. I've done this for a lot of my projects. I've found Nebula, from Netflix, to be a great starting point, for people diving into Gradle plugins in general: [https://nebula-plugins.github.io/](https://nebula-plugins.github.io/). A lot the Nebula stuff predates the Kotlin Gradle DSL, there's still a lot of good things for people getting to know the Kotlin DSL for Gradle, e.g.: [https://github.com/nebula-plugins/nebula-kotlin-plugin/blob/master/src/main/kotlin/netflix/nebula/NebulaKotlinPlugin.kt](https://github.com/nebula-plugins/nebula-kotlin-plugin/blob/master/src/main/kotlin/netflix/nebula/NebulaKotlinPlugin.kt) For me, even if I don't use their plugins, I learned a lot from reading their code. It's a fantastic resource.
Kotlin's `suspend fun`s are a lot like `async/await` from C# or JS. The difference is that, in those languages, you have to explicitly `await` the `Future` in order to suspend the current flow. In Kotlin, when you invoke a `suspend fun`, it automatically suspends the current flow - no need for any extra syntax at the call site. A `suspend val` could work the same way - any access of the property would suspend the current flow. The workaround is to make it a `suspend fun`, but then you need (potentially) unnecessary parens. I guess it's a question of what you expect of a property. Is it OK for a property to be "slow" to compute? 
I think that if you are using a proprietary database you 1. probably have bigger problems than jOOQ's licensing costs 2. you are already paying for a database which would also make this a non-issue This is especially true for Oracle users.
Agreed that such a business 'can' afford the JOOQ license, but do they actually? In my experience the kerfuffle involved in requesting and justifying budget far outweighs the amount of money requested. It's even worse if said business already happens to use JPA or something else - you've got to convince them that JOOQ is better, get enough people to agree, do some amount of training on everyone, and then also convince them (or, worse, the non-technical project treasurer) that it's worth said paperwork kerfuffle.
Seems dangerous. A network call on property access feels like an anti-pattern.
Ktor doesn't even do it.
&gt; the difference between the two shows only in situations like `T??`, which is a bad style to get yourself into anyway. Explicitly writing `T??` may be a bad style, but the problem with the untagged union approach is how it interacts with generics. If I have a type parameter `T`, and at some point use `T?`, then there is a potential ambiguity when `T` itself turns out to be nullable. eg: class Foo&lt;T&gt; { val bar: T? = ... ... } val baz: Foo&lt;Thing?&gt; = ... Oops, now the type of `baz.bar` is `Thing??`.
That is exactly the kind of situation you should not be getting yourself into. If you really care about the difference between bar being None and being Some(None), then you should not use Foo&lt;Thing?&gt;. Using Optional&lt;Optional&lt;T&gt;&gt; here will not make your code understandable either. Better figure out another approach to your problem. That said, it is a rare problem in practice. Pragmatically, most of the time you want to flatten your “absence of value” type anyway. 
I see your point. jOOQ might not be the best choice for big enterprises where Hibernate is entrenched but I did work for such enterprises and American ones are a bit more flexible. For example I managed to pull most of my library suggestions through when I was working for one of them. What my point was though that the article is about writing a new project and the OP did not imply that it was for enterprises. I have thorough experience with JPA, Hibernate, jOOQ and even EclipseLink and I'm basing my opinion on my experience: Hibernate gives you tools for general purpose ORM things but when you try to do something more complex which will inevitably happen you'll start to struggle. jOOQ on the other hand has no such problems because it does not try to hide complexity behind a leaky abstraction. It gives you easy to use tools for handling databases through a tiny dsl API which is powerful enough that even querying `json` datastructures is a breeze. So my point is that for the average user with the average setup (MySQL, PostgreSQL, etc) I think jOOQ vastly outperforms any JPA implementation.
Properties should be quick and easy to calculate, so require very little computation power. A suspended property completely goes against the ideology. If what you're doing will take a long time, it should be a function. 
Agreed. It adds extra friction to the library suggestion process. In some places the paperwork kerfuffle is so much that it just wouldn't be worth it whereas if it was free it might get in. I agree it's a good library and I might like to use it for personal projects and for those clients using OS databases, but I'd be concerned that I'd lose the skills that many large companies need - JPA, its ecosystem and workarounds. As a compromise I've been using QueryDSL for the more complex queries as it is supported by spring-data. The downside there is that its future looks uncertain.
I'm glad we reached a mutual understanding. Very rare on the internet. :D
Would you say that using a nullable as a type parameter is a code smell in general?
Yeah, but shouldn't properties be something that is instantly accessible? At least in my mindset, I expect that property is something that you can access instantly (or with very little overhead), while function might take longer to compute.
So.. what does this compile down to? Would it be a something I could load into Ableton? Or just some cool blinky lights on the Launchpad?
It's a runtime MIDI client for designing apps using a Launchpad. So no, it wouldn't be something to load into Ableton. I'm also looking to support other devices (Launchpad Pro, etc) but I don't have access to those at this time.
It's a runtime MIDI client for designing apps for the Launchpad. So no, it wouldn't be something to load into Ableton. I'm also looking to support other devices (Launchpad Pro, etc.) but I don't have access to those at this time. If you're looking for something to design MIDI files for the Launchpad, you might like [Launchpaddr](https://launchpaddr.com/)! (not my project)
By itself it does no harm. But if you take, for example, a \`Map&lt;String,String?&gt;\` and start giving the null value stored in this map some special meaning that is distinct from "the value is missing", then you might find your code being quite incomprehensible by anyone else.
Great to see some Portland made Kotlin! 
Oh hey! Do you attend the local Portland Kotlin meetups? I might be there this Tuesday, so I'll be sure to say hi
Oh hey, do you attend the local meetups? I might be there this Tuesday, so I'll be sure to say hi!
I plan on going! 
Awesome! Feel free to say hi then
What happens when a rollback throws an exception? Making `transaction` throw an exception when one occurs seems rather unintuitive, now I'll have to try/catch the transaction instead. An `Either&lt;T,Exception&gt;` might be more pleasant to use.
I agree. According to the [Kotlin guidelines](https://kotlinlang.org/docs/reference/coding-conventions.html#functions-vs-properties) &gt; Prefer a property over a function when the underlying algorithm: &gt; &gt; * does not throw &gt; * is cheap to calculate (or caсhed on the first run) &gt; * returns the same result over invocations if the object state hasn't changed I can't see a situation in which a property is cheap to calculate and requires suspension
Gradle is still a struggle for me sometimes. Thanks for sharing!
I don't have a solution for maven but have you considered switching to gradle?
It s a part of complicated build procedure. It would be problematic to switch. 
We are thinking of extracting the assertions into a separate library. Feedback is most welcome this ticket: [https://github.com/kotlintest/kotlintest/issues/681](https://github.com/kotlintest/kotlintest/issues/681)
That's kinda low for 4 years + NYC.
I love Kotlin but how it deals with absence of things isn't great. It would have been better if Kotlin just enforced non-null, period, and used a sane Option/Maybe type for potentially absent values. But that was left that out so now Kotlin codebases are a hodgepodge of question and exclamation marks and Java Optionals (which is probably the worst implementation of an Option/Maybe type ever), and developers who aren't used to non-null happily leak them deep into the code rather than only permitting them at system boundaries. For those who want to avoid all that there is a great library called Arrow that comes with well implemented Option, Either, Try etc types.
The next step is to get rid of `Deferred` and `async`. They're not needed nearly as much as you'd think: suspend fun load(): Boolean { withContext(Dispatchers.IO) { // do your I/O stuff The caller can decide if it really needs to be `async`, or if (more likely) it's OK to just suspend until there's a result.
Okay, I did that instead. It works just as I'd hoped and feels better than making consumers everywhere.
I found the discussion on `Nothing?` enormously helpful here. It's far more clever and useful than I had anticipated.
repo here: [https://github.com/bastman/spring-kotlin-exposed](https://github.com/bastman/spring-kotlin-exposed)
Very nice article! I hadn't realized that a conditional that returns a non-null `T` or null having type `T?` follows from normal subtyping rules. One small nitpick, from the second-to-last paragraph before the summary: &gt; In the if, we search for the closest supertype of types from both branches. Closest supertype of `String` and `Nothing?` is `String?`. The same is true about when: The closest supertype of `String`, `String` and `Nothing?` is `Nothing?`. Everything makes sense. Shouldn't the last `Nothing?` be `String?`?
Yes, stumbled upon the same issue. I think it should be `String?`.
You can definitely do: private val cachedHash by lazy { someExpensiveComputation } override fun hashCode(): Int { return cachedHash } Pretty sure you can't override the val itself...
Abstract class with abstract Val . 
did you mean something like this? open class A { open val value = 10 override fun hashCode(): Int { return value } } class B : A() { override val value: Int get() = 20 } fun main(args: Array&lt;String&gt;) { val instanceA = A() println(instanceA.hashCode()) val instanceB = B() println(instanceB.hashCode()) } output will be: 10 20
My main issue with exposed is that it adds extra boilerplate. Sure, reflection is slow-ish, but is it really worth the trade off to have to define your objects and their properties multiple times?
The Archduke of Akka made me giggle. 
I find it strange to bring up Scala's pattern matching without also discussing Kotlin's equivalent \`when\` clause. Scala's is more powerful in my experience, but \`when\` is very useful as well, and both can do so much more than a \`switch\` statement from Java.
Why you are working from console without proper experience, when you can use [Intellij Community Edition](https://www.jetbrains.com/idea/) for free?
Charts that don't start from zero are the best 
You can't really compare apples to oranges. Scala is a language for academics, teeming with tacked-on features contributed by graduates at EPFL, barely usable for real-life programming, while Kotlin is a pragmatic language which comes from the industry and was designed for general purpose boilerplate-free daily programming.
I was surprised to find that this is a recent article. I figured it must be older because coroutines aren't mentioned at all! 
Strange that binary compatibility is not mentioned anywhere, as it's very important to compete with java on the jvm. Also i don't think the reddit comparison makes sense, as the scala subreddit is basically dead, no matter how many subscribers there are.
Scala is used a lot for backend applications. A lot more than Kotlin in fact. That's what all the jobs are for that are mentioned in the post. Using Java libraries from Scala in not that problematic. 
Try using play.kotlinlang.org to ensure the code is correct. In which case, there could be something wrong with your installation.
I don't know what you base that on. I've been working with Kotlin on the backend for years and I'm yet to see a Scala project. &gt; Using Java libraries from Scala in **not that** problematic. ^^^-- This is the point (emphasis is mine). In contrast: &gt; Using Java libraries from Scala in **not** problematic.
&gt; Scala is used a lot for backend applications. A lot more than Kotlin in fact. What are you basing this on? It seems every backend framework is creating Kotlin wrappers, but almost no one is creating Scala wrappers.
Exactly my point.
There is a big ecosystem around Akka/Play. It's also used a lot data processing (as the link points out it's popular with Spark, it's also very popular to use with Hadoop). But it's also used quite a lot similar to Kotlin, where it's introduced into big legacy projects. In my personal experience, it had quite a spurt in adoption in larger businesses and consulting business, around the time that for example Twitter adopted Scala (Kotlin was not really around at that time). Then momentum slowed, but this is still where it is most popular. As the article already more or less shows, if you're in an IT dense area, you'll have no problem finding a job doing Scala. &gt; Using Java libraries from Kotlin in not problematic. I disagree. Platform types in Kotlin are not fun to deal with. Especially not when you adopt a legacy codebase that's not neatly annotated to be more null safe. Also see the reply from /u/WGT-java : &gt; It seems every backend framework is creating Kotlin wrappers If it's all so seamless, you wouldn't need wrappers. I wish there were even more wrappers! But maybe you and I write different Kotlin code. I've been writing multi-platform Kotlin code lately (so JVM is only one target). This provided me with 2 (related) observations: - When integrating this with the JVM and the Java standard library, it becomes clear how much better it is to have pure Kotlin code. As mentioned, you have no platform types, but also always staying idiomatic is a huge advantage. - The Kotlin standard library is quite small, and the worst part of your code tends to be where you don't use it. One thing I'll concede, I do think Scala has plateaued or is maybe in decline already. And Kotlin probably has something to do with that (and has a much brighter future IMHO), though you can not discount Java itself being a less backward language nowadays. I think this is not surprising, the language always lacked focus and vision and the core tooling was only mediocre. Unlike Kotlin which has a very well defined vision and is created by (one of?) the best tooling teams in the world.
Twitter, commercial users from Akka and Spark would disagree. Also Kotlin with its new ambitions to go beyond the JVM is also duplicating libraries for everything, even unit tests.
Tons of them here in Europe. Other than Android, we don't have any use for Kotlin, with Java 12 and later catching up in features.
I use Spark with Kotlin. Just because it was written in Scala doesn't mean they use it from Scala. Most folks use PySpark btw. Kotlin multiplatfrom is a different topic, no one mentioned it here. There is no duplication of Java streams. Kotlin sequences are there to perform a different task. Also there is no problem with `@Jvm*` annotations. You have 3 of them and they are straightforward. This is not true with Scala where even the build tool is different. Again, you can't compare apples to oranges. It is **very** different from Scala and it shows, even [Scala devs admit this](https://www.youtube.com/watch?v=v8IQ-X2HkGE&amp;feature=youtu.be&amp;t=375).
&gt; I disagree. Platform types in Kotlin are not fun to deal with. Especially not when you adopt a legacy codebase that's not neatly annotated to be more null safe. Then you are doing it wrong. You can use `!!`, `?` and `?:` same as with any nullable reference. &gt; If it's all so seamless, you wouldn't need wrappers. I wish there were even more wrappers! It is seamless. Go ahead and use it, you'll see. I'm not using any of those wrappers. They are there to make Java apis more idiomatic for Kotlin but there is nothing stopping you from using JAVA APIs as-is. That's what I'm doing as well with 0 problems. My guess is that most people write wrappers as a PR stunt (Spring for example) or just to learn the language. 
This means that you have never used Kotlin otherwise you wouldn't have said this. Java will never catch up to Kotlin primarily because of the 20 years of baggage it carries and the design by committee attitude. They are just adding some small features to make you believe in this illusion and keep some Java devs from moving to other languages.
You can't do it directly because `fun` and `val` have different access syntax (with/without parentheses) and, on the JVM, compile to different bytecode. A `val` compiles into a getter while a `fun` compiles into a method of the same name.
That's really good feedback! I'll add a section on coroutines.
&gt; Then you are doing it wrong. You can use !!, ? and ?: same as with any nullable reference. If you write pure idiomatic Kotlin you'll hardly ever use those. Use `!!` without a good explanation in the comments of why you absolutely need it, and it's an automatic reject on your PR from me. But like I said, different people use Kotlin different ways. For example, maybe you don't mind getting all these mutable collections back from Java. Personally I'd rather have things immutable by default, so for me it's not "seamless" or "without problems".
I am completely new to programing especially with Kotlin. Does anybody know of any newbie resources I could utilize? 
Spark, Akka, Play? Scala is widely used in industry too. Also, you can use Maven or Gradle and interop with Java is pretty normal. Actually, there's a decent percentage of developers that use Maven in favor to SBT. Yes, you ain't gonna find a lot of developers using Scala with Spring. Because there's a rather decent amount of Scala idiomatic frameworks and toolkits (Play, Lift, Akka...).
Sure I have, that is forced upon us on Android, unless we want to stick with Java 7.
Maven works just fine with Scala.
Let's see if Scala gets another year of celebration. :D
Then you have no idea about the features of Kotlin or you are just forced to use a small subset.
I have used both Scala and Kotlin and interop is not comparable in favor of Kotlin. Yes you can use Maven/Gradle but most devs use sbt and they are not compatible. 
It **is** the idiomatic way. Just go up to the **official** Kotlin Slack and ask Roman Elizarov yourself. Good thing that you won't get a PR from me. I also use the immutable collections and it **is** seamless and without problems. You either have some really messy code on the Kotlin part or have an unrealistic definition of seamless.
[commons-email](https://commons.apache.org/proper/commons-email/)
"it" is idiomatic? WTF are you talking about?
A programming language is much more than just a bullet point list of language features.
Thanks, I added my 2 cents to the ticket.
Who else could tell you what's idiomatic if not the official style guide? There are no examples because you haven't looked.
&gt; A programming language is much more than just a bullet point list of language features. Precisely my point. That's why Scala is declining and Kotlin is growing exponentially. Scala guys can't even agree on [basic things](https://www.youtube.com/watch?v=v8IQ-X2HkGE&amp;feature=youtu.be&amp;t=375). On the other hand with Kotlin if you check the GitHub page or the official forums / Slack you can see that people are cooperating with the Kotlin devs, brainstorming and adding features to the language which are needed and not because some graduate student needed to contribute to the language. &gt; zero friction, no need for extra tooling, less layers to debug, no need for FFI to handle programming idoms or additional semantics This is the exact case with Kotlin. Not with Scala.
There is no mention of Dotty which makes the same mistake as Python, PHP and Perl: they'll compete with Scala since it won't be compatible with it. I don't know why they don't learn from the mistakes of others. &amp;#x200B; Another thing which I'd mention is the IDE support which is abysmal for Scala. :(
Forced unwraps are like putting a marker in your code "this might crash one day". But if you write pure Kotlin code, rarely will you end up in a situation where you have to do this. There are some edge cases, but most of those will be fixed with contracts. If you find yourself using forced unwraps in a piece of Kotlin code you wrote that has no external dependencies I'd be very critical of yourself. If you still end up using it, why not comment why you at some point want something to possibly be null, but then later are so sure it is not null (even though the compiler cannot infer that). The next person to work on that code will thank you. And if you don't comment, they'll probably stuff null into your optional at some point. 
Search online for a solution in Java, you can use the same approach with the same libraries in Kotlin. IDEA can even convert Java to Kotlin on the fly if you paste code into a .kt file. I use this approach all the time when I wonder 'how to do X in kotlin'
Which version of kotlin is this? Jvm or Native?
I confirmed it with Kotlin 1.3.21 (JVM)! 
Wait, identity equality === is deprecated?
It's just deprecated for Double in this case. For regular types it is not!
Wait a second. What I was trying to say is that the recommendation is to use these operators for platform types (`!!`, `?`, `?:`). I'm not using `!!` anywhere. If you check [this](https://github.com/Hexworks/zircon) OSS project I'm working on, you'll find zero matches for [`!!`](https://github.com/Hexworks/zircon/search?q=%21%21&amp;unscoped_q=%21%21) in fact. It is 98% common code and I'm not allowing nullability anywhere.
I see, makes sense :)
Great Job. Simple but awesome.
Thanks, appreciated!
A true Kotlin WAT. Congratulations!
It's deprecated for Int, Float, and Double, at least!
Fantastic news. Lack of ide integration was one of the key factors in not adopting KotlinTest before. Great to see this.
Nice article. I've also written about the topic [here](http://the-cogitator.com/posts/blog/2018/06/29/the-nature-of-nothing-in-kotlin.html) where I expand a bit on what `Nothing` is.
This is going to really mess me up because I have used `-0` *looks at notes* approximately zero times in my code, ever.
Same for me, except I use it approximately minus zero times, so I guess it's not exactly the same
The discrepancy in the first example (string interpolation) is because the Kotlin compiler evaluates `-0.0 == +0.0` at runtime, but evaluates `"${-0.0 == +0.0}"`) at compile time, using different logic. The discrepancy in the second example, (`Double` vs. `Any`) is that `Any` is a boxed `java.lang.Double` and the contract of `Double.equals` explicitly specifies that it has two behaviors different from the primitive `d1 == d2` expression, one of them being &gt;If `d1` represents `+0.0` while `d2` represents `-0.0`, or vice versa, the equal test has the value `false`, even though `+0.0==-0.0` has the value `true`. Now, we can speculate that the constant evaluator the compiler uses in the first example uses an AST representation, a tree with `Double` instances attached, and it uses `equals` to evaluate the equality of what was actually two primitive `double`s.
Something, something equals implementation of boxed vs unboxed types? Also using equality comparison for floating point values...
Didn't know you could do that, interesting
Awesome explanation.
Wow! Thanks a lot for this explanation. This is pretty interesting. How do you know such things? 
I just went in and studied it in the IDE :)
You are a wizard to me now!
The tutorial is for Javalin, but it should be pretty much identical in Ktor: https://javalin.io/tutorials/email-sending-example-kotlin
Basically r/theydidthemath
Some examples of Kotlin friction on the Java platform, versus just using the platform language Java: - Only InteliJ has first class support, Eclipse plugin is always behind, Netbeans support does not exist; - Lack of incremental compilation for annotation processors (Yes I know it is being worked on); - On Android, code completion is currently broken, e.g. https://issuetracker.google.com/issues/121340427 - Requires interoperability guides, https://kotlinlang.org/docs/reference/java-interop.html - Needs to have libraries to change default semantics of known Java libraries, https://blog.jetbrains.com/idea/2018/10/spring-and-kotlin-final-classes/ - Building on the last point, lack of support for JEE CDI annotations, https://youtrack.jetbrains.com/issue/IDEA-192642 - Code that must be portable to Kotlin/Native, has different semantic expectations between platforms, https://kotlinlang.org/docs/reference/native/immutability.html - It remains open subject how coroutines will be mapped into JVM fibers - Increase usage of Kotlin specific libraries like Arrow or Anko, which aren't easy to consume from Java 
Alright then. So I assume you're not allowing nullability for a reason in your own code, and not just doing it for the heck of it. Hence it's a problem when you're talking to JVM classes that expose nullable values left and right, it's not "seamless" or problem free experience. Writing Kotlin code that interacts with platform code that looks confused?:? and angry!! is of course still Kotlin (it's not an accident that these operators exist), but it is not the _natural_ way of writing Kotlin, hence it is not idiomatic. The fact that the standard library of Kotlin is small (certainly compared to Scala's) means you are confronted with this problem quite often, and probably more than necessary. And arguably it's worse for many non-JVM interop scenarios.
Now write the same list for Scala. It won't fit your screen.
It is seamless for me. Precisely for the reason that `?` and `?:` exist. In Java you would have to do things like `if(somevar == null)`. I'm not allowing nullability because I *can* do that in Kotlin so why not? But there are prominent people within Jetbrains (like Roman Elizarov) who embrace `null`s and nullable types (`T?`) so using `?` and `?:` is part of their daily routine. For all of these issues you get an auto-fix thanks to IDEA: it highlights such issues and auto-corrects them for you (Alt + Enter).
No-one is saying "you can't use `?`, `?:` etc.", though, as yourself seem to embrace, you typically won't use them much. The problem when interacting with the JVM is that you get Optionals that may or may not be an Optional. Or as Jetbrains themselves put it: &gt; T! means "T or T?" T and T? are idiomatic Kotlin when used correctly. T! is and always will be a compromise. A compromise that, like any compromise, is not free of problems. Scala largely avoids this by having less reliance on the Java standard library. I honestly don't know what the plan is for Kotlin here, it seems somewhat up in the air to me.
I agre! let burn him at the stake.
I don't see a problem here. Treat `T!` as `T?`, and problem solved.
`.equals` is not always identical to `==`
Neither -0.0 nor +0.0 are null, so for them, it'll always evaluate the same.
You keep missing the point that both languages are a tiny spot on the Java world, and both languages do introduce friction. Kotlin might have a rosy life alongside Android, just like Scala might have a rosy life in big data and distributed computing. They will always be fighting for 2nd place on the JVM, and if they don't take care they will join a myriad of others fighting for 3rd place. 1st place always belongs to the platform language, the only way to win it is to reboot the platform in another language.
this isn't kotlin specific. the IEEE defines signed zeros, so this makes kotlin compliant
You're saying that it is IEEE-compliant to return sometimes true and sometimes false for the same comparison?
no, i didn't look at the post in detail and made assumptions. I tried deleting my post as soon as i realized my mistake, but you had already responded
I'm not missing anything. You are talking about a completely different thing. I never talked about Java vs Kotlin. I talked about Kotlin vs Scala. My point is that the boat has already sailed for Scala, its Reddit is dead, the ecosystem divided, people moving away from the language, and Dotty will be the last straw that breaks the camel's back. That's what I'm talking about. And BTW Kotlin has already started moving away from the JVM with Kotlin multiplatform.
\`==\` is basically \`Objects.equals(first, second)\`
Ignoring the problem is one way to deal with it.. 
There is no problem to ignore.
Then you're ignoring that `T!` was created to signify that it might never be null, or only null in error, _or_ intentionally and thus meaningfully null, like `T?` in idiomatic Kotlin.
&gt; barely usable for real-life programming Lol. Sure, it's [used to implement the backbone of Twitter's and Netflix's infrastructures](https://datarootlabs.com/big-companies-use-scala/), but it's barely usable for real-life programming. If that ain't a troll...
Yes. That's why you can be pragmatic and treat T! As T? since there is no practical difference. These types should only exist at the boundaries of any program anyway.
Been trying it out. It does not work for some reason. I get the same exceptions as using commons-email docs: SocketTimeoutException: Read timed out.
Been trying it out. It does not work for some reason. I get the same exceptions as using commons-email docs: SocketTimeoutException: Read timed out. Could you help me out?
First thing I would try out is to see if the SMTP server is actually reachable, for example using telnet, and gives me a proper SMTP response. If that works then I would try to increase the timeout (mail.setSocketTimeout) to rule out that the time is too short. If it still fails that means there is an error with how you setup the SMTP connection in commons-mail, since it worked with telnet. My last resort after double checking the URLs would be to turn on verbose debugging for the commons-mail and compare that with their manual approach.
[https://www.jetbrains.com/education/download/#section=idea-Kotlin](https://www.jetbrains.com/education/download/#section=idea-Kotlin)
I’ve been using DSLs and faker lib for defaulting values. You’re kinda mimicking what a DSL does but your approach is more verbose.
I teach Kotlin (Android) in college for fun and I found these resources helpful. https://superkotlin.com/kotlin-mega-tutorial/ https://books.goalkicker.com/KotlinBook/ http://jussi.hallila.com/Kollections/
Right. You could even describe it as a problematic seam at the edges of your codebase. 
Thank you for your inputs. I think setting up a custom DSL for your domain types would be equal to writing such mockXxx functions. Would be great if you can share some sample code to help me understand your approach.
I'm not sure what are you trying to say with this.
Just because you can sell Scala to the stakeholders it doesn't mean it is usable.
I use exact same technique and like it. It doesn't matter whether you call it mocking or DSL. It is all about creating objects which help to create readable tests.
Thank you for sharing
These are two versions of "internal DSLs", and yes, you don't always have to use the function literal with receiver syntax to have a clean internal DSL.
These are two versions of internal DSLs in Kotlin, one using the [function literal with receiver](https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver) syntax, and the other, using constructors.
These are two versions of internal DSLs in Kotlin, one using the [function literal with receiver](https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver) syntax, and the other, using constructors. (An *external DSL* would be more like a kotlin script with compiler extensions.) There is nothing, in my mind, that says you have to pick one or the other. They're just two different tools. I like the function literal approach because it's pretty easy to inject logic in there, e.g.: myServerDefinition { if (environment == "dev") { hostname = "localhost" logAWholeBunch() } else { hostname = "something-real.example.com" } } The block is just... a function. So mixing in logic you don't account for in your constructors is there. But if everything is very structured, sure, I bet using data classes can be pretty clear too. YMMV.
What a great collection of Kotlin stuff. Thanks. 
One massive difference in the two examples you have above is the "classical" doesn't support any sort of logic. It only _looks_ similar because you are showing a very simplistic, static example. As soon as you are dealing with dynamic data, the "classical" one falls apart completely. For example, lets say you were rendering a list of items, and you wanted to filter them out. With the DSL, that logic can live right inside the output, while the other one would require something far harder to reason about: body { ul { items.filter { ... } .forEach { li { +it.value } } } } (I probably have a mistake above, but you get the idea.)
It means that args (the input to the main function) is an array of strings. Main is not returning anything which is why the parentheses isn’t followed by a colon and a return type. The syntax is similar to saying public static void main(String[] args) in Java.
i understand now, thanks so much :)
Floats are a mess. Multiple representations for the same number isn't restricted to just 0. [https://stackoverflow.com/questions/34112338/can-ieee-754-floating-point-numbers-represent-the-exact-same-value-with-multiple](https://stackoverflow.com/questions/34112338/can-ieee-754-floating-point-numbers-represent-the-exact-same-value-with-multiple)
Excellent answer. It’s also worth pointing out that args is an optional argument for the main function as of Kotlin 1.3. In other words, if you don’t have any use for it you can just omit it.
Another difference: in the "withDSL" approach you don't need to have so many names at the top level, and people can still get to them without having to qualify them all the time. For example, in the "withoutDSL" version, you can use `H1` wherever. In the "withDSL" version, `h1` is a member of `BodyTag`. You can get to it without qualifying it inside of `body` because of the implicit `this`. This is perhaps a bit more obvious when the DSL is in a separate module, and all of those implementation names aren't accessible.
It's roughly the same as: Body( Ul( items.filter{}.map{Li(it.value)} ) )
There are a lot of cool products out there these days that make it fun for kids to learn programming concepts. Jumping straight into a language like Kotlin will probably be difficult and boring for younger kids. https://www.steampoweredfamily.com/education/the-best-coding-toys-for-kids/
Or `if __name__ == "__main__"` in python (it looks like this guy could be a python programmer because of the `def` mistake instead of `fun` in the second example)
If you're writing pure kotlin you probably won't ever need `!!`. In a perfect world you won't ever need `?` and `?:` because nulls are a bad idea when we have more modern ways of dealing with "invalid" return values. Like `Option` or `Result`, stuff like that.
&gt; I like the function literal approach because it's pretty easy to inject logic in there Thanks for the input. However to me it seems we do have the same flexibility with the classical, constructor-based version: class MyServerDefinition(var host: String) fun logAWholeBunch() {} val environment = "dev" val serverDef = MyServerDefinition(run { if (environment == "dev") { logAWholeBunch() "localhost" } else { "something-real.example.com" } })
best guide, looking forward for next article. &amp;#x200B;
&gt;As soon as you are dealing with dynamic data, the "classical" one falls apart completely. Not at all! :) (see below) &gt;With the DSL, that logic can live right inside the output, while the other one would require something far harder to reason about \[...\] Au contraire, we can do the same with the constructor-based approach. Here is an example in terms of the original HTML code: data class Item(var value: String) { fun isOK() = true } var items = listOf(Item("one"), Item("two"), Item("three")) var content = HTML( Head( Title("filter test") ), Body( *items.filter { it.isOK() } .map { Text(it.value) } .toTypedArray() ) )
Great explanation. Useful illustrations!
What about accessing properties from the receiver? Like let's say body has a property language. In the constructor one you can do: ``` Body(...).apply { language = Locale.US } ``` But in the DSL version it could be: ``` body { language = Locale.US } ``` Additional to this, in a well designed DSL you can access variables in the parents context and hide members of the parent context. Also adding extension functions to add behavior inside of some context but only available there. Like having an extension function available for String but only inside a block: ``` someExample { inner { val vowels = "...".vowels //valid in this context } val outterVowels = "...".vowels //not valid in this context, even a compile error } ``` Both cases are achievable with constructor + apply/run/also/let but i feel like the are less readable. It's true that it's only a matter of taste. (Sorry for pour format, I'm on mobile)
&gt;What about accessing properties from the receiver? Like let's say body has a property language. In the constructor one you can do: &gt; &gt;`Body(...).apply { language = Locale.US }` &gt; &gt;But in the DSL version it could be: &gt; &gt;`body { language = Locale.US }` If `language` is a parameter of the constructor of `Body` (maybe with some default value), one could do Body(..., language = Locale.US) without needing `apply` or similar. &gt;Additional to this \[...\] Thanks for the hint. I don't yet fully understand your example, but I will read up on this topic.
Very educational! 
Nice one!
What if someone types "null" as the input for a string. What if 0 and -1 are valid values in the range? The goal of null safety is enforcing "nothing" as a logical thing. You type more to say "this can be nothing." Which is different than the things that can't be nothing. 
To complement the reply from u/dmeadows1217, **all functions in Kotlin have a return type**, function `main` here returns type [Unit](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html). Which by default is implicit and therefore omitted. Even a function that never returns (e.g a function with infinite loop or always throwing an Exception) has a return type: [Nothing](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-nothing.html).
Thanks! Can i change any of the values? For example Array&lt;Int&gt; instead of String, if so what would that do and also why is the default an array of strings?
&gt; Putting ? infront of each var type seems to be a nuisance. Assuming you mean after: If that's what you're doing you're doing it wrong. Most vars are generally not nullable. So you should only make the ones that are in fact nullable nullable in code. That way you're forcing yourself to properly handle these cases. &gt; Or set strings to "not set" instead of null? That's what null is. A value has not been assigned. &gt; Or even set the string to "null" to indicate it hasn't been assigned yet. And then breaking your system in horrible ways when some joker puts in "null" as their last name? No thanks. Defensive programming is a habit most (good) developers get into through experience. Because thinking ahead about these kinds of stuff is way less annoying than debugging a production system on Saturday 10pm ;)
The 'main' method is a special case in most programming languages because you can start an application with command line parameters. These are the 'arguments' (shortened to 'args') that get provided to the program. The 'args' is just a convention; you can name it anyway you want. It doesn't matter. So you can have functions with any type of argument (Int, List&lt;Int&gt;, Array&lt;Int&gt;, MyOwnObject) but the main method is generally required to have an array of Strings as it's only argument, or have no arguments at all. So: fun main() { println("Hello World!") } This is probably the simplest runnable Kotlin program you can find. It will get compiled to a 'standard' main method by the kotlin compiler and the JVM will find this 'main' method when you run the program.
Thanks i think i understand properly now :)
This article could be helpful: https://handstandsam.com/2019/02/24/when-you-should-use-null-in-kotlin/
&gt; Why not just set int values to 0 or -1 before they are set by user input or before the required system assignment. Indeed, why not. If you do that, you have a non-null variable and Kotlin's null safety features ensure that you can dereference it without an NPE. &gt; Or set strings to "not set" instead of null? Indeed, why not. If you do that, you have a non-null `lateinit var`. &gt; Or even set the string to "null" to indicate it hasn't been assigned yet. Indeed, why not. But then you _do_ have a nullable var and you can't safely dereference it.
Great article with awesome illustrations! 
We were discussing the schemas with a colleague of mine, and we noticed one funny tidbit. &amp;#x200B; If we take the analogy to it's limit, then the processed crayons should not be in the big starting box anymore. However, as trained developers, it's pretty clear to us instinctively that the crayons are indeed present in the big starting box and in the small processed box at the same time. &amp;#x200B; Ubiquitous crayons, the funny limit of real world analogies. &amp;#x200B; Great article anyway!
Didn’t even notice that :) good catch!
This was good.
My key takeaway is safety and forcing you to think ahead to use null where necessary.
DSL's have the same value as macros in other languages. With a standard function call, the parameters are evaluated by the time they reach the function args. With a DSL, you enter a scope and are then evaluated. This means some paradigms without macros (or DSLs) would be impossible or very clunky. For instance, I'm working on a project right now where data needs SQL connections and we need to ensure that everything is closed properly (otherwise we could leak connections). I have a small DSL defined here: [https://gitlab.com/yak-stack/yaklet-webserver/blob/master/src/main/kotlin/ConnDriver.kt](https://gitlab.com/yak-stack/yaklet-webserver/blob/master/src/main/kotlin/ConnDriver.kt) that allows anything inside the scope to have a connection. It takes a connection from a connection pool, gives it to the requesting scope, and then when it leaves the scope, the requester has to cede control of the connection. So rather than: &amp;#x200B; val connection = connectionPool.getConnection() try { // do stuff with connection catch (e: PGSqlException) { throw e } finally { connectionPool.returnConnection(conn) } &amp;#x200B; at each request for an exception, I can do: &amp;#x200B; withConn { // do stuff with connection } &amp;#x200B; This has the benefit of ensuring the connection is not used again outside the scope and doesn't take the variable name connection either. The only way to replicate this without a DSL would be to construct a class that does that same thing, that has a function that takes a variable number of lambdas with a variable number of parameters that will run each one afterwards with these protections in place. Actually writing this out is very clunky and your users will just end up doing it the classic way and forgetting to catch and deal with exceptions.
Thanks. That seems like a very good example to me!
Null vs empty string vs 0 : https://www.reddit.com/r/ProgrammerHumor/comments/a7racq/javascript_empty_string_vs_0_vs_null_vs_undefined/
Yeah you've got the right idea. Happy to help. 
Null is the best way to represent a missing value in Kotlin. This is because nullability is baked into Kotlin's type system to force you to use it safely so using nullable types will result in less defects than using fake values. Regarding your example of having to repeatedly use the safe-call operator with nullable vars, this is actually an extra safety net. Imagine if you used a fake literal in a var like -1, you hopefully remember to check for this scenario and then continue to use it after that initial check because you know that it has a proper value going forward right? Wrong! This var could have been a proper value when you checked and then it was set back to -1 from another thread and now you used -1 in your business logic and accidentally payed the customer instead of charging them. Depending on how this value is used or how often it happens, you may have just caused your startup to go bankrupt. The simple solution is to always use `val` when possible or to copy the var into a temporary local `val` so that you only need to check it once. You might think that this is also possible with fake values but the big difference is that the compiler forces you to make this decision whereas with fake values you might forget. Using fake values is a big red flag.
How does this compare to Java's stream methods? In particular, does Java create and discard unnecessary arraylists between each method?
https://medium.com/@elizarov/null-is-your-friend-not-a-mistake-b63ff1751dd5
Chrome V8 had such issues for JavaScript. It could be exploited to run [arbitrary code](https://www.jaybosamiya.com/blog/2019/01/02/krautflare/)
I know this thread is old but nobody mentioned KVision: https://github.com/rjaros/kvision-examples/tree/master/template-electron it can work with electron too for desktop apps: https://kvision.gitbook.io/kvision-guide/ It's especially useful if you're coming from a web dev background. 
Have you tried `/defaults.properties` instead? The leading / is needed if you are reading from resources folder. I'm on mobile, I'll provide a working example later.
What's ...javaClass.javaClass... for? Can that be just ...javaClass...?
This guide was incredibly well done! So it seems to me like anywhere that you are collection chaining and ending with a `.first()` or `.take()` or something similar that this is a no brainer for minimal performance boost. Does that track with the rest of you?
? (or not) is a lot more convenient than some crazy annotation processor picking up @Nullable and @NotNull
Tried this too, same result.
I tried several combinations like below. I actually really don't think it has something to do with the string or the javaClass I call .getResource on. I figured it had something to do with my class path being wrong due to module setup or something similar. Or maybe it matters what module I use to boot the application.. I'm at a loss
No, because **Java Streams are pretty much Kotlin Sequences**, which means they are lazy and do not create unnecessary objects. Kotlin gives you freedom between lazy(`Sequence`) and eager(`Iterable`) data processing, while Java restricts you only to lazy one. 
All I can say is that Kotlin prefers simplicity, but nobody is going to care about that one.
It's a little bit easier to read and write, that's it. Though I find myself writing ${var} only to press Alt+Enter and turn it to $var quite often.
Well, intellij and ktlint care about it by default because it's part of the published conventions.
Kotlin likes terseness. For complex expressions, the curly braces helps disambiguation. For example, is $x.y meant to be ${x}.y (evaluate x and concatenate with ".y") or ${x.y} (evaluate call to value y in object x) ? I like the convention.
I understand that the curly braces help with disambiguation. What I don't understand is what value the absence of them provides aside from "terseness". It's also puzzling that this is the same language which justifies not having a ternary conditional operator because it provides no functional advantage over the if/else expression (other than "terseness"...)
I am still listening :) And I still have found no definitive answer. 
Yeah, I dislike the absence of ternary conditional operator.
Using spring I just injected a ResourceLoader: resourceLoader.getResource("classpath:accounts_test_001.csv").file If you are using modules, do you have the resource on the `build` folder? Here you have a nice explanation on how the build process packages / copies the files and why/when to use ClassLoader or ::class to retrieve resources. https://stackoverflow.com/questions/22000423/javafx-and-maven-nullpointerexception-location-is-required/22011185#22011185 
Two less characters. Does the same thing. Should be preferable
Turn that lint rule off
What are you trying to do here? It looks like there is a pretty high chance of crash (if somebody call the get at the wrong time). Does `by lazy { }` work for your needs? How about `lateinit`? Failing those, I think the best option is `?:` and a sane default. 
**\_aaa** while be initialized at the certain time before `get()` called, but it's not in the `init` or `constructor,` so `lateinit` can't be used in this case.
You can initialize a lateinit var at any time you want.
What gladed said. Stuff initialised in the constructor doesn't even need to be lateinit
I think, it's to prevent confusion with the elvis operator which is a null coalescing operator. In Kotlin the purpose of the question mark is to deal with nulls and not with booleans.
"not set" isn't an absent or unset string. It's a string with the value "not set." If you do this then the type system can no longer help you keep track of the variant condition and you're back to the dynamic nullability shitshow. The approach of avoiding nulls by embedding arbitrary sentinel values into the result is especially bad because of the semipredicate problem. Instead of getting a quick NPE you get subtle errors that result from conflating valid values with sentinel values. These invalid states will quietly propagate and create strange behaviour. Your system ends up in an article about [users who can't log in because their last name is Null](https://www.wired.com/2015/11/null/) or [people receiving parking fines because their vanity license plate is NOPLATE].
Although strictly true, actually doing so would be considered really un-idiomatic. And when calling against system views, it should be 100% safe. 
You could try using a NotNull delegate. private var aaa: Something by Delegates.notNull() print(aaa) // Will fail with IllegalStateException aaa = Something(stuff) print(aaa.stuff) // Works fine
Cannot use the Java one??
You can just use the java library. https://www.rabbitmq.com/java-client.html
Dude, you gave me something to work on over the summer, thanks!
Why do it more complex when it may be simpler ???
Looks good, I'll try it when I'm home from work!
I hate typing curly braves : the less the better !
Note that current Kotlin practise is the same as that in Bash (the script and command-line language in Linux)
Ranges would be useful to include in the annotations. Id should be in 1...1000, created should be in "2018-02-12".date().."2019-01-12".date(), etc. Also, I don't want to "pollute" my entity classes with these, so annotation might be the wrong fit for this. I think it'd be better to be able to bind properties, e.g.: ``` val fakeProducer = fake&lt;User&gt; { bind { id } .toRange(1..1000) bind { created } .toRange("2018-02-12".date()..."2019-01-12".date()) } val u1 = fakeProducer.produce() val u2 = fakeProducer.produce() etc ``` 
I highly recommend electron then, it can work with javascript graphics libraries
Sorry guys I was asking, because I am new in Kotlin world.
The behavior of `lateinit` is almost identical to your code, only better. Your design lets you reassign `null` at any time.
No offense, but I just don’t see it happening. How many times do we have to be fed this mythical “write once” future before is sounds like a broken record?
What about Java?
I mean, yes, technically speaking the JVM runs on everything. Practically, though, Java isn’t really used to write iOS apps, web frontends, video games, etc. I’d say Javascript is the closest to the “write once” future insomuch that it’s used for websites, backends, and can be used with React Native or Electron for mobile/desktop clients. Everyone I’ve talked to who’s used RN on a large scale has had horror stories, though. 
Eh, “write once” often implies some kind of common system abstraction, which is why it usually doesn’t work. the Kotlin approach of “run something with libraries on different systems” might end up being stronger. Sometimes the common abstraction just doesn’t work, so, you’ll need to dive into something specific. It’s not really write once, it’s just having a very versatile tool.
I agree, JS is the nearest (also without RN)
Kotlin native if one of the most promissing technologies to this problem because of power of the language itself and way how it solve the problem. Not saying that just like that - we are finishing Kotlin Native Android - iOS app with architecture we wanted and so far its great. (Android DEV for 7 years)
interesting, haven't seen this
\&gt; Java isn’t really used to write iOS apps, web frontends, video games, etc That's where Kotlin Multiplatform comes in - runs (natively) on iOS, web frontends (compiles to both JavaScript and WebAssembly), can run video games, run on raspberry pi, desktops, servers... Kotlin can have as big reach as JavaScript while running at near-native performance and being an actually good language with great tooling. It's not there yet, but it could be. 
\&gt; That's where ~~Kotlin Multiplatform~~ React/React Native comes in - runs (natively) on iOS, web frontends ~~(compiles to both JavaScript and WebAssembly)~~, can run video games, run on raspberry pi, desktops, servers... ~~Kotlin~~ React/RN can have as big reach as ~~JavaScript~~ native code while running at near-native performance and being an actually good language \[editor's note: lol\] with great tooling. It's not there yet, but it could be. &amp;#x200B; Not exactly 1:1 but you get the point lol
Yeah but Kotlin ain't shit mate. 
Well ya do got me there lmao
&gt; It seems like we should prefer consistency, such that we would use curly braces in all cases regardless of the complexity of the expression. I would only use `${}` if IntelliJ didn't "fix" it for me. It doesn't bother me a lot though.
Difference is that Kotlin Native is more like C then it is like Java, in that you compile it to native rather then distributing a jar and hoping that the places where it runs have a jvm. Instead of "run anywhere", it should be "write once, compile for anything" 
I found the problem thanks to that stackoverflow post. &amp;#x200B; Apparently my resource folder isn't built to the C:\\\*\\api\\out\\production\\classes directory automatically. I moved them there manually and now if I call: **var** resource = **AccountController**::**class**.*java*.getResource("/resources/defaults.properties") I get the instance of the resource.. &amp;#x200B; Of course copying the resource folder to the build output is more than unpleasant.. But I guess I can figure that out myself. Thank you for your help!
I think the approach they're taking with Ktor for networking libraries is great.
Usually lateinit is preferred but it can be useful for primitive types and other small things lateinit can't be used for
Interesting approach. But an annotation processor would generate you all the boilerplate code; what does this win you over simply writing new instantiations? And wouldn't ranges with a simple 'produce' getter defeat the whole controllable issue?
Check this out https://github.com/viartemev/the-white-rabbit
&gt; But an annotation processor would generate you all the boilerplate code Framework/library independence in my data classes. I don't want mock generators/annotations in my data classes either. &gt; what does this win you over simply writing new instantiations? You would set this up once and then could bulk generate instances in a for loop. Fake data would be really useful in initializing performance testing, for example, or for testing code stability. &gt; And wouldn't ranges with a simple 'produce' getter defeat the whole controllable point? Sure - I shouldn't have focused only on ranges. I was thinking you could have a range of functions to produce data, e.g. toRandomValue(range?), toOneOf(set), toConstant(value), etc. Maybe you could also set a default for any unspecified properties, so you could do something like: val fakeProducer = fake&lt;User&gt; { default { toRandomValue() } } ...or similar.
Is there a chance you would share at least outlines of this architecture?
Try it and see it for yourself.
&gt;Framework/library independence in my data classes. I don't want mock generators/annotations in my data classes either. No objections here. Maybe Annotations could be moved to a top level function or an interface. &gt;You would set this up once and then could bulk generate instances in a for loop. Fake data would be really useful in initializing performance testing, for example, or for testing code stability. I hear what you are saying, but I can't see this approach going beyond stability and performance. And I hadn't even thought of that initially. What I had in my was way more controlled, but maybe this could even lead to something better.
Do you run the tests as another process just accessing the server? What's the `engine` you're using in your test? Ktor offers a `withTestApplication` method, which basically strips away any network calls and directly uses the route functions - ideal to test your application logic (you might be already using that, not sure after reading your post). Also, how do you call your test? IntelliJ? Gradle tests? If you provide the info I might be able to help, I'm currently working on a very similar setup.
Yes, I know that first thing is to consider write it different. With tools that suits it best i.e. try to use Ktor testing facilities, e.t.c. But if nothing helps I can help you with mockk. Probably you need to mockk some extension function and don't know how to, do you? Check this PR [https://github.com/Kotlin/kotlin-fullstack-sample/pull/28](https://github.com/Kotlin/kotlin-fullstack-sample/pull/28) it is about testing example project with ktor.
We use a pure Kotlin version of [spotify/mobius](https://github.com/spotify/mobius/) to get the most out of Kotlin's multiplatform capabilities. We have Android(kotlin), Web(Js), and iOS(swift) clients that share pretty much everything for our application. The only thing written on these platforms is for rendering the UI and receiving UI/System events.
The developer only has to write their code once for it to be run on every system, which is the main goal of "write once."
Check out Christina Lee's segment in this video (about halfway): https://youtu.be/fPzxfeDJDzY
I would focus on a few things: * It’s got big companies behind it. It was created by JetBrains and is an officially Google supported language for Android development. Managers will want to know that this language they have never heard of is not just some random guys sideproject. * It’s safer than Java. Better null type safety removes one of the most common Java runtime errors (NullPointerException). This means less chance of crashes, which result in unhappy users and bad reviews. * It’s easy to learn if you already know Java or similar languages, and it’s very compatible with the existing Java ecosystem. You call call Java classes from Kotlin and vice-versa. * It’s a language that developers love and very popular for Android development, so if you need to grow the team it will help you to hire good people.
In a sentence: it's like python but java. 
The big thing is that you can use all your existing tools. My company has years of Java libraries built up for metrics, logging, http, dbs, deployment, etc, and new Kotlin projects use it all flawlessly. There are some pain points where the APIs meet, but they are easily ironed out with a bit of glue code. And then, once you have Kotlin projects in production, recruiting gets way easier.
If that meant anything to management I wouldn't be seeking advice haha but I could spin it as being more similar to my main language (even though that's a huge stretch)... Thanks!
Very well said! At the end of the day, the main cons are a lack of Kotlin devs vs Java and the language not being as proven. But any Java developer worth their salt should be ecstatic to work in Kotlin if they haven't already. 
Haha, I know it was mostly a joke. 
One other big advantage IMO is that it's faster and more enjoyable (IMO) to write, which ultimately boosts productivity, something management would probably appreciate.
In addition to the great answers provided, you might also consider that since it compiles to native and JavaScript, it provides an optional migration path away from the JVM, which may be relevant given recent licensing concerns.
I'm not sure if this is helpful, and our system is a java application w/ Hibernate &amp; Spring, so different use case from an Android app, but we went through a vetting period and I put together answers to questions from the architecture team and management (mostly assuaging fears) to allow our team to use Kotlin: https://git.io/fhh4K I just copied it from our internal document so let me know if I messed up the formatting.
Lambdas are a first class citizen... need I say more? 
If your boss codes have him check it out. If he doesn't and the whole team wants to use it why would he care? Oh also large and very conservative companies are adopting at this point, so its not risky, if thats the concern. And developers love it so its good for hiring and retention, while also having JVM infrastructure and ecosystem underneath it.
You can easily use Kotlin without knowing all of the cool stuff and just treat it similar to Java. And as for being "proven", it's not like it's a whole new language since it compiles to Java bytecode and you can always look at how it compiles. It's a very short leap from Java to Kotlin and you can still use a lot of Java code examples from Stack overflow and just auto convert it or just make it a Java class since you can mix Java classes in with Kotlin classes in the same package with no issues. Anyway, the risks are very low, learning code for minimum usage for a Java developer is very low, and rewards are high. 
Stress that it's not all or nothing, you can run it side by side with Java and migrate file-by-file if you want to
Also there are already big companies using it. You want to retain the talent and attract new talent. There is Square, Rewe which are fairly big.
It was tried with JavaScript with NodeJS and of course websites and browsers and Electron. But that's a horrible language with a horrible ecosystem. If Kotlin can truly bridge the gap between all these runtime environments, we would have an awesome language with a solid promising ecosystem.
Do you have to sell it? Can't you just make it?
I've "sold" Kotlin successfully at 3 different companies already. I've written about it [here](http://the-cogitator.com/posts/blog/2017/05/19/kotlin-is-the-new-java.html#things-to-tell-your-boss). From a technical perspective what I think is the single most useful thing when it comes to Kotlin is **extension functions**. Using them you can wrap **any** Java library, bend it to your will, or attach a DSL to it. This tool is so powerful that I think none of the other Kotlin features comes close in usefulness.
Only thing you need to sell is that it can make them more money. Period.
One big disadvantage in "selling" Kotlin to others is that they might also have to switch the IDE they're comfortable with, so they would feel very unproductive in a new language and IDE at the same time.
&gt; It’s safer than Java. Not really. `"Hello".charAt(23)` causes a clearly defined exception in Java. `"Hello[23]` in Kotlin may do anything from returning invisible `0`-chars to throwing an exception to I don't know what Kotlin actually does. It's not documented, it could change any time because of that, and different Kotlin editions (JS/JVM/Native) do different things.
It just returns an array our of bounds
I done it by refactoring slowly a springboot java app into kotlin over the last year, in process adding more tests, making it more stable, and doubling number of features &amp;#x200B; then by making piles of small focused microservices only in kotlin &amp;#x200B; this coincided to move to kubernetes so mamagement doesnt care what language is used as long as service has a good rest API, other teams have node, php, scala, java, python and so on services as well as piles of .net stuff
Now use https://try.kotlinlang.org/ and set it to JavaScript at the top. Also why would I expect a `StringIndexOutOfBoundsException`? It's nowhere documented.
But isn't that what would happen if you ran the same thing as javascript?
I don't know, executing it in Chrome gives me "undefined", not 0. In any case, Kotlin should decide if it's just a better Java syntax or its own language with its own error handling.
Tell them it will increase productivity over time.
This is a great issue you raise. Have you submitted an issue on youteack? I will do so if not
No more NPEs 
There are some issues about missing documentation. Not this exact case, though. Or at least I'm not aware of it. And there are so many problems of this kind. Like all the error handling of collections (List.get for example) or how the hashcode of lists is calculated and so on. It's all not really defined and you have to hope the java rules apply. https://youtrack.jetbrains.com/issue/KT-28183 is related. 
I approve of this skunkworks approach
RemindMe! 36 hours
I will be messaging you on [**2019-03-11 07:56:46 UTC**](http://www.wolframalpha.com/input/?i=2019-03-11 07:56:46 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/Kotlin/comments/az3ymz/coroutine_context_and_scope/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/Kotlin/comments/az3ymz/coroutine_context_and_scope/]%0A%0ARemindMe! 36 hours) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
To be honest, I don't understand web dev stuff. I tried it many times. I tried js, I tried css, I tried responsive stuff... I never got a grip on it. 
I think your approach is great but I'd suggest mainly sticking to written documentation rather than videos. The ones you have are great, especially to help folks get started. But videos can become dated over time, and written documentation means others can help keep it up to date or make it more readable/accessible for newcomers. And written material can be read in small chunks, re-read offline, etc. I'd like to try to help out. It may take me awhile to get up to speed, and I don't know how much time I can commit, but I will try and spend a little time each week learning, especially the bytecode stuff. 
What I'd suggest is finding corporate sponsors. Find a company using Mockk that is willing to contribute with engineer time, or having some compensation in exchange for prioritizing their needs that lures people in. It's also helped us to leave the simplest non-vital tasks to newcomers, and ask for help with core things that the library needs like static analysis tools, CI, publishing or the docs site. People can contribute even if they don't understand the core of the library, and over time they can learn it.
I think what would help well, is to have a few 'easy fix' items in your issue tracker. These might help people (like me) contribute a bit more easily. I went through the open bugs, and it would take a significant amount of brainpower to fix any of the issues I looked at, but I only looked a 5 of them. If you have some 'easy fix' items, you make the barrier to enter a bit lower.
I think this is important. Reaching out to companies that use Mockk and have a vested interest in seeing it succeed might provide sponsorship via engineer hours. 
I was about to suggest this, I've seen it in other projects and it's a great concept. It might be an issue that the primary maintainer could fix in under an hour, but that brainpower is better spent working on bigger features, writing more documentation, and working on those big refactors to make the codebase more accessible. Some clearly marked "starter items" are great for getting people involved. If you leave the feature unimplemented for long enough someone who wants it will just do it on their own and could potentially become a more consistent contributor as they get more comfortable.
Yes, indeed all items submitted from users usually have "nightmare level" complexity to fix for newcomers. People just don't know what to take. Because usually such things are corner cases. &amp;#x200B; So adding easy to fix items is good option. Although I wouldn't like to have "synthetic work"(or at least minimize it's amount) and the question is how to write such tasks?
That’s very interesting. Is that pure Kotlin version of mobius available on github?
I will add your library to my Kotlin course list. Maybe some students would be interested. However, even for my own lib, kohttp, convention is low
I am wondering who that might be. From first sight everybody use it, but not sure if anyone has vested interest.
I understand, but sometimes there's a piece of code which can be refactored, a corner case bug for which you can maybe do the investigation, but let someone else build it, etc. You probably know much better where to look than others. It could also be some documentation update, or maybe a blog item, etc. It's meant more as an introduction level thing, to make people comfortable, and slowly get them more familiar with the codebase.
From my own experience developing [jasync-sql](https://github.com/jasync-sql/jasync-sql) (and also kotlin-logging) you shouldn't afraid too much of the bus factor. With jasync-sql I picked a pretty complex project which I didn't know at all, converted it to kotlin and fixed some bugs. When there is void someone will probably jump on the wagon. On the other hand, it is really hard to get contributions to a supported open source from my experience.
I don't really have any ideas or suggestions, but I'll share my experience. I joined the project [SparkJava](https://github.com/perwendel/spark) in 2014, and I tried to attract maintainers for four years. It's a fairly popular project with 8000 stars, and we have had a few regular contributors, but they work mostly on isolated issues. Sometimes people would express great interest in coming on as maintainers, but they would lose interest quickly. I started my own project [Javalin](https://github.com/tipsy/javalin) and tried to do everything right in order to make people contribute. I label all my issues, I always ask people who submit an issue if they'd like to submit a PR (even if that makes a 2 minute fix into 2 hours of explaining things for me), but nothing really seems to have a long-term effect. My biggest contributor said something like *"Hey, I saw your project. I was thinking about making something similar, but what you have here is pretty good so I'll help."*. He worked on the project for a month or two, made some improvements, then he moved on to something else. After five years of doing this, I don't really believe there exists a good way to attract maintainers. Maintaining a project takes a lot of time and energy, and it just isn't for everyone. On the bright side (?), someone usually steps up when a maintainer steps down, but as long as you're there pushing out new features and fixing bugs, it's unlikely that someone will help out regularly.
Right, I feel this barrier. It was before the project, when I wanted to contribute to open source, and after, when I am on the other side. And it is quite weird. Just thinking about psychology. For me my project is alike my home. I invite guests, behave welcoming, but never allow to set own rules. People are bringing gifts, visiting it for some time and leave. The problem is that when you want to contribute to such project(and even want to persist in a project) you do not see it from this perspective and just think it is about understanding the code and adding features. More technical aspect than social, but I guess to return back you need opposite, more social than technical. Getting enough dopamine is a key. Then it is a question of look and feel, having nice experience, feeling important, feeling doing the right thing, impress other people and all that stuff. As well important thing is how big community is, what interactions occur between members, e.t.c. So I understand what you are talking about, but anyway will give it a try to make it more than just a private project.
Yup, sorry for that
I didn't mean to discourage you, just describing how it has been for me. I think maybe one thing that helped was having a public chat room, almost all the bigger contributors chatted with me on gitter at some point. That part can also be a bit discouraging though, because even if I have 100 000 downloads, I have less than 100 people in the gitter channel. I guess most people are purely users. Don't give up hope though, keep being welcoming, and maybe someone will join some day. By the way, I really appreciate mockk, great job! 
Remove the binaries from MavenCentral temporarily and see who complains the most :trollface:
First of all - you have to understand WHY would anyone want to join you. Is there demand for the project? What is your selling point? What do people get from banding with you? There are thousands of open source projects out there, so you are competing globally. Second - after you have settled on the why's, prepare some marketing material and go around with it - meetups, talks, beers, twitter. Gather feedback, establish connections, find someone more famous than you and make a deal with him. &amp;#x200B;
I was about the write the same thing. CTO can understand advantages of Kotlin over plain Java. Other C-Level execs. do not need to be bothered with such detail.
Yes, it can be found [here](https://github.com/DrewCarlson/kotlin-mobius).
I'm partial to just passing in a callback
In all honesty I'd just use RxJava for this. 
RxKotlin
Ah, a variant on the ancient solution of "I wonder who's using this server - let's unplug it and see".
Yep, rx is most often used to handle events in Java/Kotlin.
&gt; in C# the concept of events is basically abstracted as a type of class member. Having such a member means you can subscribe to it from the outside but just call it from the inside of the class. A simplified version of C# events could be implemented as a mapping of event type to callback. Subscribers should be able to add a callback or remove one, but the actual event source can be hidden. It may be possible to generalize the pattern through a type and property delegate. Actually getting the Producer/Subscriber semantics right will be annoying, and threading will be a ton of work that RxJava has already implemented.
Channels are the way to go in Kotlin. You need to get your head around the way coroutines work but once you are there, Channels are really pretty slick. Unfortunately there's a lot marked obsolete/experimental. But what I have used works wonderfully so far.
Excellent work. 
I can’t wait for channels to become stable. They’re great I Go, and when stable will likely be good candidates for replacing streaming in general. 
Very cool. I'll have to try this out.
Thanks!
Thanks, really appreciate it.
Could someone tell me the difference between a coroutine, async call, callback/onClickListerner and threads? Heard these terms but not sure which scenario each should be used in.
What are the use cases for using the eager algorithm with chained intermediate operators?
Hi! Thanks for willing to help me out! I really appreciate I think it's better to split this problem into different pieces before I drive you and myself crazy... I will look into withTestApplication and engine more carefully later on. Since I am thinking of first writing some basic JUnit tests, I would like to ask for your help considering defining the behaviour of a method that returns an instance of this class: //Enable Data Access Object (DAO) for more convenient data-transactions class User(id: EntityID&lt;Int&gt;) : Entity&lt;Int&gt;(id) { companion object : EntityClass&lt;Int, User&gt;(Users) var email by Users.email var password by Users.password var refreshToken by Users.refreshToken } I have a method, called `findUser`, in `DataQuerier` which runs a transaction using exposed.dao.\* package. This method returns an instance of the class mentioned above (this is the same class as I mentioned in the original post). Now, I want to mock the behaviour of this findUser in such way, that the method always returns the same instance. Typically, using MockK, this is done using this: `val dataMock = mock(DataQuerier)` `every {dataMock.findUser("some string to look for")} returns User(...)` The problem that arises now is that I do not know what to fill in the params and other properties of this instance of User, since the class is decorated heavily with things such as `EntityID&lt;Int&gt;, Entity&lt;Int&gt; and companion object : EntityClass&lt;Int, User&gt;(Users)` . Currently, I have this: `val standardUser: User = User(` `EntityID(` `8,` `table = Users))` `standardUser.email = "myname@company.com"` `standardUser.password = "1234"` `standardUser.someOtherProperty = "something"` When I run this test, it fails with the following exception: java.lang.IllegalStateException: Property klass should be initialized before get. I need to assign the `klass` property of this instance, but I am looking through the debugger-window of IntelliJ IDEA and I do not know what to do with all this information and properties, or what is needed for my test to successfully return a dummy instance of `User`. Can you help me with this? 
I'm not involved in the project, but firebase has server side apis and integrations. I assume this is that.
Mockk is sweet! Love how easy it makes everything. every { time I use it } I return happy.
Excellent work. I'll send it to my interns.
In my opinion Coroutines are for structured concurrency, and channels are a means of asynchronous communication between coroutines. You can use the channels API just from coroutines which actually forces the caller to use coroutines as well.
On the one hand yes, that gives you the chance to continue on an event with reactive programming patterns. But on the other hand it could also be overkill when you _don't_ want to use rx.
Not *entirely* asynchronous. The backpressure model means that the sending coroutine may suspend *indefinitely* until the receiver consumes the event. This behavior of course will depend on the internal size of the channel but it was a nasty surprise the first time I ran into it.
It was posted 4 days ago, do a link search before posting next time.
Ab if expression is almost identical
👀
Only if you don’t change your answers. 
I can't promise that, I like to iterate on them.
For me, it works as expected. &gt;Returns a list containing only elements from the given collection having distinct keys returned by the given selector function. This is true, but returned elements have distinct keys in new, returned list, not in the original one. I think that SQL does the same. 
No mutations though... just provide new answers. 
But the object in the returned list doesn't have a distinct price. If it returned a list of the selector type I'd agree, but that's not the definition here.
I realise I'm being a massive pendant.
It does, this is the result, only element is distinct in this list -&gt; \[block(colour=red, size=S, price=100.0)\]. Function you need would be named something like removeDuplicatesBy
Actually, I think people would still expect function named removeDuplicatesBy to perform identically to distinctBy. Maybe removeRepeatingElements ? I get your point, but people seem to prefer to keep one of the duplicates instead of removing all of them. 
A lot of good points already posted. Something to add: Make sure management has no doubt that * Kotlin code runs on the JVM in the am context as Java code * Large companies invest their time and effort to use it because it solves their problems. Google, Pivotal etc.
Why was there little to no mention of FX in the release notes? It deprecates binding which should be replaced with FX which isn't really highlighted in the release notes afait? 
Announcement of Fx as a full effects system comes in 0.9.1 when we finish a new model that is more performant based on suspension and what we've learned about IO in Kotlin. We did not want to do two announcements. binding is still there but deprecated.
We were forced to do a release to fix some bugs here and there, and in the way we had already refactored the packages so it could not have been `0.8.3`. So 0.9.0 is a major bump but not much promo. It'll come with 0.9.1 ;)
We were forced to do a release to fix some bugs and additions here and there, and in the way we had already refactored the packages so it could not have been 0.8.3. So 0.9.0 is a major bump but not much promo. It'll come with 0.9.1 ;)
Sound good, thanks for the explanation :) looking forward to FX! 
In Java you do need to initialize variables. You cannot access an uninitialized variable. There's no difference between Java and Kotlin in this particular aspect
Kotlin tries to prevent null pointer exceptions at runtime by removing null being an accepted value for types unless it is explicitly specified. In Kotlin you can't use the variable until initialized because it doesn't automatically initialized to null because not all variables allow null. It is a trade-off made to make it so there are more errors caught at compile time instead of runtime. Uninitialized variables can be caught because they aren't automatically set to null. Null pointer exceptions are reduced because not as many variables are allowed to be null.
Please see my example.
Your example is incorrect. The two are NOT the same. One is initialized, the other is initialized to null. 
I might be wrong but I think that if the uninitialized variable is a member field of a class, then it will automatically be initialized to null when the constructor is called. That could be a cause of confusion for this post
&gt; Kotlin generally tries to be less verbose than Java, but needing to explicitly declare null seems unnecessary and verbose. If you're declaring null, you're probably doing it wrong. If you're depending on uninitialized Objects, you're also likely doing it wrong. You are fighting against the languages paradigms by setting things to null, and they want you to be aware of that. They won't automatically cast objects to null for you, because they don't believe you should be using null so often that this is an issue. Try to stay away from null wherever you can. Even in Java. Kotlin making you declare null means that there's no ambiguity - then there's no "whoops, I made it null", only "I definitely intended this to be null". You suggest that you are having a hard time struggling with Optionals but I would recommend trying to fix that. It's not such a difficult concept, but it does seem backwards until you've used it enough. The safety and verbosity of Optional is amazing.
You can assign a variable to null again when you done using it but not uninitialized.
In Java: - a member field `String a;` is default initialized to `null`. - a final member field `final String a;` is uninitialized, and must be assigned in construction. - a local variable `String a;` is uninitialized, and must be assigned before use. In Kotlin: - a property `val a: String` or `var a: String` must be assigned in construction. - a local variable `val a: String` or `var a: String` must be assigned before use. Kotlin is strictly more consistent than Java here.
It behaves exactly as I would expect it to. The resulting list doesn't contain any duplicates once you apply the lambda transformation to each element of the resulting list. Select distinct also includes values that were duplicated but without including the duplicates so that's the same (but without any transformation). Am I misunderstanding you?
There seems to be some confusion in this thread, so let's be clear: * In Java, class-level reference variables default to null, unless otherwise initialized * In Java, class-level primitive variables have a default value if they are not initialized (e.g. 0 for int) * In Java, local variables must be initialized before they are accessed (but do not necessarily need to be initialized upon declaration) Kotlin does not have a concept of default value for any variable/property. See https://kotlinlang.org/docs/reference/properties.html. You have to declare that it is null, a specific value, initialize it in the constructor, or declare it as lateinit . Ultimately, the language designers decided that code safety was more important in this case than a few extra characters. YMMV, but a language whose partial *raison d'être* is type- and null-safety is not going to be sympathetic to your wanting to default everything to null, and keep going.
Great question! I wondered about this at first as well. It turns out the answer isn’t directly related to the question-mark syntax, and that Kotlin and Java actually both behave the same way in the same situations. Both languages allow the declaration of a _mutable_ (non-final) variable first, as long as it’s eventually initialized it on another line. ```java String value; value = “Hello!”; ``` ```kotlin var value: String value = “Hello!” ``` Kotlin and Java even behave the same when it comes to immutable (final) variables: ```java final String value = “Hello!”; ``` ```kotlin val value: String = “Hello!” ``` The question-mark syntax is used to indicate nullability; in Kotlin, this is the only way a variable can be set to `null`. variables: ```java final String value = null; ``` ```kotlin val value: String? = null ``` In other words, in Java, everything is implicitly nullable. With that said, an immutable `null` value such as the two above aren’t very useful in either language.
The book "Kotlin in Action" was quite good. After that, just tinker with it by creating small side projects.
Your compiler will fail on your example if you read the uninitialized value.
I agreed with you initially, but I tested it out and it turns out OP is correct, variables are always initialized upon creation. It appears that there's no such thing as an uninitialized variable. It is merely an error that the compiler throws when it knows that the variable cannot possibly be initialized. However you can bypass the compiler errors by making the field modifiable outside its scope. In this case, the variable can be accessed and Strings are automatically set to null while primitive ints are set to 0. __________________________ public static void myFunc() { String a; int b; System.out.println(a) // *Compilation error* - variable has not been initialized System.out.println(b) // *Compilation error* - variable has not been initialized } __________________________ static String a; static int b; public static void myFunc() { System.out.println(a) // null System.out.println(b) // 0 } __________________________
As another commenter said, that's not correct. Regardless, a technicality is not what I was asking about. I know the terms may be different, but they work the same. Kotlin isn't like this. 
So I'm other words, by making null need to be explicitly declared, programmers are less likely to use it accidentally, so less errors?
No, they perform the same. Both would fail if you read them right away. 
This is my code that had me post this. How would I write this cleaner without using a null value? `medIndex` shouldn't have a value before I know what the index is, and if it doesn't exist it shouldn't have a value because that would imply that it *is* something. var medIndex: Int? = null for (i in 0 until medInfo.size) { if (medInfo[i].name.toLowerCase() == medName.toLowerCase()) { medIndex = i break } } if (medIndex != null) { medInfo.removeAt(medIndex) }
&gt; Try to stay away from null wherever you can. &gt; &gt; ... &gt; &gt; The safety and verbosity of Optional is amazing. If you're working in Kotlin, you're actually probably better off using nulls. Kotlin is aware of nulls at a language level. So if you every have a value of a nullable type, the compiler will force you to at least consider whether the value is null. And, even better, once you've proven that it's not null (e.g. via `if (foo != null)`), then within that branch the compiler will know that `foo` can't possibly be null. If you use `Optional`, you lose all that assistance. Sure, the `Optional` itself indicates that the value might not be present. But even if you've proven that the `Optional` does indeed have a value, the compiler doesn't know that and you still have to sprinkle `get` or `orElse` calls all over. Optional is a library-based solution to the problem. Kotlin has a language-based solution to the same problem. As a result, Kotlin can provide better syntax and better tooling than with the library-based approach. I'd argue that using Optional in Kotlin is an antipattern. The big exception, of course, is if you're writing Kotlin code that's meant to be called from Java. 
Never thought about the different types that way.
This is really the best answer. Kotlin doesn't have default values. 
Yes.
Just extract the search for index into a separate function, this will also allow you to make it immutable (val) instead of var. Also your code implies the medIndex could still be null in case when medInfo is empty, so it’s okay to use null here. Another approach is to remove the element via iterator, this way you don’t even need medIndex variable.
There’s still the benefit of encoding things at the type layer rather than handling them appropriately at the runtime. I believe that no language with functional support would an Option be an anti pattern (until something better comes around anyway) because along with the safety, you are able to handle many structures the same way. Like promises in JavaScript and the Publisher API in java as well as many functional data structures that you can get in Arrow, you can have your code look the same everywhere, which is another benefit. Elvis operators and being able to check non-null just once are cool language features but I still would use them on an as needed basis rather than as the solution to null. But, just my two cents! 
That seems excessive to make a function just for one use.
I’m constantly telling my students: you read code 99% of the time. It’s better to have 10 little functions which do one thing than 1 big one for all those 10 things. Don’t be smarter than compiler. It will optimize variables and inline functions. Make the code understandable for your future self. In your particular case the variable is declared mutable. No one stops you to reassign it later. Compiler won’t reject such code, and the reader will question whether this variable is assigned later or not, so he/she got to scroll down (if the function is big) to just determine that this variable is assigned just once. 
In my (admittedly limited) experience, when I write functions to do simple things, the naming just gets convoluted and confusing. Putting things directly in the code makes it more straightforward for future me. Comments can alleviate anything functions would clear up. 
1. Kotlin has distinction between "Type" and "Nullable Type". Type can't be initialised with `null` by definition, so there's that. 2. Kotlin has "immutable values", so, even if your type is nullable, initialising it with null will mean that you can no longer assign actual value to it. 3. There are also lateinit var properties, that may not be initialised at the moment of their declaration, but later (with responsibility of them not being called in-between resting on the developer). Such vars can have null safety of being non-nullable, while still having their actual value be assigned at a later stage. All above meaning that the only case where "default null" would make sense is `var a: T?` case, and letting that one default to null while every other one defaulting to "uninitialised" would introduce inconsistency in language, which is much worse than mild inconvenience of having to initialise that one unique case with null manually.
Try the opposite, extracting a function whenever you would write a comment. You may find it works well.
Yeah, sorry. When I read variable I thought specifically of a local variable. Fields (aka instance variables) are automatically set to their default value (null for objects) if not explicitly initialized. 
what if you add a survey to your GitHub repo and ask? perhaps that may help
I guess you need to realise that management do not care about what programming language you use but as to whether you deliver projects on time and money. Show them that Kotlin helps you accomplish these goals.
There's a good kotlin linter ([https://github.com/shyiko/ktlint](https://github.com/shyiko/ktlint)) which I'm currently porting into a vscode extension.
They wont perform the same. The uninitialized will cause your compiler to fail. The null will work. Put these two in a unit test: @Test public void testUninitialized() { String a; System.out.println(a); } @Test public void testNull() { String a = null; System.out.println(a); }
Need more info before I can be useful to you. What’s the target platform? Linux (embedded or desktop?), iOS, something else? And what’s the nature of the app you’re looking to write? What problem are you hoping to solve?
"Kotlin/Native is primarily designed to allow compilation for platforms where *virtual machines* are not desirable or possible, for example, embedded devices or iOS. It solves the situations when a developer needs to produce a self-contained program that does not require an additional runtime or virtual machine." [https://kotlinlang.org/docs/reference/native-overview.html](https://kotlinlang.org/docs/reference/native-overview.html) &amp;#x200B; I have used it, and I love it! UI is handled by the native platform. If you are developing for Windows, you will use their UI libraries; Linux, it's libraries. You will most likely have a common module that each of your platforms will use, and then platform specific modules.
I am also interested. Which architecture should I follow for mobile? I use MVVM in android with RxJava. would it be difficult to translate project with activities to IOS app? How should I handle UI references in Activities and fragments if IOS does not has them?
Pretty much my exact situation. It’s either Kotlin Native or jump on the Flutter train. 
 val indexOfFirst = medInfo .indexOfFirst { it -&gt; it.name.toLowerCase() == medName.toLowerCase() } if (indexOfFirst &gt;= 0) { medInfo.removeAt(indexOfFirst) } is a fine first implementation. But I would write a method called `removeFirstOccurance` which can be reused, attach it to the mutableList class and be able to use that wherever you want. But even better would be to not use a mutableList at all, and instead use the default immutable one, and return a new list at the end of that function, for even more guarantees.
In this article, devs created views in Flutter and common app logic in Kotlin/Kotlin Native: https://tech.olx.com/fast-prototypes-with-flutter-kotlin-native-d7ce5cfeb5f1 There's not a *ton* of detail but it seems in line with what you're trying.
Sounds great but at that point why not just use all Dart?
Dude, that's not how it works. You won't use the Android framework inside iOS or vice versa. You will use kotlin native to build pure kotlin code (think business code, models, etc) that can be reused as a library in Android/iOS projects. You won't be able to reuse any UI code. 
My bad. I got it confused with a declaration in a class or static level. 
That's not how Kotlin/Native works. You still create the UI using each platform's SDKs. So you would have an iOS project (with ViewControllers, RxSwift/RxCocoa), an Android project (Activities, Fragments, RxJava), and a common module that is imported to each project as a dependency. The common module could do all of the networking/data storage for your app, for example. Here's a great talk I saw at DroidCon SF, highly recommend watching [https://www.youtube.com/watch?v=c8IkWGmlcNE](https://www.youtube.com/watch?v=c8IkWGmlcNE) Flutter is an entirely different story. You share (nearly) all of your code between Android and iOS, including UI. But its an entirely new framework. No Views/Activities/Fragments. Enter [Widgets](https://flutter.dev/docs/development/ui/widgets). There's also [RxDart](https://pub.dartlang.org/packages/rxdart) I wrote a quick sample app using Flutter and the Yelp API a few months ago. I was pleasantly surprised about how easy it was to get up and running. Works great with Android Studio and the Flutter Plugin. I had no experience with Dart or Flutter and had a fully functioning two-screen (list/detail) app running in 1 full day. I had it running side-by-side on an Android emulator and an iOS simulator. I'm pretty excited for both of these frameworks. I think they both hold a lot of promise. They just solve different problems
Our networking is done in repository class. It is similar in both iOS and our android apps. It is injected in the viewModels and ViewControllers. We could share our repository with kotlin native I believe but it still uses RX inside of it... It seems that flutter is much better in general case. I thought kotlin native was more powerful
But business code still uses RX in most cases or kotlin couroutines. Can you reuse that in IOS? I think Rx should be doable
As far as I know you can only use pure kotlin libraries (not even Java libs) or libraries made for Kotlin Multiplatform. 
Yup that's how you would do it - share the repository using kotlin native. Kotlin native isn't meant to handle UI on multiple platforms. That's where every shared code framework has failed before (cordova, react native, xamarin). Flutter is great, but I wouldn't compare it to kotlin native. They are two different things entirely
I know, nitpicky, but language level default values. Kotlin does have default values and I love them :).
There are no plans for Rx right now to move to multiplatform - [https://github.com/ReactiveX/RxKotlin/issues/115](https://github.com/ReactiveX/RxKotlin/issues/115) &amp;#x200B; Coroutines work fine on multiplatform (iOS was only slightly tricky to get working but not too bad)
You might already know Kotlin and not want to learn a lot of Dart Or you want to work on more platforms then iOS and Android (I know flutter is working on support, but its not there yet)
Documentation about Scope Functions was recently published on the official Kotlin reference site, which will hopefully help people better understand when &amp; when not to use them based on guidance from JetBrains.
Volatile doesn't mean that readers are waiting on writes to complete. All it means is that the value in the cache will always be considered to be dirty. So it will always ignore the cached value and fetch it again.
Curious, what's the tricky part of coroutines on iOS?
I guess not tricky, but basically for native, js, and android you have nice plugins for all the coroutine contexts but ios you have [a bit more overhead](https://github.com/Kotlin/kotlinx.coroutines/issues/470) - though from that it looks like it was marked as an enhancement to resolve later so maybe that will be easier 
It depends on your use case and what kinds of APIs you want to use in your app. If you need to access, say, sound hardware you can use Kotlin Native to wrap both the Android and iOS sound APIs in something that is useful if you were to port the desktop or even the browser (with Kotlin JS). It's all about the portability though. If you're familiar with Protobuf/gPRC, I basically envision Kotlin having the potential to be that, but capable of representing your application logic as well as "headers" (which is what proto files really are).
I thought they were called standard functions.
There is a little mistake on the docs... The comment is misplaced there: val result = service.run { port = 8080 query(prepareRequest() + " to port $port") } // this is shorter than the same written with let() function: val letResult = service.let { it.port = 8080 it.query(it.prepareRequest() + " to port ${it.port}") }
Scope functions are one of my favorite things about kotlin. Makes things that were so verbose or impossible in Java very readable and concise.
That table is worth it's weight in gold. ... if I printed it on something heavy.
Good. One of the golden pieces of Kotlin. It's hard to understand at first, but once I got receiver functions understood it all clicks. It's just a beautiful design. And they're zero-cost too (inlined). One thing I don't like is, it gives them a new name "Scope Functions", which might confuse/scare people.
If you're using Flutter for the UI stuff you (unfortunately) need to learn Dart anyway.
The locking example is only mentioned for educational purposes on how deadlocks may occur (which many of them do, because of bad practices) and not best practices for locking, although I am open for suggestions for better deadlock examples! I did clarify the volatile explanation and removed that part, thanks! 
You can only reuse coroutines, there's no RxJava on Kotlin Native.
JavaFX?
Yeah look at TornadoFX. It's javaFX but wrapped in a much nicer API specifically for kotlin. 
JavaFX is a GUI framework for the JVM platform, so you could use this. You could also go for a more OS intrinsic user experience and develop your app with common platform Kotlin that compiles as a platform independent module, although it "expects" UI code which is delivered (plugged in) by different platform dependent Kotlin modules with platform spezialized GUI frameworks for Cocoa, Gtk and so on. Kotlin multiplatform UI usually involves some app-specific mapping in each platform dependent module.
How's the documentation nowadays? I read in a thread 6 months ago that there isn't much documentation and it just assumes you already know the vocabulary from javaFX.
I think it's pretty well documented. I managed to write a dynamic table for monitoring services without javaFX knowledge. Trickiest bit for me was understanding when to use a vbox, or a hbox, etc. See the docs here https://edvin.gitbooks.io/tornadofx-guide/part1/3.%20Components.html
Maven. I personally much prefer the declarative structure of Maven poms and the way you can inherit dependency management and tasks is pretty awesome if you for example work on projects with many microservices. In a previous project we even migrated from Gradle to Maven because of this. 
&gt; the way you can inherit dependency management and tasks I'm not very familiar with Maven but it sounds like the same can be achieved in Gradle using script plugins.
Yeah, that's how we did it in another project. But it's more work to implement, you have to write Groovy, and much less transparent for devs.
For something like that, you might be better off taking an online course. I'm thinking that because you would want both the Android information and the Kotlin information to be very up to date. I'm not recommending these specifically, but here are a couple options: https://www.udemy.com/complete-kotlin-android-developer-course-tutorial/ https://www.udacity.com/course/developing-android-apps-with-kotlin--ud9012
You can also use Kotlin in Gradle
I don't think it's more work in any way... reusability is much better with gradle, because you can ... you know...write your things in a programming language :) And hell, it's better to write groovy than XML, and it should be easier for developers as well. Also, I don't know why you think something is less transparent. If you do it right, you have a ten lines file in gradle and a relative "import" statement. How could this be less transparent then a xml definition that you only understand if you have deep knowledge of maven? &amp;#x200B; For me, it sounds like "too lazy do learn how to use gradle, so maven is better, because we already know most of how maven works". &amp;#x200B;
&gt; For me, it sounds like "too lazy do learn how to use gradle, so maven is better, because we already know most of how maven works". Yeah, I always get that from Gradle fans, even when I explained I used both tools extensively, even wrote Gradle plugins, and just prefer the former. For some reason Gradle fans can't deal with the 'oldfashioned' tool still having more traction. It's totally on you that you make a preference based on extensive experience into the insult that I'm lazy. 
Definitely gradle, I wouldn't go back to Maven ever. You can even use Gradle with the Kotlin DSL if you are a bit brave :)
I know it's possible now with 5 but in the last project we tried to migrate to 5 right after it came out and suddenly our builds were slow as heck without any indication why. That's a problem that is probably solved now, but I'm not on that project anymore. The current client teams decide for themselves. I'm supporting teams with Gradle and Maven. 
I hope to see KotlinQT in the future! (qt Kotlin, qtKotlin, qtK...)
I'm using Maven (and Bazel at work). Gradle seems to be popular with Android devs, but most libraries and multi module repos I've seen use Maven. I really don't understand the aversion to "verbose xml" in this war, you probably spend less than 0.1 percent of your time in a project setting up Maven. I prefer Maven because it's declarative and looks the same no matter what project you're working on. 
I noticed that the article still has this: ``` Volatiles do not help in our scenario, because even though the readers would wait for the writes to finish ``` As for that bad locking example, that's taken from the locking section of the article where it's portrayed in a positive way (it's not from the deadlocks section)
Gradle
Thanks! I removed the example as I think LinkedList would suffice for an example for that section.
Kotlinlang.org specifically recommends [Kotlin for Android Developers](https://antonioleiva.com/kotlin-android-developers-book/) [Android Apprentice](https://www.raywenderlich.com/196563/the-full-kotlin-apprentice-book-is-here) and [Kotlin for Android App Development] (https://kotlinandroidbook.com) seem like they might work for you as well.
&gt;For some reason Gradle fans can't deal with the 'oldfashioned' tool still having more traction. Assumptions ... assumptions everywhere. I don't care if some thing has more traction than something else. It's just that statements like script plugins to be "more work to implement" than ANYTHING you can do to extend a maven build render all your extensive experience you claim to have unbelievable. But up to you when you want to take the blue pill :) &amp;#x200B;
How is Bazel? I've heard good things, but never used it
Kotkin DSL. It's 2019, c'mon
Not as much though was my point. I was able to get UI stuff in dart figured out pretty quickly but I never looked into RxDart, or any sort of networking or serialization libraries so it was a much smaller scope of dart that i learned
Definitely Gradle. * New Kotlin features always come to Gradle first (eg. dead code elimination tool). * Gradle also has dedicated support for Kotlin * The gradle script can now be written in Kotlin Our company used to use Maven for our Kotlin backend but we encountered a bunch of quirks with it so we switched to Gradle and everything is now running smoothly.
There is none yet as far as I know. There are good books on either topic but not both. I would also mention that most books are gonna be dated as Android Architecture and AndroidX are still new. 
I am already doing the Udacity course, but I'm looking for something more comprehensive. I will check the ones from Udemy, but I rather have a book.
Kotlin for Android developers and Kotlin for Android app development look like more oriented to people experienced with Android that want to learn the advantages of Kotlin. Android Apprentice is indeed exactly what I'm looking for, but I only found some mixed opiniones in another reddit thread and It is insabely expensive. (almost 80$ the pdf file)
I would help out, but I'm still a beginner with little production-level code experience. I'll try to study it though and maybe some years forward I'll be able to submit a PR or help with documentation. Really like your library though, one of the youtubers I watch uses it and his testing code is pretty clean.
You can skip maven since: * Android is Gradle Only * Kotlin Multiplatform is Gradle Only * Gradle Kotlin DSL is Gradle only (obviously) Also, you can check [this comparasion](https://gradle.org/maven-vs-gradle/).
Great. As I said it is many hacks packaged in nice package, so much more unpleasent inside.
The intellij plugin is pretty bad, but the tool itself seems nice if you have a monorepo with a lot of different languages (which we do). I'd never use it for personal projects though.
Also from my perspective of someone who wants to contribute, I find that a page with suggested reading related to the project really helps to get a direction. GNU Radio has these ones: [suggested reading](https://wiki.gnuradio.org/index.php/SuggestedReading) and [Reading order](https://wiki.gnuradio.org/index.php/SuggestedReadingOrder).
Price shows as $59.99 for me. Sorry I don't have a cheaper option.
It's a good thing they announced some official docs for it, thanks OP for sharing.
They appliy the VAT taxes after that, I guess that because I'm in Spain. Anyway the recommendation is good, this is the type of book I'm looking for.
Gradle for Spring Boot apps that are written with Kotlin. It would also be easier to start Android development since Gradle is used there as well and Gradle can be written in Kotlin as well.
Maven. It works fine. If I were to start over I'd probably give Gradle a shot, but I have no burning incentive to move.
I don't know if the books are there for 100% kotlin usage yet. I don't even really know of any android books I'd recommend. Android evolves often. I prefer books too, but it's rough in this department. You may have better luck learning android with Java, and then just teaching yourself Kotlin. You can build an android app in Java, and change your code to Kotlin, source file by source file, whenever you have the time, and it's not a terrible experience. The Java/Kotlin interoperability works very well. You may have to open the Android docs to figure out how to translate a couple of lines of code here and there(certain android libraries have slight code differences between Java/Kotlin). But overall, it's not too hard to just learn Kotlin from Kotlin's website, and the android docs.
A matter of taste I would say. I prefer access via "it", because it doesn't open the object's scope. So let is less error-prone than run imo.
Courses are great for start After that, work on your own project, no better way to practice. And one last tip, if you're already fluent with Java, try and learn kotlin.
I've been looking for this extensively. Everyone recommends tonadoFX and JavaFX but they are really bad looking. Like their UI was and graphics were designed in the 90s. You'd be much better off adding html code to your project and making the program work in a local browser window.
Gradle for me, too. I find that once you get used to writing Gradle plugins, it's easy to make it strongly declarative, and frequently much less verbose then Maven XML. IMO, if feel like you need a custom task, just get used to writing plugins in \`buildSrc\` first: [https://guides.gradle.org/writing-gradle-plugins/](https://guides.gradle.org/writing-gradle-plugins/) Once you figure out how to publish and test the plugin logic, you'll hit nirvana. :)
You can just pull in the depedency management plugin and it will use bom files much like Maven.
I think you're recalling the standard library
They've been referred to as scoping functions since they were released, so I guess I missed another name to consider this one as new
I think this is also subjective to how nested using let gets. I think name shadowing leads to just as many issues
I'm not sure you are aware of the fact that you can style a JavaFX app with css. Many tutorials don't show that part, maybe because it is considered trivial or not very interesting. With some styling you can make the app look like any electron/web app if you so wish.
I prefer Maven because of it's (mostly) declarative nature. It's certainly more straight-forward and nicer to be introduced to a Maven project than a Gradle project, probably because of the "Convention over Configuration" policy of Maven along with clearly defined build phases.
I'm very new to programming. Have yet to find anything as easy as VS C\# drag and drop ui.
If you like the way Kotlin is more concise than Java, you'll probably prefer Gradle, as it is way more concise than Maven. That said, I'm not sure I'd bother with Gradle's Kotlin DSL. It's just as confusing as their Groovy DSL, perhaps more so because it looks like Kotlin, but they do things no self respecting Kotlin dev would do (at least last I checked). I'm just using their Groovy DSL.
If you're using Kotlin/Native this is an option: https://github.com/msink/kotlin-libui It uses each platforms native gui.
You can't declare Int and String with lateinit though, can you?
&gt; Is this some kind of lambda expression or higher order function? Yeah!
The docs don't seem to say that they are treated specially.
Since `OnClickListener` is a single-method interface written in Java, Kotlin is smart enough to know it can be replaced with a lambda expression. Check out SAM conversion.
Yes. You used to have to use anonymous classes as function parameters but lamdas are much cleaner looking. 
In Java: setOnClickListener(new OnClickListener() { @Override public void onClick(View view) { } }) In Kotlin: setOnClickListener(object: OnClickListener() { override fun onClick(view : View) { } }) Shorter: setOnClickListener( OnClickListener { }) Even shorter: setOnClickListener({ }) Lifting the lambda out of the function: setOnClickListener { } ^Give or take a few syntax errors
I think there's two things at work here: 1. Yes, you're using a lambda here. As others have noted SAM conversion comes into play for these scenarios. 2. For lambda arguments at the end of a list of parameters, Kotlin allows you to forego the `()` around the lambda argument. You could absolutely write that block as ``` textView.setOnClickListener({ textView.text = input }) ``` But since the click listener is the last (and in this case only) argument being passed to `setOnClickListener`, you can exclude the parens.
Maven. It works very fine, no need to migrate away from it. I like its declarative way. I don't love the XML structure, but as some other commenter said, you don't touch the pom.xml that often. I find it funny how there are always this wave: From ant (imperative) to maven (declarative) to gradle (imperative). Lets see when the new hype (of course again declarative) hits us. 
This is incredible. I knew these existed, but didn't know they could be so powerful. 
This pretty much clarifies it. Will take me a while to learn when I can omit different parenthesis and how to format such cases. I'm still having trouble trying to understand lambdas and their use. Are lambdas the recommended approach and useful to learn sooner, or is it fully possible to get by using objects and declaring methods? Sometimes I see '*this*' being used in code. Other times I see '*it*'. Whats the difference between them?
Thanks. Also what is how does '*super*' work when overriding a function?
Android studio always recommends what can be written as a lamdba. I actually learned it by autocompleting it with the android studio. Higher order functions can be summarized in one sentence: It's a function that takes a function as an argument. It can also return a function. Now all you have to do is learn how to use it. :)
This answer couldn't be better
Any significant "reactive" library is likely waiting on multithreaded coroutines, which is coming at some point, but will take time. You \*can\* use coroutines in native, but they're single threaded. You can suspend the context you're in, but to pass work to a different thread takes more effort. To see an example of a generic coroutine that passes a lambda to run in the background, as well as a \*very limited\* pub/sub architecture that will update the UI from DB changes via SQLDelight, see [https://github.com/touchlab/DroidconKotlin/](https://github.com/touchlab/DroidconKotlin/) The steepest part of the learning curve for a native mobile dev will be threads and state: [https://medium.com/@kpgalligan/kotlin-native-stranger-threads-ep-1-1ccccdfe0c99](https://medium.com/@kpgalligan/kotlin-native-stranger-threads-ep-1-1ccccdfe0c99) Several apps from recognizable names will be coming soon, as will better library support and a more streamlined experience for the iOS side of dev. Everything takes time, but it's happening.
Writing some of your app in Kotlin and some in Dart as a way of not learning too much Dart is super impractical in practice. Learning the Flutter UI model would force you to learn pretty much all of dart, plus you need to hand-marshal your data objects over channels.
Kotlin Native is very powerful. It is just early from a libraries perspective. Flutter had a recent V1, but that's disingenuous, as they've been pushing teams to use it for about 3 years (in and out of Google). You do need to write native UI's with Kotlin, but that's what a lot of teams want. You \*can't\* write native UI's with Flutter. It's a portable UI with it's own "world". That's not better or worse, per say, but different. The Kotlin story, from a library perspective, will be changing dramatically over the next 6-12 months. Full disclosure, I gave the Droidcon SF talk :)
Can't agree more. I tried it a few days ago (for a second time) and had problems to understand it properly. It looks like the devs were high when they were creating the DSL. Groovy is fine for this purpose. 
*Sorry, this won't be an ELI5, since I think other people are covered you there!* `this` and `it` are somewhat tangential. Short version: `this` refers to the current scope, while `it` is something you can use in a lambda that takes a single argument where you are lazy and don't want to provide your own. `setOnClickListener { view -&gt; view.doSomething() }` vs. `setOnClickListener { it.doSomething() }` You can read more about lambda functions featuring `this` and `it` (here)[https://kotlinlang.org/docs/reference/scope-functions.html] It may help to realize that lambdas were only relatively recently introduced into the Java language, certainly long after the Android API started getting written. Without lambdas, the Java solution was just to create an interface with one or more methods in it, and then implement the interface on the fly via an anonymous class. When lambdas were introduced into Java, they were just syntax sugar for creating an interface with a single method in it. ``` // java interface OnClickListener { void onClick(View v) } cancelButton.setOnClickListener(v -&gt; ...); ``` was just a shortcut for ``` cancelButton.setOnClickListener(new OnClickListener() { @Override void onClicked() { ... } } ``` These one-method classes are called SAM types (single abstract method). Kotlin supports real lambdas. "(String) -&gt; Boolean" is actually a type, as valid as "Char" or "List". Kotlin tries to convert SAM Java classes to lambdas when it can, (read more here)[https://kotlinlang.org/docs/reference/java-interop.html#sam-conversions]. But it can't always do that, so sometimes you'll see Kotlin code falling back on the `object : ...` syntax. You should definitely learn more about lambdas. They are a powerful tool in your developer tool-belt. They may seem weird at first but they'll become second nature eventually.
You're asking questions that are a bit all over the place. Have you tried going through the docs yet? It may be more comfortable to learn everything in a step-by-step order rather than learn by trying to drink from a firehose, in case that's what you're doing :) I would [start here](https://kotlinlang.org/docs/reference/basic-syntax.html) and read the following sections * Getting Started * Basics * Classes and Objects * Functions and Lambdas * Other and you can safely skip the rest for now.
Gradle for quick one-offs but Maven for large projects. Gradle definitely chugs and at work we were able to cut our build times down by around 75% when moving to Maven. Shaving off 4-5 minutes on a build was a huge timesaver.
KMongo is pretty neat!
FXML looks interesting. You can style it with CSS. The main reason I want to learn Kotlin over Python is because one of the apps I have in mind needs to be fairly light and well performing, so an embedded browser would negate that.
FXML looks interesting. You can style it with CSS. The main reason I want to learn Kotlin over Python is because one of the apps I have in mind needs to be fairly light and well performing, so an embedded browser would negate that.
&gt; I read in a thread 6 months ago that there isn't much documentation you should read the documentation and decide for yourself 
Is there any Gradle tutorials? I am planing to use Kotlin for backend development. &amp;#x200B; Thanks 
Gradle. Maven is fine as well of course but a lot of the plugins in the Kotlin ecosystem are gradle centric. And then there's the Kotlin DSL for Gradle. It's very clear that maven is the second choice here.
And after using extension: ``` onClick { } ```
I went through a couple of introductory tutorials already. I was asking about the things that I didn't understand or weren't explained well in those tutorials. The good thing about asking here is that I'm getting new info and resources too.
# Gradle Gradle is concise, simple and also (personal opinion alert) Maven kinda sucks with the pom.xml. It just feels counterintuitive and unnatural to me.
Could someone please tell me, what is a kts file. An example is here [https://docs.gradle.org/current/userguide/plugins.html#sec:plugins\_block](https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block) &amp;#x200B;
Alexa build
Yes please. Qt is a pleasure to work with.
I recommend you to take a look at TornadoFx.
SceneBuilder (JavaFX) is a very good tool as well
I've been using [TornadoFX](https://github.com/edvin/tornadofx) for years! I'd suggest taking a look at it, it is awesome!
+1 I have production app in that for financial controlling.
I like it so much that I've decided to write something similar to TornadoFX which is working for multiplatform projects. I've already ported the [databindig part](https://github.com/Hexworks/cobalt/tree/master/cobalt.databinding).
It looks like just a library. So, no IDE Wysiwyg support?
Since it's the javafx of kotlin there should be an UI builder but doesn't come inside the IDE
None that I know of although I never felt the need. I just don't believe in WYSIWYG. If that's what floats your boat you might want to use Eclipse RCP with JFace/SWT. It has Window Builder.
+1 for TornadoFX Did some project apart, it's good.
Thanks, we've clarified that comment.
You can use the same tools for java and kotlin. At work we have swing and JavaFx views. I also recommend TornadoFx, I tried it and it's really nice. However, you could just start with JavaFx alone first.
I too would appreciate some pointers in this direction. I'm old school (Pascal with inline assembly) getting into java but wanting to focus on kotlin. The ecosystem is huge and I have no idea where to start. I find what seems to be newer tutorials and find they aren't new enough so I get errors I know nothing about. A lot of dumped projects because of frustration. Thanks to any that may help.
Very nice! I might adapt this for an in-house talk for some of our skeptical java devs. just a note, i think there are a few typos in the infix function section: ``` for(in in 0 until 100 step 2) println("$i") ``` i'd also consider putting the delegate info at the end, but that's just me:) 
Thanks for pointing that out! 
There are always different ways to do the same thing, its usually experimentation what tells you what you like or works for you People don't like hibernate and switch to JooQ for example, or dont want too much Spring magic and go with microframeworks like Kofu Usually is reading on what are the pros and cons of each option and trying them out
Well, I'm glad to know that I'm not alone :). Good luck to you!
Yes, you can use JavaFX Scene Builder (this creates XML-based pieces which JavaFX or TornadoFX can load) if you want, or just compose UI with code.
Has anyone tried using Kotlin multiplatform projects, and making Mac, Windows and, say Gnome apps? I've found TornadoFX to be pretty easy to monkey with. When I try to make native Mac apps, it's like the gradle plugins never work 100% of the time, etc.
Do you know of any good (complex) and working examples ? I tried every one in this repo https://github.com/thomasnield and not a single one was working...
None that I can share sadly :( I'd suggest reading [the guide](https://edvin.gitbooks.io/tornadofx-guide/). It was enough to learn how it works.
I prefer to learn by looking at examples and modifying it, and these projects had it all, but it seems that's not working this time. Thanks
I just figured some of the stuff in the repo out.. 
Nice 1!
Here's a small project that's intended to be used as a learning tool for Kotlin: https://github.com/dan-rusu-personal/Kotlin-Waterloo-AMaze
Isn't the ui layout just fxml and css? Wouldn't any javafx WYSIWYG tool work?
No, you use the Kotlin DSL which makes WYSIWYG kinda obsolete.
Kotlin DSL?
Yep, take a look [here](https://edvin.gitbooks.io/tornadofx-guide/part1/4.%20Basic%20Controls.html). There is an IDEA plugin for TornadoFX, but I haven't used it so I can't comment on it.
Thanks for posting. I have couple of questions if you have the time to respond. What, in your opinion is a good strategy to bring in kotlin into a java spring boot app (maven)? Also, does it play well with Junit 5 and Mockito - Any other unit test library I should look into? (My experience with Kotlin is just going through some of the koans so far).
In this case is simpler to have one rule that works for all cases, i.e. using curly braces. Terseness is not the same as simplicity
I'm interested in how others do this too. I'll share what I do. One way I discover libraries is by checking what some of the other teams at my other workplace use for their java/scala projects. Alternatively, whatever my requirement is, I make it a rule to first Google for a library that covers the functionality I'm looking for before rolling my own. When I find one, I look at when it had its last release and go straight to the issues tab on github to see what other users are experiencing. If any of the issues aren't blockers for me, I consider it a winner. Other times I'll do comparison search queries like "&lt;Library-name&gt; vs" in Google and see what their search suggestions are. A lot of the times they will suggest other libraries similar to the one I found that are popular.
rewrite it in C89
I found this. https://www.reddit.com/r/java/comments/4xfbej/creating_installer_with_jre/
ExcelsiorJET is amazing. &amp;#x200B; Launch4J is also pretty good.
For Java 8 there's a command line tool called javapackager which generates a exe of your app bundled with an jre. If you need more flexibility you can also uso innosetup's command line tools.
For Java 8 there's a command line tool called javapackager which generates a exe of your app bundled with an jre (in Java 9 and beyond it's jlink I believe). If you need more flexibility you can also uso innosetup's command line tools.
For Java 8 there's a command line tool called javapackager which generates a exe of your app bundled with an jre (in Java 9 and beyond it's jlink I believe). If you need more flexibility you can also uso innosetup's command line tools.
Thanks, I already forwarded it to a coworker of mine whose been on the fence for a while. And sent some claps your way. FYI, minor typo with `a++` instead of `a--`: ``` ║ a++ ║ a.inc() ║ ║ a++ ║ a.dec() ║ ```
On Linux, you can specify dependencies in the package so java will be automatically installed on the user machine. Bundling the JVM is a pretty bad idea on Linux so prefer to use package managers decencies system.
Why do you need a drag and drop UI? It is faster to hand write it. Either way there is SceneBuilder. Make sure to download the newest version from Gluon.
Thanks for pointing that typo! 
I use kotlin everyday at work as an android dev and consider it my favorite language. I recently launched [https://github.com/codeniko/JsonPathLite](https://github.com/codeniko/JsonPathLite) if you're interested in some kotlin usage. I consider it pretty clean but I'm open to suggestions for improvement from those more experienced.
It works very well with Junit 5.
Really nice and comprehensive guide. I think I will give this to new developers at my work place when they'll learn Kotlin. 
I think you're missing an } in your cache object declaration.
I really enjoyed watching [these](https://www.youtube.com/channel/UCFGnQjjr4yL7KpnhAlezLRA) videos and reading the code on github as well.
https://github.com/corda/corda is fairly large
[Kweb](https://docs.kweb.io/en/latest/) can be used to create a local web interface with relative ease.
For Java 9+ there's a similar tool included with the JDK called jlink, but the usage is different.
im forgetting how you reference the view that is clicked in the extension function
Check out GraalVM or the kotlin command line compiler. Both have an option to compile to native.
I almost never write code that will do its thing in isolation, which means most of my code depends on other code. Do you write software in any other way, or how do you unit test your code without mocking?
Works well with mockito if you use https://github.com/nhaarman/mockito-kotlin
https://github.com/mFrankowicz/tornadoFXLearn As a start i think it's good, if someone has something better to share hope they do.
I didn't know scoped functions were inlined! The more you know, I guess!
For a full app, you can look at this [todo app](https://github.com/edvin/todomvc) made by the creator himself, and has a [youtube video](https://youtu.be/DP863ceFT08) to go along with it. I have made a few apps, including a [Kafka GUI](https://github.com/spearskw/kafka-gui) and [my own front end for iMessage on mac](https://github.com/spearskw/iMessage) (which still needs a readme, but you can look at the PRs to get a sense of the project). I'm not an expert though, so take my projects with a big grain of salt.
It seems like I cannot edit the title. Sorry for the typo on the title.
It could represent Java with the lambdas we've had for years now.
&gt;https://github.com/codeniko/JsonPathLite Thanks! It wouldn't be compiling if it's missing a closing brace. I double checked and everything looks good to me. Can you please link me to the line in question where you see an opening brace without a matching closing brace?
I made a very simple app ([Wheelie Backflipper](https://github.com/stuie/wheeliebackflipper)) to flip the mouse scroll direction on Windows 10 via the registry, recently. It's not polished, and not the best example, I bet, but it's small. 
An annotation doesn't mean or do anything on its own. Annotations are given significance by the programs that interpret them. Programs that make use of annotations include the compiler itself, annotation processors like [kapt](https://kotlinlang.org/docs/reference/kapt.html), and libraries like JUnit or Spring which use [reflection](https://kotlinlang.org/docs/reference/reflection.html) to read annotations at runtime. 
I think he means here: ``` // Implement your own cache CacheProvider.setCache(object : Cache { override fun get(path: String): JsonPath? { ... } override fun put(path: String, jsonPath: JsonPath) { ... } ) ``` The Cache object declaration is missing its closing curly brace.
Ahhh in the readme! Yes, you're both right. Good catch, thanks
Yes. But suppose I give my annotation the RUNTIME retention. Now I’m trying to write that program that is trying to make use of those annotations. That’s the context for my question ^. I need to access the annotations for the things mentioned above.
Then you use reflection to access the annotations.
Yes I understand that. I’m wondering what the statements/syntax would be for that. After looking online I get how to do it if you’ve applied the annotation to the class. I can’t find how to do it if you’ve applied the annotation to a constant/variable
I finished this tutorial from Brian (Let's Build that App): https://www.youtube.com/playlist?list=PL0dzCUj1L5JE-jiBHjxlmXEkQkum_M3R- He's a really good teacher and goes step by step. Besides that, I heard that the book Kotlin in Action is great for starters: https://www.manning.com/books/kotlin-in-action I'm thinking about buying it soon.
thanks!
I’ve read Kotlin in Action and it’s very good. It will teach you idiomatic Kotlin very well.
&gt;Kotlin in Action is this the one? [https://www.manning.com/books/kotlin-in-action](https://www.manning.com/books/kotlin-in-action)
thanks!
The kotlin compiler generates accessor functions which are what actually receive the annotation. So for 'val foo' look for your annotation on the 'getFoo()' method.
Do udacity Android course (it’s in Kotlin) and it’s not outdated as most courses + it’s free
Does this help you? https://stackoverflow.com/questions/42194682/how-to-get-annotations-of-a-kotlin-property-from-java?rq=1
I figured it out, thank you! :)
thanks!
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/coding] [Options for managing derived attributes in Kotlin](https://www.reddit.com/r/coding/comments/b26uh5/options_for_managing_derived_attributes_in_kotlin/) - [/r/programming] [Options for managing derived attributes in Kotlin](https://www.reddit.com/r/programming/comments/b26toi/options_for_managing_derived_attributes_in_kotlin/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I created a Kotlin course that I've taught at a couple of big companies. There's a repo with exercises here: [https://github.com/AOrobator/IntroToKotlin](https://github.com/AOrobator/IntroToKotlin) There's an exercises branch and a master branch with all the solutions.
There isn't really anything as opinionated and "all-inclusive" as rails for Kotlin. Someone started working on a project called [Kales](https://github.com/felipecsl/kales), but it's very early stage.
Yeah I feel you. But even using Kotlin + KTOR, or Kotlin + Spring boot? 
I’m so jealous, your company isn’t in Seattle is it? 
Ktor is very bare bones. Think of it more like Sinatra for Ruby, but probably even less than that. I’ve found that Jooby works nicely with Kotlin, but even that isn’t going to be as smooth an experience as RoR or Django. RoR and Django have years of devs making it easy to make a good project and ironing out all the rough edges. I think Kotlin, static typing, etc are great, but you’ll need to be willing to endure some rough edges. For example, RoR and Django are nicely setup for a general web app where you’ll want a database, forms, validation, cookies/sessions, etc. In the Java (and Kotlin) world, it’s more “choose your libraries”. Even something like cross site scripting often isn’t something just built in. How do you pass validation errors back to a form? Well, Django and RoR have sorted that all out for you and you don’t need to think about it. Kotlin is great, but you’re going to have to be willing to figure a lot more out (often by reading the code, not googling) and having to write more code to handle things that are built-ins with RoR. I can elaborate more when I’m not on my phone. 
I'm primarily a php developer but I've been building an API using Kotlin, vert.x and Postgres. It's a thing of beauty. 
Wow first off thanks for typing so much from your phone! I think I have accepted that rails lends itself way more to web dev right out of the box. Also hear you on the adding libraries, and really interesting you bring up CSRF as I know rails has this just baked in. Maybe i'm naive, but I think to be positive this represents a good opportunity to understand these core web app functionalities better, as rails just handled it seamlessly. The danger there being that you begin to think this is just the way it works rather than knowing everything behind it and it just making your life easier. But at the end of the day, after a year of Kotlin full time server side, I would be more familiar with libraries that I could technically add quickly to a new project to explore ideas on my own, no? Really interested to hear more and thanks again for the reply ;)
Nope :) Sorry!
cool! What kind of API?
ktor + exposed! :) it's a joy to work with
My company is using Kotlin with Spring Boot and it's working pretty nice, you should give it a try. Integration is not perfect (ConfigurationProperties and data classes are quite wonky) but Spring is very mature and battle tested what you can't tell about Kotlin specific frameworks.
What about Vert.x?
Basically you want a lock on your data (string) that says "you must acquire this lock before touching it" and then you can have the writer thread lock it, change it, and then unlock (such that the reader thread sees nothing between lock and unlock). This lock can be a mutex/semaphore or it can can be a more complex concurrency structure. Alternatively you can structure your program to pass messages when it comes to making changes concurrently (Google CSP concurrency). 
I don't know RoR but we're using kotlin to do our back end, and as we wanted a framework that is mature, will last for a while, does many things and integrates with everything else we use Spring Boot: it's going very well. I've used ktor for some little experiments using kscript and that works well too. I guess find out which frameworks your kotlin teams use?
You can look into the @synchronized annotation and only read/write the variable through getter/setter functions marked with it. Or play with the @volatile annotation.
In my company which is quite big company we introduced Kotlin into an existing project (Java 8 and Spring Boot 2) actually it's going really good. Kotlin makes it very easy to go faster 
If I were you, I'd try to have one place own the string, and perhaps use [channels](https://kotlinlang.org/docs/reference/coroutines/channels.html) to communicate its state. Try Googling "actor concurrency". Having one thread responsible for computing and then report some final state is kind of what Android's [AsyncTask](https://developer.android.com/reference/android/os/AsyncTask) or Swing's [SwingWorker](https://docs.oracle.com/javase/tutorial/uiswing/concurrency/worker.html) do, if you want to get your head around some concrete examples. Multithreading is a topic that quickly gets complex, and I think less than 10% (and that estimate may be way too high) of programmers even at really great companies understand how to write multithreaded code that won't explode in a ball of fiery, tangled fury a few years down the line. When you find yourself trying to solve a multithreading problem my slapping a synchronized block around it, there's a great chance you're setting yourself up for trouble when your code scales up. One of the best books I've read on the topic is [Java Concurrency in Practice](https://www.amazon.com/dp/0321349601). I also improved my multithreading knowledge by playing around with Rust, as it uses a very novel system where the language prevents you from making lots of basic threading mistakes by throwing errors *at compile time*! Sorry, I suspect you were looking for a quick answer, and I just opened a bunch of huge doors instead... but writing excellent multithreaded code is a huge topic :) P.S. I'm not sure I'd consider myself in that group of 10% I alluded to earlier.
Simple and well explained, great article! Caught a small typo in it: &gt;what if the valued depends
You can use AtomicReference for thread-safe updates of your string. Strings themselves are immutable, so it should work properly.
I think if you are passing a Continuation there's a problem. Use `suspend fun foo(url: URL): Document { ... }`. Inside, use `suspendCoroutine` and use an asynchronous form of `Fuel.get` if you can. If you can't, use `withContext(Dispatchers.IO) { ... }`.
&gt;Maybe i'm naive, but I think to be positive this represents a good opportunity to understand these core web app functionalities better If you're looking to understand things more, trying to dive into lower level stuff can be great. However, that's different from wanting to accomplish something. Sometimes understanding things can be helpful. Sometimes it's just fun knowledge to have. Examples: I've written JAX-RS MessageBodyReaders/MessageBodyWriters. They allow you to define how responses get read or written in JAX-RS applications. It was interesting and let me create a reader for form data that mapped to Java POJOs rather than a multi-valued map and write out responses for a custom template engine. However, if I were looking to make an actual product, I probably would have been better off using libraries that existed. In Jooby, I've dived into how it handles argument binding and hacked together code so that it would treat a Kotlin nullable type the same way it would treat Java Optionals. Again, this really wasn't delivering a product so much as dealing with rough edges. Many of the things you'll learn aren't core web app functionalities. You'll basically be learning how another framework operates. "Lower level" often doesn't really expose how something actually works and just exposes different interfaces. For example, in Rails, you'd create a `PostsController` and you'd do something like `resources :posts` in your routes file and it would automatically hook up a bunch of routes to various methods in the `PostsController`. Ktor would have you define `get("/") { your code here }` and `get("/{id}") { more code }` to "manually" set up the routes, but you're really no closer to understanding how anything really works. Like, with Rails, the `resources` call makes more than one route, but that's the "magic" there. You haven't looked at what the HTTP request that comes in looks like in either case and you haven't solved how to route a request in either case - you've used code that does that for you. Similarly, with Rails, when you validate a form, it'll populate a map of errors and its form helpers will display those errors. This isn't hard to do without that. Just create your own map and pass it to a template and then check after each field for the errors and display them. Rails just has a nice, built-in way of handling a reasonably common pattern. It'll be more raw without that, but it doesn't get you down to how web apps work. &gt; But at the end of the day, after a year of Kotlin full time server side, I would be more familiar with libraries that I could technically add quickly to a new project to explore ideas on my own, no? Yes and no. You'll start knowing libraries to do some of the things that Rails has built-in, certainly. You'll spend time figuring out how to query a database and probably try Jdbi and other tools. You'll try various templating engines. However, I don't think that will really help you push your own ideas forward unless they're quite specific ideas about how web apps should be developed rather than what the web app should do. I think part of it is that a lot of the libraries can be less mature or less broad in scope. Take Jdbi as an example. I think it's a great library, but it doesn't relational mappings and requires you to write the SQL yourself. That can certainly be great, but then sometimes you want a Blog object that has many posts. You'll see alternatives like Requery which is broader, but is basically the project of one person. Does that get you libraries that you can add quickly? Yes and no. You know a bunch of libraries, but you might not have something that fits what you're looking for - or you might. -- All that said, I think learning another language and other ways of doing things can be hugely beneficial - if you're going in with the knowledge that it's not going to give you some magic way of making apps. I think static typing, null-safety, and many other things can give you a better understanding of software and the Java and Kotlin ecosystems have some great ideas in them. Heck, functional programming has a lot to learn from even if you're using a language that isn't purely functional. However, you're likely to have a much harder time making apps in Kotlin right now. A lot of the Java (and by extension Kotlin) ecosystem hasn't been aimed at individual developers or small teams the way that Rails and Django have been. You want migrations? You probably need another tool like flyway or liquibase. Want a template engine? There are loads. Want to talk to your database, there are a bunch of solutions all with different aims. Heck, you can even choose from multiple build systems. Many of these things are good when you have a large team and lots of pre-existing stuff. I think you should learn Kotlin for web dev. However, Rails will get you to a working web app a lot faster and that isn't likely to change in the short or medium term. **However, Kotlin can teach you a lot about immutability, non-nullable types, static typing, and many other extremely useful things.** Even when you use other languages, these ideas can help you create better programs. Just don't get too discouraged when you hit road-blocks and recognize that some things might not be implemented. Rails is really nice because it makes it really easy to connect with your database, deal with forms and errors, and many other common patterns without having to spend a lot of time hooking things together (sometimes things that don't quite fit together) and worrying about all sorts of little things. Again, this is more about whether you'll think of it as a learning experience or something to get something done (either today or a year from now). I think one of the best ways to learn is wanting to do something that doesn't yet exist and trying to make it exist. Kotlin (and Java) make it so easy to click through code and read what it does. I think this is the big area where Kotlin will help you. For any method, you can click through and see its implementation and see other methods that might be useful. Reading code (and being in a language like Kotlin that I believe makes it easier to read code) is hugely valuable because it means you feel more comfortable adding things. One of the things I love most about using a static language is the code navigation. -- If you really want to learn how things work, HTTP can be quite simple and text-based. GET / HTTP/1.1 Host: www.example.com That's literally what your Rails or other app sees and then figures out how to route and such. The response it writes back is similarly simple.
thanks!
This is an amazing answer, thank you for putting in the effort !
While they might be nice to work with, they're nothing at all like RoR. When using RoR it feels like the app is writing itself. /u/commentsOnPizza gave a great answer in another thread: https://www.reddit.com/r/Kotlin/comments/b28yqg/switching_from_rubyror_to_kotlin_server_side/eisc4pq/
I don't have actual numbers, but Coroutines use Threads behind the scenes, but in well optimized way. I hope this can help
Quoting [this post](https://stackoverflow.com/questions/50230466/kotlin-withcontext-vs-async-await/50231191#50231191): &gt;I'd like to dispel this myth of "too many coroutines" being a problem by quantifying their actual cost &gt; &gt;\[...\] &gt; &gt;I benchmarked this code and concluded that it allocates 140 bytes and takes 100 nanoseconds to complete. So that's how lightweight a coroutine is.
I would like to cite this post: [https://stackoverflow.com/questions/46864623/which-of-coroutines-goroutines-and-kotlin-coroutines-are-faster](https://stackoverflow.com/questions/46864623/which-of-coroutines-goroutines-and-kotlin-coroutines-are-faster) \&gt;Kotlin coroutines require less memory per simple instance than Go goroutines. A simple coroutine in Kotlin occupies only a few dozen bytes of heap memory, while a Go goroutine starts with 4KiB of stack space.
Of course they use Threads, but the point of Coroutines being lightweight is that there is a fixed thread pool and Kotlin can execute thousands of Coroutines on them “at the same time” via smart context switching at the points where a Coroutine suspends or enter a blocking state in other ways. The thing is the Coroutine framework uses these moments to push another Coroutine in queue to the execution thread until that Coroutine also reaches such point or finishes. I don’t know the actual internals of Kotlin Coroutines, it’s just my understanding of how it works based on presentations by Roman Elizarov.
Thanks for the response! That's helpful, in a way. If we're anything, we're a polyglot shop -- the utility I'm looking to replace is basically some Bash stuff with PHP wrappers -- so I don't have another team (or even developer, really) to talk to about things like this. As you can imagine, that complicates things a bit :).
Can you explain to me how much then it will cost to run a single non blocking coroutine outside the main thread? 
In theory, to have a thread outside the main thread, it would have to allocate one jvm thread, which is that 2-4 mb, probably. But, once that's allocated, that's it, it's always available to run practically as many coroutines as you care to stuff into it. So yes. There is some near-constant overhead, but there's always going to be. 
Great, so what would be the cost if you used thread pool, lets assume it has fixed size of 1?
??? Not enough information to provide a meaningful answer. The scenario I described above is exactly a thread pool with size 1. Do you mean use exactly one coroutine? Because thats not the same as exactly one thread. Exactly one coroutine in exactly one thread is the worst case of kotlin coroutines, if that's what you're trying to get at?
*OwO, what's this? * It's your **9th Cakeday** ephemient! ^(hug)
The question was what is the cost of the coroutines compared to jvm threads, and to be fair you should compair the equivalent scenario, for example running 5 coroutines (as an example it reads a file) on a single context ( which use a thread pool ) would use the same memory as running the same operation over a thread pool (executer) doing the same. So in the example above, would they cost the same?
Running 5 coroutines is cheaper than running 5 threads. Reusing a single thread executor 5 times is *not* equivalent, because in coroutines the computations get interleaved (other computations are run during the IO waits) , whereas in the executor as a thread pool scenario they are executed sequentially (IO waits block the executor's thread), in the order you start them. The memory requirements would be very similar (2-4 mb for the thread, plus a handful of reified functions and some bookkeeping), but the effects aren't. Achieving the equivalent interleaving effect in vanilla Java really does require that many threads, or else a specific library. After all, kotlin coroutines are just a library as well, with some special syntactic support. 
We are on the same line,👍🏼👍🏼👍🏼
Coroutines are a clever way of serializing the call stack on the heap, using compiler-generated JVM classes so that the thread can be used for the execution of other things instead of having to block it. Basically, every function you call which has been marked with `suspend` can pause itself by instantiating a coroutine object for that function (which is a special class generated for that function). Now if you have a call stack that is 100 `suspend` calls deep (unlikely but possible), and then suspend, you will get 100 of those coroutine objects. When the call stack gets so deep that it starts to get near a `StackOverflowError`, you can safely assume that your coroutines take up much more memory when paused than the normal JVM stack does due to the inefficiencies of storing everything as objects. But in practice this is probably rare. The size of those coroutine objects depends on the number of elements on the stack since a coroutine needs to be able to recover them. So the answer is: it depends. TLDR; it depends on how deep you make the call stack
Thank you so much for such an in-depth answer! I actually shared it with my work colleagues, so thank you. This really helped. I just started working in Kotlin today during our mini hack days to try and understand it better and am actually enjoying things so far. Again, I can't thank you enough for putting so much time and effort into writing that post. I have re-read it multiple times and book marked it to come back to. 
I feel you man, I used to do a lot of Grails development and it was pretty simple. I have not seen anything that simple in Kotlin yet. I think its probably possible to copy most of the syntax through liberal use of extension functions and infixes on top of something like ktor, but I have not seen anyone get there yet.
Edvin has a ton of videos on his YouTube channel that helped me immensely. Look up 'Edvin Syse'!
Yup! Definitely inlined. Scope functions can easily be used in some very complicated nested scenario, the performance would be terrible if they're not inlined...
Just got bitten by coroutines not being stack-safe just today -.- We'll need to implement a trampoline and see how to insert it somewhere.
 Usually look for a tutorial where someone else has used it. If there are a few, then you know more people use it. For your immediate problem, you may be able to get away with just using the built in Java ImageIO stuff. I haven't run this yet, but something like this: fun main(){ val inputDir = File("/inputDir") val outputDir = File("/outputDir") inputDir.listFiles().forEach { ImageIO.write( ImageIO.read(it), "jpg", File(outputDir, it.name.split('.').first() + ".jpg" ) ) } } 
Kotlin Native has a long way to go for keeping up with JVM counterparts.
A nice summary, although ‘age’ grates a bit after your FP posts! It might be worth mentioning that all the properties are actually accessed via a function call, whether pre-initialised or computed.
I'd argue, we're looking at native mobile changing a lot over the next few years. With Google and Apple treating their app stores a walled gardens that are milked for revenue, it is harder than ever to get your native app promoted. The cost of having to have 3 separate UI teams (lets not forget about the most important one: web) is insanely high. For the vast majority of small startups, it is a better use of their time to focus on web and progressive web apps. Together with wasm, there's a role there for Kotlin native as well. Lately most 'native' apps are anything but. React native is popular because it allows people to re-purpose web code that they need to write anyway. Many so-called native apps include web views where the vast majority of the action is. Also, looking the same as everything else out there is not necessarily a great idea. Often the whole point of application design is a unique look and feel + branding. Another shift in the market is Apple going after the high end with the latest iphones that are priced such that many people are opting for cheap Android. IOS apps are still dominant but if you want to serve your app to billions, Android is your primary platform. Android however has the issue of fragmentation where it takes years to roll out new platforms and getting meaningful traction. E.g. Android Pie is a tiny percentage of the overall market. Also, there are still other platforms to consider like ChromeOS, gaming consoles, TVS, etc. Add VR and AR to the mix and you are looking at UI requirements that are beyond what can be done with current UI frameworks for native or web. What native is and should be is in any case mostly aspirational these days. Web/WASM is set to revolutionize this space over the next few years. Kotlin definitely has a role to play there though I expect Google to be moving away from JVM based implementations; so Kotlin native is an obvious choice as something that is already familiar to Android developers. I would argue, it's primary competitors are Typescript, Rust and C#. Also Apple could reposition Swift / objective c to be part of this new ecosystem as they have been early adopters off llvm.
I second Kotlin in Action, but if you are looking at building apps, I'd take a look at Flutter first.
 [Web/WASM iS sEt To rEvOlUtIoNiZe ThIs SpAcE oVeR tHe nExT fEw YeArS.](https://i.imgur.com/rhqOu2B.png) 
thanks!
At the depth of 100 calls, it's some 14K. Relative proportions do matter. To reach the typical JVM native stack size of 2 MB, you'll need a depth of about 14,000 calls, which is completely unrealistic.
[Kweb](https://docs.kweb.io/) might be worth taking a look at. It makes it super-easy to build rich websites in Kotlin. (Disclaimer: I'm Kweb's author)
You could build a web-based GUI using [Kweb](https://docs.kweb.io/).
If you want the second thread to see A until B is actually written in the memory by the first thread, then you don't have to change anything. This is the default behaviour. Solutions proposed by the others would ensure that your second thread won't see A, as soon as the first thread starts writing. Your request is kinda strange, because this behaviour is almost never desired. This is probably what confused the others. Do you still want the second thread to be notified about the change from A to B, even though it read A the first time? In that case channels are your fried. You can make the first thread own the value and send all updates to it via a channel that the other thread can listen to.
How are you planning on calling that kotlinc? I guess what I am asking is does your current programming environment include a build tool? My recommendation is that you should try using Gradle for a build system. It will download dependencies like Kotlin for you and compile your code into a library or application. Its nice because you can just bump a version number and you will automatically get the newest versions, and there are a lot of tools built for it. If you import your project into most IDEs they will automatically pull sources for you. There is a bit of a tutorial here: https://guides.gradle.org/building-kotlin-jvm-libraries/
If I choose to adopt Kotlin I would absolutely integrate it with gradle, but right now this is purely for personal edification. As I mentioned in my OP, I'm simply trying to get the core compiler up and running; why would I need to go through this process simply to compile a "hello, world" app? I followed the instructions on [https://kotlinlang.org/docs/tutorials/command-line.html](https://kotlinlang.org/docs/tutorials/command-line.html) and downloaded what should be (and certainly appears to be) a turnkey compiler and I'm simply trying to bootstrap it.
I love the article and it actually was very resourceful. But I can't help think this just makes Kotlin harder to read. Maybe it's just the verbosity of Java that I kind of liked but some of these functions seem better to be just if statements or apart of the constructor/setter of some kind. Anyone get that? Maybe just need more time with it.
It probably works from the command line, but I have never tried to run it like that. Does that "kotlin-compiler.jar" file exist somewhere in your bin folder?
I did try copying the contents of the ../lib dir into the ../bin directory to see if that helped but still the same message. I don't know if the problem is with the relative import path but the kotlin-compiler.jar (and 48 other jars) are in the lib directory and seem to be intact (ie, I can unzip them and view their contents).
Something is wrong with your path settings and/or the directory that you extracted the compiler into. I've just downloaded the kotlin command line compiler and tried it myself, and it works fine. (Normally, I'm using IntelliJ IDEA as a development environment) What do you have your PATH set to exactly? Don't forget to include the jdk's bin folder as well. My setup is: PATH=.......................;c:\\zulu8\\bin;c:\\dev\\kotlin\\bin (c:\\zulu8 contains my jdk of choice, azul's zulu openjdk build rather than Oracle's but that shouldn't matter) I extracted the contents of the kotlinc folder in that zipfile into the c:\\dev\\kotlin folder and it looks like this: C:\\Users\\irmen&gt;dir c:\\dev\\kotlin /b bin build.txt lib license When I now type 'kotlinc' it starts up the compiler in REPL mode just fine. &amp;#x200B;
Medium is blocking me so I can't read this. I hate medium from the bottom of my heart.
Thank you. As mentioned in my OP I did add the \\bin directory to my path so that wasn't the problem, but I did solve the problem. I use a command line alternative (Take Command/TCC from jpsoft) which I've been using for more than a decade without issue, but apparently something is happening here. When I launched a vanilla [command.com](https://command.com) prompt with the exact same path everything worked just fine. Thanks to both of you for your assistance!!! # When you have eliminated the impossible, whatever remains, however improbable, must be the truth..
Glad you got it to work. I ditched tcc a couple of years ago for similar reasons (and simply, to be honest, because I'm not using windows any more to do development on -- I've shifted to Linux and liking that a lot better. Using windows only for games and testing the crossplatform stuff I made from time to time)
KN is the option to share code not obligation. It's not competing with JVM
What does the package manager look like for Kotlin native? I get that JVM Kotlin can leverage Maven Central, Clojars, and so on, but what about native?
Gradle
This looks like a fun project, thanks for sharing it. Another way I think the Kotlin DSL could shine would be with code generation. If there were a tool to consume a GraphQL schema and output builders specific to it, that might allow for an even more fluent developer experience. I haven't looked into this idea yet, so I'm not sure how feasible it is or if an existing project is already tackling it.
I started on a Kotlin code generator for Apollo models: https://github.com/tadfisher/apollo-compiler-kotlin It currently parses GraphQL schemas using ANTLR and generates an IR. The translation from IR to Kotlin models is in progress. The remaining piece then is to wire the backend to the frontend.
I'm way out of my league with this project (pretty new to Kotlin), but I played around with some of the DSL that I believe is possible and I think it is a really exciting prospect. I might try diving into your project some to try to understand what it is doing as a thought experiment.
Exercism is a very effective way to get some practise in Kotlin. Have a look at the site exercism.io
This idea is stupid, I love it.
Write one, should be quite easy to build. Of you don't I will, love the idea!
I'll work on it asap.
Please do. My current solution is to bind macros to all my IDEA hotkeys, but it keeps breaking on every update
FYI, if you haven't seen this yet, here is a repository from a talk with that drumroll: [https://github.com/angryziber/kotlin-puzzlers](https://github.com/angryziber/kotlin-puzzlers)
Yep it was this conference.
My requirements for a library rise with its complexity and my dependency on it. I usually look at: * activity -&gt; latest commits, releases, issues etc. * maturity -&gt; There're a couple of projects without recent activity but with good test coverage and documentation. * contributors -&gt; Will the maintainer abandon project in the long-term? Libraries that are maintained and used in a commercial project are a good bet. An additional abstraction layer for a library with an uncertain future is also something worth to consider. 
That seems really a cool project, thanks for sharing! very exciting!
Intellij is the single greatest IDE ever, I love it so much.
Off the top of my head: 1) "Green threads" vs "System threads", i.e. they are way more lightweight 2) They allow you to write asynchronous code in a way that looks and feels synchronise. It's more than just syntax sugar, as it actually removes some of the boilerplate around setting up nested callbacks. The keyword "suspend" even acts as a nice API marker that says, "Hey, FYI, this function is probably going to do some serious work. Call it carefully". If you've never read about async / await syntax in other languages, check it out because coroutines should have all the same advantages.
They become useful as an alternative to asynchronous future/reactive-streams/callback- based API:s. This happens in Android development, and in microservices environments where a single process may be waiting on many hundreds/thousands of outgoing concurrent http calls. They are related to, but not dependent on thread pools. You could in theory imagine a world where you would have a single system thread in an event loop (Javascript-style) but would want to program as-if it was using multiple concurrent "virtual threads" (aka. Coroutines). For comparable, but not identical, technologies, see async/await in javascript or (more closely related) goroutines in golang.
The big draw for me is that you can write asynchronous code paths the same way you'd write the equivalent synchronous code path. &amp;#x200B; On Java 8, without coroutines, you'd be stuck with some potentially nasty CompletableFuture callback/chaining nightmare.
I think I know what it should play when it [completes](https://www.youtube.com/watch?v=QDUv_8Dw-Mw)...
Not much benefit if you don't do async stuff. Honestly, if you have one system thread per task, some thread pools and CountdownLatches are pretty easy. But as soon as you want to use async libraries, you quickly get into CompletableFuture hell, which coroutines are the answer to.
Nothing like a 20 minute drum roll! ...I really need to upgrade my machine.
Can you do this instead? ``` class Tests { @Test fun myTest() = runBlocking { ... } } ```
[there you go](https://www.reddit.com/r/Kotlin/comments/b3gh7e/drumroll_plugin_is_here/), I need testers!
[A crude implementation](https://www.reddit.com/r/Kotlin/comments/b3gh7e/drumroll_plugin_is_here/). I need testers!
[A crude implementation](https://www.reddit.com/r/Kotlin/comments/b3gh7e/drumroll_plugin_is_here/). I need testers!
[](/kstarlightwut)The absolute madlad.
Yes, but it would be a lot nicer to just decorate the function.
And the sad trombone for repeatedly failing tests.
Done and done.
Seems very useful.
I really wouldn't recommend Android dev if you can't read Java (which shouldn't be difficult since you know Kotlin). To answer your question though, you should not access a view from an outside activity. A very simple and memory safe way to do this is to pass a message (called an Intent) and have the other activity open it and update the text view. 
Accessing one activity's views from another activity is a terrible idea
Coroutines are much more scalable than threads when most of the threads wait on IO (which is 99% of use-cases)
You could store the value using LiveData in a ViewModel. Activity B can pass in a new value and since Activity A said it wanted to observe any updates, it will be notified of any changes. You can update your TextView in the same A where the TextView lives. 
Sure, and when you have a million threads that's worth looking into. 😁
Hmm, I'm not sure if you're being sarcastic or defensive. Last time I did a test, I found a significant difference with just several hundred threads. Thread scheduling and extreme context switching can have quite a bit of overhead. And then there's the extra memory overhead of threads as well. 
By the gods, he really did it
No, you're totally right. You _could_ have a million threads, but 4 + epoll is always going to be better. I'm just used to one thread equaling 1 db connection, if not on my service, then the one I'm talking to. So even several hundred concurrent connections is out of the question, and coroutines are more about convenience than performance.
@Volatile annotation on the variable
This isn't the default behaviour at least per the spec. Thread #2 can read "AAAAAAAA" from the variable even after thread #1 has written "BBBBBBBB" to it.
Not really, but it's &gt; fun stuff &amp;#x200B;
 When it comes to Android app development, a major part of the developers choose Java. This can be explained by the fact that Android itself was written in Java. Java is an object-oriented programming language used for almost 20 years. It was developed by Sun Microsystems which is now the property of Oracle. Nowadays, it is considered to be the second most active language on GitHub. ### Pros: * Has a large and well-versed community, therefore – a number of great educational materials * Relatively simple and clear, which makes it easy to master * A language with a lot of features, regularly updated and open-source * Mostly used for Android, but works perfectly for cross-platform development * Has relatively high development speed * Applications created by means of Java are more lightweight than those that were made with the help of Kotlin * Has checked exceptions that improve error detecting and solving Kotlin is considered as Java’s alternative, which was initially created to add more functions to Java and solve the most crucial problems. Like Java, Kotlin has object-oriented features but is not limited to them, since it also has functional ones. The main purposes of this language are to ensure tooling support, interoperability, security, and legibility. It is matched with Java easily, so developers won’t have to learn it from the ground up if they already know Java. As for Java, it is used for Android app and desktop development. ### Pros: * Has user-friendly and understandable coding norms * Divides large apps into smaller layers and works faster and more efficiently with them * Doesn’t require any variable data type specifications unlike Java * Uses a lot of function types and specialized language structures like lambda expressions * Allows developers to create extension functions easily, which are not available in Java * Provides a very simple and almost automated way of creating data classes I created a comparison table Java vs Kotlin. You can check it in my article - [https://gravum.com/software-development/java-vs-kotlin-what-are-the-key-differences-between-them/](https://gravum.com/software-development/java-vs-kotlin-what-are-the-key-differences-between-them/)
Ideas are dime a dozen, execution is what matters.
N i c e
Does it also work with maven builds or test executions?
Anywhere we can file a bug report?
It works for tests. For gradle/maven tasks refer to [this issue](https://github.com/mhashim6/-drumroll/issues/3)
That's well deserved 
Keep in mind null-safety is built into the Kotlin type system, which is where the requirement to assign a variable instead of leaving it uninitialized comes from. var str // Do a bunch of stuff here str = null How does the compiler know the inferred type of str here? Hell, let’s specify the type to alleviate that: var str: String /// Do a bunch of stuff here str = null Oops, str isn’t a nullable type - but the compiler will yell at you at least. Crap, what if this happens: var str: String // Do a bunch of stuff crashesOnNull(str) // more stuff var str = “hello” Well shit, we just told the compiler it wasn’t null - but we managed to violate that anyway because we didn’t initialize it with a non-null value before use! The compiler certainly isn’t going to be able to sanely check that it wasn’t set, so we just thwarted the entire point of the nullable vs non-nullable types! 99% of the time the reason you want to use late initialization of variables is for conditional logic, Kotlin handles this by making conditions statements that return a value: var str = if(myBool) { “True” } else { “False” } The other time is when you are using some framework that uses reflection to modify fields, there is ONE escape hatch in the system that won’t stop you from using uninitialized variables - but it will tell you instead of throwing a generic NPE class MyClass() { lateinit var str: String fun lookNoHands() { // Throws if str was never set print(str.length) } } But remember, this is an escape hatch for compatibility - you should strive to not use it.
Can't find it in the plugin marketplace for some reason, any advice?
That's because it's still in alpha state, you'd have to download the plugin jar from the web page.
Ahhh, thanks, didn't notice that.
It is sad when a project loses its contributor in this way. 
Can this subreddit please stop responding to every Maven question with “why not Gradle?” People don’t ask how to do things with a build system just to get told “use the other thing instead”.
It's perfectly acceptable to suggest a superior solution if it exists. For Java it's debatable which is best but for Kotlin Gradle is clearly the better tool. I used both Maven and Gradle for several years each and I simply choose the best tool for the job rather than clinging to any specific technology.
https://youtrack.jetbrains.com/issue/KT-22228
"Under the hood" coroutines don't have any particular thread pool or execution strategy associated with them. You're looking at stuff in kotlinx.coroutines which is just one way of using coroutines. &amp;#x200B; At the core language level what coroutines give you is the ability to write sequential code and have it transformed to continuation passing style. This results in cleaner and more straightforward code than manually passing/chaining callbacks. The biggest real world application for this is non-blocking concurrency which is why people are always comparing threads and coroutines. The virtues of non-blocking concurrency vs blocking concurrency are a separate issue that has already been written about extensively..
This is so lame ... 
This is so sad. Languages are not political causes, we don't need to support only one. Just because you have passion for one thing doesn't mean you can't have passion for another.
Here's the Groovy cross-post if people are interested. Comments are a similar vein to those here. Sadness on both sides, as there should be. Because there are no sides. One of our programming brethren got attacked by some of his peers. https://melix.github.io/blog/2019/03/goodbye-groovy.html
I suggest reading the email thread on the Groovy Dev mailing list for context. I didn't see any attack or accusation from other Groovy team developers, only mild criticism from other mailing list subscribers (e.g. MG). I seemed to me that Cedric expected pushback and started the conversation on the defensive, and argued against a straw man of his own creation. https://lists.apache.org/thread.html/d498a86a7f8147fe5dc6d21d015122b3a5befa04f12ccd497b613048@%3Cdev.groovy.apache.org%3E
That MG post is hard to read. A bit too much kool aid.
Not sure Maybe.
interesting read, sad to hear it's not ready yet. Thanks for sharing the experiences! 
Kapt
This looks really awesome! I got really hyped while reading through it! Is there a server that hosts the demo todo-list app to check out? 
I don't currently have the todo app up on a server, would that make a difference in giving people confidence in Kweb?
Yeah I defenitly think so! It would at least satisfy my curiousity! But I will definitely check it out anyways. 
Hey, fablue, just a quick heads-up: **curiousity** is actually spelled **curiosity**. You can remember it by **-os- in the middle**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
delete
/u/sanity what about article in docs which compare React SSR and Kweb? And high level architecture overview. Also, I need two clicks to see actual code when I'm navigating from [https://kweb.io/](https://kweb.io/) (not big issue, but I was looking at Kweb yesterday, and found this little bit inconvient) 
It's still in beta, but has a huge amount support and will be production ready before you know it.
tldr: &gt; Kotlin (+8), Scala (-1), Clojure (-3), Groovy (-3)... &gt; Kotlin(#20) jumped so far, in fact, that it finally broke into the Top 20 at #20 and leapfrogged Clojure (#24) and Groovy (#24) while doing so. It’s still well behind Scala (#13) ...
It'd be weird if it was ready after I knew it.
&gt; what about article in docs which compare React SSR and Kweb? And high level architecture overview. I can take a look at React SSR, was there something about that framework in particular that would make it a useful comparison? &gt; Also, I need two clicks to see actual code when I'm navigating from https://kweb.io/ (not big issue, but I was looking at Kweb yesterday, and found this little bit inconvient) Yeah, I'll probably just have kweb.io redirect to https://docs.kweb.io/ - everything people need is there.
Sure, please do. Any and all feedback appreciated.
I disagree. Cedric's initial posting was met with charged political discussion that over generalized the choice to use the Kotlin DSL for the Gradle source. Just because Groovy chose to do their own builds one way does not mean that other people can't (or shouldn't) use the Groovy DSL for their projects. Many people in the mailing list saw this as a political issue, which is too bad. 
For this, the kotlin dev team is actually rewritting the compiler backend to give us a nice public API for compiler plugins. I hope to see this in 1.4, hopefully at kotlinconf 2019.
Nice article for the current state. Please update it when mentioned issues are fixed!
I hope so, I think the general concept of sharing all but ui is great, and of course Kotlin is a great language 
&gt; I can take a look at React SSR, was there something about that framework in particular that would make it a useful comparison? It's just a way to make users familiar with framework. I understand how SSR in JS world works: 1. common bundle that executes in node and browser; 2. node serve html with data (just like if same route will be rendered in browser) 3. node serve asynchronously JS, so clients downloads css/html and can see content and navigate, and when JS fully downloaded they can do more with site This approach can solve following problems: 1. SEO 2. Disabled JS in browser 3. Time to Interactive 
Thank you! We will defenitly post a follow up once we are adapting Kotlin/Native (and we are pretty eager to do so)
 &gt;What would make Kweb more appealing to try? A better name. I know that's superficial but I have to pitch new libraries to my coworkers and they would be all like "kweb? Quep? Krap? K-wap?" And you should account for the morons in your (potential) userbase. 
Does anyone know when Kotlin Native is expected to be out of beta?
I've thought about changing the name but haven't come up with a better one. Some people do seem to like "Kweb". If I think of a better name I'll consider changing it.
I wish compile times were better too. On even the tiniest project it takes me forever to compile something. Related issue: https://github.com/JetBrains/kotlin-native/issues/733 I want it to be good :(
It will be big mess, btw look at kotlin + groovy: [https://stackoverflow.com/questions/36214437/compile-groovy-and-kotlin](https://stackoverflow.com/questions/36214437/compile-groovy-and-kotlin)
Thanks - one of the answers talked about separating the modules. Not sure if I can yet, but I was thinking about the same sort of thing. It's a cluster to begin with; I understand that, so maybe the correct solution is to just do the conversion. God I'll miss Spock tho.
I have to admit that I'm slowly growing fond of the name - maybe it's just an acquired taste. I may also be a bit biased as I have a strong dislike towards all python projects with py- in their name, Javascript projects ending on js and I'm seeing the same thing with Kotlin. On a more serious note - do you pronounce it k-web or kweb (like a portmanteau of queue and web) 
Can't we use Spock with kotlin? 
Yes, I pronounce it as one syllable, like mashing together "queue" and "web". And of course there can be other related words: "As a Kweb developer I enjoy building kwebsites on my kweb server". The potential for lame puns is almost unlimited.
I hereby officially revoke any previous complains about the name kweb
Korolev is very interesting - I'm surprised that I haven't seen it before because there does seem to be quite a bit of overlap, thank you for the reference. The closest thing I'd previously found to Kweb is Vaadin, so I specifically address some of the differences in the [FAQ](https://docs.kweb.io/en/latest/faq.html#what-s-the-difference-between-kweb-and-vaadin). Back to Korolev, they do seem to share a lot, in particular: * Built on JVM languages * Keep the logic on the server and drive the browser from there * Nice typesafe HTML DSLs * Define a transformation between immutable server state and the DOM, and then manage keeping them in sync Looking at the code itself, my first impressions are that Kweb's API seems quite a bit simpler, but I could be biased so that's probably for others to decide :) Korolev appears to work by doing a full "diff" on the DOM and only sending what has changed to the client. Kweb has no need for such a step as this is handled implicitly by its approach to [rendering state](https://docs.kweb.io/en/latest/state.html#rendering-state-to-a-dom-fragment). Since Scala doesn't have an equivalent of Kotlin's Coroutines (at least since they deprecated the delimited continuations compiler plugin), I'm not sure how efficiently Korolev will be able to query the DOM for information, [this](https://docs.kweb.io/en/latest/dom.html#reading-the-dom) is how Kweb does it. I may have overlooked it, but I also don't see any equivalent to Kweb's [immediate events](https://docs.kweb.io/en/latest/events.html#immediate-events) feature. This is important because without it these server-driven websites can appear perceptively slow to users (it was a common complaint with Vaadin). Those are just my initial thoughts on Korolev, it definitely seems to be coming from a very similar place to Kweb spiritually. I'll keep reading about it.
GraalVM may be a solution. https://github.com/graalvm 
Maybe but it doesn't solve my 3 intertwined language problem.
One thing that piss me off about Kotlin Native is compile times (it feels even slower than C++). I understand that it is compiled for the JVM, so there are some issues with startup times and JIT warmup, but I hope that eventually the compiler will be compiled to native code by itself and it will run faster.
I always thought that Kweb looks pretty awesome, it would be great if it had a public test website. I'm planning on rewriting one of my (very interactive) websites... Maybe I will try out Kweb :3 I didn't have time to check right know, but does Kweb support SSR?
&gt; I always thought that Kweb looks pretty awesome, it would be great if it had a public test website. Thank you and thanks for the suggestions, I'm going to work on putting up the simple "todo" demo. &gt; I'm planning on rewriting one of my (very interactive) websites... Maybe I will try out Kweb :3 That would be great! I'm happy to provide any help I can. &gt; I didn't have time to check right know, but does Kweb support SSR? Absolutely, take a look at the user manual - you can read the whole thing beginning to end in about 10 minutes and it should provide a good overview of what Kweb's all about.