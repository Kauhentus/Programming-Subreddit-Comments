There's a bug https://github.com/Microsoft/visualfsharp/issues/2184
https://www.stickermule.com/marketplace/3442-there-is-no-cloud
Let me just catalogue the options: - Visual Studio: Windows-only. - Visual Studio for Mac: formerly Xamarin Studio. Mac-only. - Project Rider: cross-platform. - Atom + Ionide: cross-platform. - VS Code + Ionide: cross-platform. The only judgments I'm going to pass are: - VS Code + Ionide &gt; Atom + Ionide; - Visual Studio for Windows &gt; everything else; - Ionide has been flaky in recent months. Make of that what you will.
That works. Thanks
Visual studio can't yet open fsharp projects in the new MSBuild 15 format (used for .net core). Which means anything fsharp and .net core on windows has to be done on ionide.
What am I missing out on by not using VS, just out of curiosity?
VS is nice because it's enormously polished, it doesn't have any individual feature that's missing from e.g. Ionide that's really a game changer.
Ah, good to hear. Thanks. 
Whenever you have a function that just calls another function. You can replace it with the second. So (fun row -&gt; convert row) Can just become convert
`let rows = Seq.map (fun row -&gt; createRowFromCSV row ) stockData.Tail` can be turned into `let rows = Seq.map createRowFromCSV stockData.Tail`
You don't need Visual Studio for type providers
In general, Rider is the furthest behind for F# right now. No FSI, many features not supported yet, a bit buggy, high memory usage, etc. But they have a roadmap and it's clear that it will be awesome by the end of this year.
This. Had the same problem. 
Thanks! That really helped troubleshoot things. VS Code isn't working for whatever reason (probably me being incapable of using it), but that helped me fix builds in Atom, so I don't mind.
F# is not fine when it's not a first class citizen. Fortunately JetBrains is helping out where Microsoft laggs behind. .NET core supports is very important and it's to bad that F# and .NET core does not work with visual studio 2017. 
What about its dependencies necessitated removal?
Just so you know, a lot of the Ionide developers have switched over to working mainly on VS Code, and the Ionide plugin on Atom is lagging behind since it's a bit of an afterthought for many of the Ionide devs. So you'll probably want to figure out what's wrong with your VS Code setup at some point, just so that you stay up-to-date with Ionide's latest features. The folks who hang out at https://gitter.im/ionide/ionide-project are probably the best ones to help you figure out what's up with your VS Code setup, so if you do decide to keep trying VS Code, that's where I would recommend asking.
The problem you describe doesn't sound bad at all. Smaller projects like Fable and fable-elmish move faster than Visual Studio. Doesn't surprise me. Besides, isn't Fable in beta right now? I like it, but I wouldn't dare use something in beta for anything serious. I bet they'll regret depending on .NET Core as well. Perhaps I'm just being pessimistic about it. I got on this .NET Core train for 1.0 RC1. Then Microsoft literally changed everything and didn't tell anyone.
The other issue I've noticed with the FSharp.Data Type provider for CSV's (not sure of the others), is that it doesn't seem to give a good option for handling a file with an error. I've mentioned this in a previous comment, but basically if you have a file with a bad row, it allows you to either ignore the row or stop processing the file with an exception. It seems if I can ignore a row, I should also be able to capture some information about the failed row. Say a string representing the entire row unparsed, plus a line number and an error message? This is an essential feature for anyone using this library for automation rather than data analysis.
Nice work. Now you have it working, you can try to refactor it down to make the code simpler. As /u/brianmcn points out, you tend to pipe the last argument into a function using the `|&gt;` operator. So your function would look something like this (note the change in the first line): let YouGotTheAnswerCorrect() = let rows = stockData.Tail |&gt; Seq.map (fun row -&gt; createRowFromCSV row) let diff = Seq.map (fun item -&gt; (item.DOE, abs (item.Open - item.Close))) rows let result = Seq.maxBy snd diff |&gt; fst result Then, as /u/astory11 mentions, you can replace that first lambda with just a direct call to `createRowFromCSV`: let YouGotTheAnswerCorrect() = let rows = stockData.Tail |&gt; Seq.map createRowFromCSV let diff = Seq.map (fun item -&gt; (item.DOE, abs (item.Open - item.Close))) rows let result = Seq.maxBy snd diff |&gt; fst result But now if you look at it, you are passing `rows` as the last argument to the next line, and you are passing `diff` to the last argument of the line after that, so why not pipe all these together? let YouGotTheAnswerCorrect() = stockData.Tail |&gt; Seq.map createRowFromCSV |&gt; Seq.map (fun item -&gt; (item.DOE, abs (item.Open - item.Close))) |&gt; Seq.maxBy snd |&gt; fst Note how we could then get rid of all the intermediate variables, and the result variable, and your function starts to look a lot like a data pipeline. But we can do a bit better. We can make that second lambda into a function too... let createTupleFromRow (item : Row) = (item.DOE, abs (item.Open - item.Close)) let YouGotTheAnswerCorrect() = stockData.Tail |&gt; Seq.map createRowFromCSV |&gt; Seq.map createTupleFromRow |&gt; Seq.maxBy snd |&gt; fst Now we can start seeing some patterns emerge. We are running two maps, one after the other. If this list is very long, it could take a while to traverse the list. Whenever we are doing two maps like this one after the other, we can just compose those two functions together and perform a single map: let YouGotTheAnswerCorrect() = stockData.Tail |&gt; Seq.map (createRowFromCSV &gt;&gt; createTupleFromRow) |&gt; Seq.maxBy snd |&gt; fst Note how we used the function composition operator "&gt;&gt;" to form a new function out of two simpler functions. I find doing these sorts of little refactorings really help with your understanding of functional programming, and once you can spot them, you start to see these patterns everywhere, which is very pleasing :) Hope this helps.
F# was created after .NET 4.0. I would be surprised if this was the only library you need that doesn't have a .NET 2.0 version.
Here's what I got from the video, in addition to the above: * F# has the most open source involvement of any .net language with an enthusiastic community. * The usage of 10s of thousands is enough for Microsoft to continue to invest in it * It is a first class citizen in Azure. I got these things from the [.NET blog post](https://blogs.msdn.microsoft.com/dotnet/2017/02/01/the-net-language-strategy/): * F# "shows great actual and potential growth" * "What F# needs more than anything is a focus on removing hurdles to adoption and productivity at all levels" * "we intend to ... [make] F# the best-tooled functional programming language in the market". * "F# has a phenomenally engaged community" * "It’s been an absolute front runner for open-source .NET, and continues to have a large proportion of its contributions come from outside of Microsoft." I took a look at the market and I already think that if you're going to bet on a functional language, F# is already the best to choose. I'm looking forward to the tooling improvements and when .NET runs better on non-Windows systems. Mono is improving and .NET Core is extending its reach. Here's how I interpret all of the above and Microsoft's general positioning in the market. Being harsh, Microsoft is only about Windows (desktop), Office, Azure and XBOX. Search, mobile, internet servers, browsers, closed source, etc. have passed it by. Windows and Office are legacy, with XBOX and Azure showing real promise for the future. That future will be open source hence the focus on .NET Core. If you're looking at future growth for Microsoft, you're not going to find it in Office and Windows, in C# or VB. You're going to find it in engagement with open source and Azure. In that context, you can see why F# is important to Microsoft. All of the various pain points that we see with F# are actually just general Microsoft pain points. Microsoft rebooted Windows and, essentially, broke .NET development and exactly the same time that closed source became unfashionable. Xamarin and F# are one way out of this hole.
Hi, thank you for the feedback. I was also wondering if leaving a link to a definition would be enough. It probably would, however I wanted to highlight that this is not a trivial subject and researching a bit the topic on your own would be beneficial. The 2nd part of the article can be found here: http://www.ybouglouan.pl/2017/05/creating-a-reactive-single-page-app-in-f-with-websharper-ui-next-and-bootstrap-part-2/ 
Apparently they are using FAKE for build, good sign
I don't think any editor has this feature for F#.
You mean just calling shell commands? There's this approach: http://stackoverflow.com/questions/1469764/run-command-prompt-commands
Perhaps you could take a look at the source code for FAKE. This has helpers for all sorts of things such as executing arbitrary processes, or executing Git commands, etc... Website: http://fsharp.github.io/FAKE Source: https://github.com/fsharp/FAKE
Once upon a time I wrote a 'logical block' highlighter for the editor: https://lorgonblog.wordpress.com/2012/06/24/f-depth-colorizer-for-vs2012-now-available/ I don't know if the code for that still exists anywhere today, but it seems to me that's sort of what you want - the ability to grab the 'logical section' of text around the cursor.
There's a User Voice issue for this. I agree: run current block, reload current module and run current function, and reload file to current point would be awesome scripting enhancements for the F# REPL cycle.
From http://fsharp.org/specs/component-design-guidelines/ - referenced in your link: &gt; Do use classes to encapsulate mutable state, according to standard OO methodology. Yikes. Why not just eliminate mutable state altogether? For one thing, if we're going to use mutable state, why use F# in the first place? Admittedly .Net interop usually requires mutation for side effects to take place. But I would think that you would ought to limit where that takes place in your app to a controlled area, similar to how Redux in JavaScript-land manages state changes. F# seems strikes me as a reasonable choice with this kind of architecture. I think if you mix mutable style and immutable style together, mutation has a tendency to spread across your codebase until you lose the primary benefit of functional style, namely the greater ease with which you can reason about your code. (As well as other benefits such as safe parallelization and so on.) 
I've not observed what you describe in practice. Mutability has its place and gets used here and there. But I've not seen a codebase where mutation "eats" the system.
I actually really appreciate the ability to drop back into mutable land if I've determined that a particular piece of code is a bottleneck.
I think what you and /u/brianmcn are proposing is different from what OP wants; at least it's different from the mentioned Matlab feature, which is about explicitly separated blocks of code that might span several definitions.
You don't need any of these, `git &lt;whatever&gt;` is enough.
Been running around in circles for about 30 minutes, how is this process so confusing? Could just be that i'm up way too late. I've installed the visual f# tools as per the fsharp.org guide but i'm unable to get any online templates or anything? I've searched the online extensions also and am getting nothing...
True, this was a bad example.
I guess it's the system beep to let you know the are no options for autocomplete. Check this link: https://superuser.com/a/10576
Thank you for the link, this solves it!
Thanks for that, thought I was going mad.
I realize this is way overkill for an answer to your question but vsvim does support surrounding arbitrary things with parenthesis. https://github.com/VSCodeVim/Vim#vim-surround If reducing hand movements and editing efficiently is important to you I strongly encourage you to give vim keybindings a try some time. 
Thanks I just saw that today, but did not see the fssnip part.
Type inference is done at compile time.
This is in context of concise syntax for defining and using new types compared to C#. For example, say you had some code that worked with emails, and you wanted an email type for compile-time safety on your function arguments. public class Email { public string Value { get; set; } public Email(String value) { Value = value; } } Most devs aren't going to go write out that class and remember to throw `Email` instead of `string` everywhere. So your email arguments are actually all `strings` and have no compile time safety. You could be getting other string data at run time. In F#, your type looks like this: type Email = Email of string done. You just aliased the string type, but now have compile time safety on strings for emails vs other string data. Easy to define, and easy to use - the type inference will mean you don't need to change any of your function definitions. Check out the "Single Cases" section on discriminated unions: https://fsharpforfunandprofit.com/posts/discriminated-unions/
It depends, you may be much more capable than I am, but writing a csv parser that handles things like quotations that stretch multiple rows and large files without ballooning memory (whether using string interning or some other means) seems decidedly non-trivial. I'm sure if you're written a few before it might not take long, but it perplexed me for more than I'm comfortable saying. Especially since I didn't want to use mutation. 
I find pandas is much easier to use when you have a data set containing a lot of strings. Also it has built in Excel support which for me is crucial. Also joining dataframes is easy. Deedle the last time I tried was awkward to use with strings, but ok with numbers. And didn't support reading and writing to Excel. And joining tables needed some involved re-indexing, because it always considered the index when joining.
&gt; To actually be state-of-the-art when it comes to metaprogramming, being able to pragmatically manipulate ASTs at compile time, like certain other languages have done for decades, would be a good start Except certain other languages already taught us that such homogeneous metaprogramming isn't very useful. 
I'll apply occam's razor here and assume it's a bug on the website.
Seems ok now 
Yeahhh, it was a bug i guess then
I guess they change url structure little bit. See: * old link: https://docs.microsoft.com/en-us/dotnet/articles/fsharp/ * new link: https://docs.microsoft.com/en-us/dotnet/fsharp/ And you catch it just in the middle when redirect was not working..
It has been shown to be extremely useful. For every language that includes it, important functionality in the most popular libraries rely on it. Examples: * Elixir: Query syntax + more in [Ecto](https://github.com/elixir-ecto/ecto) (data access library), routing in Phoenix (popular web framework), [gettext](https://github.com/elixir-lang/gettext) (internationalization tool) * Clojure: [Pattern matching implemented as a library](https://github.com/clojure/core.match), [async channel based programming library](https://github.com/clojure/core.async) * Haskell: [Routing in Yesod](https://www.yesodweb.com/book/routing-and-handlers) * Rust: [Diesel - ORM / query builder](http://diesel.rs/) If F# had it, we'd see the same thing.
What about using an f# Jupyter notebook? This is in the same domain / use-case as Marlan isn't it? https://notebooks.azure.com/
&gt; Train your brain in f# Any tips of how to achieve this as a c# dev?
While browsing through the topics: Typeproviders. Really cool in ad-hoc scripting scenarios. But don't touch them even with a stick if you need a stable api or at least debuggable api in your LOB projects.
I'm fluent in Linq, thus for getting stuff done (scripting/retrieving from db/data analysis) is much faster in C# in LinqPad than in F# in LinqPad or interactive. After 1 year F# I'm still not able to do a basic Group/TopX with List or Seq. For those wondering what I mean, imagine some enumerable/queryable: .GroupBy(i=&gt;i.interesting, (k,g)=&gt;new{ Count=g.Count(), Interesting=k, Entries=g.Select(i=&gt;other properties)/*possibly also grouped/topY*/ }) .OrderByDescending(g=&gt;g.Count) .Take(10) .Dump() kinda first glance analysis I use several times a week for anything (product usage, Log/Exception-triage, you get the idea).
&gt; Type Providers are one of the best features of F#, especially for data wrangling and analysis I'm rewriting a ton of code to remove all type providers because they are so unreliable. YMMV. &gt; F# is getting features that C# doesn’t even have F# has lots of really important features that C# doesn't have like algebraic datatypes, pattern matching, type inference with automatic generalization and tail call elimination but instead they talk about navigating to a function by clicking on it. &gt; "Pushing the boundaries of what languages can do" It's ASCII art in a text box FFS! Compare with [Mathematica](https://reference.wolfram.com/language/tutorial/Files/UsingANotebookInterface.en/1.gif) which has had a proper GUI for **decades**. Still, I'm happy to see F# getting any visibility at all. When F# was originally released in 2010 nobody said anything about it. 
FSharp.Data/SqlProvider type providers, or the awful stuff that comes in-box with older versions of VS?
&gt; As someone who writes insurance modelling software, yes. Thinking in terms of functions and transformations between data states makes building models much logical and easier than being forced into objects with methods on them. Writing this on the whiteboard is how you code it out. Much fewer bugs as well when you think that way. +1 
I'm going to need you to unpack this a bit.
Oh boy. Taking 10 dumps
Why not use them in something stable?
Yeah it's true that most F# introductory material tends to assume .NET knowledge. I've long wanted to write an intro to .NET for F# newcomers, haven't really had the time to do that yet though :(
If it would be any of help I would love to volunteer for proof reading any sketches and giving feedback from a real .NET newbee perspective.
Maybe [query expressions](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/query-expressions) would be more natural in F#.
Thanks. I will have a look
Learning C# before F# would be a good idea because C# is the most popular .NET language right now, and that is unlikely to change. This means that a lot of examples on the web are most likely done in C#. If you don't know C# well enough, you will have real hard time adapting these examples to F#. Likewise most discussion on a problems that aren't tied to a specific language include C#. C# vs F# isn't like Python vs Ruby. In the latter case we're not only talking about two different languages, but also entirely different platforms, tooling, the entire ecosystem. Not so with C# and F#, both share the same platform (.NET), some of the tooling and the ecosystem.
Bought it yesterday and I'm about half way through the 215 pages currently available. I agree with the other comments here. Excellent stuff. I suspect like many others, I currently build LOB apps with C# but would like to do the same with F#. This book is what I've been waiting for. As we all know from his excellent site: fsharpforfunandprofit.com Scott is an excellent teacher. Anyway, I'm off to read some more...
I used Query Expressions from the start to soften the transition from SQL. Once I really understood (think left outer join group by having) LINQ in Query Expression and the fluent syntax (Thanks Jon Skeet for Edulinq and all that.) and started with LINQPad, the fluent syntax seemed more natural. I just don't want back to query expressions, neither in C# nor F#. Computation Expressions (Builder/Monads?) on the other hand are a great Feature to build tiny DSL from a bunch of methods in the same context. 
Well, that's one way to loose weight. [1..10]|&gt;Seq.iter (fun i -&gt; "💩".Dump()) Fun Fact: As LinqPad's Dump is fluent, you can dump intermediate results when writing/debugging the code. Just comment those once you're finished. **Update** &gt; As LinqPad's Dump is fluent Or so I thought. While this is true for C# it unfortunately is for F#. Is there a better solution than this ugly workaround? [1..10]//.Dump() WTF, why isn't Dump() fluent in F#?! |&gt; (fun i -&gt; i.Dump();i) // poor mans passing dump |&gt; Seq.iter (fun _ -&gt; "💩".Dump())
&gt; I'm rewriting a ton of code to remove all type providers because they are so unreliable. YMMV. I can feel your pain. Writing those isn't fun either. &gt; like algebraic datatypes Why don't have we build-in lenses then? Autogenerating them for Aether (or whatever you use) is feasable (I've done this only for records) but painfull. I've used several approaches and FSharp.Compiler.Services is the least painfull so far. And don't get me started on binding redirects required to run my stuff in different environments. &gt; navigating to a function by clicking on it. What is wrong with that? I use is that several times a day.
&gt; I've tried using type providers for various things like calling WSDL web APIs and they never worked You mean like all those samples with public APIs in the books, Netflix or stackoflows OData? APIs which where abandoned more than a year ago? I was really surprised when I found a still working API in _F# for C# Developers_, must have been Bing maps destination stuff. Afair non of the ones in _Programming F#3.0_ did. I don't know about other books. I guess the cycle time of the web has striked again. BTW: Is _Real-World Functional Programming_ still worth buying? It's from 2009. F#2 came out 2010.In 2017 we have F#4.1 and there may be a lot of things that have changed drastically. Still hoping for a 2nd Ed.
&gt; You mean like all those samples with public APIs in the books, Netflix or stackoflows OData? APIs which where abandoned more than a year ago? I was really surprised when I found a still working API in F# for C# Developers, must have been Bing maps destination stuff. Afair non of the ones in Programming F#3.0 did. I don't know about other books. I guess the cycle time of the web has striked again. The APIs I tried to use were fine (e.g. the Protein Databank). The problem is that Microsoft's tooling (for C# too) is completely broken and not standards compliant. &gt; BTW: Is Real-World Functional Programming still worth buying? It's from 2009. F#2 came out 2010.In 2017 we have F#4.1 and there may be a lot of things that have changed drastically. Still hoping for a 2nd Ed. I last updated my Visual F# 2010 for Technical Computing book for the original release in 2010. Frankly, nothing significant has changed in F# since then. 
Thanks, this really works, or at least in F#Program mode. Seems like a linqpad-hack calling a generic Main.Dump In F#Expression mode I get &gt; The value or constructor 'Dump' is not defined (using built-in F# compiler) Program mode then it is.
I use F# at work, and have recently started using Fable to build user interfaces for my personal projects building lighting controllers for live performance. I find the Elm architecture really appealing but Elm itself lacks too many features to be a really nice language. I'll likely move towards writing the UI server layer in F# using something like Suave, which itself would reach down into the core of the controller (written in Rust) via something like Cap'n Proto + 0mq. Not decided on this yet, though, may still write the server in Rust as well.
&gt; Is it always going to be better to start as high up the stack as possible? It varies with your problem. If you have a lot of GUI/User interaction, high-level abstraction is good. If you're doing a lot of low-level hardware integration, you obviously want to get closer to the hardware. This could be with C, C++ or even assembly some times. If you are doing things like i/o directly (I2C, SPI, Serial, GPIO), then you'll want to bridge communication from the highest level through C++ (or C) glue code. You'll probably use libraries to do this most often, but in the case of *complex* GPIO reads and writes or custom protocols, you'll probably have to write this yourself. Edit: Grammar, again.
It looks like you can download a PDF of the entire .NET platform guide (F# included). https://opbuildstorageprod.blob.core.windows.net/output-pdf-files/en-us/VS.core-docs/live/docs.pdf
Thats kinda how i use all programming languages haha. But i see alot of people say "if you use f# dont use classes or any OOP" but i wanted to see others opinions 
I use classes in f#, mostly as a place to implement interfaces. The thing to avoid in my opinion is making them contain mutable data - I prefer to separate my data types from my logic types and keep things immutable. If a class needs to be stateful, i look at MailboxProcessor first before mutability.
My advice is to program in F# however you want. I mean sure, functional programming is great, but trying to force yourself to program in an unfamiliar style will just lead to frustration. I myself only learned functional programming over many months, and the way that happened is not because I was trying to do functional programming, but instead gravitated to it naturally as I optimized the way I program and FP is more concise and reasonable than the alternatives.
Saw this on F# weekly and thought it was so cool that it needed its own post here. Fable is doing really well as a free and simpler alternative to websharper. [Fable elmish](https://github.com/fable-elmish/elmish) is another great aspect that websharper doesn't have.
&gt; 2.Do I need IIS to run web projects built with F#? No. Technically speaking, you haven't been required to use IIS to host websites since .NET 2.0 introduced the HttpListener class. I've often built applications that self-hosted a web server using this model. 
When I say "excessive memory copying" I'm assuming that you are at least using contiguous data structures such as ImmutableArray. If you instead use an ImmutableList, which is basically the same as what's described in the article you mentioned, then performance is much, much worse in the typical case. I'm talking orders of magnitude worse. Class For (us) For-Each (us) int[] 0.647 0.517 List&lt;int&gt; 1.4776 2.8544 Collection&lt;int&gt; 6.9078 8.2498 ReadOnlyCollection&lt;int&gt; 6.9520 8.2494 ImmutableArray&lt;int&gt; 0.954 2.7449 ImmutableList&lt;int&gt; 50.6617 62.3762 https://www.infoq.com/articles/For-Each-Performance That isn't to say an ImmutableList is useless. But you need a very specific scenario to overcome the inherent performance cost that arises from pointer chasing.
This seems cool. After reading a little about BEAM, i really liked it. But the two main languages that run on BEAM are dynamic typed. This on the other hand
&gt; For example, use Path.Combine(basePath, folderName) instead of basePath + "/" + folderName. Actually you can just use "/" on Windows if you want, it works fine! And Path.Combine is a trap, because it deals with absolute paths in a way most people doesn't expect. It's equivalent to **cd**-ing every argument in sequence. What this means: let path = "C:/MyProgram/" + "/" + "/MyFolder" // returns "C:/MyProgram///MyFolder", which is equivalent to "C:\MyProgram\MyFolder" Path.Combine("C:/MyProgram/", "/MyFolder") // returns "/MyFolder", which is equivalent to "C:\MyFolder" A good reference for dodging these common pitfalls is FAKE's [EnvironmentHelper module](https://github.com/fsharp/FAKE/blob/master/src/app/FakeLib/EnvironmentHelper.fs)
heh, yeah I know. I still thought the project was interesting though.
Can you add some details or a reference here? What can C# do that F# cannot?
Interfaces: not implicit, not implementable for multiple generic types by the same class Co/contra-variance: limited Anonymous types: proposed Property members: syntax is horrid, i have to it lookup every time i use them, good thing it's not often Nested types: not supported 
One day I'll learn one of the BEAM languages... 
I'm working on getting F# to work in my fresh Visual Studio 2017 install on a new machine. Once I've got it up and running I'm going to: * Write some more articles for the F# journal. * Turn my F# script that does analytics on my business using type providers and manual cut'n'paste into Excel into something that exposes the resulting graphs via the web so the rest of the board of directors can look at my analytics in real-time. * Work with our CTO to improve [our mobile app](https://play.google.com/store/apps/details?id=idtechex.app.droid&amp;hl=en_GB), which is written entirely in F# using Xamarin. * Continue work on trying to code up my market forecast for the 3D printing industry in the hope that it will lead to at least better tools for our analysts and maybe even close to full automated updates of our products. * Continue my current skunkworks project which is a minimal ML-like programming language designed to be easy to implement/port/edit and port to other platform (like Raspberry Pi) as well as compiling to tiny binaries. 
&gt; If you follow F# idioms regarding immutability you may find that performance is worse because of excessive memory copying. Immutability isn't an F# idiom. If you write code that copies excessively then it will be slow in C# and F#. 
&gt; The PersistentVector structure, for example, is a high-performance list-like data structure with basically constant-time indexing, appending, and updating. In virtually all practical cases, persistent and high-performance don't belong in the same sentence together. &gt; Use the right data structures and you won't have to. Exactly. 
Not *necessarily*... if you really wanted to drop .fsproj files you *could* just structure your project as a series of .fsx files that #load each other, and then compile them by calling fsc directly through FAKE. That should still work with editor plugins.
Install it from the official Mono repositories instead of Debian's: http://www.mono-project.com/download/#download-lin-raspbian You might need to use the `-t` flag to target the repo specifically when installing if Debian has a package with the same name.
Thanks, I'm going to see if this works tomorrow morning :)
The F# Component Design Guidelines is very short but extremely helpful when learning F#. http://fsharp.org/specs/component-design-guidelines/
Yeah, no problem, noticed that a couple days ago as well. Have fun! :)
Can anyone make Rider + .net core 1.0/1 work on OSX? I get offered F# project but it seems to only work with mono.
My guess is that modulo only works with integer types. Try converting to an int. If that doesn't help, can you tell us the error message you are seeing?
It had to do with something completely different, no worries.
Well now I'm curious. What was it?
It was probably the incorrect indexing syntax. Indexing in f# goes like 'thing.[index expression]', and OP was missing the '.' Also mutable assignment being &lt;- instead of =
Oh, yes that's probably it. I've been mainly using Python lately and had forgot that about F#.
It's tough to bounce between languages, for sure!
Very stupid. .fs files can be for f# or for fragment shaders. I was supposed to use GLSL, but they look kinda similar at a glance. I looked into it a little bit, it looked basically the same to my untrained eye, so I just assumed it was f#.
In that case, adding 1 to your red channel will just max it and you won't see any variation. I'm not really sure what youre trying to do, even if you use `mod(x, y)`, as your expression should almost always give something greater than 1.
that should have been texcoord[1] first off, but I forgot to type that into reddit. It should either be a 0 or a 1, so adding it would give either a 1 or a 2. Then we divide red by either 1 or 2, thus halving it every other line. edit: parentheses derp, should have been outside of the 1 as well.
Nice Work. It's going to be nice to have F# .NET core support in visual studio.
This is really excellent. Nice Work. Looking forward to the finished product 
Congratulations on the work achieved. What about UWP support? Without it F# is only usable as a Powershell replacement, on the context of my work environment.
Not sure if you're still following this thread or not, but in case you are, I'm surprised that no one has made mention of .NET Core. At least for myself, working with .NET Core has been a much more pleasant experience than Paket/FAKE/any of the other F# build systems that I've tried. Things have also made their way to a point where all of the tools that I've tried to use support .NET Core project structures in addition to the classic XML files. When I'm making a new project, I do something like: dotnet new console --language fsharp dotnet build dotnet run Emacs is able to read the `.fsproj` file generated by `dotnet new`, and all package management can be handled via the `dotnet` command line tool as well.. Just another thing to look into.
A dream come true for me.
If you have to - do it. You have my permission.
Thanks for the list! This will keep me occupied for a (long) while
It's because type providers are not yet supported on .NET Core.
See **What work is remaining?** at github/visualfsharp [#3298](https://github.com/Microsoft/visualfsharp/issues/3298), and [#3303](https://github.com/Microsoft/visualfsharp/issues/3303) for workaround.
Even though I chose regular .NET Application 4.6.2 and not .NET core ? As mentioned, if I compile the one from Github and reference it, everything works as expected. Oh now I see "By default, the .NET SDK tooling runs the F# compiler using .NET Core" Ok makes sense now :)
Trying to learn more and more. But struggling for ideas to make something real :(
When using this in production, one problem I ran into was with hooking up the application object's DispatcherUnhandledException event. As pointed out to me, Elmish will handle the exceptions if I just use the right calls, but that's like telling me I don't need seat belts if I just drive properly. And if I don't set Handled=true, then the application will just crash and freeze instead of recover as best it can from any exception that might come that way. That handler is also a good debugging tool while developing. Anyway I also need the application object for other stuff, such as ShutdownMode. The application object is not exposed, and you can easily see just that in Program.fs in the source of Elmish.WPF on NuGet. So what to do? Easy. The application object can be accessed through Application.Current, but not before Elmish has started it. So what I did was attach a handler to the main window's Loaded event, which you can do in F# code because you are instantiating the window and handing it to Elmish. In that event Application.Current will no longer be null, and the exception handler can be set there.
Hey @flickerer, Thanks for posting your experiences. I'm assuming you're talking about this project: https://github.com/Prolucid/Elmish.WPF Has anyone tried WPF-Rethought (https://github.com/Krzysztof-Cieslak/WPF-Rethought)? Its a similar idea. I was curious if anyone has experiences with both that they could contrast. In the last year, I've been discovering how great functional programming can be. I got my feet wet writing some Elm apps (and loved it BTW), but come from a .NET background. The idea that I can use the Elm Architecture within .NET using F# is awesome to me. I'm going to have to play with these libraries very soon. Ben
I thought fable transpiles f# to JavaScript? How does that work with WPF?
No transpilation or anything like that needed, since Elmish.WPF uses F# and works with WPF which is on .NET Framework. It's a simple library that supports the Elm model-update-view (I think it was called). The XAML you put in a separate C# user control library, but no C# is needed. Follow the link posted by euphbriggs for more info.
If I understand it correctly, this library uses fable-elmish, not fable. Its a confusing name, but I believe fable-elmish is essentially the Elm Architecture (model/view/update) implemented in F#. Fable-elmish was originally written for Fable, but apparently its decoupled enough to also be used for other environments. Very cool stuff.
Today the source on NuGet was updated with a sample that shows how Elmish.WPF can be used with FsXaml. Haven't tried it out yet. Not sure about the pros and cons.
Thanks for sharing your experience. I don't suppose any of these projects you have worked on are likely to be open source or you have any plans to show any code?
I've started working on a Japanese dictionary web-app, with features heavily optimised for looking up a lot of words with kanji that you can not read. I'm working with `WebSharper`, which feels awesome so far! I'm currently a little stuck because all the free data (kanji decomposition to pieces, meanings and readings for kanji etc.) are in a little messed-up format, so at the moment I'm trying to measure if some fields are missing for some kanji etc. which is advancing slowly :( I have big hopes for my project though! There was one point when I got the "filter kanji by radicals" feature sorted out [(screenshot)](https://images.discordapp.net/attachments/156510315260018688/325775264984465408/unknown.png) but now I'm reworking all my types so it's all broken at the moment x) How about you?
I created a demo repo on GitHub: https://github.com/BentTranberg/ElmishWpfDemos This demonstrates handling unhandled exceptions in the way I described. In addition I also got a tip (see issue on https://github.com/Prolucid/Elmish.WPF) that explained how to use Elmish.WPF's onError handler, which is in addition to the handling I already did. With that, I believe all unhandled exceptions in this application are caught. But then there's AppDomain.CurrentDomain.UnhandledException and Threading.Thread.GetDomain().UnhandledException, which is another story we don't have to go into now.
it uses the [sources of fable-elmish](https://github.com/Prolucid/Elmish.WPF/blob/master/paket.dependencies#L6), with Fable namespaces stubbed out with suitable replacements. Maybe at some point we'll pull the fable dependencies and use the nuget package directly.
This is one of these things where I don't really understand why we're making it much more difficult to understand. I agree with the main points of functional programming, like option/result types, tagged unions, immutability by default, and using map/iter/collect etc to go over sequences. In these cases I find the functional programming model makes readability easier. In this case, and I've read a few articles like this, I don't see the reason why we make things much more complicated than necessary.
I *think* this wasn't intended for this sub :)
Because we can!
The big advantage here - which is going completely unmentioned for some reason - is that you can now painlessly unit test your application logic. All you have to do is swap out the interpreter for one that throws if the `CommandLineProgram` doesn't do what you want it to do. This is an advanced pattern for separation of concerns, replacing dependency injection. I agree with you that it's a bit verbose though. E: also, this sets you up in case you ever need to do static analysis on your application logic. Great for performance investigations, etc.
Ok that's a valid argument.
Working through project Euler puzzles to learn the language. I've finished number two, and am currently trying to get my solution to number 3 to use less than 2 gigs of memory. You could say my code currently has a lot of room for optimization. :-) Http://projectEuler.net
Sponsored conference tickets for people from minorities underrepresented in tech. Two conferences so far, more coming.
I'm excited to see what comes out of this. I'm hoping this is the start of a more active FSSF!
Neophyte question ... would higher kinded types make things like this less verbose? But also potentially more abstract or obtuse? Edit: change "minded" to "kinded". 
Higher-kinded types can make this a little more principled, but to really make the best of this pattern you need some kind of limited compile-time logic programming. See [this Scala talk by Rúnar Bjarnasson](https://youtu.be/M258zVn4m2M), based on [this paper by Wouter Swierstra](http://dl.acm.org/citation.cfm?id=1394795). 
The images you posted appear to be too small
I can't even load them: "ImgBB error: Internal Server Error"
I agree that I can't read the images. However, if you could link to the example application, we may be able to determine the issue. I do know that tooling on .NET Core is not the same between F# and C#.
I should've checked them first; that's on me. I'll reupload them in a second.
... they're still unreadable.
They are not "higher minded types", they are higher sorted kinds (or HSK)
Sorry, typed that question on mobile. Autocorrect did that. 
Sorry, typed that question on mobile. Autocorrect did that. 
 let func1 = Success "" let func2 s = Success (s, 1) let func3 (s, i) = Success (s, i) ?
That is one way, but I would prefer func2 to not have to know that he is passing on the 2nd argument.
 let r1 = "" let result = func2 r1 &gt;&gt;= func3 r1 ? Edit: let passThrough (fn : string -&gt; Result&lt;int&gt;) (input : string) : Result&lt;string*int&gt; = match fn input with | Failure f -&gt; Failure f | Success output -&gt; Success (input, output) let result = func1 &gt;&gt;= passThrough func2 &gt;&gt;= func3
Not exactly a book, but I find this F# talk to be a good introduction: [Functional programming design patterns by Scott Wlaschin](https://www.youtube.com/watch?v=E8I19uA-wGY). As for a book, I recommend [Haskell Programming from first principles](http://haskellbook.com/).
Thanks! I've read almost half of his epic "F#4Fun&amp;Profit". It is great for practical F# applications and business tasks but I think it lacks theory. Probably Haskell book is what I need.
Cannot read the error message from the image you posted, so I'm not sure if this will help you or not. I played with F# (.NET Core) on Linux and as far as I remember you get permission denied if you try run "dotnet run --project path/to/project-dir". You must be in the project directory and run the "dotnet run" command (I think it's a bug).
That talk is great, do you know if there is a text version of it?
Computation expressions might be the best bet rather than using "bind". The code would look like this: let result = result { let! a = func1 let! b = func2 a let! c = func3 a b // pass in result from func1 and func2 return c } You can find the code for a `result` computation expression in lots of F# libraries. Here's a simple one: type ResultBuilder() = member this.Return a = returnM a // wrap in Ok or Success member this.Bind (m, f) = bind f m member this.ReturnFrom m = m // computation expression let result = ResultBuilder() 
https://fsharpforfunandprofit.com/fppatterns/ You could download whole site as ebook here: https://www.gitbook.com/book/swlaschin/fsharpforfunandprofit/details
Quite a few videos: https://www.youtube.com/user/DrBartosz/playlists
That's a treasure! Exactly what I need! Thanks a lot. By the way, is there by any chance a text version? :)
Ah great suggestion thanks!
For Clojure: http://mishadoff.com/blog/clojure-design-patterns/
https://bartoszmilewski.com/
Have look at https://www.youtube.com/watch?v=Rmer37g9AZM 
&gt;[**g ∘ f patterns by Mario Fusco [61:40]**](http://youtu.be/Rmer37g9AZM) &gt;&gt;The book of design patterns known as Gang of Four has been a kind of Bible for all the developers of my generation. Its main pro has been giving us a common vocabulary: when a programmer says "here I used a strategy pattern" all colleagues know of what he is speaking about. Nevertheless the biggest issue with this is that almost all patterns listed in that book, especially the behavioural ones, are a only workaround for a missing abstraction: higher order functions. The introduction of lambda expressions in Java 8 finally allows all Java developers to remove this no longer necessary and cumbersome object oriented infrastructure from their code. The purpose of this talk is showing, through a series of live coding examples, how the most common GoF patterns can be rethought and reimplemented in a simpler and more concise functional way leveraging Java 8 lambdas. &gt; [*^Devoxx*](https://www.youtube.com/channel/UCCBVCTuk6uJrN3iFV_3vurg) ^in ^Science ^&amp; ^Technology &gt;*^4,462 ^views ^since ^Nov ^2016* [^bot ^info](/r/youtubefactsbot/wiki/index)
Thanl you, that's perfect!
I would go with the basics of type theory and how it is used in Haskell (or SML). I don't use Haskell, but if you are using any ML-inspired language it is always an interesting path.
Integrating [p5.js](https://p5js.org/) with Fable, one function at a time. (Also: lamenting that I'm stuck with C# in my nine-to-five.)
 let result = func1 &gt;&gt;= fun a -&gt; func2 a &gt;&gt;= func3 a Though it is a bit ugly, you can do it like this in the most direct fashion.
Oh that's an interesting solution too, thanks!
Yeah F# for fun and profit is very practical based. Haskell is more academic (although some might argue against that) so you'll be better off with books on Haskell.
Other comments haven't really addressed the issue here: Why do you need to call func2 if you're not using its result? What should "result" be here?
I want to pass both the result from func1 and the result from func2 to func3
.net core is probably more performant, but the tooling for f# is still a wip imo. Mono 4.8.1 is stable, although it's not traditionally the most performant. It's still pretty good though and improving.
My opinion is go with dotnet core, use the ionide plugins on vscode or atom, and try out FSharp.Data or https://github.com/the-gamma for graphs and visualizations.
.NET Core is probably about 6 months from having the tooling up to snuff. I've had success on Windows and Linux, but I have no Mac to test. The advantage to Mono is that it supports the full framework, and some of the F# data science packages haven't been updated to support .NET Core, and if you're using type providers, they won't be ready until .NET Standard 2.
I don't think FSharp.Data works with .NET Core
This is [partial application of arguments](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/functions/#partial-application-of-arguments). By calling `findTile` with only the first parameter, it's producing a _new_ function which will take in a single `MapTile` and always compare its coordinate against `myPoint`.
Of course! I can't believe I didn't figure that out. I guess I still need to get used to functional programming. Thanks!
Although `=` being used for comparison isn't *that* obvious so this has a few levels of complexity for beginners
I'd say that the function should probably be defined like this: let findTile coord elem = elem.coordinate = coord Perhaps not immediately clear for newcomers, but probably a little less confusing than having it on the same line. &gt; Of course! I can't believe I didn't figure that out. I guess I still need to get used to functional programming. Thanks! It takes a little while, but not too much! You're definitely on the right track.
Should I add type annotations for extra clarity? let findTile (coord:Coordinate tile:MapTile) : bool = tile.coordinate = coord Something like the above
I appreciate having type annotations on all public functions. 👍
Intellisense being as good as it is, I don't consider it needed really. But it doesn't hurt so.
I generally don't like adding type annotations unless necessary. This also forces you to choose explicit names for your parameters.
Why not? It helps make the code a little more self-documenting IMO, but only in functions and in variables that don't help you understand their type. So not ones which are named properly or are initialized using `new` (Java's `class var = new class()` is so ugly)
I guess it's a choice to make. I personally prefer to let the compiler infer the types (when possible) and focus and choosing good names for my parameters. I also find it more readable without type annotations, but again, I think this is a question of preference.
[removed]
&gt; Starting with Visual Studio 2017 Update 3, F# is an optional component. Simply select F# from the Individual Components tab and press Install. AFAIK Visual Studio 2017 Update 3 is only in preview. I doubt the build tools are available, but I haven't bothered with that route in a while. Shouldn't Option 4b still work, since it's just got standalone downloads?
On Windows it's just use visual studio. Mac or Linux get mono. 
I don't want to install visual studio. 
You can install DotNet Core instead then.
Exactly. Just use Linux or Mac, and there is a terminal compiler.
So .. to avoid the big installation of Visual Studio I should install Linux and download Mono?
Just use a VM. Plus visual studio is significantly larger than Linux. My assumption is most programmers have vms and multiple os installs, which is usually true.
I'm not a programmer.
A minimal install of VS 2017 + just F# isn't all that large. Installs on my desktop (admittedly, a good machine) in less than 5 minutes.
I have installed F# with and without Visual Studio (VS). Whilst it is possible to do it without VS it is fiddly, error prone and complex. After that experience I decided to go the VS route for all my subsequent installs. VS is the reference implementation and installs and correctly configures everything. Having a version of VS can be really handy for error checking. Personally I prefer using VS Code. On Windows I install a minimal Community Edition of VS, or. Net Core (if that is suitable). On Linux it's Net Core or Mono. I would definitely not install linux and mono in a VM - that is the worst possible experience on Windows. Edit: I didn't say above but the purpose of installing VS is for the tool chain. I have used Notepad++, VS Code, Atom, etc for editing. Net Core is the future, so that is a good choice. 
Thanks for the answer. 
What's the best way to test suave apps on dot net core? I tried to install the suave.testing package but looks like it doesn't support dot net core yet?
Not sure it's the best way but this repo https://github.com/ninjarobot/suave-chiron-netcore has some examples with xunit.
You linked Rachel but not her article!
Whoops thanks a lot for pointing that out. It's fixed :)
Very good article!
Appears to be just testing the serializers? I guess I'll have to wait until Suave.Testing supports .net core.
Also, 'Home' and 'About' links on your website are relative and don't really point anywhere from the article you posted. Probably I should charge for web testing hahaha
Haha thanks again! I really should get rid of this Jekyll tool. I keep having issues with it recently. 
I got a tip that Gjallarhorn can be used in much the same way as Elmish.WPF, so now I'm having a look at it. It was easy for me to get going with Elmish.WPF, mostly due to very simple and clear examples and easy to grasp documentation, though there is little of it. Initially I haven't found Gjallarhorn quite that welcoming, but I look forward to a couple of days trying it out for real. Gjallarhorn appears to have a bigger user base, though Elmish.WPF is growing.
I'm doing this :) I've basically fallen in love with F# over the last year. Such a fantastic tool and it fits into the Azure Function paradigm very well.
Yeah, it's a great tool for integrations and all sorts of data manipulation.
https://github.com/fable-compiler/fable-suave-scaffold This is a full .Net Core solution with a Suave server backend and a Fable single-page app frontend plus a testing project, but you can just use the server project on its own. 
What I've always wondered, is why do I have to write functions like let encode qualif jsonObj = jsonObj |&gt; Json.Encode.required Json.Encode.int "id" qualif.Id |&gt; Json.Encode.required Json.Encode.int "value" qualif.Value |&gt; Json.Encode.required Json.Encode.string "name" qualif.Name let decode = create &lt;!&gt; Json.Decode.required Json.Decode.int "id" &lt;*&gt; Json.Decode.required Json.Decode.int "value" &lt;*&gt; Json.Decode.required Json.Decode.string "name" What do I gain from writing out functions like that, instead of using Newtonsoft, where all I need is `JsonConvert.DeserializeObject&lt;Qualification&gt;(jsonString)`? Generally curious. Clearly, there's a reason, otherwise this library wouldn't exist. So what am I missing?
Sometimes, I want to hide some properties of an object. So, I can hide, say, the value of Value prop, I will delete its encoding part.
Follow up: In C# (and I'm guessing most languages) it's bad practice to use the domain model at the edges of the application. i.e. serialization, or as a ViewModel. Would the ability to hide certain members allow the usage of domain models in this way, effectively avoiding a mapping layer?
&gt; Clearly, there's a reason, otherwise this library wouldn't exist. I don't think we should assume that. Remember that lots of ideas get tried out all the time, and not 100% of them turn out to be a good idea. For this particular one, I have some doubts. Most serialization needs can be already be handled with Newtonsoft via conventions, settings, or worst case custom serializers for a type. In the documentation for Chiron, it says doing it this way gives us a lot of power, but it is not clear what kind of power, and why it is needed for most apps, and why they are currently underserved by Newtonsoft. While writing a README, I can understand the impulse to not "step on any toes", but it has a big downside in that it obfuscates the rationale for the library. If any of the authors are here, maybe they can elaborate on this. As it is now, Chiron almost strikes me as functional programming for it's own sake, rather addressing a real problem in the ecosystem.
As https://xyncro.tech/chiron/guides/ says, "Chiron works rather differently to most .NET JSON libraries with which you might be familiar, using neither reflection nor annotation, but instead uses a simple functional style to be very explicit about the relationship of types to JSON." So your analysis of it being "functional programming for its own sake" is pretty much correct. I don't see that as a bad thing: it allows you to write code in the style you prefer. If you like the way Newtonsoft automatically figures out the serialization of your objects, great. There's absolutely nothing wrong with using Newtonsoft.Json; there's a good reason why it's [the most-downloaded NuGet package in the world](https://www.nuget.org/stats/packages), downloaded over 5x more often than the second-place package. However, if you prefer to be explicit about your serialization, and you like the functional style of using `apply` and `bind`, then Chiron fills that niche. It's not an often-requested niche, but there are some people who prefer to code that way, so Chiron allows them to make that choice -- and having options available to match your preferred coding style is, overall, a good thing.
Not only to hide certain members, but to specify exactly how the serialization is done. Do you use a struct union as a strongly-typed ID? Just convert it in the de/serialization functions. Do you need to serialize an int as string in order to fit the stupid format required by an external tool? Just convert it in the de/serialization functions. Etc.
Just like [kaeedo's comment](https://www.reddit.com/r/fsharp/comments/6qgkso/chiron_tutorial/dkx591n/), why are we writing json serialization like elm? Elm doesn't have reflection, we do. Surely that must make things way way easier.
Are there some interesting tricks you can pull off with Chiron's applicative functors? I can't really think of much. Otherwise, if the primary feature is manual de/serialisation, other libraries also let you override the default reflection-based methods with custom ones. A thin functional wrapper around those classes would let you rely on quick Json.NET or DataContractSerializer reflection when the object is simple and the mapping is 1:1, while still writing your own json representation when you need fine control or high performance. (About that, I should also mention that some f# blogger ran benchmarks a while ago - I'm on the phone right now, but the link is in the f# weekly somewhere - and apparently Chiron is dog-slow.)
I'm very intrigued by this project, especially the query planning capabilities of the parent project Rezoom. The only thing I can see that jumps out at me as a blocker is the lack of comprehensive support for json functions in postgres, but surely that can be PR'd.
I'm currently working on a script that calls a Web service (https) and publishes the results as a Confluence wiki table using the Confluence rest API. Using mainly Jsonproviders and Fsharp.Data http helpers. Lots of fun so far!
Trying to understand how web development feels in f#. What I'm trying to implement are: - Crud, postgres and marten. - Auth (is jwt the right choice for SPA?). - SPA. I don't know about react, fable, and js at all. 
You should probably give Fable a try. AFAIK the best way to get started would be to use the Fable Elmish template. You could also try Websharper!
Yes, I'm giving fable elmish a try. Though I don't know what is the best practice and stuff like that. 
This is a very recent video on the topic: https://youtu.be/fmaPeUBWZuM It should help you get started with it.
Thanks!
This has nothing to do with F#.
And Rust.
Building an in-house web site for business analytics so people can assess their own performance. I've had lots of problems with everything from VS2017, F# compiler bugs, type provider bugs (SQLProvider giving 5m30s compile times), library incompatibilities and bugs (XPlot) and so on. I'm thinking F# is the wrong tool for this job. 
I'm using a Suave back end as a REST API with an Elm front end. Not full F# but I have everything containerized so the development cycle is super tight. It's going great so far. 
Implementing a GraphQL to SQL layer. Like [JoinMonster](https://github.com/stems/join-monster), except good SQL, and in F#. 
How are you finding Marten? I'm using Postgres as well, but I'm rolling my own event sourcing instead.
Never ventured past event storing in Marten. Jimmy Byrd writes a wrapper of Marten in fsharp and I use that as document store. And here's my simplified event store and source in. https://gist.github.com/ibnuda/1e0ca7380117188e323a72a0aa1802f9 
[Project euler](https://projecteuler.net) in f# ;-)
https://github.com/Microsoft/visualfsharp/issues/2184 This should be fixed in VS 15.3 (2017 Update 3)
How does this compare to Visual Studio?
Midnight commander copy in f# is on my plate right now. Just starting the TUI basic calls for it
The primitives are rather easy to implement, shouldn't take more than a few days. There are tons of tutorials for implementing parser combinators. But do not think that you can close to the performance of FParsec.
I pretty much DGAF about performance, this is purely as a proof of concept thing.
Look at this: https://fsharpforfunandprofit.com/posts/understanding-parser-combinators/ The implementation is really not that complicated. 
Expert F# is pretty good, but it's F#-focused which doesn't appear to be what you're after. Maybe you should try /r/functionalprogramming
I googled "F# certification" and found: * https://university.xamarin.com/classes/track/fsharp# * https://www.zeolearn.com/f-sharp-training
You mean you are required to have a certificate at the end?
Scott, the sites author, has a new book on domain driven design in F# in early release. I have found it one of the best resources on the practical application of functional concepts.
Apparently there's a lively discussion going on regarding functional languages, their tools and in some cases F# versus Clojure. 
Not OP. I love using F# For Fun and Profit. I will say that I would love a book I could sit down with and potentially read front-to-back if I wanted to for ideas/inspiration. I don't usually use this site for that reason.
As a Lisp guy I would love to say "use scheme", but frankly I think the ML camp is where all the cool stuff happens. Over in scheme land we just now got to taste the goodness of delimited co tinuations or Concurrent ML-lile paralellism, that the ML crowd has had for a long time. Heck, the delcc library in ocaml is implemented in pure ocaml and has no performance impact on code that is not using it. Contrast that with scheme, where most implementations suffer because they have to support something as bruteish as call/cc. ML is what I look at for cool stuff. Scheme is what I do for fun. Neither pays my bills.
I've been working on mobile apps and went from C# + xamarin to F# + xamarin to ClojureScript + react native. While I like the simple, data-oriented approach Clojure takes, I feel much more at home in a strongly typed language like F#. But both blow C# (and OO in general) out of the water in terms of expressiveness per line of code. I have a fondness for Haskell, but depending on what you're trying to build, others may be paths of lower resistance. F#, Clojure, and ClojureScript have the entire .Net, Java, and JavaScript ecosystems available, respectively. If you're learning more as an intellectual exercise than for direct practical benefit, I'd probably lean towards Haskell. Otherwise it really depends on your target environment.
Which part of the book are you referring to? "main" is usually defined by "let main argv =". Defining it as taking unit will give a compile error.
https://en.wikibooks.org/wiki/F_Sharp_Programming/Basic_Concepts#Structure_of_F.23_Programs
That snippet doesn't mark main() as the [&lt;EntryPoint&gt;], so you have to manually call it after defining it.
My understanding is that if you just define a "let main" without a unit parameter as the last toplevel value definition (edit: and without an entrypoint label), it will execute the statements within the definition anyway. Why not just do that?
That happens because in that case (`let main = …`) you're not defining a function, you're declaring a value. So, to compute the value, it has to execute the statements to find out what the value is. Doing things this way is a bit misleading because `main` is usually a function.
Right, so why does the book use "let main()" followed by "main()" instead of "let main" alone? Why is main usually a function instead of a value in the situations where no information-passing parameter is needed? Is it for consistency's sake with main functions that have parameters, or is there some other reason?
See also the uservoice topic from **July 31, 2015** here https://wpdev.uservoice.com/forums/110705-universal-windows-platform/suggestions/9110134-f-support-in-net-native-for-uwp &gt; **After one year since has been flagged as WORKING ON IT , the support for .NET Native is not even in roadmap** https://github.com/Microsoft/visualfsharp/issues/2400. See also this comment from the F# creator Don Syme. https://github.com/Microsoft/visualfsharp/issues/1096#issuecomment-293248047 &gt; My impression was that F# libraries would likely work immediately in UWP (not coreclr native code gen) if tail. was ignored. I think it's up to the UWP team though, not the Visual F# Tools team. It's not a compiler problem, it's a runtime problem. &gt; To be honest, it appears **UWP is simply not implementing the .NET specs correctly** - tail. has been in all editions of the ECMA 335 CLI Standard... Mind you, generics have also been in that standard, with no mention of "limits of 7 deep" or anything like that. **I'm always somewhat surprised when I see adhoc limitations that incorrectly implement the ECMA standard - I really thought that was a standard which mattered.** Come on Microsoft, this is unacceptable, you're driving valuable existing and potential programmers away from your platform and F#. See the following comments from a prominent expert F# developer with more than a decade of F# experience who helped evangelize the language since the early days https://stackoverflow.com/a/32000593 &gt; As far as I know, not possible. **This has been a disaster for Microsoft, BTW. A major client of ours wanted tens of thousands of tablets and they took Microsoft tablets off the table because they don't support F#.** https://www.reddit.com/r/Surface/comments/6u1evy/the_lack_of_net_native_support_for_f_caused/dlq8wg4/ &gt; **We trained 40 software developers at that client (in the insurance industry) to use F# and helped them to port a lot of code to F#. They had a lot of critical systems written in F# by then. Their business had a push to put the calculations onto tablets for use in the field, not necessarily networked so the F# code then needed to run on the tablets. The logical choice was to reuse the F# code which intuitively meant using Microsoft's own tablets (they were previously going to buy 10k Apple iPads when I pointed this out). I got them to put the idea on pause for a week while I researched it and, to my horror, learned that Microsoft's own Surface tablets didn't support F# at all whereas Android and iPads did.** &gt; **So they ended up buying 10k iPads and not Surface tablets because Microsoft's F# language runs better on their competitors tablets than their own.** See also comments from other developers here https://blogs.msdn.microsoft.com/dotnet/2017/08/14/f-and-net-core-roadmap-update/ &gt; **All this obsession with web stuff to write F# programs is a big turnoff to all the people I talk with. You can’t even write a simple UWP app without having to deal with yet another web framework.** This is really sad since the language is vastly superior to C#. &gt; **Apple is upping their game by pushing modern languages like Swift and the JVM has Kotlin and Scala** &gt;&gt; **F# is what made .NET bearable for us, but we’re seriously considering alternatives now that don’t include any of the Microsoft platforms or languages.** &gt; It’s great to see all those improvements, but **I’m still looking forward to see full F# support for developing UWP/.NET Native Desktop apps.** &gt;&gt; **It’s baffling that other platforms now have better F# support than Windows itself.** &gt; I have mixed feelings about this. &gt; On one hand congratulations on the work done thus far in spite of lack of support from management. &gt; On the other hand, **Microsoft not considering Visual Studio support relevant to delay the release or the ongoing lack of communication regarding UWP, isn’t a good message for F# adoption.** &gt; Agree on .net core being primarily for linux and ignorable for windows developers. .net standard though has wide-ranging advantages unrelated to linux. About UWP, yes it has minimal market share for phones, but it does have significant desktop share. If you code in Xamarin, you get a Windows 10 app for free with C#, but not with F#. &gt; While I think that cross platform support and Linux support is commendable, it shouldn’t be at the expense of Windows support, which is what is happening now. **It feels like F# has been hijacked away from Windows leaving many of us who invested in F# early on left behind.** &gt;&gt; +1 … and it get even worse – it almost seems as if Fable is the only thing going forward And here https://www.reddit.com/r/windowsphone/comments/6u1j3d/the_lack_of_net_native_support_for_f_caused/dlp655x/ &gt; **Can confirm. I really liked F# back in university. I was originally hoping that I will be able to use it when developing my WP7 apps, then WP7.5, then WP8, then WP8.1, then Windows 8.1 and then UWP apps but still it's not possible.** For WP apps the only solution was targeting very limited Portable Class Libraries that were basically unusable for any proper development. **Right now F# still does not support UWP + .NET Native and there is no light at the end of the tunnel.** https://github.com/Microsoft/visualfsharp/issues/1096#issuecomment-305949873 &gt; I found this thread tonight while **looking for information about how to build a UWP application using F# in Visual Studio Community 2017. I kept seeing lots of references to C# .NET and VB.NET for this purpose, but suspiciously F# was missing.** Which made me curious: &gt;&gt; ... CAN you build a Universal Windows Platform native application with F#? &gt; And then I found this thread. **I now regret investing any time in examining F# as a future development platform for any purpose. I'll probably never pay attention to it again, and I worry about the sincerity of any of Microsoft's future developer endeavors.** And comments here https://blogs.msdn.microsoft.com/dotnet/2017/07/24/get-started-with-f-as-a-c-developer/ &gt;&gt; Full tooling support, every single feature as VB.NET and C# have on Visual Studio. &gt; Is it your expectation that every programming language be supported across everything you can use in Visual Studio? &gt;&gt; As for .NET Core, **most of us on the enterprise hardly care about .NET Core beyond UWP**, until it gets feature parity with .NET Framework. &gt; I will challenge this position. Perhaps you’ve not seen .NET Core in your organization, but we’ve seen strong adoption and significant interest in the enterprise for .NET Core. And this also goes beyond Visual Studio tooling. Many enterprises have developer who wish to program on macOS and deploy to Linux machines. We’ve made that a priority for .NET Core, and F# is every bit as capable as C# on that front. This has also been a significant area of growth for C#, F#, and .NET as a whole. See also https://github.com/Microsoft/visualfsharp/issues/1096#issuecomment-320984143 &gt; No further news or updates on F# Support for .NET Native. There is no affinity between .NET Native, .NET Core, or VS 2017. It's an orthogonal area. &gt; There are three options: &gt; Use UWP Bridge, Deploy elsewhere than the Windows Store, Use Fable + React Native And this https://github.com/Microsoft/visualfsharp/issues/1096#issuecomment-322772826 &gt; We are pushing nearly a decade now with the same mediocre featureset with no passion or desire for improvement. **Not supporting a .NET language in a .NET technology offering is the cherry topping on the cake of fail. Taking years to pacify angry developers with empty words in the meantime is a despicable achievement.** &gt; **It is quite clear the UWP group doesn't understand .NET and the fact that one of its premiere languages has not made it to its quite mediocre platform that no one has adopted is simply unacceptable.** &gt; **This is an embarrassment! A travesty! How do you design a .NET technology but do not support .NET languages?** &gt; Does anyone over there care? Do you not understand your own technologies? And now you have prominent members of the F# community who are [officially endorsed by Microsoft](https://blogs.msdn.microsoft.com/dotnet/2017/08/14/f-and-net-core-roadmap-update/) spreading FUD against UWP and mocking UWP developers, such as this Ionide-Fsharp developer. http://archive.is/4htRV &gt; **Well, they focus on platforms that people want to use and have potential to growth... Not on the dead ones.** See more of his antics on twitter http://archive.is/c9Yks http://archive.is/rLeua http://archive.is/KPRK0 http://archive.is/JxE4i Also sad that to see prominent members of the F# community are liking those tweets. This is so disheartening, since F# used have such a great Windows friendly community back in the days. Please do the right thing, be more considerate regarding UWP devs or stay out of those discussions. **F# is a mature fully .NET compliant Microsoft language, it should be expected and a high priority to get the .NET Native UWP runtime (your main client application platform) to accept F# code.** Most people I know invested in F# with the expectation to target modern Windows without fuss and workarounds. And no, UWP Bridge and [Fable + React Native are not acceptable solutions.](https://github.com/Microsoft/visualfsharp/issues/1096#issuecomment-292921318)
Unless you need to parse arguments from the command line, you done not need to use `let main` at all.
One thing Fparsec does well is error messages. If you split lexing from parsing, you will lose that and probably have to reimplement that functionality on your own. I considered splitting parsing into lexing + parsing in my own language and decided against it because of that. In fact, the reason I considered to split parsing into two phases is because of performance. Without that reason, I would not suggest that you do it.
I mean F# is a niche language... there are many things I want from Microsoft as a C# developer, particularly in the .NET Core realm. Should they have gotten around to UWP support for F# by now? Sure, I think so. "But it's not like we're waiting for C# UWP support."
If you install the nuget package FSharp.Compiler.Tools, it should come with fsi.exe. I don't know if it will actually work, though - haven't paid much attention to .NET Core development of late. Oh, and Fable has its own REPL which definitely works on .NET Core (because all of Fable does). May or may not be a useful alternative if fsi.exe doesn't run.
&gt; .NET Native UWP (your main platform) Hahahahahaha Just to make sure I'm clear about this: UWP is not the main platform. It's a joke that nobody uses and nobody will use. .NET is focused on .NET Core and cross-platform. Windows is dying as a development platform. Don't waste time on UWP. It will be killed off in a few years. Use .NET Core and run your code in Azure. These things are actually strategically important to Microsoft, and F# works well on both.
There's a main function since some languages like C# and Java have a main function that ran upon execution. Reusing this concept make it easier to understand for those coming from the other languages. Like you said, you can make main a variable instead of a function in your example and you no longer need to call the function and have the exact same result. However, there is a difference between a value and a parameter-less function. A value run the code in it only once and the value won't change after. This mean that if main is a value, "Console.WriteLine("fib 5: {0}", (fib 5))" will run once when you run the program to get the value of main. Since Console.WriteLine doesn't return anything, main have a value of unit. Every time after, when you call main. It will just return a unit type and nothing will be printed.
I'm looking very closely as F#. This is the kind of amazing tools that push hard to adopt the language. I'm just waiting for the final release of .NET Core 2.0, will this work with that release on Linux or Mac?
UWP can be targeted by VB.NET, C#, C++ and JavaScript. Additionally by any third party that adds support for consuming and generating UWP API projections. Surely Microsoft could take F# requirements into consideration, taking into account that F# was supported on the MDIL compiler for Windows 8.x, and that support was dropped for Windows 10 and UWP. Basically if UWP is the future according to the company's official message and F# UWP support isn't relevant, that says it all about how relevant the language is for Microsoft managers.
[Not everything people do](https://www.reddit.com/r/programming/comments/6tdqmv/after_so_many_years_still_no_net_native_nor/dlk0rl6/?context=3) is run in the cloud and UWP is the recommended and main application platform for Windows going forward. And no, [Windows and UWP are not dying platforms.](https://www.windowscentral.com/windows-cshell) See also these [Unity hardware statistics](http://hwstats.unity3d.com/pc/os.html)
I'll say it again: Windows is dying as a developer platform. UWP is garbage that doesn't even work with the lion's share of Windows machines. Why do you care about F# support on this?
Stop spreading FUD. Windows and UWP are my favorite platforms.
I'll say it again then! Windows is a dying development platform. UWP is hot garbage that doesn't even work with most machines people have to deploy an application to. Why do you care about UWP? Edit: Hahahaha. Favorite platforms? Dude you are brainwashed by Microsoft marketing. Think for yourself.
I care about UWP since I want to create modern creative applications for Windows 10 tablets and 2-in-1 devices such as Surface. And no, [Windows is not a dying platform.](https://www.windowscentral.com/windows-cshell)
Godspeed, I guess. lol at this article with windows phone pics on it though
That article was testing the leaked upcoming CShell on an existing Windows Phone. MS will launch a [Surface Phone/Tablet hybrid mobile device](http://www.wpxbox.com/windows-10-cshell-platform-andromeda-might-microsofts-pursuit-extreme-mobile-devices/) next year running full blown Windows. There are now devices running Windows S that only run Store apps. There will also be new mobile ARM devices this fall [running full Windows, capable of running existing x86 apps through emulation.](https://developer.microsoft.com/en-us/windows/projects/events/build/2017/windows-10-on-arm)
I'm not holding my breath. Windows phone is as dead as their earnings reports indicate. Windows S is hilarious.
Those two things are totally different. Reason is a alternate syntax for OCaml, and fable is a JavaScript target for F#. Maybe you meant "what is the advantage of bucklescript VS fable?" In which case the question probably just comes down to "why prefer OCaml over f#?"
exactly :)
IMO right now it's hard to tell if one has any advantages over the other as both are very niche at best If you are into F# already then by all means look at Fable which probably has more packages right now. If not I would honestly look for alternatives like elm, purescript, reasonml or something safe as typescript 
I could make something up. :-)
Official information about state of .Net Core F# editor tooling - https://blogs.msdn.microsoft.com/dotnet/2017/08/14/f-and-net-core-roadmap-update/
You can look at the structure of [ProjectScaffold](http://fsprojects.github.io/ProjectScaffold/) for an example. That's what I try to follow/use at least.
Sadly, Microsoft has driven most people away from F# with their lack of UWP support. Now it seems that the only F# users left, are Windows hating web developers. Did you try talk to Microsoft about this issue? 
maybe you should add .Net Core to the caption - I know you mentioned it in the comment/text but as it is the topic itself is a bit of clickbait as F# should (hopefully) be working with VS 2017.3 including intellisense as long as you don't target .net core (so no news there). For Code/Ionide yes it's fine but there the .net core Fsi story is broken too ... so it seems we don't have a *fully* working F# ecosystem right now (Fable?)
This is pretty close to what I would've answered with. Although if you're married to React, I would give Reason a bit more weight than Fable. 
yes seems *reasonable* ;) Although if you like React then Elm and Purescript are worth a look too
I've been out of the loop on F# development for a few years now. We're still using F# for some things (mobile app, backend, web dev, analytics and consultancy). Although it isn't as slick as it could be, I still haven't seen anything better. 
*The best way to use F# and .NET Core today is in Visual Studio Code with the Ionide-FSharp extension. This should come as no surprise* -Microsoft 
Which other languages are you into these days? Btw, maybe it would be a good idea to sticky this uservoice thread top the top of the subreddit https://wpdev.uservoice.com/forums/110705-universal-windows-platform/suggestions/9110134-f-support-in-net-native-for-uwp
Fsharp for fun and profit as a PDF ebook: https://www.gitbook.com/book/swlaschin/fsharpforfunandprofit/details The Scott's new book currently in preview: https://pragprog.com/book/swdddf/domain-modeling-made-functional 
I really like F# for Fun and Profit. However, for theory a combination of - free ebook: The mostly adequate guide to functional programming in Javascript https://drboolean.gitbooks.io/mostly-adequate-guide/ - book : Functional Programming in Scala https://www.manning.com/books/functional-programming-in-scala - Podcast : Lambdacast https://m.soundcloud.com/lambda-cast I really love F#. However, I have just started looking at Haskell to understand higher types and monads. 
Full Framework on Windows is fully functional. Mono on *nix is OK (some problems with FSI on 5.0 but it's not deal breaker)
By the way - F# with .Net Core 2.0 works fine on latest update for Visual Studio for Mac.
true - as long as you stay away from VS2017 and FSI/Mono everything is ok - the nix thing is a deal breaker though - I have examples where it literally produces wrong results (random numbers/whatever was in memory) so I would not rely on F# scripting
After using VSCode almost exclusively for a year I find every "real" IDE too sluggish. I love the type signatures ionide gives you. The only thing Rider does distinctly better is [unit-tests integration](https://github.com/Microsoft/vscode/issues/9505#issuecomment-235236985).
This is not good at all. Microsoft need to step up their game in the functional domain. The JVM has Scala and it is ticking on really nicely with great tooling support. .NET core has good support for C# and perhaps also VB.NET ... That's not how you get JVM programmers over to your platform Microsoft.
That's a fantastic idea, if you build it I'm sure a lot of people would love to use it. It's still challenging to get started with F# right now. Kick off the project and link it here...
And how configure? Is not obvious how make the integration (in OSX) to work. Also, what about other kind of projects like mobile?
OP here. Would you say that F# is sufficiently 'ML'? One of my professors still uses SML, for example.
OP here. Because I use Python for most of my stuff, I think I'd like to have a strongly typed language in my repertoir. That's why I'm looking into F# and Haskell (again) at the moment to see what I lilke best. Clojure is still something I want to learn and use eventually though. I mentioned in a comment that it's mostly for learning FP but if I can start using it for my studies or hobby projects (which are still *mostly* going to be AI/ML/Comp.ling) then it's ideal. But in general I have Python for that.
Thanks for posting it here as well.
Rider is awesome, but not free(i'm not sure that this JB politics is good, it would be better if they include rider to resharper package) So, VSCode pretty good, but Rider provides better refactoring\debugging\unit tests and other real-ide staff, and works better with other languages. Why you don't suppose visual studio? 
The Ionide plugin already does this today (one package for all F# stuff), but it doesn't work on .NET Core today. I'm pretty sure that's because, like the large majority of existing .NET code today, the underlying dependencies haven't been ported to .NET Core.
As an F# on Mac I really appreciate any answer here because I also don't understand, nor do I know if this will take a long time or not to understand how to approach multi platform F# with .NET Core 2.0
But you still have to install ionide and i guess configure it. Im thinking of a bundle with vscode and ionide installed by default. For simplicity for newbies . In a perfect world you would just have one installer for vscode ionide and .NET core so that newbies hade a short path to success. Today's kids don't have time to install and configure things. They want instant gratification 
It seems like typeproviders have very different dependencies. How about splitting them up in to different dlls for each typprovider. (That might already be the case )
Visual Studio Community is a choice as well.
I wonder what "better refactorings" Rider provides for F# :-) Also debugging in VSCode is fine. 
But I would like to use them from .net core Although, could I write a dll targeting .net 4.6 with a type provide, and then reference it from .net core? If I understood the release notes for .net standard 2 correctly, this should work
It's just out, the team probably needs more time to make the necessary changes. Just have patience.
I think that pre-build bundles would be great. It's such a pity that we don't have ability to use different bundles for different development workflows and have to load tons of plugins to one instance of VS or Atom. 
Main is normally executed for its side-effects (reading files, writing output, etc). Executing side-effects while computing a value is not normally something you desire – they make it harder to reason about code. Another thing is that you can execute a function multiple times, but when you only have a value you don't have any way to recompute it. Edit (expanded): Sure, it *works* to have `main` be a value since you only ever want it called once (and you aren't going to be invoking it from other code so side-effects don't matter), but for consistency with good design in "normal" code, it's best to be a function.
Older thread: https://www.reddit.com/r/fsharp/comments/5qkdl1/is_anyone_using_postgresql_with_dotnet_core_in_f/ An ORM for now.
I get that. I'm just wondering what still needs to be done. Trying to educating myself a little on this topic
No, you can't reference a net46 assembly from .NET Core. You can reference a netstandard20 assembly from either .NET 4.6 or .NET Core 2.0. What *can* be done, however, is to run the F# compiler on .NET 4.6 to produce a netstandard20 or netcore20 assembly, essentially doing cross-compilation. This allows using erased type providers (I think there's a link somewhere on this sub on how to do that). No luck yet for generative type providers though.
https://blogs.msdn.microsoft.com/dotnet/2017/08/14/announcing-net-standard-2-0/ The .NET Framework compatibility mode section states that I can reference net46 packages. Also, that was my other question. What's the difference between erasing and generative type provides?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/microsoft] [The lack of .NET Native support for F# caused Microsoft to lose a big order of Surface tablets and has driven valuable developers away from Windows and UWP, something needs to be done now](https://np.reddit.com/r/microsoft/comments/6u1o61/the_lack_of_net_native_support_for_f_caused/) - [/r/surface] [The lack of .NET Native support for F# caused Microsoft to lose a big order of Surface tablets and has driven valuable developers away from Windows and UWP, something needs to be done now](https://np.reddit.com/r/Surface/comments/6u1evy/the_lack_of_net_native_support_for_f_caused/) - [/r/windows10] [The lack of .NET Native support for F# has driven valuable developers away from Windows and UWP, something needs to be done now](https://np.reddit.com/r/Windows10/comments/6u0gu0/the_lack_of_net_native_support_for_f_has_driven/) - [/r/windowsinsiders] [The lack of .NET Native support for F# has driven valuable developers away from Windows and UWP, something needs to be done now](https://np.reddit.com/r/windowsinsiders/comments/6u0bmg/the_lack_of_net_native_support_for_f_has_driven/) - [/r/windowsphone] [The lack of .NET Native support for F# caused Microsoft to lose a big order of Surface tablets and has driven valuable developers away from Windows and UWP, something needs to be done now](https://np.reddit.com/r/windowsphone/comments/6u1j3d/the_lack_of_net_native_support_for_f_caused/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Oh, I wasn't aware of this compatibility mode, that's interesting. Erasing type providers don't create .NET types; instead, every call to a provided method is compiled to inline code. For example, the JSON and XML type providers are erased. On the other hand, generative providers do create actual .NET types, and calls to methods on them are compiled into actual method calls. SqlDataConnection and SqlEntityConnection, for example, are generative.
Still F# and OCaml but I'm mostly doing non-programming now. 
&gt; if UWP is the future according to the company's official message Is it?
So, the reason it's not done yet can be found [here](https://github.com/Microsoft/visualfsharp/issues/2400). &gt; Type Providers and Codegen from Quotations are not supported due to changes made in reflection APIs for .NET Core. These will be in .NET Core 2.0+ timeframe. That sounds to me they were mostly waiting for the release to see what apis they would have available. And the .NET Standard reflection apis might be a little different from the full framework, so that would mean some rework. They probably say 2.0+ because (at the time of writing at least) they weren't sure if the .NET Standard would implement all of the api's they needed.
I guess you have been missing out the BUILD 2015, 2016, 2017, Windows Dev Blogs, Microsoft Virtual Academy, HoloLens, XBox ONE UWP upgrade, Surface devices, Windows 10S, ....
Alright. Thanks. I hope it comes soon. I would contribute if I was anywhere near good enough for this stuff. But alas I am not.
Ok. That gives a nice overview. Thanks
Don't forget .NET Native support which is non-existent now.
I think entity framework could also be an option in addition to that other thread
I have a soft spot for ocaml, but I doubt the cool stuff is exclusive to ocaml. Porting Kiselyov's delcc to f# should be pretty straightforward, even though it might not be thread safe.
&gt; Generative Type Providers are still unsupported on .NET Core and have no workaround at this time. How problematic is this for widely used packages? Are the type providers used for SQL erasing or generative?
How will UWP replace traditional desktop apps?
I'd definitely go with Dapper in the interim. It works fine with F# records. Really, even with things like the SqlProvider, I only ever used to compile-time query type checking as validation. 
&gt; Our goal is to move you away from specifying assemblies on disk and towards referencing a package by name and optional version. That may look like this: #r "nuget: Newtonsoft.Json" // Using NuGet #r "paket: Newtonstoft.Json &gt;= 9.1.0" // Using paket This will be the killer feature of F# scripting.. just check in the script and no fiddling with dll's.. Groovy has it with Grape and it workd awesomly so having this in F# will rock.. im totally worked up right now.. need to sit down :-)
By turning desktop apps into UWP apps and releasing Windows versions like Windows 10S. https://docs.microsoft.com/en-us/windows/uwp/porting/desktop-to-uwp-root The next versions of Office, Adobe XD, SONAR, Kodi for Windows 10 are going to be UWP only as announced at BUILD 2017. Take it a few years, and legacy desktop apps will join Win16 compatibility graveyard, dropped on Win64 versions.
generative :(
Great. Maybe less magic or sophisticated but totally reasonable. Thank you
The problem is that every UWP app has less functionality and requires more clicks to access functions. It is not suitable for desktop usage at all. A good example is Code Writer. It takes 4 clicks to open a new file. It took me a while to figure that out too. I'm interested to see what Office or Photoshop will look like without a menu bar. What about Visual Studio? A "real" piece of software, with complex functions. How will that ever be ported to UWP? You can't just delete all the functions and make 5 tiles. Office is already a nightmare with their UI. I can't even see what the keyboard shortcuts are anymore. I remember when software speed up my work by giving me shallow menus and encouraging keyboard shortcuts. Yea, not everybody uses them, but I can't think of what they are doing as anything other than dumbing it down. In order for software to remain useful, it needs to maintain a certain level of complexity. You can't just reduce the complexity be removing features, you need to manage the complexity. If Windows keep going down this road they are going to lose so many enterprise customers. Do you think my boss wants to click some stupid tiles when he's interacting with my analysis tools? After using a mac as my main machine for a few years, I am throughly disappointed with windows. The Edge browser is horrible, the navigation is horrible. Half the menus are UWP, half are old WPF or WinForms based. What a mess. Mac doesn't do everything right, and the hardware is overpriced as hell, but at least I can intuitively access the functionality I need, and the functionality is usually there. Not the mention a uselful shell. Windows command prompt doesn't even compare. I'm making some WPF apps now, but I don't think I will go onto UWP. I'm just going to start developing on my mac once swift is more developed or even linux. Even though I find the .NET documentation much better than the mac and linux documentation.
Amazing. Transforming records to some more elaborate domain type I define would be very simple so this is great. Any particular reason why you prefer Dapper vs some alternative?
&gt; On the other hand, Microsoft not considering Visual Studio support relevant to delay the release or the ongoing lack of communication regarding UWP, isn’t a good message for F# adoption. Sorry, but this is complete bullshit. I really love F#, it might be my favorite language, but F# is not popular enough to hold back a release on Visual Studio, one of the major IDEs. Especially if Visual Studio Code + Ionide is better than Visual Studio ever was. &gt; While I think that cross platform support and Linux support is commendable, it shouldn’t be at the expense of Windows support, which is what is happening now. It feels like F# has been hijacked away from Windows leaving many of us who invested in F# early on left behind. How is it "at the expense of", F# still works like it always did on Windows. Honestly, all this stuff is quite hard to take serious with so much hyperbole put in. Remove it, and you're left with maybe 1 real complaint, namely no UWP support. But even then I'm confused on why they choose to learn F# to build UWP apps when there's no official support yet. Where F# really shines, imo, is for web programming and data analysis. Guess where the people are who are doing that? Yes, Linux. Getting F# on Linux was much more important than UWP, no matter how much I love UWP. The personal attacks on the developers are unwarranted and unnecessary as well. Leave that shit out if you want to be taken serious.
&gt; one of the major IDEs. Especially if Visual Studio Code + Ionide is better than Visual Studio ever was. If VS Code is better, then where is the DirectX Graphics Debugger? Also its intellisense is worse. As I said before, not every F# developer is a data analyst, targets the web or simple mobile apps, so VS Code is not better for many. &gt; How is it "at the expense of", F# still works like it always did on Windows. F# used to always work on Microsoft's primary .NET client application platforms, which is .NET Native + UWP right now. &gt; Remove it, and you're left with maybe 1 real complaint, namely no UWP support. But even then I'm confused on why they choose to learn F# to build UWP apps when there's no official support yet. Many people chose to learn F# almost a decade ago, when Microsoft promised that F# would be a first-class .NET language with proper support. Lots of code has been written that people want to port to .NET Native + UWP. &gt; Where F# really shines, imo, is for web programming and data analysis. Guess where the people are who are doing that? Yes, Linux. Getting F# on Linux was much more important than UWP, no matter how much I love UWP. Nonsense, F# isn't just good for data analysis and web programming. It's a modern multi-paradigm language that's capable of much more. [Pigeonholing F#](https://news.ycombinator.com/item?id=15029220) to certain roles [has been damaging to the uptake of the language.](https://www.reddit.com/r/fsharp/comments/6u8b05/the_problem_with_f_evangelism/dlrut8v/) No amount of [evangelizing](https://news.ycombinator.com/item?id=15027695) is going to improve the situation. F# is the best multi-paradigm .NET language for Windows, but it's not the best multi-paradigm language in general. There are also better alternatives for data analysis and web programming on other platforms. &gt; The personal attacks on the developers are unwarranted and unnecessary as well. Leave that shit out if you want to be taken serious. I got multiple times personally attacked and mocked by that dev and his friends in the F# community for asking about UWP support. I'm just stating what's happening here.
Nothing in UWP is stopping you from building a GUI like Photoshop, Office or Visual Studio. You can build any GUI you want, with whatever style you want. &gt; Yea, not everybody uses them, but I can't think of what they are doing as anything other than dumbing it down. In order for software to remain useful, it needs to maintain a certain level of complexity. You can't just reduce the complexity be removing features, you need to manage the complexity. This smells like bullshit. Complexity for the sake of complexity is seriously unnecessary.
I like it because * it's lightweight: just SQL + result mapping back to a structure you provide * it's low-dependency: operates on any ADO.Net data source * there's no hidden abstraction layer that I don't understand
&gt; And, no F# isn't just good for data analysis and web programming. I never said it was only that, but those are the areas it shines in. It's especially promoted for data analysis (atleast when I started using it). &gt; I got multiple times personally attacked and mocked by that dev and his friends in the F# community for asking about UWP support. Don't care, stay above it. I was also more pointing at sentences like this: &gt; I've seen some people joke on here and on a few blogs now that this group does nothing but play Halo all day. While funny, I am starting to think there is some merit to it. &gt; The only thing more shocking is that those who continue to butcher the vision of .NET are still employed and continue to make a paycheck doing it. &gt; Does anyone over there care? Do you not understand your own technologies? Truly a drop in talent and passion in this group. And then there's whining like: &gt; It’s baffling that other platforms now have better F# support than Windows itself. Look man, I get the frustration, but I'm not gonna take this whiny shit serious. Make your point clear, concise, and with good arguments on why it should be different, and why it should be given more priority. THEN people can give you a serious answer.
&gt; This smells like bullshit. Complexity for the sake of complexity is seriously unnecessary. I never said we should have complexity for the sake of complexity. I said useful software is complex. Look at a c++ compiler. Look at an OS. I could make an Windows a lot simpler, let's just get rid of paging and use dynamic relocation. Actually, let's go a step further and get rid of virtual memory. I just reduced windows' code base by a couple hundred thousand lines of code or more. I mean your computer is going to crash every time a program has a memory bug, but who cares. It's simple now. When we try to get rid of the complexity we also lose some functionality, it's a trade off. I think UWP is sacrificing too much functionality and usability in order to reduce complexity. Only time will tell if they made the right bet. As a person who likes to use useful software, I hope they are wrong.
&gt; I never said it was only that, but those are the areas it shines in. It's especially promoted for data analysis (atleast when I started using it). And the way it's promoted is wrong as has been demonstrated for a decade now. &gt; Don't care, stay above it. I was also more pointing at sentences like this: I was just quoting the frustration of developers, I now edited out the offending parts. &gt; Look man, I get the frustration, but I'm not gonna take this whiny shit serious. Make your point clear, concise, and with good arguments on why it should be different, and why it should be given more priority. THEN people can give you a serious answer. It's not whiny shit, F# started out as a .NET language on Windows and the reason many chose F# back in the days was to finally have a modern language with proper tooling and library support on Windows without fuss, I would have never thought that the situation could get any worse 10 years later. Back then you could at least target the main Windows platforms natively. 
Adobe XD is a full blown UWP creative app for the desktop. http://www.adobe.com/products/experience-design.html https://channel9.msdn.com/Events/Build/2017/T6114-R1
&gt; I never said we should have complexity for the sake of complexity. I said useful software is complex. Look at a c++ compiler. Look at an OS. Useful software is not necessarily complex. Notepad is pretty small and almost trivial, yet insanely useful. &gt; When we try to get rid of the complexity we also lose some functionality, it's a trade off. Depends on how you define complexity. You can definitely make things less complex without removing functionality that is visible to the user. Just look at any legacy system. UI wise same. Just because people know the old UI, doesn't mean a new GUI can't be less complex with the same amount of features. &gt; As a person who likes to use useful software, I hope they are wrong. 90% of the current windows and mobile applications can be easily done in UWP without sacrificing features technically. So I'm not sure where you're critique is coming from. UWP does not prevent you at all, in any way, from making complex GUIs if you want to.
&gt; I would have never thought that the situation could get any worse 10 years later. It didn't get worse. It works still like it always did. &gt; It's not whiny shit The way you make your point comes across as a whiny kid in the store wanting candy. Again, how you make your point matters. Mutual understanding matters. If you want to be understood, start by understanding that Microsoft is just another IT company with deadlines, priorities, resources, and roadmaps. Developing a feature costs time, money and energy and means another feature gets delayed. This doesn't magically go away just because it's Microsoft and they have a lot of it. So if you want this feature, you have to convince them it's worth doing instead of all the other work that's happening on UWP.
Exactly what I was looking for for. This is the ideal simplicity for me. Thank you.
&gt; Useful software is not necessarily complex By useful, I mean that it helps you accomplish a difficult task. I don't consider reading and storing text input that complicated. Maybe it's just my experience, but every time my users ask for a new feature, my code base becomes more complex. It never gets less complex. &gt; UWP does not prevent you at all, in any way, from making complex GUIs if you want to. Maybe, I will have to make some UWP apps when I have some free time. I just haven't seen any that I like yet.
Not sure. Seems like it's missing a lot of features from previous editions. Or they are buried somewhere behind the UI.
&gt; Maybe, I will have to make some UWP apps when I have some free time. I just haven't seen any that I like yet. Probably because most follow the general design guidelines MS laid out, which is a good thing if you want uniformity. There's nothing stopping you from not following those. I don't think complexity in features or code has to translate to a complex UX. That was sort of the case in the 90s and 00s, but since then we've learned a lot about what good UX is and what isn't. Usually people point to the information density, or less on screen, and while that may be fine for tech savvy people, for most other people, the less you can put on screen, the better. Yes, it is dumbing down in a way, but that's not a bad thing imo.
As an update, dapper has been working really well for my needs.
&gt; It didn't get worse. It works still like it always did. F# used to always natively work on **Microsoft's primary .NET client application platform.** Since 2015 this is **.NET Native + UWP** and F# still doesn't work on it. 
Thank you, I'll check it out to see how it compares to Dapper.
Which previous editions? This is how the app is, on macOS too... 
I second the Dapper suggestion. If you need a F# specific example of Dapper, this might help http://www.codesuji.com/2017/07/29/F-and-Dapper/#more
Right, there are also a couple of other factors such as compile speed, output JS quality, ease and power of the JS bindings syntax, and finally the size and volume of activity of the community/ecosystem.
https://news.ycombinator.com/item?id=15029510 &gt;I built Tsunami IDE. It is a F# IDE. I built it before VSCode or VS Community came out. I built it as a test to see if cost of Visual Studio was blocking adoption of F# and the ideas that F# codifies. The experiment was successful, I got my answer, and the answer is no. Even with free tools people have a hard time adopting F#. First let me address those who are asking for Type Classes and Dependent Types. These would make the compiler too slow. The F# compiler works in the 100s of ms and the 100s of MBs ram. Where Scala is in the 1000s of seconds and the GBs of ram. People will give up on code completion if it takes more than 500ms and they generally don't like waiting longer than 200ms. Separately Martin Odersky (the creator of Scala) laments that the more advanced language features attracted the wrong type of people to the language and flooded the internet with overly academic tutorials. I put a lot of the blame for the lack of F# adoption on Microsoft. Part of this is to do with the Dev Div vs Windows war that almost deprecated the whole .Net ecosystem. If Windows 8 wasn't such a disaster it's likely .Net would have been deprecated and would never had been open sourced. (at least something good came from Windows 8). Part of this war also ended with a lot of the best .Net people leaving to go to Facebook. This brain drain has really hurt Microsoft and I doubt they'll ever recover. Most of the old hands that know better are aging out and the new people at Microsoft don't know any better. As for tooling, Microsoft has done and continues to do a bad job with F# tooling. There is is a not invented here culture at Microsoft Redmond which includes being hostile to Microsoft Research. Visual Studio is a bucket of bandaids and it takes an army of people just to keep it going. F# is given a low priority. It's worse with the latest release because they've gone overboard with compiler features with the Rosario release and have made it dog slow and painful to use. I hope they can fix it with updates but who knows. You can still get older versions. It's very possible to build a really good IDE around the F# compiler but unfortunately Microsoft refuses to do so. Thankfully, it looks like there are some good alternatives becoming available. In comparing Scala and F# adoption, Scala has Hadoop/Spark which is a killer product that can earn a consultant a lot of money. The fact that C# is a better language that Java means there are more Java refugees going to Scala than there are C# refugees going to F#. Thankfully Don Syme has made F# completely open source. Now with .Net being open source we no longer have to worry about Microsoft shooting itself in the foot again. I make my money writing a product written in F# and can attest that F# is one of my big competitive advantages. I highly recommend it.
Von wo kommen die Grüßen?
**Edit:** highlighted text un-highlighted (Note: I somehow can't log into my "phillipcarter" account...) &gt; There is is a not invented here culture at Microsoft Redmond which includes being hostile to Microsoft Research. I typically refrain from commenting on things over here and on HackerNews, mostly because I feel that this is a space for the community to discuss and work things out, but what you've highlighted from that comment is not based on reality. MSR (and Don) work together with different groups in Azure and and the developer division. It's not perfect - we are a large, multinational corporation with the same problems in communication across organizations as any large, multinational corporation - but calling the relationship hostile is misleading, harmful to the F# community, harmful to those of us who work on F#, and harmful to F# growth. I really don't appreciate spreading this sort of stuff.
Grüße zurück ;-):
Noch eins aus Bremen!
you don't get type inference with DT anyway ... (if you do you found the silver bullet ... at this point the program will probably write itself) yes we can argue if we actually need (or should want) a more advanced type system - but people already mess with SRTP, type providers, etc. to *simulate* those features (heck many actually try to write some sort of IO monad ...) so IMO better have it for real with nice(r) syntax at least Ocaml-Functors would be a great addition that actually would give something on top of TPs to make F# a more interesting choice for FPers Right now IMO if you are a C# dev you should try F# as an introduction to FP - but if you already know FP or if you are on another platform then it's probably not worth your time as there are more than enough other alternatives. Never thought I would come to this but right now the communities mood is somewhat self-destructing (and yes I feel that too)
&gt; or if you are on another platform then it's probably not worth your time as there are more than enough other alternatives. This, exactly.
https://news.ycombinator.com/item?id=15028583 &gt; I lost faith in F# the moment Microsoft decided it is not worthwhile to delay Visual Studio 15.3 to properly support it pushing devs to VSCode, and **the lack of roadmap for .NET Native/UWP. So first make F# a first class citzen on .NET and maybe many C# devs will look again to it.** https://news.ycombinator.com/item?id=15029220 &gt; Microsoft promoted this idea that F# is for mathematicians and engineers, so its no wonder that people pick this up. **And I'm not sure who is pushing this idea that F# is not fine for OO work. It has all those features. So starting with F# as a "better C#" -- there's nothing wrong with that.** Over time I think people will come to view OO as suboptimal, but in the mean time F# is just a better language to use than C#. **MS hasn't funded F# enough, and has crippled the marketing on it to continue to push C# rather than admit they've made mistakes. The tooling issues and other random incompatibilities are why I don't use it as much as I used to - it's too much friction.** https://www.reddit.com/r/fsharp/comments/24layv/where_are_the_f_jobs/chdypvs/ &gt;&gt; The message I think people get is: "F# is for hard stuff. You can't really use it for easy stuff." &gt;**Yes. That is the message for political reasons. If F# were considered to be the general purpose language (that we all know it really is)** then it would be competing internally with C# and that would make for negative energy. So F# is relegated to DSL status. **The main destructive consequence is that F# does not get equal visibility.** When Microsoft first released it in Visual Studio 2010 it was not even mentioned on any of the comparison charts. https://www.reddit.com/r/fsharp/comments/24layv/where_are_the_f_jobs/chdy7li/ &gt;Two years ago we were getting so many offers of F# consultancy that we had to turn people down. Beginning of last year I was trying to land our first £1M deal. After that fell through F# started to dry up for us. This year we haven't had a single consultancy contract, product sales have dried up and we're diversifying away from F# in a hunt for sustainable revenue after 7 years of F#. Several other big names in F# have also left. [Zach Bray did fantastic work at Trayport](http://zbray.com/2011/11/02/solving-the-0-1-knapsack-problem-using-continuation-passing-style-with-memoization-in-f/) but is now working full-time on C# for the money. Phil Trelford just left Trayport too. &gt; **In 2007, Microsoft promised F# would be a ["first-class language on .NET"](http://blogs.msdn.com/b/somasegar/archive/2007/10/17/f-a-functional-programming-language.aspx). So what happened?** Well, when F# saw its first full release in April 2010 as part of VS 2010 we braced ourselves for a flurry of orders. In fact, for two weeks after the release we didn't sell a single F#-related product. Why? Because Microsoft gave F# no visibility whatsoever. No mention of F# on the VS box. No mention on the language comparison table (just VB and C#). That was a sign of things to come. Even today the VS sales page says [**"C#, VB.NET, C++, HTML, JavaScript, XAML, SQL and more"**](http://www.visualstudio.com/explore/ide-vs) and F# is not mentioned anywhere (!). F# is growing so slowly that you'd barely know it. According to IT Jobs Watch the percentage of technical jobs in the UK mentioning F# has increased by 0.3% over the past 5 years. And F# is bigger in the UK than almost any other country in the world. &gt; **Instead of going deep on the Windows stack, Microsoft went wide with F# by trying to support Linux, Mac OS, iOS, Android and many other architectures and platforms. The result has been a disaster: non-Windows F# has a tiny number of users and F# never worked on Microsoft's Surface RT tablet. Microsoft asked the community what they wanted on user voice and they voted overwhelmingly for basic tooling like rename refactor but Microsoft instead gave us type providers.** I've tried to write articles about F# type providers several times but I find them almost impossible to use. I tried to access Google with them and they crash repeatedly. I tried to access Amazon with them and they crash repeatedly. Most of them were lashed together by interns and are based on undocumented heuristics that only work in a handful of example cases. I have never seen them used in a commercial code base. https://www.reddit.com/r/fsharp/comments/24layv/where_are_the_f_jobs/ch8gphn/ &gt; One problem that's frustrated me for a while is that F# doesn't get quite the support that C# and VB do. You can't use it to build an MVC website, without bringing in some C#. You can't use it in SSIS packages, although it seems like a functional language would be perfect in that application. I bet there are other examples. The message I think people get is: "F# is for hard stuff. You can't really use it for easy stuff." And a lot of our work isn't that hard, and if we have to use another language for the easy stuff anyway, might as well use it for everything. You have to balance the cost of using two languages against the cost of a minority of the work taking more lines of code. The few companies that do lots of F# are companies really focused on hard stuff. **If we could use F# everywhere we use C#, and Microsoft promoted it as simply a good language instead of just a good language for hard stuff, then we might see a different picture.** https://www.reddit.com/r/fsharp/comments/652sin/what_are_the_worst_parts_of_f/dg8ur15/ &gt; **If MS doesn't put some power behind F# soon its going to have a hard time competing with Scala and then ultimately the Java echo system.** C# has a smaller community than Java and F# has a much smaller community than Scala. C# is going to grow in popularity thanks to .NET core **but if MS want to attract the best developers they have to put more effort in to F#.** **Ex: Make F# a first class citizen of .NET and visual studio.** **Microsoft: .NET Core is awesome but to attract the best programmers you have to put some more effort in to F#!! Or make Scala a 1st class citizen on .NET.** 
VB.NET isn't exactly a first class language anymore either. There is some support for it, but only as an afterthought. 
It's first-class enough that you can write UWP software with .NET Native without any fuss.
You could have addressed this on the HackerNews thread yesterday, since you were actively responding to other comments there already.
**Edit:** highlighted text un-highlighted Like the many emails that I simply don't get around to responding to, this also escaped my grasp yesterday. Damage done, even though I've since replied. Nobody can hunt down this sort of stuff all the time. I see that you've kept this post up, still highlighting the damaging text. What is the goal you have in mind by highlighting that statement?
&gt;you don't get type inference with DT anyway ... (if you do you found the silver bullet ... at this point the program will probably write itself) Coq has surprisingly nice type inference. It's not complete, but the holes are few and far between.
I un-highlighted the text. That said, could you do something about the damaging anti-UWP messages from F# community members, and advice them to stay out of any .NET Native / UWP discussion? https://github.com/Microsoft/visualfsharp/issues/1096 Since it seems that they have no interest in seeing UWP thriving anyway. 
Thanks. I'll reply back to that thread with something.
Thanks, but I mean not just that thread, but in general. 
same with Scala I guess - you know this puristic math stuff: it's all or nothing
I liked this post. Enthusiasm can be really offputting when it turns into unwarranted evangelism. &gt; Race Conditions in multithreading environments: Accessing an element you were sure is contained in a list, but now is not (anymore). This isn't really a race condition, is it?
do where are you "diversifying"? Scala? Ocaml? I'm still hoping for Haskell but that'll probably never happen.
let's say you have a producer that fills the list and one that will check for it - so you are dependent on the order of execution - IMO that's more or less exactly the definition of a race condition - so I guess this can be a race condition
I read some things about Ocaml that I found strange, mostly concerning not having operator overloading resulting in loads of +., /., etc. and something about a split standard library?
I strongly disagree that Scala has nice type inference, in particular it's 100% local and hence underwhelming.
I never said nice .... indeed my personal opinion on that matter is quite different ... but it was about "surprisingly nice type inference" and IMO you can say that about scala as well, given the tradeoffs it make in it's type system
True, especially the part saying that C# is good enough for a lot of use cases. Kotlin seems to have a lot mof traction because, I think, Java is less good than C# overall and the switch from Java to Kotlin seems to bring enough benefits to the table to worth the change.
If you want to investigate Entity Framework Core, here's the docs from Microsoft: https://docs.microsoft.com/en-us/ef/core/
According to those factors what do you prefer?
I'm biased, because I hang out in OCaml/Reason forums, but from what I've seen we really do have those things going for us with Reason/BuckleScript.
&gt; First let me address those who are asking for Type Classes and Dependent Types. These would make the compiler too slow. It is a bit strange to put these two in the same bag as they are so different. Dependent types would make the compiler slow, that is true, but currently they are a very experimental, heavy feature only a few languages support for general purpose programming and it is questionable whether they are even suited for that. What people usually ask in this context are higher kinded types which are much lighter as a feature. I am not convinced that type classes and higher kindeds would make the compiler particularly slower unless someone on the F# team can tell me otherwise. The reason why F# has not added HKTs in particular is because it would require an extension to the CLR and work on typeclasses is being experimented on. Despite what the post says, F# probably has the best tooling out of any functional language. I am not sure what the situation is on Linux, but there is really no reason not to use Visual Studio on Windows as it is very good.
I agree with you on the language features, but the tooling and most importantly, platform support (.NET Native/UWP) pales in comparison to C# and VB.NET, and this is the biggest reason why F# is not as popular as it could be.
Wow, I had never even heard of "Windows S". 
Believe me, I hear you. I would have loved to write apps for the Windows Store and help build Microsoft's platform for them and get them a less embarrassing market share. But the fact is, Microsoft completely lost their way when Bill Gates stepped down. They made massive error after massive error and will probably never recover now. When it comes to mobile and embedded they are literally a laughing stock. The whole internal shift of power from DevDiv to WinDev and the emphasis on languages like C++ and the [prophecy of a C++ renaissance](http://flyingfrogblog.blogspot.com/2012/01/c-renaissance.html) was such a joke. However, after 10 years of pointing such things out to Microsoft I think it is time to cut your losses. This just isn't going to happen. Use what is on offer and forget about the rest. F# is fine on standard .NET on Windows and on Android thanks to Xamarin. Anything else like native is a complete write off. 
Not an issue at all. Primitive and reusable stuff is listed first, specific and complex code is at the bottom. Looking at a C# project I have no idea what place a file has. The name of the file is often not so informative. Well-designed software is built in layers. Software where components have lots of circular dependencies is spaghetti code. 
As the fsharpforfunandprofit tutorial says, you can actually think of this as a language feature that prevents cycles. The other benefit is that you can read the code from bottom to top. That said, there are a few escape hatches: FSI signature files allow members in a module to be declared ahead of time (I think). You can also declare "mutually referential" types and values using the `and`keyword. Finally, F# 4.1 has a feature to make an entire file mutually referential. I generally prefer not to use the mutually referential keywords, however, unless there's a really compelling reason. Coming from a Java/C# background, F#'s file ordering freaked me out too at first. It took a little while to learn how to organize the code this way, but once it got the hang of it, it feels pretty natural. Now, it's large C# projects that freak me out. Here's some recommended reading on the subject: https://fsharpforfunandprofit.com/series/dependency-cycles.html
Significant file ordering absolutely helps make a large project more legible, and I dearly miss it when I'm not writing F#.
I think I should just be patient and be content with what's out there already. That said, things like this and the lack of abstraction capabilities like functors, or type classes makes me seriously think about abandoning F#. Soon, even mainstream web dev will be done in more sophisticated languages like OCaml in the form of ReasonML. Btw, what are your thoughts on F*, Idris, Rust, ReasonML, Scala Dotty and Scala Native?
Yep, once you get used to it, it makes perfect sense and is just another way F# guides you into the pit of success. Doesn't stop C# programmers from looking at you like you've got two heads when you try to explain it to them, though 
I'd say that this "feature" is even more helpful for larger projects. It forces you to think about your design ("Do I really need this extra dependency between those two classes?") and leads to a cleaner codebase overall. Definitely one of my favourite things in F#, even though it seemed weird to me too at the beginning, coming from C#.
&gt; Btw, what are your thoughts on F*, Idris, Rust, ReasonML, Scala Dotty and Scala Native? AFAIK, F* is too obscure to have serious support in the form of IDE integration. I haven't looked at Idris but purity is crippling for general purpose programming. Perhaps for web dev it might be ok. I had a play with Rust and found it to be seriously underwhelming. Lack of GC is really crippling. Performance isn't very good because the core data structures (of which there are very few anyway because most are intractable without GC) are designed for crypto-level security and not general programming. Isn't ReasonML just Facebook's OCaml with a face lift? If so, it fails to solve any of OCaml's serious problems. I've played with Scala a few times too and found it to be a rather ugly language with a really poor quality tool chain. The IDE integration was awful compared to F# in VS2015. So Scala Native doesn't excite me in the least. In essence, Scala fails to capitalize on the productivity of ML because it lacks proper type inference. 
&gt; I haven't looked at Idris but purity is crippling for general purpose programming. Perhaps for web dev it might be ok. http://docs.idris-lang.org/en/latest/reference/uniqueness-types.html &gt; Isn't ReasonML just Facebook's OCaml with a face lift? If so, it fails to solve any of OCaml's serious problems. It being backed by Facebook might help solve its serious problems. 
&gt; http://docs.idris-lang.org/en/latest/reference/uniqueness-types.html My personal feeling is that less-is-more at this point with programming languages. The biggest challenge I've faced teaching these languages to industrial developers is confusion about advanced features. Frankly, the vast majority of advanced features could be scrapped and the resulting language would still be fine for almost all applications. You could even improve some things with specialization. For example, people use lists as a data structure in F# even though they're rarely the right tool for the job just because they have a nice `[]`, `x::xs` syntax but that is a special case for lists (which are the wrong tool for the job most of the time) and more useful collections like arrays have few such special features. What is the current state of Idris' GC? &gt; It being backed by Facebook might help solve its serious problems. That's what everyone thought but when I checked it out I found it seriously underwhelming. They aren't even attempting to address any of OCaml's main problems. All the changes they've made are entirely superficial and aren't even objective improvements. Changing the syntax probably broke the entire dev toolstack too... 
&gt; My personal feeling is that less-is-more at this point with programming languages. The biggest challenge I've faced teaching these languages to industrial developers is confusion about advanced features. Frankly, the vast majority of advanced features could be scrapped and the resulting language would still be fine for almost all applications. I agree, but with small competent teams it's less of an issue. When using F#, I always feel constrained by the lack of abstraction capabilities, resulting in too much repeated code. The insistence of clean 2-way .NET interop seriously crippled the language and what did F# get in return for that favor after all those years? It's still considered a 2nd class citizen. My patience is wearing thin, It's time for me to look for alternatives now. &gt; For example, people use lists as a data structure in F# even though they're rarely the right tool for the job just because they have a nice [], x::xs syntax but that is a special case for lists Agreed, and that's why I admire languages like Scala, where things like List aren't given special status. In Scala you could implement your own collections with any nice syntax you want. &gt; What is the current state of Idris' GC? Probably the same as Haskell's. &gt; That's what everyone thought but when I checked it out I found it seriously underwhelming. They aren't even attempting to address any of OCaml's main problems. All the changes they've made are entirely superficial and aren't even objective improvements. Maybe give it some time until it reaches critical mass. 
The F# part https://youtu.be/ybSBCVhVWs8?t=952
Video linked by /u/TensorMetric: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Functional Programming and Modern DevOps: Aaron Contorer](https://youtu.be/ybSBCVhVWs8?t=1024)|FP Complete|2017-08-11|1:04:50|29+ (93%)|1,171 &gt; This live talk was presented by our CEO, Aaron Contorer,... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/TensorMetric ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=dlyif1b\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v1.1.3b
&gt; F# was informed directly by Haskell This guy clearly did his homework. &gt; F# is not becoming popular ... so that would be what you look at on .net Thanks for the mention? 
Yeah this guy sounds like he has no clue what he's talking about
It is fairly annoying, but compared to other C# vs F# issues, it isn't something you think about too much in a bigger project. A few things that are more problematic: - Difficulty using folders for organization in Visual Studio (slightly more annoying than the file ordering) - Really bad handling of default parameters for functions, and then still tedious to use from C# - Async vs Task - FSI being unusable a lot of the time (binding redirect problems, namespace problems, etc) Some people think is a good thing because it can make boundaries easier to reason about, but given the downsides, I think they probably have not tried a programming environment that doesn't change the project file every time you add a file. That said, I still think F# is absolutely worth it. I mean just look at some of the code comparisons with C# and F# side by side.
You could just use System.Type.IsEnum (e.g. "x.GetType().IsEnum")
That works as I specified the problem originally (I've reworded it now). What I should have said was that once I know it is an enum, I need to be able to get its value so I can apply a function to it. Sorry, that was my fault for not being clear.
You're missing a type annotation on the value `testExpr`, such as: let testExpr : Result.Result&lt;_, Error&gt; = // ... The `Bind` method works with any input and output types for which there is a valid `From` method, but if you don't specify them then the compiler can't guess which one(s) you want. Here it knows the input error type is `Error` because it can infer it from the type of `testResult`, but it can't infer the output error type without a hint.
Ah perfect that makes sense. Thank you!
Guy didn't do his homework, the future of programming is juicy steaks.
What does this mean for someone who is rather new to the .NET world? What is UWP ?
[Universal Windows Platform](https://docs.microsoft.com/en-us/windows/uwp/get-started/universal-application-platform-guide)
How complicated is implementing tail-call elimination? Isn't it just a trampoline? Am I wrong to think that this would take one PM and three engineers about two weeks each? I'm rolling the Big Company tax into that estimate, in a nimble business this would be a two-man job (one to implement, one to review.)
paging /u/TensorMetric
Wouldn't it be possible to implement tail recursion without that IL instruction?
Isn't UWP the future of apps on Microsoft's platform and the interpretation of this is that F# is dead as a client-side language.
Microsoft has had at least three 'future of apps on Microsoft's platform' technologies in the last five years and I can't say that UWP is super likely to last either.
With the attitude they're displaying, I surely hope not.
UWP is an evolution of what started as WinRT in Windows 8 and it's getting expanded every day. For consumers it's the safest and cleanest solution to application install/uninstall &amp; updates as it also supports per app permission control. It also properly supports the latest device input methods. All of MS's new first-party apps and games are using it, so it's not going away anytime soon.
Not saying everything is sunshine and roses on the client side for F#, some sort of react native framework is as likely as anything that would allow F#, but UWP is basically a lost cause at least until Windows only clients have moved to exclusively roll out versions of Windows that actually support it and even then, with phones and RT essentially dead I don't know why you'd use it over WPF. I'd expect some sort of product announcement based around .NET core or a Microsoft portable JS runtime though. Whether it'll use F#, or even C# for that matter, who knows. 
It also isn't cross platform or even cross Windows versions. RT is dead, Windows mobile is dead, and their app store is basically dead. What's the motivation for any developers to actually build anything in it? I'm saying this seriously. As a developer why would you write software in an environment that's more restrictive and less supported in terms of platforms just so Microsoft can take a cut of your sales in a store no one uses. As a consumer, who cares about features presented by an app store you don't use. Microsoft is releasing some small stuff in UWP, but their flagship products aren't written in it for the same reasons.
It's cross platform across all modern Windows 10 versions. Every Windows 7 and up user had a change to freely upgrade to Windows 10. You can distribute UWP apps outside the app store, but consumers are more likely to trust your app when it's in the store. Many people now have hybrid devices with touch &amp; pen so many people care about good UWP apps. All of MS their latest flagship games for the past few years have been on UWP and in the Store. OneNote and Edge are flagship products that are UWP as are all the default apps. The old non-UWP OneNote 2016 isn't getting new features anymore, etc etc.
The blog post and latest comments https://blogs.msdn.microsoft.com/dotnet/2017/08/25/uwp-net-standard-2-0-preview/
Funny timing. I just came across [https://github.com/mausch/MDelimcc](https://github.com/mausch/MDelimcc) last night. It's old, and I can't speak to its quality, but it is a delimited continuations port from from ocaml to F#.
[removed]
&gt; but UWP is basically a lost cause at least until Windows only clients have moved to exclusively roll out versions of Windows that actually support it The only Windows devices sold today come with Windows 10. &gt; with phones and RT essentially dead Surface Phone running Andromeda is already being tested internally. &gt; I don't know why you'd use it over WPF. WPF hasn't had any meaningful update for years and isn't even covered at Build anymore. It is not suited for modern device categories. 
&gt; Surface Phone running Andromeda is already being tested intern Rumors about a DOA technology being tested on another DOA device? I'm not trolling here. Why are you betting on untried technology, that has a tiny rumor mill going (at best), and is the following act of a failure on an epic scale, resulting in 18,000 people getting laid off? Do you seriously think that Microsoft is going to do that again? They even stopped mentioning mobile in their earnings reports because it was so awful and negative. Windows is a dying platform. It sucks and is fraught with problems, despite the fact that you have to pay to use it. It's complicated, with multiple competing technologies, which are obviously the result of competing groups within Microsoft. You need to download tens of gigabytes of shit to do literally anything. And that doesn't even begin to cover the millions and millions and millions of people who can't even use a Windows application because they don't own a Windows machine. Why would anyone who isn't already a long-time Windows developer invest in this if they can just make a halfway-decent web app?
Andromeda devices still have to sell, and there's no indication yet that windows devices that won't run windows apps have a market. They've all failed so far. Devices may come with windows 10, but that doesn't mean there aren't huge numbers of windows 7 or even earlier out there, especially in a corporate environments. Hell to even support windows 8 uwp has to cut features. WPF works perfectly fine on every single windows device with a mouse and keyboard, which is all of them. What modern device is it not suited for? Give me something that can run on an iPhone, android and windows (which you can actually do with react native) then I'm interested, but some windows devices is not the future.
No, only home users got a free upgrade, and lots of people didn't anyway. Those aren't flagship apps.
What's wrong with still using WPF instead?
I thought F# actually has tail call optimization. And C# not. Who could elaborate on this topic?
UWP is the future. Cross device responsive apps
Plain WPF supports F# and targets platforms with more market share than UWP. Avalonia is really cross platform and you can use F# with it. Same about Xamarin things. You can also do cross platform desktop apps with Electron (as MSFT does for some of their new applications) and use F# with it through Fable. And ReactNative/Fuse with Fable for the cross platform mobile app ( and with ReactNative you can target UWP if you have problem and some silly reason to target it). So the only thing that is dead is UWP, Windows Store, and Windows-only philosophy those technologies represent.
F# optimises some tail calls itself but in the general case it defers to .NET. Specifically, via the `.tail` from ILX. C# doesn't do this. 
&gt; The insistence of clean 2-way .NET interop seriously crippled the language It is F#'s raisen d'etre. &gt; and what did F# get in return for that favor after all those years? Libraries and industrial users. &gt; It's still considered a 2nd class citizen. True. &gt; My patience is wearing thin, It's time for me to look for alternatives now. I've looked. Didn't like what I found. &gt; Probably the same as Haskell's. Looks like Idris has a really crappy GC. &gt; Maybe give it some time until it reaches critical mass. I won't hold my breath. 
Not in the general case because it requires a global change to the calling convention. 
&gt; How complicated is implementing tail-call elimination? Isn't it just a trampoline? Usually a change to the calling convention. Trampolines are a slow workaround that obfuscate stack traces. &gt; Am I wrong to think that this would take one PM and three engineers about two weeks each? A student, Arnold Schwaighofer, did it for both LLVM and the Hotspot JVM in a matter of weeks. 
I see but uwp support is important because it shows that Microsoft takes f# seriously
&gt; It is F#'s raisen d'etre. I would rather have ML modules if I don't expect my code to be consumable from C#. &gt; Libraries and industrial users. Yet we still can't use F# on Microsoft's main client application platform, UWP, without jumping through hoops. Meanwhile many other languages can also target .NET. &gt; I've looked. Didn't like what I found. There are plenty of alternatives, especially if you don't care about .NET. &gt; Looks like Idris has a really crappy GC. Is it? &gt; I won't hold my breath. They just started.
&gt; I would rather have ML modules if I don't expect my code to be consumable from C#. Ok but the motivation of building upon .NET isn't just consumption from C# but also reuse of C#'s libraries. &gt; Yet we still can't use F# on Microsoft's main client application platform, UWP, without jumping through hoops. Meanwhile many other languages can also target .NET. Sure. &gt; There are plenty of alternatives, especially if you don't care about .NET. I don't care about .NET. We have one mobile app, an internal analytics tools that requires MS SQL interop and various other bits of code. None of it needs .NET but I haven't seen any other languages that seem preferable to F# for any of these applications. &gt; They just started. ReasonML has been in development for over 2 years now and all of the latest updates are to do with superficial things like syntax and packaging, i.e. not even attempting to address any of OCaml's core deficiencies. 
&gt; and all of the latest updates are to do with superficial things like syntax and packaging Aren't those one of the major reasons for the lack of OCaml's adoption?
&gt; No, only home users got a free upgrade Pro definitely did, too.
Not license type customer type. Enterprise customers didn't get an upgrade. Individual users and some SMEs.
Ah, I see. I wasn't aware of that, but I can't say I'm terribly surprised.
&gt; Aren't those one of the major reasons for the lack of OCaml's adoption? Not at all, no. OCaml has had perfectly good packaging in Debian for over a decade and syntax is rarely a concern. The big issues are: 0. 16MB limit on strings and arrays in 32 bit. 1. Type unsafe equality, comparison and hashing that can fail at run time. 1. Lack of IDE with type and documentation throwback. 2. Lack of GUI libraries. 3. Lack of operator overloading. 4. Lack of JIT, e.g. REPL is very slow. 5. Lack of reified generics. 6. Lack of multicore support. 7. Cumbersome FFI. 8. No `try...finally...`. 8. No `inline`, particularly for higher-order functions. 
The basic takeaway is that presuming that everyone has windows 10 let alone a recent version is optimistic at best.
&gt; Not at all, no. OCaml has had perfectly good packaging in Debian for over a decade and syntax is rarely a concern. I heard otherwise, also the fact that there are multiple competing standard libs. &gt; Lack of IDE with type and documentation throwback. Isn't this what they're addressing with VS Code plugins and the like? &gt; Lack of GUI libraries. They kinda address this with React Native. &gt; Lack of operator overloading. Wasn't there some module hack for this a few years ago? &gt; Lack of reified generics. Not a problem to most people. &gt; Lack of multicore support. This is an issue, but not one that affected OCaml's mass adoption. That said, the ReasonML devs stated they would like to have this addressed. &gt; Cumbersome FFI. It looks like they're addressing the JS FFI situation at least, but I haven't looked into it. That said, all those issues would have higher priority if OCaml had enough users to even care or run into those issues in the first place. So let's wait and see, ReasonML can only be good for the OCaml community and the adoption of modern languages in the long run.
&gt; I heard otherwise, also the fact that there are multiple competing standard libs. Yeah, I never found that to be a problem in practice as you can just `apt-get install` whatever package you want (thanks to the awesome Debian packaging). &gt; Isn't this what they're addressing with VS Code plugins and the like? They've mentioned it but I've no idea what they're planning. &gt; They kinda address this with React Native. I have no idea what that is. Some web thing? Oh yeah, its a tool that lets you write mobile apps using the web's awful software development toolstack. That's great if the only language you know is JS. Why would want that when I can just use F# in Xamarin? &gt; Wasn't there some module hack for this a few years ago? There have been many hacks. They all suck. The language itself needs ad-hoc polymorphism and equality types or type classes. &gt; Not a problem to most people. I think quite a few people would like a hash table than ran 10x faster with zero effort. Would be a shame to miss out on the biggest advantage .NET has over JVM... &gt; This is an issue, but not one that affected OCaml's mass adoption. I disagree. OCaml's popularity was booming up until the first multicore's were released. Then all of a sudden the number of people learning the language fell off a cliff. For example, my book sales fell 80%. See [The Rise and Fall of OCaml](http://flyingfrogblog.blogspot.co.uk/2010/08/rise-and-fall-of-ocaml.html) for some stats. &gt; That said, the ReasonML devs stated they would like to have this addressed. Many teams have made even bolder claims over the past 12 years. All have failed. &gt; It looks like they're addressing the JS FFI situation at least, but I haven't looked into it. Ok. JS doesn't interest me. &gt; That said, all those issues would have higher priority if OCaml had enough users to even care or run into those issues in the first place. That literally already happened. You are describing OCaml circa 2005 when multicore hit. Lots of people complained about lack of multicore support and then most of the community up and left. Many of them are now using F# instead. &gt; So let's wait and see, ReasonML can only be good for the OCaml community and the adoption of modern languages in the long run. Again, I beg to differ: they are literally doing [this](https://imgs.xkcd.com/comics/standards.png). Thanks to camlp4, ocamlp5 and the macro system formerly known as camlp4, OCaml already had multiple competing sytaxes. ReasonML is just adding another one. OCaml already has multiple competing stdlibs. ReasonML is just adding another one of those too. Even if you look at OCaml to JS compilation you already have Bloomberg's bucklescript and Ocsigen's js_of_ocaml. ReasonML is adding another one of those too! And so on. Meanwhile, nobody is fixing any of the actual core problems with the OCaml language and/or runtime. Put it this way: are the two largest OCaml users in the world (Jane St and Citrix) going to care? Do you expect Jane St to drop their huge stdlib and replace it with ReasonML's? What about everything built upon Jane St's Core and Async like the Cohttp library for Docker's Mirage? Are they going to port it to ReasonML? I seriously doubt it. 
[Original Source](https://xkcd.com/927/) [Mobile](https://m.xkcd.com/927/) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini\-USB\. Or is it micro\-USB? Shit\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 4784 times, representing 2.8640% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_dmcokct)
&gt; It's cross platform across all modern Windows 10 versions That is not cross platform.
A ray tracer and trying to speed it up using the GPU.
Creating a .net core 2.0 version of https://github.com/pedromsantos/vaughan
I don't know how much work it is, but I do know that it is not necessary for F# support on .NET native. (As acknowledged by Don Syme in the GitHub thread on the topic.) So it's a red herring. The problem is that after 2 years of waiting, there is so little progress that the F# team and .NET native teams have no idea of the problems, even less idea than is obvious to an interested user. As evidenced by the frequent mention of the irrelevant .tail instruction.
Creating a parser for digital talking books to be used in Xamarin mobile apps. https://github.com/chinwobble/DaisyParser
Trying to move our ETL process from Azure DataFactory to precompiled F# Azure Functions to save a bunch of money
Completed :)
That's interesting, is the data all stored in azure as well?
Originally no. 1st step, pull it from various APIs and store it as is in DataLake. 2nd step right now is implemented as DataFactory pipelines. Take raw data from DataLake, do something, store in TableStorage or Blob.
Trying to make a converter from NFA to DFA
I think it would be easier if you posted a specific problem (steps to reproduce, error message, etc). I too work with Linux (Ubuntu), VSCode and .Net Core. I had faced some challenges. Maybe I can help. Side note: I tend to not use the integrated terminal, I just run 'dotnet' / 'fsharpi' commands on the external terminal. Also things are not perfect on linux, you might find that your use case is a known issue. This is why I advise you to post specific use case.
The too much code at once is a known issue. There's a character limit to the amount that gets sent to FSI. I forget what it is now. Other than that, what distro are you using?
Arch linux at the moment. I know of that issue being open on github, multiple times even, but if I recall correctly those were solved by removing the "integrated terminal flow control." At least they should have been solved. But there is a related issue - I have to select type definitions and imports alone first before sending the rest. And much much more... 
Issue 1: **Preparation** download Fsharp according to their guide download VSCode insiders install ionide extensions for VSCode New F# Project Write `-.,-.a,-fl;+.` (Or whatever that is guaranteed to produce an error) Write approximately 10 lines of fsharp Delete the error producing line **Expected** Error should disappear, intellisense should still come up upon writing `System.`, linter should still produce new underlines in case of error **Actual** Red underline on empty line, no intellisense, no new underlines. **Known workaround** Restart VSCode after every 10 lines of code, or memorize the dotnet framework. :D PS: If this is a known issue I'll eat my hat 
Issue 2: **Preparation** download Fsharp according to their guide download Atom using pacman in Arch linux install ionide extensions for Atom New F# file Write `1+1` Execute using integrated fsi **Expected** `2` should appear **Actual** `...` appears (indicating that code was sent), but no `2` appears. PS: again I can't quite see this being a common problem or anything
You managed to get .NET Core running on Arch Linux? I didn't think that was possible due to [incompatibilities](https://github.com/dotnet/corefx/issues/19447) with OpenSSL 1.1.
I don't recall having much trouble with it. Did it not work for you?
I haven't tried that's why I asked. Reading the thread in the link I assumed it's not compatible - I searched after I saw Arch isn't one of the officially supported releases.
Try downloading `FSharp.Compiler.Service` as a nuget package and then pointing Ionide to it in the settings using the `toolsDirPath` and `fsiFilePath` options. That should be the very latest version of the compiler, and it could help (couldn't hurt, at least). Also, FWIW, I'd stick with Ubuntu 16.04 when developing on a cutting-edge ecosystem like F# / .NET Core. Even using Ubuntu 17.04 gave me trouble. 
In F# interactive, you need to tell it to execute by typing two semicolons ;; at the end of the line, then hit enter.
Not sure on the specific issue you're seeing. I know this tooling is open source and new releases come out pretty regularly, so might just be one bad release. Otherwise I'd suggest letting them know via a GitHub issue - they're very friendly, especially if you can give them a nice reproducible issue :)
Hehe, the Atom editor contains an integrated fsi terminal. When you select a chunk of code and press `[Alt]+[Enter]` the code is pasted into fsi and executed for you. Well, sometimes it is...
That's the thing, these can't possibly be reproducible issues. What is the chance of me being the first developer to have written 10 lines of code with an error... It's surely going to be something like what /u/matthewblott suggested - I could have mistakenly installed incompatible software. 
Reddit is not a best place to report issues in OSS projects, is it?
Could you share the code you're working on? I use Rider on Linux and couldn't get VStudio on Windows to work with F# so I feel your pain
Could not reproduce on Debian 9. I have just the default repos. * Installed fsharp with sudo `apt-get install fsharp` -&gt; installs fsharp (4.0.0.4+dfsg2-2) with a dependency on mono * Downloaded VS Code Insiders (.deb), installed with `sudo dpkg -i code-insiders_1.16.0-1504554213_amd64.deb`, creates the `code-insiders` alias. * Installed the `ionide-fsharp` extension version 2.34.4 and did NOT install the FAKE extension * Created a new directory, created a file `Dummy.fs` with a dummy module and a line `System.Console.WriteLine(1 + 1) ;;` * Typed some f-sharp code from LearnXinYminutes, added some garbage in, saved * Autocomplete still works, even with the garbage text: https://i.imgur.com/LpZs0OE.png * Removed garbage, saved, compiled on the console with `fsharpc Dummy.fs`, ran with `mono Dummy.exe`, outputs `2` as expected. 
One thing that causes problems on Linux is conflicting chromium versions. I've absolutely destroyed visual studio code with a conflicting chrome or chromium install and atom is electron as well. Might also be worth making sure you have node installed. A lot of plugins need node backends to run.
A different problem was solved by removing the "integrated terminal flow control" setting, but the "too much code at once" issue has not yet been solved yet; I'm hitting it too. I work around it by sending my file to F# Interactive in chunks of 3-4 functions each time (or just one function at a time if it's a large function).
Yes, F# runs on AWS just fine. I'm not sure what "either" means.
Thank you, by or I meant F# or AWS. I am still learning F#, one of the things we want to do is port over a project from PHP over to F# and have it set up distributed on AWS. But I am not sure if this is the proper term to use, I am not up to speed on distributed computing, still reading up.
TL;DR: **yes**. You might want to look at some documentation here: http://fsharp.org/guides/cloud/#cloud-platforms
Thank you!
AWS has not much to do with distributed programming. It can help you do so, but you can also just run a VM and be done.
Cool thanks, it looks like I have much to read up on.
In what part of AWS? If you can get it to run on your machine, you can get it to run on a similar enough EC2 instance virtual machine. For a serverless lambda function, what you upload is the .Net core binaries, so you can use [any .Net language that you can compile to Netcore 1.0](https://aws.amazon.com/blogs/developer/updates-for-net-core-lambda-libraries/). When AWS supports Netcore 2.0 on lambdas, [you could then in theory write a lambda in VB.Net](https://www.infoq.com/news/2017/05/netcore2preview) ;) *edit* I mistakenly had netcore 1.1 above, it seems that only netcore 1.0 is supported in Lambdas at present. I expect that it will next skip directly to 2.0
Would you mind adding a little bit more of an "About" at the top? This looks pretty cool but it took me a bit to figure out what it is, and I'm still not sure I've got it correct. :-) I find it super-helpful for open-source projects to have an "About" line at the very top that is a one or two sentences to answer "What am I looking at?" something like: &gt; Vaughan, named after blues guitarist Stevie Ray Vaughan, is a library for working with music notation and programmatically creating music. 
The single pass compiler is a big advantage, and a major factor pushing towards code correctness. Being able to digest foreign F# projects easily and reducing the cognitive load of browsing source is really nice too. The single-pass approach also has performance implications that are quite serious: quick compilation is the backbone of intellisense. People off in Scala land can see some impressive compile times, whereas F#s is fast enough to follow along with our typing.
Cool, so as long as I can get the thing running in Giraffe on my local machine I can just set it up on EC2 and just use something from AWS to do load balancing and the sort? Thanks for the help!
&gt; and just use something from AWS to do load balancing and the sort Yep. A typical configuration using EC2 machines as web servers has an [Autoscaling Group (ASG)](http://docs.aws.amazon.com/autoscaling/latest/userguide/AutoScalingGroup.html) to keep the desired number of machines in service - e.g. if one dies another will be created. And an [Load Balancer (ELB)](https://aws.amazon.com/elasticloadbalancing/applicationloadbalancer/) to well ... balance the load between them. AWS is like Lego. The pieces are small, and assembly is required in order to build anything useful. But it's quite flexible too.
Thank you for your sugestion, do you mind if I use your phrase :)
On the .NET side, if you want to embed a C# or an F# repl, you can use either the [F# compiler services](http://fsharp.github.io/FSharp.Compiler.Service/) or the new [Roslyn scripting API](https://github.com/dotnet/roslyn/wiki/Scripting-API-Samples). Currently the Roslyn scripting API is a bit more advanced as you can return values from it unlike the F#'s where it is a one way street. I wish I could give you a better answer than the above, but I am not at all familiar with either F#'s or Roslyn's compiler internals. It would be cool if there was some kind of solution for converting dynamic algebraic datatypes directly in to `System.Type`, but I haven't found it yet. What I would do if my language was at that stage where all the features are in place and it was bug free and produced high quality code is try to get in contact with the people actually working on the .NET's JIT and the language compilers for answers to questions of integration. Until then, I'd recommend you just generate F# or C# code directly as it is not too difficult and this will allow you to use those compiler services. Piggybacking of other higher level languages will also make testing things easier until you are ready to make an extra step and generate .NET IL directly.
Are this compiler services fast enough for really use them for a scripting engine? At least python-fast?
Not at all!
The F# compiler services are what F# uses in the Repl and that is quite fast, though not as fast as compiled. Maybe 3x slower depending on the benchmark, which is still way faster than Python. For Roslyn you'd have to find out yourself, though I'd guess the same story would apply there depending on how far along the compiler is on its development curve. I once saw a video on F# being embedded as a [CAD scripting engine](https://channel9.msdn.com/Events/FSharp-Events/fsharpConf-2016/The-3D-Geometry-of-Louvre-Abu-Dhabi), so maybe you could use that as a reference?
F# comes with its own ready to use repl fsi.exe, aka F# interactive. As for F# compiler service, I actively use it for more than a year for scripting in Far Manager, see [FSharpFar](https://github.com/nightroman/FarNet/tree/master/FSharpFar). It is fast and powerful.
It's called RUST 
You probably have to add the library as a reference to your project. https://github.com/fsharp-editing/Forge/wiki/add-reference This can also be done from within VS code.
OK, after submitting [an issue](https://github.com/Microsoft/visualfsharp/issues/3537#issuecomment-326696941) on visualfsharp issue tracker, Don Syme explained to me that such behaviour was by design. I am posting his answer below for those who are interested in it: &gt; The difference between FSI and FSC is that FSI is an "open" program that never produces a finalized, closed assembly, but instead you keep on adding more code. This means that a set of final checks on the "closed" nature of the inlining information collected during optimization is not performed, and the optimization data is never written to disk. &gt; There are several other differences between FSI and FSC - e.g. in FSI each fragment (delimited by ;; - added implicitly on Alt-Enter or Ctrl-Enter in editing environments) is checked independently, whereas in FSC they are checked as a whole. So I think we would consider the difference w.r.t. optimization information checking as by design. &gt; These errors are only shown when the F# compiler executes to completion, after the optimization phase. That phase isn't run in the IDE as there are only a couple of rare errors detected in it, and it would be expensive (in CPU time and memory) to run those final phases.
If it's referenced with #r then you should have intellisense on it. Assuming that's in a script file, that is (.fsx); #r is only for scripts, doesn't work in compiled files (.fs). If it's the latter, then as julesjacob said you need to reference the library in the project.
nope still does not see intellisense popups.. however if i use forge i can see libraries added into .fsproj in &lt;ref include ""&gt; tag..
F# is repl friendly. You don't need anything particularly special. There are repls for C. Repls are old technology and have some disadvantages. Notebooks and inline display of values are the modern replacements.
You might want to have a look at how Clojure works with the REPL. REPL driven development: https://vimeo.com/channels/1116889/223309989
I've seen talks about "developer happiness" with Suave and Fable, and now there's commercial support for a stack containing both. I'm going to give this stack a try for a side project I'm planning soon.
I think this lacks a little detail or comment to ensure that there's total cross platform coverage for what the recommend. They mention safe SQL with type providers but this has limited support outside windows and where there's support for instance in Linux there may be performance trade offs that need to be acknowledged. I love the idea of a stack oriented towards type safety but it certainly need to be extremely careful about the current state of cross platform coverage and be clear presenting alternatives and trade offs
well dotnet 2 supports osx, linux and windows, and for sql you can use dapper.
To my knowledge there is none at the moment, but there are discussions on integrating Fantomas to The FSC so maybe such a formatter will pop up in the near future? More details here: https://github.com/Microsoft/visualfsharp/pull/3542
Running suaveio microservices on ubuntu via dotnetcore and developing in rider on mint. Maybe the best environment I've ever used. Visual studio is close second.
Xml.Linq? https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/linq-to-xml-overview
I tend to stick to F# semantics as much as possible t list int option Etc. But that is mostly a preference and not a hard rule. `t list` is just shorthand for `List&lt;t&gt;` anyway. 
ML-style: let f (x: 't option) = () .NET-style: let f (x: Option&lt;'T&gt;) = () Neither is right or wrong. Some people prefer ML-style, and some people prefer .NET-style. I generally prefer .NET-style, but I find ML-style easier to read in some cases. Additionally, there are two ways to specify a generic type in code. ML-style: let f (x: 'a) (y: 'b) = () .NET-style: let f (x: 'TFirst) (y: 'TSecond) = () As above, neither is right or wrong. In the case of a single generic type parameter, I almost always use `'T`, though. I generally follow this rule for tuple application: If it's being passed to a method, I don't have a space: let c = Classy() c.M(1, 2, 3) |&gt; ignore Otherwise, I'll put a space there. I agree that a code formatter or style guide helps here. Code formatting may [make its way into tooling soon](https://github.com/Microsoft/visualfsharp/pull/3542). A style guide should be written in the documentation somewhere.
Yes it'll help for begginers if we should stick for a more csharp style or more ml style
I personally prefer using C#-style brackets throughout for generics (but still with the F# name, so `option&lt;'T&gt;`, `list&lt;'T&gt;`), but yeah it's far from a universal standard. I think most people use ML-style for standard ML-style types like `list` and `option` and C#-style for their own types. No spaces for method arguments I believe should be a norm, because it has a more practical argument for it: without it, chained methods don't work: c.M (1, 2, 3) .N (4, 5) Here the compiler thinks you're calling the `N` method on the tuple `(1, 2, 3)`, whereas without spaces it does what you'd expect.
You can try SharpXml. I think it has some quirks, serializing dict though. But no exceptions. https://github.com/kongo2002/SharpXml
Straight from the horse's mouth: &gt; Consider using the prefix syntax for generics (Foo&lt;T&gt;) in preference to postfix syntax (T Foo), with four notable exceptions (list, option, array, ref). &gt; F# inherits both the postfix ML style of naming generic types, e.g. int list as well as the prefix .NET style, e.g. list&lt;int&gt;. You should prefer the .NET style, except for four specific types. For F# lists, use the postfix form: int list rather than list&lt;int&gt;. For options, use the postfix form: int option rather than option&lt;int&gt;. For arrays, use the syntactic name int[] rather than either int array or array&lt;int&gt;. For refs, use int ref rather than ref&lt;int&gt; or Ref&lt;int&gt;. For all other types, use the prefix form: HashSet&lt;int&gt;, Dictionary&lt;string,int&gt;, since this conforms to .NET standards. http://fsharp.org/specs/component-design-guidelines/
That gets quite chatty for serialising. `XDocument`, `XElement`, `XName` etc.
will try this out, thanks.
Those four cases are pretty confusing I would like to spread F# usage but this weird rules make complicated I think it should favor C# way of doing generics in all cases
I think for the built-in types from the runtime, ML syntax is nicer/more idiomatic, which is basically anything that has a "lowercase" type alias: eg. Seq/seq, List/list, Ref/ref, Option/option, etc... Other than that, I wouldn't advise using ML.
You know, I'm not sure if it's good practice, but I've started naming my generic type parameters almost like identifiers. Eg.) ``` type Result&lt;'success,'failure&gt; = Choice&lt;'success,'failure&gt; ``` Unless you're interoping with C#, the extra "T" is redundant. The `'` is enough to make the type parameter clear. Also, I don't see why we need to be unnecessarily terse by using single character names like, `'a` or `'b`. These are usually fine for very abstract function like `bind : ('a -&gt; M&lt;'b&gt;) -&gt; M&lt;'a&gt; -&gt; M&lt;'b&gt;`, but why not use longer names for domain types/interfaces/contracts?
Beware! `'t list` and `List&lt;'t&gt;` are NOT always synonymous! If you open the `System.Collections.Generic` namespace, suddenly `List&lt;'t&gt;` is going to refer to the type known as `List&lt;...&gt;` in C#, also known as `ResizeArray` in F#. See https://stackoverflow.com/a/41094189/2314532 for more details.
Interesting! Seems like the F# collections will take precedence until you tell it not to. It's kind of a shame that they look exactly the same and produce no warnings when this happens
Does anyone know if Rider supports, or is planning to support Type Provider Intellisense?
On Spiral, a statically typed functional language with first-class staging and intensional polymorphism. It came from my desire to perfect the machine learning library of the same name, and I started working on it when I realized that I would never be able to deal with the GPU to the degree that would satisfy me. Staging as a feature exists in some languages like [OCaml](http://okmij.org/ftp/ML/MetaOCaml.html) and [Scala](https://scala-lms.github.io/), but having it on a first-class basis is a game changer that opens a whole new programming style based on it. What staging does is in essence guarantee the inlining of functions and deforestation of data structures, even when they are passed as arguments and allows the programmer perfect control over the degree of boxing. Similarly, intensional polymorphism works well in concert with staging and makes the language incredibly expressive, almost on par with dynamic languages, and certainly moreso than F#. Because of the inlining guarantees provided by staging, it will enable a higher order programming style on the GPU minus the recursive datatypes. In essence, it will be possible to use computation expressions (monads) inside Cuda kernels and derive all the benefits from that such as exceptional control flow (Cuda does not have exceptions) and passage of implicit state. As a functional language, it has very strong pattern matching capabilities and union types as well. Despite all of the advanced features that it has, it requires almost no type annotations, though the type inference for it is undecidable. Despite its expressiveness, or rather because of it, the language has unparalleled efficiency and when it matures it will make C++ fear for its life. I've been working on it since February of this year. Originally I wanted to just make it a Cuda backend for the ML library in order to allow me to make kernels in a generic fashion, but as I made progress, I realized that I had a great thing on my hands and decided to make it a fully fledged language and do the ML library in it instead. It will be a pretty great library no doubt, when it is done. Right now, it is usable and I am making the core libraries while testing it by doing HackerRank and Project Euler problems. I think if I am lucky, I might be able to put the Cuda backend and write a demo of the ML library with an F# API before the end of the year. I will post it here, but releasing the language in full and writing the documentation for it is something that will take me a while longer.
What's the compilation target, native binary or VM (CLR, JVM)?
On the .NET side, F# code and on the GPU side, Cuda C code. I've been thinking about whether it would be better to go a level lower, to .NET IL and LLVM IR (PTX) for Cuda and there would be a benefit in terms of compile times, but I think I will keep it as it is. The reason for that is that I want the users to look at the generated code and see for themselves that all the lambdas have been inlined, all the variables are being propagated properly and that there is not too much specialization going on should they want to. This will be important for building up skill - the style is new to me as well and that is how I am learning myself. Spiral is similar to Haskell in the sense that staged functional programming is as different from vanilla as lazy functional programming is, but the two styles do not have anything in common apart from that. Going to an intermediate assembly language would go against the purpose of building up skill. The purpose of Spiral and its selling point is not just that you can use it to make DSLs - any language with decent abstraction capabilities can make that claim, but that you can use it to perfect them. Right now, the .NET integration is not complete yet - I haven't gotten around to figuring out how to convert Spiral's tuples and functions to .NET `System.Type` which I need to interface with the ecosystem. Meaning right now, the language only supports arrays, strings and primitive types to go along the boundary to .NET land. I'll get on dealing with that once I am done with this round of testing. For the last two months, I've only been working out correctness bugs and compilation speed issues and am glad to write actual programs now that all the features are in place, so I want to play around with it for a bit and get a sense for it in practice. Also, the Cuda backend has not been implemented yet. The previous versions of the language had it - and only it for that matter, but then I removed it and switched to generating F# code because it is much easier to test. There is only so much that I can do with GPU kernels.
I'm with haf on this one. Anything that MS is pushing as the "latest and greatest", ie. Kestrel/ASP.NET core, is immediately suspect. They tend to pull the rug out from people. Better to keep the two separate for now so as not to introduce any unintended future dependencies on ASP.NET, etc... not that it wouldn't be a good idea later. It's just a bit early to make the decision.
&gt; ...encouraged by the languages... Note that F# does not encourage the use of `list` over `List` and, in fact, even provides the latter with more functionality as `ResizeArray`. To make that C# into idiomatic F# I would replace the `isVIP` boolean (which is bad style in F#) with a union `type VIPStatus = IsVIP | NotVIP`, use a sequence expression like `[for index in 1..numberToGenerate -&gt; …].` rather than hand rolling your own loop using recursion (which is bad style in F#) and used `ResizeArray`. 
Yes: I have two businesses built upon F# on AWS! 
I think this is important mostly because it questions the sustainability of F# when there's a constant link to C#. This doesn't seem to me like Clojure link to Java, but way bigger from my limited perspective as a curious person of F# after .NET Core 2 rather than an old user.
Let me give you some theory... When software development is directed, `n` developers move in the same direction at speed `n` towards the goal. When software development is undirected, `n` developers move in random walks at an average speed `sqrt(n)` in the direction of a goal. Commercial software is typically directed. There is a CEO with a vision who makes sure everyone pulls in the same direction. Open source software is typically undirected. There are a huge number of contributors adding features almost at random. Consequently, open source software requires `n^2` people in order to progress as quickly as (good) commercial software development. In my opinion, Microsoft have fallen down the gap between these two extremes. Ten years ago, they were directed. They had an excellent platform in .NET and it was the future. They had an world leading turn-key web solution in Silverlight and it was the future. They had a world class language in F# building upon these things. Today, Microsoft is headless. There is no vision. WinDev were allowed to drag the company in a random direction that irreparably damaged .NET. Silverlight was canned with no replacement. Great things like [Try F#](http://www.tryfsharp.org/) were built upon these foundations only to have them disintegrate underneath the language. Some of the [highest profile F# contributors](https://github.com/vasily-kirichenko) are publicly advising people to stay away from Visual Studio. In my mind, the three possible futures for F# are: 1. It fails and becomes another undead language like Common Lisp or Haskell. 2. It succeeds as commercial software with proper backing from Microsoft who put the resources required into making it a success. 3. It succeeds by earning a substantial body of open source contributors. I believe (3) is impossible so it boils down to whether or not Microsoft start to give it the official support it deserves. I'd note that I've had a look around and not seen anything preferable to F#. We've got a mobile app written in F# using Xamarin and we're very happy with it. We've got a lot of internal software written in F# on .NET on Windows and we're happy with it. I recently wrote a website using F# running in Windows in AWS and I hated it but every web dev tool stack sucks as far as I can see and, in this case, I can just rewrite it as a WPF app. I still love WPF. 
Thanks for sharing. Could you elaborate why exactly you see as impossible the path of substantial open source? I don't see anything better either and don't know if this should actually engage open source instead of limiting it.
The path of F# on .NET Core, despite the horribly API-less direction that .NET Core took initially, seems fairly straightforward to me. I made the mistake of hopping on that train early on, decided to step off and let MS figure out what they even wanted to do in the first place, and now it's fine. The progression over the last year seems to have followed a linear path towards more APIs, running in more places, fixing bugs, and trying to eek out more performance. Today, I can download the SDK on any one of my machines, and I get F# support without any fuss. There are some useful templates ready for me on the command line, and I can install community templates for open source libraries that I use. I can get that exact experience via the official .NET Core Docker image, or the image maintained by the [F# community](https://github.com/fsprojects/docker-fsharp) should I choose to also run code on Mono. I can push that image to Azure Container Service, or just shove a `.dll` in App Service. It also works just as well in AWS, and I imagine it would work well on Google Cloud, but I don't use Google Cloud. Xamarin has always been buggy for me, but Android and iOS development has always been an exercise in patience with me, and Xamarin hasn't felt any slower than the native platforms to me. I'm not entirely sure where it fits into the whole picture. I don't do Windows development anymore. WPF and WinForms are still solid and will probably never stop being solid. I think UWP is a garbage piece of technology that will die off like all those Windows Phones it was supposed to rejuvenate. In a way, I'm glad F# isn't a part of that mess. I just don't see Windows as relevant to developers anymore. The focus of Microsoft on .NET Core, Docker, Cloud, and Xamarin certainly makes it feel that way.
It appears there is a DiscriminatedUnionConverter in Newtonsoft. https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_Converters_DiscriminatedUnionConverter.htm
Haf's absolutely right. It's a very sobering message, but the community needs to stand up and start asserting itself. Definitely a call to action. We need to resist the asp.net siren song and step up our oss contributions.
Microsoft has a much stronger track record of undermining the community by releasing competing, lower grade knockoffs of open source projects. .net devs have been conditioned to accept this "orthodoxy" as gospel. There's no reason microsoft software should be adopted or taken as seriously as it is when the market/thought leadership hasn't been earned on merit.
I think the asp.net team has really been driving the dotnet core initiative. They seem to be hellbent on chasing the node.js developer experience at the expense of the oss .net community. Option 3 is the only way forward imo. If Microsoft continues to promote its own products in spite of community efforts (eg. heroic contributors like haf), it will eventually lead to the death of the F# ecosystem. People often complain about the lack of support from MS wrt to F#. In reality, it has been a blessing in disguise. They really need to start contributing to F# community projects and increasing momentum. I'm not sure if that's in their nature, though.
I tried adding that as a converter. But the problem is the converter tries to assign values to the wrong DU option. Here is how my records and DU is structured type DataEntryElement = {Recipients:string; Exceptions:string} type BottleElement = {StockCode:string;EmptyPacks;TotalPacks:string;AdditionalPacks:string} type FormElement = | DataEntryElement of DataEntryElement | BottleElement of BottleElement type AppForm = {Name: string; Comments:string; Elements: FormElement array} let stringText = "{Name:\"Bill\",Comments:\"TestComment\", Elements [{"StockCode:\"100634\",EmptyPacks:\"2\",AdditionalPacks:\"1\",TotalPacks:\"3\"}]}" let settings = new Newtonsoft.Json.JsonSerializerSettings() settings.Converters.Add(new DiscriminatedUnionConverter()) let results = JsonConvert.DeserializeObject&lt;AppForm&gt;(stringText) And stringtext has the Elements property but the serializer improperly trys to set values from it to the wrong option in the DU. For example it Im trying to set values in the bottleElement and instead it sets them to the DataEntryElement 
You must make your type mutable, so remember to include a setter. I think records should "Just work" though. See https://dotnetfiddle.net/NkKIIC example.
afaik the latest release should "just work" with DU's, are you sure there isn't a different problem?
[removed]
How does it fail? What's the deserialization input? What's the expected output? Same for serialization. IIRC, by default, a DU such as `Foo of string * int` gets converted by JSON.NET into `{ "Case" : "Foo", "Fields" : [ "someString", 12345 ] }`. There are alternative converters out there that return more idiomatic encodings.
Can someone please elaborate on the OWIN embrace-extend-extinguish bit that the blog mentioned?
Sure. OSS projects snowball once they reach critical mass. F# never got to critical mass and has long since stopped growing. Short of a miracle, I don't see F# ever getting there. I think the community would need to grow 10x to exceed critical mass, i.e. be the scale of Python or Ruby. 
&gt; People often complain about the lack of support from MS wrt to F#. I disagree. Without Microsoft's support, F# is just another ML derivative. &gt; They really need to start contributing to F# community projects and increasing momentum. Is there a precedent for a core F# dev at Microsoft contributing something non-trivial to an open source repo that is not under their control? 
It was always my understanding that F# was spawned purely to investigate the notion of functional programming on .NET, and that it was _always the itention_ to use it as an experiment and see what changes can be gleaned for use in C#. Certainly always felt that way, anyway.
Welp, I thought about having a look at F#. So much for that.
&gt; I disagree. Without Microsoft's support, F# is just another ML derivative. Outside of funding Don's team, which has mainly been preoccupied with retrofitting the compiler/tooling for .net core, what has MS ever contributed to the F# ecosystem? The growth thus far is almost entirely attributable to the community, particularly folks like haf. What sort of "support" from MS do you think the language needs? The sort that they're giving (have given) C#? If it weren't for this .net core hail mary, new C# and .net adoption would've disappeared by now (at least in the bay area). It would've been relegated mainly to shops with existing legacy code bases. MS's heavily curated C# "dev experience" has only (and will only) ever appeal to the sort of paint-by-the-numbers enterprise jockeys who're incapable of contributing anything of value to oss because they believe all the good things come from MS. Not that people haven't built great things with C#, but all of their contributions end up being diluted by the 800lb gorilla in the room that's stealing their mindshare, particularly when the community is trained to consume whatever MS tells them is the latest and greatest. Assuming microsoft keeps its hands off, F# on .net core becomes a formidable alternative to scala for server applications. The perception that F# is windows/MS-centric has been the albatross around its neck. People are generally excited to try it out, but they usually bump into the problem of its underdeveloped tooling, clunky dev experience, or just confusion/uncertainty about the platform. You need to have confidence in all these things to put code into production and build a dev team. Resources that otherwise could've been used to smooth out these rough edges and capture new adopters have been dumped into Visual Studio, promoting/developing synergy between F# and MS frameworks/technologies that nobody (in the *nix world) is interested in using, and accommodating MS's "reimagined" .net platform. This is the main reason F# community growth has suffered; MS has dragged the community into this weird limbo state that it won't escape until F# (the REPL, type providers, quotations, etc...) is fully supported on .net core. &gt; Is there a precedent for a core F# dev at Microsoft contributing something non-trivial to an open source repo that is not under their control? Of course not. I'm not suggesting that the F# community needs MS to contribute, but if MS were to help maintain/improve community projects, it would be the right sort of contribution as opposed to elevating projects like Giraffe simply because they integrate well with other MS technologies. Seriously, how can they actually promote a *beta* project like Giraffe over a mature, battle-tested, leading product like Suave? Do they think we're morons? Anyway, I say all this with tremendous respect for you and your contributions over the years. I'm just telling you how things are in my neck of the woods where "support" from MS is considered the hug of death. 
I updated my original example with the specific record types and text that are used to make it fail. 
SML.NET, Haskell.NET and other projects were the experiments. F# was the officially-endorsed pragmatic production solution shipped as part of Visual Studio. 
&gt; the community needs to stand up and start asserting itself What community? I look at F# people and see the same people I saw 10 years ago. I look at F# conferences and see the same number of delegates I saw 10 years ago. 
&gt; Outside of funding Don's team, which has mainly been preoccupied with retrofitting the compiler/tooling for .net core, what has MS ever contributed to the F# ecosystem? MS built F# itself. The Visual Studio tooling around it and shipped the whole lot with Visual Studio starting with VS2010 in April of 2010. They also had some high profile uses internally like Path of Go, Halo 3 and Bing. &gt; The growth thus far is almost entirely attributable to the community, particularly folks like haf. What growth? I hear about F# conferences these days that are the same size as the F# meetups we had 10 years ago. &gt; What sort of "support" from MS do you think the language needs? The same coverage as C#. When I [look something up on MSDN](https://msdn.microsoft.com/en-us/library/system.net.httplistener.aspx) I want to see F# samples along with the C# ones. When Microsoft ship libraries (e.g. WPF) I want to see F# APIs. When Microsoft describe the languages they support I want to see F# listed among them. When Microsoft ship a tablet or phone I want to see F# supported on it. &gt; If it weren't for this .net core hail mary, new C# and .net adoption would've disappeared by now (at least in the bay area). It would've been relegated mainly to shops with existing legacy code bases. That is specific to the Bay Area, which is a comparatively anti-MS and anti-.NET region. &gt; MS's heavily curated C# "dev experience" has only (and will only) ever appeal to the sort of paint-by-the-numbers enterprise jockeys who're incapable of contributing anything of value to oss because they believe all the good things come from MS. That's a very interesting statement. Those people are the backbone of .NET and F# and they are at the opposite end of the spectrum from OSS in general. I actually jumped ship from OCaml to F# in order to leave OSS and become one of them. :-) &gt; Assuming microsoft keeps its hands off, F# on .net core becomes a formidable alternative to scala for server applications. Scala is for people who've tied themselves to the JVM. Why would I run .NET Core on Windows when I can use .NET proper? If you mean Linux, why would I use F# when I can use OCaml? From my perspective, .NET proper (meaning libraries like WPF) lie at the core of F#'s allure. Without them, I see no point in using F#. &gt; The perception that F# is windows/MS-centric has been the albatross around its neck. F# is Windows and MS-centric. &gt; People are generally excited to try it out, but they usually bump into the problem of its underdeveloped tooling, clunky dev experience, or just confusion/uncertainty about the platform. Welcome to OSS. &gt; Resources that otherwise could've been used to smooth out these rough edges and capture new adopters have been dumped into Visual Studio, promoting/developing synergy between F# and MS frameworks/technologies that nobody (in the *nix world) is interested in using Yes, of course. That's precisely why I came from the *nix world to F# on .NET on Windows. &gt; This is the main reason F# community growth has suffered; MS has dragged the community into this weird limbo state that it won't escape until F# (the REPL, type providers, quotations, etc...) is fully supported on .net core. Interesting. You're saying .NET Core is critically important. I think .NET Core is an irrelevant side show. Just use the full .NET stack on Windows... &gt; the REPL, type providers, quotations REPL is vital. Type providers and F# quotations are toys. &gt; Seriously, how can they actually promote a beta project like Giraffe over a mature, battle-tested, leading product like Suave? I actually tried Suave recently for a project at work. Broken dependencies. Docs were out of date. I gave up and used `HttpListener` instead. I certainly wouldn't call Suave "mature, battle-tested, leading product". Is it even a "product"? I thought it fell out from two young guys dicking around in their spare time. I also tried Fable and a bunch of other hipster OSS F# projects and none of them worked. I just gave up and rewrote everything I needed from scratch myself to get the job done. It works now but I don't like it and will probably ditch the web UI over a WPF app on Windows because it is so much faster to develop. I mean, its a web framework and [web forms are alpha-level experimental maturity](http://vgaltes.com/suave/forms-with-suave-experimental-and-suave-forms/). I mean, seriously, WTF. That's a few lines of code. Its hard to get that wrong. &gt; I'm just telling you how things are in my neck of the woods where "support" from MS is considered the hug of death. Its a very interesting discussion. I must say, having just spent a month in the Bay Area I'm thinking of their support as the hug of death right now. :-) At least from where I'm sitting, 99% of the F# community run it on (proper) .NET on Windows. They're miffed because the VS2017 release was a disaster. They don't give two hoots about OSS. Half of them aren't even allowed to use OSS. 
The example you have has the same data types in the DU. Try with records that make up the DU each with different fields and data types. That is where my problem lies.
https://dotnetfiddle.net/Snzvda If your JSON is missing the `Case` element it won't be able to identify the DU case.
&gt; That's a very interesting statement. Those people are the backbone of .NET and F# and they are at the opposite end of the spectrum from OSS in general. I concede it wasn't exactly fair. I certainly don't consider you in this class of people. I'm speaking primarily from my own experience of being a .net jockey at one of these shops :) There are indeed some talented employees (not referring to myself) at these places, but there are also so many stubborn, unimaginative, paint-by-the-numbers, GoF-style C# folks that the stereotype is hard to ignore. C# developers are typically happy with C# and aren't particularly interested in learning F#. In fact, the reaction I usually get trying to evangelize F# (even on full .net/windows) is usually disgust. &gt; It's a very interesting discussion. I must say, having just spent a month in the Bay Area I'm thinking of their support as the hug of death right now. :-) Yes. It's clear where we stand. I may just be living in a bubble without realizing it. At any rate, I apologize for the confrontational tone; it was early and I was cranky. I suppose the discussion ends here. Again, I wish you no ill will and happy trails :) &gt; the F# community ... [are] ... miffed because the VS2017 release was a disaster. Indeed. I've had to abandon it for day to day work. It's really hard to evangelize F# on windows when VS2017 is supposed to the best IDE any functional (first) language has to offer. Plus it's expensive and the licensing process is a complete joke. 
I can recommend [FSharpLu.Json](https://github.com/Microsoft/fsharplu/wiki/FSharpLu.Json) from Microsoft. 
Trying to follow your example i am having problem with the string I was formatting let stringText = "{Name:\"Bill\",Comments:\"TestComment\", Elements :[|BottleElement{"StockCode:\"100634\",EmptyPacks:\"2\",AdditionalPacks:\"1\",TotalPacks:\"3\"}|]}" I tried the above it it failed.
You still do not have a `Case` field, nor a `Fields` field in your JSON. See here for the `Elements` field: { "Name": "Bill", "Comments": "Test Comment", "Elements": [ { "Case": "BottleElement", "Fields": [ { "StockCode": "100634", "EmptyPacks": "2", "TotalPacks": "3", "AdditionalPacks": "1" } ] } ] } 
Perfect! I see what you mean now. Thanks!
F# with libraries like WPF on .NET on Windows is still awesome. 
&gt; There are indeed some talented employees (not referring to myself) at these places, but there are also so many stubborn, unimaginative, paint-by-the-numbers, GoF-style C# folks that the stereotype is hard to ignore. C# developers are typically happy with C# and aren't particularly interested in learning F#. In fact, the reaction I usually get trying to evangelize F# (even on full .net/windows) is usually disgust. Absolutely but I see the same thing in the OSS community. They don't want better tools and better languages. They don't even want something as good as C#. They mostly want to stick with something even more backward like C++. LLVM is an excellent example of this. Awesome project idea. Excellent implementation but plagued with C++-specific problems. Rapid forward progress quickly ground to a halt as everyone started struggling to grow the C++ code base. Now the project has major problems with multicore parallelism because it is written in C++. They could have gone much further much faster if they'd used any of a number of higher-level languages instead but they are luddites. And these are the people building the next generation languages! If they cannot modernise then nobody can. Similar stories for GTK and Qt which is why Linux never got a decent GUI library. From my perspective, F# on .NET Core on Linux is just crappy OSS all the way up. The language is bloated with stupid incidental problems (struct tuples, type providers, lame quotation mechanism and so on), the VM is riddled with problems (why are they dicking around with it when everyone knows "if it ain't broke don't fix it") and you only get bare bones libraries with nothing like WPF. So why would anyone choose F# there when you've got alternatives like OCaml? &gt; At any rate, I apologize for the confrontational tone; it was early and I was cranky. Not at all. It is a very interesting discussion and I think it is good to air these things. &gt; Indeed. I've had to abandon it for day to day work. It's really hard to evangelize F# on windows when VS2017 is supposed to the best IDE any functional (first) language has to offer. Plus it's expensive and the licensing process is a complete joke. Yes. Microsoft have made it impossible for me to teach people F# easily because VS is a disaster and TryFSharp no longer works because they dropped Silverlight (and it has no replacement). 
Don't let these two guys freak you out. If you can/need to leverage .net libs, F# is as fun as anything
On other hand, you get a lot of tested and optimized stuff from aspnet for free.
&gt; Some of the highest profile F# contributors are publicly advising people to stay away from Visual Studio. I'd never do that if there were no better alternatives, like Rider and VS Code + Ionide. I don't consider VS a primary IDE for F# anymore. I think MS should concentrate on the language itself and the compiler service, not the VS integration. 
I've experienced some weird issues with FharpLu in the repl, particularly the way it resolves/binds the Newtonsoft library. Otherwise, it works fine in production code.
Indeed. 
I'm actually starting with F#, and after reading this discussion I'm doubting what does it mean to really take advantage of F#, especially because we're working with .NET Core... Could you provide an example or project of F# with WPF on .NET, sorry if it is dumb question...
&gt; Rider and VS Code + Ionide Ok. I'm downloading them now. Will report back... EDIT: So I've installed VSCode on Windows. The UI is really confusing. The docs say "Ctrl+P" and some command line to install Ionide but Ctrl+P does nothing. So I went to extensions in the GUI and installed the Ionide extension. Now I have no idea how to create a project. I've watched half a dozen videos and they're all about Mac OS and Linux which makes me think this isn't for Windows. Then I found [this](https://channel9.msdn.com/Blogs/dotnet/Get-started-VSCode-Csharp-NET-Core-Windows) video where she says it requires .NET Core which I don't really want on my computer because I'm concerned it will screw up my perfectly good .NET not-Core setup but I'm installing it anyway. EDIT2: Project Rider is a 10x bigger download so I did it second but it proved to be much easier to use. I've got a new project with some code using FSharp.Charting to plot a graph. Zero problems so far. The UI is pretty ugly though. &gt; I don't consider VS a primary IDE for F# anymore. I find that statement amazing. How ever did it get to this... 
You mean a case study? [Here](https://www.youtube.com/watch?v=WI9bNWzTkxs) is a presentation I gave a few years ago on a large WPF app I built entirely in F# for one of the world's largest insurance companies. 
Follow this step by step guide https://codurance.com/2017/01/26/create-an-fsharp-project-in-vscode/
or https://docs.microsoft.com/en-us/dotnet/fsharp/get-started/get-started-vscode
So, I have no idea about F# or Ionide. I just installed the three packages for VS Code via the usual GUI and it worked just fine. 
It doesn't really matter to me if the framework is optimized and well tested because the API is designed in a way that makes it easy to write bugs. Giraffe is a more type-safe facade, but it's an abstraction that may leak. You're still dealing with a lot of ASP.NET brain-damage under the hood. Sort of like laying the foundation of a building on a swamp.
&gt; So why would anyone choose F# there when you've got alternatives like OCaml? - An extremely good standard library (albeit only for low level stuff) - Being able to use more than 1 core 
I tried VSCode for an hour or so and got nowhere. I cannot even get it to create an empty F# project. I just get weird buggy error messages that make no sense. So I think that's a pile of crap... VSCode is a performance-critical desktop app written in Javascript. Go figure. 
Yeah, nah... It's pretty fast and has great plugins and features. 
&gt; An extremely good standard library (albeit only for low level stuff) Extremely good is a bit of a triumph of hope over reality. .NET gives you arrays where the empty array is heap allocated (!), lists that are actually just arrays, a very good `Dictionary`, a `Queue` that uses modulo in its inner loop so is very slow and no other data structures like heaps, priority queues and so on. F# adds `list`, `Set` and `Map` but they're clones of the OCaml stdlib. OCaml has way more usable purely functional data structures if you need them. For higher level functionality like HTTP you're comparing small downloads for OCaml and other libraries (Core, Async, cohttp, yojson etc.) with one huge download for .NET Core. The difference is academic. If you look at something like serving JSON over HTTP then the quality of OCaml's libraries blows .NET out of the water. If you look at something like desktop GUI apps then they both suck equally. &gt; Being able to use more than 1 core People interested in more cores are necessarily interested in performance in which case OCaml's 10x lower latency GC and 10x faster serialization will probably trump a theoretical 4x speedup on the embarrassingly parallel part of the server. 
Well I've been trying to use it all day now and it has crashed 3 times and the plugin needed to be reinstalled to recover. I've got Hello World running in FSI but I still cannot see how to compile it into an executable.
I don't think the quality or design is excellent for everything, but it is plenty good enough for most tasks, and the important thing is it is very rich in functionality. For example you can use standard types like Uris, Guids, Timespans, etc, and work with processes, tasks (TPL), directories, databases, Xml, Zip files, etc as part of the base package. I would much rather work in an ecosystem where boring stuff like that is already handled, rather than one that forces me to pick between many options for each, some perhaps being abandoned, and some using the wrong async library, for example. I haven't tried a project in OCaml, but from what I understand, the standard library situation is a little messy, where there is a third party standard library to provide basic stuff: https://ocaml.janestreet.com/ocaml-core/latest/doc/core/Core/index.html Regarding multicore, faster serialization and lower GC latency can help alleviate the lack, but it isn't enough to make OCaml a better fit for all or even most problems.
&gt; the API is designed in a way that makes it easy to write bugs. [..] You're still dealing with a lot of ASP.NET brain-damage under the hood. Do you have some specific examples in mind? Not trolling, I'm actually curious. There's definitely stuff in ASP.NET MVC that makes me roll my eyes a bit for how stringly-typed it is (eg. `return View()`), but I can't think of much in the webserver itself.
Stop trying to use Ionide, it's a hipster OSS not-product that fell out of from young guy dicking around in his spare time. Don't waste your precious time. 
Troll :) 
Yes, someone in this thread is a troll, indeed. :)
That's the first one I tried. Thanks but it didn't help.
&gt; some using the wrong async library OCaml has two async libraries that work in harmony with the Linux kernel. .NET has none. &gt; I haven't tried a project in OCaml Ok. I've built stock exchanges in both. For servers on Linux, OCaml has better tools, libraries and performance. &gt; Regarding multicore, faster serialization and lower GC latency can help alleviate the lack Other way around. A 4x speedup on a quadcore alleviates 10x slower serialization. Multicore doesn't help with latency at all. 
Pure conjecture - as your last sentence more or less admits.
Pass the salt.
I was mainly referring to how heavily reflection-based ASP.MVC is. Adding a new routehandler always feels like a crapshoot, and I'm never quite confident that 1) the right handler will be invoked at runtime 2) the model binding (which is black magic) will work as desired 3) the model validation code is correct. You can side-step all this and build a nice Suave-like facade on top of Kestrel, which is what Giraffe has done, but that doesn't mean the Leviathan won't occasionally peek through and unexpectedly break your code for some arcane reason like, for example, a framework update that subtlety changes the interactions between the various Middleware your app depends on. I don't have any personal anecdotes because I've never written an Owin app on Kestrel. 
&gt; I find that statement amazing. How ever did it get to this... It's understandable considering that VS 2017 was a rewrite using a compiler service designed primarily for C#/VB. The Visual F# tooling has always been heavily customized (if I'm not mistaken) and will understandably take some time to shim it on to a completely new IDE design. VS does some things now, like pass files to the compiler out of order, that are difficult to expect/deal with. Visual F# can get back to up to par with 2015, but it'll require more time and effort. It's a consequence of having to chase the C# tooling design, which is running out ahead without completely taking F# or even VB into account. Meanwhile, you see what basically one guy was able to accomplish with Ionide, and you start to wonder what could be possible if Don's team weren't saddled by supporting this behemoth of an IDE.
His Twitter/Github avatar even has a fedora. /s
Right, the thing is that Giraffe explicitly *replaces* MVC, which is the framework where all the [unobservable magic shit](http://thecodelesscode.com/case/219) happens. I was wondering if some other stuff like that was present in Kestrel itself, leaking through like you said.
The only leakage was a workaround to the owin specification itself as haf mentioned, which was required to get giraffe to work.
You make some good points but I really must question one thing: are you seriously saying .NET on Windows is better than anything else for a web solution? Linux is king in the server world for a very good reason.
Speaking of that, just what the hell happened to the ML community? Being a relative newcomer to functional programming, I decided to look into the language from which F# derives, but the only ML apart from it with a pulse would be OCaml. Apart from it there are well over a dozen of different ML variants that as far as I can tell nobody uses spending their time as academic abandonware. By any real world measure, they are pretty much dead. When I realized that I've been left with the sense that something went deeply wrong with the academic community that they let things come to this state. For F#, here are my thoughts on what the language needs. In general, they would boil down to me saying that the language simply needs to get better. The suggestions also outline various evolutionary paths stray from each other. 1) Higher kinded types and higher ranked types. Higher kinded types play great with type inference and should probably be a part of the toolbox for every language with parametric polymorphism. Add typeclasses as they work great with the kind of language F# is. In general, take the good parts of Haskell as they will enable better libraries, but not too much as formal reasoning starts to get in the way of informal reasoning past a certain point. F# is nowhere near that yet. This is the impredicative polymorhism branch of the tree. 2) Make the language faster. That means pulling stuff out from the partial evaluation field and putting it into the compiler either internally or as staging. When it comes to adding staging features, don't go the OCaml and Scala route because all the staging annotations make the code look like dog vomit and break modularity, instead do dynamic staging which wouldn't be tracked by the type system, but will flow better in practice. This would be a power user feature, but powerful features are necessary to make great libraries and so are power users for that matter. Staging is one of the missing branches of functional programming and a challenge that no statically typed language adequately addressed as of yet. A language like F# would never be able to have full out intensional polymorphism like the one I am working on, but on the other hand having access to very predictable optimizations means that one would be able to use discriminated unions to emulate all of that anyway. Half-baked features like code quotations and type providers are always bandied about as F#'s benefits, but I am honestly skeptical about their actual value. They would be entirely subsumed by more powerful staging anyway. This would also open the door to the language eventually having a GPU backend. Today, if you take stock of which languages having such backends (Terra,D,Scala,OCaml) you will see that they having staging as a language feature or as a library or a strong focus on metaprograming like D (and C++.) These would be be the ad-hoc polymorphism and principled metaprograming branches. 3) The above two points being made progress on would in general result is higher quality libraries and would allow the language to set foot in the AI space instead of serving as a foundation for making a language that is good for that. This third point is on pattern matching. This is where some of the major improvements in expressiveness to the language can be made and this is where the language's core strength lies. Records need to be improved and made truly first class - one should not have to define a type for a record before using it. It should be as first class as using tuples. In the pattern matching syntax one should not have to write `{some_field=some_field}`, instead `{some_field}` should do. Add lens-like updates to them: `{d.coords with x = self + 1}`. Optimize active patterns so as to make them viable for perfomance intensive code. Get rid of that arbitrary 7 field limit. Make a note in the documentation that active patterns [can be passed as arguments](https://github.com/fsharp/fslang-suggestions/issues/611). Extend exhaustiveness checking to encompass partial active patterns. Also lists, arrays, records and tuples are great, but that could obviously be extended on. Why not add array views so they can be used as sequences? Why not make pattern matching extensible? If I take stock of which features of the language I use 99.9% of the time - ML had them 25 years ago. That core can be further refined. F# did a really a good job of deriving its indentation sensitive syntax from Python's. And enforcing the top down ordering. This is brilliant design. Sorry about the rant, but I got on a roll. My personal sense of things though is that given the difficulty F# has had putting in points in #1 which have been studied for decades, it has really no hope in ever getting to #2 which is beyond the state of the art. It could probably stand to do some of #3 as it would improve the ergonomics of pattern matching greatly, but language ergonomics is probably F#'s strongest suit so I am expecting things to happen there. The real question though is why wait for all that stuff for happen? By any measure, the mainstream languages move at a glacial pace. My advice to anybody who wants much more than F# or any other language can offer and does not see programming as either a job or a hobby is to make his own, piggybacking off the existing ones. It is the logical progression for a programmer once the glass ceiling is hit.
&gt; &gt; I recently wrote a website using F# running in Windows in AWS and I hated it but every web dev tool stack sucks as far as I can see and, in this case, I can just rewrite it as a WPF app. I still love WPF. &gt; &gt; You make some good points but I really must question one thing: are you seriously saying .NET on Windows is better than anything else for a web solution? Not at all, no. For web dev I'm saying everything sucks including .NET on Windows. If you want to write desktop GUI apps then .NET is awesome. &gt; Linux is king in the server world for a very good reason. If you want to use Linux (which I would always recommend for a "serious" server) then .NET Core seems to be much like everything else. Certainly a JSON over HTTP server I wrote in OCaml was 10x lower latency than an equivalent but binary over TCP server I wrote in F# which makes me think OCaml is great for that kind of work. 
&gt; By any real world measure, they are pretty much dead. Undead. Programming languages rarely die. They move into a limbo state where people tinker. &gt; When I realized that I've been left with the sense that something went deeply wrong with the academic community that they let things come to this state. Two problems there: 1. Academics aren't supposed to be developing and maintaining production code for the rest of us. The academic tools we enjoy are a side effect: they fall out of academic, often in a barely usable state. 2. If when they want to, academics generally fail really badly when they try to commercialise things. To the extent that I've even seen them commercialise something for the sole purpose of claiming that it has "real world" value on future grant applications. &gt; Higher kinded types and higher ranked types I couldn't disagree more. The last thing F# needs is changes to the language. F# needs stability in the language (i.e. no changes) and a solid foundation to be built upon, like .NET was before Microsoft decimated it. &gt; F# is nowhere near that yet. What you describe is a domain specific language for academics to dick around with. That's the exact opposite of what most people need, which is a simple pragmatic language that limits the damage rogue programmers do. &gt; This would be a power user feature That would benefit a fraction of a percent of the F# community. That's probably around one person in the whole world. ;-) &gt; Staging is one of the missing branches of functional programming and a challenge that no statically typed language adequately addressed as of yet. That's because it is basically a complete waste of time. Anything you want to do with staging is already better done using `Reflection.Emit` or even LLVM. &gt; Half-baked features like code quotations and type providers are always bandied about as F#'s benefits, but I am honestly skeptical about their actual value. They would be entirely subsumed by more powerful staging anyway. But it doesn't address the actual problem with type providers which is that web-based schemas change so far the type provider authors cannot keep up. The first demo was Freebase, which is dead. Now it is WorldBank, which is about to die. The docs are always out of date... &gt; a strong focus on metaprograming like D (and C++.) C++ does not have a strong focus on metaprogramming. The fact that C++'s template type system is Turing complete was discovered accidentally by someone who published a program that computed prime numbers at compile time. That is literally the worst possible place to start if you want to do metaprogramming. In the context of metaprogramming the piece of the puzzle that F# is missing is parsing technologies. Why doesn't it support inline lexers and parsers? OCaml did... &gt; Optimize active patterns so as to make them viable for perfomance intensive code That would be good. &gt; Also lists, arrays, records and tuples are great, but that could obviously be extended on. Why not add array views so they can be used as sequences? Why not make pattern matching extensible? Array and string views would be awesome. In ML pattern matching is supposed to be "linear" meaning a pattern with "n" leaves should match in O(n). But there are lots of linear patterns that aren't implemented, like matching the first elements of an array or sequence. &gt; If I take stock of which features of the language I use 99.9% of the time - ML had them 25 ago [40 years ago](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.67.5276&amp;rep=rep1&amp;type=pdf). &gt; F# did a really a good job of deriving its indentation sensitive syntax from Python's. And enforcing the top down ordering. This is brilliant design. Indentation sensitivity sucks. That's the reason why F# code always breaks when you cut and paste it from the web. Why not just allow: match foo with | A -&gt; match bar with | 0 -&gt; true | _ -&gt; false end | B -&gt; true end &gt; Sorry about the rant, but I got on a roll. No problem. Its all good stuff. But I think the first question needs to be: who is this language for? Because what I'm looking for is a million miles away from Haskell. &gt; By any measure, the mainstream languages move at a glacial pace. That's because software engineers move at a glacial pace. &gt; My advice to anybody who wants much more than F# or any other language can offer and does not see programming as either a job or a hobby is to make his own, piggybacking off the existing ones. It is the logical progression for a programmer once the glass ceiling is hit. Good idea. 
&gt; I couldn't disagree more. The last thing F# needs is changes to the language. F# needs stability in the language (i.e. no changes) and a solid foundation to be built upon, like .NET was before Microsoft decimated it. They aren't essential, but my argument for having those features in, is that if you were designing a functional language with parametric polymorphism from scratch, you'd definitely want to put them in because there are only so many good ones out there. And if not HKTs, at least higher rank types. Higher ranked types have various uses, but what I'd want them for is to pass functions of types `DM&lt;'a&gt; -&gt; DM&lt;'a&gt;`, and not have the `'a` instantiated to a monomorphic type. This is one of the driving reasons why I started working on my own thing - not being able to do the above essentially meant that I would have had to redo basic arithmetic for my library using union types to get the requisite polymorphism that I wanted. I'll admit that I do not have much reason to want HKTs. &gt; That's because it is basically a complete waste of time. Anything you want to do with staging is already better done using Reflection.Emit or even LLVM. This kind of argument tells me that the kind of staging I have in mind and you have in mind is worlds apart. I don't think I can even argue here, I'd be better off coming up with a demonstration and show exactly what I mean. I am not too far away from when I will be able to do that. &gt; C++ does not have a strong focus on metaprogramming. The fact that C++'s template type system is Turing complete was discovered accidentally by someone who published a program that computed prime numbers at compile time. That is literally the worst possible place to start if you want to do metaprogramming. C++ occupies a somewhat strange spot - I consider it uniformly horrible, but somehow or the other it managed to create the similar kind of allure that attracts people to languages like Haskell or Scala. More than once I've seen its type system described without irony as powerful. A lot of its future development seem to go in the direction of taking from the points #1 (typeclasses) and #2 (metaclasses), but not so much #3. Witness the recent thing which was posted on the /r/haskell sub to rave reviews - [Category Theory for Programmers](https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/). You expect this to be in Haskell, Scala or Idris, but it is in C++ of all languages. Why? I have no idea. But the reason this strange sort of intellectualism has developed around the language can be attributed to its metaprogramming facilities. As bad as they are, C++ deserves a mention when discussing metaprogramming not because of what it can do, but because of the community wrapped around it. &gt; In the context of metaprogramming the piece of the puzzle that F# is missing is parsing technologies. Why doesn't it support inline lexers and parsers? OCaml did... Stuff like this is pretty much the reason to have first class staging in a language and you don't know it. But I will forgive you because no language did it properly yet. Please look forward to the eventual demo of Spiral. &gt; Indentation sensitivity sucks. That's the reason why F# code always breaks when you cut and paste it from the web. To be honest, this argument always confuses me. Is copy pasting from the web something that is done a lot? I am asking, because I close to never did it in the last 3 years that I've been programming and if I did, I can't recall ever having trouble with it. Also why would it break just because it was copy pasted? The argument for indentation sensitivity is better aesthetics which is important for a language. &gt; But I think the first question needs to be: who is this language for? Because what I'm looking for is a million miles away from Haskell. Programming in Haskell and trying to get any measure of control of the program you are making will drive you into a berserk state and I mean this literally, but if Haskell did not have the purity and laziness ie. wasn't really Haskell, what would be left would be possibly one of the best languages in the world. It would be a very expressive ML variant, suitable for a far wider domains of application than it can be used for now. As it is, I see it as a language with the best done type system in the world. It is not the most powerful, that goes to dependently typed languages like Idris, or maybe to metaprogramming focused languages like D and Terra (and my own unreleased Spiral.) Many of its features on an individual basis would be worth bringing into other languages. The reason for my advocacy here is from the perspective of a language creator - there are only so many directions languages can evolve in and adding more impredicative polymorphism is one of them.
**Here's a sneak peek of /r/haskell using the [top posts](https://np.reddit.com/r/haskell/top/?sort=top&amp;t=year) of the year!** \#1: ["Category Theory for Programmers" has been finished!](https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/) | [38 comments](https://np.reddit.com/r/haskell/comments/6x7ms0/category_theory_for_programmers_has_been_finished/) \#2: [Typing the technical interview](https://aphyr.com/posts/342-typing-the-technical-interview) | [62 comments](https://np.reddit.com/r/haskell/comments/64lg42/typing_the_technical_interview/) \#3: [Lecture notes on Category Theory concepts and Haskell](https://np.reddit.com/r/haskell/comments/6oagzk/lecture_notes_on_category_theory_concepts_and/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
I recently wanted to try f# on my mac but found it really repelling to have mono installed for proper f# support in vscode. 
yeah man thats the problem with f# tooling, nothing perfectly works.. spent few weeks to just get intellisense on vscode windows still nothing.. sad.
Why? This is a dependency for the tooling, most likely because .NET Core doesn't (or didn't) have enough APIs to support tooling.
It works perfectly for me, if you can describe what versions of tools you installed and what steps you took maybe that's helpful information for the ionide team.
From the user perspective it seems mad building with .NET Core but having intellisense from a competing implementation.
Dotnet core is still kinda fresh, and there is a ways to go for a full F# experience on that platform. Mono is the .net runtime on linux, so until dotnetcore is 100% in all directions it's the current platform. The intellisense server is one such example (and the language isn't different on dotnet core...). If you're a .net dev you have 23 versions of the .net framework on your PC. If you're using anything npm based in your web stack or IDEs web stack you've got 9000 packages pooled together to get that working. On a mac or linux machine we pull tens upon tens of major tools down for CLI work and numerous multi-gig IDEs without blinking. I dunno how mono sticks out in that picture. You mentioned this was just trying out the language, and I see how installing X to do Y is odd. In perspective though: dotnet core will be ready for that kind of experimentation soon, F# on mono is ready for that experimentation now, and just about any development on the mac these days means comfort with a lot of dependencies.
&gt; They aren't essential, but my argument for having those features in, is that if you were designing a functional language with parametric polymorphism from scratch, you'd definitely want to put them in because there are only so many good ones out there. Ah, ok. For a new language I'd definitely consider type classes. &gt; This kind of argument tells me that the kind of staging I have in mind and you have in mind is worlds apart. I don't think I can even argue here, I'd be better off coming up with a demonstration and show exactly what I mean. To give a concrete example where I use reflection: to create efficient serialization functions. Would be interesting to do that with staged metaprogramming. Have you looked at MetaOCaml? &gt; But the reason this strange sort of intellectualism has developed around the language can be attributed to its metaprogramming facilities. As bad as they are, C++ deserves a mention when discussing metaprogramming not because of what it can do, but because of the community wrapped around it. That's fair enough. Having mentioned LLVM it occurred to me that it is entirely possible that LLVM's success is due to the fact that it is written in C++. On the other hand, if I wanted C++ code I wouldn't write it by hand... &gt; Stuff like this is pretty much the reason to have first class staging in a language and you don't know it. But I will forgive you because no language did it properly yet. Please look forward to the eventual demo of Spiral. I'm not convinced. The problem with parsing is that you want brevity and clarity. I don't think staging can deliver that (unless you include some kind of macro system). For example, compare regular expression libraries that parse strings like `[0-9]+` with those that use combinators: the latter are much uglier. &gt; To be honest, this argument always confuses me. Is copy pasting from the web something that is done a lot? I certainly do it a lot. &gt; Programming in Haskell and trying to get any measure of control of the program you are making will drive you into a berserk state and I mean this literally, but if Haskell did not have the purity and laziness ie. wasn't really Haskell, what would be left would be possibly one of the best languages in the world. It would be a very expressive ML variant, suitable for a far wider domains of application than it can be used for now. Agreed. A strict language with a pragmatic pure core would be very interesting. 
As a new F# user (coming from C# and Python) this was my biggest disappointment!
It would be really nice to have one, however I don't feel it is needed as much as for C# for instance. It should definitely not be a reason to ditch the language or the tools. I don't know about Python though, haven't used it in ages!
No! - having a great time with F#, no plan to ditch it anytime soon!
I've had similar experiences. I spent a day trying to get VSCode to work and gave up in the end. At one point it got itself confused and stuck in an infinite loop so I had to reinstall Ionide. After all that I am left wondering why they're reinventing the wheel when we already had F# working in MonoDevelop. Having an F# IDE working on Linux is nice but F# is a long way behind OCaml when it comes to OSS and none of the core benefits of F# are there (e.g. WPF). 
I've been running suave in production for 2 years now. It's fast, low footprint, stable and elegant. Can someone explain why I need giraffe?
The main raison d'être for Giraffe is the ecosystem: Identity / Identity Server, third-party UI libraries, stuff like that. A secondary reason is that it's orders of magnitude faster. If neither of those apply to you, then you don't need it.
Ionide also works on Windows with full .NET. In contrast to VS2017 Community you can use it commercially for free. Having the same experience on every platform is also nice. If you can trace your steps on how it didn't work for you, you could help the developer community find a solution. They're very helpful and take issues seriously. OCaml is terrible on Windows, which is why I initially got into F#, because my work computer is Windows.
&gt; If you can trace your steps on how it didn't work for you, you could help the developer community find a solution. They're very helpful and take issues seriously. I will try but it is mostly very basic stuff. Part of the problem is that VSCode's UI is completely alien to me and way it conveys messages is really unclear. When it comes to Ionide, I'm not even sure how to do basic things like compile and run a project. Some docs say F5 but I tried that and it does nothing. 
It's faster than suave? Is there a benchmark?
https://github.com/Krzysztof-Cieslak/Suave.Kestrel/issues/1
I find it weird that the title and the first paragraph attempt a comparison between C# and F#, while the actual comparisons are F# vs. C++. I think you get similar productivity boosts going from C++ to C#. C# to F# might be a minor boost if you ask me, but nothing major. Also I always hear this talk about implementing DSLs, yet I've never felt the need to do that. Is that something that a lot of people do?
Implementing DSLs can be a huge time saver for some applications, especially if there is a lot of data to maintain internally or by power users. At my old job, we needed a way to define various types of survey tasks/questions. We thought about creating a full GUI to do this, but realized it would probably take weeks, be full of bugs, and even then we would still get feature requests all time time, and adding a new type of question would take a long time too. We opted to do it with a DSL instead, and 1 person finished it in a day or two. And guess what, it had cool features like "Duplicate Question" built in ;) (Ctrl-C, Ctrl-V).
If you worked for awhile I think you probably done DSL:s but you might have called it something different. For me a DSL could be a configuration in XML, JSON, C# or F# that describes what you want done rather than how to do it, declarative vs imperative. With regard to F# I personally think F# has benefits over C# but I don't think 100x performance improvements can typically be expected. That is more likely due to a better understanding of the domain that allows for a better solution.
Yes, I think so, too, I like F# and I think it has some great stuff that even C#7 doesn't offer, but I'm still writing C# so others can maintain my code, it's not that big a difference. But C# is already hugely more productive than C++ in terms of writing something useful. And I think in terms of the medium complexity programs I usually write, they'll even perform better than the C++ version, just because I have more time left over for tweaking the code, which in C++ I'd usually use for making it work in the first place. I also think C# and F# are much more productive than Python (except when there's a simple library doing everything, which is often the case with Python, but not really because of the language).
Yeah, some of my colleagues don't even want to use the command line. There might be an in between in DSLs that I haven't thought about yet. I
Thank you! That is an impressive speedup. So Suave is faster than MVC on kestrel. But by itself more than twice as slow.
Perhaps the reason developers aren't flocking to F# because they don't perceive it good enough compared to the competitors. I personally love F# but my first experience with programming languages in Uni was SML and I liked the ML syntax. Only later did I become indoctrined in C++ syntax. Perhaps the ML syntax is just off-putting to most? I have talked to developers that can't understand "fun x y -&gt; x + y" but if I rewrite it into JavaScript code they easily grasp it. Look at kotlin, getting more popular by the day and it has a syntax close enough to C to make people raised in Java/C#/C++/JavaScript comfortable. Perhaps developers realize F# is only 5 years older than C#, F# is hardly a new language anymore and if it hasn't caught on until now why should developers pay any interest? Perhaps Microsoft realizes that in order to get any traction at all with F# they have to invest a huge amount of money to promote F# but to what gain? To shut up the F# community? I am ready to accept that I might be in a minority in that I like functional composition and ML style syntax and the world might never be ready for F#/Ocaml. PS. If quora.com is any guide not only F# struggles, Scala/Ruby also seems threatened by Kotlin/Python respectively.
You know it's a legit programming article when it promises a 10x productivity boost just for changing languages. I like F# but it's not a silver bullet. 
"Productivity" is the wrong metric, i think. It's more about reliability. C# feels more productive because you're wacking out more code and have better IDE support. If find though that you end up writing much more code to achieve a comparable level of safety. It makes my wrists hurt thinking about it.
C# feels very productive in the very short-term because you can effectively drive the IDE with ReSharper and have the code seemingly write itself. But after four hours of that, you still end up with less concrete goals accomplished than if you had used F#. C#, and by some extension, ReSharper, are riding on developers feeling productive in short bursts of activity, rather than the metric which really matters: how fast you can safely produce working code.
&gt; You know it's a legit programming article when it promises a 10x productivity boost just for changing languages. OP here. 10-100x productivity boost going from C++ to F# has been my experience for over 10 years now. 
&gt; I'm wondering though, whether people are using the F# compiler as part of their program when they make these DSLs or if there is any better way (like eval in Python) to make this happen. I don't want to distribute the F# compiler with every program I give someone. I haven't used the F# compiler or even the .NET JIT in commercial DSLs. Performance has rarely been a requirement and, even when it was, the performance requirements were very tame. 
&gt; I personally think F# has benefits over C# but I don't think 100x performance improvements can typically be expected Huge performance gains generally come from having real-world deadlines because the productivity of F# means you can try many different approaches and pick the best one. In that case, it was due to completely rearchitecting the system. The original architecture had been completely crippled in order to make implementation in C++ feasible. For example, no async, three threads per connection, seven global locks taken out everywhere, no message queues and so on. 
&gt; I find it weird that the title and the first paragraph attempt a comparison between C# and F#, while the actual comparisons are F# vs. C++. Yeah, sorry about that. I just presented the data I had. &gt; I think you get similar productivity boosts going from C++ to C#. Memory safety would be a huge one. &gt; C# to F# might be a minor boost if you ask me, but nothing major. I think it is another leap again but I have precious little experience of C#. For example, in a C# part of the commercial code base I mentioned in that post I noticed that they had wrapped `decimal` to create `Price` and `Quantity` both of which were classes and then devoted over half of the entire code to implementing `null` checks everywhere and then written 200 lines of code to check that the `null` checks were working. You simply don't get that in F# code. Algebraic datatypes and ML-style pattern matching are another major benefit F# has over C#. Check out this [symbolic differentiation example](https://codereview.stackexchange.com/questions/11804/symbolic-derivative-in-c) I wrote a while back. Same with structural equality, comparison, hashing and pretty printing. These benefits are amplified by deeper features like `MailboxProcessor` because you write your message catalogues as union types in F# rather than class hierarchies. 
Unless you have (non-anecdotal) data to support that claim, I'd recommend going for a qualitative argument rather than a quantitative. "10x" is not very descriptive, and basically a meme at this point. If you instead talked about the ways that F# increased your happiness or efficiency in some way, there would be some reason for a reader unfamiliar with F# to look further. Either way, you need examples- the uninitiated doesn't have any idea what F# is, so this just blends in with the background noise of "Rust makes your code 10x safer", "Go makes your code 10x faster", "Coq makes your code 10x more confusing", "Why I left Java for Node.js".
Are you even aware C# and C++ are not the same?
&gt; Unless you have (non-anecdotal) data to support that claim "Implemented in F# in 4 hours a feature that had been scheduled to take 3 months of development in C++" isn't anecdotal. 
&gt; in a C# part of the commercial code base I mentioned in that post I noticed that they had wrapped `decimal` to create `Price` and `Quantity` both of which were classes and then devoted over half of the entire code to implementing `null` checks everywhere and then written 200 lines of code to check that the `null` checks were working. You can declare structs in c#, which are value types and so can't be null (unless you want them to, with `Nullable&lt;&gt;`).
I don't use resharper to be honest. But C# doesn't just feel more productive than C++. I can really write it much faster.
sadly it is until you specify what kind of application, which programmers, what kind of experience and background and possibly source code. A "4 hours F# feature" is hardly something that is worth talking about.. it could just have been something with a good map or library ready F# (or .NET). The context is simply not optional when making claims like these.
To me it is the power of composition. I am talking about partially applied functions that take other functions as arguments being used to build flexible pipelines. I have often found that I've written one tenth the code just to realize that all the blocks are there to finish the application shortly after, I just have to compose them together. Which is fairly easy in f#. I don't worry about object oriented design at all. Data is data in the end.
&gt; a feature One example. That's pretty much the dictionary definition of anecdote. Let's not discount it entirely, but it is what it is.
That's not the real point though, the point is that types like `Price` are useful even if a price is always decimal, never using them is called [Primitive Obsession](http://wiki.c2.com/?PrimitiveObsession). It will stop you say assigning widget a's price to widget b's length. 
Have you tried https://xyncro.tech/chiron/ ?
The feature was low latency matching of AoN orders on a stock exchange. 
Yes and I did point that out to them. However, `null` remains a massive problem in C#. 
Ok, NP. The feature was part of a stock exchange for commodities trading. The matching algorithms for exotic order types get hairy. That feature was for implementing one called low latency matching of AoN orders. The C++ developers had ten years experience on that application (trade matching). I cannot give you the source code because it is owned by the client, of course. 
Did it require fairly specific knowledge of the MSIL generated? Like, you weren't just using Seq.fold, right?
Yes, he's aware...
&gt; Did it require fairly specific knowledge of the MSIL generated? Not really, no. The only thing I can think of that boils down to specific CIL is tail calls but you don't consider them at that level. 
Fascinating.
"functions as first class citizens"
slideshare is blocked. Can you share a link on speakerdesk or pdf? Thank you
The slides don't really convey much content. Maybe the talk was great, but it's kind of missing.
[removed]
Really? Because every single post he has made, including the original submission, is evidence to the contrary. Every time someone has said C# he talks about C++
These slides are from [this talk](https://www.youtube.com/watch?v=WI9bNWzTkxs) I gave back in 2013.
See my other comment for a link to the video on Youtube.
I find rider to be better than vs. just use cli to generate the project if you are using core 2.0
If you use cli tooling for dotnetcore 2.0 to generate projects, it is a better choice imho. They are fixing this with new release. Faster, and more refined and lightweight.
I know who the OP is, and he knows his shit, at least when it comes to F#/C#, and scientific/technical computing on the .NET platform....in the comment you responded to, he was referencing the previous solution to demonstrate the multithreading challenges the application faced. Do you really not get that?
Alt account alert. And no, that's not what is happening at all. So there isn't "that" to get. OP doesn't know C# and C++ are different, as demonstrated by this very thread.
LOL. OK...have another cider, mate.
&gt; I don't worry about object oriented design at all. Try explaining that to anyone at my university. They'll look at you as if you're some kind of idiot. Obviously Java is the only good language, right?!
I feel you. 
Clicking on jdh30's name will answer the question for you. You'll find, among other things, the other thread he just posted: https://www.reddit.com/r/fsharp/comments/75diwx/using_f_to_change_the_way_we_work_slides/. Look at the slides and you'll find his real name, and slide 2 mentions his work experience. Yes, he's aware of the difference.
Since some people use the number 10 inaccurately, we should stop using the number 10? Since not everyone's experience is the same, we should avoid learning from individual evidence?
10x is fine as long as you can back it up. If I tell you that listening to Pink Floyd makes you write code 7x faster and it's 5x safer, would you accept that at face value to be universally true? What about "switching to Dvorak speeds you up by 10%" or "switching from emacs to vim is 50x easier on your wrist". I doubt you'd agree based solely on my time writing a feature once. Anecdotal evidence does have a place, but you can't extrapolate anecdotes anymore than you would a psychological study with a single participant. That's why adding arbitrary numbers to support a fact is 12.7x more likely to weaken your argument by at least 1000%. The arguments listed above could all be made to have value by presenting them as personal experience, rather than assuming your experience is universal. 
So this does not affect F# because UWP does not have support for F#?
That's "poorly implemented" vs "better implemented" not F# vs C#.
Just to respond: I have used this library and it works well. However it has been quite a while since it was last updated, and it is built against .NET Framework 4.5.1 so there may be some trouble if using in a .NET Core/Standard-compatible application.
"Implemented in F# in 4 hours a feature that had been scheduled to take 3 months of development in C++." That is quite some claim.
Yeah same. It doesn't help all the 'serious' F# people seem to be on Windows. I don't feel I can make the commitment to F# until this changes as I only work with non Windows environments.
It kinda does. UWP using their own CoreCLR was a blocker iirc. They still need F# support in .NET Native though. I imagine it'll come but .NET Native is still a beta effectively.
Jon Harrop has been measuring many aspects of code reimplementations for a long time. This is not arbitrary. All his own experience, and not controlled trials - the developer is sometimes but not always held constant. Nevertheless highly valuable experience to people contemplating similar projects. I'm sure if you gave him a few million dollars he could set up controlled experiments for you. I would not accept your statement on Pink Floyd because I don't know your credentials, your reliability, and 7x faster is implausible and most importantly 5x safer is meaningless, rendering the entire statement meaningless.
If you compare a feature that fits F#'s structures well, Talented developer coding a feature that fits F#'s structures well, compared to ordinary developers using a difficult and unsafe language where it is very hard to get something to work first time, for a project where the development time was hard to estimate. Impressive but not so extraodinary. I felt the same way writing mathematical expression parsers: discriminated unions, type safety, and functional features made it much easier than we had expected, and losing even one of those features would have made it a much harder task.
People complain so much. .NET core is very new, implausible to expect fully functional support immediately. If you need perfect support now, just install Windows.
It depends quite heavily on reflection so it might be problematic for .NET Core but probably quite reasonable to move to .NET Standard 1.6+. I am by no means an authority on this though so I advice you to take a second opinion before you let this guide your efforts. 
Appeal to authority aside, I'm not attacking anyone's credentials or work. I'm simply stating that as an article of persuasive writing this piece is lacking. If he had gone into any depth about his experience with F# it would be different. Most importantly: **if you don't have data that provides a number, don't use a number**. This is essentially *lying*, as you've pulled some figure out of thin air and are presenting it as some kind of fact. If Linux Torvalds came out tomorrow and said C++ is 100x faster than F# and it only took him four hours to rewrite a feature someone thought would take longer, would you accept that at face value because he has a lot of C++ experience? Do you think any F# users would just drop everything and switch to C++ because of that? The writer of this article may be the most qualified man in the world, and he may even be correct about his estimate, but without any kind of evidence backing it up the reader has no reason to accept the assertion. If a highly-acclaimed, highly-expensive consultant were hired to do an analysis by some company, I doubt they would be glad if at the end of a lengthy process he came back with this to convince them to uproot their entire development stack for a new language- especially if he only had a single data point (1 feature) to support his findings. I'm sure most would expect some kind of explanation of *how* this change would benefit them, because we all hear about some new language that will change our lives forever on reddit once a week. I have no problem coming up with examples of how F# is nicer to work with than C#, so I find it odd to advocate for a language's features without naming a single feature. P.S. I have decades of experience listening to Pink Floyd and writing code, and I once wrote an automation script in the time it took to finish Dark Side of the Moon, even though I thought it would take 10 hours or so. I can't believe you didn't know that about me from what I wrote.
I think [this](https://www.youtube.com/watch?v=9_pluQPfbBk) was the guy who wrote the C#. He is widely regarded as a professional. He travels the world giving presentations on how to properly implement things in C#. I watched him do the best he could. Given the limitations of C# as a language I could not have done it better myself because such solutions are intractable in C#. I see no merit in calling it "poorly implemented" when it reflects the vast majority of code written by professional software developers today. And doing so completely ignores the fact that F# makes such things easy. 
[There](https://channel9.msdn.com/Events/Build/2016/B829#time=12m46s) are many [reasons](https://channel9.msdn.com/Events/Build/2016/B829#time=17m50s) for why [we need](https://channel9.msdn.com/Events/Build/2015/2-692#time=4m02s) UWP on the desktop too. See [more here.](https://channel9.msdn.com/Events/Build/2017/B8011) In addition, this also gives you better Windows integration, [granular privacy control](https://www.howtogeek.com/221864/digging-into-and-understanding-windows-10s-privacy-settings/), improved [battery life](https://youtu.be/GJ2ClkCImtM?t=3576), and modern UI apps have better [fullscreen multi-tasking.](https://www.reddit.com/r/Windows10/comments/65t3tg/so_edge_has_fullscreen/dgd496f/) UWP apps are very capable. For example, [Adobe Experience Design](http://www.adobe.com/products/experience-design.html) is a full fledged professional creative UWP app, distributed outside the Microsoft Store. Also many Windows devices sold these days have [pen &amp; touch screens, or are 2-in-1 tablets that benefit a lot from full proper UWP apps.](https://np.reddit.com/r/Surface/comments/6pnk4q/windows_10_tablet_mode_woes/) There is also Xbox, HoloLens, IoT, Surface Hub that use UWP. And although the Windows Mobile platform is being phased out, doesn't mean that there won't be small mobile telephony capable devices (Andromeda) running full Windows on ARM in the near future. [**Here is a list of some technical benefits of using UWP:**](https://np.reddit.com/r/Windows10/comments/75lgti/announcing_uwp_support_for_net_standard_20/do7mcn2/) * UWP apps run in a Sandbox(virtualized environment). A massive security boost. so No need to worry about an application hijacking your system. * When you install UWP app, it won't create folders where it shouldn't. there will be No file spreading between AppData, ProgramData, System32, Program Files etc.. also UWP solves DLL files problem on Windows. * It won't create registry entries slowing Windows down over time[(boot times)](https://channel9.msdn.com/Events/Build/2016/B829#time=17m50s). * Clean installs with two clicks (also They can't come with adware, browser extensions or extra software attached). * Clean uninstalls without leaving anything behind in two clicks(that removes all files and don't clutter the registry or your file system with hidden files) * They work and sync across devices (desktops, laptops, tablets, phones, IoT devices, XBOX One, HoloLens, Surface Hub). * Constant seamless updates from one place (Windows Store) with the ability to either manually/individually or even automatically update them. * It's great on resources (when you minimize a UWP app, it becomes a suspended process with 0% CPU time, memory usage might reduce to 0.1MB) * These apps won't interfere with other apps because they share a certain resource together, thus if one app messes up that recourse, the other doesn't just stops working. * Properly adjust to your screen size and adjust their UI when you resize/corner snap them. * It has superior power management so Uses less battery if you are on a battery powered device. * works great on High-DPI screens including 8K extremely high resolution screens. * Unlike Win32, It runs on ARM devices natively. * You download them from a secure place, you don't have to worry about downloading malware or endlessly searching the web for these apps (very handy for casual users and older people). * If you buy a paid software the entitlement/purchase is tied to your Microsoft account so you will never have to remember additional license keys/logins/credentials and you can use it on up to 2000 devices with the same account. * it takes full advantage of native windows 10 features like notifications, Share menu, live tiles, Windows Hello authentication, OneDrive settings sync/backup, and Cortana integration. 
I couldn't disagree more. Half of the industrial projects I have done using F# have been things that C++ or C# developers had either never considered or had ruled out as being completely impossible to do. Compilers are a great example. I've written many compiler in industry and F# (as a MetaLanguage) excels at it. Yet most programmers in industry regard compilers as some kind of magic and never consider writing one as a tool to get their job done. 
Wow, I am really disheartened to hear you say that. :-( 
&gt; if you don't have data that provides a number, don't use a number. This is essentially lying Absolutely. That's why I quantified "Implemented in F# in 4 hours a feature that had been scheduled to take 3 months of development in C++" when I wrote the original post. 3 months is ~2,000 hours so the productivity improvement in that case was 500x. 
The GC is a mystery which can be problematic. For example, some things I expected to improve latency actually made it worse. 
Protip: use phantom types to do that. 
Reliability is certainly a massive issue as well. After over 10 years of using OCaml and F# I am still consistently amazed at how easily I can write large software projects from scratch with no testing and they work perfectly first time. Compared to C++ it really is like magic. 
You have some very strange and arbitrary restrictions listed as "common" in C# which is frankly false, or possibly are from systems old enough that they pre-date the features that make those restrictions uncommon in today's software world. `async`/`await` means asynchronous C# is now much more easily developed, no more difficult than F#'s `async {}`. You are comparing raw speed and CPU activity when one is using WCF (ergo SOAP and all that XML and declarative markup over HTTP) and the other Protobuf - a binary serializer socket-to-socket protocol designed for speed. Frankly in that entire comparison what you've done there is say "Hey guys, we took that race car driver and gave him some new shoes, now he races 90x faster, 10x more efficiently, and he looks rather snazzy too. All because of the shoes! Oh we also gave him a new car that has 1,000 more horsepower than his previous car, much stiffer suspension and better brakes but .. details, eh?" And to top it all off, that is your _first_ post containing any content about C# when you have been comparing to C++ the rest of the time. You have no data on how that same code would perform under C#. You've converted something from C++ to F# and decided to point a finger at C# along the way. 
&gt; You have some very strange and arbitrary restrictions listed as "common" in C# which is frankly false, or possibly are from systems old enough that they pre-date the features that make those restrictions uncommon in today's software world At that time, async in C# was considered too immature for production use by the client so the C# solution was entirely synchronous and WCF was burning threads and the GC was suffering because it had to traverse all of those thread stacks. &gt; asynchronous C# is now much more easily developed, no more difficult than F# That's a strange statement. Async in F# composes, handles exceptions and provides higher-level abstractions like `MailboxProcessor`. Async in C# is better than nothing at all but you still need to be very careful to propagate exception handlers manually and there are no higher level abstractions built-in or even union types to represent message catalogues. &gt; details, eh What details would you like? &gt; You have no data on how that same code would perform under C# I've given you several case studies from real industrial code bases using F# and either C++ or C#. If you're interested in C# then look at the C# ones. &gt; You've converted something from C++ to F# and decided to point a finger at C# along the way. If you're not interested in C++ then ignore the case studies comparing F# with C++. 
&gt; At that time, async in C# was considered too immature for production use by the client so the C# solution was entirely synchronous and WCF was burning threads and the GC was suffering because it had to traverse all of those thread stacks. If the project was done today then it would probably use async WCF. So it is an arbitrary restriction, entirely not the fault of C# but that of the client, to use synchronous WCF (and WCF at all) yet somehow magically this restriction is lifted for F#? Disingenuous comparison. &gt; Async in F# composes `Task.WhenAll` =&gt; composed Task, in a simple form. &gt; handles exceptions `AggregateException` captures all exceptions (and their contexts) raised during a `Task`'s lifetime. &gt; provides higher-level abstractions like `MailboxProcessor` Rx.NET. &gt; In practice, the modern C# code I've seen in industry usually uses global mutables to work around these problems and then, of course, they hit concurrency bugs. You may have seen people using global state, but that's far from making it a fault of the language. &gt; What details would you like? Some involving C#, when you are posting something with the title like that of this thread, wouldn't go amiss. Let's just ignore that that "details, eh?" was part of the metaphor. &gt; If you're interested in comparisons with C# then look at the case studies I've presented involving C#. I would, _if you posted them_. &gt; If you're up for a challenge, (this problem)[https://www.theice.com/publicdocs/technology/Additional_Implieds_FAQ.pdf] found in the finance industry is easily solved (like this in F#)[https://zbray.wordpress.com/2011/11/02/solving-the-0-1-knapsack-problem-using-continuation-passing-style-with-memoization-in-f/]. Consider translating it to C#. An actual fair demonstration on why F# may be better suited to a given problem than C#. Slightly more specific than your OP. 
I typically joke about never having to write F# unit tests and deploying straight to production. It drives the javascript devs at my company crazy. The confidence that code work the first time seems totally absurd to people, but it's warrented in my experience.
Why? Humans don't like being shown that they spent years learning and practicing something that is far less than ideal.
Alrighty there mr. bot, you forgot one thing though: UWP is a dumpster fire that only works on one version of windows. It’s universal in the sense that I can call anything universal!
UWP runs everywhere modern Windows runs.
So do browsers, which have more reach, and the largest UI ecosystem out there. So does WPF, which is rich and mature. So does WinForms, which is still the best way to throw together a quick UI. These all have two things in common: 1. Not garbage tech 2. Also works on other windows versions
Consumers don't want [inefficient, bloated, ugly battery killing WPF legacy apps](https://medium.com/@vitorgrs/uwp-vs-wpf-a-simple-listview-performance-comparison-c53e44782f23), with bad user experience on [modern Windows devices.](https://np.reddit.com/r/Surface/comments/6pnk4q/windows_10_tablet_mode_woes/) Stop spreading bad advice if you care about the future of Windows. WPF is in maintenance mode, even Microsoft doesn't use WPF for new projects anymore.
I’m going to ignore whatever nonsense you just wrote and say that UWP is garbage again
&gt; So it is an arbitrary restriction, entirely not the fault of C# but that of the client, to use synchronous WCF (and WCF at all) yet somehow magically this restriction is lifted for F#? Disingenuous comparison. Async was mature in F# and new in C#. &gt; Task.WhenAll =&gt; composed Task, in a simple form. Doesn't compose. &gt; AggregateException captures all exceptions (and their contexts) raised during a Task's lifetime. Great. You can manually work around the problems with async in C# using that then. &gt; Rx.NET. Is completely irrelevant and, FWIW, I removed it from all production systems because it was also too unstable. &gt; Some involving C#, when you are posting something with the title like that of this thread, wouldn't go amiss. Let's just ignore that that "details, eh?" was part of the metaphor. I just did and you're getting all emotional because these facts undermine your ideology. &gt; I would, if you posted them as part of this submission I wouldn't be having this conversation at all. I led the horse to water. &gt; An actual fair demonstration on why F# may be better suited to a given problem than C#. Slightly more specific than your OP. So you regard complete working code as "slightly more specific"? 
I mean I'm disheartened to hear that Java is still being taught. 
Frankly: Bullshit. I'm not spouting any kind of ideology. That's you. You're projecting now. Tell me, where in your original post (except the title) is there _anything_ remotely factual about F# over C#? No data, just speculative numbering with no evidence. It's blogspam. Read your OP again. The only scenarios you mention in a "F# vs C#" comparison post _are between F# and C++_. 
If I ever meet you in person, I would like to buy you a beer.
[removed]
They underestimated the collective stupidity of corporate America. Software development as a job, not passion. You got lucky with ML being taught. All I heard about functional programming was a few obscure mentions on /. One time I mentioned at work that my favorite language is F# - reaction was: "Eww isn't that based on OCaml? I hate recursion!".
Try mono helloworld.exe
Thanks it worked! Is there any way to make a file that I can run with `./`?
[removed]
.NET applications aren't native executables, they're like Java .jars in that regard. You have some options available depending on how far you need to go, [this page lists them](http://www.mono-project.com/archived/guiderunning_mono_applications/). Note that on most desktop environments .exe files will be automatically associated with `mono`, so you can just double-click them. 
Not really. Real-world mono applications are generally deployed with a small shell script that invokes `mono` on the `.exe`. In fact, `fsharpc` itself is a shell script that invokes `mono` on an `fsc.exe` located somewhere in your system.
With .Netcore2 and packet support Rider seems better choice for F# development than VS2017... What a shame
VS has a Community edition (free version of VS), whereas Rider does not (as far as I'm aware). I tried Rider when it was in the beta version and it was very slow. It is also a bit too expensive (for me). Personally, I like to use VS Code (as I mostly write F# on Linux), but I don't use F# professionally (yet).
I cannot try it out right now, but I think what you need is this: chmod +x helloworld.exe A file needs to be have the "executable" flag in its permissions. After that you can just go ./helloworld.exe ...and it should work.
&gt; I'm not spouting any kind of ideology, nor do I possess one You just happen to be rejecting all facts in one direction because they disagree with your beliefs. &gt; except to make an argument you must post relevant data. Which I have done. &gt; No data, just speculative numbering with no evidence. I just gave you data. &gt; e: as for your posted "evidence" LOL. Supposed "facts", yes. &gt; I think you'd actually struggle to find anything more skewed in F#'s favour. There is no skew. &gt; I mean honestly.. sync WCF vs async Protobuf.. Not a fair language comparison at all. The same specification was given to professional F# and C# developers in industry to solve a real problem. They chose to solve the problem in different ways. The C# developer chose to use WCF because it helps to alleviate some of the deficiencies in the C# language. The F# developer didn't need to. 
Bullshit. You keep rejecting scrutiny that is pointing out your blatant bias and flawed comparisons.
&gt; Bullshit it was anything but fair. You keep rejecting scrutiny that is pointing out your blatant bias and flawed comparisons with even more unfounded and arbitrary reasons that you do not apply to f sharp. Pure emotion. &gt; If your blog presented the knapsack problem like you did to me then it might have meant something. As it is it's just a zealot pulling numbers of of his arse. Rejecting facts. The only interesting part of your comment is this: &gt; You fail to acknowledge that the choice of different protocols is not a choice of language for a start. I fail to acknowledge that because I know for a fact that it is completely untrue having actually done the experiment myself. I wrote the Google protobuf implementation as a simple combinator library in F#. He didn't even write a single combinator in the entire C# solution. Why not? Because that is much harder to do with C# than it is with F# due to missing language features like automatic generalization, type inference, tail call elimination and so on. Why didn't he just hand code the entire Protobuf library? Oh, because that would take 10x more code in C# and he had one of those real world deadlines to meet. So, again, you are just trying to discredit facts using ideology. Or do you seriously believe that different people using different tools will always solve the same problem in the same way? 
No I believe when comparing languages it is important to do so in an unbiased and equal manner, not by taking a synchronous WCF service and comparing performance to an asynchronous, parallel Protobuf implementation and deciding the only factor was choice of language.
I know it may be not popular opinion, but if you work with .Net stack 649$ for ALL Jetbrains products is a good price... I'm not affiliated with them.
From a consultant, or paid developer perspective I totally agree. Around data science, academia, in the government and such any money for the 'base package' can be a barrier to acceptance. F# DSLs and an editor plugin can give you a user friendly free-as-in-beer data management tool, and with git(hub) integration built right in open some very interesting scenarios with lightweight editors.
It's a ridiculously great price. Honestly, if you're using . Net you should be using their products. All of them are Free for students as well.
What's the .NET Core equivalent?
My university is in germany... all courses except a handful are taught in Java. "Computer Science".
They are preparing you for being a corporate coder working on some cms or b2b. No one in those places cares about anything but java and if you're lucky .net.
&gt; No I believe when comparing languages it is important to do so in an unbiased and equal manner not by taking a synchronous WCF service and comparing performance to an asynchronous, parallel Protobuf implementation and declaring the only factor was choice of language. You're acting as if those different approaches were required of the different developers but they weren't. The developers were given the same specification and the same dead line. 
Wow, that is really interesting and amazing to me. I must say: it sounds like a complete waste of time. Just FYI: I have a son at school here in England. He is naturally good at mathematics and likely to pursue a similar subject. My advice to him is: think seriously before enrolling in a University course because I am not at all convinced that a University education is worth having these days because you can get such a good education by teaching yourself using the internet. Indeed, it would probably be more valuable if they taught school kids how to teach themselves using the internet. 
&gt; So does WinForms, which is still the best way to throw together a quick UI. Really? I always use WPF. The main thing WinForms seems to do better is grids, which are insanely slow in WPF. 
No. *You* are acting like those different approaches were required. Remember when you said that "the client" refused to allow async? That was you, not me. You specified an arbitrary restriction on the C#. You're deranged and lying to yourself and others. This is far from a fair comparison, objectively and demonstrably so. You are _choosing_ arbitrary and biased restrictions for C# but it's carte blanche for F#. Then disingenuously presenting the result as a victory for F# over C# - even when C# isn't even in the comparison. It's a horse race and you've cut one leg of every horse except the one you want to win, then declaring that it is simply because your horse is better at racing than the others. 
&gt; And although the Windows Mobile platform is being phased out, doesn't mean that there won't be small mobile telephony capable devices (Andromeda) running full Windows on ARM in the near future. That is one killer problems that makes this development pointless. The other killer problem is that it doesn't support F# anyway so it is completely irrelevant. 
I think is (I did it once two days ago) First create the project dotnet new console Build it dotnet build Run it dotnet ./bin/...don't remember../helloworld.dll
&gt; No. You are acting like those different approaches were required. Remember when you said that "the client" refused to allow async? That was you, not me. You specified an arbitrary restriction on the C#. C# async was in beta release at the time. The client didn't want to put beta release software into production. Anything that was in beta for F# would have been prohibited as well. &gt; You're deranged and lying to yourself and others. More emotional response to facts. &gt; This is far from a fair comparison, objectively and demonstrably so. It was completely fair. You just don't like the outcome. &gt; You are choosing arbitrary and biased restrictions for C# but it's carte blanche for F#. Nonsense. &gt; Then disingenuously presenting the result as a victory for F# over C# - even when C# isn't even in the comparison. F# was a clear winner in every respect. &gt; It's a horse race where you've cut one leg off every horse except the one you want to win, then declaring that it is simply because your horse is better at racing than the others, completely and totally ignoring the missing legs that you chose to remove. I placed no restrictions on the C# development whatsoever. In point of fact, once I'd finished the F# solution well before the deadline I went over to the C# developer and helped him. &gt; edit to your edit: Protobuf is available to C#, too. Stop pretending WCF is the only option to C# developers. Where was Protobuf built into .NET 4? 
Your examples are OK but the rules you are promoting are far too stark. For example here: "If you don't have data that provides a number, don't use a number." Numbers naturally occur in estimates or predictions. Some variables are quantitative and even if there is no hard data you need to use numbers to think and communicate about them. There are special cases in which rule holds, e.g. don't publish academic papers where the main conclusion is that a certain variable is a particular number and there is no hard data to support that. But you can't apply that to all communcication. If you did then the papers you do approve of would largely not exist as the authors would not be able to think or communicate prior to gathering quantitative data.
Until F# gets windows mobile support with uwp it will forever be a second class citizen!
I think that it is, and always has been, a 2nd class citizen. But it is still useful 
I think UWP will die before F# does. See the [Desktop bridge](https://developer.microsoft.com/en-us/windows/bridges/desktop).
"Reach all Windows devices" with UWP. That will be 99.9% desktops and almost nothing else. 
Nah, that's just FUD. Pure FUD. Windows Phone is on the brink of taking over iCrap any year now. And later this year, MSFT is going to completely change the game with Surface Phones. It's going to be a revolution, all on UWP. F# has to be at the forefront!
You sir, are the heart and soul of this subreddit. Bravo!
As long as Microsoft does not go with the philosophy of "every little piece of our tool/kingdom has to be lined up' to achieve that single so-called 'vision' (nth version), F# will be viable. For some 'viable' has to mean having 100% ide support *and* be able to write an end-to-end app addressing all major platforms. For some viable means being able to write some useful part of the toolbox/workflow that makes me productive and gives me all the benefits of an ML style practical language ( all the deriving pleasure in the act).
In my opinion MSFT doesn’t care at all about F#. It came from Microsoft research without business support and now it’s really maintained by the open source community, which is really awesome, really smart and hard working people. They just included it as supported because it is successful in London’s financial sector imo. I mean, the F# templates for asp.net haven’t appeared until asp.net core 2! MSFT didn’t even cared about creating a damn template, or good VS support for TEN years. The visual studio for Mac (xamarin studio previously) is better for F# than the windows version... They can’t kill it, but surely never has been a priority, and probably never will. Like VB.NET but even worse...
Rust is the functional language everyone seems to love these days. I can’t say if it does things F# can’t, but in such a situation I would strongly consider moving to Rust. It typically takes me only a week or so of writing in a different language before I “get it” enough to not have to hit Google/StackOverflow every 5 minutes.
FWIW, I tried Rust and found it seriously lack-lustre. The "borrow checker" basically forces you to annotate your code to the extent that you might as well be doing manual memory management. 
&gt; F# had more attention and support from Microsoft when it was first released but that doesn't change our ability to use and enjoy it. Really? I just read a Quora question asking for recommendations on a first programming language for a child. I myself have a son who is interested in learning to code. A few years ago I would have answered "F# in Visual Studio Community" without hesitation. Today I feel I cannot honestly say that because there is no easy way to get started writing F# any more. The TryFSharp.org site was awesome when it came out but Microsoft pulled the rug out from under it. The only available version of Visual Studio (2017) is an absolute disaster. F# is an awesome language and I love it but it is vastly harder to compile and run F# code to learn the language than it was a few years ago. The announcements about [UWP support](https://www.reddit.com/r/fsharp/comments/75nhjw/announcing_uwp_support_for_net_standard_20/) combined with the fact that they don't even support the basic infrastructure that F# needs in order to run reliably makes me wonder if the only industrial-strength VM supporting F# is going to give up before long. 
&gt; Windows Phone is on the brink of taking over iCrap any year now. And later this year, MSFT is going to completely change the game with Surface Phones. It's going to be a revolution, all on UWP. If that was FUD then this is fantasy. 
What do you find more difficult about F# development now versus several years ago? I’m curious because I spent the last year building and eventually shipping an application built almost entirely with F# and did not have much trouble. 
What about VSCode + Ionide?
Just came across this: http://fantomasweb.apphb.com/ Not as good as ionide integration of course but you can just copy paste across and back before commits say.
I used to train people a lot. I often used the TryFSharp site to do it because it has minimal requirements on their computers (i.e. they don't need VS). TryFSharp no longer works at all and there are no alternatives because F# for web is a disaster. Visual Studio 2017 is also a complete disaster. I bought a brand new Dell and it took me weeks to get VS2017 running reliably. VS2017 is so bad that I'm keeping all of my other computers on VS2015. Except I stupidly took somebody's advice to try Jetbrains Rider and ever since installing it VS2015 has been crashing all the time. 
Vaskir advised me to switch to VSCode+Ionide because he apparently had to step in to fix F# in VS2017 and found the C# devs had inserted `Thread.Sleep` everywhere in the underlying C# code. I gave VSCode+Ionide a go again last week. Didn't work out well. Lots of bugs there. Ionide got confused and stuck in an infinite loop so I had to uninstall and reinstall it. After a whole day working on it I managed to get some arithmetic through FSI but I never figured out how to create and compile a project. I mentioned it on social media and lots of people jumped down my throat. The hipsters told me to use Suave and Fable. The Russians told me to do all the work myself and give it away for free. Microsoft told me to accept the peace, love and harmony of OSS F#. Meanwhile, I am struggling to solve real problems on a day by day basis using F# which leaves me increasingly wondering what other tools I should be trying instead. 
I would still advice kids to go for university. Most of my best friends after 20 years since uni is people I met at uni (perhaps sad?). It was an environment that allowed meeting odd and smart people and giving me time to contemplate. Picking the correct university can be smart though. Where I went they wanted us to learn fundamentals rather than the latest fad (at that time CORBA, how relevant is that today?). At the time I didn't appreciate it but as I grown a bit more experienced I believe it is correct.
&gt; I would still advice kids to go for university. Most of my best friends after 20 years since uni is people I met at uni (perhaps sad?). Interesting. 20 years after uni and the only person I kept in contact with is my wife. &gt; It was an environment that allowed meeting odd and smart people and giving me time to contemplate. Yeah, to some extent. &gt; Picking the correct university can be smart though. Yeah. I just did what I was told and went to Cambridge. &gt; Where I went they wanted us to learn fundamentals rather than the latest fad (at that time CORBA, how relevant is that today?). At the time I didn't appreciate it but as I grown a bit more experienced I believe it is correct. Cambridge was supposed to be like that but it wasn't. The teaching staff don't want to teach. They teach because they are required to teach if they are to do research and all they want to do is research. So the faculty staff off-loaded teaching duties onto irrelevant PhD students, some of whom were barely comprehensible. Some were great, of course, but they were few and far between. 
I believe the discussion can be summarised by Carl Sagan's: "Extraordinary claims require extraordinary evidence"
The whole &gt; Visual Studio 2017 is also a complete disaster. isn't an F# problem particularly, it's a VS and Windows one. My installation was a mess: I had to use [Visual Studio Uninstaller](https://github.com/Microsoft/VisualStudioUninstaller) to get rid of the final bits and then reinstall everything. The Windows 10 Recovery / Reset has proved itself useful. Neither of these things are F# specific. I think the whole development story for Microsoft is a real mess. I remember giving Steven Sinofsky a standing ovation at a Microsoft company meeting when he introduced the Surface. Little did any of us realize what a disaster Windows 8 / Metro / etc be for developers and the company in general. F# is simply caught up in the general mess that is Microsoft's platform and development.
&gt; isn't an F# problem particularly, it's a VS and Windows one. F# is native to VS and Windows. It isn't well supported elsewhere. &gt; Neither of these things are F# specific. True but F# depends upon them. &gt; I think the whole development story for Microsoft is a real mess. Yes. &gt; F# is simply caught up in the general mess that is Microsoft's platform and development. Absolutely. I couldn't agree more. 
What claims?
&gt; Talented developer coding a feature that fits F#'s structures well, compared to ordinary developers using a difficult and unsafe language where it is very hard to get something to work first time, for a project where the development time was hard to estimate. Impressive but not so extraodinary. FWIW, the C++ developers had 10 years experience on solving that problem with the code base they built upon. 
The problem is that I haven't found anything else that is demonstrably better. There are just different things with different issues.
&gt; They can’t kill it, but surely never has been a priority, and probably never will. Like VB.NET but even worse... Yes. We can complain about it. We can also recognize the situation and program in it anyway because it is useful.
Exactly. Although that was the attitude when Ballmer ran the company. It's not really a parody when it's just stating the truth, is it? The whole Ballmer smashing up iPhone and saying how rubbish they were was stupid beyond belief. Anyone at Microsoft who had used an iPhone could see that it would be successful. That, sadly, was a pattern of Ballmer's tenure as the man-in-charge of Microsoft after Gates moved on. Ballmer's completely refused to recognize that Microsoft's stuff was inferior to the competition. He wasted his, and Microsoft's, resources attacking the completion instead of fixing Microsoft's stuff. Now Microsoft has a well meaning CEO but the company moves at a glacial pace.
Exactly. Although that was the attitude when Ballmer ran the company. Your comment isn't really a parody though, more of a pastiche. The whole Ballmer smashing up iPhone and saying how rubbish they were was stupid beyond belief. Anyone at Microsoft who had used an iPhone could see that it would be successful. That, sadly, was a pattern of Ballmer's tenure as the man-in-charge of Microsoft after Gates moved on. Ballmer completely refused to recognize that Microsoft's stuff was inferior to the competition. He compounded his error by wasting his, and Microsoft's, resources attacking the completion instead of fixing Microsoft's stuff. Now Microsoft has a well meaning CEO but the company moves at a glacial pace. Edit: grammar 
I'm left with two questions: 1. why bother with /r/fsharp at all? 2. since you seem to be vehemently opposed to everything, what *do* you actually use to solve your real world problems nowadays?
F#s biggest draw is also it's biggest pain-point; being based on .Net. The .Net framework is great, but it was not designed with functional languages in mind, and at times working with it in F# can be painful. And yes, C# is very relevant and very useful. Especially considering that they are adopting more and more functional features like immutable objects, true tuples, pattern matching, etc. 
&gt; The only available version of Visual Studio (2017) is an absolute disaster. Why is that? We are using it in a somewhat large product with 20+ F# projects in the solution. We are pretty happy. Some F# tools updates come faulty at times, yes. But overall things look good. Can you elaborate?
I'm pretty sure this was _sarcasm_, not fantasy. (Hard to tell for sure, though :-S)
&gt; why bother with /r/fsharp at all? Until Microsoft sort it out I cannot recommend trying to get started with F#. &gt; since you seem to be vehemently opposed to everything, what do you actually use to solve your real world problems nowadays? Most recently it seems to be a mixture of succeeding with OCaml and failing with F#. 
Exactly. Which is really frustrating. If you're building servers or websites then I'd recommend OCaml over F#. It also has a terrible installation procedure and user-unfriendly tooling but it has the advantage of mature and stable OSS ecosystem complete with decent package manager and solid libraries with serious industrial backers. IMO part of the problem is that all such offerings are way too complicated. F# is full of .NET-specific cruft that was good when people wanted stuff built on .NET but if the target has shifted to JS then it is just baggage. Then there are the academic features like type providers. If you strip out all of that junk you could get a lean retargetable language and I'll wager it would be much easier to build tooling like IDEs. 
Ok, yeah. My bad. :-)
Yes, I also have problems with building projects in Ionide (https://user-images.githubusercontent.com/873919/31585547-4a9368b6-b1cc-11e7-878a-8cc653b200b2.gif). About VS 2017, I used it for a while after a couple of months using Rider exclusively and it works pretty well. Yes, the artificial Roslyn delays make it _feel_ a bit slow compared to Rider and Ionide, but I has not encountered bugs which would make using it impossible. Also, VS 2017 have some unique (among F# editors) features, like suggesting not-in-scope symbols in completion and simplify name analyzer/fixer, which makes exploring new libraries much easier. About Rider, it's just the best choice for now, I have no idea why one could not like it. 
&gt; The .Net framework is great, but it was not designed with functional languages in mind, and at times working with it in F# can be ugly or not so smooth. I must disagree. F# on .NET was always incredible compared to any other FPL I ever used. I can even give you a case study: I developed a 50kLOC graphical product in OCaml using OpenGL ~12 years ago. Looked great on our machines but when we shipped in ~80% of customers reported seg faults on startups. We couldn't debug it and ended up shelving the product. The problem is essentially that OCaml is standalone with a cumbersome FFI that even experts cannot use correctly and its OpenGL bindings were not tried and tested. I diversified into F# 10 years ago and ported some of that OCaml code to create an [F# product](http://www.ffconsultancy.com/products/fsharp_for_visualization/) using WPF in .NET. The results are incredible: rock solid. Some features are missing because there are things you can do with OpenGL that you cannot do with WPF. A lot of people use that product now and we've had hardly any bugs against it. A great accomplishment and I owe it all to .NET. The solution was to use a functional language that sits on a shared VM with tried and tested libraries like WPF. I use F# for GUI apps all the time. I'd never use OCaml for GUIs any more (unless maybe they're web based). 
&gt; Why is that? Ah, so many problems. Didn't work out of the box: took over a day to get everything set up. Standard F# support is unusably buggy so you have to upgrade to F# nightlies which randomly breaks. Unnecessary pausing in Intellisense that appears to just die randomly so I'm always restarting VS. Etc. &gt; We are using it in a somewhat large product with 20+ F# projects in the solution. That's a lot of projects. What are you making? 
&gt; I use F# for GUI apps all the time. Can you explain what you use to build the GUI apps, exactly? If I wanted to do exactly that, how would I do it? Can I use just F# and .net or do I have to use something else too? 
&gt; For example, I tried FsLab+Suave but they couldn't work together because they required different versions of some underlying DLL (FSharp.Core?). You should add a binding redirect for FSharp.Core (actually, you really, really should add it in any F# project) into your app.config. Thankfully, Paket does it by default and very reliably, so I forget when I see any problems related to wrong assembly versions. 
https://github.com/Microsoft/visualfsharp/issues/1096#issuecomment-336707307 F# and .net native not happening any time soon. So, no, no direct effect on F#.
We have a solution containing 100 F# and 90 C# projects. VS 2017 handles it pretty well (I use Rider most of the time though because it faster (or just it _feels_ faster, whatever)).
We are making a 3D CAD application. But as @kot_ mentioned, our project is not that large. As for Itellisense hiccups, use the latest F# tools, see [blog](https://blogs.msdn.microsoft.com/dotnet/2017/03/14/announcing-nightly-releases-for-the-visual-f-tools/). As I said, they may come with new problems but overall, F# tools for VS are great.
It's also noteworthy that VS2017.2+ come with sufficient F# support to not need the nightly builds. In fact, .3 and .4 just came with nightly drops from 2-3 weeks before the update releases.
&gt; Can you explain what you use to build the GUI apps, exactly? I call WPF programmatically from F#. Sometimes I use an EDSL to compile a tree into WPF controls. Sometimes I do fancier things with OOP. &gt; Can I use just F# and .net or do I have to use something else too? Just F# and .NET. &gt; I assume that you'd use F# with WPF. I found Calculator F sharp WPF and F# MVC framework for WPF. Presumably you'd use the desktop bridge to publish a desktop only app to the Windows Store. I've never used Windows Store (does anyone?). Usually these are programs for clients. 
Rust and F# shine in different niches. Rust is good for systems-level software, F# for application code, but they are both lackluster in the other's area.
Yeah, I never tried Paket. Maybe Nuget is the problem...
The kind of CAD that might help me with 3D printing? &gt; As I said, they may come with new problems but overall, F# tools for VS are great. I'm reassured it is working for you. Maybe it is my machine then. Would be weird as it is brand new... 
That's really reassuring, thanks.
The visual F# team is very small but is expanding, I think from 3 to 4. With VS2017/roslyn and .net core/standard 2.0 a lot is changing, and they are currently behind, but once they are finished with VS2017 support in a few months I think the situation will be much better than it was before VS2017. E.g. rename, folder support.
Reed Copsey has written a lot of useful components for GUIs. His library called gjallarhorn is nice for reactive binding from viewmodels to views. If you do WPF you can use his FsXaml type provider to get typed access the objects defined in xaml. I don't use the standard C# approach to bindings and do them in code because like jdh30 I like to keep everything type safe. But you can do this if you really want to using components like ViewModule.
&gt; The only available version of Visual Studio (2017) is an absolute disaster. You are taking this far too seriously. This is a temporary situation, which will last less than a year, in which you should use VS2015 instead of VS2017. VS2015 has not stopped working, so what is the problem?
FWIW VS really, _really_ hates AV software other than Windows Defender – this is the #1 source of VS problems that I've encountered.
Update: The visual fsharp team thinks that VS2017 is in a good enough state now to recommend over VS2015. It is mainly .net core that they haven't finished.
&gt; You are taking this far too seriously. This is a temporary situation, which will last less than a year, during which time you should use VS2015 instead of VS2017. VS2015 has not stopped working, so what is the problem? Microsoft took down the VS2015 installer. 
https://www.visualstudio.com/vs/older-downloads/ But honestly, VS2017 is solid; any issues are environmental. Also, no way I'd give up value-tuples for the sake of an IDE.
&gt; https://www.visualstudio.com/vs/older-downloads/ Says "Sorry, we couldn't find any downloads for you". &gt; But honestly, VS2017 is solid; any issues are environmental. Also, no way I'd give up value-tuples for the sake of an IDE. I'm curious what you want value typles for? 
I'm giving it another go. 
&gt; Says "Sorry, we couldn't find any downloads for you". You might need a VisualStudio.com login; I just have the free one and it works for me. (I guess it could be regional; no idea.) &gt; I'm curious what you use value tuples for? I don't do F# where I work now, but at a previous job GC churn was a recurring problem for idiomatic code. Nested fold/reductions with tuple state types were changed to use custom structs wholesale if we saw they never/rarely escaped gen1, and likewise with high-volume unfolds, and that kept things sane for our purposes. All fine for the most part, but it wouldn't be necessary now and it would have been lovely to avoid the noise. (The context was aggregating training data for image/video classifiers and calculating DCGs over _very_ large datasets.)
You can use nightly releases. A new version comes almost every day and it works for a month. So, if you update regularly, you can effectively use Rider for free (I do, however I have an all products license). About slowness, I disagree. It's very responsive, no UI freezes, workable Find Usages, great test runner integration, etc.
There are really only 4 people in the F# team? Given the size of the compiler I was be sure there would be more.
Is there TL;DR version?
Main take away is that you can use FSharp in Jupyter notebook (like Python) really easily with IFSharp to do rapid prototyping, charting etc. (https://github.com/fsprojects/IfSharp). Also types and type provider help simplify the process of data wrangling, and the Accord.NET library is nice for classic Machine Learning. Nothing on deep learning.
Awesome! Thank you, sir!
Weird how he calls it a monad writer rather than the writer monad. Great article though.
There are 1.5 people on VF# Team + PM. 
is is weird? For some reason, I always say Monad Something. Maybe be I should correct that. Thanks for reading
That seems to be understating it a bit. Just recently, spurned by interest I took look at some of the other open source languages on Github and it does seem like contribution to them seem to follow a power law. F# is hardly an exception in that regard. Even the really popular projects like Roslyn or Clang tend to go up to maybe 15 active contributors. This is heartening to me as a language creator, since at a team size of one maybe I am not as short handed as I thought I was.
For what it's worth, I had never done any F# development and decided to pick it up last weekend. I installed VSCode+Ionide and it was completely pain free.
Maybe I'm just cursed. :-( Seriously though, thanks for the feedback. Always good to hear when things work for people! 
I have been reading up on the .Net 4.5 GC's latency settings... I saw a ycombinator thread that featured a cpl folks who worked on the jet .com pricing engine, it was interesting seeing their comments abt the GC
 dotnet run
&gt; I have been reading up on the .Net 4.5 GC's latency settings... I've had a play with them but wasn't overly impressed. Even with systained low latency I found .NET still pauses threads for quite a while. &gt; I saw a ycombinator thread that featured a cpl folks who worked on the jet .com pricing engine, it was interesting seeing their comments abt the GC I've found a bunch of such threads but nothing particularly insightful about the GC. Which thread are you referring to? 
I wouldn't consider Rust a functional language; it definitely has a stronger focus on imperative code though with good support for some functional idioms. It feels somewhat like a functional language due to its rich ML-esq type system. It definitely serves a different niche than F#. One of the nice things about working in Rust is it provides a remarkably high level of compile-time correctness checking. This level of correctness comes at the expense of reduced expressiveness, though Rust still manages to be quite expressive.
That's not an uncommon first experience with Rust; the formalized concept of ownership can be quite unwieldy at first, and effective Rust programming requires some change in mindset to how programs are structured. There are some paradigms that haven't been translated to Rust yet (GUI toolkits that heavily rely on OO is one). Otherwise, I've found that Rust's enforcement of ownership can help with program correctness, and programs structured with clear ownership patterns end up needing few (if any) lifetime annotations. Rust is really focused on a different domain than F#, though, so I would hardly call one a replacement for the other.
&gt; That's not an uncommon first experience with Rust; Indeed. Everyone I know who has tried Rust came to the same conclusion. &gt; the formalized concept of ownership can be quite unwieldy at first, Cumbersome. Manual memory management is too. &gt; and effective Rust programming requires some change in mindset to how programs are structured. I wouldn't call throwing out perfectly good features like recursion in order to accommodate the borrow checker a "change in mindset". &gt; There are some paradigms that haven't been translated to Rust yet (GUI toolkits that heavily rely on OO is one). Pretty much anything that works well with a GC, e.g. logic programming. &gt; Otherwise, I've found that Rust's enforcement of ownership can help with program correctness, and programs structured with clear ownership patterns end up needing few (if any) lifetime annotations. Provided you extensively rearrange your code and avoid all features that don't sit well with Rust's core design. At which point the rearrangements of your code (which were not done because they are an objectively good idea, of course) become the information that conveys lifetimes. &gt; Rust is really focused on a different domain than F#, though, so I would hardly call one a replacement for the other. Precious little in either language is actually there for the domains in focus though. That's why Go can be used to write Docker and OCaml to write Mirage, for example. I'd be happy to write Rust code in F# but I would not be happy to write F# code in Rust. In practice, Rust is being used to write a web browser which is exactly the kind of thing that should be written in a higher-level garbage collected language. Look at [Servo](https://github.com/servo/servo), for example. 
AFAIK the SAFE stack could run on .net core (not sure about Fable-elmish)
Part of the point of the SAFE stack is that there's commercial support available for it, so there's longevity there. But what are you trying to compare between the two? You can use the S- part of the SAFE stack (Suave) on .NET Core 2.0. You can swap out Suave for ASP.NET Core and continue to use the -AFE part of the stack. The A is Azure, but whether you pick Azure, AWS, GCP, or a smaller provider (e.g. DigitalOcean), it's mostly irrelevant to your chosen tech stack. If your concern is the -FE part of the stack, you're not comparing against .NET Core 2.0 at that point. It's Fable+Elmish vs. Elm vs. JS/TS+React/Vue/Angular vs. etc. It's about frontend choices, and they can be served up via any web server. Also, tools like Fable+Elmish aren't going anywhere any time soon. Elmish is a library based on the [Elm Architecture](https://guide.elm-lang.org/architecture/), and this pattern for UI dev is only becoming more popular.
I love using SAFE stack, allows me to use one language throughout the stack. Fable-elmish does have a bit of a learning curve, at least for me anyway. But the sample app is good and due to the compiler it forces you down the right path.
Fable and elmish runs great on core. 
What are the thoughts on Giraffe? which is basically f# friendly .net?
This has to be the biggest troll thread ever. The OP clearly provided very convincing use cases. And all I hear is, well the seasoned C# devs sucked. And a language can't possibly do this. It's not just another OO Language vs another Java vs. C#, it's a whole paradigm shift of going from an OO mindset to a functional one. Also, the OPs use case was Finance related which I think the industry agrees Functional Languages are much more efficient. If you wanted a legit argument, you could of argued well you are comparing Estimated hours to actual work done. Maybe if the C# developers actually started programming the solution it might of not taken them that long either. Also, OP you could have written the article much better, and made your case much stronger 10-100X better. Also your title is C#, yet only mention C++, should of mentioned the C# use cases like you did on here. Either way though, such blind zealousness for C# like someone is killing their child lol. Relax C# isn't going to die, and when/if it does you'll be long retired, or you can just support legacy apps until you die. 
Fable requires .net core.
It's a port of suave that sits on kestrel/asp.net core
From my understanding Suave has been around for longer but I don't think it has similar performance to Giraffe which is almost the same as ASP.NET that for years has been improved. This is basically my largest concern about using Suave because as most open source projects you don't know what resources are available and that may impact the authors capacity to deliver improvements. Microsoft on the other hand has make a lot of the work with ASP.
I think for most people, going with the SAFE stack is a bad idea. But this is because I think Single Page Applications (SPA's) are usually a bad idea, and the SAFE stack does not appear to have a good story for multi-page applications. The reason I think SPAs are a bad idea for most web applications is because most web apps have simple needs - a handful of interactive forms over the database, and some reports, use cases which are handled quite well with an old-school multi-page web app. Even the creators of React have said that classic web apps are a better fit in these cases. With the old school approach, you don't have to worry about figuring out how to split up your javascript bundle as it gets bigger, rendering your javascript app on the server, and other SPA specific complexity. ASP.NET has a lot of problems too (routing is extremely poorly done, for example), but it does have some support for multi-page apps.
SAFE runs on .NET Core today. That is: * Suave runs on .NET Core * Various Azure services have .NET Standard packages you can use * Fable runs on .NET Core (`dotnet new -i "Fable.Template"`) * Elmish is a [.NET Standard](https://github.com/fable-elmish/elmish/blob/master/src/Fable.Elmish.fsproj#L4) library &gt; should we learn the SAFE stack or just stick with .net core without falling into new fancy JS framework of the week? You're describing two different things. .NET Core is a runtime, and each "piece" of the SAFE stacks works on it. Fable uses the Elmish library for writing UIs, which in a sense is like a JS framework. But I think Elmish is here to stay. I don't expect there to be a new way to write UIs in Fable every month, given that model-view-update is such a great way to do UIs in F# :).
another use case with numbers for F# vs C# 5X efficiency, not that i care, but the insane amount of bashing the OP like somehow he was wrong for sharing his findings lol. https://www.airpair.com/f%23/tips-n-tricks/seven-ineffective-coding-habits-many-fsharp-programmers-dont-have
Running suave production for 2 years. It's the most stable and least fluctuating element in the stack. I can't speak for the rest of SAFE
Well, if it really bothers you, you *can* add parentheses around every argument, it's still valid syntax. Semicolons at end of line, too.
hilarious didn't know that, thanks
That's why I said EVERY argument :) let add(a)(b) = a + b add(10)(20)
&gt; you are comparing Estimated hours to actual work done FWIW, they did try to implement it but gave up after a few days and wrote a 70-page report about how it would take 3 months instead. 
got it thanks now they look like someones face or boobs don't which is worst lol
[removed]
It does get better with practice. F# really would not be the same language without currying and partial application. It is not just the whitespace, F# is an expression based language so there is that to get used to as well. `let a b = a + b` is really qualitatively different from `add (a,b) = a + b` and it is not just a matter of syntax. There are definite benefits to being able to do partial application. Getting used to the syntax is something that will take you maybe a few weeks after which you will be able to use F# like a better C# or Java, but mastering the functional higher order programming style is something that takes a good while longer, so don't be put off by the length of learning. More to the point, you do not need to master it quickly, nor is there a way to do that. The way to get better at the language is to just constantly use it and the ideas will percolate through your brain naturally. New things tend to be difficult compared to what came before as well, otherwise they would not be new nor would they be worth learning. F# probably has the gentlest learning curve out of all the functional programming languages and as a side benefit, it will teach you C# as well.
Yes I understood that after playing around with it, I think it's an amazing feature at least coming from OO where you basically have to create a whole new function. Typescript added the whole optional thing which was cool too, but this is so well done. Any books you recommend or resources, I see f# for fun and profit but it's a few years old. Anything new that would help? Also any other resources to learn about the fundamentals of F# such as currying and functional programming in general. 
You're welcome, usuckdik.
I am more interested in Haskell when Linear Types finally drop at around ghc 8.4. It is nice to use a language that evolves without being constrained to C#. 
IMO, the F# for fun and profit is the most well done out of all online resources so don't let it being a few years old scare you. Apart from that functional programming resources aren't hard to find online. .NET is pretty stable as a platform, and higher order functions, type inference and union types have existed for decades already, so there is even less reason worry about their timeliness.
You'll likely start indenting and spacing a certain way that makes it extremely readable, for example pipe operators being offset and indented by the same amount on separate lines. Once that starts becoming habit, you'll likely get frustrated by all the fluff required in c# etc. I know I do.
Your webserver is highly unlikely to be the bottleneck in your application. A better reason to go with Giraffe could be if you needed to use some specific ASP.NET library or plugin.
I think it took me at most ten hours to get used to the low-syntax style. It's insidious, though. Once you begin to appreciate it other languages will forever feel inferior.
I've written an F# introduction for my C# coworkers. It haven't been reviewed, so it probably has many faults. Might still be useful for others. Any feedback is appreciated.
one time when I was consulting for a multi-trillion dollar company we made a service that handled requests in 3 microseconds flat. This was a gazillion times faster than their existing in-house C++ implementation. Also I tried doing trig stuff in F# the other day and found it inadequate for my needs.
Hey, is the web page done using some Jekyll template? I've been looking for something cool for documentation of Ionide, and this seems OK. 
It's written in [org-mode](http://orgmode.org/), using the [ReadTheOrg theme](https://github.com/fniessen/org-html-themes).
I have just skimmed it for now but I think its really good. I like that the code samples go straight to the point without making it a "journey" from bad code to shiny and pretty F# and also without C# bashing, good tactic. When I began i very much appreciated Brad Collins F# Fridays. Simple bite sized examples with good explanations.
Did you forget where you were posting?
so is let addnum x y = x + y technically wrong with the have one argument practice? And how would you rewrite it?
I find it helpful to have types in my function signatures. That way you only have to deduce everything inside the function in your head. Now if your function is confusing, because you don't know what those lets mean, you know that your function has gotten too big.
I would guess, let addnum (x,y) = x +y juding from: The parameter can be a structure/map or some other complex type (don't think this restricts to primitives). of course, this is not good enough since it is not generic. Such solution breaks Don't use an int when you can use a number; so forth and so on.
Oh, and of course [org-babel](http://orgmode.org/worg/org-contrib/babel/) which allows me to write these code snippets and runs them and embeds the result. This combination is really amazing, and I use it to embed Graphviz/dot samples and plantuml diagrams in other documentation. Highly recommended.
I've just been trying to use a new VS2017 install on my laptop and it is still really problematic. For example, when I type `\n` it autocompletes to the nonsensical `\new` and `\r` to `\raise`. It even replaces my variable name `g` with `global` because that is an (unused!) keyword. The only advice I've been given (by an F# expert with many years of experience in industry) is [Hit escape every other keystroke. Works every time and is super intuitive!](https://twitter.com/neildanson/status/921475065119674369). I'm sorry but I just don't understand how anyone can be recommending this virtually-unusable development environment right now. 
FWIW, I installed Project Rider and my rock-solid VS2015 install immediately started crashing all the time. And [I'm not the only one](https://twitter.com/wklm_/status/919592912119386118). So for anyone out there with a working F# IDE **DON'T INSTALL PROJECT RIDER**!!! 
&gt; About Rider, it's just the best choice for now, I have no idea why one could not like it. I have a reason for you: I installed Project Rider and my rock-solid VS2015 install immediately started crashing all the time, is now unusable and I have been unable to fix it. And [I'm not the only one](https://twitter.com/wklm_/status/919592912119386118). 
As with most 'insurmountable' VS problems people seem to run into, it doesn't happen to me – not sure what to tell you. ¯\\\_\(ツ\)\_/¯ Try unchecking 'show completion list after a character is typed' in F# IntelliSense settings. I'm not trying to sell anything here – if you don't want to use VS, don't use it; but, if everyone else is fine with something you see as virtually-unusable, well, Occam's razor comes to mind. ;-]
This is the weird thing: I could swear this didn't happen to be a few days ago but I just tested it on another machine and it does equally insane autocompletions... 
&gt; Won't that basically turn off Intellisense? Hit Ctrl+Space when you want a completion list. &gt; Several people have corroborated this. Congratulations, I guess? Works for me, and has since VS2010. Either I should start playing the lottery or it's just a matter of configuration.
&gt; "Implemented in F# in 4 hours a feature that had been scheduled to take 3 months of development in C++" isn't anecdotal. &gt; Neither is "my predecessor developed an entire pension quote calculator (typically scheduled to take 300-400 man days) entirely in F# in under 100 days with no prior F# experience at all". &gt; anecdote [**an**-ik-doht] noun, plural **anecdotes** or for 2, **anecdota** [an-ik-**doh**-t*uh*] &gt; 1 a short account of a particular incident or event &gt; 2 a short, obscure historical or biographical account Yeah you're literally giving us anecdotes, hoss.
[Codelens eliminates this issue entirely for me.](https://i.imgur.com/Mn2wYIw.jpg)
Yes, we only use let. No, it does not get confusing.
I understand what you mean, but some time ago I tried a very simple hello world with both Suave and Giraffe and the throughput without any extra config was so brutally different that I'm not sure it's not relevant. When I read a little more my impression was that Suave as open source and didn't have many resources and at the moment it was not a priority to work on performance but more on the API. Is it then your impression that it really doesn't matter a lot? I come from Ruby which hast the worst performance ever and if I don't see a big spike in throughput in regular F# a big benefit seems lost. I see how I can be missing important points so thank you for the comments!
That's what "bottleneck" means. If a request spends 99% of its time in transit across the Internet or being processed in the database, and only 1% actually being handled by a webserver, then switching to a fast webserver will *never* improve your application's performance by more than 1%, *no matter how much faster the new webserver is*. Hello world in-memory benchmarks are interesting, but the only way to get a *useful* benchmark is to measure end-to-end times. Like, `Array` is so much faster than `List` it's not funny, but you're never going to start replacing every list with an array until you determine that it's actually making a measurable difference.
Did you do anything to get the variable names in the codelens? I only get the types even when the arguments are named, [like this](https://imgur.com/OsCgWje)
No, sorry. That's not actually my screenshot but was taken from the [release tweet by Ionide-Fsharp team](https://twitter.com/ionideproject/status/783359689920839680), so I don't know what happened to them either. I can only assume they were removed.
For context, F# is my favorite language by a half, and I'd kill to work in it. I think it's fated to go the way of Delphi. Microsoft is pulling out, and nobody is picking up the slack. The FOSS community, as awesome as it is, doesn't have the critical mass to keep this going; and the fact that there are no F# jobs means that technical managers won't treat it as tried-and-true, which means that there won't be F# jobs. It's a vicious cycle. And rescue won't come from academia either. Anybody in academia who could be tempted to use F# is using OCaml instead. Anybody in industry who could be tempted to use F# is using C# or Scala instead. Hobbyists go for Haskell because it's the final boss or something. I like F# better than any of those, yet it doesn't feel like it's headed anywhere good.
I think FSharp has a lot of potential in the areas of Data Science, Machine Learning and AI but it obviously needs libraries. Something like Keras which wraps over CNTK would be idea. Now that there is a .NET API for CNTK I really hope something like this comes about. Of course Python is excellent for rapid prototyping but it is really not a suitable language for robust and reliable applications due to lack of type safety and everything that goes with that. I think f# will also play a big role in Quantum Computing, check out https://www.microsoft.com/en-us/research/project/language-integrated-quantum-operations-liqui/
I like the idea of F# as a more pleasant syntax for C#. So any time spent becoming a good F# developer is also making you a better C# developer. Libraries like Giraffe make the standard ASP.NET core framework fit naturally into F#. There's a similar relationship between Kotlin and Java - it will be a niche language for a long time, but the skills and tools are transferrable. 
I believe Microsoft is said to be releasing a new language for Quantum Computing, if i read correctly. 
https://www.microsoft.com/en-us/research/project/language-integrated-quantum-operations-liqui/ Actually they already have :)
That's the same link I gave and the library is written in F# *"It allows the user to express circuits **in a high-level functional language (F#)**, and supports the extraction of circuit data structures that can be passed to other components for circuit optimization, quantum error correction, gate replacement, export or rendering."* Check out the source on the github repo: https://github.com/StationQ/Liquid
A counterpoint to this (from someone using a lot of C# libs via F# recently) is that I find myself littering the place with lots of small wrappers for C# calls that I would much rather do without, mostly so I can make partial application work. Things like: let doSomething a b = SomethingInCSharp.DoSomething(a, b) aList |&gt; Seq.map (doSomething "foobaloo")
`let addNum x = (+) x` ?
Lmao yeah, but /u/usukdik didn't seem to notice so I thought I'd repo st it
I'd use C# and the Encog library. You can do it in F# with other libraries, but I'm not sure using a functional language is a benefit. You can do a combination of F# and C# pretty easily if you feel the desire to.
Honestly for simple expose-my-DB-as-a-json-api stuff I'd just use [PostgREST](https://postgrest.com/en/v4.3/) to quickly get scaffolded. For processing CSV and ingesting that sounds like an easy task using the [CSVProvider](http://fsharp.github.io/FSharp.Data/library/CsvProvider.html) and [SqlProvider](http://fsprojects.github.io/SQLProvider/core/postgresql.html). Once the data is in the DB you can use whatever you want to manipulate and process it.
I'd like to use a FPL just for the opportunity, otherwise I could always use Java. We want to have a look at Kotlin as well, but if e.g. F# is appropriate that would be way more fun! Encog looks interesting.
I'll have a look at PostgREST, thanks. We will definitely need to do more stuff but for a first impression and overview I'd like to have something simple working that we can add to. Also, I have read about type providers occasionally, they seem pretty handy.
Yea, F# is a fine choice for it.
I've had a lot of fun building REST services with Suave, though the documentation isn't quite as helpful to beginners as it probably should be.
This is a good post to get an idea of how to organize and structure a clean F# code base. https://tech.jet.com/blog/2015/11-27-how-jet-build-microservices-with-f/ https://www.infoq.com/interviews/rachel-reese-microservices-fsharp-qcon-london-2016
F# is good here. And if you wanna experiment, go ahead. For example look at: https://fslab.org/ For tooling, consider you have the whole .NET plus whatever crazy tooling F# have ;) For DB acces: This is kind of complicated specially if you wanna use OSX or Linux. This is just because .NET is heavily biased to be on windows + sql server, so you need to have a bit of effort with other things. I settle to just use ADO.NET and wrap it around: https://gist.github.com/mamcx/fc1ad7e8adbe53cf70346dc16e9b0351 This is because I need total cross-platform support (including: iOS, Android, Linux, OSX, Windows). Other libs could work, this was like 1 year ago when I settle and now things are moving ahead with .NET Core and other new stuff that finally make cross-platform more nice ;) - for some edge cases that probably you not need to worry- --- Visual Studio Community is good. For Linux/OSX Visual Studio Code and OSX Visual Studio Mac. I haven't tested Rider.
I read that, you guys are posting things that are from 2016. I'm talking about recent news, they are supposed to be releasing a new language completely. https://www.infoq.com/news/2017/10/microsoft-quantum-platform 
I'm doing a similar project with F# (data sci and ml) and find it very good. Check out this very helpful O'Reilly guide to 'Analyzing and Visualizing Data with F#' : https://fslab.org/report/ Also check out these: http://fsharp.org/guides/data-science/ http://fsharp.org/guides/machine-learning/ For Deep Learning there is CNTK however the .NET API is very new and not as friendly as the Python API. 
F# will be fine, though C# would still be a huge improvement over Java. The only thing we miss with F# is better IDE support in Visual Studio. It still sucks compared to C# (especially if you're used to C# + ReSharper). We also run some WebAPI services using F# + Postgres as DB + Dapper for data access + Nancy as web server. 
At least the concept of adding these utility/helper functions as extensions isn't totally foreign in the .NET world. Most projects end up with a StringExtensions.cs or similar for conveniences used throughout the codebase. Putting F# functions in a module feels pretty similar. You're not hiding the classes from C#, just adding some functions notions to make the interop nicer.
You should drop your username and make a new account. It's either homophobic or very reasonable to perceive as being so. I can't engage with that username or take it seriously.
What's your background in ml and ds? Can you compare F# to Python with Scikit-learn, theano, etc.? Thanks for the ressources.
We're on Ubuntu but if we have to write wrappers for simple stuff like DB access then I'm afraid I won't be able to sell F#. We have a limited amount of time as it is, so the tools need to work.
Thanks, I'll have a look at that.
I was going to start with Suave, if there are at least some examples I think we can work with it.
I also think that C# is a nicer language than Java but it's still more similar to Java than I'd like. I'm used to IntelliJ, but also editors, so I think I'll be fine. I just installed Rider but I obviously don't know enough F# to be able to tell if it's there yet. Have you used the spacemacs layer for fsharp?
I’ve been wondering what I could do to help with F# open source, and this may be it. I think polishing and publishing these small usability shims for open source .net libraries may be it. I think many of us who are not “super developers” but love F# could contribute in this way. Converting nullable fields and/or variables to optionals would be another aspect of this. There’s a package out there for TopShelf that is an example of this. https://github.com/haf/Topshelf.FSharp Are there any good guides for this? Could we or should we set up a github project to identify/track/assign needed/wanted library api wrappers? 
Looking at the sample provided in the infoq article and the samples in the user guide for the other language, it’s fairly obvious they’re the same underpinning code. They just putting a different parser/syntax over it to give it a more c-like feel. I hope that they continue to maintain or publish further improvements to the current F# repo. It would be so like Microsoft to use that for the research project then abandon it commercially and only release the new language. 
Maybe it’s misogynistic? I guess I’m jaded to Reddit now. This type of thing would stick out to me anywhere else on the internet, but I hardly notice it on Reddit anymore. 
How can it be homofobic? Its a childish username but we don't have to be so easily offended.
To me it's very clear how it could be taken as homophobic (or misogynistic), even if that intent wasn't there. I know how damaging it can be for some people in making them feel excluded or unwelcome in a community, and in other ways. I'm assuming that the OP has no ill intent and politely asking them to consider this the above and amend their username.
There is also a risk in creating environment that we think that will make everybody feel comfortable all the time. Next time someone will be offended by something else. If people look for stuff to be offended by you can get offended by anything. Different people are offended by different things and if we create a world where nobody would feel offended then that would be a very boring world. People have started using offended as a weapon to try change the world into a world where everything is adapted to them instead of just ignoring and move on. Funny Vid: https://youtu.be/ceS_jkKjIgo 
&gt; spacemacs Haven't tried spacemacs - I've never been a big of a emacs, always liked vim more :) What you could also take a look at is Visual Studio Code (https://code.visualstudio.com/) with Ionide (http://ionide.io/).
I think gay males would look at that and be like "Yes I do suck dick, Helllooo". Only people to get offended who by straight super hard alpha males "Nah I don't suck dick bro!" and legit sluts "I'm not a slut cause I suck a plethora of dicks!" But i'll look into changing it made it whilst I was angry at Dota. 
How about a C# transpiler? Just have F# code compile to C#, like Fable does with Javascript. Than C# shops, projects won't be able to complain much, and people can use it much more freely
Well is just .NET all the way down. So is not much to wrap. Or look at this: http://fsharp.org/guides/data-access/ -- Is important to note that what is practical or what is idiomatic is not always the same. So, DB acces is as good as with C#, or you can spice it a bit the F# way. But if time is critical, you can do that later. This is how I start with F#.
C# and F# both compile to IL. So I’m not sure I understand what would be the point of transpiling? The wrappers are usually associated with three things: 1. Cleaning up method invocation to allow partial application, etc. 2. Converting bulls to Option, so that they are explicit. 3. “Catching” exceptions in a more functional way. 
Well was saying for the C# devs or shops would only deal with C#, to be able to have F# converted so they could read it in C#.
I tried that but couldn't set up a new project - it kept telling me that it has been created but nothing showed up...
I've been self-taught in ML and DS for about 6 months and done several small projects. I only started with F# a few weeks ago but finding it very easy to pick up. So far I have done a few small projects with F# and ML such as training a neural net on the MNIST data set with CNTK. This was fine the main limitation being the .NET API for CNTK. for traditional ML I think Accord.NET or Encog would be fine although I haven't used Encog. Comparing F# to Python and its DS libraries - well, clearly Python has a much greater selection of libraries available. But unless there is something you actually need in there it may not make a difference. Also remember F# has the R Type Provider which gives you access to all of the R language libs on your F# data. For statistical stuff R is generally better than Python. Right now I'm working on another project with a group doing deep learning with Keras/Python. I am doing all the data prep (pulling data with F# Csv Type Provider and wrangling it) but the actual training of the network is done in Python as that's what Keras supports.( If you are doing any kind of Deep Learning I recommend Keras as it's very easy to get started, have a look at : https://keras.io/getting-started/functional-api-guide/). Once the network is trained I plan to export it and use it from F# with CNTK. Also, I forgot to mention that if you use F# for DS there is another essential tool: IFSharp Jupyter notebook https://github.com/fsprojects/IfSharp and you also have Azure cloud notebook that supports F#, Python and R which is great when working in a team. https://notebooks.azure.com/ 
Near future looks good for usage because .Net seems to have stopped stagnating, with a lot of development around cross-platform usage: Xamarin, .net standard and .net core. F# tooling is also improving and should be very good in near future, closer to C# standards of tooling. F# should emphasize performance: we have struct tuples and DUs, .Net is getting Span&lt;&gt; for unmanaged memory. Native compilation is slow but will hopefully come soon. Performance and type safety are major benefits over Python. It does need libraries for current trends to improve, esp. machine learning and data science. F# is intrisically a good fit but libraries take work. Number of users will not be huge but that's not necessarily important to whether you can get a job, as long as the market is liquid enough. My company is hiring a junior F# dev ... but would not take someone with your username.
"Python ships with an IDE" - are they referring to IDLE here - not sure if many use it. I love Python but would equally love it if F# was widely used - an elegant, expressive language.
It would be ridiculous to compare Idle to PyCharm or Visual studio. However, from beginner point of view Python contains handful of killer features: Idle with shell, editor and documentation. Not to mention standard library and pip. All of that I was sorely missing when I was meddling with Fsharp. I was reluctant to download and run sluggish and oversized Visual Studio Community just to test new language. I ended with VSCode and Ionide. To make work anything not so simple as Hello world was really really painful. All the time when I am teaching beginners to program in Python I just recommend them to use Idle because it is so simple you can focus on learning language instead of tooling. From my perspective, Fsharp has no chance to win significant share of Pythonistas with current mindset. For some reason Fsharp agitation is mainly focused on .NET users. This is IMHO very unfortunate as F# is supposed to play some role in machine learning. It should be obvious to offer Pythonistas (who are involved in ML) something familiar. This is not going to happen. F# in Jupyter seems to me like dead animal. Visual studio is not something I would enjoy, not to say, if the Linux is your platform you are out of luck. For example, (not only) my workflow heavily use command line. Pip is just a breeze. Python ecosystem is much healthier, offering probably much more in machine learning than complete .NET. I have no intentions to start flamewar. It just seems to me that F# do not try to win Pythonistas. Just focusing on dotnetters. I have actually lost all faith in future of F# but I am open to hear different stories. I would like to know what exactly F# can offer to Python users except for language itself. Ecosysystem? Tooling? Fast development? Better libraries? I wonder. 
Can you send a screencap of this behavior and create an issue here? https://github.com/Microsoft/visualfsharp There are really two things to Autocompletion: 1. Showing the completion list, such as `log10` in a list comprehension 2. _Committing_ autocompletion, which changes `10` to `log10`. I recently fixed committing on `]` and `|` (will be available in 15.5), but this shouldn't happen for space, since [it's one of the characters that does not commit autocompletion](https://github.com/Microsoft/visualfsharp/blob/master/vsintegration/src/FSharp.Editor/Completion/CompletionProvider.fs#L72)
Committing is definitely happening with space here. And lots of other characters too (maybe even all of them). This isn't just a suggestion in a box: it actually rewrites my correct code into garbage. I only seem to get this on my desktop though which I think is using nightlies whereas my laptop is a stock install + updates. 
&gt; We're on Ubuntu but if we have to write wrappers for simple stuff like DB access then I'm afraid I won't be able to sell F#. We have a limited amount of time as it is, so the tools need to work. Either switch to Windows or ditch F#. If you want to stick with Ubuntu, check out OCaml. 
Why? Isn't Mono suitable? Also, I'm not sure I want to use Ocaml at all if I need three standard libraries just to work with strings...
&gt; Why? Isn't Mono suitable? Mono is really slow and buggy. &gt; Also, I'm not sure I want to use Ocaml at all if I need three standard libraries just to work with strings... Eh? 
Strange, I have read good things about F# and Mono on Linux. NLP could very well be in our focus, yes. Also, it could be that we'll work with german texts, so Unicode would be required. Have you used Ocaml extensively? How's the tooling (IDE, build tool, package manager, etc.)? Is it comparable to Haskell with IntelliJ plugin and Stack? 
&gt; NLP could very well be in our focus, yes. Also, it could be that we'll work with german texts, so Unicode would be required. Ok. &gt; Have you used Ocaml extensively? Yes. ~15 years with OCaml. Over 10 in industry. Wrote the book on it. &gt; How's the tooling (IDE, build tool, package manager, etc.)? Typical Linux. Lots of command line. Some random _tag files and so on. Other incompatible files for Merlin. Various package managers but the compiler is so fast I just write an sh script and recompile from scratch each time. &gt; Is it comparable to Haskell with IntelliJ plugin and Stack? No idea, sorry. What is Stack? 
&gt; Yes. ~15 years with OCaml. Over 10 in industry. Wrote the book on it. Nice. I knew that I recognised your username from somewhere. :P The thing is, it's a side project. So, if I want to introduce a language to my colleagues (Java programmers) it needs to have a certain level of tools and ease of use/user friendliness. Stack is the 'Haskell Tool Stack': https://docs.haskellstack.org/en/stable/README/ It's a great build tool and package manager.
&gt; The thing is, it's a side project. So, if I want to introduce a language to my colleagues (Java programmers) it needs to have a certain level of tools and ease of use/user friendliness. Ah, ok. Yeah, OCaml probably isn't that tool. I'd suggest maybe Jupyter notebooks with something like Python or maybe Mathematica. &gt; Stack is the 'Haskell Tool Stack': https://docs.haskellstack.org/en/stable/README/ It's a great build tool and package manager. Sounds good. Last I tried I think there was a "Haskell Platform" that I installed and played with only to learn that it could not be uninstalled. Fortunately my HDD exploded, solving the problem for me. 
&gt; Python is, umm, BASIC++ of course. :-) Yeah, I've used it for quite some time and in university as well, which is why I'm trying to learn Haskell atm. Python just gets boring after some time. And don't get me started on Java - which is exactly why I wanted to use F# or something similar. :P We'll probably use Python anyway for some tasks, with Tensorflow and sklearn, etc. &gt; Fortunately my HDD exploded, solving the problem for me. Uh, okay. Talk about side effects. You should really give it another try now, it's really good. 
Try being less of a child and grow up.
Very weird comparison. Also other questions about programming languages can give a lot of lolz
Agreed. Those comparisons are just for fun. My original intentions were to make some discussions about how or if Fsharp can offer some goodies to Python users except for language itself.
You can decompile CIL to C# but C# cannot express `.tail`.
Ten years ago I diversified from OCaml to F#. Before that I was using C++ and Mathematica and before that assembly, C and Pascal and lots of other languages. Compared to OCaml, F# was alluring because it offered better performance thanks to value types and generics, multicore parallelism and promised fantastic libraries inherited from .NET. One of the first things I noticed was missing libraries. Back in 2007 I wanted to do a Fourier transform. With OCaml I'd use FFTW (which is written in OCaml and used by MATLAB and others) but there was no FFT library for .NET. So I wrote one and around the same time people started selling commercial ones including bindings to Intel MKL and other native code libraries. More recently I wanted to do some AI, specifically NLP. Upon hearing that people were using F# for machine learning I dug out the relevant library which turned out to be an IKVM translation of Stanford NLP from the JVM to .NET CIL. I think that tells you a lot about the state of AI libraries on .NET. If you look at the world of AI you have Google beating the world's best Go player without using any Microsoft software in the same year that Microsoft unleashed their racist slut AI, [Tay](http://www.telegraph.co.uk/technology/2016/03/24/microsofts-teen-girl-ai-turns-into-a-hitler-loving-sex-robot-wit/). How many AI professionals will go the Microsoft route? Looking back it is important to note that .NET only has good libraries if you're building enterprise back-end solutions using industry standards like XML. Many .NET libraries like WCF only exist to address deficiencies in C#. If you want to do other things like low-latency fintech using Infiniband you'll find Windows lags behind Linux because it is used on 0% of the top 500 supercomputers, for example. So the library situation is not so clear cut. Another major advantage of F# over OCaml was the ability to write GUI Windows apps really easily using libraries like WPF. While those libraries are still great, interest from industry in writing Windows apps has completely died over the past 10 years. A large part of the problem is that desktops are in decline and Windows is in decline so even industrial users want to get their work done on phones and tablets and, therefore, WPF just doesn't cut it. Now everyone wants web apps. How does .NET stack up? I recently wrote both clients and servers in both OCaml on Linux and F# on Windows for commercial projects and was surprised by the results. F# has basically no advantages over OCaml anymore and, in fact, OCaml has some serious advantages. The web runs on Linux not Windows so OCaml being native to Linux with, for example, efficient interfaces to the OS for async makes OCaml ~10x lower latency than F#. Although F# has value types, reified generics and multicore parallelism its libraries are so badly written in comparison and its runtime is so badly optimised for modern workloads that the performance of F# sucks in this context. Furthermore, F# has relatively poor support for lexing and parsing compared to languages like OCaml which makes it a lot harder to process data streams. Another aspect of web programming is compilation to Javascript or the forthcoming WASM. OCaml has really solid support for this as used by companies like Facebook and Bloomberg. F# has almost nothing. Writing a custom web server in F# I was amazed to find there isn't even a standard way to write HTML documents in F# (!). That is how unprepared F# was for the Web 2.0 era! Then there is the issue of Visual Studio 2017. The problems I've described above are fundamental afflictions that can be addressed if Microsoft get their acts together. While the awful quality of Visual Studio 2017 is a crippling deficiency for F# I think the important lesson is that Microsoft are currently incapable of getting their act together and, therefore, I suspect it is extremely unlikely any of the above deficiencies will be addressed by Microsoft. Finally, there is open source. F# was made open source and more recently .NET was made open source. .NET Core is coming along. There are lots of new open source libraries for F#. However, Microsoft are the geek standing alone in the corner of the open source party. They're new at this. How well does their stuff integrate with popular Linux distros like Android and Ubuntu? Barely at all. They have a serious case of NIH syndrome and are trying to reinvent everything themselves from the ground up to avoid having to collaborate with other people and technologies from the open source communities. They're still using their own package manager (Nuget) even though it is widely accepted as a poor quality package manager with major deficiencies. Even when a better open source alternative (Paket) is released *for their own platform* they cannot accept it. And what exactly are they bringing to the table? .NET was great thanks to libraries like WPF but .NET Core doesn't have any of that so how is it any better than the pre-existing mature alternatives on Linux? Big picture: fewer and fewer software developers are using Windows or .NET or caring about what Microsoft say because their entire platform is going down. Windows, .NET, Office. The lot. F# is still tied to this sinking ship. Gedanken experiment: Imagine extricating F# was this mess and porting it to another VM. Like .NET, the JVM is increasingly irrelevant. Javascript is perhaps the next logical backend. How much of F# would you keep if you ported it to JS? All the native IO would go. Type providers would go. Value types and reified generics would go. Reflection would go. Most of the core libraries would be completely rewritten to redirect to JS libraries. You're basically left with OCaml--. So why start from here? 
Without proper modern Windows client support, the future of F# uptake is looking bleak https://news.ycombinator.com/item?id=15581493 
Managed languages typically don't come with a full-blown preprocessor, for good design reasons (google 'why doesn't java have macros' or 'why doesn't c# have macros' if you're curious). F# is no exception in that regard, supporting only `#if`. If you really hate typing `fun x -&gt;`, you should use your editor's features to make it a code snippet. I.e. press a hotkey and it writes `fun -&gt;` and places the cursor where the variable name would go. Any halfway decent text editor should let you configure such a shortcut. Apart from all that - if you ever have to share code with anybody, never, *ever* redefine basic language keywords, in any language. It's a good way to get murdered, or worse, reposted on TheDailyWTF.
[or worse](https://media.giphy.com/media/UlYq4cSAJDdKg/giphy.gif)
You could use `Func&lt;Type&gt;` if it makes you feel better
Navmeshes &amp; geometry for video game ai and collision detection. Next up, some form of functional quad tree or kd tree.
Benefits over Python are static typing (reducing bugs), performance (compiled) and functional features (e.g. discriminated unions, immutable values). VS is not slow and I don't get why its size would be a problem. If it takes 20GB, that is about $3 worth of SSD space. 
Accidentally introducing F# at work. Working on a tool to cross reference end-points and UI.
I've been thinking about doing a game in F#, what are you using? Recommend?
I'm using Unity, setup wise just build an F# project into the assets folder, any C# scripts within Unity can then reference it. There is also a way to be able to have f# scripts usable directly from the editor, but I haven't bothered to set it up. C#/Unity cover all the impure stuff, basically the UI, and does the graphics, everything else functional in F#. Be aware that Unity only uses .NET 3.5, so F# 2.0 I think, anything later than this and it will not recognise it. There is an option in the experimental settings where you can use .NET 4.6. but I'm weary of anything experimental, and the only thing I really miss is FSCheck which I've just run in a separate v4.5 project linking to my F# game project. I love it, I find it so fun and quick &amp; easy to code functionally (and really enjoy implementing purely functional data structures), but I am just a hobbyist with a maths and computer science background, so YMMV. Anything more specific you'd like to know?
Reading/Watching things about functional architecture and enterprise examples in F#. If things go my way, I'll start a medium sized backend project after new years together with 1 or 2 other devs. So if anyone's got any good resources on FP architecture (F# or similar langs) or enterprise stuff, send them my way ☺️
Ok. Static typing and reduced bugs - as far as I know, it was never proven, not even for functional languages. I don't want to start discussion on this questionable topic. You can read something like this: https://dev.to/danlebrero/the-broken-promise-of-static-typing (NB: This is link just for fun. I dont want to start dynamic/static flamewar.) But I have to repeat myself. I asked what F# has to offer except language itself, mainly for machine learning? Arguments like 20GB is OK and VS being not slow seems rather funny to me - but I dont mind. The speed, static typing, functional features - OK, you have a point. I am going for Rust, then. It is probably faster, no garbage collection overhead, static typed if this really matter, and Cargo has everything what I need to build project out of the box, even with unit tests. OK, ecosystem is lacking but you know this is not something you can win with F#. The Rust in Jupyter is in the same sorry state is F# in Jupyter. Rust is multiplatform with no MONO works, not works. No 20GB IDE available, OK I would go with VS Code anyway :) Rust is not so nice as F#. True, but Rust is designed really really carefully with no strange .NET idioms to worry about. And it is much more easier to bind Python to Rust and vice versa then F# to Python. For F# speaks REPL, though. Quite seriously, I failed to see any good reason for using F# instead of Python. C# has upper hand and better tooling if I need to develop for Windows. Kotlin seems like quite good choice for android (with Java holding its position). Python and R are winning machine learning, Go unfortunatelly has its momentum backed by Google, PHP is still not dying, Javascript and/or Typescript rule the web, and C++/C, maybe Rust are here to stay for system and realtime programming. Personally, I have to admit that F# is sad proof that superior language design doesnt guarantee success of language itself. On the other side, the growing of Python popularity seems to indicate that Python still has a lot to offer. Two years before, I would expect something much more different from F# in terms of trend of its usability and popularity. F# is something like nice experiment that has failed for me. 
When I looked at unity I wasn't sure if F# was well supported. It's good that it isn't too much struggle to use. Right now I'm doing 2d and have been playing with monogame. I'm doing everything in F# even the UI work, which isn't so bad. Mostly I was just curious if there's anything that works better. I'm also way out of my specialty working with graphics.
I'm the same with the graphics, I have a friend who did 3D modelling at uni do that bit! I've not seen monogame so I wouldn't know how it compares, but although F# isn't officially supported, rest assured that once I got it working for the first time by dropping the bin in the directory I've had no issues with it.
Do you need a C# wrapper or was that something you decided to do? 
Tried to switched to Faas with Azure Functions but it turns out it is unworkable piece of shit (hardcoded binding redirect to package versions from stone age in runtime which makes 90% of your code which compiles fine throw ManifestMismatch or MethodNotFound exceptions. More [here!](https://github.com/Azure/azure-webjobs-sdk-script/issues/992)). So right now I switched to making FaaS myself with WebJobs...
Were you trying to precompile your functions, or just deploying scripts?
.
If your specific interest is machine learning then I can't help much as I haven't got into it yet. I am interested as I already do a lot of quantitative code, and might consider TensorFlowSharp and CNTK as I do like the F# language a lot and would prefer to keep using it for those tasks. But I would need to know a lot more about machine learning and about what I would need it for to say for sure. You do need to be more focused on what libraries and techniques you need, and what hardware it needs to support. PCs with very small drives :) , or systems with arrays of GPUs? Your comments do suggest you haven't worked out what you want in a language or what you want to do with it.
Thanks for reply. I appreciate it. I have just tried to find intersection between two languages I like. Unfortunately, it seems that the philosophy of F# is rather .NET, what is quite understandable. I would prefer F# to go more independent path as the Rust went with Cargo. I have to admit I didnt learn to like .NET mindset. F# as language is fine, but the rest is completely alien to me :) Thanks and have a nice evening.
Thanks for the detailed response as much as I'm loving the clean syntax, and all those benefits of writing less code ect. It just seems dead in it's tracks career wise compared to 60K+ Jobs for the major programming languages, but I guess that's also a comparison of functional vs. OO programing. I guess the next 10-20 years will just be OO + some Functional features. I guess you can make a good case for Kotlin, just hate the boilerplate after witnessing F# beauty. 
Both. Scripts could work because of different package management (project.json) but they couldn't be developed properly with CI/CD and complex solutions. Binding redirect is mostly problem of precompiled function because they are launched in some weird runtime. Scripts are OK only for hello world situation so as Azure Functions at all.
Honestly, no language that currently exists and that includes F# is good for making deep learning libraries. The big bottleneck is the lack of a GPU backend. Some languages like D and Julia have started on this path, but all those things are either driven by academics or hobbyists such as myself. I spent over a year making a ML library, continually polishing, refining it and giving it a pretty great functional design before realizing that I have no way of abstracting away all those Cuda kernels and that underneath, my library was just an ugly mix of F# and C which is unacceptable. It was simply below the minimum threshold so I never released it. What I've been working on for the past 8 months (and longer if you count those useless code generator experiments) is a very powerful and efficient statically typed language in the vein of F# that I will use to make the deep learning library. Making a language or a deep learning library is not trivial - I've been putting in 8 hours a day into making it work for about 70% of the time I've been a programmer and still have nothing substantial to show for it, but that will change with effort. But what I want to say is this - it is not just that F# does not have a ML story to speak of, pretty much no language does. Python does, but if you look closely, now that Theano is discontinued - it has become just a wrapper language for the big corporate sponsored frameworks written in C++. C++ is hardly the language to write anything in, but presently it is the only one which gives unfettered access to the GPU, so there is not much choice. My personal sense is that those big frameworks are oversized and full of fat, and will get thrown away once somebody shows how to do deep learning properly, but that time is not quite here yet.
While I do not yet have a workflow for CI, I've proven (at least for my own uses) that one can achieve a lot with scripts as long as you are willing to load up your run.fsx with plenty of `#IF COMPILE` hackery, and abundant `load`. Still, I sympathize with you, and look forward to F# having Azure Function support improving.
What a great answer! Thank you very much.
Mark Seeman has some good stuff, but I'm guessing you've come across him already.
Do you want help with this project? I would like to volunteer :)
Thanks, but I do not think the language is in a state where I can show it to other people. It is quite usable at the moment, but I am still fiddling with the core so at any given moment it might be broken. I need to give the project it proper repo as well. Right now it is in a ML project one it grew out of and is hidden in a pile of scripts of various sorts. I am hoping that I can make some kind of sneak preview by the new year, but if I do not manage something in the next two months, I'll definitely have something in the next 3-6 after which I will be ready to accept inputs. Please stay tuned.
Project Euler problems! Did a bunch in c# and then felt like trying them out in F#
try let findString (xs : string) = Seq.map findChar xs |&gt; String.concat " " 
Thank you so much, this works. I had spent over two hours on that one function trying to learn what I was missing. I'm off to a rough start, but I'm really enjoying it.
Just saw your edit, and I really appreciate the explanation. Now that I'm not mixing up types, btw, the compiler can infer that the argument type is string without explicitly specifying it.
I found eulers problems not a problem after I discovered System.Math.BigInteger class. Try CodeWars, it contains multiple level of learning
As an additional to your findString function, I'd transform the string to uppercase first, otherwise your nato alphabet finder won't work with sentences that aren't ALLCAPS.
What are some issues with F# in Visual Studio?
Yeah once I found out that you can use BigInteger literals my world changed. And thanks, I'll look into CodeWars!
If I could write native GUIs using the Fable-Elmish style, I would use F# for every project. I've never been happy with WPF in F# though, so I typically end up with a client wrapper in C# around the library code. Dealing with events is just a nightmare in comparison to the more FRP-style solutions used in many other FPLs.
Mostly F# &lt;-&gt; C# interop issues. We have huge existing C# solutions where we sometimes add new projects written in F#. The experience of working with that mixture is less than pleasing even though F# on its own would be great. A few examples: * Renaming a type in a F# project doesn't rename usages in C# projects and silently results in lots of broken code. * "Find all references" on a F# type doesn't show usages in C# projects. * "Go to definition" on a F# type in a C# project decompiles the F# type to C# instead of just opening the F# file. * "Go to implementation" on a F# type in a C# project results in "There are no implementations." (or something similar) ReSharper adds more problems as soon as you accidentially make it touch F# code. Problems like that are quite annoying to myself (even though I'm very pro-F#) and make it close to impossible to convince other colleagues of F#'s advantages.
Actually yeah now that I think about it I've definitely had some issues with VS not being able to find definitions in F#.
I don't think its needed, I saw links online where they had it working direct, but it seemed more hassle than it was worth, I'm happy spending most my time in vs not unity.
Given what you just described, do you think that Fable could be the path forward for F#, or do you think it's already too far behind Elm ?
Fable is very interesting. I think there is huge potential for languages that compile to Javascript or WASM. I'm amazed there aren't more highly developed languages doing that given how old Javascript it but, for whatever reason, I certainly don't think it is too late. I do, however, have some reservations about the use of F# for that specifically. Although F# is an awesome language for general purpose desktop programming I cannot help but wonder if a language designed specifically for web couldn't be a lot better. F# brings a great deal of complexity that is simply irrelevant in that context. On the other hand, there is the substantial advantage of being able to run the same language on both client and server. Another issue is the critical mass of the community. F# was only able to come so far so fast on .NET because it was standing on the shoulders of giants like C# and VB. F# benefitted enormously from well-tested type-safe high-level interop via .NET. So much so that I almost never had to use PInvoke in production code. Alternatives like Fable completely sacrifice this advantage and represent F# trying to "go it alone". Is this a realistic proposition for such a small community? I'm not sure. Fable has no serious backers when competitors like ReasonML are backed by Facebook. The community using OCaml for web programming looks far bigger than the equivalent part of the F# community right now and OCaml is a really good match for compilation to Javascript. 
[removed]
ctrl-f (find), F12 (go to definition), back button (return to where you just were), PgUp/PgDown, ...
I'n most editors, you can collapse individual modules. In VSCode you can define "regions" like in C#.
In VS 2017 I use: * ctrl+T to search constructs (it picks up everything) * f12 to go to definition * shift+f12 to find all references * Hover over something and clicking on the item in the tooltip to go to definition * ctrl+f to do a document search * Code folding, which does show a little bit of the underlying stuff when you hover over the guidelines, but not much I don't work with large documents in VSCode, VS for Mac, or Rider. All three have similar feature sets, though VSCode has ctrl/cmd+click on a symbol to go to definition on it, and none of them have the clickable symbols in tooltips that VS has.
When I'm exploring a new project, I mostly jump from reference to reference with go to definition / find all references, and don't pay much attention to how the files are laid out. Once I'm familiar with a large file, the minimap scrollbar becomes my main navigation tool, because I start to remember the shape of the code and just click straight on the part. &gt; I guess what would be most helpful is some sort of outline view where I can see the names of modules and functions in those module, in the order I defined them within my project. Latest Ionide has a panel called 'F# outline' that does exactly that.
VSCode+Ionide has the `F# Code Outline` panel which will allow you to see the modules, types, and functions defined in the currently open file and it allows you to jump to them.
don't forget about top-down file structure! this helps too
Sadly when working with F# (it's usually a mixed solution with C# in my case) it's mostly ctr-f and ctr-shift-f - that and keeping the files from getting large and using meaningful names for modules and files
 I’ve been using f# to cleanly define behavior and clean up 2 c# class libraries. I have to think about what I’m writing in f# so it’s helped me to clarify the logic. Lot less debugging to do once it’s written in f#. For fun I’m writing a generic sports game model with tiers of leagues, promotion and relegation, recruiting young players and buyout markets. I’ve also got performance vs age curves for each athlete based on a varying bestAge. 
I've tried it out previously, my biggest issue was that a lot of things are harder to do than in pandas. If you want to append to data frames in pandas you just do that, in Deedle you need to reindex manually to avoid collisions. If I'm in the phase of sticking together dataframes I usually don't care about the old indexing. Another problem I had was with string handling. Most of the analysis I do is not numerical, but very string heavy. Pandas has a lot of string manipulation things built in. Working on columns with strings in Deedle however seemed like a huge chore (you can't even do quick indexing with ? for a column, in pandas you can use the normal [] to access any column the same way).
I'm using it and it works perfectly for me.
How is that 5-7-5?
In VSCode + Ionide there are following commands: * Go to symbol in workspace (`Ctrl/Cmd+T`) -&gt; navigate to symbol in workspace * Go to symbol in file (`Ctrl/Cmd+Shift+O`) -&gt; navigate to symbol in file, picks up stuff defined in local function scopes etc * Go to definition (`F12` or `Ctrl/Cmd+Mouse Press`) - navigates to definition * Peak definition (`Alt+F12` or pressing `Ctrl\Cmd` when hovering over symbol to get tooltip) - shows the symbol definition in inlined view * Peak Type Definition (no keyboard shortcut, available in command palette) - shows definition of type of current symbol in inlined view * Find all References (`Shift+F12`) - shows all usages of symbol in inlined view * Go to Type Definition (no keyboard shortcut, available under context/right click menu on the symbol) - navigates to definition of the type of the symbol * Symbol highlighting - VSCode highlights usages of given symbol in the whole file, it's visible in the scrollbar gutter. You can navigate between symbol usages with "Go to next/previous symbol highlight" command (`F7` and `Shift+F7`) * Go to line (`Ctrl/Cmd + G`) - navigates to given line * Go to next/previous error or warning (`F8` and `Shift+F8`) - navigates between errors in current file * Code folding - unfortunately, at the moment, it's the only ident based so it's not as accurate as VS one. Ionide provides also Code Outline view as a tab in Explorer view which shows the structure of the file - all declared namespaces, functions, modules, types in the declaration order. 
What else are we going to complain about now? /finally
I had an unpleasant poop today. Fuck you, Microsoft.
Judging by the comments on the blog, UWP :p
`|&gt;` is being picked up by many languages, it's great. But they forget the rest of the family `&lt;|`, `&gt;&gt;`, `&lt;&lt;` 
My poop was quite pleasant until I remembered there's no .net native support yet. FUCK U M$!!!! /s
You may be better off using Mono instead of netcore. The latter does not support any GUI programming, which Gtk part of the namespace obviously stands for.
oh really; thank you for informing me. I'm unfamiliar, though, with how mono handles package management. How should I go about installing and importing nuget packages using mono?
&gt; Still no UWP support
Thanks. I think visual studio needs a code outline view. But alas [this looks unlikely](https://github.com/Microsoft/visualfsharp/issues/3947).
Well it's about time!
Nuget works with Mono projects as well.
also `||&gt;`, `|||&gt;`,`&lt;||` and `&lt;|||`
Good IDEs have this option. 
There are a few options: 1) you can right click on a project and choose "Load References in Interactive" 2) you can use [paket to generate "load scripts"](https://fsprojects.github.io/Paket/paket-generate-load-scripts.html) for your dependencies I prefer option 2. You can either use the command line: paket generate-load-scripts --framework net461 --type fsx Or you can add the following line to `paket-dependencies` and the scripts will be generated on `paket install` generate_load_scripts: true If you're using a good/great/fantastic/the best editor (as /u/k_cieslak hinted at), you can use the Ionide Paket extension for VSCode to generate the scripts from the command pallet like: ctl + shift + p -&gt; Paket: Generate Load Scripts You can include the references in your fsx scripts like so: #load @".paket/load/net461/main.group.fsx" 
☝ developer of the F# plugin for VSCode (for those who wonder what you mean by good IDEs :P)
Paket load scripts.
Sounds good. More details please
Sounds like JET ;)
&gt; Startup like culture &gt; Must be willing to relocate Pick one 
visa sponsorship?
:) add "run by a soulless multinational"
Sadly for now, I've been reduced to doing a 'send references to interactive', copying the results, and editing them into the right format. Having a simple macro recorder (I use Xavier Poinas 'Text Macros extension) helps with this.
In Visual Studio 2017 there are three dropdowns at the top of the editor when in an F# file. (They are quite easy to miss.) These give quick-jumps to parts of the code at varying levels of detail, right down to individual functions. I can't remember if I did anything special to to enable this. Apart from that I use Ctrl+F, Ctrl+Shift+F, F12 and Shift+F12.
Also I turn on 'map mode' for my vertical sroll bar.
Problem is that they are in alphabetical order rather than the order they are declared in (which would be much more useful)
Oh yeah, that's not great, is it?
NY/NJ area means the company is in New Jersey. I don't understand your second sentence, after the comma. Does "(high 5 to low 6 figures / year)" refer the the sign-on bonuses? Are the sign-on bonuses paid every year? If so, then for how many years? If not, "does the high 5 to low 6 /year" refer to the salary? A "strong Back-end Engineer" can make that anywhere in the country. I'm a lazy-fuck back-end programmer in a mid-west farm town and I make more than that. You'd have to pay me that much to *visit* North Jersey.
No, it refers to the sign-on bonus. Sign-on bonuses can be for 1 year or 2 years depending on the negotiating but an example would be an offer I just received - 180k + 110k 1st year sign-on paid with 1st check, 125k sign-on year 2. 
Yes, if already in US