This is nice but it makes me wonder if we cannot have a port of camlp4's parser instead (which is higher-level than Parsec). 
I was wondering about that, too (if having camlp4 for F# was possible)
There is no theoretical problem but, unfortunately, Microsoft have decided to eliminate competition by closing the interface. This is a real shame but it does make perfect sense for them from a business perspective. For example, we were going to make a Mathematica-like notebook interface for F# with integrated visualization and typesetting (built upon F# for Numerics and F# for Visualization, of course) but that will now be impossible because they are closing the interfaces to the compiler in order to prevent us from competing with Visual Studio. Incidentally, this is also why F#'s quotations never went anywhere: that feature would have allowed third parties to manipulate F# code, undermining lock-in, so it has been shelved. For exactly the same reasons, Microsoft will almost certainly never produce a macro system like OCaml's camlp4. I believe it would be perfectly feasible to try to create your own (or just use the real camlp4 with a custom grammar for F#) but you could only do that by reverse engineering the F# compiler which would probably breach the license agreement. Camlp4 is still very useful as an on-line and extensible compiler compiler for grammars in general though, completely separately from macros. You could build an equivalent tool in F# but its performance would be poor due to the lack of metaprogramming (no compilation of quotations and no Code DOM) unless you wrote your own IL code generator. 
This release is great. I just wish there was better WPF integration support as there is for WinForms. I am interested in building WPF + F# apps and while I know it may be a pain, I will try.
F# is kickass and the Sept ctp shows that its getting better and better 
Great improvement over previous F# releases, shaping up to be a great addition to the .Net framework. Hopefully it will be integrated in to the core Visual Studio pack in 2 or 3 releases time.
Excellent improvement on the VS side. I hope to see more interconnection with WPF and F# in the near future as I am not a big fan of WinForms
Amen.
I've found it quite easy to write WPF apps in F#. What exactly do you find missing? 
Based on the few articles I read, I thought it would be a big deal, but if you say its not, then sweet. I haven't had much time to do F# + WPF, I am trying to finish up a book I am currently working though (Practical WPF Graphics Programming). I figure I once I am done with that I can do some of the examples in F#. Well it seems we are on the same page. Hope to talk to you about this stuff in the future man. I just wish there were more hours in the day :-)
Actually some aspects of F# make it easier to write WPF apps. For example, the designers of WPF decided to make a huge number of trivial data structures thread unsafe, so they can only be allocated on the UI thread. That is trivial to workaround in F# by allocating them lazily and only forcing them on the UI thread. 
Part 2: http://blogs.msdn.com/chrsmith/archive/2008/05/09/f-in-20-minutes-part-ii.aspx
I would comment more, but I'm still trying to process that presentation in the middle of that post.
You may check the "related" tab to see other planet feeds as well. 
Note that the algorithm implemented in this article is *not* the Sieve of Eratosthenes. 
Ugh, missing the point that you should not factor out commonality where there is none... 
Damn second base man influencing third base like that!
cool content, but please don't use url shortners like bit.ly
Once you've installed the msi, the source code is in `C:\Program Files\FSharp-1.9.7.8`. The hard parts of porting F# to the JVM would be handling features the CLR has and F# relies upon but the JVM lacks, most notably tail call elimination, value types, task parallelism and the memory model. Eliminating tail calls alone is a major headache for language developers targetting the JVM: witness the gyrations Clojure and Scala go through (e.g. `recur` and trampolines) and their on-going shortcomings. 
Very cool, thanks.
Yes, of course - nobody does anything useful anyway on non-Windows platforms and .NET runtime is quite small (under 100MB) and is already installed on practically every computer.
Provided you're happy to use Windows, yes. &gt; no LLVM backend Note that this is a red herring. If you just retrofit an LLVM backend onto an existing old-school compiler you'll only get results like the [&lt;25% speedups and slowdowns GHC saw](http://donsbot.wordpress.com/2010/02/21/smoking-fast-haskell-code-using-ghcs-new-llvm-codegen/). If you want the [50-300% speedups HLVM got](http://flyingfrogblog.blogspot.com/2010/01/high-performance-parallelism-with-hlvm.html) then you'll need to start from scratch. 
&gt; If you want the 50-300% speedups HLVM got then you'll need to start from scratch. And only run microbenchmarks.
&gt; &gt; If you want the 50-300% speedups HLVM got then you'll need to start from scratch. &gt; And only run microbenchmarks. ROTFL. A Haskeller complaining about other people's microbenchmarks. If you think my [FFT for HLVM](https://forge.ocamlcore.org/scm/viewvc.php/examples/compiler2/bench.ml?view=markup&amp;root=hlvm) is a microbenchmark, what is [Don Stewart's sum of 1..n in Haskell](http://donsbot.wordpress.com/2010/02/21/smoking-fast-haskell-code-using-ghcs-new-llvm-codegen/)? My FFT gets a single bar on a chart, his one-liner gets an eight page blog post... 
&gt; My FFT gets a single bar on a chart The lines on the bar chart linked are tco, fib,ffib, sieve, mandel, mandel2, Array.fold, hash table and bubble sort. Which one is an FFT? &gt; what is Don Stewart's sum of 1..n in Haskell? My FFT gets a single bar on a chart, his one-liner gets an eight page blog post... Neither Don nor I is claiming that as representative of the general speedup you would get from an LLVM backend. Note that his blog post starts by talking about "For the kind of loops produced by stream fusion". It's also interesting your post above has been edited and that the link &gt; &lt;25% speedups and slowdowns GHC saw. now points to Don's post, which says nothing about results like that. I'd have expected it to point to one of Simon Marlow's posts to ghc-cvs which does show precisely that kind of result on the full GHC benchmark suite. 
I think the thing which makes this an apples to oranges comparison is that the Haskell LLVM backend has to still compile Haskell programs, HLVM does not have to compile OCaml programs. Effectively, you measure the speedup of changing *languages*, so you might also conclude that C is a good alternative. It has many mature compilers, even with LLVM backends! If the LLVM GHC backend can be made to improve the performance of all programs, even by just 1-5% (although I guess it would be more, once they find some sane default optimizations). This (imaginary) 1-5% improvement to the hackage database would have more of an impact than 300% to the few existing HLVM programs.
Hopefully Mono should improve with tail recursion and better garbage collection. I like that I can do things like take C# managed libraries and use them in F# flawlessly.
Do you think the problem is that Haskell compiles to "C--" rather than directly to LLVM code? 
I think the main problem is that LLVM doesn't support GHC's "tables next to code" optimisation.
&gt; &gt; what is Don Stewart's sum of 1..n in Haskell? My FFT gets a single bar on a chart, his one-liner gets an eight page blog post... &gt; Neither Don nor I is claiming that as representative of the general speedup you would get from an LLVM backend. I fail to see the relevance of your statement in response to my statement about what constitutes a "microbenchmark". &gt; It's also interesting your post above has been edited and that the link I don't recall changing the link in my post. &gt; now points to Don's post, which says nothing about results like that. He says "speedups of 25% over the previous best performance we’d got from GHC for data parallel code". 
&gt; I think the thing which makes this an apples to oranges comparison is that the Haskell LLVM backend has to still compile Haskell programs, HLVM does not have to compile OCaml programs. Effectively, you measure the speedup of changing languages Exactly. That was my sole point and the reason why I said you'll "need to start from scratch" and not "just retrofit an LLVM backend onto an existing old-school compiler". &gt; This (imaginary) 1-5% improvement to the hackage database would have more of an impact than 300% to the few existing HLVM programs. If you assume that many Haskell users care about performance, which is an insane assumption given that there are very few Haskell users and they know full well that it runs like a dog (unless you're summing 1..n). You realise GHCs LLVM backend *slows down* a lot of Haskell code? 
&gt; Exactly. That was my sole point and the reason why I said you'll "need to start from scratch" and not "just retrofit an LLVM backend onto an existing old-school compiler". But you're not talking about just re-writing the compiler for a language, you're talking about writing a new compiler for a new language. These are *hugely* different tasks, giving up the work that has gone into the top 90% of the compiler that isn't code generation. It's easy to say "write a new compiler" but in practice it is quite time consuming to produce something reasonable. &gt; If you assume that many Haskell users care about performance, which is an insane assumption given that there are very few Haskell users and they know full well that it runs like a dog (unless you're summing 1..n). You realise GHCs LLVM backend slows down a lot of Haskell code? I fully distrust you to reliably convey how any group of programmers truly feels about any particular topic. Yes, I fully realize that it doesn't provide consistent improvements in performance. You do realize that this work was done by a student finishing their bachelor degree? I'm sure it is fine work which will only get better as more experienced core developers get exposed to it.
&gt; But you're not talking about just re-writing the compiler for a language, you're talking about writing a new compiler for a new language. These are hugely different tasks, giving up the work that has gone into the top 90% of the compiler that isn't code generation. You don't need to rewrite 90% of the compiler at all. &gt; I fully distrust you to reliably convey how any group of programmers truly feels about any particular topic. Ok. &gt; You do realize that this work was done by a student finishing their bachelor degree? Sure. &gt; I'm sure it is fine work which will only get better as more experienced core developers get exposed to it. I'm sure it will get better but I'm also sure it will never attain the performance I reached with minimal effort because they aren't even attempting to solve what I perceive to be the important problems. Indeed, that is precisely why so few people use it. 
&gt; Do you think the problem is that Haskell compiles to "C--" rather than directly to LLVM code? No, the main problem is boxing and that will afflict any backend because it is a consequence of the data representation strategy required by the compiler's design. A secondary problem is the poor quality garbage collectors: OCaml's doesn't support multicore and GHC's has poor support for mutable data structures. 
&gt;&gt;&gt;&gt; If you just retrofit an LLVM backend onto an existing old-school compiler you'll only get results like the &lt;25% speedups and slowdowns GHC saw. If you want the 50-300% speedups HLVM got then you'll need to start from scratch. &gt;&gt;&gt;And only run microbenchmarks. &gt;&gt;&gt;ROTFL. A Haskeller complaining about other people's microbenchmarks. If you think my FFT for HLVM is a microbenchmark, what is Don Stewart's sum of 1..n in Haskell? &gt;&gt;Neither Don nor I is claiming that as representative of the general speedup you would get from an LLVM backend. &gt;I fail to see the relevance of your statement in response to my statement about what constitutes a "microbenchmark". You were comparing the speedups GHC saw on its entire set of benchmarks against your set of microbenchmarks and asserting that starting from scratch could get you 50-300% speedups whereas starting with an existing compiler would only get you similar results to GHC's. My initial comment was simply noting that fact, and my follow-on was just emphasising that. &gt;&gt; It's also interesting your post above has been edited and that the link &gt; I don't recall changing the link in my post. Well, I don't know if you did this time or not, but you've certainly been observed making substantial edits to your posts after someone replied to them in the past. 
&gt; You were comparing the speedups GHC saw on its entire set of benchmarks against your set of microbenchmarks and asserting that starting from scratch could get you 50-300% speedups whereas starting with an existing compiler would only get you similar results to GHC's. My initial comment was simply noting that fact... You haven't stated a single fact. You are just trying to use emotive language to hide the facts. Let's look at some real facts about Haskell's "entire set of benchmarks": * Haskell's "entire set of benchmarks" includes dozens of tiny programs like [this one-line prime number generator](http://darcs.haskell.org/ghc-stable/nofib/imaginary/primes/Main.hs) that is the core of at least three of the benchmarks and [this ten line program to compute a series expansion of e](http://darcs.haskell.org/ghc-stable/nofib/imaginary/digits-of-e1/Main.lhs). * The "quicksort" is not actually a quicksort and, consequently, runs 100x slower than a real quicksort. So it is useless and, again, not representative of real code where performance is relevant. * On the parallel ray tracers, HLVM's gets over 6x speedup on 8 cores but Haskell's cannot even get 4x simply because it was not properly parallelized. * David didn't even run the "entire set of benchmarks" and, hence, his parallel benchmarks were limited to a dot product, sum of squares and naive matrix-vector multiply. That is a grand total of less than ten lines of code, less than a tenth the size of HLVM's parallel benchmarks. 
&gt; You haven't stated a single fact. You are just trying to use emotive language to hide the facts. Pot, kettle, etc.
you just type self as the url if you want a self post by the way
Not sure what this guy is talking about as far as microsoft not having released it yet. The source to FSharp.Core, compiler, etc are already shipped with each F# release. They install to C:\Program Files[ (x86)]\FSharp-1.x.x.x\source complete with fsproj files to build if you use the windows installer for 2008, and are also in the zip distribution. 
Note that asynchronous workflows are for concurrent IO and *not* parallel programming. 
By the time Mono fixes its GC and improves tail calls, couldn't someone implement an F# clone that targets the JVM? 
See http://cs.hubfs.net/forums/thread/13445.aspx for details
i've been plying with mailbox processor lately, but couldn't find the answer: how do i spawn new process inside other? i'd like to create ring of N processes, in that way that one process nows only his next neighbor (which the process just created)
&gt; "The F# team are also committed to open source cross-platform development, to the extent that they are hiring a new contractor specifically to help with this." All this guesswork what may be released when as OSS is really annoying. Instead of clearly communicating their plans they only hint at a possible OSS release of certain compiler components. What exactly? No one knows. When? No one knows. Apparently Microsoft still doesn't fully understand what OSS is about.
They're hiring people to make F# fully functional in Mono, even though they're not an OSS company at all. They sell and support serious products to millions of developers - they don't owe you a thing. Goddamn OSS hippies.
No, they prefer releasing actually functional piece of software, not alpha-quality crap that 99% of all OSS projects are. Plus, you already have the [full compiler source](http://www.microsoft.com/downloads/details.aspx?FamilyID=444005fb-e627-4feb-b51d-13d6a3b4b8ed&amp;displaylang=en) available in a separate package.
[One more ML dialect for the cheat](http://mth.github.com/yeti/). ;)
Nice work! Some amendments: * If `None` is `null` in OCaml then it also is in F# and (I think) `NONE` is in SML. * The `List.sort min ..` example for OCaml is wrong and should be `List.sort compare ..`. F# is just `List.sort ..`. * OCaml's `List.fold_right` is `List.foldBack` in F#. * F# also has `assert`. &gt; F# is close to OCaml, but the F# project was preceded by a port of SML to .NET. FWIW, F# was preceded by many such things including Haskell.NET. 
&gt; If None is null in OCaml then it also is in F# and (I think) NONE is in SML. NONE is one of the values for the standard option type in SML. If that's the role of None in OCaml, then yeah, they're equivalent. ETA: Hm. That's actually covered, correctly, in the "data types/null type" row. There are a handful of big omissions in the SML column (and, presumably, in the Alice column, too). The following jumped out: * currying in SML works fine (fun foo x y = ...; val foo2 = (foo 2);) * Alice should obviously have a lazy evaluation entry * SML has exceptions and the ability to raise them, and define new ones * SML has a while loop (it may not be full-featured, but it's certainly there) * everything from "environment and io" down is underpopulated: for example, languages other than OCaml have the ability to open, read from, and write to files :) In general, i recommend [RosettaCode](http://rosettacode.org/) as an excellent resource for polyglots. 
You may like our company's F# blog: [F# News](http://fsharpnews.blogspot.com/).
I hear lots of good things about Flying Frog!
No, the JVM is incapable of expressing F#. Specifically, it lacks tail call elimination and value types. That's why I chose to build my own VM rather than build upon the JVM. 
It can do tail call elimination sometimes, from what I remember. It just can't *always* do it. The jvm has *some* value types, but if you mean objects, you're correct, I don't think you can have an object exist on the heap. I just really like the F# language, and I think the JVM is an amazing platform....
This is great thanks for the template. M$ should have provided some templates or at least fix all the compiler/ide bugs that F# has as a "fully supported language" so it can work as flawlessly as C#/VB.
&gt; let handler myfunc = (myfunc 2) Superfluous parentheses. let handler myfunc = myfunc 2 &gt; let lazyMultiply = lazy ( let multiply = 4 * 4 ) &gt; Like F#, Scala is not lazy by default, but unlike F#, values -- not functions --have to be marked with the keyword lazy and therefore evaluated as call-by-need. This is completely wrong. The code is wrong and the explanation is wrong. &gt; let add = (fun x -&gt; (fun y -&gt; x + y) ) Could be: let add x y = x + y &gt; let rec fib n = &gt; match n with &gt; | 0 -&gt; 0 &gt; | 1 -&gt; 1 &gt; | n -&gt; fib (n - 2) + fib (n - 1) Can be written: let rec fib = function | 0 | 1 as n -&gt; n | n -&gt; fib (n - 2) + fib (n - 1) 
See the discussion here http://www.reddit.com/r/programming/comments/c6id6/scala_vs_f_comparing_functional_programming/
&gt; As a tester on the F# team I always took pleasure at finding the capabilities and limits of the compiler. For example, did you know if you are pattern matching against an integer type and have rules for all four billion possibilities the F# compiler stack overflows? Shame, I know. Either this example is completely made up as a challenge to see if anyone is stupid enough to try to prove him wrong, or he is taking his testing-job a lot more serious than I am.
When you work on a project that gets as many people banging on it as Microsoft does, then you would know the absolute limits of your software as well.
Hi reddit! I will appreciate feedback on the project and everybody is welcome to fork it and improve on it. Cheers
Sounds awesome. I'll take a look ASAP. :-)
I like it, you should keep going! Your blog will only become more interesting as you get into the harder problems. 
Some others i found helpful http://www.ctocorner.com/fsharp/book/ch12.aspx http://www.c-sharpcorner.com/UploadFile/mgold/PatternMatchingFSharp04292008183848PM/PatternMatchingFSharp.aspx http://natehoellein.blogspot.com/2008/04/f-pattern-matching.html http://diditwith.net/2008/02/19/WhyILoveFPatternMatching.aspx ---------------------------------- http://en.wikibooks.org/wiki/F_Sharp_Programming/Basic_Concepts http://en.wikibooks.org/wiki/F_Sharp_Programming/Pattern_Matching_Basics --------------------------------- http://www.jelovic.com/weblog/?p=234 http://research.microsoft.com/en-us/um/cambridge/projects/fsharp/manual/spec.html#_Toc264041960 http://stackoverflow.com/questions/2502354/what-is-pattern-matching-in-functional-languages 
Holy bibliography, Batman!
Nice! I spent a long time trying to figure out how to get F#/.NET4 running on a server without VS2010 installed (solution: the VS2010 CD has a redist folder with a special F# installer)
woot
This is some of the best F# vids out there! I wish he'd do the whole series.
Great lecture but the quality of these videos (at 1.3Mb/s!) and the user interface (doesn't even work in Chrome!) are appalling. At least you can download Don's (not Anders') but this is such a poor advert for Silverlight... 
http://videoaz.microsoftpdc.com/vod/downloads/FT12_High.mp4
FYI, I'm using Chrome and I didn't have a problem with it.
Cool stuff. I'm looking at reusing some client-side JS-libraries I've made on the server-side to reduce code-duplication, and while you have JScript.NET, seeing that I have more options is definitely a good thing. I guess I will be checking out both IronJS and Jurassic once I have the client-side stuff stabilized.
This generated a [huge wave of news about F# recently...](http://www.google.co.uk/trends?q=f%23) 
Anyone else wishing for graphics in F# interactive for F# 3.0? 
I think good tooling support is coming but I suppose it is only a matter of time.
The blog post wasn't really all that special, but the first comment makes my day. I really like this new Microsoft and how they are paying attention to developers.
Anyone here read this? Is it recommended if I already have *Programming F#* and *Expert F# 2.0*?
Most interesting where they disagree. Would be nice to hear more on those subjects... 
This sort of thing is why the open source compiler release is so exciting. Have any other new tools or addins come about because of it?
&gt; 2.10 in 2 - 3 months. Who has made this assumption? First it has a deviation of 30% and second, the points seem rather undoable in that timeframe. A very impressive list of fatures though, most of them for "under the hood". Looks promissing.
followup: http://www.nielsberglund.com/clr/fsharp-mono-and-mac-2/
I've seen type classes done before in F#, for instance http://fortysix-and-two.blogspot.com/2009/01/poor-man-typeclass.html. However it ends up being a wrapper on top of some nasty-looking reflection code. I'd be interested to see if anyone manages to make this work without using reflection, presumably by tweaking the F# compiler source.
http://cufp.org/jobs/developer-quantitative-strategies-group-f forgot the link!
&gt; “Language shapes the way we think, and determines what we can think about.” Benjamin Lee Whorf Obligatory links to Language Log: http://www.google.co.uk/#q=site%3Alanguagelog.ldc.upenn.edu+whorf&amp;fp=1
I'm a C# guy personally although I can work effectively in both VB.Net and C#.
Lots of votes for F#
I write mostly in C# for work, but I'd be more comfortable with IronPython.
I used to, but now I write all my new stuff in F# 
I may have skewed the results slightly when I posted it on [F# News](http://fsharpnews.blogspot.com/2010/11/whats-your-preferred-net-programming.html). ;-) 
F# before conversion: [&lt;ReflectedDefinition&gt;] let rec factorial n = if n=0 then 1 else n * factorial(n - 1) Javascript after conversion: ExampleScript.factorial = function(n){ return (function(){ if(Microsoft.FSharp.Core.Operators.op_Equality(n)(new System.Int32((0)))){ return new System.Int32((1)) }else{ return Microsoft.FSharp.Core.Operators.op_Multiply(n)(ExampleScript.factorial(Microsoft.FSharp.Core.Operators.op_Subtraction(n)(new System.Int32((1))))) }; })() }; 
This is a great idea. I just used the Currying snippet on Stack Overflow. It needs: * A "Share On Twitter" button * Comments (a la Reddit for source code)
I was wondering if the website could automatically post links to all public snippets to some twitter account (but I'm not sure how to do that yet). Sharing link - do you mean button for posting code to fssnips.net (e.g. from blogs) or for posting liks to snippets to twitter?
&gt; automatically post links to all public snippets to some twitter account (but I'm not sure how to do that yet) This is straightforward if you've got an RSS feed. I set up @reddit_fsharp using http://twitterfeed.com/. &gt; Sharing link - do you mean button for posting code to fssnips.net (e.g. from blogs) or for posting liks to snippets to twitter? I was thinking of an easy way to post tweets containing links to snippets. Maybe the other direction would be handy too. (If you were going to go all the way you could give it a Git API like http://gist.github.com. :) )
Apropos of nothing, an abstract syntax tree: http://github.com/fsharp/fsharp/blob/master/src/fsharp/ast.fs
&gt; type FscCommandLineBuilder() = let builder = new CommandLineBuilder() let mutable args = [] // in reverse order let mutable srcs = [] // in reverse order let mutable alreadyCalledWithFilenames = false /// Return a list of the arguments (with no quoting for the cmd.exe shell) member x.CapturedArguments() = assert(not alreadyCalledWithFilenames) List.rev args ... This looks weird to my OCaml-trained eyes. Is this how you specify objects in F#? 
Jesus, that's about 700 lines of just syntax definitions. 
Yes: that's a class with one method (CapturedArguments), four private fields (the let bindings) and a parameterless constructor (type FscCommandLineBuilder()).
Thanks. Is it possible to specify multiple constructors in this style? 
Yes - any secondary constructors must call through to a primary constructor: type FscCommandLineBuilder(a, b, c) = new() = FscCommandLineBuilder(1, DateTime.Now, "hello")
That sounds perfectly reasonable to me considering the functionality it supports (mapping ASTs back to ranges of source code, error handling, language features). 
That's several times more code than my self-contained [Sudoku solver in OCaml](http://www.ffconsultancy.com/ocaml/sudoku/). 
The refactoring feature I miss most in F# is Organize Usings (or Organize Opens, in F# terms). Without it, the list of *open* statements in my source code keeps on growing.
+∞: This is a beautiful description of a really useful functional concept with a squarely pragmatic application. 
After posting it occurred to me that this isn't directly related to F#. However, anyone who's programmed F# for more than a few days has probably come across the fact that you can't do arithmetic on a value and keep its type generic.
It's called typeclasses. There's a number of problems with them and with your proposal. 0) You've missed the T One() and T Zero(). 1) There are things you can "add", but can't multiply, etc. There's a whole hierarchy of these algebraic structures - magmas, semigroups, monoids, groups, semirings, rings, fields (and a few more). You've roughly described almost a field. 2) There are things you can "add" in several ways. Which of these ways shall you implement? What if you need the other one? That's what "dictionary passing style" is for (google it). 
Keep up with these posts! Very interesting
Awesome! Congratulations :)
You rock Johann. Have you ever considered on giving a talk on the community for F#?
Thanks for the kind words!
Hmm, not really, maybe some blogging, but no talk planned. Why, do you have a specific audience in mind?
Very helpful. I'm trying to decide between making the first iteration of my game with xna for xbox/pc/wp7 in mostly f# or to use Tao for pc releases and then write another presentation layer for xna later. This makes me think a little more about going the Tao route.
Wow, that's lovely. Maybe we can port this to Vim.
Once the first install had crashed partway through and uninstall threatened to corrupt Visual Studio, I found that a maintenance reinstall of SP1 helped (even though it also crashed!). Silverlight seems to be the culprit... 
and that's why I install this in a VM
For the interactive online tutorial/demo, go here: http://www.tryfsharp.org/Tutorials.aspx Give it a spin. Following seems to work for me ;) printf ("Hello reddit\n") 
Well, this is only tangentially related to F#... anyway, I'd love to see an option type in mscorlib.dll 5.0 :)
That looks worth a look. Are there any reviews up?
there is one now :)
lo!
Partial application is a blessing when writing generic code. This kind of code typically depends on lots of variables, making it rather unpleasant to use unless convenient shortcuts are written. Partial application helps redability and maintenance of the code code of these shortcuts.
The link is here: http://technologyandfriends.com/archive/2011/04/04/tf149.aspx
F# does not support forward declaration, so mutually recursive types let you define types that reference each other in a circular way. 
Example: http://www.quanttec.com/fparsec/tutorial.html#parsing-json.createParserForwardedToRef-example
Now there is only one step to ClusterF*... ;)
This snippet originated on our discussion at SO: http://stackoverflow.com/questions/6969197/f-async-stack-overflow The result of the discussion was two versions of mapReduce, appropriate depending on whether reduction is just associative or also commutative, as kindly pointed out to me by Nick. It is curious that Nick would use the non-commutative version for the word count algorithm where the commutative seems more appropriate.
type providers get me hot. Have an upvote.
Just a reminder: in 2008, [Java was the language of choice for discriminating hackers](http://en.wikipedia.org/wiki/ICFP_Programming_Contest#Prizes). J
I'm very pleased that we managed to keep imperative languages off the top spot this year! EDIT: See the description of our strategy [here](http://mjolnir.cs.ox.ac.uk/icfp2011/README.txt)
Kudos, good sir.
1. No idea but I recommend not trying to encode anything F# cannot already express directly in its type system. 2. Lists are not as common in F# as in Haskell (or even OCaml). Maybe try arrays and `Array.sub` instead? 
Hi Jon, Thanks for your insight. Your point about not trying to add to the type system is pertinent. The code that I link to looks horrific. I will leave well alone. Ben
Business people have no business deciding on programming languages :) You probably meant technical managers though. In that case, F# does allow you to use C# chained LINQ methods, e.g.: let a = [1;2;3] let b = a.Where(fun x -&gt; x &gt; 2).Select(fun x -&gt; x + 5) Which really looks C#-ish , instead of the equivalent but more F#-ish: let b = a |&gt; Seq.filter ((&lt;) 2) |&gt; Seq.map ((+) 5) More generally though, IMHO it's a useless endeavor... it's like wanting to make Chinese more English-like just to make it easier to learn for English speakers. It's just a different language. FWIW I started with F# around three years ago with no previous functional programming experience and I never thought the syntax was cryptic...
Hmm.. am I alone in thinking that there's a pretty strong correlation between "readability" and adoption in programming languages in enterprise environments?
"Readability" is a function of what's written (the code) *and the reader (the programmer)*. Again comparing with spoken languages, I don't know Chinese, but I can't say it's unreadable. I can only say it's unreadable *for me* , i.e. you must set both variables to get a readability value.
Exactly; although I now only like my statement in conjunction with your qualification. Goes back to the old writer's saw: Write for your audience Sure, code is different because it becomes executable and a compiler/interpreter must be able to use it, but ultimately the code we write is consumed by others as well, and when a customer will see and review it, then they must be able to understand it too. Makes me wish literate programming was a widespread practice. I really think Knuth is on to something with that.
I don't disagree, but let's say someone wanted to discuss concepts that were culturally Chinese, and therefore quite alien to you. You would still have an easier time if that discussion were in English. I think the point is I already know English. So if you could make a discriminated union like this: Type Expression WhichIsEither Binary WhichIs Tuple(String, Expression, Expression) Or Variable WhichIs String Or Constant WhichIs int Obviously I'm not very good at this, but you get the point, it is at least readable without knowing what a pipe character is. Better examples might involve words instead of stuff like h::tail or | [] -&gt; 0 which means nearly nothing unless one has read and memorized the relevant chapter. 
If I'm chinese I'd rather have the discussion in Chinese. Why should English have priority over Chinese? If you expect the Chinese to learn English, then I can just as well expect the other party to learn Chinese. Someone will have to learn the other language, and if you're explaining a Chinese concept it would be best to do it in Chinese. About idioms like h::tail, there are similar idioms in C-like languages. Why the semicolon at the end of every statement? Let's drop it so it's readable without knowing what a semicolon character is. Why do people usually use variables like i,j,k in for loops? Yes, I know they were reserved variables in fortran or something like that, but by now they're purely idiomatic, there is no real reason, yet people still write code like that. What's "a++;"? Why not just "a = a + 1" which is simpler and doesn't have side-effects? Bottom line: idioms are unavoidable. Obviously when you start learning you might not understand them, but later you will embrace them. There's nothing inherently more readable in C# than in F#. 
FWIW, as F# is derived from OCaml, the syntax follows in a number of areas. The design guidelines for F# state that symbolic operators should be kept to a minimum for public apis. However, in order to retain some level of OCaml interop, the pipeline and other operators were retained. For my part, I've never found them hard to understand. If anything, I generally find them far easier to understand than most of the noise in C#. It's definitely a personal preference. You are free to alias the functions: let pipeRight x f = x |&gt; f let pipeLeft f y = f &lt;| y etc. If I may ask, do you not find `=&gt;` difficult to read in C#, as well? I should think you would find that nearly incomprehensible given that it is just stuck in between a variable name and either a function call or curly braces.
If you're looking for a more C#-like functional programming language, take a look at [Nemerle](http://nemerle.org/About/). It's also a hybrid OO/FP language like F# but with syntax mostly derived from C#, unlike F# which belongs to the ML family. Once you're comfortable with the fundamentals of functional programming you can learn any other FP language much faster and syntax won't bother you as much since it will map to concepts you will already know.
Imagine maths if everyone wrote like this: integral over x from zero to Pi of x times sine of x Horrible, and kind of like Java...
When I learn something like math, I rely heavily on the discussion text surrounding it. A wall of math symbols pretty much leads me to close the book. Actually, come to think of it, the same thing happens when I learn programming. I need an English discussion of the concepts first, and then I can sort-of slog through the symbolic representation. I think I'm realizing that I am basically an Englishman in Beijing.
Yes, =&gt; is an obstacle for me. I mostly write in VB.NET at work, so I probably learned it once but I don't remember what it does, and there is nothing in the symbol itself that clues me in. Don't get me wrong, I'm not saying symbols are bad. For example, I can't imagine anything worse than changing the dot for invoking methods and properties from an object to something more verbose, even for learning purposes. All I'm really saying is that for me learning both the F# symbols and the functional concepts at the same time presents a bit more of a hurdle than if the symbols were self-documenting. Once I understand, then tell me that CodeAsData() can be replaced by &lt;@@ @@&gt; or something like that.
In the case with lists, you can usually use "hash-types" that let you write functions which take lists containing elements that are subtypes of the specified parent type. For example: "let foo (elems:list&lt;#Parent&gt;) = ...". It doesn't give you the full power of co/contravariance, but it works in many situations.
Lack of covariance hasn't been much of a problem for me. Just map-upcast wherever needed, not a big deal. You mention you recently learned about covariance, and .NET only added this in .NET 4 (i.e. quite recently), did you find the lack of covariance before that to be a big problem?
Thanks for the suggestions, I'll try this. It has been a frustration to me, and still is since I'm still stuck coding in older VB in VS2005 at work. I sort of dream of being the guy to bring F# to the company, but I really need to write an elegant and clean solution to an existing problem before anyone is going to be convinced to try it.
Have you tried using Discriminated Unions? It's much more common for a F# programmer to use them instead of OO-inheritance. 
I don't use much inheritance in F#, and when I do it is almost always in the "values are always upcasted to their abstract base type" sort of thing, using object-notation to construct values. It is kind of like a "super record", now that I think of it.
The one time I tried to use it, working on a similar problem actually, I was running into a similar problem, having trouble constructing hierarchies of things that were essentially subtypes of each other. I'm sure it is still just my OO-focused brain trying to wrap itself around the functional way of doing things. I do really like discriminated unions, though. That is another thing that it really surprises me other languages don't have baked in. "This can either be one of these or one of those..." Very common in practice, I think.
The one time I tried to use it, working on a similar problem actually, I was running into a similar problem, having trouble constructing hierarchies of things that were essentially subtypes of each other. I'm sure it is still just my OO-focused brain trying to wrap itself around the functional way of doing things. I do really like discriminated unions, though. That is another thing that it really surprises me other languages don't have baked in. "This can either be one of these or one of those..." Very common in practice, I think.
When you say always, do you mean always? So does that make it more of a pattern of different ways values can be constructed?
Actually, DUs are implemented as abstract class hierarchies under the hood where the defined type is the base class. The only downside is that users can't extend them directly by inheriting. However, you can make the contents of one case in a DU another class and that can be inherited from, and will act as if it were it's base class once properly wrapped in the DU type. Pretty cool, eh? 
Well, in the cases I'm thinking of yeah, it's always. I'm not sure what your second question means. And I shouldn't say I never use inheritance - working with reflection or ADO or whatever requires pretty heavy use of marshaling via `obj`.
I was trying to think of a situation where you would create subtypes and then always upcast them. I assumed because you called them values that they didn't have behaviors attached, so I couldn't see how they would be different in any way from each other once upcasted. So the difference between the subtypes would have to be in how they were instantiated. But maybe my assumption about not having differing behaviors was incorrect.
Oh, no they had a lot of behaviors attached. But the interface to the behaviors are defined on the base class.
So I tried to be functional and create a generic map-upcast function where I would pass in a list and the type to which to upcast its elements. But I can't figure out how to pass in the target type. Any idea how to do this? I guess the ideal would be to constrain the type passed in to be a supertype of the type of the elements of the list passed in, right? 
I'm almost sure it's not possible to do this generically, or at least not generically and safely at the same time. If you want generic and unsafe use something like Seq.cast. If you want safe but not generic use Seq.map (fun x -&gt; upcast x)
Wait... is it as simple as the fact that I am using the debugger hence it keeps the stack frames around for me to inspect? Crap. Going to have a look at release builds... edit: ok in the release build it just inlines the call to a and converts to a loop. I take it all back F#, I still love you.
Wow, GREAT idea ! I'll be following this closely. Make sure to post your updates here.
I believe the same thing can happen to a Rubik's cube.
I've been writing code professionally in F# for 5 years now and I've only found a couple of situations where covariance might have helped and none where contravariance would have done. I came to F# from an OCaml background and OCaml has supported co- and contra-variance for 16 years or so and, yet, it is practically unused in real OCaml code. So you probably want to embrace ML as others have said and use union types. 
ok - the next part is online: http://www.gettingsharper.de/?p=103
next part: extending with alpha-beta-pruning: http://gettingsharper.de/2011/11/23/extending-minimax-with-alpha-beta-pruning/
Another F# junkie? Awesome! Here's a few ideas (take them or leave them): -.Net library for hot-swappable programs (a la Erlang) -Monte carlo baduk AI -NOSQL time series database -Enhancing http://fsharprefactor.codeplex.com/ (also maybe take a look at enhanced F# support in the VS 11 preview) Wish I had time myself for any/all of these :) Good luck!
&gt; Another F# junkie? I never said that! &gt; NOSQL time series database I don't really care for non-relational databases atm. &gt; Wish I had time myself for any/all of these :) Me too! &gt; * Thanks for the ideas!
I've been working on a TSQL parser in F# a few months ago. It uses Yacc and the query structure can be read into a C# class model. I suppose they also teach parsing at your university. So that might be a nice combination of the topics you like? It's based on this article: http://en.wikibooks.org/wiki/F_Sharp_Programming/Lexing_and_Parsing The github example code: https://github.com/obeleh/FsYacc-Example Current parser: http://code.google.com/p/fs-sqlparser/source/browse/#svn%2Ftrunk
Yeah this is actually a good idea! I earlier wanted to write a language that compiled/translated to tsql, and think now that this would be a fun idea. It'd also be practical as hell; I can actually see it being used at my work. Thanks for the idea, again. Unfortunately we don't really have a compiler/parsing class, but I'm not worried at all, really. I learned most everything about cs on my own and I have relatively strong technical skills, so I think I can pull it off.
A library for code generation. F#'s quotation mechanism generates ridiculously slow code and the code DOM doesn't let you compile generated F# code so I'd like a library that uses `System.Reflection.Emit` to compile high-level code down to efficient CIL that can be evaluated efficiently. Applications include serialization and parsing. For example, I could use reflection to generate efficient serialization code and then run it with performance as good as 2-stage compilation but without the separate compilation stage. You could have in-line lex and yacc as well, rather than separate tools with their own build stage. 
That may be a bit beyond me, but I'll look into it :). I have no problem with reflection, but it seems like something that since it's not done by now, and it's not that obscure, it's probably too difficult.
http://keithsheppard.name/notes/2011-10-02-compiler-with-FSharp-and-LLVM.html &lt;- grow this
Access denied You are not authorized to access this page.
Should probably post it then?
F# tries quite hard to eliminate tail calls itself using inlining and jumps but it also falls back to generating the tail call CIL opcode.
System.Reflection.Emit is not a trivial class to work with, as you have to understand CIL.
You might have better luck using System.Linq.Expressions, it's just as fast or faster than normal reflection.
For whatever reason, this is a vid of 3 talks rolled up, DPH starts at 43:00 and Cisternino re:F# at 1:07:00 (at which point mod says that Expert F# book has just been updated)
My experience with F# is that it can be used even for general-purpose, LOB applications where C# is often used. You don't have to confine your use of F# to applications that rely heavily on numerical computations (like in the scentific and financial industries). The only issue is whether you can get management and your fellow programmers to agree on using F#. It's also not necessary to use just 1 language. C# and F# can be used in combination quite easily. For example, with GUI-based applications, the UI layer can be written in C# (because handling mutable state is better expressed in C# than in F#) while the "library" part can be done in F#. I've written some of my own commercial apps myself this way. 
Oh, I'm not saying you've done bad - I've rolled my own parser-combinator modules in F# when I needed to parse arbitrary token-streams. But I still use FParsec for my work-horse because it is fast. I think there is room for both approaches.
F# cross-platform and open source? love it
Woot! #light (* exec fsharpi --exec $0 --quiet *) printfn "Hello World"
F# (as in Microsoft's product) has no support for web programming out-of-the-box. There is a third-party product called WebSharper from a company in Hungary called Intellifactory that lets you compile F# both client and server side. I've used it and it is technically very good. 
very interesting article. Thanks.
Any programming language that doesn't have an apt package for Ubuntu will not go very far in the "open source world". To me this is a much bigger issue than whether f# runs on the jvm or mono on Linux. Also the focus on monodevelop seems a little off to me. A lot of Linux devs love their tools and would rather not have to switch them out just to learn a programming language. Working on the vim, emacs, sublime integration, command line debugging/building, and most importantly: package management. This would probably do a lot more good than polishing the IDE.
Stupid blog post from an incredibly arrogant person. F# is better than all other languages, anyone who doesn't agree with him is an idiot, .NET developers are dumb and follow Microsoft blindly, Microsoft are a bunch of crazies who frighten developers (??), open-source is the best thing ever... plus some wrong theories about the future of .NET and related languages. It's true that Microsoft is not giving enough attention and resources to F#. That's about the only correct thing in this post.
Neat comparisons!
Same behaviour with rlwrap, except it prints ~H and ~F for home and end. Same issue with the cursor too.
BTW, the best support for F# is usually over at stackoverflow.com: http://stackoverflow.com/questions/tagged/f%23
Thanks, will do.
I was having this trouble as well on ubuntu a few months back. Definitely some bug that still needs to be fixed.
[FPish](http://fpish.net/topics) is also a good place to ask. (full disclosure: I'm a maintainer on FPish.)
Real hackers do real thangs.
As an 8 year programming veteran, i understand only 25% of the words.
I love F# examples like this and it is why I am dabbling in the language during my spare time. So I might be wrong about this, but doesn't his conversion of Severity to a string require him to then write something to handle it on the way back, if he wants to convert it back to the discriminated union? Also, shouldn't he just implement a tostring method for it? And a complete aside, what is the best way to handle connection strings in F#? Examples always assume you have one, and I can create one, but then where do you store it: in metadata or config files or what? You obviously don't want it in your code if you are promoting it to a public project, right?
I found there us a problem with storing discriminated unions, because enum is not supported by Azure Table Storage. That is the reson for the conversion to string. The LogEntity stores it also as a string, not as a discriminated union, so if you get the log back, severity is string.
[Other F# (and now Haskell) user group talks](https://vimeo.com/rickasaurus/videos)
Code &amp; slides are available here: https://github.com/tpetricek/Documents/tree/master/Talks%202013/Domain%20Specific%20Languages%20(NYC) 
I had a quick look and I think I recognized some parts of the code, or maybe it's just a coincidence :) In any case, it looks like you have some interesting things in there. I haven't actually compiled the code, so please excuse me if my remark is unjustified, but I think it's a good idea to separate your framework into multiple layered libraries. I always run away from everything that's got "framework" in the name. To me, it means "unflexible stuff with potentially useful bits in it". The easier you make it to extract the useful bits, the more likely people are to adopt your code. The term "library" of "collection of libraries" is a lot less intimidating. For instance, I am at this point not convinced I want to deal with the update/draw code generator stuff (that sounds like PhD material that has yet to prove its usability and applicability IRL). However, some of the simpler things like co-routines and vectors with units-of-measure are of immediate interest to me, and are pretty stand-alone. Then I also think that the choice of license and hosting site are maybe not optimal, but that's just my personal opinion. I think many will find the GPL too constraining, and I think github is the place to be if you want external contributions from other F# developers. AFAIK that's where most of the OSS efforts with F# are centralized.
Hi, first of all thanks for checking this out. About the recognition, I do believe we discovered various bits in parallel, and indeed you may find a lot of overlap with your work. We are, after all, doing the same thing :) Coroutines, vectors, and the menu system are cleanly and simply useable and can be extracted from the libraries, that is true. Do not discount the update/draw generator though, and check the sources for the RTS and Asteroid Shooter if you can. Not only using Actions in Casanova provide you with shorter code, it also *generates spatial optimizations for you*. The benefits in terms of performance without the visible degradation in clean representation of the information are significant, that is you do not muddle your game code with optimization data structures because the code generator does that. Imagine something like LINQ but capable of some limited but effective SQL query optimizer. I started the project mostly because I wanted to be able to do this and hated the way it is usually done in games, functional or not... The number of samples available and their complexity, coupled with our experience with medium-sized internal project shows that the library as a whole is much more valuable than the sum of the bits...
I was extremely happy when I saw the title and then checked the repo and now I am not that happy. Did I miss something or does the very early stages mean that there is almost nothing in there yet?
It looks like all they have done is write the grammar from the language specification in an ANTLR format. 
I would like to thank /u/7sharp9 for his efforts, documenting how to get things working, and overall paving the road to making this happen. He really deserves a lot of the credit. 
Excellent watch in case you missed it (media persona)
Great post!
See the other thread http://www.reddit.com/r/programming/comments/1h7xpz/announcing_a_prerelease_of_f_31_and_the_visual_f/
Oh wow, I didn't realize there was a parser combinator library for F#; I love parsec in Haskell, so I'll have to give this a try. Thanks for the link!
FParsec is an amazing library and quite efficient. I've got it parsing some 30,000+ line files into an AST in about 30ms.
Damn, that's impressive. Are you reading the files in asynchronously, or is this sequential? In a parser in Haskell reading about 132 MB of code split up into about 3,600 files and weighing in at about 4 million lines, the original version I wrote parsed each file sequentially and took about a minute and a half. When switched to parse files in parallel, it took ~20 seconds, so it was a huge improvement. If I did my math right, at the end it was taking about 15ms per 30,000 lines, but that was with 4 threads and when I was making a rather uncomplicated tree and disregarding large chunks of input. Regardless, if you're working on a lot of files, it might help to parse things asynchronously, then combine the trees at the end if you can. Mind if I ask where you work that you use FSharp, or was this a hobby project?
Was parsing single files at a time (didn't have the need for doing them concurrently as I'd only ever parse a few at a time). The 30,000 line file was actually an edge case, as most of the files were only a dozen or so lines in length. It was for a hobby project, but I've been slowly working to introduce F# where I work. One of the teams within my department already uses Scala, so I know there's quite a few people that would already be familiar with many of the concepts.
I think it's better than Parsec, honestly. And MUCH faster. I used it for my senior honors project to compile a language I created to SQL.
I should have opted for more jam sessions. I only got to do the one on Monday, which was creating a spell checker. 
I found out about lambda jam too late but I plan on going next year. Would you recommend going?
I liked it a lot. It was not f# specific though, so if you are only interested in f# I don't know that it would be very beneficial. The thing for me was to get some exposure to other functional languages to further my knowledge on functional programming in general. There was a pretty big f# crew and some big names in other languages, such as Joe Armstrong (the guy who created erlang). I also booked early enough to stay in the hotel that was hosting it too, which made things very easy. 
Side note/reply are you checking out the progressive f# thing going on in nyc ? If you haven't heard about it yet now is the time to jump on it before the prices go up. http://skillsmatter.com/event/scala/progressive-f-tutorials-nyc 12 more hours on early bird pricing: http://www.eventbrite.com/event/6321500779?ref=ebtnebregn 
Probably wont be able to swing it but it looks awesome 
Do you do f# professionally?
Nah, I do c#. I'm an f# hobbyist. My work recently sent our team to qcon in New York and I did another conf in Toronto in January so it's a hard sell for another conference. I'm tempted to just go anyways since I'm interested in f#.
awesome, I was sort of in that situation, but now we got a good group of guys pushing F# at the place I work. To be honest I think we had the highest number of people from one company that went to lambda jam and we all like F#. Its awesome that in a .NET shop you can put F# in where it belongs and not change the build/deployment process.
I really like f#, though I wish it had the same level of tooling c# has. while parts of the dev experience are faster, other parts are painfully slower. if f# had resharper it'd be the killer language. Side note, maybe you can help me here. i ran into a scenario where I learned that functions don't support variance, so using polymorphic data types doesn't work with function arguments and return types without up casting. Is this just a fact if life with f# or am I doing something wrong? For example if I have a class A that implements interface IFoo, then if have a function like func: IFoo-&gt; unit You can't do func (new A()) Without doing func (new A() :&gt; IFoo) right? Seems weird that you have to explicitly upcast 
I have had to do this quite a bit. I think its the type inference and the fact that its not meant to interfaced. New A() can be any implementation that works with IFoo and is not IFoo itself because you can not create a new instance of an interface. Anytime I have interfaced anything out I can not seem to use the stuff inside without up casting to the interface. 
Ok cool, thanks for the tip.
Awesome, looking forward to having you at the meetup!
I run the NYC F# meetup. Don't be afraid to do hands-on stuff sometimes. It's a great filler when you can't find speakers, and many of the newer folks actually get more out of it.
What topics have you guys covered in the past?
Most of the talks are available for you to watch online here https://vimeo.com/groups/97577
Jackpot
I wish there was an active Palo Alto/Silicon Valley F# meetup group. There's an SF one, but it's not very popular and all the way in SF.
I do F# and live in DFW
Site breaks back button = fuck you.
if you are intrested in a ML implementation for the JVM checkout yeti-lang : http://mth.github.io/yeti/ 
KOTSDHHG
I wanted to share a library I've been working on called ParsecClone. It's obviously an FParsec "clone" (not a full clone) that works on strings as well as binary (byte level and bit level) streams. Anyways, figured I'd share cause it was a fun project! If anyone has any feedback I'd be into hearing it. 
I hope people find it that way. I was able to parse the mp4 format with this using combinator style parsers. I work with video and use a c++ home brew parser at work which is a million times more complicated so it was neat to rework a portion of it in f# for a demo. 
Is there a good primer that explains what a type provider is? I see some MSDN documents, but they jump right into using and building a type provider without really explaining what one is.
Just an update on the library, you can now pass user state for context dependent parsing, and access internals such as the stream position. The mp4 parser uses all of this stuff to demonstrate how it works. 
More updates, binary parsing is now almost as fast as c++. Especially handy is being able to directly blit structs that contain blittable types. It's almost 50 times faster to do that than to map types directly. I'm leveraging some native helper code but the combinator library is still compiled at any CPU and uses runtime side by side loading to get the right architecture assembly to load the native code
If you go the raw pointer route, why not unsafe C#? A lot of people don't have VC++ installed, and the dynamic loading sounds complicated.
Actually I did end up doing that after I played with the native route. The problem is blitting generic types, so I had to emit custom IL to do that. Now it's two managed dlls instead of one managed and two native
You could check out the [F# Deep Dives](http://www.manning.com/petricek2/) book which is all about practical applications of F# Then there's also [Building Web, Cloud, and Mobile Solutions with F#](http://www.amazon.co.uk/Building-Web-Cloud-Mobile-Solutions/dp/1449333761/) which also has a very practical approach to F#.
If you can try to go the [Progressive F# Tutorials](http://skillsmatter.com/event/scala/progressive-f-tutorials-2013) in London. Lots of sessions on practical uses of F# by experts (and me). I write bespoke enterprise applications in F# and will be presenting a session on this and domain modelling without objects. 
You might like to buy a subscription to our [F# Journal](http://www.ffconsultancy.com/products/fsharp_journal/?so) which has over 150 articles on F#, most of which walk through the design and implementation of a program to solve some problem. For example, the last article described a program that segments a scan/photo of hand-written digits into individual digits and then uses a simple technique to do OCR. Others have mentioned the Progressive F# Tutorials in London. I'm the second speaker (after the keynote by Don Syme). 
Find the "F# WPF MVC Framework" tutorial on Github. It gives comprehensive overview on creating reactive UI with F#.
I can see the little quibbles about inconsistent naming of things--tuple being (type * type) vs. (type, type) is a fair point. I think some of those inconsistencies arise from the fact that F# is derived from OCaml but it adds some types which are present on .Net but not in OCaml. I don't believe there is an array type in OCaml (although I may be wrong)--hence int[] vs. int array.
If your code is only dealing with lists or arrays not both at the same time, you could open the namespace so you only have to change it once per file. As far as F# is concerned Array.map is unrelated to List.map so having those not accidently swap is a good thing. What we really need is one map function that works on IEnumerable objects in such a way that it passes through the underlying collection type to the map's output. I am an F# newbie as well though so I am not sure how feasible that is.
I've started doing this as well. It's essentially the same as using LINQ in C#.
F# does support a number of polymorphism-related features (operator overloading, method overloading, subtype polymorphism, parametric polymorphism). But indeed, F# does not not support higher-kinded polymorphism (like in Haskell's type classes). But even in Haskell, code usually does not abstract over the type of sequences (correct me if I'm wrong) because it just not necessary unless you write some very general code.
Most of the so call warts come from F#'s ML\OCaml heritage. It was kept this way in order to make it easy to port code. As for the Array.map vs List.map problem, this is an issue with the .NET type system. The only way to do this efficiently would be to make an IMappable interface and apply it to all of the data structures, then use something like Mappable.Map, but you can't do it to existing data structures like arrays because they're part of the .NET core. There is one caveat to this. Whenever you see #seq in a signature it uses the IEnumerable interface but without most the performance loss normally incurred. Maybe some day we'll get something like extension interfaces, until then we're kind of stuck.
&gt; I think higher kinds make type inference undecidable in general. No, higher kind type inference [is decidable](http://www.lfcs.inf.ed.ac.uk/reports/97/ECS-LFCS-97-365/ECS-LFCS-97-365.pdf). The main reason why there are no higher-kind types (nor OCaml-like functors) in F# is that the .NET intermediate language and runtime system don't support them. Undecidability of the inference wouldn't really be by itself a criterion for F#; after all, the current system already needs annotations, in particular for OO code. (What's the type of `fun x -&gt; x.Length`?)
&gt; true polymorphism What exactly do you mean by that? 
&gt;I can see the little quibbles about inconsistent naming of things--tuple being (type * type) vs. (type, type) is a fair point. types are sets, 'a * 'b is the set of all tuples (a, b) for a belonging to 'a and b belonging to 'b. It's standard math notation.
In an OO paradigm, the ICollection interface could define a polymorphic Map method. Then every implementation of ICollection would implement that method in a way that is specific to its structure. You'd invoke it via myList.Map() or myArray.Map().
Pattern matching in F# over sum types can be used in many situations where you would use an interface in C#. Generally (I think) any interface can be refactored into a sum type and vice versa. (Not saying it's always advisable, just that it's possible.)
&gt; In an OO paradigm, the ICollection interface could define a polymorphic Map method. In OO the best you can do is: map : ICollection -&gt; (Object -&gt; Object) -&gt; ICollection which is basically useless. In OO with generics you can do: map : ICollection&lt;T&gt; -&gt; (T -&gt; U) -&gt; ICollection&lt;U&gt; which is better but you are returning an abstract `ICollection` so you cannot then use concrete functions specific to the kind of collection that it really is. What you really want is higher kinds but there are major trade-offs in the design of the language and the practical benefits are actually quite small. After all, how many such functions are there? &gt; Then every implementation of ICollection would implement that method in a way that is specific to its structure. An interface cannot contain types specific to the class implementing it. 
&gt; how many such functions are there? Nearly every function in the collection modules is potentially polymorphic: * Array.append, List.append * Array.average, List.average * Array.averageBy, List.averageBy * Array.choose, List.choose * Array.collect, List.collect * ... I got tired of typing. There are dozens, if not hundreds, and that's just for collections.
&gt; types are sets, 'a * 'b is the set of all tuples This is a valid historical point, but it still doesn't seem like good programming language design. Why use set notation for tuples, but not for any other types? 
I did say it wasn't impossible to solve, just that it wasn't something that F# could solve given what it is. While being a .NET language is an incredible benefit, it also comes with some tradeoffs.
I see. So there's no way to return a covariant type in a .NET language?
F# is an ML-family language, this syntax has been standard for more than 40 years. I'm not saying that it's a good reason, but it's that way for the same reason that C# has curly braces and semicolons. EDIT: also, mathematical notation is used for some other types than tuples: using an arrow to represent a function is standard mathematical notation. In fact, Haskell has an "Arrow" type that represents a generalization of functions.
Let's just think about some of those: `append` takes two ordered collections and makes a new ordered collection so it is not applicable to many collection types including `Set`, `Map`, `Heap` and `Dictionary`. On lists and arrays, `append` has different time complexities and both are quite rare in the wild. `average` and `averageBy` take one enumerable sequence and returns a single value (not a collection). So the built-in `Seq.average` function already does exactly what you want. `choose` filters an enumerable sequence. Useful in the form of `Seq.choose` but `List.choose` and `Array.choose` are rarely seen in the wild. Same for `collect`. Now, let's say we did classify collections according to characteristics like ordered, associative and so on. We'd end up with a very complicated web of relationships. .NET is not capable of expressing such a web so whatever your solution it will not support interop with languages like C# (which is a primary goal of F#). The result would be much more complicated for developers and it is not clear how tools like Intellisense would handle this. And the practical benefits are very small: you rarely have to switch all your `Array` functions to `List` and vice-versa because mutable contiguous arrays and singly-linked immutable lists have little in common so they are rarely used interchangeably. Ultimately, you can always pick some random obscure feature like higher kinds and argue why they should be there. That is how academic languages are created but it does not result in pragmatic trade-offs. 
I believe covariance/contravariance is only supported for delegates and interfaces (as a whole).
You hitting a problem here because the '/' operator is not generic, so the function cannot be either. An easy work around is to mark the divideByTen function as 'inline' (let inline divideByTen ten n = n /ten). At that point type inference will be carried at in each place it's used independently and the relevant '/' picked for that context. let inline divideByTen ten n = n / ten let ints = divideByTen 10 let longs = divideByTen 10L Compiles correctly, for example.
You're either mistaken about, or simplifying a lot, what actually happens when you add `inline` here. Type inference is not really deferred to `ints` and `longs`; rather, `divideByTen` is inferred to have a generic type with a [member constraint](http://msdn.microsoft.com/en-us/library/dd233203.aspx): val inline divideByTen : ^a -&gt; ^b -&gt; ^c when (^b or ^a) : (static member ( / ) : ^b * ^a -&gt; ^c) Member constraints are interesting beasts, but it is generally not advised to use them for anything else than this.
This is strictly true, and I've also played with explicit member constraints before to make impromptu "interfaces" over core or third party objects - call it static duck typing :). Having said that, I've generally found the explanation I gave above helpful for people understanding the effect that inline has on the type inference algorithm; I should also have mentioned that it was a simplification of what is actually happening under the hood. I should also have pointed out that 'inline' does really inline code, which has effects on both performance and things like debugging (Visual Studio will never hit a break point in an inline function, for example). 
Very interesting. I wasn't aware of "inline". It essentially turns the function into a macro, yes?
Not really a macro in the LISP sense of the word. There's a bit more on it here: http://msdn.microsoft.com/en-us/library/dd548047.aspx
How does SML.NET have functors then?
Im an organizer at this meetup and we are thinking of broadcasting it in a google hangout. We'll post more details when it gets closer
what are those tradeoffs in your opinion? i've been learning haskell, but am considering jumping ship over to F# mainly due to haskell being unusable for modern graphical user interfaces.
F# isn't nearly as neat for extremely abstract computation. It doesn't have typeclasses, higher-kinded types or GADTs, meaning that some solutions that are natural in Haskell will be downright unavailable in F#. Also, since F# has the escape hatch of unlabeled IO and state mutation, the types don't always tell the entire story. On the other hand, it classes and interfaces. If you're like me you won't use classes much, but interfaces are really neat to use with tagged unions and records. The big advantage of F# is its tight integration with the .NET framework, meaning you get access to a bazillion really, really good libraries. The interfaces are mostly written in imperative style, but it's not usually a problem. You can use Rx to unit test time-dependent functions, or to implement your own reactive programming monad; you can use the Charts library for easy and beautiful reporting; you can use WPF, XAML and all the rest of the microsoft UI world as a first class citizen. Conceptually, F# sits about halfway between C# and Haskell, although it does have a few advanced features that I haven't seen much elsewhere (Type Providers are a big one!) I'd recommend F# for product development, especially consumer-facing or "enterprise" products, while I'd recommend Haskell for research applications or purely server-side applications that mostly interact with the HDD and network. E: also, the trade-offs I was originally thinking of show themselves during prototyping. In F# you can randomly decide to make an IO call (printf, etc.) during initial development, it really helps with debugging. Also, the debugger for F# benefits from strictness and the limits placed on abstraction by the absence of higher-kinded types.
There's an official MS add-in for F# for VS Express - see [here](http://blogs.msdn.com/b/fsharpteam/archive/2012/09/12/announcing-the-release-of-f-tools-for-visual-studio-express-2012-for-web.aspx). This will give you the full compiler and editing capabilities for F# of the full Visual Studio.
thank you for the response, but is that not exactly the first option i described? it is, as i had already performed the installation, but it isn't clear without getting into it more if i'm going to run into problems as that development environment is clearly meant for web applications. although, your comment seems to imply that everything should be okay. so do you think this is the best way forward? am i going to constantly be running into problems developing applications with XAML and F#? if the answers to these questions are positive, then why doesn't microsoft just release the F# tools for the desktop version of visual studio express?
Another option would be to use Xamarin Studio which has full support for F#. http://docs.xamarin.com/guides/cross-platform/fsharp/fsharp_support_overview I've used Xamarin Studio on occasion and I've been happy with it.
thanks for the link. i'll be sure to read through this and all the linked articles as well.
thanks for that, as i hadn't considered the xamarin stuff. but is their stuff based upon mono, which doesn't support WPF? i couldn't tell from briefly looking around on their site, but i'll look into this more.
Ah yeah it doesn't support wpf. In that case if wpf is a requirement then you can use visual studio 2012 express for desktop and install the f# tools. http://www.microsoft.com/visualstudio/eng/products/visual-studio-express-for-windows-desktop Edit: It appears that F# support isn't available for VS2012 Express for desktop. 
It's possible to download just the VS Shell for free and install the F# tools on top of that.
Is this a repost? I am pretty sure the string join challenge was at least a month ago.
Eric Lippert's original post was [Apr 2009](http://blogs.msdn.com/b/ericlippert/archive/2009/04/15/comma-quibbling.aspx). 
I like it!
OmniBlade Vlog #11 - Showing Off Progress on the Game Editor - https://www.youtube.com/watch?v=I6uQeGfJhgw
OmniBlade Vlog #12 - OmniBlade's (Hopefully) Innovative Funding Model - Developing a game in a 'Post-IP' World - https://www.youtube.com/watch?v=z3AqFD8BGKw [link fixed]
Author here. I am primarily a C# developer but have been using F# for the last 18 months or so and wanted to try and create something that would be both useful in my day job and a good learning experience. Any feedback welcome :) Edit: spelling.
&gt; I am primarily a C# developer but have been using F# for a last 18 months or so... How are you finding F#? 
Loving it. In fact, the only thing I can think of which regularly trips me up or irritates me is that interfaces are always implemented explicitly and the hoops that occasionally means you have to jump through.
Always torn between "I can always do it imperatively if the functional version doesn't work" and the reality of what imperative code looks like in F#.
The latter occured lately to me when I was rewriting some C# code into F#. The result (with almost 1to1 transition) was huge wall of text - you can imagine, after all, F# reduces the noise. On top of that, F# editor in VS doesn't do as nice highlighting thus, I admit longer names in F# don't contribute to clarity at all...
The syntax highlighting in VS is poor and it can mean that longer names result in a hard-to-read wall of text. I find liberal use of the newlines in combination with the pipe forward/backward and composition functions can help with that a bit. Generally though I try and keep function names down to 3 words at max, asFunctionNamesLikeThisAreUnreadable.
&gt; In F# you can randomly decide to make an IO call (printf, etc.) during initial development, it really helps with debugging. Have you met my friend [Debug.Trace](http://hackage.haskell.org/package/base-4.6.0.1/docs/Debug-Trace.html)? &gt; Also, the debugger for F# benefits from strictness and the limits placed on abstraction by the absence of higher-kinded types. Very true. There has been a lot of work lately in the Haskell community to improve debugging and/or provide stack traces. Lazy evaluation makes the former chaotic and the latter an exercise in inventing a non-existent stack :(.
Thank you for the Trace hint, I'll definitely check it out! I've been doing a lot of Haskell this week, my assessment is that with equal tooling it would absolutely destroy F#, but that tooling isn't there yet.
&gt; Loving it. Great! &gt; In fact, the only thing I can think of which regularly trips me up or irritates me is that interfaces are always implemented explicitly and the hoops that occasionally means you have to jump through. Yeah, that's fair enough. 
&gt; Always torn between "I can always do it imperatively if the functional version doesn't work" and the reality of what imperative code looks like in F#. What do you not like about imperative code in F#? 
Depends on what imperative code you are talking about. * Lack of `++` is really annoying when doing a counted computation on a complex object. `complex.whatever++` vs `complex.whatever &lt;- complex.whatever + 1`. And I don't believe operator overloads support this either. * Lack of early return is painful if you aren't careful, sure the built in functions usually work, but having to redo your operation to avoid a `return` in a `while` can be painful. Computation expressions can pull it off. * `mutable` wastes a lot of screen space if you aren't careful. Not that I dislike `readonly` as the default. It is similar to how I hate writing functional logic in C# due to the verboseness of getting all of the types defined. It isn't so much that it doesn't get the job done, it just makes me want to be on the other side of the wall. EDIT: Not sure if I communicated it well enough, but I agree with OP on the overall language, it is fantastic. I just find that if I fall off the functional side of things I end up wishing I was just writing C#.
Warning about PDF would be nice
I've been playing with this library recently and, although I'm not an R user, this looks really useful! :-)
There's a built in Linq to SQL type provider as well as an Entity Framework type provider, so there are two already. In addition, you could use the Mongo C# driver albeit with some caveats (there's an F# driver coming out next year, though).
Will this work for postgresql?
I think you can use Entity Framework to work over postgre, but I've never done that before personally.
Have you tried Dapper?
While researching Dapper I found http://soma.codeplex.com/ which looks quite interesting.
&gt; I have had problems with it for a long time because for me, coming from haskell background the "run until blocked" semantics j fyi: the repo moved to: https://github.com/tpetricek/fsharp/commits/research 
I'd be absolutely stoked to work for IntelliFactory, WebSharper is absolutely amazing, and its code base is really sweet. What are the specifics on getting a visa to Hungary from Canada or the US?
&gt; A medium-energy group of nondescript age, blurred ethnicity, and indeterminant gender
Note: I am in no way saying there is anything wrong with the company above they seem like a good bunch of people! Call me cynical but whenever I see that in an ad, I immediately think "We like to work overtime." I'm always hesitant about companies that talk about how EXCITING everything is. A decade of development in and I'm much happier to have an interesting job that has as little excitement as possible. 
Github repo: https://github.com/fsharp/FSharpCommunityTemplates/
Not a moment too soon. Was just looking for something like these yesterday.
Isn't there a San Francisco office as well?
Exactly how I feel.
Unfortunately, with no anonymous types and painful dynamic types I haven't found a way to actually use Dapper. Well, dynamic types could be skipped, but anonymous types are used to pass actual parameters. How would you do something like: var result = connection.Query&lt;dynamic&gt;("SELECT [Make], [Model] FROM Cars WHERE [Year] &gt; @Year", new { Year = 2002 }); Honestly, I have no idea... As far as I know, e.g. NHibernate should work, and there's the EF-based type provider. I wish there was more variety though... :)
I have a deadline looming, so I haven't actually tried it, but you should try using FSharp.Dynamic for dynamic type support and something like type private QueryArg = { Year: int } connection.Query&lt;ResultType&gt;( "SELECT...", {Year = 2002} ) for calling dapper 
Very nice revamp of their website replete with examples, even of Piglets which from my perspective is an abstraction at least as excellent as Formlets are. Working on my own extension + fsharp friendly wrapper for Kendo Web here: https://github.com/davidgrenier/Kendo And here: http://www.nuget.org/packages/WebSharper.KendoWeb Extension is used by my employer but I maintain it on my own time. WebSharper's simply the best web development abstraction out there for SPA and regular websites - I just couldn't do without transparent RPC calls.
When you have a UK opportunity, I'd be interested :) 
[Expert F# 3.0](http://www.amazon.com/Expert-F-3-0-Don-Syme/dp/1430246502), by Don Syme, Adam Granicz and Antonio Cisternino. It covers much more than Programming F# 3.0.
It's not out yet, but I've gotten to read some of it. I would recomend: http://www.nostarch.com/f_sharp
Learning F# is very easy if you already have a handle on functional programming. To that end I got a lot out of [Cousineau &amp; Mauny](http://www.amazon.com/The-Functional-Approach-Programming-Cousineau/dp/0521576814) This isn't really for the faint-hearted and I found it best to work using the caml light distro which exactly matches to language used in the text. But that requires being cool about using a very bare repl (I used rlwrap on osx to make that a little more palatable. I have no idea how set any of that up on windows.
This is a compiler bug that caught me out, posted it in case it might help others.
This is now available through No Starch Press' new Early Access program. Same link as above.
Just bought on a whim. Really hoping it's good. No Starch have published some pretty good books (Land of Lisp, Learn You A Haskell), it'd be nice for F# to have an equivalent. 
I liked the sample chapter about collections. However I'm still not sure where this book fits exactly. Could someone please tell me how this book compares to the other well known F# books like "Programming F# 3.0", "Expert F# 3.0" and "Functional Programming Using F#"?
Thank you, that sounds good. I'll buy it when it hits the book dealers here in Germany. $23.95 shipping fee is a bit much...
http://fsharp.github.io/FSharp.Compiler.Service/interactive.html Holy shit, I guess that means I can easily use F# as a plugin language?
Yes. This is work-in-progress BTW.
Hopefully this will be a significant step toward obtaining F# macros as well as refactoring support!
I really enjoyed and was the book that actually got me into F# Jon Harrop's [F# for Scientists](http://www.amazon.ca/F-Scientists-Jon-Harrop/dp/0470242116)
That is awesome! I was already using it for C# fiddles.
I'm a fan of http://suave.io/ - I've not used it for any large projects yet, but I've built several small, single role, services with it and it's been excellent.
Looks great. I'm looking for something super lightweight e.g. web.py, and this looks like it fits the bill. 
i guess mvc isnt a microframework but there is an F# mvc 5 template i was looking at in VS
MVC's a bit too heavy for me.
Great, thanks. I'd like to run it in process, looks like Nancy can do that.
I like the comment about the only inference in C# being a NOP. Although to be fair to C#, you do get some quite powerful (and abusable implicit operators due to it).
This is pretty cool, though any syntax/type issue results in just a "failure to parse" exception, which is not helpful when debugging syntax or type errors. If that could be fixed, this would be absolutely my preferred tool for F# development. (Disclaimer: I funded LightTable on Kickstarter way back when, so I'm a little biased :P)
Well, it depends. Are you trying to get language proficiency or .NET class library proficiency? If you're worried about working in a .NET shop later, it would make sense to learn C#. If you feel like you'll be working on projects where you define the bounds, F# would be just as good. Also, if you have Java or C++ experience you'll find it incredibly easy to transition to C#.
It would probably be easier and more comprehensive to learn a little C# first. C# was designed so much in tandem with .NET, the whole ecosystem will be easier to learn with a C# background. It will also make F#'s OO and NET-specific side much more understandable.
If you already know a bit of VB.Net I don't think there's much advantage in learning C# first. VB.Net has the same capabilities as C# including OO. The only significant difference between VB.Net and C# is syntax, i.e. in C# each statement must end with a semi-colon, and instead of defining statement blocks like if as if/endif you wrap them in curly braces. F# is a great fit for analytic components and is used heavily in science/data applications. Also F# specific features like Type Providers make light work of data analysis tasks.
Learn both! I mix C# and F# in my .NET solutions. I use F# when I need clear, concise and correct code. I use C# when I am forced to.
I learned them concurrently. It gave me a broader understanding of both languages that most of the other seasoned C# devs I worked with didn't have. 
Indeed. It's much easier to verify the correctness of F# code, especially with the REPL. It's surprising how often my F# code works the first time it runs.
Ideally, I'd like to shift over to a .NET shop down the road. So, C# sounds like it would be best. I think I am going to start learning with C# and then start tackling F# too. Thanks for the info.
I think that I will start with C# first, but then get into F#. I watched a few F# videos and was shocked at how clean the code is. Any recommendations on books for learning C# &amp; .NET?
I will, but down the road. I think I am going to start with C# in order to understand the benefits of F# better. Also, it will give me time to get used to the .NET environment.
I watched this YouTube Microsoft presentation on F#. I thought it was really interesting that the three main areas of F# are Let, |&gt;, and Fun. It seems like it can do quite a bit with just those three features.
Did you already know the .NET framework? My VB.net class didn't really harness the .NET environment much. I am afraid that trying to learn C#, F# and the .NET framework will be a "large pill to swallow." Any tips on how you did both at the same time?
OK, Jeffrey Richter's "CLR via C#" is a good place to start for a thorough grounding in .NET and will not be wasted when you make the switch to F#.
Absolutely. I read this after becoming familiar with C# and having been stuck using Visual Basic 6 for years. This is the book that takes you to the next level. There are plenty of good reasons to use both languages and this book will help you to understand the platform on which these languages run. I generally find that it is a good idea to look at lots of different languages and explore their concepts and bring what you like and can use into the language you are using. Plenty of functional programming concepts can be used in C#, especially with things like LINQ.
If your dealing a lot with data and big numbers f# excels. However, there is no reason another programming language with any database management wouldn't work. If you wanted to impress your teacher and make things a little easier F# seams like a great choice. You do have to learn a new language, although it seems you have 2 years, which is more than enough time to learn F#.
F# can really help you here, not just with the business logic but also with the database access. Take a look at type providers!
From the way you've described the problem, it looks to me like you can do that in C#. It doesn't really play that much in to F#'s strengths, unless there are some number crunching or big data handling in there somewhere that you haven't described. Keeping it all in C# will simplify your code, make it more homogenous and easier to understand. You said that the UI is in C#, so the code there will be definitely be Object Oriented, and if you write the logic part in F#, that part will be in Functional style. While developing and (most importantly) debugging this application, you'll be constantly switching back and forth between an OO and Functional mindset. And also, the coding conventions between C# and F# are different. So when you start calling F# libraries in C# (or vice versa) the source code becomes somewhat non-uniform. That being said, I'd still do the logic part in F#. I've written 2 applications which are mix of C# (UI part) and F# (logic part). The "mismatch" between OO and Functional approaches made the development harder than it had to be. But from a maintenance and perspective, the F# code had less bugs and was easier to fix largely because it had little to no mutable state.
Glad to hear you are considering F#. Coming from a C# background, I found [Programming F#](http://www.amazon.com/Programming-F-3-0-Chris-Smith/dp/1449320295/) to be a helpful book for learning the language. [F# for Fun and Profit](http://fsharpforfunandprofit.com/) is a very nice web resource. Also, the F# communities on Twitter (#fsharp tag) are very helpful and enthusiastic. Good luck in your journey!
And don't forget &gt;&gt; / &lt;&lt; if you're trying to be points-free :)
Nice post! One thing about your site, though: your font (and everything) is BIG! Maybe reduce? I changed my zoom to 75% to read things. Maybe it's just me.
I'm old! ;-) But, yeah, one day in my copious spare time I'm going to have to work on the style of the site...
I'm a little tired of seeing companies persist in insisting on degrees and paper, as if to be the best, you must have had the money and opportunity to do university. I've met with coders of ten years my experience, with paper and all sorts who I CAN keep up with just fine. Despite lacking paper or even many years. (I've met plenty more, with and without degrees, that of course - yet- I cannot). My point being, can some of these clever, visionary companies open the doors to ANYONE who has the capacity to prove their ability rather than just those that have the 5 figure budget and several years to spare going to university. If you want coders who can handle algorithms, thinking at varying levels of abstraction, shift to different languages as required and adapt to changing circumstances, offer a better job ad filter than mere paper. Written in some frustration at seeing yet another pointless tickbox barrier job ad. A shame for a company that I would one day have liked to try for.
I'll read the PDF tomorrow at $work, but I don't think I can run any examples in Linux, righto?
Unfortunately, I've not yet set up the project to run in Mono. While Nu is explicitly designed to be multi-platform, I haven't yet had time to deploy to anything other than .NET on Windows. So the answer is, yes if you have a few hours to figure out how to build and run Nu on Linux / Mono :)
Use Seq.fold. Your state can be a map or Dictionary (map is more functional style but Dictionary is faster if you don't care about persistance). Each time your function gets called you check the map and return it unchanged if the name is already there, or return the map with the new entry if the name isn't already there. The actual code will only be a line or two depending on your tolerance for wide lines.
if all you want is the name of the university, use something like `Universities |&gt; List.fold (fun set elem -&gt; Set.add elem set) Set.empty`. If you want the entire row with the university name, use a map instead of a set, and as a key use the name of the university; as a value, use the entire tuple. This works because sets and maps don't allow duplicate keys. Otherwise, use a for loop and a dictionary.
You can pipe your collection into: |&gt; Seq.distinctBy (fun (x, _, _) -&gt; x)
Be sure not to skip http://fsharpforfunandprofit.com, I wish I had access to that site when I started. I even learned a lot after 4 years+ experience with F#. F# excels at modeling problems (which you will learn a lot about in fsharp for fun and profit) which seems a great fit for your domain. As for the UI, if it was me, I'd do it in F# as well. There are a few examples out there of UI built directly in F# with either WPF or Web (see WebSharper/FunScript) and I remember Don Syme gave a few lectures where he showed how you can build UI in an ad hoc fashion using WinForms. I have my own projects I started to do Graphics programming using WPF and F# which shows some examples where you do not need to learn XAML to build UI: https://github.com/davidgrenier/cgpp.net There's also this WPF F# library that does the same using Formlets (quite abstract) https://github.com/mrange/wellformed
thanks!
This is super cool
I'm not sure if it's "just" a news aggregator or not, but I often come across F# stuff on [FPish](http://fpish.net/).
What exactly does this mean?
Would it be possible to combine the last two into a single "if and only if" property?
That's a neat idea, I'll investigate :) I suspect you could, by simply stating (cond1 &amp;&amp; cond2 &amp;&amp; cond3) = Valid(password)
The piece I want to try out at that point is what happens if I feed it a collection of rules that cannot be collectively satisfied...
Yes please! I am new to F# and do not fully understand the negative consequences that a change like this might have, but I would love to have macros if possible. Perhaps Nemerle would be a good place to look for inspiration. It has good support for functional code, is based on the CLR and apparently has very powerful macros.
Thanks for sharing this. I tried to do Android development in its more native Java and it was a tough pill to swallow after writing my last big project using functional programming (Haskell). I've been looking for a way to get into mobile dev and stay mostly functional. F# might be ready for that now.
Kotlin isn't functional by any useful definition of the term. No union types o_o
I was very surprised to read that the F# support is up to par. I'll definitely be checking out Xamarin Studio soon!
Being serious now though. For those that want to stay in Java ecosystem, Scala and Clojure currently don't fit that well into Android. Scala is too big, requires lots of ProGuard magic and produces code that is too heavy for Dalvik to handle properly. Clojure suffers from long startup times, until the var bloat is taken care during this year Summer of Code projects. Xtend is not used anywhere besides Eclipse projects, it seems. Given that Kotlin is a light Scala and belongs to the company producing the new generation of Android tools, it seems a good bet. And sum types will be supported, after all the language is still at 0.7. Having said this, F# is great.
Don't TypeProviders already provide a mechanism for meta-programming at compile time? Surely a "MacroTypeProvider" would suffice?
No, it would not be comparable - type providers cannot enhance F#'s syntax, among many many other things that macros are needed to enable. Visit the reddit'd link, there is further discussion on that there.
Discussion at the site.
this is amazing!!
So legit, thanks for the big ups
Why the #hashtags
brain fart :) social media overload?
This slideshow, history polluting bullshit has to be the most annoying way to present content on the web.
http://www.manning.com/petricek/ is a great introduction to functional programming. To be honest though, I learnt Haskell in order to learn FP, as at the time the F# documentation had a few references to "just like in Haskell".
Thanks for the nice words about my book! Regarding Haskell - I only learnt Haskell properly myself *after* writing the F# book, so I'm pretty sure that one can learn F# perfectly fine without learning Haskell :-). The core functional ideas are the same (which is also the case for ML and OCaml, which are closer to F#). Learning more advanced Haskell is quite fun, but maybe not necessarily all that useful for F# programming.
&gt; I was told that F# was the best FP language to learn. It's good, but it supports mutable state, which makes learning true functional style hard for me. I've done C# and python for 12 years, C/C++ for 25, and even if I learned lisp in mid 1980's the amount of imperative programming has made a permanent impact to my style. I use F# as a better C#. When functional style is natural, I write functional code, but as soon as the sligtest need of state appears, I find myself declaring a mutable, and not thingking how to solve this functionally. Now I'm coding for fun, and decided to learn Haskell or J just to rewire my thinking. Being an old APL fan I chose J. 
I'm looking forward to the next one :) I wouldn't say I know Haskell properly, but the cold hard purity or nothing approach taught me to think recursively, and made F# a breeze to pick up (I'm a C# developer by day). I'm curious, did you have a background in OCaml/SML before coming to F#, or was F# your baptism of fire?
I have never really tried TDD and I'm quite skeptical about it so please enlighten me if I'm wrong, but you are not testing anything interesting in the example and if we actually tested the code we would have no choice but to implement it twice and make it tautological or re implement the libraries we are using. Let's take a look: [&lt;Property&gt;] let ``when all rules pass, password should be valid`` (password:string) = let rule1 = UpperCharsRule () let rule2 = NumbersRule () let rule3 = LengthRule () let validator = PowerValidator([rule1;rule2;rule3]) (rule1.IsSatisfied(password) &amp;&amp; rule2.IsSatisfied(password) &amp;&amp; rule3.IsSatisfied(password)) ==&gt; validator.IsValid(password) What this code is really testing is the All() function in the implementation here public bool IsValid(string password) { return this.rules.All(rule =&gt; rule.IsSatisfied(password)); } This doesn't test if UpperCharsRule, NumbersRule or LengthRule is correct it only test the All() function for 3 values because that is all we did we wrote the same thing that is in the lambda expression 3 times. So let's go on and test the individual rules. Lets start with UpperCharsRule [&lt;Property&gt;] let ``must have one uppercase letter`` (password:string) = let rule = UpperCharsRule () rule.IsSatisfied(password) ==&gt; password.Count(Char.IsUpper) &gt;= 1 But wait that is the same code that we used for the implementation and my test is now tautological, so all I have gained is that if If I change the implementation and forget to change the test I get an Error. So are we "making our software more robust" by simply writing everything twice? What am I supposed to do instead? implement it in a different way in the test? Use a for loop instead of the Count function? Reimplemented Char.IsUpper? Or is TDD really supposed to be tautological?
Also check out this website, it is a great resource for learning how to code idiomatically in F#: http://fsharpforfunandprofit.com/
I really enjoyed it as well, and still go back to it - easily my most thumbed-through F# book. The samples are excellent.
I had to Google "idiomatically", thanks for the link. Do you know any sites that goes into the FP theory and gives exercises in F# for changes ones mindset?
http://en.wikibooks.org/wiki/F_Sharp_Programming
You can pick up Petricek's *F# Deep Dives* in early access :) it's an interesting read if you're not an F# expert.
The site I linked is great for exactly that!
[Functional Programming Using F#](http://www.amazon.com/Functional-Programming-Using-Michael-Hansen/dp/1107684064). The book focuses on functional programming, has a nice set of examples and nontrivial programming exercises. Also, if you're into MOOCs you could try [this course that teaches ML](https://www.coursera.org/course/proglang). I struggled really hard with the course, but I learned a lot, and after ML it was really easy to start with F#.
I started out with Expert F# by D Syme et al and then also read F# for Scientists by John Harrop. The first is a good overview of the language and its features and the second opened my eyes as to what else could be done with FP languages.
I have read some criticism of OCaml, especially regarding the lack of documentation on the language. When it comes to learning a new language, available exercises with full og close to full solutions is really essential to me. I have read plenty of books on programming over the years, but I never really learned programming because most books don't have exercises, and when they do, the rarely ever give you full solutions. Are there any of the books mentioned that you know of having full exercises with solutions, or is F# just too small a language for that to happen?
F# for Scientists by John Harrop looks like a book I could would buy. I still haven't got any idea what I could use F# for, I use R at work for data analysis and I am learning Python to expand my horizon and do some practical programming projects in my spare time. I would like to learn F# to get deeper into the FP paradigm, and improve my coding skills in R, but must admit I have no ideas on what I could actually use the language for on a more regular basis.
This is one of those reason why I really want to learn FP, you talk about mutable data as if it was something the devil created. But I have no idea why. The same with function side effects, I googled what it was and I think I understand the basics, but I fail to see why it must be avoided at all costs.
* Mutable state is not necessarily a bad thing if it is localized and used parcimoniously. The reason it is undesirable at the macro (e.g. program architecture) level is because it increases *accidental complexity* (ref. *Out of the Turing Tarpit*, *Simple Made Easy*). * When you look at a function in functional programming, the type should tell you the scope of its action. It's a means of documentation too; types never lie or become outdated, unless side-effects are involved. * Persistent data structures modified via message queues are an incredibly useful tool for concurrent program development. Anything in Chris Okasaki's *Purely Functional Data Structures* (which I heavily recommend reading) can be made thread-safe; meanwhile, thread-safe mutable queues or maps (to only name those) are complex and difficult to implement. * Information hiding should be limited as much as possible; this makes unit tests a lot easier, for example.
&gt; Chris Okasaki's Purely Functional Data Structures Thank you for the explanation. It looks like Okasaki's "Purely functional data structures" is available for free. It has been added to my reading list. Is it necessary to learn about data structures in an imperative language first, or would you say it greathy aids in the learning of data structures in FP languages? I am still busy learning Python for my master thesis, after finishing the books on the basics and scientific computing in Python, I was strongly considering reading this book on [Data structures in Python](http://interactivepython.org/courselib/static/pythonds/index.html) The book seems like a good introduction to data structures and some basic Discrete mathematics. Generally for learning mathematics I really do prefer Schaum's outlines, there really is nothing better than solving tons of problems when you are trying to learn a new field, and Schaum's outlines have full solutions helping me tremendously in staying motivated.
Reading about Data Structures in Python will help you understand purely functional data structures; the converse is also true. Also, Okasaki's book has interesting problem sets :) If you want an interesting problem, look into the book's implementation of red-black trees, and try to implement the `balance` function in F# using [OR patterns](http://msdn.microsoft.com/en-us/library/dd547125.aspx).
If you're looking for something with solutions you could try the [F# Koans](https://github.com/ChrisMarinos/FSharpKoans), but if you're looking for books with solutions you're out of luck. I have have scores of programming books and almost none of them have solutions along with the exercises if they even have the exercises at all. [Functional Programming Using F#](http://en.bookfi.org/book/2234242) and [How to Think Like a Functional Programmer](http://greenteapress.com/thinkocaml/thinkocaml.pdf) both have a lot of good exercises and shouldn't be overlooked due to a lack of exercise solutions. Syntactically OCaml is a superset of F#, so you could go through all of [How to Think Like a Functional Programmer](http://greenteapress.com/thinkocaml/thinkocaml.pdf) writing your code in F# and it would look nearly identical. One of my friends is doing that and they've gotten halfway through the book without issue.
Could you explain what this thing does exactly?
Try it online at http://rise4fun.com/FStar/tutorial/guide but from what I understand it allows dependent types which to simplify means you can add rules to when types apply. &gt;type pos = x:int{x&gt;0} &gt;let y:pos = -1 would fail type checking.
Thanks. Interesting. So it's a new ML language that supports some sort of correctness check (like design-by-contract).
From what I gather it's influenced by f# f7 and a few other languages but essentially yeah.
F* is an experimental/research fork of F#. It's type system supports *[refinement types](https://en.wikipedia.org/wiki/Refinement_%28computing%29#Refinement_types)*, which allow you to be much more specific about the properties that need to hold for a value -- to the extent that the F* compiler can [mathematically guarantee the correctness of your code](https://en.wikipedia.org/wiki/Formal_verification). If you've ever used Eiffel or C#'s [Code Contracts](https://research.microsoft.com/en-us/projects/contracts/), you can think of F* as being along the same lines, albeit more powerful and flexible.
using F# is not a problem for me at work. the problem is that C# is *good enough* for anything i need to do. i tried introducing F# into the code base a few weeks ago, and everyone was excited, but i couldn't really see the point. the only thing F# offered was an awesomely concise syntax.
There is no date but I assume it is a couple years old, since it mentions VS 2010 and .NET 4.0, and does not discuss any F# 3.0 features.
Oldie but goodie
I feel that this feature should be built in the compiler. Maybe something like let book2 = { aBook with Editor.Car.Mileage = 1000 }
Cool! I gave 2 votes.
F# is in that twilight zone. Not too different from C# to be attractive to *most*, current C# shops. Too much .NET baggage for non-NET shops to adopt it - they might as well bite the bullet on scala/haskell/ocaml. 
In a similar Hacker News thread not too long ago, there were a handful of companies that were all-in with F#: https://news.ycombinator.com/item?id=7613706 You might also have some luck with OCaml, which seems to have a fair share of opportunity available. I know it's recommending another language, but they are quite similar. If you are well versed in F#, you probably could pick up OCaml very quickly.
*EDIT: I just realized this post addresses an argument that /u/olts did not make. Apologies olts! However, I'm leaving it up as it does do a good job demolishing the arguments that I thought the poor chap was making :)* Not to be argumentative, but why would any C# shop choose those languages over F#? - Scala is a language design fustercluck due to its wrongheaded and failed 'fusion' of FP/OOP. I definitely would not move all the way from .NET to the JVM just to live in that mess. - Haskell is impractical for ordinary development due to its dogmatic insistence on laziness and its practical requirement for monads everywhere. How many programmers who praise it have ever tried debugging / optimizing a non-trivial Haskell program, or have dealt with the perplexity caused by a stack of monads? - OCaml doesn't run on either of the mainstream platforms (neither JVM nor .NET), doesn't support parallelism, and has tooling even less desirable than Haskell. Due to portability and sane language design, I would even say Clojure is more practical than all three of the languages you mention. But it doesn't even have static types, thus enabling entire classes of bugs to sprout up all over your programs! Argh!!! At least with F# you get a very well designed functional language based on the mainstream and highly portable .NET platform (which, unlike the JVM, isn't crippled by type erasure). And it works in Visual Studio, which really does matter to .NET programmers. For these reasons, among many others, F# seems to me to be the world's most practical functional programming language. And it has a damn solid functional language design to boot. Why then does its adoption seem so lackadaisical? Sorry if I'm coming off as argumentative or pedantic, but it's all just so frustrating!
Actually OCaml can compile to a few different platforms due to the cross compilers available. Ive only really tried out arm for iOS to be honest though.
Sorry for going OT but what's with the bashing of Scala? Why do you hate it so much? I'm new to FP and just looking around the park: F#, Haskell, Scala... but I've only written little stuff for now, not fully fledged applications.
No problem; I've been looking for a forum to rant about this subject for a while :) I just think Scala is so badly designed that it borders on unusable for programmers like myself. I'll try to go into more detail, but beware, I'm in rant mode :) Scala's attempt to 'fuse' FP and OOP is one of the many things that hurt its design. It was wrong-headed to try to fuse two *entirely orthogonal language concepts*, and the results were predictably disastrous. The major practical point of moving to a functional language is to get away from OO thinking. Unfortunately, Scala's fusion-ness makes that nearly impossible. You can't do FP without OO because the syntax (and even semantics) for each is overloaded for the other! Having less keywords in a language can be nicer, but overriding their meaning (and worse, semantics) to achieve that is **many** times worse. Objects are great when you actually need them (EG - for components) but object-*orientation* is just not good in most situations. Coupling program behavior with representation generally inflicts much incidental complexity in programs (http://fsharpforfunandprofit.com/posts/cycles-and-modularity-in-the-wild/). See also Scala's atrocious collections library in detail. Scala constantly violates the principle of least surprise nearly everywhere in its usage, whether you're an OOP or an FP person. From which perspective was X language feature designed? One or the other, sure, but you're typically left guessing, then referring to the spec. There is almost no consistency in or predictable model of thinking for how Scala is defined. People still can't pinpoint what the basic programming idioms for Scala should be! This partly goes back to the fusion, but also can be blamed on Scala's general incoherence of design. Scala is hugely complex with surprisingly little payoff in expressiveness. This is especially true for the type system. We get the complexity of type inference multiplied by that of implicits / sub-typing / variants / etc. The complexity of the type system is combinatorial! At the same time end up with weaker type inference than F#. Scala's design seems to have been generally incoherent - throwing together features that either failed to add to or actually detracted from its whole. Did we really need co/contravariants to make the type system even more incomprehensible than it already was? Maybe, due to its mutant fusion of OOP/FP... But that's where coherency in design decisions must come in! Scala essentially combines the complexity of C++ with the speed of Java. It combines poor-support for generic types with a very ambitious type system. It really is the worst of many worlds. To avoid going on too long, Scala is just a failed experiment with a long enough feature list to attract naive programmers and functional newbies. While we should perhaps applaud the gumption it took to take such an experiment as far as Scala has been taken, now that the failure is clear in hindsight, we need to call it what it is.
Now that... sounds awesome!
This thread has been linked to from elsewhere on reddit. - [/r/programmingcirclejerk] [Where are the F# jobs?](http://np.reddit.com/r/programmingcirclejerk/comments/24m5hz/where_are_the_f_jobs/) *^I ^am ^a ^bot. ^Comments? ^Complaints? [^Message ^me ^here.](http://www.reddit.com/message/compose?to=%2Fr%2Fmeta_bot_mailbag) ^I ^don't ^read ^PMs!* 
One problem that's frustrated me for a while is that F# doesn't get quite the support that C# and VB do. You can't use it to build an MVC website, without bringing in some C#. You can't use it in SSIS packages, although it seems like a functional language would be perfect in that application. I bet there are other examples. The message I think people get is: "F# is for hard stuff. You can't really use it for easy stuff." And a lot of our work isn't that hard, and if we have to use another language for the easy stuff anyway, might as well use it for everything. You have to balance the cost of using two languages against the cost of a minority of the work taking more lines of code. The few companies that do lots of F# are companies really focused on hard stuff. If we could use F# everywhere we use C#, and Microsoft promoted it as simply a good language instead of just a good language for hard stuff, then we might see a different picture.
thanks. I think I still need to go deeper into FP to fully appreciate what you're saying. On this note, any advice?
I think they are playing safe, as the enterprise, their biggest customer, still suffers from FP phobia. When I write C#, I still have to think twice, because my cool FP code has a higher probability of being re-written into boring interactive OO code by other team members.
Haskell.
I am trying to pick up F# as someone coming from a unix background as a way to "diversify" my programming portfolio,so I *am* for seeing F# being a true *cross-platform* contender. Regarding Scala -- perhaps the most successful story on JVM for functional programming, backed by quite some marketing push. And marketing does help as opposed to microsoft's "Hey, our top nerds like F#, we are supporting it, but we really don't mean to scare the hoi-poloi away from C#" approach. Haskell is far out there to act as a hiring filter a la "the python paradox". OCaml is actually pretty fine these days, especially with opam etc.,. They are progressing steadily. Not much of hoopla, but not languishing either. 
You can use F# to build MVC sites, that's what I'm doing with it.
Can anyone interested in doing some F# work send me a direct message, please? 
&gt; Scala's attempt to 'fuse' FP and OOP is one of the many things that hurt its design. It was wrong-headed to try to fuse two entirely orthogonal language concepts, and the results were predictably disastrous. For better or worse, I think that's the exact reason for it's success. Note that "fusing two entirely orthogonal language concepts" has been done before - and resulted in arguably the worst OO-like language ever (C++). However that provided C programmers a path whereby they could get to some of the nice parts (say, STL collections) without having to learn a real OO language. Scala's similar. I use it because I work with a huge legacy pile of Java; and during the first afternoon I tried Scala, it was able to get me significant productivity gains over Java. Sure there's a vast learning curve beyond that -- if you wanted to you could study the type system for years, comparing System Fω type systems vs more limited type systems like Girard-Reynolds or Damas-Hindley-Milner systems and argue about each of their various flexibilities and limitations. But that matters little for people that just need to get real work done and want something that can help them right away. That's the part that's missing from F#, Haskell, etc that "ugly" languages like Scala and C++ got right.
&gt; On a different note, I would bet there are some .NET shops that would be willing to use F#, and could definitely use my expertise to train their current devs to use it... but how do you find them? This type of information won't typically be in the job description. This is probably not the answer you are looking for but a lot of times it comes down to knowing people. There are a lot of shops that want to use F# but either don't have the knowledge or the resources to get their employees that knowledge. But if they have someone that could slowly introduce it as part of their team, I know a lot of places that would go for that. Maybe try your local .NET user group and see if you can find some leads. The other option is freelancing. Unless you are working on an existing app, it's a lot easier to use a language of your choice when developing. And since F# is cross-platform, you don't ever run into issues with platform lock-in like you sometimes do with C#. 
Why can't you use F# for ASP.NET MVC? Are you talking about having to use C# in *.cs Razor files? If so, [there is FSRazor](https://github.com/dahlbyk/FSRazor).
That sounds pretty confused.
True, but it is community driven and not really officially supported in Visual Studio out of the box.
Is that a problem? A lot of decent libraries are community driven.
Yes, as it means lack of support from Visual Studio tooling. For example, one needs to manually hack the project files for Visual Studio to recognize a F#/MVC project as web project so that the corresponding tools are enabled. Wizards only generate C#/VB code so no luck with wizard support. On the desktop side, Blend and XAML designer only work directly with C#/VB code behind.
There are tools to let VS recognise f# mvc/webapi so no need to hack proj files. As for the wizards fair point, but personally I've never needed to use of them. Never built any f#/xaml projects so I can't really comment on that. But I find with F# I don't need to use wizard's to generate code as the language it self allows me to express generalised code.
It's sort of a chicken/egg problem right now. Even in the start-up world there are companies who would hire F# developers, but it's not clear if there are any. Secondly, the .NET platform is much maligned in Silicon Valley. You will literally be laughed at derisively (perhaps deservedly so) for building a company on C#/ASP.NET/Azure. Tachyus is the outlier, and have built almost all their tech on F# from the ground up. It certainly helps that their CTO (I believe) is a former MS employee and F# evangelist. For non-technical founders though, F# seems like a gamble. The perception is that the "talent" is interested in Ruby/Python/JS-based stacks. Given the speed at which even average devs can churn out Rails apps, it's hard to convince them otherwise. My advice to aspiring F# devs: The community really needs leaders like Tachyus (who went from 0 to release in something like 12 weeks, which is insane) who are willing to make F# jobs. If you want an F# job right now, make one for yourself -- and then tell *everyone* about your success! Otherwise, put F# on your resume and linkedin profile so employers can find you. Commit F# projects/tools/libraries to GitHub/BitBucket/Codeplex. Tweet/blog about them. Post to reddit/hacker news. Show the world what you're working on.
That is the main problem, how maligned .NET platform is. Even thought, I don't think many people know the ML/F# story. We need to get that story out there. Just think about this, most people that like dynamic languages don't like type systems. And in reality, they don't like the type systems that they know. That is something people need to know about. If they knew that there is a type system with more benefits than the Java type system. That is also requires less work. I think you would get a different reaction.
More evidence that type providers constitute an extremely crude mechanism for dependent typing. I LOVE type providers. &lt;3
We really need the Jetbrains guys to resharper F# :)
The difference is that Scala embraces OO with its advanced OO system. F# says "yeah, yeah, we've got OO for interop, but we're a functional language". You can say that all functional languages have their imperative parts...even Haskell
I was referring to http://paulgraham.com/pypar.html wherein Paul Graham says that (in 2004), developers who know Python are a positive filter when hiring developers. That mantle has now passed to PLs like Haskell/OCaml and even F#. 
I do C# and Scala consulting. I know F#. I can't think of anything F# has that Scala doesn't aside from reified generics (which is a mistake), however, there are a few features missing from F#/C# that make me groan every time I have to use the aforementioned languages. You seem to have a major problem with scala but haven't articulated a particular example showing how scala fails at melding OO and functional, where F# has succeeded. 
Perhaps you don't see the difference between having two features sit nicely side-by-side and explicitly fusing them together. F# does the former, Scala does the latter.
Cursorily, I'd presume you don't know F# as well as you think / say. The only major thing it is missing is macros - http://fslang.uservoice.com/forums/245727-f-language/suggestions/5674940-implement-syntactic-macros
Good advice, much of which I've personally tried to follow over the past couple of years. Tangentially, if a company can't spend 5 seconds on google search to find the many F# user groups all around the world, well... I don't know how anyone could help them.
implicit parameters, implicit conversions, higher kinded types. 
Trust me, if they're looking for F# devs, they'll find you. The problem is overcoming the anti-.NET bias. I know of almost no startups in the valley (other than Tachyus) who're on a .NET stack. I really think it's up to the F# community to change this perception by building things that force companies to give it their attention.
Only problem is that Scala is made worse overall by the inclusion of those features, as would F# be too. Only when you ignore all the hideous downsides of having those features in Scala do you think their absence is a problem. However, the lack of these in F# is generally considered a _feature_ by the community. It all goes back to Scala being incoherently designed - due to it being more concerned about the size of its feature list than the actual implications of its features and their interactions.
How are you going about it? I've googled and haven't really found much.
I guess I just don't have any sympathy for anyone with an anti-.NET bias. A tool is just a tool, and if it works well, it works well.
Why would F# be made worse by having higher kinded types? You keep repeating the same phrase over and over ("overcomplicated") but you seem to have trouble nailing down specific complaints about said features. If I didn't know better, I'd say you don't actually understand much about those features and are just parroting something you heard, but surely that can't be the case. 
Because it wouldn't cohere well with the underlying .net type system. At any rate, I'm done with your trolling. So bye.
&gt;Because it wouldn't cohere well with the underlying .net type system. In what way? 
I use two VS extensions: * [F# Web Item Templates](http://visualstudiogallery.msdn.microsoft.com/f1dae7fe-1ecc-4f1b-86b5-32a2970d012a) * [F# MVC 5/WebApi 2](http://visualstudiogallery.msdn.microsoft.com/39ae8dec-d11a-4ac9-974e-be0fdadec71b) To get the MVC/Web api projects templates and "Add Controllers" menu options. Right now there is a bug with F# and doing a publish to web from VS, it has been fixed and is in a daily build: http://blogs.msdn.com/b/fsharpteam/archive/2014/04/06/towards-web-project-support-in-the-visual-f-tools.aspx but not released. I got around this by having a C# Web project that only had a reference to the F# Web project and published it that way.
Sweet, thanks.
That's just incredibly defensive without any substance at all. Compared to F#, Scala feels like a Scheme in terms of features.
Sure, it was funny to watch how you were in denial. :-)
You may get more responses posting this on the F# mailing list than you will here: http://groups.google.com/group/fsharp-opensource. Or maybe even Twitter, if you have an account.
&gt; I know F#. I can't think of anything F# has that Scala doesn't aside from reified generics (which is a mistake) Last I looked: * Reified generics * Value types * Tail call elimination * Type inference * Exhaustiveness and redundancy checking on pattern matches * Usable IDE support * Stability * User-friendly collections library * User-friendly error messages * Performance Doubtless some things have changed since I looked but I found Scala quite unpleasant. The lack of real type inference was my biggest gripe by miles. It makes Scala feel more like C# than F# and fails to capture the productivity benefits of ML. 
I heard that a recent study of Silicon Valley startups showed that those mentioning Microsoft or its products in their manifesto had a 100% failure rate in getting funding. 
&gt; There are a lot of shops that want to use F# but either don't have the knowledge or the resources to get their employees that knowledge. Two years ago we were getting so many offers of F# consultancy that we had to turn people down. Beginning of last year I was trying to land our first £1M deal. After that fell through F# started to dry up for us. This year we haven't had a single consultancy contract, product sales have dried up and we're diversifying away from F# in a hunt for sustainable revenue after 7 years of F#. Several other big names in F# have also left. [Zach Bray did fantastic work at Trayport](http://zbray.com/2011/11/02/solving-the-0-1-knapsack-problem-using-continuation-passing-style-with-memoization-in-f/) but is now working full-time on C# for the money. Phil Trelford just left Trayport too. In 2007, Microsoft promised F# would be a ["first-class language on .NET"](http://blogs.msdn.com/b/somasegar/archive/2007/10/17/f-a-functional-programming-language.aspx). So what happened? Well, when F# saw its first full release in April 2010 as part of VS 2010 we braced ourselves for a flurry of orders. In fact, for two weeks after the release we didn't sell a single F#-related product. Why? Because Microsoft gave F# no visibility whatsoever. No mention of F# on the VS box. No mention on the language comparison table (just VB and C#). That was a sign of things to come. Even today the VS sales page says [**"C#, VB.NET, C++, HTML, JavaScript, XAML, SQL and more"**](http://www.visualstudio.com/explore/ide-vs) and F# is not mentioned anywhere (!). F# is growing so slowly that you'd barely know it. According to IT Jobs Watch the percentage of technical jobs in the UK mentioning F# has increased by 0.3% over the past 5 years. And F# is bigger in the UK than almost any other country in the world. From 2007 to 2010 we built several solid revenue streams on F# even though it had not yet been officially released as part of Visual Studio. Our [F# Journal](http://www.ffconsultancy.com/products/fsharp_journal/) was our biggest earner and had hundreds of active subscribers at its peak. Our [F# for Visualization](http://www.ffconsultancy.com/products/fsharp_for_visualization/) and [F# for Numerics](http://www.ffconsultancy.com/products/fsharp_for_numerics/) libraries have hundreds of users. From 2007 to 2010 our revenues from F# products grew 500%. Incredibly, as soon as F# was officially released in April 2010 our revenues from F# actually began to fall, a trend that continued to the present day where they are now at their lowest levels ever (lower than in 2007!). Microsoft destroyed our commercial software libraries by paying interns to write alternatives and give them away for free. Microsoft officially advocated the use of open source .NET libraries over commercial alternatives like ours. Instead of going deep on the Windows stack, Microsoft went wide with F# by trying to support Linux, Mac OS, iOS, Android and many other architectures and platforms. The result has been a disaster: non-Windows F# has a tiny number of users and F# never worked on Microsoft's Surface RT tablet. Microsoft asked the community what they wanted on user voice and they voted overwhelmingly for basic tooling like rename refactor but Microsoft instead gave us type providers. I've tried to write articles about F# type providers several times but I find them almost impossible to use. I tried to access Google with them and they crash repeatedly. I tried to access Amazon with them and they crash repeatedly. Most of them were lashed together by interns and are based on undocumented heuristics that only work in a handful of example cases. I have never seen them used in a commercial code base. I had to stand in as a lecturer and host at the world's largest conference on printed electronics last year. Over 2,000 delegates and I lectured about 3D printing. Huge buzz, massive interest, lots of forward thinking, fascinating conversations. So many people keen to adopt that exciting new technology. I came back totally hyped and went straight to London to lecture at an Microsoft F# conference. Grindingly dull in comparison. Lots of people in the audience whining about having to modernise. I decided there and then that I don't want to do software any more. Maybe if/when the world gets back on track with a decent software toolstack I'll come back to software development but, in the mean time, there are so many more interesting things to do... 
&gt; The message I think people get is: "F# is for hard stuff. You can't really use it for easy stuff." Yes. That is the message for political reasons. If F# were considered to be the general purpose language (that we all know it really is) then it would be competing internally with C# and that would make for negative energy. So F# is relegated to DSL status. The main destructive consequence is that F# does not get equal visibility. When Microsoft first released it in Visual Studio 2010 it was not even mentioned on any of the comparison charts. &gt; If we could use F# everywhere we use C#, and Microsoft promoted it as simply a good language instead of just a good language for hard stuff, then we might see a different picture. Absolutely. But that isn't going to happen. In fact, all I ever wanted was for Microsoft to promote F# for anything at all. To give it any visibility at all. But that never happened and, consequently, F# is growing slowly. It is growing, but nothing like the exponential uptake you see with competitors like Scala. 
Microsoft put up a user voice asking customers what they wanted. Thousands of people said "tooling" like rename refactor. They didn't provide it in-the-box. Instead they provided type providers (which I've never found a use for) and left the community to do it themselves. The community have sort of done something but it is typical OSS quality. 
"On second thought, let us not go to Silicon Valley. Tis a silly place."
&gt; I don't want reified generics. It's a mistake to have them. Why? Reified generics gives you performant polymorphism without the boxing and branching and you can still resort to type erasure if you want to (which I never do). &gt; Scala supports tail recursive elimination but has limitations. F# also has these limitations. Not true. Scala cannot support TCO in the general case because the JVM does not. F# supports TCO in the general case and is able to do so because .NET does. Furthermore, when I accidentally disable it (e.g. compiling in Debug mode) my programs often stack overflow because I rely upon TCO so heavily so I find it difficult to believe that Scala's lack of TCO would not be a hindrance. Indeed, it makes me think that people use Scala like a scripting language and not like a real FPL. &gt; Yes, scala's type inference is less than ideal, but I mostly run into issues relating to kinding, which isn't an issue with F# because it's completely missing this essential feature. I prefer to walk before trying to run. Until Scala gets basic type inference right I don't care if it has higher kinds or not. &gt; Scala has this. Last I looked, Scala couldn't even do exhaustiveness checking over pairs of bools correctly. &gt; Not an issue moving forward after the 2.8-2.9 problems. Stable since the minor release before last which was what, 12 months ago? F# hasn't hit me with a breaking change in 5 years. &gt; I don't actually think the 'real' signatures are all that scary The problem isn't that I cannot grok Scala's collections library without enough effort. The problem is that there is no way the people I teach could possible grok it. I trained a room full of professional software developers in F# a couple of months ago. Half of them struggled with basic functional programming. Scala's collections library is straight out of a Stephen King novel. &gt; Again, I haven't noticed much of a difference between the two. The humble hash table is the obvious example. Up to 17x faster on .NET because it has reified generics and value types. Same applies for complex numbers, low-dimensional vectors and matrices, arbitrary precision, colors, key-value pairs and lots of other value types whenever you want generics without having to cut and paste your entire collections library and specialise it by hand. 
&gt;Why? Reified generics gives you performant polymorphism without the boxing and branching and you can still resort to type erasure if you want to (which I never do). Do you really take a performance hit on non boxed casting from not having reified generics? I would think not... For non value types I see your point. &gt;Not true. Scala cannot support TCO in the general case because the JVM does not. F# supports TCO in the general case and is able to do so because .NET does. Furthermore, when I accidentally disable it (e.g. compiling in Debug mode) my programs often stack overflow because I rely upon TCO so heavily so I find it difficult to believe that Scala's lack of TCO would not be a hindrance. Indeed, it makes me think that people use Scala like a scripting language and not like a real FPL. So, I guess you're right, you can do things like mutual recursion in F#? Scala supports tail call elimination at the compiler level but that definitely has limitations. The reason I don't run into an issue too often is it's easy enough to use trampolining with Free monads. I don't even really think about it at this point. And anecdotally, the scala I write is often long running service oriented network apps. &gt;Last I looked, Scala couldn't even do exhaustiveness checking over pairs of bools correctly. No, it definitely does this. &gt; I trained a room full of professional software developers in F# a couple of months ago. Half of them struggled with basic functional programming. Scala's collections library is straight out of a Stephen King novel. Again, I haven't noticed much of a difference between the two. I believe you, and I talk trash about the collection library all the time. I just don't think F#'s is much better. Subtype polymorphic collections libraries are archaic. You don't need a 'collections' library. You need data structures and a number of principled type classes that they may or may not implement. &gt;The humble hash table is the obvious example. Up to 17x faster on .NET because it has reified generics and value types. Same applies for complex numbers, low-dimensional vectors and matrices, arbitrary precision, colors, key-value pairs and lots of other value types whenever you want generics without having to cut and paste your entire collections library and specialise it by hand. Good to know. I do appreciate taking the time to banter with me, it's been very informative. F# is a really good language. I just can't stand not having HKTs, it affects my architecture quite a bit. Unfortunately, I don't see any easy way for them to support it with the current implementation of their reified generics, but i'm crossing my fingers that someone smart can think of something...
Why not use xamarin studio? Can you debug and get auto complete in emacs? 
The lack of HKTs is one of my pet peeves, too. And I code in F# almost entirely. And it seems [we are not alone](http://fslang.uservoice.com/forums/245727-f-language/suggestions/5664242-simulate-higher-kinded-polymorphism). However, we already can implement some higher-kinded type classes today with some ugly inlining, so simulating HKTs in the compiler would probably be feasible. After all, in scala it is also a simulation in the compiler. This would probably suffer from some compatiblity issues with say C#, but this is also true for inline functions and they *can* be used.
Hm. This is really sad. I think I am sticking with software for a while myself, I am still too fascinated with it. But the picture you are painting - well, seems very plausible. Developers are too conservative, and trying to convince them to change anything is a job that can exhaust any reserve of patience.
Just to note - clojure does have type safety with core.typed. 
In the pragmatic category, it's a bit strange to group F# in with Haskell...
&gt;For example, one needs to manually hack the project files for Visual Studio to recognize a F#/MVC project as web project so that the corresponding tools are enabled. Or just use one of the F# MVC project templates...
I'm kinda half-way on this. The design seems pretty good, and the annotation syntax is reasonable, but it does scare me that the feature isn't first-class, and its may not be well-supported or considered idiomatic by the community. Nonetheless, Typed Clojure will be my go to language on the JVM! (assuming I ever go there)
OK, but that's not what you said.
**Follow-up to readers**: Please note much of the conversation here has been down-vote attacked by Scala trolls after the thread died. Don't let their biases affect your experience of this thread.
Excellent article.
He demonstrates his lack of understanding about the real advantages of F#'s features. Pro-tip - F# isn't for making shorter code, it's for making more understandable code. He then condemns the language as being "second-class" because he doesn't understand its advantages. Let's do ourselves a favor and down-vote this article.
I didn't notice that I had said F# was for making shorter code (whatever that means). In fact I think you will find the opposite to be true. I refused to accept the discriminated union solely on the basis that the code was more concise. F# is second class in that it doesn't have the tooling support that some other .NET languages do. Also it doesn't get the commercial investment. What is the ratio of job adverts for C# devs compared to F#. Incidentally both of these things disappoint me. Pro-tip: read the reddiquette on suggesting that people down vote But thanks got the feedback! 
&gt; F# is second class in that it doesn't have the tooling support that some other .NET languages do. Also it doesn't get the commercial investment. What is the ratio of job adverts for C# devs compared to F#. Well that's kind of a self-fulfilling prophecy.
Yes! Most of them actually. Some are using Visual Studio and some are using Xamarin.
Yes, you can.
C#6 solves a bunch of these issues with Immutability and code size with default constructors. *Edit:* I'm not sure what all of these downvotes are for. Factually, by adding read-only properties plus default constructors into C# the barrier to programming immutable classes will go down significantly. It obviously doesn't help with value based equality, however it is a strong start.
not even close. although this guy doesn't really get it either. "F# is concise because the default functionality you get out of the box. With F# you have to write less code.".... sorta kinda basically but he's clearly not done a lot of f# or functional programming. it's more about composition and how a language models the world. C#'s come a long way in the last 10 years but yeah its not just "oh hey look how much smaller this code is" that's a nice side effect but not remotely the point
then why write a blog post about it and link to it here? you don't really know what you're talking about. less writing blog posts, more writing code
I'm also a primarily C# developer who enjoys using F# for my personal projects. Reading your blog helped provide me with some more inspiration to keep at it. Thank you.
Hi, i'm not qualified for this position but this is the kind of job i'd like in the future. I'm currently a web developer, studied math/cs in college. I would really appreciate if you could give any advice on how someone such as myself could become employable for this kind of job (not necessary senior level, obviously, until my experience warranted it). 
I'm not surprised -- the F# version isn't very well optimized either. EDIT: I spent a few minutes cleaning up the code and sent a [pull request](https://github.com/philtomson/ClassifyDigits/pull/1), so maybe we'll see a third post in this series...
This got my interest since I'm in pretty much the same position as Phil. I'm a Linux guy (for now) and I like both OCaml and F# and have been vacillating about which one to use. I decided to see if I could speed up the F# version since I've been leaning that way. In terms of experience with F# I have almost none (dabbled 2 years ago on Windows and this is the first time I've used it since). My goal was to keep it as simple and high-level as what Phil already had (i.e., I didn't want to write a bunch of imperative loops). The first thing that struck me on the monodevelop side is I seem to have no profiler at my disposal. Ok, no problem -- I've done plenty of machine learning stuff in other languages, I know the bottleneck in these cases is usually the distance calculation. It looked like Phil's version makes two passes over the data to calculate the distance. So I changed the distance function to: let distance (p1: int[]) (p2: int[]) = Array.fold2 (fun acc a b -&gt; (acc + (a-b) * (a-b))) 0 p1 p2 |&gt; float |&gt; Math.Sqrt That by itself was enough to beat the OCaml array version on my machine. But since I'd only changed 1 line of code I figured I'd allow myself one more, I looked at the map calls for places where I could introduce some parallelism. The obvious places are where we calculate the distances in classify and where we actually do the classification. I'm not sure if my logic is right, but I think the best thing is to aim for coarse parallelism here (because there is overhead in scheduling, so we want the chunks of work to be fairly substantial). For want of a profiler I just tried both, I got the best results doing Parallel map on the classification itself: let num_correct = (validationsample |&gt; Array.Parallel.map [... ] That was 3x faster than the OCaml array version with only 2 lines of code changed so I decided to call that victory and I feel more confident about my choice. Although I should say, obviously there are always more options... these arms races can go on until we have hand crafted x64 ASM k-NN classifiers and we're just benchmarking FFI's but for keeping the code high-level I thought this was pretty awesome.
One thing I think you'll find is doing parallel map in both places is slower than either one alone. 
Thanks for the report, I recently noticed the same problem. It is a regression that happened as we adapted build logic to be portable to Mono/XS. Here is the ticket from the issue tracker: https://bitbucket.org/IntelliFactory/websharper/issue/247/make-it-easier-to-add-embedded-web I believe it should be fixed in the latest WebSharper. To embed a resource, you add an Embedded Resource as usual in VS, and then classify it as something to depend on. Here is an example: https://bitbucket.org/IntelliFactory/websharper.d3/src/7b4d52981e689b0ea582235e1554be27976ddfed/IntelliFactory.WebSharper.D3/Main.fs?at=default#cl-1285 Do you have a URL for the Cesium binding? Sounds exciting!
Right from the source! Thanks, I will try this when I can later today and let you know how it goes. No URL yet for the extension since I want to convince myself I did it correctly before putting it out there. I wrote a perl script to generate the WIG code from the jsDoc annotations in the Cesium library. It gets most of the job done, but some jsDoc annotations aren't right and the script isn't perfect, so I need to go through and double check it manually and run some tests. Once I feel good about it, I'll put it on github and let you know.
Hi again, toyvo. I got around to trying this out and I'm still having the same problem. I confirmed my nuget W# version is 2.5.114.49. Just to be safe, I created an entirely new solution from the Extension template after I upgraded my W# version. I have Cesium.js in the same directory as my Main.fs and my fsproj. I have tried to copy the D3 example as exactly as I can: let CesiumAssembly = Assembly [ Namespace "Fluffynukeit.WebSharper.Cesium" _List Namespace "Fluffynukeit.WebSharper.Cesium.Resources" [ (Resource "Cesium" "Cesium.js").AssemblyWide() ] ] [&lt;Sealed&gt;] type CesiumExtension() = interface IExtension with member ext.Assembly = Definition.CesiumAssembly [&lt;assembly: Extension(typeof&lt;CesiumExtension&gt;)&gt;] [&lt;assembly: System.Reflection.AssemblyVersion("1.0.0.0")&gt;] do () I have checked and my Cesium.js file indeed is listed as EmbeddedResource in the property viewer. However, I still have the same problem: the resulting Fluffynukeit.WebSharper.Cesium dll file is only 13 kB when the minified Cesium.js file is over 1MB. Have you seen success with embedded resources using the new W# version? Do you have any idea what my problem is? Happy to take this to PM or elsewhere if you prefer.
Ramblings about f# by some dude who has never really used f#. Pass.
No I haven't used F# but I have used C# commercially since .Net 1.1 so I think I am qualified to comment on F# to an extent. See my other posts on F#
Oh and I've also used many other languages commercially including Haskell. What languages have you used in a commercial environment?
Well you must be well respected constantly rubbishing people trying to further their own knowledge. You don't sound like any well versed architect/developer you have too narrow a mind. Would you have anything constructive to say about the article?
Wow I'm amazed by the negativity on here! I happen to know a lot of C# developers who are very intrigued by F#. I'm merely logging my learning process in the hope it might give some C# devs an entry point. I appreciate that F# has more about it than a small code footprint and I also confess to not being an F# expert I am merely coming at this from a .Net OO person trying to learn a .Net functional language. It ain't a tutorial. For what it's worth: Don Syme liked this post enough to tweet a link to it on twitter :)
Like I say maybe the people who are down voting appreciate that it is a blog. That is a web log of myself learning F#. While I appreciate and take on board the feedback it needn't be so negative
Hi, once again! I have been working on this this weekend and managed to get it mostly working. The only issue I have is that right now all my embedded resources are written to the Scripts/WebSharper/Fluffynukeit.WebSharper.Cesium/ directory in an entirely flat hierarchy, and only .js files are written out even though I have .css files declared as embedded resources (and I checked: they exist in the assembly). I want the files written here to have a particular folder structure because this is how the cesium library expects to be installed. The assembly itself also stores the resources in an flat manner even though I have them organized into directories in my fsproj by manually editing the fsproj file. Is there any way to assert control over how websharper writes the embedded resources to the Scripts directory? Modifying the Cesium library to work with this flat file structure is something I would like to avoid. Thanks much!
I'm not "constantly rubbishing people." Constructive? Sure. Stop wondering about how second class F# must be and just use it in production and see how you fare. That would be a good post.
FP has a good bit of sour apples; there's more than one reason FP isn't getting picked up as much as many of us wish.
Fascinating piece of work. My only nitpick is that "This means that the ratio of number of nodes to number of links is roughly the same both in F# and C# projects" is not true. A straight line on a log-log plot means power law, not linear. 
Thank you for the comment, I'll change the formulation. Anyway, the best fit seems to be a quadratic model, when the full dataset is included. When I exclude the EntityFramework (which is by far the largest project) the best fit is actually just a linear model. It seems we need more data! 
Wow, cool. So type providers can be used to do things like, if I'm understanding right, type StateAbbr = FixedLengthStringProvider&lt;2&gt; let s = StateAbbr("CA") let t = s + "lifornia" // error
This test only checks that the type `StateAbbr` doesn't have a `+` operator though. IMO The more interesting test case is this: let s = StateAbbr("California") // should be an error But it can't actually be made to throw a compile-time error in this case, because you can't know at compile time the length of the string passed to the constructor. You can have such a guarantee by taking the elements as separate arguments: type StateAbbr = FixedLengthStringProvider&lt;2&gt; let s1 = StateAbbr('C', 'A') // success let s2 = StateAbbr('C', 'A', 'L') // error: no constructor with 3 arguments type Alpha3CountryCode = FixedLengthStringProvider&lt;3&gt; let s3 = Alpha3CountryCode('U', 'S') // error: no constructor with 2 arguments let s4 = Alpha3CountryCode('U', 'S', 'A') // success Now, the big thing that vectors using GADTs allow is the following: let s5 = s1 + s4 // val s5 : FixedLengthStringProvider&lt;5&gt; AFAIK type providers are unable to do this. It's probably not something you want to do with state codes anyway, but in a more general case it's quite useful. #&amp;nbsp; Another, even more limited way, would be to take the value as static parameter: let s1 = FixedLengthStringProvider&lt;2, "CA"&gt; // success let s2 = FixedLengthStringProvider&lt;2, "CAL"&gt; // error But it has the same limitations, plus it only allows strings known at compile time. It might still be useful for state/country codes though.
I was playing with a similar idea to this in http://blog.mavnn.co.uk/type-safe-printf-via-type-providers/ , with type safe string templating. It boils down to it works for some aspects of dependent typing but not others - because the parameters for the type provider have to be constants, it's great for things like the templating example above but can't easily help with things like lists with dependent length. You could create (for example) a list with a known number of elements (and guarantee at compile time it had that many) but there would be no way to write an append function for it.
Now if I could install them in the express editions, it would be great!
It largely doesn't matter really. `'a` for example is the "type parameter a", I don't think anyone really says "a prime" or "prime a". Yes `|&gt;` is the "pipe operator" but when reading code that uses it you should think about what it *does*, not what it *looks like*. Think "function application", not "pipe", just as when you read `2*3` you think "multiplication" and not "asterisk", and this also lets you say `2x3` or `mul(2,3)` and everyone still understands multiplication, i.e. you have to detach the concept from the symbol.
For parametric types like `'a`, etc., I would call it 'An "a" '. And for function types, I would say 'A function _from_ something _to_ something'. So for a function type `'a -&gt; 'b`, I would say 'A function from an "a" to a "b" '.
Oh, that's very nice! Makes perfect sense. Thank you! 
No. What I meant is that when you say "you need to just pipe in the values here." it's just like saying "you need to asterisk this value" instead of "you need to multiply this value". The pipe is the name of the symbol. The operation it does, which is what matters, is function application. `'a -&gt; 'b` is "a function from a to b", just like in math you say "a function from reals to reals", i.e. defining domain and codomain. Again, trying to come up with names for every symbol does not matter much and will not help you understand the concept beneath. The important thing is to learn the concept. The symbol is just syntax. The obvious exception is when you're talking specifically about syntax, which isn't often the case. When talking to someone about some code you talk about it in terms of concepts. For example you don't say "function blah open parens foo close parens open brace...close brace", because that's syntax, not concept. 
They are both descendants from ML
The Scala hate in this thread is pretty funny. For that matter, there is no "grand treatise" on large systems F# development either. I would like to see more FP in any form penetrate the market regardless of which language carries it in. FP in only a few languages will not gain mindshare from developers fast enough; the multi-pronged approach is good for all of us.
Well, you *could* go the route of [subscription](http://www.visualstudio.com/products/visual-studio-online-professional-vs), rather than forking over $500 straight up.
I don't think my employer would buy into it.
404
I think the biggest reason fp is not very popular is UI, its very hard to have immutable state in Ui. Textboxes, checkboxes, labels etc would be a nightmare. Edit: I would believe games is also a fp nightmare. 
Awesome! Good to see that development is progressing so quickly, that kind of tooling is what was (and still *is* to large extent) sorely missing...
Awweesssomeee!!!!
This video seems to be down now. Can you reupload it? 
Had to edit out some stuff again from the vid: here is the new link http://vimeo.com/100960317 
this may be entirely wrong, i'm not trained at all in FP-ish ways. for Q1 i tend to for the former. i do that for two reasons. first if i extend the operation i can add more pipes forward. second i can see immediately it's the items value being operated on - less eye movement to scan. for Q2 i tend to do the former, but that may be my OOP-ish background getting me. like i said i may not be idiomatic. 
I've seen a lot of single piping like in your former example, I also prefer to do this. Helps show you what is being operated on and I think it reads more like a sentence. As for the second question, unless I have to interop with c# I don't even bother with classes or members. It's all about functions! They are easier to compose, curry, and they are already logically grouped by module. Why bother with a class if you don't need inheritance, an interface contract, or state?
for Q2 I usually do the latter. It makes composition much easier. For example, if I want to define a function that adds a double, I could do let blah number = number |&gt; Item.double |&gt; Item.add OO style, it would look like let blah number = number.Double.Add Which is fine, as long as you don't want to introduce other functions into the pipeline. Honestly I barely use classes when I'm working in pure F#.
Discriminated unions are classes too :)
Another question: what does everyone think about point free function composition? let doSomePipeline number = number |&gt; firstStep |&gt; secondStep vs let doSomePipeline = firstStep &gt;&gt; secondStep
I like the &gt;&gt; operator, but I don't find much occasion to use it, especially to define a point-free function like that. 
1) Sometimes you just have to use the pipe because the compiler can't figure out the types otherwise. Another case where the forward pipe is useful is when you extend the processing pipeline: long pipelines look more clear when each step is separated by a pipe operator, so you don't have to rewrite anything. I personally do the forward pipe as a reasonable default. 2) It is inconvenient to use class members when your operation is immutable. Also, class member drags along the context of an object -- you don't always need that. Of course, you can define a static member in that case -- it will work the same for most practical purposes. As a rule of thumb, I prefer to use functions when I'm doing immutable or context-free stuff and define class members if I want to intentionally mutate the object or need the context (like defining a property). This also applies to cases when you need to go the OOP way for C# compatibility.
&gt; It's no different than using static classes Yes, that's exactly what it feels like, which seems like a small step backwards. C# uses extension methods to make these functions behave like members. &gt; Does it feel weird doing Seq., or List.? Honestly, yes. I'm a big fan of LINQ, so I'm used to this: items.Select(...); Typing this instead took some getting used to: Seq.map (...) items In the second case, the Seq module is an extra thing to think about that's hidden in the first case.
&gt; Sometimes you just have to use the pipe because the compiler can't figure out the types otherwise. Yes, this is a "gotcha" in the type inference mechanism. This is also a major reason to use functions instead of members - members aren't used for type inference.
From **Expert F# 3.0** (Don Syme is one of the Authors): &gt;In a sense, |&gt; is function application in reverse. However, using |&gt;has distinct advantages: &gt; &gt;* *Clarity*:When used in conjunction with functions such as List.map, the |&gt; operator allows you to perform the data transformations and iterations in a forward-chaining, pipelined style. &gt; &gt;* *Type inference*:Using the |&gt;operator lets type information flow from input objects to the functions manipulating those objects. F# uses information collected from type inference to resolve some language constructs, such as property accesses and method overloading. This relies on information being propagated left to right through the text of a program. In particular, typing information to the right of a position isn’t taken into account when resolving property access and overloads. In the next page they shows this code: let google = http "http://www.google.com" google |&gt; getWords |&gt; Array.filter (fun s -&gt; s = "href") |&gt; Array.length 
You'll get there :)
Apparently experienced F-sharpers don't like point-free style for top-level definitions because it somewhat hides the function arguments and their types. I can somewhat see the logic but personally I prefer point-free.
I do too. It feels more functional to me. It's just a straightforward composition. I don't think it's any more hard to follow. I use it when I'm defining a function that's just a composition. If it gets more complicated, i'll switch to pipe.
So let me ask you how to layout a typical .fs file for a type. Here's what seems logical to me: namespace MyProject type MyType = { ... } module MyType = let func1 myType = ... let func2 x myType = ... Unfortunately, you can't have a module with the same name as the type. So if the type is called "MyType", what do you call the corresponding module?
Yes and no. You tend to use namespaces and modules, it gives you better granularity of what you import into your local space. As far as intellisense, it's no different than functions in your local scope. Control+space on empty will list them all :)
On structuring your application modules, types etc.. it might be worth reading this http://fsharpforfunandprofit.com/posts/recipe-part3/
&gt; You can get away with having a class named the same thing if its a generic type (like List&lt;T&gt;, Array&lt;T&gt;, Option&lt;T&gt;) and the module having the same name, since they are two different things. One is a class instance of a generic, and the other is a static class without generics. Just a small clarification, you *can* have the same name for both the class and module, with a little attribute trick that generates different compiled name: type User() = class end [&lt;CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)&gt;] module User = let doStuff() = ()
Thanks, that's very informative. I also found [this document](http://fsharp.org/specs/component-design-guidelines/fsharp-design-guidelines-v14.pdf), which gives somewhat opposite advice: *Use properties and methods for operations intrinsic to types. This is called out specifically because some people from a functional programming background avoid the use of object oriented programming together, preferring a module containing a set of functions defining the intrinsic functions related to a type (e.g. length foo rather than foo.Length). ... In general, in F#, the use of object-oriented programming is preferred as a software engineering device. This strategy also provides some tooling benefits such as Visual Studio’s “Intellisense” feature to discover the methods on a type by “dotting into” an object.* 
You have to use extension methods. I'm on my phone so I can't format, but it's essentially like this: type T = stuff let function t = f t type T with member this.function = function this
Thanks, that makes sense, although it's interesting that it's not documented as an extension method.
I see. So could it even be an abstract method?
Yup.
Set.remove is a function on a module called Set. Set.Remove, the instance method, is part of the type called Set&lt;'T&gt;. This is **not** an extension method; these two functions belong to different types. You can do something similar using this syntax: open System type Set&lt;'T&gt; = member x.Add item = raise (new NotImplementedException()) [&lt;CompilationRepresentationAttribute(CompilationRepresentationFlags.ModuleSuffix)&gt;] module Set = let add item (_set: Set&lt;_&gt;) = _set.Add item The only real magic to this part of the Set implementation is the CompilationRepresentation. This comes in incredibly handy when you need functions that support currying, others that have optional, tupled parameters, etc. Pretty easy to adapt by making Set&lt;_&gt; an abstract class in `add`
Hit the nail on the head. Here is another example from a project of mine. I was parsing raw text commands off a socket stream: https://github.com/devshorts/Playground/blob/master/StateMachinery/ExamSystem/ControlInterface.fs#L33 https://github.com/devshorts/Playground/blob/master/StateMachinery/ExamSystem/CommunicationProtocol.fs#L117 Active patterns made this really elegant 
[**@FSPowerTools**](https://twitter.com/FSPowerTools): &gt;[2014-08-11 07:02:05 UTC](https://twitter.com/FSPowerTools/status/498726026172964864) &gt;v1.4.0 is out with graying out unused opens, full support for VS 14 and much more besides. Check it out [*visualstudiogallery.msdn.microsoft.com*](http://visualstudiogallery.msdn.microsoft.com/136b942e-9f2c-4c0b-8bac-86d774189cff) [#fsharp](https://twitter.com/search?q=%23fsharp) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/2d7uh5%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Q1 is fine, and is more natural. The Seq and List functions are just written to be piped that way. (Putting the subject argument at the end is weird to me.) For Q2, I tend to avoid traditional OO in F# as much as I can. Member functions don't compose and don't generalize nearly as well as real functions.
What's wrong with South Americans? Assuming that you limited the continent because of time-zone limitations...
We would consider an excellent candidate from South America, but prefer North America because of the occasional need for in-person visits with customers.
I see. For many countries, US consulate gives 10 year multiple entry visa by default. It is a tourist visa but can be used for occasional meetings. Anyway, arranging similar business visa shouldn't be a problem. Just FYI so that you won't miss good candidates because of a little bureaucratic hassle... 
I guess a Functional Data Scientist doesn't exist? (404)
Correct link is http://www.infoq.com/presentations/functional-data-scientist Submission link has some weird non-ASCII characters at the end. This is causing the 404.
The F# addin is open source so perhaps log an issue detailing your problem? https://github.com/fsharp/fsharpbinding/issues
The F# plugin is virtually brand new - and it seems to have an equal number of bugs stemming from not being visual studio, being cross platform, requiring a separate tools install, etc. I still use Monodevelop, but I keep a windows-generated template project around so I can use that instead of the built-in one that has the issues.
Confusing article. Async and await are orthogonal to any threading models.
This kind of stuff is why I'm suspicious of the MS/Xamarin promises that they make it so easy to port your stuff everywhere. 
[Meetup](http://www.meetup.com/nyc-fsharp/events/199367152/) [LinkedIn](https://www.linkedin.com/groups/Happily-together-F-SQL-NYC-2347131.S.5912256989810950146?trk=groups%2Finclude%2Fitem_snippet-0-b-ttl) 
Awesome splash intro!
Article doesn't work on mobile :(
Works just fine for me on a S3 with Chrome. 
I've taken to doing most of my side projects in F# and I've been meaning to look at how to do more of the ASP.net code in F#. Useful information here.
Nice to see an easier setup for a Web Api and F# site. If your are really hoping to go lightweight then I might suggest http://suave.io/ . There is a lot that MVC and Web API offers but if you need something really simple then it is overkill.
Suave looks pretty slick but it really does show how much I still need to learn about F#.
found this (via twitter) TODO List app rewritten in F# with OWIN that is also a nice exemplary F# web application. https://github.com/panesofglass/TodoBackendFSharp
You definitely should use http://fsprojects.github.io/SQLProvider/ for this task.
You sure? http://blog.tallan.com/2009/12/31/adding-sqlite-to-a-windows-mobile-application/
The f# compiler is slower than the c# compiler, I've noticed that too, but it's also doing a crapload of optimizations such that your end code is often times faster than c#. As for compile size, all those anonymous functions and modules and stuff get compiled into classes and interop IL. If you decompile the binary it can look kinda messy, but, you will write so much less code in f# anyways so it counter balances! Keep exploring f#, it's a great language
Quite certain. SQLite itself runs on almost anything. It's extremely portable. System.Data.SQLite is an ADO-style wrapper for .NET. It is very incompatible with the Xamarin tools (which are the way to use .NET-ish stuff on mobile platforms). And the F# SQL provider mentioned by kot_2010_0 gets its SQLite support from System.Data.SQLite. 
&gt;typical OSS quality what.
I've not actually been able to use it. Last time I tried I was on Linux Mint with MonoDevelop from the Mint/Ubuntu packages and I think the plugin was from the official repo (via the Monodevelop menu). It just wouldn't work for me. Unfortunately I don't get to go on my computer much these days, so I haven't been able to investigate why or try to use a more recent monodevelop version. If I remember correctly it was complaining about version compatibility for some reason. It's a shame, because I like Linux and I like F#.
Same here--couldn't get it working on Linux Mint. Too bad, because I'd like to use an IDE that allows vim emulation. (Visual Studio Express doesn't.)
I didn't know you could use active patterns like that, very interesting. F# is truly a great language.
Wow, I had no idea you could use active patterns in arguments. This is kind of game changing for me
Nice! This is a great example for people who don't program in F# on a regular basis. It's simple enough to be understood while still being useful
CloudSharper (cloudsharper.com), from the same company, is written with it. I'd say a web-based IDE is a pretty good example of its power. I don't have any real applications written with it, but am exploring the stack myself. Am interested to hear what others have done as well.
Partial application is a bit like a poorman's DI. Dependencies are passed in as parameters of a curried function and partially applied. The result of the application is a function with all of its dependencies resolved. Eg. let makeExampleFunc a b c d e otherParam = // do some stuff with a, b , c, d, e... // resolve dependencies let exampleFunc = makeExampleFunc a b c d e The good thing about this is that you're not registering dependencies with a global(ish) DI container which may be composing things in an order you don't expect. The bad thing is that there's no DI container to register your dependencies. :) So your code will be a bit more clumsy.
cool, thank you. i was thinking partial application could be useful here...my fear is the whole clumsy code bit. i'll have to experiment.
If dependencies are stateless, stick them in module variables?
not exactly sure what you mean. can you elaborate?
Would you mind pointing some more obvious mistakes? Doesn't have to be very detailed, as long as I can google it more.
[**@FSPowerTools**](https://twitter.com/FSPowerTools): &gt;[2014-10-05 08:06:51 UTC](https://twitter.com/FSPowerTools/status/518673659305926656) &gt;Do you have cool ideas for F\# tooling? Let us know your thoughts on [*vfpt.uservoice.com*](http://vfpt.uservoice.com/) [#fsharp](https://twitter.com/search?q=%23fsharp) [#visualstudio](https://twitter.com/search?q=%23visualstudio). ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/2idouk%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
I want this to be true so badly.
It is true when working in the finance and insurance sector. Many companies are using it for data modeling.
My university was very strong in FP an LP back in the mid- 90's in Portugal, so I got to learn how to think in those paradigms. As for the rest I would say a CS degree or an applied mathematics degree, most likely. However asking around is also very important ,as many positions only announce more mainstream languages.
Heaps of materials for getting started - there's no excuse to not be familiar with at least one fp language. The biggest barrier to adoption is usually interop. No project has the resources available to rewrite in take new language. In this regard f#, closure and scala are great. Haskell, ocaml and erlang not so much. One thing I don't understand yet - how has Go become popular with essentially no interop with existing code outside of http service Apis? 
So you're working with time series data? Check out Deedle.
The functional equivalent for the ICursor would be a monad. Here is a [link](http://en.wikipedia.org/wiki/Monad) that describes them. The TL;DR; is basically a structure that is immutable but acts mutable. *Edit: Apparently I fail at knowing how to link to something with brackets. Just follow to the one for functional programming.*
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Monad (functional programming)**](https://en.wikipedia.org/wiki/Monad%20(functional%20programming\)): [](#sfw) --- &gt;In [functional programming](https://en.wikipedia.org/wiki/Functional_programming), a __monad__ is a structure that represents [computations](https://en.wikipedia.org/wiki/Computation) defined as sequences of steps: a [type](https://en.wikipedia.org/wiki/Type_(computer_science\)) with a monad structure defines what it means to [chain operations](https://en.wikipedia.org/wiki/Block_(programming\)), or nest [functions](https://en.wikipedia.org/wiki/Function_(computer_science\)) of that type together. This allows the programmer to build [pipelines](https://en.wikipedia.org/wiki/Pipeline_(software\)) that process data in steps, in which each action is [decorated](https://en.wikipedia.org/wiki/Decorator_pattern) with additional processing rules provided by the monad. As such, monads have been described as "programmable semicolons"; a semicolon is the operator used to chain together individual [statements](https://en.wikipedia.org/wiki/Statement_(computer_programming\)) in many [imperative programming](https://en.wikipedia.org/wiki/Imperative_programming) languages, thus the expression implies that extra code will be executed between the statements in the pipeline. Monads have also been explained with a [physical metaphor](https://en.wikipedia.org/wiki/Physical_metaphor) as [assembly lines](https://en.wikipedia.org/wiki/Assembly_line), where a conveyor belt transports data between functional units that transform it one step at a time. They can also be seen as a functional [design pattern](https://en.wikipedia.org/wiki/Design_pattern) to build [generic types](https://en.wikipedia.org/wiki/Parameterized_type). &gt; --- ^Interesting: [^Functional ^programming](https://en.wikipedia.org/wiki/Functional_programming) ^| [^Purely ^functional](https://en.wikipedia.org/wiki/Purely_functional) ^| [^F ^Sharp ^\(programming ^language)](https://en.wikipedia.org/wiki/F_Sharp_\(programming_language\)) ^| [^List ^comprehension](https://en.wikipedia.org/wiki/List_comprehension) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+clfjf2m) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+clfjf2m)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
A quick update just now to show how awesome FRP is. :D
[**@silverSpoon**](https://twitter.com/silverSpoon): &gt;[2014-11-02 16:36:41 UTC](https://twitter.com/silverSpoon/status/528948821427257344) &gt;Ok, since apparently I m doing a video about FAKe, what do you want covered in it ? [#fsharp](https://twitter.com/search?q=%23fsharp) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/2l2r7u%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
- What is it? - how to use (getting started) - integrations with some CI (TeamCity, Appveyor) 
From Steffen Forkman (on twitter) - I would like to see projectscaffold and how FAKE/ProjectScaffold can help to improve C# project builds. - also I think FAKE is really mature and not some random build tool. If you think the same than I'd like to see that covered too. - Also important point: it's a small DSL. We don't think you have to study 3 years of F#. Especially if you use projectscaffold. 
From Rudi Grinberg [on twitter](https://twitter.com/rgrinb/status/529023742627024897): - how it works in conjuction with Nuget and Packet wishlist: - how to get started on Mono
Basically - why should I use it? The mechanics of it are very simple, but I'm not sure which use case it fulfills better than other tools in the market.
Release notes for everything in 1.6.0: https://github.com/fsprojects/VisualFSharpPowerTools/blob/master/RELEASE_NOTES.md
It would be so nice to have this in express versions....
I already did long time ago. It is not that I am a big F# user, still it would be nice to have access to the tools at home.
I've never tried [Xamarin Studio](https://store.xamarin.com/) beforebut it has a free starter subscription. Maybe that would help?
I have Visual F# 3.1.2 installed in Visual Studio 2013 Express, but it is not as feature rich as the FSPowerTools.
You should use async version of the GetHostAddress function instead: http://msdn.microsoft.com/en-us/library/system.net.dns.gethostaddressesasync(v=vs.110).aspx
So I saw that func but didn't see how to use it right. i found an example here https://github.com/CRogers/immdb/blob/master/immdb/Network.fs but i'm getting this error in fsi when i try and use it: error FS0192: internal error: convMethodRef: could not bind to method i'm on mono 3.8 on OSX yosemite. EDIT - seems to be an issue with mono pointing to .Net 4.0 and not 4.5. investigating ... 
On .net4 you can use Async.FromBeginEnd passing BeginGetHostAddress, End... methods.
Could you go into a bit more detail? Right now it sounds like your team tried to write C# using F# and you found that writing C# in C# is better. This is a common complaint that comes from teams that have heavy background in OO languages when they try their hand at a functional one.
Some things I think are behind /u/dex206 post - CLS code is OOP, so you either wrap all plaftorm APIs in more F# friendly way or use them as they are - When you look at BUILD and Teched events, the Visual Studio support is usually C#, VB.NET, C++ and then comes F#. This leaves F# as the least supported in terms of tooling - As consequence of the previous point F# is pushed to library code with the UI being done in another better supported language. Or one just tries to leave without tool support. The F# Foundation guys are doing a lot of nice work in terms of tooling, but Microsoft's management is the opinion that traditional corporations won't buy into F# full stack applications (their main market), as such the tool support is as it is.
Some nice additions there. Still, I can't help being a little disappointed. I am (probably unrealistically) waiting for the day when F# becomes of 1st class citizen in Visual Studio and in .NET land in general. For example, the day when any developer can open up VS and build a UI (web, wpf, whatever) just like they can do with C#. I am well aware of the fantastic community contributions and extensions out there and have used them myself, but let's face it - until Microsoft presents F# as a 1st class citizen it is not going to gain widespread adoption, and will perceived as a fringe language. I'm not saying this is fair (it's not), but I think the direction MS takes with F# helps feed in to the beliefs that many people carry around. Namely that F# is a research/academic language and is not on the same level as C# in terms of priorities at MS. I really wish this wasn't the case, as I think F# is terrific and really is poised to gain wide acceptance - under the right circumstances. 
F# feels as if it has two possible paths right now. One would be a replacement for C# (perhaps what Swift is for Objective-C). The other would be in a more academic direction -- adding more to the Type System (higher kinded types, effect inference, enforced purity) -- more [Daan](http://research.microsoft.com/en-us/people/daan/), [Don](http://research.microsoft.com/en-us/people/dsyme/), and [Tomas](http://tomasp.net/) (my apologies for leaving out tons of other great people -- just trying to get across the idea that I want people who **know** what they are talking about in charge, rather than taking the top requests on UserVoice), more pure functional programming, more effect-aware programming, and building **functional** libraries and toolkits. I would probably prefer the latter path, but can certainly see the appeal of the former -- I would prefer it if my team used F#, for example. My concern would be that if we made F# a first class citizen in the UI right now, that it would be adopted in a way that increase the pressure on F#'s interoperability rather than on its *functional*ness. If the F# tutorials of the future start off by saying in F# we use "&lt;-" instead of "=", it will be very hard to keep the language from being pulled in the wrong direction. There are very interesting things being done with FSharp UIs right now, but from what I have seen the functional UI is just not understood well enough. I hope F# can be used in all of these areas as a first class citizen, but I hope we get there not by increasing F#'s already great ability to work with object oriented frameworks, but by building up frameworks that work functionally. I think we are close, but not quite there yet. This is just a Preview and there are a lot of things coming. I would love to know what the Web Sharper and FSharp.Desktop.UI guys wish lists are for F#, including what kind of tooling support would make those platforms first class. 
This is an interesting tension. IMHO, the OOP stuff is something to be avoided, if possible. However, most stuff right now is OOP (.NET Framework). The question is should F# be made more OOP, or stick with the better paradigm? I would prefer the better paradigm, but it depends on what your needs are. 
F# becoming an academic toy / lab language is at odds with mainstream success (and subsequent increased industry interest). F# is quite palatable for mainstream right now (certainly at level of, say, Scala). Not a good idea to waste that opportunity.
Agree with this 100%
F# was kind of born as an academic language -- it is an ML dialect from Microsoft Research and still led by Microsoft Researcher Don Syme (who knows a thing or two about academic languages). Haskell, another language 'led' by a Microsoft Researcher (SPJ), is known for "avoiding success at all costs" -- a bit of joke, but it allowed the language to make some really great advances in programming languages, and the work that is being done on types with Haskell, CoQ, Idris and Agda (and others), is really interesting stuff. Stuff I hope finds its way into F#. A lot of what makes F# such a great language is its more powerful than C# type system and its roots as a *principled* language. My sense is that advancing the Type System would be better than making it easier to construct mutable code, or to interop with mutable code. It would be awesome if the tooling were better, but critical that F# keeps its functional first nature. And I hope it continues to innovate in that direction (I would love for an effects system to accompany the type system), or in its own direction (Type Providers are awesome, unique, and I think continues to be fertile ground). Wider adoption would be great as long as the adoption is driven by tooling that brings people toward the functional style rather than tooling that bends F# toward already existing libraries. I would love to see more BCL Libraries that were pure functional in nature. I would hate to see progress on this thwarted because we make it easier to write C# style code in F#. So, I think I agree, more adoption of F# is better and now is a great opportunity that better tooling could help -- just make sure it keeps what makes it great and continues to innovate in that way. Success has not always been kind to the continued design of programming languages. 
What does it mean when he says it's for the Enterprise? Is it because with 4.0, you can now trust F# (just like you would with C#) for any production and business critical applications?
It's an explanation of what F# brings to the table, including proper tooling and interoperability. I expect the title is to indicate right off the bat that companies that haven't heard of it before can trust it not to be some academic concern or toy language.
Whenever we being up F# as an option for developing code to management or the architects they always have the same two objections. - None of the other developers know it. - Microsoft might drop support for it. Seems that one of the road blocks is down. 
In fairness, there are now some great templates you can download (no manual hacking needed) for web projects. But your point remains very valid, the simple fact that you don't get that out of the box speaks volumes - especially to enterprise people.
The key part is, &gt; They did try to sell it in a way that doesn't scare their typical customers. 
Mentioning it in the release notes of Visual Studio scares people? If anything it's the opposite, its absence makes it look like Microsoft isn't committed to it.
At PDC, BUILD and TechEd events there have been a few talks from Microsoft evangelists about F#, since the early days of the language. 
Does this warrant the 4.0 designation? Seems like 3.2 at most.
Thanks for noticing F# is missing there. I got in touch with the content owners and the F# 4.0 preview download/blog are now linked. The VS Preview/Connect(); thing was a pretty big marketing push, with a ton of different blogs/pages/videos/etc, and we just missed that one. Confusion was partly due to the fact that our newest stuff was not in the box, but needed an update download. FWIW F# is in fact slowly getting more marketing/management attention. We did miss that relnote page, but the OP video was produced/supported by marketing, F# was represented along with C#/VB last week [on Channel 9](http://channel9.msdn.com/events/Visual-Studio/Connect-event-2014/022), the F# videos/blog were hyped by the C#/VB on their [two](http://blogs.msdn.com/b/csharpfaq/archive/2014/11/12/introducing-the-visual-studio-2015-preview-for-c-and-vb.aspx) [blogs](http://blogs.msdn.com/b/csharpfaq/archive/2014/11/12/short-videos-demonstrating-what-s-new-in-visual-studio-2015-preview-for-c-vb-and-f.aspx) last week, and we even got a nice Soma (head of all VS) [tweet](https://twitter.com/SSomasegar/status/532684105415405568). Baby steps...
F# works great for WPF and WinForms app development, as you can use the full fat .Net Framework. F# code can run in a Windows 8 Store App using a portable library, however you'll need a C# or VB.Net project to host the app and call the F# code. I have an example from a couple of years back of building a cross platform Pacman game (including Windows Store): http://trelford.com/blog/post/PacTile.aspx Another option for building a Windows Store App with F# is to use WebSharper (to compile to JavaScript) and WinJS. Ironically building an app with F# for iOS or Android is easier and has better support (via Xamarin) than building a Windows Store app, i.e. no C#/VB.Net boilerplate required.
So you're talking about the intersection of three technologies: (1) F# (2) .NET (3) Windows Store apps You're climbing several learning curves all at once. It'll be ... challenging. :-) There is a lot of good reading material out there, but most of it is only going to cover one or two of your three areas. For example, for the F# language itself, this site is highly recommended: http://fsharpforfunandprofit.com/ 
It's not that much different from doing it in C#. You have to set the same attributes on the class and methods that you use in C#. All of your exposed methods have to use tuples as arguments. It's a hard topic to Google, but you can use any C# examples and tutorials. That's the good thing about being .NET based.
Interesting, in C# I would tick a button in visual studio to expose to com, not sure what this does in terms of code impact, and this option does not exist in visual studio. So not sure how to expose it, do we have the assembly.cs equivalent etc in F#
I'm not sure how far along it is, but you may want to check out the COM type provider. https://github.com/fsprojects/FSharp.ComProvider Edit: Ahh, no primary interop assembly support yet.
Btw in VS2015 the F# templates contains an AssemblyInfo.fs, similar to the usual AssemblyInfo.cs.
I felt incredibly overwhelmed when I first approached .net, coming from a Java background. For some reason, as soon as I found out the C# equivalents for ArrayList and HashMap, I felt immediately more comfortable. (FYI, they are List and Dictionary.) I can't help you very much with your specific query, but here's some information more relevant to F#: the vast majority of .net collections implement an interface called IEnumerable, and can be manipulated using the excellent Seq module in F#. Armed with this knowledge, it's surprisingly easy to just find a C# tutorial for any given task and start writing an F# implementation instead.
Hi thank you for your response. I write some clojure at my day job so I have *some* grasp of functional programming. I could never get over how ugly lisp is but I love the beauty of F# so far. That link looks fantastic. Very excited to start this journey. 
&gt;&gt; Armed with this knowledge, it's surprisingly easy to just find a C# tutorial for any given task and start writing an F# implementation instead. Thats a great pointer. thank you. 
&gt; however you'll need a C# or VB.Net project to host the app and call the F# code Where is a good guide on how this works? I have been looking to make these kind of applications and can't find anyone to walk through what steps need to happen. Specifically: How do you make F# libraries to be used with C#? How do you use that library in a C# project? How do you link form objects to the F# calls?
i'm assuming you already program in another language. i've been using the Programming F# 3.0 2nd edition from O'Reilly to great effect. i google for other stuff to augment (e.g. like working on understanding how to ref mutable variables in list comprehension), the stackoverflow community for F# has been pretty good. i didn't like the wikibooks F# book at all and do not generally recommend it. 
&gt;i'm assuming you already program in another language. Not with any fluency. I have taken classes in Pascal and VBA (one of each). So I know the very basics. I know the difference between While loops and Do loops and stuff like that. And I could sit down and make an Excel spreadsheet do useful things as long as I had a handy reference guide to knock the rust off my VBA knowledge. But that's about it. Dunno if that changes the book recommendation any.
It doesn't. That's still a good book to read. Organized well and doesn't get too crazy too soon. Hope it helps m
that is NOT a beginner's book. it explicitly states it is for people already familiar with visual studio, C#, and the .NET framework.
i recommend [functional programming using f#](http://www.amazon.com/Functional-Programming-Using-Michael-Hansen/dp/1107684064). i just picked it up myself and am enjoying it. the programming f# 3.0 book is also pretty good. there's also [programming language concepts](http://www.amazon.com/Programming-Language-Concepts-Undergraduate-Computer/dp/1447141555). it's an introduction, although it doesn't play around, to exactly what it says, but it uses f# as a meta language to explore the concepts.
as good as any book: http://fsharpforfunandprofit.com/
While I love both of those books, I think "Programming Language Concepts" is much better as an introduction to compilers than as an introduction to the F# language. "Functional Programming Using F#" is definitely the best book to start learning the language with. Unlike the other books people are recommending, it focuses a lot more on the conceptual side of function programming and it's the only one that has practice exercises. "Expert F# 3.0" is my goto reference book, with "Programming F# 3.0" a close second. Skip "F# Succintly", "Foundations of F#", "Friendly F#", and "Beginning F#"; they all cover the same or less material than the books I already mentioned and they do a worse job at it. 
&gt; While I love both of those books, I think "Programming Language Concepts" is much better as an introduction to compilers than as an introduction to the F# language. yep. i really only mentioned it because i myself ooked and looked for the best beginner book before landing on function programming using f#. throughout all this search, i didn't come across the programming language concepts book, or if i did, i didn't realize it used f# to present the concepts. it's a neat book, but it definitely focuses on programming language concepts using f# to discover and explorer rather than programming in f#. i personally am interested in both books because a project i have in mind could mean writing something resembling a compiler plus the normal higher abstraction stuff like a UI and models.
the author of that website is supposedly writing an f# book based. although, he ignored my tweet asking about the status of the book, so i have no idea when it's actually supposed to come out.
The COM Type Provider is for consuming COM components from F#. The OP is wanting to go the opposite direction. :)
Each function can only have one output, so if both values are expected to come from the output of *g* you will have to use a tuple. On the other hand, if you know the value of *y* in advance then you can just use partial application, e.g. let composed = f &gt;=&gt; g &gt;=&gt; h y Applying the argument *y* to *h* returns a new function that just takes a single parameter of type *B*.
i'd buy that book for sure, even though the website is free. thanks for the heads up!
&gt; how can i make h more amenable to composition? Partial application is your friend. Assume you start with a resultX and resultA, then you can do let processY y = let h' = h y resultA // RESULT&lt;A&gt; |&gt; bind g // RESULT&lt;B&gt; |&gt; bind h' // RESULT&lt;U&gt; let resultU = resultX // RESULT&lt;X&gt; |&gt; bind f // RESULT&lt;Y&gt; |&gt; bind processY // RESULT&lt;U&gt; 
F# is a statically typed .Net language just like C#, and F# code is instantly accessible from C#. To get started, from your C# project simply add a reference to your F# library, just as you would with a C# library. If you're designing an F# component to be consumed by multiple languages you should also check out the F# Component Design Guidelines: http://fsharp.org/specs/component-design-guidelines/
Try fquanty: https://github.com/luajalla/fquanty
Check out ExtCore -- it's designed using the same guidelines as the F# core library: https://github.com/jack-pappas/ExtCore
Do you have a link to the slides?
I found this on twitter the other day but haven't found the video yet :\ This doesn't look like the right video: https://skillsmatter.com/skillscasts/4971-domain-driven-design-with-scott-wlaschin 
WOOOOOOOOOOOOOOOOOOOOOOOOOOOOO Is it just me or has the F# experience become radically more open in the past few months? .NET core is open, Xamarin has better features for FOSS and student developers, and now this!
There's definite hype, and I'm definitely enjoying it.
My guess is you are seeing something like : http://gamedev.stackexchange.com/questions/17641/what-is-the-directx-for-managed-code-update If that is the case then it will not work with .Net versions &gt;= 4.
Wow! Fantastic news. Should bolster commercial adoption rate.
He was doing this talk both at Build Stuff (vilnus) and NDC London and they were both recorded. So keep an eye on those (twitter, etc). I can tell you , totally worth it (just saw it in London)
Which twitter should I follow for updates? :)
I think this is a shorter talk but some of the examples and slides there are also in [this presentation](http://vimeo.com/97507575) 
I should have said it this way - F# has a strong oral tradition. Much of the language's idioms and patterns aren't documented in books and blog posts.
Oh I see, thank you. Sorry I'm not a native speaker
And I am not either :)
Meetup: http://www.meetup.com/nyc-fsharp/events/218780450/ LinkedIn: https://www.linkedin.com/groups/Understanding-social-networks-F-NYC-2347131.S.5946784893450088449?trk=groups%2Finclude%2Fitem_snippet-0-b-ttl
It would be interesting to hear if he actually caught many bugs with these test and see how it would compare with simply using real world code from github as test cases. 
Why call it printfn? Print, formatted, newline. If you want a crappy semi-generic print function, defining something like Let print = printf "%A" might do the trick, but you probably won't be happy with the result. Refer to this bit of the Zen of Python: "Explicit is better than implicit."
As pointed out, the name effectively means "print, formatted, with new line" and is a part of the [Core.Printf](http://msdn.microsoft.com/en-us/library/ee370560.aspx) module. F# inherited a lot from OCaml, including many of the core function and type names, printf being one of those.
I can't understand your question, both because of a language barrier and because you're playing fast and loose with technical terms.
https://twitter.com/ScottWlaschin
He just twitted [this.](https://twitter.com/ScottWlaschin/status/541627249280421889)
The "f" in printfn is where all the magic happens! It denotes a formatted string. What's more, the formatting is statically typed, which is more than you can say for your average print function.
There are faster and/or more elegant algorithms for testing for primality. (e.g. Once you know your candidate is not divisible by 2 or 3, you already know that it's not divisible by 4, 6, 8, or 9...) But that's a general-purpose math question, not an F# question, and since you posted here I assume that's not your main interest. So confining things to the way you've implemented this particular algorithm in F#: The biggest problem is that you do a List.map to get all the values that divide a, and then check if that list is empty. If you just changed that to a List.exists, you'd be done as soon as any divisor was found. Secondly, only integers are prime numbers, so you might as well do the whole thing as integer math since it's faster. If you need a floating-point version, just add a check that the real value is an integer and then call your integer version. Finally, there's no reason to generate your complete list of trial divisors as an whole object in memory. All you need to do is consume it once, not operate on it or keep it around. That's the textbook case for using a sequence instead. So putting it all together, here's what I'd have written: let isPrime2 a = match a with | a when a &lt; 2 -&gt; false | a -&gt; let divisors = seq { 2 .. int (sqrt (float a)) } not &lt;| Seq.exists (fun d -&gt; a % d = 0) divisors Again, there are fancier algorithms one could use instead, but that's my F# version of this particular algorithm.
Try searching for "Sieve of Eratosthenes in F#". E.g. http://rosettacode.org/wiki/Sieve_of_Eratosthenes#F.23 This is the oft-repeated (and [incorrect](http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf)) functional implementation of the sieve: let rec sieve = function | (p::xs) -&gt; p :: sieve [ for x in xs do if x % p &gt; 0 then yield x ] | [] -&gt; [] let primes = sieve [2..100] 
From a more theoretical perspective: use probabilistic tests such the [Fermat primality test](http://en.wikipedia.org/wiki/Fermat_primality_test). That's what the professor I had for my intro to discrete math class said, and [he's pretty good at factoring integers](http://en.wikipedia.org/wiki/Arjen_Lenstra), so...
Not really. A quotation is just an AST in f#. There are some good examples if you google it. Though I'm not totally sure how you'd do this but it may be possible 
When I see something like this, I typically ask, "What would the Haskell guys do?". In this case it leads to a very informative page on Haskell solutions, but most of this should translate pretty well: [Prime Numbers](https://www.haskell.org/haskellwiki/Prime_numbers)
Matching seems odd to me. Here is a simple version: let factorsof (n:int64) = let upperBound = int64(System.Math.Sqrt(double(n))) [2L..upperBound] |&gt; Seq.filter (fun x -&gt; n%x=0L) let isprime m = factorsof m |&gt; Seq.length = 0 You can shorten computation by only checking numbers that are 2,3, or 1 away from any number divisible by six, but I didn't do that here.
I'm a beginner and this is a dumb "tip" but I actually quite like defining let print x = printfn "%A" x; x since it can be inserted seamlessly into a string of a |&gt; b |&gt; c |&gt; d at any point.
Not my show; bug Troy on twitter :)
Seems to comeup every so often on the mailing list. Here is one, https://groups.google.com/forum/#!topic/fsharp-opensource/AX-Mwwe0fGI
Feed title shows as "The F# show logo" in iPhone podcast app
Is this really a good idea to measure execution time with DateTime functions? http://msdn.microsoft.com/en-us/library/system.threading.timer(v=vs.110).aspx
Here you go: https://itunes.apple.com/podcast/the-f-show/id951577378 And it's keeping on going :)
Thanks! It should be fixed now.
I'm on mobile so I won't be elaborating too much... but IIRC you might gain performance at larger numbers with a three case option: power is even, power is one, power is odd. You'll lose some of your tail recursion, but you'll be doing less string concats.
Here's a few options. If the source string is always going to be 1 character: let pow1 (c : char) (n : int) = new System.String(c, n) Otherwise, there is already [a function to do this](https://github.com/fsharp/fsharp/blob/master/src/fsharp/FSharp.Core/string.fs#L64-L71): let pow2 (s : string) (n : int) = String.replicate n s For a bit more flexibility: let pow3 (s : string) (n : int) = String.init n (fun _ -&gt; s) And one more: let pow4 (s : string) (n : int) = Seq.init n (fun _ -&gt; s) |&gt; String.concat "" 
This is perfect. Thank you.
Wow. Thank you for your detailed answer. I am new to .net, so this helps a lot
And, naturally, there's an F# room. http://jabbr.net/#/rooms/fsharp
No. Given how many "lightweight formal methods" were proposed and rejected by developers (the only formal method _ever_ adopted in programming are types), I'd like to see how this is different from all the failed ones.
Includes 4 talks on F#
I'm not aware of any. Real-world applications will probably need mutable state at some point. It's probably really inefficient to have all functional code. 
There's a book that was just released by Manning Publications called, "[F# Deep Dives](http://www.manning.com/petricek2/)" that addresses this sort of thing. Totally stealing the official summary here: &gt; F# Deep Dives presents a collection of real-world F# techniques, each written by expert practitioners. Each chapter presents a new use case where you'll read how the author used F# to solve a complex problem more effectively than would have been possible using a traditional approach. You'll not only see how a specific solution works in a specific domain, you'll also learn how F# developers approach problems, what concepts they use to solve them, and how they integrate F# into existing systems and environments. I just picked it up and, although I haven't read all of it yet, it seems like it's a good source for "real-world" projects and problems that were tackled in F#.
True. Even Scala's immutable collections maintain mutable internal state.
They are not referenced automatically, you need to use #r "packages/FSharp.Charting ...";;
I tried from different ways and I am still stuck on this. I am in the directory fhsarp fhsarp ├── hello.fsx └── packages └── FSharp.Charting ├── FSharp.Charting.fsx ├── FSharp.Charting.nupkg ├── lib │ └── net40 │ ├── FSharp.Charting.dll │ ├── FSharp.Charting.pdb │ └── FSharp.Charting.xml └── LICENSE.md 4 directories, 7 files I am in the directory: - #r "packages/FSharp.Charting ...";; #r "home/tux/fhsarp/packages/FSharp.Charting" ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/tux/fhsarp/stdin(11,1): error FS0078: Unable to find the file 'home/tux/fhsarp/packages/FSharp.Charting' in any of /usr/lib/mono/4.5 /home/tux/fhsarp /usr/lib/cli/fsharp/ &gt; and then I tried with absolute path: - #r "/home/tux/fhsarp/packages/FSharp.Charting" - - open FSharp.Charting - ;; #r "/home/tux/fhsarp/packages/FSharp.Charting" ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /home/tux/fhsarp/stdin(18,1): error FS0078: Unable to find the file '/home/tux/fhsarp/packages/FSharp.Charting' in any of /usr/lib/mono/4.5 /home/tux/fhsarp /usr/lib/cli/fsharp/ &gt; - I don't know if F# is mature enough on Linux. 
You need to put the path to the dll file itself. How did you do it on windows, if not like that?
You can do this: #I "packages/FSharp.Charting/lib/net40" #r "FSharp.Charting.dll" // (or just #r "FSharp.Charting", you can elude the .dll extension) I don't know how familiar you are with the .NET model of assembly referencing. Unfortunately it is designed to be convenient to use from an IDE but not really ideal for a REPL; assemblies from different packages are rarely put in the same directory so you need a new `#I` for every package you use. Still, there is the GAC (Global Assembly Cache), which is a system-wide set of directories from which you can directly reference assemblies (for example, try `#r "System.Web"`). You can install assemblies there using the command-line tool `gacutil`. It's quite uncommon to do that though, as the GAC is in theory meant for system assemblies, not stuff you use for development -- NuGet is meant for that. Plus you can only put strongly-named assemblies in the GAC, ie. assemblies signed with a cryptographic key. You can check [this page](http://www.mono-project.com/docs/advanced/assemblies-and-the-gac/) for more information.
Got it. What's the trick that makes immutable lists more efficient than immutable arrays?
So if I get this right, immutable linked lists are only more efficient if you prepend data on them, but for other manipulations (append, replace) you still need to do a copy, just as with immutable arrays?
We need to inflict some pain on those pragmatists. We need to start making fun of C# programs that run a computational intensive calculations in one thread. It needs to be the same kind of argument you would used to make fun of people who terminate a loop with an exception. It is really easy to write code that is not thread safe in idiomatic C#. Lets switch to F#, where immutability is idiomatic. 
Taking the piss is not the way to win people over and will result with "siege mentality". People have been sneering at PHP for years and yet it is still very popular.
Great article. I like the bell curve analogy. I think the pragmatists are going to flock to Swift though not (so much) because it addresses pain but rather because of Apple's 'reality distortion field'-style marketing, which touts every product as the next best thing since sliced bread. Of course, it doesn't hurt them that the Apple evangelists (the early adopters) have the 'cool kid' halo and when they push Apple's new tech, they have the benevolent hand of Apple supporting them. E.g. check out [this video](http://2014.funswiftconf.com/speakers/andy.html?utm_content=bufferbd18d&amp;utm_medium=social&amp;utm_source=twitter.com&amp;utm_campaign=buffer) where a Swift developer explains how to help your co-workers adopt a more functional style: target pain points and show them elegant, easy functional solutions. Another example of this was Microsoft's .Net platform and C# when it first appeared. MS was pushing .Net like no tomorrow and convinced the pragmatists that .Net was the way forward on the Windows platform instead of Java, and of course Mono worked out very well for them because they could point to it as an independent cross-platform implementation. The problem is MS is not doing the same thing today: they're not pushing F# as the way forward in programming .Net like Apple is Swift. They're afraid to cannibalise the C# business despite the pain points like concurrency and high ceremony/boilerplate. When Microsoft speaks, the pragmatist herd listens. Today, F#'s biggest competitor is not Haskell or OCaml or whatever, but rather C#.
I write scala/C# professionally and have dabbled in F#. I would love to see F# gain more market share, however, Scala is considerably more powerful than F# (until higher kinded types are added). I routinely miss them when writing C# (our new apps are written in scala), so I don't think moving to F# would mitigate it. I'm not trying to troll, but just letting you stand as someone who has used all three. If F# added that, I'd probably prefer it to Scala. 
&gt; They're afraid to cannibalise the C# business despite the pain points like concurrency and high ceremony/boilerplate. When Microsoft speaks, the pragmatist herd listens. On one SkillsMater webcast the presenter was stating they don't want to scare the typical business developers with strange concepts. Hence why F# is pushed for libraries instead of full blown .NET applications. The idea being gradual introduction into codebases for use cases where FP shines, instead of full breakage with existing code practices.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Persistent data structure**](https://en.wikipedia.org/wiki/Persistent%20data%20structure): [](#sfw) --- &gt; &gt;In [computing](https://en.wikipedia.org/wiki/Computing), a __persistent data structure__ is a [data structure](https://en.wikipedia.org/wiki/Data_structure) that always preserves the previous version of itself when it is modified. Such data structures are effectively [immutable](https://en.wikipedia.org/wiki/Immutable_object), as their operations do not (visibly) update the structure in-place, but instead always yield a new updated structure. (A persistent data structure is *not* a data structure committed to [persistent storage](https://en.wikipedia.org/wiki/Persistent_storage), such as a disk; this is a different and unrelated sense of the word "persistent.") &gt;A data structure is partially persistent if all versions can be accessed but only the newest version can be modified. The data structure is fully persistent if every version can be both accessed and modified. If there is also a meld or merge operation that can create a new version from two previous versions, the data structure is called confluently persistent. Structures that are not persistent are called [ephemeral](https://en.wikipedia.org/wiki/Ephemeral_(disambiguation\)). &gt;These types of data structures are particularly common in [logical](https://en.wikipedia.org/wiki/Logic_programming) and [functional programming](https://en.wikipedia.org/wiki/Functional_programming), and in a [purely functional](https://en.wikipedia.org/wiki/Purely_functional) program all data is immutable, so all data structures are automatically fully persistent. Persistent data structures can also be created using in-place updating of data and these may, in general, use less time or storage space than their purely functional counterparts. &gt;==== &gt;[**Image**](https://i.imgur.com/xrcVrm9.png) [^(i)](https://commons.wikimedia.org/wiki/File:Purely_functional_tree_before.svg) --- ^Interesting: [^Hash ^tree ^\(persistent ^data ^structure)](https://en.wikipedia.org/wiki/Hash_tree_\(persistent_data_structure\)) ^| [^I/O ^request ^packet](https://en.wikipedia.org/wiki/I/O_request_packet) ^| [^Persistence ^\(computer ^science)](https://en.wikipedia.org/wiki/Persistence_\(computer_science\)) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cng0mz7) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cng0mz7)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
It's a reference to https://en.wikipedia.org/wiki/Crossing_the_Chasm which in turn is based on https://en.wikipedia.org/wiki/Diffusion_of_innovations
and force the java shops to adopt the .NET run-time into their build and deployment process? probably okay if they're already using windows servers to host their services, but if they're a *nix shop, i really don't see this happening. not that running F# on mono is hard (we do this in production all the time), but it's just extra work- and for what? they can just use functional languages on the JVM without bringing in an extra environment. anyway, F# has completely lured me away from C#. i do most of my development in F# at work now (when i can).
&gt; Things like: Non-Windows ecosystem support http://fsharp.org/use/linux/ we run F# in production on ubuntu boxes in docker containers all the time. it's really not that bad.
well, i hear you on that. i do most of my F# development in VS on my windows machine, and i've been thinking of just installing ubuntu, but running VS on my host is too attractive to abandon.
&gt; MS don't include F# default template for web, Windows. WPF projects. Of course there are nugets, produced by 3-rd parties, and F# is very good for web development The Visual Studio for Web Express had F# support &gt; There is no F# Microsoft certification yet. Maybe F# is something that doesn't matter to MBA managers? &gt; Microsoft adds some functional features in C#: lambda, anonymous functions, immutable collections and so on. Mostly work driven by Erik Meijer. Drive FP to where mainstream programmers are, not the push them where they won't go. [Confessions of a used programming language salesman](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.118.2025) &gt; Roslyin only for C# and VB.NET compilers, not for F#. Roslyin main goal was to rewrite C# and VB.NET compilers in their own languages instead of C++. F# compiler was bootstrapped since day one.
&gt; misgivings about F# (mainly not mature enough and poor tooling - at least when compared with C#). he has those feelings when he's using haskell? that doesn't make much sense to me.
&gt;anyway, F# has completely lured me away from C#. i do most of my development in F# at work now (when i can). I'm the exact same way. I do a lot of embedded work but all my tools, proof of concept, etc has always been in something functional (scheme/racket/clojure). I just seem to get things done faster. Sadly no one in this company knows anything that isn't C/C++/C#. Lately I've been writing more Windows tools so I've been trying to use F# when I can. I'm hoping that someday we will accept it as a company supported language.
Use File.ReadLines instead of hand written function. Use http://nessos.github.io/UnionArgParser/ for argument parsing. Don't use sprintf for formatting large amount of data because it's relatively slow. Just concatenate strings or use String.Format. 
Also consider .NETs StringBuilder.
...in linewrite I mean.
Actually I'd go with OP's as your recursion is not tailrecursion and could cause problems.
I know, was kind of kidding. Just never seen that drastic of a difference between concat and printf in a language before. My code was originally written in Racket and I'd didn't notice much difference which I guess is a good and bad thing.
On this note: I love the book "Expert F# 3.0." At least for me, though, I've had to reread chapters 2-3 times to get them (especially in the later chapters).
kiteason's suggestion is very good, passing bools into the linewrite function feels very non-idiomatic to me. Note that you started using comments there to explain each case, but if you used a discriminated union these cases would have a meaningful name associated with them anyway making the code more clear without the comment. Also I'd use the verbatim string quoting with """ """ instead of a million sw.WriteLine's for your blocks of C# code.
I have not read it yet, nor do I even remember who recommended it, but I have a book titled [Real-World Functional Programming With examples in F# and C#](http://www.manning.com/petricek/) on my reading list. I've been lead to believe that it deals with what you are after however it isn't F# exclusive as it touches both F# and C#. You might have some luck finding reading lists that have this on them.
Look up "Expert F# 3.0". It has rationalizations for why various features are as they are. 
Probably the book you're looking for is [Functional Programming Using F#](http://www.cambridge.org/gb/academic/subjects/computer-science/programming-languages-and-applied-logic/functional-programming-using-f). I haven't read it myself yet but I've heard good things about it. 
There is an [Emacs binding](https://github.com/fsharp/fsharpbinding) that works on any platform Mono or Visual F# works on, and it's absolutely fantastic. You get tooltips, type annotations, autocompletion, error checking, sometimes I do my F# work using that instead of working with Visual Studio, as I run VS inside VirtualBox, and I can stay native by using Emacs. Visual Studio sometimes can get in the way, and the syntax coloring isn't as good as Emacs', even when you have F# Power Tools installed in VS. Honestly, the only thing I miss in the F# mode, in Emacs at least, is the ability to add files to projects. It's not an IDE, but it's *very* close. There's no debugger though.
Looks a bit verbose for my tastes - or maybe I'm reading too much in the business logic outside mandatory ASP.NET code
Bryan's comments not mine :-) He did say compared to C# - I guess he's been using Haskell so long that it's not a problem. Plus he's using it on *nix, not Windows.
Regarding 'don't talk about monad', I write a blog post on bad communication habits among FP fans recently: https://medium.com/@vivainio/functional-programming-dysfunctional-communication-1320b55c957f
This is an excellent blog post, I'll keep it around. However, it needs some copy-editing.
Apologies for hijacking, but here's what I wanted as someone who tried F# and eventually moved on. A text that: 1. Does not assume C#/Visual Studio knowledge. 2. Builds up from simple principles in an axiomatic manner. 3. Covers the latest features of the language. 4. Points out best practices. 5. Lets you know how often some feature is used. Is this something I really need to have down, or something I should file away for lookup when I come across it? 6. Has exercises with a website where learners can post solutions and talk about them.
&gt; do actual case studies I agree completely. I am writing a series of case studies as articles in the [F# Journal](http://www.ffconsultancy.com/products/fsharp_journal/index.html?reddit). The first one is about [porting a commercial compiler from OCaml to F#](http://fsharpnews.blogspot.co.uk/2015/01/porting-commercial-compiler-from-ocaml.html). &gt; Demonstrate that F# can be used to solve actual problems (not just toy CS-101 problems) and convince people that they can solve those problems in less time than by other methods. I have also lectured about this in the past. For example, [my presentation at F# in Finance 2014](https://www.youtube.com/watch?v=WI9bNWzTkxs). 
I didn't mind that label, because it gave me a word to succinctly explain how I've always approached programming ever since I was a kid -- that I prefer to use it as a tool for outcomes and results. So I liked the article, because I went "aha! that's me!" I tend to teeter between early adoption and pragmatism simply because I like to build a working piece of software.
&gt; this post from you did not make me feel great about the future of F# My gripe is really with the entire software industry. Web and mobile has taken developers back to the dark ages when it comes to tooling. F# is great whenever you can use it (and I still use it whenever I can) but it is not slick for web and mobile (yet). &gt; highly evident that you were burnt out on F# You noticed that? :-) &gt; other outside evidence confirmed your post was really your own experience and that F# has been trending upward on places like Twitter/HN and still an alive community I'm out of touch with the F# community now. F# hasn't been my primary work for a year now. I do market research on emerging technologies, mostly 3D printing. That said I do still use F# to analyse market data, do business analytics and for fun. Check out the first graph in [this article](http://www.idtechex.com/research/articles/the-3d-printing-market-boom-22-cagr-over-the-next-decade-00007191.asp?donotredirect=true). &gt; Case studies are great in that they provide a boost of confidence because others have successfully used F# My case studies are not all success stories. I paint an accurate picture of what happened on several real industrial software projects where F# was used. Most of my projects have succeeded but not all. When things went wrong I analyse how and why and make recommendations to help others learn from my mistakes. &gt; The F# Deep Dives book has been phenomenal in this regard. I am very happy to hear that. I shall tell the authors. &gt; it's highly apparent you're very talented with F# and have contributed a TON of value to the F# community Thank you. &gt; From what I've seen, the F# community is often committed to helping us noobs, and I've been trying to brainstorm ways to help build more of that momentum once I get a decent F#/FP foundation F# is a fantastic tool. Let me know if there's anything I can help you with. 
Why are people downvoting this? Really curious.

BTW, I'm looking to hire someone part-time with expertise in functional programming and / or game development to help work on the engine as well as a game with it. I'm available at bryanedds@gmail.com if anyone is interested!
Thanks for posting!
Thanks for the show! 
I haven't done much type provider development, but for the little I did I definitely felt that an API like this one would be much more convenient than the usual ProvidedTypes.fs.
Picked that up from this tweet: https://twitter.com/h0x0d/status/567484537135824897
Could you give a few concrete examples of very easy things made quite hard?
The point being *Microsoft*, I am well aware there are community efforts to fill the gaps for what should be Visual Studio standard features. Sure, even as library language F# is quite cool and I do understand Microsoft motivations in doing so, specially in the enterprise, their largest customers. I already have issues when talking with fellow developers about the few features VB.NET and C# got from the functional world, trying to make them appreciate the said functionality. Anyway, from all ML derived languages, F# is still the one with best tooling support. 
Sadly, I'm personally not impressed with F# show so far. Too few technical discussions, too many vague opinions how great F# is. [DotnetRocks](http://www.dotnetrocks.com/tag.aspx?tag=F) has done a better job discussing F# IMO, but The Haskell Cast is what I think showpiece of language-oriented podcast. Anyway, I'm happy F# show exist and hope it'll improve in future.
Just curious, when you say lack of tooling, what specific tools are you thinking of? I hear this complaint in the general sense (argh! bad tooling!) a lot, but looking for more specific details. I use F# mixed in with C# MVC for a web app at work, and also use F# extensively for any script/data-manip type work... maybe I'm just ignorant to what I'm missing?
Easy: - No integration with Windows Forms designer - No integration with XAML designers, although the new XAML type provider helps - No integration with Entity Framework code generation from database schemas - No code generator for XML validation - No support for Web Forms designers - Code refactoring, although the community extensions help Just some issues, not providing an exhaustive list.
How are projects managed? In the .NET world your main project is contained in an overarching container called a solution. This is the .sln file. If you were to make a java anlogy this is like the parent project of a multi module project. The .sln by itself isn't really anything, its just metadata. In the .sln you will have folders that contain .csproj files (c# project files) or for f# .fsproj. These proj files define a compilable unit, which is usually an assembly. An assembly is just a fancy word for dll, which is akin to a jar. They are compiled byte code. You can manage what kind of "assembly" you want by right clicking on the project in visual studio and going to its properties page. The types are basically either a dll or an executable. The "proj" file is an xml file that is managed by visual studio and contains the list of files in that project along with the dll's that project references. So if you have a project and want to put a dependency on fsharpx you'll see the dependencies listed there. Here i'll show you an example from an f# project I did that generates typescript locale files for an angularjs frontend. https://github.com/devshorts/TypescriptLocaleGenerator When you open it up you'll choose to open the sln file. When you open it up you'll see two "projects". Each one compiles into a separate dll. Notice the fsproj files in there. This is just the same as with c# projects, except they are csproj files. One thing thats not really idiomatic in this example is that usually you'll see a "packages.config" file in each of the project folders. This is like an npm style dependencies config thatyou can use to restore packages on build. In the project I linked you I just checked in all the dependent binaries with it. You'll see more often in other libraries that checking in binaries is a no no (oops, heh) The dependency "manifest" is managed by nuget. Here is some random repo I found htat shows the packages config https://github.com/kzu/NuGetReferences/tree/master/Demo/Backend. To restore the packages you can do that automatically in visual studio by right clicking on the top level solution item in the solution explorer and saying "resotre packages", or by running on the command line &gt; nuget restore Nuget.exe isn't always installed on macines so lots of repos will version it in a .nuget folder. Nuget has some configurations you can apply but like 99% of the defaults are what everyone uses. It may or may not work well under linux, I know that mono nuget support is ok (but not great) and xamarin studio doesn't like it that much but will work with some futzing (there are good tutorials out there). that said I haven't run into major issues using it on a mac (though I don't do that often). However, visual studio will work right out of the box is awesome. As far as what libraries and things to learn, unlike java and other languages the .NET core libraries are fucking awesome. Learn those. You will be at MSDN a lot, and their documentation is pretty good. For F# look into fsharpx, its probably the best library out there for augmenting the library. It will wrap a lot of the C# style things into more functional. I.e. you want to access a function on a string like "str -&gt; str" but in .net you have to access the string function directly off the string object. F# will give you helpers to do things more functionally, even though under the hood its the same. There are a couple of mental things you need to remember when leraning .NET by looking at c# and how to translate into f#. In F# the "Seq" type is mapped to an IEnumerable in .NET. It's basically just a lazy list based on iterators. There is no "List" in C# (the cons cell list in f#). But honestly a few googles will give you that. Does that help? I am totally willing to elaborate more on stuff if you have more questions
Now that the .net platform is open source do you think it would impact java in any way?? 
It really depends on what you are targeting. If you are going for desktop, then WPF with FSharp.ViewModule is a pretty good bet. Web, I usually use a C# project as the web host (Visual Studio seems to work better with C# web projects than pure F# ones), but all of the MVC / WebAPI controllers are in an F# class library. If you just want to hack something together for testing, WinForms is still the quickest way to get up and running and can be spun up from F# Interactive in a few lines of code.
&gt; If you are going for desktop, then WPF with FSharp. That seems to be Windows only... &gt; Web, I usually use a C# project as the web host (Visual Studio seems to work better with C# web projects than pure F# ones), but all of the MVC / WebAPI controllers are in an F# class library. You're talking about ASP.NET, right? I'm actually looking forward to Websharper, it's one of the reason why I'm picking up F#. From what I understand, that needs no C# wrapper.
If I were you, I'd set up Visual Studio in a VM so you can hit the ground running, and once you've written some toy projects, start looking under the hood. F# is an excellent introduction to .NET, you just have to be hands-on about it.
&gt; My biggest issue is that everything is written for people to whom .NET is familiar but functional is alien. My problem is that functional is familiar but .NET is alien and nobody seems to cater to that. This is exactly my problem as well. Augmented by the fact that so much of F# assumes that you are using Windows and VisualStudio. Maybe the people who are serious about expanding F# adoption should take this more seriously. I have zero desire to install windows, zero desire to learn about things that F# users use on Windows/VisualStudio that aren't necessary to use F#. I don't mind at all the idea of learning .NET, but so much of the published material on .NET is 100% intertwined with Windows/VisualStudio. If it isn't possible to build anything with F# unless you subscribe to the full Microsoft ecosystem (IDE, build system, runtime, etc), then the open source-ness of F# is nominal at best. 
True. Now that Microsoft is committed to make .NET a first class citizen on Linux and Mac, there's should be no barrier to bring us into the fold. Clojure and Scala have quite taken off and I think it has much to do with catering to other OSes too. F# has the simplicity of Clojure and the type safety of Scala (even better types I would think given it's not limited by the JVM's type erasure).
"Saying that Java is good because it works on all platforms is like saying anal sex is good because it works on all genders." There's no denying that .NET is technically a better platform than Java and a better host for new languages, in part because it didn't repeat Java's mistakes. But not being cross-platform was a huge drawback, especially since Windows is not as well liked on the server as Linux. Now that it plays nice on other OSes, it competes head on with Java which it never did before.
Thanks a lot! I never heard of any of those so I'm going to look into that!
&gt; No. Quite unlike the Java world then. Probably a good thing.
Hopac (instead of System.Tasks.Task), NodaTime (instead of System.DateTimeOffset), System.Net.Http.HttpClient (instead of System.Net.WebRequest), C5 (instead of System.Collections.Generic.*), Logary instead of System.Diagnostics, DotNetIO instead of System.IO. Alternatives. Don't use DateTime, btw, it will bite you.
Hopac looks really really bad for multicore parallelism. HttpClient looks good. Looks like an academic exercise. How is Logary better than .NET's own StopWatch? How is DotNetIO better than System.IO? 
Here's my initial thought member this.GetUsers request = let filterById q id = q.Where(fun user -&gt; user.Id = request.Id.Value ) let filterByUserName q userName = q.Where(fun user -&gt; user.UserName = request.UserName ) let mutable q = query { for user in datastore.Users do select user } if request.Id.HasValue then q &lt;- (filterById q request.Id) if not (String.IsNullOrEmpty request.UserName) then q &lt;- (filterByUserName q request.userName) (q :&gt; IEnumerable&lt;Users.User&gt;) One benefit to this would be the ability to pull these filters out elsewhere for reuse. Still a bit messy though.
Also, maybe (pun intended) this: let maybe (n : 'b) (f : 'a -&gt; 'b) (x : 'a option) = match x with | Some(x) -&gt; f x | None -&gt; n let maybeApply&lt;'a, 'b&gt; : ('a -&gt; 'b -&gt; 'b) -&gt; 'a option -&gt; ('b -&gt; 'b) = maybe id module Option = let fromNullable (n : Nullable&lt;'a&gt;) = if n.HasValue then Some n.Value else None module String = let nonEmpty (s : String) = if String.IsNullOrEmpty s then None else Some s let GetUsers req = let filterById id q = q.Where(fun u -&gt; u.Id = id) let filterByUserName name q = q.Where(fun u -&gt; u.UserName = name) datastore.Users :&gt; IQueryable&lt;User&gt; |&gt; maybeApply filterById (Option.fromNullable req.Id) |&gt; maybeApply filterByUserName (String.nonEmpty req.UserName) :&gt; IEnumerable&lt;User&gt; *Edit:* cleanup
I can dig it.
I might be too hung up on naming variables...
Notes: `maybe` is [Haskell's maybe](http://hackage.haskell.org/package/base-4.7.0.2/docs/Prelude.html#v:maybe) `maybeApply` is actually `Option.foldBack` (was not aware of this) PS: Haskell's `maybe` is clearly more flexible.
It is one of the hardest problems in computer science.
Thanks for all the great answers guys. It really helped me figure out the direction here. [answer context link](http://www.reddit.com/r/fsharp/comments/2wsfc0/entity_framework_linq_complex_queries/cotxqdw?context=2)
Ah, the phrase "erased types" makes a little more sense now
FWIW in Haskell where point-free style is more common, you often have a more descriptive type signature so good variable names aren't as necessary. E.g. isProperLength :: Message -&gt; Bool Where Message is a type alias or a new type or something more rich. You can do this in F# too, but I don't think it's so idiomatic. 
FWIW, I think proper IDE support is important when learning F# - esp. to see how the global type inference works (float mouse over variable to see the type). Debugger is also quite fast, which makes the development experience more 'interactive'
[**@tomaspetricek**](https://twitter.com/tomaspetricek): &gt;[2015-02-23 20:25:54 UTC](https://twitter.com/tomaspetricek/status/569956335430832128) &gt;[@fsibot](https://twitter.com/fsibot) let n,c=\(int 'D'\)\-65,String.concat in c"\\n"\[for i in\-n..n\-&amp;gt;c""\[for j in\-n..n\-&amp;gt;if abs i\+abs j=n then string\(char\(65\+abs j\)\)else" "\]\] ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/2wxee9%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
As others mentioned, getting into the .NET ecosystem is a lot of work, because it is so big. The good thing is that translating C# code to F# is usually pretty easy and so if I don't know how to do something in .NET, I often search for "TheThing C#" and translate the answer to F#. As for the project structure, F# has quite rich ecosystem for building, documenting etc. * [F# ProjectScaffold](http://fsprojects.github.io/ProjectScaffold/) is a project template that demonstrates a typical organization for an open-source library that is used by most F# OSS projects out there. * I did [a talk about this topic](https://vimeo.com/100960317) - although this uses Windows, it might be of interest and I also [wrote a blog post about this](http://tomasp.net/blog/2013/great-open-source/index.html).
Check out atom editor with https://github.com/jbtule/language-fsharp And/or https://atom.io/packages/script
My 2 cents: Maybe use a cross-platform build system like [FAKE](http://fsharp.github.io/FAKE/) on top of the command-line F# compiler `fsharpc`. MonoDevelop/Xamarin and VS work with MS Build scripts, which afaik are big XML files that I consider very unfriendly. You may have to go text editor-only because I don't think these IDEs can be trivially configured to build with FAKE.
Check out the [F# Community Page](http://fsprojects.github.io/). It's a great place to get an idea of what the community recommends. Specifically, look at [Project Scaffold](https://github.com/fsprojects/ProjectScaffold), a prototypal F# project following all recommended best practices for F# development. Cloning this project and then putting your specific source files in the appropriate subdirectories should get you started from the command line. You can also fork the scaffold project, customise it to your class's needs, and have the students clone your fork to get started.
Emacs has some pretty awesome F# plugins; last time I tried it had full Intellisense support.
http://fluentco.de is about to be in alpha, and will support F#. Maybe they'd be willing to organize some sort of educational discount? I suggest this mostly because my experience with mono develop was very poor, and this IDE is growing and they may have some discount for marketing reasons, helping you in the process.
/u/garciat is on the right track here. You do not explicitly call it out, but I am assuming you are creating projects for use in an IDE. That project has some portion completed, maybe some unit tests and there is a comment block somewhere that tell a student where to add code? I will assume the above is true in my reply. You can create a nice project in MonoDevelop or VS and set everything up as normal. you can then add a very trivial [FAKE](http://fsharp.github.io/FAKE/gettingstarted.html) script to allow for the project to build for people without an IDE. That script would require some very trivial instructions on pulling FAKE down as a nuget package. You could also provide that as a build.sh or build.bat for people to run as a boot_strap. This combination would let you give the IDE people the familiar world they want and let the text edit users work in *hard mode.* Most text users can bootstrap an environment anyway.
Maybe something like [iFSharp Notebook](https://github.com/BayardRock/IfSharp) would work well here.
The type provider idea came to mind, alas it's not an easy first target for me as of now, I'm just starting to use F# more frequently and implementing advanced type providers is not something I can quickly achieve (I needed the basic "more functional" idioms usable quick so I can work on scripts). I agree a type provider would rock and be refactoring friendly. Discussion just began about such a type provider on the mailing list: https://groups.google.com/forum/#!topic/fsharp-opensource/G9W5Gj5o_VQ someone started such effort: https://github.com/adamchester/DocoptNetProvider
It's times like these that I would literally consider murder (or at least assault with a deadly weapon) if MS would release VS for Linux and/or OS X. :P
Believe me, we're crossing our fingers very hard!
I'm not near my computer, so this is a semi-guess, but I used composition to make it happen: let applyIf (p:bool) (f:'a -&gt; 'a) (x:'a) = match p with | true -&gt; f x | false -&gt; x let filterWhere (f:'a -&gt; bool) (q:IEnumerable&lt;'a&gt;) = q.Where( f ) let applyFilterIf (p:bool) (f:'a-&gt; bool) (q:IEnumerable&lt;'a&gt;) = q |&gt; applyIf p (filterWhere f)
Thanks for the response. Glad it's just not me. What do you use and what is your workflow like?
Good news is, we won't teach UI in that class. :)
Is there a way to report those bugs to the Xamarin team? I'd love to see those issues fixed, since we'll probably be using Xamarin to teach F# starting in early 2016.
Could you not just use MSBuild/xbuild to drive the build from the command line?
So, my project builds exactly as it should in Xamarin Windows and the applications run fine (both the GTK and Console). I'm not familiar with deploying .Net applications (had trouble when I forgot to include FSharp.Core.dll in the config), but Xamarin can be configured to properly create packages that run on any platform regardless of the dev OS. *deploying not building
Yeah I feel like F# needs atleast code completion (for objects) and highlighting inferred types.
Thanks a lot for this! I'll keep it for future reference.
I'm pretty sure that the "workflow" syntax includes a case for monoids, using yield!.
Highlighting for inferred types? Like colouring for user types or?
There were some issues with the new semantic highlighting in ~5.6 they should be sorted out in the master builds now and filtering down to the release channels.
No problem! It's something I've been meaning to do anyways. Hope the F# class pans out.
Instead of storing file contents in a hash table, calculate SHA-1 of each file (and do not load entire files into memory, use FileStream and calculate SHA-1 incrementally).
From experience I know most programming chores are better put in async rather than data-parallelism, though. But you're wrong, it's not bad for multicore at all, it's just 10% slower than tasks, but not much. However, it's much better for programming async, which is what you do most of the time. C9 is academic yes, but it's not just an exercise. It's a fully-fledged collection library with many years of production use. It's not about the timing primitive; it's about how to make use of it in the end. Logary is a logging library as well as a metrics library. You don't get a usable metric from a measure without doing something with it; like giving it a unit, giving it a name/path or calculating aggregate statistics. A metric is aimed to provide intelligence into how your app is doing during runtime, and you can't look at individual data points for that. System.IO is only static invocations, meaning you can't unit test, mock or stub calls to such invocations. With DotNetIO you can. Also, there's no CLR-native transactional file system exposed with System.IO, but it is in DotNetIO. Also, with System.IO you can't easily replace side-effects with an in-memory file system, but you can with DotNetIO -- this makes it much easier to write self-contained services and apps.
I don't really follow this. Only framework I know is the .NET framework that I think of and use as a library.
Yes. Most people can get up to speed with F# in 1 month. **EDIT**: Some people here are saying I am wrong. Just to clarify: I've trained hundreds of people to use F# over the past 8 years including lots of Microsoft employees. I've trained people with no formal qualifications in software who had no prior experience of FP to write financial systems in F# and they got up to speed in 1 month. 
define "up to speed"? how far can you really go from 0 FP knowledge?
My experience: I'm a ~Junior-level .NET dev (full stack C#, MVC, SQL Server, etc., full-time for a bit over a year) It took me probably 40hrs of serious study to go from no FP experience to giving a talk on F#, and am currently building some fun side-project stuff. So I guess go off of the hourly estimate, and not the fact that it took me probably 6months to think functionally?
This is an awesome testament to F#. Thank you for relaying these experiences.
Thank you for your explanations. I thought F# was the best of two worlds, but from what you're saying it's just a world and then some (full imperative and a flinch of functional). That's a bummer.
Yes, and for cache locality the TPL is better; I'm just giving some pointers to things you can look into when designing e.g. HTTP server-side software and not number-crunching or algorithmic programs.
&gt; for cache locality the TPL is better Regarding locality, actually, the scheduling inside Hopac is specifically designed to exploit locality. When a lightweight Hopac job, running on a specific native worker thread, spawns new concurrent jobs (e.g. using [Job.start](http://hopac.github.io/Hopac/Hopac.html#def:val%20Hopac.Job.start) or [Job.queue](http://hopac.github.io/Hopac/Hopac.html#def:val%20Hopac.Job.queue)) or jobs are resumed via message passing operations, jobs are pushed to a stack owned by (or local to) the current native worker thread. In other words, work that originates on some native worker thread tends to stay on that worker thread and work that is touched by some native worker thread tends to continue on that worker thread. Also, work is done in LIFO or stack order, which gives better locality than a FIFO / queue. Hopac also does not preemptively switch out jobs unless they wait for something. This also improves locality. The scheduling approach is broadly similar to (but in detail different from) what parallel programming languages like [Cilk](http://en.wikipedia.org/wiki/Cilk) do.
You could ask Dave Thomas in Xamarin's issue track, where the relevant files are for highlighting fsx files. In a day or two you'd probably be able to enable highlighting for them, and your problem would be solved with a low time commitment.
Another idea: you could spend a while implementing a more scaffolding than what I already have in albacore: https://github.com/Albacore/albacore/blob/master/lib/albacore/cli.rb for modifying sln files or scaffolding a project from scratch (right now it just scaffolds itself into a project). Since albacore is easily distributable as a gem it's very easy to install on ubuntu.
I'll look into it. Thanks.
You can still improve this! type Rank = Pip of int | Jack | Queen | King type Card = Common of Rank * Color | Joker | ColorJoker Also, &gt;The above is not ~~sudo code~~ **pseudocode**. Finally, if you were to expand on this, you could add a few card games, for example Spades. When you do that I'd love to review your code :)
F# is great and people who discover it do get excited, rightly so. It's not all that rosy though, and using F# in real world poses some difficulties. A couple of points from my experience: The biggest pain is interop with C#: - it's full of difficulties and can be a real pain; - try using those cute F# domain models as MVC models, good luck; - the requirement for FSharp.Core.dll is a real pain and combined with VS/MSBuild bug is major deployment issue; - collections are incompatible between F# and C# (eg lists, maps); - records are great in F# but can't be used in the same way in C#; - Obviously curried funs in F# are a pain to use from C#. On F# language itself: - lack of tooling is astonishing in comparison to C#. Go to declaration, where used, basic refactoring like rename are all not there; - even code folding is not there; - async is in F# but it's a completely different beast from C# async. Obviously not compatible between each other; - the code can become really complexy really quickly; - you can write very little code but it's not necessarily more readable than C#; - lack of nulls? Ha! Try using core .NET libraries. 
Yes I have most definitely noticed the lack of tooling, this is however not the languages fault but I agree that it can make or break a language(especially when coming from c# and all the glorious tools). Like the post said I just scratched the surface. There are still many things that I need to explore before I will drop c# for f#. I am still not sure if this will ever happen. But I am sure that going through this process will make me a better programmer, regardless of what I end up using. 
Looks good. Got to give it a go.
The enums are needlessly put on multiple lines, for one. public enum Suit { Club, Diamond, Spade, Heart } public enum Rank { Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten, Jack, Queen, King, Ace } There goes 15 lines of code.
Fair enough
It's starting right [now!](http://channel9.msdn.com/) Thanks for sharing!
In addition to the enum's, in c# 6, instead of this: public class Deck { public Deck(List&lt;Card&gt; cards) { this.Cards = cards ?? new List&lt;Card&gt;(); } public List&lt;Card&gt; Cards { get; private set; } } You'll be able to write this: public class Deck { public List&lt;Card&gt; Cards { get; } = new List&lt;Card&gt;(); }
To give some credit back to c# I did the following * Put all the enums on one line, even though this is not convention * Auto initialized the lists (available in C# 6) This brought the line count for c# down to 55 vs 19 for f#. I then figured you can write everything on one line and that a word/character count might be a better metric. C# had 160 words and 1063 characters. F# 82 Words and 457 Characters. There is still a significant difference. I also feel the need to say that I still love c# and I think it is a great language. This post was less about c# being long winded and more about f# being really compact.
I think I can comment on at least some of those points: &gt;The biggest pain is interop with C#: &gt;* it's full of difficulties and can be a real pain; * try using those cute F# domain models as MVC models, good luck; Yup to some extent. Unfortunately if you want to expose some F#-specific functionality, you're better off creating a specific interface and maybe a reference implementation class that wraps F# logic. ADTs are such a mess when exposed to other CLR languages that - IMO - no one should ever do that. &gt;* the requirement for FSharp.Core.dll is a real pain and combined with VS/MSBuild bug is major deployment issue; Bundling FSharp.Core can be annoying, although you can *technically* link it statically using [`--standalone` and `--staticlink` compiler flags](https://msdn.microsoft.com/en-us/library/dd233171.aspx). It has its quirks tho'... &gt; * collections are incompatible between F# and C# (eg lists, maps); Default collections - yes, but technically those are *different* collections than default C# ones. They should be rather compared to BCL Immutable Collections. The only argument I'd have here is that they're unwieldy when used outside of F#, which ties back to first two points. &gt;* records are great in F# but can't be used in the same way in C#; * Obviously curried funs in F# are a pain to use from C#. Records are - arguably - the least gnarly F# piece that you can expose to other CLR languages. They just compile as immutable classes. The syntactic sugar is not there, but other than that they're fine. Add `[&lt;CLIMutable&gt;]` and you have regular DTOs outside of F#. Not too bad. Completely agree about curried functions, although I'm not sure how you could expose them in a nice way to C# - the language simply lacks support for that... For F# specific stuff: &gt; * lack of tooling is astonishing in comparison to C#. Go to declaration, where used, basic refactoring like rename are all not there; * even code folding is not there; Someone else already linked F# Power Tools and I have to say that plugin works well (e.g. CTRL+D to reformat current file). Of course it's nowhere near the level of tooling VS + ReSharper gives for C#, but bar is set really high here. Compared to most of other functional languages (e.g. Haskell, OCaml), I'd say the tooling is pretty good. Only IntelliJ Idea + Scala plugin is *comparable*. &gt; * async is in F# but it's a completely different beast from C# async. Obviously not compatible between each other; That's true to an extent. You can easily convert `Async&lt;T&gt;` into `Task&lt;T&gt;` using `Async.AwaitTask`. The ugly corner-case is turning `Async&lt;Unit`&gt; into `Task` - you have to jump over hoops because there's no `AwaitTask` for non-generic `Task`. How I wish `Void` was a regular type... &gt;* the code can become really complexy really quickly; I'm not sure I follow... Save from the fact that that can happen in any language, I'd say that most of the F# code I've seen was not really *that* hard to comprehend, but that's subjective. I'd appreciate a clarification on what you mean here :) &gt;* you can write very little code but it's not necessarily more readable than C#; * lack of nulls? Ha! Try using core .NET libraries. First is kind-of subjective and depends on the domain - some stuff is done in an easier, faster and simpler way in F#, other stuff in C#. As for nulls - it can become an issue when dealing with non-F# libraries and that's when a simple `Option.ofNull` extension can become really useful. You have to be careful, true, but any guarantee about non-nullness - even if only F# specific - is better than none. :) 
Some ideas: * A FFTW wrapper or more ambitious a separate Fast Fourier Transform library would be awesome. * A library for working with high-dimensional tensors. If you are coming from machine learning you might get excited about this. * Better libraries for expressing Probabilities and expectations. I am personally interested in this last one so feel free to PM me if you want to brainstorm a bit. Good luck, sounds like a fun project :)
A probabilistic programming library! [PDF](https://web.engr.oregonstate.edu/~erwig/papers/PFP_JFP06.pdf) Actually looks like Microsoft Research has done some work in this area: [Fun](http://research.microsoft.com/en-us/projects/fun/), a probabilistic programming language based on F#. But they decided ultimately to turn into it an Excel add-in. Maybe it would be fun (pardon the pun) to liberate it from Excel!
Also, I updated Xamarin recently and found that some of the IDE bugs have been fixed in regards to F#.
Oh, this is neat. I hadn't seen fun before.
While Math.Net Numerics is predominantly C#, [Math.Net Symbolics](http://symbolics.mathdotnet.com/) is a pure F# project. 
Here's my from-the-hip response to the 'no compelling technical advantage' point. Here are the technical features I find compelling: - Type providers - Immutability by default - Record types - Comprehensive libraries of higher-order-functions for collections - Forward pipe operator - Backtick naming - Computation expressions - Discriminated unions - Pattern matching - Concise OO class syntax - Strong typing - Type inference - Tuples - Custom operators - Powerful generics - Strongly typed string formatting - No 'return' keyword (last-expression returns) - Functions as first class values In case anyone might think that some of these are slightly theoretical: I use ALL BUT ONE of these features in the ONE SOURCE FILE (115 lines) that I happened to have open when I started typing this. The one exception to this is type providers: for that you'd have to move four feet to my right, where you'd find someone using type providers to solve a problem which would be an utter nightmare without them. I'd be fascinated to know how long the good Dr. spent evaluating F#.
Don't forget structural equality
&gt; Type inference The author of [the referenced article](https://jamesmccaffrey.wordpress.com/2015/03/01/why-i-dont-like-the-f-language/) explained he'd rather specify types explicitly, so he wouldn't consider inference an advantage. The guys sounds like a lot of other C# devs that I know who romanticize the days they spent writing assembly code. Their response to FP is usually, "Get off my lawn." Incidentally, I find this type of personality difficult to work with :)
&gt; definable 'this' naming That piqued my interest :) Do you have an example of definable 'this' being used in an advantageous manner? I tend to mostly just swap between using 'this' and 'x', not really enjoying either to a large degree... 
Oh nice! I was a bit jeleous of Clojure's ability to keep 5/3 as a fraction, and I see that with Symbolics you can by doing 5Q/3. And obviously way more than that. Very cool :D
If you take a look at his coding style in the articles he's written for visual studio magazine, you can see why F# would be a stretch for him. Edit: talking about the guy who wrote the original "why I don't like F#" article. 
The "I prefer to specify my types" crowd tends to shut up really fast when they find out that you can hover on names and see their types as a tooltip. Besides - if you want to specify your types, you're more than welcome to.
From the ref. article: &gt; But some languages, including F#, Prolog, LISP, and SQL, seem to fight me rather than assist me. Yeah. Four of the most powerful paradigmatic programming languages dismissed in a sentence. This says more about that guy than those languages. 
Well, this was an interesting one. Actually I was trying to deal with the fact that in F# you have to cast to the interface type to use the interface methods. My code goes something like this: type MyThing&lt;'T&gt;(arg : argtype) as this = ... // Cheeky! I'm shadowing 'this'. I could have used a different name. let this = this :&gt; IMyInterface&lt;'T&gt; ... interface IMyInterface&lt;'T&gt; with member __.MyMethod1(args) = ... member __.MyMethod2(args) = ... // Look Ma, no casting to interface type at call site: this.MyMethod1(args) |&gt; ... The point is that I could call MyMethod1 from MyMethod2 without casting this to IMyInterface at the call point. Otherwise the code in MyMethod2 got messy. There may well be an easier way! 
Oh, please please post links.
Still working on it privately but of course it will be open source. It shouldn't be difficult to get a version that supports dicts and structures as generated types. I will tweet you with a link when it's up =)
Didn't VB have the (non inferred) "Dim" keyword first?
Adding to already said here: the very existence of REPL in Visual Studio F# is a huge 'compelling technical advantage' over C#
As far as type providers are concerned, I'm on the fence, so to speak - if the data structure you're retrieving is relatively simple and regular, they work great and are really easy to use. But, for example, once you get to some really gnarly XML (especially with DTD and weird schemas), the providers fall short in my experience. Also I dumped a fully-fledged sample of XML document into a provider once (~400 or so lines of formatted XML) and the Intellisense was pretty much unusable (took too long to process on each and every autocomplete call, about 7 seconds each time you wanted to access a member on any provided type), even though the sample was inline string.
Gah, another one I missed. We must be well into the 30's now...
I've never had any major performance problems with the XML Type Provider. The largest file I've used is about 11 MB long and contains around 110,000 lines of XML, but its structure is fairly straightforward. 
11MB file for a sample? Yeah, that would be bigger than my string, I have no idea why it slowed down the IDE that much. I was using VS2013 with F# Power Tools, so nothing too fancy... Maybe I'll give it a try again in the near future, tinker with it and see what happens. I wish there was a way to generate the types from a schema instead of trying to assemble a representative sample, e.g. if element/attribute is optional, I have to have a sample of at least 2 parent-level elements, in one of which said element/attribute would be populated, in other - missing.
Yeah, I try not to talk about F# too much outside of F# groups online. I just let people know I'm using it and sometimes they ask why, then I can explain the benefits.
Actually, there are Functors and Applicatives. I found this code in a tutorial on FsCheck (must have been on fsharpforfunandprofit, I didn't keep the reference, sorry) let generateCustomer = createCustomer &lt;!&gt; generateName() &lt;*&gt; generateEmail() &lt;*&gt; generatePhone() &lt;*&gt; generateDate()
Stick with it. It gets better, and it's worth the wait.
Thanks. 
I'm not sure why you post this in the F# subreddit. Want to elaborate?
that's good for local scope, it still sucks donkey balls when viewing the code on the web or in a diff tool or something like that and you have to hindley milner the signature all by yourself. 
Is that often a problem for you? I've always used the VS diff viewer. I guess I can see a space for web-based diff tools with type inference.
Interestingly. This is the first time I've seen someone explicitly favor the Haskell style over the F# style. I personally hate it :0
Both. I don't like explicit type signatures except when they help constrain the code to make it more understandable, and I especially don't like type signatures that are separate from the code.
[F*](https://github.com/FStarLang/FStar) has an option translate in to an smt format which is used by Z3. That's about as relevant I could make it :)
Unless you're in a hurry, I'd wait until .NET is ported to Linux :)
Mono is quite decent! But I'm pretty sure it's not going to survive in its current form - why bother learning it?
what do you mean? learn F#, use mono to run it. your skills will translate to the MS .Net runtime just fine. i guess given that mono is a runtime, i don't see your point when you say "why bother learning it?"
I mean learning the tools related to it - xbuild, how to install it, etc. I remember setting up F# on my rpi some time ago, it was non-trivial and I ended up reporting several bugs to the package managers before I'd even gotten it up and running.
F# doesn't have higher order modules so you cannot parameterise one module over another. All you can do is copy and paste code by hand (which, for example, the OCaml compiler would do for you). However, it is not a major concern in practice.
And comparison, hashing, pretty printing...
Use tools to make sites like [this](http://fsharp.github.io/FSharp.Data/library/JsonProvider.html). 
&gt; What exactly? Explicitly writing out signatures that can be automatically inferred or is it just the syntax? I hate it because of the verbosity. I once analyzed Haskell source code for an OSS project and found that 30% of the code was taken up with type annotations that were not necessary. Complete waste of time and effort, IMO. 
A photo would've made a priceless response. 
&gt; And things not from that one file: - Functions like TryParse automatically sugared into functions which return a tuple. But the way this is done sucks because it boxes and makes illegal states representable. The result should be an option represented by a value type, not a tuple containing potential-garbage and a boolean. 
&gt; Do you have an example of definable 'this' being used in an advantageous manner? I use it all the time. If I am writing a `Queue` class then I call "this" `queue` because it is a reference to a queue. If I'm writing a `Heap` then I call it `heap` and so on. Much more readable than `this...this...this`. Also if I am ignoring it then I call it `__`. 
&gt; As far as type providers are concerned, I'm on the fence, so to speak... I've had similarly-bad experiences but type providers just became really useful for me in the context of exploring databases. I have a market research company with a big database full of information that we could be using to streamline the company but doing analytics was too tedious before I had F# and type providers. 
Tomas did incredible work, but it's not widely used and works only on websites you control (not on github), not in the terminal, not in emails etc. Allowing the signature syntax inside fs files would be a more universal solution 
&gt; no need to use redundant 'new' keyword (just call constructor) Interestingly, some F# code uses "new", and sometimes compiler / IDE suggests that you should use "new", without clearly specifying the rationale (something about IDisposable IIRC).
You might want to check out this first to get a feeling of how the type inference works: http://andrej.com/plzoo/html/miniml.html Each of the things you mention are pretty big language features. 
Ah, I forget to say that I already know a bit about type inference (and not care about it at this stage at all)... but thanks for the link &gt; Each of the things you mention are pretty big language features. But could be considered more critical to have than type inference (type inference is more a assist tool than a critical part of the language IMHO)
This looks like a really nice book. Is it self-contained from someone with beginner knowledge in FP + F# and intermediate knowledge in OOP and C#?
I give a fast read but don't see where it talk about how build a type system. However, it say about other parts of the compiler that are interested, so thanks for the input.
I actually prefer to call it "throw-driven development" because then it has the popular acronym TDD. Anything labelled as TDD must be an instant success!
I wish I could use FSPowerTools at work, it doesn't handle 360k LoC in a single solution very well. Makes VS completely unusable. I hope they work on improving the performance of it at some point.
I implemented A* once using this site : [Introduction to A*](http://www.redblobgames.com/pathfinding/a-star/introduction.html). Good explanation of every steps needed to understand the implementation. As for the grid, in my case I used something like this type Position = int * int type Content = (* whatever you want here *) type Grid = Map&lt;Position, Content&gt; 
Huh, might I ask what kind of F# project (solution?) are you working on that's nearing 0.5 MLoC? I'm just curious :)
The F# community is relatively young compared to other languages. Now that you've identified a gap in the F# community, how do you think you would improve it? F# has an unusually strong group dynamic in that many of its language users find ways to contribute back to F# where they identify targets for improvement.
I've always found [fssnip.net](http://fssnip.net) and StackOverflow to be the best locations for examples and help. "Real World Functional Programming" by T. Ptacek and "The Book of F#" by D. Fancher are good resources too. This Reddit forum has readers who will reply if you post a quality question. F# is growing in mentions on Twitter and HN, so you're definitely onboarding a rising trend. Every new technology has that early phase where hard work has to be done and things aren't going to be given to you nicely-packaged and hand-delivered in a neat and tidy library. It's not a chicken and egg problem, it's a we-programmers-are-lazy-and-want-everything-easy-and-free problem. At some point *somebody* has to come along and do those 10 hours of hard work so everyone else can have their 1 hour of easy learning. So why not you? You seem knowledgeable on what constitutes quality documentation, so I would encourage you to lay the groundwork on how future F# programmers can write/improve their docs. F# is on that track to becoming tidy. It's got a mature foundation with fairly mature extended libraries. Toolchain is still coming along. Documentation is really last in line but is improving. What else do you do at work when something isn't documented? Break down the code and you're rewarded with far more intimate understanding.
Thanks for the response. I'm so used to writing code using vim that I haven't really had any experience with IDEs at all, including how to get at the xml docs and how all of the intellisense works (is it still called intellisense if I'm not using VS?). I didn't realize that I could get a lot of information out of that, although it still is pretty rough for me to understand the reasoning behind the api decisions by looking at docs for individual modules or functions. . I'm trying to understand a lot of these libraries because I want to do some mobile gui programming (which is completely new to me). I have a ton of experience with functional languages, but it seemed like all of the standard xamarin practices for creating mobile apps was with very object-oriented MVVM frameworks and C#, and so I wanted to see what sort of api/functionality I could find in some of the more F#-centric wrappers. I may not end up using these libraries, but I'm hoping to explore what is available and what is intuitive. Ideally I'd like to find some solid examples of using F# Agents/MailboxProcessors as ViewModels. The idea of using actors in a state machine style just seems like the perfect abstraction for an interactive UI (have you ever met a UI, computer or not, that couldn't be described as a state machine?). If that is possible, I'd like to see how Observables fit into the equation. I like the idea of being able to query over events, especially with buffers, etc. 
This sucks - one of the reasons why we created ProjectScaffold is to make it really easy to write documentation. There is quite a lot of projects under the "fsprojects" repo where this worked - and they have excellent docs. Sadly, none of the projects that you mentioned used this. Not all open source projects are perfect and pretty much all of them need some contribution - so if you're interested in one of these, you can explore the project in other ways (using IntelliSense, looking at the tests, etc.) and contribute some basic docs yourself! That would be awesome and I'm sure the maintainers would be really glad for this. There is a guide on writing docs here: http://fsprojects.github.io/ProjectScaffold/writing-docs.html
I've also been looking to learn F# proper, and I've considered reading [The Book of F#](http://www.nostarch.com/fsharp). Does anyone have an opinion on it and how it compares to the books already mentioned? Edit: Oops, somehow I stumbled upon 4 months old topic... Sorry.
Do you have Intellisense?
Very interesting and a great idea but disappointingly puritanical. * Union types and pattern matching are just as important as functional programming in F#. * "Learner...you often need to use mutability and OO idioms" is wrong. Professional F# developers often need to use mutability and OO idioms like `IEnumerable`. That does not make them "learners". * "Expert...very comfortable with monadic code and computation expressions" is wrong. In 8 years of professional F# development in industry I have never once seen or used monadic code or written a new computation expression IRL. Learners do such things because they have yet to learn how damaging it is to shoehorn obtuse academic things into production code. * "Functional but can be tweaked to perform well". By implying functional means slow, this assumes the Haskell definition of "functional" as side-effect free. Functional is not always slow. In F#, `inline` lets you write higher-order functions with no performance penalty. * "Immutable by default". The most fundamental data structure, arrays, are not immutable by default. The whole thing smells of Haskell. 
Explain what you have tried
I wonder where they have courses using F# in the world! :)
I tried a lot of things, code from Stack Overflow and snippets of code from various sites... sadly, this course forced this language onto me without instruction as a "learn this language on your own" requirement. Like seriously, not even in the book or talked about once in class. Well, either way it's over now. Thanks though!
Yep, that was the idea I was trying to implement. Just couldn't make it happen. Thanks though. 
Thanks for the reply. :)
That sounds kind of horrible. I've been learning F# by building a (soon-to-be) large scale project. I've been working on it in my spare time for several weeks now and I'm just starting to get the hang of how the language really works and settle in on patterns that I like. All of that work that I did while learning F#? The state of the project right now? I could have done it in an afternoon or two if I had used C# simply because I have more experience with it. "Go and learn" is great. "Go and learn with a deadline and zero guidelines" is not.
Thanks man, that's very kind!
So true. That's exactly how I felt when I was trying to iterate variables for a loop, or even make it read a simple file... in c++ it woulda taken twenty minutes. So frustrating. Thanks for understanding. It's nice to know I'm not just stupid as hell. 
if you put code that didn't work here, we could point you in the right direction, if you just say it doesn't work we have no way to help you understand.
Does anyone have concrete examples of how the limitations of erased type providers show up in real world scenarios? And where's the literature on generative type providers - I've never found it!
Tip of the hat to the ready-made solution: https://github.com/nessos/UnionArgParser
Very freaking useful. I use it in a lot of places. I had to write a filesystem-ish kind of library, so I had units for page, byte, pointer (page pointer/byte pointer)... Saved my bacon more than once. Now if only strings could also have units of measure.
I use units of measure for all life threatening calculations - nobody has been hurt yet and it helps to keep the lights on in the UK: module UnitSymbols = /// a synonym for halfhour, a unit of time [&lt;Measure&gt;] type min = minute /// a synonym for halfhour, a unit of time [&lt;Measure&gt;] type hh = halfhour /// a synonym for hour, a unit of time [&lt;Measure&gt;] type h = hour /// a synonym for kilowatt, a unit of power [&lt;Measure&gt;] type kW = kilowatt /// a synonym for megawatt, a unit of power [&lt;Measure&gt;] type MW = megawatt /// a synonym for pounds sterling, a unit of currency [&lt;Measure&gt;] type ``£`` = poundssterling /// a synonym for pence sterling, a unit of currency [&lt;Measure&gt;] type p = pencesterling /// a synonym for hertz, a unit of frequency [&lt;Measure&gt;] type Hz = hertz /// a synonym for gigajoules, a unit of energy [&lt;Measure&gt;] type GJ = gigajoule /// a synonym for tonne, a unit of weight [&lt;Measure&gt;] type t = tonne /// a synonym for therm, a unit of energy [&lt;Measure&gt;] type th = therm /// a synonym for MVAr, a unit of reactive power [&lt;Measure&gt;] type MVAr = megavar /// a synonym for resolutionperiod, a unit of time [&lt;Measure&gt;] type RP = resolutionperiod
It goes at compile time, but it doesn't just generate structured data as types, it also generates code (methods on these types).
this helps? * http://www.mindscapehq.com/blog/index.php/2011/09/19/f-type-providers-as-if-by-magic/ * http://www.developerfusion.com/article/145919/an-introduction-to-f-type-providers/ * https://vimeo.com/49045879 * http://www.roundcrisis.com/2015/02/22/Type-providers/
&gt; Now if only strings could also have units of measure. How would that work?
Not yet. I want to evaluate it one day, but for now I don't really want to change the deployment and CI settings because deadlines :)
Sorry if I'm being obtuse, but how are those units of measure?
What version of Nuget are you using? There's a known with F# and the package manager console issue that was fixed in 2.2: https://docs.nuget.org/release-notes/nuget-2.2 Edit: sorry, didn't see your nuget version in there 
I am curious why you decided to learn F# as first language. Not that there is anything wrong with it but that's an uncommon choice. I wonder if there are benefits to learning a functional language first. Any thoughts F#'ers?
ohh i like to do things differently than others. I like to be unique and Fsharp is relevantly new in my opinion. And because its hard to make bugs with F# which is a huge plus for me cause I want to limit the times I get angry or frustrated. I heard it was good for algo trading and the pipe seemed very logical for me for what I want to do I heard its good for machine learning but then I heard thats hard to implement with algo trading I also enjoyed to hear that I'll probably be using less amounts of code smaller simpler and less is better from what I've experienced in this world so far what do you think? 
You are absolutely right. F# will most definitely help reduce the amount of code and the number of bugs compared to an OO style language. It's just that I never considered recommending F# (or a functional language, to be more specific) as the language for someone new to programming, so I was a little surprised. But good for you. Hope it goes well. 
They're compiler plugins that generate .net assemblies from structured data (eg. Wsdl schemas) at compile time. The types can be generated (ie. embedded in the assembly and used in other projects) or erased (no runtime type information). So type providers are a bit like code generators that are automatically hooked into your build script via the language. Very interesting and useful. Just another couple of examples: there are type providers for regular expressions and SQL queries. These are extremely useful since they allow you to statically reference things like regex groups and record columns without writing custom types by hand.
We don't use F#, but the company I work for builds software for public works, and there are units of measurement all over the place. We have to handle the conversions ourselves and it requires quite a bit of diligence. F#'s units would be insanely helpful.
I started using spacemacs about a week ago and I think it's great. However, I've been unable to get my F# formatted like the examples on this site or [here](http://fsharp.github.io/FAKE/). Emacs always wants to align everything up to the parenthesis. Does anybody know how to get F# code more left aligned in emacs? [Example](http://imgur.com/3JbYZ3T)
I think it does that because the F# style guide recommends aligning code like that. I also really hate it, and would be delighted if I could have Emacs just give me 2- or 4-space indentation on everything.
He talks a lot about how cool it is -- I haven't seen anything he's done with it though.
[**@ashic**](https://twitter.com/ashic): &gt;[2015-04-25 07:24:00 UTC](https://twitter.com/ashic/status/591865226301206529) &gt;If [@Microsoft](https://twitter.com/Microsoft) is serious about its [#oss](https://twitter.com/search?q=%23oss) community, it can show it by giving [#fsharp](https://twitter.com/search?q=%23fsharp) first class support. //[@scottgu](https://twitter.com/scottgu) [@shanselman](https://twitter.com/shanselman) [**@sforkmann**](https://twitter.com/sforkmann): &gt;[2015-04-25 07:46:21 UTC](https://twitter.com/sforkmann/status/591870849113837568) &gt;[@ashic](https://twitter.com/ashic) Hehe. Good luck with that. [@Microsoft](https://twitter.com/Microsoft) [@scottgu](https://twitter.com/scottgu) [@shanselman](https://twitter.com/shanselman) [**@ashic**](https://twitter.com/ashic): &gt;[2015-04-25 07:57:00 UTC](https://twitter.com/ashic/status/591873528712007680) &gt;[@sforkmann](https://twitter.com/sforkmann) that response reflects how bad the situation actually is. //[@Microsoft](https://twitter.com/Microsoft) [@scottgu](https://twitter.com/scottgu) [@shanselman](https://twitter.com/shanselman) [**@shanselman**](https://twitter.com/shanselman): &gt;[2015-04-25 07:59:55 UTC](https://twitter.com/shanselman/status/591874264015310849) &gt;[@ashic](https://twitter.com/ashic) [@sforkmann](https://twitter.com/sforkmann) [@Microsoft](https://twitter.com/Microsoft) [@scottgu](https://twitter.com/scottgu) What do you mean first class? It ships with VS. It's pretty well thought of. ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/33wo5q%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
I'm new to F# (from Scala/Java world), and have been very surprised by the lack of support for F# in VS. The first thing a new user sees is the lack of project templates for F# in comparison to C#. Those can't be hard for MS to add. What kind of message is that? 
Do people really use project templates though? I don't think I've ever used one, in any language!
What kind of stuff do you work on?
I've done four internships and some hobby coding. At work, I tend to work on established projects; at home, I just write everything from scratch.
Surely MS supports F# more than Oracle does Scala?
I think SQL type provider is a very concrete example that people are likely to need. You can write EF-like code without any mapping classes, with full static checking.
Well, yeah? But Scala is not Oracle's product. 
Well I did say I left Scala, did I not? :) Seriously, not trying to down F# so much as suggest an *easy* way that a new user's experience could be much improved. We don't need to compete for who's *worse*.
The difficulty is that Microsoft has very heavy validation processes. That's quite understandable, they sell stuff for a pretty penny so they want it to be heavily tested, plus they need to translate everything in dozens of languages, etc. But it means that "weekend code" is very hard to get integrated into a final product. Best of luck nonetheless, we need people with dedication to make things happen :)
It sounds like your app doesn't have a console window. How are you launching it?
Oh just trying to run it from within Visual Studio. You select the code and hit alt-enter. You'll forgive me, I have a Comp Sci degree, but we didn't even learn C++ back then. lol Assembler, COBOL, Fortran, etc, I can do. Trying to learn F# and the biggest hurdle seems to be understanding how the tools themselves work. Worked as a lawyer all this time, so I got a bit behind. lol
When you do alt enter it executes the given code in the immediate window. If you need to use Console code you need to execute the program with F5.
[**@shanselman**](https://twitter.com/shanselman/) &gt; [2015-04-27 07:56 UTC](https://twitter.com/shanselman/status/592598227263758338) &gt; @ArgesRic they're reading too much into the tweet. They also underestimate the work required. Our teams are smaller than folks realize. Thx. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Incredibly useful? Not really, since you *can* code around it, but they bring in an extra measure of safety to the application. In the end it will depend on your application and needs. For example, it would help a pharmacy application: [&lt;Measure&gt;] type = cc [&lt;Measure&gt;] type = dram and then you can define your conversions let ccPerDram = 3.6966912&lt;cc/dram&gt; let ccToDram (x:float&lt;cc&gt;) = x / ccPerDram let dramToCc (x:float&lt;dram&gt;) = x * ccPerDram Now you just have the measurements annotated so you always know whether you're working with drams or not, and things get a bit safer.
You might like this. I did it on the Plane on the way to BUILD http://www.hanselman.com/blog/RunningSuaveioAndFWithFAKEInAzureWebAppsWithGitAndTheDeployButton.aspx
&gt; Most of the F# community uses a NuGet alternative called Paket Never heard of it. :-) 
Cool. What's the main advantage over Nuget? 
I think the C# version would look better if it was written using Where() followed by a Select().
One of F#'s obvious strengths (relative to JAVA) is parsing. It's a core CS concept that'd probably be right in your wheelhouse as a 2nd year. If you're interested taking on a project involving some sort of parsing working, the FParsec parser combinator library would provide a really good learning experience, and it would set you up for a course on compilers. The other strength is DSL design. Tomas Petricek has posted [a fun example of a DSL for 3D Modeling](http://tomasp.net/blog/2014/composing-christmas/) on his blog. Great for beginners. You might check out the rest of his blog, http://tomasp.net/ for more ideas.
A compiler.
Try writing a symbolic differentiation package. That's one application where F# absolutely blows Java out of the water - you might be able to write it in 10x fewer lines of code than you would need in Java. Basically, use a sum type to represent functions. type Equation = Const of float | Mult of Equation list | Add of Equation list | ... Then, write a function which recursively applies differentiation rules to a value of type Equation. Should total a few dozen lines of code. Also, try writing a trie data structure with insert/remove/find. Reference implementation at http://github.com/lilred/trie-fs (though there currently is a bug with the "find" function base case, which I'm going to fix as soon as I get home.)
You might consider working through Real World Ocaml. It might help understanding the approach vs minor syntax difference. Once you get functors chapter you should probably stop though if f# is your desired path. 
I think that was actually for Atom editor, of which Visual Studio Code is a derivative. I've been working off an on getting VSCode going for f# as well, and I think all we have to do is define the msbuild task in .settings/tasks.json, and then define one or more launch configurations, so you can say 'debug' and have stuff actually happen. If you want to go at it, take a look at the documentation sections for [Debugging](https://code.visualstudio.com/Docs/debugging) and [Tasks](https://code.visualstudio.com/Docs/tasks).
F# supports the same OOP concepts as C#. I believe GUI is more difficult because the GUI design tools Winforms/GTK# etc. seem to be only written for C#/VB.net. So there would be manual instatiating forms and buttons and such if you're doing pure F#.
Vote for it at https://visualstudio.uservoice.com/forums/293070-visual-studio-code/suggestions/7756026-f-great-support
Also, homebrew contains an fsharp package. Doesn't give you VS, but then you don't need a VM. 
 Xamarin Studio, even without the paid subscription has excellent support for F#.
Good info, but a slightly misleading title. This isn't F# "on a Mac" using Windows 10, this is F# "on virtualized Windows, on a Mac". I don't think there are many developers unaware that virtualization options exist... Parallels makes for a nice development and VM management solution, too. Xamarin studio will have you up and running quickly with a native app. Portable F# apps living in platform-neutral Docker containers is the dream, IMO, once .Net Core and Windows 10 settle in a little.
In my opinion, the fact that Scala is a "third party language" is an advantage. This is a clear philosophical difference between the JVM and the .NET worlds. You see, in the JVM world nobody uses Netbeans as everybody is on IntelliJ IDEA or Eclipse. In the JVM world it matters much less what Oracle is doing. Languages like Scala and Clojure have really strong communities without any Oracle involvement whatsoever. In the JVM world a third party to both the JVM and Scala (IntelliJ) is providing support for Scala in the best IDE ever made. In the JVM world there is no conflict for the makers of Scala when promoting it over Java ;-) You see, Microsoft has no real incentive to promote F# over C# and what will happen if Microsoft's interest in F# goes away, like when they stopped development on IronPython and IronRuby? Well, IronPython is barely alive and IronRuby is dead. Compare that to what happened with JRuby.
Well, I am allowed to use F# as it is part of the Microsoft stack, even if for small scripts and own workstation utilities, whereas I doubt I will ever use Scala at work. Our customers don't really like third party tools and most of their IT tends to control what software is available. So unless their IT accepts Scala, it won't land on my workstation. I do use Netbeans every time I am allowed to choose. Way better integration with Ant and Maven than the other IDEs and not so resource intensive as InteliJ. Its features for Swing/JavaFX UI design, profiling, and HTML/CSS/JavaScript/Java two-way integration are just great.
Hi, I tend to like #1 approach as well. Though if you need more advanced scenarios (health checks, auto restarts etc), take a look how it's done in Akka.Net [http://getakka.net/docs/concepts/supervision ](http://getakka.net/docs/concepts/supervision)
big fan of F# here, but a couple of things why the Go comparison is possibly a false one. first, Go was a Google initiative, and Google has a lot of fans out there. people will pick up Go because it's cool. MSFT doesn't have that same fanbase, that same interest. you saw a lot of people adopt C# back when it launched but at the time the MSFT community was largely unique in that regard. second, F# is a functional language, while Go is an imperative language that has largely subsumed peoples' former use of C - it's not a complicated jump for most people - and meets their common needs for portability and speed. again, comparing to the more widespread love of C#, it's OOP, which people are familiar with, and better than Java in many eyes (mine included). back to FP, people adopted scala but only because a) you could still write Java in it, and b) it was better in terms of modern features than Java before Java8. that's my take on why F# hasn't yet taken off and why it's unlikely to. again, i really like F#, a lot. i just see the above barriers remaining to widespread interest. 
&gt; Are there really that many F# developers who aren't also competent in C#? Knowing F# helps you write better C#.
&gt; I'm not sure, however, that I can find even a team's worth of C# developers that will write me a gourmet medium-rare pan-seared Ribeye with Vermouth-glazed Mushrooms and Curried Bacon Haricots Verts. With F#, or any ML-descendent for that matter, I do have that confidence. Bit of background on my .Net experience: I've done a large amount of C# over the years, only tinkered with F#. I still use C# for gamedev, but currently working in Clojure for things I used to use C# for. Horrible programmers can write horrible code and horribly structured applications in any language. It is true, however, that having a lower barrier of entry will likely mean that you're getting more applicants that you'll have to sift through ([a large percentage of which will likely be bad](https://en.wikipedia.org/wiki/Sturgeon's_law)) but I don't particularly see anything about C# that encourages people shooting themselves in the foot. Maybe C# does make it easier for people to fake knowledge initially, since it's more familiar. Maybe since there are more resources out there, it's easier to run into people who are able to pass a competency Turing test when they're nothing but a coding Chinese room (I've run into my share of those). But I suspect a lot of this comes out of the popularity of the language and not the language itself, since getting into F# right now requires more effort than getting into C#, and anyone who has paid the learning toll likely did it out of true interest. Now we only need for F# to get really popular so we can see if that suspicion is right or wrong.
Redmond recommending F# for existing C# developers is quite unlikely to happen. It would be a risky move that wouldn't be backed up by current state of tooling (e.g. all the C# features in VS, Roslyn, asp.net, documentation). F# advocacy will need to come from outside MS for the predictable future.
So if F# is allowed at your place and not Scala, that's fine, but I'm not seeing this as something that happens because "*it's from Microsoft*". I understand that there needs to be a commercial entity available for providing support, but Typesafe is just as good as any, plus the beauty of open-source is that it never dies. Well, maybe in the .NET ecosystem you do need the Microsoft stamp as a matter of culture, but either way, you still have to find F# developers or train people in F#, you still have to make a leap of faith, so I don't think F# is routinely accepted at your average .NET shop more than Scala or Groovy or Clojure are at your regular Java shop. Scala is allowed at other places. I've been working with Scala full-time for the past 3 years. Right now we are contracted for a project of a big multinational and the higher-ups wanted Java, but we convinced them to go with Scala. All it took was good salesmanship :-) Granted, the presence of Typesafe on the market makes this easier, but again, it doesn't have to be Oracle. On Netbeans, you're really missing out. I haven't felt that IntelliJ IDEA is too intensive, my Macbook only has a Core i5 and 8 GB of RAM, which by all counts is a very modest setup for a developer and it's been working fine for the last year. IDEA can do web stuff, it can do Python and Ruby, it can do Scala, Clojure and Groovy, it has integration with all kinds of frameworks including Play and Grails, it has integration with Maven, SBT and Gradle, it can do Android development, soon it will do C++ as well (CLion is in beta). To make Visual Studio smart, people buy ReSharper, from the same folks that make IntelliJ IDEA ;-)
Getting permissions to install stuff on your work computer sucks, though I understand it is common practice in some organizations. From this point of view F# does have an advantage, though with other languages it's not like you're asking for Skype :-) I also prefer smaller, more dynamic companies, otherwise for big corporations I end up working as a contractor, precisely because I have more freedom to move between projects, or to use whatever tools I want. There are many downsides to startups or to contracting work, but at least you don't have to suffer from policies that are dumb as fuck. So it's pretty funny going with a Macbook on top of which I have Ubuntu installed into a room filled with people that have severely restricted Thinkpads.
Now if only it worked for ATI/AMD as well this would be perfect.
I will ask Bryan to upload the slides and update the meetup page and here with the link
My 2 cents: If you're new to Functional Programming (FP) but have a strong base in Object-Oriented (OO), you can try using ASP.NET WebAPI 2. (I wrote a short [tutorial](http://garciat.com/2014/09/11/minimal-web-api-2-fsharp/) a while back. All you need is MonoDevelop.) You can then host a Single-Page Application (SPA) on Apache or something and hit your F# API via XHR (see: [CORS](http://www.asp.net/web-api/overview/security/enabling-cross-origin-requests-in-web-api)). With this approach, you can start writing OO-style F# code and progressively move towards more FP-style F# code. If you're comfortable with FP, try [suave.io](http://suave.io/). I haven't tried it yet, but it seems quite functional (as in FP). Mono is quite simple to install and set up. Most Linux distros have it available as a ready-to-install package. Have you had any particular issues?
I enjoy F# very much! That said, I'd recommend any new programmer that wants to GetThingsDone™ to just learn web programming: HTML and JavaScript (JS). You can use both to write applications for the three main Internet platforms: browser, server, mobile. (server = Node.js; mobile = Apache Cordova) Yes, your code will be very ugly and full of bugs. But remember: you want to GetThingsDone™. No amount of perfect code can rival an app that JustWorks™. So go forth, learn JavaScript, and build apps!
Yes, F# is a great language to start with. I am teaching my son programming using F# in Visual Studio and I have used F# professionally for over 8 years.
The good thing is Visual Studio Community Edition is free, and it comes with support for a few languages out-of-the-box, so I would recommend trying some C# or C++ along with it to get a better exposure to programming. Best thing to do is check the Microsoft docs; they have tutorials and are a complete reference for everything about the languages and libraries.
is it possible to use F# without VS and on *nix platform?
If I am not using windows and vs, would you recommend me f# or ocaml? Also what's your opinion on f# vs Scala? Which one is easier ?
Yes it is. The usual and easiest way to go is using Xamarin studio (aka Monodevelop on Linux).
Something more in the style of django/flask? I found ServiceStack but is commercial-only now. 
It's definitely a miscommunication. You can also make universal ~~web~~ apps in F#, JavaScript, etc. Source: Microsoft intern currently developing a~~n~~ universal web app in F#. E: terminology
I did miss that, thanks for pointing that out.
It was a mistake, now edited :)
To be honest, I really wasn't happy when I read that myself. There is no internal or external push for F#, but simple grassroots efforts seem to be enough to drive a slow but steady growth in adoption. Leaving F# out of official communications risks sabotaging that growth.
&gt; If I am not using windows and vs, would you recommend me f# or ocaml? Try Monodevelop but I haven't used it before. &gt; Also what's your opinion on f# vs Scala? Which one is easier ? F# is a much simpler language than Scala. Scala is only really preferable if you're already tied to the JVM by legacy. 
wait what
Have an upvote for the proper use of "an" vs "a"...
&gt; simple grassroots efforts seem to be enough to drive a slow but steady growth in adoption [The UK F# job market is down over 60%](http://www.itjobswatch.co.uk/jobs/uk/fsharp.do). 
&gt; Other examples include the lack of pattern matching directly in the function definition I'm not sure what's meant by this? You can pattern match directly in function definitions: &gt; let f (x,y) = x + y;; val f : x:int * y:int -&gt; int And moreover it can be done directly in anonymous function defs as well with "function" (I don't think Haskell does this?)
So far, the only thing I really do not like is msbuild. How did that barf sandwich ever make it out of alpha? 
Thanks for your reply. Whats your opinion about Ocaml on linux/mac platform as comparable to F#?
Complaining that there's too much OOP in a .NET language is pretty comical, I think. I don't understand why some people see OOP and FP as being in conflict. To me, they're very complementary, which is one of the reasons I like F# - it doesn't force me to choose one over the other.
Yeah, our sales of F# products and services dried up a couple of years ago. Now we're doing other stuff. I have been involved in many F# projects in industry and I know from former colleagues that many have been canned. Trayport were a poster child with a trading front-end written largely in F# and server-side code being written in F# and both were canned and many of the people involved left. I trained ~40 people in F# at one of the world's largest insurance companies and they were almost all made redundant soon after (general cuts, nothing to do with F#). I still love F# and I use it all the time but you can no longer have a self-sustaining business selling tools to F# developers or literature to people learning F# because adoption has stagnated. The development of F# at Microsoft went sideways for a few years (giving us type providers instead of basic tooling like rename refactor). Things seem to be back on track now but the emphasis is on diversifying to other platforms rather than going deep on Windows because every new Windows venture has been a failure lately (Windows 8, WinRT, Windows Phone). Doesn't help that Microsoft corporate is full of luddites who think they can solve all problems using C++... I'm doing mostly 3D printing now. 
I will not claim that OOP and FP are completely incompatible. Still, most C#-focused libraries use mutable state extensively, making it difficult to fit it into a functional programming style. You can certainly write OOP code in a way that plays well with FP, but the simple fact is that most .NET libraries do not (as it hasn't been the focus). And if we don't have a suitable toolbox of libraries that play well with FP, it makes it a lot harder to actually do FP in F#. I will not say that the situation is SO bad, though, but the problem exists, and it causes some frustration for those of us who prefer to do FP rather than OOP in F#. But still, it is certainly a matter of preference.
I've been venturing in that direction as it is far more comfortable, but It still uses msbuild under the covers.
I think small wrappers on C# Libs are nice, and also PInvoke wrappers around C++ DLLs. Make sure to pack them up with nuget though, or else they won't see much use. Come by the F# channel on fpchat.com sometime and talk to people about what they might need help with.
Or go with couchbase.
All of the books I have written assume no prior programming experience (but mathematical knowledge). For example, [Visual F# 2010 for Technical Computing](http://www.ffconsultancy.com/products/fsharp_for_technical_computing/). 
Will universal apps also be completely portable to Windows 10 Embedded? 
&gt; I really miss type classes and higher kinded types Now you're talking. I would love to have that as well, but AFAIK the CLR simply doesn't support the necessary concepts.
I've used this before: http://fsprojects.github.io/FSharpx.Async/reference/fsharpx-control-autocancelagent-1.html I guess it might be possible to have a break in your handler function that returns a unit, but I've tried that and never got it to work. Using a normal agent, really the only way I've found to stop them and let them be collected is to use a cancellation token. The AutoCancelAgent wraps the cancellation token with with a type that implements the IDisposable interface, so you would use them with the `use` construct instead of `let`. Once it goes out of scope, Dispose() is called, sending the cancellation notice to the actor to shut it down and let it be collected. 
excellent talk and great speaker... he really lays it out there in a very friendly way, the kind of talk i'd give to my friends not yet doing FP; glad i gave this a watch thanks for posting!