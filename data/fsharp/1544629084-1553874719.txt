Blazor and its derivates confuse me, they seems to skip a step. Sure, running a SPA framework in C#/F# is nice. **But how about being able to call a C#/F# library from Javascript first?** I would love to be able to reuse libraries in the browser without rewriting them in javascript!
Very cool! Can I ask what your development setup looks like? OS, IDE, whether you took advantage of the Live Update functionality, etc? Also, have you made other mobile apps before? If so, how does the mobile app dev experience using Fabulous compare?
It's not Blazor's intended use case, but you can still do what you want with it. Just remove the contents of the C#/F# main entry point, and define the functions you want to call from js with [Blazor's interop](https://blazor.net/docs/javascript-interop.html#invoke-net-methods-from-javascript-functions).
I loved Perry Rhodan as a kid. Glad to see this here.
Late to the party, but I'm part of a recently launched startup that decided to take a bet on F# (https://masse.app , basically our entire backend is F#). There are two non-technical founders, and I was hired as the first full-time employee. I initially started coding the backend in F# because I had worked at Jet for 2.5 years and so I was used to using it daily. The founders were a bit leery about hiring, but ultimately the pool is not as small as you think (assuming you live in a city, or are willing to accept remote work). There's a very small pool of people who are already proficient in F#, but there's a sizable number of .NET developers who are interested in functional programming (and honestly, knowing the .NET ecosystem is the hardest part of using F#). And there's also a lot of developers (again, if you live in a city) who are interested in functional programming in general. And an interest in functional programming is in some ways a filter for halfway-decent developers. Re: immature tooling...I mean, it's really not. Compared to C# and Java, probably the leaders in lang tooling, sure, it's not quite there yet. Compared to most other languages out there, it's on par, assuming you're willing to pay (which you should, if you're basing your business on this). I've used Rider and VS for F# development, both of those have a solid dev experience. I consider F# library support to be really good, considering you have access to the entire .NET library ecosystem. I very, very rarely have trouble using C# libraries from F#, and if I do have trouble it's never been a complete sticking point, it just results in a bit of awkward code. Frankly I think you're much more likely to find .NET bindings for a library or service than Go bindings. Why? .NET has traditionally been used in enterprise, and enterprise pays money. Even looking at a few of the services my startup uses now, I see they have .NET bindings but no Go bindings. Anyway, if you're running a startup and this is your actual business, use the technology that you're comfortable with and will produce a good business outcome. If you're more experienced with Go, use Go. If you're more experienced with F#, use F#. If you have equal experience, I'd probably use F# (and I have). The main reason I use F# is that it's pretty hard to do something really, really awful. There's friction when doing the stupid thing. That means when you're pumping out features and just trying to get the thing done (as often happens in a startup), your technical debt will never be that bad. Compare this to more OO or procedural languages, where doing the stupid thing is easy. The worst you'll see in an F# code base is that someone decided they wanted to do Haskell or only do point-free programming and and their code is inscrutable. But again, there's a lot of friction to that, so I don't see it often. Anyway, that's my two cents. Feel free to send a message if you want to chat more.
Hi. I used Visual Studio 2017. No Live Update Function because the Type Provider for parsing the HTML throws an exception (the fscd.exe from fabulous.) I mostly build the easy structures in my head and then mostly by looking it in the emulator. For other thinks I used a simple C# project and wrote it in xaml and use the preview of xamarin. The Portation is easy from xaml to fabulous. This is my 3 mobile application. And all these are made with F# Fabulous (or how ever the naming before that was.) Please look into my Github repo. All there. FSharpris a Tetris clone and a Crypto Currency Portfolio Calculator with Online Price Refresh. (MyCryptoPortfolio) The Last App have I written the first time in plain C# UWP for Windows 10 and Windows 10 Mobile (it's in the store there). So it was the first try for me to port this app to xamarin f#. So I don't have any expirience in mobile development rather than with Fabulous. I build WPF and UWP Desktop Application and for the Last 12 years. Backend Stuff. I learn wit every app. So my first try was do it all in one view. Than I saw the way to separate the view, model, update stuff into sub models, sub views and sub update function. Now I have extended this with elements like the audiobookItem with their own model, view update function. And a list of these items will be used in sub views. So that we have here basically a bunch of sub sub views inside sub views. It feels nice. I also have to extend some Cmd functions. Like the Cmd.ofAsyncMsgWithInternalDispatch or something like that. I have Async Commands which throws while there working progress updates. So instead to make message loops, I make the dispatcher an argument of the async Cmd to dispatch messages while the file will be downloaded and unzipped. (normally you dispatch the message after your async function is ready with return Msg). So here I have the dispatch function inside a async command like it is in the view function. (I don't know if break this any convention - but it works for me) 
So it's time to hear the normal or neo series with my cool app :D :D You never stop loving Perry Rhodan... You must continue. And with audio books it is easy on the way to work for example.... With my app.... *hypnotizing* *hypnotizing* :D
I have a board game based on this property. I am still surprised how little English there is available of them.
Very nice. F# and Webassembly combined. Hopefully this will grow and be a thing.
The problem is not making the class in F#, its already an existing C# class. But you are correct with the link provided on the initialization is not showing Intelisense since the C# class has only a default constructor and none that accept properties. 
Would you like to show example of F# pattern matching and C# pattern-matching which is not enough "exhaustive" as F#?
and the server, so it really replaces SAFE with W#BB
Because people are asking Reddit to do their homework for them instead of learning F# themselves?
OP didn't "ask for help." OP asked Reddit to "do it." &gt; However if someone here could **do it** it would be really appreciated
Knowing that platforms like Amazon are absolute leeches I would like to know where could one purchase the book where the author gets the biggest cut?
How many people are building new greenfield apps with WPF? 
A lot
[FsXaml](https://github.com/fsprojects/FsXaml) is great for building WPF apps in F#. I don't think there's need for anything else.
I am.
is f# integrated into the designer in visual studio?
More than you'd think. [It's significant enough that .NET Core 3.0 is released with open-sourced WPF, Winforms, and WinUI development packs](https://blogs.msdn.microsoft.com/dotnet/2018/12/04/announcing-net-core-3-preview-1-and-open-sourcing-windows-desktop-frameworks/).
No, but it doesn’t need to. You use the designer to build XAML and then use the FsXaml type provider to access it from F# with full Intellisense and type safety.
I presume no, unless there's a big community push for a plugin that would allow that. But the designer is kind of bad for writing or even previewing SOLID MVVM-y C#-based Views, so I don't know how F# would be able to give a decent experience on it either. I usually just ended up hand-crafting the XAML and previewing/adjusting on build, and most peers I know were in the exact same boat. 
WPF is a really great technology. And I would argue it's a better markup technology, with native databinding and whatnot than html. I worked with it for about a year and a half, and I miss it and would gladly see it used as a multiplatform native application UI framework. 
well, i just can't see how you think there's no need for anything else. i have looked into fsxaml before, and i have no idea how to use it. here's the ["tutorial"](https://fsprojects.github.io/FsXaml/tutorial.html). and my experience with f# type providers hasn't been great. i couldn't even get the ini type provider to work on a trivial ini file. and neither could others. [see here.](https://github.com/fsprojects/FSharp.Configuration/issues/71) whereas i can go right now into visual studio and create a basic wpf app in c# using the designer with me barely knowing any c#. i have been investigating moving my development to f#, but all of my work requires non-trivial GUIs. i have come to the conclusion that i need to learn both c# and f# to be effective.
Except that is to make the move for old apps to .net core possible. A side effect is it also makes writing new apps possible as well, but I don't think that was the primary goal. 
I'm sure most .NET developers would agree with you. F# is often seen as being appropriate only on the back end. All I'm trying to tell you is that F# is effective (and quite pleasant) for WPF/XAML development without Visual Studio integration, if you're willing to endure the learning curve. However, there's no doubt that building WPF apps with C# takes less initial effort. I'm sorry the official FsXaml tutorial is non-existent. I was able to piece together how to use it from various blog postings. You might try [this one](https://riptutorial.com/fsharp/example/28006/create-a-new-fsharp-wpf-code-behind-application-) for a simple "code behind" example. I'd be willing to help you as well, if you're interested. I haven't used the .ini type provider, but I have used several others successfully. Obviously, the quality of a type provider depends very much on the implementer.
it's kind of funny people view desktop apps as legacy and outdated and web apps as "modern". there are tons and tons of people developing desktop apps for industrial and enterprise use.
There is a major difference between asking for help in a professional setting and asking for someone to do your homework for you.
Can you point me to any programming community that encourages people to just post homework questions and ask "solve this for me?". Because I have never seen a community who encourages that. The least OP could have done is posted things he has already tried to prove he at least attempted it before asking the internet to just do it for him. 
Lol nope, he’s an asshole 
I agree with both of you!
Is it properly tail recursive? It looks like it. But also I believe that the F# compiler doesn't do tail recursion when compiling in debug mode. Try compiling in release mode.
I'm also curious if using Seq.tail would be faster than Seq.skip 1 
Looking at the source for Seq.skip and Seq.tail, they are effectively the same for skip 1. There is only an extra `for x in 1 .. 1: do...`
However, after looking at the source of each, I'm think each breaks the tail recursion in this case. What you effectively wind up with is ``` seq {... seq {... ... } } ``` nested for each element in `xs`, which I think results in chained computation expressions to n^{th} depth. I'll have to run a little test.
As I mentioned in the replies to [jackmott2](/u/jackmott2), `seq` breaks the tail recursion resulting in effectively nested `seqs` and chained computation expressions. Yuck. After running a test that directly uses the .NET IEnumerator, I confirmed the issue and came up with a functional version that IMO knows too much about .NET effectively peeling back part of the F# library wrappers around it. This is almost as fast as the imperative version: ``` let firstDuplicate (xs : seq&lt;int&gt;) : int = let rec firstDup (seen:Set&lt;int&gt;) (e:IEnumerator&lt;int&gt;) = e.MoveNext() |&gt; ignore let x = e.Current if Set.contains x seen then x else firstDup (Set.add x seen) e use e = xs.GetEnumerator() firstDup (set&lt;int&gt; []) e ``` YUCK!
I agree, yuck. Might as well just write that in c# at that point. However, some quick stack overflowing leads me to believe that you might be better off using seq.unfold, but I'm not at a machine with f# right now to investigate.
lol
This isn't very fast but perhaps someone can use this as a basis and make it more efficient: let firstDuplicate (xs : seq&lt;int&gt;) : int = let ((_,_),(_,v)) = xs |&gt; Seq.scan (fun (seen,_) x -&gt; ((Set.add x seen),x)) ((set&lt;int&gt; []),0) |&gt; Seq.tail |&gt; Seq.pairwise |&gt; Seq.find (fun ((prevSet,_),(nextSet,_)) -&gt; Set.count prevSet = Set.count nextSet) v
Here is a functional solution using scan that is on par with your imperative function: let firstDuplicate (xs : seq&lt;int&gt;) : int = let head = Seq.head xs let (_,v,_) = xs |&gt; Seq.tail |&gt; Seq.scan (fun (dup,v,seen) x -&gt; match Set.contains x seen with | true -&gt; (true,x,seen) | false -&gt; (false,x,Set.add x seen) ) (false,head,set&lt;int&gt; [head]) |&gt; Seq.find (fun (dup,v,_) -&gt; dup) v Here is a non functional but extremely short solution that is ~22 times faster than anything presented so far: let firstDuplicate4 (xs : seq&lt;int&gt;) : int = let s = new HashSet&lt;int&gt;(1024) xs |&gt; Seq.find (fun x -&gt; if s.Contains(x) then true else s.Add(x) |&gt; ignore; false)
I'll stick with JetBrains Rider
There's no case being made here. The whole thing is just rubbish. The fact that a function to multiply a number by two is simple in both languages is not an indication that F# is accessible, that function is simple in every language, including assembly. Then the author confuses static typing with strong typing, and doesn't actually understand that python is strongly typed when trying to indicate F# is better. Immutability just isn't that helpful for this scenario. That's not to say you can't use F# to do ML, but this doesn't come close to supporting the idea that you should pick F# to do ML. 
Wtf? Below the multiply by two example is the sentence &gt;As it can be seen, despite some minor syntax and character differences the functions are essentially the same. Where does it say F# is more accessible just by looking at that example? The post mentioned nothing, NOTHING about strong/weakly typed differences. It focused on static/dynamic type differences. Seems you are wrongly interpreted it.
It specifically talks about the accessibility of both languages and uses a trivial function to prove it. The point about dynamic VS statically typed languages does stand, but it's an argument that is ruined by the fact that the author doesn't understand it. And while yes Immutability does help, it's not a killer feature, and might actually be a serious disadvantage. Parallel ML algorithms don't need Immutability because they don't share state, no parallel ones aren't going to become parallel because of it, and you're going to do a lot of copies because of it. Immutability is nice, but it's literally the only thing where F# isn't, well we can do that to, and it's simply not that useful in this space. It's not as useful as functional devs generally make it out to be in general, and it's sure not free. TL;DR if the best you can come up with is static typing and Immutability your argument is weak. 
When it comes to ML you are currently most likely way better of just sticking to Python. Not because of the language, but the excellent libraries that are available for it. Just a clarification on the immutability. Although in ML I also don't see the real use, in f# you can use mutable objects if you want and some cases for performance you actually want it. When you do want mutable objects you just have to be specific about it. Also the compiler is smart enough to not keep data in memory twice. For an example on this you can read [https://fsharpforfunandprofit.com/posts/correctness-immutability/](https://fsharpforfunandprofit.com/posts/correctness-immutability/) Also although the article focuses on ML a machine learning application rarely only contains the ML logic. There is more often than not also some interfacing with the rest of the software (rest apis, rpc, commandline IO) and potentially even the user (GUI), and depending on how big that part of the code is, static typing and immutability might actually be preferable.
I'm aware that F# can mutate objects, my point was that the only actual significant benefit the author gets correct is Immutability and it's not a very good argument in this case. Again this is not to say that you can't or shouldn't use F# for ML, or anything else for that matter, but this article purports to provide reasons why you **should** use F#, and it completely fails to do so. Half the arguments boil down to "F# can do it too", the learning curve of F# syntax and typing is massively understated, the type systems of python VS F# are completely messed up, and Immutability is referenced to support parallel algorithms when it's totally unnecessary. It simply doesn't make the case it claims to. 
The other problem with this article is that it doesn't say why F# is uniquely qualified for ML. I could replace F# and .NET with Scala and the Java ecosystem and you can make the same argument--in fact Scala is widely used in data science thanks to Spark and other JVM-based data processing systems.
Why so?
I think the basic gist for ML is that you can probably use whatever language you already know to solve your problem and if you can't or you don't already know one use python. 
Look at the username
The thing is that what you wanted to do (as did I, recently) is to advance existing seq, but the functions in Seq, including tail, only create new sequences derived from existing ones. So if you call them recursively, like you would call list processing functions, you end up with more and more nesting of sequences. The problem is not tail recursion, as that pertains only to how you use the call stack. Calculation of your next item in the sequence could be perfectly tail recursive, but it would still take a lot of time, because to get the item, the code has to go through all the levels of sequence nesting. The solution is to avoid calling sequence functions recursively. Calling Seq.tail is not the same as advancing enumerator, and you shouldn't think of it as such.
Took me a while to put this all together. It's my FsAdvent contribution Looking forward to some feedback and if you think I've missed something important!
Here is some feedback: Please avoid "you should" titles. They are condescending and annoying.
Thanks, that's very helpful. Next time I'll try to be mindful and perhaps spend a few more hours thinking about my blog post title and that he word "should" could potentially offend people. Do you think "Why you must learn F#" would have been better? Or I know which one! What about "Why you NEED to learn F#". I've got a few more: "Why you have to learn F#" and "Why you ought to learn F#"...
Lol don’t say stuff like this.
I like that you had C# -&gt; F# examples. I wish I could see more of those in the wild.
I'm not exactly sure what you mean when you say you have to hand-craft the XAML. The designer works fine for me with F#. But then again I haven't made any advanced GUI-based applications in F#, only basic one-view/viewmodel applications.
Well OP doesn't know me personally or why I care about F#. How about "Why *I* should learn F#"? (Where "I" means the writer.) That describes the essay better.
To be fair, I agree with what you say but unfortunately I have chosen a slightly different title now. English is also not my first language so I don't always get the subtle differences in phrases, but I'll take your point on board for next time!
Once a View starts accumulating a bunch of Data Templates, composites of other views, or the underlying data is dynamic in some way, the preview of the view in the designer stops matching up with how the view ends up looking. &amp;#x200B; Dynamic styling (e.g. dark theme, light theme) also messes things up for simple view previewing. &amp;#x200B; Basically there's a certain complexity point where I'd rather just write the XAML in the text editor, and then tune/iterate using XAML debugging tools.
So, I've been reading up on F# and wanting to learn it for a long time now. Haven't had the opportunity to sit down and just do it 'till I grok it fully. I've come across a few of these "why you should use F#" articles, and what I still haven't seen is what F# looks like in production with big, long-lived systems. I've got a big codebase some other idiot (possibly myself 6 months ago) wrote and it's showing performance problems. How do I troubleshoot that? I've got a lot of code that was written by a n00b (possibly myself 2 weeks ago) and needs to be refactored mercilessly. What does that look like when dealing with F#? Basically, what's it like living with F# past the first date?
Wonderfully put together article. I absolutely love the various examples you provided.
I can relate to the "I'm the idiot who wrote this code" sentiment. :) You bring up a great question: How easy is it to look at code from the past and figure out what it is doing? It is one thing to be able to write code that works now. It is completely different to be able to read and quickly understand code that it unfamiliar because someone else wrote it. (Or you wrote it and forgot about it). 
Also, code written by mathematicians tends to use single-letter variable names or spelled-out greek letters like "theta". Which, I'm sure are perfectly clear to people with a strong math background, but I prefer long variable names!!!
Quite many in life sciences and laboratory automation devices.
&gt; I've got a big codebase some other idiot (possibly myself 6 months ago) wrote and it's showing performance problems. How do I troubleshoot that? Standard stuff. Profile, identify hot spots, optimise, repeat. &gt; I've got a lot of code that was written by a n00b (possibly myself 2 weeks ago) and needs to be refactored mercilessly. What does that look like when dealing with F#? Really really nice. Abstraction is dead easy. The compiler catches lots of different kinds of errors when you refactor, like exhaustiveness and redundancy checking. 
Dark theme???
The value of F# over language ABC to do thing XYZ is a fairly petty way of making the argument to begin with. The value of F# is it’s functional first design that manages to keep most of the OO stuff as well. I’ve only dabbled in rudimentary ML so take my words lightly, but I can imagine that any functional language could be better than any non-functional. That doesn’t mean F# specifically, although it is easy to work with. As many have pointed out, there is a ton of existing material available to utilize when using python. At the moment I think you would need to have a significant cause to move from python to whatever. 
Primarily there are three reasons to use a language to solve a problem. 1. Your knowledge of that language. 1. The availability of other resources that know that language if applicable. 1. The ecosystem of the language for that particular problem. In that order. Effectively everything else is irrelevant for any serious project. 
I disagree. Any one persons personal knowledge of a language should be the last point. Learning the syntax of a new language is not necessarily difficult, as long as the language paradigm is familiar. The last point, which I think should be number 1, ought to consider the language itself at least as much as how many packages for it are available. All the convenience libraries in the world won’t make the wrong tool right. Number two only applies if you’re working on something esoteric (not many are) and it should be a minor concern at most. Now that I think of it, you’re a team manager or project guy, yeah? :p
I'm not a team lead or project guy, but I work in a market where there isn't just *any* skillset imaginable available. I did say where applicable. Fundamentally though while yes, a good developer can learn a new language fairly quickly, efficient, idiomatic usage of a language takes time. If you're doing production work, then unless some other factor is just overwhelmingly superior you will write dramatically better code in languages you are fluent in. 
I think we agree on the last point mostly. It really depends on the team make up. and hat tip to you for taking my jab in stride. 
Great article. Found one typo. The link for Blazor says Balzor.
I think your title described the post perfectly. It addressed why I, the reader, should learn F#.
It's a complicated thing. Knowledge of a particular language is both overvalued and undervalued, and depends, as you say a lot on the way the team is organised. If you have experienced people with good mentoring skills doing code reviews a new language is trivial to pick up. If you don't, novices can write really suboptimal code even if you're an expert. 
A great book about this is Domain Modeling Made Functional by Scott Wlaschin. It tries to convey the message that the code is much easier to read, because you use the language as a modeling language by expressing all business logic with types.
 let getImages (collection: Collections.CollectionProduction) = let supportedLanguages = ["en"; "fr"] let initialMap: Map&lt;string, Image list&gt; = Map [] collection.CollectionToDamLinkProductions |&gt; Seq.filter linkIsImageAndHasVariants |&gt; Seq.rev |&gt; Seq.map (fun (imageLink: Collections.CollectionToDamLinkProduction) -&gt; let variants = imageLink.Variants.Value { BaseUrl = (getImageUrl variants.Size1) Captions = imageLink.Caption.Values |&gt; Seq.map(fun cap -&gt; ( ( defaultArg cap.Lang ""), ( defaultArg cap.Value "") ) ) |&gt; Map.ofSeq Alts = imageLink.AltText.Values |&gt; Seq.map (fun alt -&gt; ( ( defaultArg alt.Lang ""), ( defaultArg alt.Value "") ) ) |&gt; Map.ofSeq } ) |&gt; Seq.fold (fun (images: Map&lt;string, Image list&gt;) (rawImage: RawImage) -&gt; supportedLanguages |&gt; Seq.fold (fun images lang -&gt; let image = { Url = rawImage.BaseUrl Caption = rawImage.Captions.[lang] Alt = rawImage.Alts.[lang] } match images.ContainsKey(lang) with | true -&gt; images.Add (lang, image::images.[lang]) | false -&gt; images.Add(lang, [image]) ) images ) initialMap This is the wart in my current f# codebase, it turns an xml type provided object into a map of strings and an Image object. I find it hard to parse even though I wrote it. But on the plus side it is the only really bad wart and things like this: let render (category: Collection) = element "Category" ([ attribute "name" category.Name attribute "id" category.Id attribute "IsSearchable" (defaultArg category.IsSearchable "1") attribute "Definition" (defaultArg category.Definition "GeneralCategory") attribute "lastmodified" System.DateTime.Now ] @ (maybeExternalId category.ExternalId) @ (renderImages category) @ renderTranslatables "UrlSlug" category.UrlSlugs @ renderTranslatables "DisplayName" category.DisplayNames @ renderTranslatables "Description" category.Descriptions @ renderParents category.ParentCaregories) Are quite beautiful in F#. Other than that, the main sticking points I have with it are not with the language itself but with dependencies. * On more than one occasion I've had dependency problems with this project, I'm still not 100% sure I've solved the versioning on FSharp.Core * Running FSX files (which is a huge boon!) brings another set of dependency issues when running them on non local machines with compiled f# dependencies * I use type providers which even after a year don't seem to have a perfect user experience when using dotnet core, though this has improved immensely I love f# and learning it has been fantastic. For play projects its my language of choice but nothing is pure sunshine and roses.
&gt;with pauses regularly exceeding 100 ms No. I mean you could concoct scenarios where the pause times are regularly that high but it really depends how much data you are throwing at the GC. Regular 100ms pause times would imply some huge heaps. People manage 3d games with .NET, a chat service isn't going to be a problem. 
Yes, "regularly" sounds misleading without context -- I edited in a comparison.
Of the ones you listed I'm only sure that Go's GC exhibits better worst case latency by a significant margin. Are you imagining a use case where you would use .NET for the server of a chat application hosting many thousands of simultaneous users? If so the lack of multi-threading in OCaml might make that more problematic than GC pause times. You should be able to implement a chat server such that there is little to no GC pressure at all. .NET gives you a let of tools to manage memory that most other GC language do not, value types (structs), span&lt;T&gt;, etc. 
Re: long build times, I've mostly gotten around this by being very liberal about my project usage (lots of projects, small number of files in each). I use Rider as my IDE, and it does some extra analysis to determine if the API surface of a DLL would change in the dependency tree (also takes into account if code has changed, as per usual). If not, the project doesn't get recompiled. This has cut down compile times for me pretty drastically (anecdotally).
More info here: https://blog.jetbrains.com/dotnet/2017/05/24/incremental-build-rider/
As with anything performance-related, the answer is: * Measure a sample * Analyze the sample * See if a hot spot is in your code * If it's in your code, think of a fix and try to apply it * Measure and analyze the sample again If you reach a point where the hotspot is not your code, then it's safe to say that the underlying environment is not suitable for your application. Otherwise, there is no way to know. Speaking generally, there are plenty of low-latency systems built with .NET (and even F#), so I'd be surprised if the .NET GC was preventing something like a chat service from running well.
Maybe, with location data too -- I just included Ocaml for reference, wouldn't consider it as an alternative partly for the reason you mention. Not a representative data point by any means, but I read [Uber](https://eng.uber.com/go-geofence/) came within an order of magnitude of their latency requirements with Go for geofence lookups -- F# seems to experience more than an order of magnitude more latency than Go, partly raising my question.
That was in a microservice architecture, where Go has the added advantage of being natively compiled for quicker startup time. Go/Rust are pretty attractive in those scenarios (and Rust was twice as fast for one company's microservice than Go, so maybe you should use Rust!) Go is certainly a fine choice for a chat server with a lot of load. Goroutines and channels make parallelizing it pretty pleasant, and the standard library has a lot of useful tools for it. 
What I would do for Rust with GC...thanks though!
Why would you need GC?
Maybe I wouldn't, but it could make things easier to reason about initially I figure.
If you are okay with GC, try Elixir/Erlang.
At least in reading that blog post, I'm not sure startup time is really the interesting metric for their use case. It wasn't mentioned in the blog post, at least. It sounds like they needed good CPU perf, multithreading, and high throughput.
Would F# satisfy all but their latency needs, possibly?
You could take a look at Fabulous, which is Elmish for Xamarin.Forms. It’s super nice.
Elixir does look very nice, if just dynamically typed.
Of course. But Elixir does have very good testing frameworks and doc generation. The community is also completely FP, so there's no split on FP vs OOP interfacing. It's very rubyesque.
I am thinking about a System like that for a while now. As of now I would use a MVVM kind of app. The Viewmodels I would write in C#, because they work best being mutable and that's cumbersome using F# imo. All the logic underneath would be F# in this aproach. Frameworks to use could be WPF or UWP on Windows or xamarin for the Cross-Plattform Story.
Wouldn’t know unless they tried and determined it wasn’t :) In the post they mention other dynamic langs (and how static typing helped them out), so I also have a suspicion that the team who built that system weren’t as familiar with other static langs and corresponding runtimes. JVM or .NET is likely suitable for their needs, but without measurement it’s all just guesswork.
I thought it was idiomatic for option/result/etc. CEs that `let!` early returned on failure and `return!` early returned on success? Like: let ``this evals to "Some 2"`` = option { let! _ = Some 1 return! Some 2 return! None }
Does this also work with UWP / WPF ? (desktop)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/csharp] [Architektur Question](https://www.reddit.com/r/csharp/comments/a7x5xz/architektur_question/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
&gt; because they work best being mutable and that's cumbersome using F# imo You can have mutable properties in F# just fine. Tho having immutable and just updating via the `with` syntax is easy as well.
They do mention &gt;The response time was &lt; 5 ms at 95th percentile, and &lt; 50 ms at the 99th percentile. But it is impossible to know if C# or Java or anything else could have done the same without knowing exactly what they were doing.
The problem is that if you have a immutable state object bound to the view models once you change a single property the whole ui is being rebuilt. I’ve read a blog post about bringing the Elmish architecture to WPF/UWP. what the author ended up doing to prevent the app from rebuilding is using a custom converter between view and view model that detects changes and only fires events for those properties... There was a lot if boilerplate code and interfaces to make this work..
Any examples off the top of your head? It does seem likely other [toolchain](https://elliotbalynn.blog/2017/08/01/low-latency-applications-in-c/) [components](https://www.reddit.com/r/erlang/comments/a0jiso/erlangs_soft_realtime_performance_is_just_what/eajvt1h/?context=3) affect latency more than runtime -- I'd just rather not scale something up then have to switch languages for response times. 
Thanks, any examples off the top of your head? It does seem likely other [toolchain](https://elliotbalynn.blog/2017/08/01/low-latency-applications-in-c/) [components](https://www.reddit.com/r/erlang/comments/a0jiso/erlangs_soft_realtime_performance_is_just_what/eajvt1h/?context=3) affect latency more than runtime -- I'd just rather not scale something up then have to switch languages for response times.
I love F# as much as the next guy, but the approach of taking examples from stackoverflow and random blog posts and trying to make a point with them is severely flawed. You can't claim "F# is great because the functions are fully parameterized" by comparing to a C# Fizzbuzz method that looks like it was written by or for a C# beginner student (single method, no parameters, unnecessary ToStrings, "namespace oop", etc.) The concepts of encapsulation, simple single-purpose functions, orthogonality etc apply just as much to OOP as to FP. Here's Fizzbuzz in what I consider "regular, procedural-rather-than-OOP C#" looks like. [Bikeshed Guard: The stacked ternaries may be replaced with if-elseif-else, but that doesn't actually impact the code too much and is a individual preference thing.] If the example was longer, I'd also split the body of the loop out into a separate method. using System; class Fizzbuzz1 { static bool divisible(int dividend, int divisor) { return dividend % divisor == 0; } static void show(int start, int end) { for(int i=start; i &lt; end; i++) { string fizzbuzz = divisible(i, 3) &amp;&amp; divisible(i, 5) ? "Fizzbuzz" : divisible(i, 3) ? "Fizz" : divisible(i, 5) ? "Buzz" : ""; Console.WriteLine($"{i} {fizzbuzz}"); } } static void Main() { show(1, 20); } } Here's an example of a more OOP-flavored approach, using a standard OOP idea of encapsulating a transformation (the integer to fizzbuzz string) inside of a class, and exposing its functionality via its public interface (the constructor, and `ToString`). using System; using System.Collections.Generic; using System.Linq; class FizzbuzzItem { int Value; bool divisible(int divisor) { return Value % divisor == 0; } public FizzbuzzItem(value) { Value = value; } public override string ToString() { if (divisible(3) &amp;&amp; divisible(5)) return $"{Value} Fizzbuzz"; if (divisible(3)) return $"{Value} Fizz"; if (divisible(5)) $"{Value} Fizz"; return $"{Value}"; } static void Main() { foreach(var i in Enumerable.Range(1, 20)) { Console.WriteLine(new FizzbuzzItem(i)); } } } IMHO, either of those C# examples is easy enough to understand and extend. I guess the F# code still looks better, but at least it's a more direct comparison. 
Author here. I don't want to argue with you, mainly because there's bikesheds all over the place. I'm happy with the article as-written. I also feel the conclusions stand. "Functions as first-class citizens", especially with all the syntactic sugar F# brings to the table, means constructing a system of simple tokens to create solutions. Those tokens are reusable in F#, hooked up to a bunch of structure in C# -- even if you scope them out to do the same thing. In fact, I think the essay works better taking the F# version and making it as C# as possible, even though that's not the kind of code the average C# coder would come up with (in my opinion). Thanks for the comment! Hope you liked the piece.
There are a few customer stories involving scale: * [Jet.com](https://customers.microsoft.com/en-us/story/jetcustomerstory) * [Tencent](https://customers.microsoft.com/en-us/story/tencent-telecommunications-dotnetcore) * [Raygun](https://customers.microsoft.com/en-us/story/raygun) * [GoDaddy](https://customers.microsoft.com/en-US/story/godaddy-professional-services-net-core) The Tencent example is probably the most relevant, since a payment system that handles 600 million businesses needs to be able to scale well :) I severely doubt that the .NET Core runtime will be an issue for the things you've mentioned. Now, if you're in the business of building high frequency trading infrastructure and want to beat other requests coming in by microseconds, then I doubt any managed language and runtime will be up for the task. But for something like a chat app, or even a server that needs to handle many thousands of requests per second, .NET Core (with F#) should be suitable, provided that you built it out correctly. There is [documentation](https://docs.microsoft.com/en-us/aspnet/core/performance/performance-best-practices?view=aspnetcore-2.2) on how to think about this sort of stuff when you've gone beyond building the first iteration of something, and there is a wealth of knowledge in the .NET community on how to tune things appropriately.
I certainly agree that the F# structure is better, and that your conclusions are correct. I just think the conclusions are stronger when the comparison is made between more fair examples. I think one of the dangers of code examples on blogs is that the examples themselves can be seen as authoritative, even the "losing" examples. For an example where F# got the short end of the stick, a while back I read [kNN in Ocaml and F# / Stop the presses Ocaml wins](https://philtomson.github.io/blog/2014-05-30-stop-the-presses-ocaml-wins/) comparing Ocaml to F# on a kNN benchmark, where the author discovered that F# took 22 seconds on a benchmark while the equivalent Ocaml took 47s on a benchmark, then optimized his Ocaml down to 11s and proclaimed a victory of Ocaml. Of course, a F# programmer could look at his code and optimize it down another 4x to 10x, but now there's a blog on internet with example F# kNN code that people will just take and say "oh, this is how you do kNN in F#. I guess F# is just twice as slow as Ocaml", even if the intention of the post was just to show a fixed Ocaml solutionand not to intentionally write a suboptimal F# solution.
i agree. if we use the same "fair" method for choosing the f# code, then we would get something like this: [1..100] |&gt; Seq.map (function | x when x%5=0 &amp;&amp; x%3=0 -&gt; "FizzBuzz" | x when x%3=0 -&gt; "Fizz" | x when x%5=0 -&gt; "Buzz" | x -&gt; string x) |&gt; Seq.iter (printfn "%s") (taken from [https://stackoverflow.com/a/2422713](https://stackoverflow.com/a/2422713). currently the accepted answer.) no reuseability, no "pieces" &amp;#x200B; secondly, the original F# code has a bug: iteri provides a 0 based index, so the output looks like this: 0 1 2 Fizz 3 4 Buzz 5 Fizz 6 7 8 Fizz 9 Buzz 10 11 Fizz 12 
Is this parody? Or did you not realize that your code doesn't actually work? It's supposed to print a number or a word, not a number and a word. Beyond that no C# programmer is going to take you seriously when you don't show equivalent code. Why not show an iterator in C# like you do in F#? The `yield return` syntax isn't hard. Why aren't you caching the result of the modulus operation in F#? You need to explain that because it doesn't make sense to do so in one but not the other. 
Yes! They’ve had Xamarin.Forms targets for some of the main desktop platforms (MacOS, GTK#, WPF) since about 2017, but they’re all in a preview/beta state. Some useful links: https://docs.microsoft.com/en-us/xamarin/xamarin-forms/platform/wpf https://blog.xamarin.com/glimpse-future-xamarin-forms-3-0/ 
As a technical coach, I resisted posting code on my blogs for a very long time -- exactly for the reasons you mention. If you manage to make a provocative point, all you end up with is a hundred programmers telling you that you coded it the wrong way. It's a difficult call. I coded the F# the way I did -- wrong behavior and all (!) because I wanted it to feel like what I'd code from scratch. But you're exactly right: you end up creating examples where you didn't want to. After hashing this back and forth for years, I don't see an easy answer here. I'm interested in how people program, not how to program perfectly. One of the points I made in the video -- and one I'm sticking to -- is that two really good FP coders/teams might come up with completely different ways of abstracting the problem out. And that's fine! If people can solve problems and maintain code, it's a win. Otherwise it's a loss. The C#? Very tough to do. I think being a functional programmer may have ruined me for OOP work for life. But maybe there's still hope. I think even as a C# coder I would have kept close to the example I used. Why? Because, as pointed out in the article, it's a template. Heck, most of it comes up automatically when you start a new project. Now? Now after learning how to factor at a level I didn't know existed I might do that very differently. I don't know. burnall13 has a great example of a direct F# solution. I'd argue the ActivePattern falls out rather quickly -- and that the entire point was creating tokens just like that. What I think we're really getting at is this: to what degree do you factor out code? How do the people interact with the code? Not how you or I would, how does the average coder do it? To me F#'s main strength is that it's a training language. That means you start off with the direct solution burnall13 provides, then talk about how/why you'd rearrange things. And yes, that creates hard-coded "bad" intermediate examples as blog entries. It also provides subjective guidelines rather than rules, which a lot of olks have problems with. I'd rather live with that than abandon the training aspect of the environment. I can certainly understand and appreciate that others feel differently.
&gt; Why not show an iterator in C# like you do in F#? The yield return syntax isn't hard. He explained the rationale for not writing the C# version himself in his article. &gt; Why aren't you caching the result of the modules operation? This is kind of trivial. The active pattern was used, I'm assuming, to demonstrate how to split things up into reusable operations. I suppose he could've written it this way without the active pattern: ``` let inline divisibleBy n m = n % m = 0 let findMatch n = match divisibleBy n 3, divisibleBy n 5 with | true,true -&gt; "FizzBuzz" | true,_ -&gt; "Fizz" | _,true -&gt; "Buzz" | _ -&gt; "" ```
&gt; This is kind of trivial. That's not the point. C# developers are going to key in on the performance difference and use that to ignore the rest of the article. (Yes, I know the performance isn't really that different. And the optimizer might see the duplication. But the people you're trying to convince won't care. )
&gt; C# developers are going to key in on the performance difference and use that to ignore the rest of the article Your concern is appreciated, but you're setting the burden of proof unfairly high IMO. A segment of people (perhaps a majority) will always find ways to pick apart an argument, and if they're going to hone in on the minutia (like caching the modulus computation) and immediately tune out, there's no sense in trying to persuade them. At this stage in F#'s adoption curve, the effort is better spent addressing those who are more open. 
The burden of proof is what it is. If you want to convince people, or even get them to not dismiss you out of hand, you can't offer such an obviously flawed argument. The only time you get to set your own burden of proof is when you are writing for yourself. 
The burden of proof is subjective for these kinds of things. At any rate, it's clear that you think C# was poorly represented. Point taken. It's possible to do a more-or-less direct translation of the F# example to C#. The purpose of these examples, however, was to compare FP and OOP implementations -- not F# and C# apples to apples. If you replace the F# code with a faithful C# equivalent, the main points of the article are still valid IMO. 
&gt; Everything is stuck in the Main method, and the Main method is coupled to the DoFizzBuzz1 method. In addition, the range, 1 to 100, is coupled to the implementation. The class is the way it is because it’s coupled to being a C# console app. All of those complaints go away once you rewrite the C# example to use an iterator just like the F# example. More importantly, anyone who knows C# is going to see that instantly. So as far as they're concerned, it isn't a fair comparison. 
I would use SkiaSharp for drawing. For cross platform use just do (almost) everything in .Net Standard. And then hook it up to a Xamarin.Forms project or UWP project. This is just a small bit of code and if you have almost everything in the .net standard project you can easily change your mind later. I would definitely not use a pure functional approach. You can model states (a list of geometries) and operations (saving undo operations too if operations aren't invertible) without requiring that states are immutable.
I think you make some good points here, and I'm not going to weigh in on whether the C# example is fair or not. My only critique is that the code samples don't look as polished as some I've seen on other blogs. Consider using the facilities provided by **FSharp.Formatting** to provide more polished looking code samples, here's a great example of how to do it: https://fsprojects.github.io/FSharp.Formatting/sidescript.html Note that the column on the left shows what would be in your F# script file, and the column beside shows what the html generated from your script file renders to, which you can then incorporate into your blog post. Try hovering your mouse cursor over the identifiers in the right column - you even get nice tooltips generated for you!
Also the F# example of the FizzBuzz could be simplified down much more. I didn't see the need for Active Records in this particular example: https://gist.github.com/lloydjatkinson/112ce32cc69b83250dff5e556bd7a9fb
If I may be so bold, really none of the solutions here are anywhere close to code I would want to reuse. The reusable bit is the idea that I have a way of taking a value and applying multiple tests to it, and either returning the original value (converted to another type, this case string) or a message(of type string, in this case). Some future reuse case might have different input and output types. But let's just stick with integers and strings for now. The goal of a fizzbuzz program is to apply multiple tests to a value, such that if no test succeeds, the original value is passed through. Another feature of the fizzbuzz problem is that the results of the tests are concatenated. In the standard case, if a number is divisible by three, and it is divisible by 5, then the result is "fizz" + ""buzz". Every example I have seen in the original posting, and in the comments (to this point) have used a match or switch statement, and because it is a match statement, the statement stops processing tests after the first match. But, here is the problem, especially with reusability and extending the program. Suppose we introduce "Klunk" as a new rule, and we make this rule be true when n modulo 2 is true. This would make a sequence [ 1 , Klunk, Fizz, Klunk, Buzz, FizzKlunk, 7, Klunk, Fizz, BuzzKlunk, 11, . . . 29, FizzBuzzKlunk, ...] By adding one rule, a Match statement would double the number of cases it would need to test. One would not only need a Klunk Test, but a FizzKlunk test, and a BuzzKlunk test and a FizzBuzzKlunk test. And, not only that, if you code the Match statement incorrectly, and put the tests out of order, the Klunk test would end all matching ahead of the FizzBuzzKlunk test, and so you would never see it. AND, to top it all off, after you have coded up the match statement, the client comes and says, "I don't want "FizzBuzzKlunk", I want "KlunkFizzBuzz", because the Klunk comes from 2, and 2 comes before 3, and, with a match statement, you have already hard coded those composite strings. Okay, so what is the solution? So, the solution is concatenation rather than a match statement. Note that FizzBuzz has a special case where if no test succeeds then the original value is used. If that rule isn't going to change, then we can code a single case solution in F# as: let rec applyRules rulesList resultText number= match rulesList, resultText with | [] , "" -&gt; string number | [] , _ -&gt; resultText | x::xs , _ -&gt; applyRules xs, number, resultText + (x number) where : * rulesList is a list of functions of type int -&gt; string * number is the current number to test * resultText is the current state of the result string, it is initially called with an empty string * the first match line matches the end of the list of rules AND an empty string as a result, this fires the special case rule where we return the original value converted to string * the second match line matches the end of the list of rules and returns the resultText * the third line of the match statement separates the first rule from the rest of the list (x), applies the rule x to the number (x number) and then concatenates the result of the rule to the resultText. Then, it recursively calls the applyRules function , but with the tail of the list of rules and an updated resultText. * Each rule in the list is a function that takes a number and returns either an empty string, or a string like "Fizz", "Buzz", "Klunk" or whatever. Assuming a function moduloTest int * string * int -&gt; string we can make a list of partially applied functions like this: let fizzBuzzRules= [ (moduloTest 3 "Fizz") ; (moduloTest 5 "Buzz") ] let klunkFizzBuzzRules = (moduloTest 2 "Klunk") :: fizzBuzzRules Which, as you can see, can be modified on the fly. Applying the rules is a simple one liner let fissBuzzResult = map (applyRules fissBuzzRules "") [1 .. 100] So now, we have a completely reusable code, and by my count, only needed seven lines of code. The problem with all the other code I saw was implementing the rules as code, rather than as a list of functions. 
What does it do? It wouldn't load on my phone for me. Browser said script was unresponsive
Back when Silverlight was still "majorly" (read: somewhat) supported by browsers, [http://tryfsharp.org](http://tryfsharp.org) was a website where you could write, compile, and execute F# code in your browser. Through the Silverlight stuff. The site has since broken, and it's a shame, because it was a really useful resource! It's actually what got me into F# in the first place. Anyway, lately there have been two new projects trying to solve this problem! Which is really exciting. 1. The Fable REPL, at [https://fable.io/repl2](https://fable.io/repl2), with the previous version now at [https://fable.io/repl-legacy](https://fable.io/repl-legacy). These projects work by compiling the compiler (?!?) into JS, and then running your compiled F# code (now JS!) in the browser. 2. This new thing by the WebSharper people, solving a very similar problem, but with WebAssembly and some WebSharper stuff that I'm ignorant of. I think the key take-aways from this article are: \- Cool, we're going to have a few "Try F#" replacements stable soon! \- Neat; WebSharper has really been increasing their PR lately - time to invest a bit of time learning more about this scene.
Well, I like the post and thought it made interesting points. Well done.
I wasn't specific enough there. Mutable state is a lot "louder" and doesn't pair as well with MVVM style frameworks. My POV is that C# works better for the mutable side of things. I never built a larger scale App this way though. It's in my pipeline though.
Could you link to that post please? This Elmish like aproach paired with xaml and especially xamarin seems like a good deal.
Hypothetically it's possible, that of course depends on the rest of the code you write and your network and servers. I wouldn't worry about just the GC, for example let's say you had no choice but to use .NET, worst case scenario you have a solution like https://www.reddit.com/r/csharp/comments/4y2akd/stop_the_net_gc_running_with_trystartnogcregion/d6lcsl8/?st=jpy0r7n8&amp;sh=2a888d79 You can also deal with the startup times and JIT Compilation by using Ngen All in all &lt;500-5000ms response times are doable in pretty much everything assuming your network and business logic isn't just slow. If you meant &lt;50-500ms it's probably still possible depending on network latency. 
I think it really depends on how far you want to take it. In [C#], I’ve had projects where I allocated a large chuck of memory manually and worked within that buffer. If you’re not allocating on the heap, then there is nothing for the garbage collector to do. If the garbage collector never runs, then you never have pauses.
Go's garbage collector priorizes latency above all else, so it is only natural that latency will be better than what .net offers. The dotnet garbage collector on the other hand is way more balanced. It trades higher latency for higher throughput. I would argue that in most real world scenarios, this is the right choice. As always, be wary of artificial benchmarks, and look carefully. The linked article doesn't show the *distribution* of the latency, just the maximum Stop the World time (and that go chickens out after 16GB working set). The higher throughput means that I can service way mire requests with .net compared to go. Depending on the distribution of the wait times, I can just have a few servers sitting idle for the few pathological cases, and still come up ahead in terms of cost. So if my budget is 100ms, and the average latency is 20ms, I can issue another request to a standby server at 30ms. 
You could use the TechEmpower benchmarks as a way to get an estimation as they do measure latency. For for json serialization benchmark F# based frameworks actually beat go on latency fairly often. That suave can have an average latency of **0.3ms** with 0.5ms std dev I think indicate the GC is not a bottleneck to low latency. JSON: https://www.techempower.com/benchmarks/#section=data-r17&amp;hw=ph&amp;test=json&amp;l=hr9nun-1 The Fortunes benchmark includes database access and F# does worse there. I wonder if this indicates that the .net database drivers aren't as optimized as the go ones. Still, Zebra and Giraffe have an average **3.3ms** and **22.7ms** response time on average. There are some concerning high maximum latencies there but the standard deviation isn't too bad so those may be fairly rare. https://www.techempower.com/benchmarks/#section=data-r17&amp;hw=ph&amp;test=fortune&amp;l=hr9nun-1 
It's somewhat different, yet much the same. Others have mentioned standard tooling and the great book by Scott to guide you, btw the book is a translation of the DDD book into modern practices and F#. Aside from similarities, once you stop writing C#-like code in F# you'll find that the language lets you work in finer/better abstractions and that will result in a profound change in your "weeks from now" experience. Your problems and consequently the refactoring will be different. The changes will be more along the lines "oh, this concept was poorly understood and this is what it's really like" instead of "I don't understand what's happening here even though I wrote this".
Part 1 [https://nicksnettravels.builttoroam.com/post/2018/05/15/Redux-and-the-State-of-My-XAML-Application-(part-1).aspx](https://nicksnettravels.builttoroam.com/post/2018/05/15/Redux-and-the-State-of-My-XAML-Application-(part-1).aspx) Part 2 [https://nicksnettravels.builttoroam.com/post/2018/05/16/Redux-and-the-State-of-My-XAML-Application-(part-2).aspx](https://nicksnettravels.builttoroam.com/post/2018/05/16/Redux-and-the-State-of-My-XAML-Application-(part-2).aspx) Part 3 [https://nicksnettravels.builttoroam.com/post/2018/05/16/Redux-and-the-State-of-My-XAML-Application-(part-3).aspx](https://nicksnettravels.builttoroam.com/post/2018/05/16/Redux-and-the-State-of-My-XAML-Application-(part-3).aspx)
The Fable REPL (current) doesn't work for me in Chrome, I just get a blank canvas no matter what example I pick. It works great in Firefox though.
This is a good idea. I really like the idea of using SkiaSharp for the editing/rendering. &amp;#x200B; &gt;I would definitely not use a pure functional approach. why ? &gt;You can model states (a list of geometries) and operations (saving undo operations too if operations aren't invertible) without requiring that states are immutable. what do you mean by " if operations aren't invertible" ? &amp;#x200B;
[https://github.com/adamped/xamarin.flutter](https://github.com/adamped/xamarin.flutter) this is also a very promising project.
Hehe, since this most is much more centered on Uber's evangelism, I think it's good to focus on that a bit :) I was a bit startled that they mentioned this: &gt; (Thanks to static typing, no more guessing and unpleasant surprises). Errr, huh? You'd think that an engineering group would have had experience with statically typed languages for high-load services. That's what nearly every major company that has these problems does... So then I re-read it and noticed some things: * Very quick dismissal of industry-standard techniques for geofencing (such as those developed by Google for maps...), but without any math of their own to back up their decision * 170k QPS max over 40 nodes...which is 4.2k QPS per node. That's pretty good, but not exactly amazing? And it turns out that an ex-Bing maps engineer (the portion of Bing maps he worked on was eventually bought by Uber) and expert in geofencing wrote a very [detailed post](https://medium.com/@buckhx/unwinding-uber-s-most-efficient-service-406413c5871d) that uses tools such as math and benchmarking to determine that they grossly under-engineered their system. His use of industry-standard techniques that they threw out gave equivalent single-core results to their max QPS on a single node _if you assume their nodes only have one core_. If you assume a 16-core CPU on their nodes, they're 640x slower than they could be. I imagine (or at least hope) that Uber engineers significantly improved their service since 2016. Long story short, it's rarely the underlying runtime that actually affects how your system can perform. Others have mentioned how F# and .NET perform in some benchmarks, and the numbers are competitive for those benchmarks, so I won't reiterate what's already been said.
Sounds like you should file a GitHub issue!
Thanks again, great write-up I should've caught earlier. Just to clarify, the 640 ratio seems to refer to throughput below, distinct from latency, right? &gt;\[Uber's\] cluster is 40 nodes and making the assumption that the cluster is composed of 16 core CPUs, we’re trading at a 1:640 ratio. If we apply that ratio to the performance disparity we’re talking the difference of millions of requests of throughput. The next profile of fence time durations seems to affect latency more directly, but I don't know how to compare the differing time allocations. &gt;It’s evident that the majority of the work in the brute force family of fences is done in searching, while the spatial indexes are serializing *more* data and responding to *more* requests. I would think the poor time complexity of Uber's algorithm translates to worse latency, but the blog post's preface confuses me a bit -- sounds like a brute force approach could achieve better latency at the expense of worse throughput? &gt;I respect that Uber set out a specific latency distribution requirement of serving 99% of all requests in under 100 milliseconds and used that as their success metric. If augmenting the brute force approach got them there, then kudos are in order.
Correct, but neither latency nor throughput lives in a vacuum. And to the Uber blog post's point, it does mention both. You can use a GC like Go's that has been optimized for latency (at the cost of throughout and tunability...) and pay on the order of 10x as much due to a poor choice in implementation. Had they gone with a different underlying technology but used a better algorithm, I doubt the rebuttal blog post would have existed.
Cool! Thanks for this example.
Wow, Zebra is a lot faster than I was expecting. All of the database access requests that I saw (Single Query, Multiple Query, Fortunes) have Go take all the top slots (Giraffe makes a placing here or there in latency), whereas the non-query ones are more balanced. Definitely seems like the .NET database drivers aren't as optimized for these tests.
That aside, I've been looking at the coreCLR repository lately and it seems they are in the process of decoupling the GC for the runtime, which opens up new possibilities for custom gabrage collection in the future. Interesting stuff.
Just looked into Elixir a bit more -- dynamic typing still makes wary. Any thoughts on how F# compares?
Will it be distributed? Or everything in-memory?
The goal of this series is to provide the tools to start with prototyping an event sourced app. There wont be a distributed event store. For now it is just in memory. If the series is well received I might expand to file storage and later to Azure.
Not the full thing and it's far from perfect but I've written a parser for a [toy language](https://github.com/FrankBro/ordo) that is very similar to ML. Maybe you can use it to inspire yourself. [This file](https://github.com/FrankBro/ordo/blob/master/ParserExpr.fs) plus ParserUtil.fs might be useful.
Thanks to you, it looks interesting. I notice that you do not implement indentation, if you are interested, there is [this](https://github.com/stephan-tolksdorf/fparsec/wiki/Parsing-indentation-based-syntax-with-FParsec) that works with FParsec. Maybe for a future version ;) 
This is kind of on purpose. Didn't want to make my language white-space-aware. 
Which implementation are you using? I looked at a common implementation of Option/Result builder and they are defined as just returning the thing you give it directly: Option: [https://github.com/fsprojects/FSharpx.Extras/blob/master/src/FSharpx.Extras/ComputationExpressions/Option.fs#L13](https://github.com/fsprojects/FSharpx.Extras/blob/master/src/FSharpx.Extras/ComputationExpressions/Option.fs#L13) Result: [https://github.com/cmeeren/Cvdm.ErrorHandling/blob/master/src/Cvdm.ErrorHandling/ResultBuilder.fs#L12](https://github.com/cmeeren/Cvdm.ErrorHandling/blob/master/src/Cvdm.ErrorHandling/ResultBuilder.fs#L12)
Thanks for making these videos Roman! I enjoy them very much!
Thank you for the nice words!
You can use WPF with fsxaml. Together with the fsharp.viewmodel it can be done quite lean. 
What is all this about /u/grauenwolf? It's very frustrating seeing a de facto authority on .NET (Your articles are often close to top on google for common search terms like "C# 8") repeatedly put down part of the ecosystem. This subreddit isn't really a good representation of the F# community, most simple discussion and things like homework help happen in the #beginners channel on the FSSF slack. It's not like /r/csharp or /r/dotnet are much better in any case... You are one of the maybe three/four people who give genuine answers to questions there.
 `MethodAttributes.Public ||| MethodAttributes.Virtual` This should do the trick
Great, thanks!
More generally, all bitwise operators (for enums and integers) are easily recognizable in F# by being triple characters: * bitwise or `|||` * bitwise and `&amp;&amp;&amp;` * bitwise not `~~~` * bitwise xor `^^^`
Nevermind, after digging I found out I need mono-devel &amp;#x200B; Sources: [https://www.mono-project.com/download/stable/](https://www.mono-project.com/download/stable/) [https://github.com/SaturnFramework/Saturn/issues/52](https://github.com/SaturnFramework/Saturn/issues/52)
We have to be better than /r/csharp or /r/dotnet. Those other two can afford to be assholes when it comes to newbies due to their sheer size. (Though I still try to call them out on that BS.) F# is not afforded that luxury. If we want it to be a serious alternative to C#, the community needs to grow. And that means being very supportive of new members. 
I was wondering why F# chose to do it differently than C#, but it's obvious when you think about it. The `|` is used for piping, so you can't have it be bitwise OR. `||` is still boolean OR, so `|||` it is. Once you've got "triple the character used for boolean equivalent" established, you do the same for the others.
Working on a dataset labelling project recently, it's build with SAFE stack. &amp;#x200B; [https://github.com/JacobChang/Senses](https://github.com/JacobChang/Senses)
 type HelloWolrdController () = inherit TwilioController [&lt;HttpPost&gt;] member this.Index (request : SmsRequest) = let response = MessagingResponse() response.Message "Hello World" this.TwiML response this is assuming that the `TwiML` response is a member of the`TwilioController` base class (you could use `base.TwiML` instead of `this.TwiML` too if you like) Also I did not test it and there might be problems with overloading on the way but that should be the pattern
Awesome! Getting a few errors, - `namespace WebApplication1.Controllers ` A reference to the type in assembly 'System.Web' was found, but the type could not be found in that assembly `type HelloWolrdController () =` - A reference to the type 'System.Web.Routing.RequestContext' in assembly 'System.Web' was found, but the type could not be found in that assembly WebApplication1 C:\Users\xx\source\repos\WebApplication1\WebApplication1\xx\ValuesController.fs and for `response.Message "Hello World"` I just changed it to `response.Message "Hello World" |&gt; ignore` debugging now! XD
cannot really help you with the reference stuff aside from pointing out, that this is not F# specific - works the same as with C#
I am working on a HTTP file server with expiration dates. Sometimes I simply want to share a file with someone without worrying that it will stay on the net indefinitely 😅 https://github.com/b0wter/Torpedo
No, both operators are just one-line definitions and have the same performance.
I had such a blast playing around with Vue.js and AirTable last month I plan on doing a couple/several more evenings with it. I feel like there's not a lot to do to turn it into a proper component system for serverless blogging and once that's done it should be even more fun to play with :) On the F# side, I may add some optional server support, but probably not. Don't use stuff you don't need and all of that. I _do_ plan on getting back to F#, though, and quickly. My analysis notes compiler is right at the top of the complexity hump and another good session or two should see it start simplifying massively as well. My goal all along was to show how this happens -- how you explore complex spaces using functional programming to both understand the problem better and create simple solutions. I'm not going to bail out on that now when I'm in the home stretch. I'd also like to start playing around with ML, but that's probably a few months out. We'll see. I'm looking forward to a lot of fun coding this month. :)
About to start working with F# full time at [olo.com](https://olo.com) later this month! &amp;#x200B;
`|&gt;` is more common than `&lt;|` because in F# type inference goes left to right: "foobar" |&gt; (fun x -&gt; x.Length) is valid, because the lambda is known to take a string parameter (fun x -&gt; x.Length) &lt;| "foobar" is invalid because the lambda cannot be typed without looking ahead. It is also somewhat cultural -- Haskell favors `$` (`&lt;|`) and `.` (`&lt;&lt;`) where the type inference isn't hindered by the operators but `|&gt;` more closely mirrors chained method calls in "fluent" OOP style: foo |&gt; fooToBar |&gt; barToArray foo.ToBar().ToArray()
Still working on an elmish Coupon-sharing app (Fabulous + FsCheck). Restarted it in a more or less TDD fashion. I'm currently struggling with how to write proper tests for navigational logic. https://github.com/janssen-io/coupon-app/tree/tdd/master
Congrats man
In terms of "speed", `f a`, `a |&gt; f`, and `f &lt;| a` are the same, and it is more idiomatic to use `f a` or `a |&gt; f`. `f &lt;| a` has its uses, but I wouldn't really use it generally. That said, there is a tangent involved that is worth mentioning. If multiple arguments are involved, non-pipe function application may be _marginally_ faster. For example, this F# code: ``` type F&lt;'a, 'b, 'c, 'R&gt; = 'a -&gt; 'b -&gt; 'c -&gt; 'R module M = let f1 (g: F&lt;'a, 'b, 'c, 'R&gt;) a b c = g a b c let f2 (g: F&lt;'a, 'b, 'c, 'R&gt;) a b c = c |&gt; g a b let f3 (g: F&lt;'a, 'b, 'c, 'R&gt;) a b c = g a b &lt;| c ``` Compiles as such: ``` public static class _ { [CompilationMapping(SourceConstructFlags.Module)] public static class M { [CompilationArgumentCounts(new int[] { 1, 1, 1, 1 })] public static R f1&lt;a, b, c, R&gt;(FSharpFunc&lt;a, FSharpFunc&lt;b, FSharpFunc&lt;c, R&gt;&gt;&gt; g, a a, b b, c c) { return FSharpFunc&lt;a, b&gt;.InvokeFast(g, a, b, c); } [CompilationArgumentCounts(new int[] { 1, 1, 1, 1 })] public static R f2&lt;a, b, c, R&gt;(FSharpFunc&lt;a, FSharpFunc&lt;b, FSharpFunc&lt;c, R&gt;&gt;&gt; g, a a, b b, c c) { return FSharpFunc&lt;a, b&gt;.InvokeFast(g, a, b).Invoke(c); } [CompilationArgumentCounts(new int[] { 1, 1, 1, 1 })] public static R f3&lt;a, b, c, R&gt;(FSharpFunc&lt;a, FSharpFunc&lt;b, FSharpFunc&lt;c, R&gt;&gt;&gt; g, a a, b b, c c) { return FSharpFunc&lt;a, b&gt;.InvokeFast(g, a, b).Invoke(c); } } } ``` Note that the `|&gt;` and `&lt;|` variants are equivalent, but the `f a b c` function actually has one less call involved. So, should you always use `f a`? Not exactly. Only when multiple arguments are involved does this come into play, and even then, the F# compiler can optimize some calls to be equivalent. For example, the following F# may make you think that `f2` is less efficient, since it appears to allocate a tuple and "double-pipe" that into `f`: ``` type F = int -&gt; int -&gt; string module M = let f1 (f: F) x y = f x y let f2 (f: F) x y = (x, y) ||&gt; f ``` However, it produces the same output for both functions: ``` public static class _ { [CompilationMapping(SourceConstructFlags.Module)] public static class M { [CompilationArgumentCounts(new int[] { 1, 1, 1 })] public static string f1(FSharpFunc&lt;int, FSharpFunc&lt;int, string&gt;&gt; f, int x, int y) { return FSharpFunc&lt;int, int&gt;.InvokeFast(f, x, y); } [CompilationArgumentCounts(new int[] { 1, 1, 1 })] public static string f2(FSharpFunc&lt;int, FSharpFunc&lt;int, string&gt;&gt; f, int x, int y) { return FSharpFunc&lt;int, int&gt;.InvokeFast(f, x, y); } } } ``` Long story short: always measure and look at outputs.
For the second, you need to import that reference
Wow, very nice 👍
Ok so if I write it like haskell then it's faster, right? 
Can I do it for free?
Yes, yes you can. If it is just an occasional article, I can publish it for you under your name. But if its something you're interested in doing on a regular basis you should go through our training process so we can grant you permission to publish items directly.
You're right, it appears I was mistaken. I use Cvdm but haven't actually used multiple `return!` in my code, so I never noticed the behaviour. So let me amend the above post to: I think it *ought be* idiomatic that (etc.), but I guess it would be a breaking change at this point.
You can pay me for YouTube vids if you want ;-)
We do run videos, but mostly they are filmed at conferences. InfoQ can only pay for exclusive content, as they get their money from advertisers and sponsors. That said, if you are interested in speaking at a QCon conference I can put you in touch at with the right people. https://qconferences.com/
Is your Twitter handle also @Grauenwolf, or is that someone pretending to be you?
I haven't used twitter in years, but I think it's still linked to my Wordpress account.
Ok. I was going to post it there as it has a much better chance of being seen by the F# community.
I am quite interested in becoming one!
Thank you. And it's best to not to mention my Twitter handle since I don't really monitor it.
Continue working with a compiler project for some well-known small company, and still be steady to improve the implementation of HKT and type classes in F#.
A lot of YouTube people do sponsorships to help fund the ongoing effort of creating content. SkillShare and SquareSpace are quite common for art oriented videos etc.
I am currently making my way through Expert F# having had no experience with the language. If you feel confident with any other language the book will not be too advanced for you. That is my experience anyway. Keep in mind it is not a tutorial/course, it reads like a reference manual.
I would say you can still learn quite a lot in F#3. Of the top of my head there were some performance improvements(struct DUs in 4.1, spans in 4.5), usability improvements like list slicing syntax and normalization of collection functions (4.0). But for the large part you wouldn't have to relearn the whole language.
Is that just because you have access to books already that target F# 3.0? There are plenty of excellent 4.0+ books: "Expert F# 4.0" (my favourite, especially if you are intermediate, but also fine for F# beginners who know at least one other language) "Domain Modelling With F#" - Scott Wlaschin "Get Programming With F#" - Isaac Abraham And the inevitable self-promotion: "Stylish F#" - by moi: [https://www.apress.com/us/book/9781484239995](https://www.apress.com/us/book/9781484239995) I think you'd still get the gist by reading F# 3.0 books, but it seems odd to potentially confuse yourself a little by doing that. &amp;#x200B;
cool 👍🏼
To be honest theres not much in F#4 thats deserved a new book.
Actually you could pick up an old Expert F#2 and still get by just fine too.
I have access to Programming F# 3.0 by Chris Smith but I also wanted to pick up Functional Programming using F# by Michael Hansen. All of the books you listed interests me too by the way. It's hard for me to decide so I'm definitely going to be picking up a few.
Actually Chris Smith's is my co-favourite (alongside Expert F#). Good choice!
From the Github thread it doesn't seem to be fully stable, though. Will it become officially supported on UWP documentation and VS tooling, by VS 2019 release?
It's stable. Its compatiblity is increasing over time. It's not complete or official. I see no reason for Microsoft to support it officially and only minimal advantages to users from that.
Sorry I don't check Reddit often. If you have operations: `seq&lt;Operation&gt;` and `inverse:Operation-&gt;State-&gt;State` and `apply:Operation-&gt;State-&gt;State` then you can easily go back from the current state to the previous one. Where `state |&gt; apply operation |&gt; apply(inverse operation) = state`. If you can't find an inverse function then not can go all the way from the initial state but that's slow so you may need to cache a few previous states. I would definitely store the current state as a mutable variable for performance.
So not something I will ever get management to agree on.
How would you use it if it were supported? UWP directly or via Xamarin? FSharp for most of the app or just FSharp library dependencies?
If F# had feature parity with C# on UWP, I could eventually try to sell the idea on some of our Windows 10 RFPs. As it is, management wouldn't be that happy with me putting the idea on paper.
I pushed this issue as far as my startup needed, which is for Microsoft to open the back door. I believe there is feature parity with C# already. If anyone wants official support the best thing would be to take further the work that some of us started. The next step would be to alter the F# test suite to avoid sprintf in tests that don't specifically test sprintf. That might given them enough evidence to change the label from "unsupported" to "supported with known workarounds".
On my case, I have other battles to fight. If the powers to be at DevTools don't see a value in giving tooling parity to what VB.NET, C#, JavaScript and C++ enjoy in UWP, so be it. 
That's very reasonable but you shouldn't then complain if Microsoft has the same attitude that its energy is better spent on other things. If you want something better than what we have achieved so far you will have to work for it.
It very valuable from you to do the work for free that the .NET team was supposed to do, and I congratulate you for your efforts. However as Microsoft customer I am also allowed to complain if they fail to deliver in some areas of their products. F# is yet another proof that betting on platform languages is the best way for productivity. 
I am mid way reading your book “Stylish F#”, completed The Haskellbook to understand fn programming better, and your book is succinct and just the right amount of dose to pick up F#. I am really enjoying it. 
How did you find the Haskellbook for grokking fn programming? 
If you just want to understand the functional concepts then Scott Wlaschin's series or "Functional Programming in C#" is not bad at all. However if you really want to understand functional paradigm with mathematical concepts really well go for "Category Theory For Programmers" and HaskellBook - reading these will make you understand concepts really really well and gets the concept ingrain. If you pick later, picking up any functional language will be a walk in park (aside: no language comes close to a superior syntax as haskell - i cry when i look at scala code)
thank! I'll definitely look into those two books as well.
Per your recommendation I just started reading "Domain Modeling with F#" and this has been an awesome book, and I haven't even made it to the F# stuff yet. My team is using so many of these practices and this book is contextualizing all of it (or perhaps it's the other way around). Very practical and accessible so far.
Great. Thanks so much for your custom, and for the feedback. It's always hard to judge how much detail to put in but 'succinct' and 'enjoyable' are what I was aiming for!
Hansen's academic, which I liked -- he focuses on basic functional ideas, so no worries about version differences there.
It's good to see systematic articles like this. A problem with the F# ecosystem is there are many approaches and libraries for standard tasks, serialization and sql in particular. So it's hard for someone to choose the right libraries without becoming an expert. Chiron is manual serialization and deserialization but without the performance benefits usually associated with manual serialization: [https://theburningmonk.com/2016/01/ms-bond-and-chiron-benchmarked/](https://theburningmonk.com/2016/01/ms-bond-and-chiron-benchmarked/) . So I would not recommend using this in production. Manual serialization and deserialization is pretty easy, e.g. using JsonObject from NewtonSoft.Json and reading and writing directly. But Json in general is overused. It's the wrong approach for most purposes to convert to and from strings. (The inefficient habit of converting things into maps instead of arrays is similarly overused.) When human readability is important, convert at the point when the human has to read it. We have adopted CBOR and it's fast and compact, easy to manually serialize to and from, and convertible to JSon when it needs to be human-read.
CBOR looks interesting. Is there a Nuget package you'd recommend for working with it?
Using [https://github.com/peteroupc/CBOR](https://github.com/peteroupc/CBOR) [https://www.nuget.org/packages/PeterO.Cbor](https://www.nuget.org/packages/PeterO.Cbor)
Oooh, interesting, thanks!
As somone who learned F# through reading Haskell code (as the amount of good FP resources for F# was and is a bit lacking) - If I were to do it all over again I'd probably just start with Haskell.. 1. Learn Haskell using [http://haskellbook.com/](http://haskellbook.com/) 2. Read something like Export F# 4.0 since at this point you should have a good understanding for FP and pretty much just need to learn the F# the language. 3. Start working on reading through this: [https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/](https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/) 4. Be slightly annoyed at the fact that F# isn't as expressive as what you are used to from Haskell. 5. ???
Yeah, so, I rely heavily on serialization so try to keep up with the different library. I've never understood the point of Chiron. It always seemed complicated, poorly documented, and not much better than defining your own interfaces. Despite reading through the source and samples several times I still have absolutely no idea what the operators are for, and what value it adds.
As far as I've understood, messages are only sent from either the view function (through dispatch) or via commands returned from the update function. Is this enough information? Otherwise, can you provide a minimal code example that described your issue?
I don't have WPF example, nor would I advocate to mix Rx with elmish, but from elmish perspective there's no difference between making http request or calling a database. You return commands from `init` and `update` functions to do that. There are tons of examples for http requests from SPAs and the only difference is that in the browser ecosystem we work with the primitives that return `Promise` which we hookup into a command via `Cmd.ofPromise`. If you can expose a data access method that returns `Async&lt;Something&gt;` you'd use that with `Cmd.ofAsync` to map the result into your message and you're done. If you want to step up in your abstractions, you can expose a set of DB commands instead, take a look at my elmish/oidc repo to see how that is done.
I've been playing around with Elmish.WPF also. I have a small sample work in progress, which uses Rx to trigger an external event from a timer and then an elmish subscription to that event. Feel free to have a look [https://github.com/wilsoncg/MarketWatch.Elmish.Wpf](https://github.com/wilsoncg/MarketWatch.Elmish.Wpf/blob/master/MarketWatch/Program.fs) As for your problem, I would suggest looking at the various [elmish commands](https://elmish.github.io/elmish/cmd.html). You should then handle the command in the update and return an updated model. I too am looking for examples but not finding many, I get the impression that Elmish.WPF is very niche, so we will have to create them ourselves!
I think this is what you're looking for ? [https://github.com/elmish/elmish/blob/master/docs/content/subscriptions.fsx](https://github.com/elmish/elmish/blob/master/docs/content/subscriptions.fsx)
Agreed. I spent some time a few months back trying to understand and use it, but it had a lot of restrictions: I could never find a good way to serialise and deserialize Maps with a DU for the key. I needed to serialize/deserialize into more than one format, which I couldn't figure out how to do. And if I can remember correctly you had to keep the serialisation code with the models. That felt really nasty. Polluting my Domain model namespace with JSON specific serrialization. In the end I created a separate set of DTOs with custom Domain &lt;-&gt; DTO conversion code, then used Newtonsoft.JSON to serialize/deserialize the DTOs. I did originally try to use Newtonsoft.JSON on the raw domain models. Unfortunately it chokes if your model has DUs as Map keys anywhere. And It really does some produce some monsterous JSON if you have complex DUs. (That's probably only a problem if you need other services to use your output)
No, if I understand his situation (UI-&gt;logic-&gt;DB-&gt;logic-&gt;UI) he shouldn't go through subscriptions.
You're right. I got that wrong 
Fascinating stuff! &gt; "through the async implementation used in the system MLDonkey by Fabrice le Fessant" MLDonkey is mentioned but I cannot see any reference to OCaml's LWT library for async. &gt; async { &gt; let! x = p1 &gt; let! y = p2 &gt; return x + y &gt; } Interesting to compare with the equivalent circa-2000 OCaml code using LWT: p1 &gt;&gt;= fun x -&gt; p2 &gt;&gt;= fun y -&gt; x+y The main practical differences are: * Async loops in OCaml rely upon shared mutable state. OCaml's approach doesn't handle exceptions but, then, daemon-style code tends to avoid exceptions at all costs anyway. * Async is 10-100x faster in OCaml than in F# because computation expressions are extremely inefficient. &gt; The introduction of computation expressions to F# hit three nails with one hammer: iterators (C#), list comprehensions and async programming were all dealt with via the one general syntactic mechanism I am actually of the opinion that F# goes to great lengths to factor out commonality that isn't there. Firstly, iterators and list comprehensions are the same thing: sequence expressions. Secondly, a decade later and generators and async are the only two practical applications of this abstraction I have ever seen in (non-Microsoft) production code. Thirdly, they uses different syntaxes with sequence expressions using `yield` when async does not and async using `return` when sequence expressions do not. 
I like and use both F# and OCaml, but from this paper and own experience it seems that F# is the practical OCaml. Except in rare circumstances, when would one choose OCaml over F#?
Thank you for answering the actual question positively based on both your experience and the public reality, rather than mere speculation!
Thank you for sharing this encouraging bit!
&gt;nor would I advocate to mix Rx with elmish I'm trying to understand Elmish and Rx won't jive. Is it because making use of an observable would require state (the observable itself), which does not exist in the FP / Elmish paradigm? 
That is an interesting solution; thank you for sharing. My concern here is that by declaring the observable at the top of the module, it has become global state, which I think may be an anti-pattern. Also, while it might work for one WPF window, what if more than one was needed? Just thinking out loud, but I wonder if it would be possible to encapsulate the Elmish bits within a class / instance instead of a module. Then each instance could contain its own state / Rx observable. &amp;#x200B;
When one works mostly in UNIX based OSes, cares about battle tested AOT compilation support, and better low level support for system programming (see MirageOS).
I'm not sure I agree with that comparison. Perhaps in the F# 1.0 days that was a bit more true, but F# and OCAML have since diverged quite a bit on what they support and what people using either language tend to focus on. The core of each language is nearly identical, but if you want to do anything with F# for an application (such as a Giraffe web app running on .NET Core), then you'll be using a very different feature set.
As to Unix based OSes argument, .net core runs on major Linux distros. I use OpenBSD at home, but I have never seen a *BSD machine in production. 
The section in the paper near the end goes into this a bit, though I think it's important to divorce language _design_ versus _implementation_ approaches. For example: The overall design of `byref&lt;'T&gt;` was flawed until F# 4.5. This had to be reworked so that F# could actually utilize the zero-copy benefits the .NET Core runtime brings with `ByRefLike` structs. But even then, it isn't without its quirks in the design. Since `|&gt;` is a generic function, and `ByRefLike` structs cannot be parameterized in a generic function otherwise they get heap-allocated (which would then violate an invariant), you cannot pipe `byref&lt;'T&gt;`s into other function. This is a design problem that would probably take a lot of time and care to handle properly. In contrast, the implementation of some Computation Expressions can be inefficient, but the construct itself isn't too terrible. We're considering a `task { }` CE for some of the high-throughput needs that .NET Core developers have, and current implementations can already achieve most of what people need. Some additional work in the compiler would be needed to eek out a bit more performance, but it's not monumentally hindered by the CE mechanism itself.
You raise some excellent points. The reason I created the solution was to explore exactly those issues you have highlighted. I want to explore what happens when an application has say 1,000 market subscriptions, but renders only 50 at a time, or asynchronously retrieve data from a database table with a million rows and multiple filters applied. I am still learning what the correct Elmish WPF approach is. But feel free to fork or copy what I have so far, I would really like to see your improvements.
This reminds me of T-diagrams from my compilers course. It's good to see these concepts in actual practice!
You definitely don't choose Ocaml if you want unicode support.
Yes it runs on UNIX, but the tooling isn't at the same level, given the lack of AOT compilers. Netflix delivery platform is built on top of FreeBSD, with Erlang.
Interesting problem. Would a map with ids for the nodes work?
Of course it would work but don't you lose some type safety, which is the whole point of compile-time type-checking with type systems such as F#'s?
Why would you lose type safety? ADT are only one tool in the type safety toolbox, there's more
I just don't see the need. Technically - possible, conceptually - unnecessary. 
You can use a product type, which counts as an ADT, but are you looking how to represent it as a Sum type? &amp;#x200B; type Node&lt;'T&gt; = { data : 'T children: Node&lt;'T&gt;\[\] }
children needs to be mutable if you're building *cyclic* graphs.
module rec?
I think this is the real issue! If you avoiding mutability there is no way you can have cycles because to make use of a name, it has to be already defined.
Please explain further?
Alrighty then.
I don't know if that's what they meant, but you can still have strongly-typed nodes with ids. Something like this for example: type NodeId = int type Node&lt;'T&gt; = | Node of NodeId * 'T type Graph&lt;'T when 'T : comparison&gt; = { nodes: list&lt;Node&lt;'T&gt;&gt; edges: Map&lt;NodeId, list&lt;Node&lt;'T&gt;&gt;&gt; nextId: NodeId } module Graph = let empty : Graph&lt;'T&gt; = { nodes = []; edges = Map.empty; nextId = 0 } let addNode value graph : Graph&lt;'T&gt; * Node&lt;'T&gt; = let node = Node (graph.nextId, value) let graph = { graph with nodes = node :: graph.nodes nextId = graph.nextId + 1 } graph, node let addEdge (Node (srcId, _)) dest graph = let srcEdgeList = match Map.tryFind srcId graph.edges with | None -&gt; [dest] | Some l -&gt; dest :: l { graph with edges = Map.add srcId srcEdgeList graph.edges } // Example use: let myGraph = let g = Graph.empty let g, node1 = g |&gt; Graph.addNode "node1" let g, node2 = g |&gt; Graph.addNode "node2" let g, node3 = g |&gt; Graph.addNode "node3" g |&gt; Graph.addEdge node1 node2 |&gt; Graph.addEdge node1 node3 |&gt; Graph.addEdge node2 node3 
Exactly!
Congrats!
\&gt; Async is 10-100x faster in OCaml than in F# because computation expressions are extremely inefficient &amp;#x200B; can anything be done?
Oh yeah. The F# compiler could optimise it to state machines as C# does. 
simple matter of programming then. let's get going! &amp;#x200B;
Better check that Microsoft want it in their repo first otherwise you're looking at forking the compiler...
What degree of difficulty are we talking?
It's basically an introduction and I'd imagine it wouldn't be a problem for someone used to OOP. I've sadly fallen a bit behind on my studies due to personal issues, which is why I'm requesting 1v1 help. I can show you the files and give you a description once I'm home. I decided to go home a bit earlier, so I can show you in around an hour or so.
Sure, I’d be happy to take a look and see if I can help out. 
Sure, I’d be happy to take a look and see if I can help out.
Thank you, I appreciate it a ton. Do you use Discord? PM me your handle if you do.
This looks "promising": [https://github.com/dbrattli/Reaction](https://github.com/dbrattli/Reaction) &amp;#x200B;
Sorry - by "cyclic graphs" I assume you mean "graphs that may in general have cycles?" A.k.a "graphs more general than a tree/forest." The Haskell library Alga has an interesting approach: [https://github.com/snowleopard/alga](https://github.com/snowleopard/alga) Roughly, in F#, /// Representation of a graph G = {V,E}, with V the vertex set made of elements of 'T, and E the edgeset (elements of 'T*'T) type Graph&lt;'T&gt; = /// The empty graph. | Empty /// The graph consisting of a single vertex from 'T (edgeset is the empty set) | Vertex of 'T /// The graph built from two graphs G1 = {E1,V1} and G2 = {E2,V2} by G_overlay = {V1 ∪ V2, E1 ∪ E2} | Overlay (Graph&lt;'T&gt;) (Graph&lt;'T&gt;) /// The graph built from two graphs G1 = {E1,V1} and G2 = {E2,V2} by G_connect = {V1 U V2, E1 ∪ E2 ∪ (V1 × V2)} | Connect (Graph&lt;'T&gt;) (Graph&lt;'T&gt;) So you can see how to build graphs recursively - add two `Vertex(v_i)` graphs, `Connect` them, add another `Vertex`, etc.
Does anyone know which release this is scheduled for?
I like how well F# combines with Azure Functions that run from top to bottom, this is a really good use case. Most of the web where you have a request and response type of logic can be solved much more elegantly with F# than C#. The problem is that GUI applications are usually cyclic and keep a state, using functional patterns there can be degramental to performance. Right now it looks like you are better off writing UI applications in C# and business logic or backend in F#. C# code looks (imho) better when working with loops and mutating state. As a professional developer, so far I've had zero luck convincing coworkers to try out F#, not to mention stakeholders. At best, I've taught them functional paradigms like LINQ data flows, not reassigning variables, handling all logic branches, etc but a whole new language is too much. I think you need to first demonstrate (probably from your own free time) the theoretical benefits of a functional language before you can use it in your workplace. Do like I do and write F# for your personal stuff in the evening and C# during work hours. Learning a function language improves your problem solving skills and you are still hireable when you offically work with .NET / C#. F# has a lot of benefits over C# but it looks like you need to climb a mountain of challenges before you can reap many of them.
The short answer is: when it's ready :) There's a long tail of testing needed, plus there are quirks with it today. We intend on it being _the_ way you reference things for scripting moving forward (`#r` on assemblies still works, it'll just be seen as an old way to do stuff). Data Science and ML.NET are big motivators for this. However, it's not ready to ship yet, nor has there been tooling hookup work yet.
Thanks for working with this and i really look forward to it :-) I would like one super big motivator that would love this: Dev Ops Being able to write typed short scripts in F# that are easy to distribute (just one file) that automatically pulls down dependencies is pure Gold for Dev Ops. Scripting and dealing with dependencies usually sucks. Just look at PowerShell where you have to install modules and or import. With this its just an #r away :-) its super convenient. Its also excellent for learners of F#. You don't need to start a whole project to build small things that relies on other packages. Being able to write small F# fsx files is a great way to learn F# It could also be used for serverless. Just upload an fsx file per service. It would download all the dependencies it needed. So there are a lot of potential good use cases and i also agree alot with the ones you mentioned.
Hey, pure\_x01, just a quick heads-up: **alot** is actually spelled **a lot**. You can remember it by **it is one lot, 'a lot'**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
\&gt; The problem is that GUI applications are usually cyclic and keep a state, using functional patterns there can be degramental to performance. This is... not 100% correct. Popularity of React/Redux and Vue.js in the front-end world shows that using FP principles is not only viable, but just really good way of building UI applications that are composable and easy to reason about (unlike mutation driven MV\* approaches that has neither of those qualities). Not to even mention the Elm, PureScript or ClojureScript which proves that \*purely\* functional programming is also great way for building UIs. Ofc, F# community has created really good libraries/frameworks inspired by the mentioned above solutions. For the client web side it's [https://github.com/elmish/elmish](https://github.com/elmish/elmish), [https://github.com/fsprojects/Fabulous](https://github.com/fsprojects/Fabulous) (created by Don) for the Xamarin.Forms or [https://github.com/elmish/Elmish.WPF](https://github.com/elmish/Elmish.WPF) for WPF applications. 
It's a language that encourages clear thinking, and it's a pleasure to use it for coding. I'm not about to drop C# any time soon, but I might be able to convince some clients to use F# for the more algorithmic parts of applications. It would be great if C# and F# could interact more easily within the same application.
Basically, the best answer to question of whether you should learn FP or OOP is: Learn OOP in order to gain/maintain employment, then learn FP to become a better developer. In an idea world, starting with FP would be a better plan, but since we live in a world where we have to put food on the table, this doesn't really work.
Sorry for the delayed response -- I was busy with real-life projects. This worked like a charm! Here is the counter example from the Elmish.WPF repo that I modified with an Observable&lt;int&gt; to throttle the size slider. [https://gist.github.com/JordanMarr/b578a1f389d32c4c5b4c5d83717d1711](https://gist.github.com/JordanMarr/b578a1f389d32c4c5b4c5d83717d1711) &amp;#x200B; I added the observable to the model, and then used the `Program.withSubscription` per your suggestion. The only issue I had was that the "Reset" cmd, which previously called `init`, did not re-init the `Program.withSubscription` handler, so I modified it to preserve the already initialized `StepSizeChanged` model property. &amp;#x200B;
Interesting that you talk about FP vs OOP at all. Most of the benefits of F# have nothing to do with either.
I was under the impression that Vue.js was an MVVM approach to frontend. I can understand why one-way bindings would be more popular, since they enable functional reactive programming on MVVM frameworks. I didn't expect bidirectional bindings were that far off the beaten path for Vue.js, though. FRP-based UI design definitely makes sense to me when working with a complex, mostly-asynchronous or event-driven system. From that, it makes total sense why React/Redux are popular for single-page applications on the front-end.
I'll bite. What are the benefits that have nothing to do with either?
Yes, plain Vue is some kind of MVVM pattern, just like plain React is a variation of the MVC (or at least it used to be, arguably React team has been pushing pure and function components nowadays). But Vue team provides Vuex (https://vuex.vuejs.org) library that is basically implementation “The Elm Architecture”. 
Oh, I wasn't aware of Vuex, now it all makes sense!
I can model the domain with way less ceremony. 
That's definitely a hot take.
probably, maybe theyre just on separate forks i can say the issues are active with conviction tho
Don’t learn it. Wasted effort!
https://github.com/Microsoft/visualfsharp
That's downstream maintained by F# Software Foundation. Upstream repository is this https://github.com/Microsoft/visualfsharp and it's quite active
Learning a functional language is considered by many to be a excellent way to expand your skills, and fsharp is a really good choice.
Well thought out and argument post. 👍
See the readme for the rep you linked: &gt;The main day-to-day purpose of this repository is to deliver extra packagings of the F# compiler, core library and core tools for use in different settings. This repo accepts direct contributions related to the cross-platform packaging of F#. Most other contributions to the F# compiler/library/tools go first via the [upstream repository](https://github.com/Microsoft/visualfsharp) which is also used to package the Visual F# Tools and .NET SDK tooling for F#. &amp;#x200B;
The last time I logged a compiler bug (a few months ago) it was picked up and fixed overnight.
I think it would be a brave-ish person who committed to using F# exclusively for GUI-heavy development. If you are limiting your choices to F# versus C#, and to desktop rather than web, then honestly I would start with C#. You can always move later to have domain modelling/business logic in an F# layer and keep the C# thin. But it's also worth questioning the decision to make your stuff desktop oriented even for business apps. (Unless those apps are closely coupled to the desktop because they have to access files, hardware etc.). If you're open to web based, then it's worth exploring Fable and SAFE-Stack a bit - but that too would be a pretty steep learning curve especially if you are new to F#. Maybe look at node.js too?
This must be a dumb question, but what's the difference between a "downstream" and "upstream" maintained repository?
I'm not 100% expert, but this is my understanding. Historically, F# started in Microsoft labs and was 100% MS product. Then back in 2013 or so they decided to make it open source and organized non-profit organisation F# Software Foundation (FSSF) which has to be the main maintainer of F# code and community. Both (MS and FSSF) are contributing to F# and both have their own public repositories in GitHub. In fact the main development is happening in MS repo, while FSSF is only a mirror of that activity plus it accepts some contributions related to the cross-platform packaging. This is how the changes distributed now: from MS repo (upstream) the changes pushed down periodically to the mirrors or forks (downstream).
Upstream means it's the original source, where main development happens. Downstream means it's a fork, potentially with some specific changes. In this particular case microsoft/visualfsharp is the upstream repo, and fsharp/fsharp is a downstream repo that adds tooling for building it on Mono (IIRC that's the main difference). fsharp/fsharp.compiler.service is another downstream repo that adds a library to implement code services for F#.
The main benefits are: 1. Hindley-Milner type system with tuples, records and unions. 2. Damas-Milner type inference with automatic generalization. 3. ML-style pattern matching over tuples, records and unions. 4. Active patterns. 5. Type providers for disposable exploratory code. Functional programming definitely deserves a place on the list but people always assume that it is the crux of the issue when it is just one piece of the puzzle. 
&gt;Bad hombres!
Found the blub programmer 
Learn Haskell instead if ‚functional‘ is your goal 
I don't understand. Do you just go to programming language subs and shittalk other tools? What do you get from this? Some sort of misguided gratification that your selected tool is obviously better than others? I hope you defeat these insecurities you have.
Also if you want to know whether the language itself is being actively worked on: https://github.com/fsharp/fslang-design
I'm not interested in a fight. I consider it a wasted effort because it isn't much used in industry and quite frankly you don't get very deep into functional concepts. You scratch the surface with F#. There's too much distraction with the C# compatibility layer. Also I didn't get personal to anybody. I don't see why you would connect that to insecurities but nevermind... i don't care.
&gt;"GUI applications \[...\] can be detrimental to performance" I always choose OOP languages every time I need to write GUI code that needs to handle more than 10,000 mouse clicks per second (i.e. never - sarcasm). In all other cases, I use F#, because it is safe, short, concise and fast to debug.
The answer to this would make a great sidebar link mods if you're out there
The process for improvements to the language and the overall 'roadmap' for lack of a better term can be found at two Github repositories. * [Suggestions](https://github.com/fsharp/fslang-suggestions) * [Approved and completed RFCs](https://github.com/fsharp/fslang-design) The process is generally: * Suggestion is submitted and discussed * Suggestion is marked 'approved in principle' * And RFC is created (in fslang-design drafts folder) for the suggestion to serve as the design document/release notes/etc. The RFC links to the PR that implements the feature (as soon as it is opened) * Discussion happens on the draft to nail down design * Once the design is finalized, a PR is opened and the RFC moves to the RFCs folder to signal it is actively being worked * Once the implementation is done and tested, the PR is merged. The RFC is moved to the folder for the specific version of the language/FSharp.Core version it applies to. This makes it easy to see each set of changes in a specific version of the language. That's it in a nutshell. If there are specific changes that you'd like to see happen for F# 5.0 I'd encourage you to engage with those repos in discussion on the issues/RFCs, and potentially even help work on the implementation of those features! 
So the end result is that you pissed a bunch of people off with your very short answer with no arguments at all, and then went back and spent time on a good answer with what i consider to be perfectly good arguments. If you had added those in your first post, it would have added great value.
Nice, wish to see something about sqrs with commands and pipelines :) 
Nice job, you make adding rx look easy. I don't know how often the contacts are likely to change but, does it make sense to have the facade.GetContacts() periodically poll for updates instead of just pulling the one time? FYI I'm a MVU noob and don't know what Revit is so take my feedback with a grain of salt.
It's not that it's an unholy, it's just that something like throttling aka "debouncing" is trivially accomplished w/o it. There's an example in elmish debugger and I think Maxime has a debouncer in his Thot collection. OOP+FP is fine, something like the global state (`contacts`) is not. If you need to call data access, change `mkSimple` to `mkProgram` and use commands to issue reads. You can start with the simple `Cmd.ofFunc` and convert it later to a custom command.
&gt; created by Don Forked by Don, ftfy ;)
&gt;It's not that it's an unholy, it's just that something like throttling aka "debouncing" is trivially accomplished w/o it. ... I think Maxime has a debouncer in his Thot collection Your point is valid only for simple cases (i.e. when you have a dependency on Fable and want to debounce), but in my case, I actually need more than just debounce: I need to combine it with DistinctUntilChanged, and CombineLatest to merge multiple filter streams into a single subscriber that applies all the filters. I need the full power of Rx! &gt;OOP+FP is fine, something like the global state (contacts) is not. If you need to call data access, change mkSimple to mkProgram and use commands to issue reads. You can start with the simple Cmd.ofFunc and convert it later to a custom command. Thanks! This is useful feedback. &amp;#x200B;
I think that adding polling to the facade.GetContacts() could be easily accomplished by creating a timer in the `rxSubscription` function, and dispatch a new "ReloadContacts" msg from the timer tick event. However, it looks like I need to do some more work to this sample so that `contacts` is no longer class level state, so i'm not exactly sure yet what that will look like. to be continued...
Fair point. I'll try harder next time.
&gt;DistinctUntilChanged / CombineLatest Can you use a simple Seq.distinct in your data? And mergin data in F# is also a simple task. I am no expert in Rx, but it seems you want to use this, even if there are other way to do it. But maybe I am wrong. &amp;#x200B;
The issue for me isn't finding the RFCs, or even parsing them, it's figuring out the hierarchies and status of those RFCs. There are many *old* RFCs that are approved in principle, and some that are waiting for changes in the rest of .net. It's quite difficult to tell where development is being focused, at least to me. This may just be an issue of involvement, as I learn the language more I will pay more attention, maybe contribute, and see things more clearly. But the C# suggestion repos are much cleaner imo.
F# is perfectly good for GUI-heavy development, including approaches incorporating mutation and making heavy usage of .Net GUI components. You can handle mutation in procedural ways, or better use reactive approaches. F# does not support some standard .Net GUI approaches quite as well as C# (mainly tooling): XAML/binding in particular. But these two are arguably worth avoiding in C# too, with all the loss of type safety, all the INotifyPropertyChanged boilerplate, reflection and magic strings, and the nonsense of Value Converters. Desktop-only and web-only are both unfortunate choices, the first because it doesn't cover mobile usage, and the second because it gives a poor experience on both dekstop and mobile.
Rx reverses control flow, so the data is pushed into the pipeline as opposed to the pipe pulling it like enumerable/seq does. Rx offers linq-like selectors, so it may look similar but threading model is completely different - seq will block the current thread, rx observers work on separate thread(s). Elmish dispatch loop does something similar, except that the app is a single observable for everything and it streams all the data through the same pipe on the same thread.
F# is in a weird spot.. I don't think I can recommend the language for getting a job (some people make good money using F# according to stackoverflow) nor would I recommend F# for improving at functional programming, meaning there are better options. It's the best statically typed functional language on .NET :P It's not a bad language it's just not that amazing either. 
&amp;#x200B; so here is your example, but without react. (maybe some optimizations are necessary) &amp;#x200B; [https://github.com/DieselMeister/wpf-elmish-async-debounce-example](https://github.com/DieselMeister/wpf-elmish-async-debounce-example) it contains a debounce function (which returns "DoNothing" Messages in case the characters are expired. (this is a quick and dirty debounce function). Also It uses the Cmd.ofAsyncMsg to run a asynch command. (the filtering of your collection, or you can start database call or something). To use the debounce I have split the process into 2 Commands. SetContactsFilter implemnts the async debounce ... and the second command ContactFilterSet actually filters the data with your command asynchron. So you doesn't has need the react stuff. And doesn'T init the react stuff in a subscription, which runs all over your whole application. If yu have multiple pages, than I think you get into trouble to have a global subscription.
Nice! It seems to work. Now add "DistinctUntilChanged" (so that typing "250" twice in a row doesn't execute again), simplify the usage a bit, and then put it into a NuGet package for use with Elmish and you would have something that would be fairly useful. "CombineLatest" is more of a nice-to-have, but one that can really eliminate bugs when you have lots of filters. However at that point it would just be reinventing Rx, which is silly because Rx already exists, and it is industry standard. It is unfortunately that the subscription work around causes problems down the road. But hey, that's why I was just doing this as a spike instead of for production. Good to know. &amp;#x200B;
The distinct part is your homework :D. I want you to know, there are ways to implement your requirement into an elmish architecture. And it is no reinventing. Some of the things are basic stuff. And if they are not basic, than peek into to the source code of rx ;) and implement the algorithm into f#. :D
Actually it *literally is* reinventing Rx. lol I mean, it's fairly trivial to do those two, but that's a fragment of the functionality. The power of Rx is the composability of *many* stream manipulations, using a *clean* syntax and a library that is *tested*. I am loving F#, but I am fast coming to the conclusion that I am not willing to hoist MVU on my team at this point. Don't get me wrong, I dislike having to use a C# front end to call my nice F# back end library because then my API can't natively use Option types, DUs, etc. But I think it would be... not an enjoyable experience... to use MVU architecture for a complicated UI with lots of nested controls. I'm not saying that MVVM is perfect. In fact it's far from perfect, and two way binding is fast becoming an anti-pattern. I want to like this because I think FP UI design is likely the future thanks to React with Redux making it mainstream. Maybe my best course of action for now would be to create MVVM style UIs using F# / OOP. &amp;#x200B; But point taken on there being ways to implement my requirements into an Elmish architecture. 
yes! they're called `signatures` in F#, and you create them with `.fsi` files. The compiler uses them to handle module member accessibility (public/private) as well as to house the external-facing documentation. For example, here is the signature for the `Seq` module: [Seq.fsi](https://github.com/Microsoft/visualfsharp/blob/master/src/fsharp/FSharp.Core/seq.fsi) You just include these files in your project like any other `fs` file and you're good to go.
thanks!
The short answer is that there are a few fundamental things happening for .NET with .NET Core 3.0 that we'll be supporting either fully or partially: * Explicit nullability for reference types * Interfaces that support default implementations for members (consumption support for F#) * `System.Index` and `System.Range` support * Unmanaged constructed types (take the address of a generic struct provided it doesn't contain managed objects) We've spec'd out nullability and done lots of work on it already, but the rest still need attention after F# 4.6 is finished off. Beyond that, we haven't prioritized other RFCs yet. I personally would like to get `let! .. and!` (i.e., applicatives), `task { }`, and more advanced slicing support in addition to what has been listed above. But the team is focused on successfully shipping what we have while making a bit more headway in longstanding performance issues. Once the dust settles on that rush, we'll have a pretty hard push for F# 5.0 prioritization. This is why the RFC process exists as-is, and why there are more approved suggestions and written RFCs than what is currently being worked on. Anyone in the community and write an RFC or submit a pull request to speed something up that they really want to see in the language while we're focused on something else. Although there's no guarantee of a merge at a given time, we do have a history of getting feature-complete community contributions into forthcoming version of the language.
Minus all the functor stuff...
Every time I start to think I have a modest grasp on F# I see a link to something like the Seq.fsi above, read the following, and feel my brain melt 😐 val inline average : source:seq&lt;(^T)&gt; -&gt; ^T when ^T : (static member ( + ) : ^T * ^T -&gt; ^T) and ^T : (static member DivideByInt : ^T * int -&gt; ^T) and ^T : (static member Zero : ^T) 
Average requires that the thing you're going to average can be added and has a 'zero' element, and can be divided :) Boom explained!
There are attempts to simulate/fake/whatever you will call it - type classes with SRTPs (statically resolved type parameters) - which works to some degree ([example](https://fpish.net/topic/None/59738) - there is a library doing this on github but I cannot find it nor remember its name right now sorry) but has their own issues (the syntax is really ugly and you might get the type-checker/compiler into real trouble). Over the last few years there was some effort to bring type classes to F# (don't know the current progress or if this is still a goal) but this approach lacked HKTs (you could express `Show` but not `Functor` for example). So IMO the answer to both of your questions is NO: - F# does not have type classes right now - what F# has (and is planning AFAIK) does not really compare favorably to Haskell
It does not. There have probably been some proposals to add it in. It has also been hacked in on top of existing language using inline functions that magically lookup the type class information via a helper struct encoding the typeclass, or at least that was the gist of what I understood.
You can kind of get the same outcome via interfaces and classes.
No, however [https://github.com/fsharp/fslang-suggestions/issues/243](https://github.com/fsharp/fslang-suggestions/issues/243) recently changed status to "await-csharp-alignment"
Eh?
F# supports interface files but OCaml supports interfaces everywhere which is really useful. F# actually used to support that (and I used it a lot) but the support was dropped. 
I said kind of, not the same thing. A mix of generics, interfaces and classes gets close enough for most use cases.
Thank you guys, this has been helpful. Scala encodes typeclasses through implicits which is a natural construct in the language, if there is no such equivalent in F# then it is a pity.
Thank you for the detailed reply, I appreciate it (you're cartermp on GitHub aren't you!). I've found the 'started' tag now, so that helps a lot. The use of 'Projects' by some MS repos is much appreciated, as that helps to see where things are at etc. That kind of workflow would probably be quite a change, and may not be merited. The proposal champion tag from the C# repo is also quite nice, it makes it easier to follow the issue imo. Just some thoughts that might make the process easier to parse for newcomers like me! 
I’m dead sure that f# will never develop a taste for advanced type system shenanigans like Haskell or scala. If you want to be on the cutting edge, f# is not the right choice. You chose it because it is a fast functional language with access to the .net ecosystem. 
It sure is! I rather not use F# for this reason unless I'm forced to. On the other hand Scala's syntax makes my eyes bleed. If it was up to me, I wouldn't touch anything that isn't Haskell or Purescript.
I'm no expert in type provider authoring or TDMS, but this looks very interesting.
The new list might be empty though because of ```if x % p &lt;&gt; 0 then yield x```
`(p::xs)` is destructuring the list into the first element (`p`) and the rest of the elements (`xs`) When you call the function recursively with the list comprehension (the `for x in xs do...` bit) you're only iterating over the 'rest' of the elements - the `xs` So each time you call `sieve` recursively, there's 1 less element in the list. Eventually you'll call it with the empty list, which returns an empty list, as per the 2nd pattern match case (`[] -&gt; []`)
This is a nice, clean implementation of a TP, well done! I'd suggest you submit this to the [awesome-fsharp](https://github.com/fsprojects/awesome-fsharp#type-providers) list over on github.
This function starts by going down to the smallest prime integer and builds a "filter" of sorts (a sieve if you will) by taking out the multiples of those numbers. [wiki link](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes) . The reason why this particular implementation stops is because of if x % p &lt;&gt; 0 then yield x this means the list might sometimes be empty (in the case of non prime numbers to be precise) and then will hit the exit condition on the pattern match
Happy to add some context :) The "started" tag is, unfortunately, rarely accurate. I've taken it upon myself to actually remove some of these process-related things (e.g., status tags) that end up not being used or languish as things evolve without updating them. On one hand, it doesn't help with clarity on what's happening. On the other hand, it won't mislead people into what's happening either. As for the C# repo, there is a bit of confusion there. I'd be hard-pressed to find a non-Microsoft employee that could say what is actually shipping in C# 8. Many people think that it's getting Records, for example, when it's definitely not. But it's still a championed proposal. Is that helpful? In a way, yes, because it does give a view into the team's aspirations around shipping things. But I do feel like it can mislead people if crystal clear, up to date tagging is used at all times.
I can learn a lot from this codebase..
I assume you're referring to [existential quantification with interfaces](https://www.gresearch.co.uk/2018/08/17/squeezing-more-out-of-the-f-type-system-introducing-crates/)? I suppose the quick answer here is, "yes", but the hoops you have to jump through do make this sort of thing hard to do for most programmers. Luckily blogs like this and libraries like [TypeShape](https://github.com/eiriktsarpalis/TypeShape) do show how to do it :)
They aren't even a first class citizen in Scala. You can use Scalaz, sure but to say that it's "encoded through implicits" is borderline propaganda. F\* compiles to F# and includes Dependent Types, Refinement Types, and a weakest precondition calculus. All of these are frankly a lot more interesting than type classes which mostly just get used for some code reuse.
If we don't give the children alcohol we'll NEVER be popular as a church youth ministry. Enabling people and helping people are different things. Giving someone an answer to their literal homework is absolutely terrible advice, it's also morally reprehensible. 
Thanks for your help. Yes, I'm only iterating over the rest "xs". But it also prepends p again "p :: sieve [...]", doesn't it? 
It does, but the recursive call only operates on `xs`. `p` is appended to the return value of the recursive call. In your example, the first time you call `sieve`: p = 2 xs = [3; 4; 5; 6; 7; 8...50] The recursive call to `sieve` will filter out all elements which are divisible by 2. So the 2nd call: p = 3 xs = [5; 7; 9; 11; 13; 15...49] As you can see, the list is already smaller: you've removed the 1st element from your original list *and* all elements divisible by 2. The next time `sieve` is called, it will filter out all elements divisible by 3, then by 4, then 5, and so on... Eventually, `sieve` will be called with an empty list, where it will return an empty list. That empty list is appended to the `p` in the recursive call one level before, which will be (47). Which will return `[47]` (single element list). Which in turn is appended to `p` (43) in the level before that one, returning `[43; 47]`. This continues back through the recursive calls, appending to the `p` at each level, until reaching the 1st function call. At which point the list (`[3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43; 47]`) is appended to `p`, which is 2. Returning you all the prime numbers between 2 and 50.
Amazing explanation. Can't thank you enough. I finally understood it! that really got me down that I didn't understand how the snippet worked and couldn't figure it out on my own. 
Disclaimer: I can't make any personal recommendations, as I am in the same boat as yourself - i.e. a programmer with no learning of FP lingo/theory but I have had the following blog/book recommended to me, but have not had the time to read it yet, but I will forward that recommendation here: https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/ Which has also been compiled into a book: http://www.blurb.com/b/9008339-category-theory-for-programmers By these guys: https://github.com/hmemcpy/milewski-ctfp-pdf 
It's not a good thing IMO because it hinders education.. I suggest you read: [http://haskellbook.com/](http://haskellbook.com/) This book does it right, it cover all these things without being confusing, in fact it expects almost no previous experience in programming. For Category Theory I'd recommend this: [https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/](https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/) \- however I suggest you read the haskellbook first.
Yes exactly.
Thanks. I'll look into those two and in that order.
Reformatted: let function (list: int list): int = let mutable p = 0 for l in list do if l &gt; p then p &lt;- l p
https://github.com/cboudereau/category-theory-for-dotnet-programmers is worth a peek! (cc /u/KeyYam)
Hmm, doesnt work when I do it. Maybe because im on my phone? 
Check response again - just updated.
\&gt; I thought it must be returning the maximum of the list but apparently thats wrong. Can anyone enlighten me? Mostly correct, except for the corner case of the empty list, where it returns 0.
I'd check out this talk which has some fair points [https://skillsmatter.com/skillscasts/11745-easing-the-path-to-f-sharp-adoption](https://skillsmatter.com/skillscasts/11745-easing-the-path-to-f-sharp-adoption) Also this one on category if that' what you're looking for [https://skillsmatter.com/skillscasts/11064-a-pragmatic-introduction-to-category-theory](https://skillsmatter.com/skillscasts/11064-a-pragmatic-introduction-to-category-theory)
How does it hinder education?
The functional programming wave with haskell etc is interesting to read through compared to this panel [he moderated and how its evolved.](https://skillsmatter.com/skillscasts/11438-park-bench-panel-hosted-by-don-syme)
For a decent intro the new native interop stuff with some C# to F# translations. https://blogs.msdn.microsoft.com/dotnet/2018/08/14/announcing-f-4-5/
thank you
I am a long time C# developer who has been learning F#. I think that learning both would be good, if you want a job in the industry then you are going to have a lot more options by learning C#, however the more I learn about F# the more I like it and I have been moving all my personal projects to F# but the fact is there are not many jobs for F# but it will not hurt your resume to know it in addition to C# and would probably benefit you. As others have stated F# enocourages a different way of thinking about programming that is good in my opinion but in today's current climate I would not make it the only language I know.
The `fixed` portion would likely correspond to the `fixed` expression in f#: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/fixed I _think_ the byte* stuff would be achieved through the `NativePtr` module in `FSharp.Core.NativeInterop`: https://msdn.microsoft.com/visualfsharpdocs/conceptual/nativeinterop.nativeptr-module-%5bfsharp%5d 
That's a really interesting blogpost, thanks for linking.
Any reason why it can't be recursive? 
What have you tried so far? How do you think you might go about writing this in general terms?
I was trying to work with 2 loops, a for loop that goes through the array and checks if the current element is bigger than the previous one and a while .. do loop that keeps looping as long as the for loop returns true
OK, so do you have some code? If so, what part doesn't work? Can you describe the algorithm to check if an array is sorted, without going into any coding details?
im practising using loops in f#, so im "translating" recursife functions into loops. &amp;#x200B; my idea is to have a mutable bool. the while loop then checks it it is true. inside of it is the for loop that compares every element to the one before, and sets the mutable variable to true or false, and returns it to the while loop
OK, so my next question is why are you practising using loops in F#? Typical F# programs tend to avoid mutable state and explicit loops in preference for using higher-order functions over collections. If you want to do this, I suggest you first try to implement this in C#, and then, if you really feel compelled to do so, convert that code into F#. If you want to avoid all the things F# gives you (higher-order functions, recursion), then just use C#! If you don't want to do that, the F# reference pages (such as the one I linked to above) should be enough for you to implement the funcion. So far, you have just said what you want to do, but you haven't actually demonstrated you've actually done anything. Asking for help on something is rather different than just asking someone else to do something for you.
I DMed you, hope thats ok
It would be better to post any code here for all to see, then other people can also give comments if they want, and other people who might need help can find it. But like I said, I'd start with an outline of the algorithm, then try to implement it is a more imperative language such as C#. Using F# in an imperative way doesn't give you any benefits.
I want to practise it in F# tho, because thats part of the exam I take. what I have is let sorted (a: Int\[\]): bool = let mutable b = true let mutable p = 0 while b = true do let mutable i = 0 for i in a do if a.\[i\] &gt;= p then b &lt;- true else b &lt;- false p &lt;- a.\[i\] i &lt;- i + 1 b b 
OK, so what problems are you having with the code? What inputs does it work for? What inputs does it not work for? Can you describe what the actual function is doing in English?
the problem is that it doesnt compile and im not sure what to do. &amp;#x200B; like i said, when the Array is sorted in an ascending order, it should return True
OK, so can I suggest you maybe start with something a little simpler if you are having problems with F# syntax. I can recommend the F# track on Exercism if you want to get started using the language: [https://exercism.io/](https://exercism.io/)
Well I know how to use the language, Im just having trouble with this specific function. &amp;#x200B; can you tell me whats wrong with and maybe give me some tips on what I should change?
You might want to check out this F# book: [Machine Learning Projects for .NET Developers](https://learning.oreilly.com/library/view/machine-learning-projects/9781430267669/)
Sorry, this link is for the changes for Preview 1. The link for preview 2 should actually be https://docs.microsoft.com/en-us/visualstudio/releases/2019/release-notes-preview#fsharpP2
F# specifically. I don't care about other .net things. 
How do you find material on something you do not know the name of? Call it what it is so people can choose to make use of 50+ years of research.
That book I linked to is 95% F#. It has a couple of C# examples in the first few pages, but after that it's all F#.
 `let rec fix f x = f (fix f) x` `// No rec :)` `let isSortedBy (f: 'a -&gt; 'a -&gt; bool) (xs: 'a list) : bool =` `let go = fix &lt;| fun g ys -&gt;` `match ys with` `| [] -&gt; true` `| [_] -&gt; true` `| (x::y::zs) -&gt; (f x y) &amp;&amp; g (y::zs)` `in go xs` `// No rec :)` `let isSorted (xs: 'a list) : bool =` `isSortedBy (&lt;=) xs`
F# will be forced into when C# does :) [https://github.com/dotnet/csharplang/issues/339]
Can’t wait to try out the anonymous record types for DIscriminated Union payloads! Almost every DU case name has a corresponding record type in the code based I work on. 
That is a very pretty use case! It's not a widespread problem in our code base, but there are a bunch of smaller clumps that will become much more succinct.
&gt; let phillip' = JsonConvert.DeserializeObject&lt;{|name: string; age: int|}&gt;(str) Single step, ad-hoc, type-safe, JSON deserialization? As if F# wasn't already streets ahead for data munging.
Thanks, but like I sai, I was looking fot an answer without recursion or functions of higher order if anyone still cares, my soulution was let isSorted (a: Nat[]): bool = let mutable b = true let mutable c = 0N for x in a do if x &lt; c then b &lt;- false c &lt;- x b &amp;#x200B; &amp;#x200B;
Mathias, the author of the book, gives huge attention to F#, and it looks like it is one of his primary languages. I was lucky to be on his speech about using F# in ML during one of F# conference.
Yeah I know, I was trolling slightly while also showing some code even though I know it's not what you wanted :)
Thanks. although this looks like general ML rather than Deep Learning. but good to get started with. I hope they come out with something new which focusses on F# and CNTK
I meant deep learning, and yes, they use CNTK with F#. Check out this keynote (you need to be registered to watch it, but it's free): [https://skillsmatter.com/skillscasts/10265-keynote-can-t-wait-to-hear-from-mathias-brandewinder-at-fsharpx-2018](https://skillsmatter.com/skillscasts/10265-keynote-can-t-wait-to-hear-from-mathias-brandewinder-at-fsharpx-2018)
&gt; preview of the F# 4.6 language FWIW, I'd rather see the bugs in the current solution fixed and not new language features. 
Is FSharp.Compiler.Service (23.0.3) with FSharp.Core (4.6) supposed to work with anonymous records, or its newer version is needed? In my test project based on the above packages a script with anonymous records fails, such a syntax is not recognized.
sooo...does AwaitObservable work in F# now? the last I messed with F# it had some kind of problems...?
Do you use the AwaitObservable construct in your UIs? The last time I experimented with creating an F# GUI using this seemingly perfect idea, but it had a few problems...?
god i love Dr J's posts...i learn more about the actual use cases/actual pitfalls of F# than all of the books, except Syme's...
may i ask what you do, what you use f# file, and what you use tdms for? do you use labview or other national instruments products? assume i am quite familiar with ni products, labview, tdms, and to a degree f#.
I’m a software engineer at an automotive supplier company. We use National Instruments software for our test systems. We therefore log data as TDMS files.
that's f# equivalent of duck typing - but static: you specify exactly what member functions the input has to implement and then whatever type does this will fit, similar to interfaces in Go &amp;#x200B; [https://stackoverflow.com/questions/289106/are-there-any-static-duck-typed-languages/312934#312934](https://stackoverflow.com/questions/289106/are-there-any-static-duck-typed-languages/312934#312934)
\&gt; but not Set.find predicate or Set.filter predicate \&gt; useful core functionality like the ability to enumerate a Set or Map both upwards and downwards I don't see how enumerating Sets or Maps makes sense. How can they be ordered? This problem includes Set.find which presumes that there is a first match. \&gt; Putting O(n) etc. in the docs for these functions would really help with adoption. I like this idea and posted it on your behalf: [https://github.com/Microsoft/visualfsharp/issues/6149](https://github.com/Microsoft/visualfsharp/issues/6149)
It's not yet been merged to fsharp.compiler.service and released, that's why. Now that they've announced a preview would be a perfect time to begin that merge.
&gt; I don't see how enumerating Sets or Maps makes sense. How can they be ordered? `Set` and `Map` are both ordered containers. When you enumerate them as a `seq` you get the elements of the set in increasing order or the key-value bindings in a dictionary in increasing order by key. Some algorithms require the ability to use a sorted set or dictionary and enumerate the elements either forwards or backwards but the F# `Set` and `Map` only support one direction (forwards) and not the other. A workaround that works in some cases is to construct the `Set` or `Map` using an inverted comparison function so you can traverse backwards (but not forwards, yargh!). &gt; I like this idea and posted it on your behalf: https://github.com/Microsoft/visualfsharp/issues/6149 Thanks. 
ml.net seems to be taking F# seriously, or at least they are making the effort to have F# samples available and up to date -- https://github.com/dotnet/machinelearning-samples Matias Brandewinder also maintains https://github.com/mathias-brandewinder/CNTK.FSharp which is all about shimming CNTK into F#, and is also available via nuget. If you want you can also check my own ongoing attempt at translating Microsoft's own python tutorials into the managed API, using F# in jupyter at https://areslazarus.com/archive/net-deep-learning-stack-cntk-101-logistic-regression/
Serious question: how many people care about these benchmarks, and for which reasons?
it is pretty popular, people tend to glance at them when considering learning a new language. it is good PR to have good results on them, and can be good practice to work on them I think. there was a concerted effort to improve the F# benchmarks a while back. 
Here's one using List comprehension: ``` let sorted xs = List.forall ((=) true) [for (x,y) in List.pairwise xs -&gt; x &lt;= y] ```
FSharp.Compiler.Service (26.0.1) was released yesterday. It supports anonymous records.
Is the HKT and type classes repo open source? Can you share the link? 
I'm rewriting a native iOS app from Swift to F# using Xamarin.iOS and I'm having lots of fun doing so :)
Funny story, I'm the guy that did the merge :D
Nobody else answered so far? Too bad, I was curious. But never mind. In my case, I am applying newly learned algebra stuff in f#. I know there are libs out there already, but that doesn't help me learning nor understand. :)
We rearchitected our package manager and switched from Java to F#. Over 6 months of development and &gt;85 closed issues later we replaced 20k lines of Java with 8k of F#. Computation expressions (asyncSeq), value semantics, recursion and a propper typesystem were the biggest enablers for us. Feel free to ask us anything
I'm seriously considering it. Problem is the last times I tried Ionide I just couldn't get it to work with only. Net core installed. Probably should give it a go and see if it is any better than jetbrains rider right now. 
No, dotnet cli is part of. Net core. If you have mono you can build applications targeting. Net framework.. Net core is the future so I would seriously consider targeting that, but no you don't need it. 
Can I use dotnet on ubuntu?
Jup, https://dotnet.microsoft.com/download/linux-package-manager/ubuntu18-04/sdk-current
I'm still working an my simple Laser Engraving System. &amp;#x200B;
Prophecy in comments section of the article not fulfilled :)
So I can take a research paper and implement it and submit it. Is that enough?
Nice write up comparing F# Options to C# Nullable types, but one thing needs to be cleared up. Option.map NEVER returns null, as can be seen from its signature: `('a -&gt; 'b) -&gt; 'a option -&gt; 'b option`. You assumed that it may return a null because `printfn "%A" None` rather confusingly prints out "&lt;null&gt;".
Aha, I shall ammend that when Im back at a computer, thanks.
Why didnt you write it in C++? Usually package managers are written in the language they serve.
We certainly could have written it in C++ and we have spent a lot of time investigating this idea. Buckaroo at its core is an IO-bound asynchronous SAT solver. In Buckaroo V1 we used extensively Reactive-Extensions (RxJava) to model our algorithms. We initially wrote V1 in Java to integrate it with \[BuckBuild\]([https://buckbuild.com/](https://buckbuild.com/)) which supports many programming languages. As a result Buckaroo was designed to be a package manager for all languages supported by buck build - however it just happened that pretty much 100% of our packages ended up being C++. As Java was a very painful to write our algorithms in and we realized that there were no benefits of using buckbuild as a library, we decided to rewrite it in a more appropriate language. The obvious choice would have been C++ with RxCpp. However we also came to the realization that a pull based model would be preferable. &amp;#x200B; As such we investigated coroutines in C++ and ended up open sourcing \[conduit\]([https://github.com/LoopPerfect/conduit](https://github.com/LoopPerfect/conduit)) which was leveraging the CoroutineTS. Over time we got quite invested into C++'s upcoming CoroutineTS and unfortunately had to conclude that it is not quite production ready. After an extensive Cost-Benefit analysis we decided to rewrite it in F#. 
Sounds like a good choice. Thanks for the informative answer. I would have done the same. 
is it possible to sponsor using paypal? I only noticed options for credit cards.
One of the last remaining pieces, acquisition-wise, is removing the need for Mono once FSI works (properly) on .NET Core. There are actually previews of the .NET SDK that get you 75% of the way there, but a few remaining bugs mean that it wouldn't be good to fully switch over from the Ionide perspective just yet.
Looks like it's just credit cards, at least those were the options available to me when I signed up as backer. Not sure if other options exist at different tiers.
FSI as-is now works with some quirks for .NET Core. If you install from [here](https://github.com/dotnet/core-sdk#installers-and-binaries) you should get an experience that is close to parity with Mono, except that it's all .NET Core, and there are some console colors. 
I'm following some of the examples in [Scott Wlaschin's book](https://pragprog.com/book/swdddf/domain-modeling-made-functional) and building a small DDD app. I'm new to F#, but I have a lot of experience with DDD apps in C# so it a nice way for me to become more familiar with the language/tooling.
Scott's book is awesome!
&gt; If you install from here When did this land? With the 4.6 preview? I've typed `dotnet --help` who knows how many times the past few weeks (after playing with anonymous records) and didn't notice I could use `dotnet fsi`. Glad it's coming along so well!
Nice, thanks! I still can't seem to start it from Ionide in Vs Code since it says `The terminal process command 'fsharpi' failed to launch (exit code: 1)` If I link directly to the executable in the settings for "Fsharp Fsi File Path" then it says `/usr/share/dotnet/sdk/2.2.200-preview-009797/FSharp/fsi.exe` `bash: /usr/share/dotnet/sdk/2.2.200-preview-009797/FSharp/fsi.exe: Permission denied` Is there a way to set the permission? (Is that even how I would go about it?)
Fixed :). Thankyou
Ionide hasn't been "hooked up" to the .NET Core FSI yet, so I doubt you'll have much success launching it from there. If you type `dotnet fsi` does it work?
Ah, that explains it. Yes, that works.
Glad to hear it. It should work for lots of stuff, but there are some remaining bugs (e.g., bits for `System.IO` aren't correctly referenced by default) before we cut a release and declare that it works. The remaining big piece is `#r "package, version"`, since dealing with referencing the right .dll in a cross-platform way is pretty frustrating unless you have an actual package management system handle it for you.
Cool, thanks! This is already awesome. Is there a way for me to follow the development or get updates?
So super secret workaround (please don’t do this) for Ionide is creating `fsharpi` script somewhere in your PATH or just alias in your shell that will run `dotnet fsi` under the hood... For mono we basically execute `fsharpi` command in shell (unless you specify some additional config like `fsiPath` - for above hack set all FSI config in Ionide to default), if you change what it means you can get other stuff working 
We're about to ship what we believe to be a completed "parity" experience (modulo a bug or two if they come up) in .NET Core. As for package management, [this PR](https://github.com/Microsoft/visualfsharp/pull/5850) is the closest thing we have in terms of an update notice. Once it's merged, we'll determine if it's ready to ship and try to get it into the latest shippable SDK for .NET Core.
His book his great. It's not only a great resource for F#, but also for many of the ideas and strategies behind DDD as well. I'm really glad I stumbled on it.
I have a bad news for you :D Roslyn is a C# compiler, not F#! That's it. Nothing will happen because Roslyn never compiles F# code. He doesn't know what it is, he doesn't have AST, he can't visit AST nodes for F# code and analyze it. You should work with FSharp.Compiler.Service to create your analyzers. Ionide for VS Code has a way to plugin custom analyzers in toolchain. Not sure about Visual Studio.
Just a guess, but does it work if you change "type WhereAnalyzer" to "type *public* WhereAnalyzer"?
no, doesn't work. default should be public anyway, but I did try that. 
fun deriv -&gt; f -&gt; f -&gt; deriv Does that answer your question?
Thanks! With some self experimentation I wound up with this : &amp;#x200B; let derivF x = fun x -&gt; deriv(x) It seems to be doing the trick. I will keep this composition operator in my pocket. The goal is to do straightforward numerical derivation for now, but roll something symbolic out once I get more advanced. Then working my way up to understanding/getting behind more professional pre-made libs. &amp;#x200B;
You're welcome. Just a few notes: Your specification implied something there was another function you wanted to apply to the input x. Also, there is no need to shadow x in that instance. I am guessing you made a typo as you might have intended to apply the function f. Another thing, I highly recommend you write this as a higher order function so that you decouple your derivF from deriv and f if it exists. Finally, you won't go too far unless you consider learning functional programming in F#. I recommend some freely available material you can go through during your spare time if you have any: https://youtu.be/aNaYu5w1dLc?list=PLZK4yeOfRtWBbEAIUGU_EyNCiACye5Rh5
your function `deriv` doesn't do anything useful; `(x + i - x) / i` is a constant `1` for non-pathological cases. I think what you want is to pass the function as a parameter and use partial application: let deriv f x = (f (x + i) - f x) / i // example usage let my_cosine = deriv sin assert (abs (my_cosine 0.5 - cos 0.5) &lt; 0.0001)
I don't know much about Azure Devops Yaml, so I can't help you. But remember to state your case in terms of business impact, lock-in, opportunity costs. In a healthy org those are the factors that drive the choice of technology.
Thanks good points
For me, one important feature of Fake is that I easily can run the same build scripts on my machine. But I guess that is what you refer to with a shorter feedback loop. And by having all the developers build locally with the same scripts you get less issues where someone says “it works/builds on my machine” ;) (but the same case can be made for Cake, of course). 
Regarding Cake I have been facing the same problem and the argument is usually we know c# and it’s less of a learning log curve for us c# developers. I would say that you can consider both Fake and Cake as build DSL languages. And in that case Fake is much less verbose, comparing it with Cake you can really see how F#’s piping syntax shines. When I look at Cake scripts I only see a bunch of parenthesis and overly long method names ;) Also I think that Fake is more mature than Cake. I also feel that it’s more widely used, but maybe that just is confirmation bias. 
Possible a good case study: https://www.elastic.co/blog/solidifying-releases-with-fsharp-make
I mean, the very first F# I ever did was automating builds/deploys with FAKE for a C# microservices shop (the only lines of F# in the company) and it was a business win specifically for the anti-lock-in reasons you mention. We migrated from a homegrown build orchestrator, to Octopus Deploy, to Gitlab CI all without changing hardly any of our build code, and all along the way kept the ability to test the whole pipeline locally. That seems like a huge win to me, and in the rare cases where we had CI brownouts, we had the capability to stamp releases and initiate deploys from a developer system if necessary. Cake/FAKE is secondary to that. I'd honestly just be happy to get an organization away from CI lockin.
I'm not at all familiar with Azure devops yaml or Cake, but I've used FAKE as a general task-runner for a while. Is it not possible to hook FAKE/CAKE into the Azure Devops via the yaml file? Your intuition about putting \*all\* of your build logic into the yaml file is probably correct. Ideally, you'd only want to include configuration settings specific to Azure Devops in its yaml file and put the meat of your build script elsewhere. This way you're not dependent on Azure Devops for your builds. As for FAKE vs. Cake, I can only really comment on FAKE. I find it very useful as a general task runner. The API is very lightweight and modular, and the custom operators really help with readability. Cake achieves this via a "fluent" api design, but honestly, it seems a bit noiser. FAKE scripts are also just normal fsx scripts. There's no magic; just some additional utility libraries. You can write your own utility libraries the way you normally write F# scripts. FAKE can also be installed as a dotnet global tool, as well, which is very convenient. Overall, I'm quite happy with it. Upgrading from FAKE 4 to FAKE 5 was a minor annoyance that sucked 3-4 hours out of a work day. I'm still kind of getting familiar with the FAKE 5 api, but the docs are very helpful. As for other downsides, I've heard from some people that FAKE's first-time setup can be somewhat complicated, but there are dotnet project templates, now that help with that. The [MiniScaffold](https://github.com/TheAngryByrd/MiniScaffold) project is also a good, up-to-date reference. Intellisense is also somewhat temperamental, but CLI will usually warn you when it's necessary to regenerate the \`intellisense.fsx\` file. Also, I've only ever used FAKE with paket, which gives you a nice way to manage FAKE module dependencies together with your actual project dependencies. If you use the default nuget-client, YMMV. Besides the language hurdle, the main disadvantage of FAKE is that if your team wants to edit build scripts with intellisense, etc... they'll need to install the F# tooling for their editor. Otherwise, FAKE comes batteries-included as a dotnet tool. So as long as you have .net sdk installed, there's nothing stopping you from editing FAKE scripts via plain-old Vim/Notepad and executing via the command line. So to wrap things up, FAKE is a great, low-ceremony task-runner/build-tool/DSL w/t a lightweight, modular library. I vastly prefer F# to C# as a scripting language, so FAKE over Cake is a no-brainer for me. FAKE's never hung me out to dry in the years I've been using it. Why not give it a shot and see how people like it? &amp;#x200B;
If you're trying to get F# in your workplace, I'm not sure introducing an esoteric build system is the best way to endear people to F#. Personally, I would suggest you introduce simple F# Pythonic looking F# in a small library. Write a parallel implement in C# so people can see the code side-by-side. Focus on inter-op and show people that F#'s defaults make it good choice for developing certain types of components.
\&gt; Shorter feedback loop What does this mean exactly? \&gt; More portable than Azure devops yaml OK but Azure devops is a good system which isn't going away soon. Can you see any specific reasons to migrate away from it? \&gt; More flexible than AZ DO yaml since it is a programming language Why are your builds so complex they need a programming language to define?
For Cake vs Fake: Fake is an actual normal fsx script that works with all tooling and intellisense and syntax highlighting etc. Cake is a dsl that looks extremely similar to C# but adds stuff that makes it not be C#. That means that in general the main argument for using C# ( the great tooling) is actually dead in the water because it doesnt work. So Cake is not C#. Its a dsl that looks like C#. Fake is actually F#. Also, we used to use cake a lot. But it ended up randomly breaking with no notice and no explanation causing a lot of extra work. We started switching to fake instead after realizing that we could usually port the buildscript to fake in half the time that it took us to diagnose one of these issues.
&gt; Shorter feedback loop &gt;&gt; What does this mean exactly? If you make a change to the build you can try it locally and get feedback directly. With Azure DevOps yaml you need to commit, push and wait for an agent to build it. There is also alot of clicking involved between pages. &gt; More portable than Azure devops yaml &gt;&gt; OK but Azure devops is a good system which isn't going away soon. Can you see any specific reasons to migrate away from it? That is the mentality that gets people trapped in lock-in scenarios. There is also alot of reasons to migrate way from things. The two most obvious ones * There comes another better alternative * There comes an alternative that is equally good but hell of a lot cheaper We know that technology changes and we know that different companies are in different phases of the change cycle. A company might be modern right now but in 5 years their services are considered old. There are loads of examples of this throughout history. &gt; More flexible than AZ DO yaml since it is a programming language Why are your builds so complex they need a programming language to define? The system consists of 6 million lines of codes and 100s of micro-services... 1000s of components.. there are components that uses legacy technologies and others that use modern technologies. These components should be built and tested together. Complex database setups.. Deployments to servers, mobile stores, kiosk's etc different package formats... installers etc... so yeah its not your typical hello world app. 
You might be able to push FAKE if they don't know about CAKE; otherwise, it will be a tough sell. But if they're not using CAKE already, then they likely don't know about it, so you might be good. If you have any WiX installers, I've found that F# + WixSharp is a really great combination. I have a few FAKE + WixSharp builds that I'm really happy with. &amp;#x200B; The problem is that if you hoist a new language on them to solve a task, it will just feel like a burden to them. That's why I think you have to genuinely pique their curiosity, to make them *want* to learn F#, just like you did. To make them gain faith in F#, you should demonstrate why they should start to lose faith in C#. Make them question problems with OOP that they have accepted and no longer question. Sell it to them. &amp;#x200B; For example, show how easy it is for classes to have uninitialized properties with no way to catch this at compile time. Add a property to any domain entity, and then leave it uninitialized, and the compiler is totally cool with that! Then show how algebraic data types (records, discriminated unions and exhaustive pattern matching) will never let you make those kinds of mistakes again, with full compile time checking. &amp;#x200B; Show a side-by-side example of polymorphic OOP code with behavior scatter throughout the hierarchy, and then show an F# example that models the polymorphism as discriminated unions and handles the business logic all in one function. Show how much space one file per class takes up, and then show an entire feature modeled in a single file module, without all the ceremony of classes. Once they start to see how painful the ceremony of classes is, and that algebraic datatypes are the superior way of modeling, then the seed will be planted. &amp;#x200B; Maybe start by picking out the most likely to be interested team-mates first, and see if you can capture their interest. If you can't get them, then you'll never get the jaded git-r-done guys. &amp;#x200B; Feel free to use my slides: [https://1drv.ms/p/s!AnjY5bNNUKYnliiOulfv0Mdap3\_2](https://1drv.ms/p/s!AnjY5bNNUKYnliiOulfv0Mdap3_2) &amp;#x200B; &amp;#x200B;
My own article on [creating a term-rewrite language](http://fsharpnews.blogspot.com/2017/10/creating-new-term-rewrite-language.html). 
This is my dream reddit comment. Correct use of both "pique" and "tough sell" rather than "hard sell".
there are quite a few lisp and scheme books that cover this. i can come bacl and comment later if you're interested.
Yes, that would be great. 
Sorry for my late reply, these days there is a special festival in my country. The repo is here: https://github.com/thautwarm/FSTan
I think you should do something like this: \`\`\` Page.Company.Parse("\[" + json + "\]").\[0\] \`\`\`
can you post the sample json from "paged-companies-example.json"?
Unfortunately I'm can't post the data because it's work related. I did figure it out though! Searching for that Parse method (which I couldn't find) I noticed that JsonProvider generated types inherit from IJsonDocument and can be initialized from a JsonValue type. So this allows me to do: let loadFromRedis key = let json = Redis.Load(key) json |&gt; JsonValue.Parse |&gt; Page.Company ... which is exactly what I needed! Apparently Page.Company is a method from somewhere that constructs the Company object. Thanks for the help!
no problem. glad you figured it out.
it is common to not use oop patterns in game programming for performance reasons, even in c++ where you could oop if you wanted to. read up on entity component systems for one approach. totally compatible with monogame. you can do whatever you like inside its draw and update loops. you dont have to extend its gameobjects or anything. 
In general I don't think this question is specific enough for an answer. However, I have been working on a game in F# and do have some higher-level advice: &gt;How do you manage state? Is there a common simple approach, or do you have to use mutability? You definitely don't have to use mutability. Below is a sketch of a somewhat standard "functional style" where everything is immutable. Basically the idea is that, instead of having a mutable state in some while loop, you use a recursive function that takes the state in as an argument, does some processing, comes up with a new state, then calls the function again with the updated state. &amp;#x200B; type PlayerStatus = | Alive of health:int | Dead type Player = { location : int*int status : PlayerStatus } /// commands that affect the player's status in-game (move, block) type PureCommand = /// Change coordinate | Move of Direction /// Reduce incoming damage | Block /// Do nothing | StayStill type EffectfulCommand = /// Stop motion until player unpauses | Pause /// Write to disk and display main menu | SaveAndQuit /// The player's commands can either be pure (affecting the player's state in-game), /// or effectful (affecting the game program by pausing or save-and-quit). type Command = | Pure of PureCommand | Effect of EffectfulCommand type GameState = { player : Player level : Entity array array // Entity is some other type playerNextFrameDamage : int playerNextFrameCommand : Command } /// Blocking halves incoming damage. let blockDamage (incomingDamage : int) = incomingDamage / 2 let rec gameLoop gameState : unit = match gameState.player.status with | Dead -&gt; gameOver() // a function unit -&gt; unit that prints "Game Over!" to the screen then goes to a main menu | Alive health -&gt; // player isn't dead, process their command match state.playerNextCommand with // If it's a PureCommand, we will recursively call gameLoop. // If it's an EffectfulCommand, we will call some other function with output type unit. | PureCommand c -&gt; // First update the incoming damage let newDamage = getPlayerDamageFromLevel (state.level) // a function that adds up all the incoming damage from monsters let updatedLevel = updateLevel (state.level) // levelUpdate : Entity array array -&gt; Entity array array // pattern mach on player's PureCommand to get player's next state let updatedPlayer = match c with | StayStill -&gt; {state.player with status = let updatedHealth = health - (state.playerNextFrameDamage) if updatedHealth &lt; 0 then Dead else Alive updatedHealth} | Block -&gt; {state.player with status = let updatedHealth = health - (blockDamage state.playerNextFrameDamage) if updatedHealth &lt; 0 then Dead else Alive updatedHealth} | Move d -&gt; // call some function that updates the player.position let nextCommand = getPlayerInput() // parses keyboard input into a Command // recursively call game loop with player having taken damage and with updated level gameLoop {player = updatedPlayer; level = updatedLevel; playerNextFrameDamage = newDamage; playerNextFrameCommand = nextCommand } | EffectfulCommand c -&gt; match c with | Pause -&gt; pause() // function that blocks until player hits unpause, handled in the body of the pause function // after unpausing, notihng about state has changed except the player's incoming command gameState {state with playerNextFrameCommand = getPlayerInput()} | SaveAndQuit -&gt; saveAndQuit() // a function unit -&gt; unit that saves to disk then goes to a main menu This will probably be less performant than an implementation with mutable state. OTOH, using immutability means you can modularize and parallelize these actions fairly freely, and only be interested in synchronous control from the perspective of gameplay (e.g players can block before taking damage but take damage before they get to move), not in terms of data/thread orchestration. It also makes the code much easier to maintain correctly. &amp;#x200B; I do want to emphasize there's nothing wrong with mutable state. But you would typically want to have the mutability properly encapsulated in a class with some sort of RW access control, and have to keep track of things like race conditions and so on.
&amp;#x200B; &gt; &gt; &gt; How to emulate OOP stuff? I feel there is a need for it - because inheritance feels really clumsy (because of lack of protected properties) and composition + interfaces approach doesn't feel much better because every interface has to be implemented explicitly. I am not quite sure what you mean here. You don't need to "emulate" OOP stuff in F#, it fully supports almost all OOP constructions from F#. There are some trivial limitations (I don't think you can do static public fields on F# classes) and some more serious ones - covariance / contravariance :( :( :( - but I don't think the syntax is that awkward. Abstract classes are a bit more awkward, but F# idiomatically prefers parametric polymorphism rather than compositional (e.g. you supply the behavior of abstract class "virtual" parameters as functions in the constructor). &amp;#x200B; But, by design, F# does make you put a little more work into creating a class. So: &amp;#x200B; &gt; Is using algebraic types the right approach or there are better ways? It depends. I wouldn't want to give a categorical answer to this. But there are general guidelines: * If the data being represented is something within the *logic of the game* it is probably better to use immutable algebraic data types, with maybe a few helper static/instance methods for convenience, and then a separate module of (static) functions for manipulating / processing them. If you want polymorphism, use a union type. That is, instead of `Monster, Player, Item` inheritng from some abstract class `Entity`, do `type Entity = Monster of MonsterState*MonsterType | Player of PalyerState | Item of ItemDescription` * If the data being represented is something *architectural or otherwise external to the game logic* \- database access, controller configuration, graphics settings, etc - it is probably better as a full-fledged class. I will add that F# object expressions make interfaces much more convenient and interesting to use : [https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/object-expressions](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/object-expressions) &amp;#x200B; &gt; How do I emulate interfaces / inheritance? Again - you don't need to "emulate" interfaces or class inheritance. These are first-class features in F#. [https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/interfaces](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/interfaces) [https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/inheritance](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/inheritance) [https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/abstract-classes](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/abstract-classes) &amp;#x200B; And an unadorned normal .NET CLI interface is perfectly "functional." These two types are functionally identical: &amp;#x200B; /// normal .NET interface type IProcessData&lt;'TData&gt; = abstract member GetAverage : seq&lt;'TData&gt; -&gt; 'TData abstract member PrintData : 'TData -&gt; () abstract member UpdateData : seq&lt;'TData&gt; -&gt; DataStore&lt;'TData&gt; -&gt; Result&lt;Ok,Error&gt; /// An interface is functionally the same thing as a record type of functions type DataProcessor&lt;'TData&gt; = { averageFunction : seq&lt;'TData&gt; -&gt; 'TData printFunction : 'TData -&gt; () updateFunction : seq&lt;'TData&gt; -&gt; DataStore&lt;'TData&gt; -&gt; Result&lt;Ok, Error&gt; } And can be implemented in functionally identical ways: &amp;#x200B; type CSVDataProcessor() = // blah blah interface IProcessData&lt;CSVData&gt; with member x.GetAverage input = // blah blah member x.PrintData data = data.ToString() member x.UpdateFunction dataList dataStore = // blah blah let csvDataProcessor = { averageFunction = fun input -&gt; // blah blah printFunction = fun data -&gt; data.ToString() updateFunction = fun dataList dataStore -&gt; // blah blah } The biggest difference is that using interfaces allows interface polymorphism and easier cross-.NET consumption. I think interfaces tend to compile to faster CIL as well. Generally you should use interfaces instead of records - they are syntactically heavier, but more robust. &gt; What are common idioms patterns for game programming or similar problems (let's say simulations - as far as I am aware F# is not used much in game programming). I am really not sure what you mean by "idioms." Iam not even sure how to start answering this one. I don't think there's an easy recipe. Compared to other programming paradigms, I find functional programming to be very domain-specific, and there will be different answers as to whether this is a strategy game or an action game. And generally functional programming isn't about GoF-style idioms and doing things "Pythonically" or whatever - it's about having accurate datatype representations of the underlying problem, and efficient, maintainable functions that implement solutions to the problem. I am sorry if this sounds vague and zen-like. &amp;#x200B; F# does manage a lot of the organization / idioms itself by the way it organizes projects. Since the file / module order is linked top-to-bottom, you will invariably start with a Utils module, then some basic DataTypes. basic Contracts, etc etc. So "drilling down through abstractions and increasing specification until the problem is solved" is sort of the way it goes. Kind of like the adage about sculpture - you start with a block of marble and remove all the bits of marble that isn't Michelangelo's David :)
Pro game dev and F# newbie here. I have had success tinkering with F# in Unity by using it to represent the domain model in a [MVC architecture](https://www.toptal.com/unity-unity3d/unity-with-mvc-how-to-level-up-your-game-development). Writing the model and its transforms in an F# library is super fun and effective. I've been keeping stuff handling GameObjects and Components in C#. This View/Controller stuff is heavily OOP and F# feels like the wrong tool for me. In my next project I plan to try using Unity's new [Entity Component System](https://unity3d.com/learn/tutorials/topics/scripting/introduction-ecs) with F#. That architecture should be a much better fit for functional programming.
Referencing packages with `#r` actually works, just not well enough to ship. You can build FSI from the branch that has it implemented here: https://github.com/Microsoft/visualfsharp/pull/5850 If you're not interested in using experimental bits, you'll just have to wait. Needing to support both .NET Core and .NET Framework makes it massively complicated and time consuming, especially when there is a need to evolve other parts of F#.
Have you tried \`paket generate-load-scripts -t fsx -f netstandard2.0\` ? You can generate scripts for different frameworks, too, by changing the \`-f\` switch to \`net461\` for example.
Not sure if it's been fixed recently, but when I last used this feature several years ago, it was extremely time-consuming.
Interesting. It's never taken more than a couple hundred milliseconds in my experience. Perhaps now is a good time to give it a shot.
Cool, will do, thanks!
What's the reason for still adding support for .NET Framework? 
Thanks. I will try to get my hands on that book sometime.
That's sort of approach I was thinking about. The problem with that approach, is that if you have many objects (or entities) that have behavior that depends on each other, then in order to update a single object, you need to take into account the whole game state (I am talking about `updateLevel` in your code), and at the moment I feel that it can run both into both performance and complexity issues. Let's put the performance issues aside at the moment - people make playable games using python, ruby and js... I just have the feeling (perhaps wrong) that immutability makes things more complicated to control - that what worries me. For example if we have something like type Hunter = {Pray: someType... } Now when you update the game state - the actual Pray actually changes, which means that I need to calculate and update it as well, except just changing the "actual state" of the hunter. If behavior is more complicated, I have a feeling that it becomes even more harder to handle.
&gt; I am not quite sure what you mean here. You don't need to "emulate" OOP stuff in F#, it fully supports almost all OOP constructions from F#. There are some trivial limitations (I don't think you can do static public fields on F# classes) and some more serious ones - covariance / contravariance :( :( :( - but I don't think the syntax is that awkward. Abstract classes are a bit more awkward, but F# idiomatically prefers parametric polymorphism rather than compositional (e.g. you supply the behavior of abstract class "virtual" parameters as functions in the constructor). I don't know - while F# supports OOP and imperative styles (That's was one of the reasons I picked it, besides descent libraries) , I feel that OOP is a bit clumsy - at least if I try to copy Java/C#/CPP approach. As I have said earlier - inheritance is more complicated than it should be because there are no protected members (I understand there is a reason for that though), and while I can avoid using protected members, I feel it makes some things unnecessarily more complicated. One of the workarounds is to have interfaces and use composition instead of inheritance, which would allow polymorphic behavior. However, it also uncomfortable - every interface has to be implemented explicitly. If the class implements one interface it is annoying, but I can live with it. However, what happens if I want the class to implement several interfaces? At this point I feel that I am doing something wrong - because I have to type a lot of boilerplate code for no good (at least one I am aware of) reason. &gt; I am really not sure what you mean by "idioms." Iam not even sure how to start answering this one. I don't think there's an easy recipe. Compared to other programming paradigms, I find functional programming to be very domain-specific, and there will be different answers as to whether this is a strategy game or an action game. And generally functional programming isn't about GoF-style idioms and doing things "Pythonically" or whatever - it's about having accurate datatype representations of the underlying problem, and efficient, maintainable functions that implement solutions to the problem. I am sorry if this sounds vague and zen-like. My problem as I've said in earlier post, is that I don't know if there is good "functional" approach if I need to handle complex behavior that depends on object interactions (when there are lot of them). Is there common "high level" approach to do that? Or it is one of the cases when one has to use "not pure" approach? (I am fine with that - don't get the wrong impression)
That's sort of approach I was thinking about. The problem with that approach, is that if you have many objects (or entities) that have behavior that depends on each other, then in order to update a single object, you need to take into account the whole game state (I am talking about `updateLevel` in your code), and at the moment I feel that it can run both into both performance and complexity issues. Let's put the performance issues aside at the moment - people make playable games using python, ruby and js... I just have the feeling (perhaps wrong) that immutability makes things more complicated to control - that what worries me. For example if we have something like type Hunter = {Pray: someType... } Now when you update the game state - the actual Pray actually changes, which means that I need to calculate and update it as well, except just changing the "actual state" of the hunter. If behavior is more complicated, I have a feeling that it becomes even more harder to handle.
I check that issue like a toddler checking their advent calender -- really looking forward to it! 
Hey, \_pupil\_, just a quick heads-up: **calender** is actually spelled **calendar**. You can remember it by **-ar not -er**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
delete
&gt; the Generate Script button, the Send References to Interactive button has gone away Good IDEs still have this feature, just saying...
Ionide has a generate fsx references feature, but I'm not sure if it'll send them automatically
You can read it online free here (beta version, so not as refined): http://www.dataorienteddesign.com/dodmain/ 
It's still used by the majority of users. Plus it's the .NET Framework version of FSI that ships in VS 2019, and will continue to do so until at least the VS after that.
I think I might just switch to vscode. All the kinks seem to be getting worked out now.
"So as we could see this json looks a little bit different than the previous one. Because of that I decided to write my own converter for union types." Or you could have used an enum again? xD just kidding.
Yeee some sort of xd
Or not... Ionide is still extremely glitchy :/
I'm figuring out why this language exists in 2019.. I told my co-workers that I'm learning F# and they seem to start their Python romance talks.. Python is best, it's for everything, it's future, its this and it's that.. So much so that my whole department has dumped C, C++, Vb, C# and *completely* shifted to Python.. Everyone loves *P* so much that F# is a decayed thought now. *P* is also being used in web dev and cross platform dev now.. Hell, my co-workers are making ElectronJs apps with *P*!!
instead of writing your own converter, you could also use existing ones to do this. e.g. https://github.com/Microsoft/fsharplu/wiki/fsharplu.json
Can you file a bug when you come across them?
[This autocomplete bug ](https://github.com/ionide/ionide-vscode-fsharp/issues/938) has been a showstopper for me, and it's been known but irreproducible since October. Likewise, [this intermittent slowness](https://github.com/ionide/ionide-vscode-fsharp/issues/706) was reported a few days ago and seems to be widely recognized.
``` &gt; .paket\paket generate-load-scripts Paket version 5.196.2 Performance: - Runtime: 4 seconds &gt; .paket\paket generate-load-scripts -t fsx -f netstandard2.0 Paket version 5.196.2 Performance: - Runtime: 1 second ``` Definitely more than a couple hundred ms, but it's fast enough. I only have a few items in paket.dependencies, and my paket.lock is 43835 bytes. Not sure if that's big or small.
maybe it's doing a restore? My lock file is 55kb with about 40 top-level dependencies. According to paket, the runtime for `generate-load-scripts` is 1 second.
I did a `paket install` prior, so it's probably not a restore. The OS might have something to do with it -- I've seen GHC for example be much faster in an Arch VM than on Windows, for whatever reason. Either way, it's not nearly as bad as I remember it being, so this definitely a winner. Thanks!
Yup, I discovered it a couple of weeks after writing own "converter" (big words for a single function). But thanks for a link it would be for sure worth to consider when we would need a more complex serialization in our project ;)
Rad!
* pretty much all the "little" books, such as the little schemer, the seasoned schemer, the reasoned schemer, etc. * structure and interpretations of computer programs * list in small pieces * anatomy of lisp * essentials of programming languages * programming languages by samuel kamin * the architecture of symbolic computers * lisp 1.5 programmer's manual hopefully this helps! i haven't read all of these, yet, but have most of them. i am currently going through sicp. 
1) This is awesome! 2) I literally was just talking about how a project like this would be a smart idea (WRT the use of Swift in tensor flow). I've used similar 'cohabitation' with F# and R via the R Type Provider, and found the experience surprisingly fruitful and a nice way to demystify a new technology.
Nice, I've passed this on to my more data-sciencey colleagues. I wonder if the implementation of `member this.UniqueName( ...)` in `Graph.fs` is thread safe. ;-)
Looking forward to the new FSI! A lot of my workflows are still buggered thanks to the .net core transition, hoping this will let me script like normal again :D
Hi, I wrote a simple game back when I was learning F#. Most of the code is in a single file, and the core of it uses no mutable state. You can check it out here: https://github.com/amaiorano/FSharpRipOff 
I am pretty new to F# but I also heard about [FsPickler](https://github.com/mbraceproject/FsPickler) and [Chiron](https://github.com/xyncro/chiron). Do you know the two I have mentioned and could you give your opinion about them? 
Maybe try popping the C# and F# versions into [https://sharplab.io/](https://sharplab.io/) to see if the generated output is the same? This is what I got for the F# -&gt; C# conversion. Interestingly, the method call seems to have been inlined: using Microsoft.FSharp.Core; using System; using System.IO; using System.Reflection; using System.Runtime.InteropServices; [assembly: FSharpInterfaceDataVersion(2, 0, 0)] [assembly: AssemblyVersion("0.0.0.0")] [CompilationMapping(SourceConstructFlags.Module)] public static class _ { [Serializable] [CompilationMapping(SourceConstructFlags.ObjectType)] public class MyClass { public MyClass() { ((object)this)..ctor(); } public void MyMethod(string s, object o, [Optional] object o2) { PrintfFormat&lt;Unit, TextWriter, Unit, Unit&gt; format = new PrintfFormat&lt;Unit, TextWriter, Unit, Unit, Unit&gt;("non-generic called"); PrintfModule.PrintFormatLineToTextWriter(Console.Out, format); } public void MyMethod&lt;a&gt;(string s, object o) where a : class { PrintfFormat&lt;Unit, TextWriter, Unit, Unit&gt; format = new PrintfFormat&lt;Unit, TextWriter, Unit, Unit, Unit&gt;("generic called"); PrintfModule.PrintFormatLineToTextWriter(Console.Out, format); } } [EntryPoint] public static int main(string[] argv) { MyClass myClass = new MyClass(); object obj = new object(); PrintfFormat&lt;Unit, TextWriter, Unit, Unit&gt; format = new PrintfFormat&lt;Unit, TextWriter, Unit, Unit, Unit&gt;("generic called"); PrintfModule.PrintFormatLineToTextWriter(Console.Out, format); return 0; } } namespace &lt;StartupCode$_&gt; { internal static class $_ { } } 
I would say intentional. It seems more consistent with the idea of currying.
I haven't heard of FsPickler before, but I do know Chiron. The main difference between FsharpLu.Json/Json.net and Chiron is that with Chiron you need to do the mapping between the json and objects yourself. That has both benefits as well as downsides. The main benefit of chiron is that it is very explicit and allows more flexibility for the parsing. Downside is that it is very explicit and requires you to do the mapping yourself whereas Json.net uses reflection to deserialize an object. Most of the time I use FSharpLu.json but when I'm using Fable, then I'm using [Thoth.json](https://mangelmaxime.github.io/Thoth/json/v2.html).
Have you run any kind of benchmarks or know about any? I am planning of creating an fsharp precompiled azure function where time = money. 
More info, but no answer yet. https://github.com/Microsoft/visualfsharp/issues/6234
Yes
How can this translated into C#; if it is possible?
The .NET way is to use `INotifyDataErrorInfo` and/or Attribute Based Validation. https://www.infoq.com/articles/CSharp-Models
&gt; You might wonder why the list of reasons is not defined directly in primaryBoardingDeniedReason. First, the order of the reasons is a separate concern that should be easily testable, which it trivially is when defined on its own. Secondly, there is no compile‐time guarantee that the list contains all reasons (which may not necessarily be desired; see the next point), and keeping the list close to the case definitions makes you more likely to remember updating the list when adding new reasons. &gt; You could also use reflection to generate all cases automatically. You’d never forget a case, but you’ll probably get a runtime error if you add a case with data (an entirely valid thing to do here and something you might need at some point), and you won’t be able to use list expressions as mentioned above. An easy way to enforce *'this discriminated union should only hold empty tags'* is to make it an enumeration, which also has the advantage of automatically providing an ordering to the cases. The only downside is the possibility of spurious numeric values appearing at runtime, which may be a negligible concern for a private type or a serious one for a part of a public API. type BoardingDeniedReason = | NotOnPassengerList = 0 | NoBoardingPass = 1 | FlightOverbooked = 2 | IsTerrorist = 3 | IsCriminal = 4 Otherwise, if one favours flexibility, you can have your cake and eat it too by autogenerating the full list of reasons and then mapping it to an ordered set like integers. The mapping function will provide the compile-time check for completeness, and can be structured any way you like: static member AllReasons = FSharpType.GetUnionCases(typeof&lt;BoardingDeniedReason&gt;) |&gt; Seq.map (fun case -&gt; FSharpValue.MakeUnion(case, [| |]) :?&gt; BoardingDeniedReason) |&gt; Seq.toList let denialReasonPriority = function | NotOnPassengerList -&gt; 0 | NoBoardingPass -&gt; 1 | FlightOverbooked -&gt; 2 | IsTerrorist -&gt; 3 | IsCriminal -&gt; 4 // Flight -&gt; Passenger -&gt; BoardingDeniedReason option let primaryBoardingDeniedReason flight pas = BoardingDeniedReason.AllReasons |&gt; List.sortBy denialReasonPriority |&gt; List.tryFind (hasBoardingDeniedReason flight pas)
&gt; override this.CanConvert objectType = true; Don't do this: you're telling JSON.NET that it should pass *any* kind of object to your custom converter, but you actually just want to handle union types and let the rest be passed on to other custom converters (if any) or the default handlers. &gt; override this.CanConvert objectType = FSharpType.IsUnion(objectType); 
Good catch, thanks! I will update post to include that :)
Sticking to business logic only, I guess you could model this using an enum and then use a switch statement. Functional programming in C# is certainly possible - the language receives more functional features with every release. Still, it's notably higher friction than with F#, because C# is at its heart an object-oriented, statement-based langauge.
I'm interpreting the question as how do model the domain logic. Using \`INotifyDataErrorInfo\` is a way to show (input validation?) errors to the user in a UI, which is only relevant for MVVM architectures in the viewmodel layer. The domain logic shown in the post is completely separate from any specific front-end. It may be used in a web API, or the reasons may be used in other domain logic.
Thanks for an interesting comment! A couple of thoughts in return. In general I don't agree with you, and I'll try my best to explain why and how I'm seeing things. Please let me know if I have misunderstood anything (your argument, F# stuff, or otherwise). &gt;An easy way to enforce 'this discriminated union should only hold empty tags' is to make it an enumeration, which **also has the advantage of automatically providing an ordering to the cases**. (My emphasis.) Discriminated unions also have (implicit) ordering. I assume you're talking about providing an explicit ordering. Unfortunately, this ordering comes with an actual value, which is information that can be (mis)used for more than just ordering, e.g. in a DB or an API (though one might argue that this particular enum has no business being outside of the domain layer). &gt;IIRC a recent language update should have introduced separate warnings for "you forgot a case" and "the value could be a number not associated with a case" This is correct, but you'll still have a compiler warning (or an error if treating warnings as errors, which many do, and you'll then have to ignore that specific error). &gt;making the compile-time checks about as good as those for regular unions. For the reasons mentioned above, I would disagree with this. &gt; Otherwise, if one favours flexibility, you can have your cake and eat it too by autogenerating the full list of reasons and then mapping it to an ordered set like integers. This was an interesting approach. As mentioned above I am in favor of specifying the ordering without any extra values, and in this case (as opposed to enums), nothing stops you from specifying the same ordering value for multiple DU cases. A safer approach based on yours would be if the \`denialReasonPriority\` function (which would have another name) simply mapped each case to \`unit\`. Then it would never be called; it would only exist as a compile-time safeguard that all cases are covered. The ordering would be in the DU definition (I assume \`GetUnionCases\` return the cases in definition order). But even that approach, as with your suggestion, does nothing to ensure that you only add cases without data. You can add a case with data, add it to the mapping function, and everything would compile but the reflection would fail at runtime. IMHO the safest approach is simply specifying the (ordered) cases as a list, as I did. If you keep it close to the definition, it's very hard to miss when adding new cases.
does your professor have something specific in mind? seems kind of a pointless distinction if not, because you’ll be stuck figuring out what asynchronous solutions are multithreaded or multiprocesses. anyway, check out asynchronous workflows and also the MailboxProcessor (basically an actor type of framework). in f#.
Multi-processing means that tasks would be executed by multiple processes and two processes cannot share the same memory, they are different execution units in isolation. This means that they need to use a communication mechanism to receive the input data for the process they are executing. Often the communication mechanism is a queue system, like MS-Queue or RabbitMQ but other times it can also use Remote Procedure Calls (RPC). Usually the way multi-processing works is that you have a process dedicated exclusively to receiving input data and sending it to the queue in processable units. Then you have as many instances as you want of process that reads from the queue and actually does the work. In this case parallelism is achieved by firing multiple instances of the same process connected to a single queue. These processes do not even have to be running in the same computer for the system to work. I hope this helps you identify how your implementation should work, but be aware that none of the parallel execution techniques that apply to threads apply to multiple processes. You could have multiple threads running inside your process, but you would only achieve multi-processing if several instances of your process are running simultaneously. 
great well written post! thank you
Not OP and this is not a suggestion for this specific issue, but take a look at [Functional Programming in C#](https://learning.oreilly.com/library/view/functional-programming-in/9781617293955/) for general coverage of how to apply functional programming practices in C#.
&gt; which is only relevant for MVVM architectures in the viewmodel layer That's not true. I use it all the time for Web-MVC projects as well. In fact, my I even tweaked my ORM to automatically validate against `INotifyDataErrorInfo` so that I don't have to worry about doing it manually. If you are using EF Code First, it will use `IValidatableObject`. https://weblogs.asp.net/scottgu/class-level-model-validation-with-ef-code-first-and-asp-net-mvc-3
You can use Active Patterns to match against `private` cases of your DU. https://stackoverflow.com/questions/54239399/discriminated-union-allow-pattern-matching-but-restrict-construction
Thanks for the clarification, I didn't know that.
That's awesome! Thank you for the answer
I used to declare Active Patterns before but now I usually just create a value-function: ``` module NoneEmptyString = let value (NoneEmptyString v) = v ``` You won’t be able to pattern match, but getting the value is just a one-liner. I am quite happy with this approach as well. 
The F# community obsession with single-case DUs generates a lot more effort than it saves. Single-case DUs also have no advantages relative to classes (which can also be private and have safe constructors).
OK. For that level of complexity it does make sense to use a more programmed solution.
Thanks for working on this. Its really an awaited feature that I think will be somewhat of a game changer in some areas. Do you think it might be shipped with .net core3.0 final or is that to early?
Hopefully before 3.0! We’re just now finished with our VS2019 GA payload, so work on this can resume soon.
My biggest complaint about F# tooling is the random crashes that I experience with Visual Studio. I can't find any logging or dumps, so I have no idea why it's happening or who/how to report it. It doesn't seem to be connected to FSI - if I were to hazard a guess, it's related to mixing C# and F# projects in the one solution. But that's a very vague idea. It's incredibly frustrating, and the only drawback I've experienced so far in such an awesome ecosystem.
How about Websharper? As a (perpetually) new F# user I don't understand why it isn't more prominent. It seems to be quite mature and full featured. 
Good point, but one I covered - for better or worse, I had already committed to Vue.js on the front-end. Unless there's some wrappers I couldn't find, that rules out WebSharper (which is a shame, because it would wrap everything up nicely).
That's awesome. Nice work
That doesn't really rule it out though. WebSharper does both front-end and back-end, and while one of its selling points is the tight integration between the two, it can also very well be used for just one or the other. I've done plenty of both. (Full disclosure, I'm one of the main developers of WebSharper)
Personally, I wouldn't put any weight on Swagger integration at the moment. Things like this end up being "non-essential" for development, and at some moment they end up being not used and eventually removed.
I've never had a crash, and I never use FSI, so maybe it is FSI! Maybe too some of these perf fixes will address the crashing. 
Did you find any framework that handles the HttpClient (HttpClientFactory) like the MVC one in .net core?
It's also notable that with Asp.net Core's upcoming Endpoint-based routing, which giraffe plans to integrate with, Swagger/OpenApi docs can be generated from the endpoints the selves, irrespective of the web application framework used to generate them. This is great because it means that giraffe/Saturn/Freya/et al exist on the same tier of support as asp.net core MVC for this feature. I'm quite excited for it.
You can just DI in an Http client, named or otherwise just like you would in MVC, from giraffe/suave. They both use the underlying HttpContext RequestServices model that ASP.Net Core MVC uses for dependency injection.
Don't you need to read before you process then write??
He is, those are backward pipes so it's equivalent to: writeData (processData (readData))
\&gt; One day I decided that enough was enough. I was going to quit. It was a cold, dark winter day. I exited the office, got in my car At this point I was thinking, "How relatable." \&gt; ... but then a fire erupted from under the hood. Cue superintendent Chalmers, "Good, Lord! What is happening in there?!"
Are you saying it's possible for me to use Vue.js and WebSharper together? If so, I'll definitely take another look.
&gt; Personally, I wouldn't put any weight on Swagger integration at the moment. Things like this end up being "non-essential" for development, and at some moment they end up being not used and eventually removed. You don't find it faster to write controllers etc to spec and auto-generate client code?
Unfortunately I still get crashes even without using FSI, so I'm not sure what's going on. Does make me want to throw my laptop out the window sometimes.
For outbound Http clients, I've been using [F# Data](https://fsharp.github.io/FSharp.Data/library/Http.html), though it doesn't really seem comparable to HttpClientFactory. Not sure if that answers your question. For whatever reason, I seem to use significantly less dependency injection with F#. 
any weird extensions?
I grew up in a family of software engineers, so I can't quite relate to the failure, but to the feeling like you're not good enough I can relate. &gt;The entire architecture is 10 lines of code, written in a couple of minutes. No interfaces, abstract fabrics, locs, all of these DefaultInterfaceNameClasses and other crap I have to do in C# before I even understand what I want to create. You write dumb core that simply solves the problem, and it’s more beautiful than your enterprise-level sufferings in Java or Sharp. The problem here is that you can (almost) write the same code in C# or Java. But most places don't. Object Oriented religion and their gods, the GoF, have made so many bad design practices industry standards that people think this bullshit actually helps. Often it's better to just write your functions in a simple manner and then if you actually need some abstraction only abstracting what's necessary. Object oriented programming is abstracting everything and then thinking about the problem, which is why it fails to deliver on its promise of flexibility so often. It might be the ultimately flexible design, but if you don't have that many moving parts, simple is often better, especially if rewriting simple parts into more abstract only when necessary is usually cheaper than doing it from the get go. But large corporations love OOP for the same reason that Conway's law is a thing. You can neatly put everyone in their niche and make them unproductive.
This has been sort of a moving target and involves extra attributes in the controllers. F# Swagger story is probably even in a worse state. Assuming the tools are a bit raw on F# side, an F# user can safely skip this item from analysis. &amp;#x200B; &amp;#x200B; &amp;#x200B;
&gt;This has been sort of a moving target and involves extra attributes in the controllers. F# Swagger story is probably even in a worse state. &gt; &gt;Assuming the tools are a bit raw on F# side, an F# user can safely skip this item from analysis. Ah, I see what you mean. By and large, I now agree with you, but I didn't know that before I started out. It was something that I really wanted, but after digging into the projects I concluded that it's probably all too immature at this stage. That being said, there are a few items on the horizon (e.g. [https://github.com/giraffe-fsharp/Giraffe.Swagger](https://github.com/giraffe-fsharp/Giraffe.Swagger)) which may change that opinion. &amp;#x200B;
I've never heard of the 'cake' term in this specific context, but the pattern should be readily replicable in F# :)
Not quite in the same way; I've only given the article a cursory read but it seems to rely heavily on higher-kinded types.
I haven't read the article, and don't think most anything is going to be exactly the same between languages that are different ;) &gt; ... you have one layer with functions to all impure calculations like DB access et.c. Afterwards you create a second layer with an interface, or type class, so that you can instance that type class with a pure and impure implementation for easy mocking As advertised, this is *highly* acheivable in F#. Modules, interfaces, signature files, types, and mocking frameworks in conjunction with the single pass compiler give you any and all tools needed for the job. This multi-layered approach to application composition is fairly standard, with various implementations in each tech stack. The benefits of higher kinded types can be built in through other means, cheaper, if all you need is bespoke architectural validation... You can also wire up [degenerate versions of them](https://robkuz.github.io/HKTS-in-fsharp-part-III-Concept-Emulation/) if you were trying to create a framework or something. There`s also looking into the dependent types and refinement types of [F*](https://github.com/FStarLang/FStar) to see if they cover the need.
Though it is nice not having to go through the ceremony of "public static class Foo {" public static void Bar() {" before you can write a function.
The ports &amp; adaptors (aka the hexagonal architecture) is probably most popular in F#.
I agree. Hell, you can do this pattern in ... well, basically every other language. I do it in javascript all the time. The article even links an explanation of it being done in [ruby](https://open.spotify.com/track/5Nv7Jj1ekvAh7SNZeQpZOR). Higher kinded types is one way of implementing the pattern, but it's still just a pattern.
How do you do this pattern in Javascript?
i personally think either way is fine. although if sheetService is something you initialize and close, i think a class models that type of api better. however, while you are building your api, it is easier to add functions to it when not adding methods to a class. so you could build a functional api but then wrap it later with a class once you have settled on the API.
This is a dependency injection problem. The strategy in these situations is usually to separate the dependency (\`sheetService\` in this case) from your functions somehow. You could pass the service in via a class constructor, but before you pull the trigger, consider giving this series a read-through: [https://fsharpforfunandprofit.com/posts/dependency-injection-1/](https://fsharpforfunandprofit.com/posts/dependency-injection-1/). It has some alternative suggestions. &amp;#x200B;
I'm still waiting for part 2..
That's the perfect case for a Reader Monad. 
This is how I load stuff in my .fs files, so that I can play with it in FSI \#if INTERACTIVE \#r @"packages\\FsToolkit.ErrorHandling\\lib\\netstandard2.0\\FsToolkit.ErrorHandling.dll" \#load "FileManager.fs" \#endif 
Any good F#-focused articles about that?
I agree that this is the exact scenario the Reader monad exists to address. I'll try to see if I can find the stuff I read that actually helped me understand it (though Scott Wlaschin's series on "elevated worlds" was part of it, at the same F# for Fun and Profit link above). Absent that, though, you could use currying to your advantage. Calling your existing functions with just an instance of the sheet service will give you a new function that has that parameter applied already.
https://fsharpforfunandprofit.com/posts/elevated-world-6/ That one perhaps.
Thanks a ton!
does this work in dotnet core? Cause the nuget packages is in your .nuget folder inside your user directory.
Sorry, I thought about mentioning packet management but left it out. I am using [Paket](https://fsprojects.github.io/Paket/) instead of the nuget client. I'm omw to turn in for the night so I just give a super condensed example how to install and use it for a hypothetical Console App.. with the project file in the root and a terminal opened there. First (only once ofc) install Paket as a global .net tool `dotnet tool install -g paket` Then configure Paket for the "per project/solution" `Paket init` `paket add` [`FSharp.Data`](https://FSharp.Data) `-p myproject.fsproj` Now you can add packages to the project with `paket add` [`FSharp.Data`](https://FSharp.Data) `-p test.fsproj` I might have done a typo but this is the basic concept. When starting with F# I was really hesitant/unmotivated to use Paket instead of the default Nuget Client because it just seemed to be more "stuff" for the same thing. I was wrong, it gives better control and I think its worth the switch. I have not used the Nuget client for a long time though so it might have improved. Anyway... that's how I do it.
What software doesn't exist in the world that you'd like to exist?
https://www.owlnet.rice.edu/~asolano/PrettyPictures/ 
Since you're new to the language I want to recommend fsharpforfunandprofit.com 
This looks really interesting! I am a little confused though. It uses algorithms to generate images? Does F# have graphical abilities?
Yeah, I found that! I’ll probably use it to get started on learning. Do they have simple programs that give an idea of tasks you could use F# for?
options for generating images: * opentk * directx * monogame * probably winforms or something on windows * generate a png with imagesharp and send it to a web page 
is this computer science or computer engineering? if the former, how about a compiler and text editor or ide for a small lisp langauge? ml dialects are great for compilers. also, f# has wpf and windows forms so you can build a nicentext editor ide. maybe make your lisp language a graphics language like processing.
CS. A text editor? That sounds pretty feasible. Thanks!
There is a post about [parsers](https://fsharpforfunandprofit.com/posts/understanding-parser-combinators/), that I find very interesting. It is a bit advanced, but it is a good, real-world example for monads, which is a programming-technique that is very common in functional languages.
yea, a text editor or ide for a simple lisp/scheme language sounds fun. f# is perfectly poised to do it, and it incorporates a lot of ideas. i have been wanting to do it myself.
Given that F# is from the ML family of programming languages that were designed to implement other programming languages and that it also has uniquely good support for GUI programming I'd say implement some kind of graphical programming environment. Maybe a Scheme REPL in a window or a little computer algebra system (if your parsing skills are up to it). 
* generate a BMP by writing bytes manually, the file format is super simple and it can teach you a bit about file IO if that's something you haven't done in .NET.
Here is a better link with more info on the project: http://sys.cs.rice.edu/course/comp314/10/p3/ the link I provided isn't the one I meant to. 
[https://www.seventeencups.net/posts/building-a-mud-with-f-sharp-and-akka-net-part-one/](https://www.seventeencups.net/posts/building-a-mud-with-f-sharp-and-akka-net-part-one/) This blog has a good tutorial for an interest "actor-model" kind of project.
\+1 for ImageSharp. I've used it very successfully to generate pngs. (Bmps would be similar.) Be aware it's still in alpha though. Message me if you decide to go down this route and have difficulty getting started.
Why don't you start by doing something \*really\* simple with a deadline of a week. This will get you used to working both with each other, and with the language. Put off the decision as to what to \*actually\* do until you've completed that - or at least 'failed fast'. By really simple I mean something like: \- A local file finder with a simple ui for 'find files containing' or 'find all files dated before...' etc. \- A batch image thumbnailer (using Imagesharp). I.e. complex enough to give everyone a role, but do-able in a week.
Vs code + the ionide extension continues to be a dream to work with for me
Vs code + the ionide extension continues to be a dream to work with for me
Simple answer: No IDE is ready because F# Interactive isn't ready. More complicated answer: FSI isn't _just_ FSI, it's "FSI on .NET Framework" and "FSI on .NET Core". Both are different because .NET Framework and .NET Core are different, and FSI was originally built with assumptions that were true with .NET Framework but not with .NET Core. Many of these have been resolved and will be released in the .NET Core releases that align with VS 2019 (you can use them in preview today), but there are some other things that aren't done yet: * Proper integration with VS (and other editors, which face similar problems), including answering the question of _which_ FSI to use under which contexts, plus whatever additional feature set can make sense with this in mind * Ability to have a sane way to send arbitrary references to FSI from an editor To address the second point, FSI will eventually have the concept of package references, which let you send packages to FSI. It's far easier to just specify `#r "nuget:FSharp.Data"` than it is to find some way to send a `.dll` that exists somewhere on your machine to FSI. The Visual F# Power Tools in VS 2015 had a way to sort of do that, provided you were scripting within a project, but that was still fundamentally a limitation of FSI that the extension managed to work with. Paket also has a way to generate a load script that you can `#load` into FSI, but it's still an additional burden.
the story happened with me too, i also burned out, and functional programming held me; then i found haskell and lot of other things; i wrote a [book](https://libeako.github.io/c/ID_1371518733.html) about this journey to attract fellow coders out of [the industry swamp](https://libeako.github.io/c/ID_311875598.html) be happy with f# and when you eventually become bored with it then remember that functional programming is only a first step; learn haskell to drop you jaw
God bless you! Figured out that VS Code was using the .NET Framework version by default and thanks to https://github.com/ionide/ionide-vscode-fsharp/issues/889#issuecomment-437469481 can now reference the .NET Core version of FSI.
I am understanding correctly that FSI with .Net core releases aligned with VS 2019 will be mostly functional on its own and only the IDE integration will be lacking?
Correct.
Build a tetris game using canvas in F# to Webassembly with Bolero https://github.com/fsbolero/Bolero/blob/master/README.md .. if possible. Webassembly will be the next big thing revolutionizing the IT business 
Thanks. That is awsome!
You don't need to
No
nope!
No, I don't think so. I learned F# before C#, and learned dot net as I learned F#. Good luck in your journey!
I'm still learning the language myself, and I would say that most of the time the answer is no. However, F# does run on .net, so you will have situations where you want to figure out how or why something works like it does in .net (especially if you try using F# on Linux and .net core without all the perks of vs, so you have to understand better how the whole project/solution/dotnet cli thing works) and you will find a lot more materials referring to C# than F#. And if you start writing any projects, you will probably need to read C# api of some library you want to use. But if you ever worked with any of the C-like languages, this shouldn't be an issue. Also, sometimes when you read some blogs or watch some talks, they will use terms that may not be familiar to people without any .net background (things like IDisposable, for example). Again, you will easily find a lot of materials (most of it in C#, though) to understand these topics.
Learning F# first helped me learn C#.
There may be some interop situations where knowing a bit of C# will be useful, but it's not required.
To start learning? No. Do you want to write applications? Yes, and it can be difficult to learn this in my experience. Examples of things that FSharpers don't teach because it's assumed you'll know or learn from CSharpers: \- How fsproj or sln files work \- How compiling a project works \- How config files work \- How to fix problems with assembly resolution (and there can be sooo many) \- How to create GUIs \- How commonly used (but oh so intricate) DotNet types function (looking at you [HttpRequest](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httprequest?view=aspnetcore-2.2)) \- How Attributes work &amp;#x200B; I love F#. I think you should consider learning it. But damn it can be frustrating if you don't come from a developer background. Here's some resources that have helped me: \- Expert F# 4.0 by Don Syme ( great for referencing) \- Get Programming with F# by Isaac Abraham (great as a beginner's guide) \- Stack Overflow (great for asking tough questions) \- [F# Slack](https://fsharp.org/guides/slack/) (great for asking simpler questions) \- [https://fsharpforfunandprofit.com/](https://fsharpforfunandprofit.com/) (great as a guide for the topics more related to pure functional programming; really incredible work here) \- [.NET API Browser](https://docs.microsoft.com/en-us/dotnet/api/) (for basic DotNet reference)
You don't need to. A lot of learning material does assume that you know dotnet though.
I have been using F# professionally for 13 years and still haven't learned C#. Once you have F#, Intellisense makes it very easy to learn .NET. 
No. Good luck and have (fun x -&gt; x*2)
It would help to know how GC works and how assemblies are structured in general.
Do you have any good references for those? I’m also getting into f# without a .net background
Good one. I learned on 1.0 in 99-2000, i believe it was a predecessor book to “C# and the .NET framework” by Troelsen. It was leaps and bounds beyond other fluff and explained how the entire framework works and why it was designed like it was. You don’t have to learn C#, but find something that has equal emphasis on explaining the underlying system. Probably not going to ever use it directly - but it will separate you from language jockeys. 
It depends whether you know another language. If you can Google c# and the other languages concept name you'll be fine. 
You don't, but I would recommend checking out a decompiler tool like ILSpy or dotPeek because those tools will help you establish a frame of reference to C#. Caveat, it works better with simple F# code, however sometimes even simple F# code generates complicated looking C# code. Nevertheless... Good luck on your endeavors!
+1 For this perspective. Though I'd say that the former are less about learning from "CSharpers" and more about the .net ecosystem - which as C# is the primary language ends up being mostly C#. Notably though the first few have been through a number of revisions centered around .net core so learning about these comes with a bit more of a "fresh start" and a lot can be gleaned from some of the dotnet new &lt;template&gt; infrastructure.
As a beginner myself, learning functional programming was quite nice thanks to fsharpforfunandprofit. But holy hell noone prepared me for the .NET environment and I've quit several times with F# as I just couldn't put all the pieces together on how it all interacted. NuGet and paket, sln's vs fsproj (and csproj too?). Hey .NET Core is also released and we have Mono! What the hell are assemblies even? By trying and failing then googling, I got most of my answers and how-to's, but a dotnet environment intro for outsiders would be welcome. I feel like all those kind of guides come from a C# perspective.
I agree with /u/jks612's central point - 95% of F# educational content out there assumes you're come from assumes you have some background in C#. That said, I believe that the rewards will be worth your effort.
Thanks Everyone!:)
Learning F#! 
Looking into writing an F# [System.Collections.Immutable](https://docs.microsoft.com/en-us/dotnet/api/system.collections.immutable?view=netcore-2.2) wrapper. Some of these classes (structs, actually) have amazing performance profiles, like ImmutableList, which has O(log n) random access and tail insert. Also, trying to get FsXaml to behave in F# Interactive so I can use it for work. Also, writing a small website backend for work using [Giraffe](https://github.com/giraffe-fsharp/Giraffe) (a functional ASP.NET wrapper). Also, daydreaming about writing a toy programming language, mostly because I want to play with [fparsec](http://www.quanttec.com/fparsec/). Also, trying to figure out ways to improve the FSI experience. Been using F# for over a decade now and I'm starting to fall in love with its shortcomings, which is kind of terrifying.
My coursework that’s in f# 
Hope all goes well!
 That’s easy: no. :)
One of my previous employers had some serious .net engineers. My first project was to take over and maintain a codebase that was something like 40k lines of code, full of classes, abstractions, interfaces, it was a mess. Took me a month to learn my way around the basics of it and after a couple years I was finally confident I understood the code. Then I moved to another company that had the exact same problem to solve and I took my knowledge and rewrote the entire process that took me forever to learn and reduced it to about 3k lines of pretty straight forward imperative/functional code: one helper class full of functions, a couple of classes for data representation, and then the primary application logic which was embarrassingly minimal compared to the monstrosity I was tasked with maintaining before. The best part was I was able to explain the code in about 15 minutes to the junior devs that came in and they were off and running with it in a few days once they got used to the production environment. As you've noticed, I sometimes think OOP is a hammer and people look to use it to hammer everything with when sometimes, all you need is "echo 'hello world'". 
Thera are not a lot of jobs but at the same time there are not a lot of F# developers to compete with. F# is a great language and it's to bad that people don't give it a serious try.
\&gt;Is the market as strong as it is for C# developers? Definitely not, but there aren't as many people applying for F# jobs either. I was job hunting a couple months back in the USA and got two F# related job offers , and they were the highest paying offers. So the jobs are out there, and seem to pay well. &amp;#x200B;
Well, that explains why I get zero results for F# jobs in my area. That's too bad, seems like a great language. 
It *is* a great language. Learning it will make you a better developer, and then it will become your favorite tool in your belt whether you decide to go for a full time F# gig or not. &amp;#x200B;
Just out of curiosity, which companies were they?
Project #1 is related to conduits for biiig data centers. It is an inherited code base but with lots of new feature development as well, so I am creating new features using F#, and I also recreated the build and installers with F#. The existing features tend to be very stratified throughout many project layers. One very nice thing about the new features I have implemented in F# is that it has been easy to consolidate the logic together and in mostly one place. &amp;#x200B; I dabbled with the idea of creating UI for the new features using Elmish.WPF, but I was unable to incorporate Rx with Elmish in a way that wasn't "hacky"; so I am still waiting for that story to improve. Also, the Elmish patterns seem to be designed around a "SPA" style application, which is not really a good fit. I still would really like to do this, but I just haven't been able to make any headway there. &amp;#x200B; Project #2 is a brownfield C# [ASP.NET](https://ASP.NET) MVC + jQuery + NHibernate app, which is perhaps the most unsatisfying stack ever! :.( But I will be creating a much need FAKE build script for it, as well as some automated deployment. 
dell virtustream and olo.com olo is where i am now, mostly a c# shop but my team has an f# project
Right on. Thanks.
Pros and cons, based on my branding myself as an F# developer for the past several years: \*Pro\* 1) The 2018 stack overflow survey rates it as the highest paid tech: [https://insights.stackoverflow.com/survey/2018/#top-paying-technologies](https://insights.stackoverflow.com/survey/2018/#top-paying-technologies) This bears out my own experience, where F# has proved a great defense against the fact that older developers' salaries tend to decline over time. 2) It's a great filter against recruitment time-wasters. Looking for "A developer for a cutting edge greenfield machine learning project. Technologies. C#, [ASP.Net](https://ASP.Net)... Salary: £35k". Yeah. No. 3) There seems to be an increasing number of "dark matter" F# teams with little or no social media presence. The last time I moved between F# roles, I had to move about 300 metres. This was in what Londoners like to think of as 'the provinces'. 4) A great community. \*Con\* 1) The F# market is somewhat 'illiquid' - i.e. at any one time there aren't that many roles out there. And it's hard (by definition) to valid illiquid markets. (This does make me question the significance of that survey result.) 2) Recruiters don't seem to know what F# is, however often I tell them. 3) A few companies/recruiters will say that F# is in use when it really isn't. Ask searching questions! 4) Managers whose egos depend on having 'human waves' of C# developers really don't like F#. Not really a 'Con' because you can use this fact as a filter. &amp;#x200B; Ultimately the decision you have to make is "Do I personally want to be a commodity or a premium product". Luckily learning F# will greatly improve your approach to other languages such as C# and Python. A member of my team was telling me only this week that learning F# had transformed his approach to Python. There really isn't a downside to learning it, whatever your opinion of the current job market. &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B;
[We've been trying and failing to hire F# people for years](https://www.idtechex.com/careers/jobopps/data_scientist_000620.asp). We've used a few consultancies to try to get work done but the quality was generally awful and only one of the projects was ultimately deployed. A large part of the problem is that the vast majority of F# developers are clinging to yesteryear's technologies. Web development was especially problematic. I have basically given up on trying to expand our F# efforts at this point because the RoI has been so bad. 
fwiw R# does emit a warning for switch statements when not all the cases are covered
.NET Core SDK is much smaller than that and contains all the tooling you need. https://dotnet.microsoft.com/download
Plus pair that with VSCode and Ionide too for Debugging you have a pretty lightweight development environment. 
Does that work for enums only, or subtypes/pattern matching also?
I already have VSCode and I will probably bin Visual Studio itself as I haven't needed to touch it in over a year, and VSCode is not only smaller in terms of HDD space taken, but also much easier on resources.
ohh you got me there, I've only seen it on enums
Incorrect title. There is no reason to believe that this will be offered in C# 8. The last update to the proposal was 2 years ago and the Liam's are broken.
Ah thanks for clarifying that.
It's compiler sugar, so the underlying objects will be normal POCOs with some read-only considerations. F# records will still be independent. One is a nice way to glue this into a finished language, the other is what you want for deeper guarantees and language support outside of superficial sugar. On a side note: I remember *so much* of the OOP design arrogance flying out of .net ecosystem in the early 2000s... A couple decades later and C# is now trumpeting so much of what the zealots said was irrelevant.
I have a blog post which goes goes step by step through getting F# up and running on .net core with Ionide and Fable. Step 3 is the smallest amount of visual studio build tools that I could find which lets you use F# interactive. If you just skip it everything will work _except_ interactive and that should come to .net core soon.
Thanks 
it is practically non-existent. i know because i have looked and looked and looked. the only "big" place hiring people is jet.com, but even that is disappointing. i am sure there is a lot to do there, but working on e-commerce just isn't an exciting application. i am sure there are people using f#, but from what i can tell, these places are have a very small f# team. and it seems they tend to hire or train internally rather than asking for an "f# developer". almost every single job description that has f# in the description (a rarity) actually uses another language like scala and only uses the description to generally attract functional programmers. i am trying to force fit it into my job, and i have, but it has been extremely basic things. however, moving completely to f# is a bit problematic because it would require a significant amount of "infrastructure copying" from my current environment. i think it could be a win in the long run, but it isn't an easy binary switch. the only way i feel i will ever do f# on the job that isn't either financial or advertising or mobile- or web-app related (a disappointing high percentage of most software jobs anyway) is just to starting using myself and force it.
I've been working on a programmable wiki.
I tried FsPickler before and found it unsuitable because it can only deserialize back to the same instantiation of the same type. For example, if you redefine your type in FSI and try to deserialize to the new type it fails.
It’s really sad that microsoft doesn’t put in the effort to support F# on the same level JavaScript, C++ and C# is supported by UWP.
i would abandon the idea that vs is a hog. compared to vscode with ionide running it really isnt. time some common workflow scenarios sometime.
Then it must be something I'm experiencing as I find that VS really doesn't well on my laptop.
you may find similar problems once ionide is doing it’s thing. do you use resharper along with vs? that slows it down a lot.
I don't use ReSharper, though I think I had a VisualD plugin that bugged out pretty nasty. I'll look into that. I wanted VSCode support also partly because I'm on a Linux dual boot setup and sometimes I use that.
ah, yeah in that case if you can get ionide working with that setup it will be a big help. good luck! 
I don’t want to try it myself, but is `client.UseDefaultCredentials = true` even valid? I would think it should be `client.UseDefaultCredentials &lt;- true` since I presume that’s a mutable property of client. In F#, `=` is used for equality tests and let binding, not for mutation.
I regret the time I wasted learning F#. Its a shame it isn't much more than a hobby project for MS. 
Is it not supported? https://www.reddit.com/r/fsharp/comments/acj7dn/f_winrtuwp_apps_on_net_native_are_now_releasable/?utm_source=reddit-android or will it be?
It's unofficial, and not complete.
&gt; We can confirm that .Net Native compilation works now on Store compilation machines, and we have released our beta F# app on the store ... So the building machines from Microsoft allow compile .NET Native F#. What excactly is incomplete? 
I'm much more interested in support for web than support for UWP.
\&gt; A large part of the problem is that the vast majority of F# developers are clinging to yesteryear's technologies Anything specific, or just complaining with no context? \&gt; F# developers seem to be completely clueless about web development Server side: \- Giraffe \- Saturn \- Suave \- basically anything that .NET has to offer (given the fact, that [ASP.NET](https://ASP.NET) is basically the fastest production-grade web server on tech empower benchmark, it's a thing). Both Giraffe and Saturn are build on top of [asp.net](https://asp.net) middleware. \&gt; There isn't even a decent standard way to generate HTML from F# \- Fable with entire ecosystem \- Anything that .NET has to offer (HtmlAgitlityPack or CsQuery for example). \&gt; I benchmarked the standard FSharp.Data implementation against RapidJson and found the F# code was 40x slower. Looking in detail I found it was generating huge intermediate data structures because its API is fundamentally flawed. I had a go at writing my own JSON serialization code in F# and was plagued by the same issue because it also appears in F#'s own Reflection API. You've got Jil (which is faster than protobuf), Chiron, FSharpLu. Developing something on your own is easy (JSON parser is around 50-100LOC in F#), but for sure it won't be fast, especially when you have no idea what you're doing. &amp;#x200B;
why dont we as f# work on our own ui framework?
errrbody wants their niche language to have a great ui framework. ain't nobody wanna write all that code. &amp;#x200B; &amp;#x200B;
It is not available in production builds from Visual Studio, if you read the thread discussion there is still some care required regarding generated IL, and no UWP documentation has been updated to reflect it. I wouldn't stick my neck for putting it into production. Rather use the features C# keeps getting from F# instead.
&gt; I don’t want to try it myself, but is client.UseDefaultCredentials = true even valid? I would think it should be client.UseDefaultCredentials &lt;- true since I presume that’s a mutable property of client. In F#, = is used for equality tests and let binding, not for mutation. Interesting point. It is valid and works though… &gt; Also, WebClient has a dispose method. So, you could pack this all into a function that takes a float parameter (your BTC balance). Then, use use client = WebClient() instead of the let binding, so that you clean up after yourself once you print the result and go out of scope. Also, a lot of this can be piped instead of explicitly bound. Right, thanks 
We have written great UI frameworks for F# for important platforms - [Elmish](https://elmish.github.io), [Fabulous](https://github.com/fsprojects/Fabulous), [Elmish.WPF](https://github.com/elmish/Elmish.WPF)... And UWP? Well, waste of time, it’s dead platform
well i greatly appreciate all these platforms, but for native ui performance we should have something like Qt, wpf. am i wrong at something here?
I am enjoying my dead platform right here, doing application design with Adobe XD, just like the users of HoloLens and gamers that updated their Xbox to XBox ONE. Pretty dead indeed.
[Good for you](https://imgur.com/gallery/R1fdEt3)
f# doesn't support uwp does it yet? it will with .net core and f# 4.&lt;something&gt; though, right?
&gt; &gt; A large part of the problem is that the vast majority of F# developers are clinging to yesteryear's technologies &gt; &gt; Anything specific, or just complaining with no context? Don't get emotional about technical discussions. &gt; &gt; F# developers seem to be completely clueless about web development &gt; &gt; Server side: &gt; - Giraffe &gt; - Saturn &gt; - Suave Giraffe, Saturn and Suave are three incompatible ways to do the same thing badly. Having tried them I now use `HttpListener` directly instead. F# has evolved the same problem that OCaml had: tiny community fragmented between many incompatible ways to do the same thing. We actually hired the people who wrote one of those solutions and they failed to deliver a working product. And it was a simple project. &gt; - basically anything that .NET has to offer (given the fact, that ASP.NET is basically the fastest production-grade web server on tech empower benchmark, it's a thing). Both Giraffe and Saturn are build on top of asp.net middleware. I benchmarked it againt OCaml with async, cohttp and yojson recently and the latency of the .NET solution was ~1,000x worse out of the box. Not that I need low latency for the problem I'm facing now but, suffice to say, I'd take those benchmarks with a huge grain of salt. My company actually uses older ASP and not ASP.NET precisely because ASP.NET is a pile of crap. Also, F# has essentially no value add in this context. &gt; &gt; There isn't even a decent standard way to generate HTML from F# &gt; &gt; - Fable with entire ecosystem LOL. Don't forget Funscript and Websharper. Again, many immature and incompatible libraries solving the same problem badly so none of them have gained any traction. &gt; - Anything that .NET has to offer (HtmlAgitlityPack or CsQuery for example). Again, no value add. &gt; &gt; I benchmarked the standard FSharp.Data implementation against RapidJson and found the F# code was 40x slower. Looking in detail I found it was generating huge intermediate data structures because its API is fundamentally flawed. I had a go at writing my own JSON serialization code in F# and was plagued by the same issue because it also appears in F#'s own Reflection API. &gt; &gt; You've got Jil (which is faster than protobuf), Great that its fast but it doesn't even work with F#'s own built-in types: Map[(1, 2), 3] |&gt; Jil.JSON.Serialize Jil.SerializerException: Error occurred building a serializer for Microsoft.FSharp.Collections.FSharpMap`2[System.Tuple`2[System.Int32,System.Int32],System.Int32]: JSON dictionaries must have strings, enums, or integers as keys, found: System.Tuple`2[System.Int32,System.Int32] ---&gt; Jil.Common.ConstructionException: JSON dictionaries must have strings, enums, or integers as keys, found: System.Tuple`2[System.Int32,System.Int32] at Jil.Serialize.InlineSerializer`1.WriteDictionaryWithNulls(MemberInfo dictionaryMember, Type dictType, Local inLocal) at Jil.Serialize.InlineSerializer`1.BuildDictionaryWithNewImpl(MemberInfo dynamicMember) at Jil.Serialize.InlineSerializer`1.BuildDictionaryWithNewDelegateToString() at Jil.Serialize.InlineSerializerHelper.BuildToString[BuildForType](Type optionsType, Boolean pretty, Boolean excludeNulls, Boolean jsonp, DateTimeFormat dateFormat, Boolean includeInherited, UnspecifiedDateTimeKindBehavior dateTimeBehavior, SerializationNameFormat serializationNameFormat, Exception&amp; exceptionDuringBuild) --- End of inner exception stack trace --- at _DynamicMethod6(ThunkWriter&amp; , FSharpMap`2 , Int32 ) at Jil.JSON.Serialize[T](T data, Options options) at &lt;StartupCode$FSI_0013&gt;.$FSI_0013.main@() &gt; Chiron, You recall I said FSharp.Data was 40x slower than other (non-.NET) solutions. Well I just tested Chiron and it is 3x slower than FSharp.Data and requires even more memory: Chiron: 15.125332s GC gen0: 530, gen1: 144, gen2: 9, mem: 579297kB FSharp.Data: 5.812851s GC gen0: 245, gen1: 72, gen2: 3, mem: 488573kB &gt; FSharpLu A quick test of FSharpLu shows that it silently corrupts your data when writing and crashes if you try to read it back in: Map[(1, 2), 3] |&gt; Microsoft.FSharpLu.Json.Default.serialize |&gt; Microsoft.FSharpLu.Json.Default.deserialize&lt;Map&lt;int * int, int&gt;&gt; Newtonsoft.Json.JsonSerializationException: Could not convert string '(1, 2)' to dictionary key type 'System.Tuple`2[System.Int32,System.Int32]'. Create a TypeConverter to convert from the string to the key type object. Path '['(1, 2)']', line 2, position 11. ---&gt; Newtonsoft.Json.JsonSerializationException: Error converting value "(1, 2)" to type 'System.Tuple`2[System.Int32,System.Int32]'. Path '['(1, 2)']', line 2, position 11. ---&gt; System.ArgumentException: Could not cast or convert from System.String to System.Tuple`2[System.Int32,System.Int32]. at Newtonsoft.Json.Utilities.ConvertUtils.EnsureTypeAssignable(Object value, Type initialType, Type targetType) at Newtonsoft.Json.Utilities.ConvertUtils.ConvertOrCast(Object initialValue, CultureInfo culture, Type targetType) at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.EnsureType(JsonReader reader, Object value, CultureInfo culture, JsonContract contract, Type targetType) --- End of inner exception stack trace --- at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.EnsureType(JsonReader reader, Object value, CultureInfo culture, JsonContract contract, Type targetType) at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.PopulateDictionary(IDictionary dictionary, JsonReader reader, JsonDictionaryContract contract, JsonProperty containerProperty, String id) --- End of inner exception stack trace --- at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.PopulateDictionary(IDictionary dictionary, JsonReader reader, JsonDictionaryContract contract, JsonProperty containerProperty, String id) at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue) at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.Deserialize(JsonReader reader, Type objectType, Boolean checkAdditionalContent) at Newtonsoft.Json.JsonSerializer.DeserializeInternal(JsonReader reader, Type objectType) at Newtonsoft.Json.JsonConvert.DeserializeObject(String value, Type type, JsonSerializerSettings settings) at Newtonsoft.Json.JsonConvert.DeserializeObject[T](String value, JsonSerializerSettings settings) at Microsoft.FSharpLu.Json.Default.deserialize[T](String json) at &lt;StartupCode$FSI_0006&gt;.$FSI_0006.main@() &gt; Developing something on your own is easy (JSON parser is around 50-100LOC in F#), but for sure it won't be fast, especially when you have no idea what you're doing. Also not a compelling reason to use F#. 
There is unofficial support. https://www.reddit.com/r/fsharp/comments/acj7dn/f_winrtuwp_apps_on_net_native_are_now_releasable/
Dead platform, more alive and supported than anything else, including every other framework that has come before it. 
I'm not the one being emotional ;) I'm sitting in F# jobs for 3 years, long enough to let the love-at-the-first-sight phase to pass. Nonetheless, I was able to write high perf F# and deliver products on multiple occasions, so from my experience your claims sounds just funny. \&gt; Giraffe, Saturn and Suave are three incompatible ways to do the same thing badly. So maybe first define, what's "good" by your standards. \&gt; I benchmarked it againt OCaml with async, cohttp and yojson recently and the latency of the .NET solution was \~1,000x worse out of the box. \[Here\]([https://www.ageofascent.com/2019/02/04/asp-net-core-saturating-10gbe-at-7-million-requests-per-second/](https://www.ageofascent.com/2019/02/04/asp-net-core-saturating-10gbe-at-7-million-requests-per-second/)) you have more detailed article - [ASP.NET](https://ASP.NET) Core doing 7mln req./sec (and outperforming i.e. nginx). I'm talking about the .NET Core version of [ASP.NET](https://ASP.NET) \- if you're using old one then you're the only one to blame. Also let me be just as skeptic about your benchmarks, since you're the person who uses \`#time\` for microbenchmarking JIT (and reflection-heavy code) instead of proper micro-benchmarking solution able to do warmups ;) \&gt; LOL. Don't forget Funscript and Websharper. Again, many immature and incompatible libraries solving the same problem badly so none of them have gained any traction. Sure, Fable has it's own conference, and it's used by multiple companies. But as you've said, no traction at all. \&gt; Great that its fast but it doesn't even work with F#'s own built-in types: Great, because RapidJson (which was your own example) also would fail on that scenario (or any non-string key in a map). The reason for F# is ability to be able to utilize .NET platform potential (i.e. very good multicore and I/O support, which btw. is still not a thing in ocaml, you've used for comparison) with it's low level primitives, while still being able to use functional-rich language (HM type inference, expression-based syntax, expressive type system). But maybe instead of trying to fight with your arguments, one should ask: if you dislike so many things, please share with your examples on how things should be done. So please let me understand: what languages and frameworks would you use, and why?
Indeed, please let us know when the amount of F# apps in production surpasses UWP ones.
I think you're missing the most common way of doing this: tuple deconstruction. &amp;#x200B; Let's say you have a tuple: \`let x = (1, 2)\` You can deconstruct this into its parts like this: \`let a, b = x\` Then, you can get the sum by: \`let y = a + b\` &amp;#x200B; I don't think people use \`fst\` and \`snd\` very often, especially since they don't work (iirc) when using n-tuples where n &gt; 2
I know about deconstruction but that requires a whole new row for doing that. The ._X syntax is more succinct and readable. I want to be able to extract the values inline where it is being used.
It's not readable because it's not clear what _1 and _2 are. Also the presence of underscores indicates that this is doscouraged and not idiomatic
It's not idiomatic F# since it's not in the language. Its idiomatic scala and for a scala developer it's very clear what it does. If F# incorporates the syntax everyone would see it as idiomatic and understand exactly what it does. It's the same for non F# developers seeing ex: ":&gt;" for the first time . 
Not *that* alive. Forms and WPF will outlive it because they happened before web revolution
&gt; I'm sitting in F# jobs for 3 years Wow, impressive. Good for you! &gt; if you're using old one then you're the only one to blame My company uses Classic ASP. Nothing to do with me personally. &gt; Sure, Fable has it's own conference, and it's used by multiple companies. But if you said no traction at all, then it must be true. Especially when you put OCaml in your counter examples. OCaml is far more widely used in industry than Fable (or any of the other F# libraries you've cited). &gt; RapidJson (which was your own example) also would fail on that scenario (or any non-string key in a map). Again, not a compelling win for F#. &gt; The reason for F# is ability to utilize .NET platform potential (i.e. very good multicore and I/O support, which btw. is still not a thing in ocaml, you've used for comparison) with it's low level primitives while still being able to use functional-rich language (HM type inference, expression-based syntax, expressive type system). You say F# has great multicore and IO support and, yet, OCaml is 10x faster in the context of JSON and HTTP. You say F# is a "functional-rich language" but, again, I just pointed out that optimising the reference types into value types in my 60-line JSON parser causes it to stack overflow which is a bug in the JIT not honoring tail calls. &gt; But maybe instead of trying to fight with your arguments I wasn't arguing. That's the whole point of my having provided concrete counter examples. I just gave you several example one liners that break the libraries you've referred me to in fundamental ways because those libraries suck. &gt; your examples on how things should be done MLs like F# have a simple core type system consisting of atomic types, tuples, records and unions. In modern programming you should be able to (structurally) serialize any value of any of those types to and from JSON with a simple function call. Erlang does it. Mathematica does it. Clojure does it. F# has many libraries that pull in even more dependencies to try to do this simple task and I've tried ~12 of them and they all have serious bugs like the one I just showed. &gt; what languages and frameworks would you use, and why? OCaml is an obvious choice but there are many other alternatives that get these basic things correct out-of-the-box. 
I dislike the .\_N syntax deeply. Don't make it easier for developers to do stupid things - they're good enough at it without bad language features.
If someone wants to access individual elements of a tuple for something as simple as the example you provided, I imagine most people would just use an array.
&gt; Who is using Fable in production today? You've got a list of some of the companies on main site. &gt; OCaml is used in this context by Facebook, Bloomberg and Jane St, for example You mean, by 10 people at Facebook, probably next 10 at Bloomberg, etc. Companies like [Jet](https://jet.com/) have over 1000 employees, system working on over 2000 machines, and F# is their primary language. &gt; Yet OCaml is ~10x faster in this context (JSON and HTTP). You say that as if F# burning all my cores whilst still running slowly is a good thing. **Your** OCaml may be ~10x faster (which 2 responses later was ~1000 times, with no proof provided) than **your** F# ;) And given the context - as you've said, F# developers failed to deliver simple product in your company - which pretty much mean, that you're not an F# developer. &gt; Again, I just pointed out that optimising the reference types into value types in my 60-line JSON parser causes it to stack overflow because the foundation on which F# is built and is entirely reliant upon doesn't honor tail calls in the specification of the CLI precisely because Microsoft don't take functional programming seriously. Again, only proves what code do **you** write ;) F# (and .NET VM) honors tail calls. There's a known issue, that F# compiler may not optimize `rec` functions, which can be PITA. &gt; I just gave you several example one liners that break the libraries you've referred me to in fundamental ways. And gave an another library as a counter example (RapidJson in your case), which also would not work with the type you've specified. &gt; Ideally a serialization library should even support the evolution of user-defined types. For example, it should allow you to add new union cases and record fields and still work in at least one direction, i.e. deserialize to a supertype. Agree on that. Still I don't see how this addresses the problem.
If you are using reflection, it might be that those classes are not supported by AOT compilation to native code. https://docs.microsoft.com/en-us/xamarin/ios/internals/limitations
Fabulous works with UWP or WPF or Qt or Android or iOS or ... 
&gt; You mean, by 10 people at Facebook, probably next 10 at Bloomberg, etc. Companies like Jet have over 1000 employees, system working on over 2000 machines, and F# is their primary language. Why are you comparing the total number of employees at Jet.com with your estimated number of OCaml developers in Facebook working on messenger? &gt; Your OCaml may be ~10x faster I've written low latency servers for the finance industry in both OCaml and F# using Infiniband. The OCaml is ~10x lower 95% latency. &gt; (which 2 responses later was ~1000 times, That was OCaml's web stack vs ASP.NET according to the website you gave. &gt; with no proof provided) I'm under NDA. &gt; than your F# ;) And given the context - as you've said, F# developers failed to deliver simple product in your company No. I said the F# consultants who wrote software you cited and ran (or sponsored?) the conference you cited failed to deliver for us. &gt; - which pretty much mean, that you're not an F# developer. If that's what your 3 years of F# experience tells you. &gt; Here's the counter example. You're comparing some of the largest industrial OCaml and F# code bases with the Great Computer Language Shootout. &gt; F# (and .NET VM) honors tail calls Then how come changing from a reference type to a value type turns a program that works on arbitrarily-long input into one that stack overflows almost immediately? &gt; There's a known issue, that F# compiler may not optimize rec functions on few occasions Which issue on Github are you referring to? &gt; And gave an another library as a counter example (RapidJson in your case), which also would not work with the type you've specified. 
&gt; 2,000 machines but Messenger is on "1,000,000,000+" Android devices and then there's iOS. Apples to oranges. You're comparing server apps running millions requests/sec. to JavaScript compiled language used by one person on one machine at the time. &gt; You're comparing some of the largest industrial OCaml and F# code bases in the world with the Great Computer Language Shootout. No, I'm comparing verifiable evidences to unverifiable opinions. &gt; Then how come changing from a reference type to a value type turns a program that works on arbitrarily-long input into one that stack overflows almost immediately? How do you expect me to answer, without seeing the actual code? ;) &gt; Which issue on Github are you referring to? https://github.com/fsharp/fslang-design/blob/master/RFCs/FS-1011-warn-on-recursive-without-tail-call.md &gt; How many F# JSON libraries can serialize and deserialize Map[(1, 2), 3] correctly? Depends on your definion of "correctly". If we assume that Map type should be serialized into JSON map, then IMHO correct result of that value should be a runtime error.
&gt; https://github.com/fsharp/fslang-design/blob/master/RFCs/FS-1011-warn-on-recursive-without-tail-call.md That's about flagging non-tail calls which is irrelevant to this bug in .NET's JIT. &gt; If we assume that Map type should be serialized into JSON map, then IMHO correct result of that value should be a runtime error. ML `Map` supports any key type whereas JSON objects support only string field names. 
For that specific example, I'd use `x ||&gt; (+)`. Replace `(+)` with whatever function makes sense, but it works w/o having to access individual elements.
Fair point
Fair point. We shall see :)
I'm using reflection as the code show. This is for the decimal type. It work elsewhere except on this case. 
Do you know, that C# Tasks were once a nuget package, too? To your question, I did not know other libraries for that. So my (unqualified) answer ist yes.
Why did you learn it in the first place? It’s not like it was ever the main language for .NET development...
the idiomatic way to deconstruct tuples is let x = (1,2) let (a,b) = x let y = a + b now, you may not like the extra line, but that is the standard way to pattern match tuples. it can be very convenient in larger functions and pattern matching. for example, say you were only interested in one of the elements of a tuple. then you could do something like: let (_,z) = (1,2) // now z = 2 in terms of syntax, your parentheses are not needed: let x = (1,2) let y = fst x + snd x so, i personally don't see much difference between that and let y = x.1 + x.2 i understand how that it is slightly cleaner, but not much. although, i do not think the underscores are cleaner. something like let y = x.1 + x.2 would be cleaner. tuples are not recommended to be large, and are only really intended for simple datatypes. they aren't intended to be much larger than two or three elements (there isn't even a default function to get the third element from a tuple), and so your syntax adds additional features to the language for little payoff. dot notation is reserved primarily for objects and records. records are recommended since they name the elements, whereas tuples do not name their elements. let's say you *really* wanted to do the above. well, you can with records. for example: type Tuple&lt;'a,'b&gt; = {_1 : 'a; _2 : 'b} let x = {_1 = 1; _2 = 2} let y = x._1 + x._2
I've got several projects that use EF Core. It works well, and if you're also using Giraffe (or something that uses TaskBuilder.fs), you can use the `task` computation expression. I use the function style (`db.Users.FirstOrDefaultAsync(fun x -&gt; x.Id = 3)`) instead of the `query` CE.
Shameless plug: If you are looking to do mostly untyped sql generation, take a look at [https://github.com/vivainio/SqlFrags](https://github.com/vivainio/SqlFrags)
Maybe the Typeprovider SQLProvider ([https://fsprojects.github.io/SQLProvider/](https://fsprojects.github.io/SQLProvider/)) is something for you. But this is more lightweight than a full ORM with the integrated pepository pattern. Also you can serialize the generated types, because with a type provider the types will be objects at runtime (so my last information about that). So before you send the "entities" over the ether, you better map them into a proper DTO. The awesome thing is, when you Databse changes, your code brakes and the compile tells you, what is wrong and not the ORM, when you try to write data.
This is not my project, but I just wanted to share it here, because I think it's great. It's also a nice example project if people want to see some F# code.
Dapper and SQL is decent choice. In the end best DSL for SQL DB is... SQL. 
I am currently on mobile, so I can't confirm, but I am guessing that VS Code generates a. Net Core project, not a classical net framework one. I am hoping that Godot will use NET core in the future too so you can use the command line tools. 
Looks interesting. Something to play with while waiting for dot net core F# interactive...
Hey thanks for the reply! So changing the fsproj to include the references and "TargetFrameworkVersion" to v4.5 won't help in Ionide? Also this all got a bit more annoying cause after updating VS 2017 I get different error in Godot when building a hello world in VS2017: `Message: Building solution configuration "Tools|Any CPU".` `Project "Dodger.csproj" (default targets):` `Project "DodgerFs.fsproj" (GetTargetFrameworks target(s)):` `C:\Users\rskar\stack\dev\gamedev\FSTest\DodgerFs\DodgerFs.fsproj(42,3): error MSB4020: The value "" of the "Project" attribute in element &lt;Import&gt; is invalid. [C:\Users\rskar\stack\dev\gamedev\FSTest\DodgerFs\DodgerFs.fsproj]` `Done building project "DodgerFs.fsproj" -- FAILED.` `Done building project "Dodger.csproj" -- FAILED.` `Project "DodgerFs.fsproj" (default targets):` `C:\Users\rskar\stack\dev\gamedev\FSTest\DodgerFs\DodgerFs.fsproj(42,3): error MSB4020: The value "" of the "Project" attribute in element &lt;Import&gt; is invalid. [C:\Users\rskar\stack\dev\gamedev\FSTest\DodgerFs\DodgerFs.fsproj]` `Done building project "DodgerFs.fsproj" -- FAILED.`
What surprises me is that you are getting an error in the F# project - did you create a new project for this test or did you update VS and open an older project? Try creating a basic C# Godot project first and creating a separate F# library and see if one of those fails.
My steps with the updated VS2017 was starting from scratch following the first tutorial I linked. I'll try your way to see if it works when I get home, thanks!
That's my tutorial :-) I read through it a couple of days ago and I didn't notice anything that would need to be updated. Let's see if creating the default project works and if you can create a simple F# library. One idea... did you create a .Net framework fsharp library or a .Net core one? If it was a core one that might explain the error. 
Weird, I'll reinstall Mono, but according to the beta I was using, MSBuild is required and Mono comes pre-bundled? https://godotengine.org/article/dev-snapshot-godot-3-1-beta-10
Should ' mean Fsharp Type Parameter inside of the Generic&lt;'System.Int32&gt;.NestedInGeneric ? 
Yes, I read that too, and Godot does come with a set of the Mono libs, but the path that your compiler complains about on my computer holds a path that points to a previous Mono installation, and that file does not exist in the Mono folder that comes bundled with Godot.
Reinstalling Mono didn't help. Maybe I have my path's setup incorrectly, I'll look into that tomorrow! Thanks for the help :D
Does it work with dotnet core? 
It is what I usually do
Can you point me some examples
Sure. [This one](https://github.com/bit-badger/PrayerTracker/tree/master/src/PrayerTracker.Data) is the data context for an app I recently open-sourced. It uses record types and works with all the entities as untracked, with functions to mark new or updated ones in the context. It also uses an "option converter" which translates possibly-null columns in the database into proper `Option&lt;'T&gt;` types. (I wrote [that as well](https://github.com/bit-badger/FSharp.EFCore.OptionConverter); it's in a separate package.) The `DataAccess.fs` file has most of the query logic, and the handlers in the main project do most of the marking of entities once they've been updated. I also have [another project](https://github.com/bit-badger/myPrayerJournal/tree/master/src/api/MyPrayerJournal.Api) that uses F# to provide a backend API. It's smaller and more self-contained. *(The migrations/model stuff followed* [*this example*](https://github.com/odytrice/PluralsightDownloads) *- there are C# and F# examples there.)*
Here is the issue. So some Databases works on .NEt Standard. [https://github.com/fsprojects/SQLProvider/issues/575](https://github.com/fsprojects/SQLProvider/issues/575)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/microsoft] [Mozilla is looking to contract with someone to help bring Rust to UWP and HoloLens, meanwhile we still have no official UWP support for F#](https://www.reddit.com/r/microsoft/comments/aybfx4/mozilla_is_looking_to_contract_with_someone_to/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Can someone ELI5 why people care about F#? I'm not trying to be an ass, I'm genuinely curious what differentiates it from C#, or Javascript / Typescript? As far as I can tell it's a functional language ... which I'm not entirely sure what that means beyond allowing you to pass functions around instead of just classes/objects. I'm honestly not sure why that would be better than something object oriented like C#? I'm also not quite sure how that's different from Javascript / Typescript since I believe they operate that way? i.e. Why do you want to use a "functional" programming paradigm in the first place, and to follow up, why wouldn't Javascript / Typescript work for that? 
UWP is an awkward platform at the moment, but I wouldn't describe it as dead. As a software dev I'm super interested in a lot of the UI features / controls available as part of UWP, as well as some of their new APIs (like a straightforward API to turn the bluetooth radio on and off!). But at present I cannot write any of my software for the UWP, because our company still has ~40% of their machines running Windows 7. Until the point where every single one of our machines is running Windows 10, I cannot write UWP apps. 
Yes, but you will need to do a bit of configuration. See here [https://github.com/fsprojects/SQLProvider/tree/master/tests/SqlProvider.Core.Tests](https://github.com/fsprojects/SQLProvider/tree/master/tests/SqlProvider.Core.Tests) &amp;#x200B; In particular, you'll have to compile using the .NET Framework or Mono version of the F# compiler (but they will still output a .NET Core assembly). This means pointing to fsc.exe in your PropertyGroup node in the fsproj via &amp;#x200B; \`\`\`&lt;PropertyGroup&gt; &lt;RootNamespace&gt;fs\_playground&lt;/RootNamespace&gt; &lt;OutputType&gt;Exe&lt;/OutputType&gt; &lt;TargetFramework&gt;netcoreapp2.1&lt;/TargetFramework&gt; &lt;FscToolPath&gt;C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Professional\\Common7\\IDE\\CommonExtensions\\Microsoft\\FSharp&lt;/FscToolPath&gt; &lt;FscToolExe&gt;fsc.exe&lt;/FscToolExe&gt; &lt;/PropertyGroup&gt;\`\`\`
&gt; As far as I can tell it's a functional language…I'm not entirely sure what that means beyond allowing you to pass functions around instead of just classes/objects? Functional languages are much much more than this. I guess it would be like saying "object oriented languages are just structured programming languages with interface-directed dispatch." The zen of a functional language is being able to manipulate the structure of your code as if it were data, so you can align your control flow with your domain logic. A well written functional program should read like a specification of the solution, and a specification of that specification, and so on, until the implementations are one line definitions.
I just use SqlDbReader with JSON queries in Sql Server and a JSON parsing library.
 👍 👍 👍 Thanks!
You should not goose a tool for performance. You **as an Engineer** should determine whether a tool is the right tool for the job. That decision should be based on several factors and not just simply ‘performance’. If performance is all you care, then you would be choosing to hand-code in Assembly, but you would never get anything done. 
c# is the lowest possible language that is also easy to use. thats why i went for c#
If you haven’t done Functional Programming before, you will run into so many “I-am-stuck” moments, and will end up implementing things in imperative style. However, you still get the benefit of being able to brainstorm and model the components of your idea 💡 much more quickly. So it will be like eXtreme Programming step-1 where you just write down whatever comes to mind to understand the problem first. Then, you can sit down and analyze what you have accomplished and refactor your design. * Having really good tools like F# Interactive allow you to test your ideas fairly quickly and easily. * Discriminated Unions allow you to model your domain faster than C#, and revise on it with safety. * Being able to pipe through stuff makes it easy to read/understand your “pipeline”. If those advantages above sound interesting, try it out. Start with this reading list in order. * https://fsharpforfunandprofit.com/posts/dependency-injection-1/ * Domain Driven Design with F# https://fsharpforfunandprofit.com/ddd/ * Organizing Modules in a Project before you start. https://fsharpforfunandprofit.com/posts/recipe-part3/ * Railway-Oriented Programming (i.e., Monadic Continuation Passing style) https://fsharpforfunandprofit.com/rop/ The *last bit* Railway-Oriented Programming (i.e., Monadic Continuation Passing style) is optional in early stages of learning F# capabilities. **Do NOT adopt it early** because you WILL be completely wasting your time trying to really understand what it is and how to implement even the most basic feature. However, it becomes quite nice when you are building a Validation pipeline of your models. 
Both languages are on the .net platform and can access one another. In broad terms you're choosing .Net more than the language. F# will help you model domains more succinctly (faster), write code that is more robust (less time hunting bugs), and give you system guarantees that you can't get with C# (more correct). Less code, faster development, better expression. If your game dev includes online services, distributed programming, or complex models then you'll get benefits from F#. If you're hiring people who are mostly C# developers, that will likely be your deciding factor.
Should you? No, but you will become a better and more productive programmer if you do. &gt; full C# web dev stack That's a misnomer, unless you count TS as C#. F# compiles not only to IL, but also to JS and therefor you can stay in the same language on the backend and in the browser.
So is Go a purely functional language? I notice a lot of passing of methods within it, does that make it functional?
F# has been working on UWP for years, via Fable and ReactNative - MS supported [ReactNative](https://github.com/microsoft/react-native-windows).
This thread is just complaining for the sake of complaining. F# works on UWP.
This is just whinging. It works well. There is very little interest in making it official. If it's important to you to make it official I can tell you exactly what to do.
monads eclipse is the worst thing that has happened to programming lately. Fortunately, current trends are such that everyone goes from monads to effects
"Mozilla is looking to contract with someone to help bring Rust to UWP". Meanwhile F# already works.
That's literally the exact opposite of what I said makes a functional language functional. 🤦🏼‍♀️
F# and unity is not a good match at the moment, but with that said. You can always create helper functions / domain models in a F# library and use it from Unity. You will ofc not get the integrated development experience as with C# as you will need to recompile the F# library outside of Unity. For domain modeling I think F# outshines C# but I wouldn't go the F# library route until I thought long and hard about why. For web dev I think F# .net on server with F# Fable on client is amaaazing! Both for performance and the development experience. Giraffe (Saturn) outperforms MVC and after working with Fable React and the Elmish model, I would cry if I had to do another Angular project. 
what about react or razor?(if you had such experience)
MS SQL Server, SSDT projects, FSharp.Data.SqlClient, CBOR. (Running on ASPNetCore.) Works very well. Took us a lot of flailing around to come to this combination.
Ah sorry I was reading the guy you responded to, its a hard concept to understand.
Im a senior C# developer with a strong oop background. Felt in love love with F# a month ago and upon reaching the railway concept and trying to implement it as standard early on as it looked very solid and sensefull I was exactly at that point realizing that this is a completely new paradigma to adapt to with the neat railway oriented style not actually being understood by a it seems even small amount. 
F# compiles to JS with Fable C# compiles to JS with Bridge.Net Neither of them are built-in framework features
Well, there’s your answer then, goodbye. People gave some good well-thought out answers and I hope that others read them and it helps them make an informed decision. 
F# will probably never be a good match for modern game engines, since it promotes best practices that these engines don't adhere to (e. g. Unity, Unreal, Godot, Cry, Lumberyard, Atomic Game Engine... so probably all engines like these). These engines declare objects in the editor, create them in the backend and then allow you to modify them in the scripting layer. Therefore you usually aren't allowed to access engine functionality in the constructor. Afterwards you are expected to update each object in place, so the whole architecture is built around mutable state wrapped in objects, so it shouldn't come as a surprise that a functional first language isn't the best match. That being said once you don't try to write the whole game code in the architecture of the engine you can make good use of F#'s strengths. Usually that means writing the game code in F# and then sending it to C# to have Unity update the state of the display. 
&gt;create them in the backend and then allow you to modify them in the scripting layer But isn't it good fits to MVU pattern?
- You can’t create (as far as I know and tried) create a F# only UWP App - You can’t even reference an F# project and do a release build (.net native) without modification of some vs configuration files (undocumented) I don’t consider this supported. If it were just like it is with WPF I would be more than ok with it.
The first is not important. Even on Xamarin I would highly recommend having C# platform project files. You hardly need to edit these C# projects. The second, while clunky, is a one-off 5mins task by whoever on the team is managing releases. "Consider this supported." You mean what happens if things go wrong? This is community supported, with the coreRT team helping where they can. So far no one has added any F# issues to the ones that I and my colleagues have documented. The problem is a lot of people are trying to be backseat drivers in the most lazy and casual way. Just complaining without helping and without even any indication that they would use the features that they are asking for. All the people outside Microsoft complaining, they did not chip in one bit when we asked for help to work on the issue, and we did it ourselves and people are still complaining and still not showing any sign that they are willing to do any work. Ridiculous.
I never intended to offend anyone or anyones work. It seems like I offended you in some way.. The problem for me currently is: - You have to do your UI stuff (UWP specific APIs) in C# and call your F# .net standard library from C#. This is limiting because you have to expose a C# friendly less functional programming minded API to the UI project. It’s still doable (I have a project like this) but not optimal. So basically you cant write UWP apps in F# but you can reference your libs. Or am I missing something ? For me it looks like the community did a lot to support F# on .net native / corert https://github.com/dotnet/corert/issues/6055 
\&gt; but that requires a whole new row for doing that Does it? How did it get into "x" in the first place? Do the deconstruction there.
You could feasibly create a "half elmish" framework (like Elmish.WPF) which would still allow a functional style elmish workflow of the model white still using Unity based "views" (where the views are the GameObjects). 
Check this out: https://stackoverflow.com/questions/54713827/using-bind-with-an-async-function
 let loginThenScrape () = async { let! loginResult = login() let! scrapeResult = loginResult|&gt; Result.bind scrape return scrapeResult } That is all I can think of from the top of my head without writing a lot of infrastructure code for handling `Async&lt;Result&lt;‘a&gt;&gt;` with a custom Computation Expression Builder. If `Result.bind` isn’t defined in `FSharp.Core`, it should be simple enough to implement it.
Would be nice to be included in the standard lib tbh.
Very much agreed 
 let! scrapeResult = loginResult|&gt; Result.bind scrape doesn't work since scrape returns `Async&lt;Result&lt;_,_&gt;&gt;` instead of `Result&lt;_,_&gt;` so for it to work you need to do let! scrapeResult = loginResult|&gt; Result.bind (fun _ -&gt; scrape |&gt; Async.RunSynchronously)
Any of the MV* architectures should work, just as long as you separate the F# code from the Unity related display code. To be fair it's not like F# was horribly bad for Unity, it's just occasionally a little more awkward than C#, whereas using the right approach it can be a lot less awkward and rather more elegant than C#. 
https://github.com/haf/YoLo - found your bind, you can pull it in via paket and it has a beautiful license. Or get your fix with a computation expression - https://github.com/havarnov/asyncresult 
Ridiculous is paying MSDN subscriptions and expected to so this stuff for free.
Yep, forgot about that one.
lets be realistic most engineers can't determine the right tool for the job; too much bias
as below dapper and sql is a good choice, but type providers do function on dotnet core, give them another go. its the lowest resistance option i.e. easiest :-) for me the harder part was not getting it to talk (read write) to sql db but what the hell to do with the result it returns, record types are the key here don't struggle to start parsing untyped tuples of tuples, look at record types fist and get the sql result returned as a record, and should be plain sailing. good luck &amp;#x200B;
\- F# has units (C# has libraries for them) \- F# has computational expressions (you don't need them very much) \- F# has good pattern matching with active patterns (modern C# has very flexible "case" expression with pattern matching too) \- F# job is good payed (here is all very individual) &amp;#x200B; Actually you have not such reasons. But if you have interests... :) Btw, IMHO also vb# is very cool - super human readable. I like all 3 .NET languages :)
This crops up all the time in my code base, and we use the `asyncResult` computation expression from https://github.com/cmeeren/Cvdm.ErrorHandling all over the place.
You don't have to put up with any situation. You pay for a service and you get it. There is a product out there ("F# UWP support with an official stamp of approval"), which does not exist, and which you don't care about much. So why make a big fuss about it?
Once you start using F# regularly you might ask yourself "Is there any reason I should use C# instead of F#". If you care about using multiple cores F# makes this much easier. If you care about having less bugs or run-time exceptions F# can also make this easier. If you care about spending less time writing code F# can make this better. Idiomatic F# is somewhat slower than C#, but you can write F# that keeps up with C# and that style may fit your requirements. You can always adopt F# style as needed to write something quickly, correctly, and with parallelism. 
`Result.bind` definitely exists already
\&gt; Or am I missing something? Yes you are. F# is perfectly able to reference UWP specific APIs. So 99.9% of your code can be F# (dot net standard library), and the remaining 0.01% is a C# library referencing the F# one that you don't even need to touch. This is actually a very standard project structure across UWP/WPF/Xamarin. \&gt; For me it looks like the community did a lot to support F# on .net native / corert Yes. I am de facto in charge of this community effort because no one else is helping. For some reason everyone wants to complain and no one wants to help. Not that it's really needed because the work is basically done. But they are complaining about things that (lack of an official Microsoft stamp) that are both unimportant and easily fixable if they were willing to help (by continuing the testing effort).
`client.UseDefaultCredentials = true` is valid it doesn't actually do anything. You probably got a warning like ` The result of this expression has type 'bool' and is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |&gt; ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.` 
&gt; Yes you are. F# is perfectly able to reference UWP specific APIs. So 99.9% of your code can be F# (dot net standard library), and the remaining 0.01% is a C# library referencing the F# one that you don't even need to touch. This is actually a very standard project structure across UWP/WPF/Xamarin. Wow, did not know that. Can you explain how ? (cant find any resources about it) Would be awesome! 
I love UWP, not sure to whom you are answering to. And since my MSDN subscription only offers UWP support for C#, VB, JavaScript/PWAs, C++, those are the languages I care about. It would be nice to sell customers on F#, but not if Microsoft themselves do not believe enough in F# to make it part of the above list.
Sorry my mistake, misread one of your posts.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/dotnet] [Alternative to Jupyter\/IFsharp](https://www.reddit.com/r/dotnet/comments/b0rxfq/alternative_to_jupyterifsharp/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Actually I tried it and it is trickier than I thought and seems to depend on this issue: [https://github.com/dotnet/corefx/issues/17071](https://github.com/dotnet/corefx/issues/17071) I assumed it would work the same way as Xamarin class libraries, but that's not the case. I will update the F# thread with this info.
I upvoted your comment in the core rt issue. Let me know if I can support you some how. I’d prefer the nuget approach btw..
I upvoted your comment in the core rt issue. Let me know if I can support you some how. I’d prefer the nuget approach btw..
Wait. Can the F# compiler produce `Expression`s from F# code? O_o
In some cases, it will translate `fun x -&gt; blah-de-blah` into an `Expression` implicitly. If it doesn't, there's a technique you can use that involves quotations (code between `&lt;@ @&gt;` pairs), which I used in the `OptionConverter` I referenced in my other reply. You can [take a look at its code](https://github.com/bit-badger/FSharp.EFCore.OptionConverter/blob/master/src/FSharp.EFCore.OptionConverter/Library.fs) if you want to see an example. *(I'm not an expert on it; I wrote that based on an example Tomas Petricek posted, and it's still my only experience with quotations in F#.)*
That's cool. I would worry though about it accidentally falling back to using `Func` and `Action`, causing the whole thing table to be read into memory, and then filtered/projected/joined there.
Are you using it with Mono or with dotnet core?
I know some folks that could get you a pretty affordable deal for Python binaries
When using EFCore, I make sure to set it to throw an exception if anything tries to evaluate client side. You'll catch that problem in dev/testing that way. See [this](https://docs.microsoft.com/en-us/ef/core/querying/client-eval#optional-behavior-throw-an-exception-for-client-evaluation). You can also set that in your startup code. E.g.: services.AddDbContextPool&lt;AppDbContext&gt;(fun options -&gt; options..ConfigureWarnings(fun warnings -&gt; warnings.Throw(RelationalEventId.QueryClientEvaluationWarning) |&gt; ignore) |&gt; ignore ) |&gt; ignore
*Wooo* It's your **8th Cakeday** mongreldog! ^(hug)
f# is for actually programming stuff and getting things done in the tradition of sml and ocaml. haskell is for playing around. i would recommend not judging f# based upon its lack of typeclasses alone. it has plenty of festures that haskell does not have.
I love it already.
Perhaps try http://ionide.io/FsInteractiveService/ that gives a nice blend of interactivity and less external dependency. Out of interest, what’s it about the Python dependency the you want to avoid?
Yes I'm exploring that solution writing a front end to use the service They don't want to install python and jupyter only for the notebooks and they would prefer dotnet solution 
You could also try one of the online REPLs e.g. the visualisation samples on [https://fable.io/repl/](https://fable.io/repl/) or longer term there's an F# to WebAssembly approach here [https://fsbolero.io/docs/](https://fsbolero.io/docs/)
VS Code w/ Ionide because I'm constantly switching between OS X and Linux.
I jump between vscode (on linux) with the Ionide plugin and visual studio for mac. I tend to use visual studio for mac if I'm building a small utility desktop app since it has a "windows form" (which is just gtk) editor. &amp;#x200B; They both have the ability to highlight code and push that code to the repl. That's a really important feature for me because the "cold boot" time of the jvm and the clr ruins my ability to think through some problems because I rely on a tight quick feedback loop when I code. 
Some large projects don’t open well in `Ionide` extension for VS Code. I switch back-and-forth between Ionide and F# Language Server extension.
Jetbrains Rider
VS2017.
Visual Studio. Works well with existing .NET ecosystem and has everything I need.
Jetbrains Rider is definitely your best bet if you're okay with paying for it 
Back when I wrote F#, I did it in emacs with no syntax highlighting - fun times!
Windows: VS or VS Code Linux: VS Code or Rider I don't know why.
I'm pretty happy with VS Code + Ionide. I don't work on any larger F# projects, though. They're mostly just little side things for fun.
Emacs :)
vscode + ionide has better intellisense. Visual studio has better gui tools (tests, managing nuget packages if you use it, managing projects) if you are into that. Both still cannot see the definition of libraries though. Which is a shame. You have a library function that takes a discriminated union but you can't see the definition of the type without typing the type and hovering on it.
VSCode + Ionide (for a hobby project, nothing serious) on Linux with .net core. It's great when it works, but unfortunately it does not always work. This is really the main factor that would prevent me from using F# in some production project in the future. The tooling is not reliable (although, I have to admit I haven't tried Rider in a while, I might give it a shot). 
Emacs with Fsharp-mode (Company-Mode, Flycheck), simple fast; completion and syntax checking, works wonderfully. 
Notepad, can't beat it. Simple and fast. I use it for everything.
Interesting. I'm using Rider as my main editor and the C# experience is great but haven't yet tried F#.
In VS, if you hover over the API you will see underlined types in the tooltip. If you click one, it will Go to Definition on that.
does it display any inferred types?
*Eyy, another year!* It's your **8th Cakeday** ssboisen! ^(hug)
&gt; Together with C#, F# will be incorporating nullability as a concept for .NET reference types. From the F# perspective, this fits with the default non-nullness of other F# types. But compatibility with existing code makes designing this a wild ride! In this talk, we'll briefly explain what nullability means for F#, some existing mitigations for null in the language, and how we must consider compatibility with everything in mind. This deep dive into language design should give you an idea about what it is like designing a nontrivial feature that improves existing code while remaining compatible with it.
rly nice username.
Because it doesn't solve a specific problem that's bothering a significant number of C# developers. You can't just be better, you have to be better in a way that people care about today.
I don't think there's ever going to be a moment when suddenly everyone is using F#. I have noticed more and more awareness of it in the past few years. More and more people I know have started using it, and that's how it'll happen.
Also, if you look at the major C# language features added in since roughly 2010 they're all half-baked implementations of core F# features. For top-line .net language evolution: every year has been FSharp year. The entire platform is moving over to F#, but only one language gives you built in compiler guarantees where the other will give you sugar (and must, based on it's compiler and fundamental spec). The .Net Core change has hurt the toolchain too much, IMO, so it's hurt adaptation, but hopefully that dark chapter is soon behind us for good...
&gt; The entire platform is moving over towards F# that’s not really true. the platform is moving towards having f#-like features, but that isn’t the same as moving towards f#. i mean, f# is rarely even mentioned in .net announcements, and there are plenty of ecosystem features that don’t work with f#.
As someone who loves the language and uses it for some hobby projects, I don't think F# will have its year, or that it will get much more popular in the future than it is now (although I hope I'm wrong). A big push from a major company would be required for something like that (for better tooling, documentation, support, tutorials, evangelists pushing the language on conferences all around the world, more F# libraries with proper APIs, ...). And for me it doesn't seem that MS is interested in doing so, which is understandable, they have C# which is a great language.
Unpopular opinion: when average IQ rises. Lets be honest, for average joe - FSharp is just too much to wrap their mind around. I’ve worked with many senior developers who have hard time with recursion. 
&gt; the platform is moving towards having f#-like features, but that isn’t the same as moving towards f# Re-read that a few times ;) I didn't say the ecosystem, or developers, are moving towards F#. I said the entire platform is moving over *towards* a degenerate version of F#. "the platform is moving towards having f#-like features" is a restatement of the same. &gt; f# is rarely even mentioned in .net announcements I read F# code examples across the entire MSDN, and read ample announcements about new and upcoming F# features... Is there less marketing churn? Hell yeah. That's a positive for data science and big data types. But what about the content of those announcements? When the major "innovation" and improvement to C# already exist in F# in more mature forms, what do we expect? While one side is making announcements, the other side spec'ed it all out from the bottom up and put it in prod over a decade ago, based on a mature language that nailed these issues to the floor almost three decades ago... Is the F# team supposed to announce that "Simpsons already did that" every time there's a new blog post? &gt;and there are plenty of ecosystem features that don’t work with f#. I addresed the toolchain issues in my post already. And if you've been following this you'll also know why VS 2019 hitting RC within the next few weeks is a big deal. Also those features are still operational if you stick to the .net ecosystem, the .net core ecosystem is still striving for parity for on some below-the-hood issues.
F# already had support for ref structs? And what's their plan for nullable reference types? (Don't say Option&lt;T&gt;, we already know how that half-baked solution doesn't work.) Yes, F# has some interesting features. But C# is moving in a lot of directions and F# isn't keeping with all of the changes. In fact it can't in some areas because of fundamental design decisions made a long time ago. 
&gt; And what's their plan for nullable reference types? [From the top of this sub.](https://www.youtube.com/watch?v=BJGmkJEltC4)
It will never happen, because of Microsoft.
If Year of the F# is a year when F# will become mainstream (C#, Python, Java, JS etc) language then answer is never... and that’s the good thing. ~Our goal~ Goal of the people advocating F# and building its ecosystem should be making it viable enough for the open minded companies to choose it for interesting projects. Being mainstream is not a value - it just means it would be chosen by the software shops that cares about things like quickly hiring cheap replaceable developers and treating them as expandable Human Resources. 
Average IQ never rises since it's defined as 100. Besides, it has nothing to do with IQ but with time investment needed to learn F#. C# is just good enough for 90% of problems and it has several different "advantages" like being widely adopted, somewhat understood by most programmers and in high demand.
Discriminated Unions Immutability by default and first class immutable data structures built into the language Exhaustive pattern matching Record types and a "with" syntax for fast immutable copies with changes Type Providers Computation Expressions There's other great features as well, but these are the main ones in my opinion that make F# much more flexible, safe, and pleasant to work with than C#. I've done primarily C# the past 5 years and it's a great language and ecosystem, but after using F# the past few months its painful how OO languages haven't taken in more features from the ML family (as F# and Scala have both shown the paradigms mesh well)
It’s also generational. A lot of the people who are in industry now grew up with a specific paradigm and learned languages that, for the most part, aren’t as widely used anymore. For example, as a physicist, I learned Python, Mathematica/Matlab, and R in school, whereas my mentors learned stuff like C, BASIC, and FORTRAN. While the paradigms are valid in any language, you’re still gonna want to stick to what you know, especially if you’re already rooted and have no need to learn anything new. F# has seen adoption in some curricula, so I’m sure in time it will be at the level of Mathematica at least in terms of popularity. C# is ubiquitous and will probably always be the mainstay of the .NET platform, but I would fully expect more mixed projects to appear where people realize the strengths of each of build on them. Also the year of F# will be when FSI works on .NET Core.
Fortunately, there's no reason to wait until F# reaches Python/Javascript levels of popularity :) You can start writing cool stuff with it right now! 
Find a good company that lets you work with F# full-time and every year will be an F# year for you! :) This comes from first hand experience. 
The [year of F# was 2010](https://trends.google.com/trends/explore?date=all&amp;q=F%23). The language has been in decline for several years now. 
&gt; Average IQ never rises since it's defined as 100 ROTFL. :-) 
&gt; I’ve worked with many senior developers who have hard time with recursion. Are they familiar with recurrence relations in mathematics? How do they code them up? 
&gt; As someone who loves the language and uses it for some hobby projects, I don't think F# will have its year, or that it will get much more popular in the future than it is now (although I hope I'm wrong). Agree. &gt; A big push from a major company would be required for something like that Disagree. An easy-to-use freely-available web-based language (e.g. in the form of a programmable wiki) is a low-hanging killer app in this context. That's what I'm working on now... 
I am sure they passed some test in college that required it. :]
Why are you a moderator of this community?
Well, you weren't wrong about the unpopular opinion it seems. Hmm. Idk. I think most programmers could benefit from programming in a functional fashion. And where better to do that than in a functional language like f#? But again, mediocre programmers don't care; and most programmers are mediocre. So that's why 90% are still using java/c# everyday writing for (int i=0; i&lt;list.length; i++) and then appending element by element imperatively like it 1960. It's insanity really. If you want to watch a good video, watch: we're doing it all wrong by Paul Philips.
Can be hard to find, but definitely a recommended route :)
You might want to have a look at https://fsharpforfunandprofit.com/posts/elevated-world-5/#treating-two-worlds-as-one. The whole series, actually, is really worthwhile. 
What sort of specific problem? Genuinely curious.
Don't know. C# is far from perfect; but off hand I can't think of anything that's bad enough to make me want to try a different language. And again, that's the real adoption problem for F#.
I see what you mean, now. It sounded like there were some specific grievances, but you're saying people are generally content with C#. Are you interested in F# at all? I'm just wondering why it's worth hanging out in this sub if there's nothing you find particularly compelling about it.
Generics, LINQ, async-await, if they didn't have these and an another language did there would be an opening as each solved a pretty serious problem. I don't know if "content" is the right word, as many are still clamoring for new features. But I'm definitely not seeing the frustration that preceded the VB6=&gt;C# shift or the Java=&gt;(Clojure/Groovy/Kotlin). &gt; Are you interested in F# at all? On a personal level, no. When I saw how ham-fisted their handling of nullable references I decided it wasn't the language of my hopes and dreams. And having to explicitly cast from X to Option&lt;X&gt; pretty much killed my interest in it. But professionally I still need to keep appraised of it. Both as a reporter and as an open source library maintainer. In fact, just recently I did a major overhaul of my ORM (Tortuga Chain) to make it more F# friendly. 
Well, I'm sorry to hear that you're obligated to be here. Hopefully you'll find someone else to cover F#. In the meantime, you might consider reporting on the \[new developments on nullable reference types\]([https://www.youtube.com/watch?v=BJGmkJEltC4](https://www.youtube.com/watch?v=BJGmkJEltC4)). I'd be thrilled to read about it on InfoQ.
Over the last few years, with each "innovative" C# language addition, C# is looking more and more like a poor man's F#.
Yes, I am looking forward to seeing that. And though it is an obligation, it isn't an onerous one. I wouldn't hang around here if I didn't think F# had something to offer.
That's not unintentional. C# isn't meant to be innovative; most of what you see in it were prototyped elsewhere. Even async/await started as an obscure robotic's library called CCR. Designed to simulate Erlang style messages, it was hacked into the language using `yield return`, w which simulates `await`. 
Seems the link to the source at 14:00 is broken. Crazy statistics 
https://youtu.be/MGLxyyTF3OM?t=847 350k C# code developed over 5 years by 8 people was translated into 30k F# code in less than one year by (at most) 3 people. 3k null checks in the C# project and 15 in the F# one. You'd think the software managers would notice things like that but alas.
Might be worth looking at \`Seq.concat\`, \`Seq.collect\`, \`Seq.filter\` and \`Seq.choose\`. (You might not need all of these but looking at them might get you started.)
Reply again here if after looking at these you are still stuck. ;-)
If written in an idiomatic way it is actually a lot easier to understand than typical procedural programming. Good example is code written in Elm which is really easy to understand.
Well I don't know what that is and I can do F# :-)
&gt; Also the year of F# will be when FSI works on .NET Core. It doesn't?!
&gt; Because it doesn't solve a specific problem that's bothering a significant number of C# developers. I agree completely but there are huge problems unrelated to C# that F# could be attacking but instead they're still smoothing over C#↔F# interop. 
&gt; the new developments on nullable reference types would make an interesting story to report on. I wish they aspired to do more than a fifth variation on legacy interop. 
Nay. https://github.com/Microsoft/visualfsharp/issues/2407
OMG, I could cry. :-(
Any in particular of interest to you?
It sounds like you’re using a jagged array, so Seq.map to Seq.filter over each nested array would be my guess. You could try representing your game board as an array2D as well (‘a[,]) which might make it conceptually simpler to operate on.
&gt; There will be some trivial extra steps involved in getting actual indices `Seq.mapi` and `Seq.iteri` will give you the indices while traversing the game board.
&gt; There will be some trivial extra steps involved in getting actual indices `Seq.mapi` and `Seq.iteri` can help here while iterating over the board.
Rider is a lot more enjoyable than VS2017 for F# (ans also for C# in a certain measure). This being said I haven’t been able to use fsi from Rider and it is very annoying. 
&gt; handling of nullable references What are you referring to here? There is no concept of a nullable reference type in F# today. There is the notion of _null as a proper value_ for F#-declared reference types, but this is not the same thing.
Can you put a null into a string variable? Yes. Can you put a null into an Option&lt;string&gt; variable? Yes. Is a null in an Option&lt;string&gt; the same thing as a None in a Option&lt;string&gt;? No, so you need to check for both at API boundries. Does lying about F# not having nullable reference types hurt it's reputation in the community? Not sure, but it certainly makes me doubt the other claims about it's benefits. 
There is no distinguishing nullability for reference types in F# today, full stop. I honestly have no idea what you're talking about here.
Start here, &gt; You must be careful with such code to keep the null values encapsulated. In a library intended only for F#, you do not have to check for null values in every function. **If you are writing a library for interoperation with other .NET languages, you might have to add checks for `null` input parameters and throw an `ArgumentNullException`**, just as you do in C# or Visual Basic code. https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/values/null-values
This is not nullable reference types. As I said, there is no ability to distinguish between nullable and non-nullable reference types today. So what are you referring to when you say this? &gt; Does lying about F# not having nullable reference types hurt it's reputation in the community? The entire point of the feature is so that we can distinguish nullable reference types from reference types, so situations like what the docs mention about handling `null` inputs from non-F# components are easier. While we're at it, this point also makes no sense: &gt; And having to explicitly cast from X to Option&lt;X&gt; pretty much killed my interest in it Are you sure you're referring to F# here?
Yeah, loads. I've been teaching F# to people in industry for 12 years now and one of the main things that sticks out is that lots of the people learning F# are not software developers and they don't know C# or .NET. In fact, many of them actively don't want to know C# or .NET because they regard that as "proper" software development and they don't want to be considered as software developers. These people are traders, actuaries and so on. When they do "programming" traditionally it is usually in the form of Excel macros and maybe some Mathematica or MATLAB. Sometimes they want to put little scripts into production and, when they do, traditional tool stacks and company processes mean it takes months instead of minutes to achieve. Often they want to write disposable scripts to help them massage data or make sense of some detail. F# is completely traditional in this sense: massive Framework, massive IDE and slow startup times combined with library, DLL, Nuget and DNC vs DNF woes. This is exactly the kind of crap these people don't want to deal with. I think what they need is a lean and simple language with a minimal IDE running in the browser being compiled to Javascript on-the-fly and executed client side. Code hosted in the Cloud, e.g. exposed as a programmable wiki with page history replacing a VCS. Simple working Intellisense (F# in VS2019 is still really buggy and these are nasty concurrency bugs that may never get fixed). Simplicity was a major benefit of F# and it would have made it easy to retarget F# from .NET to Javascript and make a killer language for the web era but instead they've piled on .NET-specific complexity like `byref`, `None` vs `ValueNone` and now `string?`. I'm a "proper" dev and even I would much rather have not had `Span&lt;T&gt;` in favor of a simple pair of functions to convert any value of any type to and from JSON. 
That makes a lot of sense. And correct me if I'm wrong, but it sounds like the core problem is that F#'s leadership don't really have a vision as to the language's purpose so they are solely focused on playing catchup with the runtime changes. *** &gt; instead they've piled on .NET-specific complexity like byref, None vs ValueNone and now string?. Fundamentally I think the problem may be F# needs more magic. Think VB instead of C#. For example, why are Option&lt;T&gt;, T?, and Nullable&lt;T&gt; all separate types? Why didn't the compiler hide the implementation details from me and make everything look like Option&lt;T&gt; from day one? 
This is the true answer.
Most programmers probably don't know what that is.
I don't have a source that would confirm this, but in several places F# tries to keep you from doing things that are considered bad, so I assume that this is one of those cases. The protected modifier is only needed to create a class interface that is different for external code and child classes, so its effect is that inheriting from a class gives you a different interface than adding an instance of the class as a member. And the only thing you would need something like that for would be code inheritance, which is the whole issue behind the "composition over inheritance" war. There's no problem with a class inheriting an interface from a base class or interface and there's nothing wrong with a class using encapsulated behavior of a base class, but accessing the encapsulated members of a base class is dangerous.
Protected members are used exclusively in OO design patterns, and forces the client to inherit the class and override the behavior. Declaring it is more verbose and causes tighter coupling through the inheritance hierarchy created. The same behavior can be accomplished more succinctly by passing functions to a class, which is the preferred way to implement the pattern in a functional language like F#. The lack of protected member support encourages the functional approach here over the OO approach. 
If you're looking for a production-grade generic project template, check out [MiniScaffold](https://github.com/TheAngryByrd/MiniScaffold)
I am currently using the build in Web MVC template. Is conventional to separate the business logic in a separate library project and then require it as a dependency to a web api or mvc project?
It does, just in preview. Lots of old assumptions in the old FSI to unravel.
You could do that. I typically split off the web-server specific stuff into a separate console project only because it allows the business logic &amp; library code to be shared by other potential executables (like a headless command-line interface for example). If you think of your project in terms of the ports &amp; adapters (aka the hexagonal) architecture, the "Web" interface is really just a way of accessing your domain services over http. 
Or you can just use public and call it a day
&gt; so they are solely focused on playing catchup with the runtime changes If one ignores everything else, such as multiple features every release that have nothing to do with interop or new .NET features to account for, then it could be seen that way.
yeah it is going to be a simple bookkeeping application for personal finance. 
&gt; multiple features every release that have nothing to do with interop or new .NET features What features? 
I can't speak for websharper, but at least the Giraffe v. Saturn question is about low-level vs. high-level abstractions. Giraffe gives you more control and is about directly setting up routes atop ASP.NET Core. Saturn uses Giraffe and builds higher-level abstractions over the top of it, trading flexibility for more "in the box" behaviors.
How would you redesign the DBCommand class and friends where the internals were injected?
That does sound like the more likely outcome. 
The one project would probably do fine. If you're looking for a web framework that's more in line with other MVC frameworks you may have worked with, Saturn would be worth a look. I the author of that project has invested a lot of time in making the dev experience as smooth and fully-featured as possible. If you're looking to do a quick &amp; dirty http/json api, then suave or giraffe are lower-level options that allow you to devise your own "framework". WebSharper is more of an all-in-one server/client solution that's probably more closely tied to the .net ecosystem. 
The Wikipedia list here is up to date: https://en.wikipedia.org/wiki/F_Sharp_(programming_language)#Language_evolution And F# 4.6 has anonymous records, which isn't a .NET interop feature. F# 5.0 also has multiple candidate features that have nothing to do with .NET interop, such as applicative computation expressions, `nameof`, extensions satisfying trait constraints, implicit yields in array/list/seq expressions, etc. Therer's also more, but the ones I mentioned have actual PRs out right now. Nullability is a huge feature there, but it's not the only thing coming along.
Thanks. For 4.5 that list says: * Versioning alignment of binary, package, and language * Support for 'Span&lt;T&gt;' and related types * Ability to produce 'byref' returns * The 'voidptr' type * The 'inref&lt;'T&gt;' and 'outref&lt;'T&gt;' types to represent readonly and write-only 'byref's * 'IsByRefLike' structs * 'IsReadOnly' structs * Extension method support for 'byref&lt;'T&gt;'/'inref&lt;'T&gt;'/'outref&lt;'T&gt;' * Relaxed upcast with 'yield' in F# seq/list/array expressions * Enumeration cases emitted as public * ... 
&gt; And correct me if I'm wrong, but it sounds like the core problem is that F#'s leadership don't really have a vision as to the language's purpose so they are solely focused on playing catchup with the runtime changes. The vision seems to be to add progressively more abstruse academic features to the language when it already has far too many. The compiler is now ~100x larger than it needed to be. What's missing is everything that goes around the language like availability, user experience, teaching aids and so on. Let me give you some concrete examples. Here are the new features in F# 4.5 from Wikipedia: * Versioning alignment of binary, package, and language * Support for 'Span&lt;T&gt;' and related types * Ability to produce 'byref' returns * The 'voidptr' type * The 'inref&lt;'T&gt;' and 'outref&lt;'T&gt;' types to represent readonly and write-only 'byref's * 'IsByRefLike' structs * 'IsReadOnly' structs * Extension method support for 'byref&lt;'T&gt;'/'inref&lt;'T&gt;'/'outref&lt;'T&gt;' * Relaxed upcast with 'yield' in F# seq/list/array expressions * Enumeration cases emitted as public * ... I would be aiming for features around web-based development: * Maximum accessibility in the form of being able to do serious software development in your browser without having to install anything at all. * Slickest possible user experience with a simple and reliable IDE in the browser coupled with a graphical REPL with color and integrated charting and graphing. * Teaching aids in the form of interactive on-line tutorials. 
FWIW, it does support `internal`, which equates to "assembly public". It won't keep other files from seeing it, but if you're distributing it as a library, other users won't be able to access those members. You can also specify assemblies that can access internal members, so you can still test them in a test project. There are other uses for that last case, but at that point, the advice above is correct - just make it `public`. :)
From a technical perspective, public works. Really the purpose of `protected` is documentation, it signals which methods are for general consumption and which are for infrastructure. Which is why I was surprised that it wasn't fully supported. 
If you really don't think casting from x to Option&lt;X&gt; makes sense then I don't know if you are referring to f#. How do you check a string (or any other nullable value) to make sure it is not null? let doSomethinWithStringValueFromWorld str = // check by throwing. Pretty shitty to do in F# IMO if str = null then failwith "null string" ... &amp;#x200B; let doSomethinWithStringValueFromWorld str = // do your own null check and return None, still sucks let strOpt = if str = null then None else Some str ... &amp;#x200B; let doSomethinWithStringValueFromWorld str = // Use builtin let strOpt = Option.ofObj str ... &amp;#x200B;
None of your examples are about casting from X to Option&lt;X&gt;, which is what I'm asking about.
And us smug lisp weenies and Haskell hippies will still look down on you F# coders who we consider BASIC bitches. See how that sounds? Fucking arrogant, right? Also, people don't want to take their own sweet time to learn the idiosyncrasies of a language just to avoid common pitfalls they have identified in a paradigm and are experts at it. The productivity gains aren't going to be immense anyway and are generally exaggerated. Plus, coding is a social activity since you've other people looking and your code and modifying it and adding stuff to it. You are there to solve problems, not revel in the perceived beauty of a language. 
What are the short comings of the existing F# templates that ship with dotnet core? I feel like if I make things to easy, it would be a detriment to figuring out how things work under the hood. 
Software developers are not in exclusive pool. So no it does not rise. And yes your other reasons is why i am stuck writing C++ most of my coding hours. I’d also argue that benefits of non-OOP are generally lost on people who can’t see how pointless it really is.
The productivity gains are immense, even with syntax alone, if you are just a “basic bitch”. No arrogance was intended with my original comment. Just an observation.
Was taught in CS1 in my high-school. We had to map out a directory and store it to text in readable form. Not sure what to tell you.
The dotnet templates are perfectly fine to use. I've only ever used the `console` and `classlib` templates, though. I can't really speak on the others. If you decide to use Saturn or Giraffe, I'd probably recommend using the template (at least as a reference.) If you're interested in adding Paket or Fake (they may not be included in some templates), then the Miniscaffold should be a good reference. There may also be paket and FAKE dotnet templates. I just haven't used them yet. 
Most mainstream programmers don't have a CS degree.
High school isn’t a degree. But yes, most people coding up C# business software have about as much passion for it as a plumber for plumbing.
? In order to work with the string and not have the program blow up I need to go from X (string) to Option&lt;X&gt; (Option&lt;string&gt;). I think you are getting too hung up on the word cast and missed the whole point.
There's a very big difference between using options at the boundaries of a system to avoid flowing nulls into a program and casting from one type to another, so no, there's no point being missed here.
Nah, this is typical, spreading FUD comment from JDH. It seems the only reason he’s mod of this subreddit is to spread his own agenda that has nothing to do with reality (i.e not with how F# is perceived by majority of its users, nor with how MSFT treats it, nor with what is important for the community). I can only hope that this is just lack of knowledge about current state of ecosystem, and not malice. However given the fact such comments are repeating despite the fact many users of this subreddit are regularly pointing out that he’s wrong, I’m afraid it’s the latter. 
I was an early adopter of F#, when it was just an alpha. So I know he's right.
There's fst and snd, which grab the first and second respectively - beyond that you'd have to deconstruct. Consequently, people often use 2-tuples only or make their own accessors for other elements.
So it'd be something like "Seq.reduce snd (+)"? 
I don't think what you're asking (if I'm understanding correctly) is possible. A functions parameter must always be the same type and tuples that have different elements types or number of elements are different types. In other words, you can't reduce over tuples of arbitrary length. The reason you can use reduce with Lists, or Arrays, or Seqs, etc. is because they are always the same type regardless of length. For example, `[1; 2; 3]` and `[1; 2; 3; 4; 5]` both have the type of `int list`. However, `(1, 2, 3)` has a type of `int * int * int` and `(1, 2, 3, 4, 5)` has a type of `int * int * int * int * int`. For a function to be able to reduce through a tuple like this, it would have to be able to take parameters of drastically different types, which is not allowed by the F# type system. &amp;nbsp; If instead, you're trying to get the sum of the second elements of a List of tuples, you'll have to use a fold. Your `Seq.reduce snd (+)` won't work because `snd` is a function that takes a single parameter and returns a value. For a function to work with reduce or fold, it must take two parameters, one for the running total and one for the current element. To achieve something like the sum of the second elements of this list: `[(1, 2); (3, 4); (4, 5)]`, you can implement a function like this let tupleSndSum = Seq.fold (fun acc x -&gt; acc + snd x) 0 and then use it printfn "%A" &lt;| tupleSndSum [(1, 2); (3, 4); (4, 5)] getting the expected result of 11 (2 + 4 + 5) It can be further simplified to let tupleSndSum = Seq.sumBy snd &amp;nbsp; I hope I've answered some of your questions. If not, it may be helpful for you to explain what problem you're trying to solve. 
A tuple is not a sequence.
Is there any systematic study on this? I highly doubt you'd get substantial gains. Else, there would've been a massive migration. And if it is difficult to actually code in it, maybe it is fundamentally flawed as a language. I'm trying to solve problems, not solve the problems a language has. Plus, the joke was that there'll be language users who will inevitably still look at languages like F# and say, 'meh, I'm not going to use that. Only low IQ people use need that'. This has been going on for ever. Some of the smartest people I've met can't code for shit. Heck, Larry Page and Brin were apparently horrible at coding (they certainly have higher IQs than most people and the trend is not uncommon at least in grad school though it is a very small set of people I know). 
&gt; I've been teaching F# to people in industry for 12 years now --jdh30 Yea, that's a real scary agenda. How dare he speak for the people who teach and learn F#. Let's keep F# hard to use so only the 'smart's people will touch it. 
Tuples can’t be enumerated and must be decomposed to operate on the individual elements. If you need to reduce a tuple, then a tuple is not the right collection for your task.
Dom gives an overview of how in his talk, F# code I love . You take all the abstract methods, and you pass them in as functions in the type's constructor. Group them in an interface or tuple if there are many.
I think you're tuple-ing wrong. Tuples are structured bags of (usually) different things, not a sequence of similar things. As such, it usually doesn't make sense to "reduce" on a tuple any more than it makes sense to "reduce" on an F# record or a C# class.
Ok, so if you completely redefine the meaning of the word 'language' to fit your personal definition, then yeah you're right. :shrug: Meanwhile, in the real world, those of us that want to see great libraries for web development, language embedding, F#-on-javascript, etc are actually working on those things to make the story better for everyone. I don't see you contributing materially to make that story happen.
And that's supposed to be better than `new SQLiteCommand(sql,con)`? You remind me of the early days of J2EE when they didn't understand encapsulation and everything required stitching together a dozen classes. (Literally that's how many it took to post a message to a queue.) Only this is worse because we have to stitch together the methods that make up each class too.
Could you please describe the fsi issue you get on [Rider tracker](https://youtrack.jetbrains.com/issues/RIDER)? I'd be glad to look into it.
I don’t know of such a study, sounds like you’ll need quiet the sample size with very specific experts in it to get anything useful. As far as difficult to code - sure, C# is easy because it follows same imperative model everything else does, but in much more polished presentation. Functional language is different at fundamental level. You HAVE to change the way you think about software. No more classes, loops, nulls etc. Its easy once you get it. But as always look at C++ - its a horror show of a language with no discernible design philosophy aside from backward compatibility, yet its still more used than anything we discussed here, because its established. Is it good? Is rust/d/nim better? Where is mass migration? C# was first. So its most established. And business software plumbers just want the paycheck.
&gt; if you completely redefine the meaning of the word 'language' to fit your personal definition Non-sequitur. You argue for restricting consideration to the language and then start talking about non-language projects. &gt; great libraries for web development We've already had `HttpListener`, Suave, Giraffe, Freya and now SAFE stack. Firstly, how will your new "great library" improve upon them? Secondly, why would you develop yet another library for web dev on a programming language that isn't seeing any uptake or even interest from its own developers in fixing the underlying problems that have been crippling its uptake? &gt; language embedding Similarly, we already have computation expressions and type providers. The `seq` and `async` are ubiquitous but everything else is practically unheard of in production, e.g. we've stripped out all type providers due to reliability problems. Adding more language embeddings isn't going to fix the underlying problems with F#. It is just another academic play thing to tinker with. &gt; F#-on-javascript Similarly, we've already had several third party attempts in the form of Funscript, Websharper and Fable. None saw significant uptake due to F#'s underlying problems. How do you intend to do better? &gt; I don't see you contributing materially to make that story happen. Yes, of course. I just explained why I don't buy into your story so the fact that I'm not punching out code to help you for free should not be surprising. 
I know it is easier especially when you can user types as a lightweight proof system. That said, a lot of people do struggle to use these. I especially love Julia cause of the multiple dispatch on types. I like type classes in Haskell (especially in blue spec, a hardware description language DSL). And finally, success of any language is tied to the quality of the library, which .Net languages really won't have a problem with. Well, I do agree with the fact that people can write terrible code with C++ but then again, I've seen people write horrible code in every other language. Finally, migration won't really happen if people don't perceive a benefit of moving it. Not because they are idiots. They need substantial benefits to move. And languages' strengths are quite subjective. I hate C++ by the way. Too bad all the self driving companies use that. Bahh! 
Citation needed. A CS degree is pretty standard.
Not where I come from.
Okay
I don't know if some folks are talking past one another here but it seems your objection is about F#'s general handling of null values and options, and not about the upcoming formal [Nullable reference types](https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references) feature for C#/F#? In my experience F# null handling is no worse than say C# and in some aspects better so I'm trying to understand the complaint. First, there is no requirement to use options anywhere if you don't like them for whatever reason. You can just use the raw X and do standard null checks (if X = null) or catch null exceptions if you want. Second, options are not alternate syntax for nulls. They are their own type with different semantics. They don't just inherently automatically map null to None, that is up to the programmer to choose to use it that way. If you store a null value as "Some null" in an option and mistakenly expect it to convert to "None", that is a matter of understanding the intent and usage of the type, not a language flaw. The Option.ofObj function exists for this use case of mapping a null to None. Third, for a whole range of F# types, nulls are basically a non-issue and you don't even have to do any of the above. Records, unions, lists, maps, even classes defined in F# simply can't be null in normal usage. These types often make up a large majority of domain code in an end-to-end F# app, so large portions of F# programs can have zero risk of accidental NullReferenceExceptions. Of course there can still be nulls in non-F# types, such as strings which are a CLI type. And programmers can do things like opting out of null safety with e.g. Unchecked and AllowNullLiteral. But again this is no worse than the status quo in C#, and the risk is limited only to some types, not the whole codebase.
&gt; In my experience F# null handling is no worse than say C# and in some aspects better so I'm trying to understand the complaint. True, but I was hoping for a solution. When F# was released, I was working an engineering help desk. More than half the errors I saw were null reference exceptions.
&lt;&lt;10% of the software developers I've worked with had a CS degree. Many didn't have any degrees. 
&gt; C# is far from perfect; but off hand I can't think of anything that's bad enough to make me want to try a different language. I find business people are happy to read and discuss a page of F# types (tuples, records and unions) pertaining to their specialist domain because they find it comprehensible whereas the equivalent C# terrifies them. 
&gt; Nah, this is typical, spreading FUD comment from JDH. I literally linked to data backing up my claim. &gt; It seems the only reason he’s mod of this subreddit is Because I stepped up when nobody else would. &gt; to spread his own agenda What agenda? &gt; that has nothing to do with reality (i.e not with how F# is perceived by majority of its users, nor with how MSFT treats it, nor with what is important for the community). If Google trends doesn't reflect reality then look at other metrics. The [market for F# jobs hasn't grown since 2012](https://www.itjobswatch.co.uk/jobs/uk/fsharp.do). The world's largst conference on F# is no bigger than it was in 2012. If you want to learn something about reality: I have to approve your ad hominem attacks on me because I'm the moderator of this subreddit. &gt; I can only hope that this is just lack of knowledge about current state of ecosystem, and not malice. However given the fact such comments are repeating despite the fact many users of this subreddit are regularly pointing out that he’s wrong, I’m afraid it’s the latter. There are a couple of people who agree with you. 
Reduce requires the type of the accumulator to be the same as the type of the elements so you probably want a fold with a lambda function extracting the specific element of your tuples instead: [0, 0, 0; 1, 2, 3; 5, 6, 7] |&gt; Seq.fold (fun a (_, x, _) -&gt; a+x) 0 
Bingo, this is actually quite possibly the killer feature. I’ve had subject matter experts at multiple companies and in multiple domains actually read and make corrections or improvements to domain type systems in F#. I’ve never used another language where we could do this without writing a DSL with a custom lexer. 
SQL too. You wouldn't believe how many financial people I've met that understand SQL but no other programming. I used to get feature requests in the form of crude CREATE TABLE scripts. 
Order (often) better still, \`\`Seq.indexed\`\`.
&gt; Why are you a moderator of this community? Because I stepped up. &gt; Also if you want fun propaganda this works for a lot of languages the year of C# was 2004 the language has been in decline for several years now . The year of javascript was 2004 the language has been in decline for several years now. Absolutely. C# and Javascript are also in decline. &gt; Either delete non-constructive posts like this, This isn't a fanboy forum. The people here are free to discuss the shortcomings of F# and practical ways to improve the situation. &gt; respond to them with actually correct answers, My answer was correct. I even included a link to primary data from Google. You see the same thing if you look at the F# job market or F# conferences or most other metrics. &gt; or moderate some other community. If you don't like this community, you are free to go elsewhere. 
That's fine. It's also one of the fastest-growing degrees in academia, and especially in the US where a college degree is essential to finding skilled labor, it's becoming a standard. Most jobs now explicitly list it in their requirements, even if it's not strictly enforced.
I think demand massively outstrips supply though.
These are interesting points, but I agree with Chet that they aren't language features but part of a larger tooling and library ecosystem. These pieces are aspirational and all worth doing, but unfortunately not going to be happening soon. Programming languages at large, including F#, aren't anywhere near that. Even if you're using JavaScript, where you can do all sorts of things in the browser, the instant you have to do "real" programming you're fighting a dependency manager and installing untold numbers of things on your machine. Cloud IDEs like Cloud9 are a start, but require a credit card and (shocker!) fail pretty miserably once you start incorporating packages and falling off the happy path that their respectable (but likely small) team has optimized for (in this case, writing AWS lambda functions). This isn't to say it's not impossible, but we're talking years, not months, from where things are today. Perhaps if our industry never changed since 2010 such a thing would have been possible, but as the size and diversity of developers and their projects exploded, the difficulty in keeping up did as well. This isn't specific to F#. Put differently, as an in industry we're not struggling to get everything into a zero-install browser experience, we're struggling to keep a million existing things from breaking while inching towards loft goals. Unless you're Swift at Apple, in which case you're fine breaking everyone every release. But then again, Swift still doesn't work on Windows :)
&gt; These pieces are aspirational and all worth doing, but unfortunately not going to be happening soon. I'm working on it... :-) &gt; "real" programming I appreciate what you're saying but it sounds like you're going head-to-head against C# when the perception is that C# is about to get 99% of F# anyway. Where do you see F# differentiating beyond just being a slicker me-too? 
I think you can make a similar case for most languages. Need to write a web service? Take your pick from oodles of languages and ecosystems, most of which will probably get the job done. Some app kinds are walled gardens that require specific tech, but most aren't. Given this, I think it's about two things: Language defaults and how each feature "feels". For example, type inference will make byref parameters to functions`inref` (read-only pointer) unless otherwise specified or used only with an explicitly mutable byref. This is very different to C# despite it being the same feature. If that sort of thing is your jam, you'll have a better time doing lower-level stuff in F# than C#. If not, then C# may feel nicer. Every programmer is different, and with so many languages that can do wonderful things out there, I honestly feel that personal preference is a big driver. Using core strengths in new(ish) domains. Data Scientists and ML practitioners aren't exactly enthralled with Python. It's got libraries, but if you do anything serious with Tensorflow it's sort of like throwing stuff at the wall to see what sticks. Interviewing professionals in this space yields a similar set of problems they all have. This is the core rationale behind research efforts going into [TensorFlow.FSharp](https://github.com/fsprojects/TensorFlow.FSharp), which does shape checking and inference and bubbles it up into tooling. Something like this could make peoples' lives easier, especially as TensorFlow continues to explode in popularity, evolve, and find its way into enterprises. This space is still pretty wide open, hence our investment there. Similar tech could be built for anything else, but at a huge cost. This is while "core F#" continues to evolve in the background. New features, more focus on performance of the language service, renewed FSI on .NET Core with package references, ensuring it all runs smoothly in Azure, etc.
&gt; Language defaults and how each feature "feels". For example, type inference will make byref parameters to functions_inref_ (read-only pointer) unless otherwise specified or used only with an explicitly mutable byref. This is very different to C# despite it being the same feature. If that sort of thing is your jam, you'll have a better time doing lower-level stuff in F# than C#. If not, then C# may feel nicer. Why about fixing the defaults for struct tuples?
That's a binary breaking change, not to mention huge semantic change that is widespread, so it won't be happening. It's also not something to "fix", as that implies struct tuples are inherently better. There are many circumstances where it is a disadvantage to use them instead of reference tuples.
&gt; ... Javascript are also in decline LOL &gt; This isn't a fanboy forum It's not about fanboyism, it's about lying to people, &gt; or F# conferences Yeah, let's do that. New conferences created in last 4 years: * Open F# - San Francisco, 1st edition in 2017, we'll have the 3rd edition in September 2019 * RemmidemmiConf - Germany, the 1st edition in 2016, happening every year. * FableConf - Europe, 1st edition in 2017, 3rd edition will get announced soon * Southern Fried Fsharp - Raleigh, NC, USA, 1st edition will happen in April 2019. And, of course, F# eXchange is still around with last year edition being probably best ever - the majority of people in the audience being new to the F# community and a lot of new speakers. Additionally, we have a huge presence on many general programming, FP focused, or .Net focused conferences all over the world. &gt; Can you cite some metrics that indicate any significant growth in the F# world over the past 4 years? Just from last year: * "VS users who use F# up &gt;25% Year-over-Year" [06.04.2018, Source: [F# eXchange 2018](https://skillsmatter.com/skillscasts/10138-keynote-thrilled-to-have-phillip-carter-hosting-a-keynote-at-fsharpx-2018) ] * "VSCode users who use Ionide up &gt;50% Year-over-Year" [06.04.2018, Source: [F# eXchange 2018](https://skillsmatter.com/skillscasts/10138-keynote-thrilled-to-have-phillip-carter-hosting-a-keynote-at-fsharpx-2018) ] * "F# Software Foundation membership up &gt;70% Year-over-Year" [Source: [F# eXchange 2018](https://skillsmatter.com/skillscasts/10138-keynote-thrilled-to-have-phillip-carter-hosting-a-keynote-at-fsharpx-2018) and [FSSF webpage](http://foundation.fsharp.org/welcome_to_2018) ] * "32% YoY messured growth in external [non-MSFT] VS and VSCode F# usesrs (de-duped)" [Source: 28.09.2018. [OpenF#](https://www.youtube.com/watch?v=VNstJOPQIpU) ] Additionally, totally anecdotal, I can mention noticeable growth in popular community-driven projects such as Ionide (1.2 million downloads just 3 years after release), Fable or SAFE Stack (Fable/SAFE talks, workshops and training has been happening on tens of meetups, conferences and events over last year, there has been huge interest in commercial support for those technologies, and noticeable growth on the communication channels used by those projects (Gitter/Slack)) 
&gt; LOL [From 32k jobs to 25k jobs over the past 12 months](https://www.itjobswatch.co.uk/jobs/uk/javascript.do) &gt; It's not about fanboyism, it's about lying to people, I wasn't lying. &gt; New conferences created in last 4 years: That's great but: * How many conferences have died? * What was their attendance? For comparison, ~10 years ago the F# meetup in London regularly had 100-200 delegates. See [F# meetup 2012](https://www.meetup.com/FSharpLondon/photos/5631492/) vs [F# meetup 2019](https://www.meetup.com/FSharpLondon/photos/29688566/). The [Open F#](https://pbs.twimg.com/media/Dob7c66VAAEpAFS.jpg) conference appears to have ~40 attendees including the 20 speakers. [RemmidemmiConf](https://pbs.twimg.com/media/DNxvuUoXcAAEb6n.jpg) looks like 15 people. [FableConf](https://axxes.com/wp-content/uploads/2017/11/FableConf_Collage.png) looks like 39 people. The feedback I've heard is that none of these meetups or conferences has grown significantly over the past 10 years. For comparison, my company has been organising the same event for 10 years: in 2009 it had ~150 attendees, today it has 4,000 attendees and we consider it to be growing too slowly. &gt; Just from last year: Those are some great stats, thanks. I'm not surprised that VSCode users have been massively up over the ~2 year period where Microsoft broke support for F# in VS. 25% growth YoY for VS users is unbelievable to me. &gt; I can mention noticeable growth in popular community-driven projects such as Ionide (1.2 million downloads just 3 years after release), Fable or SAFE Stack (Fable/SAFE talks, workshops and training has been happening on tens of meetups, conferences and events over last year, there has been huge interest in commercial support for those technologies, and noticeable growth on the communication channels used by those projects (Gitter/Slack)) Of course. The mailing list was hugely popular but died and everyone moved to Fx and then to Slack/Discourse/Gitter and so on. One part growing to replace another is not growth in F# per se. 
Some lightweight visualisation using open source data and XPlot in Jupyter notebooks. 
Nobody's forcing you to believe what I've talked about, but the growth figures are based on concrete measurements of the product. Keep in mind that what's measured is strictly less than actual usage, since we enforce GDPR constraints worldwide, and nearly any customer in finance has all telemetry off. VSCode usage is also quite distinct from VS usage. Most people use one or the other. The UK job market is also fairly saturated and hard to grow in general (regardless of tech). We see lots of F# growth in Eastern Europe, China, and the US but the UK is fairly stagnant. It's not surprising though - F# started off in the UK and got a strong foothold, but it is an expensive and mature market. I can't imagine the Brexit debacle is doing us any favors here either.
&gt; Most people use one or the other. On what basis do you say that? I have F# installed in both VS and VSCode on at least three personal computers. &gt; I can't imagine the Brexit debacle is doing us any favors here either. The uncertainty is awful but the shift in exchange rate has been hugely beneficial for exporters and overseas earners including my companies. In point of fact, my CTO wanted to hire F# developers but I told him to diversify the role to include many other tools because I was nervous about the future of F# (and we've been burned twice by F# developers and countless times by Microsoft). I suspect other people are in the same position so it is good to clarify the situation. 
&gt; On what basis do you say that? I have F# installed in both VS and VSCode on at least three personal computers. Am I being counted six times? It's complicated. Beyond various heuristics, it also depends on if you're signed into anything or not, but if you have an install of both on the same machine you're not being double-counted. Keep in mind that this is all within standard error measurements. We don't report on anything unless its rate of change is outside the error measurement range. There's noise in every measurement and issues are found forcing a rebaseline of historical data, making it hard to be _precise_ about things. But F# usage and growth is large enough and outside the measurement error, so it's at least _accurate_. &gt; I suspect other people are in the same position so it is good to clarify the situation. I'm not sure what your experience has been, but at least in my experience talking to people who have recently grown their business with F#, they have had the best time when just hiring good people and not focusing on any technology - F#, .NET, Xamarin, VS, Azure, etc. It generally just takes them within a month to fully ramp up, which is well within the multiple months it generally takes someone to be at peak productivity. 
I never got it to run either. Do any members of the F# community have any advice for this guy to help him get fslab running? 
I once got it working VS 2017 back in late 2017 before some big changes to the project, but IIRC it's been changed a bit and big changes to packaging were made. Unfortunately it is a heinously complex package and I would be shocked if any editor support today fully works. Have you tried using Paket and Fake directly to install packages, build from the command line, and then open in VS?
No I'll Google fake tomorrow then... Jeez. You'd think they'd edit the getting started page it only takes a minute
Just to elaborate on this. Krzysztof Cieślak says my perception about the community is wrong but I just checked the Reddit bin for reported posts and found [this post](https://www.reddit.com/r/fsharp/comments/b5cbc1/fslab_and_visual_studio_2017/). Checking the OP's history I see that someone on /r/dotnet advised him to try the combination of Deedle and R interop which led him to FSLab. FSLab is a great case study. [FSLab](https://fslab.org/) is a combination of several different OSS F# projects. [FSharp.Data](http://fsharp.github.io/FSharp.Data/) is a kitchen sink library for data access written by an intern that sports one of the slowest JSON implementations in existence and a variety of type providers that are too unreliable for production use. [Deedle](http://bluemountaincapital.github.io/Deedle/) is another library by the same intern that tries to replicate the functionality of Python's Pandas using some fancy tricks but, ultimately, there is no elegant F# equivalent because the fundamental concept doesn't fit F#'s type system very well. [Math.NET](https://www.mathdotnet.com/) is another kitchen sink library this time around technical computing but, last I tried, it was way too buggy for production use. [XPlot](https://fslab.org/XPlot/) is a really unsafe shim over charting libraries that sports a poorly-typed API that results in loads of run-time exceptions making it virtually useless for production code (I am in the process of stripping it out now). [FSharp.Charting](https://fslab.org/FSharp.Charting/) is another library that does the same thing in an incompatible (but better-designed way) using WPF. [Jupyter](https://github.com/fsprojects/IfSharp) is a poor man's Mathematica notebook interface for text-only languages originally for Python which they added F# support to but when I tried it I found it was really unreliable. So Microsoft combined all of these libraries into one OSS bundle. I tried it and couldn't get anything to work. This guy obviously tried it more recently, not only couldn't get anything to work but had his post hidden because someone reported him asking for help as "spam". By officially endorsing this abandonware they've only accomplished destroying the higher quality commercial offerings people were building for F# and now it has nothing that works. 
What do you use? I'm not hell bent on forcing something to work I just wanted a nice editor similar to pythons jupyter notepad
You can use F# in Jupyter today, it works fairly well. Azure Notebooks also hosts an environment for free.
Nice one
Interesting use case! Thanks for sharing!
Why does F# need it's own JSON library in the first place? Perhaps I am missing something, but it sounds like a waste of effort. 
&gt; Why does F# need it's own JSON library in the first place? &gt; &gt; Perhaps I am missing something, but it sounds like a waste of effort. Good question. In the era of microservices almost every modern program sends and receives messages over the wire. In most cases, both sender and receiver are under the control of the same person and are usually written using the same tool stack. In such cases it is extremely valuable to be able to serialize and deserialize any value effortlessly. Erlang really led the way in this regard but even Javascript has `JSON.stringify` and `JSON.parse`. JSON is the defacto-standard format these days so it is logical to support JSON as a wire format. In the context of F# this means the holy grail is a pair of functions, say `Json.serialize&lt;'a&gt;` and `Json.deserialize&lt;'a&gt;`, that convert any value of any F# type into JSON and back again reliably. F# has a really nice, simple and elegant core type system that it inherited from ML consisting of atoms (ints, floats, chars, strings, decimals, `DateTime` etc.), tuples, records and unions. JSON serialization only needs to cover these in order to handle 99% of practical use cases. Many people have tried to do this with varying degrees of success but none are officially endorsed or have even become defacto standard. The obvious question is: why not use the .NET libraries? The answer is: 1. They don't target that ML type system. 2. They are only partial solutions, either converting JSON data into tokens or into parse trees but rarely to final values. Some libraries like `Utf8Json` only provide tokenization and don't even handle parsing much less the construction of native types. Other libraries like `FSharp.Data` serialize between JSON and their own format which you must then convert between yourself which isn't much of an advantage over just handling JSON directly but, in particular, is extremely inefficient because it generates huge temporary data structures (our server was struggling with ~30s startup times because 41MB of JSON data was exploding into 0.5GB of unnecessary intermediate data structures in memory). Then you've got libraries like Newtonsoft's that try to master everything including the entire .NET type system with OOP which is mission impossible so they end up being a jack of all trades and master of none with, in particular, . Combined with some really stupid design flaws found in most of the libraries, like serializing a .NET `Dictionary` or F# `Map` that is generic over the type of key to a JSON "object" where the key must only be a `string`. Consequently, almost all of the libraries I tested fail when confronted with a dictionary where the key is something like an array of ints. Worse, most of them silently serialize your data to a corrupt format and only crash when you try to recover it! 
Just a heads up because you seem to be new to F#: having throwback of inferred types in the editor is extremely valuable if you're writing anything but the simplest code snippets. By the looks of it Jupyter doesn't support this so you might prefer F# in Visual Studio maybe with `FSharp.Charting`. 
Fantastic presentation, thanks!
&gt; It feels a bit weird to need to install extra libraries from nuget just to iterate in parallel... Get used to it! :-) On the upside, you don't have a massive standard library bogging your code down. I actually prefer having non-essential things like this relegated to libraries. A simple core is really valuable... 
 let y = (fst x) + (snd x) Don't do that. IMO `fst` and `snd` shouldn't even exist. The whole point of ML, and one of its major evolutions from LISP, is that destructuring is always done using patterns. That's why there are patterns everywhere in the language: `let`-bindings are patterns, `match` expressions have a pattern in every match case, `fun` lambdas have a pattern as the argument and the short-hand `function` starts with a pattern. You have ample opportunity to use patterns to destructure everything! FWIW, the problem with `fst` and `snd` is that they make 2-tuples (aka pairs!) special when they aren't special. So noobs get tripped up because they cannot do `fst (1,2,3)`. 
FWIW, I never cared for those OOP things and always wanted a simple first-order module system with signatures on any module so you can hide things from some parts of a code base but not others. F# used to have this but it was stripped out and now only works at the `.fs` file level, which seems weird to me. 
I just use a little reflection magic to read database tables into a `Map&lt;int, myRecordType&gt;` like this: open System.Data.SqlClient open System.Collections.Generic let (|Found|_|) (d: System.Collections.Generic.IDictionary&lt;_,_&gt;) key = let mutable value = Unchecked.defaultof&lt;_&gt; if d.TryGetValue(key, &amp;value) then Some value else None module Raw = let [&lt;Literal&gt;] connectionString = "Server=dbdoo.kebkjbwwgl.us-east-1.rds.amazonaws.com,1433;Database=all;User Id=admin;Password=11378008;" let read&lt;'a&gt;() : Map&lt;int, 'a&gt; = let info = Reflection.FSharpType.GetRecordFields typeof&lt;'a&gt; let fieldNames = info |&gt; Seq.map (fun info -&gt; info.Name.ToLower()) let key = Seq.findIndex ((=) (typeof&lt;'a&gt;.Name.ToLower() + "id")) fieldNames let sql = sprintf "SELECT %s from %s" (String.concat ", " fieldNames) typeof&lt;'a&gt;.Name let make = Reflection.FSharpValue.PreComputeRecordConstructor typeof&lt;'a&gt; let makeSome (ty: System.Type) = let case = Reflection.FSharpType.GetUnionCases ty |&gt; Seq.find (fun case -&gt; case.Name = "Some") let make = Reflection.FSharpValue.PreComputeUnionConstructor case fun (obj: obj) -&gt; make [|obj|] let optionify (ty: System.Reflection.PropertyInfo) = if ty.PropertyType.Name = "FSharpOption`1" then let makeSome = makeSome ty.PropertyType fun (value: obj) -&gt; if System.Object.ReferenceEquals(value, System.DBNull.Value) then box None else makeSome value else id use connection = new SqlConnection(connectionString) use command = new SqlCommand(sql, connection) do connection.Open() use reader = command.ExecuteReader() seq { while reader.Read() do let fields = Array.init reader.FieldCount reader.GetValue let fields = Array.map2 optionify info fields yield fields.[key] :?&gt; int, make fields :?&gt; 'a } |&gt; Map type Contact = { ContactId: int UserId: int option } type Product = { ProductId: int ProductCategoryId: int } type ProductCategory = { ProductCategoryId: int ProductCategoryName: string ProductTypeId: int } type ProductType = { ProductTypeId: int ProductTypeName: string } type Oline2 = { Oline2Id: int Invoicedate: System.DateTime option Salesdate: System.DateTime option Approxgbpvalue: decimal option ProductId: int option ContactId: int option O2id: int } type Publication = { PublicationId: int Authorstaffids: string option ProductCategoryId: int Supercede_publicationid: int option } type PortalSubscription = { PortalSubscriptionId: int Startdate: System.DateTime option O2id: int } type ProductScope = { ProductScopeId: int ScopeId: string option ProductId: int } type Userscope = { UserscopeId: int Userscopestart: System.DateTime option UserId: int ScopeId: string option } type Staff = { StaffId: int Name: string } type Article = { ArticleId: int Accesslevel: int option AuthorStaffId: int option Published: bool option PublishedDate: System.DateTime option ApproxHits: int Summary: string LongSummary: string Title: string } type CompanyProfile = { CompanyProfileId: int PublishedDate: System.DateTime option LastUpdate: System.DateTime option Interviewer_ContactId: int } type DB = { Contact: Map&lt;int, Contact&gt; Product: Map&lt;int, Product&gt; ProductCategory: Map&lt;int, ProductCategory&gt; ProductScope: Map&lt;int, ProductScope&gt; ProductType: Map&lt;int, ProductType&gt; Oline2: Map&lt;int, Oline2&gt; Publication: Map&lt;int, Publication&gt; PortalSubscription: Map&lt;int, PortalSubscription&gt; Userscope: Map&lt;int, Userscope&gt; Staff: Map&lt;int, Staff&gt; Article: Map&lt;int, Article&gt; CompanyProfile: Map&lt;int, CompanyProfile&gt; } let downloadDB() = { Contact = read() Product = read() ProductCategory = read() ProductScope = read() ProductType = read() Oline2 = read() Publication = read() PortalSubscription = read() Userscope = read() Staff = read() CompanyProfile = read() Article = read() } We've found it to be much faster, simpler and more reliable than other DB layers, particularly type providers. 
Okay thanks will give it a go
Thanks. That #INDEX syntax would be nice to have 
No problem, glad you liked it! 
Here's how to do it: First, install [.NET Core](https://dotnet.microsoft.com/download). Then, open a terminal and enter the following: ``` dotnet new -i FsLab.Templates dotnet new fslab-journal -lang F# -n Experiment1 ``` Open the Experiment1.fsproj in Visual Studio. I used VS 2019 RC update 4. Run without debugging (ctrl+f5). This will launch the integrated terminal, with a file watcher, and will open the rendered experiment script as HTML in a new browser window. Now you can hand edit the script (Experiment1.fsx) and the page will update whenever you save the file.
Not as a direct port. [This line](https://github.com/MichalStrehovsky/zerosharp/blob/master/efi-no-runtime/zerosharp.cs#L121) uses unmanaged generic constraints (which is not yet released, but will be). We have [candidate PR](https://github.com/Microsoft/visualfsharp/pull/6064) but it's not as ready for use.
Sadly, /u/jdh30 is right. F# is currently the laughing stock. For example, look at the comments in this link. https://reddit.com/r/programming/comments/b4u6u6/microsoft_pyright_static_type_checker_for_python/
/u/jdh30 what is your view on this?
&gt; It's not about fanboyism, it's about lying to people, What about your lies about UWP and the Windows platform?
Thanks, how do you add more script files to the build? Does it watch the whole folder?
Legacy code is relying upon the ability to read and write tuples atomically. Struct tuples aren't read or written atomically. So changing the default to struct tuples would introdue nasty concurrency bugs into existing code which is a non-starter. If I were redesigning from scratch today I'd go with unboxed tuples, records and unions from the get-go because they would be a lot more efficient. 
Sure
Rust is also a systems programming language without a GC, so this isn’t an apples to apples comparison. Especially since tuples are used more than just as ephemeral groupings of data in F#, it’s not just an obscure corner case where a struct is worse than a reference type. I’ve seen it many times where “fixing allocations” by replacing a tuple with a struct tuple results in more CPU time overall.
&gt; Rust is also a systems programming language without a GC, so this isn’t an apples to apples comparison. Ok. ATSLang, HLVM, MLton and other GC'd languages also unboxed tuples to good effect. &gt; Especially since tuples are used more than just as ephemeral groupings of data in F#, it’s not just an obscure corner case where a struct is worse than a reference type. I’ve seen it many times where “fixing allocations” by replacing a tuple with a struct tuple results in more CPU time overall. In F#, yes. F# does lots of optimisations around reference tuples that haven't made it into struct tuples yet. .NET has never been very good at handling structs which doesn't help either. When I wrote HLVM using LLVM unboxed tuples were only slower on the most abstruse torture tests. 
https://github.com/ninjarobot/FsPdf
This is an interesting point, though I still feel it's not quite fair to compare here. Ignoring compat (since that is the primary reason), unboxed types by default isn't going to be the same from runtime to runtime. Perf characteristics are rather finicky on .NET when it comes to using value types vs. reference types. In our recent perf work for the compiler service, almost none of the sweeping improvements were due to using value types. When making changes and measuring, the impact was usually either insignificant (sampled perf runs with slightly better or slightly worse CPU time) or worse (more copying, hence more CPU time). In one instance did using unboxed tuples help, since it was just some ephemeral data being used to group results before they were processed. In "real world" sampling it was also insignificant, but benchmark runs did yield some improvement so we took the change. Additionally, allocations by themselves are not inherently bad at all. The .NET GC is an incredible machine that can easily handle many workloads. The primary issue is LOH allocations, which until now the F# compiler has done a ridiculous amount of. LOH collections cannot be done on background threads and result in huge GC pause times. In rare cases does the use of value types avoid LOH allocations.
&gt; Additionally, allocations by themselves are not inherently bad at all. The .NET GC is an incredible machine that can easily handle many workloads. The primary issue is LOH allocations, which until now the F# compiler has done a ridiculous amount of. LOH collections cannot be done on background threads and result in huge GC pause times. In rare cases does the use of value types avoid LOH allocations. For serial code, yes, but for multicore parallelism the GC is a shared resource and allocations kill it. I'll wager if you run those benchmarks in parallel the ones using value types will scale better starting from similar serial performance. 
&gt; I'll wager if you run those benchmarks in parallel the ones using value types will scale better starting from similar serial performance. Only if it's applicable :) In the case of the F# tools, due to type inference, all operations that require typechecking info are single-threaded. Parsing-only features are free-threaded, and in those it can help...but since bottlenecks in CPU and memory are not in parsing only operations (anymore...), changing them to primarily use unboxed types for an unknown improvement isn't worthwhile. Making architectural changes is, though. For something like a highly concurrent web server, yes it can help to use unboxed types if they're used correctly. But what _really_ helps is byref-like types such as Span, since they come with compiler analysis that ensure you don't escape the stack, or end up doing confusing things where it _looks_ like it allocates less but it actually allocates a lot, or copies data implicitly. This was one of the primary themes for F# 4.5, since it's quite difficult to write code that doesn't allocate needlessly without compiler help in F# or C#. To that end, struct active patterns are on the roadmap and we feel they're totally worth doing. Perhaps if F# were started now there would be more unboxed types by default, but I honestly couldn't say.
Looking at [the IL transform in question](https://github.com/dotnet/corert/blob/bd07c4e/src/Common/src/TypeSystem/IL/Stubs/CalliIntrinsic.cs), I *think* it would still work if you replaced the generic pointers with actual pointer types, which means you wouldn't need the `unmanaged` constraint.
A lot of what you mention is why .NET Core 3 is planning to introduce a standardized, high performance and near-zero allocation JSON reader/writer. But in general, JSON is a bit of a trashfire from a framework author's standpoint. Not that XML was incredible, but there were at least tools to have consistency that were more widespread. People in other ecosystems are also solving galaxy brain level problems every day like, "why did this not deserialize right?" and "did someone change to JSON schema?".
&gt; A lot of what you mention is why .NET Core 3 is planning to introduce a standardized, high performance and near-zero allocation JSON reader/writer. That's great but for a high-level tool like F# it is a small part of the whole solution. Ideally F# would have a constraint (like `equality` and `comparison`) for serialization and it would autogenerate a high-performance near-zero-allocation serialization and deserialization function for every type. &gt; But in general, JSON is a bit of a trashfire from a framework author's standpoint. Not that XML was incredible, but there were at least tools to have consistency that were more widespread. People in other ecosystems are also solving galaxy brain level problems every day like, "why did this not deserialize right?" and "did someone change to JSON schema?". Absolutely. Thanks to the core ML type system, F# has a huge advantage in this context. If you can just handle the built-in atomic types (`(u)int8/16/32/64`, `float32/64`, `char`, `string`, `DateTime` etc.), tuples, records, unions, arrays, lists, `Set` and `Map` then F# would have a massive advantage over all of those other tools that, as you say, struggle to serialize all objects of all classes (because that is a practically impossible problem to solve). 
&gt; In the case of the F# tools, due to type inference, all operations that require typechecking info are single-threaded. Why exactly are they single threaded? There's nothing about inferring types in different source code files that is inherently single threaded. &gt; For something like a highly concurrent web server, yes it can help to use unboxed types if they're used correctly. But what really helps is byref-like types such as Span, since they come with compiler analysis that ensure you don't escape the stack, or end up doing confusing things where it looks like it allocates less but it actually allocates a lot, or copies data implicitly. This was one of the primary themes for F# 4.5, since it's quite difficult to write code that doesn't allocate needlessly without compiler help in F# or C#. Sure. &gt; To that end, struct active patterns are on the roadmap and we feel they're totally worth doing. Perhaps if F# were started now there would be more unboxed types by default, but I honestly couldn't say. FWIW, when F# was started structs were not well supported in .NET. For example, you could not tail call a function with a struct return type. 
&gt; Why exactly are they single threaded? It's how the typechecker is implemented. The overhead of coordination is also likely to be high and error-prone so it's not a priority to build some kind of infrastructure that gets around the compiler. Besides, the typechecker itself isn't terribly slow, it's the architecture of the language service itself that makes some calls (e.g., Find Refs) slow. Use of value types here can make some marginal improvements, but as with any complicated system it's the architecture. &gt; Looks like System.Int32.Parse and friends still don't support Span If you're on .NET Core, Span has proliferated in the BCL. In this case, [Parse](https://docs.microsoft.com/en-us/dotnet/api/system.int32.parse?view=netcore-2.2#System_Int32_Parse_System_ReadOnlySpan_System_Char__System_Globalization_NumberStyles_System_IFormatProvider_) I have a quick benchmark [here](https://gist.github.com/cartermp/e2aa9fe556b6a2dae40e0fcaa94e748e) that you can try for yourself. Using [my machine](https://gist.github.com/cartermp/a9f53d4e802167b2f22c7fbec50ed550), use of Span cuts allocations down by ~1/3 and CPU time by ~1/3. Addition of a struct tuple removes almost all other allocations and halves the new CPU time (so ~1/5). The big deal here isn't necessarily the perf, but how the programming model is simple and the compiler is quite struct when using it (though the .NET Core runtime does have some new innovations regarding byref-liuke structs such as span).
I recently had success with using iTextSharp in an F# project. My use case was to select and copy a PDF template file, and then map record properties into the template fields. iTextSharp was the only library that handled the process of modifying the PDF fields properly. &amp;#x200B; If you want to use it for free, you will have to make sure to get the last version that had a free license via nuget/paket (the license changed at some point). There are various forks of the free license version. I actually ended up using this one (via nuget): &lt;package id="iTextSharp-LGPL-Core" version="1.1.0" targetFramework="net461" /&gt; (LGPL is less restrictive than GPL in that it is free as long as you use the originally distributed compiled dlls - unmodified.) &amp;#x200B; PdfSharp is another good lib that is completely free, but I had issues with writing to fields that made it unusable that project. It may be a good alternative though, depending on what you are trying to accomplish. &amp;#x200B;
C# does provide poor man's F# features that are, as someone else put it, "syntactic sugar" versions of better implementations in F# (meaning less compiler enforcement). For example, C# now has pattern matching, but it's not exhaustive. The average C# dev has no idea why it is inferior to F# pattern matching because the "exhaustive" part seems like a subtle detail until you use it and understand that it is a *game changer* in terms of having air tight code! C# is a "git 'r done" language compared to F#. Mutable variables are like putting sticky notes with eraser smudges all around your code, hidden underneath everything, conspiring against you behind your back. To debug C# code is to continually update your mental maps of where all the sticky notes are and how they affect each other. F\*\*\* that! C# is glorified Excel file programming. &amp;#x200B; &amp;#x200B;
If you have many charts for one document, a poor man's (poor person's) solution is to generate Markdown and use Pandoc with TeX to generate pdfs. Alternatively you can generate docx files with Pandoc and automate Word to open and export them to pdf. If you want to turn a single chart into a single pdf maybe you could use ImageMagick (wrapped as a .Net package as Magick.Net) if the file format of your chart is supported? 
Projects are how you compile an executable binary. That's just how it works. &amp;#x200B; (Ignore anything you see about script compilation; it's a niche scenario that requires advanced knowledge to get anything other than the most trivial of code working.) &amp;#x200B; For everything else, refer to the official docs: [https://docs.microsoft.com/dotnet/fsharp/get-started/](https://docs.microsoft.com/en-us/dotnet/fsharp/get-started/) &amp;#x200B; There are multiple ways to get started and you should pick whichever you feel is best (IDE, VSCode, CLI + bring your own editor) &amp;#x200B; If you want to use VS, don't use VS 2015 unless you must for policy or tooling compatibility. Most features from the VFPT extension are ported over into VS 2017, with significant bug fixes and perf improvements since then.
Not able to install the extension, is there a port or something?
You don't need it. Features it has are in the box in VS 2017.
my entire team use Rider, we switched from all the above and haven’t looked back. 
&gt; It's baffling to me, as to why MS isn't leading by example, wrt improving the status quo of mainstream programming, considering all the PLT heavyweights they have at MSR. Did you know that [Microsoft funded Scala](https://jaxenter.com/microsoft-fund-scala-for-net-project-103595.html), F#'s main competitor? 
&gt; It's complicated. Beyond various heuristics, Ah. :-) &gt; it also depends on if you're signed into anything or not, I use different MSDN accounts on different machines. &gt; but if you have an install of both on the same machine you're not being double-counted. Keep in mind that this is all within standard error measurements. We don't report on anything unless its rate of change is outside the error measurement range. There's noise in every measurement and issues are found forcing a rebaseline of historical data, making it hard to be precise about things. But F# usage and growth is large enough and outside the measurement error, so it's at least accurate. Ok, thanks. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [F# Implementation of Scala ZIO](https://www.reddit.com/r/programming/comments/b6uomk/f_implementation_of_scala_zio/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
&gt; No, I'm not talking about the code itself. I'm talking about the set up to start writing it. &gt; It seems that you can either pick Visual Studio or Visual Studio Code. VS2017 F# support apparently doesn't have the "power tools" so you have to use VS2015. VS2017 used to be extremely buggy but is now only fairly buggy and, in particular, usable. VS2015 is hard to get now so I recommend VS2017 with a vanilla F# install. &gt; I don't want to download an entire new IDE to play around in a language, so I picked VSCode. &gt; The Ionide extension is littered with bugs. It works very well for one script file, however when you can only run it on a REPL and not an executable, you have to make a project. But the extension auto generates projects that cause errors to itself. I think. The "error messages" don't even say an error has ocurred, just say info about the project. The one time I managed to make it work, it took probably like 2 minutes to compile a Hello World. Interesting. I had a similar experience a while back. Apparently it has a huge number of active users but I've never met a single one. &gt; It also generates so much stuff. Aparently there's an alternative to NuGet and a build system. But I don't think I should use those when I don't even know the basics yet. Is there another way to compile an executable besides a project? Like you, said VSCode isn't even trying to be an IDE. It is just an editor. So don't expect it to help with any of that stuff. Visual Studio is much better: just create a new F# solution and hit CTRL+F5 to have it compiled and executed for you. You can write hundreds of thousands of lines of F# code and keep doing that same simple thing to run your code. 
I agree except for this: &gt; If you want to use VS, don't use VS 2015 unless you must for policy or tooling compatibility. Most features from the VFPT extension are ported over into VS 2017, with significant bug fixes and perf improvements since then. VS2017 is still far worse than VS2015 ever was. For example, rename refactor in VS2017 has concurrency bugs that corrupt your code if you type too fast! 
&gt; &gt; I've been teaching F# to people in industry for 12 years now &gt; &gt; Yea, that's a real scary agenda. How dare he speak for the people who teach and learn F#. FWIW, I wrote the world's first commercial literature on F#, shipped the world's first (non-Microsoft) product written in F# and own the world's oldest F#-centric consultancy. And I am now working on a new programming language for the sole purpose of replacing all the F# code we have with something better precisely because I'm sick of all these bugs in the F# ecosystem... 
Good luck. 
&gt; Computation expressions do not compose well. At the IO layer a solution is needed for dependencies in a testable way. The IO layer also needs to efficiently use the thread pool. Making errors type-safe and integrated in the IO logic completes this compelling trinity. Fascinating, thanks. I suppose the obvious point is that you're back to using only bind just as you do in OCaml so do we need computation expressions? 
OCaml may be able to follow ZIO more closely making all the cases explicit. I'm not sure if that could lead to functionality not possible in F#. I've not seen anything in ZIO that isn't possible so far.
Can you elaborate on what you mean by "communicating sequential processes"? I'm thinking of code like this: ``` let chainOfFunctions = firstStep &gt;&gt; secondStep &gt;&gt; thirdStep &gt;&gt; fourthStep ``` And I don't know if this is what you mean.
&gt; communicating sequential processes [This](https://en.wikipedia.org/wiki/Communicating_sequential_processes). &gt; let chainOfFunctions = firstStep &gt;&gt; secondStep &gt;&gt; thirdStep &gt;&gt; fourthStep And I don't know if this is what you mean. Pretty much except the `&gt;&gt;` need to be async interfaces with ring buffers between each step and the end needs to asynchronously send messages back to you (it doesn't return a value). 
The other major CSP implementation available for F# is [Hopac](https://hopac.github.io/Hopac/Hopac.html), which has all of the primitives that /u/jdh30 mentioned in their post. Logary uses Hopac + RingBuffers to great effect to architect their logging infrastructure.