[Http.fs](https://github.com/haf/Http.fs) hands-down. Final answer.
FSharp.Data has an [HTTP module](http://fsharp.github.io/FSharp.Data/library/Http.html) that you may find nice.
&gt; Join 4k+ WebSharper developers 😆
I tried. Trying to use Websharper with F# on fedora today gives me something like this: "The specified task executable "wsfsc.exe" could not be run. Permission denied." See [https://github.com/dotnet-websharper/core/issues/950](https://github.com/dotnet-websharper/core/issues/950), which refers to issue 941, which I think was still unassigned when I checked it. I think that means that Websharper with F# is a non-starter if one is not on Windows and has .NET Core installed until real soon now.
This issue is being worked on -- [here](https://github.com/dotnet-websharper/core/pull/942) is the associated PR.
&gt; I think that means that Websharper with F# is a non-starter if one is not on Windows and has .NET Core installed until real soon now. That sounds correct to me and I think it's crappy people downvoted you. You're right to be annoyed about something that markets itself as a .NET Core API but doesn't work on .NET Core environments. I guess you got what you paid for :) I am not that familiar with WebSharper but I looked at the bug a bit. The problem is that in WebSharper's compiler there's a .NET *Framework* library being referenced, and you don't have .NET Framework installed. Maybe it would work if you had Mono and rebuilt the libraries with that, but I am not sure. Either way: this is quite a severe flaw in WebSharper's architecture! The whole point of .NET Core is self-contained deployment across architectures: WebSharper fails in that pretty hard, it looks like. That said: the .NET Core rollout is still very much ongoing and 3rd party libraries sometimes don't update as well as they should - particularly in F# :/ .NET Standard mitigates this substantially - it looks like we'll be avoiding too much of a Python 2/3 catastrophe :) But sometimes porting Framework-Core takes a loooooot of work, especially if some of the Framework code was really leveraging win32 APIs. Honestly it seems like you can wait a month, check the issue, and try again. I suspect that issue isn't assigned because it's related to the bigger issue of the WebSharper compiler not being written in .NET Core. So it's more of a triage housekeeping thing than an issue being ignored. If you want to try some web development in F#, you could check out this video https://www.youtube.com/watch?v=W8qAUJIVj8c I posted it on this subreddit yesterday. He even does some examples on a Mac, so that's a plus :) I cannot vouch for Fedora specifically but Linux support is a priority for the F# team, and I would be shocked if the built-in Visual F# ASP.NET Core app gave you trouble. Giraffe, a functional wrapper around the C# ASP.NET Core code, says its builds are succeeding on Linux - this might be a good tutorial https://blogs.msdn.microsoft.com/dotnet/2017/09/26/build-a-web-service-with-f-and-net-core-2-0/ If you don't want to use MSFT tech, Suave is quite nice [Giraffe copied a lot of its syntax] but maybe a bit tricky if you're not very familiar with F#. https://github.com/SuaveIO/suave 
Thanks for the recommendations. It is hard to know which bus to get on when none of the signs on the buses announce where the bus is not going.
I think DSyme has nailed this one. The underlying feature is... interesting... but an un-modified export to F# would cause a lot more pain than it would solve. It's like pulling on a sweater thread, only with interfaces and types you otherwise wouldn't be touching in F#.
straight fire. You sort of have to wonder if his argument applies to SRTP as well
I do a lot of OO in F#, probably more than I should :) I guess I would call my style "class-dominant functional-first." I also really like C# - Scheme was my first language, but C# was my first OO language. And this feature seems like a really bad idea. AFAICT, the two most compelling arguments for doing this are 1) It's annoying to go and have to change all the classes that implement an interface if you go and add a new method. 2) This makes higher-level type-based programming easier in C#. I couldn't get through the rest of the thread to find anything else so there is almost certainly something I am missing. I also DID NOT READ THE PAPER THAT WAS CITED so there could be something about trait-based programming in .NET that's really useful which I am missing. 1), frankly, strikes me as a terrible idea. If you change your interface, it absolutely should break the classes that inherit from it. The programmer changed the contract and she should be forced to go to all the classes and do some work in them to make sure they respect the contract. Sure, add tooling to make this easier - such as the perfectly fine abstract class that exists. The higher idea is that the compiler should force you to do a code review in this situation. And in general, the Single Responsibility Principle is a good idea in both class design and language design. Trying to squeeze implementations into interfaces seems to me to be unnecessary cognitive overhead - and I hope my example below shows that how cognitive overhead can lead to worse software. 2) is a bit more interesting, but I think the gains are extremely paltry The C# Semigroup/Monad example is actually a bit too cute. By showing how this feature works nicely with a very general mathematical structure, they hide how it can go so wrong for an actual piece of software. Semigroups and Monoids by their nature care very much about the business logic of the underlying abstract type. This is not true in general. Sometimes you will have a generically-typed interface with radically different implementations based on the underlying type. Here is an example, written in pseudo-F# but intended to be .NET agnostic: type IComputationService&lt;'TData&gt; = abstract GetAverage: seq&lt;'TData&gt; -&gt; float type SimpleComputationService() = interface IComputationService&lt;float&gt; with member __.GetAverage input = Seq.average input // Earlier we defined a custom WeightsAreAllZeroException // it exists because the weights of a nonempty weighted data series // should not all be zero. // If we come across it, we want to raise this specific exception. type WeightedSimpleComputationService() = interface IComputationService&lt;float * float&gt; with member __.GetAverage input = let sumWeights = input |&gt; Seq.sumBy snd if sumWeights = 0.0 then raise new WeightsAreAllZeroException() (input |&gt; Seq.sumBy (fun (a,b) -&gt; a*b)) / sumWeights To be clear: the WeightsAreAllZero custom exception exists because a DivideByZero exception is not descriptive of the actual problem - if the weights are all zero, something else went wrong in your program and you need to know that. But let's say we want to change the interface to have a default average method: type IComputationService&lt;'TData&gt; = abstract GetAverage : seq&lt;'TData&gt; -&gt; float GetDefaultAverage (input : seq&lt;'TData&gt;) (numeratorGetter: seq&lt;'TData&gt; -&gt; float) (denominatorGetter: seq&lt;'TData&gt; -&gt; float) = (numeratorGetter input) / (denominatorGetter input) So in a lot of ways this is a nice trait-based functional way of doing things, right? We said in our type that an average involves a division of some numerator and denominator calculated from the input data, and how those numerators and denominators are calculated is up to the caller. Let's say we've decided to almost always use the GetDefaultAverage method with supplied numerator/denominator funcs, and only use the GetAverage implementations for legacy purposes. let mySimpleAverage = (new SimpleComputationService()).GetDefaultAverage [1.0;2.0;3.0] List.sum (List.count &gt;&gt; float) let myWeightedAverage = (new WeightedComputationService()).GetDefaultAverage [(1.0,0.0);(2.0,0.0);(3.0,0.0)] (List.sumBy (fun (a,b) -&gt; a*b)) (List.sumBy snd) mySimpleAverage works, but myWeightedAverage will throw a DivideByZero --&gt; NOT the WeightsAreAllZero exception you really wanted. That was an important part of the logic of WeightedComputationService, and the developer just hid it by trying to be too clever with polymorphism :( If the developer had used WeightedComputationService's GetAverage method, there wouldn't have been a problem. But by using the interface implementation, the burden is on the developer to go and make sure the interface actually still makes sense for the class. The compiler is pretty quiet about it. And yes, there are ways to mitigate this. But I hope the idea is clear. Having dependency go signature =&gt; implementation via interface =&gt; (abstract) class should be a one-way street. Loosening that introduces new types of weaknesses and I am not sure the use case is sufficiently compelling. 
They're turning C# into Scala. I don't know how I feel about that.
In what way?
Traits!
I have tried to stay out of this debate :) but this just strikes me as some C# devs being lazy and missing the point: &gt; Adding a new method would require changing every class that implements it! One of the points of this feature is that you can add to a base interface without changing its implementations. I see no tangible upside for this other than "it saves me some work, especially when I don't feel like refactoring things out into an abstract class." The downsides are vast. When you write a class that implements an interface in .NET, there's an implicit *human* contract there that says "a developer looked at this interface, considered it carefully, and wrote a class that implemented it appropriately." This will be severely compromised by having default interface methods. Here's an example: type Sketchiness = StillGood | ThrowItOut type SaladIngredients = | Lettuce | Tomato | Cucumber | LiteItalianDressing | BoiledEggs | Mayonnaise of Sketchiness type ISaladService = abstract MakeSalad : unit -&gt; seq&lt;'TIngredients&gt; type BasicSaladService = interface ISaladService with member __.MakeSalad = [Lettuce;Tomato;Cucumber;LiteItalianDressing] // Here the caller calls EggSaladService by first reporting whether the mayo is StillGood or ThrowItOut type EggSaladService(mayoSketchiness:Sketchiness) = member __.MakeGoodSalad() : seq&lt;SaladIngredients&gt; = match mayoSketchiness with | StillGood -&gt; [BoiledEggs;Mayo StillGood] | ThrowItOut -&gt; failwith "the mayo is bad!" member __.MakeBadSalad() : seq&lt;SaladIngredients&gt; = match mayoSketchiness with | StillGood -&gt; failwith "the mayo is still edible, we can make good salad!" | ThrowItOut -&gt; [BoiledEggs;Mayo ThrowItOut] interface ISaladService with // we call MakeGoodSalad by default and want it to fail if the salad is not good // if someone is calling this as an ISaladService they might not be aware that bad mayo is bad for egg salad // That is an implementation detail we would expect EggSaladService to handle member this.MakeSalad() = this.MakeGoodSalad() Now, let's say a developer has been working on EggSaladService in a separate .fsproj file for a while. That dev understands egg salads as a business object and has carefully implemented methods for handing egg salads. In a whole separate F# project, someone else has been making [BoiledEgg, Mayo StillGood] salads separately, in a static method, while implementing ISaladService more specifically for other salads. They aren't aware that the EggSaladService exists, but they do need such a service. Reasoning that egg salads show up a lot in whatever other salads they're using, they add this to *ISaladService* member this.GetEggSalad() = [BoiledEggs, Mayo StillGood] So the default egg salad is a good egg salad. The developer who was writing the EggSaladService *will not necessarily see this change even if their code base is up to date.* After all, that would be "annoying" - only dweebs and squares want to break classes just because you broke something earlier in the inheritance chain. So, a third dev, up to date, has access to EggSaladService and the updated ISaladService. They have a MayoWatcher that reports the status of the mayo, and at some point call new EggSaladService(ThrowItOut). Then they call *GetEggSalad()* on that method instead of GetSalad - hey, it showed up in Intellisense, seemed like the obvious choice. So even though the mayo is in fact bad, somehow your program is making egg salads with fresh mayo. I am cranky about this but I hope the example makes it Yes the VP of Tech at this company has human-oriented work to do around communication. And yes the exact same thing could happen with abstract classes, or even two conflicting EggSaladServices. But the really nice thing about .NET is that the languages help make that communication a lot easier, in both design and idiom. I don't think we should be making things more difficult for ourselves here. When you change an interface, the compiler should yell at you and make you change the classes that implement it. This isn't the compiler being difficult, it's helping you. It's basically forcing you to do a code review. Method implementations that "look" generic at the interface level might have surprising pitfalls at the class level - you can use Seq.length on a seq&lt;int&gt; but you might not want to do it with a seq&lt;ExtremelyShakyConnectionToARemoteDatabaseWithCrappyErrorHandling&gt; 
After initial struggle with operators syntax I've found this library very powerful and expressive. 
Beware using Hopac if you're not prepared to pay for commercial licenses (for non-commercial use), other projects from the same creator are moving to non-standard licensing schemes. E.g. &gt; The same constraint applies for the API signatures and general design — a commercial license is needed if used in conjunction with any/all Microsoft web stacks In reference to the use of [Logary](https://github.com/logary/logary/blob/master/LICENSE.md)
[removed]
Haf is not Hopac's author so this is not the case there.
My mistake, I misremembered that + the latest commit was from Haf which confirmed it when I checked. And I thought I did my due diligence...
&gt; P.S.: I tried to apply this method for the SQLProvider, but couldn't understand the path to place de .so file. Just FYI, it looks like that link is for Mono, and not .NET Standard / Core. So the info there might not be very useful for you - and definitely the references will be very different. This is confusing if you're new to .NET so if you have questions feel free to ask. It is true that you need to target netstandard2.0 to get type providers to work. For the "namespace 'Data' is not defined error" - this could be any number of things, from a trivial problem where you need to add 'open FSharp.Data' to a serious configuration issue. Could you show us your code? I am assuming there's an .fsproj and probably a single .fs file. Hopefully it's a quick fix. If not...I haven't used F# on Linux much and hope someone can jump in a with a more helpful answer :)
Yea I think it's by Vesa Karvonen
SQLite on SQLProvider on .NET Core on Linux? Oh wow, you've chosen probably [the *single most complicated* thing](https://fsprojects.github.io/SQLProvider/core/netstandard.html) that you can do with a F# project, when it comes to tooling. The reason it's so mesy is that you basically need to janitor library and framework dependencies twice, separately, for compile-time and run-time. The SQLProvider library is build to handle multiple different databases, so it requires you to provide the correct database libraries manually, and the SQLite libraries are particularly troublesome due to the mix of native and managed code. It can be done, minus the SQLite part (I'm using it in production, with a CI/CD pipeline as well), but it's not trivial, the support is still in active development, and you want to have a good understanding of the .NET build pipeline to handle any surprises. If you're only writing a toy project to play around with F# and type providers, which is what it sounds like, my recommendation is to install PostgreSQL and use [this type provider](https://github.com/demetrixbio/FSharp.Data.Npgsql) which has a much simpler architecture. Follow the instructions in the 'Target platforms' section carefully and you should be set. 
I'm trying to extend the [fable-compiler code](https://github.com/fable-compiler/samples-browser), more specifically the redux-todomvc which is a simple todo list
Thanks for the very good explanation of my issue, it helped me a lot to understand it. That's way more complicated than I thought using SQLite, I'll give your suggestion a try
I'm making an API wrapper for Reddit.
Chat bots, NLP and AI.
What impact might [blazor](https://blogs.msdn.microsoft.com/webdev/2018/03/22/get-started-building-net-web-apps-in-the-browser-with-blazor/) have on the stack, and web programming with F# in general? Is anybody thinking about "blazor-elmish" yet? Also, what if I wanted swagger-style documentation for an API that I wrote using SAFE? It seems like it would be pretty easily generated, right?
I'd like to hear more about the Typescript-Fable interop story. Typescript has a huge, growing ecosystem of .d.ts files, and F# supports most of Typescript's type system, so that's a very attractive argument for Fable. Interacting with JS libraries is a big part of frontend development, unless you want to write all your fancy controls from scratch. But, the status of ts2fable isn't very clear from the docs. Is it an official part of Fable or just a third-party project hosted in the repo? Is it aiming to become an all-in-one tool that immediately generates usable Fable interop modules (and if so, how close is it to that goal?), or is it just supposed to be an initial rough draft generator that will always need manual work to compile? Most importantly, is it what the (few) professional Fable developers are actually using to interact with JS/TS libraries right now, or do they prefer to go untyped?
ts2fable is as official as anything is in OSS, but TS is object-oriented in its definitions. It is not ergonomic/idiomatic from F# perspective so I don't think you'd ever want to use what it generates AS-IS.
The mysterious ncave has F#-supporting fork going (sans all the Razor): https://github.com/ncave/dna-redux but DOM/JS interop story is just too murky for me at the moment. In terms of swagger, AFAIK only ASP.NET (reflection) and Freya (machines) APIs can even be subjected to the analysis at runtime required to comeup with the information needed to generate the swagger info. If swagger docs are imperative, you could write your APIs with ASP.NET and attribute with swashbuckle - can confirm, this approach works.
F# is a fairly complex language syntax-wise, so you're not going to find a "simple" parser for it, unless you want a pretty minimal subset. See how complex the [lexer](https://github.com/Microsoft/visualfsharp/blob/master/src/fsharp/lex.fsl) and [parser](https://github.com/Microsoft/visualfsharp/blob/master/src/fsharp/pars.fsy) from the F# compiler itself are. That being said, depending on how close to actual F# you want to be, you might have more luck finding a parser for OCaml.
High-level: yes, learning event programming in F# is a bit of a mess. I think part of it is that "event" is an overloaded term in .NET, particularly in F#. So when you're "learning about events" there's a hurdle in learning about the .NET CLIEvents vs. F#-specific Event&lt;'T&gt;s, for instance. Likewise there's a balancing act in how event programming evolved throughout the development of .NET, and the need for F#/C# interop. Another problem is that F# gives you a wealth of event abstractions and implementations, from the MailboxProcessor&lt;'T&gt; which uses a functional-first agent architecture, vs. doing things with old-fashioned C# delegates. Here are my suggestions for getting started: * Tomas Petricek has written a number of blog posts and MSDN articles specifically about MailboxProcessors - e.g. http://tomasp.net/blog/agent-event-reporting.aspx/ * This might be good for your particular use case: it doesn't sound like you're doing an event-sourcing architecture per se but having a concrete implementation is something I always find useful: https://blog.2mas.xyz/fsharp-event-sourcing-and-cqrs-tutorial-and-agents/ * If you're just getting started: the GUI programming sections in Expert F# 4.0 had nice, accessible event-driven programming, which I think can teach enough of the basics to get going. Plus it's really nice to be able to whip together a simple desktop UI when you're learning a language. &gt; (Aside: how performant are F# events?) It depends on what you mean by F# event :) I will add that someone here certainly knows more about this than I do: You can define an F# type that's as performant as event in C#. So slower than C++ but easier to program, faster than Python...and also easier to program. In terms of raising/receiving events, I believe a lot of that code is actually native and quite performant, at least on Windows. *Processing* events can be a bit of a coin flip... it depends greatly on the work being done by the agents, and sometimes clock speeds in .NET concurrent processes can scale unexpectedly. .NET Framework's garbage collection can often blow up, for instance. Unfortunately a lot of my event programming has actually been in the cloud, so single-machine benchmarking for .NET isn't something I'm familiar with. For agent-based event programming with MailboxProcessors: as a .NET class, the MailboxProcessor is fairly lightweight and a modest program can easily handle tens of thousands of them. OTOH, they are not designed for consistent CPU intensive work - they are more designed to be mostly idle until needed. I think having a lot of MailboxProcessors constantly streaming something while handling subscriptions is not the best use. Given that multiple clients will probably subscribe to a single image stream, you might want to separate out subscriptions from streaming - MailboxProcessors would be an excellent choice for subscriptions and you might have to get your hands dirtier with the stream. But I guess I'm not sure what the intent is - if the MailboxProcessors are simply returning a *handle* to a stream then they could be excellent for this. 
Thanks for the answer. Wow, that's a pretty big parser, I did not expect that. What I like in F# is the indentation-sensitive syntax, the possibility to name the fields of algebraic data types (without introducing a record type), and to use optional parameters and named arguments. But given your answer, I think I'm better off starting from a simple ML syntax and adding these features to it myself.
Right now I'm working on figuring out why my post to this forum was deleted even though I messaged the mods to ask what I did wrong. I'm also working on a blog entry with a few F# tips. I might grab one from that recent post here. I want to get back to FParsec and my analysis compiler project sometime this month. It was a fun little side project. I was learning a lot.
You might want to look into reactive programming. F# events with observables are a form of reactive programming. See the following resources: http://fsprojects.github.io/FSharp.Control.Reactive/ https://css-tricks.com/animated-intro-rxjs/ http://rxmarbles.com/ 
&gt; Right now I'm working on figuring out why my post to this forum was deleted even though I messaged the mods to ask what I did wrong. I'm a mod. Looks like it may have been flagged to require explicit approval which I've given and it looks like people are replying so it is visible. Thank you very much for your contributions. &gt; I'm also working on a blog entry with a few F# tips. I might grab one from that recent post here. Excellent. Keep up the good work! &gt; I want to get back to FParsec and my analysis compiler project sometime this month. It was a fun little side project. I was learning a lot. Me too. :-) 
Thank you for replying. It's still not working. Shows up fine when I'm myself. Coming in as somebody else, I got nothing. But that's okay. It's no big deal. I had just promised to update people on when those F# videos came out. I'm sure they can find out other ways. I was more concerned that I had done something wrong and wanted to apologize and fix whatever it was. Looks like I still don't know what I did to end up in the spam trap. Maybe I'll try again with a F# blog article sometime and see what it does. FParsec is odd because it makes total sense to me -- but I still end up struggling when creating non-trivial implementations. Maybe this next time will do the trick!
&gt; It's still not working Just to check: are we talking about this post? 
[This one](https://www.reddit.com/r/fsharp/comments/8w08te/update_on_the_uncle_bobclean_coders_f_case_study/) Like I said, no big deal. I don't want to become known as a complainer. I just thought you guys were mad about something I did -- wanted to fix it so I wouldn't do it next time.
There was a discussion with Uncle Bob about type checking on Twitter recently. He really didn't seem to understand the fundamental purpose of type checking. 
Oh, I was looking at the wrong post. Sorry. I have approved it now. &gt; Like I said, no big deal. I don't want to become known as a complainer. I just thought you guys were mad about something I did -- wanted to fix it so I wouldn't do it next time. No worries. I really want content like that here. I think it is really valuable. 
This was the crux of the problem as we shot the videos. You guys were kind enough to point that out afterwards. At the time I was not trying to teach anybody anything. I was more interested in how Bob and James's mind worked. The type system and immutable code eliminates all kinds of problems the OO guys have. Although I read a wag on HN recently say something like "But that just pushes the problem to somewhere else" I need to think about that comment some more.
The only idiomatic way here is the first one, the rest are pure obsession with not typing `FooType.foo`. It is the same syntax for classes, objects and modules, so I guess I don't get the purpose of avoiding it. I mean, it's nice that you learned about the other features, but those have other use cases. If you truly want it to be shorter, you could check out type extensions instead, which let you turn it into a property `"hello".Foo`.
I used several type extensions in the code already. I even thought about taking it as far as you show. But that wasn't the point. The point was to talk about getting stuck, something not looking right, and how to think through learning more about the problem. If I had gotten as reductionist as your comment is --- there would have been no point in writing the article to begin with. Somebody could just google around. All of that stuff is already out there in various places.
I'm not saying the things you learned aren't valuable, I claimed the opposite in fact... But the start of the post is particularly confusing. At first you say: &gt; [In other languages] You write two different functions with the same name that take different parameters, then you just call it. The compiler figures out which one to use. Yeah, that’s not going to work in F# But then you proceed to show that it *does* work in F#, when using methods instead of pure functions. Same rules as in C# (where "pure functions" would be delegates). Code afterwards then dismisses it and covers interesting ways to use F# features and type system instead. That in itself is fine. I'm just confused by how the start of the post ties in to the rest. The way it goes from "F# doesn't have overloading" to showing that it has and then kind of dismiss it, it put me off. I think that the start doesn't set the right expectations about the post, not that the content itself is bad. Don't get me wrong though, it's great that you learned in depth about F#'s features and showed them off. Although I take offense about your _reductionist_ call out, as you won't see me claim that learning and exploring is worthless. I just didn't really see where the post tried to lead into, and left me wondering if you had really found the solution you were after.
We may be violently agreeing. Either that or we're headed towards a discussion on semantics. Beats me. F# does _not_ support bare-bones function overloading the way other languages do. Instead, you can make something that looks like it happen by jumping through various hoops. The reasons the hoops are there are very interesting and playing around with various configurations of code lets you learn more about why things are the way they are. So both statements are correct. You can't do it -- and it's possible. Both statements can be correct simultaneously because it is possible _given a whole lot of other syntactic dancing around_. Sorry about applying the adjective reductionist to your comment but we seem to be headed down this same road with your insistence that it be one way or the other, that it supports it or not. The answer is more nuanced than that. And fun to learn, too. In my opinion that's what makes it fun. Who would have guessed that HM is related to function overloading? Not me. I appreciate your feedback. I'll go back with fresh eyes tomorrow and double-check to make sure I'm clear on intent. It is a wrapper essay, with a few paragraphs at the top and bottom giving context to the material in-between. It's very important to be clear in that kind of situation. Apologies if I screwed it up.
Don't worry, this has resulted in an interesting discussion. That already makes it worthwhile! Oh, and I think I see where this one is going. So let my try to explain something: F# makes a difference between methods and functions. Semantically speaking, functions are plain variables bound to a function, so they can't be overloaded in the same sense that `foo` can't be overloaded in `let foo = fun x -&gt; ...`. It's just a normal variable. But methods are different from functions. The former are members of a class, and have the semantics you're used to from other languages. This is where your first example comes in: type FooType = static member foo(x:int) = ... static member foo(x:string) = ... This *is* how methods and overloading look in F#, not any kind of hoop. That's declaring a class with overloaded static methods, and it is 100% equivalent to the following C# class FooType { static void foo(int x) { ... } static void foo(string x) { ... } } Note that the previous distinction is true of all other languages with first-class functions you have probably used, too. In C# for example, there's no way to have an overload on `Action&lt;int&gt; foo = x =&gt; ... ;` because it is a variable, not a method. But the above code of course does. So F# modules can contain types and variables (including variables of function type, `'a -&gt; 'b`), but not methods. Those require you do declare a type instead. It just happens that in F#, the default is using modules and functions instead of class methods, because they fit the language better and help a lot with HM inference. Namely, HM can't decide on a type when a parameter is overloaded on multiple types; without any other type hints, type inference fails. Finally, keep in mind that both F# and other languages, such as C# or Swift, have *both* methods and first-class functions as somewhat distinct concepts and exhibit this behavior. But none is a lesser construct, F# just prefers the "other" one. --- Sorry for the long post. So, I was getting really confused because you had already found the actual feature of F# that lets you declare methods (as opposed to functions) and have method overloading, so I felt I was missing something.
Cool. Thanks. I believe you are repeating what I was saying, only using language I wouldn't use for new programmers. If not, I'm completely missing it. My essay was about the journey, not the math. I love the way you've put this. It would make for a nice conclusion to the fun. If I could figure out how to work it in. Being a tech coach, I'm as interested in the people as the tech. Probably more so. There's something, well, _fun_ in playing around with F#. I don't find it in other languages. You get the feeling that the more you play with it the more you learn stuff. That's the magic I'm trying to convey to the reader. It may end up being a series of essays, frankly. I've had a hoot on all sorts of adventures in F#. (BTW, when I started F#, there was one book. I had to buy the OCAML books to get going. That back when dinosaurs ruled the earth, kid! (shakes cane)) You weren't missing anything. I was purposefully looking at it from the standpoint of a new coder going "Gee, that doesn't look right!" Don't get me started on my wish list for F# (Full-featured module system, maybe? Programmable type system? Data as code without having to use reflection and honking with the compiler?) but to me that's much less fun than playing tour guide with folks just getting started. Thanks for the good overview. Looks spot on.
I find discriminated unions to almost always be good enough for function overloading, cf. http://blog.ploeh.dk/2013/10/21/replace-overloading-with-discriminated-unions/ The nice thing, semantically, about discriminated unions is that they encapsulate the scale of your overloads in its own type, which acts as a sort of contract on what overloads make sense in the context of your program. So, e.g., let's say you have (in OO-pseudocode) double getRandom() = rand(); // random double between 0 and 1 double getRandom(double maxValue) = maxValue*rand(); double getRandom(double minValue, double maxValue) = minValue + maxValue*rand() double getRandom(int startingSeed) = … // In F#, you can start with the DU type RandomDoubleOption = | Basic | MaxValue of double | MinMax of double*double | CustomSeed of Int And then getRandom is implemented as: let getRandom (inputType:RandomDoubleOption) : double = match inputType with | Basic = rand() | MaxValue (v) = rand()*v ... There are contexts where the old-fashioned OO overloading syntax makes sense - particularly in systems programming. But this F# workaround is expressive, and if you design it right you can make *compositional* function inverses (e.g., extend RandomDoubleOption to have Composition of RandomDoubleOption * RandomDoubleOption)
I guess I felt off about the correct/idiomatic solution being the first one, and then seeing the post continue. I didn't know what to expect from the post from there. But don't let my comments and "well, actually"s discourage you. You definitely show passion about this! I like teaching, but I admit I'm not a "people person". So I'm sorry if I sounded rude. Yeah, I too have my own wish list for F#. When I have time, I skim over [fslang-suggestions](https://github.com/fsharp/fslang-suggestions/) and [fslang-design](https://github.com/fsharp/fslang-design/) and leave feedback when I see a proposal that I think is going astray. But the team doesn't have much manpower and they're very conservative about adding features to the language, so I fear that it will get stale eventually. I'd just be happy if they removed a handful of quirks and made some changes to reduce the number of allocations, as I'd love to make videogames and desktop/mobile applications in F#.
I've seen either this essay or a similar one to it in the past. I love it. It's a great example of "growing a type", i.e., figuring out that there's a hidden DU type in your code that you've been overlooking that enables composition and so forth. To me this is a more advanced topic because the key thing going on is pulling out the Period DU and then making the other members private. I thought about adding this in, but it seemed to distract from theme by adding more complexity in. I wanted to stay away from OO-like things. I see far too many new F# coders start splaying classes all over the place before they really understand the problem they're solving. (Insert rant here)
In my view, the key to working effectively in a programming language is to work *with* the grain of the language, rather than against it. That means not bringing preconceptions with you, and being open to discover what the "grain" actually is. For example, the way I program using F# is different from the way I program in Python, which is different again from the way I program in Smalltalk, or Prolog. So when you way *"their instincts were always leading them down rabbit holes"* I interpret "their instincts" to mean "techniques that they were familiar with from a different paradigm". Nor surprisingly, that is not particularly effective :) One of the nice things about being experienced with different paradigms (and why I recommend it so much!) is that when you find yourself falling into this trap you can recognize it and do a reset. As to the equivalent of a rapid development process in a language like F#/Haskell, I would say that it is: * understand the domain * write some types that model the domain. * get feedback, then change types and fix compiler errors as needed. * prototype some functionality using those types * get feedback, then change types and fix compiler errors as needed. * repeat from step 1 This process is not Big Design Up Front, as this cycle can be very rapid, taking minutes or hours, just like TDD. However it does involve *thinking* before coding -- something that TDDers often sadly ignore. (Aside: I was once so frustrated by this that I wrote [this post](https://fsharpforfunandprofit.com/posts/roman-numeral-kata/).) 
Thanks Scott. I don't have any of the answers. Heck, I'm not even sure I have any good questions. :) In the XP community, we talk about code smells a lot. Working with The Bobster and James, I realized that F# has its own code smells that are different from, say, Java. Using "mutable" would be one. Creating C#-like classes right off the bat would be another. We're stuck incrementally understanding a domain. The old joke is you never understand the problem until you've finished coding the solution. There's some truth to that, especially in fast-paced environments like startups. I'm hoping I can write some essays to help get my thoughts sorted a bit. If nothing else, maybe I can come up with better questions! I'll take any feedback you can provide. It is much-appreciated.
&gt; I'd just be happy if they removed a handful of quirks and made some changes to reduce the number of allocations, as I'd love to make videogames and desktop/mobile applications in F#. That's precisely what we're doing :) [F# 4.5 set of features](https://github.com/fsharp/fslang-design/tree/master/FSharp-4.5) The big one there is all of the work to properly support `Span&lt;'T&gt;` and proper `byref` programming. The rest is cleaning up some of the quirks, like no longer needing to indent the closing `]` or `|]` brace for list and array expressions. The corresponding [FSharp.Core](https://github.com/fsharp/fslang-design/tree/master/FSharp.Core-4.5.0.0) is also primarily about cleaning up async stack traces, since they're pretty incomprehensible today.
As a follow up, I should mention the [XY problem](https://en.wikipedia.org/wiki/XY_problem) which is particularly common for programmers. E.g. see this [StackExchange comment](https://meta.stackexchange.com/a/66378). In learning the functional paradigm, this happens a lot. For example, people say "how do I write a for-loop?" rather than "how do I iterate over a collection?", or "how do a write a class?" rather than "how do I group common functionality together?" When learners say that kind of thing, I always stop them and get to focus on the *problem* that they want to solve, rather than assuming the solution. In my experience, that helps to prevent the frustration of going down rabbit holes.
Oh, I know! Just today I was catching up with the new RFCs and proposals. I meant that *just* those two things would make me much happier. Congrats on the effort to everyone involved BTW!
Thanks! Hopefully it is something people enjoy.
Wow. This brings back some of the pain. They struggled quite a bit with XY. In TDD, many times you'll code out a class or method incrementally, starting with the "zero" case, then handling one item, then many.... This is called the ZOMBIES pattern. Zero, One, Many, Boundaries, Interfaces, Exceptions, Scenarios. So they kept trying to to code in that fashion. It took me a while to realize that in FP as much as I can, I'm working with _vectors_. I don't wanna no to be worried about all that crap. If the vector code works, it works. (There's a long discussion here about the onion architecture and total programming. It's for another day.) But by tying to "pre-solve" the problem using tests -- which is what you're supposed to do -- it was actually making the coding much more painful. I hate to say it, but they were lab rats and it was a useful learning experience.
thanks so much for the thoughtful and helpful response. sorry for being slow getting back here. yes, i agree that due to the overloaded term of event in .net with f# have its own event programming it is even more confusing. this is additionally confused by the observable module and event module in f# (i was reading about this in the *real-world functional programming* book). &gt; Tomas Petricek has written a number of blog posts and MSDN articles specifically about MailboxProcessors - e.g. http://tomasp.net/blog/agent-event-reporting.aspx/ i have read that article before, but it only unfortunately partially cleared things up. it was this article and in particular his line of "sometimes the agent also needs to report some state change that can be handled by another interested agent. This is done using F# events" that led me down the event path. in the actor model, all communication is typically done via actor messages, but it seems in f#, it is better to use events, at least according to petricek. &gt; OTOH, they are not designed for consistent CPU intensive work - they are more designed to be mostly idle until needed. I think having a lot of MailboxProcessors constantly streaming something while handling subscriptions is not the best use. this is a bit concerning and contrary to my experience using the actor model in another language, which makes me worry about f# now. see below for some more clarification of what i'm trying to achieve. maybe you will have some suggestions of what to do. &gt; I guess I'm not sure what the intent is my goal is to do instrument control via f#. this is something i already do in another language, utilizing an actor framework. a toy example that illustrates what i already do in this language is a camera application. all actors are represented by value-based objects (so basically f#'s records with members). the oop is limited in that only single-inheritance is allowed and it doesn't have interfaces. the framework is designed so that all actors inherit from a single actor class and all messages inherit from a single message class. in this toy example, there might be three actors: * camera: does nothing but acquire images (say at 60Hz) and streams them out to subscribed actors. can accept messages to adjust its settings, such as exposure time. * logger: simply subscribes to the camera stream and logs the images. * controller and gui: manages the application and user interface. it launches the camera actor upon startup, subscribing to its image stream. the image stream is 60Hz, but the controller and gui actor only publishes the images to the screen at around say 10Hz. then when the user hits "capture", it dynamically launches the logger, which then subscribes to the camera's image stream itself, logging the data at the full 60Hz rate. when the user hits "stop capture", the controller and gui actor asks the logger to stop, which then unsubscribes itself from the camera's image stream and then stops. all the data streaming, subscribing, unsubscribing, settings, etc. between the actors happens via actor messages. i could obviously do this in f#, but i have seen events suggested for the streaming multiple times. so my idea has been to use f# MailboxProcessor messages (both synchronous and asynchronous) for the settings, stopping, etc. but then events for data streaming. the above describes a general setup that i have used but for many more instruments. but the idea is the same in that various pieces of hardware are modeled and interfaced via actors, which respond to various settings messages (such as exposure time), and then the hardware (some but not all) streams out data, at possibly relatively high rates. i normally have multiple timed loops that execute rather reliability with ms timing (usually 10-200ms loop iteration times). i would now like to do the same thing in f#, but i am having trouble with the architecture. i am relatively new to f# in terms of production code, but i unfortunately need to use it's more advanced features, otherwise, it will be of no help to me by using it to do little one-off things. my biggest problem right now is how to do the data streaming. i think setting settings using asynchronous message and even requesting properties of hardware using synchronous messages is doable already with my tests of the MailboxProcessor. but it's the data streaming that has me worried. also, oop handles hardware abstractions really well since hardware APIs are always session or connections based. so moving from an oop-based actor architecture to f#'s more hybrid approach leaves me a lot of design room. i'll have to pick something though. i am not worrying about the UI in f# right now. the UIs are too complex for me to completely jump ship to f# or c# (primarily due to the learning period). so i will end up wrapping my application written in f# with a single class and exporting it as an assembly, which my current application will then call and then wrap a UI around. the class will abstract away all of the actor stuff going on underneath and will simply provide methods to set various settings, change states, and then get the status of the application (all the hardware basically). thanks for any additional feedback you can provide!
the language i am moving to f# from is a dataflow language, so i am familiar with these concepts (and also the term in general). i build applications using a dataflow oop-based actor framework. actors are value-based classes/objects that just sit in a while loop listening for messages. when they receive one, they process it, and then pass the new object state to the next iteration of the loop. do you know how the FSharp.Control.Reactive compares to the built-in observables and events in f#? i have heard of it but not looked into it yet because i was trying to stay away from non-native packages (hence my staying away from akka.net at the moment) to try and reduce complexity. since i am new to f# with regards to large project architectures, i was trying to keep it simple. however, this does seem worth at least looking into for my use cases. thanks!
The library adds a lot of extra functions to observables. Without it you might find them a bit bare. You could write them all yourself, but it is easier to use that library.
I haven't heard ZOMBIES before, but it sounds ass-backwards to me :) I prefer to get the scenario *as a whole* working, and then tweak as needed (e.g. changing something to return an option, and then seeing how that affects the rest of the pipeline). This is what I mean by TDDers iterating over test cases rather than iterating over functionality. I go into this more in the Roman Numeral kata post I mentioned. And [here's a well-known illustration that I like](https://i.pinimg.com/736x/40/95/d4/4095d49512cbeb8897f8e90bbfa5b4cd.jpg) that shows the difference.
Well the idea here -- and I hate to rag on mutable/OO code because it's how I started and my first love -- is simple: _I can't look at the dang code and tell what's going on_. OO gives you this wonderful illusion that you can reason about what you're looking at. But a graph of complexity at all, with all the holes most coders leave in it, that's a lie. This is where TDD comes in. The basis of the theory is that the tests drive out the code, they don't verify it. (For this reason I prefer to call it Test-Driven Design, because that's the real role of the tests: incrementally driving out and verifying the design) So the ZOMBIES thing makes total sense from that angle. If you ever get a chance to sit in on James's embedded C/TDD class it's well worth it. Only by strict adherence to the TDD loop can those coders know that the code actually performs as expected. There are a ton of side-effects from designing incrementally from the ground-up like this. For instance the tests become more important than the implementation. Also creating the tests is where the design happens. The link's great. Bob asks me in the first episode why I love F# so much and I told him it was because of Lean Startup. Functional code is always asking: what are you doing for me right now? Whereas OO code always seems to be asking: where does all of this stuff go? I don't he got it.
thanks. i actually had started reading an rx book i bought on kindle a while ago. definitely seems applicable to me. it’s kind of funny. coming from the dataflow world to the functional world, there’s all this hubub about immutable this and reactive that, but it’s all aready totally natural. the struggle is really about getting the practicalities down. which is unfortunately a bit of a learning curve. thanks again for the pointer.
The ideal of "making invalid states unrepresentable" is a powerful one, a solid foundation I think for supporting efficient TDD.
Weren't typeclasses originally added to Haskell in order to implement the equivalent of function overloading and then it was found to be useful beyond simple overloading? 
You could write your own operator: open System.Text let inline (++) (s : string) (c: char) = match s with | null -&gt; c.ToString() | _ -&gt; (new StringBuilder(s, s.Length + 1)).Append(c).ToString() let y = "hello, wor" ++ 'l' ++ 'd' ++ '!' printfn "%s" y
Isn't creating a new StringBuilder every time you append defeating it's purpose? 
That's for your help. I take it by your answer there is no inbuilt operator for the tasks. I don't know why I assumed there was.
The simplest way is probably: "ab" + string 'c' You can do this with any type btw: "ab" + string 12 // -&gt; "ab12" "ab" + string (Some 1.2) // -&gt; "abSome(1.2)" "ab" + string [1; 2] // -&gt; "ab[1; 2]" `string x` is equivalent to the standard .NET `x.ToString()`, except that if `x` is `null` (or a value represented as `null`, such as `None`) then it returns `&lt;null&gt;` instead of throwing NullReferenceException.
Yes, if you're adding several characters then the following is much more efficient: StringBuilder(s) // or StringBuilder(s, s.Length + 3) if you know how many chars you'll add .Append('l') .Append('d') .Append('!') .ToString()
That is definitely handy to know, thanks. I thought I tried ToString and had a compiler error, obviously not.
Yet another option is `sprintf "%s%c"`
Here it is without the StringBuilder: let inline (++) (s:string) (c:char) = new string ([|c|] |&gt; Array.append (s.ToCharArray())) 
Great stuff.
I just realised the irony: these people who are into TDD must be doing it because they're suffering from bugs in which case they are the very people who need to know about types. 
I bought these videos, and I found them very painful to watch. I think it's meant to be illustrative of the problems encountered when changing paradigms, but it just didn't really seem to get resolved in a clean way.
I wish we had either done another six where the issues were worked out -- or not done them at all. But I'm not the expert on making videos, just somebody who likes the language. I don't know why it ended up the way it did. Personally I made progress towards understanding the issues faced by programmers when moving from TDD to FP. But like you said, we never got there and worked through the problems.
It's not just types. I would not underestimate the OO folks. There's much wisdom there. In fact, if you want to talk about types, C++ is probably the place to go, since you can effectively build them from the ground-up if you like. Bob keeps running these blog essays where he compares functional and OO code. He usually ends up with a conclusion that's something like "It's all ones and zeros" (I exaggerate, of course). It's the old "Coding is coding, kid!" reprieve. Don't get fooled by new and shiny things! That's right. But it's also wrong. It kept bugging me because there was something he was missing. In my mind, it's the entire ecosystem around pure functional coding that's the trick. Done correctly, pattern matching, pure FP, and the type system work together to "lock" the code into running only one way. I ran through some TDD exercises in F# a few years ago. What I found was that as I incrementally added functionality, F# required me to "pick up the pieces". I couldn't code just one path through the system at a time. Instead, at the very least, I had to code the path I was working on, call out the rest in a "|_-&gt;" construct, and then throw and error if we ever got there. This is actually one useful thing we accomplish in the videos in all of that thrashing around. Pure FP finally "clicked" for me when I realized it resembled most programming relational databases back in the day. You'd normalize the model, add in the constraints, and then lock down access to stored procs which had business logic. It was the onion model with "types" preventing anything bad from happening. And done well there were no loops or cursors. There are a lot of parallels there. But I'm just guessing. Who knows. I know there's something else going on here besides a Von Neumann machine.
This is a lot of fun to read, but what I would really love to see now is a conversation between the almighty Scott Wlaschin /u/swlaschin and the (also almighty) Robert Cecil Martin /u/unclebobmartin a.k.a. 'Uncle Bob'. Mr Markham u/ExistentialismFTW how about getting them both on stage in front of a camera? I imagine the synopsis in the end might create a wonderful learning experience that would add tons of value to your short video series for F# you published for the clean coders video online shop.
All three of you are fabulous speakers, I want to add.
This reminds me of an incident I noticed a few years ago. One of the big TDD gurus (probably \*not\* Uncle Bob but in that sort of league) had had his first introduction to a functional language. He wrote a blog post along the lines of "OMG, this changes \*everything\*", the implication being that TDD wasn't going to be so much of a "thing" in functional land. The blog post rapidly disappeared again. I like to think it was because he realized he'd built a livelihood out of TDD, a concept which he'd just completely undermined.
This is a great idea -- I would love to set something like this up. Apologies if I sound cocky or prideful, but I really don't think this is an either-or situation. Instead, I think both the Domain and TDD guys bring something useful to the table when it comes to incremental FP app development. That's just my intuition. One of the things I'd like to do over the next year or three is figure out how that convergence happens. But once they start lining up more, sure thing! I think it'd be a hoot. Even sooner, maybe I can get both on a call or Skype and see how the ideas play off of one another. There's some cool conversation there waiting to happen!
Fiddling around with web dev in F#. I tried WebSharper for a bit, and while I thought using type providers and fluent method calls for templating was pretty neat, the whole vars and views and holes thing seemed kind of convoluted to me. So now I'm looking at Suave and using Elm for the front end.
Thank you very much for your enticing words. I will try to follow along and keep an eye on your endeavours.
&gt; three Well, I didn't mention Mr James Grenning because I have never seen / heard him speak. My apologies. ;-D
Different people have different learning styles. You may have to try different things to see what works for you. One thing that always made a big difference to me was having some sort of pet project that I wanted to do with the new language. For whatever reason, it seems like it all comes together once you actually have to make something real. The thing I love the most about F# is that to me, it's a learning language. On my first projects, I was able to bumble through it by just translating stuff I already knew from C#. Then I went back and tried to figure out why I had to use so many "bad" things (mutable state, for loops, and so on) Frankly, I think this taught me more than anything else. I had an perfect ideal version of what pure functional programming was supposed to _not_ have -- and then I wrote stuff and tried to figure out how to make it that way.
[removed]
&gt; Was wondering if there were any communities that revolve around it (like a Discord Server or something) [https://fsharp.org/guides/slack/](https://fsharp.org/guides/slack/)
https://fsharpforfunandprofit.com/ That's how I learned. Great site with great examples and shows how things work in a clear and easy to digest fashion 
Hi! Because F# can work pretty well as both a scripted language in F# interactive or compiled like C#, you have a lot of options depending what you're trying to do with it. If you're familiar with C# I'd try reading and replicating a few people's blog posts, or coming up with a project of your own and getting stuck in? I'm trying ([early days](https://millerdw.github.io/World-Bank-Data-in-FSharp/)) to write a series about using F# for data analytics, once you're comfortable with syntax and arrays vs sequences vs lists etc, give that a go! 
I will second /u/centurijon on F# For Fun And Profit. And /u/ExistentialismFTW is right: the best way to learn F# is to write programs in F# :) Here are some resources that helped me: * Specifically from F# For Fun And Profit, [F# vs. C#](https://fsharpforfunandprofit.com/category/FvsC/ ) might be worth looking at. C# does have strengths relative to F# but seeing the same algorithms side-by-side might help. * [F# Snippets](http://fssnip.net/) has bite-sized chunks of F# to solve little problems, usually presented pedagogically. This is realllly nice for learning in my view. Being able to quickly track down some [basic crypto algorithms](http://fssnip.net/20/title/Project-Euler-182) or even a small [F# version of Tetris](http://fssnip.net/5W/title/Tetris) means you can focus on how F# implements logic which you already understand. * I learned F# when I needed to do data analysis and wanted to interop with existing C# code. The [FSharp.Data library](http://fsharp.github.io/FSharp.Data/) is easy to use and can showcase a lot of the features of the language and of F# Interactive. Doing data analysis in F# instead of Excel won't necessarily expose a lot of the deeper functionalities of the language, but it's a great way to learn. It will also probably make you sneer at Python :) * MSDN is not great for learning without any other resources, but it's a very good reference and is IMO largely beginner-friendly. 
This and the F# forums ([forums.fsharp.org](https://forums.fsharp.org)). You have to become a member, but it's free.
Thank you!!
&gt; Why all the hate on Option types? I feel like I've missed something, who hates Option types?
In my function overloading essay I said "...The only way to fix that is to return an option. And I don’t want to return options from functions unless I’m being held hostage at gunpoint..." It was a bit dramatic and over-the-top. A commenter asked, "I’m very interested in the reasoning behind your strong aversion to writing option-returning functions..." And that's how we got here. Thanks for the catch. I'll put a link in the essay.
Expanding /u/ExistentialismFTW's explanation, here's the "problem" with option types as originally stated: &gt; The problem is when option types start propagating throughout the rest of the code. Then I’m four levels down and I’m having to make all of these decisions that should have been made somewhere else (I agree that that's a problem. Two levels down, okay maybe, four, ehhh...)
At least they're not invisible while shifting the decisions up a level, like exceptions do. 
Only unchecked exceptions. You have the same safety with checked exceptions as you do with option types.
You can See.choose over options etc. Exceptions are a different thing. Often better (e.g. abnormal file not found)
The equivalent to checked exceptions is, I think, a Result type with a DU error type full of novelty defined error cases - which is again one step better than the Exception-based method. 
Check out Chessie (http://fsprojects.github.io/Chessie/). Imho the strength of option/result/either monad is creating a pipeline with bind/apply/lift and handling all errors in the last step (or where appropriate).
I feel like this essay spends a lot of time thinking about a problem for which functional programming already has an idiomatic solution: the monad. The ultimate solution described in the essay feels very much like taking object-oriented code and thinking and translating it into a functional language, instead of using the techniques offered by functional programming.
You are exactly right and I need to do a better job of explaining what the heck I'm doing. I'm explaining incremental type development using XP principles. I am not exercising every language feature with the assumption the reader has mastered or is interested in maximizing their use of the language. Instead, I'm taking the "dumb" approach and doing a little at a time, then adding more features and detail as circumstances merit it. This is "F# coding for stupid people", as the goal is not language mastery, it's adding tiny little bits of usefulness and then learning the language as you go along. I don't know how to respond to the "thinking in OO" criticism. I'd love to hear more about this, as I am actively trying not to do it. I'm certainly not creating a tiered class architecture. Heck, I'm not even adding classes. It occurs to me that I'm going to get it from both sides here. The functional folks are going to look at my code in horror. E-gads! No monads! No HOFs! And so on. Then the OO folks are also going to freak out. Why isn't he creating classes? Where are the tests? How can he expect to control program execution mostly through types? Everybody has a point here. And I don't claim to be anything but a crappy programmer. This, more than anything else, has me convinced to continue writing. I also don't claim to be doing this the correct way. I claim to be explaining the thought processes I go through when coding. That's it. And those thought processes end up with monads. So let's incrementally develop some good places where monads can help. We can also talk about how jumping directly to monads isn't what I consider the best thing to do (in F# at least), and why. (Haskell is a different story entirely) There's a lot of purposeful dumb stuff going on here. I think it's fair to call it out. But there's a reason for it. It may be a horrible reason, but I'm not doing it the way I'm doing it because I'm ignorant of all this other stuff. Thank you. Please keep the criticism coming.
Yay! Thank you! This is most excellent. I really want to get to using this along with railway-oriented programming as a side-by-side deployment option to true microservices. If I can get there, this is what I'll use for validation.
I thought a lot of chessie's features have been incorporated into fsharp.core since?
I confess to being horribly behind in .NET and F# news. Is anybody maintaining a good up-to-date resource on .NET and F# core? What with all the different work being done with different branding, with the collapsing of some libraries into core, I lost track of it. I'm still using Mono on linux. Should I switch to .NET core? Is the PowerPack still out there? There are a lot of little pieces to try to track.
Yes, F# 4.1 added a standard `Result&lt;'ok, 'error&gt;` type as well as a `Result` module with most of the basic functions like `map` and `bind`. I think Chessie predates all of those. If you make heavy use of the `Result` type, I recommend the `Cvdm.ErrorHandling` library, which is a very simple project that provides `result { }` and `asyncResult { }` computation expressions for syntactic sugar. We use that at work in conjunction with liberal use of a `Result.ofTry : ('a -&gt; 'b) -&gt; ('a -&gt; Result&lt;'b, exn&gt;` wrapper for unsafe code (mainly I/O stuff), and it works very well. 
Thanks for explaining more what you're trying to accomplish. I see now that you're illustrating an iterative approach to solving the problem rather than just presenting the "best" solution. I look forward to reading more of your material.
Poster here, so lay on the criticism. WPF people especially
I'm going to come at this from the other, non-WPF side. Dang that's a lot of....well...._stuff_. Can't you just instantiate the form, buttons, and whatnot in Main? let myForm=new System.Drawing.Window() or something? I don't understand why we're doing this with so many files and code and such. Perhaps I missed the explanation? Thanks for this, btw.
Is there a practical reason for this beyond just because you can? What makes this better than just building out the GUI in C#?
Man I really wish I could run it... Can't run WPF apps on Mac. Sounds really cool though, keep it up!!
I just made my first web api using Giraffe (snuck it in the back door for an internal app at work) - and wow! The composability of the http handler functions really makes me feel closer to the metal so-to-speak. Being able to visualize the flow of the request/response in the router is just such a beautiful fit for declarative functional programming! After the fact I decided that I need to split the api into two separate apis / apps: one to be public facing and another to be internal only. My first thought was that it might be easiest to just copy the project and strip out the methods I didn't want on the public side. But then it occurred to me that I could compose a function in the routing module that would check the config file and short circuit the private routings based on a configuration. The really cool part was that I was able to do this in one 4 line function *without even having to read the documentation!* It was so intuitive, it just worked. And the code just seems so elegant. I really love the rare framework that provides just enough and can just get out of the way! I'm so hooked on F#!
I’m not aware of any one resource which explains the current state of F#, but I do like F# weekly. As for any burning questions you have, feel free to ask on this subreddit :)
Classes are a perfectly fine (and often times, functional) construct that are fantastic for things like passing in a connection string in a way that is testable and lets you read such resources from elsewhere; e.g., a file. The "record of data I need to initialize" pattern is also just fine, so long as you don't need to "save" that data for later. If you do, then a class is probably better, because you'll likely want to tie the lifetime of that data with the lifetime of the object. There may well be times where that isn't true, though, so it's good to keep an open mind. As a side note, this is something I've been meaning to write about more in the [F# style guide](https://docs.microsoft.com/en-us/dotnet/fsharp/style-guide/conventions#object-programming). The section on object programming isn't that fleshed out, and doesn't cover this situation very well. It's common to see F# programmers do something silly like this: ``` module Foo = let connStr = GetConnStrFromSomewhere() ... ``` And that needs to be explicitly listed as an antipattern due to static initialization of that module now depending on some other function call that might fail. If you have any feedback about this and where such a thing could be documented, I'd love to hear it.
If you instantiate the controls in Main, you can't use the Forms Designer - you would have to write this by hand: [https://github.com/vivainio/FSharpFormsSkeleton/blob/master/ScfProject/ScfProjectDesign/ScfProjectForm.Designer.cs](https://github.com/vivainio/FSharpFormsSkeleton/blob/master/ScfProject/ScfProjectDesign/ScfProjectForm.Designer.cs) In addition to being tedious, it's going to require more Forms skills/experience than just slapping the controls out in the Designer.
You get to stay on F# side to implement the event handlers. That means \~ all your application code is written in one programming language, which seems more pleasant to me.
Still wondering why Microsoft didn't have native GUI builder for F# in VS2010, as it would have greatly helped F# adoption. Perhaps the lack of partial classes meant that it was just not possible, as partial classes may not be doable in F#.
It's probably just a lack of investment. Partial classes are in no way necessary to solve this problem, e.g. the F# UI designer could create a designer-managed Form1Controls class that has the component initialization and dispose.
Yes, a lack of investment and a lack of vision. For a .Net language, the absence of a GUI builder essentially renders the language, no matter how good its features and benefits, to permanent second-class status or at best pigeonholed to a narrow class of problems.
tbh, with the HKT and typeclass proposal for C# (aka .NET CLR change), F# will benefit greatly :)
Ditto re: WPF. These might not be areas you're as interested in exploring for fun, but a test suite and/or a command line interface would help non-Windows users to fiddle with it.
I noticed you said that you don't talk to anyone about f#. We should change that :) https://discord.gg/ATkgqr
&gt; It’s easy to use from F#, as you’ll see from this post. WPF requires more complex adaptation work (e.g. there is a XAML type provider), while Forms is pretty much straight .NET. this isn't totally accurate. xaml and wpf are two different things, and you can do straight wpf, without ever touching xaml, just as easily as you can do straight winforms. &gt; UWP (or more correctly .NET Native) does not work with F# at all, and possibly never will — so it’s probably not going to be relevant to you. Because of severe limitations of UWP, Win32 is unlikely to go anywhere, so you’ll be running Forms apps a long time. i am not for sure of the relevance here. you can use uwp controls in both winforms and wpf in .net core 3.0.
Join the F# Slack channel! https://fsharp.org/guides/slack/
I just added a quick and dirty console UI (just for fun). It's not the most intuitive way to move the pieces around the board (I could feel the new neural pathways forming as I struggled to quickly identify col/row coordinates), but it works! Considering that the hard part was the logic, why not? After pushing the change, I noticed that a more standard protocol for playing verbal chess exists, but I had already "committed" to the from-to coordinate approach ("a2 a3"). As an added bonus, I got to try C# pattern matching for the first time. It was better than not having it, but not as elegant or powerful as F# pattern matching! Thanks for the comments. What a great community! :D
Thanks for the feedback, I added a note about Mono, and reworded the UWP stuff: Now it has this: \&gt; .NET Native (i.e. the “full” UWP stack) does not work with F# at all, and possibly never will — so it’s probably not going to be relevant to your choices. The terminology around UWP/.NET Native is messy, and the story seems to changing as we go on.
Almost forgot... updated the domain project to .net standard 1.6 and the console ui project to .net core!
I've always used .net core and the .net command https://docs.microsoft.com/en-us/dotnet/fsharp/get-started/get-started-command-line 
That's very good looking code. Maybe I'll use it as an example in my lecture on programming languages. There's one thing you can shorten though: Chess.fs 129-133 can be shortened from match (fromPieceColor, xDelta, yDelta) with | (White, 1, 1) -&gt; Ok move | (White, -1, 1) -&gt; Ok move | (Black, 1, -1) -&gt; Ok move | (Black, -1, -1) -&gt; Ok move to match (fromPieceColor, xDelta, yDelta) with | (_, 1, 1) | (_, -1, 1) -&gt; Ok move since the color can only be Black or White and since you can group cases that have the same result. 
have you tried *option 2* from [here](https://fsharp.org/use/linux/)? it's been a while because I have really current versions available on .deb/ubuntu/mint so I'm pretty happy. But I never had "greater" problems compiling it in the past
When doing exactly as stated in option 2 (from source, with make), I get the 'msbuild: command not found' error. That leads to a dependency on MSBuild (not stated in the build docs) which is not included in Mono (anymore). Installing MSBuild, however, requires .NET Core. Now dependency hunting begins...
The first entry in this series for those, like me, who have not read it yet is here: [http://tiny-giant-books.com/blog/failure-is-not-an-option-in-f/](http://tiny-giant-books.com/blog/failure-is-not-an-option-in-f/)
We don't have partial classes, but we have inheritance. An F# GUI builder could just generate base classes with abstract methods for the event handlers (maybe even with empty default implementations). Then our own code would just inherit from those, or even just instance them with `{ new ... }`. I wish we had such a builder to describe componentes we could then use jsx-style.
Nice! I didn't realize that the patterns fell into each other like that. Glad to see that it is similar to C# switch cases in that regard. I will update it. Now that you mention it, it could be optimized yet again if I took the abs of xDelta: match (fromPieceColor, abs xDelta, yDelta) with | (White, 1, 1) | (Black, 1, -1) -&gt; Ok move I'd be very interested in seeing your lecture if you post it.
To be clear, most of the UWP APIs can be called from any .NET process, even from .NET Framework. The only exceptions are those related to the UI and XAML, but even those only require the app to be packaged as an *appx*. I believe all of that works with F#. The real limitation is the Windows Store, which requires all .NET apps to be compiled with .NET native, which has no support for F# and maybe never will. The alternative is releasing it using Desktop Bridge, which limits you to Window 10 Desktop but would allow you to write UWP apps in F# (or any other language really, Desktop Bridge packages any Win32 app as an Store app). Maybe if we started making F# UWP apps through Desktop Bridge (Elmish.UWP?), we'd have a case for the .NET Native team to focus on F# support.
bookmarked!
Thanks for posting that guide. Very much worth the read. I really enjoyed the "Framework Design Guidelines Conventions, Idioms and Patterns for Reusable .NET Libraries" book. I bought it many years ago, and I see it is now rolled into the guidelines site. The format of the guidelines was great (DO, CONSIDER and DO NOT). Nice to see a similar approach being extended to F#. After reading through it, I see where you addressed this in the section entitled "use classes to contain values that have side effects". One question that many C# developers will wrestle with is, "how do I do dependency injection in FP/F#." The answer becomes completely different if you ask that question about FP in general (where the answer is likely somewhere between "partial application" and "you don't"). But if the question is asked specifically with regards to F#, then I think that the answer may be, "the same way that you would do it in C#: classes with ctor injection!" Surprisingly, I have not seen this answer in any of my googling on the subject, probably because the question is usually asked in the more general context of "FP". (But with F#, we can actually have the best of both worlds!) So to expand on this example, maybe there is some opportunity to touch on DI as a valid/good architectural style in the object programming section (or maybe even in a new section that outlines architectures). I think some of these discussions that focus on FP rather than F# can actually deter/discourage C# developers because it leads them to believe that they have to discard or completely relearn tried and true patterns like DI. You have already implied or hinted at DI simply by the fact that the example code named the class ctor parameters "dep1, dep2, dep3": type MyParametricApi(dep1, dep2, dep3) = member __.Function1 arg1 = doStuffWith dep1 dep2 dep3 arg1 member __.Function2 arg2 = doStuffWith dep1 dep2 dep3 arg2 So maybe this could be further expanded on by discussing DI in general as it can pertain to application architecture with F#. I think this would be a welcome message to C# devs who are reading otherwise in blog posts and forums.
Indeed, Win Forms is not dead. At my company we are nearly complete with rewriting a legacy medical billing application (140+ forms), mostly in F#. Being able to handle the requirements of the GUI logic using union types, pattern matching, option types, Result workflows and other features of F# has been amazing and I am so happy we were not forced to write it all in C#. We started with FSharp.Desktop.UI by adding binding support for Win Forms, but it was too OO and the project has been abandoned. During our F# journey, we've developed a functional-first framework based on the same separation of concerns and made it open source: [VinylUI](https://github.com/Acadian-Ambulance/vinyl-ui). It will soon have WPF support as well. Since we are actively developing a large application with it, we are still adding fixes and features. Ideas and pull requests are welcome!
I install .net core and in addition fsharp via the Ubuntu packages. Works well, but I don't really understand what the relation between the two and mono is and if there is a way to use only core without mono.
Enjoyed the first episode, will be watching the others later today. Thanks for taking the time to make them. :)
VinylUI seems awesome, thanks for the hint! Especially this: Bind.view(&lt;@ form.WidthInput.Text @&gt;).toModelOneWay(&lt;@ model.Width @&gt;, parseDecimal)
1+ for not using Visual Studio on Windows (quite a few of us never use it and find it an impediment when used in tutorials). Nice effort :-)
Maybe you'll be happy to learn that I documented a simpler approach with CreateComponentBehind: [https://github.com/vivainio/TrivialBehinds#hybrid-f---c-project](https://github.com/vivainio/TrivialBehinds#hybrid-f---c-project)
Coming from a more web/linux/cli oriented background visual studio and its eco system was quite of a shock for me when I started with .NET on windows last year. I really love to work with vscode and Ionide and .net core. At the moment we are refactoring a huge part of a C# legacy into F# and because of this we need C#/F# interop and we therefore have to work with Visual Studio. Saying I dont love it is quite an euphemism... 
Based on PKGBUILD files in AUR for fsharp and msbuild-stable, both depend on mono. Then f# is built by calling autogen.sh of the fsharp sources. Have you tried building it having those dependencies? 
I was a Windows and VS user for years but made the switch to macOS about 4 years ago (mainly because I was fed up with the non .NET experience on Windows). Anyway, I have no hate towards Windows or VS but feel the Windows / VS / SQL Server setup makes people view .NET as enterprise only and not a viable option for OSS.
Thanks. I was just a bit confused about the title, as I knew it was possible (and easy) to create Windows Forms with a small number of controls declaratively. Now I see the goal was somewhat of a hybrid approach for more complex situations.
Cool videos! Do you think you'll do one on async? 
Chessie has a slightly different abstraction, as the declaration of the Result type there is type Result&lt;'ok, 'msg&gt; = | Ok of 'ok * 'msg list | Err of 'msg list and Chessie comes with some conveniences related to aggregating multiple errors. The now-built-in Result type is just type Result&lt;'ok, 'error&gt; = | Ok of 'ok | Err of 'error 
Yes. Pretty sure. But it might take some time. First holidays with my children. Then I will need to prepare two conference talks (Event Sourcing with F# and how to marry CQRS with the Elm architecture and the Safe Stack). Will publish those as well on the channel. After this I have a lot of ideas about how to move on and async is one of them.
Easy to follow, currently on episode 5. Is it possible to use the list functions without the List. predicate?
Thanks! No this is not possible. In theory you could open the List module with `open List` and than call map without the List prefix but the List module is marked with the "RequiresQualifiedAccess" Attribute. This meaans that you always have to use the module name as a prefix. Otherwise you get: ```This declaration opens the module 'Microsoft.FSharp.Collections.List', which is marked as 'RequireQualifiedAccess'. Adjust your code to use qualified references to the elements of the module instead, e.g. 'List.map' instead of 'map'. This change will ensure that your code is robust as new constructs are added to libraries.```
Core doesn’t need mono and F# comes built in. You probably don’t need the F# package.
You can inline it, e.g. let inline foo x = Seq.groupBy x But heck if I'd want to do that. That's ugly. Those aggregate functions are overloaded in all sorts of other modules. Perhaps you could do something with Higher-Order Functions? I don't know. Still feels bad to think about. I really want to know whether I've got a seq or a list when I'm working with stuff. Simply because you can do something doesn't mean you should.
You can get this kind of site running for free on Azure as a normal Azure website.
I have been enjoying reading your blogs lately. Keep up the good work! 
I like it! :) There's definitely a weird vibe in the F# community. Your code looks fine to me. In my next essay, which I started coding this morning, I'm going to do something similar. At the end of the day, you got types, whether you want to have them or not. The Domain guys tend to want to abstract everything and make a sort of master functional model of the universe. I guess if that makes them happy, more power to them! I just want to make stuff for people, not get in religious wars about style. I lost a lot of friends in the great Braces Stand Alone battle of '94 I think the more we can show how fun and easy things are in F# to the C# folks, the more of them that are going to want to come over. And that's a big win for everybody. Keep up the good work! And please let me know if these essays are getting old. I'm having such a blast I could probably do another six or seven. I don't want to become annoying. (Or rather, _more_ annoying) (grin) Daniel
The usual reason for that weird `ActualType.T` pattern is that it allows you to declare the record or DU definitions as private (to the module), only exposing a validator function that returns `T option`, plus accessor functions for `T`'s hidden fields. Of course, you can do the same with an OO-style private constructor, static `.Create` method, and read-only properties, which IMO is generally both more legible and more concise.
I don't know if this is helpful or not, but something I noticed was that there was a difference between code I could look at and eventually figure out -- and code I could look at and immediately start working with. That's a different standard for everybody -- in every project. That's one of the big reasons I'm bragging about being stupid. It's not that I'm stupid, it's that in FP a big part of the job of the programmer is managing complexity. Much more so than OOP. I really, really love some of the F# code I've seen. And when I'm elbows-deep in coding, I naturally drift that way. (That's one of the reasons I push all of that stuff out of the way) But I'd never write something that I wasn't sure that I could come back, cold, in six months and pick up right away. (And there's no right or wrong answer to what that code looks like) So be cool and do awesome stuff. Just don't make a mess for yourself. You're the one that's going to have to clean it up. :)
Well done! Now you should do Poker :) I have been looking for an open source poker app written in F#. Does anyone know if it exists? I've seen evaluators but no full games.
But it does not come with the `fsharpc` and `fsharpi` executables. How can I start an interactive shell with just dotnet core? 
The interactive REPLs are not available for dotnet core yet unfortunately. 
You have lots of questions here. \&gt; Does f# profit from [performance improvements of dot net core](https://blogs.msdn.microsoft.com/dotnet/2018/04/18/performance-improvements-in-net-core-2-1/) in the same way c# does? mostly yes \&gt; is the number of response / second at all relevant for \~ 80% of all sites? Even if you do not need to return 43,968 responses per second, reducing latency can improve user experience and make you money: [https://blog.gigaspaces.com/amazon-found-every-100ms-of-latency-cost-them-1-in-sales/](https://blog.gigaspaces.com/amazon-found-every-100ms-of-latency-cost-them-1-in-sales/) It is also nice to be ready for big traffic if whatever you are working on it makes it to the big time, or has designs that change that make it more resource intensive.
1. I would be really careful in comparing results to non-MVC ASP Core implementations. They are mostly marked as “micro-frameworks” or “platform” and in principle they are not representing how typical, idiomatic ASP applications looks like. (Same applies to giraffe stripped implementation, and Zebra) 2. Comparing results to MVC looks really good for Giraffe - it’s faster in both plain text and json benchmarks. 3. Fortunes test measures not only performance in typical query-DB use case, but also rendering view performance. And I bet this is a reason for huge performance difference between Giraffe and MVC shown by this test. Giraffe view engine implementation is pretty naive and as far as I know it was never really optimized. PRs are welcomed ;-) 4. 43k requests per second on one node is enough for 99% of web applications :-)
As /u/k_cieslak mentioned, it's not quite an apples-to-apples comparison since there are different view engines at play, with the MVC view engine most certainly having better performance. It's hard to say where the actual bottleneck lies, though, since that information isn't present. If you look at Giraffe results for [plaintext](https://www.techempower.com/benchmarks/#section=test&amp;runid=f2e525b1-9d14-4bbd-922d-7c1ed28416f6&amp;hw=ph&amp;test=plaintext&amp;l=hra0hp-1) and [JSON serialization](https://www.techempower.com/benchmarks/#section=test&amp;runid=f2e525b1-9d14-4bbd-922d-7c1ed28416f6&amp;hw=ph&amp;test=json&amp;l=hra0hp-1), all of a sudden things are a lot more close, which I personally thing is a better comparison because I've never considered using Giraffe for more than just being a web server on the backend. But to answer this question: &gt; Does f# profit from performance improvements of dot net core in the same way c# does? Yes. It would have been inconceivable to have F# running on Linux and producing nearly a 550k req/s throughput on a small JSON payload prior to .NET Core. The extent of improvements F# sees under .NET Core is far more difficult to get a grasp on beyond benchmarks like this, though.
I assumed the same as your point 4.) 43k requests / s is good enough. So to get a better idea about the number of responses (, request) i searched for statistics for website. I analyzed [PageImpressions from 871 sites](http://ausweisung.ivw-online.de/index.php?i=116&amp;mz_szm=201806&amp;az_filter=0&amp;kat1=0&amp;kat2=0&amp;kat3=0&amp;kat4=0&amp;kat5=0&amp;kat6=0&amp;kat7=0&amp;kat8=0&amp;sort=&amp;suche=&amp;pis=1) Assuming evenly distributed page impressions (this is likely not the case but it makes it simpler to calculate) i divided the page impression per month through 30 days then 12 hours (no traffic during the "night"), 60 minutes, 60 seconds - Example: 5,000,000 pi / month / 30 days --&gt; 166,667 pi / day 166,667 pi / day / 12 hours --&gt; 13,889 pi / hour 13,889 pi / hour / 60 minute --&gt; 231 pi / minute 231 pi / minute / 60 seconds --&gt; 3.86 pi / second This led to these results cumulated page impressions / page impressions / % of sites second with 30 days second with 20 days / month 51.2% &lt;1 &lt; 1.3 71.6% &lt;4 &lt; 6.0 86.0% &lt;8 &lt;12.0 95.8% &lt;62 &lt;93.0 98.0% &lt;232 &lt;348.0 in the sample above 86% of sites deliver less than 8 page impression per second. I have no idea how peaks are distributed - it could be that during a peak hour the number of page impression is 3 to 50 times as high. So lets assume 50 times this would mean that during a peak second 72% of sites must be able to handle 200 page impression / second (200 = 50 * 4 PI/s). Assuming about 100 http request per page this could amount to 20,000 requests / second. This is still less than half what giraffe was able to deliver. I agree that faster is better but still what is fast / good enough for 72% of pages or even 86% of sites (peak 50 times * 8 pi/s * 100 --&gt; 40,000 requests/second)? 
Most sites are limited in throughput by their data access layer. A lot of optmization, caching and architecture is required before the web server itself becomes the bottleneck.
Nope, definitely not getting old at all. I like that your blog contains some real-life F# code. There's too much "getting started" stuff out there and not enough in-the-trenches code, imo. I'm so sick of seeing something F# on YouTube and fast forwarding through an hour that covers the basics. I'm interested in architecture patterns and functional solutions to real problems at this point.
Nice work! The console UI is easy to use and runs perfectly on my mac :) What led you to do it in C# instead of F#? Just for fun?
Thanks! Good question... I work on a C# dev team, so I have been learning F# with the question of interop with C# at the forefront of my mind. I know that doing an entire application in F# will be an impossible sell, but I \*might\* be able to pitch smaller bits like an F# domain model, or an F# web API. Wrapping the F# domain model in a class based API at the outer boundary with DTOs for the calling C# code seemed to work pretty nicely. Next I need to try something where I share the F# domain entities everywhere in the solution. Btw, I love the emoji chess pieces pull request. Perfect!
Hey guys, I've tried to put a strong disclaimer at the top of the essay. Once I get the wording right I'll put it in the other essays as well. This isn't a "Code like this" series. This is an adventure series around coding that just happens to use F#. My goal is to talk about the mental processes you go through while coding and some of the struggles you might face while making useful stuff using this cool language. There are a ton of better books on programming than I'll ever write. I just want to share with folks how it can be fun -- and how it can make you a better programmer as you go along.
There's a lot here. I agree that there is a lot of development framework/tooling support that probably should be added. The only thing I'll add -- and I know it sounds like I'm a purist but I am not -- is that I would not expect F# to work the same way as the other Visual Studio languages. Yes, it's all just IL under the hood, but functional programming in general represents a different way of thinking about things. My complaint about F# comes from the complete opposite end of the spectrum. If they'd somehow stick to their roots and make it more like OCaml and Haskell while still supporting .NET libraries (waves magic wand here), I'd be a bigger fan. The more it looks and acts like just another MS language, the more I see a future with a lot of guys dragging-and-dropping controls on a form and making a big mess in a hurry. Playing around is great, but take your time playing around. You don't need power tools to learn. I guess no matter what Microsoft does, it's not going to make people happy.
This is my unfounded theory: Microsoft rounded up some of the best computer language &amp; compiler geeks in the world and told them to counterfeit the JVM architecture and create two languages for it: * C#, a faithful copy of the most bland computer language ever * VB.net (no comment) And they said: Okay, but only if we also get to create the language **we** want to make. So my take is that F# is not the functional language for your core business logic. Instead it's the language you are meant to write your whole project in. A language that can easily deal with the real world: IO, databases, exceptions, logging, etc.
There are many languages that rely on community support or support from much smaller organisations. I wouldn't say that Microsoft caring about the language is a requirement for me to use it. And from what I have seen, they do care about it but aren't willing to invest as much money in it as C# and [VB.NET](https://VB.NET). It still gets a slot on the VS installer and it now has dotnet core support out the box. I think any issues you have should be raised with the F# development community so that they can be resolved. \&gt; In Visual Studio 2017 Enterprise, F# is clearly a second class citizen. It does not let me create a WPF project in F#. Or windows forms project. Or anything other than library or console program. Implementing infrastructure for WPF and WinForm designers is a lot of work. I expect Microsoft don't see it beneficial for F# which most people will use for Console Apps and libraries rather than UI. I personally would make my UI in C# and then call into my business logic which is in a different F# assembly. * c# / f# interoperability is abysmal. In the C world, I can mix C, C++ and asm source files. Even in Visual Studio. In the JVM world, I can mix java, kotlin, scala, groovy source files. In dotnet, C# &amp; F# seemingly cannot even coexist in the same project. You can not mix [VB.NET](https://VB.NET) or C# sources in a single project either. The only way this would be possible is if each compiler output a source file to IL and then you can a final linking task to assemble into a single assembly. .NET doesn't work like this, it works for C and Java because they have a 1:1 relationship between source files and class files / object files which are then linked / bundled. In .NET you are expected to organise your solution into projects with each project being any .NET language. * The VisualStudio C# IDE is about where IntelliJ &amp; Eclipse were 5-10 years ago. Which is completely okay. But the F# IDE is really bad. I get some syntax highlighting, but no help to get the syntax right or any kind of "you probably meant to do this". For me VS has always been a superior IDE, just the editor alone is much better in my opinion. You are right in that the F# language service is not as mature as C# which isn't surprising as it has not had the same amount of time put into it. It is also a much more complex language to cater for. I think the the improvements to this are largely community driven. * F# debugging is broken. In VisualStudio breakpoints don't fire or cannot be set at all. (It seems VisualStudio is innocent here, it doesn't work in rider either.) I agree, but I can't imagine an easy feature to write. * Error messages are pretty useless. "Unexpected identifier in expression". Maybe half a screen from here. Thanks. It can't be as bad as C++ templates. :p * On MSDN F# seems to be the language that least often gets examples. Even VB (has anyone actually used this this century?) seemingly gets more love. There is a lot more legacy [VB.NET](https://VB.NET) code around that is too expensive to port. Microsoft are instead helping the maintainers modernise the code. * the compiler does not do any of the crazy optimisations that are possible with functional languages (think GHC for haskell). (Yes, a keyword to separate side-effect-free code from imperative one would come in handy for this, but hey, the language was designed by the guys who created the compiler). From what I can see, F# was never designed to be fast. If you want fast code, you would use C#. That said I hope more optimisations get added, I often use struct tuples to reduce GC amongst other things.
I disagree with F# not being fast. I ported a large program from C to F#, and found that it performed overall well within the margin of the C version, and portions that were tail call optimized ran significantly faster (even in FSI) than the C equivalents. Plus, I only had to write 1 line of F# for every 10 or so lines of C.
I expect the performance gain was the algorithm. I am talking more about micro optimisations based on the final generated IL which is a lot more than you get with C#.
The first class F# experience right now, imo, is .NET Core, VS Code and the Ionide plugin.
To clarify my point, you are correct in that F# is more flexible and offers many more paradigms than does C for writing the same thing; in this case, that flexibility coupled with tail recursion resulted in code that was orders of magnitude faster. I haven’t ever thought about the change to tuples as a reference type, but I get what you’re saying. I think they did it because the performance benefit to small tuples as a value type did not make up for the drastic performance loss of having large tuples on the stack. I know there is a blurb from the compiler maintainers somewhere about the performance loss of small tuples on the heap vs stack being negligible - if I find it I’ll link it.
I need to switch over. Any good quickstart guides?
No it doesn't. Blame u/phillipcarter2 :&gt;
My VS Code experience has been terrible. I've been very patient and invested time working with it but working with any solution that has more than one project is unusable. Completions fail to work, errors appear that aren't errors, debugging is patchy - the list of problems is long. I had to (reluctantly) give up and use VS for Mac simply because I have work to do.
You'll hear platitudes from various MS employees about F#'s importance but (as you say) the user experience is quite different. However I feel F#'s survival is a useful test case to the viability of .NET being a serious rival to the JVM for OSS. Although Oracle 'own' Java the JVM eco system isn't tied to one dominant tech company whereas .NET is very much Microsoft / C# (and that's certainly how it's perceived by those looking in). Until we see more independence from MS the JVM will continue to dominate in OSS land.
I see this was downvoted, can someone please explain why? I merely wrote down my experience. I'm genuinely interested in what someone has taken objection to?
Note that as of F# 4.1, we have \`struct (int \* int)\` for value tuples. However, value types are not always going to buy you a performance win. The .NET GC is very, very good at dealing with lots of smaller allocations. You may reduce some allocations by switching to a struct only to find that CPU time has not been improved meaningfully due to copying of values. Only through careful measurement can you say for sure if one representation over the other will be of a benefit to your system. Generated IL from F# is often not as ideal as that from C#. Though a lot of that really is micro-optimizations. When playing little perf games like the Language Benchmarks game or TechEmpower, this difference isn't really felt. But it would be nice to get to cleaning up some of the generated IL. We have some changes slated for F# vNext that do this a bit.
F# was born out of Microsoft Research, and the language designer for F# also implemented generics in .NET. The language absolutely has not been put in the cupboard - as someone who uses it professionally, the upgrades in IDE support over the past couple of years has been staggering. Back in 2015, I had strings and keywords highlighted and that was it. Now my IDE is colourful, the tooltips are highlighted, etc. It’s so much further than where it was. With regards to F# expressions not working in the debugger, that’s because expressions are compiled with the C# compiler (same in Rider, unfortunately). I’ve spoken to the F# program manager at Microsoft and it’s a huge piece of work - there are more important things to work on (like performance, which they’re also making strides on). 
i personally don't understand why microsoft is so nonchalant towards f#. from what i have seen, python is completely dominating the software market, especially in scientific, data science, and research positions. this is quite embarrassing for something like f# which absolutely excels (or could excel with the right libraries) at these things. python is in general listed on every single software qualifications list i have seen and is quite often the lingua franca for large projects. where is c#? it's mainly in more enterprisey areas and f# is nowhere to be found. so in my mind, microsoft is throwing out business because f# blows python out of the water. and no one using python is going to switch to c#. it's just not going to happen. python developers are a bit of a closed minded bunch, and f# is a clearer transition for them, if only because of the cleaner syntax. so why isn't microsoft using f# as a way to bring people who otherwise develop in python, scala, clojure, and elixir to the .net landscape? it doesn't make sense to me why it isn't used as a major marketing point. "come to .net. we have c# and f#, which is all you need." instead, f# is (moronically in my opinion) billed as an alternative to c#. that marketing strategy has never made sense and has obviously not worked.
visual studio code is great for little projects (by that i mean those that just sit in a few .fs or .fsx files). but visual studio seems the way to go for actual projects. i don't even know how to do projects in visual studio code. although, i would estimate that the syntax highlighting and intellisense for f# only works about 60% of the time in visual studio. when it does work, it is much faster than the intellisense in visual studio code.
Also, since string literals evaluate to System.String, the algebraic string type literals could be identified with a prefix: let str = #"Hello, world."
I see this is already being discussed here in terms of how F# will handle C# so-called "non-nullable types": [https://github.com/fsharp/fslang-suggestions/issues/577](https://github.com/fsharp/fslang-suggestions/issues/577) That thread is making my brain hot.
It's sad, except for pandas I really don't want to use Python (and no Deedle is just not useable in the same way, it makes a lot of things too complicated, especially when dealing with string data instead of numbers).
yea, i see all these amazing systems and opportunities, and what are they using? python. for some of the systems, it is just the plain wrong decision made by people who don't understand software. but unfortunately, these are the people coming up with interesting applications, and they just reach for python because they think it's the latest and greatest.
&gt;&gt;With regards to F# expressions not working in the debugger, that’s because expressions are compiled with the C# compiler Yep. If you can mentally convert to C#, type that expression in and it works okay. Same for debugger breakpoints.
Here take my upvote. I know your pain.. F# stuff in VS Code only works half the time. Totally frustrating.
Interesting. That's for the head's up.
Ha thanks dude, have an upvote in return :-)
C# interop is the best and the worst thing of F#.
&gt; C# &amp; F# seemingly cannot even coexist in the same project. This is the same for VB.Net. I see nothing wrong. &gt; the F# IDE is really bad. I get some syntax highlighting, but no help to get the syntax right or any kind of "you probably meant to do this". I use .net core + vscode with relevant plugins, and my experience is pretty smooth. (I mainly create DLLs and RESTful web APIs) &gt; In default setting, the VS F# IDE creates tab characters, which the F# compiler dislikes and does not show whitespaces. So to indent, you have to press space exactly 4 times. Tab creates invisible errors. VS really seems to hate F#. Same as above. &gt; F# debugging is broken. In VisualStudio breakpoints don't fire or cannot be set at all. (It seems VisualStudio is innocent here, it doesn't work in rider either.) Expression evaluation seems broken, even though F# seems great for this sort of thing. Same as above. &gt; Error messages are pretty useless. "Unexpected identifier in expression". Maybe half a screen from here. Thanks. Can you be more specific? &gt; Even VB (has anyone actually used this this century?) seemingly gets more love. Many businesses use VB.Net. Your arrogant tone only shows your ignorance. It may not be used in your specific niche, but remember you're not the whole Universe. &gt; the compiler does not do any of the crazy optimisations that are possible with functional languages (think GHC for haskell). Can you be more specific about those missing "crazy optimisations"? 
I'm not sure what to tell you because I've had none of those problems. I don't know exactly what your requirements are, but I would clarify that I am exclusively using .NET Core. I.e., I do not have Mono installed, I've never developed anything against Mono. There is a setting in the Ionide plugin you have to change to tell it you want it to source its language services from .NET Core rather than Mono. Also look into an extension called F# Language Service. Unlike Ionide, which does its own thing, F# Language Service goes the route of conforming the Language Server Protocol spec, so that it can simply leverage F# Compiler Services. I only just discovered it, and haven't really done anything with it other than enable it, but it seemed to be working. 
Last time I checked Ionide does not work with .Net Core and still requires Mono.
Just adding this as a clarifying note (not really a statement about your post). Both Ionide and FLS use the same component (F# Compiler Service) and are subject to the same underlying behavior. Ionide has a more elaborate set of features built atop this, such as sorting items in a completion list, special formatting of tooltips, etc. I'd definitely encourage using an evaluating both, though it is important to note that all F# editors (VS, VS for Mac, VSCode with Ionide or FLS, Rider, etc.) use the same underlying compiler and compiler service. How they surface features differs from editor to editor.
If you're interested in reading the (very, very, very, very long) spec that we're assembly for nullable reference types, it is evolving here: https://github.com/fsharp/fslang-design/pull/317 Long story short: it won't be an algebraic reference type system, the world is complicated, but it'll probably be fine (I hope)
Thank you for the clarification.
I like the sound of this (#1 specifically): [https://github.com/fsharp/fslang-design/pull/317#discussion\_r203063736](https://github.com/fsharp/fslang-design/pull/317#discussion_r203063736) \-- "design a fully sound ... and fully checked non-nullness for F#..." That would be sweet! *Feeling optimistic*
Unfortunately, I'm not a believer that this is possible without either bifurcating the language into "good F#" and "bad F#" or sacrificing backwards compatibility with existing codebases. It's something we'll discuss and I may be (hopefully) proven wrong, though.
This post has been linked from Hacker News https://news.ycombinator.com/item?id=17605125 
&gt; In default setting, the VS F# IDE creates tab characters, which the F# compiler dislikes and does not show whitespaces. So to indent, you have to press space exactly 4 times. ... Or you could switch your VS settings to indent with space characters instead of tabs. Then you can press the Tab key once and it will insert 4 spaces. I have grown to seriously dislike indenting with tab characters for precisely the same reason that tab lovers like it: because it will look different on each person's screen. This, in my experience, generally results in files with inconsistent indentation, because one person likes 4-space tabs and the other person likes 2-space tabs. So if they lined something up on the right-hand side without paying careful attention to their indentation (which always seems to happen IME), suddenly the file is inconsistent and you cannot find a tab setting that makes everything line up. https://softwareengineering.stackexchange.com/q/197838 has more details. But I'm wandering from the point. The point is that VS's options give you a lot of flexibility: you can set options on a per-language basis. So VS *should* be configured by default to indent F# code with space characters only, and if it's not, that should be considered a bug and reported as such. But you can easily change one setting and be done with the problem forever. You should never have to hit the space bar four times to indent your code!
&gt;i don't even know how to do projects in visual studio code. Open the integrated terminal and use `dotnet new`? &gt;when it does work, it is much faster than the intellisense in visual studio code. I'm using the VS 15.8 Preview (F# support for Span&lt;T&gt; and Memory&lt;T&gt; doesn't seem to work yet with Ionide), and the intellisense and completion is a noticeable step down from VSCode. It may just be the Preview release, but I've also noticed that VS crashes *a lot* (many random freezes and crashes while rendering the Intellisense pop up?)
You're not alone. I'd say the chance of getting a crash while debugging F# in VSCode is roughly 45%. That said, I haven't had all that many issues with Ionide's errors, completions, etc. and when I do (very rarely), it's usually fixed by closing and reopening the file I'm editing. What seems to guarantee issues is having two F# files open side-by-side. I should probably file a bug for that.
On a non-Windows OS, yes. I believe they are working on that, however.
that only works with .net core and not .net framework, to my knowledge. and that’s not really any special integration with code. it’s just using the integrated terminal. i need .net framework due to library dependencies. and adding references to a project is rather easy in visual studio. the intellisense and syntax highlighting does seem to stop working frustratingly often in visual studio, but it has definitely been faster, especially intellisense code completion, in visual studio versus code. code does have the display of types over functions, which is nice, but it is often slow and is sometimes jarring as it moves things vertically when lagging between code updates. i do actually use code for my home use of f# while i learn and experiment. for the couple of side projects at work, i use visual studio. 
&gt;In default setting, the VS F# IDE creates tab characters, which the F# compiler dislikes and does not show whitespaces. On a completely fresh install of VS 15.7, the default setting for Tabs is "Insert spaces".
&gt;that only works with .net core and not .net framework Set `&lt;TargetFramework&gt;net462&lt;/TargetFramework&gt;` in the .fsproj file. That example sets the target framework to .NET 4.6.2, for example
Tip: ctrl+shift+P "reload window" is the faster way to "reset" the current project 
It is, but usually it's just the editor tab that has issues, and Ctrl-W, Ctrl-E, Enter seems negligibly slower to me, if at all.
Every dotnet job (of which there are plenty) is a partial F# job waiting to happen
I opened an issue on GitHub: [https://github.com/fsharp/fsharp/issues/865](https://github.com/fsharp/fsharp/issues/865)
&gt; There is a setting in the Ionide plugin you have to change to tell it you want it to source its language services from .NET Core rather than Mono. What setting is that?
While a bit harder to work with, you can define your own String type (a list of chars). Create a function from System.String to MyString (where null matches to an empty list) and the reverse (where an empty list matches to an empty string). This is similar to Haskell's String type (you do get performance problems if you need fast string computations, however). Any function that you need (say String.IsNullOrEmpty) can be redefined by transforming your own type back to string and then using the function, or by reimplementing it yourself, so you don't always have to transform it back into a regular string. Using an array type instead of a list should also improve performance if you need fast string computations.
Shouldn't it be the other way round? I think this would get tedious rather quickly.
Did you log the issues you encountered?
You can use a setting to just use .Net Core
Its a catch 22 situation, unless the user base increases significantly then no business would plough a substantial amount of resources into developing it. The only exceptions are companies like Apple where they want their language to success and replace another entirely. Microsoft have an entire business around C# now.
But what setting is that? I can't find any mention of it on the Ionide homepage.
Breakpoints are not completely broken, there issues with certain expressions but they are not just totally broken.
\&gt; use the same underlying compiler and compiler service Of course, **how** they use them can have massive impacts on performance. Changing between two files repeatedly should never cause freezing and hundreds of MB of memory allocation! I assume FSAC is just misusing the F# Compiler Service. I hope the the new language server does better, because it's faster to compile my solution than wait for FSAC these days...
I tend to log issues when I encounter them but I simply had too many of them.
Yeah I'd agree that's a bit of a stretch, they generally work for me.
`"FSharp.fsacRuntime": "netcore"`
F# is already fairly low on Microsoft's priority list, so as C# gets closer to F# feature-wise, I can't see the situation improving. As the feature gap narrows, it will get increasing difficult to convince C# shops to use F#, even for a limited class of problems. Without more developers taking up F#, it's hard to see Microsoft committing more resources to it. I agree with u/nikofeyn that Microsoft should be targeting the same domains that are currently dominated by Python. With .NET Core enabling practical cross platform development, F# could be positioned as a great platform for scientific, data science, machine learning, complex data analysis, etc. I'm also puzzled at Microsoft for not heavily promoting F# for its clear advantage over C# when it comes to software correctness. With the increasing dependence of software on our lives, software correctness should be a key feature when promoting any programming language. One problem facing F# take up, and hence prompting MS to commit more resources, is that F# is in an unfortunate middle ground. It's too low level to attract those who want the advanced features of Haskell or OCaml, but ( now) not sufficiently more advanced than C# for devs to put the effort into learning the language. With .NET Core making it a viable cross-platform language, it faces the same problems as it does against C# when one looks at Swift, Kotlin and even Java 8. Perhaps F# needs to move up towards Haskell and OCaml (or even F\*) in order to differentiate itself sufficiently from C#, Swift, Kotlin and so on in order to attract new developers. What attracted me to F# in 2010 was the overwhelming superiority of the language over C#, despite the limited VS support. Now that gap has narrowed to such an extent that I wonder if I would feel the same way today.
Thanks.
F# reminds me of Dart they are kind of dead. some people will point out various signs of life for each one. but still you can kind of see they are not super serious/critical. I get the vibe that they are being kept alive because Microsoft/Google don't want to piss off and lose the brilliant people working on them. so they are like "there there .. you good engineers keep yourselves busy with your stuff ... let us know if you need anything ... thank you ... we'll leave you guys to it".
that's true of python jobs as well, in my opinion.
I'm writing a full guide for it.
Scala on the JVM is a much better experience than F# on .NET. Wish Microsoft would change that but they don't care as much. The thing is that people coding in F# are usually top programmers and trend setters. I could easily introduce F# on teams of over 30 people at my work but I won't do that because I don't see that Microsoft is pushing F# hard enough. In the meantime I code F# in hobby projects and for small scripts just because I enjoy the language so much. My suggestion to Microsoft is to put more money behind F# to compete better with the jvm. F# will probably live on as a hobby language for most if MS doesn't change the situation. 
Too lazy for a full guide.
&gt; If they'd somehow stick to their roots and make it more like OCaml and Haskell while still supporting .NET libraries (waves magic wand here), I'd be a bigger fan. I think this is why Clojure on the JVM has, comparatively, been more successful. Clojure interops with Java libraries when absolutely necessary, but it's much easier to just pull in a Clojure lib that fits the style guide. In F# it's too easy to pull in things like NewtonSoft.Json to write imperative F#
From the video [F# web programming options for .NET Core](https://youtu.be/W8qAUJIVj8c?t=77) * ASP.NET Core MVC * [Suave](https://github.com/SuaveIO/suave) (2.4.3) Ademar Gonzalez and Henrik Feldt * [Giraffe](https://github.com/dustinmoris) (1.2.0 preview) Dustin Moris Gorski. According to [Phillip Carter](https://github.com/cartermp) Giraffe is derived from Suave. * [Saturn](https://github.com/SaturnFramework) (0.7.4) Krzysztof Ciesllak. Saturn builds on top of Giraffe * [Freya](https://github.com/xyncro/freya) (2.0.203) Andrew Cherry and Ryan Riley Phillip shows briefly two frameworks: * [ASP.NET Core MVC](https://www.youtube.com/watch?v=W8qAUJIVj8c&amp;feature=youtu.be&amp;t=202) object oriented, wire up API like in C#, best to start with f# coming from c# / ASP.NET MVC background. (~12 minutes) * [Giraffe](https://youtu.be/W8qAUJIVj8c?t=1056) lightweight it's a library not a framework, uses Kleisli composition to define API routes, recommended if you have functional experience (~ 17 minutes) 
Nice! Any intro tutorials?
Not yet, but I plan to do it after a time collecting pain points.
That's ok. Your README is good. What did you want to include in your full guide?
How to better design and separate the shared messages to keep them to a minimum, so the local messages don't clutter the shared domain. I'll use it on a project and then write from real world code instead of creating problems to artificially solve them.
I do not like C# anymore. Why ? I quote another poster: " C#, a faithful copy of the most boringly okay computer language ever ". Also C# goes into the wrong direction: A firework of new features every year. So I thought, VB .Net or F# ? The number of "new Projekt" templates in Visual Studio, and Vistaual Studio support, is only one Indicator how serious Microsoft is with a language currently. An other indicator is the number of "dotnet new" Commands and here F# is 10 more active than VB .Net: [https://github.com/dotnet/templating/wiki/Available-templates-for-dotnet-new](https://github.com/dotnet/templating/wiki/Available-templates-for-dotnet-new) Here C# has 31 templates, F# has 13, and VB .Net 1.
Bare minimum implementation with no argument validation: open System.IO [&lt;EntryPoint&gt;] let main argv = Directory.EnumerateFiles (argv.[0], "*", SearchOption.AllDirectories) |&gt; Seq.filter (fun path -&gt; (Path.GetFileName path) = argv.[1]) |&gt; Seq.iter (printfn "%s") 0 
Thanks for the question! First thing you need to do is understand monads. Then async and compiler services. You're okay with algebraic types, right? Just kidding. circly has the right answer. :)
Here's a version that's safe in cases where you might not have permissions to access some of the paths the search hits (it'll just ignore them). It's a 5-year-old piece of code so style may not be great but IIRC it works. [http://fssnip.net/fp/title/Enumerate-files-without-permissions-errors](http://fssnip.net/fp/title/Enumerate-files-without-permissions-errors)
Hurray! It's a bit sad that we have to wait for VS for a proper release, but at least those are every few months now instead of years like they used to be.
I simply cannot believe that this is all it requires. Thank you very much!
So long as the code works that all that matters to me! Thank you very much!
I am very excited. :)
I bought the videos. I took a lot from the series, but not what I was expecting. It was very interesting to watch as someone who (by noooooo means an expect ) uses and prefers a functional style. I could tell their approach was causing pain points, but I couldn't figure out why for the first few episodes. Then it suddenly hit me. The problem was types. Typically in a functional language, my Very Initial Work is defining my program domain. I start with the types I need first and the connective functions tend to flow from that domain model as a result. TDD in the way it was implemented in the series seemed to favour a more function first development pattern. While OOP encapsulates behaviour in classes one things grow to some size, FP captures behaviour in types from the get-go. To me anyway. So halfway through I was mentally shouting at the screen "Stop using functions to coral your primitives into the behaviour you want! Bake the behaviour into the type system itself!" But they didn't listen, almost as if that's not how things work. :) Anyway, I enjoyed the series, and I did love watching a mind like Uncle Bob work, but the value was in watching these sort've tried and true methods for one programming style attempt to map to another and the discord that ensued. Also, it was a good reminder of what does work and how good design is leveraging the tools you have available. Thank you for your hard work. :D 
This. So much. To be fair it's much harder to do an intermediate level series than an intro-level series. But I have personally vowed that I'm not making any introductory content for programming. I don't think it's wrong or bad of course; I'm just reasonably sure someone else will cover it. So I'm pushing myself to create more "in-the-trenches" material when I do decide to publish work.
It's actually a .NET Core release :) There's no non-preview .NET Core to bundle F# with, so we need to ensure we can align with their monthly cadence. For future releases, depending on timing, we may ship with .NET Core and _not_ with VS, but it's unlikely that the reverse will be true because every time VS ships, an associated .NET Core SDK also ships.
You scared me there for a second. I learnt how monads work after writing Elm code for about six months, posting in the slack about a "good design pattern I recently recognized", and having someone respond, "Yeah, that's a Functor." He explained a bit more and it slowly dawn on me that all the good "patterns" could be described by words like Monads, Functors, etc. But it clicked in Elm the way it never did in Haskell because I'd _already been using them_, every day in writing what I thought was just idiomatic Elm code. That was a big moment for me.
Apologies for the corny joke. I was running on little sleep this morning when I saw your question. It's funny because the question sounds like it deserves some sort of complicated answer, but nope! Just a few lines and you're done. F# is really good at this kind of thing: taking pieces from other .NET libraries and transforming them into something useful with very little code. Years ago I wrote a set of apps to get links from new sites and collate them into one master link page. The more I messed around with it, the less code it looked like it should be! I had to stop before I ended up with an example like the one above. Ha! Because of that, some people are using F# as a systems scripting language. That looks pretty cool. Likewise, OCaml is being used by some folks for system scripting on the linux side of the house.
F# is so much fun!
Are we going to get better recognized project types anytime soon? Really hate having to wire everything up in a C# project because the tooling doesn’t recognize the F# project as a web app or whatever. I would love to use F# only for my Azure Functions, but I am not going back to script files from precompiled now. 
Great news. A comprehensive list of improvements. Very nice walk through on the features. Good Job F# Team and Thanks for bringing this to use!!!
Is there any information in the topics of the talks (other than the programming language).
Try to create a GUI, HoloLens, use the VS designers or data modeling tools in F# and then in VB.NET.
That would be good. I've not used Windows for about 4 years now, there are quite a few of us. I still think F# suffers adoption because it's too associated with the Windows tooling and ecosystem.
Yup yup. I'm trying to learn more of the F# langauge, since I recently inherited a legacy C# system and immediately wanted a functional solution that played nice with it. Starting off with using it to automate and batch a few things, then I'll start slowly introducing it to the main codebase. I really like it.
I will both challenge one part of your response and agree with another :) I think it's great that F# is not stuck shipping only with Windows-specific things if we want to release something. F# is fundamentally cross-platform: features are designed with cross-platform in mind, features are prioritized if they involve cross-platform runtime components (e.g., `Span&lt;'T&gt;`), and our own `master` branch on GitHub allows you to run `build NuGet` in the Compiler Service folder such that you can build a fully language service with the latest compiler and include it into your own editor (which is what Ionide does, for example) as a .NET Standard 2.0 component. Perception issues have to catch up with today's technical reality, which is a challenge, but certainly not one that is insurmountable. But at the same time, I don't see it as particularly good for F# to release without an associated Visual Studio update. The majority of measurable usage of F# is still on Windows with Visual Studio, even if the target for these developers' apps is not necessarily Windows. Many developers use Windows for developing software. We will strive as much as we can to align things so that we can continue to deliver for this important and growing cohort of developers. But we're not shackled to that as the _only_ way to ship something. If for some reason VS were to not release any updates for a year, and we had a bundle of language features we wanted people to use, we'd have a fully supported way to do so.
When Don mentioned (on Github or somewhere else) suggested that the next release should coincide with Visual Studio, it sort of annoyed me as well. I understand the practicality, but the perception of releasing in lock-step this way (at least for me) is that "official" F# development experience is somehow implicitly subordinate to Visual Studio (and C#). The thing that struck me as refreshing about the F# ecosystem when I first started was that it seemed more independent, or shall we say more FOSSy. The Microsoft tooling was nice, I didn't feel dependent on it. There were community tools like FAKE for building from the command line without writing a bunch of powershell/MsBuild scripts or F5ing in Visual Studio. There was an alternative nuget client (that worked with C# projects as well.) F# has obviously come a long way since then. It was open-sourced (maybe a year?) before .NET itself. The ecosystem has made great strides toward becoming more cross platform. There's are several editing environments now that're somewhat on part with visual studio. F# is more independent than it's ever been, and yet its release cadence is still curiously tethered to a Microsoft IDE that only runs on Windows (sorry VS Mac). As you've said, it doesn't *have* to be this way. F#'s progress already seems so held up by decisions/changes driven by the C# team (eg. having to interoperate with Span, the new non-nullable reference feature, the design of dotnet core that essentially broke F# and FSI which is still broken.) It would be great if F# planted a flag in the ground for once and did its own thing. Although, I do understand that decoupling from the VS release cycle may not be the most practical way to make that statement.
There are literally dozens of us. Dozens!
Ha ha!
Hi, Alfonso will talk about Fable 2 – its benefits, performance improvements and will also show how to migrate to the new version. And in short – Saša Jurić will talk about simplifying systems in Elixir; Philip Wadler about category theory for developers.
This is fair feedback. Though do make sure to direct frustration my way (not Don's), since I called the meeting to assert we'd ship F# 4.5 with full `Span` support this year, and alongside the VS 15.8 update :)
I think i get the rationale for supporting span. I'm just more frustrated that changes keep coming down the pipe that more or less force you guys to drop what you're doing . Is there anyway you could ask the C# division to pump the breaks on the framework changes so F# can catch up? :)
I think this is implying that we had a set of planned changes to work on that are now being dropped. All previously worked-on features are still up for a release just as before. I've been planning and prioritizing nullable references work for some time now, including working with the C# folks to make sure interop is great and that they can handle anything we emit appropriately - for example, the door is open for C# to better understand `Option` in this world; we just don't know what that would entail and thus haven't written it down yet. Nullable references are as big as generics in terms of impact for .NET. Being late to that party would _not_ be okay for F#, despite our existing remediation features against `null` when using only F# types. But for most people, this is not something they can do nor control. It's also useful for people using Fable, as `null` can flow in just as easily in that ecosystem, and the Fable story is also one we're considering here. Nobody is forcing us to adopt this, as C# 8.0 will work just fine if it sees binaries compiled from a language without nullable reference types. There are no plans to bring this to VB right now, and they need to interoperate that way. We could very well just not do the feature for F#, but I'd ask you this question: How quickly would you demand nullable reference types once C# and CoreFX can emit metadata that allows you to distinguish `null` from non-`null`? My guess is very, very quickly. F# Interactive is a pile of 10+ years of technical debt whose chickens have finally come home to roost now that you cannot guarantee an older MSBuild binary is present on someone's machine. This is work that must be done carefully, and it is, but it will take time. There is nothing big about .NET Core - since perhaps 1.5+ years ago - that is fundamentally different w.r.t what F# must worry about. It's that F# components such as Type Providers and FSI take a very, very long time to break old technical assumptions out of. It also helps when you don't have a disaster-level breakdown on CI servers that eats ~3 months of developers' time they could otherwise be spending on FSI bring-up!
&gt; I've been planning and prioritizing nullable references work for some time now Yes. I saw your RFC. Nice work. &gt; There is nothing big about .NET Core - since perhaps 1.5+ years ago - that is fundamentally different w.r.t what F# must worry about. I thought the sticking point was `#r` includes. Maybe I misunderstood. &gt; F# Interactive is a pile of 10+ years of technical debt whose chickens have finally come home to roost Would it be possible to release a v2 CTP executable alongside normal fsi, which would continue to be deployed on CI servers, etc... ? Just having it available for the REPL would be handy. 
`#r` includes are a major sticking point, but not so much in terms of how .NET Core lays things out on disk, but because of hard dependencies and assumptions that FSI has. It may have been a good design many years ago, but it was not an extensible one and we're paying that tax now. Additionally, we need to be able to produce FSI as a .NET Core application using a supported build system, and today it still relies on `project.json`. Yep. The FSI executable that ships with the .NET SDK is usable (-ish), and actually does work so long as you don't need to reference any additional `.dll`s. A hack to get around that is to reference then in a project, build that project, then include that project (and any files you want to reference) into a script.
Another thing to note is that there are also some experience-level questions to figure out and make sure that CoreCLR and desktop FSI support them. For example, say you have a solution level script over a solution that has .NET Core and .NET Framework projects. In what context does FSI run with that script? What if FSI is already running under one context (.NET Core, referencing .NET Standard components), and you attempt to execute a script in another (.NET Framework, referencing Framework components)? Figuring out how to support (or not support, but gracefully) these sorts of things is also a part of the work.
You're saying fsi.exe so I'm assuming windows. You could use the where command depending on which windows versions need to be supported. https://superuser.com/questions/49104/how-do-i-find-the-location-of-an-executable-in-windows Otherwise you could search your windows path yourself (hint: there can be two, one for the user and one for the system).
The problem is that the fsi.exe is not on the path by default AFAIK .. so im thinking that if they have .NET framework sdk installed i could find it in some special location
For numeric values, units of measure are also an option. Another advantage of those is that they are erased at compile time. See here: https://fsharpforfunandprofit.com/posts/typesafe-performance-with-compiler-directives/#using-units-of-measure
I'm working on a tool that analyses the logs of version control systems to check which files are commonly changed together. Quite new to fsharp, so I reckon this is a good first project.
IIRC FSI is bundled with the .Net SDK, so it's generally only available for developers unless you're distributing it. I hope and pray that this (painful! glaring!), issue will be resolved with newer .net core versions, extensions, and side-by-side installation tooling... That said: depending on what your script is doing an early failure and warning about a missing environmental variable (FSI_PATH?), might do the trick. Let the user specify it in their variables and forget about doing anything smart... If an environmental variable is too hobo: you'll find FSI in *"c:\Program Files (x86)\Microsoft SDKs\F#&lt;version&gt;\Framework&lt;version&gt;"*. So if you list out and reverse sort the directories for F# and Framework versions you could always be running on the newest FSI. You may very well want to lock at least one of those values (if not both), so a check for a specific path and erroring if its not found wouldn't be the worst thing.
I agree, one could go with some solution that definitely finds fsi.exe in the end. E.g. use where, if that doesn't work scan the path, if that doesn't work scan the probable installation directory (see above), if that doesn't work scan all drives. This sounds like a much bigger source of errors than just expecting FSI\_PATH and a good error message to tell you how to solve it.
I miss working in F# regularly :(
Are you using Elmish.Bridge?
GUI: I yesterday learned that F# has no partial classes which are used in WPF. So making WPF applications is more complicated because this (?). But today I learned that Microsoft wants to make Winforms and WPF Programs possible on Windows-Dotnet-Core, and in all 3 languages ( C#,VB, F#) ! see the link [https://blogs.msdn.microsoft.com/dotnet/2018/05/07/net-core-3-and-support-for-windows-desktop-applications/](https://blogs.msdn.microsoft.com/dotnet/2018/05/07/net-core-3-and-support-for-windows-desktop-applications/)
BUILD 2018 sessions from May are old news in August for any savvy .NET developer. Yes, .NET Core will replace .NET Framework long term, still GUI tooling will be C# and VB.NET only, no F#.
Not as a direct dependency but they are very alike. This one has a notification area and a view function to render those notifications depending on their content. Some gif on twitter: [https://twitter.com/DiEsmerio/status/1024768124648873995](https://twitter.com/DiEsmerio/status/1024768124648873995)
A parsing library that implements OMeta's algorithm for handling indirectly left-recursive grammars and parameterized nonterminals, but based on FParsec-like combinators.
Wouldn’t it make more sense for map.tryGetValue to return a Maybe?
An Expecto addin for MonoDevelop.
I made an exe for that: [https://github.com/vivainio/fsirun](https://github.com/vivainio/fsirun)
Not if it required an attribute. It would be a completely erased wrapper. Sort of how TypeProviders generally work.
Perhaps, though this would then make the definition uglier than a single case DU :) Perhaps there’s an optimization to be done for single case, though erasing them is likely out of the question. The space of “I want to apply semantics to a thing without it being a real type and in a lightweight manner” space is worth exploring, though.
After see this: https://poshtools.com/powershell-pro-tools-for-visual-studio/ Yes, I'm pretty sure F# is doomed
A framework for building functional-style WinForms (and soon WPF apps) https://github.com/Acadian-Ambulance/vinyl-ui
Great news! But I wonder, can I use Fable without FAKE and without Paket now? Last I checked there was a dependency on one of them (forgot which).
Got excited about a possible compilation to web assembly. One can dream... In all seriousness this is great news, things like this keep F# alive
* Even in the newest Visual Studio 2017 Enterprise, F# is clearly a second class citizen. It does not let me create a WPF project in F#. Or windows forms project. Or anything other than library or console program. Not having graphical editor support for WPF and Windows Forms does not make F# a second class citizen. Every non-trivial projects in VS2017 is a solution with several interconnected projects. It is perfectly normal to have a project with business logic and one with GUI interface. The easiness VS provides to interoperate between projects does pretty eliminate language barriers. * c# / f# interoperability is abysmal. In the C world, I can mix C, C++ and asm source files. Even in Visual Studio. In the JVM world, I can mix java, kotlin, scala, groovy source files. In dotnet, C# &amp; F# seemingly cannot even coexist in the same project. In the cloud/micro-service/IoT/multi-core era, mixing different languages in the same bigger components is far less important than being able to deploy multiple small components in an environment that streamlines their composition. I don't see benefits in being able to mix F# and C# in the same executable component. * The VisualStudio C# IDE is about where IntelliJ &amp; Eclipse were 5-10 years ago. Which is completely okay. But the F# IDE is really bad. I get some syntax highlighting, but no help to get the syntax right or any kind of "you probably meant to do this". In 28-years-long experience I've worked in all the mentioned IDEs (and more). Microsoft Visual Studio might have been behind others for a few months, but for the greatest majority of time it's been well ahead others. Since community (free) editions are available, the price tag is also no longer a deterrent, making Visual Studio the best IDE for Windows development. I have seen many attempts to do better, none has succeeded in the long term. Being 1 year behind in this market would be almost suicide, 5-10 years is inconceivable. If Microsoft spirit doesn't change, now that the company has embraced OSS I would bet that in a few years Visual Studio and Visual Studio Code would dominate over every other IDE for software development * In default setting, the VS F# IDE creates tab characters, which the F# compiler dislikes and does not show whitespaces. So to indent, you have to press space exactly 4 times. Tab creates invisible errors. VS really seems to hate F#. How would this absolute (3 microseconds solvable) triviality have any importance in defining the validity of any IDEs is really difficult to understand * F# debugging is broken. In VisualStudio breakpoints don't fire or cannot be set at all. (It seems VisualStudio is innocent here, it doesn't work in rider either.) Expression evaluation seems broken, even though F# seems great for this sort of thing. F# is different than C# and C++, so the debugging experience is also different. After the necessary learning curve, F# debugging becomes perfectly fine. Moreover, a real use of F# power drastically reduces the necessity for both debugging and testing. * Error messages are pretty useless. "Unexpected identifier in expression". Maybe half a screen from here. Thanks. Having worked with at least 15 different languages, F# error messages system is not different than others. The beginner always has problems in understanding error messages from any languages. With experience the developer tends to write right code earlier and so less error messages appear and they are more easily understandable. However, if that same developer tries to learn a new language, he is suddenly back to beginner, and the error messages will result difficult for a while. This doesn't mean that the new language has more useless messages, at all. * On MSDN F# seems to be the language that least often gets examples. Even VB (has anyone actually used this this century?) seemingly gets more love. VB, C# and F# are all .NET languages but are very different and have different targets. The spectrum of developers around the world is hugely variate. There is the Sunday developer that simply wants to display a form with a couple of buttons and two labels, and there is the genius researcher looking for the most elegant or performant way of implementing a generic type library. There is abundant material and examples available online for F#, but they are mostly of the second type. It doesn't make sense to expect examples of how to run a Ferrari in the outback. Whether Microsoft is serious about F# is not a matter of personal judgement. Microsoft is an established business with an important reputation: if they say they are serious about F#, that's all that matters.
 "FSharp.fsacRuntime": "netcore" 
Doesn't work on Windows in latest VSCode with ionade-fsharp. The output for F# Language Service shows: [16:04:48 INFO ] Logging to output at level INFO. If you want detailed messages, try level DEBUG. [16:04:49 INFO ] listening notification on /notify started [16:04:49 INFO ] listening notification on /notifyWorkspace started [16:04:50 ERROR] Cannot execute lint, File 'c:\...\src\App.fs' not parsed [16:04:50 ERROR] Cannot execute simplifiedNames, File 'c:\...\src\App.fs' not parsed [16:04:50 ERROR] Cannot execute unusedDeclarations, File 'c:\...\src\App.fs' not parsed [16:04:50 ERROR] Cannot execute unusedOpens, File 'c:\...\src\App.fs' not parsed 
When building it adds a `.fable` folder with a bunch of projects cloned inside. Is this intentional? It seems really weird and adds more mess. It also messes up Ionide in VS Code, as it is unable to parse the .fsproj files.
Rewriting a simple VB6 user management app in WPF with Elmish.WPF and SqlDataProvider.
Hi, I am a noob too, I have 1 question, how can you use c# for the graphical interface and then f# for the logic? 
Yes, very much so, if the GUI layer you are using (WinForms, WPF...) happens to have better tooling for C#.
Well, yeah, but http://fable.io/repl2/
I haven't profiled this, but I had a crack at the Game of Life recently too. Just as a way of learning some more F# [http://gitlab.t0mb.net/tom.boland/conwaysgameoflife/blob/master/ConwaysGoL/Program.fs](http://gitlab.t0mb.net/tom.boland/conwaysgameoflife/blob/master/ConwaysGoL/Program.fs)
I posted one in the OP
I don’t know if this is a performance improvement, but would using pattern matching instead of if statements help? IIRC if statements evaluate sequentially but a pattern match with when guards and tupled pattern would evaluate all patterns simultaneously - correct me if I’m wrong!
good idea, isAlive can be pattern matched!
Aahhh, I thought it would be something like that. In hindsight, the syntax for indexing lists makes this apparent. Thank you!
&gt;MS does not care about the language (meaning they might abandon it or make decisions about the .net ecosystem that might impact the usefulness of F# People have been wringing their hands over that for years and years. F# is still here, and it still gets regular upgrades. The worst case is that Microsoft completely pulls all of their resources *and* all of the community contributors also all pull out, all on the same day. What you'll be left with is a solid open source toolchain you can still use to build your software as long as it takes you to transition off the dead platform, which could well be the rest of your career, if that's how you chose to play it. That's a pretty good place for a computer language to be in. Ask anyone who's dependent on a binary-only single-sourced language implementation if they'd rather their language be in the position where F# is now. &gt; F# is clearly a second class citizen. How could it be otherwise? Microsoft currently has a bunch of current programming language offerings: * F# * C# * C++ * T-SQL * VB.NET * TypeScript * PowerShell * R (via Revolution Analytics purchase) * JavaScript (IE, Edge, Node, Apache Cordova...) There are other languages I could put on that list which are even less well supported: C11, C++/CLI, Python, etc., but let's take this list as it is. Look at F# in that context. Is it really in such a bad position? Would you really expect Microsoft to split their large but finite resources equally among all of them? No: one of them will dominate, as in any competitive market. Microsoft will send more resources to F# as adoption grows relative to the other languages. F# is in a great position to do that as people keep hitting the productivity walls we can no longer pound our way through by throwing Moore's Law at the problem. We're going to have to learn to program smarter now that the free ride is over, and F# is a great tool for allowing that, given that although [IQ rises](https://en.wikipedia.org/wiki/Flynn_effect), it does so too slowly for business to put much reliance on it. &gt;In the C world, I can mix C, C++ and asm source files. Try passing a std::vector reference to a C function. Try iterating through the vector in assembly. Try calling through a C++ object pointer's vtbl in C. It's just the same in .NET: if you're going to mix C# and F# in a single VS solution, you probably shouldn't be defining F# interfaces that require curried calls or that expect you to pass discriminated unions. Just as you say `extern "C"` at the interface between C and C++ modules, you should use structs, arrays, and lists with tupled function calls between F# and C# modules. &gt;In dotnet, C# &amp; F# seemingly cannot even coexist in the same project. C# and F# have different building behaviors, so they have different project types: .csproj vs .fsproj. Just for one thing, F# requires that you list modules in reverse dependency order, while C# does not, so the same project interpretation logic can't be used for both. It's easy to get around this: generate a C# application solution and add an F# library project to it. You can call between the two projects just as between two modules in the same project, because they're built into the same .NET executable. &gt;It does not let me create a WPF project in F#. Or windows forms project. Same solution as above: write a thin GUI shell in C#, which calls down into an F# library that does all the real work. You wanted to separate your GUI and core logic code anyway, right? Right?? &gt;Error messages are pretty useless. I think a lot of languages train programmers to write screens and screens of code, then try building it all at once, dealing with the error messages like a to-do list. Compilation is so expensive in these languages that programmers learn to put it off as long as possible, which creates bad habits when you get to use a language where compilation and linkage is fast. In F#, you want to lean on its continuous compilation feature heavily, getting back to a state of no red squigglies as quickly as you can. Ideally, every line you write should give a program that passes the background compiler, so that a proper build always succeeds. That's not to say that every build results in a bug-free program, just that it should always give a syntax error free program. When you write F# this way, it's usually a lot easier to figure out why you're getting the red squigglies: the error is almost certainly on the line you're writing and thinking about right now. In this mode, I tend not to care so much about the actual error message text. I see the red squiggly line, and I go, "Ah yes, of course, that's wrong" after a second or two of reflection. The fix is usually immediately evident from this. &gt;On MSDN F# seems to be the language that least often gets examples. I'm impressed by how many F# examples they *do* give in MSDN. I'm also impressed by the fact that the F# example is almost always shorter. :) &gt;the compiler does not do any of the crazy optimisations that are possible with functional languages Examples, please. &gt;think GHC for haskell This would be the language that's famous for occasionally producing slow binaries because the programmer accidentally fell into some kind of lazy evaluation trap? Eager evaluation makes F# code's performance easier to reason correctly about, IMHO, which means you're more likely to write fast code in F# than in Haskell, modulo the .NET performance hit. Better algorithms usually dominate performance over better low-level optimizations, which means it's far more important that the human understands the performance characteristics of his program than it is for the compiler to do tricky little things to squeeze another 1% of CPU time from an inner loop. Now, if you want to complain about how F# doesn't have a native x86\_64 compiler yet, I'm right there with you. :) (I'm not talking about .NET Native here, but that's [also still a known issue](https://github.com/dotnet/corert/issues/6055).)
I feel like getCellValue could be pattern matched too, it would just look a little uglier with the guards. I tend to pattern match everything except for Boolean statements.
Thank you so much! Greatly appreciated!
I'm still learning F#, so I'm currently making a program to generate roguelike items and treasure as a way to get acquainted with the language. I'm trying to stay as purely functional as possible to wrap my head around these new paradigms.
This
You're welcome. I've just been writing the 'Performance' chapter of my forthcoming book 'Stylish F#' (Apress, due out Q4 2018), so this issue was at the front of my mind. I'm going to treat u/jdh30's agreement below as meaning he also agrees with everything I've said in the chapter. Even though he hasn't seen it. ;-)
Ok. I'll hold off until Fable lets you do Fable development in the browser. :-)
Send me a copy of that chapter if you want me to take a look. I'm sure it is already awesome! :-)
If you want to get *really* fancy, you might want to read up on Bill Gosper's amazing [Hashlife](https://en.wikipedia.org/wiki/Hashlife) algorithm, which uses Quadtrees to represent the game board and uses memoization to say "Hey, I've seen this pattern before, so I know what it produces". Follow the links in the Wikipedia article to read more about this algorithm. It might be a bit of a challenge to wrap your head around, and implementing it in F# would be a further challenge if you're new to the language, but challenging yourself is the best way to grow.
See also http://jennyhasahat.github.io/hashlife.html for a decent explanation of the algorithm (that's the current version of one of the broken links in that Wikipedia article).
I want to start using F\# more, so to get acquainted with the syntax and the FP paradigm, I created a tool. This tool computes temporal dependencies in a version controlled repository. A pair is considered coupled when they occur in the same commit. The project consists out of three project and has less than 600 LOC. I would love some feedback!
I've DM'd you on Twitter. Other modes of contact are available. ;-)
Ah, I tried to explain it a bit in the readme and the comment here, but I suppose it's not a very good one. Two files are "temporally coupled" (have a timely relation) when they are changed *together* frequently. Together as in, part of the same feature/functionality request or bug fix for example. This tool checks it based on git commits (or TFS changesets).
Sweet, that's a great next step to keep using this project to learn more f#!
One more reason why you should not have a project manager... He banned it for now, but you can still educate him. Propose to educate your colleagues and do a small project. Maybe that can change his mind. Either way good luck! 
It might be worth it to bring up how much time/money was saved in your small project (plus general extrapolation to larger projects) vs what it costs to do whatever level of training you think he/your team would need. Or maybe try to set aside some time (e.g. brown-bag lunch) with him to show him the "scary" syntax isn't very difficult to learn.
Unfortunately, this reaction - "This doesn't look like a C style language and thus cannot be used!" - is way too common in our industry. My advice is to spend schedule a learning session with developers on the team (and your lead), focused a bit less on "we should do stuff with F#" and more on thinking about how to approach problems differently with another language (F#). Although I've run into countless C# developers who stare at real-world F# and run screaming, I've never encountered a C# developer who sees introductory/learning-level F# code and outright rejected it. Usually when they first see DUs and pattern matching, they're keenly interested. Build from there, and the risk of a learning curve will seem a lot lower for your lead. This is all dependent on having a workplace culture where learning new things is encouraged, though. If it's not, then I recommend changing jobs.
Why is he reading your code? And why does he expect to understand a new language just by looking at it for one minute?
Looks pretty good to me. A few comments, broken down by file. **Helpers.fs** I might put a few comments next to `split` and `pair` to describe what they do; tt isn't immediately obvious. The `hasExtension` function might be more succinct with `List.exists`. **Library.fs** Point-free style can be nice and concise, but it can make reviewing code outside of an IDE harder. Just an observation. **Args.fs** Couple of points here. Firstly, semi-colons are optional if you are also using newlines (c.f. `Options`). Secondly, you might be interested to checkout the Argu package, which I really like for handling command-line arguments. **Program.fs** In `orderDependencies`, you could write `List.sortByDescending snd`. It is shorter, but less obvious you are sorting by count. But you could have a separate function, `sortByCount`, which is just `List.sortByDescending snd`. When you have a sequence of `Result.map` calls, you can normally combine them into a single one using function composition: `x |&gt; Result.map f |&gt; Result.map g` becomes `x |&gt; Result.map (f &gt;&gt; g)` Often it is useful to prefix all lines that only have side-effects with `do`, just to make it clear you aren't interested in the result of the expression (c.f. `printOptions`). Also, I might indent the Console.WriteLine functions one level and do so consistently for all cases. In general, I find mixing `|&gt;` with `&lt;|` in the same expression is a little confusing (c.f. `main`). You can flip `Args.parse &lt;| List.ofArray argv` around to use `|&gt;` which then looks more consistent with the rest of the expression. And I often like to define my own `Result` module with extra functions on it, one being `reduce` (but I think `result` might be a better name), that takes a Result type and two functions, one for `Ok` and one for `Error`. This would let you remove the `dependencies` binding entirely and `main` becomes a single pipeline function. But overall this looks like some pretty good F# code! Keep up the good work :)
Welp. Change Your Company or Change Your Company. 
&gt; The trick is that you can either be the independent person who's asking if the team wants to play around with something new -- or you can be the excited evangelist. So, if I'm the person trying to introduce something new which of the two is the better one to start out with?
In a team it's not just about what one person has to write, it's also about what the others have to read and work on. As I like to say programming is not just about writing code that works, it's about writing code that you can work with. 
A good programmer doesn’t write code, he or she writes solutions to a problem. Short of some deliberate attempt at esotericism, the syntax and purpose of any snippet in any language is recognizable to even a novice programmer. Why do you think pseudocode exists? If I write a bunch of functions in F#, I can give it to my teammate working in C#, they can make a .dll, and I’ll email them the API. If my project manager blows a fuse because he or she can’t understand my approach to a problem, then they’re a bad project manager and probably only want their programmers to write code that they can work with. Your explanation of a team just sounds like a bad team.
Can't push a piece of rope. Likewise you can't push an entire stack on a group of people who, frankly, probably don't want it. You might could push some small things here or there. Better yet, get somebody else to do it. So you mix it up. Use very little "push" at discrete times and seek out as much "pull" as you can get from the group. Ideally the push part should be disconnected from you, since you're supposedly there to help them evaluate things. If it were me, I'd confess to being a fanboy. I'd apologize for asking folks to take their valuable time to see if this is just a lark or not. (Always apologize. You lose nothing and people are more inclined to be kind in response.) I'd say that my only goal was for us to have more fun writing tighter code. All of this is true, by the way. Even if you're right, you're being a huge PITA by introducing new stuff. This is a good place for outsiders: the boss, a consultant, the program lead, whatever. That outsider applies a slight bit of pressure, "Ok guys, I know we're all under the gun here, but they tell us we're going to have to be able to evaluate this F# thing by next month to see if it's practical to use in production or not. And to do that we're going to need to show that we can write code with it. Sucks, I know, but there it is. How do we minimize the pain so we can still get our work done?" They push a little bit, the team itself learns all as one unit. (Very important, since peer pressure will do a ton more work for you than any amount of arguing, pleading, or lecturing). You see what people are interested in. You float some ideas for possible implementations while people learn. Whatever you can get interest in, you do more of. Then you repeat and rinse with the little bit of outside pressure. Over a period of a few months you should be able to build up enough momentum that various members of the team itself will be wanting to do more. Then you'll be the one advising them to hold back -- which is exactly where you want to be. My friend Bob uses the "If you're really a professional, you do X" routine, which is great for motivating people who want to be at the top of their field, but let's be honest, that's just not the majority of folks. The majority of folks just want to do a good job, have fun, and go home at night to do other things. Not screw around with building their own DSL or whatnot. A coach or hands-on trainer is a good thing here because they can play the pro/fanboy role and after a month or two you can get rid of them. Mission accomplished. Leads or PMs are okay but it tends to limit their effectiveness over time unless they're really careful about how they do things. It's far too easy to fall into the trap of being considered the big assh*le who's always overthinking everything and making life miserable for everybody else because they want to make things more complicated than they have to be. (I'm not saying you're that person! I'm saying that it's easy to be perceived that way. In my mind, F# is the best way to code today, hands down. But the battle isn't in our minds, it's in theirs.) The thing is, many of us are the type of people who enjoy learning and playing around with this stuff. So we're already motivated. We have to find out what motivates other people and help them get more joy and happiness from coding. Honestly I never thought coding would be as fun again as it is with F#. That's the thing you want to share. I'm looking for new clients, so ping me if I can help. I'm happy to do whatever I can without the new client part, just thought I'd be as honest as I could about things up-front. I'm working on a "Clean F#" workshop for later this year which will concentrate on moving C# folks over to F#. It needs some work but it's also the kind of thing which makes for a good kickoff for this kind of journey. Having management approve of everything stopping for a few days while some schmuck teaches stuff is a great way to impress on people that there is an outside force that's going to require some movement from them -- without you having to be the one applying direct pressure.
You’re working as part of a team, so writing in a language that nobody knows won’t end well. What happens if there’s a bug and you’re not there?
I don’t think he wrote any production code, it looks like he just made a toy web app
Thank you for the review! &amp;nbsp; A few thoughts (mostly agreements) I had while reading your comment: **Helpers.fs** &gt; The `hasExtension` function might be more succinct with `List.exists`. That's exactly what I was looking for. I didn't even know it existed. :) &amp;nbsp; **Library.fs** &gt; Point-free style... Yeah, I don't think it adds much here actually. If I would end up with tons of parentheses, then yes. But I might just add the arguments here then. Besides, I didn't even use it consistently. &amp;nbsp; **Args.fs** &gt; semi-colons are optional if you are also using newlines Good catch, didn't realize this. &amp;nbsp; &gt; Argu package I did a quick search for an argument parser and then found an article on *F# for fun and profit* that showed how to do it yourself and it didn't even look that bad. But the Argu package looks really neat! &amp;nbsp; **Program.fs** &gt; sortByCount, which is just List.sortByDescending snd Oh, I really like this one. I can't believe I didn't think about it myself. I guess I just got stuck in the pattern matching mind set. &amp;nbsp; &gt; When you have a sequence of Result.map calls, you can normally combine them into a single one using function composition. Great advice! &amp;nbsp; &gt; Often it is useful to prefix all lines that only have side-effects with `do`. That's an interesting one. I'll have to keep that in mind. &amp;nbsp; &gt; In general, I find mixing |&gt; with &lt;| in the same expression is a little confusing Fair enough. I wasn't sure what the right way to do it was. I figured since it's on one line it looks quite alright. But I'll flip 'm around. Probably safer anyway, in case I mess up due to operator precedence at some point. &amp;nbsp; &gt; And I often like to define my own Result module with extra functions on it I like this idea a lot. I was thinking about creating a sort of 'Prelude' package with extensions on common modules (like List and Result) and just use that in projects. &amp;nbsp; &gt; But overall this looks like some pretty good F# code! Keep up the good work :) Thanks! I really enjoy FP for problems like this. I hope I can create some good habits early on so the code stays clean and idiomatic. Again, thank you for taking the time to review the code!
A good programmer writes solutions that can be supported, extended, and most importantly understood by the rest of the team and by people the company can recruit and retain. If that's not the case you haven't solved the problem. 
.ýpp
Update: I have been granted permission to schedule a primer for the team - based on my appeal that some of the complexity observed was due to A) the overlay of a WebAPI framework, and B) a few unique features of F# that are actually quite simple if I was give then opportunity to explain their usefulness. My plan: \- Consolidate my main points into a PowerPoint \- Do a live coding session (with the completed solution on my other monitor) in which I portray a payment system
Unfortunately, Python is also often not taken very seriously and treated as a "scripting language" despite being perfectly suitable for web apps and other "real world" things. But it is something more people are familiar with due to being prominent in education.
To be fair, I think he's very competent, and I totally understand his apprehension. But I wouldn't be pushing this if I didn't think there were gains that will make it was worth the effort. I just want a fair chance to present something compelling to my team, and hopefully pique their interest. If their curiosity can be engaged, there is a chance. Your tooling sounds really cool! That is a great example of what a win looks like! 
Interestingly enough, another member of the team has been using Python for various things (Web APIs) and it hasn't raised an eyebrow. 
[removed]
Hi there! If you're on Linux, your best bets are either [VS Code](https://code.visualstudio.com) with [Ionide](https://ionide.io) or [JetBrain](http://www.jetbrains.com)'s "[Rider](https://www.jetbrains.com/rider/)". There seems to be a fairly even split between usage nowadays. I haven't used Rider very much, but I'm very happy with Ionide. Regarding file ordering - I think that both of these systems will allow you to handle this in a non-manual way, (so don't worry about that!). FAKE and Paket are both optional tools. Paket is a tool alternative to \`dotnet\`'s built-in "NuGet," and has several advantages depending on your context. FAKE is a tool to help with build tasks if you find yourself having interesting things going on in that space.
There's still a bit of churn going on since dotnet core was released. There's a lot of third party/community tooling/libraries that are still playing catch-up. Historically, most .net dev wasn't done via terminal. This is why so many of the older tutorials are all Visual Studio based. That's seems to be changing now that we have the relatively new dotnet cli. Fake and Paket aren't required for F# dev. Fake (like rake, psake, cake, etc...) _allows_ you to write your build steps in F# if you want to. This can be nice when your build steps become complicated enough that writing msbuild tasks isn't fun (which is most of the time). Paket is kind of a superset of what nuget offers. `dotnet restore/build/run` should still work for you. Dotnet core, the full framework and mono can be installed/run side-by-side. You shouldn't have any issues installing mono and running netcore builds.
Also about Ionide, it has experimental support for running using. Net core only. I've found it works fairly well, so mono is not required anymore. 
I'm on a Mac, but maybe my workflow is adaptable to Linux (I just haven't tried it). I generally create a .Net Core F# project with Paket and work on it in VS for Mac, using the F# interactive pad to test stuff out. That way, I can still fall back on the command line when messing with project stuff. Sometimes I use VS code, but more often not. I haven't messed around with Fake before (so I can't really speak to it -- blub programmer? :) ), but I almost always use Paket. Except for really small throwaway solutions.
Don't give up! I've fought this fight, and it took \~3 years of off-and-on F# evangelism finally be able to use F# on my team. For me, the biggest factors in my favor, were: * I waited. I tried introducing it to my team 3 years ago and failed. Over time, the team changed around me. A few people moved to different teams, the team split, and we hired other folks. I was heavily involved in the interviews, and I was always on the lookout for folks who liked to learn and who were interested in FP or just programming languages in general. * My company has a good culture of experimentation and learning. I started using our team Hour of Learning meeting to introduce it to the rest of the team. Because I made it clear in the hiring process and the team split process that I was interested in doing a more functional style, the reception here was mostly positive. * I set up a mob programming session where we took a logic-heavy part of our app and re-wrote it in F#. That was super helpful for everyone. This led naturally to the next point: * I proposed trying F# in our code as an experiment. We were already planning to rewrite the data access layer of our code anyway, so we started there. The team was on board, partly because they trusted me, and partly because of the culture of learning and experimentation * We had to fight for it. When I introduced our experiment to the architecture team, there was lots of push back and hesitation. Without their approval, we couldn't use it in production. The interesting side effect of this is that, because they had to fight for it, it solidified my team's desire to use F#. In the end, the architecture team was quite reasonable, and approved it. I think a big part of getting their approval is my tenure at the company. * My manager supported us in doing the experiment. It helps that our managers are not in the code and function more as a support system for us. When the questions of hiring F# devs came up, I was up front that we'd have a really hard time finding F# devs in our area, but that there would be plenty of C# devs who would be excited to learn if we would be willing to train them. * Because we have a microservices architecture, it was easier to get F# adoption on just my team, without the whole org having to buy-in to using F#. Now, I realize that the conditions had to be just right for this to happen, and it definitely depends on the company. Good luck! I'll be happy to answer questions that you or others have as this is all quite fresh on my mind.
I've been running into a lot of issues in regards to Mono and .NET Core on Linux, so I can understand how it's overwhelming. Until .NET Core is capable of replacing Mono, on Linux you'll most likely need both. :/ The other stuff I'm figuring out for myself as well.
Mono is needed for F# interactive on Linux, but you likely shouldn't need it for actual projects you build. I'd view Mono as a necessary dependency for cross-platform tools (for now); but otherwise, using the .NET CLI and Ionide is a perfectly valid way to program F# on Linux.
You gotta be trolling me? So you think that your co-workers should learn the new language at the same time as fixing a time critical bug?
Assuming you are a Python dev who is asked to look at some Lisp, and assuming you don’t know any Lisp, could you look at a Lisp for-loop and tell what it does?
Most bugs aren’t as simple as an incorrect for loop. The reader needs to really understand the code to fix the bug, most of the time. I refuse to believe I’m not being trolled, I’m out. 
You’re honestly trolling yourself. The first sentence of your comment is such a preposterous reduction that I refuse to believe that *I’m* not being trolled. I’m out.
Yay! That's really cool to hear! I don't know the technical parts that will turn your team on or not. Perhaps these examples are great. Just please acknowledge that: 1) functional programming can look butt-ugly if you're not used to it. 2) it's up to the team to decide what styles they are comfortable using. Also please add 2-3 stories from the news about how functional teams rock-and-roll with fewer bugs and happier customers. WhatsApp is a great example of this. They scaled to hundreds of millions of users with an extremely small team. There are a bunch of other great stories. Having a story of where the team could end up if things work out is a great way to show a future vision without having to use a bunch of code. Plus I'm betting the boss will like it too :) Good luck! Let us know how it goes! 
Do you think the interactive F# console will be added to the dotnet CLI tool in the future? For example with Scala/SBT I can run `sbt console` and get an interactive console with all dependencies loaded correctly using the Scala version I specified in my project. If I run `fsharpi` I get the Mono version which is not the same version that is used by `dotnet build`. 
I think that knowing what will access a new file and what it will access, ahead of time, is a good habit to get into. Then, intuitively, you can right click on a file int he Project Explorer and "add file above." Alternatively/additionally, checkout https://github.com/fsprojects/Mechanic
Yeah, especially now that there's Kotlin on the JVM... I'm not sure they can see how far behind they are at the moment.
Is there a site where I can see the status of F# and .NET core?
That's a good question. I'm just guessing, but I'd say yes. You might want to ask in one of the channels in the sidebar or at the [repo](https://github.com/fsharp/fsharp).
Triangle numbers: Seq.scan (+) 1 {2..System.Int32.MaxValue} Splitting a list in half: let halves xs = Seq.foldBack (fun x (l, r) -&gt; x::r, l) xs ([], []) halves [1..10] 
I'm new to F# too, use VSCode + Ionide plugin, never touched VS. I use paket to install dependencies, never had to do anything with nuget. I don't bother with fsproject and build tools either, just write fsx files and include each other. I figure when I have something viable and big enough I'll properly setup Fake. A side question since you mentioned scala, I'm dabbling with it too and trying to do the same thing: avoid sbt and just write scripts. It seems ammonite alone is enough for making a sizable prototype app. Have not had enough luck on getting IntelliJ picking up dependencies from the scripts though. If you or anyone here has any tip, I'm all ears. 
Nice! I personally prefer a more "readable" version of the fold and foldBack function: input and initialState -&gt; foldBack with bla `let halves xs = (xs,([],[])) ||&gt; Seq.foldBack (fun x (l,r) -&gt; x::r,l)` But this is only a personal preference. Nevertheless. NICE!
Seems like I saw a ray-tracer in one line of F# several years back, but heck if I can find it now.
One of my favorite side effects of `match!` is that it makes eastern europeans seems way more excited about things than they would likely intend :)
\&gt;The first thing you may notice about F# 4.5 is that it’s higher than F# 4.1. But you may not have expected it to be *four* decimal places higher! I was also thinking, did I miss something?
I'm glad they did this, ironing out these little quirks help reduce the cognitive load on people new to the language and makes it more likely they'll pick it up. 
Yeah that was a weird bit of historical cruft. "Why is FSharp.Core's assembly version 4.4.1.0 for F# 4.1?" -- "Well you see, back in the day there was .NET 2.0..."
When will they allow native compilation?
\&gt; The .NET interop is pretty much flawless Eh, no, not really. :( 1. Completely different build systems. 2. All the nice F# stuff like unions, lists, modules are \*horrible\* to use from C#.
Very happy to see the relaxed indentation for lists and arrays. Re: side-by-side compilers: I had no idea that was a thing, but it sounds like much hair pulling will be avoided due to that one. Y'all are like Men in Black saving the F# world from all sorts of unseen disasters behind the scenes. Keep up the great work!
Here's one that I really want: Go to definition C# to F# [https://github.com/Microsoft/visualfsharp/issues/3497](https://github.com/Microsoft/visualfsharp/issues/3497)
You forgot my favourite feature of F# that C# will *never* have: Things must be declared in order. Files, modules and functions. It’s a dream to open up a large project you’ve never seen before and immediately know that the core code is in the files at the top and the surface code towards the bottom. Also prevents circular dependencies. 
Don't get me wrong: I use C# every day, so I welcome these changes! I think they are *great* additions to the language. Obviously, languages copy each other all the time. C# was copied from Java, and F# from OCaml. But I do take your point that there was a slightly conspiratorial nature to my post that is perhaps silly. I guess it's not clear to me to what extent the .net language teams compete with each other vs Microsoft having an overarching strategy as a whole. If the latter is true, then it seems like Microsoft could do a better job at differentiating F# and pushing it to have a higher adoption rate. 
Great points!
&gt; Things must be declared in order. Sort file: ctrl-M,Z I usually just set this to automatically run whenever I save. &gt; Also prevents circular dependencies. No. What it does is force you to shove all related classes into the same file.
I'm sorry, perhaps the actual feature that I was reaching for was "partial application". :D
&gt; C# was copied from Java Not really. C# has a Java-like syntax, but most of its features were from VB and Delphi. That's why we have things like real properties and events.
Isn't that the same thing?
I bring this up for three reasons, 1. I was a huge VB fan for years and years. I still think there are areas where it is much better designed language than C# or really anything inspired by C. 2. It's important to know your history. 3. I was an early adopter of Java and I'm still sore that they completely ignored obviously beneficial features from VB like events and properties. 
That is a good question. My understanding is that currying is the mechanism that makes the feature, partial application', possible. I think that currying of functions happens behind the scenes, and the resulting intermediary code has a class for each function that wraps the other functions, like a decorator pattern. The fact that the F# compiler allows you to represent partially applied functions is I guess a feature. But really, it seems to me that currying and partial application are so closely related that it's kind of hard to separate the two, so I tend to substitute them interchangeably. It's kind of like Dependency Injection vs Inversion of Control.. those two get substituted for each other all the time, but I believe that DI is just one form of IoC. 
&gt; [..] and we could have that today if someone felt like taking the effort. This is true of any feature. For example, if someone was willing to put in the time and effort to make GADT encodings elegant in the runtime, it could be done. But that says nothing of how difficult it would be :) Type Providers isn't just code generation that runs in the background. It's baked into the type system, which is why it's so extensible and powerful (despite its limitations). Source Generators were akin to this, but much like Type Providers, ended up having an IDE story that was too problematic for a large number of cases. For example, how do you reconcile your build depending on the internet? Would a large swath of C# developers really want IntelliSense to become inherently unreliable because a remote resource is down? Etc. So many questions with risky behaviors. That level of risk may be acceptable for F# (though many would argue it is not), but likely not for C#.
All great points... especially #2. I don't hear many people espouse how great VB is. It seems to me that it served its purpose as the gateway drug to get VB6 devs on board with .net, and then everyone seemingly abandoned it for C#. (although I could be totally off on that one -- maybe VB still has a niche?)
I didn't realize that this was considered a feature. To be honest I found order-dependent files and functions very frustrating as someone just starting out with F#.
Something to note is that this a community-proposed _idea_, not an official proposal or spec for such a feature. There are a lot of these (wow, it's over 1k?!); but not every one constitutes a promise to implement things. This is similar to the [F# language suggestions repo](https://github.com/fsharp/fslang-suggestions/issues). So I don't think that feeling dismayed is in order here :)
&gt; &gt; &gt; I think that currying of functions happens behind the scenes, and the resulting intermediary code has a class for each function that wraps the other functions, like a decorator pattern. That's how "closures" work with anonymous functions. If you capture a local variable, the compiler moves that variable into a separate class along with the anonymous function. (Or functions if more than one capture the same variable.)
My take on this is think many of the features of F# that come across as burdensome at first become the guidelines that ultimately serve to make a more consistent and stable result in the end. In exchange for putting up with some more rigorous guidelines, we benefit by allowing the compiler to find more problems up-front at design time. It also is another "feature" that makes F# more predictable, and therefore easier to reason about. Anything that can be left up to the whim of the developer will be... and then you will have every permutation imaginable in the wild. It's kind of like allowing end users to type free text into a date field: you will have no consistency in the database. More rigorous enforcement of standards can be viewed as a feature for this reason. For example, most C# devs have a different idea of how class members should be ordered, even though there are Microsoft guidelines and conventions that have been available since 2001. There are recommendations, but they are not enforced. That's why you see tools like "Codemaid" that try to remedy these inconsistencies. 
&gt; This is true of any feature. Not even close. Many features require changing the compiler or even the CLR itself. But this one could be done entirely in the IDE. 
Fan boys will call any flaw a "feature". True masters of the language will tell it to you straight, then help you mitigate the problem.
Yea. I would really like it if C# had a "super strict" mode. Kinda like we almost had with Code Contracts.
C# 9.0 should remove brackets and switch to whitespace with optional meta tag /sarcasm
lol
haha ok, that helps.
ohhhhh, ohhhhh!! Thinking about your question made me think of a big feature that I forgot to mention: Type Inference! You may be right that imposed ordering is not meant to be a feature; it occurs to me that it may be imposed to reduce the burden put on the compiler to do type inference quickly and efficiently. File and function ordering probably allows the compiler to ignore all the functions and files below when deducing types. (just a guess on my part.. i could be way off here). However, the "fan boy" in me can still appreciate that consistency, predictability and making the code easier to reason about are very real byproducts of this limitation (for the reasons I already stated). It's kind of like "opinionated frameworks": some people learn to appreciate the restrictions provided by opinionated frameworks. In the end it's all about trade-offs and what is important to you. So maybe top-to-bottom ordering of files/functions is a debatable as a feature. But I definitely see type inference is a huge feature, and one that is probably next to *impossible* to duplicate in a language unless the language was designed with it in mind from the ground-up.
It was literally copied from java. That was the main goal - have java on .net
No, J# was "literally copied from Java". And yes, C# 1.0 had properties and events. That's pretty obvious if you've ever looked at any of the core APIs.
Fucked up array casting rules was from Java.
&gt; Not even close. Many features require changing the compiler or even the CLR itself. I think my point still stands. Any feature is just a matter of enough people deciding to invest their time and effort. Just a few questions that come into play assuming that this is "just" in the IDE (which does not imply it is any easier than a compiler or runtime feature): How do you know when something has changed? How configurable is this? Is this dependent on the kind of resource? If so, what kind of tools should you have in the IDE? How to account for things like rate limiting? What if your local machine is set up differently from a CI server and something will build/not build in either based on this? Should there be some diagnostic tools to help with this? I don't think it's straightforward at all.
Valid questions, but F# has to deal with them too.
&gt;Syntax support would be nice, but all we really need to get started with this is an easy way to subclass value types For a Units of Measure implementation to be truly usable, an easy to use and intuitive syntax, like that provided by F#, would be almost mandatory. Subclass based examples like those I have seen using C++ are an abomination. The secret sauce that makes a Units of Measure implementation practical is a powerful type inference mechanism, which C# lacks. That's probably one of the main reasons why F# was the first, and currently the only mainstream programming language to support it. Even attempts using Haskell have been a bit underwhelming.
&gt; WTF? There are a lot of things that make code unmaintainable. Allowing `LinkedList` and `LinkedListNode` to know about each other isn't one of them. Cyclic dependencies on a small scale with closely related types like this are indeed fairly benign, and they're also fairly easy to write in F# with type...and. The problem is cyclical dependencies at the scale of a whole application involving tens of classes.
It’s one of the few reasons I prefer F# over Haskell. Of course F# has its flaws but for me dependency order is certainly not one of them. 
Does ctrl-M, Z sort functions within a module?
Then that wiki page is wrong. `Array.Length`, `String.Length`, `Environment.NewLine` and so on are implemented as properties, and they have always been. The semi-official ["History of C#"](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-version-history) page tells that events and properties were present in 1.0.
I'm not sure that I understand exactly what you mean by this. You don't need HM to know that 1&lt;m&gt;*10&lt;s&gt; = 10&lt;m s&gt;.
Then wiki is wrong. See p. 21 of the spec for 1.0. C# 2.0 added generics. 
You right. C# 2.0 implemented access modifiers on properties. Wiki is wrong then
No you don't, but speaking from the perspective of someone who isn't an expect in type theory and reading Kennedy's two papers (see references), I get the impression that a language with type inference makes it far easier to implement a Units of Measure system than a language without one. I also saw [this](https://www.doc.ic.ac.uk/~dorchard/publ/iccs15-fortran-units.pdf) article that seems to imply that type inference makes it easier to implement an UoM system. I wasn't implying that type inference was a necessity, but that it makes implementation easier.
C# does have computation expressions. They are done with linq. Any type that has a SelectMany is F#'s Bind, Select is F#'s Yield. You typically only see linq used for enumerables but they can be used observables or monadic types as well. You just have to implement those methods or find a library that has them.
In short it completely prevents circular dependencies and tight coupling which ultimately just makes your codebase a bit cleaner. Not sure it would prevent any bugs but should make things much easier to reason about.
True. You are right that you can implement and use the monadic bind pattern in C#; afterall, F# computation expressions are simply syntactic sugar that is powered behind the scenes by a simple class with a monadic bind method. SelectMany is an example of a monadic bind extension method that allows chaining in a functional style. The TPL ContinueWith method is another example. But I think "async/await" is closer to a "computation expression", although it is a "[one-shot language feature](http://blog.ploeh.dk/2015/04/15/c-will-eventually-get-all-f-features-right/)", not a definable "workflow" that can accommodate any bind from any Lifted&lt;T&gt; to Lifted&lt;U&gt;. Thinking about your post led me on a search where I found a really nice explanation of monads from a C# perspective: [monads-explained-in-csharp-again](https://mikhail.io/2018/07/monads-explained-in-csharp-again/) I also discovered along the way that it is technically possible to use the C# 7 feature "generalized async return types" as a pseudo computation expression continuation workflow creator ([if you can stomach using "async" for your binding syntax](https://blog.neteril.org/blog/2017/04/26/maybe-computation-expression-csharp/)). :c However, that still doesn't come close to the flexibility of defining your own workflows with computation expressions! In F# you could have just created your own implementation of async/await as a CE instead of waiting for it to be added! (in fact, [someone has already done that](https://github.com/rspeele/TaskBuilder.fs)).
True, but we don't. Which is why the feature is explicitly not used by some people. Some Type Providers do account for things (e.g., `JsonProvider` from `FSharp.Data` pings every 30 mins to account for rate limiting). That results in sometimes unexpected behavior, as some people will have their `localhost`-deployed JSON payload change only to notice that the Type Provider doesn't change its provided types until you fiddle with the URL again in source, or 30 minutes has passed.
Also, creation of bind functions reminds me of another F# feature that i forgot: custom operators If you don't have computation expressions in C#, then the next best thing would be the ability to create a bind operator: &gt;&gt;= (Actually i prefer this style) But you can't do that in C#, so you have to use a method. To make matters worse, you have to manually create chaining APIs due to lack of forward pipe and partial application features. Even worse than that is having to define all the argument types manually due to lack of type inference feature. :c 
I don’t believe f sharp has an auto format tool, as lovely as that would be
I think the one thing I don't like about F# is `&lt;&gt;`. Every one of my projects start with a file that just contains `let (!=) = (&lt;&gt;)`
A shame because elm has elm-format and it removes so much cognitive overhead not having to think about formatting. Also makes everyone's code more or less the same style which is nice.
Im right there with you. I'm in the JavaScript world in my day job. I would go mad if I couldn't enforce formatting on commit.
For more information about why dependency order in F# preventing circular dependencies is a good thing, see [this great article by Scott Wlaschin](https://fsharpforfunandprofit.com/posts/cyclic-dependencies/)
Last time I tried Fantomas, it actually _removed_ some of my code. It's probably improved since then, though! Also now it's much easier to use now that it's available as a dotnet global tool: `dotnet tool install -g fantomas-tool`
Ehhh, that’s stretching it. Aside from there being more to it than Bind and Yield, CEs in F# were designed to be a general purpose system for computations that exist within a particular context. LINQ was not designed for this at all, which is why in practice it is rarely used beyond being a nicer way to do for loops.
Here is an example of what I am talking about: https://github.com/louthy/language-ext/wiki/Thinking-Functionally:-What-is-LINQ-really%3F
I see your point, you could have the compiler detect circular dependencies without enforcing a compilation order. You would still be missing what I think are two important benefits: * When writing code you need to think about what smaller functions will be used first before composing them into bigger ones. I know some people like to do it the other way around but once I got used to doing it this way writing Haskell just seems messy in this regard. * When reading code, especially big projects, you have the pleasure of functions being declared in order of usage. Again, reading Haskell seems messy in this regard. With C# projects I find myself jumping all over the place when figuring out what a class does. Any particular side effects that concern you?
Any success with the presentation?
+1, thanks. &gt; I had build a Xamarin F# Elmish app "I *built* a Xamarin F# Elmish app..." 
&gt;If we take off our F# hat, ignoring what and why F# does things the way it does, and you read that file do you find it jarring? Confusing? Unintuitive? If so, what about it gives you that impression? Haskell has a mixture of both. The reason I (and I suspect others too) find small to big easier is because when reading from top to bottom you need to hold in your brain functions that have been called but you don't know what they do yet. When you read about those smaller functions you usually have to go back to the big function to put it all together. Lets take: let composedFn a b = doThis (321 a) |&gt; doThat (123 b) let doThis i x = ... let doThat i x = ... My though process "okay `composedFn` calls `doThis` and `doThat`, *remember to find out what they do*. Okay `doThis` does this now I need find out what `doThat` does. Okay `doThat` does that. So if we go back to `composedFn` we can see it calls `doThis` with 321 and `doThat` with 123". With small to big there's much less remembering to find out what a function does. let doThis i x = ... let doThat i x = ... let composedFn a b = doThis (321 a) |&gt; doThat (123 b) I don't constantly have this list of unknown functions in my head where I need to find out what they mean.
&gt;My though process "okay composedFn calls doThis and doThat, remember to find out what they do. Yes, but "doThis" and "doThat" **is** what they do. And by that I mean if those functions are named appropriately they tell you what they do without you reverse engineering their implementation details. This example from the QuadTree implementation demonstrates that. ``` insert : Point2D -&gt; QuadTree -&gt; QuadTree insert point (QuadTree data nodeType) = if withinBounds data point then case nodeType of Tree nw ne sw se -&gt; insertInSubTree data nw ne sw se point Leaf currPoint -&gt; insertInLeaf data currPoint point (QuadTree data nodeType) Empty -&gt; QuadTree data (Leaf point) else zoomOutAndInsert (QuadTree data nodeType) point ``` withinBounds, insertInSubTree, insertInLeaf, zoomOutAndInsert aren't defined yet but they indicate what's going on there, wouldn't you agree? FWIW I also write business apps so we have common background there.
My feeling is that generally, C# devs don't care to write in a functional stye. It feels weird and alien compared to the usual OO way of doing things. And if you do write C# code this way, it'll probably fail review for not conforming to style guidelines. So, although C# keeps adding "functional" features, I don't really see it encroaching on F#'s territory. If you write code in a functional-first style, you'll find F# is much friendlier, where as with C#, you're likely to encounter much more resistance from both the language and the culture. 
The famous "functional programming" answer to that question is no. Hopefully I'm explaining this right. A curried function's arguments are sequenced so they may be applied one by one. Partial application is the process of actually applying arguments to a curried function. In code: let add l r = l + r // this function has curried arguments let addTwo = add 2 // This function is a partially applied version of add. 
The strict ordering is a nuisance at first. After several years, it still kinda is, but now I actually find the lack of ordering in C#/javascript disorienting. When you encounter a function/class/name you haven't seen before, it's reassuring to know that you only have to scroll "up" to find the definition.
The unfamiliar Elm syntax aside, I think in F#, it would be more idiomatic to define the top-level types at the top. Then you'd put all the QuadTree related functions in a Quadtree module. All the "implementation details" would go in a private module inside Quadtree. So, something like: type Point2d = ... type QuadTree = ... and NodeType = ... and Data = ... module QuadTree = [&lt;AutoOpen&gt;] module private Implementation = // Internal functions // public functions 
thanks !
I think we'll have to agree to disagree. I don't get any kind of scroll up or down reassurance. I Cmd+Click functions if I want to see their definition, or I open up the file in split view.
yeah I knew something was wrong with that ... But I couldn't point my finger on it. Thank you!
&gt;background I had been given a verbal go-ahead to present during the next team meeting, but we got sidetracked so it didn't happen today. But the good news is that the boss did announce that I will be presenting on F#, and I think he sounded slightly more open this time. As much as I was excited and ready to present, this has given me some more time to tweak. Even after working on the pptx for much of the last week and weekend, there were still some slides that I felt were too busy and others that were boring. I only have one chance to present this in a compelling and uncomplicated way, while still making it conform to the style that my team is used to coding. I am starting with some basic examples, but I really want to ramp it up quickly to show some real-life examples without showing too much too quickly. If it goes well then I'll donate my pptx; otherwise, I will zero my hard drive and switch to Abacus Oriented Programming.
I think if you used C#'s linq query syntax with Tasks or Nullables, you might get shot.
Fable2 (now in beta) makes that quite a bit smaller. I also recommend configuring webpack to split out the vendor code and version the bundles, this way it will benefit from and play nice with the browser cache. 
"In dotnet, C# &amp; F# seemingly cannot even coexist in the same project." That's just a problem of terminology. A "project" in dotnet-land is a single-language entity. "Solutions" are where you combine multiple projects that use different languages. Just realize that you're working with solutions, and the problem goes away. It's really not a issue at all, although it takes a few minutes to get used to.
Well, bundling the dependencies is a thing, wether you like it or not I'm not here to convince you otherwise. However if bundling, versioning ensures that if your app is updated the user will use the new version (which is identified by the [persistent hash](https://webpack.js.org/guides/caching/)) instead of whatever is in their cache and splitting cuts the download in half, assuming you update your code often but dependencies - not so much. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [DAG - An Immutable Spreadsheet Data Structure • r\/fsharp](https://www.reddit.com/r/programming/comments/99vhf2/dag_an_immutable_spreadsheet_data_structure/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Cool. Will keep the repo and may extend over time.
I thought F#'s attraction was more about the absence of boilerplate, basically that it was a functional-styled scripting language for C#.
Any suggestions?
I haven't done winforms in years -- although, oddly enough, I started a quick winforms app this afternoon. I wanted to play around with drawing stuff and the web seemed like overkill for a four-hour fun project. IIRC, you catch mouseDown, set a flag, track the element as it moves, then catch mouseUp. There was an issue with dragging outside the form. That's all I got from 10-15 years ago. Fortunately, there should be plenty of help available online. Just find it in C# and do the mental translation. Event bubbling is an issue, just the same as it is on the web. Sounds like a cool little project. Keep us updated! Sorry I couldn't be of more help.
Come do projects for life science companies, it is pretty much alive.
"...My primary goal of being able to use F# on my team now appears to be a very likely possibility..." Yay! Happy to hear this! "series of guided exercises..." One suggestion: have you thought about eventually making these into katas? Could be very useful in onboarding new folks -- plus the team itself could help make a few, thereby reinforcing whatever they've learned. Good stuff. Please keep us informed on how things are going!
Sure! There was only one slide that referenced an actual project, so I will replace that with something more generic and then post a link.
Previous link was broken. Fixed.
Link added in the original post.
I'm also learning F#, so what I say may not be of much use. You seem to be using classes and abstract classes quite a lot, I don't think that's very functional.
Kind of looks like a port. Did you copy it from another place? There's nothing wrong with that. It's a great place to start factoring stuff out. Just look for imperative code smells and get rid of them. I'd love to do a raytracer one day. Congrats on getting it done.
Kind of looks like a port. Did you copy it from another place? There's nothing wrong with that. It's a great place to start factoring stuff out. Just look for imperative code smells and get rid of them. I'd love to do a raytracer one day. Congrats on getting it done.
Yeah. Peter Shirley’s Raytracing mini series and www.scratchapixel.com is where I have the parts of the code from. Although I do have a couple of features which are not in these resources. Such as multithreading and the way I calculate arbitrary oriented planes. So I kind of take offense to “did you copy it”
Yes Its not functional in that aspect. Thats part why I posted it here. All resources I read are c++ based, which use class based hierarchies. 
Apologies. No disrespect intended. This feels very OO to me. You've got big modules named scene, camera, and so forth -- classic OO stuff. (Of course you should use these things, but I'm not so sure they are appropriate groupers of code) You've got a bunch of render stuff in the scene module. A scene would render itself, right? Sure, but in FP rendering is the important thing, not the scene. The scene is what goes through the renderer, not the other way around. FP is "inside-out" of OO. I also notice some stuff like "for px in 0..width-1 do" There are other ways to do that. Struck me as kind of odd, but what do I know? It's not a right or wrong thing. I'm just looking at the code to see what it looks like you were thinking while you wrote it. I was wondering why the code was grouped the way it was -- whether it was by design, happenstance, or as a result of using another piece of code as a template. I really didn't want to waste your time commenting on something that perhaps a standard piece of kit. Like I said, never wrote ray tracer myself. I like it. I had no idea what the history of this code was. That's why I asked. My intent was encourage you, nothing else. It looks like a lot of work here. 
Thanks. Maybe im abit touchy feely about this, it was a lot of work 😂. Yes, its very OO since the two resouces (any resouces I read for that matter) were c++ based. The reason why I posted this here was to maybe get suggestions how to used more functional aspects instead of the OO style
Thank you!
Thanks. Maybe im abit touchy feely about this, it was a lot of work 😂. Yes, its very OO since the two resouces (any resouces I read for that matter) were c++ based. The reason why I posted this here was to maybe get suggestions how to used more functional aspects instead of the OO style. The reason for the for loops instead of higher order functions is performance though. Higher order functions allocate new arrays at runtime which is really bad for this kind of stuff. So thats why I chose to use imperative loops.
I personally kind of prefer the old ways. It saves a lot of headaches trying to decide for everything which of the available packages works best, is likely to continue to be supported and will be robust. When I tried starting a little hobby project in F# a while ago, it felt a bit like JavaScript, where I had to spend my weekend setting up VS Code with all kinds of add-ons, then grab an assortment of packages from all over the place to do what I want it to do. I much prefer just opening up Visual Studio, having an existing endorsed framework with template, learning how to use that, since it is 'The way to do it' and not having to worry about all the other stuff. I'm just too tired to be making all kinds of decisions that I am not qualified to make, since I am not an expert in those areas.
.Net Core global tool to tell you what city a postal code is. aka you enter `witw 10008` and it tells you NYC. The entire thing works offline with a local SQLite, and supports over 80 countries. https://github.com/kaeedo/WhereInTheWorld
I've got a lot of irons in the fire, and I'd appreciate any help if anyone is interested. At the moment I have * F# 4.5 merge from Microsoft/visualfsharp to fsharp/fsharp to enable mono to package 4.5 * FsAutoComplete MRs around reacting to file paths for fsi/fact/Fsharp.core introduced by Visual Studio 15.8 * Ionide MRs to incorporate those changes * MRs for Fsharp.Configuration and Fsharp.Management type providers to make them .net core compatible * MR to IFsharp to enable .net core jupyter notebook kernels
Nothing and everything. I have at least four pet projects I'd like to advance, including the rocket simulator. I also have a "real", work-related project which doesn't have a deadline but is about 20 times more complicated than the pet projects. I'd like to finish the rocket simulator. It's a demo anyway, and advance the other ones a bit. As for the work-related project, I haven't decided how to prioritize that yet.
What's wrong with using Visual Studio since your team is already familiar with it? I've had minimal problems using VS and F# for Azure Functions, console applications and scripting via fsx files. Works for classic .NET and for .NET Core also.
ok thank you and what was minimal problems with Visual Studio for F#?
I find f# language server to be work more consistently than ionide in vs code. However, ionide works better if you use fsx files. 
Thanks you. This are very good tips!
Ok I will suggest to the team. Thank you.
I don’t find myself doing it that often, but still more than ideal. In spite of that I’d still contend that F# is safer and more productive than C#, at least in my experience.
If only this was an open source project... And people could help improve it... More seriously, I am personally using it daily and rarely need to reload the window. My current instance is up since several days for example. 
VS was extremely buggy last year so we tried VSCode and then Rider. We found them to be even worse so we've stuck with VS. However, VS is still much less reliable than it was 3 years ago to the extent that F# is significantly less useful for us and we're looking at alternatives. &amp;#x200B;
Can you file an either with Report a Problem (ideally with a snapshot of your process, it’s an option), or via GitHub? Thanks!
&gt;If only this was an open source project...And people could help improve it... &gt; &gt;If you are able to reproduce a repro that cause Ionide to freeze, and force it to need a reload. Please feel free to open an issue :) While it'd probably take me months to become a productive contributor to a project like Ionide, I do spend quite a bit of time (\~weeks / year) trying to make such bugs reproducible (not in Ionide, because I don't use it, but in others like VS, Xamarin,...). Most of the time this is quite hard because these bugs always pop up in relatively huge projects and you have to try to shrink it down to a minimum of files and like half a page of code before opening an issue... I guess most (like my colleagues) don't mind going for that trouble and just live with these problems.
JetBrains Rider has support for F#. They tend to be more responsive to problems than Microsoft in my experience.
Try List.pairwise.
 [ 2;3;4;4;5;6;3;1;20 ] |&gt; List.pairwise |&gt; List.map (fun (a, b) -&gt; b - a) &amp;#x200B;
I think you should use the `function` keyword in `exclude`. Try this: let rec exclude (n: int ) (* no list argument any more, we can use function keyword *) = function (* list is empty *) | A -&gt; A // list is not empty | B(v1, rest) -&gt; // if head = n, then the rest part of list is your result if v1 = n then rest // if head is not n, then exclude n in the rest part else B(v1, exclude n rest) Here is a [online demo](https://glot.io/snippets/f4iaqzk7gd) 
This is better than my so far solution, but it does not seem to handle some cases: Before: B (3,B (2,B (6,B (2,B (7,A))))) exclude: 2 After: B (3,B (6,B (2,B (7,A)))) only one 2 was excluded. The same case for this: Before: B (3,B (2,B (6,B (2,B (2,A))))) exclude: 2 After: B (3,B (6,B (2,B (2,A)))) The logic of your response makes perfect sense to me, but I don't know why it's not excluding the other elements.
`if v1 = n then exclude x rest` can handle this case, this means if v1 is the one you want to remove, then remove the same number in the rest part of your list. Try it online [https://glot.io/snippets/f4ift88x3h](https://glot.io/snippets/f4ift88x3h) 
I dont give a shit goddamn
I'm not sure I understand your example. How do you intend `{ U = () }` to be interpreted as `int -&gt; int`? Would it be the same function in all contexts?
Yes, it would be the same function in all contexts. I was just trying to give a more concrete example.
Do you imagine being able to pass an `int` to any value, and get an `int` back, or just values of type `R`? Would the function be invoked by `() 5`? What about `(fun x -&gt; x + 3) 5`? Which `int -&gt; int` would be invoked in that case, `5 + 3`, or the `int -&gt; int` from your example?
Wish granted.
[XY Problem](https://en.wikipedia.org/wiki/XY_problem). You're asking for a solution. What is the problem you are trying to solve? &amp;#x200B;
**XY problem** The XY problem is a communication problem encountered in help desk and similar situations in which the real issue ("X") of the person asking for help is obscured, because instead of asking directly about issue X, they ask how to solve a secondary issue ("Y") which they believe will allow them to resolve issue X. However, resolving issue Y often does not resolve issue X, or is a poor way to resolve it, and the obscuring of the real issue and the introduction of the potentially strange secondary issue can lead to the person trying to help having unnecessary difficulties in communication and offering poor solutions. The XY problem is commonly encountered in technical support or customer service environments where the end user has attempted to solve the problem on their own, and misunderstands the real nature of the problem, believing that their real problem X has already been solved, except for some small detail Y in their solution. The inability of the support personnel to resolve their real problem or to understand the nature of their enquiry may cause the end user to become frustrated. The situation can make itself clear if the end user asks about some seemingly inane detail which is disconnected from any useful end goal. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/fsharp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
The usual suspects, mostly to do with my new programming language: * I've tweaked the syntax to \`module {...}\` and \`type List(a) = Nil | Cons(a, List(a))\`. * In-house business analytics &amp;#x200B;
Nice!
I have no idea what that means.
I personally use: * `__` if there is no need to use the self identifier * `this` if I need to invoke another instance member I've tried to apply this to the F# docs as well (hence is why you're likely seeing this split), but a large amount of it is older stuff that hasn't been updated yet. [This article](https://docs.microsoft.com/en-us/dotnet/fsharp/style-guide/formatting) doesn't yet have a section on classes or members. Perhaps this could go there?
Would you ever mix the two in a single scope? One member uses `__` and another uses `this` \- they're both good for the use cases you specified.
I do indeed mix them if it's appropriate. We do this in the F# source as well: [set.fs](https://github.com/Microsoft/visualfsharp/blob/master/src/fsharp/FSharp.Core/set.fs#L518)
I finally managed to build F# from source :) &amp;#x200B; What I did: * cloned mono from [https://github.com/mono/mono.git](https://github.com/mono/mono.git), and built \[master\] (no problem) * cloned msbuild from [https://github.com/mono/msbuild.git](https://github.com/mono/msbuild.git), and just called `make` (initially I had to use branch \[mono-2018-04\], but yesterday it compiled just fine on \[xplat-master\] (the default?)?) * cloned fsharp from [https://github.com/fsharp/fsharp.git](https://github.com/fsharp/fsharp.git) \[master\] and set my `PATH` env var to include `.../msbuild/artifacts/mono-msbuild` and proceeded according to the instructions given on [https://fsharp.org/use/linux/](https://fsharp.org/use/linux/), Option 2: Install from source: &amp;#8203; export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/.../mono/lib/ export PKG_CONFIG_PATH=/.../mono/lib/pkgconfig/ followed by the holy trinity `./configure &amp;&amp; make &amp;&amp; make install` &amp;#x200B; Please comment if you're solution to install F# from source differs...
I personally use, when I first started with F#, this, but only because I came from C#. In the first time, it was strange to use any name for that. For a C# developer it is more clear (in the first days or weeks of using F#), because it is familiar. But after the first cultural shock in uses F#, I tend to use \_ or x or something.
Not sure if dis 😑
Since you have some ionide experience, I hope you don't mind if I ask you a quick question: I've got a fairly small FSharp project, a website using Suave, it used to open up in VSCode and Ionide would work great. Now it doesn't, none of the usual ionide features are happening, as if it doesn't recogize the folder as an fsharp project. How can I debug what is going wrong? I've done some of the obvious things like look in the output window for the language service and such with nothing obvious. &amp;#x200B; I am using the old fsproj format, if that is a likely culprit. &amp;#x200B;
What kind of type checker are you doing?
Trying to do basic HM for now but dream of type classes.
There's a command pallette option to get diagnostic logs, that would be the first thing I'd grab and submit an issue for. The next thing I'd suggest to to swap over to the dotnet SDK/new project files, even for .net framework stuff. The tooling/detection for that is so much more reliable, and more unified with the rest of the ecosystem. If you've ever heard the term 'project cracker' followed by cursing and/or excessive drinking, that's what you're using now with old project files. But suave on full-framework should work and be supported. Until yesterday I had a project at work in that configuration.
Is there a tool to automatically convert project files? or a guide on how to do it by hand? 
thank you very much! 
That's not the problem, rather the problem is the obstinancy of the MSBuild team. To fix this, you need to tell MSBuild where the .net framework reference dlls are, and MSBuild knows where these are on windows. For max/linux, you can either set an environment variable, or you can add the following file to your project files with an `Import` xml element: The file to include is: https://github.com/fsprojects/FSharp.TypeProviders.SDK/blob/master/netfx.props And an example of how to reference it is: https://github.com/fsprojects/FSharp.TypeProviders.SDK/blob/master/src/FSharp.TypeProviders.SDK.fsproj#L2 The key concept is that `FrameworkPathOverride` property that's being set in netfx.props. 
Learning type providers. Made a toy type provider that makes member access functional, in order to write something like words |&gt; List.map T.substring(2,3) instead of words |&gt; List.map (fun x -&gt; x.Substring(2,3))
This is one of the things I love most about F#. It keeps you on your toes, so as long as you can keep the compiler happy, a lot of the times your code just works, even after refactoring. And it looks so much prettier than C#, too.
Here's the real question - &amp;#x200B; Why isn't wildcard (\`\_\`) available for said identifier - IE, why does the syntax force us to resort to \`\_\_\` when we really intend \`\_\` anyway? &amp;#x200B; Cheers!
Cool! Funny, I was thinking a lot about trying my hand at Tetris. Very nice.
Sweet! Very cool. I love reading that domain logic. Reads like English, and in a very short amount of time I know exactly how the code works -- and won't work. Congrats on a nice piece of code! :)
Thank you very much. 
This is really nice code to read!
Thank you :) 
https://www.nuget.org/packages/FSharp.Compiler.Tools
Visual Studio is the gold standard of IDEs. It’s pretty much the only selling point of Windows for me. If you’re not using it for F# you’re really missing out. Bonus: VS Mac has intellisense in the F# REPL.
It depends on what you use for the domain/data project(s). If you use F# on the back end, then you might as well use F# / MVC on the front end so that you don't have to worry about hiding F# data structures from the C# front end. At the end of the day, F# OOP still results in less lines of code than C# OOP, plus you get the benefit it not allowing null classes by default if it's all F#. That sounds more joyful to me than using C#. &amp;#x200B;
I echo this. F# interoping with MVC would still be preferable. And consider Giraffe if possible.
There are a few different ways to look at Fable. The simplest view of Fable is that it's a transpiler. It converts an F# syntax tree into a BabelJS syntax tree. And that's it! Well, not quite. This does mean a few things: * Because the underlying runtime is the browser rather than .NET, there are some semantic differences. But the core of F# (functions, types, pattern matching, classes, etc.) all work as you would expect. * Fable supports "native" interop with JS wit the `JSInterop` attribute. * Fable supports compiling with JS libraries and TypeScript definition files. The target runtime is the browser, after all. * Because fable supports JS libraries, it supports JS tooling and UI libraries. Additionally, the preferred way to build a UI with Fable is with the Elmish UI library. It's a very F#-centric way that makes use of F# types, pattern matching, and F# expressions. But Fable is unopinionated, and you could use any UI library you like (it just likely wouldn't be nearly as nice :)). To answer your question: &gt; I have seen a lot of buzz about Fable and Elmish, and was wondering how exactly this works. Would it transpile ALL of my code into JS? Wouldn’t that degrade performance? It's not clear what you mean by performance. Fable is for building UIs, and if you build an inefficient UI then it won't run well in the browser. If you use Fable to do things like churn through lots of data, it will have performance similar to a JS application that does so in the browser.
I'm biased, but I'd use F# for either. You can very easily build an OOP layer in F# that interoperates with the MVC APIs, and calls into a functional core. Your MVC project would be small in this case, with the majority of logic happening in F# libraries.
MVC still (at least in its modern incarnations) seems to fit a functional style reasonably well. It obviously won't be as good as a framework designed for F#, but it certainly won't be obnoxious to use F# OOP imo.
\&gt; F# is a superset of C#. F# doesn't have \`goto\` or partial classes and requires manual upcasting in OO code. &amp;#x200B;
Fable and Elmish are generally used to create WebApps. That is, a Application running on a server, with a HTML/JavaScript frontend (or GUI, if you prefer that term). For your use case, if you already have a Terminal application that does what you need, dropping a webserver and an API in front of it may not take much work. You can then use Fable and Elmish to build a frontend for the app, and you are off to the races. However, hosting a webserver and stuff may not be suitable for your application, if you expect you students and colleagues to be able to access the tools offline. one alternative is to build the main brunt of you application (the logic, that you already have in your consosle app) in F#, and create a seperate project in C# that consumes you F# library and exposes it to a GUI (winforms, or WPF).
good bot
\&gt; Would it transpile ALL of my code into JS? Wouldn’t that degrade performance? &amp;#x200B; If you implemented your numerical computations in the Fable app, yes, most likely. Although JavaScript can be used to write performant desktop applications - [for instance, Visual Studio Code](https://github.com/Microsoft/vscode) \- I don't think it would be a good fit for scientific computing. The use case for Fable is in having behaviorally-sophisticated UIs without having to run through the dynamically/weakly-typed mess that is JavaScript. That said, JavaScript is not a terribly slow language - [the Node.js JavaScript runtime is typically faster than Python.](https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/node-python3.html) And Fable has [Electron](https://electronjs.org/) bindings for creating desktop apps. It could be worth trying. But I imagine a transpiled F# program would be noticeably slower than having one run in the .NET Framework or .NET Core runtime. &amp;#x200B; You really want to think of this as a UI layer on top of a computation layer. For a web application, the UI is typically run client-side in JavaScript (the browser sends .JS code to its JavaScript runtime, or in the very simplest case is only an HTML renderer), while the server code is some other language (F#, C++, PHP, etc) that sends user-facing data to the JavaScript. For a .NET desktop application, it'll all be bundled and run in the same place, but typically with a separate frontend project and a backend project. Unfortunately, either way it'll be a bit of work. And I think we'd need a bit more information about your code to give a good answer - for starters, is this Windows, or Linux? .NET Framework or .NET Core? * Honestly, using Windows.Forms or [Eto Forms](https://github.com/picoe/Eto) is the easiest way to solve the problem of "add a GUI to my F#." Compile your numerical code to a class library and create a separate project for the UI which references that library, then call the numeric functions you need from the UI. * /u/Mischala suggested the standard way F# devs add user interfaces to their desktop applications: in Visual Studio, C# desktop UIs can be built visually using the Forms designer, which is a tool that F# unfortunately lacks. The designer [automates what would be extremely ugly and tedious code](https://github.com/Acadian-Ambulance/vinyl-ui/blob/master/examples/ShapeArea/ShapeArea/ShapeAreaForm.Designer.cs) and lets you drag things around on a screen to build out your UI. Since C# and F# interoperate fairly nicely, you can reference your F# project from C# and call your functions directly. I imagine this would be the fastest way to add pictures and buttons. * If you don't want to get your hands dirty with C# - who would blame you :) - then it's really not *that* hard to write a forms application purely in F#. I am assuming, given your userbase, that aesthetics are a low priority, so you wouldn't need to learn anything fancy or play too much with resizing.etc. Here are some tutorials to get you started: * The book [F# For Scientists](https://www.amazon.com/F-Scientists-Jon-Harrop/dp/0470242116) has an excellent introduction to using Windows.Forms in Chapter 7. Unfortunately it is out of print, but I snagged a copy fairly cheap on Amazon. * Expert F# 4.0 has a chapter using Eto. I have not played around with this but it looks more F# friendly than Windows.Forms - plus, there are tutorials in F#. It's also cross-platform * [https://www.c-sharpcorner.com/uploadfile/f5b919/windows-form-application-in-fsharp/](https://www.c-sharpcorner.com/uploadfile/f5b919/windows-form-application-in-fsharp/) * [https://emmorrisonjr.wordpress.com/code-tutorials/f-tutorials/creating-a-simple-f-windows-forms-application-using-visual-studio-2010/](https://emmorrisonjr.wordpress.com/code-tutorials/f-tutorials/creating-a-simple-f-windows-forms-application-using-visual-studio-2010/) * Like /u/Mischala said, turning your existing F# code into a webserver isn't a bad option. * Note that it doesn't actually have to be a real webserver hosted externally; an ASP.NET Core app is just a console application, and you can use the (amazing) [Fable.Remoting](https://github.com/Zaid-Ajaj/Fable.Remoting) library to have a webpage-based UI talk to the CLI console application. * Unfortunately you'll have a lot of useless boilerplate and overhead. Still, I think this would be the easiest way to use Fable for a high-performance desktop application. The Giraffe framework is both relatively easy to use and a lot of fun, and Visual Studio has an ASP.NET Core F# template out-of-the-box. * You could try forking Fable.Remoting and modify it to have it chat to a desktop application directly. This might be easy, but I don't know enough about JS to endorse it.
The point you bring up about Python is actually why we refuse to use it. F# is giving us performance that *barely* deviates from the C platform we are replacing, so we are getting a more easily maintainable platform without a significant loss of speed. Right now, we are targeting Core, and mainly using Windows. Medical image processing is the application, and some of the images are 2GB+. I wanted to look into Elmish because it seems like that would have the most solution for displaying images, rendering 3D volumes, and embedding charts and plots (like plotly) since I figure I could just use a JS library. Side note - I know there is a plotly F# library, which I am interested in, but I don’t know what exactly I would contain/view it with if I used WinForms or Eto- would this even be possible? I don’t want to have to use directx or any low level graphics framework if I can help it (one guy suggested unity for rendering and plotting, but that would probably be a PITA). With the plotting and image rendering considerations, do you think that Eto could still serve as an adequate frontend, or are my needs likely better suited for Elmish and JS interop? You’re right that a pretty frontend isn’t our primary need, but it certainly wouldn’t hurt! 
I use F# for a lot of things that you would expect to be more OOP than FP, namely file IO. F# struct marshaling is actually significantly easier than in C#, IMO.
\&gt; The point you bring up about Python is actually why we refuse to use it. &amp;#x200B; Upvoted without even reading the rest of the comment :) I think Python is holding scientific computing back substantially because of its bad performance and bad type system. And yeah, for .NET Core apparently in some applications it approaches C/C++, which is very exciting. &amp;#x200B; Unfortunately .NET Core alone simply doesn't do GUIs yet - **and is not compatible with WinForms or Eto**. So ignore what we said about using Windows Forms or WPF or Eto. Sorry :( These will work in .NET Core 3 but we're not there yet. Eto's core internal library targets .NET Standard but anything front-end is .NET Framework. &amp;#x200B; So I think Fable.Electron might be the way to go: your F# library runs on .NET Core natively, as a web server, and exposes an API to the JavaScript in Electron - which is transpiled from F#, and hence can be built in a type-safe way that references the types you use for the numeric code. When compiled and running, there will be two separate processes: a .exe running on .NET Core, and a separate JS application running on the Node.Js runtime. Not entirely sure about the Elmish integration here but Fable.Electron by itself would probably be fine. There's also [Electron.NET](https://visualstudiomagazine.com/articles/2017/11/03/electron-net.aspx), which seems promising. &amp;#x200B; Luckily for both of us, I don't have a real job at the moment and this project seems interesting :) I have been working on data analysis / visualization and might try some of this out myself. I'll send you a link to a GitHub repo if I figure out anything useful - but no promises :)
Our Python prototypes for this project were hilariously slow. I am hoping Julia supersedes Python as the “language of technical computing.” I was pretty excited for Julia, but in the long run a general purpose language on .NET better suited our needs. I’ll definitely be using Julia for other, smaller projects though. I’ve really got my fingers crossed for UWP... I hope with Core 3 we get more news about that. I figured there would be some limitation with Forms or Eto since F# doesn’t really even have Native support yet. Framework isn’t ideal of course since it’s not cross-platform and Core is just better for numerically heavy workloads. I’ll definitely look into doing a JS frontend with Fable or Electron and getting my F# to hook into it. I am actually pretty pleased that this was confirmed to be a reasonable approach since it also allows the possibility for a cool UI, and hopefully three.js and thing.js can be worked into it. If you end up doing a repo, I would love to see it. I’d share my code but we have to keep it internal until we get our papers published on some of our algorithms, but I’ll definitely forward that to you once it’s out for everybody to see - especially if I get the visualizations working.
Good news - proof of concept works: https://imgur.com/a/8z9JaNA I will try adding a few buttons and graphs tonight and link the repo tomorrow. There are maybe one or two bumps between going from C# to F# but it was pretty painless.
Well, it wouldn't need to be hosted, you could ship it with a webserver. Make the users spin it up and take it down when they are done using it. Calling an F# library without a webserver would be difficult, and transpiling the core of your app would have a performance cost.
Hm, I see how you translated the C# from the example public void Configure(IApplicationBuilder app, IHostingEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); app.UseBrowserLink(); } to F# (or at least my best extrapolation) member this.Configure (app: IApplicationBuilder) (env: IHostingEnvironment) = if env.IsDevelopment() then app.UseDeveloperExceptionPage() app.UseBrowserLink() **This seems reasonably doable!** As far as translating from C to F# (which is what I have done the most of), it always came down to not actually translating, so much as knowing what I wanted to do (say, a gamma function) in F#, and being able to use the equivalent C code as a guide/reference. It looks like I'm going to have to learn a lot of concepts that I've been able to avoid, but it doesn't seem like it's an unreasonable undertaking. I'm definitely looking forward to seeing your repo!
look here r/http://push.georgiartro.com
That was my initial inclination, but with Forms not targeting Core 2 and Avalonia being pretty green, I’m leaning towards Electron. Parsing isn’t the issue, it’s that I need a way to display high-res images, 3D renders, and plots/charts. I don’t know if WPF/Forms has this capability without needing a directx or other low level graphics implementation, whereas this is a domain that JS seems to dominate.
Do you know HTML/JS? If not, you're going to have a hard time with Fable, as great as it is. 
That doesn’t look as bad as I expected it would! I think I’m going to pursue Electron, since I can understand the build process well enough. My last ditch effort will be Fable, since the documentation is hard for me to follow along with. I don’t really know JS, but languages are never too difficult to learn, it’s always the build processes and the way different concepts are abstracted that gets me. Hopefully I can follow along your repo and get a better understand of how this all fits together. I’ll fork your repo if I have any successful results so you can see!
These look just like the qT charts I used to use in Python - only problem is that if they’re leveraging forms/xamarin, I don’t think it’s an option since I’m targeting .NET Core
Those are valid nitpicks! I would have posted the video, but I caught a handful of other "untruths" that made me reconsider since you folks are like logic piranhas! ;) &amp;#x200B; Re: Records and DUs being reference types: Perhaps I should have just said that they are immutable and left it at that. But you are right: they compile down to classes in IL (unless the Struct attribute is used). In fact, I should probably update that in case anyone else uses it. &amp;#x200B; Re: superset: Interesting point. Hopefully my team won't show up with torches when they find out that 'goto' and partial classes are missing! (I'm not sure if I would be more impressed or worried if a teammate asks what happened to goto.) If it's not a true superset, it's still pretty damn close... Besides, the "fully qualified" version of the truth would have been less compelling. ;) &amp;#x200B;
This is really slick! I like the dotted-line preview, the "hold" feature, and that you even covered the case where you have a brief opportunity to slide the piece after it touches the bottom. Source looks pretty good, too! Where did `FSExtend.fs` come from? It seems unused. (also its Result type seems redundant; there's one built in: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/results )
Thanks a lot! Really appreciate it. Whoops, FSExtend was just me experimenting. Forgot to delete it. Thanks for letting me know about the Result type, that'll definitely come in handy. I was under the impression you had to create your own after reading some tutorials in http://fsharpforfunandprofit.com (which has been a fantastic resource btw)
Go to the interview. If you fail, learn from it. The only way to prepare is to practice and realise that they likely care less about your ability to write a specific piece of code and more about how you approach the problem.
Yes, go to the interview. Having botched my fair share of interviews, it's really not as emotionally difficult as it sounds, and you will learn something new either way. I am assuming this is a junior software engineer / developer position? I've interviewed junior engineering / data science candidates with F# questions and certainly did not expect them to know F#, or any other ML-based languages. Beggars can't be choosers :) What I was looking for was * General understanding of declarative programming - SQL or R skills were enough for my questions. * Understanding data structures, type-driven development, and basic knowledge of static typing - and NOT algebraic data types. Likewise with "type-driven development" I wasn't looking for anything fancy; just basic understanding of domain modeling. * Quantitative reasoning - this was more specific to my company. But someone who had math skills and struggled with the programming is someone who can learn the programming. Remember that the posting said F# is a plus, not a requirement. If you can solve the problems with declarative pseudocode that isn't syntactically proper F#, that is almost certainly fine. And being able to *read* F# will get you far. I've never given an interview where I didn't give a few hints along the way. If they picked up on the hints and I could "lead them to water," that was really what I was looking for. That said, given that the job specifically mentioned F#, you might be asked questions about recursion, immutability, and pattern matching. These weren't as important at my last job, but it could be for this one. \&gt; I can't solve the easiest leetcode problems in F#. I am not trying to sound like a jerk here, but...can you solve them in other languages? What language are you most familiar with? If you can solve them in your favorite language, try writing out (on paper!) an F#-ish solution. It doesn't matter if it won't compile - what matters is that you're able to understand the problem and find a solution. 
Thanks for the encouragement. I'll definitely focus on the concepts and not worry too much about the syntax. I'm comfortable solving LC problems in C#. I'm good with LC easies, mediums and some hards. This is only because I've prepped a lot for it. It certainly isn't natural. 
thanks. valid points but to clarify one thing: I'll be sharing my screen so this is isn't strictly a phone interview per se. 
Ok, well, a little practice before the interview writing, executing, and debugging F# code would be well in order. You want your muscle memory hot loaded. The other points stand in so much as it will be an actual interview and not just a coding demo.
if F# is a plus and not a requirement, if you get stuck on the F# bit you can sketch out a solution in C# instead, so that they know you can solve it. (depends on whether the interview is to test your knowledge of F# or your ability to solve problems with code)
And if they're more concerned about you having syntax and the System library memorized, you don't want the job anyways. Coding is the easy part of coding.
Hehe ... nice one. I a "tetris clone wars" comming? :D
"does f# have any kind of higher order polymorphism and features like traits? Or is it limited to interfaces?" Yes, but it's a bit of an oddity among programming languages. In general, F#'s type system is limited because interoperability with C# is a paramount concern. The CLR does not support anything like typeclasses. But: F# has [statically-resolved type parameters](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/generics/statically-resolved-type-parameters), which are sort of similar to Rust traits - in some ways they're actually more powerful because you don't have to explicitly define-then-implement something, you just need to have a method with the correct name and signature. In many cases the compiler can figure it out for you without needing to annotate the type: let inline doubleValue x = x + x doubleValue 2;; // = 4 doubleValue 2.0;; // = 4.0 doubleValue "my string";; // = "my stringmy string" // The compiler annotates doubleValue as: val inline doubleValue : x: ^a -&gt; ^b when ^a : (static member ( + ) : ^a * ^a -&gt; ^b) But they have numerous drawbacks compared to typeclasses, sometimes confuse type inference in things like Intellisense (never had a problem at compile time, just weirdness in the IDE), and can be pretty finnicky to use. I really like them but they aren't particularly idiomatic. Regrettably, you can't define a (Rust-style) trait defining the statically-resolved method constraints and pass that around in your methods, so there is still copy-pasting involved. OTOH, being able to restrict generic functions on a by-method basis does give you a lot of flexibility in not having to define a trait/typeclass ahead of time. .NET is probably getting something like [traits](https://github.com/dotnet/csharplang/issues/288) but that's a controversial change. See[ Don Syme \[creator of F#\] here](https://github.com/fsharp/fslang-suggestions/issues/679#issuecomment-399411192) on F#'s design philosophy regarding this. "Also does f# have an equivalent of clojure's transducers/ haskell stream fusions?" Not in the core library. I think F#'s type system is powerful enough to get pretty close to a Clojure transducer, but I am not quite sure, largely because I am not quite sure what a transducer is. This isn't something I've used in my programming - I am a F#/Scheme/Idris person, making me probably the only Idris developer in the world who is fairly unfamiliar with Haskell :) - but you could take a look at this thing I just Googled and see if it fits your needs: [https://gist.github.com/cloudRoutine/9c62477b91547d9d3523](https://gist.github.com/cloudRoutine/9c62477b91547d9d3523)
Uh oh, I'd better change my project to Tetris Dr. Mario :)
&gt;Go to the interview. If you fail, learn from it. Interviewing is a skill, just like any other. So maybe it takes you a few times to get kinda good at it? So what? It'll be fun. I've found that my imagination always creates a much worse interview than actually happens. The more I relax, the easier it goes --- but relaxing (for me) takes a lot of practice.
So just be honest. It said it’s not a requirement but a plus. What’s there to freak out about - what a great opportunity. F# programmers are unicorns.
I'd probably still use F#. If you architect your application layers nicely, then the thinnest and most insignificant layer will always be the web at which point you might just care less that it is MVC or even retrospectively be able to justify an F# web framework as it will feel less important to your colleagues who perhaps were against it in the first place (especially when you will be able to demonstrate how compact you can make the web layer in an F# framework as opposed to MVC which requires multiple controllers and action methods for simple routes).
[Nessos Streams](https://github.com/nessos/Streams) rewrites the compositions like that to provide efficient computations.
That was so whiny. I had to skip down the bottom to see the offered a solution, but it was just a call to whine some more. &amp;#x200B; Why pick the automobile industry, a space which has very clear use cases and performance requirements and is highly refined, and then compare it to *the entire software industry*? Software only gets optimized to the point where it is "good enough" to meet the use case requirement. There are usually trade-offs in the form of time, quality (performance) and cost to develop. &amp;#x200B; If you want to compare a car engine, then maybe compare it to a gaming engine written by, say, John Carmack. There is your optimization and efficiency in the software industry. (I even read somewhere, maybe here, that he is a big fan of FP). &amp;#x200B; Software developers are not the Borg. Even though search engines bring us pretty damn close to a collective consciousness, we are still individuals with varying levels of experience. Even if we were able to merge together into one single consciousness, then we would only be able to develop one thing at a time, so it wouldn't scale. Granted, it would be probably be one *really good* thing, presumably written in F#. Of course, maybe our collective self would be highly evolved enough to build a single microservice to serve them all (although that would likely violate the single responsibility principle). &amp;#x200B; All in favor of merging our individuality into a single consciousness for the sake of making our software behave like a Toyota, say "aye". &lt;...crickets...&gt; &amp;#x200B;
Great article. \&gt; It just seems that nobody is interested in building quality, fast, efficient, lasting, foundational stuff anymore FWIW, I've been working on a simple ML programming language for a couple of years now. &amp;#x200B;
&gt;If you want to compare a car engine, then maybe compare it to a gaming engine written by, say, John Carmack. There is your optimization and efficiency in the software industry. (I even read somewhere, maybe here, that he is a big fan of FP). Carmack wrote incredibly highly optimised game engines in the 1990s. I haven't seen anything impressive since. &amp;#x200B;
Link please?
i don't think it's whiny at all. it is definitely ranty and probably gets a few details wrong, but it is right. i have often thought about leaving software myself because of the situation he describes. if anyone has spent any time at all dealing with software that interacts with hardware, then you can just triple the frustration described in this article. you wouldn't believe had bad it is. so the author is right. nearly nothing works as it should, and it's all more complicated than it should be.
Yeah, I agree for the most part with it. It gets a few things wrong, but that's probably because it's so long that most people would. For example the delay from input to screen has gotten bigger because there's just so many more things happening between keyboard input and screen output now, not because the individual stages are slow. I find especially true the criticism of the developer vs computer time. It might be correct in principle, but a consistent application of this has lead to things like a build taking 4-7h in my last job, uni tests taking even longer because they need the build result and then some. Delays in developing, even if it's computer time, are often also developer time. If you have one problem with your code and you need to find it out you will spend a lot more time searching if you can't just run a few second build and unit tests to see if it improves. Instead you try something out and while the computer spends hours churning you try to find it by thinking. So the developer vs computer time thing just turned on its head. Now you're wasting both. In a large corporation the team working on the tool chain often doesn't suffer from it themselves, so they save developer time, but they cost it somewhere else. 
&gt; Whiny but true. Many of his criticisms are "this thing I didn't write and don't really understand doesn't run as fast as I think it should". For example... &gt; Windows 10 takes 30 minutes to update. What could it possibly be doing for that long? That much time is enough to fully format my SSD drive, download a fresh build and install it like 5 times in a row. Yes. Quite amazing that applying several independent updates while preserving the evolved state of a system is more difficult than farting out a pre-tested set of files in pre-defined locations from a single compressed image, right? Of course, it could be made faster, but would it be as reliable? And, of course, OSes with no legacy to deal with can update faster. &gt; Modern text editors have higher latency than 42-year-old Emacs. Text editors! What can be simpler? On each keystroke, all you have to do is update tiny rectangular region and modern text editors can’t do that in 16ms. "all you have to do"? He's ignoring syntax highlighting (that works properly), language support, unicode, and a whole host of features that modern "text editors" have that EMACS didn't. He's also completely handwaving away the "latency" you would get in EMACS if you ran an inefficient macro. There *are* efficient text editors out there. He's picking on ones that prioritize features. &gt; And then there’s bloat. Web apps could open up to 10× faster if you just simply block all ads. And games would be faster without copy protection and OS's would be faster without security. Web apps don't have ads for "code bloat" reasons, they have ads because that's what pays the bills.
That was a good rant. Thanks. I watch and study the startup crowd when I want to learn how to make things well. They produce value -- or die. That tends to sort things out quickly ! :) (As opposed to BigCorp Developer #THX-1138, who tends to do what they're told/what's popular) In my mind, nobody's making economic decisions about software development/performance \_overall\_. Sue the developer optimizes for language features, Amhit the UI guy optimizes for responsiveness, Vasquez the Ops guy optimizes for uptime. We've broken stuff into so many small pieces, each piece can be rocking and rolling for one silo -- and the overall system suck. But it's always somebody else's problem, right? This actually isn't an issue of total conformity as green-mind says. Just the opposite, I think. If we cared about overall performance there would be hundreds of conflicts in any non-trivial-sized org. Instead, there's crickets. The crickets are everybody grooving out on their own thing and heck with the rest of it.
Thanks! This is how I'm approaching it. I was stressing out too much the past couple of days, so I reached out to the interviewer (who is the director of engineering). I explained to him that my experience with F# is limited and confessed that I struggle with simple coding exercises. He kindly replied and re-emphasized that F# is a plus and not a requirement. They will teach me if I'm willing to learn. I think the interviewer is checking to see if I grasp the main ideas and concepts. If the problems are too challenging in F# then I'll sketch out a solution in C# to demonstrate my ability to solve the problem. 
I think in static typed languages like F# or C# you have to write a function/method that processes the exact underlying type. So you can check the header and call the right function. If this function you call maybe use generic functions if needed. Maybe you look into expression trees.
Right now I have this clumsy match statement to do that. Assuming I have a header read into a record struct, and a field called typecode, where the code specifies a type (eg. 1 = int, 2 = float, 3 = bool, etc). I use the match statement to instantiate the appropriate binary reader as such: let bstream = new BinaryReader(stream) stream.Seek(header.offset, SeekOrigin.Begin) match header.typecode with | 1 -&gt; while stream.Position &lt; stream.Length do bstream.ReadInt32() |&gt; add to list | 2 -&gt; while stream.Position &lt; stream.Length do bstream.ReadSingle() |&gt; add to list ... Obviously this is ugly and makes the type system cringe. It’s slow and janky too, and was wondering if there is a more idiomatic way to do this. The .NET framework is used at an enterprise level so I know this is just something I don’t know how to do, rather than being something that’s not possible. A suggestion I was given was to use delegates? 
Also use an array instead of a list (it's a linked list). And maybe use greater chunks when you read the data.
I guess I really don’t know what to expect since I’ve never done such extensive file IO in .net before. My initial concern was that matlab can read the same file very quickly, but doing the binary reader on the stream takes minutes, and I assumed the delay came from the match statement, even though I’m pretty sure that each arm of the match statement is assessed in parallel. I’ll try reading it into an array or possibly a memory stream. I like pretty, idiomatic code so I thought there must be some way to use delegates to pull together a type-appropriate binaryreader without resorting to a match statement. It just felt very brute-force.
That would make sense, I know matlab reads it into an array-type structure. When I said list I should have specified that I’m actually using a ResizeArray - i believe that’s a .net List type that’s different from an F# immutable list, but I can probably create an array that’s based on the number of data points in the array and just mutate it element-by-element?
Daniel's right. You don't want to ask .NET to read one byte at a time. Read the entire thing, then do whatever conversion you'd like. The type/conversion issue should be viewed as a separate problem from the read.
600 loc? I need to see this.
&gt;The strict ordering is a nuisance at first. After several years, it still kinda is, but now I actually find the lack of ordering in C#/javascript disorienting. The ability to put a method anywhere in a class is convenient in that you dont have to think about the ordering right at that moment, but that's where the convenience ends 
Any luck?
I ended up using Buffer.BlockCopy, which seems to be pretty quick. I’m going to try consuming a memorymapped file as well and see if that yields any improvement.
My "IDE" is just a text box where you put code and a label where it tells you either parse errors or values bound after execution. Clicking on an error takes the cursor there. No build system or even color syntax highlighting. Given that the parser is &gt;300LOC I'm wondering if typesetting `let` and `match` would actually require less code. I'm worker on a type checker and it will be \~300 more LOC. &amp;#x200B;
Asterisks represent tuples. A tuple looks like this (5,6) -- two numbers in a parens separated by a comma. int-&gt;int-&gt;int represents a function taking two ints, like so: foo 5 7 In the first example, there's one argument, a pair of numbers. In the second example, there are two arguments which are numbers. It gets more complicated than that, but that's the basic difference: the number and type of arguments.
Thanks for your reply. In practice they both achieve similar results, so how do i know which one i should use? 
For tuple you have to pass the values, in tuple, at the same time. But for the another one you can just pass some parameters first to make a new function that needs less parameters. Read https://fsharpforfunandprofit.com/posts/currying/
In general it doesn't matter!
Great idea. Registered.
Thanks for this! This is a great idea for those who missed signing up for the FSSF Mentorship round, or those who want to get a feel for Mentorship before committing to that.
Thanks a lot!
Absolutely! I've learned a ton while mentoring F# code.
What is expected of being a mentor? I have some mentoring experience from programming workshops and I do like F# but I do not know it very well, just the basics.
A mentor is expected to look at solutions submitted by students, and then review them. There is no fixed amount of time you have to spent, any time spent is helpful. You could most likely easily mentor the more basic exercises (leap, two-fer). You can decide for yourself which exercises to mentor, so if you feel like you are not comfortable to mentor a submission, you can skip it.
Good to hear!
I've signed up as well. Looking forward to getting stuck in tomorrow.
Well, you don't really have to use slack in your mentoring work. All the mentoring work can be done on the website. Slack is only used for communication between mentors.
Great!
I've signed up to be a mentor! I'm a bit skeptical about the code of conduct, which seems EULA-esque. Contrast with the Recurse Center's [four social rules](https://www.recurse.com/social-rules), which are particularly easy to grasp and readable while amounting to essentially the same thing.
Agreed, the code of conduct is quite long and scary. There is good stuff in there, but a lot of the points seem like a bit too much. I do like those four social rules you posted, very simple and to the point. I think we should think carefully about these things and not throw good-sounding words around just to make people feel good. I can't really put my finger on it but the code of conduct really doesn't seem right. Maybe it just hammers the point so much that it starts to sound disingenuous.
I don't agree. Tupled `let f (x:X) (y:Y) (z:Z) : A =` makes only some forms of partial application easier. The three forms of giving two inputs and creating a function in the third are then , `fun x -&gt; f x y z`, and `fun y -&gt; f x y z`, and `f x y`. Only the third is made easier. If you do not know which arguments you are likely to partially apply (a default case), then by currying you create a more abstract function, to make partial application asymmetrically easier. Instead I would advise currying if you know that you are likely to apply earlier inputs first to create functions taking later inputs, of if the inputs are such that they can be ordered in when you are likely to want to apply them. Or if there is a "main" input that you can put at the end and other inputs that can be thought of as parameters if you want to use a pipelined flow. If you have no opinion about the differences between inputs of the function, the default should be to use a tupled function.
I do not think it's worth doing unit testing of your "Controllers" (HTTP Endpoints), this should stay just for your business rules, but it would still be possible by using the implementation in memory, it could serve as mocks of the "Interface" (TodoFind, TodoSave, TodoDelete) that the "Controller" is waiting for in the Services container.
Hi there! You can find some details on this here: [https://github.com/SAFE-Stack/docs/issues/52](https://github.com/SAFE-Stack/docs/issues/52)
As much as I've tried to procrastinate, I think it's time I move my analysis compiler, EasyAM, over to dotnet 2.2 and make it act more like a "real" compiler. &amp;#x200B; I've been saying this for months, but as the project gets more attention, it's probably worthwhile to at least start down the road of making it more viable. I'm on version 3.0 now, so I know what I want it to do and don't need to make the same architectural mistakes I made the first two times around. This time I can make new ones! 
Yep. &amp;#x200B; I believe you want to use the old double-backticks trick. &amp;#x200B; [https://stackoverflow.com/questions/11836167/how-to-define-a-type-extension-for-t-in-f](https://stackoverflow.com/questions/11836167/how-to-define-a-type-extension-for-t-in-f)
That’s actually exactly how I did it, might just have to scroll up in the code block.
I hadn’t thought about doing the ranges as well as my xyz parameters. I was not really that interested in the ranges at the 3D level since I can just slice the output of my GetSlice function, but this is a good idea. I’ll try it out.
I've been working on a tool to help play/broadcast games of 'Dragon Warrior Randomizer'. The tool takes screenshots of the game every second, and uses the info it 'sees' in the game to bring up monster data, automatically map the world, and keep track of level-up splits (times). It also has manual checkboxes for me to manually track progress through the game. You can see it in action decently around 31.5 minutes into this video: https://www.twitch.tv/videos/315415627 The code lives here: https://github.com/brianmcn/DragonWarriorRandomizerTools It is not very sophisticated, but it has been fun.
It's more that you don't have a choice: `*` is just a special case of range syntax, so if you want to support it, you must support ranges. For defaultArg, I don't use it here because it's eager: it calls `this.GetXerBound(n)` even if the value is `Some`. If you want to use a function instead of explicit matching, you can use `Option.defaultValueWith`.
Ok, that's good to know about \*. Thanks for the heads up regarding the eagerness of defaultArg. I'll try to put this all together, thanks!
I've been interested in f# for a while and I grew up playing dragon warrior. Can you share any details on the overall setup? How are you running/emulating dragon warrior? There's no actual integration with the emulator, it's just taking screenshots?
Yeah, I'm using fceux emulator, it's a separate process that grabs the current active window (DW emulator), takes a screenshot of the pixels, and compares to know locations/layouts for certain colors and things, see Program.fs and PixelLayout.fs for the (somewhat poorly factored) details.
Awesome, thanks!
I plan to do an app to help control house expenses between roommates.
Looks nice! My focus is something that is meant to be shared, like services, rent and some supplies with the possibility of allocating an amount that someone owes you towards a shared expense. Also, online and with a pretty GUI because I want my roommates to use it, but for the calculations it's a welcome starting point!
Yup! Just figured I'd toss it your way since it's what I used as a base for something similar. Good luck!
Since my F# presentation at work, I have been using F# on my first "official" project for a big customer and really enjoying it. The project is a bolt-on to an existing C# app to provide batch reporting in various formats. A business analyst recently gave me a spreadsheets with pages of mappings, and I was able to create Excel formulas to generate all of the F# pattern matching transformation functions! F# is turning what would otherwise be tedious and boring work into a very satisfying experience, and I am essentially done at the halfway point and now working on testing, vanity refactoring and performance optimizations. I'm anticipating a record-low number of bugs when this is all said and done. I have been asked to onboard others to the project for a code review. I also plan on using some of my remaining time to setup Azure DevOps deployment hosted agents to the client site for automated deployments. &amp;#x200B; Additionally, I recently created some F# katas for the team to learn with, which some of them have already completed, and one teammate even added one! This first round of katas were designed such that all types already existed, and the user just had to implement a function, which had built-in FsUnit tests. I'm looking forward to getting past this first round of katas so that I can do a deep dive on the Seq, List and Array modules (which should prove to be beneficial for me as well). I think they will really like some of the stuff like partition, chunkBySize, etc. Possibly some more katas to follow. &amp;#x200B;
Have you ever used a heap based implementation when you do this?
Yeah that what was what I was going to suggest, do it with a heap and compare the performance. BenchmarkDotNet is a nice package for benchmarking, good tool to learn.
Here is a bit of feedback on the core solver code. Overall, the code looks good. * Good use of types and members. * Good use of `|&gt;` operator. Some things you might want to look at. * Helpers.fs In your `transformAppendListToMap` function, you might prefer to use pattern matching. For example, the outline of the function might look something like ``` let rec internal transformAppendListToMap inputList calculator outputMap = match inputList with | [] -&gt; outputMap | k::tail -&gt; let v = calculator k transformAppendListToMap tail calculator (Map.add k v outputMap) ``` But it looks like this function is iterating over a list and generating a map, so you might want to consider using the `List.fold` function. * Solver.fs You appear to be using exceptions to represent the state of the `State`. You might want to consider using a discriminated union instead. Such a type might look like: ``` type SolveState = | NotSolved of State | Unsolveable of State | MaxTickReached of State | Solved of State ``` You could then pattern match on this DU. You might also want to consider prepending lines that have only side-effects (e.g. functions that return unit) with `do` to make it clear you are expecting just side effects to happen. For example, on the line `newState.Iter newState`. But the code looks good for your first project in F#. Keep up the good work!
Concerning the `|&gt;` operator, if the code is "piping" data through functions in sequence, such as `list |&gt; List.toArray |&gt; Array.map fn |&gt; Map.ofArray` (very silly example), then I prefer the `|&gt;` operator, as I think it makes it clear in code what is happening (e.g. do this, then do this, then do this). But sometimes it does make sense to use the `funcA (funcB x)` syntax instead. Through practice you should start to get a good feel for when to use which syntax. (I would also try to avoid a) using more than one `&lt;|` operator in a single expression, and b) mixing `|&gt;` and `&lt;|` operators in the same expression as I tend to find code like that is just hard to understand.) Similarly, when you start writing more code, you'll find quite a few functions (especially ones involving collections such as lists, arrays and maps) can be built up using the standard library functions. For a list, you tend only really want to do three things: * Convert a list to another list of the same length (`List.map`) * Convert a list to a single item (`List.reduce`) * Convert a list to another data structure (`List.fold`) Also note that both `List.map` and `List.reduce` can be implemented with `List.fold`, so it really is a powerful function. I suggest learning how to use `fold` functions on collections. Regarding the `do` binding, this page suggests it is good practice to use `do` to indicate you are only interested in the side-effects of a function: https://fsharpforfunandprofit.com/posts/let-use-do/ Hope this helps. 
I just want to add my five cents to this answer because I find its treatment of standard library functions somewhat confusing and perhaps misguiding. Typically when we talk about the three most fundamental types of collection operations in functional programming, we refer to: * `map`\- Transforms a list by applying your function on each of the elements. `List.map (fun x -&gt; x + 1) [1; 2; 3]` =&gt; `[2; 3; 4]` * `filter` \- Transforms a list by using your function as a predicate. For each element in the list, if your function returns `false` when given that element, it will be removed from the list, and if your function returns `true` for that, it will stay in the list. Obviously we are not talking about in place mutation of the input list, instead these changes will be reflected in the output list. `List.filter (fun x -&gt; x = 2) [1; 2; 3]` =&gt; `[2]` * `fold` \- Traverses the whole structure, accumulating a final value. Just like shefmichelle mentioned, `map` and `reduce` can be encoded in terms of `fold`, and the same applies for `filter`. This works because `fold` let's you accumulate whatever you find appropriate, in `map` it is a list which has the same size as the input list but with its elements transformed, and in `filter` it is a list that contain the same elements as the input list or fewer. But it is not limited to data structures. The following snippet sums a list of integers: `List.fold (+) 0 [1; 2; 3]` =&gt; `6` Here is a definition of factorial (it's behavior for negative number is perhaps not satisfactory): `let fac n = List.fold (*) 1 [1..n]` The reason why `reduce` is not included is because it is simply a `fold` with an additional constraint - the input list cannot be empty (in Haskell `reduce` is called `fold1` for just that reason). This has an implication on the provided function as well, constraining its type. The signatures are as follows: `List.fold : ('a -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; 'b list -&gt; 'a` `List.reduce : ('a -&gt; 'a -&gt; 'a) -&gt; 'a list -&gt; 'a` As you can see, `reduce` demands that the first and second argument to our function is the same type. Finally, just to see it in action, here is summing a list with `reduce`: `List.reduce (+) [1; 2; 3]` =&gt; `6` Just like shefmichelle mentioned, you will be able to use these functions to solve a great many problems, so make sure you understand how they work and how to build larger algorithms from them by composition. A great exercise is to first write them yourself as recursive functions, and then write `map` and `filter` using `fold`. When you have done that and feel confident with these three functions, you should start looking at the other parts of the standard library. Just like we use `map` and `filter` instead of writing functions that do the exact same thing but using `fold`, we can use other library functions instead of redefining them in terms of `map`, `filter`, `fold`. Lets say I want to count the number of occurrences of `x` in a list: `let countX x = List.filter (fun y -&gt; x = y) |&gt; List.length` I could also define it like this: `let countX x = List.sumBy (fun y -&gt; x = y |&gt; System.Convert.ToInt32)` This is perhaps a bit convoluted, but the best I could make up right now. While it perhaps does not look that elegant (fsharp does not allow us to convert booleans to integers using the `int` operator), it does offer an improvement. While the first example performs two passes, one over the original list, and one over the filtered list, the second example only performs one pass (I'm not taking into account eventual compiler optimizations such as loop fusion). A very useful function to learn is `collect` (`concatMap` in Haskell and `flatMap` in other languages). It can do a lot of things one might find surprising at first. For example, we can define filter with it: `let filter f = List.collect (fun x -&gt; if f x then [x] else [])` Finally, take a look at `groupBy`. With it we can solve the problem of building a frequency table of a collection very succinctly: `let freqTable xs = Seq.groupBy id xs |&gt; Seq.map (fun (x, ys) -&gt; x, Seq.length ys)` `freqTable "hahah"` =&gt; `seq [('h', 3); ('a', 2)]`
I apologize. There's a second part of this video that shows code. I'm having some technical problems. If you come by and there's only 5 minutes of video, please come back later. (I would delete the post, but I'm not sure if that's allowed. Some places when you delete a post, you can't re-post) Just wanted you guys to know that I wouldn't post anything here without F# code in it. :)
Nice. If you're interested, I can send you copy of my forthcoming intermediate book on F#, which might help the team advance. PM me your address details if you're interested. Congratulations anyway!
I haven't looked at the code in detail, but first impression is that I love the way you designed this!
Being new, I am curious as to what I did that you like. I am trying to learn the correct way to do things and any feedback would be greatly appreciated!
Well, that's a lot of info. I am going to take some time to digest this and see how I can implement these ideas.
Nice! I think I should replace my helper functions with this tool!
Very nice. I think we should try to Since you have both `Result` and `AsyncResult` CEs, do you run into the same [limitation of type inference that CVDM does](https://github.com/cmeeren/Cvdm.ErrorHandling#a-note-on-type-inference)? If so, did you manage to work around it?
Great stuff. I am also a non C# dev learning F# and so much of your post resonated with me. So much content seems geared towards teaching C#ers F#. Good luck on your journey!
Hi, FsToolkit.ErrorHandling doesn't do overload on bind method so, I haven't faced the issue described there.
 match o with | :? Int32[] as ia -&gt; ia.[0] &lt;- 4 | :? bool[] as ba -&gt; ba.[0] &lt;- true Etc 
This doesn't work because you can't set stuff inside an object.
I'm a noob to F#, but even in C#, I think the problem is that you're trying to treat it as an array of a specific type too soon. You can't typecast an array of bytes to an array of Int32. You need an explicit conversion. Can you read the file into an object that has a Type field and Bytes array. Then, match on the Type field and call DoSomethingInt32(ConvertFromInt32(byte[])) etc. as appropriate. (again, please pardon the lack of F# syntax, as I'm a noob at F# and have been absorbed in C# work lately)
It sounds like you may want the resultant data type from your parser to be a Discriminated Union that captures each possible data type; e.g. ``` type Data = | Int16s of int16[] | Int32s of int32[] | Singles of single[] | Doubles of double[] ``` Where you construct a specific case based on the value of the header. Depending on performance characteristics, that could also be a struct, but I'd avoid those sorts of optimizations until you get everything working.
I'm not actually casting the byte array to an int32 array, I am using Buffer.BlockCopy to read a byte array into an int32 array or int16 array, etc. It has better performance than using BitConverter. My question is more about casting the obj inside the ResizeArray&lt;obj&gt; (lets call it someObj) to the type returned by someObj.GetType().
From what I have been researching, this seems to be the most idiomatic way to do it, but DUs just don't seem to make sense to me. Would I create the cases before I read the data from the file, or after? Then, would the cases just be pattern matching on the DU or on the header type-code? &amp;#x200B; This is a rough mock-up of how I'm reading the data in: let buffer: byte[] = … &lt;-- read bytes into here let container = new ResizeArray&lt;obj&gt;() //maintain same type in pattern match let matchDatatype (dtype: int) = // Let's read File B match dtype with | 0 -&gt; let typeBuffer: int16[] = numBytesInFile/2 |&gt; Array.zeroCreate while stream.Position &lt; stream.Length do stream.Read(buffer, 0, numBytesInFile) |&gt; ignore Buffer.BlockCopy(buffer, 0, typeBuffer, 0, numBytesInFile) typeBuffer |&gt; Array.chunkBySize 8 |&gt; container.Add | 1 -&gt; // Reading int32 from File B let typeBuffer: int32[] = numBytesInFile/4 |&gt; Array.zeroCreate while stream.Position &lt; stream.Length do stream.Read(buffer, 0, numBytesInFile) |&gt; ignore Buffer.BlockCopy(buffer, 0, typeBuffer, 0, numBytesInFile) typeBuffer |&gt; Array.chunkBySize 8 |&gt; container.Add | 2 -&gt; ... …. &amp;#x200B;
I think you're close on the approach, but need to tweak it a bit. When reading a file, I'd recommend: 0. Establish your buffer and container 1. Read the marker 2. Based on the marker, parse the file differently 3. Produce a case of `Data` (or whatever you choose to name it) 4. Add it to your container Rough outline: ``` // Define the type that models your possible data types type Data = | Int16s of int16[] | Int32s of int32[] | Singles of single[] | Doubles of double[] ... // Define exception for seeing something unexpected exception UnrecognizedMarkerException of int * string ... let parse file = // Type is Data match dtype with | 0 -&gt; let d = parseInt16Data() Int16s d | 1 -&gt; let d = parseInt32Data() Int32s d | 2 -&gt; let d = parseSingleData() Singles d | 3 -&gt; let d = parseDoubleData() Doubles d | _ -&gt; raise UnrecognizedMarkerException(dtype, "uh oh!") ... ``` You'd need to write code that can parse each data type based on the format (which should be short and simple). But the end result is a case of `Data` that contains the underlying data. Should you continue to use ResizeArray, it'd first look like this: ``` let container = ResizeArray&lt;Data&gt;() ``` And after calling `parse` for each relevant file, you'd have a full array of the DU type. Working through that list would look sort of like this: ``` let doStuff containerItem = match containerItem with | Int16s data -&gt; ... | Int32s data -&gt; ... | Singles data -&gt; ... | Doubles data -&gt; ... ```
Am I missing something? type MapList&lt;'a,'b&gt; when 'a :comparison = Map&lt;'a,'b list&gt; module MapList = let insert (key : 'a) (value : 'b) (table : MapList&lt;'a,'b&gt;) = match Map.tryFind key table with | None -&gt; Map.add key [value] table | Some lst -&gt; Map.add key (List.sort (value :: lst)) table &amp;#x200B;
&gt; I like to play blackjack. I'm not addicting to gambling... I'm addicting to sitting in a semicircle. – Mitch Hedberg [Source: Mitch All Together](http://skulkersbole.tumblr.com)
I really like the way this approach looks. I’ll give it a try tomorrow and report back with my findings!
The files I’m reading in are basically binary image files. If the data in the file is int16 or int32, you could think of it as a grayscale image. If the data in the file is single or double, it could be T scores or p values at each pixel position, etc. I need to be able to do computational operations on the arrays, like k-means clustering or smoothing, etc. Obviously I can’t do this with an obj since it doesn’t implement IEnumerable (I don’t think), and I need to get the data into an array of the intended format to maintain precision. Your notes about “return same type as other processing functions” are confusing me - I feel like that’s the trap I’m trying to wriggle out of, but you and Phillip both seem to have similar approaches which makes me think I need to be doing what you guys are suggesting.
Have you implemented these computation operations? How will they handle the varying value types? What data type will the result be in each case? I think this is much more important than how you will read the data from the file.
Does it have to be thread safe? E.g. what should happen if two threads add an object with the same key 'simultaneously'?
Use a hash map. Object+key are the hash map key, insertion index the value. This takes care of the uniqueness constraint and the updates index. Later on, get all keys and values, sort by value, and keep the objects/keys. That should do what you want, if I understand your requirements correctly. 
It's immutable. You don't "add" objects.
I wanted to keep with the idea of Immutable, which kind of implies thread safe.
I know how to write a hashmap in a mutable manner, but not so sure on how to do it in an immutable way. Googling has led me down a long rabbit hole. I guess back to the google to reach more about functional collections.
Adding this to benchmark and test
Yes, that’s the simple stuff. I just didn’t want to have to keep going into my source and hardcoding the data type I was reading for a particular set because that meant I head to either always use this stuff from FSI, or compile a solution for each data type, which is ridiculous.
It is a recursive function that checks if all elements adhere to the predicate "p" The function takes two arguments, p and the hidden one indicated by the "function" keyword. "function" is a short hand for "match x with"
This is helpful. Thanks to you I understand the premise however... how do I get an output from this? Because what truly baffles me is "p:('a -&gt; bool)"... what do I have to feed in?
I woke up thinking that sets my be better for your needs. Tell me how this one benchmarks as well. (Granted, the above comment about PriorityQueues from FSharpX.Collections will probably be better). type MapSet&lt;'a,'b&gt; when 'a :comparison and 'b : comparison = Map&lt;'a, Set&lt;'b&gt; &gt; module MapSet = let add (key : 'a) (value : 'b) (table : MapSet&lt;'a,'b&gt;) = match Map.tryFind key table with | None -&gt; Map.add key (Set.singleton value) table | Some theSet -&gt; Map.add key (Set.add value theSet) table let values table = Map.fold (fun acc _ values -&gt; Set.union acc values) Set.empty table let containsValue value table = table |&gt; Map.toSeq |&gt; Seq.exists (fun (_,values) -&gt; Set.contains value values) let smallestObj (valueOfInterest : 'b) (table : MapSet&lt;'a,'b&gt;)= match Map.tryFindKey (fun _ values -&gt; Set.contains valueOfInterest values) table with | None -&gt; Set.empty | Some key -&gt; Map.find key table |&gt; Set.remove valueOfInterest &amp;#x200B;
How do you expect to "research type providers" without having even 100-level general knowledge of the language?
I don't mean to be rude, but you seem to have some misunderstandings about the F# type system that are preventing you from understanding people's answers here. I'm pretty sure you don't need to use obj/GetType/casting for this, but it's impossible to say for sure without knowing the parameter/return types of your computation operations. If the parameters are all doubles then you can't avoid casting all these values to doubles at some point. If you have different versions of the functions for different data types, that's a different story.
I’m absolutely having misunderstandings about the F# type system, no offense taken. Like I said, I’m coming from mainly using Matlab/python/Mathematica for everything, where I can do an if statement or switch and pretty easily get arrays of different types. I get the whole deal about type safety, but it just doesn’t make sense to me why returning arrays of different types, if that’s explicitly what I want, doesn’t fit that criterium. On top of that, it doesn’t make sense to me why an obj that knows what it is can’t use methods from the underlying type.
Yeah, it's like you're getting annoyed that you can't find the gas tank on an electric car. :D If you can answer some specific questions, we may be able to solve your problem. Do the function(s) that will process these values exist yet? Will there be just one of these functions irrespective of the data type of the source data, or a separate one for each type? What will the result type(s) of this function/these functions be? Not what *could* it be - any function could return obj, but that's very rarely a good idea.
What is the ultimate goal here? Why did you pick F# specifically? Why don't type providers interest you? How about computation expressions/active patterns/units of measure? If your only experience is PHP, why not start by trying to port some code from PHP to F# and write about the experience of switching to a statically typed language with Hindley-Milner inference?
That pretty accurately describes my frustration. I feel like I'm being incredibly dumb, and obviously not getting some fundamental concepts here. &amp;#x200B; So, some of the functions exist. I have only rewritten a few of them in F# from C, but I'm working on it as I go along. I figured I would be able to inline the functions that could work across multiple types, and ones that were specific to a particular type would just implement that type for the input. &amp;#x200B; For instance, one of the functions is a way to convert an array to a 3D array, in which case the function signature is 'a\[\] -&gt; 'a\[,,\], a general function to work on any type array. A type specific example is one that does k-means clustering, where the signature for that function would be 'a\[\] -&gt; double\[\]. Another one is my low-pass filter, which would take have the signature double -&gt; double -&gt; double -&gt; int32\[\] -&gt; double\[\].
Have a look at this: http://fssnip.net/7Vq I made some assumptions about the format of the source file, and added dummy implementations of the processing and visualization functions for k-means clustering. Does that help?
So, I'm kinda moving along with a little help from every stackoverflow post on F# ever created, and I'm starting to form this monolith: type Datum = | Int16 of int16 | Int32 of int32 | Single of single | Double of double type Data = | Int16s of int16[] | Int32s of int32[] | Singles of single[] | Doubles of double[] interface IEnumerable with member this.GetEnumerator() = match this with | Int16s arr -&gt; arr.GetEnumerator() | Int32s arr -&gt; arr.GetEnumerator() | Singles arr -&gt; arr.GetEnumerator() | Doubles arr -&gt; arr.GetEnumerator() member inline this.Length = match this with | Int16s arr -&gt; arr |&gt; Array.length | Int32s arr -&gt; arr |&gt; Array.length | Singles arr -&gt; arr |&gt; Array.length | Doubles arr -&gt; arr |&gt; Array.length member inline this.Item with get(i) = match this with | Int16s arr -&gt; Int16 arr.[i] | Int32s arr -&gt; Int32 arr.[i] | Singles arr -&gt; Single arr.[i] | Doubles arr -&gt; Double arr.[i] and set(i) v = match this with | Int16s arr -&gt; arr.[i] &lt;- int16 v | Int32s arr -&gt; arr.[i] &lt;- int32 v | Singles arr -&gt; arr.[i] &lt;- single v | Doubles arr -&gt; arr.[i] &lt;- double v &amp;#x200B;
Yeah actually this was exactly what I think I needed to see. It brought everything closer together in terms I get. I think now I can see how to better build around the types instead of fighting them. &amp;#x200B; let dataType = reader.ReadInt32 () let result = match readData dataType reader with | Int16s values -&gt; kMeansClustering values | Int32s values -&gt; kMeansClustering values | Singles values -&gt; kMeansClustering values | Doubles values -&gt; kMeansClustering values &amp;#x200B;
I have no idea what you're trying to accomplish here. Best of luck!
I’m currently reading [Concurrency in .net](https://www.manning.com/books/concurrency-in-dot-net). It does a great job of highlighting how immutability and functional programming makes for a much easier time introducing concurrency into programs. [Domain Modelling made Functional](https://pragprog.com/book/swdddf/domain-modeling-made-functional) is another excellent read for modelling complex business domains using the F# type system. 
Glad to be of help!
&gt;Can someone please explain why split the code between type and module, instead of having type with member functions? From [Expert F# 4.0](https://www.apress.com/us/book/9781484207413): * Use members (methods and properties) where they already exist, unless you have other good reasons not to do so. It’s better to use s.Length than String.length, simply because it’s shorter, even if it occasionally requires using an additional type annotation. That is, embrace dot-notation, even though it may require type annotations, but use it tastefully. * When designing a framework or library, define members for the intrinsic, essential properties and operations associated with a type. * When designing a framework or library, define additional functionality in new modules or by using extension members. * Sometimes there is duplication in functionality between dot-notation members and values in associated modules. This is intended and should be accepted as part of the mixed OO/functional nature of F#. &amp;#x200B;
Since you don't have a lot of knowledge about F#, and you don't seem too excited about learning it, why not switch to the human angle and ask people who love/do cool stuff with F# why they like it so much? Specifically, why do they like it more than languages you know like php? &amp;#x200B; Either you'll get excited about F# and want to know more -- or you'll realize it's not for you. Either way you'll learn something. Plus you'll meet cool people at the same time. Win!
Aim high, I guess.
No. If I do it on a brand new project it still looks in the c: drive
Couldn't you replace | File s -&gt; \[s\] with: | File \_ -&gt; \[\] ?
My guess is an environment variable is set to "C:\" and is overriding the default path for project files. Try this in powershell: gci env:* | Where-Object {$_.Value -eq 'C:\'}
This is awesome. I would love to run with this and add timing in. Then you can start to represent simple songs and melodies.
You should check out The Haskell School of Music if you like this. :)
I'm sure this has come and gone, but you can write functional C#. You don't have to know or code in F# to write a functional approach to solving a problem in C#.
I think some of my best coding experiences the first year or two with F# was doing this kind of stuff. As an OO guy, it was really mind-blowing. &amp;#x200B; Thanks for the essay!
Recursive pattern matching. https://dotnetfiddle.net/HKp2LN let rec substitute s = function | V x -&gt; V s | F (x,d) -&gt; F (x, d |&gt; List.map (substitute s)) | x -&gt; x
No, in the first it return int * int like in the second. 
You’re not using “x” so the type of x can’t be inferred since the syntax of the first function isn’t correct. You have to put parentheses around parameters with type annotations.
That would work but the interesting thing is why code like "let yx : int : int\*int = x,x" compiles and runs?
I can't explain the precedence, but here's a more obvious example, without the function: let foo: float:int * int = (1, 2);; &gt; val foo : int * int let bar: x:int * y:int = (3, 4);; &gt; val bar : int * it
I don’t understand why you’re confused? Why not just give it type annotations the way you’re supposed to?
In both cases you're creating a function that takes one input parameter and always returns a fixed int\*int tuple with a value of (1,2), ignoring the input value. It seems that in the first example the x parameter declaration is syntactically incorrect, but the compiler simply ignores the annotation, resulting in a generic input parameter. The first example would be equivalent to: `let c _ : int * int = (1,2)`
Their example explains nothing. You’re trying to query the type of an expression that takes 3 arguments, uses 1, and doesn’t even output the type you specify in the binding declaration. The expression (x,x) is a tuple; x,x isn’t. There’s no reason to pass a and b since you don’t use them. Your expression should read let y (x: int) = (x,x) Or let y (x: int): int*int = (x,x)
ah sorry, it should be let y (x:int) : a:int \* b:int = (x,x) with the ":" and I don't think you need parentheses here to define a tuple, "x,x" should be the same. I'd want to read it as it is a function "y" that takes an integer "x" and returns a tuple of ints with names a and b. But then why the above expression is valid but this isn't: let y (x:int) : (a:int \* b:int) = (x,x) and why can I name tupled returning variables? It makes no sense. CAN I actually give names to tuple types? Is there anything that makes use of that? &amp;#x200B;
This! If this is fixed I would be so happy. My best Christmas present would be so that nuget dependencies could be specified in the fsx files and loaded on the fly and cached for subsequent invocations 
Just waking up here again, so apologies if I'm missing the point. Options, DUs, and matching are all functions in F#, and functions are all values (mostly). So it's all kind of the same thing, right? In other words, an option is a function that resolves to a type or empty type. A value option would be a function that resolves to a variant....which resolves to a type (or empty). It's just one level removed. One level "up" from a normal option. Another way of saying this is that ValueOptions aren't options like you think of Option. They don't become values or nulls, they become options.
There isn't a mistake, it's just that the ValueOption definition is a bit verbose by including the type signatures - that is, `ValueNone` takes no arguments and returns a `ValueOption&lt;'T&gt;`, while `ValueSome`takes a `'T` and returns a `ValueOption&lt;'T&gt;`. This is what discriminated unions do - they are like different constructors for a class, in OO parlance. `ValueNone` is parameterless (really it's like a static property), while `ValueSome`is sort of like `new ValueOption&lt;'T&gt;(value : 'T&gt;)` &amp;#x200B; These two bits of code are completely equivalent: &amp;#x200B; type MyOptionSignature&lt;'T&gt; = | MySignatureNone : MyOptionSignature&lt;'T&gt; | MySignatureSome : 'T -&gt; MyOptionSignature&lt;'T&gt; type MyOptionRegular&lt;'T&gt; = | MyRegularNone | MyRegularSome of 'T If you hover over `MyOptionSignature`, you'll see two things: 1) Intellisense fills it in as `MySignatureNone` `MySignatureSome of 'T`, i.e. without the type annotations, as you would expect for a normal discriminated union. 2) F# gives you a compiler warning: "This construct is deprecated; it is only for use in the F# library." I am not entirely sure why this is the case, but the ValueOption definition from MSDN is probably straight from the F# core library. 
Ah, no problem. Yeah, `Option&lt;T&gt;` is similar to `Maybe t` from Haskell. FYI F# doesn't support higher-kinded types and hence really have monads in the same way that Haskell does, but does enable monadic operations (among other things) through [computation expressions](https://gist.github.com/kekyo/cadc0ec4b016368a0cee81d87fbee63a). It's actually a very interesting abstraction and I wish I knew more about the theory behind it. &gt; Also, a google search revealed that there has not yet been a discussion about ValueOptions on this subreddit, so now maybe it's a time. Do you use it? Does it improve performance? I have not actually used them! They're fairly new, I think . In my code I don't think I would have seen much of a speedup, since I tended to use options fairly sparingly. Generally structs do reduce memory and increase speed, but there are subtleties. I did a quick benchmark: open System #time let rand = new Random() let myArReferenceType : float option array = Array.init 10000000 (fun _ -&gt; Some (rand.NextDouble())) let myArValueType : float voption array = Array.init 10000000 (fun _ -&gt; ValueSome (rand.NextDouble())) Results: &gt; let myArReferenceType : float option array = - Array.init 10000000 (fun _ -&gt; Some (rand.NextDouble()));; Real: 00:00:01.001, CPU: 00:00:00.984, GC gen0: 25, gen1: 25, gen2: 0 [output and compiler warning omitted] &gt; let myArValueType : float voption array = - Array.init 10000000 (fun _ -&gt; ValueSome (rand.NextDouble())) - ;; Real: 00:00:00.188, CPU: 00:00:00.187, GC gen0: 0, gen1: 0, gen2: 0 [output and compiler warning omitted] So about a 8x speedup for creating an array of struct options - I would guess largely due to the garbage collection. But I don't want to say that's a definitive answer. Copying a whole bunch of structs all over the place can actually reduce speed, and a struct which is too large can also cause slowdowns. In general, especially with managed code: don't guess or assume a theory holds, do an actual benchmark :)
They are working perfectly for me in .net core, using fsharp.data v3.0.0 https://www.nuget.org/packages/FSharp.Data
yes some do work AFAIK - but I think there used to be a problem with certain types and there used to be this work-around: https://github.com/Microsoft/visualfsharp/issues/3303 Is this fixed as well? (sorry I really don't know and I did not check for quite a while so I might have missed the info - that's why I was looking for a roadmap or some public announcement or anything like that)
Thank you very much - that's the info I was looking for. Sorry if this did bother you or the community - I'm sure I could have found this answer by reading more in the issues.
No bother at all :) It's a little frustrating as a user to get good info on TP's in general, for example when looking at a given TP you don't know from intellisense/docs/etc usually if it is erasing or generative.
yeah - to be honest: I usually don't bother as I rarely use TPs in my day to day work. I'm 100% Linux in private and as those where a pain to try out I just ignored them there completely.
Looks like the code you pointed to is indeed using a type provider from the FSharp.Data library.
Thanks, I will look into it!
To be honest, not really sure, but defenetly not a first one, I would like to get some benefits of this representation, that could be used to make some statistics? Long term idea would be to be able to run a script, which takes a file containing exported data in (not yet sure) type, and make some useful graphs out of it, that could lead to some further investigation. Its for education purposes, a mini project. 
Try wrapping the str in () to make it explicit that is the only parameter. My guess (not at a computer) is that it can't decide which overload to choose as there are TryParse methods that accept format specifiers in addition to the string to parse. 
Changing the code to let parseString x:string = let (|Int|_|) str = match System.Int32.TryParse(str) with |(true,int) -&gt;Some int | _ -&gt; None let result = match x with |Int i -&gt; i |_ -&gt; 0 result 
`let (|Int|_|) str =` to `let (|Int|_|) (str:string) =`should fix it. To answer your original question - yes, it has changed. The ReadOnlySpan&lt;Char&gt; overload is new to Core 2.1
* NuGet and NPM/Yarn are the same concept as Elm package installer. * `.vscode` folder is something you don’t need to understand or use. It is just a settings folder for VSCode IDE. * `package.json` is like `elm.json` where it keeps track of **immediate** dependencies for your JavaScript code, and some utility executables. * `yarn.lock` file is a dependency lockdown file for NPM/Yarn so you get consistent package versions wherever you use it. So you don’t need to know how it works, but it is an important file you should commit alongside your source code under source control. * `Foo.sln` is the file that Visual Studio IDE uses to keep track of the collection of projects it needs to be aware of. It is just a simple file that you don’t need to understand how it works. I don’t know what Pack file is. I’ve to look it up. I’m assuming it is for compiling or some kind of build tool chain. I hope this explanation helps. And yes, I agree. Fable’s documentation and it’s “Gettijg Started” guide sucks so bad.
paket is just another dependency manager like yarn, for and in f#, because the fsproj isnt that good at multiple projects, lock files, etc
This turns out to be non-trivial. I couldn't find any help online at all. The best I could find was a C# programmer who made a run at it a couple of years ago -- and he had an oddball approach that I was certain wouldn't work. It worked. It's a crazy way of solving the problem, but it worked. I thought I'd throw this out as a separate link on this forum. Somebody else might run into the same situation, and I wanted to make finding an answer as easy as I could. As always, feedback welcome! Right now the code is "blown-out", with big names and lots of comments. I'll probably do a follow-up with it collapsed into pure FP goodness. First, however, I want to keep testing the heck out of it to make sure I wasn't missing any edge cases.
Why would you want to do F# -&gt; Fable -&gt; Javascript -&gt; Nodejs on the backend rather than just F# on the backend? &amp;#x200B;
Possibly for libraries, but doing so seems counterintuitive. It does seem like just F# makes more sense. I'm new, so I'm guessing Fable/Elmish are more for client-side JS?
I think between all the F# and usable C# libraries you can probably do what you need. You'll have a simpler build process, better runtime performance.
Using F# with Fable to target React-Native sounds strictly inferior to just writing React-Native in TypeScript. Go Xamarin or go bust. For the back-end, F# on .NET Core - plausibly with suave.io - would be your best bet. Try running it on Azure, AWS, or Google's public cloud. (Normally I'd have a bias in favour of Google here, but when I tried their .NET Core example project it was irrecoverably broken. Azure would be my second choice.)
Yes, I would never use F# -&gt; JavaScript (whether Fable or WebSharper) for anything else than the browser's client side; I would recommend ASP.NET Core (with one of the F#-centric libraries such as WebSharper or Giraffe) on the server side. Unless you have a very compelling reason to use Node (such as an existing js code base that you would want to interact with).
And Swift would be preferable to F# and Xamarin, right? How does Suave compare to Giraffe? I've also heard good things about Digital Ocean, might give them a try.
&gt;And Swift would be preferable to F# and Xamarin, right? If you're *only* targeting iOS, probably, yes. If the choice is between F# on Xamarin and Swift+Kotlin... I know where I'd want to be. &gt;I've also heard good things about Digital Ocean, might give them a try. It's cheaper but more management/ops work. Your call ;)
Since F# is a first class asp.net core language, what do those libraries gain you?
They take advantage of F#'s type system and syntactic features to provide more convenience than a language-agnostic library can. For example, in WebSharper, you can define the URL space of an application as a discriminated union and it will automatically parse requests and generate URLs to and from values: type MyUrl = | [&lt;EndPoint "GET /"&gt;] Home | [&lt;EndPoint "GET /user"&gt;] GetUser of id: int | [&lt;EndPoint "POST /user"; Json "data"&gt;] PostUser of data: UserData and then your application is defined as a function: let MyApp ctx myUrl = match myUrl with | Home -&gt; Content.File "~/index.html" | GetUser id -&gt; Content.Text "user data" | PostUser data -&gt; Content.Text "posted user" Giraffe has a different approach which uses lists and custom operators: let myApp = choose [ GET &gt;=&gt; choose [ route "/" &gt;=&gt; htmlFile "index.html" route "/user" &gt;=&gt; text "user data" ] POST &gt;=&gt; choose [ route "/user" &gt;=&gt; text "posted user" ] ] Then you have Saturn which uses computation expressions, but I'm less familiar with it.
Thank you for taking the time to explain that to a part time fsharper. 
This worked for me. Are you sure your library is .NET Core? Span does \*not\* exist in .NET Standard - check your fsproj. Otherwise, maybe update your .NET/Visual Studio installation?
I’m using Visual Studio 2017, and my project is targeting .NET Core 2.1. I actually *just* updated VS to 15.8.8. It’s not working on either of my computers, but the funny thing is that if I hover over a Span reference in the editor, IntelliSense shows me all of the information about the Span type. It’s like there’s some weird disconnect somewhere, but I can’t actually figure out where. If my .NET environment isn’t ok, would that just be a matter of reinstalling?
&gt; but the funny thing is that if I hover over a Span reference in the editor, IntelliSense shows me all of the information about the Span type. Hmm, this is really odd. Another dumb question: did you try actually building the project? It sounds like it, but it's unclear from your prompt. If the error only appears in the VS error list, maybe it's just VS being confused and the project will compile fine. Other things I would suggest: 1) Double-check the actual .fsproj file - not what it says in Visual Studio's Properties menu, but the text of the XML. Make sure it says &lt;PropertyGroup&gt; &lt;OutputType&gt;Library&lt;/OutputType&gt; &lt;TargetFramework&gt;netcoreapp2.1&lt;/TargetFramework&gt; &lt;/PropertyGroup&gt; At my last company we sometimes confused VS2017 by switching between Framework and Core with manual .csproj edits, so there might be something like that going on. It's possible that VS2017 is thinking of your project as .NET Core, and filling in the intellisense accordingly, but the actual project file says Framework/Standard. 2) Try `dotnet restore` then `dotnet build` from the command line (in the project directory) - sometimes F# needs to be "jostled" a bit :) 3) See if Span works in C# with a quick .NET Core console application. Something like using System; namespace SpanCheck { class Program { static void Main() { Span&lt;float&gt; floatSpan = new float[10]; Console.WriteLine("Creating Span&lt;float&gt; worked."); Console.ReadKey(); } } } 4) If the C# code doesn't work, then repair the installation in Visual Studio Installer &amp;#x200B; I have had some problems with F# and .NET Core, but not with Span or any of the new ref struct features. In fact lately I've been using them quite a bit without issue. Maybe I just got lucky, but I am hoping that there's an easy solution to your problems.
One thing is not like the others; Suave is not a framework, Suave is a self-contained web server with no dependencies. The other ones you have listed still need a web server to run on top of (at the moment Kestrel). What ever speed gains they portrait it is not theirs but the underlying server. For a commercial UI I would say WebSharper is the most robust and battle tested with commercial support. 
I recently made [notes on the fable ecosystem.](https://gist.github.com/enerqi/b941b953f89f3ac91dddff81b932f2ea) Hope they can help someone.
Well that seems to be the problem then! I didn’t know that about the interactive sessions. I actually thought it would be the other way around. So if you’re using Span, do you just test it with dotnet CLI until you get it to do what you want?
Ah ha, thanks for the correction -- but say, Websharper wouldn't interop easily with Suave right?
&gt; Using F# with Fable to target React-Native sounds strictly inferior to just writing React-Native in TypeScript. Why is that? Both transpile to JS, with Fable you also get superior state management via Elmish. 
No, this not for VSCode. This is a dark theme for the (FSharp.Formatting)[https://github.com/fsprojects/FSharp.Formatting]
You should watch this: (The Curious Case of Freya, Suave and Giraffe: reducing risks in picking a new tech - Gien Verschatse)[https://vimeo.com/283390821]
I did skim through the slides, which seemed sparse -- haven't listened to the whole thing though. 
It is possible to run WebSharper on top of Suave. https://github.com/dotnet-websharper/suave It might need a little bit of updating.
Ok, thanks! One last question - do you think there are worthwhile performance/memory improvements to using Span as opposed to the traditional buffer/array method?
Thanks! Its too bad it's really pretty! I could probably try to make a vs code theme but its just going to be easier to find something else and spend that time learning fsharp
Giraffe and Suave have pretty much the same thing going on. Between the two, I'd recommend Giraffe so that you can leverage Kestral or IIS. I don't particularly care for Websharper, preferring Fable/Elmish. I don't have much experience with Freya or Saturn, so I can't speak to them. I've done a three Suave projects, and currently am writing my second Giraffe. OO isn't how I'd describe the experience actually, you just build up handler functions that you then combine to create a function pipeline/tree that defines the flow of each request. 
Assuming you're not trying to create some kind of bot to commit crimes, that's an interesting question! &amp;#x200B; I don't think I'd use F# for that. You could, of course, there are a few ways to get there. It just seems like the wrong tool. Since you want a programmatic way to interact with web pages, maybe you should look into something like Selenium?
Don't worry, nothing illegal here. Thanks you for your response and your suggestions, I'm gonna do some search about Selenium
Cool! &amp;#x200B; There are a lot of architectural choices to make with that, and for a new person to F#, I'd just find something that already works and learn the small amount you need to know to get your job done.
Yes, but with wich language
For just this need - I would go with Typescript using Protractor actually. I use it here at work for UI automation tests to go along with the UI code I've written, and it's an excellent way to do this. Now, that said, this will force you to have a solid understanding of HTML and the DOM, not to mention CSS selectors, events, etc. so you'll have your hands full learning all of it. https://github.com/angular/protractor/tree/5.4.1/exampleTypescript Actually, you'll also want to just take courses on HTML, CSS, Javascript, Typescript, and Protractor. Also, you might want to pick up Angular and / or AngularJS as well just for general web development skills using a framework. There are other options of course. Do that though, and you'll have an actually marketable skill as well, in the form of UI automation. 
Thanks for the details -- I'll do just that.
If you really want to try it with F#, you can use both: https://lefthandedgoat.github.io/canopy/
There are Linux install instructions here: [https://github.com/fsprojects/IfSharp#manual-installation-linux](https://github.com/fsprojects/IfSharp#manual-installation-linux) that I know various folks have successfully used. You're then able to do something like #load "XPlot.Plotly.Paket.fsx" #load "XPlot.Plotly.fsx" open XPlot.Plotly and draw with Heatmap(z = [[1; 20; 30]; [20; 1; 60]; [30; 60; 1]]) |&gt; Chart.Plot |&gt; Chart.WithLayout (Layout(title = "Simple Heatmap"))
Grafana looks pretty cool! 
I'm finally getting around to working on the F# project I've been putting off for six months or more -- a rewrite of my EasyAM Analysis Compiler. &amp;#x200B; Hopac, Logary, Expecto, DDD, dotnet -- it's got some fun pieces to it! And I'm using the rewrite as opportunity to do some blogging, video training, and talk about what an analysis compiler is and my book that started everything. Plus it's the first major rewrite of a large-ish F# project I've done. There are some interesting questions about what to keep and what to throw away/rewrite. &amp;#x200B; Who knows, if I get it all working the way I want, I may even plug it into a UI framework to show off both F# and the tool. Right now I'm leaning towards Jupiter Notebooks, but as long as I write it the right way, I should have dozens of options once I get there. &amp;#x200B; Fun stuff. I never thought I'd be so happy to see a bunch of colored Expecto text in my terminal showing that my unit tests are passing. :) Woo! Colored text!
\&gt; Giraffe's faster but more object-oriented Giraffe is not any more object-oriented than F# is itself. You can write an entire Giraffe web application completely functional, however if you MUST (want?) to integrate with object oriented interfaces from other [ASP.NET](https://ASP.NET) Core libraries then you \*can\*. I see this as a benefit rather than a detractor, but that's just my opinion. I leave the judgement entirely up to you :) &amp;#x200B; Just to give you a couple examples... &amp;#x200B; If you use another [ASP.NET](https://ASP.NET) Core middleware which comes with an object oriented IConfiguration interface then you can easily use it, but if you just want to provide configuration to your own functional web layer then you don't have to (and I don't even recommend it). For example I do things like this: [https://github.com/dustinmoris/CI-BuildStats/blob/master/src/BuildStats/Web.fs#L30](https://github.com/dustinmoris/CI-BuildStats/blob/master/src/BuildStats/Web.fs#L30) &amp;#x200B; Another great example of doing the balancing act between an OO [ASP.NET](https://ASP.NET) Core and a functional Giraffe is Logging. [ASP.NET](https://ASP.NET) Core has an OO logging abstraction which lets you configure different logging providers in a centralised point. There's so many useful libraries (e.g. Serilog, NLog, etc.) which build on top of that abstraction that it would be a shame to miss out on it, however at the same time Giraffe tries to give ways which lets you use these things in a very functional way: let someWebFunction = fun (next : HttpFunc) (ctx : HttpContext) -&gt; let logger = ctx.GetLogger() logger.LogDebug "Test log" text "Hello World" next ctx Even though you theoretically retrieve an \`ILogger\` instance from an IoC container you barely notice any traces of OO programming in your very functional \`HttpHandler\`. &amp;#x200B; It is not 100% pure functional, but it's certainly not OO either. It's basically F# ;)
The more you split it up, the more expensive synchronization is going to be. Have you done any benchmarking to show you where the hotspots are? It's possible (probable) that you can do a lot to speed things up without throwing cores at it (e.g. finding repeated maps and composing the functions for a single map). If the major cost already is with a bunch of threads trying to allocate arrays on the stack or expensive syncs, then you probably don't want to spend thousands to make it worse. Without analyzing for the cause of the problem, it's probably not a great idea to start formulating solutions.
Try Nessos.Streams, in particular the parallel version. I feel like if an i7 isn't performing great on your problem with your code you're not going to see a big (nearly linear) improvement with an i9 or ryzen.
If you want full mouse emulation, you can write a fake mouse driver to do it. The DDK has a template key/mouse logger, modify it to accept commands via the driver interface instead of logging them, then write a C# or F# stub to send commands to your fake driver. If that's too fancy for you, use something like Windows.Input.
In my experience, .NET Framework and Core code handles multi-core CPUs just fine. I have written an F# program that solved large, trivially-parallelizable statistics problems, and ran it on a 32-physical-core machine (I think it was Intel, don't recall - company paid for it, not me). Getting to max core utilization was not too difficult, though I had to do some work with optimizations around IO-bottlenecking, had to play around with ParallelOptions to make sure it wasn't spinning up too many threads, and so on. .NET makes it easy to create new threads, which means it's easy to get yourself into a situation where the overhead of managing different threads ends up in overall performance reduction on parallel code. &amp;#x200B; I couldn't give you processor-specific information but I doubt that would be an issue. Though I would strongly recommend looking at C# boards for more specifics here - if there is a problem with the Threadripper, it would almost certainly be a problem in the CLR rather than the F# compiler, and it's more likely a C# dev would have stumbled across it. &amp;#x200B; That said, I have the same hesitation as /u/Mouaijin. Frankly, without looking at both your code (at least a description of the problem) and benchmarking results, I don't think we can give you appropriate advice. Some general questions here: &gt; I'm running a pretty old i7 and it's struggling a bit * Struggling how? Are you at &gt; 90% CPU utilization? Or does it seem like it's not using the cores effectively? Does CPU utilization bounce up-and-down? Are any other resources (disk read/writes, memory) causing any problems? &gt; Given the type of the problem I'm working on I don't think it suits trying to push it on to the GPU or cloud. * Could you clarify further why running in the cloud woudln't help? It sounds like breaking up the problem into multiple processes running on several cheap machines could work. * It might be worth spinning up a machine in AWS/Azure with a large number of physical cores, and try running your program there. Try before you buy :) 
Let me prefix this with a "Your mileage may vary" but anecdotally I have two things to share: 1) I'd recently been working on an F# project that used XML type providers. In and of themselves they aren't terribly slow, but by swapping out some data structures within my code and making use of .net dictionaries to do lookups for joined files I was able to cut out a huge portion of my run time (from 15 minutes at worst to \~40 seconds). Moral of this story, performance isn't always gained where you expect, and choosing the right data structure is really important. 2) My top level loop uses Parallel.Map to push the processing of the files across all CPU cores. I was finding that on intel machines it reliably used all processing power available. On my AMD machine though it did multi core it as expected, it didn't flat out on all cores like on intel, resulting in a longer run-time. I think without testing on specific hardware and environments it is hard to know in advance what is going to be the best environment. 
Every parallel problem is different, so without more details it is hard to offer advice. One issue can be how big of a batch size to use. You can tune this yourself if you drop down to using Parallel.Foreach in the C# core libs. See example here: [https://github.com/jackmott/LinqFaster/blob/master/LinqFasterParallel/SelectParallel.cs](https://github.com/jackmott/LinqFaster/blob/master/LinqFasterParallel/SelectParallel.cs) &amp;#x200B; As well when you have a lot of cores, arranging the problem such that it doesn't run out of memory throughput is important. Minimize indirection, function calls, pointer hops. Keep data streaming from ram into L1 in order, do lots of work on each chunk of data before proceeding to the next chunk of data, etc. &amp;#x200B; &amp;#x200B; &amp;#x200B;
Thanks, I'll take a look at that.
Cheers yeah. I'm currently running at very high CPU usage. The problem parallelises about 20/30 ways and each threads needs its own unique large blob of data (which isn't allowed to leave the machine).
Thanks. Thats interesting. As for your first point I think we're reasonably well optimized at the moment but there is always room for improvement. As for your second point thats interesting amd exactly the kind of thing I was worried about.
Thanks I'll take a look
Days: Various proprietary things in the rail industry. ;-) Evenings: Finishing off the index on my forthcoming book, "Stylish F#" (Apress).
Top 3 recorded talks, according to a guy who saw some of them live: \- \*react performance in a fable world\* If you're using elmish and haven't used react in the past, this is a \*great\* talk that lets you peek into that world while getting some very useful knowledge \- \*build a game with fable\* Tomasz is the F# king of live demos. I didn't walk away with things immediately useful in \*my\* job, but this is a great demo of Fable's promise of typed functional js \- \*data visualization w/ fable\* Evelina always gives some great data science talks :)
I caught [this](https://www.youtube.com/watch?v=Tf_3z0DXsMo) review last night, and I think it illustrates the same thing. If you can utilize the cores, Threadripper is the most powerful processor out there right now. However the architectural change and the slightly less mature scheduling algorithms on windows on the AMD platform are resulting in possible performance loss due to under utilization in certain scenarios. I don't think you can know this in advance without testing your specific code on that platform. Is it possible to rent these boxes temporarily?
Thanks again. I'll watch it now. &amp;#x200B; I don't know about renting. I managed to borrow someone's 10 Core Xeon. Obviously there are lots of differences between the systems so it's hard to attribute it precisely but that shaved about 30% off the run time.
Thanks for the clip.Can you make the font larger for your next videos? I offen watch with my phone when i‘m on the go. Thanks!
Great Video but could you give a more practical example of the usage of metaprogramming?
Thanks! I’m thinking a series is needed as the subject area is quite large even just for quotations, I didn’t want to go much over 10 mins so I decided on just the basic operations, quote literal, splice, traverse, and substitute. 
I hope Microsoft is serious about F#. We just started a new company and committed to building all 5 of our products in F#, and we did this largely based on public reassurances by Microsoft. &amp;#x200B; Plus, because of the success of [Jet.com](https://Jet.com) which built on F# then was purchased by Walmart for over $3 billion, we feel like Walmart is a big enough customer for Microsoft to stay interested in F#. &amp;#x200B; In February 2017 InfoQ quoted Microsoft's Program Director of .NET Languages, **Mads Torgersen as saying that Microsoft intends to “make F# the best-tooled functional language on the market” while ensuring it interoperates well with C# where appropriate**. &amp;#x200B; Then in May 2017 at Microsoft's build conference, Mads Torgersen went on stage with Phillip Carter, and before Phillip's talk on F# Mads said the following: &amp;#x200B; &gt;"We want to address some of the reactions people have to F#, or some of the thoughts they have about adopting it. &gt; &gt; &gt; &gt;"It's a language that has a lot of things going for it. It has a lot of cool stuff that are unique to F#. &gt; &gt; &gt; &gt;"But there are still people who are a little hesitant to adopt it, even when they discover it in the marketplace and so we've been asking around and trying to figure out what is the hesitation? Once you decide that this particular task would be better solved in F#, what are some of the things that are stopping you? &gt; &gt; &gt; &gt;"And some of the main things we have heard are 'We're not sure Microsoft is behind it.' and 'The tooling support doesn't come up to the level of C# or VB or even close. &gt; &gt; &gt; &gt;"And so we've sort of went after trying to address those two things in particular over the last year with F#. &gt; &gt; &gt; &gt;"One of the things we did recently I put up a blog post about the .Net language strategy where we talk about our 3 main languages: C#, Visual Basic, and F#, and how we think about each of them... what's the current state of each of them in the marketplace and how do we think about investing in it, and F# is on here. &gt; &gt; &gt; &gt;"One of the first reactions we got when we put it up was from F# people saying, "Oh my gosh! F# is on there! They didn't forget about it! &gt; &gt; &gt; &gt;"So clearly there is some sort of issue there. &gt; &gt; &gt; &gt;"So I am here to play the part of saying, as Microsoft, we really do embrace F#. &gt; &gt; &gt; &gt;"And you are seeing it with a lot of the technologies that we put out, that we sort of went from 'F# is a little side project' mode to more and more things, like support for it in the .NET stack and Xamarin. &gt; &gt; &gt; &gt;"Microsoft as a larger entity is embracing F# as a first class language, side by side with VB and C#. &gt; &gt; &gt; &gt;"We do this because we think F# has tremendous potential. There are many workloads that are well addressed with F# — in particular the ones that are in the Cloud, which is where we like people spending a lot of cycles. &gt; &gt; &gt; &gt;"We are also seeing a growth trend behind F# being really good. &gt; &gt; &gt; &gt;"In particular, when we look behind different data we see that the potential growth for F# and the people that would like to use F# if they could, if their boss would let them or if it targeted the thing that they are interested in. &gt; &gt; &gt; &gt;"That is really huge, so we want to give F# a boost, and help it become a mainstream language. &gt; &gt; &gt; &gt;"F# already has tens of thousands of users in production, so it is a language that is not just a toy. It is being used for very big things including [Jet.com](https://Jet.com) as you saw in the keynote this morning. Their whole Azure thing that they talked about is written all in F#. The whole thing! &gt; &gt; &gt; &gt;And so we have big customers that are using F# in production and it really holds up in these situations. &gt; &gt; &gt; &gt;"So go back and tell your boss that if you want to use F#." &gt; &gt; &gt; &gt;"Microsoft is behind it. We are in this for the long haul, and it's not just some academic project on the side." &amp;#x200B; Consequently, our native apps for iOS and Android are being built with F# on Xamarin, and our web apps are being built with the SAFE stack on Azure. &amp;#x200B; And we are having a BLAST! &amp;#x200B; &amp;#x200B;
That's a very nice video with good production and content! I would like to see more videos about quotations as well as other types of metaprogramming. But really I would like to see more videos about F# in general, there are very few out there compared to other languages. I believe the community would benefit from any F# related videos that you would be willing to create.
If you want to append `l1` and `l2`, use `yield!` instead of `yield`. You'll get `[1; 2; 3; 4]` instead of `[[1; 2]; [3; 4]]`. As you have it, `[l1;l2]` creates a two element list where each element is its own list, so you end up create a list of lists. `for i in [l1; l2]` just iterates over the outer list, so `i` is only ever `l1` or `l2`; it is never the contents of `l1` or `l2`! `yield` returns `i` as a value for the list, and `yield!` concatenates all the values of `i` to the list. I'm not great at explaining things, and I tried to find some docs to back me up on `yield` vs. `yield!`. [This](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/sequences) has a couple of examples to show the difference; it's for sequences, but you can test it for lists in fsi, too.
Well this was just an introduction to the different methods available, and a quick tour of most of the different parts that quotations have. In a future video I will cover type providers and more quotation usages as well as top tips on using quotations.
Im going to do more on core F# features, everything from defining functions through to type providers. I hope to have a catalog of different parts of different languages in the end too though. It would be cool to build a simple games in a series, I'll probably feature more aspects from my life as a programmer and stuff like that too. I have more ideas than time though!! :-)
In addition to the other (good) answer you could cons the single item onto a list, e.g.: [1;2]::[[3;4]] ==&gt; val it : int list list = [[1; 2]; [3; 4]]
Generally, if you want to replace a list comprehension `[for foo in foos do yield bar]`using lambdas and higher-order functions, you can use `List.map (fun foo -&gt; bar) foos`. So this would work: let append l1 l2 = List.map (fun i -&gt; i) [l1; l2] However `List.map (fun i -&gt; i)` does nothing, so, as has already been pointed out, the above could just as well be written as `let append l1 l2 = [l1; l2]`. Now, if you wanted to implement `@` using lambdas and higher-order functions, you could use `collect` instead of `map`: let append l1 l2 = List.collect (fun i -&gt; i) [l1; l2] `collect` is similar to `map`, except that it concatenates the results produced by the function (which therefore must be lists) instead of just putting them into a list. Generally `List.collect f xs = List.concat (List.map f xs)`. Of course this implies that the above could just be `List.concat [l1; l2]` because, as I said earlier, `List.map (fun i -&gt; i) xs = xs`. And of course `List.concat` with a list containing only two elements is the same as just using `@`.
Maybe you'll like \`Ayu Mirage\` (for Sublime Text, Atom and VS Code): [https://github.com/dempfi/ayu#mirage-with-ui\_separator-option-off](https://github.com/dempfi/ayu#mirage-with-ui_separator-option-off)
You can choose another tool like FineReport. The FineReport report project is deployed to the tomcat on the Linux system and is relatively stable. Data visualization is also very powerful, real-time data, the official website has helpful documentation:http://47.74.34.81:8090/display/VHD/FineReport I don't know if it can help you.
Visual Studio 2017 support was an absolute disaster when it was first released. Over many months it improved at a glacial pace. Even today it is riddled with concurrency bugs so, for example, rename refactoring will regularly corrupt your code without warning because it thinks it is operating on an old code base. So there is still room for improvement but at least, as of today, it is a useful tool. Incidentally, there were times when it got worse so it may well not stay in a good state going forwards. At one point I literally had two companies looking to move off F# because it was so bad as to be virtually useless. 
Here's my impression of the current status: * Things have definitely improved after a low point. This is thanks to enormous efforts by a small number of people. * We seem to now have more issues with .NET Core things than F#+VS2017 things - hopefully also a phase which will go away. Biggest example is that project dependencies aren't bundled - everything has to be a package or you have to hack the build. * In contrast to jdh30, I find that ALT/UP and ALT/DOWN do work for file ordering, but I guess that might be project-type dependent or something. They certainly did disappear for a while. * Refactor rename *usually* works for us, but yes as jdh30 says it can corrupt code too. * I personally don't love VS Code yet but am trying to use it more. My feeling is that F# is very much worth the effort despite any residual tooling issues. But there's no doubt that the shortcomings give ammunition to people who might not want to progress with F#.
This has definitely not been my experience. Well, the 'absolute disaster when first released' definitely *was* my experienced but it was cleaned up pretty well in a few months. I use VS2017 + F# every day for boring/unremarkable line of business application work and don't have any problems. Probably worth noting that everything I do is on the older full .NET framework so I can't comment on .NET Core support.
Microsoft essentially says in their language strategy that VB is a language designed to be approachable for new programmers, and is no longer going to be designed to keep up with developments in C#. [https://blogs.msdn.microsoft.com/dotnet/2017/02/01/the-net-language-strategy/](https://blogs.msdn.microsoft.com/dotnet/2017/02/01/the-net-language-strategy/) Conversely, C# seems to be targeted at the bulk of the industry that has a background in C++ or Java. It has some really great features, but that legacy also constrains the design of C#. I think F# should get more attention than it does from expert developers. I just started playing with it recently and I was blown away by the type providers feature, and that's just one thing it can do that VB and C# cannot.
I have tried Xamarin multiple times and have always been disappointed in the end. It does not feel like a first class citizen on neither iOS nor Android. App startup times are longer than "regular", app sizes are bigger and the lifecycle management is somewhat "off". Swift is a nice language so I suggest you give it try :)
&gt; I personally don't love VS Code yet but am trying to use it more. I've tried it several times and just never seems to do what it is supposed to. And I never figured out how to build hello world... 
&gt; Note that the March is also referring to March of 2017, not 2018 "Release Date: March 2018" 
The release date of VS 2017 RTM was March 2017.
It looks like VS 2017 was released in March 2017, and the book I linked to was released in March 2018 (jdh30 is quoting from that linked page).
So, Masse is an app for making product recommendations, and viewing your friends. We've got two major components to our system: the catalog component, which is responsible for keeping product data up to date, and the social component, which tracks your friends, your recommendations, your "agrees," your "thank yous," etc. Our product data comes from one of three places: the original retailer, an affiliate network, or from user submitted product data (in case we didn't have the product they were searching for; this is a feature of the app). We have a batch pipeline that downloads external feeds (this is via Fargate tasks, so batch F# jobs running in Docker containers), does some parsing of the data to normalize it, and then journal it into Postgres. Then there's another job that will check that batch of products against the previous batch of products from that source, and depending on if anything has changed, will issue updates into one or more DynamoDB tables. We have F# lambda services that listen to the streams of those tables and will do things like download images, or update Neo4j, or update a CloudSearch index, or some other action that needs to be taken. There's a similar process that takes place with "social" data. User takes an action, it gets journaled into Postgres, we have a long-running F# service subscribing to table updates, and Neo4j is updated based on the events coming in. For the user-facing endpoints, we are using F# with Giraffe running in Lambda. These actually do not hit Neo4j directly, we use a variation of the [GRAND](https://grandstack.io/) stack (we just found it was more productive to do this and has some nice tooling associated with it). The F# REST endpoints issue GraphQL requests to Apollo, which has [neo4j-graphql-js](https://github.com/neo4j-graphql/neo4j-graphql-js) installed. It has been a very effective, expressive combination thus far. We are using Neo4j because it is an excellent use case for modelling our data, which is very relationship/network heavy. From the product side, we have source skus which need to be rolled up into Masse skus, and each of those source skus have their own source category trees which have been mapped to our internal category tree. It is very easy to ask the question "Given this product, find me the shortest path to an internal Masse category," and it will spit out the answer without much fuss. On the social side, social networks are more or less the canonical case for graph DBs. For your main feed view, it's very simple and performant to ask the graph "Give me all questions, answers, recommendations, and products from users that are within n degrees of the given user." Hope this answers your question!
Cool. Thanks for the comprehensive write up. Next questions. How did you decide on F#? Do you all just happen to like F#, or was there a specific language feature that fit your needs really well? Was there any training needed for any of the employees, or some resistance against F#? Also what were some pain points in using it? Thanks again
Also I just have to give a shoutout to https://github.com/cmeeren/Cvdm.ErrorHandling and the asyncResult computation expression. So freaking useful, it is littered through our code and makes error handling a breeze.
Hey! Two questions: 1. What are you using to access Postgres from F#? 2. How do you manage migrations?
Regardless of the F# aspect, this feels like a very, very good idea! Coming to Android phones at some point I hope?
Eventually! I think the plan now is to hire an Android dev the first quarter of next year.
Thanks! No trouble at all :)
I highly recommend dbup to slightly tighten your goose. Very low ceremony. Seems to support Postgres: [https://www.nuget.org/packages/dbup-postgresql](https://www.nuget.org/packages/dbup-postgresql)
It looks like the package is authored for a specific set of users ([CS-Script users](https://github.com/oleg-shilo/cs-script/)). Adding it to a new project just busted the whole language service for me. It's hard to say where a bug is occurring. Language Service features generally don't just stop working in the presence of an unknown symbol, but this could somehow be a corner case that is rarely hit. `packages.config`-based packages can be problematic too, since there's no concept of transitive references like with `PackageReference`. Unfortunately, NuGet packages _can_ basically do whatever they want if they come with custom tasks and targets, even if this is definitely not the norm. In short, there is likely a bug, but there's some generally odd things going on with this package that it's hard to say.
This will be recorded, and once we have a link to that I'll add it to the meetup event, as well as broadcast it from the soon-to-be-created Austin F# Meetup twitter (handle suggestions welcomed!)
And in the meantime we have slides+recordings from our last meetup as well: * https://baronfel.github.io/austin-meetup-2018-09-20/#/ * http://usergroup.tv/videos/intro-to-f-on-the-web-the-safe-stack
Here is the repo: [https://github.com/JordanMarr/FSharpExtensionMethodBug](https://github.com/JordanMarr/FSharpExtensionMethodBug)
Read it alreadry on Medium, great article!
Thanks man!
r/csharp too, I guess)
vids on youtube?
Thanks for sharing, I learned something even though I've been dabbling in FSharp (Fake) for over a year. Great job!
Wow. F# looks like an easy to read OCaml. How does it compare speed-wise to OCaml?
&gt; 2017 at Microsoft's build conference From the [captions](https://channel9.msdn.com/Events/Build/2017/KEY01/captions?f=webvtt&amp;l=en) * [01:24:53 Jet.com is a great customer who's running entirely on Azure](https://channel9.msdn.com/Events/Build/2017/KEY01#time=1h24m53s) * [brief scene with code in f#](https://channel9.msdn.com/Events/Build/2017/KEY01#time=1h25m34s) At Build 2018-05 [Jet Employee Scott Havens](https://medius.studios.ms/Embed/Video/BRK3602?sid=BRK3602&amp;oid=731a118a-d6b9-4e5e-a7fb-dbab9f5b012f) tells that they use f#, treat microservices as stream processors and use event sourcing. He explains one of their core flows - executing commands, producing events (9m32s) and shows Commands (~ 14m15s) and Events (~17m32s) as discriminated unions type Command | Update of UpdateInventory | Reserve of ReserveInventory | Cancel of CancelReservation | Ship of ShipOrder type DomainEvent | Updated of InventoryUpdated | Reserved of InventoryReserved | Cancelled of ReservationCancelled | Shipped of LineItemShipped
Thanks! I've re-opened a [bug](https://github.com/Microsoft/visualfsharp/issues/2962) with a similar issue regarding transitive references.
Yes dbup is great!
This looks pretty useful and thorough! Maybe consider posting it to this sub for greater visibility?
It looks like you're close, there's just a syntax issue. This works: type Vec2 = { x: float; y: float } let plus(a: Vec2, b: Vec2): Vec2 = {x = a.x + b.x ; y = a.y + b.y} Output from F# Interactive: &gt; open Vec;; &gt; plus ({x=5.0;y=5.0},{x=1.0;y=2.0});; val it : Vec2 = {x = 6.0; y = 7.0;} &amp;#x200B;
thanks a lot , it worked.
 type Vector = { X : float Y : float } type Vector with static member (+) (lhs: Vector, rhs: Vector) = { X = lhs.X + rhs.X; Y = lhs.Y + rhs.Y} static member (-) (lhs: Vector, rhs: Vector) = { X = lhs.X - rhs.X; Y = lhs.Y - rhs.Y} &amp;#x200B;
At which point did you get stuck? &amp;#x200B;
Normallly in F# the return type here would be Option&lt;Point&gt; Since you don't normally do early returns in F# you restructure like so: &amp;#x200B; // ... if denom == 0 then None else // ... if //t etc then None else Some(p+(Point)r.Scale(t))
make sure you understand why though. you separate record fields with semicolons or newlines, both when defining the type and when creating values. in your original plus definition, you actually created a tuple with the parentheses and comma. commas create tuples in f#. however, that's valid syntax but not what you wanted. then you placed that tuple inside curly brackets, which is a syntax error. when creating record values, you must use the name of the record fields with equals signs.
looks great to me. maybe others will have some tips.
In addition to what wrath said, your first if statement doesn’t seem to have a matching else branch, which it will require since it doesn’t return unit.
Yes. I would be inclined to replace `static member` with a `let`-bound function and curry it. You could deconstruct `line1` and `line2` into `p`, `q`, `r`, `s` using a pattern instead, like this: let intersection {p=A; r=Delta} {q=A; s=Delta} = ... You have `r.VectorProduct(s)` but can you not overload `*` and just write `r*s` or even just use a function `dot r s`? Rather than test for floating point equality (which is generally a bad idea): if denom = 0.0 then You could rely upon the calculations producing `infinity` and check for that instead. It is often a lot faster and more robust, e.g. handles overflows. On a mathematical note, I find `.ToVector` and `.ToPoint` disturbing. Points and vectors are the same thing (e.g. in WPF) and there should be no distinction between them. 
Note that Option, while idiomatic, allocates memory. That's perfectly fine for most F# code, but since you are doing vector math I suspect you're writing a game/simulation or similar, aren't you? If that's the case, you're probably conscious about allocations. Note that ValueOption was recently added to the language; like all Value-Types in .NET, it's slightly expensive to copy around but it doesn't allocate memory, so if (and only if) you're worried about the GC and about cache misses (e.g. you're making a real time game) consider trying it out and benchmarking which is more convenient to you. It's still missing the combinators from the Option module, but you can pattern match on it just as well. Don't hesitate to use Option for most code though, ValueOption just gives you different trade-offs. The same goes for all Value-Types really (Line and Vector sound like prime candidates for Value-Types too).
That's some quality info!
Huh? There are no options tested here.
Is a record type the right choice for implementing a vector type ? Also is it good practice to add members to a type ? here is my code, would be awesome if anyone would provide some improvement ideas! Thanks in advance. awesome community!
&gt;Note that Option, while idiomatic, allocates memory. That's perfectly fine for most F# code, but since you are doing vector math I suspect your code is meant for a real time 3D application or similar, right? Its not exactly real time, but performance is critical.
First, I'll let you know that the System.Numerics namespace already contains vector and matrix types and some of their operations are SIMD accelerated. This goes for both C# and F#. &gt;Is a record type the right choice for implementing a vector type ? It's a matter of preference. A record type is a perfectly valid way to implement a vector type. Others would prefer it to be a single case union, or a class/struct (`type Vector(x, y, z) = ...`). Depends a lot on the ergonomics you're looking for. Also, if talking about vectors, I'd suggest to make the type a value type with the `[&lt;Struct&gt;]` attribute. As an aside: The same guidelines for deciding between class (reference type) and struct (value type) in C# apply for F#; vectors and points are the go-to examples of structs. F#'s records and unions are normally implemented as classes, but the aforementioned attribute let's you implement them as structs, with few changes if any. (But I don't recommend trying it with multi-case unions, unless you know what you're doing. The resulting type can be quite bloated due to limitations of the CLR.) &gt;Also is it good practice to add members to a type ? Yes! Instance members don't always play nice with type inference but we don't shy away from them either. It's also a matter of preference if you want to use static members or a module of functions. I think [the F# Component guidelines](https://fsharp.org/specs/component-design-guidelines/) is an useful document to get a taste of how F# code is meant to look like. Take a look specially at sections 3 and 4. Just notice that when they say "consider", they mean "take it into consideration", not "you're doing it wrong otherwise".
Point and Vector are distinguished here because they are part of a game library, where Point is integer based, usually used to refer to screen coordinates, and vector is floating point. 
&gt;First, I'll let you know that the System.Numerics namespace already contains vector and matrix types and some of their operations are SIMD accelerated. This goes for both C# and F#. I know, and maybe will use it in the future, but for now learning the math behind it is also a goal of this project. Anyhow thank you for mentioning it. &gt;'d suggest to make the type a value type with the &gt; &gt;`[&lt;Struct&gt;]` &gt; &gt;attribute. This is really cool, so you can decide which types should be value types! &gt;Yes! Instance members don't always play nice with type inference but we don't shy away from them either. It's also a matter of preference if you want to use static members or a module of functions. Ok, didn't knew that, always thought that this is some sort of anti pattern &gt;I think [the F# Component guidelines](https://fsharp.org/specs/component-design-guidelines/) is an useful document to get a taste of how F# code is meant to look like. Take a look specially at sections 3 and 4. Just notice that when they say "consider", they mean "take it into consideration", not "you're doing it wrong otherwise". Bookmarked
FYI a more up to date version is here: https://docs.microsoft.com/en-us/dotnet/fsharp/style-guide/component-design-guidelines
for f#, i would first recommend becoming familiar with the microsoft docs. for example, here's one of the entries on records: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/records they are quite good, show examples, and also dictate conventions. for example, it's a convention to capitalize and use PascalCase for record field names. sonyou should use X and Y unless your instructor says otherwise. as a note, your question is about f# records and not f# vectors. you are defining a vector type using records. i also recommend the suggestion of providing a + operator overload to your vector so that you could add two vectors with "a + b" and not just "plus(a,b)". there are other books, but to be honest, most f# books are not great. they are good, but not great. given that many of them are more reference type of books, i find myself using the microsoft docs a lot.
What about Visual Studio Code? Does it offer a good alternative? (C# developer thinking of trying out F#)
It’s definitely well-worth trying F#! I’ve gotten VSCode + Ionide working great for me in MacOS, Windows and Ubuntu. I’ll briefly sketch what I had to do get things set up: **Install these core components** - .NET Core: https://www.microsoft.com/net/download - Mono: https://www.mono-project.com/download/stable/ - F# Language Support: https://fsharp.org/ **VS Code + following extensions** - ms-vscode.csharp - ionide.ionide-fsharp - ionide.ionide-paket - ionide.ionide-fake **Create F# Project** - Create project folder - Open project folder in VSCode - Command Palette -&gt; F# New Project -&gt; Console Application -&gt; &lt;pick directory name&gt; -&gt; &lt;pick project name&gt; **Re-target project to .NET Core and refresh packages:** - In your .fsproj file, change Target Framework to: *&lt;TargetFramework&gt;netcoreapp2.0&lt;/TargetFramework&gt;* - In paket.dependencies file, remove this line entirely: framework: *&gt;= net461* - Comand Palette -&gt; Paket Install - Terminal -&gt; dotnet restore **Setup tasks.json and launch.json** This is bit trickier to explain in point form, I would look at the instructions on this web page https://atlemann.github.io/fsharp/2018/02/28/fsharp-solutions-from-scratch.html Do a search on the page for the phrase “**With VsCode**” to jump directly to the relevant section. --- You should be able to build and and run the project with debugging at this point. I'm new to F# myself, but free to ask for clarification on this process, and/or check out this discussion page, https://gitter.im/ionide/ionide-project, managed by Ionide creator Krzysztof-Cieslak.
I would suggest following the up-to-date instructions from Microsoft here: https://docs.microsoft.com/en-us/dotnet/fsharp/ As for free books, sign up for a free trial for Safari Books Online (they won't ask for your credit card or anything just for the trial), and read this excellent book: [Get Programming with F#](https://www.safaribooksonline.com/library/view/get-programming-with/9781617293993/) &lt;whisper&gt; when your free trial expires you can sign up with another email address &lt;/whisper&gt;
The relevant section is here: https://docs.microsoft.com/en-us/dotnet/fsharp/get-started/get-started-visual-studio#running-your-code Unfortunately, that part of the wiki looks wildly out of date. I love the wiki for general programming concepts, though, so definitely bookmark it for language documentation and examples.
Thank you. What is the difference between a .NET Core Console app and a Console app? 
&gt; The relevant section is here: &gt; https://docs.microsoft.com/en-us/dotnet/fsharp/get-started/get-started-visual-studio#running-your-code ah. oddly enough, after following that, I got an error about tabs not being allowed in the code. I went to `Tools -&gt; Options` and forced tabs to be rendered as spaces. After that `CTRL-F5` worked fine.
&gt; &lt;whisper&gt; when your free trial expires you can sign up with another email address &lt;/whisper&gt; lol. thanks.
Good to know you got started. Please PM me if I can help you on your journey. ;-)
let countWords (s:string) = printfn "%s has %d words in it" s (s.Split(' ').Length) &amp;#x200B; let countWords2 (s:string) = printfn "%s has %d words in it" s (s |&gt; Seq.fold(fun tot thisChar -&gt; if thisChar = ' ' then tot+1 else tot) 1)
Since you don’t use wordList, you could say: let numWords = s.Split |&gt; fun wordList -&gt; wordList.Length Although there really is nothing wrong with the way you’ve done it.
Your code is fine, no need to get rid of the temporary variables as they add to the readability and debug-ability of your code.
&gt; I want to eliminate my temporary variables This style is called point-free, and regardless of whether it is considered bad practice or not, I think you want something like this: `let countWords (s:string) = s.Split(' ') |&gt; Array.length |&gt; printfn "%s has %d words in it" s`
Updated in my post too. Sorry for posting an old version; it shows up first on Google for me, and Microsoft's insistence on giving SEO to badly machine-translated documentation doesn't help. I didn't even realize it's the same document because the title shows as "Design instructions of the component of F#" in broken Spanish.
Hello Dave, Great job so far. I'd like to give you some feedback if that's ok. - You videos are really fast paced. It's sometimes hard to follow (specially as someone that is new to F#). I understand that it's your style and format but I think it will be beneficial for a lot of viewers to have a more calm pace. - It's great that you explain the use cases but they sometimes don't resonate with me. Maybe putting more context and backstory would be beneficial. I understand that it will have an impact on the format and the style of the video and that might be too much to ask. - It would be nice to have a larger font. It's hard to read when I'm on the phone. What is your thoughts on these ?
I program in Python professionally. I'm a bit tired of 80 million temporary variables each time I want to do something.
wow. nice. curried functions. so `Split()` returns an Array in .net... In python `split()` returns a list. if you're going to be functional-first, this is how to get the job done. 
Im still sort of experimenting with the format, it was intended to be bang, bang, bang, job done, no wasting time - 10 mins max. I see so many videos with lots of fluff, yes I know I have 30 seconds of b-roll at the beginning, I feel that gives some personality though as it shows me as a person, I like that in other YouTube channels that I enjoy watching too. If you look closely you will find I use a different IDE on each video too, this one was done with JetBrains rider in presentation mode, Im not sure if theres actually an option for font size in that mode. One thing I will try to do is create some titles for between each section so there is a little pause to catch your breath and let everything settle in for a few seconds.
Use cases, sometimes the use case itself could take longer than 10 mins to describe, for the active patterns one I thought it would be good to start with simple ones that shows you the syntax then show a few variations like the quotations one and the rom access one, which so something I used in the emulator I was like streaming, also if you look in the gist in the description theres a CPU matching one that never made it into the video, its probably a shame as that shows more of how active patterns simplify a collection of if elif else into a nice succinct, single pattern match.
I completely understand, maybe going less in depth then. Not to dumb down the content but to push forward some broader and most use cases. It's a thin line to walk I understand. I can't stand all the "create your app in 2 minutes" videos and tutorial and it's sometimes hard to find proper tutorials from knowledgeable people.
Thats the thing you can do weird hacky things with everything Ive tried to avoid the less used things, like using muticase AP's as a method and matching on the different choice types that come back, thats still in the gist if you wanted to take a peek. Im not entirely happy with the format, feels a little formal... Im sure I'll keep experimenting with the format and it will evolve along the way, I do try to incorporate the feedback I get, although sometimes I forget my check list :-) &amp;#x200B;
Pattern matching work a little different than you you seem to expect. Your first try shadows the n input parameter with a new n. The same happens on the second try. The third try uses whats called an active pattern to either return Equals or _ and the fourth let just matches on this pattern. Your last pattern works as the pattern matching binds the value of x to z when z = n. I would recommend using If than else in this case like this let equal x n = if (x = n) than 1 else 0
yes, when you use temporary variables, the fsharp interactive window shows you the values of each temporary variable as it executes... no more need to echo-print them!
I would actually suggest not using a pattern match for what you’re trying to do. It is a construct that I think would be better represented with an if/else expression and a Boolean return: `let equals x n = if x = n then true else false` This is more concise and readable in my opinion. If you need to do it the way you’ve indicated, then I personally would use the active pattern that you found on stack overflow. If I have to guard a pattern match, I typically prefer an if/else expression, or I will use an active pattern to encompass the guard. Another way to express this is with function syntax, wherein one might say: `let equals x = function | n when n = x -&gt; 1 | _ -&gt; -1` What this means is that `equals` takes an explicitly defined input, `x`, and any input after that is routed through the pattern match as `n` at which point it compares x to n.
Honestly, 15 or even 20 minutes are okay if it helps to get the topic across. 
What for. Property access is petty fundamental. It's like asking how to make code more DRY by not using the (+) operator more than once. Also doing so would improve the readability either. So what's the point?
 open Domain open Operations [&lt;EntryPoint&gt;] let main argv = let joe = { FirstName = "joe"; LastName = "bloggs"; Age = 21 } joe.FirstName |&gt; if joe |&gt; isOlderThan 18 then printfn "%s is an adult!" else printfn "%s is a child." 0 
My first response is that this isn't necessary here. Having an explicit `joe.FirstName` helps with readability - the dot-notation makes it clear that you're grabbing the FirstName of the `Customer` type. Generally with DRY, it's more about not repeating substantial pieces of logic. For instance, you might want to put the `if joe |&gt; isOlderThan 18` logic into its own function if you're using this often. That would be good DRY design. Literal syntactic repetition of grabbing fields from record types isn't really anti-DRY. Trying to work your way around it is usually overcomplicating the code. I think it's better to leave the `joe.FirstName` calls in here. &amp;#x200B; But I don't like giving absolutist advice without knowing more about the context :) You could grab the first name in a let binding: [&lt;EntryPoint&gt;] let main argv = let joe = { FirstName = "joe"; LastName = "bloggs"; Age = 21 } let joeFN = joe.FirstName if joe |&gt; isOlderThan 18 then printfn "%s is an adult!" joeFN else printfn "%s is a child." joeFN The downside of this is that the programmer has an extra value name to keep in mind. I would stick with `joe.FirstName` here. Another option is adding your own custom implementation of `ToString()`, which is the direction I personally prefer: type Customer = { FirstName : string LastName : string Age : int } override x.ToString() = x.FirstName // override ToString to only return the first name. // Note the use of %O format code. This will print the type's .ToString() value. if joe |&gt; isOlderThan 18 then printfn "%O is an adult!" joe else printfn "%O is a child." joe Then you could add another method to `Customer` if you want to grab the full name later. (e.g., `member x.FullNameString() = x.FirstName + " " + x.LastName`) But this is only ideal if you're mostly &amp;#x200B; See also this SO post for using the `StructuredFormatDisplay` attribute: [https://stackoverflow.com/questions/791706/how-do-i-customize-output-of-a-custom-type-using-printf](https://stackoverflow.com/questions/791706/how-do-i-customize-output-of-a-custom-type-using-printf) &amp;#x200B; Again, all of these may be engineering things into your `Customer` type that you don't actually want! You probably don't want the default ToString implementation to *always and only* return the first name. Basically: don't make the program too complicated in order to reduce very simple repetition. That's sort of like a premature optimization.
oh this is sweet. man I like it!!!
 printfn "%s is %s" joe.FirstName (if joe |&gt; olderThan 18 then "an adult!" else "a child.")
DRY doesn't mean you're not allowed to write something twice. It's about not writing copy pasta code. Nothing wrong with what you have. The clean code solution would be to write a method taking the age as a parameter, and return a string / side effect to print. That way you don't inline all your logic making it hard to read, and you have a reusable (DRY) way to perform the same operation for other people
I was literally on another post when I posted that. I have no idea why this comment is in this post...
Fair point for lists, but the original question was not about lists.
I don't believe there is, though your first example can use the standard function composition operator (&gt;&gt;). Functions are partially applied from the left, so I'm not sure that there's any shorthand for composing on the right-hand side without partially applying. So, the second example could be written as: let composed a b = f1 a b &gt;&gt; f2 I appreciate that's not what you're after, though I would be surprised if any FP language offered what you want. 
Not using "traditional" language features, unfortunately. It's technically possible to approximate this using SRTP (statically resolved type parameters), but it is incredibly ugly and brittle. SRTP is pretty difficult to use in general, but especially in a case like this with many function types and generic types, putting it in a code base is basically saying "fuck you" to whoever comes after you to maintain that code :) It fails if you pass a generic function, and if you have a type mismatch anywhere near it, the error message you'll get will make you throw up. I suggest you just bite the bullet and define different operators for different numbers of arguments.
the easiest way i see is to just assign a local binding to the name. so after "let joe = ..." just use let name = joe.FirstName and then replace joe.FirstName with this name binding. what is nice about this is that it is clean, and it also provides a one stop shop for when you want to update the name reported. for example, what if you later decide you want to print out the full name? then you'll just update the name local binding. also, as a note, you can pattern match with records. so you could get fancy and do: let {FirstName = firstName; LastName = lastName; Age = _} = joe then firstName will have value "Joe" and lastName will have value "bloggs". anything more complicated than a local binding is not worth it, at which point you should keep the multiple property access. as others said, this is fundamental. it should be fast and not a problem at all. it's possible that it's something the compiler even takes care of in this case.
It's actually not about `open`, it's about the difference between a source file and a script file. Since a source file (`.fs`) is considered a part of the project it lives in, it can access anything defined before it within that project via the `open` statement. Scripts are "free" in that they aren't attached to a particular project at all. The upside is that you can do whatever you want in a script without affect the project it may happen to live in. The downside is that it doesn't get access to everything in the project by default, and you must `#load` a given file to access its constructs.
I'm using Fable extensively at work to do just that. It's both very powerful and fun.
IMO this is a fine place to ask that question :) Maybe other people disagree, but I think this subreddit is happy to help beginners - it's also quiet enough that I don't think we feel flooded by intro requests. &amp;#x200B; In your code, you are binding the results (of type `unit`) to a value, even if that value is discarded. So you still need to use `let` to bind the result. This should work: &amp;#x200B; let fileSystemAudit acct message = let fileSystemPath = sprintf "C:\temp\learnfs\capstone2\%s\%s.txt" acct.customer.name acct.id let _ = createBaseDirectoryOf fileSystemPath let _ = File.WriteAllText fileSystemPath MessageProcessingHandler Note the `let` before the underscore. But for side-effect computations, it's typically more idiomatic to do something like this: let fileSystemAudit acct message = let fileSystemPath = sprintf "C:\temp\learnfs\capstone2\%s\%s.txt" acct.customer.name acct.id createBaseDirectoryOf fileSystemPath File.WriteAllText fileSystemPath MessageProcessingHandler Since the return type is `unit` you don't have to bind them to a value.
Thanks, I realised a while later that its basically not possible to do it without breaking the whole concept of lambda calculus. I updated my post.
Thanks, I realised a while later that its basically not possible to do it without breaking the whole concept of lambda calculus. I updated my post.
and just a note for the op, if the expressions didn't have type unit and returned something, you'd want to put an "|&gt; ignore" in there like: let fileSystemAudit acct message = let fileSystemPath = sprintf "C:\temp\learnfs\capstone2\%s\%s.txt" acct.customer.name acct.id createBaseDirectoryOf fileSystemPath |&gt; ignore File.WriteAllText fileSystemPath MessageProcessingHandler |&gt; ignore that causes the return value to be ignored and then a unit type is returned from the ignore.
you are calling DirectoryInfo.CreateDirectory and not Directory.CreateDirectory in model.fs . the example you linked does just that. you need to call Path.GetDirectoryName for that method since you are just opening System.IO .
I don't know what happened to it, but based on the Google preview it seems it was a library to add Fable bindings for Inferno. I dind't spend too much time with Fable, but it seems they utilize the TypeScript DefinitelyTyped typings, so could it be that the fable-infero library is simply not needed anymore? DefinitelyTyped provides types for Inferno, so you can just use those.
Thanks for the answer. I guess that makes sense. I'll look into trying out [https://github.com/fable-compiler/ts2fable](https://github.com/fable-compiler/ts2fable)
You're not calling an F# function, but a .NET function. You need to use an alternative syntax providing a tuple: File.WriteAllText(path, message)
The file you have linked to is an F# source file (it has a `fs` extension; F# script files tend to have the `fsx` extension). For F# source files, the entire file has to be compiled into IL code before it can be executed.
&gt; ~~.NET function~~ .NET method Might as well use the most differentiating term :)
Good point, I've modifed my post. Thank you Mr TarMil.
Full disclaimer, this is my podcast.
Nice talk. High energy speakers. I learned about Elmish-Bridge.
The github link to elmish is dead.
I believe this will work. type LineElement = { a: Point b: Point strokeColor: string strokeThickness: float } type Document = { width: float height: float Childs: Element list } and Element = | Line of LineElement | Document of Document
Check out this [https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/classes#mutually-recursive-types](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/classes#mutually-recursive-types)
Use `and` instead of `type` on the latter type. `type ... and ...` lets you declare mutually recursive types.
this is exactly what I was looking for &amp;#x200B;
Are you by chance thinking that recursive namespaces allow creating a circular dependency between two different files? If that's the case, "recursive namespaces" only affect the file where the `rec` modifier is added to the namespace, so I'm not really sure it changes anything about how F# compilation order helps break circular dependencies between files. e.g. Assuming `A.fs` compiles before `B.fs`, this will error: &gt; A.fs namespace rec Test type Document = { Width: float Height: float Children: Element list // It errors here } &gt; B.fs namespace rec Test type Element = | Line of string | Document of Document If you already know that recursive namespacing works only within the file where `rec` modifies `namespace`, what do you mean? I don't see how it's that different from using `and` to create recursive function definitions and types within a single file.
I'm aware of that, I just feel that new F# users should endeavour to order their definitions within individual files properly, and not rely simply on defining a recursive namespace.
I've been getting into Angular and want to use F# for the backend of my new little learning project. 
What kind of project? And will you share the source? :)
F# Beginner here! I'm going to make some small games (tic tac toe, black jack and more) to get to know the language a bit better! If any of you have some fun beginner-friendly projects let me know!
It's supposed to be a small e-commerce like website. I don't feel like sharing the source atm because pretty much nothing is really working hahaha
[https://adventofcode.com/2018](https://adventofcode.com/2018) That \^\^ Beginner here, learning F# via uni Currently terribly stuck with trying to make a while structure in a functional mindset. It's proving astonishingly difficult (part 2 of dec. 1st)
using f# a little for instrument control. it makes it very easy to interact with .net APIs, even if they're written in an oop or imperative style. i normally wrote some functions to interact and then wrap everything in a class.
I often like to avoid while type loops completely and go with tail recursion. I think it’s a lot more satisfying to implement.
Using my F# skills, oddly enough, to answer the question: what's the smallest blog platform?[0] (I know it sounds contrived, but it's true) Really, really hoping to get back to finishing up my analysis compiler enough to do some demos. Beginning to suspect that the framework I've created based on past projects was a bad idea. Too much structure, too many assumptions, too soon in the solution process. 0. https://www.youtube.com/watch?v=XUjfD55SMxc
1) I am also doing Advent of Code :) I would say I'm a fairly experienced F# dev, but I'm sure I'll get stuck on something and learn new techniques and ways of thinking. In addition to F# answers, I am also trying out answers in Idris. 2) I love roguelike games, and I have been working on a small F# library, similar in concept to [GoRogue](https://github.com/Chris3606/GoRogue/) or [RougeSharp](https://github.com/FaronBracy/RogueSharp). Currently the front end is just an ASCII console application but I am thinking of trying an Electron solution (retaining the .NET Core backend). I am not sure if anything will come of this, but it's fun. 3) For quite a while, and very slowly, I have been working on an F# program to solve out-of-core linear algebra problems using an actor model on Azure Service Fabric. F# isn't a great language for high-performance linear algebra, especially large dense matrices, but in a lot of real-world cases I'm interested in (e.g., electricity grid modelling) "big matrices" really means "very sparse matrices made up of fairly small dense blocks." I.e., something where the by-flop gains of a language like C or Fortran maybe isn't as important (or cost-efficient) as having a good domain / parallelism model. I am not sure anything will come of this either! But I have been developing F# tools for Service Fabric more generally, and again it's a lot of fun. 4) I am unemployed, so: trying to convince employers that they need an F# dev :)
you can use `Seq.scan` instead of `Seq.fold` to get a list with intermediate results (very useful here) I'm not sure if there is a function that let's you endlessly repeat a sequence but this should do: let rec cycle xs = seq { yield! xs yield! cycle xs }
When I did the second problem I also sat for a bit and wondered how this could be done "functionally" but decided "screw it i'm using a while loop, because it is easy with a while loop" let freqs = inputStr.Split("\r\n") |&gt; Seq.filter ( fun s -&gt; s &lt;&gt;"") |&gt; Seq.map (fun s -&gt; Int32.Parse(s)) let dict = new HashSet&lt;int&gt;() let mutable freq = 0 while true do for i in freqs do if dict.Contains(freq) then printfn "%A" freq Console.ReadLine() |&gt; ignore else dict.Add freq |&gt; ignore freq &lt;- freq + i
This was my recursive solution: let input = File.ReadAllLines("Day1Input.txt") type SearchResult = SolutionFound of int | StillLooking of int * Set&lt;int&gt; let SolveTask2 () = let rec searchForKnownSum previousSums previousSum numbers = let rec searchOnce previousSums previousSum numbers = match numbers with | [] -&gt; StillLooking (previousSum, previousSums) | newNumber :: remainingNumbers -&gt; let newSum = previousSum + newNumber if Set.contains newSum previousSums then SolutionFound newSum else searchOnce (Set.add newSum previousSums) newSum remainingNumbers let searchOnceResult = searchOnce previousSums previousSum numbers match searchOnceResult with | SolutionFound number -&gt; number | StillLooking (sum, newPreviousSums) -&gt; searchForKnownSum newPreviousSums sum numbers input |&gt; Seq.map ParseInt32 |&gt; Seq.toList |&gt; searchForKnownSum Set.empty 0 |&gt; printfn "The first repeating frequency is %i.\n" That works, but it's *slightly* longer than the functional solution I was able to build using jackmott2's hint towards Seq.scan: let input = File.ReadAllLines("Day1Input.txt") let SolveTask2 () = seq { while true do yield! input } |&gt; Seq.map ParseInt32 |&gt; Seq.scan (fun (set, sum) number -&gt; (Set.add sum set, sum+number)) (Set.empty, 0) |&gt; Seq.find(fun (set, sum) -&gt; Set.contains sum set) |&gt; snd |&gt; printfn "The first duplicate sum is %i.\n" &amp;#x200B;
Yes! Thank you, Seq.scan was what I was looking for! I had a feeling that I had seen a function that does what I need, but I couldn't remember that name. For the endless loop I simply did seq { while true do yield! inputlist } In this case I find the while loop more expressive than recursion since it makes it more obvious that this is in fact an endless loop.
Seq.scan wasn't my hint! But that does turn out nice, and performance may not be terrible too. 
yeah good thinking - usually while loops are better than recursion in F# (did not think about it - to much Haskell on my mind lately ;) )
I am currently knee deep in preparing my "Event Sourcing Do it Yourself" Video series for the F# Advent calendar. Takes way too much time but I hope it will be worth watching it in the end
Oops, sorry, I meant CKoenig's hint of course.
indeed, in the end i found a rather satisfying solution to it(since we're on day 2 already, it's probably alright to share) module PartTwo let input = System.IO.File.ReadLines("./input.txt") |&gt; Seq.toList |&gt; List.map int let rec solve (list :int List) (values :int Set) (cFrequency :int) :int = match list with | [] -&gt; solve (input) (values) (cFrequency) | x::xs -&gt; let y = x + cFrequency in if Set.contains y values then y else solve (xs) (Set.add y values) (y) solve input (Set.add 0 Set.empty) 0 |&gt; printfn "%A" 
I'm sharing my solution - an example of an elegant functional solution without while loops or lists. If we think about the demands for our problem, neither lists or sequences are good enough. Since the list of frequencies changes can potentially be iterated over millions of times, we need to make sure that can be done fast. This means that all frequencies should preferable be in the CPU cache for the whole of the algorithm's runtime. The only structure that can guarantee this is the array. When it comes to iterating "infinitely" through the array, a simple recursive function is enough, as you will see. Secondly, we can do a lot better than a linear time lookup, which unsorted lists or arrays give us. Instead my solution uses the `Set` module, which is implemented using a self-balancing binary tree (AVL-tree). Binary trees give us O(log n) lookup and insertion. My solution performs these two operations for every frequency change (until we find a duplicate), resulting in the complexity of the algorithm being O(n log n). An algorithm based on unsorted lists or arrays can at best achieve O(n\^2). Note: using `HashSet` will probably be even faster - lookup and insertion is O(1). But since I wanted a functional solution a settled for set. Here is my solution: &amp;#x200B; let findDuplicate (xs : int \[\]) = let rec go i freq set = if Array.length xs &lt;= i then go 0 freq set else let freq2 = freq + xs.\[i\] if Set.contains freq2 set then freq2 else go (i + 1) freq2 (Set.add freq2 set) go 0 0 (Set.singleton 0) &amp;#x200B; &amp;#x200B; &amp;#x200B; let readAndRun : string -&gt; int = File.ReadAllLines \&gt;&gt; Array.map Int32.Parse \&gt;&gt; findDuplicate &amp;#x200B;
My solution is similar to yours, but instead uses a functional style (see my comment above). Writing a recursive function that behaves like a while loop is really simple (as seen in my comment). Try it! 
Interesting, I'll do a benchmark when I am at my computer. What I suspect I will find is that in my solution it's a mistake to do everything using Seq-functions, since that probably means that the strings are parsed over and over again, but I expect that once I replace that one call the non-recursive functional solution should be doing the same thing internally. 
My solution is similar to yours, but instead uses a functional style (see my comment above). Writing a recursive function that behaves like a while loop is really simple (as seen in my comment). Try it!
Cool! Post the benchmarks when you are done! Your second solution is probably faster than the first one simply because it does not rely on linked lists. However, I suspect that my solution will still be faster. Even if the chain of `Seq` functions is rewritten into a tight loop, there will probably be overhead caused by the iterators used in the `Seq` implementation.
Day 2 - second problem was kinda hard for my beginner F# brain. Managed to do it though. let problemTwo (inputList : seq&lt;string&gt;) = let inputCharArrays = inputList |&gt; Seq.map (fun x -&gt; x.ToCharArray() ) |&gt; Seq.toList let letterDiffByOne (text : char[]) (other : char[] ) = let indexDiffs = Array.map2 (=) text other |&gt; Array.mapi (fun i a -&gt; if a then None else Some i) |&gt; Array.choose id if indexDiffs.Length &lt;&gt; 1 then None else Some (indexDiffs.[0]) let letterFreq (text : char[]) (all : seq&lt;char[]&gt; ) = all |&gt; Seq.map (letterDiffByOne text) |&gt; Seq.choose id |&gt; Seq.toList let splitAndCombine arr index = let (part1, part2) = Array.splitAt index arr Array.concat [ part1 ; (Array.skip 1 part2) ] |&gt; System.String let result = inputCharArrays |&gt; Seq.map (fun x -&gt; (x ,(letterFreq x inputCharArrays))) |&gt; Seq.filter (fun (x,y) -&gt; y |&gt; Seq.isEmpty |&gt; not) |&gt; Seq.collect (fun (arr,seqOfIndex) -&gt; seqOfIndex |&gt; Seq.map (splitAndCombine arr) ) |&gt; Seq.distinct |&gt; Seq.toList printfn "%A" result
Ok... I did not expect this. Benchmarking is weird. And reasoning about benchmarks is a bit like trying to explain the Bible. The slowest solution is my second one, the one making excessive use of Seq-functions. On average that solution took about 670k ticks. The next faster solution is that same one where I first mapped the array of strings into an array of integers before I generated the endless sequence. It's significantly faster at about 600k ticks, but it's just about half way to your solution. So so far you were right. Now your solution takes about 521k ticks, so it is indeed the fastes out of the three so far. And here comes the crazy part: my recursive solution using lists is actually faster than yours. Only slightly so (about 512k ticks), but consistently. I even repeated the benchmark using Mono, where everything was orders of magnitude slower, but then I only started it using "mono Day1Fs.exe", so there's a good chance that was my fault. But even with the slower results the relation between the four cases was the same. 
In case someone wants to verify my findings this is my code. I didn't clean it up in any way to make sure that I didn't clean up any mistakes that I may have made that might explain the results. open System.IO open Microsoft.FSharp.Core.LanguagePrimitives open System let input = File.ReadAllLines("Day1Input.txt") let SolveTask1 () = input |&gt; Array.map ParseInt32 |&gt; Array.sum |&gt; printf "The sum of all inputs is %i." let SolveTask2 () = seq { while true do yield! input } |&gt; Seq.map ParseInt32 |&gt; Seq.scan (fun (set, sum) number -&gt; (Set.add sum set, sum+number)) (Set.empty, 0) |&gt; Seq.find(fun (set, sum) -&gt; Set.contains sum set) |&gt; snd //|&gt; printfn "The first duplicate sum is %i." |&gt; ignore let SolveTask2Array () = let array = Array.map ParseInt32 input seq { while true do yield! array } |&gt; Seq.scan (fun (set, sum) number -&gt; (Set.add sum set, sum+number)) (Set.empty, 0) |&gt; Seq.find(fun (set, sum) -&gt; Set.contains sum set) |&gt; snd //|&gt; printfn "The first duplicate sum is %i." |&gt; ignore type SearchResult = SolutionFound of int | StillLooking of int * Set&lt;int&gt; let SolveTask2Recursive () = let rec searchForKnownSum previousSums previousSum numbers = let rec searchOnce previousSums previousSum numbers = match numbers with | [] -&gt; StillLooking (previousSum, previousSums) | newNumber :: remainingNumbers -&gt; let newSum = previousSum + newNumber if Set.contains newSum previousSums then SolutionFound newSum else searchOnce (Set.add newSum previousSums) newSum remainingNumbers let searchOnceResult = searchOnce previousSums previousSum numbers match searchOnceResult with | SolutionFound number -&gt; number | StillLooking (sum, newPreviousSums) -&gt; searchForKnownSum newPreviousSums sum numbers input |&gt; Seq.map ParseInt32 |&gt; Seq.toList |&gt; searchForKnownSum Set.empty 0 //|&gt; printfn "The first repeating frequency is %i." |&gt; ignore let findDuplicate (xs : int []) = let rec go i freq set = if Array.length xs &lt;= i then go 0 freq set else let freq2 = freq + xs.[i] if Set.contains freq2 set then freq2 else go (i + 1) freq2 (Set.add freq2 set) go 0 0 (Set.singleton 0) let readAndRun : string -&gt; int = File.ReadAllLines &gt;&gt; Array.map Int32.Parse &gt;&gt; findDuplicate let SolveTask2Reddit () = "Day1Input.txt" |&gt; readAndRun //|&gt; printfn "The first repeating frequency is %i." |&gt; ignore [&lt;EntryPoint&gt;] let main argv = //SolveTask1() let measure tests f = let watch = new System.Diagnostics.Stopwatch() let measureOnce f = watch.Reset() watch.Start() f() watch.Stop() watch.ElapsedTicks [1..tests] |&gt; Seq.map (fun _ -&gt; measureOnce f) |&gt; Seq.averageBy(fun ticks -&gt; (float)ticks) |&gt; printfn "%i tests took %f ticks." tests printfn "SolveTask2:" measure 100 SolveTask2 printfn "SolveTask2Reddit:" measure 100 SolveTask2Reddit printfn "SolveTask2Array:" measure 100 SolveTask2Array printfn "SolveTask2Recursive:" measure 100 SolveTask2Recursive 0 // return an integer exit code &amp;#x200B;
I took your code and made some improvements to the benchmarking. First of all, we're interesting in measuring the actual time that each function spends on the processor, or CPU time. This is because the operating system does a lot of things at "the same time", switching processes around. If we then measure actual time, we will also measure the execution time of other processes - ruining our measuring. Secondly, I noticed that switching the order around changes which function is the fastest. More specifically, the last function is the faster. This could be because of some kind of "virtual machine warm up", but let's not dwell on that. The fix i came up with is to intersperse the running of the two functions: first we run f, then g, then f again, then g again, etc. With these changes, the measuring on my machine shows that my solution is up to one second faster for 100 tests. However, most often it' about a couple of hundred milliseconds faster. Please confirm this. I ran with .NET core using the command "dotnet run -c Release". My analysis: It's amazing that the linked list implementation i so fast! I reckon that the compiler never actually generates the linked list, it's optimized away and your solution gets the benefits of linked list syntax without the performance drawbacks. The small difference between yours and mine should be the overhead from using iterators of integer indexing. Here is the code: open System.IO open Microsoft.FSharp.Core.LanguagePrimitives open System open System.Diagnostics let path = "d1.txt" let input = File.ReadAllLines path let SolveTask1 () = input |&gt; Array.map ParseInt32 |&gt; Array.sum |&gt; printf "The sum of all inputs is %i." let SolveTask2 () = seq { while true do yield! input } |&gt; Seq.map ParseInt32 |&gt; Seq.scan (fun (set, sum) number -&gt; (Set.add sum set, sum+number)) (Set.empty, 0) |&gt; Seq.find(fun (set, sum) -&gt; Set.contains sum set) |&gt; snd //|&gt; printfn "The first duplicate sum is %i." |&gt; ignore let SolveTask2Array () = let array = Array.map ParseInt32 input seq { while true do yield! array } |&gt; Seq.scan (fun (set, sum) number -&gt; (Set.add sum set, sum+number)) (Set.empty, 0) |&gt; Seq.find(fun (set, sum) -&gt; Set.contains sum set) |&gt; snd //|&gt; printfn "The first duplicate sum is %i." |&gt; ignore type SearchResult = SolutionFound of int | StillLooking of int * Set&lt;int&gt; let SolveTask2Recursive () = let rec searchForKnownSum previousSums previousSum numbers = let rec searchOnce previousSums previousSum numbers = match numbers with | [] -&gt; StillLooking (previousSum, previousSums) | newNumber :: remainingNumbers -&gt; let newSum = previousSum + newNumber if Set.contains newSum previousSums then SolutionFound newSum else searchOnce (Set.add newSum previousSums) newSum remainingNumbers let searchOnceResult = searchOnce previousSums previousSum numbers match searchOnceResult with | SolutionFound number -&gt; number | StillLooking (sum, newPreviousSums) -&gt; searchForKnownSum newPreviousSums sum numbers input |&gt; Seq.map ParseInt32 |&gt; Seq.toList |&gt; searchForKnownSum Set.empty 0 //|&gt; printfn "The first repeating frequency is %i." |&gt; ignore let findDuplicate (xs : int []) = let rec go i freq set = if Array.length xs &lt;= i then go 0 freq set else let freq2 = freq + xs.[i] if Set.contains freq2 set then freq2 else go (i + 1) freq2 (Set.add freq2 set) go 0 0 (Set.singleton 0) let SolveTask2Reddit () = input |&gt; Array.map Int32.Parse |&gt; findDuplicate //|&gt; printfn "The first repeating frequency is %i." |&gt; ignore [&lt;EntryPoint&gt;] let main argv = let measure tests f g = let proc = Process.GetCurrentProcess() let measureOnce f = let t = proc.TotalProcessorTime f() let t2 = proc.TotalProcessorTime (t2 - t).TotalMilliseconds seq {while true do yield (f, g)} |&gt; Seq.take tests |&gt; Seq.map (fun (f, g) -&gt; measureOnce f, measureOnce g) |&gt; Array.ofSeq |&gt; Array.unzip |&gt; (fun (fs, gs) -&gt; Array.averageBy float fs, Array.averageBy float gs) let recursive, reddit = measure 100 SolveTask2Recursive SolveTask2Reddit printfn "task2recursive vs. task2reddit:" printfn "CPU time: %A ms; CPU time: %A" recursive reddit 0
I'm not sure I understand how you counted the chars. Here is mine btw, I'm not happy with all the for loops but you are right I was pretty hard for someone new to the language. let HasDoubleOrTriple id = let mutable hasDouble = 0 let mutable hasTriple = 0 let dict = new Dictionary&lt;char, int&gt;() for char in id do if dict.ContainsKey char then let count = dict.Item char + 1 dict.Item char &lt;- count else dict.Add (char, 1) for entry in dict do let count = entry.Value match count with | 2 -&gt; hasDouble &lt;- 1 | 3 -&gt; hasTriple &lt;- 1 | _ -&gt; () (hasDouble, hasTriple) let CalcChecksum (input: string) = let arr = input.Split ',' |&gt; Array.map HasDoubleOrTriple let doubles = arr |&gt; Array.sumBy fst let triples = arr |&gt; Array.sumBy snd doubles * triples let checksum = CalcChecksum input printfn "%i" checksum
My goal was to not to mutability and for loops and my solution kinda suffers for it performance wise but it was fun to do. I make a char array and compare it with another. Then if char is same i map it to None and if it differs I map it to Some with value of the index that is different. Then I only keep the collections that have 1 Some value. Remove the char index, make strings to display and cleanup. I made it that there can be multiple differences in the input. The input had only one though.
Oh I see now. Thank you. FYI here is a solution that I think was the proper way of dealing with it in a functional way : https://github.com/CameronAavik/AdventOfCode/blob/master/Program.fs#L516 I'm not definitively not there !
Oh nice! That looks super compact. Thanks I'll have to play with that code a little :p
I don't quite follow the point about using iterators. Why would an iterator into an array cause any overhead? I mean an iterator is basically just an object that knows where it's pointing, how to get the data it's pointing at and how to get to the next element. In case of an array that would be pretty much exactly what you wrote. I wouldn't know why an iterator would contain any more data than the integer index in your code and why it would do anything other than what you are doing with the integer index. But yeah, I was surprised as well. But on the other hand the bigger question is why the performance isn't much better in all of these cases. I benchmarked my C# and C++ solutions and they were about ten times faster than any of the F# solutions.
That's not bad for a beginner! It is are really close to my solution. Here is my solution for day 2. let toInt = function | false -&gt; 0 | true -&gt; 1 let count xs = let freqs = Array.groupBy id xs |&gt; Array.map (snd &gt;&gt; Array.length) (Array.contains 2 freqs, Array.contains 3 freqs) |&gt; (fun (hasTwo, hasThree) -&gt; toInt hasTwo, toInt hasThree) let checkSum = Array.map count &gt;&gt; Array.fold (fun (a, b) (a2, b2) -&gt; a + a2, b + b2) (0, 0) &gt;&gt; (fun (numTwos, numThrees) -&gt; numTwos * numThrees) let differByOne cs cs2 = Array.map2 (&lt;&gt;) cs cs2 |&gt; Array.sumBy toInt |&gt; ((=) 1) let common cs cs2 = Array.zip cs cs2 |&gt; Array.filter (fun (a, b) -&gt; a = b) |&gt; Array.map fst let findCommon (all : char [] []) = let picker cs = Array.tryFind (differByOne cs) all |&gt; Option.map (fun cs2 -&gt; common cs cs2) Array.tryPick picker all |&gt; Option.map (fun cs -&gt; new String(cs)) let readAndRun path = let lines = File.ReadAllLines path |&gt; Array.map Array.ofSeq printfn "%A" (checkSum lines) printfn "%A" (findCommon lines)
Since I have not had time to read the generated IL, everything I say should be taken with a grain of salt. Right now, I'm just speculating. &gt;I mean an iterator is basically just an object that knows where it's pointing, how to get the data it's pointing at and how to get to the next element. There you go, that's why integer indexing is faster - integer are not objects and they do keep track of anything. The integer used for indexing in my solution is just 4 bytes of data, which is likely to get prioritized and perhaps stay in the CPU's registers. An iterator will only be equivalent if the compiler is able to totally optimize the object away. The F# compiler does not optimize as rigorously as C# and C++ compilers - sometimes because the devs just haven't gotten there yet, and sometimes because they prioritize the simplicity of the implementation over a specific optimization. If you consider sloc, C++ compilers are millions of lines of code, Roslyn is like 500 thousand lines of code, while the F# compiler is only like 150 thousand lines of code. Here is an interesting stack overflow thread which discusses a sequence expression and the code that is generated for it: [https://stackoverflow.com/questions/35378119/why-is-this-simple-f-code-36-times-slower-than-c-c-versions](https://stackoverflow.com/questions/35378119/why-is-this-simple-f-code-36-times-slower-than-c-c-versions) .
have you previously worked as a f# dev ? I’m currently hired ad a c#/.net dev and would love to hear how you got a f# role!
2. This could be really ambitious, but have you thought of renderig your game using Blazor ? [there are no templates, but blazor works with f#! ]
1: Building a library that can be used to calculate the hatching of a concave/convex polygone. 2: Blazor + F# experiments
This is how I did it, a bit longer, but for me it's a bit more readable: let SolveTask1 () = let calculateCharCounts (line : System.String) = line.ToCharArray() |&gt; Array.countBy(id) |&gt; Array.countBy(snd) |&gt; Map.ofArray |&gt; fun map -&gt; ((if map.ContainsKey(2) then 1 else 0), (if map.ContainsKey(3) then 1 else 0)) let addUpCharCounts = Array.reduce(fun (a,b) (a2,b2) -&gt; (a+a2,b+b2)) let addChecksum (a,b) = (a,b,a*b) let printResult (pairs, triplets, checksum) = printfn "There are %i pairs and %i triplets. The checksum is %i.\n" pairs triplets checksum input |&gt; Array.map calculateCharCounts |&gt; addUpCharCounts |&gt; addChecksum |&gt; printResult &amp;#x200B;
Does someone have some nice documentation on Seq.scan, Seq.fold or Seq.groupBy ? This looks like useful tools, but I don't have the habit of using them. 
I dug a little deeper and found out that what eats up the performance is the FSharp Set. It's not surprising that it's slow, given that it returns new copies everytime something is added, but I didn't expect it to be that slow. Once I replaced the Set with a HashSet the performance jumped from more than 200ms for an average run to about 7.5ms. The 20ms I had in C# were only due to the fact that I didn't parse the lines ahead of time, so with that fix I get the same result in C#.
Brilliant 
* Go is a very simple language, like C with garbage collection * Go has no generics (for now) compared to F#'s very sophisticated generics system * Go has very limited type inference * Go compiles faster * Go compiles to native executables Where F# (normally) runs on the .NET runtime and is JITTed * Go uses {} f# uses indentation * Go community and language prefers imperative, explicit idioms, F# community leans towards functional/declarative idioms * F# has various metaprogrmming facilities, Go intentionally avoids that * Go provides easier control over memory. You can use a type as a reference or value at will, vs needing to decide ahead of time in .net (struct vs class) * Go's gc is optimized for minimum latency while .NET is optimized more for throughput &amp;#x200B; Can't think of two languages more different really! &amp;#x200B;
I just want to make a point about your last statement. .NET GC can be configured in various ways, including [LatencyMode](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/latency) for critical operations and [Workstation/Server modes](http://mattwarren.org/2017/01/13/Analysing-Pause-times-in-the-.NET-GC/).
&gt;Go compiles faster Compared to F#? Compilation time has never been an issue for me in F# (and C#).
Yes, but in latency mode the latency isn't as low as Go's
Yes. and yes, compile times being an issue or not depend on a lot on workflow and project size.
Interesting, while researching this I came across [this article](https://medium.com/servicetitan-engineering/go-vs-c-part-2-garbage-collection-9384677f86f1) &gt; Go’s pauses are barely visible here — because they are tiny. The max. pause I was able to measure was ~ 1.3 seconds — for the comparison, .NET got 125 sec. STW pause on the same test case.
&gt; Go compiles to native executables Where explain this point further? isn't f# standalone implemented?
Yeah, it is an interesting trade off. That test was with really unusually high heap sizes, normally it is a question of sub millisecond vs 1 second pause times, rather than 1 second vs 2 minutes. The Go GC would be really good for games or other realtime graphics applications, but unfortunately go's design also has innately slower C interop, which is bad for those same applications. The net result may still be better in some cases, not sure. 
Normally when you compile an F# program it compiles to IL. When you run the program the .NET runtime compiles the IL to machine instructions on demand. It is possible to AOT compile .NET stuff now, I don't remember if F# is fully supported at the moment. If you do that, compile times will get even longer. And of course it is always possible *in principle* to compile a given language, or not. 
From fellow redditor /u/kiteason You can also read it online at https://www.safaribooksonline.com/library/view/stylish-f-crafting/9781484240007/ (free 10-day trial available without credit card required) I have no affiliation with the author, just happy to see good F# books come out...
Thanks for the plug, /u/danysdragons! If anyone has any questions about the coverage of the book, please ask here or PM me! It's intended as an intermediate book: i.e. you'll need a bit of previous F# exposure to get the best out of it. Kindle edition is available already. Physical copies available from 30th December, so if your aunty gives you book tokens for Xmas (are book tokens global and still a thing?) you know what to do with them! Once I get my sample physical copies I'll do an 'unboxing' video on youtube, where I'll discuss the coverage of the book. The cover was generated using F# and some open Ordnance Survey data. It's not fully nailed down yet, but my current plan is to talk more about that process at F# eXchange 2019.
Can also buy from Apress (https://www.apress.com/us/book/9781484239995) to get EPUB/PDF versions (which I prefer over Kindle/MOBI versions).
I wound up looking at the prices on apress out of curiosity... $35 for the book, or $29.95 per chapter! what a steal! 
Calibre is convenient for converting between file types. I suppose that technically involves DRM removal, but I can't see any moral objection in this case if you're just converting into another format for your own use.
$29.95 per chapter does seem odd! I'll check with Apress whether this is intentional. Thanks for pointing it out.
Looks like many books on Apress are $29 per chapter. I can't imagine they sell many that way...
I can't either! It was more a commentary about Apress than on the book itself! I'd be interested in checking it out. I've got a basic idea of F# and have done koans, but really have no idea how to make a project with F#... Would this be a good book for it?
I will check it out. I like that they use the word stylish. For me the ascetics of code is important and I like to look at beautiful code. I think one of the reason I like F# so much is that it looks perty. 
Very nice writeup. I love F# for all of those reasons and more and I dont like the code I'm forced to write in Go because of missing language features. Go is really not a modern language if you compare it to all of the newer languages the past years .
&gt;F# has various metaprogrmming facilitie Well, F# are pretty poor to be honest, I know a company that scrapped F# code using a type provider to use Go to generate code instead :-)
F# will AOT compile for iOS using Xamarin.iOS, no TCO though.
Yeah there are few ways to do it. I wish it was a "first class" option. Like go to project settings "AOT build this, LLVM optimization level 9000" 
&gt;Go is really not a modern language Yes Go is mostly uninteresting as a language, no doubt about it. I still like it :D 
Hey Kit, I've been really excited about the book. I have a subscription to Safari Books Online and started reading your book today. How are authors compensated on that platform? If I refresh the page a million times do you make a million cents? Love the book so far.
Have you looked at using Fable to interop with a Javascript graphing library? [Here's a bar chart example.](http://fable.io/fable-graphics/samples/d3/barchart/index.html) At the least, it gives you a ton of options on what you'd like to use for charting. 
The main difference is that being an average go developer you will find job. &amp;#x200B; While it is almost impossible to find F# job until you are "Muhammad I'm hard Bruce Lee".
&gt; .NET GC can be configured in various ways, including LatencyMode for critical operations and Workstation/Server modes. Which in turn can give you flexibility to prefer either latency or throughput. I've tried .NET's low latency GC modes and so on and they really suck. .NET is a high latency GC compared to languages like Go and OCaml. 
I've seen a talk on using Haskell at a startup where it was claimed that, while you get fewer candidates who know, or want to learn the language, that they are of higher than average quality. Not sure if that is true but it would be something to consider. &amp;#x200B; Go \*is\* a simpler language to pick up and learn fully, but is F# hard to learn the basics of? I had a summer intern who picked it up fine and quite enjoyed it, and was productive with it. &amp;#x200B; Since you can use most C# libraries the library situation is not so different I don't think. &amp;#x200B;
Hiring is gonna be hard.
Yeah, nothing compared to C++. IIRC, Go was created to be an alternative to C++ at Google.
It's hard whether you're hiring for Go or for F#. Would you rather hire someone who knows Go or a good programmer who doesn't know Go? I'd much rather hire the latter, but it takes time to suss them out. The same is true for F#. You won't find many people on the market who know F#, but you probably won't be inundated with resumes from *bad F# programmers* either the way you would be with Java, C#, and likely Go. The reality it is the responsibility of the company to cultivate talent. That's the sort of company talented people want to join. You have to help people become proficient at their jobs by providing training, learning materials, career opportunities, and a safe/high-functioning team environment. Hiring someone already proficient in your stack doesn't net you all that much value in the long run. You may not have to spend the two weeks training them in the basics of Go or F#, but the cost of that initial 2-4 weeks you spend training is really inconsequential over the span over 2-4 years of employment. 
having done both, go is a 'simplistic' language, not a simple one... it's myriad of corner cases you must eventually learn makes it quite cumbersome long term. F# may have a bit more startup cost, and not without it's faults but overall is a much better language, and still has quite a rich ecosystem. &amp;#x200B; There are F# programmers out there, and there's only one way to get more..and thats for people like you to go all in :D
In my experience, you have to be competent enough in the language and the ecosystem to teach it to other people. This means knowing the ins and outs of the tooling, the editor options, the run-time, the profiler, debugging, diagnostics, the relevant libraries/frameworks, style guidelines, etc... If people have confidence that you (or your co-founder) know all these stuff and demonstrate that you can build-up a productive core team of 4 or so developers, then you won't encounter much resistance from your exec team or your investors. The FUD around F# and functional programming is pretty high (sometimes even in this subreddit), so you have the confidence to deal with it. Nothing kills FUD like enthusiasm, so make sure the people you bring on initially are zealots (in a good way) about whatever they're doing. That will permeate the rest of the organization and carry you through to the point where you reach critical mass and people stop second-guessing you. All that said, I love F#. I'm using in my current startup (alongside other technologies). I've been able to successfully teach it to other people, including non .net programmers. There are some gaps, though, in the dev experience, especially wrt to C#. The last few years have been tumultuous in the .net world, and I think the F# ecosystem is still catching up. Microsoft I think allowed the C# team to lead the shake-up, so of course they made some decisions without consideration for how other languages on the platform would be effected. The F# REPL, for example, is still broken as result of these foundational changes to .net. (They're very close to fixing it). So, you'll have to tolerate these gaps for the time being while the dust truly settles. My expectation is that in a few months time, the dev experience at the very least will come to resemble what node, Go, scala, etc... programmers would expect: very command-line driven, better than average editor support and intellisense, and cross-platform. F#'s dev experience however will probably never approach the level of polish Microsoft has applied to its flag-ship C#/Visual Studio combo, though. But neither will node, Go, or even Java. The larger concern has to be the .net ecosystem itself, and this goes for F#, C# and VB. Python has gained a massive advantage in the AI space, the JVM ecosystem continues to innovate, node dominates web and increasing desktop applications, and Go seems to be gaining traction with a lot of high-profile projects (eg. Docker, Kubernetes, Terraform, etc...) .NET isn't necessarily best-of-breed in any of these areas, and as a .NET startup, you may have to settle for whatever Microsoft's pushing or invest time in building/integrating technologies that are already available to JVM/Go/Python/JS users. When it comes to F# OSS, unfortunately, the aforementioned tumult around the .net platform has been rough on the smallish number of authors out there. A handful of exceptionally smart and prodigious people are responsible for a majority of the F# projects, and they could certainly use your help :) What I'm saying is that you may have to roll up your sleeves and contribute, at least with things like bug-fixing, documentation, and maintenance. Anyway, I hope this has been a fair (albeit rambling) assessment. The important points are: F# is a great language, perhaps the best of the mainstreamish statically-typed, FP/OOP hybrids out there today, including Scala and C#. (Yes, I realize there are no HKTs :) Your F# code will likely be very robust, maintainable and of high quality. It is a fantastic tool, especially combined with the REPL (when it works). It's far-and-away the most independent language/community in the .net world, as it was open-sourced a year before the rest of .net. The tooling is good, but you will experience some jank. The .net ecosystem somewhat behind, but dotnet core is formidable now, and positions .net well for future growth. And yes, you *will* have to teach some people F#, and you *will* have to support and engage in the community, which is something you'll likely enjoy anyway.
&gt;you may have to settle for whatever Microsoft's pushing or invest time in building/integrating technologies that are already available to JVM/Go/Python/JS users. Could you elaborate? I assume you mean the lack of native libraries. Of course, F# seems to have access to C# libraries, but I'm not familiar with the user experience there.
Thanks for your comparison yesterday. Paul Graham said something similar about Python programmers before the language got real popular -- I guess my issue's whether F#'s design advantages outweigh the disadvantages of its small community, which drags on all sorts of things, given pleasant-enough alternatives.
I'm referring to projects like Apache Spark. It's a popular JVM technology with .NET bindings but no .NET core support as of yet. Support for Kafka is OK, but there's only one serious library out there. Same with Redis. On the AI front, you have a TesorFlow library, but there's no equivalent of Keras (yet at least. Things are in the works). Microsoft has just released its own ML.net library for other kinds of machine learning applications. There's also the CNTK deep learning library that's supposedly pretty good. The F# interop with C# is pretty good, so you'll have access to pretty much the entirety of the .NET ecosystem, although you may prefer to write some more idiomatic F# wrapper libraries around this. The F# community itself is small, but I wouldn't be too worried about it. The quality of projects written entirely in/for F# is typically very high. As I mentioned, the main factor that has stunted growth is the overhaul of the .net ecosystem itself. I expect the community will pick up steam again once all the major projects have finished porting to .NET standard. So while the F# community is small, it's also supplemented by the larger .NET ecosystem. The F# community's contributions only improve on the libraries/frameworks that are already available. For example, the AWS SDK for .net is fully-featured, mature, and very usable from F#. There are, however, projects out there that provide more F#-friendly facade. Another example is ASP.NET. It's totally usable from F# out-of-the box, however, there are libraries/frameworks like Giraffe and Saturn that provide superior programming models. Final example: paket. You can use the nuget client that dotnet provides in-the-box, but paket is in many ways a superior package manager. The ecosystem aside, the mission-critical core business logic you end up writing yourself in F# will most likely be rock-solid and dependency-free. You won't have worry as much about simple logic-errors or bugs as you would if it were written C#, Java, JS and probably GO (I say probably because I can't speak from personal experience because I've never used Go in production.) I'm not exaggerating when I say that the code almost bug-free. F#'s type system is just a superior way of modeling your business domain, and it will help you move fast. It's truly a wonderful feeling to have so much confidence in the code you put into production. 
I’ll go ahead and say it - your reasoning is a self-fulfilling cycle of the so-called “slowly growing community and immature tooling.” If you like F#, you should use it. Help increase adoption. Show the people you hire why you like it. Frankly, the library and community situation for F# is perfectly fine, since you can interop with C and C# with literally 0 difficulty. If you want to use F# as a human-readable glue for illegible C-style libraries, it will excel. If you want to write your own libraries in F#, they will be a fraction of the size and easier to maintain. 
Thanks for your time, this really helps. A basic clarification, but if F# smoothly interops with C#, do the project/binding issues you mention come from inevitable F/C# differences or more general .NET compatibility?
Yeah, I'll admit my sentiment reinforces itself, but it gets at whether I should prefer an alternative for productivity. Tooling still seems [mixed](https://www.reddit.com/r/fsharp/comments/91gg6j/is_microsoft_serious_about_f/), and I want to know where projects, like those u/ivquatch mentioned, stand. 
f# is perfectly comfortable when doing oop, in my opinion. it doesn't feel weird, and f#'s oop is very clean. i have mainly used f# at work for instrument control. many manufacturers provide .net APIs, but these are of course oop-based and intended for c# and visual basic. the .net assemblies provided are also sometimes just wrappers for a c/c++ dll. so there is often heavy use of oop and imperative things like passing around references to data. i have found it easy to wrap these APIs with f# code that is more functional, i.e., functions take in values and return values with no reference types visible. f# is able to do this easily. i then wrap these functions with a simple class to make things more .net friendly so that i can export an assembly to use elsewhere outside of f#.
The bindings are almost always a matter of convenience. For example, C# tends to use a more class-based "fluent" style: new [] { -1, 0, 1, 2, 3 } .Where(i =&gt; i &gt;=0 ) .Select(i =&gt; i * i) .Sum(); Where as in F#, it's more idiomatic to use functions and modules. Eg) [-1..3] |&gt; Seq.filter (fun i -&gt; i &gt;= 0) |&gt; Seq.map (fun i -&gt; i * i) |&gt; Seq.sum It is possible, however, to use these C# extension methods directly in F#: [-1..3].Where(fun -&gt; i &gt;=).Select(fun i -&gt; i * i).Sum() Another example might be the `Int32.TryParse()` method. The following is common in C#: Console.WriteLine("Enter an integer") var input = Console.ReadLine(); int? result = null; Int32.TryParse(input, out result)) { return result + 1; } return result; In F#, you'd try to avoid the imperative assignment of `result` by writing a more idiomatic wrapper around `Int32.TryParse` that would look like this: module Int32 = let inline tryParse input = match Int32.TryParse(input) with | (true, result) -&gt; Some result | (false, _) -&gt; None And then you'd use this the wrapper like so: printfn "Enter an integer" Console.ReadLine() |&gt; Int32.tryParse |&gt; Option.map (fun result -&gt; result + 1) The C# and F# versions are functionally equivalent (albeit C# returns a `Nullable&lt;int&gt;` whereas F# returns an `Option&lt;int&gt;`). You could compile the F# version in a separate dll library and use it from C# and vice versa because the underlying CIL code the C#/F# compilers generate is generally compatible. There are rare circumstances where a C# library uses language features that make the code impossible (or extremely inconvenient) to consume from F#. I did encounter such a situation once, but I worked around it by writing a wrapper library in C# that exposed an API that was easier to consume from F#. So, F# and C# are largely compatible because they both compile down to roughly equivalent CIL. I'm pretty confident that you'll never be stuck with a C# library that you can't use in F#. If you're interested in a real-world example of one of these F# wrapper libraries, have a quick look at `Akkling`, which is an F# API for the more C#-oriented Akka.NET project. [You can see here](https://github.com/Horusiath/Akkling/blob/master/src/Akkling.Streams/Source.fs) that most of the code is simple boilerplate with some extra F#-only goodies like the `graph` computation expression that allows you to write stream graphs like this: let pickMaxOf3 = Graph.create &lt;| fun b -&gt; graph b { let! zip1 = ZipWith.create max&lt;int&gt; let! zip2 = ZipWith.create max&lt;int&gt; b.From zip1.Out =&gt;&gt; zip2.In0 |&gt; ignore return UniformFanInShape(zip2.Out, zip1.In0, zip1.In1, zip2.In1) } 
Honestly, that’s really going to be the scenario for every language. And for every negative perspective, there is an equally positive one, especially [this one](https://visualstudiomagazine.com/articles/2018/05/09/fsharp-improvements.aspx?m=1). With .NET Core and VS2019 previews already here, I think you’re going to see attitudes shifting soon enough. And really, if you need functional paradigms, then you should use F#.
Consider your architecture. Are there some areas that would benefit more than others from F#? If it's a webapp with a RESTful backend then could you write both in F# initially, but migrate the frontend to vanilla javascript if you hit too many bumps (or if you decide to outsource)? Are there any other areas that can be modularized? Personally I often find myself writing in a functional language for a first pass (which is great as if forces me to understand the problem), and then re-implementing in something more boring when reality hits and I have to work with other people. But I've never been a founder in a startup.
Thanks for reading! Very uncommercial of me I know, but I don't know how the Safari model works. More broadly speaking, with a publisher like Apress, the author gets a small advance on delivery of the text. Then the publisher records electronic and physical sales, and the author's cut of those sales. Once the author cut passes the advance the author starts getting income. With a very specialised book like this, one is pleasantly surprised if it covers its advance. ;-)
I wouldn't say that my book is necessarily the best on 'how to start a project', as it talks mostly about syntax and style, so kind of below the 'project' level. Plus that aspect is rather fast moving: gone are the days when your choices were just 'New command line project' or 'New library' in Visual Studio. That said, I do create projects for a couple of the chapters, and the source for these is provided in the sample code. So you could use my book as a launching point if you were adventurous!
I think this is very interesting, and I'm glad you liked the choice of title. I was talking with a fellow F# developer who is stuck in the bowels of a large financial organisation, and he said to me "you are literally only the other developer I know who cares about style". So it's very good to know you are out there too!
Thanks for reading! Very uncommercial of me I know, but I don't know how the Safari model works. More broadly speaking, with a publisher like Apress, the author gets a small advance on delivery of the text. Then the publisher records electronic and physical sales, and the author's cut of those sales. Once the author cut passes the advance the author starts getting income. With a very specialised book like this, one is pleasantly surprised if it covers its advance. ;-) 
I think this is very interesting, and I'm glad you liked the choice of title. I was talking with a fellow F# developer who is stuck in the bowels of a large financial organisation, and he said to me "you are literally only the other developer I know who cares about style". So it's very good to know you are out there too!
Using C# libraries is usually fine. A lot of popular ones even have F# wrappers already. There are occasional pain points, like implicit conversion operators for instance. There is an easy workaround but you have to know about it. Reliance on MS priorities is a fair concern I think. They aren't treating F# at even 1/2 the priority of C#. There is decent open source support with things like Ionide and Paket. But Go has a mostly better story here. Go didn't have a package manager last I checked, though I know they are working on it now. What sort of product are you making? I might make my choice based on the relative importance of metaprogramming, latency, native binaries, quick compile times, and compile time safety. Like if I was making client facing applications where safety is less important, Go's native binaries and low latency GC might make for a better product and easier distribution. If I was working on a server side product where safety/correctness is very important the F# language might better serve me there. 
It hasn’t been mentioned yet, but jet.com went from startup to billion-dollar acquisition, so I’d say F# (and great execution, great business model, hard work, good people, etc.) certainly are viable for a startup. Though I would argue choice of programming language is only a small part of startup success.
If I were to start my own company today, I'd most likely do it in Go because: \- Decent talent pool \- Not a big leap for people experienced in languages like Python, Ruby, and JS \- Great standard library as well as third-party \- Good documentation \- Easy to get stuff done quickly (which I think is the most crucial part for a startup) &amp;#x200B; And I say all this even though I quite like F#
\&gt; You won't find many people on the market who know F#, but you probably won't be inundated with resumes from *bad F# programmers* either the way you would be with Java, C#, and likely Go. &amp;#x200B; This makes no sense to me. The only reason you are less like to "be inundated with resumes from bad F# programmers" is because the pool of people interested in it is that small.
&gt; The only reason you are less like to "be inundated with resumes from bad F# programmers" is because the pool of people *interested* in it is that small. Yes. You'll be starting with a smaller number of qualified leads. 
Please format your code, it is impossible to read without formatting.
But still smaller from an absolute size perspective, which was my original point: it will be easier to find and hire great C# programmers than great F# programmers because the C# labor market is way, way bigger. I wouldn't start a business where my core was in F#, and I find F# to be an absolute joy to program in. Personal projects and hobby projects? Sure. A business that has aspirations of scale? No way.
If you pay enough, look for more than just F# devs, and filter candidates well, you’ll get a good developer who will be productive no matter the language. Go or F# won’t have much bearing on hiring in that regard. All companies at all stages using any technology struggle with hiring.
Of course. Is this better?
Assuming the product is non-trivial, new developers will already have to learn the domain. Adding the ins and outs of a new programming language -- especially an ML language for someone not familiar with them -- makes learning the business' special sauces more difficult because they're trying to go up multiple learning curves simultaneously. If you have lots of revenue coming in the door with a product that's selling, with plenty of money in the bank? Sure. You can afford to stack learning curves a bit, because you have some breathing room. Without these preconditions? You're taking a huge, huge risk.
Of course. Is this better? &amp;#x200B; &amp;#x200B;
Of course. Is this better? [https://imgur.com/kbOZAbo](https://imgur.com/kbOZAbo) [https://imgur.com/CwyMOdt](https://imgur.com/CwyMOdt) [https://imgur.com/FbTesGa](https://imgur.com/FbTesGa) &amp;#x200B; &amp;#x200B;
I see -- I'm thinking of a consumer mobile/web app, so sounds like I should prioritize speed over safety? I assume you mean stuff like SaaS or mission-critical software would use F#'s correctness better.
Could you elaborate on Go's corner cases? Obviously F#'s type safety's hard to beat.
&gt; it will be easier to find and hire great C# programmers than great F# programmers because the C# labor market is way, way bigger. So why not hire great C# programmers and teach them F#? You also have to admit, many of the great C# programmers already work for large companies. You'd be extremely lucky to hire a "great" one. The prospect of working with a language like F# might actually lure them away. And finally, if you start with C#, you're going to end up with a C# code base. So while you may be able to hire average C# devs more quickly, you'll have to account for the challenge of scaling the code base with the team. I've worked with large and very talented C# teams whose productivity has stagnated as a result of an unwieldy codebase. And this happened despite them having made "boring" technology choices. I know this is a wild claim, but the large F# code bases I've worked on haven't succumbed to this fate (as quickly at least). For starters they're usually not as large. Secondly, they have far fewer dependency cycles. Thirdly, the type system gives you much more confidence when you do need to refactor. &gt; My preference when it comes to [startup] business is to use proven, boring technologies and save the risk-taking for higher-leverage activities. There's definitely merit to this viewpoint. My view is that F# is "boring" in this sense. It's battle-tested as far as I'm concerned. C# may be more boring, but the Microsoft stack isn't. Yes, their frameworks/libraries are backed by a large company, but there's also a history of churn. This is just my opinion, but I find that in the C# ecosystem, rather than making the "boring" choice, you're goaded into making the "Microsoft" choice.
Just a small tip. On Reddit with 4 space indent you get code formatting: Type Node = |File of string*int //File name and size |Folder of string*(node list) //Folder name and contents Example: let helo = File ("Helo.txt", 123) let helo2 = File ("Helo2.txt", 456) let documents = Folder ("Documents", [helo; helo2]) 
The cost of a good dev learning a new language or platform is dwarfed by the cost of a bad one who is fairly familiar with the tech. If a business cannot afford a good dev they are already lowering your own standards, and I personally find it unlikely that a startup will be successful if they cannot pay well. Choice of language probably doesn’t factor much into it.
Your cousin shouldn’t directly seek answers to his homework. Tell him to give it a try himself, use google to research the syntax and language, then ask any specific questions on here. A good programmer is a good googler.
IMO slowness is often because of choosing incorrect algorithms and data structires rather than inherent language design. Ofc solutions written in Go will be able able to go faster in the absolute sense, but that does not mean f# is not fast enough for the job. To me, unless you need realtime calculations, going for a language that allows for easy refactoring and switching algorhithms with confidence is a no brainer. Personally I have zero experience working with go, but I'd be surprised if it would do better on this aspect than f#. 
We are in the same boat, F# is beautiful and seems like the best option out there for safety and productivity (with acceptable performance). The tooling for F# may not be as good as C#, but my experiemce with IntelliJ Rider has been good and it shouldn't be a huge issue. Sadly, the support for pure F# bindings may be an issue and seems too small and too much of a risk unless we are going to just interface everything with C#, which undermines some of the safety a productivity gains. Go is likely a more sensible option unless you need very few external libraries, I would love to be wrong about this because it would be great to use F#.
I find this claim offensive. I really good programmer can live entirely without googling. Just go straight to Stackoverflow.
Paul Graham would like a word with you. http://www.paulgraham.com/avg.html
As an architect who took a small company from no cloud expertise to a highly productive team that has delivered multiple projects and ultimately a SaaS offering in F#: ### others have pointed out Haskell experience, it's similar in F# - if you want pure F# experience, you will end up owning the stack. It's neither good nor bad, some great things came out that way. - expertise is not an issue, the people you want to hire will have natural affinity to learn already. - hire remote consultants to get you started if you want to, you absolutely can get top talent that way. ### You can start writing F# as if it were C# - the libs are usable and most C# samples are trivially portable. - some idioms are different, but you can figure it out as you go. ### Code is not an asset - F# lets you express abstractions succinctly, which is a key to keeping the code bloat in check. - you can be productive by focusing on the problem instead of plumbing. - you can stay with small team longer and avoid having to scale your organization. - maintaining quality is easier. ### Tooling and ecosystem - .NET and by extension F# is still recovering from NetCore debacle, but things are looking better than a year ago. - between Fable, Xamarin and NetCore you can implement every tier in F#, which means less expertise silos. - AFAIK Go still doesn't have a decent package manager. ### Beyond the basics - metaprogramming is hard in F# and AFAIK Go has none, if that's important look elsewhere. - evolution is sloooooow in F# and some see it as a good thing. 
&gt; Sadly, the support for pure F# bindings may be an issue and seems too small and too much of a risk unless we are going to just interface everything with C#, which undermines some of the safety and productivity gains. Could you expand on this? You don't need to use C# to work with a .NET library, even if the .NET library doesn't have idiomatic F# interaction patterns.
Startups are not about language/stack choices. That's maybe 1% of the equation -- although it's probably the easiest to chat about and tweak. As long as your tools aren't getting in the way, they're working. (Which means the more you talk about them, the less you're actually building out your startup) You need to be joined-at-the-hip to whomever you're trying to help. It's that people interaction that's the critical factor -- and one that most coders don't want to do, sadly. If you're making new stuff, you should be familiar and close enough to your potential users that you can demo from the command line/repl. If not, you're not close enough. After that, add UI. (Different rules if you're just making existing stuff more sexy. Then you've got a UX problem)
does this book cover guidelines for how to best manage and organize namespaces and modules in f# or how to best setup scripts to auto-load and test source files? these are two "industrial" use cases i haven't seen explained well at all in the f# community, where it seems everyone tends to have their own style. lots of information is buried in forum posts. thanks for the book. i will definitely pick it up.
Have you ever taught a class? Or worked in s professional setting? Of course he should ask for help. I would be pissed if someone on my team wanted several days because he was too proud to ask for help. That doesn't excuse someone from trying to use the documentation first. But a good student, or employee, uses all the resources that are available.
Ignore the assholes, asking for help was the correct thing to do and is in no way shameful.
F#'s type safety is sadly exaggerated. It's no better any other statically typed language on the .net framework. And it had weird cases like Option&lt;string &gt; containing nulls. 
The dude just copied and pasted his homework here. Simply answering his homework questions for him doesn’t seem like the right thing to do, but please be my guest. More specific questions eg “how does this operator work?” would, in my view, have him learn enough so he can try it himself. 
Calling me an asshole is a big conclusion from [my comment](https://www.reddit.com/r/fsharp/comments/a4nwjv/i_feel_kinda_ashamed_asking_but/ebgo5sz/). As I said, if you would like to directly answer his homework rather than guide him please go ahead. 
Maybe, but I'm not [entirely](https://stackoverflow.com/questions/947710/f-in-real-terms-what-is-the-difference-between-a-string-and-a-string-optio) [convinced](https://apisuckage.wordpress.com/2009/06/04/f-static-typing-done-horribly-wrong/).
Sure, but scaling concerns about F#'s [latency](https://www.reddit.com/r/fsharp/comments/a3um5c/comparing_go_and_f/ebac5z0/) and [compile times](https://www.reddit.com/r/fsharp/comments/a3um5c/comparing_go_and_f/eba6wae/) seem warranted.
That depends on the situation. Most software is not so time critical as a lot of developers seem to think. 
I didn't specifically call you an asshole, I was talking about people who heap scorn on those asking for help in general. But if you choose to self identify as one of them then I see no reason to contradict you. 
And I'm reminded why the F# community is less than a tenth the size of VB. 
I'm confused as you why you are citing examples of where F# could have been successful but failed. 
His project failed and had to be rewritten. The company was a wild success in the startup lottery, but that's not the same thing. 
For context.
Fair enough 
every time I click on the book to start the free trial, it just brings me to the home page.
Maybe quick check on the domain and range? If the input/output is equivalent, then the functions much be equivalent? Well at least i tried.
Do you mean this page here: https://www.safaribooksonline.com/register/? Can you just fill in that registration there, and when you're done navigate to the book?
I did Register but it just redirects home each time I click on the book afterwards unfortunately :(
Start with the first function. What I find helpful is to begin by writing out an empty stub with the types and a minimal implementation that simply satisfies the type checker. I'll get you started with the first function. (Hint: You'll want to use the rec keyword to define it as a recursive function.) Can you stub out the other functions? type Node = | File of string * int //File name and size | Folder of string * (Node list) //Folder name and contents let rec totalSize (node: Node) : int = match node with | File(filename, size) -&gt; 0 | Folder(folderName, contents) -&gt; 0 &amp;#x200B;
Hmmm... Maybe ignore any existing link you have to the book, and use Safaribooks's search function to do a fresh search for the book?
Tweet it at Don Syme. Or head over to office hours and ask him. &amp;#x200B; [https://twitter.com/dsyme/status/1067061876025159680](https://twitter.com/dsyme/status/1067061876025159680) &amp;#x200B; &amp;#x200B;
On the other hand, most software's not as fast as it should be -- when would you start to worry about latency and compile times?
Compile times when developers start complaining and there's a chance they start leaving the company or when time to release for bug fixes is too long and impacts customers. Latency when effectiveness of end users is impacted or their overall appreciation of the product starts dropping due to the latency. 
There's a bit about modules, i.e. some ideas for how to organize business types and related functions into modules. Nothing much on namespaces though. Also nothing on the script aspects you mention unfortunately.
the laziness obfuscates the behavior a bit, but the key recursive bit are when (++) returns the head if the index is zero or the tail of the list otherwise, with indexes decremented: let (++) head lazytail = create( function | 0 -&gt; head | n -&gt; lazytail.Value.[n - 1]) This means, for example, a `BitSequence.find (f.[2] == One)`, 
The laziness obfuscates the behavior a bit, but the key recursive bit is when (++) returns the head if the index is zero or the tail of the list otherwise, with indexes decremented: let (++) head lazytail = create( function | 0 -&gt; head | n -&gt; lazytail.Value.[n - 1]) This means, for example, a predicate `seq -&gt; seq.[2] = Zero` gets reduced to `seq -&gt; seq.[1] = Zero` to `seq.[0] = Zero`, and at that point the value of `head` is returned instead of further iteration. Now, in `solve`, we lazily construct all possible values of BitSequence, and run the predicate. When the maximal index `n` in the predicate is reduced to zero, the recursion ends, in `2 ** n` steps after we've generated all possible prefixes up to that index. You can check this for yourself by adding a counter: &gt; let mutable counter = 0 &gt; BitSequence.find (fun b -&gt; counter &lt;- counter + 1; b.[10] = One) val mutable counter : int = 1024 &gt; let mutable counter = 0 &gt; BitSequence.find (fun b -&gt; counter &lt;- counter + 1; b.[6] = One) val mutable counter : int = 64 
Sounds neat. I assume that, in the SAFE stack, this allows for an alternative option for Suave and Fable? 
It replaces html and JavaScript.
You need a match l1 = |x::y::xs do stuff ecc.
i think that what is going on here is that the c# syntax you've shown is how to set properties or fields of a class at the time of construction. in f#, what you have shown is equivalent syntax for doing so. https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/members/constructors#assigning-values-to-properties-at-initialization i am not for sure and can't test this at the moment, but it seems possible to me that f#'s intellisense may not support this. of course, looking at the class' documentation tells you what properties it has. you could also use dot notation on a class of that type to see the available properties that could be set.
It should be possible with a fold 