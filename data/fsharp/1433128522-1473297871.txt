I always tell people they should use a functional programming language when they first start teaching children how to program in schools. And if somebody actually listens, I suggest F# to them. The reason I suggest a functional language is because it's much closer to the algebra children are being thought at school. One our we're stuffing all the algebra in their heads and the next hour we tell them that **x = x + 1** makes perfect sense... There will always be a mismatch between algebra and imperative languages. With functional languages kids can apply what they learned in algebra directly, it just makes more sense. As for why F#? Well, .NET/Mono is everywhere and it's not going away soon. 
Is it just me, or does anyone else find the prescience of grey-beards in the community reassuring?
Why wouldn't it work using the same approach as here (from 2011)? https://msdn.microsoft.com/en-us/magazine/hh394149.aspx 
The functional style is indeed more natural to the uninitiated. The notion of an object (state + behavior) more of an "advanced" concept in that it requires prerequisite knowledge to understand when/where the abstraction is appropriate to use.
I too am interested in using FsXaml with Universal apps. After using the XAML type provider with WPF, I wouldn't ever want to go back to using C#-backed XAML. I opened an [issue](https://github.com/fsprojects/FsXaml/issues/23), but it looks like the maintainer doesn't have a lot of time to devote to it. 
Tryfsharp is pretty good as well
Real world functional programming is a great book for this http://www.amazon.com/Real-World-Functional-Programming-With-Examples/dp/1933988924
Thanks, I appreciate it. 
You sure? I think I used chrome...
It depends on how you prefer to learn. As suggested, there are the sites where you start trying out code. If you prefer books, then Beginning F#, Expert F# 3.0, F# for C# Developers, Testing with F# are good book type resources too
Chrome disabled plugins in a recent release.
Fsharp koans is how I started. https://github.com/ChrisMarinos/FSharpKoans
https://jabbr.net/#/rooms/fsharp
It is available on MSDN. https://msdn.microsoft.com/en-us/library/vstudio/hh314518%28v=vs.100%29.aspx 
I've been looking at FSharp.ViewModule because I've seen a few blog posts that make it look pretty interesting, but the project itself doesn't have much in the way of documentation and I'm pretty new with F# so I don't really know what I would be getting into. Can it be used on Xamarin as well? Losing F# for the views is a big bummer though...if C# had ADTs and pattern matching, I could get 90% of the value I get from F# views, but that isn't happening any time soon. 
I just realized you are probably Reed Copsey. Sorry if I'm going overboard on the requests for info, but I just have one more question. Does the Xamarin stuff still work on iOS and Android when you do this: do this.DependencyTracker.AddPropertyDependencies(&lt;@ this.Field1 @&gt;, [ &lt;@@ this.Field2 @@&gt; ; &lt;@@ this.Field3 @@&gt; ]) I was under the impression that the untyped quotations relied on runtime code generation which isn't allowed for iOS or Android platforms. 
I think there is a project that compiles F# to JS from F#. Thats the only thing I can think of. Its on github.
Isn't the F# compiler itself written in F#? https://github.com/fsharp/fsharp
Recursion!
Websharper and Funscript both do that, IIRC.
Technically, this is bootstrapping rather than recursion, but yes. 
Would you recommend expert f#? Did you learn anything useful? I'm considering to buy it, but I already know f# and have written a few projects in it, so I'm not looking for completely introductory books 
I'm a strong proponent of F#, but I'm not sure it would be my first choice for implementing a compiler. Ocaml has righteously been called "a DSL for writing compilers", maybe you should look into it? Haskell is another good option.
boostrapping \subseteq recursion
If wanna write about this I will appreciate ;) https://stackoverflow.com/questions/30584942/how-implement-sum-product-types-for-a-language-made-in-f
We could also add a subreddit wiki for a more exhaustive list of resources (books, blogs, more OSS projects, specific videos, etc.) with detailed descriptions and maybe a few guides/tutorials 
I wrote an optimizing Brainfuck compiler for the CLR in F# the other day. [Check it out.](https://github.com/paavohuhtala/bfcfs)
Aml, "A Modular Language", was written entirely in F#. It's here - https://github.com/bryanedds/FPWorks/tree/master/Aml It's a language built entirely for building external DSLs. You extend the language's syntax and semantics by building language plug-ins in F#. The standard library is here - https://github.com/bryanedds/FPWorks/tree/master/Aml/Aml/Aml/Stdlib
Great to know...
Meetup: http://www.meetup.com/nyc-fsharp/events/223024610/ **Synopsis:** Suave is a lightweight, non-blocking web server. The non-blocking I/O model is efficient and suitable for building fast, scalable network applications. In fact, Suave is written in a completely non-blocking fashion throughout. Suave runs on Linux, OS X and Windows flawlessly. 
Since Microsoft started the whole "go where our users are" discussion, I have to ask - what's the point of Channel9 when there's already YouTube?
I'm Linux/Mono user. I think these two are also needed [MSbuild Reference](https://msdn.microsoft.com/library/dd393574.aspx) Without IDE, I have to update msbuild files by hand. A reference to msbuild is a must. Some libraries like xamarin and monogame also needs customized msbuild files. [Yeoman F# generator](https://github.com/fsprojects/generator-fsharp) ProjectScaffold is too complex for one who don't use an IDE. *.sln and complicated build.fsx are redundant. Yeoman F# generator provides several simpler and useful project templates which are much easier to be understood.
I just started reading it, so no clear recommendation for the moment.
Well, that's unfortunate, however not unheard of: functional structural elements work best at small scale level.
That's a great write up. Tomas just did that presentation at the [NYC F# User Group](http://www.reddit.com/r/fsharp/comments/39cy29/web_with_f_from_scripts_to_azure_with_tomas/). Thanks for pointing out the book as well.
It really, really depends. My working theory is that functional elements work better in the data pipeline, while OOP/actor/reactive work better for state machines. Reading through the lines, I don't see a criticism of F#, I see a criticism of the design pattern literature in functional programming. I've had few of the issues mentioned in a large real-world product, because there was a strong oral tradition on the team of which features to use where.
&gt; Type providers &gt; Initialy we started to use them intensively, but after some time we removed all usages from our codebase. First problem is scripts. When you created a script with a type provider and copies it to some server, first of all it shows you "The .NET SDK 4.0 or 4.5 tools could not be found". Also it increases a number of dependencies and is not very easy even if you are using Chocolately or so on. Type safety of type providers sometimes become a hell when for example you are working with json type provider and it forces you to create a lot of boilerplate code. I've found type providers useful for exploring SQL databases but I would never use them in production code, just disposable scripts. &gt; For example to process json value which can be null, skipped, empty or has value. Sounds like you want schemas. &gt; Also json type provider forces you to use F# Data: JSON Parse module but what if I prefer to use an other json parser? And why does it have its own hand-rolled JSON parser anyway rather than using, say, JSON.NET? &gt; Db type providers seems to be similar but all have different possibilities and problems and differnt api. It is easier to use EF with blackjack and migrations. Provaiders seems to be perfect fit for external uncontrolled data sources, but unfortunately with some drawbacks. Try to use only when you really need them. Or when you don't plan to keep your code. &gt; Tuples and other data structures with unnamed fields. &gt; Initially we started to use them actively. For easier reading we used type abbreviations for every position and different type abbreviations for diferent composite types. But type abbreviation are erased at compile time and this way is too error prone. Yes, of course. That's a silly thing to do. Read any decent tutorial book on F# and it won't do that. &gt; For example when you inserts or removes a field in tuple or union type you are forced to fix a lot of lines where you are trying to construct or deconstruct values. Also it is very easy to do a mistake and fail at runtime when your json serializer can't (de)serialize message and throws an exception. You're doing it wrong. &gt; Inlining &gt; Seems to be cool but can throw exception at runtime when used form csharp. Use only internally inside Fsharp code and mainly for performance issues. Yes, `inline` is very useful. &gt; Pattern matching and union types &gt; Incorrectly used it moves your code and brain into the "switch case hell" which you could remember from C like languages. Currently we partially rewrites code which uses union types to simple OOP classes and interfaces. You'll lose pattern matching, exhaustiveness, redundancy checking and the ability to add functions over that type. &gt; Try to avoid union types creation, Again, you're doing it wrong. &gt; but if you really need them for tasks like AST representation then you need to be sure that your type has const number of representations. What do you mean by "const number of representations"? &gt; Also use only named fields for union types. Interesting. In 8 years of professional F# programming I have never used that (new) feature. &gt; And before writing, just think about visitor pattern again :). NEVER USE union types in your external api like rest/json. I did it once and never do that again. You don't want to expose union types to C# code but there's nothing wrong with exposing union types to other F# code. &gt; Monads and computation expressions &gt; Monads is very hard to understand for novice devs and they do not compose. So try to avoid creation of your own monads and use predefined ones or from libs. Develop your own only when you really need it. This is setting alarm bells ringing for me. You seem to be struggling with basic F# programming (e.g. pattern matching). Trying to write your own monads is trying to run before you can walk. Take it easy. Keep it simple. &gt; Collections &gt; Inconsistent api for different collections (fixed in F# 4) causes dramatic time loss in developing. Elaborate? &gt; Missing of some really useful methods like OrderByDescending (fixed in f# 4) can show you a lot of interesting stuff during debugging on production server :). Use `sortBy (~)` or `sortWith (fun x y -&gt; -compare x y)`. &gt; No built in generic performant solution for collections. What does that mean? &gt; Fsharp idiomatic libs &gt; Unfortunately after some use we decided to switch to better tested production ready libs. They are not so idiomatic, but easier to work form both fsharp and csharp. What libs are you referring to? &gt; OOP support &gt; Currently we move more and more code to OOP style from FP style. OOP feels just better and easier for maintain when your project starts growing. Usual fp project way: functions with positioned args and pattern matching -&gt; functions with args in one record -&gt; record with closures -&gt;&gt; old school OOP. Ok. You're doing something seriously wrong. 
Fantastic. 
Not OP, but... &gt;&gt; Collections Inconsistent api for different collections (fixed in F# 4) causes dramatic time loss in developing. &gt;Elaborate? I'm pretty sure OP is referring to [this](http://blogs.msdn.com/cfs-filesystemfile.ashx/__key/communityserver-blogs-components-weblogfiles/00-00-01-39-71-metablogapi/3125.collectionAPI_5F00_254EA354.png), blue being existing functions, green being new additions to the API and white being intentional gaps (L - list, A - array, S - seq). I admit, it's nice to see it being standardized, but it's more of a minor annoyance (and sometimes minor performance penalty) than 'dramatic loss', IMO. Other than that, I agree with everything else. I have pretty much the same opinion about SQL type providers, but I have to admit I've been lately looking with interest at [FSharp.Data.SqlClient](http://fsprojects.github.io/FSharp.Data.SqlClient/), although I'm yet to test it on a 'live' app. I'm not really anxious about writing extensive SQL queries, but I really dislike the fact that you either have to suffer extremely weak typing with a lot of boilerplate or use full-blown LINQ-compatible ORM. Usually, in C#, I use both 'full' ORM and a micro-ORM when appropriate (often within one project), but I'll keep my eye on `FSharp.Data.SqlClient`.
&gt; I'm pretty sure OP is referring to this, blue being existing functions, green being new additions to the API and white being intentional gaps (L - list, A - array, S - seq). I admit, it's nice to see it being standardized, but it's more of a minor annoyance (and sometimes minor performance penalty) than 'dramatic loss', IMO. I'm not a big fan of that idea. For every user who benefits from the improved commonality there is another who is confused by it. For example, `List.singleton x = [x]` is pointless, `Seq.foldBack` is silly and turning O(log n) `Set.contains` into O(n) `Array.contains`, `List.contains` and `Seq.contains` is going to confuse people. I want them to add functions that actually leverage the specific collection in question. I'd like to be able to split sets and maps in order to divide-and-conquer for parallel programming but that has been abstracted away. I'd like asymmetric union and merge of two `Map` collections adding the values from colliding key-value pairs but what I need to do that efficiently has been abstracted away. I'd like a heap or priority queue in Core. 
&gt; I'm not a big fan of that idea. For every user who benefits from the improved commonality there is another who is confused by it. For example, List.singleton x = [x] is pointless, Seq.foldBack is silly and turning O(log n) Set.contains into O(n) Array.contains, List.contains and Seq.contains is going to confuse people. I'm not sure about the confusion. I mean, it's possible, but people can be confused by *a lot* of things. At least in this case, the API is uniform, although you still have to know your data structures and algorithms to be able to reason about big-O. &gt; I want them to add functions that actually leverage the specific collection in question. I'd like to be able to split sets and maps in order to divide-and-conquer for parallel programming but that has been abstracted away. I'd like asymmetric union and merge of two Map collections adding the values from colliding key-value pairs but what I need to do that efficiently has been abstracted away. I'd like a heap or priority queue in Core. With this I agree completely. Having more 'advanced' collections out of the box, all properly tested and optimized by people smarter than me would *definitely* be an asset. For anyone else reading, here's an easy example: implementing A* search means you have to implement your own priority queue (via, for example, Fibonacci heap), which is not a trivial task.
https://github.com/yawaramin/FsBuild
Wow, that's screwed up. You might be right then. I'm very unhappy about this. RIP F#? :/
I'm wondering how hard it would be to integrate F# with Roslyn. The difference between C# and F# is only the front-end, it shouldn't be too hard.
The .NET Native compiler is tightly coupled with Roslyn. :/
I cannot see anybody switching to the JVM so they can use that.
Here's my take on this. I'm definitely one of the 'annoyingly vocal' community, but I'm going to be as constructive as I know how to be! **Type Providers** Missing dependencies - yes, this kind of thing is a bit of a bane when moving on from 'it works on my machine'. On the other hand you shouldn't necessarily expect to be able to copy scripts around the place and have their dependencies magically come with them. It is a bit more disappointing when you build and deploy something from -say - Visual Studio and have the dependencies not get correctly identified. That needs improving. In contrast to jdh30, we do have some type providers in live use (albiet for reporting) and in that case they were an utter godsend. I feel that type providers (as a concept and as implementations) have a bit more maturing to do. **Tuples and other data structures with unnamed fields** My advice on tuples is - keep them extremely local in scope. (I.e. in the context of one short function or one little pipeline of piped-together operators.) "Type abbreviations for every position" - I hadn't even thought of that but... yikes! Maybe records would be good fit here? "It is very easy to do a mistake and fail at runtime when your json serializer can't (deserialize)"... This makes me wonder what you would want to happen when a message comes in which isn't the shape you expect. Guess at the values? Default to nulls? My feeling is that F# isn't the problem here. **Inlining** I haven't encountered this runtime exception when called from C#. Note that an important use of inline within F# code is to allow operators to be inferred as polymorphic: http://stackoverflow.com/questions/3754862/use-of-inline-in-f **Pattern and union types** This is where I disagree with you most strongly. Rather than regarding the situation as 'switch case hell' you need to think clearly about what you want your code to do in every situation. If you find this hard to do in a particular situation, it probably means your overall design, or your understanding of the domain, needs examination. Generally people seem to agree with you on not exposing union types in APIs to be used from other languages. I haven't tried it. **Immutability** We agree! **Monads** Yeah, kind of agree. However it has been interesting for me on occasion to watch C#/OO devs painfully re-invent something like the maybe monad over a period of several days. **Equals, GetHashCode...** Agreed. **Collections** This has never really bothered me. Array.ofSeq and Seq.ofArray FTW! I strongly agree with jdh30 that it's important, once you get beyond the toddler stage, to understand what's really going on behind the scenes with arrays vs. C# lists vs. F# lists vs. sequences (etc.). Promotion alert: my PluralSight course on 'F# Functional Data Structures' goes into a certain amount of detail on this. It isn't an advanced course - just gives the basics on the differences between the built-in collections and some hints on performance. **Fsharp idiomatic libs** I agree that there can be a maturity issue here. **Type inference** "F# does not allow type constraints involving two different type parameters". I think I'm not understanding you here. This is fine: type MyType&lt;'TOne, 'TTwo&gt; ... So is type MyType&lt;'TOne, 'TTwo when 'TOne : equality and 'TTwo : null&gt; ... As I say I think I'm misunderstanding **OOP support** Sorry, I agree with jdh30 on this one. It feels like something is going wrong culturally. Edit - various typos. 
&gt; I'm not really anxious about writing extensive SQL queries, but I really dislike the fact that you either have to suffer extremely weak typing with a lot of boilerplate or use full-blown LINQ-compatible ORM. Usually, in C#, I use both 'full' ORM and a micro-ORM when appropriate (often within one project), but I'll keep my eye on FSharp.Data.SqlClient. Now I'm going a bit off-topic and also doing some shameless plugging...but I've had the same feeling for a long time concerning ORM's. There's no good "middle-ground", it's either the full entity framework/nhibernate route or writing sql in strings in the code (or stored procedures). So I started a project trying to provide a more "middle-ground" ORM (or a microORM++ might be a better description I guess). It's not production ready yet, but it's getting there. Feel free to have a look, any feedback helps :) https://github.com/wastaz/Hyperboliq 
Another thought - on this point: &gt; Monads ... do not compose. I'd be interested to know what OP means by this. In a sense monads are the essence of composition. Here's a great example of computation expressions (which overlap with monads) composing: http://www.m-brace.net/programming-model.html
I think the major failure of documentation in the F# community is when we have libraries that are obviously popular (lots of github stars, dependencies in example projects), but have literally nothing in the way of documentation. What it says is that in order to use F# *and its ecosystem*, you need to be enough of an expert to read the code. The ecosystem of F# is pretty awesome to read about, but then you try to get things to work on your own terms and it becomes roadblock after roadblock. Everybody is warm and welcoming but it still feels like a community of insiders. The basic essentials are the API docs: We need to know what your data types and interfaces are, and the common core functions that manipulate them. Most OO libraries are dumbed down enough that if you know the API, you know the library. That isn't always true with a lot of functional libraries. If you take an opinionated approach with a lot of magic, you really need to have a section of the docs dedicated to the core concepts. Show where you should keep state, show how information should branch or flow, show examples of how your functions compose, etc. For example, I know that Freya is an OWIN stack, and AFAICT OWIN itself is routing agnostic, so I would assume that Freya would be performing the routing. How does information flow in the routing? Maybe some examples of URLs in a basic API where you have a mix of information to be extracted from the path and/or parameters and how they are mapped to the underlying `Func&lt;IDictionary&lt;string, object&gt;, Task&gt;;` The `freya { }` computation expression looks like it performs a lot of magic behind the scenes. Can you give me an overview?
As I know you're interested: I actually talked to someone on the .NET Native Team. He confirmed that Windows 10 GA will _not_ support F# in .NET Native. It's on a list for a future release, but that could be whenever. He suggested I upvote https://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/7542181-add-f-support-for-net-native - as the votes for uservoices can affect priority. I suggest you do the same!
You could add Logary https://logary.github.io/ for F# logging
I believe F* (a higher order, effectful programming language like ML from MS Research) is written/bootstrapped in F# and OCaml.
F# would need to be integrated into the Roslyn pipeline - so not an entire new compiler, but a sizeable piece of work regardless.
Define syntax by types and composite semantics by functions(values as zero-order functions). In some aspects, functional programming languages looks like complier compilers.
There are UML compilers. :) https://en.wikipedia.org/wiki/Executable_UML 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Executable UML**](https://en.wikipedia.org/wiki/Executable%20UML): [](#sfw) --- &gt; &gt;__Executable UML__ (__xtUML__ or __xUML__) is both a software development method and a highly abstract software language. The language "combines a subset of the UML ([Unified Modeling Language](https://en.wikipedia.org/wiki/Unified_Modeling_Language)) graphical notation with executable semantics and timing rules." The Executable UML method is the successor to the [Shlaer–Mellor method](https://en.wikipedia.org/wiki/Shlaer%E2%80%93Mellor_method). &gt;Executable UML models "can be run, [tested](https://en.wikipedia.org/wiki/Software_testing), debugged, and measured for performance.", and can be [compiled](https://en.wikipedia.org/wiki/Compiler) into a less abstract [programming language](https://en.wikipedia.org/wiki/Programming_language) to target a specific [implementation](https://en.wikipedia.org/wiki/Implementation). Executable UML supports [model-driven architecture](https://en.wikipedia.org/wiki/Model-driven_architecture) (MDA) through specification of [platform-independent models](https://en.wikipedia.org/wiki/Platform-independent_model), and the [compilation](https://en.wikipedia.org/wiki/Compiler) of the [platform-independent models](https://en.wikipedia.org/wiki/Platform-independent_model) into [platform-specific models](https://en.wikipedia.org/wiki/Platform-specific_model). &gt; --- ^Relevant: [^Stephen ^J. ^Mellor](https://en.wikipedia.org/wiki/Stephen_J._Mellor) ^| [^Shlaer–Mellor ^method](https://en.wikipedia.org/wiki/Shlaer%E2%80%93Mellor_method) ^| [^Model-driven ^architecture](https://en.wikipedia.org/wiki/Model-driven_architecture) ^| [^Sally ^Shlaer](https://en.wikipedia.org/wiki/Sally_Shlaer) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cstpc33) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cstpc33)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](/r/autowikibot/wiki/index) ^| [^Mods](/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Call ^Me](/r/autowikibot/comments/1ux484/ask_wikibot/)
I would fork or download the source and include it as an extra project in your solution for now. Please note that the the documentation on the page is for version 1.5.1 but current master is for the 2.x release. I think this commit is the last one for 1.5.1, so you may want to fork, and roll back. https://github.com/relentless/Http.fs/commit/8763f3dbdbc2e78198a7e4de9b2f470ac2e2de69 I have been using http.fs and really enjoy it.
Can you comment on how good the course will be for non-Windows users? I run Linux at home and at my university, and although I have Mono and Emacs set up well enough to write, compile and run small programs for hackerrank.com, I wonder how well it will play in larger projects.
The thing that most intrigues me about F# or any functional language at this point is the idea that it can especially handle complex distributed networking and how that can be applied to multiplayer games. John Carmack recently tweeted about how a functional language could be the language of the metaverse. 
I'm a long time Arch Linux user myself, and only recently turned traitor to move to mac :) So this matters to me too. CROSS-PLATFORM: For those of you not using Vim or Emacs, Visual studio code (https://code.visualstudio.com/) will take you further than Monodevelop, and will feel a little more comfortable. It plays well with Git, Azure and other languages besides F#/C#. It will work identically across Mac, Linux, and Windows. @gnuvince Mono's fine to get started and will support fairly large projects. It will certainly take you past the point where you'd need to move your code onto dedicated servers anyway, in which case your desktop environment doesn't really matter anymore. We're going to have an emphasis on deploying online throughout the course (especially if we reach some of those stretch goals) and we'll show you how to manage that. I'd say if you've got Mono and Emacs working well together, you're pretty much sorted for a lot of tasks. 
You know, I have the feeling that we'll look back on this period in 40 years and we'll think it very weird that we used OO languages in the first place. The benefits of functional languages for the workloads that we're facing in the next decade seems pretty clear, whether we're building the metaverse or the next enterprise data warehouse :)
based /u/jdh30
You are not stupid.. well maybe you are, but not because of this post. Curl wouldnt work without something like mingw/cygwin installed. I didnt see the author mention it anywhere.
I hoped that may be I have old powershell or something, but I ended up with installing mingw and it works. :-) I have another problem when I use FSharp.Data.TypeProviders It does not compile. I did not realize why. Compiler error was that FSharp.Data.TypeProviders.dll could not be found but it was in packages directory. :-(
F# types provides what's known as 'structural' equality, rather than 'referential' equality. In C#, let's say I make a Person class with 2 properties (name and DOB). If I try to create 2 Person records of "John Smith" "05/24/1992", identical in data, then check them for equality, C# will say that they are NOT equal since they are NOT the same exact object (same pointer or whatever) If I make an equivalent type in F#, structural equality is assumed, and these records would be considered equal since their internal data is equivalent, structurally. This statement is true for records, classes, tuples, lists, etc.\ Keep in mind that if you do want to create an F# type with *referential* equality, it can be done with just 1 attribute! [&lt;ReferenceEquality&gt;] or something like that.
This is one of the things I love about functional programming languages or programming javascript using plain objects instead of constructors/classes. If something needs reference equality it needs a UUID not a hidden pointer.
...That's not really an answer. C# records can automatically be compared too although I guess not in the same way. 
C# does not has records. C# has structs, which are different. If you look at the C# version of the F# code, you see that the record is actually a class. Classes are reference types, structs are value types.
They can but most often it doesn't matter. In the cases where it would be do expensive you can either write your own equality function, use reference equality (as above) or override it the old fashioned way. You also get free hashing this way in F#, which is awesome for Dictionaries and HashSets.
Cool. Thanks!
Symbols types in Lisp provide referential equality. 
I'll be honest I didn't read your question thoroughly but from what I understand you are looking to create an IEnumerable of primes. Sequences are IEnumerables so you could do that with something like this: let primes start = let calc = new PrimeCalculator() seq {for n in start .. 2 .. System.Int32.MaxValue do if calc.IsPrime(n) then yield n} Now when ever you call the primes function with a starting value you get an IEnum that goes from that value to the int max (you could switch it out for BigInt if you need true infinite).
I really need to put in some time and learn F#. Been interested for a long time.
I'm just happy that constructors are now first-class functions, I'll be able to clean up a lot of small crufty areas of code that previously had to work around this limitation.
This is a pretty slick release - lots of nice integration cleanups that will have a lot of impact on the ecosystem.
&gt; I’m not sure yet why they didn’t just swallow a keyword and always use “this”, and it still strikes me as a pretty weird syntax. One possible reason is that there is the object literal syntax. For example if you have an interface like this: type IFoo = interface abstract X : unit -&gt; int abstract SomeMethod : int -&gt; string end Then you can directly create an object of type `IFoo`, without needing to create a type that implements it, like this: let myFoo = { new IFoo with member this.X() = 42 member this.SomeMethod(x) = string x } But then, if you use this syntax inside a method, you have two `this`s in scope, so you need a way to distinguish them. Hence the `this.` syntax. type SomeClass() = member sc.X() = 27 member sc.GetAFoo() = { new IFoo with member foo.X() = 42 member foo.SomeMethod() = string (foo.X() + sc.X()) // I can distinguish them! } 
Yes, that's never going to change. The difficulty to introduce cyclical dependencies is not a bug but a feature :)
Don Syme was experimenting with HK types in CoreCLR some time ago, but it seems he has since deleted his fork. It's quite unlikely we'll have them in the foreseeable future.
https://visualstudio.uservoice.com/forums/121579-visual-studio/category/30935-languages-f-tools
Also this: lightweight hkt through a library. https://github.com/palladin/Higher
I'm surprised that F* don't have CIL backend. It's not usable with F#.
The problem with higher kinded types is that you need a new type layer in the VM. CoreCLR does not support that and the CoreCLR guys don't want to add it. For Scala they had to tweak the Java type system quite a bit to get it to work. 
It's been asked and debated hundreds of times.
Install [F# Power Tools](http://fsprojects.github.io/VisualFSharpPowerTools/resolveunopenednamespaces.html) and you'll get this.
Exactly what I wanted, thanks!
As much as I enjoy F#, I'm not really convinced about it's future. I've been waiting for it to take over in the .Net world for the last 5 years, and not much has changed. The language evolved, is still ahead of C#, but too often C# is good enough for people to not to care about alternatives. 
His point about learning never really going to waste rings true here. My first few attempts at F# made me feel like a fish out of water and I walked away feeling incredibly stupid. But then I went back to Python and suddenly this whole lambda thing started to make sense. Huh, a map and a filter could duplicate that functionality in half the number of lines and be easier to reason about and test. I eventually realized that this is a classic example of finding more tools. If all I had was a hammer, everything looked like a nail. I don't use F# at all day to day but I think I learned something important. 
I've been waiting for FSharp to make some kind of dent in the actuarial world, for which it seems incredibly well suited. Nothing's happening, even though that sector relies almost exclusively on MS tools. I find FSharp incredibly attractive but I'm not sure investing time into mastering it is going to pay off. The one MS product that I can imagine making huge inroads is enterprise R (if MS sticks to it!). Maybe once enterprise R is here, FSharp will tag along.
As an F# newb, one of the things I like the most about the language is the incredibly good type inference. It's *almost* as if I'm writing a dynamic language that is somehow magically type-safe. It really helps de-clutter the code, without losing the benefits of static analysis. 
Yeah, I agree. Some things I thought were a bad idea aren't anymore, because they are easy to type and read. Mostly of course these are the ones that have something to do with functions, delegates, lambdas, whatever you call it. Like even if you write some silly small interface wrapper, it feels okay here, because there is almost no code duplication. In C# you can't avoid specifying types on a function signature. As an example: let private textureLoader (group : ResourceGroup) path = (group.Resources.[path] :?&gt; TextureResource).Value let getTexture group path = LazyResource(group, path, textureLoader) Being able to omit both argument types and return types sometimes saves a lot of typing. And helps with reading if function is that small.
I feel like I've stripped away all the boilerplate from my code, and all that's left is the fundamental *essence* of my program. It's small, highly condensed, and with no redundancy. It takes me longer to write it, because I'm still a newb, but I have so much more confidence that my code is correct. Most of my coding errors end up being logical errors of the mind that were written exactly as I intended them to be, whereas with C# many of my errors tend to be a mistranslation between what my mind was trying to express and what was actually coded. I've been programming for more than 10 years and I never understood the appeal of functional programming until now.
bought! thanks for the tip! ;)
Can´t you make it even nicer by changing count &lt;- split |&gt; List.head variables &lt;- split |&gt; List.tail into count::variables &lt;- split 
I am not sure, I could not get it to work let split = [1;2;3;4;5] let mutable count = 0 let mutable variables = [] count::variables &lt;- split 
Only with let and =
That immediate instantiation of a tuple is brilliant! I wish I had a GIF on hand to send you! (on mobile)
Now there is only 60 hours to go! And we are hoping to unveil some good news!!
Can you tell me how to get started with a Universal F# app? There isn't a project template available for F#. 
It looks like you *can* write your application logic in F# - as a library - and use that in the app: http://i.imgur.com/P6QYZkx.png note the "Windows Store" bit, which as far as I'm aware is just the Windows 8.1 name for that framework. I'll bet it's *possible* to write the whole application in F#, but they just haven't bothered to set up the automation to for F# GUI applications at all. 
Oh, boo. Thanks for clearing up that misunderstanding on my part. Surprised to hear this, really, but I guess that's where we are then. I recently tried to read up on what UWP really entails but was thoroughly confused by the .. diversity in coverage and age of documentation.
Wait until you try to set a break point for logic in an in-line function and you realize it's going to trigger at the variable level where the function is assigned and not let you see anything important.
To confirm, we have Xamarin on board and we will be offering a free cross platform mobile dev course as part of this, so you now get even more! :-)
Thank you, I personally want to do the machine learning parts so hopefully we will get around to it ;-)
Not to mention that their marketing machine will be churning away promoting fsharp.
Don't you have closures in C#? `memoize` returns a closure which refers to `cache`. The real thing to understand is how to use `memoize` correctly. For instance, let rec fiFast = memoize (fun n -&gt; if n &lt;= 2 then 1 else fiFast (n - 1) + fiFast (n - 2)) is OK, but let rec fiNotFast n = memoize (fun n -&gt; if n &lt;= 2 then 1 else fiNotFast (n - 1) + fiNotFast (n - 2)) n is plain wrong!
Ah ahn... I think I'm starting to clear some clouds now, thanks! Just to make sure, let me try to understand why the second iteration is wrong. The only difference seems to be the argument ```n``` , does this mean that it will memoize only for that instance of ```n``` ?
The difference is that let rec fiFast = memoize (fun n -&gt; if n &lt;= 2 then 1 else fiFast (n - 1) + fiFast (n - 2)) computes the expression on the RHS and assigns it to `fiFast`. So, `fiFast` is the closure returned by `memoize`. Therefore, when you call `fiFast`, you're calling the closure directly. On the other hand, let rec fiNotFast n = memoize (fun n -&gt; if n &lt;= 2 then 1 else fiNotFast (n - 1) + fiNotFast (n - 2)) n defines a function which calls `memoize` and passes `n` to the closure returned by `memoize`. This means that `memoize` is called every time you call `fiNotFast `. So, `fiNotFast (n - 1)` calls `memoize` again. This is bad because every call to `fiNotFast` generates a new closure (returned by `memoize`) and all these closures use different caches.
3 is not a function. Remember f is a function going from 'a to 'b. So let's go through a use case here. let square n = n * n then let memoizedSquare = memoize square You can think of memoize as a function that 'rewrites' your function to be smarter.
Ah yes, sorry and thanks for your help so far. So what you're saying is that calling ```memoizedSquare``` twice won't create two separate dictionaries?
Absolutely brilliant. I finally see the light. Thanks so much :)
Yes, I think what was tripping me up was the usage of ```memoize``` more than anything.
Just for fun, a toy memoize function in C# with sample callings: namespace Memoize { class Program { static void Main(string[] args) { Console.WriteLine("Calling original version..."); Console.WriteLine(DoubleIt(5)); Console.WriteLine("Calling original version again..."); Console.WriteLine(DoubleIt(5)); var memoizedDouble = Memoize&lt;Int32, Int32&gt;(DoubleIt); Console.WriteLine("Calling memoized version..."); Console.WriteLine(memoizedDouble(5)); Console.WriteLine("Calling memoized version again..."); Console.WriteLine(memoizedDouble(5)); Console.WriteLine("Calling original version again..."); Console.WriteLine(DoubleIt(5)); Console.ReadLine(); } public static Int32 DoubleIt(Int32 a) { Console.WriteLine("Original version"); return a * 2; } public static Func&lt;P, T&gt; Memoize&lt;P, T&gt;(Func&lt;P, T&gt; func) { var cache = new Dictionary&lt;P, T&gt;(); return (P p) =&gt; { T cached; if (cache.TryGetValue(p, out cached)) { return cached; } cached = func(p); cache[p] = cached; return cached; }; } } } 
It isn't a thing for exactly the reason you pointed out -- lack of pre-installation. Powershell might be ugly, but you have to compare it to what came before, batch files. Over batch, Powershell is a massive upgrade and can do serious work right out of the box. Now, of course, nothing stops you from doing it on the machines you control.. there are far worse solution in common use... but you would be in relatively uncharted territory. 
I don't have much use for shell scripting, but I do have a set of F# scripts in LINQPad I use for similar purposes.
Using Suave.io to build a website.
What you call "a downside" is a deal breaker for me (as a hacker/pentester).
You could always use the [PowerShellTypeProvider](http://fsprojects.github.io/FSharp.Management/PowerShellProvider.html) as well.
Building an image processing library and other things.
Fun.
I write a lot of Automated UI Web tests, load tests, a business rules engine, documentation, and build scripts with F#. I have been doing it full time for &gt; 2 years now and never want to look back!
FSharp make to build, package, and manage our projects.
I've replaced using C# with F#, but I still use Powershell heavily for shell scripting because: * As you said, F# isn't included on all Windows, and I need my stuff to be widely used. * F# just doesn't fit as well into typical shell-scripting for the stuff I do. I run things on remote machines, I execute commands through remote Powershell sessions, and I do a lot of WMI / command execution. Yes, I could do this with F# and the WMI interface and Powershell provider, but that's more code, and using F# for something that I don't feel is really its strength. * Powershell is far more understandable by everyone else I have to work with, if they have to run any of my scripts.
I'm building an automated/predictive build/continuous deployment system for the company I'm working for. I built a library atop F# FAKE originally to convert people from the current build/deployment framework (some amalgamation of Ruby/Java/Ivy/Perl to build .NET code), and converted some people over to using it, but the team at large has very stubborn developers who like mindless build systems and don't want to see build files. So I'm currently working on a web service (using Suave.io) to handle some portion of this (mostly integration with CI/CD servers and source repositories), and building a client-side tool that can do stuff like generate dynamic build files on the fly to build source repos. 
Powershell is so goddamn good though. I'm sure F# is the newest thing to solve all the world's problems, however I don't see it dethroning Powershell anytime soon. Powershell is too good. 
My complaints: I can't stand the fact that you can't import namespaces. This alone makes using any .NET classes a pain in the ass, and far more verbose than using C# or F#. There is no lazy evaluation, so calls like Get-Content attempt to read the contents of the entire file into memory before returning, which obviously doesn't work well on large files. C#'s File.ReadAllLines() returns an IEnumerable&lt;string&gt; which lets you operate on arbitrarily large files one line at a time. Also, the fact that its missing LINQ is a huge downer, and what it has instead is just so much more complicated, verbose, and less powerful The back-tick is the lamest way to escape a character I've ever seen There are some weird oddities with the working directory associated with powershell scripts that gets me every time. I can't even remember what they are, but I know they will screw me over again. the comparator operators are just absurdly stupid: -gt for &gt; -lt for &lt; ugggh
Everything has it's own warts. I've honestly only used F# with an accompanying Pluralsight course for fun. I've never used it to actually make anything or really accomplish anything of significant value. So with that being said, I can't honestly truly gauge it against PS. It's a big task for F# to unseat PS considering MS puts so much stock in it across their products and the fact that even with some warts it's just really good. At a lot of things. If F# can prove itself better than PS, I'm all for that. It's a long road imo. 
What does your flow look like? That will change what you need fake for. For example, where I work we use Visual Studio and mostly C# so FAKE takes over task running and defining the build targets for CI. I am not a Xamarin person, so I cannot answer about the manifest. However msbuild is an xml task runner, like Ant for java, so it might be including extra build targets or adding special files that a Xamarin task would use.
[But you can still write your posh modules in F# ;)]( http://blogs.msdn.com/b/fsharpteam/archive/2012/10/03/rethinking-findstr-with-f-and-powershell.aspx)
why didn't you test it? Would that be not the first clue about the quality of your solution? anyway I'll write down what I find: 1.) here: | Neg x -&gt; Neg (negNormForm x) you already know what `x` has to be (an Atom right?) so you can save yourself the trouble with `negNormForm x` - so indeed I think it's clearer (and closer to the definition/task) if you do: | Neg (Atom _) as x -&gt; x 
&gt; why didn't you test it? Would that be not the first clue about the quality of your solution? It should be correct by construction! &gt; 1.) [] Yes, you're right! We could also write let rec negNormForm = function | Neg(Conj(x,y)) -&gt; Disj(negNormForm (Neg x), negNormForm (Neg y)) | Neg(Disj(x,y)) -&gt; Conj(negNormForm (Neg x), negNormForm (Neg y)) | Neg(Neg(x)) -&gt; negNormForm x | Conj(x,y) -&gt; Conj(negNormForm x, negNormForm y) | Disj(x,y) -&gt; Disj(negNormForm x, negNormForm y) | x -&gt; x Or is it too implicit? edit: BTW, thank you for taking the time to look at my code!
I can read the first one in about 5s. I can add or remove any new function in less than ten seconds. I can show a BA the first function and have them understand it. For the second and third one, these numbers are probably double or triple this, and the BA will cry.
Definitely third. If you want readability just use different formatting type Instruction = ADD | SUB | MULT | DIV | SIN | COS | LOG | EXP | PUSH of float let bin = [ ADD, (+) SUB, (-) MULT, (*) DIV, (/) ] |&gt; Map.ofList let un = [ SIN, sin COS, cos LOG, log EXP, exp ] |&gt; Map.ofList let execInstr3 stack inst = match (stack, inst) with | (x::y::r, _) when Map.containsKey inst bin -&gt; (Map.find inst bin) x y :: r | (x::r, _) when Map.containsKey inst un -&gt; (Map.find inst un) x :: r | (r, PUSH x) -&gt; x :: r | _ -&gt; failwith "Can't execute the instruction!"
Here's a neat solution based off of dotneter, using Active Patterns: type Instruction = ADD | SUB | MULT | DIV | SIN | COS | LOG | EXP | PUSH of float let bin = [ ADD, (+) SUB, (-) MULT, (*) DIV, (/) ] |&gt; Map.ofList let un = [ SIN, sin COS, cos LOG, log EXP, exp ] |&gt; Map.ofList let (|Binary|_|) (stack, inst) = match (stack, Map.tryFind inst bin) with | (x::y::r, Some(op)) -&gt; Some(op x y, r) | _ -&gt; None let (|Unary|_|) (stack, inst) = match (stack, Map.tryFind inst un) with | (x::r, Some(op)) -&gt; Some(op x, r) | _ -&gt; None let execInstr stack inst = match (stack, inst) with | Binary (result, r) -&gt; result :: r | Unary (result, r) -&gt; result :: r | (r, PUSH x) -&gt; x :: r | _ -&gt; failwith "Can't execute the instruction!"
If this were my own code, I'd probably do something like this, though; type Instruction = ADD | SUB | MULT | DIV | SIN | COS | LOG | EXP | PUSH of float let (|Binary|_|) (stack, inst) = let bin = [ ADD, (+); SUB, (-); MULT, (*); DIV, (/) ] |&gt; Map.ofList match (stack, Map.tryFind inst bin) with | (x::y::r, Some(op)) -&gt; Some(op x y, r) | _ -&gt; None let (|Unary|_|) (stack, inst) = let un = [ SIN, sin; COS, cos; LOG, log; EXP, exp ] |&gt; Map.ofList match (stack, Map.tryFind inst un) with | (x::r, Some(op)) -&gt; Some(op x, r) | _ -&gt; None let execInstr stack inst = match (stack, inst) with | Binary (result, r) -&gt; result :: r | Unary (result, r) -&gt; result :: r | (r, PUSH x) -&gt; x :: r | _ -&gt; failwith "Can't execute the instruction!"
I'm going through pluralsight courses and trying to practice on Hacker Rank. Unfortunately, I just do everything using the Seq functions just like if I were doing c#, so I'm not really getting anywhere with that XD
I added another version to the main post because execInstr3 is still not perfect.
I would use #1 until there was a clear and immediate reason not to (e.g. user-defined operators).
How /u/statuek use Active Pattern looks odd. Here is how I use Active Pattern: type Instruction = | ADD | SUB | MULT | DIV | SIN | COS | LOG | EXP | PUSH of float let (| Unity | Binary | Push |) x = match (x) with | ADD -&gt; Binary (+) | SUB -&gt; Binary (-) | MULT -&gt; Binary (*) | DIV -&gt; Binary (/) | SIN -&gt; Unity sin | COS -&gt; Unity cos | LOG -&gt; Unity log | EXP -&gt; Unity exp | PUSH x -&gt; Push x let execInstr5 stack inst = match (stack, inst) with | (x::y::r, Binary op) -&gt; op x y :: r | (x::r, Unity op) -&gt; op x :: r | (r,Push x) -&gt; x :: r | _ -&gt; failwith "Can't execute instruction"
Nice! BTW, can't your Active Pattern be emulated with an ADT and a function with pattern matching?
It's just a little bit more code. Transform type Instruction into a new type InstructionWithNewPattern that can be pattern matched: type Instruction = | ADD | SUB | MULT | DIV | SIN | COS | LOG | EXP | PUSH of float type InstructionWithNewPattern = Unity of (float -&gt; float) | Binary of (float -&gt; float -&gt; float) | Push of float let withNewPattern x = match (x) with | ADD -&gt; Binary (+) | SUB -&gt; Binary (-) | MULT -&gt; Binary (*) | DIV -&gt; Binary (/) | SIN -&gt; Unity sin | COS -&gt; Unity cos | LOG -&gt; Unity log | EXP -&gt; Unity exp | PUSH x -&gt; Push x let execInstr5 stack inst = match (stack, withNewPattern inst) with | (x::y::r, Binary op) -&gt; op x y :: r | (x::r, Unity op) -&gt; op x :: r | (r,Push x) -&gt; x :: r | _ -&gt; failwith "Can't execute instruction"
I use [Http.fs](https://github.com/relentless/Http.fs) for testing external/internal RESTful APIs. It's great for writing functional http clients libraries. In my opinion, it beats the crap out of the Web API client tools. The three Http.fs client libraries I've put into production have been very reliable. The only reason I touch this code is for enhancements. There have been literally no bugs thus far.
Oracle 11g + MS SQL + Rx + SOAP = scheduled communications service with back pressure and throttling. Nancy+SignalR+Typescript = web interface for the above service. Everything is on F# of course.
Thank you! this helped quite a bit. The issue I see now is that I'm not able to access the groupValBy keys. e.g. In C# I can do "tt.Key.Label" However in F# ".Label" doesn't seem to exist. All the examples I could find only use one key :\
Living the dream. I wish I could work on F# full time. Ah well, I did sneak in FAKE for our build and deployment scripts :D so there's that. 
Yup, F# seems to be a bit niche. I can understand *why* though, and - unfortunately - I think that it's mostly due to C# being 'good enough'... I asked people at Tachyus about their openings some time ago, but they didn't get back to me ;(
If the tree is balanced then I would prefer the non-tail-recursive function. If the tree is arbitrarily deep then I might prefer an imperative solution using a `Stack`: let count t = let stack = System.Collections.Generic.Stack[t] let mutable n = 0 while stack.Count&gt;0 do match stack.Pop() with | Leaf -&gt; () | Node(l, _, r) -&gt; stack.Push r stack.Push l n &lt;- n+1 n I would not prefer the CPS version because it offers no advantages. If you're after simplicity then I might consider implementing `IEnumerable` on the type definition and using `Seq.length`. 
maybe upwork?
You can post a request on http://www.outsource.com I'd help but I am still learning F Sharp.
Keep trying, you never know :)
&gt; It's shorter and equally efficient. Shorter yes but it is not equally efficient. You're creating linked lists two nodes at a time resulting in `2n` heap allocations. The `Stack` collection uses an array internally that is resized resulting in `log(n)` heap allocations. Heap allocations incur unnecessary indirections and stress the garbage collector, reducing performance. This is particularly important in the context of parallel programs for multicore where cache efficiency is critically important. This generates an example tree: let gen n = let mutable t = Leaf for i in 1..n do t &lt;- Node(t, i, Leaf) t let t = gen 1000000 Computing the count eight times in parallel using your function takes just over 1s: Array.Parallel.init 8 (fun _ -&gt; myCount t) // Real: 00:00:01.055, CPU: 00:00:01.388, GC gen0: 82, gen1: 21, gen2: 0 Using my function takes just 0.12s (over 8x faster than your function): Array.Parallel.init 8 (fun _ -&gt; count t) // Real: 00:00:00.122, CPU: 00:00:00.530, GC gen0: 0, gen1: 0, gen2: 0 Note the speedup as CPU time over real elapsed time. Your function gets 1.388/1.055=32% speedup on this quadcore with hyperthreading whereas mine gets 0.53/0.122=4.3x speedup. Note also the garbage collection cycles incurred. Your function incurs 82 gen0 collections which is bad but also 21 gen1 collections which is *really* bad. My function incurs no garbage collection cycles at all. Every time you incur a gen1 or gen2 collection you are causing the GC to mark all reachable objects in that generation (all objects in your case, which is pathological behaviour in the context of the generational hypothesis and, consequently, a worst-case scenario on .NET because it uses a generational collector), copy all of the live objects to the next generation and update all pointers to those objects to point at their new locations. That is essentially 3 unnecessary passes over your data so your algorithm is ~3x slower than necessary just because of that happening in gen0 and then another 2x slower for each time it happens in gen1. 
I was referring to an asymptotic estimate. It's well known that mutable data structures are more efficient. Your code is basically C#, so what's the point of programming in F#?
&gt; I was referring to an asymptotic estimate. It's well known that mutable data structures are more efficient. Ok. &gt; Your code is basically C#, so what's the point of programming in F#? As Yaron Minsky says, don't be puritanical about purity. Functional programming is not a panacea. You should not set out to apply it everywhere whether it makes sense to or not. There are many problems for which purely functional programming is not a good solution. You have stumbled upon one such problem. So use imperative programming in this case but don't throw the baby out with the bath water by then swinging to the opposite extreme and saying "what's the point" of using it at all. Pick your battles. If functional programming does not permit a more elegant, efficient or comprehensible solution then don't use it just for the sake of it. Same goes for OOP and every other tool in your toolbox. 
I agree. &gt; &gt; a more elegant, efficient or comprehensible solution &gt; &gt; most time &amp; space efficient I said "or". You said "and". 
It's not a static website it's a small web store. It's mainly a toy project for me to learn the framework without having to think too much about the domain with the added benefit of actually being useful for a friend.
Is the project itself bound to source control? There won't be anything to check out if it is not being tracked.
It goes without saying that there's no way to tell if a function has side effects in F#. No one is claiming that F# lets you haphazardly mix FP in IP styles with no consequences. I'm claiming you can mix both style with some ground rules. If you need some convincing, take a look at the core F# libraries (https://github.com/fsharp/fsharp/blob/master/src/fsharp/FSharp.Core/array.fs). Like John's code, a lot of these functions use the mutable keyword to maximize performance, yet they remain composable and introduce no side-effects.
Try using dictionaries instead of maps. Use the `hash` function on the string you're using as keys instead of the strings themselves. hash "key" or hash ("date","resource") You could also use a System.DateTime over a string You could try a tail recursive read into a list instead of a `seq` let readRowsFromCsvZip path = use stream = new ZipInputStream(File.OpenRead(path)) ignore (stream.GetNextEntry()) let readerConfig = new CsvHelper.Configuration.CsvConfiguration() readerConfig.HasHeaderRecord &lt;- false use reader = new CsvHelper.CsvReader(new StreamReader(stream), readerConfig) let rec loop acc = if reader.Read() = false then acc else reader.CurrentRecord::acc loop [] In parse rows you should use Array.filter and Array.map to pare down the data that you feed into the dictionary. You might be able to speed it up even more if you turn the entire calculation into a fold by combining readRowsFromCsvZip with collectRows where you create the dictionary and output collection before you start reading from the file and on each read you create you also create the corresponding record and add/append it into your collection. Of course parse rows needs to be declared first though. Also printfn is sloooow. Fold a stringbuilder over your collection and then print the final string for more speed
Building data import tools at work. Heavy user of http://fsprojects.github.io/FSharp.Data.SqlClient/
on that, maybe https://weworkremotely.com/ would be a another suitable option? (never used it but check there from time to time)
&gt; If you need an editor without hassles, I think Atom editor is better than MonoDevelop on Linux: https://atom.io/packages/atom-fsharp Hm.. Intriguing.. /me installs atom. Always wanted to try it, but never had a reason to. My main requirement for a text editor is emacs-like key bindings (including mark-based selection mode) and for monodevelop I had to make a plugin for myself (https://github.com/nsf/emacskeys_md, it's crappy and fairly incomplete). As for atom, I've seen quite a few emacs emulation packages. Worth a shot.
I started with 5.0, but that's not the problem because it drops pretty quickly, as you can see from the first 5 iterations: 5 0.283662185463226 0.960036930294662 0.573489732695365 0.840012680952159
I was running it through fsi by passing it the filename. That compiles it, right?
There is also mature (more mature then Atom) Emacs plugin (or whatever it's called in Emacs ;) ) https://github.com/fsharp/emacs-fsharp-mode
Hey thanks for the tips, Why would a tail recursive read into a list be faster than a seq? My understanding is that a seq is basically running that loop and returning the result as its being pulled from the caller, it seems like storing it in a list would be slower, no?
fsi is the interactive interpreter. It won't have TCO, so I guess it will be slow with recursive functions that require many levels of calls, as yours does. I have no idea why adding an fprintfn to the function makes a difference though. You really need to start compiling your code with fsc - fsi is only intended for evaluating simple expressions, not running programs.
Interesting that the [Documentation](https://msdn.microsoft.com/en-us/library/dd233172.aspx) for FSI says that tailcall optimisation is enabled by default. Unless I've completely misunderstood it.
Ok, my mistake, in which case I don't really understand why fsi is choking on your function. But still, try fsc and see if you still have the slowdown.
Thanks, but there are reasons why I ended up writing emacskeys plugin for monodevelop. I like emacs keybindings, I like org-mode, I like macros, I like few other things about emacs, but the rest of it I hate. The day when I have to touch a single line of elisp code is a nightmare for me.. :)
Well, in such case atom might be good choice. It's decent and have nice integration with things like FAKE, Paket and F# yeoman generator. But I'm bit biased so take my opinion carefully ;)
Might be worth to open an issue there: https://github.com/Microsoft/visualfsharp/issues Do you want to do it?
Archlinux has automatic packages building and managing system called AUR. I don't know whether Ubuntu has similiar one. If not, you can write a shell script instead. 
Hi, I must say that now on Fedora things work OK for the most part * installed *fsharp* and *MonoDevelop* using `yum` from the [official *mono* repository](http://www.mono-project.com/docs/getting-started/install/linux/#centos-fedora-and-derivatives) * for starting a new project, fork [ProjectScaffold](https://github.com/fsprojects/ProjectScaffold) * you can look at my [playground project](https://github.com/sideeffffect/FSharpHello) (and the commit history), where I'm (with help from others) fixing some of the issues you can come across 
The project is bound to source control. There is the "blue lock" next to it indicating it is checked in. Is that what mean by "Bound to source control" ?
try www.venturepact.com
I wish it wasn't MS doing this
I am sure they will do an great (and complete ) course, but it perpetuates the perception that F# is Microsoft's baby and it alienates people coming from other places.
Actually isn't it about time MS did something to promote that awesome language ? The scala MOOC on coursera seems to have done a lot to increase scala's visibility so I'm quite thrilled to see MS promoting both F# and R on edx.
If anything, F# currently feels like Microsoft had a baby, and abandoned it in a dumpster full of really wonderful hipsters.
but it was raised by a larger (cooler?) group
I don't have any ocaml experience, or much distributed experience, but this may be helpful to what you are creating http://www.m-brace.net/
A bit weight in your decision is to check out [MirageOS](http://www.openmirage.org/). 
Good grief, what is up with the scrolling on that page?
Repeating what I wrote in /r/ocaml: &gt; Particularly, if F# has anything more to offer on deployability and system interop on enterprise windows networks, or is OCaml usable? I'm sure there are pre-existing .NET tools for that but, unless you're already intimately familiar with them, learning them will probably be more trouble than its worth. &gt; We are considering starting a new project that will be deployed simultaneously on many networked computers of different architecture (Some windows, some not), which we do not have full permissions to. Basically I would say that OCaml is better under Linux and F# is better under Windows. &gt; So main interest is networking, concurrency, hardware interface, and deployability in a restricted environment Both OCaml and F# have great networking and concurrency support. F# has great hardware interface support but I think ctypes has fixed the problems I had with OCaml. Deployability in a restricted environment might be the only big difference. Provided all of your target machines have .NET installed, deployability is dead easy and very reliable with F#. I've had showstopping problems with compiled OCaml binaries not working when copied to other machines before. However, that may have been specifically due to OpenGL libraries. Overall I'd say there is probably not much in it so stick with whatever you're familiar with. 
I don't remember there being a brew package when I tried last, or maybe there was one and I didn't find it. I have an F# project on the back burner. I'll give it a shot again one of these days. Glad to hear someone has good luck with this.
I think the plan is to implement it for the native code once the bytecode works, which is not entirely unreasonable. Also, don't hate the bytecode, having very fast bytecode compilation is great during development.
I'm loving this new rash of tooling!
I want something like this for D. And then I want both for Sublime. Pretty please?
The Ionide plugins are all written in F# and unfortunately for Sublime we don't have a way to transpile into python. I still use Sublime regularly, but Github did a much better job at making Atom extensible and that's why it's gotten a lot more attention.
More cool stuff is coming (slowly)
Understandable. Great work all the same! This can completely replace my VS workflow.
Does this replace atom-fsharp?
Ok, I install all recent versions, but how build a project? How run a fsx script? Is necessary to use faker?
sql type provider: https://msdn.microsoft.com/en-us/library/hh361033.aspx
Can I do this without learning LINQ?
Honestly, if you don't learn LINQ, you won't benefit much from using F# either. On the other hand, if you know F#, you can pick up LINQ in a half an hour.
Sure: * The most important thing is that SQL is text, while as LINQ is code (in the context of a C#/F# program). * With SQL, you have no type safety or guarantees about the correctness of syntax. You might make syntax mistakes or use a non-existant table/column, and you'll only know about that after the database returns an error. Also, since you're writing raw SQL, you have to make sure you thoroughly sanitize user input to avoid SQL injections. * LINQ on other hand is normal C#/F# code, which is converted to SQL at runtime by the framework. Invalid syntax is literally impossible, otherwise your program wouldn't compile. Since you're using an ORM / a type provider / LINQ-to-SQL / Entity Framework, you have full type safety. You can't query tables/columns that don't exist, and everything in your database (as defined in your schema) is discoverable with Intellisense. And assuming the SQL provider is implemented correctly, SQL injections are impossible. * LINQ is not just for databses. You can use LINQ to query anything that implements `IEnumerable&lt;T&gt;`, including in-memory collections (List, Dictionary, Stack etc), XML files and even [Twitter](https://linqtotwitter.codeplex.com/), with little to no modification.
Here is an example of using regular ADO.net (in this code against PostgreSQL, but it would be almost identical for SQL Server or Oracle) https://github.com/lefthandedgoat/SuaveMusicStore/blob/postgres/Db_Postgres.fs Type providers and LINQ can make your life better, but regular ADO.net works too (just more work).
I would (slightly) disagree with this. Yes LINQ is amazing and has the advantages simspelaaja states. However it can get obscure, and it isn't true that it's impossible to write invalid syntax. Only a couple of weeks ago I wrote a LINQ query which compiled fine but failed at run-time for a reason which could in principle have been detected at compile time. I think avoiding LINQ initially and using something like Dapper is a legitimate route for someone with your background, though you'll want to loop back and revisit LINQ later. Incidentally you can mitigate the risks of writing raw SQL by doing your development in a test-driven way, perhaps using something like NCrunch. If you write fine-grained tests (technically integration tests but in a unit-testing style) you can get to a position where if you change a single character of your SQL to something invalid, your tests immediately fail.
You can find the repos for the individual packages at https://github.com/ionide You want to checkout the 'develop' branches
Coming from a C# background, it will be my first time with the language. Lets have fun.
Interesting! Could you provide a more detailed view of the actual problem with CIL code patching such that we might discuss potential solutions and their respective feasibility?
&gt; Can someone with the requisite insight summarize what it would take to implement Edit and Continue in F#? The simplest solution would be to make all F# function calls virtual so they can be hot-swapped. This will impact performance, of course, but I think it would be much easier than CIL patching. &gt; the halting problem prevents types from being expressive enough to model the artistic intent of a simulation designer I find this statement disturbing. Sounds like you're doing it wrong. Are you sure you don't want a DSL that support monkey patching instead of hand-coding everything in F#? AFAIK, this feature is requested by very few people. 
That would be an interesting approach. I wonder what type of effort we'd be talking for that? As to the latter concern, don't be disturbed; it's not as bad as it sounds. To expand on the various trade-offs in play and the actual level dynamism in Nu, take a look at this little inline dicussion here - https://github.com/bryanedds/FPWorks/blob/master/Nu/Nu/Nu/Program.fs#L10-L53
&gt; Do we build an F# to C# compiler? Actually, would we even need to build it? I've never tried them on a F# assembly, but I don't see why ILSpy/dotPeek or other IL decompilers wouldn't be quite capable of providing the C#/VB.Net translation of your F# code. And it would preserve every optimization the F# compiler performed.
Perhaps I was being a bit absurd :) In actuality, I think we'd just need to translate the F#-outputted IL that is not supported on .NET native to IL that is. No idea how hard that would be tho.
I agree, Xamarin is just ugly and klunky, but in all reality I would still just use Xamarin. I have tried sublime fsharp, ionize ffsharp, emacs, vscode, and they all are sub par. Things you realistically need: - auto complete - managing of fsproj/sln/nuget - debugging - repl - syntax highlighting - type inspection nothing but vs and Xamarin give you all that with no fiddling and futzing
Why F# on OS X vs OCaml? I am deciding which to learn (and maybe Haskell) but I don't really do anything with Windows at this point. So I am not sure if .NET anything is useful to me.
Seriously, what's wrong with using Visual Studio? 
Not cross-platform.
I'm also interested in this and have few questions: 1. What do people mostly use for data access with F# in production? 2. Entity Framework model is ugly in F# due to the need to have virtual navigation props - would it make more sense to define it in a separate assembly using C#, as mutable classes are needed anyway? 3. Are Type Providers fast enough and how they compare with "normal" access to DB using EF or similar? 4. How do you deal with the need to have hard-coded connection strings for Type Providers? 5. Are Type Providers suitable for CRUD scenarios?
The [PR that fixes the bug I was hitting](https://github.com/ionide/ionide-fsharp/issues/147#issuecomment-145260874) hasn't made it in yet. &gt;What don't you like about the Xamarin F# tools? UX warts. The UI is slow in all the wrong places, the interface feels cluttered, and it's really not clear what the Linux story is.
I hadn't noticed any speed issues in other parts of the Xamarin UI, I only boot it up to check how the F# tools run in it. Xamarin's actually have the fastest speed for a lot of cases. Granted that isn't enough to get me to actually use it ;D I'll checkout that PR tonight, see if it does what it claims.
This looks cool but when I go to the configuration panel, I get a message telling me that "No projects are currently open".
It would help if you could put the code up on a site like fssnip 
You're 100% correct. For /u/mcdileo, the signature int -&gt; seq&lt;int&gt; means that the type is actually a function that takes in an int and returns a sequence of ints, i.e. your getTotals function is partially-applied.
Thanks guys! 
fsc.exe is the F# compiler shipped with VS. You can launch a command prompt with all the VS tools available through the shortcut in the VS folder under the Start menu. From that prompt, use fsc.exe. Run with /help to get started. Also important: fsi.exe is the command line REPL, and one of the best parts of F#
So you've got some options, depending on how low-level you want to get. if all you want to do is build the project the same way that visual studio does, all you need is the .fsproj file and the msbuild executable. The msbuild excuteable should exist at c:\Program Files(x86)\MSBuild\&lt;VERSION&gt;\bin\msbuild.exe, where &lt;VERSION&gt; is 14.0 for Visual Studio 2015 (don't ask :)). Then, you can compile your .fsproj using msbuild my_fsproj.fsproj /p:Configuration=Release and you can change the build configuration between any of the ones that the .fsproj supports. Now, if you want to go super-low-level, all the .fsproj file is is a build script for msbuild that calls fsc.exe, the F# compiler, with a set of inputs to get a compiled dll or excutable. fsc.exe, if you have it installed, should live at c:\Program Files(x86)\Microsoft SDKs\F#\&lt;VERSION&gt;\Framework\&lt;VERSION&gt;\fsc.exe And that should get your started. Now, if you don't have Visual F# installed with Visual Studio, you can cheat and get the open-source versions of fsc.exe and fsi.exe from the FSharp.Compiler.Tools nuget package, where they are known as fsharpc.exe and fsharpi.exe. Hope this helps!
In Visual Studio right click on your project in the solution explorer, then click Open Folder in File Explorer. That should open the project directory, then go to bin/Debug/ and you'll see the compiled executable there, which you can run in the console. Another option is just add a `System.Console.Read()` call at the end of your program.
Ive been using the music store app as a guideline for building apps in Suave. So far its proven to be excellent and cover all the basic scenarios. Thoroughly enjoying developing in Suave vs MVC + F#.
*Self-promotion alert* If you don't particularly like the MS course, you might want to try my "F# Jumpstart" course on PluralSight. This covers various ways to run your stuff, amongst much else obviously. It's paid unfortunately, though many employers have a subcription. http://www.pluralsight.com/courses/fsharp-jumpstart 
Oh, and I've just found the 'free trial' links. Click 'Subscribe' then 'Try it free'. You could easily complete my course in the 10 days they give you.
Probably something something Azure. The VS plug-ins already exist.
I could not care less. However I think that Microsoft should have taken the term "Visual" out of many of their products a long time ago.
[This article](http://fsharpforfunandprofit.com/posts/fsharp-decompiled/#records) should help you understand a bit more about what F# record types look like in C#... You can see why it results in nulls -- an F# record's properties would be written with { get; internal set; } in an equivalent C# class. As far as your general question, I used classes when I refactored a simple MVC ViewModels/Forms library from C# into F#. Even as classes you still gain a lot of benefit by using F#... it's quicker to bang them out and easier to read.
&gt; focus on C#/F# Definitely. :-) 
&gt;We're not winning the war on getting MS to make F# a first-class language [This](https://wpdev.uservoice.com/forums/110705-universal-windows-platform/suggestions/9110134-f-support-in-net-native-for-uwp?tracking_code=a252df9cb256a30bfc7c92cffc40ff81) paints a quite different picture: &gt;Quick update. We are committed to bringing F# support to .NET Native. The initial version of .NET Native was designed to do a great job of compiling the most popular apps in the Windows Store. Since its launch, we’ve been working on .NET Native support for more advanced .NET IL code, like tail call instructions and complex generic types. These IL features are more common in F# apps than C# apps, and they’re the reasons the F# support isn’t there, yet, in .NET Native. &gt;Beyond .NET Native, there’s more going on with F# at Microsoft. We’re in the process of bringing F# to .NET Core. We see new teams inside Microsoft adopting F#. We’re excited to see startups considering and adopting F#. And we have an awesome open source community supporting the language and tools. If you’re interested in contributing, join us on Github at https://github.com/Microsoft/visualfsharp.
Sweeeet - F# makes so much sense as a cross-platform and universal language, nice to see action here.
It might be helpful to link to the meetup group :)
Yes indeedy, thanks! I foolishly assumed that since Reddit prompts for a link when you add a post, the link would itself get posted. ;-)
so ye :P
Wow, that takes me back. This is old school, MS-DOS programming. First off, I'm not sure what mouse drivers are available for the command line screen. You'll have to find that first. If you can find that, here's how we used to do it in the old days. In a 80x40 text screen, every character position is memory mapped. So, beginning at a particular memory address (use a pointer), every character on the screen had a memory address. If your screen memory started at 0x0000 (which it doesn't, this used to be the O/S starting address and it might still be) then the character in the upper left position would be 0x0000 and the next (moving right) would be 0x0001. The last character on the first line would be 4F and then the first character on the next row would be 0x0050 etc. Store the start location in a pointer called ScreenStart. Set ScreenStart + 0x0001 to 0x0041 and you will see a 'A' in the second position. So, what we did would be to map out the region of a cell (start point, length) and store them in an array. The mouse driver would report the current screen position it was over. You'd use that to discover which cell you were in. Then you'd copy the character values of what was in that screen location to your array, add a bit or two to the character values so they'd appear 'reversed' (light background, dark character) and then swap the whole array cell into that screen memory position. Doing this would result in a change on the screen. You would intercept every key stroke, and change screen position (arrow keys). You'd intercept every key stroke and fill in the cell (or re-position the cursor). In short, it was hell, and you wrote a massive amount of boilerplate to display menus (using ASCII characters for vertical or horizontal lines) and you'd swap out whole chunks of screen memory for menu (preserving what was 'behind' the menu off to the side so you could swap it back in when the menu was dismissed). Nobody does this anymore because windowing systems do all of that for you. It might be a good exercise. It is unlikely to be useful to you unless you're maintaining an ancient point of sale system that still uses 80x40 character screens and dumb terminals. But, my advice is don't go backwards 20 years, but embrace the window and mouse drivers of your choice and write an F# program that does what you describe in a window.
That's true. Basically, you need a loop that intercepts every key stroke. Treat every key stroke as an event. Map each key (or range of keys) to a function (event handler). Maintain a 'current position' value. 'character' values are directed to the 'PrintCharacter' function which will put the character in the current position, then call the 'UpdateCurrentPosition' so the current position stays correct. 'repositioning' values, such a as arrows, tab, space, backspace, home, end, will all be directed to a 'ComputeNextPosition' function and then call 'UpdateCurrentPosition'. You'll want to designate some sort of loop end so you can stop the loop with standard input. 'Esc' is a common one. Input loop which maps input events to handler functions. Not a bad exercise, actually.
well what im missing is not the ability to read keys but rather to have a tui were i can move around without just writing one command at a time. I want something like curses WICD on linux? or other terminal apps .. So imagine i have the matrix below. I want to jump from cell to cell with the arrow keys, and have a marker showing were i am. pressing RET will make me enter the cell and changing the value of the cell.. ---------------------- | * * * | * * * | * * * | | * * * | * * * | * [] * | | * * * | * * * | * * * | ---------------------- Right now i just write something in terminal and it gives me an answer like this. term : "Welcome" user : "load matrix" term : " * * 3 * * 2* * user : (0, 0, 3) term : "3 * 3 * * 2 * * And i dont want that.. Hope it makes sense now :P ?
so those matrix did not show up like i wanted them to..
Windows? Linux? Cross-platform?
Thanks gonna read that :)
Feedback: this is very pretty. That "getting started" is so short. &lt;3 F#.
How far did you get? I am just starting this journey.
Those are the only built-in workflows at this point. From MSDN: &gt;Sequence expressions are an example of a computation expression, as are asynchronous workflows and query expressions. For more information, see Sequences, Asynchronous Workflows, and Query Expressions.
Thanks. I saw that as well, but wasn't sure if it was a complete list, since they're only described as "examples". 
Yes. Shame active patterns are slow because they allocate...
Very similar approach to single case unions: http://fsharpforfunandprofit.com/posts/designing-with-types-single-case-dus/
I don't know if this helps, but there's also a very nice one called eventually {} in the compiler source. Not exposed though.
From what I understand, they're working on building a bridge to make this happen pretty soon, but it'd probably take an abstraction if you wanted easy swapping between the options.
Put it in a gist on github and post the link to it back here
I am doing really well. I have almost all of the crud functionality working on most of the app, nicely skinned with a bootstrap theme, all the html being generated by Suave.Experimental.Html. Some basic javascript on a few screens. Permissions, users, cookies, etc.
By the way, it isn't on the page yet, but Eugenia Cheng (who you may know from this: https://byorgey.wordpress.com/catsters-guide-2/ and from this: http://www.amazon.com/How-Bake-Pi-Exploration-Mathematics/dp/0465051715) will be giving a keynote.
[](/dumbfabric) Because .NET strings implement seq&lt;char&gt; (AKA IEnumerable&lt;char&gt;), you could just iterate through the sequence, yield those chars you want to keep and yield your replacement when the forth index (3) is hit. For example: "string" |&gt; Seq.mapi (fun index char -&gt; if index = 3 then 'o' else char ) |&gt; Seq.toArray |&gt; (fun charArray -&gt; new string(charArray)) The built in string constructors can take a char array, hence the Seq.toArray and calling of the constructor. (Note that we cant just do "|&gt; string" in that last step, as *string* is a function of type 'T -&gt; string, which just calls the object's ToString() method)
Thanks. However, I want to devise a solution that doesn't make use of anything rather than the simplest functional language constructs (lists, chars, comparison operators, ... and so on).
I'm confused. You want to access the individual chars of your string, but doing that necessarily requires knowing *how* the string is made out of characters. And the answer to that question is: the string is an array of characters. That's just what it *is*; any more "functional" (what do you mean by that?) construct you can come up with could only be a wrapper or interface around the array. In fact, tehcrashxor's solution could be rewritten purely as an array transformation: "string".ToCharArray() |&gt; Array.mapi (fun index char -&gt; if index = 3 then 'o' else char ) |&gt; (fun charArray -&gt; new string(charArray)) If your code has no understanding of "a string is made out of chars", then it cannot express the concept of "replace the third char with 'o'".
Nice. I have moved to a Cordova app with an F# backend server. Just starting so we shall see how it goes.
&gt;any more "functional" (what do you mean by that?) I beg your pardon, I'm rather new to functional programming and thought that only **chars, strings, digits, boolean** and **lists** were the core functional data-types. The way I devised is generating strings by concatenating chars. The problem is, in this way I must generate every single string up to that one in order to start manipulating it, which is exponentially costly. I may rephrase my question: how can I sort out the issue above just by using these constructs?
Good stuff! Cleaning up an abstract :)
Thank you. you can not pattern match without O(N2). That was my fear.
Seems very positive for fsharp recently, I have seen the excitement from other devs and the photos from BuildStuff have rooms packed with devs interested in ML and/F#
Nifty little guide. There is some discussion with what appears to be the author's reddit tag under r/programming.
Thanks for the confirmation and for providing a link. F# has a lot of awesome features. As I noted on the other thread, my biggest issue (personally) is that most of the doc I've seen (as well as the entire "Book of F#") assumes a high level of C# or at least .NET competency. I'll continue to look into it though. I was reall excited about Scott W's (author of the blog F# for Fun and Profit) upcoming book in December 2014, but alas it has no expected release 1 year later. I'll keep waiting though :)
Can this run on a private network?
Thanks for the recommendation. I want to say I downloaded a sample from Amazon before, but I can give it another try. Another thing I'd like to stay away from is 6 chapters on currrying, recursion, immutability, and map/fold/filter. The hardest part of FP to me is learning how to apply that to make actual code once you learn it. Edit: Once you learn the mathematical concepts.
Obligatory piece of self promotion: these concepts are covered in a C#-pre-knowledge free way in my PluralSight courses, 'F# Jumpstart' and 'F# Functional Data Structures'. https://www.pluralsight.com/courses/fsharp-jumpstart https://www.pluralsight.com/courses/fsharp-functional-data-structures I would also add that I don't think you actually do need much math(s) to understand things such as fold - at least not the way I try to explain them. ;-)
Yeah, but that would require me to be unlazy enough to go looking for one. [](/sbstare) [..okay, fine.](http://blog.mavnn.co.uk/type-providers-from-the-ground-up/)
There are a bunch of links here. https://sergeytihon.wordpress.com/tag/type-providers/
[wat?](http://i.imgur.com/4JOddaI.png)
It's not a bug, just try it yourself ;) http://imgur.com/3Q1Rhbq When you press ↵ in fsi, it inserts '-' character so you can see your multiline input sequence. There're 2 different cases: * *1 - 1* treated as a single expression, because '-' triggers new offset line * *1 -1* treated as two lines where '-' acts as a unary minus. In this case F# just returns to you the last statement
Ideally in the second case it should warn you about the fact that you're ignoring a value of type int.
The first `-` is a prompt continuation, it's shown when running fsi from the command line but not in VS.
Well, it warns you when you do the same in a source code.
This is a much better explanation than I could have given, thanks!
He followed this up with another related post, [MSDNifying Types via TypeProviders](http://trelford.com/blog/post/MSDNify.aspx), where he groups the memebers by category as MSDN docs do.
MSBuild works off fsproj files and I think it is generally smarter about locating system dlls. It also is the standard place to specify references. In the end it just invokes FSC though. Still, I think it _should_ be possible to do it all with Fake, you just may need to replicate some of the helpful things that MSBuild does for you. I too have wanted to use fsharp outside of the fsproj context and it seems like you have a good start with Fake. As an aside, I was working on a similar project a year ago that would allow me to have a "grunt watch" style coding loop in F#, by running everything from Fsharp Interactive. So you didn't need to "build" from an IDE, it would just rebuild and re-run inside FSI on each file save. It sorta worked, but needed some refinement, and I still assumed that the reference list was in an fsproj file, so it isn't really your use case. It does show how FSI can pretty powerful though: https://github.com/jmquigs/FSIRunner 
i gave up on xunit and went with nunit, and locked myself to net45. no system issues after that. (might be coincidence.) yeah, that was my thought, re: problem with dlls. i may try.
i was hoping to stay outside of project scaffold as it is a very heavy project file imo. perhaps i can see about reusing its component to generate the fsproj, but then, what are the things that read that file? back to ides, right?
awesome i love that! thanks for sharing.
I understand that this is a shameless plug, but at Hogeschool Rotterdam (in, you guessed right, Rotterdam!) there is a college-level course in functional programming that focuses heavily on Haskell and F#. It is not intensive, in the sense that it last three months with once-a-week lectures, but it might be possible to organize something shorter. Let me know by PM in case of more interest.
Most importantly (to me) msbuild and xbuild use the solution and project file for compilation. I use emacs and the fsharp plugin also uses it. I suspect the vim one does too because the same people maintain it. Sometimes I find project scaffolding too heavy so I spend some time deleting stuff early on. I know some people made their own similar but lighter thing, but after some searching I could not find it.
And it is FREE :-)
Looks like it should be good. I'm wondering if it's worth the time to learn F# on a Linux system without VS? Any tricks as to the best path to installing, editor preference, etc? (I ask cause I'm hoping to spend some focused time over the holidays learning.)
I would like to try Atom. I have heard stories about emacs being used too, might be worth an experiment. On fsharp.org there are guides for Linux. 
I have been using OSX (also have it working on Linux) with Mono, Emacs (with Vim bindings, and fsharp plugin https://github.com/fsharp/fsharpbinding) and F# for 9 months now with great success. I actually like it better than Visual Studio because its so much faster and lighter. F# Support in VS isn't great so you don't miss much. I installed Xamarin Studio first, and it setup all the Mono bits, then it was just installing the rest via package manager. Emacs/Vim have a learning curve but if you have someone to guide you its not too bad. Frustrating at first though =)
Although I haven't used it for this course, I've used [MonoDevelop](http://www.monodevelop.com/) on Ubuntu with success. If you want NuGet package support, you'll need to install [this](https://github.com/mrward/monodevelop-nuget-addin) addin. 
As it wasn't clear in just this article, he's supplying a solution to [Day 16](http://adventofcode.com/day/16) of the daily [Advent of Code](http://adventofcode.com/) challenges.
What are you using as a build tool?
I'm using vim-fsharp on manjaro and antergos. Building fsharp from source, using yeoman fsharp generator. Working great.
Already run out of games things to be mad about? In any case, if we wanted to have a discussion about whatever is going on in FSharp, I would rather we linked that and discussed that directly rather than discussions from some forum of upset gamers.
So, uh...not that I have a massive opinion on either side of this issue in particular, but I don't see "\#GamerGate" anywhere in the Github PR about the CoC. So....why not just link to the PR itself and let people form their own opinions, rather than pulling in some unrelated controversy and jumping to partisan language ("CoC censorship")? Doesn't the "CoC way" at least claim to be inclusive and not to simply throw ad hominems around? And doesn't the "NCoC way" at least claim to be meritocratic in its decision making without giving into petty squabbling? This headline (and linking to a heavily-biased comment section rather than the PR itself) is not in the spirit that either side claims to hold to, I think.
Perhaps a long-shot, but are you running Visual Studion 'as Administrator'? In the past this seemed to solve some permission problems for me, so might be worth a try.
I've tried that :/, im on windows 10 so by default it seems that the documents folder is read-only. I set vs to run as admin a while ago to get it working for c++/c# projects. Thanks though!
I also strongly disagree with the Contributor Covenant code of conduct being associated with the core F# distribution. However, this is not the way to go about resolving this. When you make oblique references to nefarious, shadowy "corporate power" and "social justice harassment", you're painting yourself - and, by extension, the rest of us dissenters - as foaming-at-the-mouth conspiracy theorists. I think this deserves a respectful community-driven debate, but you're already trying to draw battle lines.
If, like me, your contributions are automatically down-voted by corporate cucks and social justice harassers, then this is the group for you!
&gt;corporate cucks please go
But, as you can see, I have only gotten started.
You're not the only one who's unhappy about the code of conduct. I think it's unwarranted politicization at best and entryism at worst. But if you turn this into a fight between two competing groups trying to take over the F# community - one that uses the term "cuck" unironically and one that professes respect and equality as its goals - then we already know how it's going to go. The mainstream attraction of the brand of social justice activism you so despise is as an antidote to the kind of rhetoric you spout. Don't go and fuck this up for all of us.
I'm not so afraid of the consequences of truth-telling. I am now putting all my capital and efforts into severing my financial dependency on the commercial software industry. How many have done the same? What you must admit, however, is that people's careers are being attacked for fighting your purported enemies. Perhaps not as gracefully as you pretend yourself to do so, but with potentially much more efficacy.
So rather than throwing rhetoric at one another, look at our manifesto, and tell me that you actually disagree with any of it - http://justpaste.it/puzu You will have to admit that this fight is much bigger than you have supposed.
I think "meritocratic principles of governance" is a problem when you have discrimated groups that are discouraged from joining in, and therefore are less able to prove their merit If you tolerate language and behavior that excludes certain people based on irrelevant attributes like race or gender, then you are kidding yourself that you are "meritocratic"
&gt; 3 users online now of 7 registered. Oh noes, the revolution is coming.
Maybe your manifesto would seem more serious if it wasn't on a paste site? I'm not going to expend the mental energy to review it if it's just side-of-the-napkin stuff.
I don't understand what problem this is solving. I see that you don't like a code of conduct, but I don't know what your specific issues are with the code of conduct. Other projects have adopted codes of conduct and it seems like the benefits have outweighed any harms they've caused. So without having any personal issues with the code of conduct, I'm not going to go join some fork of the F# community because maybe you feel you've been slighted somehow.
What I'm getting at is, ideally, the censorship keeps the focus on the real topics - neither intolerant language or irrelevant "SJ" comments need be included when talking about fsharp. For example, why bring up the article was written by an "African-American Liberal Academic"?
It's part of a much broader group of issues - Here's the WIP manifesto - http://justpaste.it/puzu
And yet you're attempting to fork the fsharp community, in effect, and spamming this sad code of conduct business instead of furthering a project with intrinsic value. Are we to believe your domain knowledge of the legal concerns of operating an OSS-centric nonprofit exceeds that of legal counsel who, among others, advised the adoption of the CoC? FFS, you seem entirely unwilling or unable to frame the discussion without resorting to [pejorative insults](https://www.reddit.com/r/fsharp/comments/3xurif/alternative_f_functional_programming_slack_chat/cy7y45q) and can't go 3 sentences without invoking "SJ" demons, sans clear examples of the harassment or censorship you're complaining about. I don't speak for anyone else but I don't care about your contributions to the FSSF if you can't act like an adult in the face of people who simply disagree with you.
Of course, you can't possibly be responsible for your actions, you were forced into acting like a child, right?
Here's more detail, from my upcoming article - "Anatomy of a Corporate Cuck - A ‘cuck’, in internet parlance, is someone who gives their loyalty to an undeserving party, usually out of cowardice, misguided belief, or for selfish personal gain. A corporate cuck, then, is one who applies this loyalty toward a corporation or another participant therein, either to the detriment of others, or to necessary institutional or scientific integrity." You can label the statement what you want, but it won't make it any less applicable for the most part. But again, if you think you can run this organization better than me, I'm happy for you to join up and give you enough rope to succeed. I only started this thing because no one else was. Never said I was terribly qualified. All I wanted to do was fucking code, but these people have consistently made that either undesirable or impossible.
You haven't shown the slightest ability to reflect on your actions so far. That doesn't just make you unqualified to lead an honest, reasoned debate, it suggests you have much deeper issues than are under consideration here. You could have raised these points in the context of real examples of stifled speech and probably would have gained the support you need but you haven't shown anything (that I've seen) that isn't drenched in hyperbole, vindictiveness, and arrogance. I don't wish you any ill will but I don't see any reason to support this endeavor.
Okay, so here's what you don't understand. It's not my task to give a million personal anecdotes as to why you should support something you don't already. I'm building a social platform for people who have already experienced these problems, and who are already fed up. If you're not one of them, fine. I'm not sure how providing that platform for people is either vindictive or arrogant, but if you wish to hand out judgment and insult to everyone with whom you do not already share experience, well... It's time for you to look in the mirror before offering up a critique. Especially someone who tells everyone else how unreflective they are.
&gt;Okay, so here's what you don't understand. Pontificate if you like, you don't know anything about me, you have no idea what I understand, nor what I stand for. Merely by being unmoved by your rants, you've decided you can measure my perspective, as if your arguments were so persuasive that no one with any sense could possibly differ with either the substance or delivery. And in lieu of *a million* personal anecdotes, you gave zero--among several examples which demonstrate that nothing of substance supports your arguments. Take your toys and go home if that makes you feel like you're doing something important but so far you haven't done a damn thing.
I know one thing about you - You don't have much sense of irony :)
"All I wanted to do was fucking code, but these people have consistently made that either impossible or undesirable." How could they possibly stop you from coding? Aren't you the one in charge of your typing fingers?
An assessment at least as accurate as the rest you've given. Have fun with your persecution complex, I'm sure it'll make you happy.
We should be so lucky.
So now you are hoping death on a person with whom you've had a short argument on the internet, shortly after claiming the high ground on both social interaction and psychological health. Hmm... Yes, while I'm not arrogant enough to diagnose people with psychological disorders that I've never met, I still stand by my statement in regards to your lacking in any sense of irony :) That all being stated, this is why we need a community without people like you. You've exhibited most of the negative traits of the people and institutions we want to provide an alternative to.
Awesome, just about the same time as the Haskell org was [granted 501(c)(3)](https://www.reddit.com/r/haskell/comments/3xtoxl/haskellorg_is_now_a_501c3_charity_in_its_own_right/)! Glad to see these steps forward to help the functional community become more and more of a mainstay in the industry.
:o what is going on here? what's the deal? can somebody give me a short summary?
As someone who works daily with xml and xslt, I found this very interesting. I wouldn't mind seeing the shrinker implementation as well. 
Try this one: [1..12] |&gt; List.sumBy (fun x -&gt; x * (13 - x));; *edit*: You don't even have to do this iteratively, here's a general function: let presents day = (day / 6.) * (day + 1.) * (day + 2.) Which for the twelfth day gives: &gt; presents 12.;; val it : float = 364.0 
As far as expressing the intention is concerned, your code is as good as it gets (apart from maybe replacing `|&gt; List.map f |&gt; List.sum` with `|&gt; List.sumBy f`). In terms of optimization, as /u/knubbze said, there are mathematical simplifications that can be done.
Also, a fork doesn't magically make a CoC go away from the main repo.
Go back to your video games and let adults continue working.
Or just C#/F# (or OOP/FP in general) comparison.
&gt; As far as expressing the intention is concerned For this reason, your code is just fine.
How much time can you spend on the topic?
My answers: * I can spend ~2 months * My other interests are open data, finance, insurance. I know, sounds boring, but it's really ok :) Can be stock data/Bloomberg API. Ok, I'm also interested in brazilian jiu jitsu, that may look a bit more like fun :) * Skill level - have some experience in C# * No constraints. I haven't chosen tutor yet. And AFAIK, implementation of a thing (type provider) is also allowed. I agree Bioinformatics is cool; concern is, I'll need time to familiarize with domain. Arduino is fun too, but, as I see, may be not the best area for F# learning. I'm really looking forward for some BLOBA-like application; some simple area where F# would be the coolest part (and bioinformatics and Arduion are already cool by themselves, and worth it's own thesis).
Is it me missing something or is there a lack of correspondence between the illustration and the code? I would have expected the green and orange nodes to have at least one child as they are illustrated as sub-trees and not leaf nodes.
* About WebSharper (full disclosure: I'm a developer on WebSharper): it used to be closed source a few years ago, but it's now [under Apache license](https://github.com/intellifactory/websharper), and only some extensions for JavaScript like Sencha are closed, so there shouldn't be much worry in this regard. Support wise there are paid packages, but we're also active on [the open forums](http://websharper.com/questions). * About Mono: I too think things are looking up, especially since .NET Core came out and they've been collaborating with each other. * Community: I don't know that much about the Clojure community, I think it is indeed bigger but not overwhelmingly so. * Microsoft: there's indeed been a visible lack of commitment from them, but given the exponential increase in community involvement in the development of the compiler over the last 2 years, I think it's not too much of a problem.
I have a similar background (Delphi, Python, C#, Obj-C) and think F# is great. Clojure have a lot of good ideas, but the syntax is off-putting for me ;) However, is true that the Web story with F# is weak, even more than C#. More exactly, you will not find anything *in the league* of Django, flask or rails (don't know if truly better on clojure). And acces DB other than Sql Server is problematic outside windows. Anyway DB acces is one of the weakest point among languages, when you have know better ;) In the other hand, you have .NET there, so you can workaround. I *believe* clojure is much more in do things *clojure way* so is necessary to re-implement more (is this true?) About Mono: I don't see any big trouble with it. I do everything on OSX with F#. However I don't have do big deployments, but suspect all is ok. Now with the .NET core things are improving faster - About Community: Well is a functional language so you found a lot of folks scaring little kids with monads, monoid and stuff like that, but in the other hand you find places like http://fsharpforfunandprofit.com/ where things are more sane. In fact, despite I have read about haskell first, F# feel better because the community is not THAT CRAZY about functional-speak-worship 
Ah, WebSharper is open-source now! Cool. Rooting for you guys! Will definitely take a closer look. A follow-up -- what WebSharper tooling will I be missing out on by using vim instead of VS or Xamarin Studio?
&gt; Web -- my biggest worry. I read a bit about WebSharper and FunScript -- first impression is that both are nascent at best, especially compared to the traction that ClojureScript has. I do like WebSharper's approach, but am wary that it's commercial/closed-source (not that I mind paying a fair price, just I fear it won't get traction). I don't do web programming myself but I've tried to play with both Funscript and Websharper. When I tried Funscript the sin and cos functions didn't work so I had to write my own trig functions using CORDIC algorithms. When I tried Websharper I found the docs hopelessly out of date and impossible to follow. So I gave up and still don't do web programming. Why would anyone want to do web programming anyway? &gt; .NET -- is my bullishness about Mono misguided? (I have little interest in the Microsoft ecosystem per se.) Should I diversify and get to know the JVM? .NET on Windows is absolutely freaking awesome. WPF is freaking awesome compared to anything else I've ever tried on any other platform. Mono has been awful for many years but it is finally getting better now that they are replacing its rotten core. I did some F# development on Android and that was great. &gt; Community -- A Clojure friend (who respects F# a lot and isn't the language religious war type) estimated the Clojure community to be an order of magnitude bigger than F#. Is that true? Absolutely not, no. Clojure is a bit bigger than F# in the US where everyone still starts from Lisp rather than ML because of NIH syndrome but across the rest of the world F# is bigger. &gt; (Stack Overflow questions and Reddit subs don't bear that out.) More generally, what is the difference in communities, not just in size but style? In particular, is there a coherent/strong shared value/vision/opinionatedness across the community? (A la Python folks being "Pythonic" or is it more generalist and free-for-all like C#?) If so, what are the differences in programmer values? I've never been a member of the Clojure community so I don't know a great deal about them but I have following Clojure for many years and was a prominent troll in the Lisp community for years before that. My impression of the Clojure community is that they are the more practically-minded and forward looking Lispers with substantially fewer smug weenies but they often come across as script kiddies compared to the F# community because Clojurians often lack theoretical foundations. Even Rich Hickey himself has no formal background and, to me, he often comes across as a child stumbling upon great theories for the first time. This comes across most often in the context of type theory where people from the Clojure community are mostly completely clueless. &gt; Microsoft -- everyone says they aren't really behind F#. Is that true? Does it matter? Microsoft are definitely not behind F#. Microsoft don't give a shit about F#. Does it matter? Well, if Microsoft had backed F# as they promised they would then it would have been given a big fanfare when it was first released in April 2010 and millions of .NET developers would have given it a try and many would have loved it and continued to use it for real work and an entire ecosystem would have flourished around it. Instead they didn't even mention it, our commercial F# products didn't sell at all after the launch event as a consequence and F# continues to languish in obscurity, dismissed by most professional software developers as a mostly-academic-plaything. So, yeah, it matters. &gt; Can/will F# flourish independently? I don't think F# will flourish independently in the sense that it will never have a particularly big community. For example, I don't think F# will ever reach the popularity that Python has reached today (which is still an order of magnitude less than C#). Basically, every single time the F# team at Microsoft catch a break and have the chance to do something amazing they drop the ball. When F# was first commercially released as "first-class .NET language" they forgot to put it into Visual Studio and it was relegated to a separate download (WTF!). When Ballmer offered them anything they needed they said "nothing thanks" so, for example, most MSDN documentation has F# missing (WTF!). When Microsoft had a massive push on WinRT when the Surface RT was released the F# team didn't bother getting F# to work on it at all (WTF!). When the F# team asked users what they wanted on User Voice, the users all replied "IDE tools like rename refactor" so the F# team ignored them and did type providers instead (WTF!). I just bought a new Windows 10 laptop and installed VS 2015 Community with F# and tried to use my existing code that uses type providers and they don't work apparently because nobody at Microsoft has added support for Windows 10 yet (WTF!). I do think you will be able to solve a lot of real problems well using F# though. 
Yeah, there isn't much worry about Microsoft pulling the plug, the issue is more that the plug was never big to begin with.
Without getting too involved, I'm gonna claim that you should never be worried to learn a programming language. It brings new skills, knowledge, and paradigm practice. F# is based on ML, so you'll be able to use languages like OCaml easily. Practicing functional will help you naturally transition into Lisps like Clojure and ClojureScript smoothly. F# has access to the ridiculous .NET libraries, so you can make actual things that do stuff fairly quickly. Apply that kind of posititivity and learning almost any language is valuable. And the more languages you use, the less time it takes to learn new ones, since similar paradigms usually means similar syntax. So jump in. Stop worrying and learn to love recursion!
If you are familiar with .NET and like Python syntax, then F# is a no-brainer, imo. But they are both good languages, so why not learn both? Or at least spend a few weeks with both. In my experience, working with the same ideas in different languages deepens your understanding. And after a few weeks, you'll have a better idea of what appeals to you. It sounds like you are interesting in learning for personal reasons right now, so I wouldn't worry about commercial traction, etc. Once you learn the FP paradigm, you can transfer most of that knowledge to other languages (although some concepts used in typed languages are uncommon in dynamic languages and vice versa).
This is probably too much for a single Stack Overflow question, but I'm not even sure where to start. let rec cast&lt;'a&gt; (m: MemberInfo) : 'a = match m, typeof&lt;'a&gt; with | (:? MethodInfo as m), ty when FSharpType.IsFunction ty -&gt; failwithf "Not implemented" | other -&gt; failwithf "Not implemented" Higher-order and generic functions promise to be a headache.
What was it before?
congrats!
I'm well aware of the enormous technical achievements of the OCaml community, and I have unreserved admiration for that. But we're teaching to first- and second-year students. When we taught OCaml, we asked them to use Emacs in tuareg-mode. Many of them came out of that class with a burning hate for both Emacs and OCaml. The learning curve just didn't work out. These days we're doing F# + Atom. Only two lectures in, and students have been using the MSDN documentation to get a head start. The hype is real.
How so?
Thanks, this was a great writeup!
&gt; For those of you who have switched to F# from C# and work with F# on a daily basis, how has your transition experience been? Flawless. Never looked back. &gt; What percent do you do F#, and how much do you still code in C#? 100% F# and 0% C#. &gt; I'm seriously considering taking a deep dive into F#, but the lack of tooling compared to C# is giving me second thoughts. I appreciate any insights you can give me. Thanks :) Seems like an odd reservation to me. Resharper is used primarily to autogenerate large amounts of code because C# requires large amounts of boilerplate code to do simple things and to refactor between object oriented representations because they are never a good fit. F# doesn't require large amounts of boilerplate for anything so you never need to autogenerate code and unions, records and tuples are a better fit for 99% of the people 99% of the time (I rarely use objects). The ability to rename a variable using the Visual F# Power Tools extension for Visual Studio is useful but I cannot think of any other kinds of refactoring I really want. 
I don't like resharper for any language. Most of the useful features are now a part of visual studio. You should learn f# to increase your toolbox. Learning functional programming should be a goal in your programming life. You will learn some things to take with you.
&gt; Fancy renaming for everything would be nice (types, functions, ...) F# Power Tools has pretty good renaming support. No-one should be using F# in Visual Studio without the Power Tools. &gt; margin icons to run tests The wonderful NCrunch is the way to go on this. It's commercial but well worth it. I paid my own actual money for it. &gt; Go to type/symbol/everything a-la R# Again this is pretty good with Power Tools. The main remaining issue is goto/find references between C# and F# projects. &gt; A better solution explorer I don't see any differences between the way VS behaves between C# and F#, except possibly in the area of creating folders. Again I think this is solved with Power Tools.
Thanks! That looks quite swell.
In the View Model pattern you need more glue code I believe. Pure Views seem to be just one function which receives the current model as input and renders a UI with event listeners and such as output. That's all. Even if you use data binding in OO there is not much less glue code, it just gets hidden. 
&gt; What applications do you primarily use F# for? I develop whatever the client needs. Some recent examples: * [The trading platform that is used to trade almost all oil, coal, gas and electricity in Europe, both client and server side using F#](http://quant.stackexchange.com/a/7138). * [A bespoke business rules engine for the insurance industry](https://youtu.be/WI9bNWzTkxs). * [Translated a compiler to F# for a company who sell to the insurance industry](http://fsharpnews.blogspot.co.uk/2012/09/performance-of-compiler-translated-from.html). * Lots of software to massage and visualize data (e.g. analytics). For example, this [map of the 3D printing landscape](http://www.idtechex.com/research/articles/the-3d-printing-market-boom-22-cagr-over-the-next-decade-00007191.asp) is derived from a database of 3D printers that quantifies build volume, speed, precision, price and other characteristics, groups them by technology, [computes the convex hull](http://fsharpnews.blogspot.co.uk/2010/11/computational-geometry-quick-hull.html) and [visualizes the result using F#](http://fsharpnews.blogspot.co.uk/2013/09/f-for-visualization-07-released.html). &gt; I've been toying with the idea of using it to create data analytics reports but I'm primarily a web developer so I don't see switching from C# anytime soon. I don't do any web development at all. In fact, after a decade of using OCaml and now F# I looked at the web developer's tool stack, cringed and ran away. The whole of the web stack looks like an absolute disaster to me. I personally hate web apps. I'd much rather have a native app. 
As far as I'm concerned it's still functional since it has no side effects and results in the same answer with the same input. A lot of code in fsharpx and other libs do the same thing, they do mutation hidden in a stack based function for perf reasons, but unlike imperative styles, that mutation never leaks out 
Arrrrgh!!! &gt; it is totally un-F# Absolute nonsense. The whole point of F# being an *impure* functional programming language is that it is absolutely fine to write code like this when you want to. In point of fact, a language like Haskell would do a lot more to optimise this kind of functional code (e.g. stream fusion). F# does not bother because there is no point: if you want performance you can only ever get it by using mutation. &gt; It may as well have been written in C++! Except you have memory safety and a multitude of other benefits. Here's a purely functional solution that runs 25x faster than the pure code you found on the internet and 2x slower than your mutable solution: let genNext (input: ExtArray&lt;byte&gt;) = let rec loop n i c (output: ExtArray&lt;byte&gt;) = if n = input.Length then output.Append(i).Append c else let ch = input.[n] if c=ch then loop (n+1) (i+1uy) c output else loop (n+1) 1uy ch (output.Append(i).Append c) loop 0 0uy input.[0] (ExtArray(())) Assumes the existence of a purely functional alternative to `ResizeArray` called `ExtArray`. I'll leave that as an exercise for the reader (and publish my version in the F# Journal!). 
&gt; Why is it slower? You pay a performance price for the ability to reuse old versions of collections even if you don't reuse old versions. &gt; I thought CLR had tail call elimination, thus it should be possible to make a recursive version that is just as fast (or at least very close). The CLR's TCO is actually not used here because this is self recursion so F# converts it to jumps. Goto is ~2x faster than a CLR tail call. &gt; It would maybe not be totally pure, but would it not be just as fast? Oh, if you rewrite the loop as a recursive function but still use a mutable collection then it is actually slightly faster. 
The timer is breaking the responsive theme on my phone. Its minimum width is too large.
Not [the lenses I was expecting](https://www21.in.tum.de/teaching/fp/SS15/papers/17.pdf)
As others have written, F# is designed to be impure. So functional style is just one acceptable way of writing an F# program. The post reminded me of another question that often comes up reading other people's, or my own, code: when does performance trump code clarity? There have been many times when I have come across code snippets which have stunning performance or are incredibly clever but are difficult or impossible to read. These strike me as difficult to maintain but do the job perfectly. So, like performance vs functional style when does performance trump code clarity?
I really enjoyed this talk. He has many others as well which you can find on the right side of his website [F# for fun and profit](http://fsharpforfunandprofit.com/) under the Slides/Videos header.
I always thought FP was an umbrella term for programming with the lambda calculus, I guess I never thought of it that way. Interesting.
Thanks for the great explanation, that made sense to me. I have a lot to learn to become even semi-competent in F#, but I'm working on it.
It deals principally with a functional services architecture. No other cases. It is concise and dependent that you look in detail at the example code. 
Wow. Didn't realize Bertrand had a radio show. He's also one of the authors of [Orchard CMS](http://www.orchardproject.net/) in case people weren't aware.
My biggest question would be, "Why have CacheManager?" I would just leave it at an ICache list. By putting the ICache list behind a name, you are forcing yourself to add a bunch of wrappers around standard List operations.
So say there are 100 points in my codebase where I will be getting something from the cache. The item could be in the IIS cache, or an external redis cache. I will implement ICache for each of those caches. I want to try the IIS cache first because it is faster, redis cache otherwise. I don't want to repeat that logic 100 times in my code base, I just want to call CacheManager.Get(key); and have CacheManager take care of it. Does that make sense? The "add" case you could pretty easily just use map or something like that but Get and some of the other methods I am not showing here will be more involved. 
Wait... so you set once in the cache manager and it gets placed in *all* of the caches? Ok... I guess. But then you only retrieve from one. So really you're duplicating data for no real reason.
Iis will purge things as memory fills up. Redis will keep it longer. Stackexchange usses this approach.
Why cache untyped objects? It costs you nothing to create generic caches for distinct types, and if you do find yourself in need to store mixed-type objects you can always create an ICache&lt;object&gt;. My take on it: type ICache&lt;'a&gt; = abstract member AddForever: string -&gt; 'a -&gt; unit abstract member Get: string -&gt; 'a option type CacheManager&lt;'a&gt; (caches: ICache&lt;'a&gt; list) = member cm.Add name thing = caches |&gt; List.iter (fun c -&gt; c.AddForever name thing) member cm.Get name = caches |&gt; List.tryPick (fun c -&gt; c.Get name) // usage let trivial = { new ICache&lt;int&gt; with member this.AddForever _ _ = () member this.Get _ = Some 5 } let cm = CacheManager [trivial; trivial] cm.Add "asd" 10 cm.Get "dfkdmvldm" |&gt; Option.map (printfn "%i") 
Gotcha. I don't think I've ever seen a system that was utilizing multiple caches. I guess it makes sense, depending on your needs.
Thanks, this helps too. I was totally lost on how generics worked. 
IMHO - I wouldn't even create a WebCache class. Just use [object expressions](https://msdn.microsoft.com/en-us/library/dd233237.aspx).
Thanks, I'll read up and think on that! 
Clean and concise. Great examples too.
aha, I have the solution: member this.GetCountStartsWith keyPrefix = HttpRuntime.Cache |&gt; Seq.cast&lt;IDictionaryEnumerator&gt; |&gt; Seq.sumBy(fun e -&gt; match e.Key.ToString().StartsWith(keyPrefix) with | true -&gt; 1 | false -&gt; 0 ) Is anyone familiar with what happens behind the scenes when I do a cast like that? Is it making a copy of, or iterating over the whole list ahead of time? 
Thanks, good stuff! 
There, "Cloud Services" are not cloud services in general, but rather one of the specific types of cloud services offered by Azure, which goes by no other name than "Cloud Services", or "Cloud Services (Classic)" in the new version of the Azure portal. They do not have the continuous integration options that the newer services do. VSTS (formerly VSO) can only integrate with the newer variants. (Or rather, they can only integrate with the newer service types *from the Azure portal side.* Perhaps there is external tooling / tooling on the VSTS side to integrate with the classic version, but I am unaware of it.)
As far as I know there is no book really fitting in that niche. You can´t really avoid having to books as your companions: * Expert F# 4.0. Indispensable for the experienced programmer and if you´re having little or no experience with .NET but, again, are an experienced developer, than have * C 6.0 and the .NET 5 Framework, 7th edition alongside it http://www.apress.com/9781484207413 http://www.amazon.com/gp/product/1484213335?keywords=C%23%206.0%20and%20the%20.NET%204.6%20Framework&amp;qid=1454434862&amp;ref_=sr_1_1&amp;sr=8-1
Thank you for your helpful response. Expert F# looks like a great book. It also caught my attention in my first book scan. Why do I need the second book? It's huge.
This website sorta targets C# developers but don't let that sway you, it should get you going: http://fsharpforfunandprofit.com/
Am I the only one who really doesn't like that site? Most of the time it's unhelpful, and the difficulty level can be uneven within a single article.
&gt; Am I the only one who really doesn't like that site? Yes. :P
Thank you. I will take a look at it.
"Expert F# 4.0" is a reference book, definitely worth having it
If you know another functional language i would say Expert F# 4.0. If you have no previous functional language experience, go for Functional programming using F#. 
It's a couple of F# versions out of date, but my favourite for people new to the language is Chris Smith's "Programming F"'. The differences in the language since the book came out are relatively minor. Combine it with Expert F# 4.0 and you're winning! http://shop.oreilly.com/product/0636920024033.do Also here's the obligatory plug for my Pluralsight Course: https://www.pluralsight.com/courses/fsharp-jumpstart
I have been exposing myself to functional languages pretty intensely in the last year. I tried Haskell, PureScript and my favorite so far for client side is Elm. I started taking online the suave tutorial here: https://theimowski.gitbooks.io/suave-music-store/ So I think I'll go for Expert F#. 
Thank you all for the insights!
I don't have a pluralsight subscription yet but this might change in the near future. :) I heard that they have great content. Thanks!
Some time ago I wrote this blog post: [Reading List for F# Learning](http://jorgetavares.com/2015/01/01/reading-list-for-f-learning/). Just replace Expert F# 3.0 with 4.0 and the text is still valid. A few things came out since then but not enough to make me want it to update it. It's also my opinion on the topic!
Agree, I don't like it much. And pointing you to a tutorial that uses Silverlight doesn't exactly fill you with confidence. UPDATE I spoke too soon and was getting confused with the official site. You're directed to the Silverlight tutorial from "fsharp.org" not the site we're talking about here.
http://app.pluralsight.com/signup -- see '10 day trial' button at bottom. ;-)
The F# libraries are not really optimized for speed. I suggest you write your own reduce and mark it inline. Then the lambda will be integrated directly into code. You can even make it a type extension - then it will have a pretty syntax, too. Many things generic are also slow in F# unless you write them yourself: generic comparison, generic hashing... even some math functions such as Operators.pown. 
The only "flaws" I can see in your tests are * 7 ms is on the brink of stopwatch'es precision - add more elements * no jit warmup - call the code several times * try inline if your gut feeling thinks thats the issue well I've tried all 3 things and the results are the same as your findes. More or less (by doubling the number of elements my timings also doubled) reduce sequence of list = -2004260032 - Time = 122 reduce array = -2004260032 - Time = 26 for loop array = -2014260032 - Time = 7 reduce list = -2004260032 - Time = 28 
Related to a post I saw [just recently](https://zeckul.wordpress.com/2013/08/09/the-fastest-sum-in-f/) that investigated how those simple reduction were compiled into assembly code. You should get a lot better performance with [Array.sum](http://pastebin.com/HVMuUpYF). I had to convert the array to a series of ones otherwise Array.sum would throw an overflow exception. In addition, your imperative loop is off by 1. :) It is interesting that the imperative loop is a lot slower in interactive mode than the Array.reduce. In fact it is nearly 7 times slower on my machine. The library calls however are not affected.
* Seq is very slow partly because `IEnumerable` imposes many overheads and also because the F# compiler does not bother to optimise them much (whereas the C# compiler does, for example). * List is slow because the argument `+` incurs dynamic dispatch and the list collection is not contiguous. * Array is slow because the argument `+` incurs dynamic dispatch. * The imperative loop probably still suboptimal because of bounds checking. 
Interactive should not be slower, I think. Have you enabled --optimize in fsi?
I have script debugging enabled, so maybe that is what is eating it? Yeah, generally disabling script debugging improves performance for the loop and reduce tests, but for some reason the Array.sum test becomes 2x slower. In general the performance is still 2-3x below that of the compiled executable. I've increased the number of elements by 10x to 100 million in both the list in the array. Here are the times I get: Compiled executable: * reduce sequence of list = 100000001 - Time = 741 * reduce array = 100000001 - Time = 151 * for loop array = 10000000 - Time = 5 * reduce list = 100000001 - Time = 239 * Array.sum = 100000001 - Time = 78 With script debugging off: * reduce sequence of list = 100000001 - Time = 676 * reduce array = 100000001 - Time = 135 * for loop array = 10000000 - Time = 13 * reduce list = 100000001 - Time = 203 * Array.sum = 100000001 - Time = 314 With script debugging on: * reduce sequence of list = 100000001 - Time = 878 * reduce array = 100000001 - Time = 254 * for loop array = 10000000 - Time = 31 * reduce list = 100000001 - Time = 366 * Array.sum = 100000001 - Time = 174 ~~The for loop is so fast that I am suspecting the compiler optimizes it away. I'll try it with random numbers.~~ Strange about the Array.sum. This might be some kind of compiler or library bug. I'll post this on the F# Github as an issue. ~~I tried it with random numbers and the performance is the same. I guess it did not get optimized away.~~ The lesson, yeah you should code your own reduce if you need absolute performance on large array or even better, use a library like MathNet. ~~I guess this is a point in favor of templates vs generics that .NET uses.~~ Also while I was testing, the list with 100M elements caused out of memory errors even though I have 8GB of ram. Lists are sweet with pattern matching, but they are so bad in terms of efficiency. Edit: Actually, I made an embarrassing error in the for loop. I forgot to increase it by 10x which is why it is so fast in the above. Here are the corrected timings for the imperative loop. Script debugging on: * for loop array = 49996432 - Time = 463 * Array.sum = 49996432 - Time = 173 Script debugging off: * for loop array = 50003982 - Time = 245 * Array.sum = 50003982 - Time = 250 Compiled with full optimizations: * for loop array = 50003982 - Time = 71 * Array.sum = 50003982 - Time = 78 Edit2: I've noticed that removing and adding the --optimize switch in F# Interactive options does nothing. Also the performance I get in F# Interactive is the same as compiled with no optimizations. Edit3 (16 days later): I waited a bit for an answer and then ended up doing some study on IL assembly on my own. When I disassembled the thing using dnSpy I realized that the IL code is the same between script debugging off and compiled. Probably the performance differences are due to the JIT optimizer or something else. A bit anticlimactic if you ask me. At any rate, the erratic performance above is not related to F# it seems.
What the hell? Erase this.
If you are coming from a Linux or OS X environment, much of the F# material and blogs assumes that you already know C#, are using Windows and Visual Studio. It's understandable, but annoying. 
Yes, I'm getting the exact same results on compiled and interactive. Here are the times for summing 100M elements x 10: * for loop - 0.99s * Array.sum - 1.20s * Array.reduce - 2.25s * for loop using System.Numerics SIMD - 0.37s 
That's what the partial application is for in Module C. It's limiting the exposure to that threading process.
I'm pretty new to F#, so I thought I'd try my hand at it as well =) (http://pastebin.com/TZVzjGrZ). I omitted the web client stuff, because you said the point you are trying to make is about design/testability. Any thoughts on it?
He does too much apologizing in the updates. &gt;. Yes, I know that no one sensible would ever do this Sure they would. I seen it! 
Besides, even if they would never do it on purpose, mistakes happen. The difference is, when the mistake is discovered - immediately, or at compile time, or maybe after hours of hair pulling...
I've been playing around with F# for a couple of nights now and it's starting to grow on me. I looked at it before and thought it looked weird and not something that would interest me. I've done a bit of Python since then, liked its functional aspects, its less verbose syntax, the lack of boiler plate and was looking for an alternative to C# (but thought Scala would be too much as I'd need to learn the JVM). So I thought F# - running on a stack I'm very familiar with - was definitely worth another look. So, there's some reasons to use it. But. I work in the Linux world now, I develop on my Macbook and push to CentOS and Ubuntu. I do most of my coding in Xamarin Studio and it is not without its pain points. .NET is a second class citizen in the Linux world make no mistake. I have production code running smoothly on Mono but setting it up and working round deficient libraries is something you need to be prepared for. I'm an experienced C# developer so I can live with this but it concerns me embarking on F# that the aggravation will be worse with a language I'm not familiar with. Is F# worth it for anyone working outside of Visual Studio land? Predictably all the books and many of the tutorials walk you through the tasks in Visual Studio and Project Rider seems like it's only targeting C#. I guess I can get by on poor tooling but I've struggled with some of the libraries and can't use type providers which seems like a core F# feature. It's a shame as F# looks like a great language and I'm sure there are evangelists who can tell me how wonderful some of their code runs on a Debian based system but for someone starting out I can't help feel there are better options.
I am the same way in that I really like what I see with F#, but I run Linux and OSX, and am not about to go shell out for Visual Studio and an OS that is opposite of my preferred workflow. That being said, the probably is less that .NET is second-class on Linux and more that "anything other than Visual Studio on Windows" is third-class in .NET land, and F# is second-class below C# and VB.NET in Microsoft's priority list. As a result the F# community seems much more inclined to build it themselves than the C# "what do you mean non-Microsoft" community. So there are projects like Forge and FAKE and Paket and Ionide. I'd strongly recommend the stuff managed by FSProjects to you as a way of working in the bazaar instead of just the cathedral. 
Lack of a first class IDE isn't a problem for me. I'm a hacker and work a lot in the command line and like lightweight editors (I do a lot of stuff in VS Code now). I did hope F# devs would be a bit more command line savvy and less reliant on the VS comfort blanket but it's still nice when even terminal based tools work. The main issue seems to be getting libraries to run. I've only been using it for a couple of nights so I might be jumping to conclusions, perhaps I'll post back in a week or two with an update :-)
 &gt;Posted by scottw on 26 Jan 2015
Thanks for the pointers, I'll definitely check these out. I'm using fsharpi in iTerm a lot and it's not too bad but could be better so I'd be really interested in seeing how Forge shapes up.
I am a total noob at it, but this is the bash script that I worked up over the course of the weekend. I can't tell you that its secure or correct, but it does work and lets me setup a stock debian VM in ~3 minutes. I assume it will work with a fresh box also. --manually from command line #install sudo #apt-get install sudo #add chris to sudoers #sudo adduser chris sudo #sudo visudo #add #Defaults env_keep += "HOME" #if vm setup virtualbox and enable auto eth1 on device #http://superuser.com/questions/424083/virtualbox-host-ssh-to-guest --actual script #setup mono remotes sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF echo "deb http://download.mono-project.com/repo/debian wheezy main" | sudo tee /etc/apt/sources.list.d/mono-xamarin.list echo "deb http://download.mono-project.com/repo/debian wheezy-libjpeg62-compat main" | sudo tee -a /etc/apt/sources.list.d/mono-xamarin.list sudo apt-get -y --force-yes update sudo apt-get -y --force-yes upgrade #install git sudo apt-get -y install git #install emacs sudo apt-get -y install emacs #install postgres sudo apt-get -y install postgresql postgresql-client #install nginx sudo apt-get -y install nginx #install mono sudo apt-get -y install mono-complete fsharp #make projects folder in /usr/local cd /usr/local sudo mkdir projects cd projects #clone setupstuff repo sudo git clone https://github.com/myrepo/mysetupstuff.git #clone mycodebase sudo git clone https://github.com/myrepo/mycodebase.git #copy bash alias over cd mysetupstuff cp bash/. ~/ -R #copy emacs stuff over cp emacs/. ~/.emacs.d/ -R #setup nginx cd /usr/local/projects/mysetupstuff sudo cp nginx/. /etc/nginx/sites-enabled/ -R #setup iptables rules cd /usr/local/projects/mysetupstuff sudo iptables-restore &lt; iptables/rules-both.iptables #setup systemd to auto launch exe cd /usr/local/projects/mysetupstuff sudo cp systemd/. /etc/systemd/system/ -R sudo systemctl enable mycodebase_server #build the code from mycodebase dir cd /usr/local/projects/mycodebase/Site sudo sh build-debian.sh CopyBinaries #start system service sudo systemctl start mycodebase_server #restart nginx sudo service nginx reload ############################################################################################## #stop here do below stuff outside of a shell script, by copy pasting it to command line #switching to root then postgres messes up the shell script #setup db as postgres user #switch to root #switch to postgres su root su postgres psql -U postgres -a -f /usr/local/projects/mycodebase/sql/000_createdb.sql psql -U postgres -d mydb -a -f /usr/local/projects/mycodebase/sql/001_intial.sql psql -U postgres -d mydb -a -f /usr/local/projects/mycodebase/sql/003_createtables.sql exit exit
&gt; ...output |&gt; Seq.toList... Don't do that. Writing `f x` as `x |&gt; f` is confusing. Just write: List.ofSeq output &gt; ...fun (output:int list)...output.Head... Don't do that. Don't add a type annotation so you can access a property when you can use `List.head` and have the type inferred. And don't use `List.head` anyway because it is a near-invisible source of unnecessary run-time errors. Use the type system to convey the fact that the list has at least one element by using the type `'a * 'a list` instead and get the first element using pattern matching. &gt; let calculateFormScan = List.map convertToPoints &gt;&gt; List.scan (+) 0 Don't do that. Eta expand function bindings if they are point free so you don't hit the value restriction: let calculateFormScan results = List.map convertToPoints results |&gt; List.scan (+) 0 
I run Mono code in production currently and setting it up wasn't without it's pain points. Installing Mono on Ubuntu Server is pretty straightforward but getting a web app running was quite fiddly (lack of docs was the main problem). I've not tried anything with F# yet but here is a tutorial I wrote for setting up an ASP.NET site for production on Linux ... http://coderscoffeehouse.com/tech/2016/01/19/aspnet-linux-setup.html I'm really hoping .NET Core will bring some people over to Linux because Linux and .NET together is a very poor fit at the moment.
&gt; Writing f x as x |&gt; f is confusing. [](/dumbfabric) I've seen this used as the default style in a few projects; as with most style conventions, it largely depends on who is using them. E.g., programmers coming from C# used to calling methods on objects, or even functions or function chains in the "extension method" style, `x |&gt; f`reads close to what they're accustomed.
95% of the F# community ignores Linux. Every time I venture into learning more, Yet Another F# Blog goes into details about Visual Studio, yada, yada, yada... It's discouraging enough that I'm looking at non .NET functional languages that are primary Linux supported or truly cross platform. 
I hear you, Visual Studio is a comfort blanket and I think most .NET programmers would have a panic attack if it didn't exist. Of course it's useful but for other languages the IDE is auxiliary not a core component of the framework itself. I honestly thought F# would be different but my experience thus far has been much as it is with C#. I thought about looking elsewhere but learning the JVM (for Scala) seems daunting whereas I already know .NET framework pretty well. It's a judgement call and I understand why you'd look elsewhere - do I stick with F# despite the pain points because I'll reap the benefit or is the experience so poor that I'm better off bailing out and learning Scala? It's a tough one.
I'm not enamored with the JVM. I'd like to have a cross platform language other than Python, something more functional and performant. I'm thinking of exploring Erlang and Elixir next. (Either that or sucking up the issues of .NET on Linux.) 
How does it compare to Funscript?
There's a FAQ that has a comparison to Funscript here: https://github.com/fsprojects/Fable/blob/master/docs/faq.md Fable takes a lot from FunScript and probably it wouldn't have been possible if FunScript didn't come first. But besides that it's completely a different project, the main differences are: * Fable uses F# Compiler Services to generate the AST instead of quotations. This means it's not necessary to compile to .NET bytecode first. * Fable doesn't generate JS code directly, rather transforms the F# AST into a new one which is passed to Babel.js. This way it's easier to target different EcmaScript versions or module systems when needed. * One of the main goals of FunScript was to keep the full F# semantics, like generics or structural comparison. Fable sacrifices some of the semantics to generate cleaner and more idiomatic JS code. The generated code is structured using ES6 modules, making it much easier to interact with other JS development tools. * Like FunScript, Fable translates TypeScript definition files to build foreign interfaces, but the latter uses plain .fs files instead of .dll assemblies, making it easier to edit the files if needed.
Obviously my sample scenario is a little contrived, and that approach might be more appropriate given the simple nature of the code. My only concern is when you have a class like a WebClient that brings business logic, error conditions, or other complexity that is worth testing, it is sometimes better to give it a decent amount of attention so that there no assumptions working their way into your code. My fear would be that if we blindly wire up a WebClient into registerDependenciesAndMatch() and don't really have a sense of it anywhere else, that we'd have untested behavior. I'm more familiar with this pattern in IoC against imperative languages, so maybe I'm giving it too much emphasis in F#. I'm actually curious what others' experiences are on this.
I really like the look of Elixir - Ruby for grown ups (I actually don't mind Ruby, just joking). And the Phoenix framework is a sort of Rails for Elixir and is past 1.0 and seems pretty stable.
I had a similar situation related to Linux, in that all the good machine learning libraries are primarily Linux and secondarily Python and it is a pain to get them even to work on Windows. During my learning period, I actually had to install Linux just to get Tensorflow to run and now the partition is mostly wasting 100GB on my SSD. It was quite a wakeup call after spending a lifetime in Windows land having everything spoonfeed to me to suddenly find myself a second class citizen. My experience with Linux has not been great either, while everything is free, everything is also broken and I can't remember trying to do a thing without hours of painful debugging. In the end, I just wrote my own library rather than switch OSes and languages. I've never tried the language, but from what I read, Ocaml is similar to F# and works just as great on Linux as F# does on Windows. If I ever had to work in Linux, I would personally give it a try as I know the skills would be transferable from one language of the ML family to the other. Also why would anybody prefer to not use a IDE? Intellisense and autocompletion and all the other goodies are great!
My switch to Linux was for similar reasons - I had problems getting stuff to run on Windows. Customer requirements had me using open source frameworks and I just found that people didn't test stuff on Windows and in the end I found running Wordpress, Rails, Node etc had me worrying less that I'm going to hit problems with a rudimentary part of the stack. You missed my point on IDEs. Of course they have their uses but I said they should be secondary to the language and I feel for many .NET developers this isn't the case. Personally I find VS too bloated, I like code completion and a good debugger is something I sorely miss on Linux with Xamarin Studio but most of the rest I find gets in the way. Not tried OCaml - it does look exactly like F#. I played a bit with Haskell but it doesn't seem like its used much outside academia and I fear that's the case with OCaml. I'm with "xradionut" - if I have to pick another option it'll probably be Elixir.
Awesome, thanks for sharing!
The problem isn't Visual Studio and IDEs, the problem is Windows. I still develop on Windows for work, but I'm 100% Linux at home, not counting the spouse's computers. I'd love to have VS for Linux, but hell would probably freeze over first. I really like F# as a language, but if they, (advocates), want to crow that it's OSS and cross platform, then more than a handful of primary core developers have to commit to promoting it, especially for newbies. 95% of all the books and blogs assume the users is on Windows and using VS. Might as well stick to C#. Haskell is nice for learning pure functional programming, but it's not a practical language for an unpure world. 
Well, I have nothing to say to that. The Linux problem should be solved by [CoreCLR](https://dotnet.github.io/about/overview.html) once it matures so I hope that works out for you (and matthewblott).
Yeah, that's my experience too. In c# I'd define interfaces just like you do here, but it doesn't feel right to me in F#. For your testing concern, I'm not sure I understand. I'm just talking about the interface, which isn't tested anyhow. The actual code that implement IWebClientWrapper would be the same, and be tested however you were gonna do it, etc, it's just that the client (postData) doesn't have to define an interface. The benefits I've seen of doing it that way are that references/dependencies are simpler, ie no middle "messages" or "interfaces" projects to manage to keep dependencies inverted. The downsides are that it's not as clear in the type system, ie, you could have a bunch of clients that need a IWebClientWrapper type function, and if you name it and include it as an interface they're all linked. If you're just passing functions, it's not as clear that they're all using the same function.
Cool write up, it is interesting to see how others refactor. I plan on moving to New York soon and was looking at applying to Jet.com. Any tips for getting a job there? Anything in particular they look for or avoid in candidates?
Going through it slowly...one session every blue moon lol Thank you.
I have never used freya I just know the authors and have a lot of respect for them. I am a windows guy too but I've been developing on OSX for the last year almost and its been a great journey. I intend all projects that I create outside of work to be hosted on linux. So far its a somewhat challenging learning curve but great fun!
[Websharper](http://websharper.com) looks pretty cool, but I've never really done more than scratch the surface of it. 
Thanks for that. I tried to get SqlProvider working with PostGres, but the error messages were completely opaqe and didn't get anywhere. I was able to use your create script and Db.fs to get going. I'm at the admin section, everything runs great on windows and linux. great success. 
Look into either [FsLex/FsYacc](http://fsprojects.github.io/FsLexYacc/) and [fparsec](http://www.quanttec.com/fparsec/) (my favorite). I used fparsec to write a parser to do [write you a scheme](https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours), you can find it [here](https://bitbucket.org/frankbro/writeyouascheme/src/822dbb6df91c98e7c2c1e5abbaf975f1361990fd/WriteYouAScheme/Program.fs?at=master&amp;fileviewer=file-view-default#Program.fs-110). Easier than reinventing the wheel :)
[**@VisualFSharp**](https://twitter.com/VisualFSharp/) &gt; [2015-11-11 22:30 UTC](https://twitter.com/VisualFSharp/status/664570819331276800) &gt; \#suave built with \#fsharp running on \#coreclr on Linux : &gt; https://www.youtube.com/watch?v=rbsjdCJgrME&amp;feature=youtu.be Thanks for helping: &gt; @tomaspetricek @ReedCopsey @westleyl ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
No *that* easier. I have tried like 5 times in implement a python+ml parsers and hit block at each significant step, then fallback to manual code with far easier success. Plus it become harder and harder to dechiper. Take this as a noob point of view. Probably the tool is amazing and I don't know how use it. Moot point, anyway...
It's also always fun to implement stuff. I think the F# parser uses FsLex/FsYacc so it should be good enough for full programming languages.
Coreclr is still being developed, I don't think they added F Sharp support or Visual BASIC support yet, just C Sharp. Yeah you need Mono for F Sharp so far. Until Coreclr and other projects get updated to support F Sharp. But the priority is always in C Sharp.
Mono is very easy to install on Debian based systems so from that perspective I wouldn't worry too much - FWIW here's a tutorial I wrote on how to achieve that ... http://coderscoffeehouse.com/tech/2015/12/09/mono-linux-setup.html Your problems will be after installation. I've been using F# a bit and the experience outside Windows is even worse than that for C#. Partly that's because every book and tutorial is Visual Studio centric so you need some patience. For me it's worth sticking with because I know .NET very well but if you're coming from elsewhere and are working on Linux I'd probably pick something else.
Wow I didn't know about active patterns, really cool stuff there. I was thinking it could decomposed to something like let (|DoubleColon|) input = if input.StartsWith("::") then DoubleColon let testDSym input = match input with | DoubleColon -&gt; (TokenType.ColonColon, input.SubString(2, input.Length - 2) What do you think? I can't think of a better way to modify the string.
I haven't checked them out yet, but i will when i get home 
If you cant find examples in F# for what you need, bear in mind you can look at C# examples and translate them fairly easily due to sharing the .Net runtime. However, there should be plenty of F# examples for common tasks like this 
[You certainly asked on the right day.](http://weblogs.asp.net/scottgu/welcoming-the-xamarin-team-to-microsoft)
A bit off topic what was your other language that you are abandoning? I'm starting to feel the same about Scala so currently just browsing 
We are working on F# for CoreClr, which runs on Linux and OSX. The coreclr F# compiler today runs on Linux and MacOSX and generates working libraries and programs. We continue to improve the support for these platforms, currently we are working on debugging support, to come will be clean up the command line. It is fully integrated into the dotnet cli tool you can install the dotnet cli tool and run it from here on each supported platform: https://github.com/dotnet/cli The OSS project is hosted here: https://github.com/Microsoft/visualfsharp coreclr branch for cross platform support. I think a blog post on how to use the dotnet cli tool on Ubuntu or OSX to build f# libraries and apps would be an awesome thing. I will try to point David Stevens at that piece of work. 
Microsoft just bought Xamarin, so maybe not :)
You might find this interesting. It's an interpreter in F# using monads, it's for arithmetic operations but you can simply change it to fit any kind of tokens and keywords and such. https://github.com/Stickypatrol/BasicMonadicInterpreter
Thanks Kevin, that's great, and would certainly be a boon to folks like me giving F# a serious look.
It's Scala. Particularly [this](https://www.lightbend.com/blog/typesafe-changes-name-to-lightbend), and especially the concerns raised by these blog comments [here](https://www.lightbend.com/blog/typesafe-changes-name-to-lightbend#comment-2530410620) and this one right [here](https://www.lightbend.com/blog/typesafe-changes-name-to-lightbend#comment-2531364197).
I'd be (perhaps naively) exploring the language with the CLI and Vim, at least initially. Would I still experience these problems?
In that case no. I actually prefer the Mono experience to Windows in that respect - Linux has a good C# REPL out the box whereas you have to install some patchy tools for Windows to get anything similar. The F# REPL on Linux seems decent as well from my experience so far.
I just had an interesting experience with F# on linux mint. Previously, I had always great problems trying to get it to install and run, but last week I installed the open source F# compiler using a git clone, I think, and that worked out fine. Then I installed the open source C# and VB compilers, and the latest version of mono, too. That done, I tried the sample websharpersuave project, and it built and ran. Never got anywhere near that far before. So, where I work we've got MSVC to use with other languages, and I happened to be installing a new version, professional 2015 + patch 1. I checked all the boxes to get F# installed, too., When that was installed, I tried the websharpersuave sample project there. The build failed. So, I've got 1 data point that says F# works better on linux than on Windows 7. 
Yeah stuff is getting weird these days. Microsoft owns Xamarin. Installing PostgreSQL on linux includes a graphical management interface. whaat? it is buggy though so not everything has changed. 
Yep I kind of have the same feeling, although many say Dotty will be a solution but I think it'll be to little to late. F# really seems a neat alternative I'm just worried about not knowing the .net stack. Having jvm experience helped a lot when learning/using Scala. 
Thanks, dude I've just completed it, and it was instructional. 
I'm hoping it means better cross platform support and better compiler/runtime for Unity3D... Maybe even direct F# support in Unity3D! (I'm sure that is like, last on their list of things to worry about) 
My prediction? Some of Xamarin Studio's features become a Visual Studio plugin, XS gets killed, mono slowly dies from lack of development/maintenance, F# gets relegated to the same red-headed-stepchild treatment we've seen with .NET Core. Xamarin gets embraced and its projects get extinguished.
&gt; The Xamarin guys seems to really like F# They seem to really like everything but when did they put their money where their mouth is and use F# in production? Heck, is there any evidence they have ever even used F# at all? Those guys are writing metaprograms using the wrong tools for the job despite the existence of F#. They should be all over F# but they aren't. 
Doesn't that presuppose that C# can "steal" features faster than F# can invent them. ;-)
Xamarin supports writing mobile apps in F#
As someone who writes C# as part of his day job, the more 'stealing' happens the better off we are. Global type inference is going to take a while though
That's my fear. I have a license but it's clear to me Xamarin is mostly interested in making the Visual Studio experience as smooth as possible. Xamarin Studio doesn't have the same level of focus.
let add1(x,y)=x+y add1 is a function with two arguments, mapping tuples of ints into ints it has signature int * int -&gt; int let add2 x y = x + y add2 has signature int -&gt; int -&gt; int It is the function which when applied to x returns a function which when applied to y returns x + y I.e. add2 x is the function which when applied to y returns x+y.
https://msdn.microsoft.com/en-us/library/dd483468.aspx#Anchor_2 "Typically, you enclose method parameters in parentheses in a tuple form, which is the way methods appear in F# when they are created in other .NET Framework languages." In other words, methods from the .NET BCL take tupled parameters, and do not support currying (space separated parameters). Edit: Well they can support currying assuming its return type is another function.
I have no details to share because the deal is not yet completed. Rest assured that we on the Microsoft F# team are all very ... very ... excited about this. Xamarin has been a long term, consistent promoter of F#, they have invested significantly in improving the experience of cross platform development for F# developers. We are convinced that this is an excellent development for the F# language and the dotnet eco-system in general and we can see many opportunities brought about by this development, and are eager to start work on making them happen. Kevin Ransom
F# error messages can be misleading sometimes. I am guessing that File.WriteAllText file str would get parsed something like this: ((File.WriteAllText file) str) In the innermost expression it only has one argument so it throws the aforementioned error. As one other person mentioned, string * string -&gt; string (no currying) and string -&gt; string -&gt; string (with currying) are distinct types. .NET library generally do not support currying.
Thanks for clearing this one up for me guys. It makes sense to me now - if you're calling C# libraries then arguments will be interpreted as a tuple. Unfortunately I was reading through a couple of F# books that demonstrate performing this task but they don't adequately explain this - assumptions like this shouldn't be made, F# is more idiosyncratic than more traditional OO languages (at least for me) and it's very easy to get tripped up.
That's true to a point. My complaint with Xamarin is their focus is all on cross platform development with Visual Studio. That leaves us non Windows users out in the cold somewhat - Xamarin Studio does not get the same amount of love and I don't see this acquisition by Microsoft changing that.
C# supports lambdas. You could do lock with them
Love this blog - I find myself refreshing it repeatedly throughout the work week in the vain hopes that this week, finally, is the week that 'week' suddenly means every single day :)
So you "may have over-stated your case out of frustration" and the mean old SJWs aren't really following you around, downvoting you. Golly, I wonder if there are any other things you may have "over-stated" about SJWs? You know, out of frustration.
Just, no. We're programmers interested in a programming language. This isn't the place for this.
For the love of all that is holy, **stop quoting ESR** as an argument. He's the MRA version of Coraline Ada. His allegations about Linus being harassed have zero basis in reality.
That's the whole point though. Have you seen those CoCs?
What's the issue with ESR and his thoughts on this topic in particular?
From what I can tell, maintainers of OSS projects are adopting a minimal standard of professional conduct. That doesn't seem especially awful.
Something like the ruby one is just fine, the one pushed by Ehmke ties every outside activity to the project which is horrible 
new CoC - "ESR can not contribute" =) 
That's my point precisely. Stop the politicization of our community, and remove the CoC.
Then consider yourself uninformed, and read the actual content at the link before adding your 2 cents.
You're citing a rationalwiki article to assert the bias of a source. I will repeat that slowly for you. You're citing a _rationalwiki_ article - to assert the _bias_ - of a _source_. Please tell me where you are having difficulty finding the irony.
I did. I still don't see the issue. Merit shouldn't be a factor when judging behavior. Being a good producer shouldn't give you a jerk allowance when setting a positive example for other developers is certainly better for the community you're contributing to. Based on rate of adoption, most of the community seems to be fine with reasonable guidelines for professional conduct in shared endeavor.
Biased towards not being fucking insane, perhaps.
I have no idea but Linus Torvalds is an arse of the highest order. I'm not surprised women are put off tech and it's disappointing that people defend him.
I've spoken out against SJW's and loathe what they are doing on university campuses (I'm pretty active on Twitter and a glance at my timeline will validate this) but this isn't the same thing. The problem with the PC debate is its polarisation: tell someone you don't like people being hounded out of their job for a mildly racist remark and you'll get the response "yes, I don't know why people get so worked up about the n-word [edit: they don't say the n-word]". That wasn't my point. There's a balance to be struck. Free enquiry is a hallmark of the enlightenment and is what separates us from Islamic State so all ideas should be explored in institutes of learning but we're not doing that on Github. It's not 'politically correctness gone mad' calling out Linus Tarvolds for the arse hole he is. If you go to a party and are obnoxious because you've overdone it on the sauce don't be surprised if people ask you to leave. Ditto a hacker event. In most walks of life we don't have to formulate these rules because they're not necessary (the laws that work best are those adhered to by consent) but tech has a problem in this area. FWIW Scott Hanselman wrote about this earlier today here ... https://medium.com/@shanselman/bring-kindness-back-to-open-source-90ed7d3ac76b#.ug8sxfu5w
The specific page documents and cites the source of the allegations quite clearly. The original source is ESR. You can't just dismiss the reporter out of hand as biased when the links to pretty frightening source material are clearly available.
I was like, "You know? I'm tired of clojure. I'm angry with how Sun is managing the JVM. I want to learn F# to see if that ecosystem could support what I'm doing. I wonder what the community is like? Oh wow, Don Syme is cool. Tomas seems really smart." Then, with a bit of dread, I clicked the subreddit. My spine twitched as I saw, "On pushing back against the SJW encroachment" in this thread. Then I saw the score. Then I read the thread. Then I saw how firmly the community pushed back on this. Hi. I'm Dave. I hope you don't mind, I'm going to hang out here for awhile. And do be clear: CoC for everyone. All the CoCs.
Those holding forbidden opinions have to do what people did in the Soviet Union. Hold them privately, or use double-entendre art and humour to express them in a plausibly deniable manner. Ostracism has been the punishment for open dissent for a long time.
I really dislike this approach for pre-interview coding assignments. In general, the purpose of a good pre-interview question is to assess if a candidate has practical skills and signal to the candidate what would be required to be successful at the role. Arguing that purely abstract programming questions should exist is fine if you're interviewing for a pure abstract position. Very few of those exist. I have a friend who recently asked F# candidates to submit a screencast of using F# and deedle to extract and present insights from a anonymized data set. I thought this was amazing.
What are other people's thought on his demo? I was extremely impressed with the application of fsharp.
I too think it's wonderful. Video freezes part way through though - I hope channel 9 can sort this out.
Taken me a whole day to parse that headline!
Video now works. If you only watch one F# video this year, make it this one.
Is there no repo to follow along with?
Refer to [MSDN article](https://msdn.microsoft.com/en-us/library/s2tte0y1). Has some sample C# code which can be easily translated to F#.
I've had horrible, horrible experiences with Atom + F#. I suggest trying Visual Studio code (which is essentially an Atom fork) and seeing it that works.
I guess I'll give that a try too. Monodevelop was almost perfect but the type aware tooltips aren't working for me. *so close* 
Yup. I'm doing a lot of Rust right now... It's got a complex type system with excellent type inference, but the lack of an IDE makes it a PITA.
FSDG
The Rust plugin for VS Code is actually pretty good. Not as good as the F# one and it crashes occasionally, but it definitely helps.
Any idea for a good workflow for remote development? I worked with sshfs for a bit and it wasn't great, I can't delete a file etc
&gt;Is there a technical reason we can't port Elm to F#? Looks like you'll have to get the OSS project started so we can find out!
We're still waiting on .NET Core support for F#, where the runtime is compiled into your binary. Not sure it's coming anytime soon.
That would be awesome! Do you think this would be a Windows-only thing? Or would one be able to do the same with Mono?
.NET Core runs on linux already. people have built some F# with it too, though it isn't official yet.
Yeah, Elm looks really cool.
Do we really need to _port_ elm though? Elm is quite fine as it is. Wouldnt it be better to just better integrate elm the way it is so that its easier to setup and run a project where the frontend side is in elm and the backend is in F# instead of "forking" Elm?
Do you have a good 68000 assembly book? Just asking 'cause I've got a few machines that use the processor and there's one at the local used book store calling my name.
Yup, I have the same setup and I'm seeing the same thing.
Anyone have an idea who to submit the error to? monodevelop, vs fsharp binding people? 
&gt; Delimited continuations are better than undelimeted (as I have read) I wouldn't say they are better, but they are different in small ways. Delimited continuations are more complex, but with that complexity comes a notion of scope. Depending on what you're doing, that extra capability may or may not be better (okay, so usually it's better in real programs). So if you're designing a language or library that implements continuations you still have a trade-off between the added complexity of delimited continuations vs undelimited continuations. Have you seen Andrew Appel's book ["Compiling with Continuations"](http://www.amazon.com/Compiling-Continuations-Andrew-W-Appel/dp/052103311X)? I have not read it personally, but my understanding is that it is highly relevant to your question. Perhaps you can find an online preview to see if it would help you. I think you would benefit a lot from "wrapping up" your continuations in a computation expression. In Haskell land, they have a continuation monad and it makes writing things in terms of continuations more convenient. For instance, here is an article meant to introduce beginning Haskell programmers to the Cont monad: https://wiki.haskell.org/All_About_Monads#The_Continuation_monad The idea is that you create a continuation at each lexical point you may want (or need) to return to (say for instance, you want to return to the top level of the interpreter when you detect a division by zero). Creating the continuation gives you the 'escape hatch' that you may call later in the exceptional case. I think the haskell example makes this clear by calling the continuations "exit1" and "exit2". I hope that helps.
That would certainly be less work. There is a certain appeal, though in having the same language all the way through. We already have a lot of the components in place. The language is mature, the IDE is perfect and Funscript can be our JS translator, the virtual DOM can already be accessed through funscript. I think the only missing parts are signals and ports. 
Similar code is in the Functional Game Dev Videos. If you think that article was cool you should check them out.
How common is using something like this state monad, vs something like continuations or "railway-oriented" programming? I'm just getting started in F#, so I'm looking to make sure I'm writing idiomatic code. 
If you come across any good resources for integrating F# idioms into your development practices, please share.
URL? 
He produces a ton of content and he has a nice couple breaks where he goes into how F# works. https://www.youtube.com/channel/UCb9COpeTD58UYeSV6Ia97GQ 
You might find OCaml to your taste.
Thanks! 
Absolutely
Yeah the only issue I have is watching them all he puts up about 1 a day and I don't have that much free time. :)
And highest paid!
Behind Spark, Scala, and Cassandra, though only by a little bit! As someone who writes Scala for a living and enjoys F# in my spare time, I'm not complaining.
Ah, that's right! That's what I get for only checking the US stats, haha.
I will love to get jobs with F#. I do python, so is good too, but wanna a challenge!
To be honest, I've never seen a state monad in F# code. The "railway oriented" approach is almost certainly more idiomatic. 
Same issue here. It comes and goes, I can't really put my finger on what makes it stop working.
Everything critical in that article points to external references. Most of them point directly to his blog and his words.
Curious, why you don't want System.Console.ReadLine()?
I don't see what the big deal is. The CoC, from what I can tell, just says I can't call you a retarded fat faggot in the context of the F# tools repository and expect to remain in that particular community. And I'm perfectly fine with that because I have no idea who you are, what you look like, or your sexual orientation and in the context of code, I don't care. 
Then you didn't read the linked in Contributor Covenant which allows SJWs to stalk you online such as at twitter and agitate for you to be removed from the project for having 'wrong' opinions.
Apparently, care to share again? EDIT: Here's one of the documents, care to point out the offending passages? They seem rather innocuous to me. Contributor Code of Conduct &gt;As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities. I don't see any issues with this. &gt;We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality. I don't see any issues with this, either. Your code either makes it or it doesn't. Your gender/politics/whatever should have nothing to do with it. &gt;Examples of unacceptable behavior by participants include: It could get hairy in here: &gt;The use of sexualized language or imagery No problem. &gt;Personal attacks No problem. &gt;Trolling or insulting/derogatory comments No problem. &gt;Public or private harassment No problem. &gt;Publishing other's private information, such as physical or electronic addresses, without explicit permission No problem. &gt;Other unethical or unprofessional conduct This is vague and the only "issue" I have with this whole document. But I understand the Spirit of the document, so it's not a stretch to imagine that this is to catch corner cases that aren't explicitly set out. &gt;Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. No problem. Don't like it? Start a new project. &gt;By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team. Good for them! I'm not a project maintainer and I like to get drunk at times. &gt;This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. I don't see myself representing the project or the community, so I don't have a problem with this, either. Even if I were, I think the "don't be an asshole" rule applies here. &gt;Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting a project maintainer at [INSERT EMAIL ADDRESS]. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. Maintainers are obligated to maintain confidentiality with regard to the reporter of an incident. I don't have a problem with this, either. Fuck em, it's their project. &gt;This Code of Conduct is adapted from the Contributor Covenant, version 1.3.0, available from http://contributor-covenant.org/version/1/3/0/ Don't see a problem with this, either. Seriously, you anti-SJWs are just as bad as your SJW counterparts. Your analysis is some seriously fucked up paranoid conspiracy theory shit.
Our analysis is in line with our experience with how the contributor covenant has been abused in practice to exclude people from communities who have 'wrong' public opinions - no 'theory' is necessary. The agitation - https://redmine.ruby-lang.org/issues/12004 The abuse - https://github.com/opal/opal/issues/941 This type of abuse is precisely what the Contributor Covenant is designed to enable and is how it is used in practice. CoC's themselves are a lie, being politically exclusionary while promising to be inclusive - social fascism wrapped in politeness. You can keep your head in the sand if you want, but please stay out of the way of those of us attempting to protect our communities from ideological purgers.
WOW. And here I was hoping for some Adria Richards "dongle gate" nonsense. So.. I didnt' wade through the whole thing, but what you call abuse.. Did the person make transphobic comments on their public twitter account with the project affiliation as publically viewable? Yeah, I'd probably tell that person to fuck off, too. It's right there in the CoC, as well. I do not have a problem with this, at all. Take down your affiliations with public projects whom you do not speak for when you make your stupid, asinine comments and then we can talk about unfair bullshit. But that's what this is. Bullshit. Seriously, this is high school level retarded bullshit. &gt;please stay out of the way of those of us attempting to protect our communities from ideological purgers. WHOAHHHHH there Howard Roark. I'm part of these communities, too, and you most certainly don't speak for me. In fact, your cretinous actions make it *extremely* difficult to even support the potential 5% (totally made up) of issues that are actual issues. So, yeah, shut the fuck up. There is no war on christmas, princess.
lol. Watch out everyone, we got a bad ass here. I bet he trains ufc. Shut the fuck up 
Fair enough, we see this one differently.
Check24 in munich. We use FAKE build scripts, and i'm trying to use it more for various new projects
Oh, that's a surprise. I heard you guys are moving to Scala. Nice to hear F# is there. Are you organising any meet-ups on the functional programming topic?
Unfortunately, no. [It's been proposed and even prototyped](https://fslang.uservoice.com/forums/245727-f-language/suggestions/5690218-allow-open-in-local-declarations-like-in-standard), but not brought into the language as a feature.
Interesting. Thanks!
[removed]
You can't do it the way you show, but you can get the same effect by doing Opr.add 1 2;;
This was my favourite session of the conference!
Potsdam: https://twitter.com/tforkmann/status/715155506810261505
Has F# changed in this update?
There have been [preview releases](https://github.com/Microsoft/visualfsharp/releases) of the binaries, so I assume it has.
Yeah, I got the same feeling :( I found this though: https://channel9.msdn.com/Events/Build/2016/T661. There might be some hope after all :)
I thought the interop was at the IL level.
&gt; Y'all laughed at me a while back when I said that the C# folks were stealin' some of the better pieces out of F#. Who laughed? Because that's pretty much the consensus around me.
For completeness, C# pattern matching spec is here: https://github.com/dotnet/roslyn/blob/features/patterns/docs/features/patterns.md
I also made a self post in the C# subreddit about [pattern matching more in depth](https://www.reddit.com/r/csharp/comments/4ctoy7/exploring_pattern_matching_in_c/). e: Also, a lot of the spec deals with records, which we don't currently have yet. So keep that in mind while reading it.
FWIW, this: let map f x = match x with | Success(result) -&gt; (f &gt;&gt; ok) result | Error(message) -&gt; err(message) can be rewritten as: let map f x = match x with | Success result -&gt; f result |&gt; ok | Error message -&gt; err message or even: let map f = function | Success result -&gt; f result |&gt; ok | Error message -&gt; err message Are you interested in C# for legacy code or are you planning to use C# for new code? 
Yes, this is true. F#'s general strict top-bottom ordering makes it very easy to understand projects you're not familiar with, versus trying to make very complicated UML diagrams to understand what your C# code is doing. But I think some people would just as easily see the strict ordering and difficulty to make mutually-referential types as a downside, so, it might be an acquired taste.
It didn't always not-work. At some point in 6.xx `Enable-Migrations` stopped working for F# projects, and didn't work for me when I just tried it. But even when it did work, [making repository classes that EF likes in F# is just awkward](https://blogs.msdn.microsoft.com/visualstudio/2011/04/04/f-code-first-development-with-entity-framework-4-1/). F# oddly enough works better with smaller abstractions like dapper or far more robust ones, like type providers. That's just kind of the problems you run into with .NET shops and F#. Type providers mostly obsolete it (provided you want to manage migrations on your own) and are never out-of-date, but, inertia at this point is quite something.
I tried this on Debian. Stable package can be installed but fsharpi/monodevelop fails with runtime exceptions. Packages from mono-project can't even solve their dependencies. Edit: I actually followed instructions on fsharp.org which are outdated. Adding additional repositories fixed dependencies. 
Something C# is unlikely to get is full type inference &amp; automatic generics. It's kind of a big deal
Ah, finally, an official project scaffold. I've had more trouble getting a 'yo fsharp'-made project to build on my mbp than anyone should :\
I had the same problem, so I ran MonoDevelop with the --no-redirect flag as advised and spotted the exception: -------- Exception while creating tooltip: System.MissingMethodException: Method 'PopoverWindow.RepositionWindow' not found. at MonoDevelop.FSharp.FSharpTooltipProvider.CreateTooltipWindow (Mono.TextEditor.TextEditor _editor, Int32 _offset, ModifierType _modifierState, Mono.TextEditor.TooltipItem item) &lt;0x40d31210 + 0x0003f&gt; in &lt;filename unknown&gt;:0 at MonoDevelop.FSharp.FSharpTooltipProvider.ShowTooltipWindow (Mono.TextEditor.TextEditor editor, Int32 offset, ModifierType modifierState, Int32 _mouseX, Int32 _mouseY, Mono.TextEditor.TooltipItem item) &lt;0x40d309e0 + 0x0018d&gt; in &lt;filename unknown&gt;:0 at Mono.TextEditor.TextArea.TooltipTimer () &lt;0x40cc0870 + 0x0055d&gt; in &lt;filename unknown&gt;:0 Guilty line is [here](https://github.com/fsharp/xamarin-monodevelop-fsharp-addin/blob/f6f82b9388a09e89e2d88fe9d5820f8f98e94cfc/MonoDevelop.FSharpBinding/FSharpTooltipProvider.fs#L117). But I looked at the Monodevelop repo and it seems the RepositionWindow() method is correctly present in both the PopoverWindow base class and in the TooltipInformationWindow derived class. I'd have to clone and debug both projects to figure out what's going on.
I've been playing with Suave.io and was reading about user authentication recently as well. Here are two resources that I found helpful. 1) The Suave Music Store (git)book has a section on authentication and session. https://www.gitbook.com/book/theimowski/suave-music-store/details 2) Hawk is an authentication library for f# with a really clear example for both server side Suave.io as well as how to use it from javascript. https://github.com/logibit/Logibit.Hawk
[fsharp.org/use/linux](http://fsharp.org/use/linux/) does not mention additional repositories for Debian 8 and later. I filled [issue](https://github.com/fsharp/fsfoundation/issues/532#issuecomment-205077915). Link on Mono homepage from you above has correct instructions.
If you want to use oauth you can use this library as a starting point. I used it with some slight modifications to make it work better in my particular case last time I implemented auth in suave. https://github.com/OlegZee/Suave.OAuth
Yeah, and this is a pretty simple monoid type, too. It'd be even worse if I made the error case generic as well. The good news is I can write it in F# and leverage type inference and automatic generalization, and then just pattern match against the F# structures in C#.
I agree. Both of those are pretty huge, and part of the reason I find the F# syntax so light and enjoyable. 
Well, maybe it would be worse, but even if your type was not parameterized at all, the type signatures for functions would still be annoying.
The last option is definitely the best from the functional mindset, the problem is that the return type of the function cannot be determined (one case is an int, the other a string). You could update doStuff to return SuperType and it should be ok again. But then you really need to consider what you're trying to accomplish with doStuff and ask if you're generifying too much. Maybe make functions like let processInt x = x let processString x = x in lieu of one mega-generic function
Thinking about it more carefully, I suppose this makes sense. If you have to break a function up into different logical cases for each type to make it generic, it isn't really saving you anything over just writing multiple functions.
The thing is, once you put the value x into a parameterized type, such as Option&lt;'a&gt;, you can't get it out without strings attached. what you could do is create an unwrap function that automatically matches the type, takes out the value *in the way it is there* and plugs it into a function that returns the same time, then you can chain these functions together easily. let dostuff x = bigcomputation x let UnwrapAndWrap f x = match x with | Some(x) -&gt; f x | None -&gt; None You can also do this with other parameterized types. In case you were asking for how to make a function that works on multiple datatypes, you can do this with generics and you can make overloads for operators with members of types, like so: type IntorFloat = | Int of int | Float of float with static member (+) (a:float, b:float) = a + b static member (+) (a:int, b:int) = a + b this is a contrived example but you get the point
You can write something like your original function using unbox: let dostuff(input: 'a) : 'a = let atyp = typeof&lt;'a&gt; if atyp = typeof&lt;int&gt; then unbox 3 elif atyp = typeof&lt;string&gt; then unbox "3" else input 
[removed]
To expand a little more, from fsharpi: let nameTuple = "bob", "barker";; val nameTuple : string * string = ("bob", "barker") The comma between "bob" and "barker" is the syntax to create a tuple, but the type signature is represented as * instaed of , You can mix types and have more than 2 items in a tuple, each with an additonal , in the code and * in the signature let person = "bob", "barker", 83, "Hollywood", "California";; val person : string * string * int * string * string = ("bob", "barker", 83, "Hollywood", "California") 
It declares a Tree as a discriminated union (in OO lingo, you can think of an abstract class, almost) An instance of Tree can either be a Leaf (containing a string) or a Branch (containing a string AND another Tree) 
Just tried, it seems F# is broken in this update (failed to install). No wonder they were not talking about it much yet
 `string * string` is the type definition, `( "" , "" )` is the value
Record syntax is like this type Person = { FirstName : string LastName : string } let bob = { FirstName = "bob"; "LastName" = "barker" }
The only overhead it ads is the learning overhead. I am currently working on a site in F# with Suave and really enjoy it.
Suave is great, I would argue there is much less overhead. The Suave Music Store tutorial is a great starting point: https://theimowski.gitbooks.io/suave-music-store/content/en// 
What's the situation with libraries that you would typically use for projects (logging, authentication, ORMs, testing, etc.)? Also any recommendation on how to overcome the learning overhead? 
Thanks! This looks like it would be a good starting point to learn about Suave. I am assuming you have used Suave before. Any pointers that you can give me based on your experience? Potentially pitfalls, gotcha's, etc.?
Interesting. It looks like WebSharper has corporate backing. I wonder if that means it has more features/less bugs compared to Suave and/or Freya. Can anyone that has experience with both comment? 
Sure, I think the way they deal with Forms in the Music Store demo is overly complex. Could be this is just my lack of familiarity with F# (I'm a bit new to it) but I've taken to using Newtonsoft.json to get data back from javascript instead, or query parameters where appropriate. I've got some good helper functions along those lines. Also you will want to decide if you should use something like SqlProvider to talk to a database, which is very slick F# way to do it, but still very Alpha, you will run into things that don't work if your DB interactions are at all complex. I've been using "FsSql" which is a lightweight wrapper around the database driver. If you are using MS Sql Server there are some nice options. IIRC some of the popular C# database tools can be problematic to work with in F#, can't remember if it was Dapper or Entity Framework that were a bit cumbersome to work with. Feel free to send me a message if you have questions, I've been developing a website from scratch with Suave for a few weeks so have a few ideas and code I can share. Would be happy to bounce ideas off of you too. Good news, all the Sauve stuff has worked on both windows and Linux without any pain. Been able to interact with Bootstrap templates, DotLiquid templates, and TypeScript just fine. I know people use Suave with react to good effect too, and React got some nice improvements with V15 today, so might be worth looking at. 
WebSharper has the interesting promise of replacing your javascript with FSharp that transpiles to javascript. I've found it very hard to navigate their documentation, but that might just be. It is worth a look I Think. 
I haven't gotten the the stage of logging yet, but I would probably just write something to the db for starters. Authentication is done by taking the users' info from the login screen and seeing if it matches whats in the db, using bcrypt for password hashing. Suave has a mechanism for cookie encryption/decryption already. I dont use an ORM. I am using postgres so I use just use oldschool raw ADO. If I was using SQL Server I would use http://fsprojects.github.io/FSharp.Data.SqlClient/ which I have used extensively and its awesome. Testing, I use canopy (author) and a unit test lib based on canopy. Learning overhead was overcome by me, by just porting the suave music store example to use postgres, then just using it as an example of how to build my own.
FsSql is a nice db wrapper, not an ORM but saves you some pain
Yep, me too! Hah. I just tried it on Docker and it doesn't work there either. It's a known bug apparently. If you Google it you should find the issue on Github.
What we need is a type provider for Xamarin forms XAML. Working with WPF in F# is so good: You get the Visual studio graphical editor for the XAML and typed access to everything in code via the FsXaml type provider. I am not sure whether this will come from Xamarin or thE F# community. There are some old defunct community Xamarin projects which could be resurrected now that Xamarin is free and the next big thing. Or the F# enthusiasts at Xamarin could write one. Either way I hope it gets done soon. Currently using Xamarin forms works well via code only.
Yeah, Jason Imison has been doing great work lately on making the REPL better, too. Check out his Twitter!
&gt; I haven't seen many examples of F# being used in web development See jet.com. * http://techgroup.jet.com/blog/2015/03-22-on-how-jet-chose/ * http://hanselminutes.com/494/jetcom-scales-with-azure-f-and-more-with-rachel-reese * https://www.dotnetrocks.com/?show=1240
I often think about how hard it is to do experiments about what effect language has on people's ability to write code quickly or correctly or some combination of the two. So many confounding factors exist such as the library ecosystem, tooling qualify etc. Comparing language that partially share ecosystems might be more feasible though. Such as comparing F# and C# or Scala and Java. It would be interesting to see careful experiments. It certainly feels like I the F# code I write is much more likely to be correct the first time I get it compiling, even though I'm more familiar with C#. But I don't trust feelings =) F# definitely is more fun to work with and nicer to look at though. 
I thought Scott stopped blogging, nice to know he's still doing his thing
I think they are here: https://github.com/pblasucci/DeepDive_ActivePatterns/blob/master/DeepDive_ActivePatterns.pptx From this: https://github.com/pblasucci/DeepDive_ActivePatterns
Thank you!
&gt;So I've made @code (and @IonideProject) 1st editor supporting .Net Core for #fsharp. Krzysztof Cieślak is the best.
It was easier than it sounds ;)
You made it sound easy, and we know that you are down playing the great work you are doing and have already done.
This is so cool. We'll definitely do this. Thanks for your help :) Now the biggest sticking point is that Windows doesn't have a stand-alone F# installer that packages all the dependencies. I guess that's what I'll work on.
I was thinking about creating standalone F# package for [Scoop.sh](http://scoop.sh/). It would solve distribution problems on Windows. It might be something worth investigating.
Why not?
Link?
Let's just have a look at those points: &gt; More difficult type system than C#. Sums and products are difficult? &gt; Inferred Types are difficult to work with in IDE. He's talking about implementing these parts of the F# compiler himself from scratch and he doesn't know how to do it. That's fair enough but you don't need to implement it yourself: you just call the existing F# compiler service as Visual Studio does. &gt; Resharper support never worked well with it. Nobody at Jetbrains knows how to do this or even where to start. &gt; 'Doesn't Believe in It'. A religious argument if ever there was one. At least he says if someone came to him and offered to do it then he would let them. &gt; FSharp compiles into huge amount of lambdas/clojures, with lots of boxing/unboxing. True. Async generates closures and boxing in F# so it is much slower than the elegant state machine that C# uses. Active patterns box unnecessarily which makes me a sad panda. However, I am not sure how this is relevant. &gt; Bad interop with C#. Really? &gt; Entire code has to be an expression. Which is a good thing. Looking at this guy's [LinkedIn page](https://www.linkedin.com/in/sergey-shkredov-689a0829) it seems he graduated in 2006, has had two jobs and knows only one programming language (C#). So I am not surprised F# would be baffling to him. I'm guessing Jetbrains don't employ people with diverse PL knowledge. Just clicking on random other people: * Andrew Starovoyt lists only Java as a skill. * Andrey Ivanov is endorsed for only one PL: Java. * Dmitry Jemerov lists Java, Kotlin, Python, Ruby, Javascript, C++ and C#. * Kirill Skrygan lists C# and SQL. * Konstantin Solomatov lists only Java. Holy narrow skill set, batman. Is it really surprising that such people would make such statements? 
Well, be careful about reading too much into people's backgrounds. Looking at my background you would deduce I'm an imbecile, but I'm actually more of a moron. I also get the impression that F# is something they look at as a bullet point on the way to competing against visual studio. I'm sure a similar discussion is internally taking place on the subject of VB.net. I don't believe this is really a matter of hating F# but rather being pragmatic, it's just kind of a letdown since from the moment they announced Project Rider I was hoping for an F# 'grand reveal'. I assumed JetBrains made the decision to actually build it because they knew Microsoft was building a cross-platform dotNet, and was unlikely to unveil a cross-platform Visual Studio in the imminent future. I figured with Fsharp's position in the community of being cross platform friendly and generally aimed at backend code, it would be a natural choice. Instead this seems to be going after the Asp.Net/C# crowd alone. In fact, I would actually wouldn't be surprised if they throw in VB.net at this point since it seems to align more closely with what is thought of as a reasonable language (In their opinion). He did seem to hesitate before giving some of the answers, so maybe his views are not shared by others there, or perhaps he knows his comments might not be received favorably by the rabid F# community ;)
&gt; The best thing to do here is make JetBrains aware that F# is a fantastic language and developing for F# would help to draw in a crowd of generally sharp programmers who could really help them shape a great product. But is that actually true? There are far more C# programmers than F# programmers and they have a far greater need for refactoring tools and fancy IDEs. The market for such tools for F# must be vanishingly small. Furthermore, when I even enquired as to the possibility of creating an alternative IDE for F# Microsoft responded by closing off the relevant APIs in order to prevent me from competing with them on a level playing field. &gt; That said, I have no idea why anyone would use this IDE. VS Pro costs ~$300 and VS Community is free. When I do .NET dev I stick with the Windows stack and when I want to go Linux, I pick other languages that work best with that stack. The whole .NET on Linux thing has never really appealed to me. I'd love to be able to use Raspberry Pis as my development machines rather than Windows. And I'd love to be able to deploy production F# code to Linux machines. 
I've documented them pretty extensively in the F# Journal. The easiest thing to do is decompile some suitable F# code using ILSpy and take a look. Active patterns allocating is a much bigger gripe for me than async because it is a place where I'd like to write a lot more perf critical code but cannot because of the allocations. Tuples being heap-allocated reference types is an even bigger gripe but there are historical reasons for it and it is a .NET problem not specific to F#. 
Which is sad because from what I can tell at conferences and other media, it's picking up a lot of hype.
&gt; Tuples being heap-allocated reference types is an even bigger gripe but there are historical reasons for it and it is a .NET problem not specific to F#. Since C# 7.0 is likely going to introduce value-type tuples, I think F# is looking to adopt them too in some fashion.
ah--this is fantastic. i spent a few hours compiling things from scratch only to figure out that i didn't know what sort of directory structure the dotnet platform expects. i had no idea where to put dependencies, how to structure projects, etc. while this information is still lacking in the general open source projects, this is a huge help. edit: doesn't quite seem ready for the prime time. can't get the default f# hello world to build using this utility.
Resharper/Rider won't have integrated F# support for foreseeable future, but there is still lots of room for F# users to push for features that are not too hard to implement based on assembly/debug symbols analysis. few examples of things which could work based on up to date compilation of the code: Go To Definition Find Usages Launch Test from editor What it takes is for a noticeable portion of the user base dealing with C#/VB.NET and F# to log and vote on issues, be active reporting issues etc.
I think that the type inference engine is looking at just internalTailRecursion without inferring the type of a from the call below it. If you change |(head::tail, a) when a.IsNone-&gt; internalTailRecursion(tail, Some(head)) to |(head::tail, None) -&gt; internalTailRecursion(tail, Some(head)) It makes it slightly shorter and also provides the required hint to make the next line's a.Value work. If you switched the order of those lines you would get FS0072 on a.Value instead of a.IsNone. I might then also change the following line to 'Some a' but this is more a matter of taste. |(head::tail, a) -&gt; if a.Value&gt;head then internalTailRecursion(tail, a) else internalTailRecursion(tail, Some(head)) to |(head::tail, Some a) -&gt; if a&gt;head then internalTailRecursion(tail, Some a) else internalTailRecursion(tail, Some(head)) 
https://glot.io/snippets/ee09e6kv98 check line 4
line 3 can be reduced to `|([head],_)-&gt; Some(head)` line 4 can be reduced to `|(head::tail, None) -&gt; internalTailRecursion(tail, Some(head))` as a bonus, compiler now can infer type of the variable
I think it could be positive in the long run... Lots of languages have ascended to prominence without VS support. The better the cross platform story, the stronger the eco system, the more the language will be a competitor to Node, Python, and a bunch of backend languages. Tools like Paket, for example, show the way towards and awesome .Net cross-platform story. Maybe tooling not as dependent on MS is the better way forward...
&gt; which makes me a sad panda Sad **lambda** surely.
I'm kind of amazed actually. I don't actually know very much about F#. If I had been assigned this work, I would've gone straight to C++, since there was a C api to interface with and high-throughput data streaming to be done.
My feelings exactly. I asked them to buy the appropriate license, but they just went with the "err... yeah... look for one and tell us which one you need". Thank you for your reply!
The open source and Visual Studio-included compilers are literally the same compiler, and their output should be 100% equal. I don't think there are any licensing restrictions about using it for commercial projects. You don't need a Visual Studio license, but as /u/APimpNamedAPimpNamed said, if you have to pick one, pick Professional. Visual Studio Community has all of the same features and it's free as in free beer, but you can only use it in small businesses, personal projects and open source.
On the syntax part, you should probably be better fully using the pattern matching instead of using the internal properties of the objects they produce. +/u/CompileBot F# let getMax x = let rec innerMax = function |([], currentMax) -&gt; currentMax //Empty list case |(head::tail, None) -&gt; innerMax (tail, Some head) //First element case |(head::tail, Some currentMax) when head&gt;currentMax -&gt; innerMax (tail, Some head) //New maximum case |(_::tail, currentMax) -&gt; innerMax (tail, currentMax) //Default case innerMax (x, None) printfn "%A" (getMax [-2;42;27;5])
Output: Some 42 [^source](http://ideone.com/Zb6q9y) ^| [^info](http://www.reddit.com/r/CompileBot/wiki) ^| [^git](https://github.com/renfredxh/compilebot) ^| [^report](http://www.reddit.com/message/compose?to=compilebot&amp;subject=Report%20Abuse&amp;message=--report%20https%3A//www.reddit.com/r/fsharp/comments/4fzul0/cant_make_sense_out_of_this_issue/d2i0bok%20Include%20your%20reason%20for%20reporting%20here.) 
Well I've just installed Xamarin Studio 6.0 (beta) and I'm really pleased with the new features (not to mention the great new look and feel).
I'm a big fan of fsharp blogs geared towards business applications. Very useful info!
Best place for it to be honest :-)
Same here, I can't get hello world - or anything - to build on a fresh install of the latest OS X. Such a shame, really don't fancy using a wrapper like mono.
Great and really honest article. The tooling situation with MS is a bit of an issue, but as the cross-platform story matures I see C# trying hard to absorb more functional features as a wonderful step forward. Fundamentally, though, as more and more almost-functional grammar gets bolted onto the language you've got to wonder why not just take a parallel step to a language with years of polish on top of complete versions of those features? I found the one comment about F# yielding the promise of the .Net framework, to pick the right language for the job, to be quite interesting. C# plumbing on top of F# cores could be a win/win in a lot of situations.
I was reading [CLR via C#](http://www.amazon.com/CLR-via-4th-Developer-Reference/dp/0735667454) the other day and something that struck me is how often the author talked about the advantages of being to use multiple languages that can talk with one another seamlessly due to them all running on the CLR. The author seemed disappointed that VB became C# with slightly different syntax while other languages on the platform weren't really getting much love. With C# getting pattern matching in the next version, I do wonder how far and how large C# will become, ultimately, and if we'll see a more distinct push to have more varied usage of other CLR languages to solve particular problems. 
I was interested in pattern matching in C# for a wide variety of reasons. After I [played with the implementation a bit](https://www.reddit.com/r/csharp/comments/4ctoy7/exploring_pattern_matching_in_c/), I came to the conclusion that I don't dislike it. Even more, there appears to be some [interesting ground to tread in how it'll work with F# interop](https://www.reddit.com/r/fsharp/comments/4d2g3q/pattern_matching_f_constructs_in_c7/). But. public class User { public int? Id { get; set; } public bool CanSendEmails { get; set; } public string Email { get; set; } } // later in some function somewhere ... let user = GetUserInfoFromSomewhere(); let User { Id is int id, Email is string email, CanSendEmails is true } = user else return false; SendEmail(email, id); return true; I appreciate the *tremendous* utility going on here. Handling `null`s declaratively and being able to destructure like that will be a *huge* win for C#, but I just don't see junior, or maybe even intermediate C# devs naturally thinking or intending to write code like this. Is it more "magic"? I don't know. Will it fragment how people write C#? I think it'll take a good few years for it to really sink in and percolate. C# is becoming quite a large language with quite a lot of syntax features. Maybe that comes with the territory of trying to be the best general-purpose programming language? C++ is also quite a monster, and even java is getting more crazy with things like default interface implementations. Really, I'm just hoping this makes the F#&lt;-&gt; C# interop even *better*. Pattern matching against F# constructs in C# isn't ... particularly pretty or terse, but it's much better than not being able to at all. Maybe it'll get even better with C# record syntax and user defined `is` operators. I'm hoping it'll just make it that much harder to deny someone who wants to use F# in a C# solution. 
Try clicking on the Script link in the list on the left. You can also search by typing in the search box in the upper right. Pro-tip: Many of the tool windows in VS have a search box, including the solution explorer.
There isn't an F# option there either. http://imgur.com/FJPFmBV http://imgur.com/I0KUwXG Do you have an F# new file option in your VS 2015? Is there a Visual Studio Support center that I could go to?
Yes, I do. It just creates an empty file with the proper extension, so it's not hard to work around. Do you have the option to create an F# project? Do you have F# Power Tools? If not, you should get it as well, lots of nice extra features.
Yes I can create an F# Project and yes I've downloaded the F# power tools. What's the work around for not being able to create the fsx file and will I be able to send the script to fsi? 
Create a new text file File &gt; Save Change the extension from .txt to .fsx and Save. 
Correct me if I'm wrong, but this approach smells like a band-aid for inadequate data abstraction (https://vimeo.com/128464151).
I am not sure how can we refactor it to a better data abstraction. Can you provide a sample code snippet of what do you mean?
C# will be getting _some_ pattern matching, but it seems like a lot of that feature has been postponed for "later" - so the pattern matching that C# will be getting in the next version seems kinda...sad. https://github.com/dotnet/roslyn/issues/10866
Do you happen to have default IDE settings for C++ instead of C# (default ones)? I happen to have this strange behaviour due to my choice of default settings: https://github.com/Microsoft/visualfsharp/issues/804
Be careful what you wish for.
I'm not sure I agree with that. I agree that |&gt; isn't the F# composition operator (&gt;&gt; is), but IMO the author was saying that |&gt; makes it easy to compose functions in the sense of juxtaposing them in intuitive ways at the call site.
In the sense that I think the author, not unreasonably, meant "to compose functions", yes I do agree that fluent interface call chaining is an example. One with its own advantages and limitations sure.
I like F#, but think some points against it can also be helpful, especially within the community. F# is a second class citizen compared to C# in Microsoft's eyes, and the tooling support will not be drastically improved by Microsoft in the near future. You may argue that other tools are helping to pickup the slack, but the fact remains there are no enterprises really supporting this. The F# community is small even compared to other novel, functional languages. For instance, it isn't near the size of Clojure or Scala. Why would anyone pick F# over Scala? Compare for instance, http://www.clojure-toolbox.com/ with any equivalent list of F# tools. F# has not produced any must-have projects. It hurts to write this, but I think it's accurate. The closest projects would be FAKE, Paket, and Suave, which while good, are not really banners to convert users of other languages. Most other functional languages have equivalent tools already for them. I'm thinking here of projects like Datomic (Clojure), Akka, and Spark (Scala). I know of nothing on that scale that is created in F#. While these projects obviously support being used in many different languages, the mere existence of these large projects makes the choice of that language seem safer. The JVM has a better cross-platform story than the CLR and this will likely not reach parity for several years. In fact, the impression is that Microsoft spends little time worrying about Core CLR for F#. F# doesn't really have a healthy relationship with C# practitioners. I don't really know all the historical or psychological reasons for this, but I get more a sense of competition between these communities than unity. I don't think adding features to F# will have an appreciable impact on user adoption of F#, and actually hurts adoption somewhat because it out-dates existing resources. Look at Go lang for a great example of how not iterating the language can pay huge dividends. Stop trumpeting things like Type Providers, they're neat but unless there have strong implementations they're not useful. I can only think of one 'good' type provider, and that's the set in FSharp.Data. Otherwise it's all half-implemented, unsupported, github projects that someone made because they like to make Type Providers, not because they intend to support some mission critical thing with it. 
\&gt;no F# :(((((((
If you squint it is the same! 
You should post this in /r/ocaml instead...
Hey. I'm afraid I can't specifically help you but what *is* a validOperationException? Seems like a strange thing to throw an exception about. Edit: words
Woah, the book has ETO samples in it? That's awesome! That may actually encourage me to get it.
Worked, BTW. Thanks. 
I wondered about that too, when I tried out Monodevelop. I put it down to my being a noob but it does seem - strange to say the least.
There is a workaround for the permissions issue at least. * In MonoDevelop, right click the project and choose options. * In the Build/Custom Commands tab hit select 'After build' and add this as your command, varying the flags to suit your taste: chmod 777 ${TargetFile} 
.NET executables are not ELF structured, so it would make sense to keep around the EXE extension to remind you to use mono or register a binfmt_misc handler. Treat it like java jars.
I assume F#, as a mono-based language, has no native code options.
You can make ELF (native) binaries with [mkbundle](http://www.mono-project.com/archived/guiderunning_mono_applications/#bundles), the output of which will have execute permissions. You should not add the execute binary on files that the kernel is not executing. You might also want to be looking at [ahead-of-time compilation](http://www.mono-project.com/docs/advanced/runtime/docs/aot/) which makes native "code" in a way similar to how [ngen](https://msdn.microsoft.com/en-us/library/6t9t5wcf(v=vs.110\).aspx) works.
Looks like this would be a bad idea in the light of the other comments here.
I hadn't heard of the function, but after some reading its new in F# 4.0 which come out in the last year. Here is a blog post about it that also suggests it is not on MSDN yet: http://bradcollins.com/2015/10/09/f-friday-the-seq-chunkbysize-function/
[F# for fun and profit](https://fsharpforfunandprofit.com/posts/list-module-functions/#13) has a good series on F# collections that includes information on List.chunkBySize.
Oh my gosh. well that will let me delete a lot of code 
While I'm at it: does anybody know what's the deal with F#/.NET Core and Visual Studio 2015? When I load my project.json file in Visual Studio it fails to restore. But `dotnet restore` works perfectly fine.
Also, can we use F# as a first-class language for Xamarin.Forms 2 from Visual Studio?
The .NET blog: https://blogs.msdn.microsoft.com/dotnet/ Another good set of resource can be found here: http://dotnet.github.io/support/
thanks you two!
Do you have a source on `project.json` being dropped?
I always watch the [ASP.net Community Standup](https://live.asp.net/), where Damian Edwards (Program Manager of ASP.net), Jon Galloway (Presenting community stuff) and Scott Hanselman discuss everything that's happening in .NET Core (and ASP.net Core) land.
Thanks, this might be my favorite new function!
More details of the binfmt_misc thingy here: http://www.mono-project.com/archived/guiderunning_mono_applications/ The curious thing is that although I have a deliberately vanilla Ubuntu/MonoDevelop setup, running the .exe directly from the terminal does actually work (once the permissions are set). Maybe MonoDevelop sets up a bnfmt_misc for you. Who knows?
Badly needed post, thanks Chris!
Awwwwwwwesome :D
I ready the article, but failed to see a concrete reason for using f
Best resource for "how" and "why" that I've seen: https://fsharpforfunandprofit.com/
I'm creating a general purpose performance testing library. I'm demonstrating that in F# this can be simple and yet have powerful features. This would be harder and less obvious to do in an OO language and hence you don't see it.
Ah. In that case, I doubt it since F# already fixed the Ocaml problems that Reason is fixing. F# problem isn't syntax, but rather windows stigma of .net (that is being solved already)
There is also the www.fssnip.net web site (using Suave + Azure) with source code here: https://github.com/fssnippets/
Really good resources! Thanks for sharing 
it also works the other way around - good windows support is the main reason i've started learning f#, because i'm developing a desktop that i'd like to be able to deliver to users on other platforms.
You seem to mostly compare with Rails and Django, judging from your arguments. Could you specifically compare WebSharper with Yesod on the points you mention (composability and type safe routing; I expect compile to JS to be lacking in Haskell at the moment) please?
If you installed Visual Studio without checking the "F#" checkbox, you can manually add it by browsing to Control Panel -&gt; Programs and Features -&gt; right click on Microsoft Visual Studio [Your Edition] 2015 -&gt; Change -&gt; Modify. Select the "Programming Languages -&gt; Visual F# option. 
Good stuuf - Suave and websharper open up some really interesting avenues for .Net web-fun :)
[removed]
There's not a lot to compare because they're both very similar in terms of being web frameworks in functional languages. For instance, Yesod has applicative and monadic forms just like WebSharper does. So as far as composability is concerned, you're in good hands if you use either. The same thing goes for routing: both languages use ADTs to represent routes and you can't match a route that doesn't exist because the possibilities have been encoded in the type system. Yesod has a very heavy emphasis on DSLs. The routing is done through the equivalent of a lisp macro which simultaneously declares the routing type and defines the routing function for you. That's pretty handy, but I prefer the WebSharper way of declaring the ADT yourself and using Infer. The reason? When I use Yesod, I have to learn all these funny new DSLs that are nothing like regular Haskell; intuition is lost. Further, you have to remember the dispatching function conventions. If you've got a route constructor IndexR that dispatches on a GET request, you need to follow the naming convention getIndexR for the corresponding function. What this means is that you've suddenly added quite a fair amount of stuff you need to learn on top of just learning Yesod the library: template Haskell mini languages and naming conventions. Now, WebSharper uses magic, too! I mean, using reflection to construct route parsing functions? How is that any less complex? The difference is that WebSharper usually preserves your intuition and builds on it. Routing maps really well to F# ADTs (even better than Haskell ADTs because of named constructor arguments in union cases). JavaScript functions and server side functions are compiled to RPC but they look just like normal function calling. Etc. And then there's using monad transformers. I think monad transformers are a hack and an intellectual dead end. I think they're interesting for combining several monadic effects but quite often you spend a lot of time thinking about how to go up-and-down the stack. The barrier to entry for Haskell is already very high and it can be hugely discouraging for people to finally understand monads but then discover that they now have to know transformers to do anything useful with benign side effects like database access and logging. So this makes using Haskell for large projects more onerous in my opinion, and of course others strongly disagree. There are frameworks other than Yesod written in Haskell. The most popular are Happstack and Snap. I have not really tried either but I heard that they don't have the same DSL fever that Yesod has. In any case, much of what I've said here is subjective, anyway, and just comes from my 4 years of using Haskell and 1 year of using F#.
The main problem I had was getting past their custom lingo. They have various random examples on their webpage but it is disorganized and I have no idea how to begin. For instance your first bullet point: "sitelets and formlets". What does that even mean? I want to like it because I would love to stay in one language. By comparison the Suave Music Store tutorial made it really easy to get started and understand what is going on in half a day.
The documentation on their website is, I think, fairly complete. In fact the documentation for those two things you mentioned explain quite clearly what they are: sitelets are composable html content servers, and formlets are composable html forms. Suave's music store tutorial is great! There's a chat client tutorial for WebSharper that might serve the same kind of complete beginning to end product. http://websharper.com/tutorials/livedata
I will also mention that Suave is a lot lighter and so coming up with a tutorial that uses all of the features is much easier. The reason WebSharper's documentation is larger than Suave is that Suave simply does less, per its intention. Also, I think it is definitely fair to point out that there is very little documentation on Suave compared to WebSharper. Their typed routes page is a single snippet of code, and it has no explanation!
Thanks for the proper comparison, it deserves a reddit post on its own :) &gt; So [monad transformers] make[] using Haskell for large projects more onerous in my opinion, and of course others strongly disagree. I agree, though you will mostly not need them when implementing a simple webapp in Yesod. And when you make a complex one, they will also "save your complex ass" from time to time. &gt; There are frameworks other than Yesod written in Haskell. The most popular are Happstack and Snap. I have not really tried either but I heard that they don't have the same DSL fever that Yesod has. I think it is possible to write the tedious code that the DSLs generate at compile time, but it is not very popular for obvious reasons. Compared to the other FWs Yesod is far ahead in features and community size, in my opinion. 
One thousand times this.
Websharper might be my favorite piece of technology ever. I love everything about it. The fact that you can make a client-side single page application almost exactly like you would do a regular multi-page website, and that you can mix the two as you like is wonderful. And it's brillantly using F# to do so.
I've heard great things about Elm. Maybe some good lessons there.
I think many people have been burnt from frameworks that try to abstract away JavaScript. Remember WebForms? Some of the problems would be compatibility with other JavaScript Frameworks, Gaps in Abstraction would be painful to close, Debugging buggy Client Code would be a challenge etc. WebSharper's goal is admirable and I'll keep my eye on it.. but honestly, I don't see myself using it in production
Thank you for taking the time to share. After falling in love with FP and F#, one of the most interesting areas for me is interop with C#. Which is absolutely coupled with perceived adoptability. An awesome part of F# is how seamless the integration of OO and FP feels.
I agree with this somewhat. You have to dig into the documentation and blog posts before you understand that the formlets mentioned on the site are actually legacy. It's my understanding that they're coming back in the next major release, but they're going to be reimplemented with the UI.Next libraries. Formlets, however, are not unique to WebSharper. I believe they're [based on this paper](http://homepages.inf.ed.ac.uk/slindley/papers/formlets-essence.pdf). Generally speaking, Formlets are "Applicative Functors", which is an FP concept that's broader than WebSharper. Sitelets, on the other hand, are sort of a mystery to me. They're "strongly typed" server-side web applications, meaning all the routes and params can be represented as regular F# types. I don't fully understand yet if Sitelets are applicatives, too. I've only ever allowed WebSharper to "infer" my sitelets from DUs. There may be an applicative-style composition API similar to Formlets. Nevertheless, Sitelets, Formlets (and Piglets too) are extremely useful abstractions. I wish more web frameworks implemented Formlets, because they are IMO WebSharper's major selling-point. The javascript transpiler is second and remoting third.
This is exactly what Suave does - to call the main Suave function you need to provide a configuration record object, but there's a convenient `defaultConfig` value in the global namespace that will give you a basic server (HTTP on localhost). There's a lot of things to like about that pattern, but I do see a few downsides: - IntelliSense won't tell you *what* those default values are, since `defaultConfig` is just an instance. If you want to discover the contents of that `defaultConfig` object, you'll need to fire up the debugger. - In your example, after I type `insertPersonBuilder` the compiler will just tell me that I need to provide an argument of type `Configuration`, but I'll have no idea where I can find one until I look through the library namespace. Suave mitigates this issue by prominently displaying its 'hello world' implementation on its homepage. I think that in .NET the gold standard for ease of use + flexibility are optional parameters. You type in `FunctionWithLotsOfArguments(` and Intellisense will immediately tell you about all the parameters with their types (and specific XML comments), *and* it will display the default value they assume if left unspecified. Sadly, a massive limitation is that default values must be compile-time constants, so "default to `IO.File.TextReader`" is not possible - you need to default to `null` and explain in the XML comments what the default will be replaced by. But other than that, F# fully supports named and optional parameters as long as they're on type methods rather than module functions. I think in many F# libraries you will absolutely want to have mostly if not exclusively module functions, but in cases where it already makes sense to have classes (for example, if your library deals with unmanaged resources which you'll want to put in an `IDisposable`) then optional parameters make for an even better tutorial experience.
[Here's a related approach using computation expressions.](https://gist.github.com/Porges/a7d59d416cd216f19a73) With this method you don't need to explicitly pass in the dependencies - they are implicitly passed around for you. (Although the example there doesn't show calling other functions that also use the dependencies.) Updated - here's a version with the types/functions in OP: https://gist.github.com/Porges/df9b386a7e5383dbc857ea8fe49f4b95
In general what is available for f#. Here is just an example: https://www.youtube.com/channel/UCCQPh0mSMaVpRcKUeWPotSA
If you're talking about conference talks, then I think that's a general issue with technical conference talks. An hour is seemingly selected arbitrarily as a good amount of time for a talk, even if the content doesn't justify it. Also, it takes more time and effort for the speaker to condense a talk into less time, and it doesn't seem right to complain about that for free content. However, I do see more and more conference talks coming in at 30 - 45 minutes so maybe organisers are coming round to the idea.
Good points. It also suffers in that your initial investment just to get started is far more expensive than other compile-to-js solutions.
**I completely agree with this.** Most of the F# content online is a video someone posted from a conference presentation. So you have the issue where: - The video is about an hour long - The audio may be hard to hear, especially on laptop speakers - There is no guarantee that you will be able to read the source code - Nearly every video has an intro talking about who the speaker is and what F# is, why it's so great, and who the F# foundation. *Nothing wrong with this, but I'm trying to use the video as a tutorial.* I would like to see more videos that are screencasts that are about 15-25 minutes long that run through a specific scenario.
State monad, bleh! I like computation expressions but I've never liked this kind of usage.
I'm having a hard time spotting where the functions dependencies are passed implicitly, care to point me in the right direction?
http://fsharpforfunandprofit.com/ Read articles and peruse code at your own pace.
Yeah, you can't really see it there (aside from the fact that `doMyThing` has no arguments). Here's an example using your types: https://gist.github.com/Porges/df9b386a7e5383dbc857ea8fe49f4b95 Note that you can decompose `insertPerson` into separate functions and you still don't need to pass around the dependencies.
Pluralsight courses like this one have been my go to resource for learning f#. I'm hoping the Pluralsight continues working to have more f# videos in their collection.
Haven't heard much about fable lately. Always struck me as unusual that it talks about being a cleaner compilation (in comparison to funscript I guess?) but I can't seem to find any actual examples of what the compiled code in javascript looks like to make that judgement for myself.
Why do this instead of using Xamarin from F#?
I have the same issue on the Alpha channel (I think beta is on the same build currently). Haven't spent much time looking for a solution, just put up with the annoyance right now. 
This was posted two months ago so you may have moved on by now, but just in case: have you tried closing and re-opening the file? That sounds so much like "have you tried turning it off and back on again?" that you may think I'm joking, but I'm serious: for a while, there was a race condition in Atom between opening the file and when the FSharp Compiler Service was ready. So when you first opened Atom, it wasn't able to give you type tooltips -- and the symptom was exactly what you're seeing: "open (namespace)" puts a red squiggly under (namespace) and complains that (namespace) can't be found. But closing the file and re-opening it works, because this time the FSharp Compiler Service is ready for input, and can inform Atom about what the namespace contains. So try ~~turning it off and back on again~~ closing and re-opening the file, and see if that fixes your problem.
&gt;set IE as your default browser ?
[Instructions](https://github.com/fsprojects/FSharpCommunityTemplates) on how to install the community templates.
Cannot navigate to definition. Source code is not available.
Thanks for the feedback! These are good points, I will think more in this direction.
Elm isn't used very much at the moment might be the reason. It's a shame as I really like the look of Elm, I'm certainly hoping it will become more popular. I agree in theory an Elm front end would fit better with F#.
Sure, but you could make the same argument against F#. Particularly if someone is going to use redux and a functional language anyway, elm seems like a completely appropriate choice. 
Well, this was from a fresh install of 2015 Community. When I clicked on Visual F#, there was an option to install Visual F# Tools (since It does not come installed by default). When I did that, it brought up a new installer which asked me to close Visual Studio, so I did that, and at some point during that installation, it said a package failed, and when I went back to try to install it again, it looked as if it had successfully installed those templates, except it wouldn't load or create any F# project, throwing an error. That's when I Uninstalled F# Tools, and the rest of what I did to attempt to get it back is in the original post. Thank you for your help! :)
You'd think, but look again. There's no reference manual to download, just a link to msdn. http://fsharp.org/about/index.html#documentation
This is the source to https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/visual-fsharp?
Right. That's what I want. Is your point that I could have just scraped it? Because that is a good point.
Oh, you want an offline version? I guess it'd be cleaner to compile from source then.
Some coverage of architecture and the surrounding 'ecosystem' and how it is used to build, deploy and maintain a larger scale application would be very useful. The existing courses cover the language itself and the 'nitty gritty' very well but I'd love to see something to address the wider picture. If I pick an open source F# project on GitHub at random, chances are I will encounter Paket, FAKE, etc. The use of these tools (nor even what their overall purpose is!) is not addressed in the existing Pluralsight courses. I really like the idea of a more advanced/high-level course where you talk through some of the architecture of a larger scale real word application (or possibly a handful of them to highlight different approaches?) and how to create and maintain such an application covering both the structure/architecture and all the associated build tools, dependency management tools and deployment/CI tools it warrants. A couple of worked examples* at a quick pace without dwelling on detail would be perfect. *Maybe even fix an issue from an open source project on github that uses a tool you'd like to demo? It's the 'Real World' aspect I think is missing from the existing ones and it doesnt get more real than that!
I do have those installed but the Rename option isn't showing for me on right click. (and I can't figure out how outlining works either) Edit: when I tried the keyboard shortcut on the website (Ctrl + R, Ctrl + R) it gave me an error that it is bound to a command Refactor.Rename but that it is not currently available
Why do you think f# is in that position? I find F# typed "just hard enough" for real work. I spent some time using typed racket, and got the feeling I always had to struggle with the type system. F# is a breeze in comparison.
Very interesting. Perhaps F# simply filters out the weak programmers by being different, "difficult" and/or "weird" and only good thus well paid ones do it? I've been working a bit with F# and I really like the way I start doing things the C# way, get stuck, find the F# solution (just like there's a pythonesque solution for everything in python) and I see all of those lines of blah blah blah code suddenly compact to one surgical line of exactly-what-I-meant code.
Purchased. I've been finishing up a docker-based microservice application with suave. Being new to F# and Suave (but not microservices), I'm sure there are some things that I can take from the book to make my application better. Thanks for making this available!
Purchased, I am liking it so far. There are some typos and maybe non-idiomatic f# code. Do you have a place where we can help report typos and discuss the code style? 
Thanks @NuvolaGrande for the comments. I've updated it. 
Thanks mofus for your interest. I just created an gist page to report the errors/typos. https://gist.github.com/tamizhvendan/987828aae0780b0394531798ce0138b1
perfect, will comment on that gist with any findings
Thanks Mofus
I would avoid .net core right now as its in flux heavily. Just create a new project through the File-&gt; Project -&gt; New Project dialogue and pick F# as your language. You can add a few lines of code, a breakpoint and it should work.
I don't really like their websocket support, I'd rather just use f# for my data pipeline and not fully buy in so I can get better tooling/support and projects with more of a thriving community. Thanks for your help though. 
Also I recommend docker for setting up the Postgres dependency :) look at it, it's great!
Also just some general guidance. let a = 1 //value 'a' which is an int let sayHi name = printfn "%s" name //value 'sayHi' which is a function that takes a string and return unit (signature is string -&gt; unit) let add x y = x + y //function that takes in 2 int arguments and return int (int -&gt; int -&gt; int) let add2 (x,) = x + y = function that takes 1 argument, a tuple of int and int and returns an in ((int * int) -&gt; int) You wont find yourself using a lot of parens and commas in F#. like maybe 10-20% as much as you would in C#, They generally has special meaning where as in C# they are just part of normal day to day syntax.
I tend to prefer match statements to if/else simply because it's more similar to the other code flows: match cell.checkConflicts head with | true -&gt; trySolveValues (Cell(cell.Row, cell.Column, cell.PossibleValues |&gt; List.filter (fun x -&gt; x &lt;&gt; head.PossibleValues.[0])) tail) | false -&gt; trySolveValues cell tail 
Also wanted to add that reading the first &lt;100 page of this book made processing lists recursively really click for me. https://mitpress.mit.edu/books/little-schemer
I've reduced my paren usage even further since I figured out, firstArg |&gt; takesTwoArgs &lt;| secondArg Edit: I also really like the ability to tuple args and still pass it as two separate arguments. Like when my function takes three arguments and I need to apply it to multiple values with the last two args being the same. let missingFiles = baselineFiles |&gt; findFilesMissingFromDirectory &lt;| repariableDirectory let foundFiles = baselineFiles |&gt; Seq.except missingFiles let fromAndToDirectory = (baselineDirectory, repariableDirectory) let modifiedFiles = foundFiles |&gt; getModifiedFiles &lt;|| fromAndToDirectory modifiedFiles |&gt; forceCopyAll &lt;|| fromAndToDirectory missingFiles |&gt; forceCopyAll &lt;|| fromAndToDirectory
Ah! This book is wonderful for thinking about processing things more functionally. 
It's tricky. I like [tryFsharp](http://www.tryfsharp.org/), but it only gets you through the most basic of basics. (This site uses Silverlight, so just be aware it may not work in chrome/Fire fox) So far I've supplemented my learning with random homework assignments I remember and project Euler.
While I suspect I might actually have to murder someone if they routinely did this: value1 |&gt; f &lt;| value2 I had forgotten about `||&gt;` and friends. So you get an upvote anyway for reminding me.
The F# community is small, but very warm and helpful.
&gt; This might seem a little disorganized to have a bunch of top-level functions, but that's what modules are for. That is literally the only reason I made a class like that, so if you have lots of top level functions in a module do you try and keep modules quite small?
understandable, thank you very much so far anyway!
Thanks Kurren for reporting this. I've changed the payment form.
I read that as "F*ckit"
Haha. That may or may not be intended.
Inline is a good trick. It was also explained to me in comment here: https://www.reddit.com/r/dotnet/comments/4nidxs/f_gotchas_for_c_developers/d44bm2y It has a bit different meaning though than .NET generics (which can be made in F# as well, just need to specify all the types explicitly in &lt;&gt;). 
Is it not allowed to have gotchas in 101? :) It's just that for a C# guy these things might not be intuitive in practice after going through theory and some crash course.
You can use .sql files with FSharp.Data.SqlClient https://github.com/fsprojects/FSharp.Data.SqlClient/blob/1f28569e218d65d042c995334c54c2c0a2e17cf0/src/SqlClient.Samples/WebApi.Controllers/DataAccess.fs#L8 
A lot of the stuff in the article seems kind of obvious to me, but maybe I'm taking a lot for granted after using FP for more than a decade. GC is not the issue it once was for lots of reasons. That said, I disagree with some of the things in the article. For example, I find it extremely unlikely that GC will move to hardware anytime soon. Language needs simply differ too much to really agree on primitives. The conclusions about pure code seem to be mistaken. See Haskell for lots of examples of pure code out performing side-effectful code. Sadly, many of those optimizations won't apply to F# because in Haskell you can make more aggressive assumptions in the optimization because things are pure by default. F# (and other ML-family languages) get to make other interesting trade-offs to get good performance, but they can't be as aggressive with rewrite rules.
To author of article: Please check this tweet: https://twitter.com/dsyme/status/743946462443233281
woah.. quite a big leap of faith going from 5000 unspecified updates to Uncharted kind of AAA don't you think? I love F# as much as you but I really don't see why gamedevs should waste cycles and memory like that just for the sake of using a cool language. Surely I am not using C++ because it is nice or cool or productive, I do it because my first requirement is performance, then comes everything else.
Working with Objective-C or Swift I have a hard time understanding the need for GC. We used to have it for OC but nobody used it after ARC was introduced. I see Android devs suffer getting similar performance on superior hardware while I don't notice downsides as a programmer. GC is a dead end and I wonder what F# would do with ARC in terms of performance 
Sorry, I now realize I should have titled it - Pure Functional Programming can work for Games.
No, I mean I had to ditch references altogether. There are use cases the GC just cannot cope with. F# not having pointers makes this extra painful. 
If you click the older version of the package in the nuget webpage it will give you the command to install it https://www.nuget.org/packages/canopy/0.9.52 You ca also right click on the packages folder in your solution and add a package. It should let you pick the version from a drop down. I dont have Monodevelop on linux, but Xamarin Studio on OSX is very similar and it has it.
What version of Mono do you use? I can target .NET 4.5 without any problems using latest version from Mono Project repo
Most conference talks are not meant to go more than 45 minutes to allow for questions after the talk as well as to allow time for setup/teardown between sets.
Replying to myself - I realised that I can change the .net target version by right clicking on the project/general and changing it there. Let's see how it goes! Thanks
I'll note there are a couple of good piece in the Expert F# 4.0 book specifically discussing these kinds of tradeoffs.
The UI type is the equivalent of the virtual DOM and there is a diff function on the UI module. Do you mean can we directly use the vDOM for Web UI's? I'm focused on WPF and Xamarin at the moment but anything is possible. I'm just realising how good a virtual UI is and not just an overhead. Helps simplify threading, removes two way binding, cleanly separates GUI controls, optimise update interaction, standardise the UI library, etc, etc. 
[The Elm Architecture](http://guide.elm-lang.org/architecture/index.html) is a lot more than a MailboxProcesser. It's a UI pattern. It's true that Elm has used some language ideas from F# and other functional languages. The UI pattern has evolved in Elm and has recently moved away from FRP to what it is now. F# has FRP libraries for the web but nothing like Elm. I'm more interested in using it for WPF and Xamarin at the moment.
 I don't think GC is even the first order performance problem when using a managed language for games (provided you don't do anything totally degenerate like allocate thousands of vector classes per frame, like Minecraft does) But it does add extra challenge when going for AAA quality, or on mobile. 
This.
What is your aversion to using Option types? They were created for these specific cases so that you don't have to come up with some "odd value" to represent a failure case and optional values. Is the issue anything more than just having to refactor already existing code that didn't use Option types to begin with?
From glancing through the F# 3.0 spec, it looks like the attribute should come just before the type name (i.e. after `and`). http://fsharp.org/specs/language-spec/3.0/FSharpSpec-3.0-final.pdf It doesn't seem to be covered anywhere in the reference on MSDN, though.
Something like this maybe? I do not understand what that last match is intended to do, but maybe it should be using a for loop to iterate over the elements or Array.iter or Array.map to map them, and then use the match on the individual elements. Edit: My previous example would give a type error. Here is an improved version. let rec DoReadCommand (maybeStr: string option): int = let DoReadCommand' (str: string) = DoReadCommand (Some str) // No need to pass in Some on each call. // If maybeStr is provided, print it. Otherwise, just proceed. match maybeStr with | Some x -&gt; printfn "%s" x | None -&gt; () let line = System.Console.ReadLine() line.Split() |&gt; Array.iter (fun item -&gt; // iterates over each of the elements. match item with // ... ) 
The error i'm getting is pointed at the first attribute, as if the whole concept of "type X... and Y..." is a language element that isn't a type declaration. If I try to put the attribute after "type" but before "X", the compiler goes nuts (points at "errors" later in the file, which magically go away once the test code is removed.)
Having followed [this link](http://blog.ploeh.dk/2013/10/15/easy-aspnet-web-api-dtos-with-f-climutable-records/), the attribute over the type works as intended 
I just wrote a test program, and it looks like the attribute at the top applies to *both* of the types. EDIT: Oops, stupid bug, it was showing the attributes of the first type twice :(
This is working for me now: [&lt;CLIMutable&gt;] type abc = { efg: int } and [&lt;CLIMutable&gt;] xyz = { efg: int } I'm not sure what went wrong before. Maybe it was just a problem with the newlines? F# is finicky about newlines.
It's needed because in F#, a declaration is not in scope in the code that precedes it. This makes it impossible to create mutually recursive types and functions. The way around this limitation is `and`, because anything within the scope of a single `and` chain is in scope in all of the declarations in that chain. So, this is bad: type t1 = { a: t2 } type t2 = { b: int } But this is OK: type t1 = { a: t2 } and t2 = { b: int } For that example you could solve the problem by reordering the definitions, but consider this: type t1 = { a: t2 } and t2 = { b: t1 option } C has the same limitation with declaration order, but it gets around it with forward declarations. Java gets rid of the limitation entirely by saying that declaration order doesn't matter. 
im looking forward to the day that VS code allows us to modify the file order list rather than forcing it to be alphabetical. Having a visual representation of the compile order of my fs files is the only thing stopping me from switching from VS to VS code
Which a little ridiculous of a thing to have to need, honestly. I never see the compile order of my source files in... * Java/Scala/Groovy/Clojure/Frege/Kotlin * Rust * Elixir * OCaml * Haskell And yet, somehow, all those languages are totally usable to me! (Well, okay, I don't like Groovy and Clojure so much, but that's just personal preference) It's almost like file compilation order is irrelevant to humans and only matters if the human has to do the compiler's job for it.
They pushed out the advanced features.
F# still has some things C# doesn't have, and is a lot terser imo. It will stay but it will stay the same niche it always has been.
https://github.com/dotnet/roslyn/issues/10866 https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md I submitted a discussion about it [here](https://www.reddit.com/r/csharp/comments/4hh6sj/pattern_matching_features_severely_cut_for_c7/) to the C# subreddit a while ago. Records and non-nullable types are definitely not in. Pattern matching is in, but only in statement form, and severely limited (e.g only "type" patters, like `x is int i`). Nothing recursive or expression-based, like F#. Not sure about tuples. e: added another source
Well I'll be damned. Thanks for the info!
To me the linear compilation order would be worth it alone.
No. Every language is useful in some way that another is not. C# is a general purpose OOP language. F# is a functional language making it better suited for some things than C#. Yes, you can do functional programming with C# and you can do OOP with F#. Has C# replaced any other general purpose language because it has all of the same features? Other than VB.NET, no. Though even VB is still useful for Excel macros and I think it's used in Report Builder and PowerBI.
C# will probably never have non-nullable references. It might grow into C++ size of compiler candy to try to make you help forget that fundamental problem in the language but you really can't go back from programming languages that allow you to trust your pointers.
Once I got used to it, it was a weight off my shoulders - now I don't have to wonder if my system hierarchy is in order, because it can't be out of order. 
It seems like some of the features would be pretty hard to implement in C#. Discriminated Unions for one (partially due to the other stuff like pattern matching that would have to come over to make them fully effective). The pattern matching that is planned for C# seems to be a bit less robust than what F# already has. I'm not sure I could recursively parse and pattern match commandline arguments as elegantly as I could with F#. It would be pretty cool if they do manage to get there. There's a lot of really smart people on those teams :) 
It's wonderful to open up a big project and immediately see the hierarchy of layers involved. Definitely one my favourite f# features.
&gt; C# will probably never have non-nullable references. They are actively working on this.
When C# gets these features it will be very hard to get F# adopted in the workplace. It's hard now. Just imagine how much more difficult it will be when many of the features that make F# shine are also in C#. Saying that F# had it first or that F# implements them more elegantly won't count for much. F# just isn't innovating like other languages. I've been using it for about 6 years and there have been only minor new language features in all that time (Type Providers as great as they are, aren't really a language feature). In that time C# has steadily added new language features. So has OCaml, Haskell, Clojure, D, Rust, and so on. Is F# so good that it doesn't need additions to the language? How about type classes or some mechanism to provide ad hoc static polymorphism, a more generalised and powerful computation expressions implementation, GADTs or higher kind types. Perhaps some of what has been learned implementing F7 or F* could prove useful. Perhaps it's the small F# development team size that is causing the language to evolve so slowly. Maybe the design team are held back by the limitations of the .NET type system. It could be a combination of these plus other factors, but whatever it is, F# 5.0 had better have a least a few compelling additions to the language otherwise it's future doesn't look too rosy. One thing is absolutely clear. When C# gets these features, those of us who are trying get F# adopted in the workplace will find it very difficult to convince management to give F# a try because many of most its powerful features won't be unique anymore. The only way to tackle this problem is to add more powerful language features. I hope the F# design team aren't holding back because advanced language features like type classes or higher-kinded polymorphism may involve type erasure and won't be useable from other .NET languages. Features that are only usable in F#, like units of measure or statically resolved member types, would not a problem at all to most F# users.
And how is F# different in this regard?
However, I think I'd still like to ask the same question: do you think that C# getting some (or maybe eventually all) of these features will decrease F# adoption? See mongreldog's comment below
&gt; it won't be for another few years (at least) that C# has comparable features -- so I don't see the urgency to improve F# I think he's saying there will be a point where C# does overtake F# in language features due to their relative speeds of improvement. No urgency in improving F# means we wont stay ahead of C# for long. &gt;adding features such as DUs and pattern matching to C# makes those features more mainstream and less scary That is true. Do you think at appeal will be added to F# or taken away as a result of these features being added to C#?
F# is compile time safe (i.e. won't compile code that generates nulls unexpectedly) unless you do some dirty hacks or use .Net libraries in a weird way. C# will show a warning and since all old code starts to show you these warnings you might want to turn these warnings off because they'll force you to refactor all your old code. A warning will end up in production, something that doesn't compile sure doesn't. A method in a library that says that it promises you a normal (non-nullable) pointer is still allowed to return you null and screw with your application's stability. It's just a warning and it isn't much better than what ReSharper already does. It's not possible to tack on real null safety as an afterthought on a language without really breaking stuff or not really fixing stuff. F# either doesn't compile or it forces you to deal with optional values before you can use them if you're doing calls between F# code. F# can't be completely pure since it needs .Net which wasn't designed with that in mind but it works really well regardless. I can trust F# in every case.
That's better than I expected. Thanks for the explanation! 
&gt; When C# gets these features... When C# gets these features... Are you holding your breath? 
&gt; I really, really really really really don't want F# to go down the scala route and get stuck adding in a bunch of shiny new features, making a horrendously complicated and inscrutable language in the process. +1 
&gt; I think he's saying there will be a point where C# does overtake F# in language features due to their relative speeds of improvement. How are they ever going to fix the billion dollar `null` mistake in C#, for example? &gt; Do you think at appeal will be added to F# or taken away as a result of these features being added to C#? I think it is largely irrelevant. 
Everyone has been actively working on this for decades. 
No significant difference. C# already has some of the features of F# but you need to reach a critical mass for them to be useful. C# doesn't have any pattern matching. Maybe C# will now get a little pattern matching but only one level deep. Then you want arbitrarily-deep pattern matching. Maybe C# will get that some day. Then you want recursive functions pattern matching over your recursive types so you need tail calls. That's an invasive change to C# so maybe it will get manually annotated tail calls (yuk!). And so on. F# is attractive because it is elegant. The idea that C# will become competitively attractive by slapping on more mud is as absurd as Herb Sutter's "C++ renaissance". They already slapped half of these features on to C++. Are you rushing to go back? C++ is still fundamentally memory unsafe just as C# is fundamentally null unsafe. 
I don't know C#. Could you please translate the following F# lambdas into C# syntax for me so we can have a more representative comparison: fun n -&gt; n fun (a, b) -&gt; b, a fun m n -&gt; m+n fun (p, (q, r)) -&gt; p+q*r fun (x, None | _, Some x) -&gt; x function [] -&gt; 0 | (n,_)::_ -&gt; n 
&gt; Though I haven't used F# in practice enough to know if that's actually a problem. The only problem in F# is that Visual Studio Community 2015 doesn't honor the order of fs files in a project so builds randomly break and you have to dick around endlessly to "fix" it again with no idea what the actual problem is. 
What null mistake?
&gt; It is my no 1 favourite feature of F# There are benefits to reap from required ordering of files as fed to the compiler. But I don't think this is a feature. I think global type inference would probably explode if file order wasn't required.
Have a look at: [Null References: The Billion Dollar Mistake.](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare)
Thanks, I was looking for this but couldn't find it.
Right. So C# is more concise on one of my examples but none of the rest. I'm curious how much more verbose C# is on my last two examples... 
On the bright side, writing some of my F# code with the older C# pattern matching made me *really* appreciate type inference and automatic generalization! ;)
Well, with the old pattern matching, a bit more verbose. The implict pattern matching would have to be converted into a `case` or `match`. With C#7 pattern matching, it would not be possible to express the last few as expression-bodied members, you'd have to make a statement arrow, and do some imperative code. 
&gt; You're missing my point. I disagree. &gt; F# is successful despite being uncommon because it is used to solve important hard problems. By that reasoning aren't nearly all languages successful? People use all sorts of languages, both elegant and inelegant, to solve "important hard problems".
C# lambda expressions are more concise. The extra concisement (is this a word?) is from features that don't exist in C#. 
&gt; By that reasoning aren't nearly all languages successful? People use all sorts of languages, both elegant and inelegant, to solve "important hard problems". People do not use "nearly all" languages to solve important hard problems. 
&gt; The UI type is the equivalent of the virtual DOM and there is a diff function on the UI module Can you elaborate on "diff"? You mean set difference, right? If so this is very interesting to me because I just spent a month writing some industrial code in OCaml that consisted mostly writing my own in-memory database holding values of a record type and then working out how to send the differences over the wire to subscribers so they can keep their own equivalent copy of the database up to date. I found it so irksome that I dreamed up a language that would have first-class databases that support `diff`. :-) Hadn't occurred to me that UIs have the same problem... 
What important hard problems are solved in Brainfuck and Whitespace, for example? Have a look at just [some languages with names that begin with 'A'](https://en.wikipedia.org/wiki/List_of_programming_languages#A) and try to come up with important hard problems solved with them. Most languages aren't even used to solve any practical problems, much less important or hard ones. 
See, now you're just being pedantic in a thread using generalized and *technically* incorrect statements, rather than providing any actual argument which could back up your statements that F# is "used to solve important hard problems". What is your argument here? Do you have anything to back up that statement? Were you also meaning to imply that other languages aren't used in this manner? Specifically, C#? What about other languages? You also never refuted the previous statement, &gt; Elegance is nice, but probably not even in the top five attributes that determine how successful a language can or will be. Nor did you attempt to call bullshit on this statement. You sidestepped to redefine "success" in the context of this argument and shifted the conversation to *that*, rather than what the original poster was referring to.
Good thinking. Out of interest, whats the difference between discord and slack?
Hmmm, when you say you found the opposite to be true, are you talking mostly about C?
Mainly C++ but also C#, Java etc. 
Both are essentially trying to be replacements for Skype et al. However, Discord is more targeted at the gaming crowd while Slack is aiming to be more of a solution for business, and this is reflected in the features that each has. For example, Slack provides more robust add-in support and control over notifications (including being able to set schedules, etc.) but Discord has features like a cross-server friends list and an integrated voice chat service (voice channels are defined the same way as text/chat channels and work almost exactly the same as something like Mumble/Ventrilo/Teamspeak). Personally, I prefer (and am using) Discord even for non-game, dev-related teams.
Sometimes it just takes a while for Ionide to finish processing. Try waiiting a bit then closing and reopening your source files, and maybe waiting a bit again. As an aside though. Visual studio is free. It seems popular for people to complain about it, and then they complain about all these other tools because they are not nearly as complete as visual studio is. Point being, if you have Windows anyway, why not use Visual Studio? General performance is better than Atom+Ioinide, you get a debugger, easier build/run integration, easier project file management (Except...for folders...sigh) 
I was able to put extensions together to make for some pretty cool workflow in atom, but with medium sized source files I would quickly run into performance issues. VSCode is much better about that, might be worth a try if light weight is the goal.
C# may reach feature parity with F#, but it will never be F#, and the reason is that C# is OO first while F# is FP first. In other words, the functional style is not idiomatic in C#. It's harder to write FP code because functions aren't curried by default, there's no composition, custom operators that allow writing in applicative or monadic style (although it's possible in C# with LINQ query comprehensions). Furthermore, C# doesn't encourage FP style the way F# does. On the contrary, F# punishes you for writing in an imperative OO style. So you likely won't have a situation common in Scala shops where half the devs are writing Java++ while the other half are writing Haskell-lite. F#'s ML syntax is also much more terse whereas C# contains more line-breaks, braces, etc... The signal to noise ratio in F# is higher. Many of the F# features that also appear in C# seem much more bolted onto the C# language. Eg. async/await. The implementation in C# is quite different and often more surprising. It's also coupled to the TPL (if I understand correctly.) whereas F#'s async is derived from ordinary language primitives. It's also possible to write different async implementations in F#, so you have more control. Finally, the F# community and ecosystem is much more independent of Microsoft than that of C#, where Microsoft's frameworks and tools are orthodox. This is the biggest differentiator in my mind. I don't know if you noticed the tone of the recent blog post announcing .NET core 1.0, but it was presented like a decree. "Here's how you will build applications with .NET Core." You can't help but feel like you're being spoonfed, which is even more obnoxious after the Project K -&gt; DNX -&gt; DOTNET CLI churn. You don't get the same sort attitude from F#. It all seems more collaborative. 
Maybe give VS Code a try? It's similar to Atom in that it's not a full fledged IDE but more of a text editor with some IDE features. Also you could maybe give [Cloudsharper](http://cloudsharper.com/) a try, if you want a really lightweight solutions considering it's a fully cloud-based IDE.
IntelliJ is pretty extensible, and you can have nice plugins on the community edition, so there's no reason people can't create an F# extension to it. Heck, there are even a Perl extension for it 😂
Why wouldn't it make more sense to work on Mono and resolve any issues between native .Net, CLR and Mono? I'm exclusively a Linux developer and never was a fan of Mono and especially not .Net until F# came around. I write in Clojure when it comes to JVM but would prefer an ML styled language, type system, etc. etc. which got me into F# in the first place. Sure JVM runs on everything but if you look at how slow community effort is to get non Java languages to support the "Billions of Device that run Java", starting an effort to get FSharp on JVM seems like a bad idea. Clojure or Scala development directly on Android...still a huge pain unless you are ok with doing some weird hybrid where you write libraries in your preferred language and the UI in Java. Just because Java runs on everything, doesn't mean it is easy to work with. Yes you get all the libraries but at the end of the day that is not the issue. The issue is your targets. Communities will be able to generate libraries if there is a need, but if your code doesn't run on Mobile, if it doesn't run on AWS, if it doesn't run on a toaster then who cares if you have every library under the sun. You need a community to do the work and right now the major issue I see is that .Net is great for Windows development and just so so for everyone else. Windows has not been a great environment for growing an open source, work for free cuz you love the project types of communities. Right away your support base is pretty small as F# is still not even close to the number one choice for ML developers in non-Windows. Porting your language over means you need people who love the language to do the work, as no one else will want to work on it. On the other hand, trying to get more people interested in Mono might be easier. Mono is useful for C#, VB, and F#. C# is the defacto Windows platform so you should be finding a larger base of developers to work with. Fixing issues in Mono, and porting it over to other platforms should provide a much larger mutual beneficial target for people to work on. Just think if you could get all the C# coding houses to put a little effort into Mono. Would be much more support than getting every single F# developer to put time into porting it from CLR to JVM. 
You are right about that. If the jvm path is not on option then just bringing stellar support for developing fsharp on osx and Linux with perfect intellij or Eclipse support might work.
&gt; Maybe Microsoft will make a java to .net compiler again that makes it possible to leverage all the good java libraries on .net. who knows. Have you tried [IKVM](https://www.ikvm.net/)? CLR IL bytecode being richer than JVM's means that libraries can be ported almost verbatim to .NET. Actually, I do not have experience with Java's libraries, but I was not under the impression that the .NET ecosystem was inferior to it in terms of offerings.
Downvoted as you predicted :). That said, Scala isn't exactly a model of success either. It's being challenged by lighter alternatives like Kotlin. Rise of CoreCLR is the most important thing. JVM got lucky by being on Linux at the time people realized they didn't want to deploy on Windows
Scala has higher kinded types, however it's all compile-time tricks that uses type erasure to get to the runtime. F# uses generics in the .NET runtime (in fact, it brought generics to the runtime), and does not use type erasure. It would be *significant* work to have F# as-is and with the same behaviors work on the JVM.
Every time C# gets picked over JVM, F# wins (as it creates program surface you can use the language against)
Tail call elimination doesn't work as well on the JVM which is a pretty bad problem to have for a functional language. I think better to focus on improving the Fsharp compiler and ensuring .NET has first class runtimes on OSX and Linux. A fully functional IDE for linux/osx would be good too. The Ionide guys are doing amazing work to approximate that but it isn't quite as nice as the Visual Studio or Jetbrains experience. 
&gt; Could be an Fsharp subset Those never go anywhere. Either people get frustrated that the one thing they need is missing, or they learn the subset thinking its the real thing and generate lots of bad code.
This will not work because at *minimum*, it SPLIT the market of F# in two: Java land and .NET land. And people that use Java mostly don't wanna use .NET, and the opposite is true; ie: Not *everyone*, but Java/.NET are not only 2 different virtual machines but HUGELY different and truly the most close to TRUE ENEMIES ecosystems in the soft industry, by proxy of: - *nix vs windows - Sql Server vs mysql/pg - MS vs Google - Visual Studio Vs wahtever the java guys use - etc This is a HUGE split. Instead, ruby vs python vs perl vs erlang vs almost everyone else is more a matter of preference and are more *firendly* towards each other... And Java sucks! ** run away with a maniac laughs!** 
People are worrying too much about this, the people in the F# community who actually work on tools are very committed to making the F# dev experience high quality across all platforms. The dotnet cli makes it easy to add extension tools to let you customize your build process however you'd like. Don't buy into the FUD ;P If you want to help improve xplat F# tooling contribute to - - https://github.com/ionide - https://github.com/fsharp/FsAutoComplete
I prefer paket/fake for builds. As long as the new dotnet cli plays nicely with these, I'm happy. Ionide is fantastic, and the VS Code experience might almost be close enough to abandon VS. Nothing against atom. It just feels sluggish, the REPL's kind of weird and the intellisense is kind of spotty.
F# is a ML based language on .net/CLR that fills a niche there - if you want native or want to switch from the CLR just go Ocaml. As long as it's about the language (F# ist really a simple FP language) not the frameworks/libraries you'll have a good head start if you switch to ML/Ocaml or even Haskell - yes all niche but well - people dream in Objects and that probably won't change for quite some time) Heck why should it not survive? And going into JVM is surely NOT helping it to survive (for some time it did look like Oracle had lost interest in Java, now they lost their suit against google/android, ...) Also while not perfect Mono is already a good way to support F# on non-windows environments and once .net core get's going it probably becomes even better (I cannot really see the difference between JVM and .net core)
Well that is another enemy ;). I think in Google by proxy of Android (I know them use another java implementation, still it hold IMHO)
Look at 'String.Split(..)' and 'Int32.TryParse(..)'.
Thanks for the feedback. I will give the interactive option a shot first but might be a while before I can switch to Paket.
I did this GUI with F# and XAML on Visual Studio 2015: http://www.gburri.org/parasitemia/ (source code can be downloaded from the web page). If you want a portable GUI library, check Eto: https://github.com/picoe/Eto
I think F# is excellent for UIs. Use FsXAML. You can start with the "F# empty windows app" which uses FsXAML. You can use the XAML designer and FsXAML will load it and you will have typed access to everything inside.
You can also use [Yeoman](https://github.com/fsprojects/generator-fsharp) to generate a F# WPF Project
raspberry pi
For web or wpf app development
No Visual Studio. 
Since you're asking if it's good enough, the answer is yes. I've used much less and Visual Studio works great. You'll notice that the larger the project the more memory you'll need to debug it. If you get Visual Studio 2015 Update 3 you'll be better off since it uses much less memory than previous version when debugging. 
While it's true that you can write and debug F# applications on a Raspberry Pi, I find it to be slow and unproductive. 
I don't understand your comment. What problem you see with the advice?
Of course, yet all of that provide tangible benefits for coding: - Fast CPU benefit compilers. Multi-core benefit some of them, but also having 2-6 help balance the load. Plus,provide the base to do parallel code - RAM help everything, including a IDE like VS Studio and host VM, Database engines, etc - Fast I/O is a serious performance boost that accelerate a lot of stuff related to programing in ways that pay off more than CPU this days for more kinds of tasks - Multi-Monitor setup is a proven performance boost. Quality screen and 2K/4K (if posible) is also great - Quality devices (mouse/keybs) are part of the ergonomic experience. I have a similar setup, despite 3 years old (and not Retina :( ) and I can run OSX, Windows, XCode + iOS simulator, Sql Server, PostgreSQL, Xamarin, Visual Studio AT THE SAME TIME, and much more at ease. 
I'd wait for watercooled versions.
No, this is stupid. Someone can quite happily make amazing software on a Chromebook. Speeding up responsiveness of a computer is not necessary for "what configuration of PC is will be good enough to code F# in Visual Studio". Good enough is a £400 computer, and even that's more than satisfactory. * OP doesn't need a 'gaming mouse + Mechanical keyboard'. * They don't need 2-4 monitors. * They don't need "as much RAM as you can buy and install". * They don't need an SSD "as large as possible". For coding locally on most projects, they **need** a low-mid-range CPU (2 cores is fine, each is faster than 4 cores), 2GB of RAM, 100GB HDD. What they *could* have to speed things up is another matter entirely but presented as *need* could cause someone to waste money they may not have.
I think this does not work in VS Code right?
X-Post referenced from /r/programming by /u/Cylons [Continuous - A C# and F# IDE for the iPad](https://www.reddit.com/r/programming/comments/4rjzsb/continuous_a_c_and_f_ide_for_the_ipad/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Thanks for all your work on FsLab, I love it! 
I'm afraid we need to have this person in the office.
I don't mind to move to Denmark, but I'm not sure about work visa. Is it required?
&gt; mark, but I'm not sure about work visa. Is it required? Yes, you will need working visa.
For patterns, this may help http://anthonylloyd.github.io/blog/2016/06/20/fsharp-elm-part1
I know some people do not enjoy using Visual Studio with F#, but these tips might make it a bit more pleasant for you. F# featured in the final "after" screenshot. 
That's great! You can also disable line numbers, since current line is visible in the status bar and you can jump anywhere with CTRL+G. "Selection margin" &amp; "Indicator margin" are useless too(try setting a breakpoint and discover that they look better without these). And finally, some icons(like VCS-&gt;show history) would be useful to have in title bar, and there's a [vote for this feature](https://visualstudio.uservoice.com/forums/121579-visual-studio-2015/suggestions/12426123-allow-moving-toolbars-into-titlebar).
I'm the exact opposite. I always enable line numbers in editors that disable them by default, it's weird to not have that information clearly visible where I'd expect it. A status bar with a line number doesn't give me a sense of locality.
c++ to f#! 
Love the concept - was just thinking that something like "Elm" could be a nice niche for F# as a best of both worlds integration. Great work!
In case you're still looking, Xamarin sponsored us to create a free intro to F# course which would be good for getting you started: https://fsharp.tv/courses/fsharp-programming-intro/
As I'm writing in OP I have Haskell experience. On the other hand your course states that it is for: &gt; Anyone new to programming It does not seem like you're course is what I'm interested in.
why not use CTRL+ALT+SHIFT+ENTER? it does most of the job in single chord.
That does not eliminate the selector and indicator margins, it does not eliminate the code outlining, It does not remove the navigation bar, it does not remove codelens, It does not set autohide on the solution explorer (I think, not clear, it may be the default in that mode) 
I notice the following There is a parameter in one of the methods with two attributes in the .cs if I use C# to add a web reference [XmlAttributeAttribute] [XmlIgnoreAttribute] createDateTimeStamp When I use F# with the Wsdl Type Provider it does not include the property in the method signature but it does include it in C#. Is there a way to tell the type provider to include input parameters that have attributes marked with [XmlIgnoreAttribute] in the method signatures ? Maybe this is a bug in the type provider ? 
I just thought it would have been a good tip for readers, not so many people use that feature.
Nothing is without choice, advantages and disadvantages. 
Fair enough. I've added a tip about Full Screen. Also added a tip about handy VS extension https://jackmott.github.io/programming/tools/editor/ide/visual/studio/2016/07/11/decruft-visual-studio.html
I'm guessing you meant to post a link, but it's not showing up.
I guess your best call is to submit an issue to the project, possibly with a .wsdl to reproduce it.
tools options text editor languages fsharp check navigation bar that work? 
I didn't know the navigation bar option was in there. Its dimmed out. Very strange. I even relaunched VS to ensure i was running it as admin and the checkbox is still disabled. 
&gt; I couldn't get F# working on linux The problem of most F# tutorials and books is that they assumes that the user is using Windows and IDE like Visual Studio and knows the .NET framework, specially C#. F# on Linux, MAC OSX and other Unixes relies on Mono implementation of .NET that doesn't have all features that .NET (Windows only) has like WPF, Silverlight and Xaml. Another trouble that I faced to run F# on Linux was the repository versions of Mono was out of date. I hope that after Xamarin/Microsoft deal F# and Mono improves. &gt; .. decided to just stick with OCaml) ... OCaml has some unsolved problems like the missing multi-core support, lack operator overload: it means you cannot write *10.23 + 20.0*, you must write instead of that *10.23 +. 20.0* and lack of enough libraries like F#. Another feature that I miss from F# in Ocaml is the single line comment // instead of (* comment *). &gt; or has the language changed enough that the best practices are very different? Linux and Nixes has less integration with .NET (Mono) and the user must use more command line tools that aren't show when its assumed that the developer runs Visual Studio or similar IDE. Example: This code from - http://fslab.org/FSharp.Charting/PointAndLineCharts.html Doesn't work on Linux. The package that must be used is: FSharp.Charting.Gtk instead of FSharp.Charting. // On Mac OSX use FSharp.Charting.Gtk.fsx #I "packages/FSharp.Charting" #load "FSharp.Charting.fsx" open FSharp.Charting open System // Drawing graph of a 'square' function Chart.Line [ for x in 1.0 .. 100.0 -&gt; (x, x ** 2.0) ] The best way to install packages in the project directory is to use the utility Packet that downloads a package with all its dependencies to directory packages in the current working directory. Here a working Linux example: - In the shell $ mkdir fsharp &amp;&amp; cd fsharp # Download paket $ curl -O -L https://github.com/fsprojects/Paket/releases/download/3.8.1/paket.exe $ mono paket.exe init $ mono paket.exe add nuget FSharp.Charting.Gtk $ fsharpi - In fsharp shell - #I "packages/FSharp.Charting.Gtk" ;; --&gt; Added '/home/arch/fsharp/packages/FSharp.Charting.Gtk' to library include path &gt; #load "FSharp.Charting.Gtk.fsx" ;; [Loading /home/arch/fsharp/packages/FSharp.Charting.Gtk/FSharp.Charting.Gtk.fsx] &gt; open FSharp.Charting - open System - ;; &gt; Chart.Line [ for x in 1.0 .. 100.0 -&gt; (x, x ** 2.0) ] ;; val it : ChartTypes.GenericChart = (Chart) &gt; You can also download the package directly in the FSharp shell. $ fsharpi &gt; #r "paket.exe" ;; --&gt; Referenced '/home/arch/fsharp/paket.exe' (file may be locked by F# Interactive process) &gt; Paket.Dependencies.Install """ - source https://nuget.org/api/v2 - nuget FSharp.Charting.Gtk - """ ;; val it : unit = () - #I "packages/FSharp.Charting.Gtk" ;; --&gt; Added '/home/arch/fsharp/packages/FSharp.Charting.Gtk' to library include path &gt; #load "FSharp.Charting.Gtk.fsx" ;; [Loading /home/arch/fsharp/packages/FSharp.Charting.Gtk/FSharp.Charting.Gtk.fsx] &gt; open FSharp.Charting - open System - ;; &gt; Chart.Line [ for x in 1.0 .. 100.0 -&gt; (x, x ** 2.0) ] ;; val it : ChartTypes.GenericChart = (Chart) &gt; Here the Chart: http://imgur.com/a/PFsx1
That was removed: https://github.com/fsprojects/VisualFSharpPowerTools/issues/1380 A navigation breadcrumb feature will be integrated at some point but it won't have the dropdowns. Please comment on the issue with remarks / ideas: https://github.com/fsprojects/VisualFSharpPowerTools/issues/1446
Well this seems to work, ~3x faster than Array.reduce type Array with static member inline SIMDReduce f (values : 'T[]) = let mutable i = 0; let mutable result = Vector&lt;'T&gt;(Unchecked.defaultof&lt;'T&gt;) while i &lt; values.Length - Vector&lt;'T&gt;.Count do result &lt;- f result (Vector&lt;'T&gt;(values,i)) i &lt;- i + Vector&lt;'T&gt;.Count result But you have to flatten out the result vector when you are done..hmmm
Yes I used 16 million floats, accounted for JIT warmup etc. Assume intermediate level of competence on my part :) I've played with it a few different ways, using Linq directly, etc, everything just goes slower. Perhaps there is some fixed per-item overhead that is too large to be worth it on such few operations. Though, if I did this by hand it would definitely speed up. 
so i realized the nessos streams library has parallel versions and these perform very well. 
There are quite a few gems to be found in the book when it comes to purely functional algorithms. In that respect it's still relevant and worth a read.
F# doesn't support that. I *think* it's called contravariance. You need to cast your classes to the parent class. Edit: I guess one way of doing it would be to have your function generic for, say, type `'a` , when `'a` inherits your base class. Then specify your argument to be of type `'a`
Just as with lists &amp; arrays, it's sort of lame that slow stuff gets to keep the pretty syntax "(1,2)" while the fast stuff needs syntactic overhead of "struct (1,2)". 
Very nice :)
Yeah, one big `filter` can cause GC churn – now make that one per thread on a server... Yikes! It appears value types are only supported for _single_-case unions, so that's of no help for rolling one's own `Option` (or `Choice`), and in any case it wouldn't play nice with the collections modules.
Is solution management a planned feature for Forge? If so, would it be something an outside contributor could take on? Edit: just found this: https://github.com/fsprojects/Forge/issues/63
Tuples usually aren't that large, I wager
I have been facing similar problem. Created a ticket (https://github.com/fsharp/FSharp.Data/issues/965) but no help till now.
Not a bad idea, I've asked if they are interested in their discussion area. 
The lack of activity on this server actually disappoints me as a new F# learner :C
Many "classic" desktop GUIs are new browser engines under the covers, and they work very well. Heck, VSCode + Ionide is a good example of this.
This is perfect, thank you!
I had trouble following WebSharper as well, but it looks very interesting. Try Suave.IO out, they have a tutorial that is excellent and easy to follow: https://www.gitbook.com/book/theimowski/suave-music-store/details Once you get through that you might have more familiarity with F# and the WebSharper docs might make more sense 
Still I think is better to focus in the fundamentals that dive into a specific path at the start. This resource help me: http://fsharpforfunandprofit.com/ 
*Self-promotion alert* There are some nice F# courses on Pluralsight if you want to go a bit deeper, including my own F# Jumpstart: https://www.pluralsight.com/courses/fsharp-jumpstart
ah, that is a good tip. yes it is used later as well. i will take a look at that. thank you.
Yep, you were right on. Was using it in a lambda below. Fixed that, it became a nice for loop, and faster than the recursive solution by a little. Thanks again. 
Happy to help! I see that [System.Numerics.Vectors](https://www.nuget.org/packages/System.Numerics.Vectors) has left the prerelease mess behind, that is nice. 
It is not terrible. I wish it had full coverage of Intel and ARM SIMD operations, and I hear it has some unnecessary bounds checks at times. Hopefully it will improve. I was really itching to implement a SIMD-enhance Array.reverse, but without shuffle I don't think I can. 
Jared Hester has done a great job at helping refactor this into a proper library, with testing and benchmarking frameworks, build scripts, etc. I've been adding more functions and tweaking performance. I've got some benchmarks up now in the readme: https://github.com/jackmott/SIMDArray
I just noticed too that the same MissingMethodException is thrown when TryGetAttribute is used on the HTML provider. It's probably safe to say that the overall FSharp.Data type provider does not work well with the latest Visual Studio 2015 update.
Try using the :&gt; operator to cast the Control subclasses to Control, like this: new Form() :&gt; Control. You will have to cast in this fashion on each branch, but then your function should have a return type of Control.
Thanks, it worked. let makeControl (widgetType: control) = match widgetType with | WLabel -&gt; new Label() :&gt; Control | WForm -&gt; new Form() :&gt; Control | WTextBox -&gt; new TextBox() :&gt; Control ;; val makeControl : widgetType:control -&gt; Control 
Note that you normally don't need to manually fix or pin an array in C# or F#, if you declare your PInvoke signature appropriately. For example, if you have a DLL containing: #include &lt;cstdint&gt; #include &lt;numeric&gt; extern "C" __declspec(dllexport) std::uint32_t sum(std::uint32_t* inputs, std::uint32_t count) { return std::accumulate(inputs, inputs + count, 0); } Then you can declare it like this: open System.Runtime.InteropServices [&lt;DllImport("Add.dll")&gt;] extern int sum(int[] inputs, int count) Note that `inputs` is declared as `int[]` and not `int*`. Then you can simply call it by passing a normal F# array. The runtime will handle pinning and so on: [&lt;EntryPoint&gt;] let main argv = let arr = [| 1; 2; 3; 4; 5 |] printfn "expected: %A" (Array.sum arr) let result = sum(arr, arr.Length) printfn "got: %A" result 0 (Note that if the target function stores a pointer to your array somewhere you *will* need to pin it, but this should be quite rare.)
Thanks for the explanation! 
Thanks! 
Isn't Xmonad's config just an actual Haskell file anyway?
The advantage of this format is that the user can write the configuration using algebraic data types, already in a EDSL - Embedded DSL format that is more compact and human readable than Xml and Json. This format is supposed to be edited by humans and not intended to be used outside the application. It would be useful to F#, not the whole .NET. Doess Json.NET use reflection ? I guess that it could be a way to implement the algebraic data type serialization. 
Sorry! Here you go: https://fsharp.tv/gazettes/running-titles-and-accumulators-with-f-gazette-005/
https://fsharpforfunandprofit.com/ is a good resource. If you know Haskell already then I do not think you'll have much trouble using F# at any rate. I myself have been trying to learn Haskell (again) recently without much success. Though I fail, I find that every time I come back I learn some new programming patterns. My current theory on why monads are hard is because they are continuations and continuations are definitely hard.
For a quick overview there's always https://learnxinyminutes.com/docs/fsharp/
This could be a bit tricky because, much like Scala is to Java, F# is a wrapper over doing functional programming in the .NET runtime (usually done in C#). While you can probably understand the basic concepts of F# well enough without needing to study C#/.NET, it will be impossible for you to avoid learning the syntax and paradigms of C#/VB.NET as you go. Although both Scala and F# try and smooth the process as much as possible, they're primarily meant to be replacements for those who already have proficiency with the host language/runtime. Keep this in mind while you study. 
There's also the [F# for Fun and Profit ebook](https://swlaschin.gitbooks.io/fsharpforfunandprofit/content/), which even though it's geared towards C# devs who want to get into F#, it still covers and presents enough of the commonly used .Net libraries to make it useful for someone unfamiliar with the .Net framework. (I prefer the ebook to the site, easier to search)
You can also consider this alternative, using the upcast operator: let makeControl widgetType : Control = match widgetType with | WLabel -&gt; new Label() :&gt; _ | WForm -&gt; new Form() :&gt; _ | WTextBox -&gt; new TextBox() :&gt; _ 
You could try using Git dependencies if you're using Paket. https://fsprojects.github.io/Paket/git-dependencies.html https://github.com/fsharp/FSharp.Data?files=1
Thanks, the changes to the config file worked perfectly!
The courses in Pluralsight are a great way to start out. I originally started with the unit test related course and have gradually adopted the language at work. While we still are predominantly a C# shop I see no reason to no use F# if given the opportunity. 
Counter-question: how do you survive addition of another variant in ADT in the library that was written sometime ago by someone who is out of reach for whatever reason?
There is a Paket plugin for VS, which helps simplify the upgrade from NuGet. Paket is well worth the (small) time investment to learn and incorporate into any .NET solution (including C# projects)
A relational database with first class support for algebraic data types? Yes please. 
While true that discriminated unions cannot be directly modeled in a relational database, there are some techniques that constrain the data enough to get you close. Consider a base table containing an ID primary key and a Type column (make it a varchar for legibility) that represents the generic member of your union. For each member of the union that contains supplemental data, there is a table that extends the base, referring to that base table by foreign key. There is a degree of looseness here in that there is nothing constraining a 1-to-1 relationship between a row in the base table and one of the extension tables but you can mitigate this reasonably by using that type column in your joins and upserts. This is OK. The database is an impure component of your application anyway. Don't let it ruin your day :) Regarding your concern with marshalling functional object graphs into the database, it helps greatly to use some techniques from domain-driven design, namely aggregate roots and repositories. I've found something like an ORM to be unnecessary when my database interactions are organized around meaningful chunks of the domain. A repository interface might have as few as 2 functions: 1 to load a rich domain entity when given an ID, and 1 to save an updated version of that rich entity back to the database. The dynamic SQL is actually no big deal for me anymore. The key for me is in separating my DB code (you don't even need the intermediate types you appear to suggest) from my core model.. as an infrastructure layer, if you follow any type of onion architecture. It doesn't even end up being much glue code and there is not much room for the invalid states you mentioned. Back when I thought The Object was the best thing ever and wished my relational database would just store objects, I thought I needed an ORM. Now, I see the relational model as a powerful paradigm in its own right. I've had the most success not by obscuring my relational database behind some API that lets me pretend it's something else, but by explicitly mapping between the relational and functional data types myself. I ended up developing some interesting tools to make this easier and more reliable. Well, that was long-winded and anecdotal. Hopefully there's something useful for you in there. 
I was thinking the same thing recently. You can choose for a type to be E.g. int64 or int64 | NULL but not int64 | string. To add discriminated unions or product types however I think will require a new (strongly typed? Functional?) query language.
I'm not quite sure how things work in Ionide, but on the command line `paket add nuget ParallelSeq` only downloads the package and adds it to paket.dependencies and .lock; if you also want to add it to your .fsproj, the command is `paket add nuget ParallelSeq project MyProject`.
I struggled that in VS Code as well. Your fs file are not going to work if you only create them. You need to create project first (and add the file into project). It is incredibly messy if you ask me. But I am not .NET guy :) Fsx files are script file so they work fine standalone. They referencing is somewhat different. Unfortunatelly, management of .NET project is not something you would like to do manually. In VS Code it is pretty simply if you have ionide, fake and packet. http://kcieslak.io/Working-with-F-Projects-In-VSCode I suppose the workflow might be similar in Atom or just try VS Code. 
Kinda the same problem OOP languages have, really - your object model doesn't really translate well into your data store. I generally try to just deal with the data as data and construct types when it's the most beneficial, rather than always at the data access level. It's not always the best move, but I do tend to find myself not worrying about constantly having to mold it into a picture-perfect object model or set of types.
Thanks for the recommendation on Greg Young's videos. I've been watching them all morning... Lots of "Aha!" moments. Interestingly, I'm detecting some parallels between Event Sourcing and the Elm UI language in that the current, transient state of the program is a left fold over all the events that occurred since the start of the program. Event Sourcing feels like an excellent choice these days, mainly for the scaling that comes from immutable events. 
I love the idea. I'm toying in build a relational language with a type system alike F#. The problem with a database is NOT because is relational (the relational model could fit wheel the F# type system) is built the rest of it (transacction support, storage, etc). ------ My dream RDBMS is one that is not monolith. Current ones are alike wordpress: Great, but you buy the whole package and can't diverge from it. I wish something alike django/flask: A common infrastructure but you MUST fill the holes. Think for example why you have a table with a NAME UNIQUE CHAR field, then you create the index (so, data duplicated) and yet you can't use the index, alike: `SELECT FROM NameIndex WHERE Value='A'` So will be great if were possible to "enlist" a datastructure to the transacctional support, another to the logs, another to the query planner, etc. ie, alike redis but you can do something like: `STORAGE.add(Customers.btree)` `STORAGE.add(Products.btree)` and the storage take control in how manage the data on disk... 
I would love this. And a way to store functions in databases too. I love the F Sharp type system but now that I'm using databases I'm finding that the primitive database types are trying to take control. Instead of using the natural types to model the problem, I'm having to force everything into the form the database wants :(.
scan is another one to wrap your head around, it comes in handy sometimes. 
If you just need to flatten the list without any more processing then List.concat is even better than List.collect. let f x = List.concat (List.concat x.P paths)
For your first attemp it's really good. I'd like your tutorial. Thanks...hope I will see more 😆
Why do you need hosting? You can have simple virtual server for 1 Eur/month with say debian https://www.arubacloud.com/ You can use docker to run your project there. https://github.com/forki/suaveondocker 
Thanks a lot, leobm! I'm looking forward to making more :)
Yep, but I would bet he thought server with complete setup for fsharp. By the way, would you provide link for free azure you mentioned below?
Original thread: https://www.reddit.com/r/fsharp/comments/4ulcjq/a_peek_into_f_41/
That's a great list! I haven't learned some of those yet so it might be a good chance to learn and throw them in
Yeah! There's some crossover between people who are interested in PowerShell and F# so I think it'd be interesting to cover that in the future.
when you get to type providers be sure to include using the `const` keyword for TP parameters to get around needing to define a new literal for it like `let [&lt;Literal&gt;] x = ...` e.g. ``` FSharp.Management.FileSystem&lt; const(__SOURCE_DIRECTORY__ + "/../data/gotodef")&gt; ``` It's a neat little keyword most people don't know about, seeing as the the [keyword docs](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/keyword-reference-%5Bfsharp%5D) list it as reserved when it's already in action.
Thanks Jack.
After reviewing the materials you linked (I really enjoyed them by the way), I don't believe Event Sourcing and CQRS directly address the OP's concern about the structural looseness of modeling functional datatypes in a relational database. While the features of Event Sourcing are very nice (replayability, complete change history), you still have the labor of mapping your in-memory structures to relational tables if you want to support traditional reporting via SQL. Only now you have increased the complexity of your system overall. Can that system do a lot more? Sure (multiple read models, for instance) but you've introduced eventual consistency, which you might not want. At this point in my understanding, I think it would be wise to use Event Sourcing only when one needs one's audit log to drive the system (ie. Banking, finance, gambling, etc). Other times, I think the problems at hand can be more directly addressed with primary relational storage and a regular audit log. I think my assessment may not be totally accurate (or totally informed). What do you think is the point at which the addition of ES to your domain is warranted? I want to be careful and only use ES because it's the appropriate solution and not just because it's really cool (I've burned myself with shiny, new toys in the past; read: ORM).
You can check this out: http://tpetricek.github.io/FSharp.Formatting/ You can see an example of the results here: http://lefthandedgoat.github.io/canopy/actions.html I know there are also general .net ones that do like javadoc, from the XML comments on code, but I can't remember the name. edit:fixed link
I agree with you 100%. In my own applications where I've used event sourcing, were in places where I had to track stock updates over time. This only constituted for about 30% of the whole system. There were normal CRUD and a very small amount that uses flat files (configs). So your caution against using ES-only is good! You will probably always end up with some kind of hybrid solution which is okay, nothing wrong with that, I expect it actually. Plenty of things are easier to reason about in a ES way rather than the CRUD way. Too be 100% honest, I hate ORM's with a passion and they're pretty much the loan sharks of technical debt. But, I would also never attempt to build everything in a ES-only way, neither a CRUD-only way. The reason why I mentioned this in an F# post, is because F# makes modelling your domain insanely easy - You will see much quicker what data needs storing and possibly how you need to store it. Sometime it nudges you into CRUD, sometimes into ES or Graphs or document stores (I see NoSQL &amp; ES in the same camp..they cater for immutables &amp; stuff you won't relate/compare). And since F# strongly nudges you to work with immutable data, then you will almost always work with eventual consistency even if you think you don't - rather then build your application around eventual consistency than try to hack it in later. Some appications I/we have in the wild that uses eventual consistency (using worker services to do crunching), we average at about 7 seconds to guarantee consistency (most are below 5 seconds). About 10 to 15 seconds is still okay in our environment, but anything above 15 seconds and you start seeing conflicts and issues - thus one of our core health metrics we use is a "consistency rate", ie how long it takes to process a transaction/workflow end-to end. If it goes above 15 seconds our devops gets a notification and they go pamper the servers. Please note that this is very complex software and it involves multiple parties and a few dozen servers or so. We made the trade off to use some ES/eventual consistency to be able to prove that work was done on our side (we used to have finger pointing situations, so this solves the human element without minding audit logs). If you go past a certain point in complexity/size of an application, doing things in "real time" might start taking up 10 seconds to complete anyway, so the 5 to 15 second processing time is not a deal breaker for us, but we end up having a complete trace of history for free and actual consistency even though it's "slow". This is much more valuable when you sit in business meetings and you can give your PO/PM the ammo to defend themselves properly. Anyway, hope you guys have fun experimenting with this! The lessons learned from this will bring you a lot of joy and I guarantee it will make you a better programmer over time.
One would be Sandcastle https://github.com/EWSoftware/SHFB
I really enjoyed reading this post; nice one Jack.
Very interesting stuff! &gt; AverageBy is much faster as it now no longer just calls into Seq.AverageBy That is positively disturbing. The `Seq` functions should detect lists, arrays, sets and maps and call the appropriate functions in them. Doing the opposite is insanity. &gt; Partition faster and uses less memory due to new algorithm That's a lovely optimisation. Reminds me of the in-place partition in Hoare's Quicksort. &gt; Filter faster due to using preallocated array instead of List&lt;T&gt; Presumably the new `filter` is slower if most elements are rejected because you're allocating a much bigger array than necessary? 
and yeah the averageBy thing just looked like an oversight. Probably not often used.
That is a really good idea. 
What I really like about FSharp for things like scripting are type providers. They allow you to interact with config files, spreadsheets and api's in a typesafe way, so if you make a mistake in your programs, they don't even run instead of fail miserably somewhere later. Do keep in mind you need to use Mono if you want to use it on Linux.
I love Python on Windows and Linux, but work is becoming more of a .NET shop. I also love the fact the VS Code works on Windows and Linux. O_O I'm trying to figure out F#'s place in my admin scripting, but I need to spend more time on the basics. I have several years of scripts that I may try to translate from Python, batch and PS to F#, but I'd love to see a site/resource for F# admin scripts... 
I knew PowerShell before I knew F#, and once I learned F# I realized how easy it was to script in a functional style from PS. I would recommend PowerShell because all the tools you are going to want are going to be available to you and easy to use. With piping it's very easy to still write things functionally
I'm working my way through the PDF version of 'fun and profit. 
Uploaded the video yesterday but forgot to post the link to Reddit! I should be ashamed of myself. Let me know what you think!
Uploaded the video yesterday but forgot to post the link to Reddit! I should be ashamed of myself. Let me know what you think! 
&gt;How suitable is F# for CRUD operations? Most of the required transactions will be pretty simple, along the lines of deserialise -&gt; validate -&gt; persist with some reasonably simple reporting. [This article](https://fsharpforfunandprofit.com/posts/recipe-part1/) answers this question for you.
For existing apps that already have the entity framework you can still use F# with no problems. We have a few of those where I work and just modify or rewrite the middle layer as desired to use F# instead of C# classes. We specifically stay with Entity framework for projects that need Geography and Geometry datatypes. 
That's exactly what I was after, thank you.
The only other things we have used are the SqlConnection Type Providers. We use those when we have new projects that do not need Geography/Geometry as specified above. The reason we do not use the SqlEntityConnection one has to be private or internal and we often return the data objects directly to Json through layers without creating new entities/classes. 
[It most certainly can.](https://gist.github.com/Tarmil/cc9243a055c213253d5c6f09cdd24d13) The question is whether it's as efficient; since Haskell is lazy and F# is strict, that's not a trivial question to answer.
Well, the thing is that not only code but data structures themselves, including lists, are lazy in Haskell. And the compiler includes tons of optimizations dedicated to running lazy code on lazy structures as efficiently as possible. So even if you were to create your own list type based on `Lazy&lt;'T&gt;`, you would end up with very hard-to-read code that would most likely be slower than the corresponding Haskell. Then again, maybe the strict version I posted is just as efficient; I don't have a Haskell compiler at hand to compare.
I just ran some benchmarks with it against the built in List.sort, which converts the list to an array, quicksorts it, then makes a new list, and this mergesort is definitely much slower. I was playing around to see if it could be done more efficiently directly as a list, and I'm thinking not. If the list was mutable, maybe. 
I wrote a generator for CRUD apps, you can check it out here: https://github.com/lefthandedgoat/genit
NUnit and xUnit are more classical unit testing frameworks. However, they are mainly targetted at C#, so the syntax when used in F# can look a little odd, hence FsUnit works with these underlying tools to make your unit tests more F#-like. Note that FsUnit also supports some other testing frameworks. FsCheck gives you property-based testing, and again, can be integrated quite nicely into either an NUnit or xUnit based solution. So you can mix up Property based tests with more traditional Fact based unit tests. I don't think there are many major differences between NUnit and xUnit, although I think xUnit currently supports .NET Core, which I'm not sure NUnit does (at the moment). So I think it's more a matter of personal taste. I have successfully used xUnit, FsUnit and FsCheck all together on a project. This page might help (although it might be a little out-of-date): https://xunit.github.io/docs/comparisons.html
In this first example you are correct I wanted Features to be a discriminated union. However if the type is set to just 'T how is 'T constrained only to discriminated unions. Is that done at the let binding as you have shown in example ? 
Yes. The biggest disadvantage of doing it by hand is really syntactic. In XAML, the controls have other controls inside them and they are nicely indented, and ordered in a sensible manner, but when you do it in F#, the code will necessarily have to be flattened and child controls will need to instantiated before the parents which will introduce disorganization. It is possible to get around that to a degree by nesting modules, but it could be smoother. Sometimes I wish F# could nest classes or maybe have modules inside let statements or classes and this was one of those times. Ideally, it would be good if somebody did a GUI library for the Elm pattern. [Anthony Loyd](http://anthonylloyd.github.io/blog/2016/06/20/fsharp-elm-part1) did the proof of concept for it, but in its current stage it is not usable unless you want to write the entire thing by yourself. There exists a [XAML F# type provider](https://github.com/fsprojects/FsXaml), but when I did research on it, apart from few examples, I could not find any documentation for it so I opted to just do it by hand.
Ok, I've never used Json or that particular library, but here is how I would do it. I haven't tried running it, but I think it should work. Tell me if there is something you don't understand. #if INTERACTIVE #r @"..\packages\Newtonsoft.Json.9.0.1\lib\net45\Newtonsoft.Json.dll" #endif open Newtonsoft.Json type Account = // Just a placeholder { id: int name: string } type GisFieldAlias = int // Just a placeholder to stop type errors. type GisCanalLateralFeature = Account // placeholder type GisDeliveryPointFeature = Account // placeholder type GisFeatureList = // If the lists are long I'd suggest using arrays for performance. | CanalLateralFeatures of GisCanalLateralFeature list | DeilveryPointFeatures of GisDeliveryPointFeature list | NoGisFeature type GisResponse = { DisplayFieldName:string FieldAliases:GisFieldAlias GeometryType:string Converter:string -&gt; GisFeatureList // The converter function Features:obj // I am guessing this is compressed } // F# is indentation sensitive so brackets should be level indented member x.CustomFeatures = x.Features // obj |&gt; JsonConvert.ToString // (obj -&gt; string) Not sure if this is the correct ToString function |&gt; x.Converter // (string -&gt; GisFeatureList) let canalLateralFeatureConverter x = JsonConvert.DeserializeObject&lt;GisCanalLateralFeature list&gt;(x) |&gt; CanalLateralFeatures let deliveryPointFeatureConverter x = JsonConvert.DeserializeObject&lt;GisDeliveryPointFeature list&gt;(x) |&gt; CanalLateralFeatures //let noGisConverter x = NoGisFeature // Does not use the argument let canalTest = { DisplayFieldName="Square" FieldAliases=0 GeometryType="Shape" Converter=canalLateralFeatureConverter Features="Erm, how does Json work again?" } let deliveryTest = { DisplayFieldName="Square" FieldAliases=0 GeometryType="Shape" Converter=deliveryPointFeatureConverter Features="Tell me and I'll test it more tomorrow if this does not work." } let noGisTest = { DisplayFieldName="Square" FieldAliases=0 GeometryType="Shape" Converter=fun _ -&gt; NoGisFeature // Since converters are small you can also pass it as a anonimous function instead Features="zzz..." } As it turns out, now that I know what you want to do, I can see that you do not need to do any pattern matching at all. Instead you can just pass along a converter function as one of the record fields directly. Well, assuming you can plug this into your code and it works, I should emphasize that this is just a local optimization. Carrying around an obj type looks a bit fishy to me, but not knowing more I am satisfied with this.
I like the idea of a converter however I never get to create the recordType manually what happens is the JsonConverter.DeserializeOjbject&lt;'T&gt; where t is my record type creates. So somehow the Deserializer would need to know what converter to use. Here is the code example let request = HttpProcess.getJsonRequest(queryString) let wellResponse = JsonConvert.DeserializeObject&lt;GisResponse&lt;GisWellFeature&gt;&gt;(request) So wellResponse is the recordType. I never had to code up any of the code in your test examples. Does that make sense ? Thanks for your feedback this has been very informative. 
That is great. One other thing. Just as I've mentioned, dragging around that Features object is a little fishy. Every time you call the CustomFeatures function the object will be deserialized again which is incredibly slow and inefficient. I'd very much recommend doing it only once. I'd also suggest that when making the `load_and_deserialize_object` function that you pass in the converter as an argument just like I'd shown you to make the code generic. Then use that function during the record's creation and have the record only hold the final product. That should be much better than this as .NET class methods and properties are always re-evaluated when called.
Yea I was thinking that it could get slow, for now the conversion is only needed once but I will keep it in mind. Thanks!
You can also write this entire expression as x &amp;&amp; (do something; true)
I like it. I was trying to avoid if else statements just to see if I can write the full program without them but sometimes I see they can still be useful.
If you're trying to do validation, the idiomatic way is to use Applicative Functors. Eg. let isValidPerson person = notNullOrEmpty "name is required" person.name *&gt; minLength 10 "name must be more than 10 chars" person.name *&gt; maxLength 200 "name must be less than 100 chars" person.name *&gt; validateName "name must be in [A-Za-z ]+ format" person.name &lt;?&gt; person Where `minLength`, `maxLength`, `notNullOrEmpty` are standard validators that can be functionally composed. [FSharpx.Extras](https://github.com/fsprojects/FSharpx.Extras/blob/master/src/FSharpx.Extras/ComputationExpressions/Monad.fs#L743-L789) contains a validation library with these combinators. If you're looking to build the form *and* include validation, there's an applicative functor for that, too called a Formlet. WebSharper has a formlet implementation for web forms, but I don't know of any existing impementations for WPF or windows forms.
Possibly `let inline nop _ = Unchecked.defaultof&lt;_&gt;` but I haven't tried it...
(I'm imagining F# and OCaml are similar enough, otherwise I'm completely misreading your question) You could try fun _ -&gt; () fun x -&gt; false The second will apply to both `foo` and `bar`, the first is more typical for this scenario, when you lazily do nothing.
But, the name for the Windows Forms must be unique. The name is used to locate the widget like the names are used in html css. The approach that I used only worth when you are creating some library. If this is not your intention, it is better to stick to the oo approach and use the constructor directly as C# oo features are available in F#: let btn1 = new Button(Text = "Click me") let form1 = new Form(Text = "A sample form", BackColor = Color.LightBlue) form.Show() 
Take a look at http://nut-cracker.azurewebsites.net/blog/2011/11/15/typeclasses-for-fsharp/. At least when I last tried this many years ago adding enough static members made the compiler take several minutes to compile a single class. 
Yeah. I'm expecting that to happen if I go too crazy. Truth be told though, we don't really "need" typeclasses. The 4 requirements I had can easily be solved by either adding these standard operators (&gt;&gt;= and similar) to built in types like Async and Option. Or (what I really want) by allowing extension operators (not just extension methods). 
Although there is some merit to parser generators they are a completely different beast. 
I haven't looked at the grammar closely, but there might be parsing reasons to avoid a syntax like `arg =&gt; res`. In languages like ES6 or C#, the argument-list is a parenthesized (or not if there's only 1), comma-separated list of identifiers with optional type annotations. That's easy to parse. In F#, the identifiers might be arbitrarily complex patterns, and multiple arguments are space-separated without parentheses around the whole set. There's a lot more risk of ambiguity if you don't have a prefixing keyword to indicate that this is an argument list.
Been trying out fparsec for the past couple hours. It's pretty good. The tutorial explains things quite thoroughly. Thanks for the tip. 
&gt; I don't think it's an ML baggage issue. F# already has non-complaint "light" syntax that's on by default. It does have quite a few things that come from ML despite not making much sense in its own context. The standard library's lowercase functions despite .NET standard mandating uppercase, for example. The problem with parsing is not so much that it's hard to disambiguate valid code, but more that it's hard to provide a helpful error message for invalid code. In ES6, it's still always an identifier or parenthesized bunch of stuff followed by `=&gt;`, there is no juxtaposition of several arguments like in F#. Maybe this is still nicely solvable, I don't know, I was just suggesting a possibility :P In any case I do agree that Haskell's `\` would be a nice shorter syntax. I know that Don Syme is not a big fan of operators everywhere though, I've heard him complain about people who overuse `&lt;|` and `|&gt;`.
Hmm, do you have any source on Don Syme not liking operators? I do like how, as a whole, F# prefers things like `()` instead of `$` , but disliking `|&gt;` seems to be a pretty extreme position.
I don't have a source on this, it's what I gathered from a couple face-to-face discussions. Note that I didn't say he doesn't like operators per se, but them being all over the place. Using `|&gt;` in functional pipelines is fine, and in fact the intended purpose, but a lot of people tend to use `|&gt;` and `&lt;|` where a normal function call will be just as readable if not more. I agree with him in that sometimes Haskell uses operators so much that it ends up looking more like APL than anything else. I wouldn't be surprised if `\` for `fun` was seen as a step in that direction.
After doing a bunch of research, I decided to just my [write my own](https://github.com/mrakgr/Embel) in the end. The library is just 120 LOC and inspired by Fuchu.
Why don't you like parser combinators?
I find they result in ugly and hard to maintain code. 
&gt; Is what I've written wrong and that as I go along this path, will I find that the code will get hard to maintain? Are your feelings towards parser combinators are a reflection towards the applicative style in general? I am actually pretty curious about that. As a rule of thumb, if you're inventing your own operators (e.g. `&gt;&gt;.`) then you're doing it wrong. 
&gt; In your view, how would a well designed parser combinator library look like? That's like asking what a hammer for screwing in screws would look like. Objectively, to solve such problems (like parsing) I would not use a combinator library but, rather, a DSL. 
New operators are generally kind of hard to introduce because F# allows custom operators. I for example use `=&gt;` to define Map&lt;string,obj&gt; literals, eg: ["one" =&gt; 1 "two" =&gt; "2" "three" =&gt; ["1";"3"]] |&gt; Map.ofList Which is handy for creating JSON payloads. 
Here's what a hammer for screwing in screws looks like. https://en.wikipedia.org/wiki/Impact_driver -- That guy
Let me give it a shot. type Money = int // placehold to placate the type checker type AccountDto = { Id : string Amount : Money } type PurchaseDto = { Id : string ShopId : string } type MemoryDatabase() = member val Accounts = ResizeArray&lt;AccountDto&gt;() with get,set // ResizeArray is shorthand for System.Collections.Generic.List&lt;&gt; member val Purchases = ResizeArray&lt;PurchaseDto&gt;() with get,set // Originally I tried this using pattern matching but it can't be done as the three functions have different return types. member t.AccountQuery(accountId: string) = t.Accounts |&gt; Seq.find (fun a -&gt; a.Id = accountId) member t.PurchaseQuery(purchaseId: string) = t.Purchases |&gt; Seq.find (fun a -&gt; a.Id = purchaseId) member t.AccountListQuery = List.ofSeq t.Accounts let db = new MemoryDatabase() let account = db.AccountQuery "home" printf "%A\n" account.Amount let purchase = db.PurchaseQuery "operation-1" printf "%A\n" purchase.ShopId let accounts = db.AccountListQuery accounts |&gt; List.iter (fun a -&gt; printf "%A = %A\n" a.Id a.Amount) At first I saw you using interfaces so I imagined this problem must require some complex type magic, but this particular problem is tailor made for the OO solution. The above solution is completely type safe and requires no complex casting and going through hoops, so whatever you are doing start from there. Making code generic and advanced functional features are really there for when you find yourself doing code duplication with minor changes.
In future there will be hundreds of query methods and I want to split execution logic to different independent functions. With possibility to easy replace this in-memory database with real one. And without creating an interface with hundreds of methods in it. (Thank you for ResizeArray)
LOL. Ok, bad example. :-)