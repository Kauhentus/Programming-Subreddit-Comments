&gt; 2 2 Sqrt 2+y 2 2,
You could also use Select with !FreeQ.
&gt; 2+mc/12 2+3 2 2+ma/12 2
Thanks! That'll suffice :)
I think you can use Assuming[] or the Assumptions-&gt;{} flag. E.g. Reduce[x^2 - 1 &gt; 0] gives x &lt; -1 || x &gt; 1 but Simplify[Reduce[x^2 - 1 &gt; 0], Assumptions-&gt;x &gt; 0] will just give x &gt; 1 But, Assume/Assumptions is kind of weird. You can't pass multiple assumptions as a list, it has to be an and clause. E.g., something like Assumptions-&gt;x&gt;1&amp;&amp;x&lt;2. You can combine this with the trick /u/duetosymmetry mentions to handle lots of variables. For instance, if you have a bunch of bounds on lots of variables, you could do something like this: upper = {1, 2, 4, 9, 1, 8, 2}; lower = {.1, 1, 3, 2, .2, 7, 1}; n = Length[upper]; vars = x[#]&amp;/@Range[n]; bounds = Inner[Less, vars, upper, And] &amp;&amp; Inner[Greater, vars, lower, And]; Simplify[Reduce[{yourExpressions}], Assumptions-&gt;bounds] Note the use of the abstract Inner[] to construct the set of conditions. Of course, it's a matter of whether or not you want to build the full set of constraints for your problem every time, but this way will get rid of the "extra" solutions. For your problem specifically, Inner[Unequal, vars, ConstantArray[0, Length@vars], And] will generate the non-zero constraints you want. Note that you have to write your equations in terms of x[1], x[2], x[3]... instead of x1, x2, x3... for this to work, with x not mapped to any single variable function name (so, if you have x[a_]:=a^2 somewhere, that will break treating x[n] as a variable). If you really want to use something like x1, x2, x3... you can do it with an ugly hack like vars = ToExpression["x"&lt;&gt;ToString@#]&amp;/@Range[1, 10]; but the other way is a lot more natural. ( &lt;&gt; is the shorthand for string concatenation) 
Thanks for the information! I'll try it as soon as I get home
The example is working correctly, so that shouldn't be the problem (thankfully). Could you perhaps tell me if it's even possible, using the network.zip provided with the Euler Problem, to construct a valid graph?
Thanks again for the feedback
Haha magic
Final question! How would one extract the Total Edge Weight from the MinimumSpanningTree computation?
Sorry to keep bothering you.. ToAdjacencyMatrix[MinimumSpanningTree[graph]] Indeed gives me the position of the edges in adjmat, should I now cross reference the two by hand or could I automate this? When I try to do so I get Graph : &lt; 39, 40, Undirected &gt;
Great - thank you very much! I feel bad for being so close, but you know how you can end up ripping your own hair out when you've been at it for too long... A couple of questions: 1. Why exactly do I need to write the "?" in front of the boolean test? I can't seem to look it up anywhere. 2. How do I make sure `v1` is a positive integer? Right now I'm only testing whether it's an integer or not. If I input -2 as `v1` I get an output of -5. I've tried writing `Trapez[v1_ /; v1 &gt; 0,` ..... `]` in the code, but that doesn't really make any difference it seems.
Thank you! You've been a great help. I got it working with what I wrote before after restarting Mathematica. I'm actually taking classes in Mathematica and Matlab, but we've only just begun - so I'm working on it! I'll look into the books. EDIT: Oh, one last thing - sorry for bothering you. I really want to make the call of the function so that I don't have to define the function every time. Instead of funk[x_] := x^2; Trapez[2, funk, {x, 1, 3}] I'd write Trapez[2, x^2, {x, 1, 3}] Isn't that what I was about to do in my original post? With the `funk /. var -&gt; (?)`?
try this. I don't know much about PCs but this should work. Open the PDF on your mac in Preview.app File-&gt;Export select PDF, and select PDFX-3 quartz filter save it. 
Thanks for the help! I got it working!
Thanks. I figured out how to get it working!
With the same input, how can I plot this together with f(x)? Sigh... Nevermind, I needed a `Quit` again... 
IntegerPartition is the command you're looking for. IntegerPartition[n] outputs all the possible combinations of integers that add up to n. For example IntegerPartition[5]={{5},{4,1},{3,2},{3,1,1}, etc. If you use IntegerPartition[n,10,W] where W is a list of each of the weights you have, then it will output only partitions that use instances of the weights you mention, and n is the maximum number of weights you want to use. For example, IntegerPartition[35,5,{5,10,20}] gives {{20, 10, 5}, {20, 5, 5, 5}, {10, 10, 10, 5}, {10, 10, 5, 5, 5}}, all the ways to build 35kg with the specified weights using 5 weights or less. If you want to take the partition with the fewest weights then it would be easy enough to just got IntegerPartition[n,k,W][[1]], which will take the first entry. 
thanks for the response, but this doesn't take into account the amount of plates of one weight i have.
[Here's a screenshot from Notepad](http://i.imgur.com/9EHLmcn.png). I was thinking maybe I could do it by player ID or game ID, and get all the information from that row. [Here's a link to where I downloaded the file from if you want to take a look at that](http://www.basketballvalue.com/publicdata/matchups20120510040.zip). 
Exactly the kind of thing I was looking for. Just out of curiosity, would this work for other things than the game ID. Also curious where a good place to look up working with data in Mathematica is. I'm able to find codes decently, but not well enough to have found what you used there. 
Are you required to use Mathematica for these problems? If not, your question may be better suited in /r/AskPhysics. EDIT: I'm studying for a mechanics exam, but problem 2 is probably the easiest to grasp: (2a) Think about what acceleration is. In its most basic form, average acceleration is the change in velocity divided by the change in time. See this [HyperPhysics](http://hyperphysics.phy-astr.gsu.edu/hbase/acca.html) page for a good explaination. (2b) Newton's second law (probably the most important formula you will use in introductory physics) states that: F=m*a. You know what the average acceleration is from (2a). You also know what the mass is from the given problem. (2c) You know the acceleration of the dragster. Draw a [free body diagram (FBD)](http://hyperphysics.phy-astr.gsu.edu/hbase/freeb.html). In order to keep the driver from being left behind, the seat has to exert a force on the driver to keep him there (since he has to accelerate as well). Use Newton's Second Law again to find the force exerted on the driver. Make sure that you label your coordinate system on your FBD so that you get the correct direction. Does the value make sense (Think in terms of g-forces)?
Thanks so much for the help! I'm guessing Mathematica doesn't and possibly won't ever apply to your average high school student haha I'll read that after my homework though 
Probably not. It's useful for modeling systems if you have to do a Senior project. Plus, it's not very difficult to get started with.
Have you looked at joint histograms? I.e. Histogram3D
You're right, I completely screwed up my intervals! I will give it a shot! How would I change your statement if I wanted to use A &amp; B as my two variables?
????????????????
Apparently. It's on the left-hand side of the equation. 
The expression {{1,2,3},{4,5,6},{7,8,9}} looks to me more like it's a matrix (list of lists of equal length) than a string. I'm guessing that what you probably want is the [ToString](http://reference.wolfram.com/mathematica/ref/ToString.html) function. Maybe something like this: ToString/@{{1,2,3},{4,5,6},{7,8,9}} That would map ToString over the matrix you specified.
I tried that, but the output is the same as the original... It just returns {{1,2,3},{4,5,6},{7,8,9}} I really need the quotes....
Hi abadabing, The output is different, it's just hard to see because strings aren't quoted in StandardForm (the default method of Mathematica output). To add the quotes, tell Mathematica to write the output in InputForm: InputForm@(ToString/@{{1,2,3},{4,5,6},{7,8,9}}) {"{1, 2, 3}", "{4, 5, 6}", "{7, 8, 9}"} Thanks for the clarification about the default output form!
I don't have my Mathematica right handy as I'm at work, but I would guess that what's happening is that it's converting the inner lists to strings but not actually displaying the quotes. Try this: ToString/@{{1,2,3},{4,5,6},{7,8,9}}//InputForm That, I think, should display it the way you're expecting. 
Thank You!!!
Thank you!!!
Use this expression block to load the data and create a function which searches it: data = Import["matchups20120510040.txt", "Data"]; Search[parameters_] := Block[{query, GameID, StartTime, EndTime, ElapsedTime, ElapsedSecs, HomePlayer1ID, HomePlayer2ID, HomePlayer3ID, HomePlayer4ID, HomePlayer5ID, AwayPlayer1ID, AwayPlayer2ID, AwayPlayer3ID, AwayPlayer4ID, AwayPlayer5ID, HomePlayer1Name, HomePlayer2Name, HomePlayer3Name, HomePlayer4Name, HomePlayer5Name, AwayPlayer1Name, AwayPlayer2Name, AwayPlayer3Name, AwayPlayer4Name, AwayPlayer5Name, StartScoreHome, StartScoreAway, EndScoreHome, EndScoreAway, PointsScoredHome, PointsScoredAway, PlusMinusHome, PlusMinusAway, PossessionsHome, PossessionsAway, OffensiveRtgHome, OffensiveRtgAway, OverallRtgHomevsAway, OverallRtgAwayvsHome, OffensiveReboundsHome, OffensiveReboundsAway, DefensiveReboundsHome, DefensiveReboundsAway, OffensiveReboundingRateHome, OffensiveReboundingRateAway, DefensiveReboundingRateHome, DefensiveReboundingRateAway}, query = {GameID, StartTime, EndTime, ElapsedTime, ElapsedSecs, HomePlayer1ID, HomePlayer2ID, HomePlayer3ID, HomePlayer4ID, HomePlayer5ID, AwayPlayer1ID, AwayPlayer2ID, AwayPlayer3ID, AwayPlayer4ID, AwayPlayer5ID, HomePlayer1Name, HomePlayer2Name, HomePlayer3Name, HomePlayer4Name, HomePlayer5Name, AwayPlayer1Name, AwayPlayer2Name, AwayPlayer3Name, AwayPlayer4Name, AwayPlayer5Name, StartScoreHome, StartScoreAway, EndScoreHome, EndScoreAway, PointsScoredHome, PointsScoredAway, PlusMinusHome, PlusMinusAway, PossessionsHome, PossessionsAway, OffensiveRtgHome, OffensiveRtgAway, OverallRtgHomevsAway, OverallRtgAwayvsHome, OffensiveReboundsHome, OffensiveReboundsAway, DefensiveReboundsHome, DefensiveReboundsAway, OffensiveReboundingRateHome, OffensiveReboundingRateAway, DefensiveReboundingRateHome, DefensiveReboundingRateAway} /. parameters; query = If[(StringQ@#) || (NumberQ@#), #, _] &amp; /@ query; Cases[data, query] ]; Then use the Search function the following way: Search[{GameID -&gt; "20111225BOSNYK", StartTime -&gt; "00:48:00"}] {20111225BOSNYK,00:48:00,EndTime,ElapsedTime,ElapsedSecs,HomePlayer1ID,HomePlayer2ID,HomePlayer3ID,HomePlayer4ID,HomePlayer5ID,AwayPlayer1ID,AwayPlayer2ID,AwayPlayer3ID,AwayPlayer4ID,AwayPlayer5ID,HomePlayer1Name,HomePlayer2Name,HomePlayer3Name,HomePlayer4Name,HomePlayer5Name,AwayPlayer1Name,AwayPlayer2Name,AwayPlayer3Name,AwayPlayer4Name,AwayPlayer5Name,StartScoreHome,StartScoreAway,EndScoreHome,EndScoreAway,PointsScoredHome,PointsScoredAway,PlusMinusHome,PlusMinusAway,PossessionsHome,PossessionsAway,OffensiveRtgHome,OffensiveRtgAway,OverallRtgHomevsAway,OverallRtgAwayvsHome,OffensiveReboundsHome,OffensiveReboundsAway,DefensiveReboundsHome,DefensiveReboundsAway,OffensiveReboundingRateHome,OffensiveReboundingRateAway,DefensiveReboundingRateHome,DefensiveReboundingRateAway}
The _ is on the right hand side of the symbol x, but it is on the left hand side of the equation. When they say "left hand side" they are referring to the left hand side of the = sign. 
The correct form of a function definition is just as in the screenshot: f[x_] := x^2 The underscore appears on the LHS of the =. A function of two variables could be definite as: f[x_,y_] := x^2 + y^2 The rule is that everybody on the LHS of the = gets an underscore, and nobody on the RHS gets an underscore. 
So f[x]_:=x^2 is good? 
No, it's not good. It sounds like you want to know the general logic and theory of what the underscore means and all the places it can possibly go. Well, for starters the underscore can only appear after symbols (where by symbols, I mean expressions which have the Head "Symbol"). x and y are symbols (unless you assign them to something), you can see this by starting a fresh kernel and typing: Head[x] it will return Symbol. Now, ] is not a symbol. That is why it can't immediately proceed an underscore. Now, what is this business of a symbol followed by an underscore? x_ means "any arbitrary *pattern* which I am hereafter naming x". So if we have: f[x_] := x^2 and we later call f[5], Mathematica runs through the following process: Does f[5] match anything I've seen before? Well, I've seen f[x\_] and since x_ stands for any arbitrary pattern, f[5] is of this form. So the pattern x_ is matched with 5 and we apply the definition f[x\_] := x^2 to get f[5] = 5^2 = 25.
I get this message when I write Eigenvalues[A]: Eigenvalues::arh: Because finding 16384 out of the 16384 eigenvalues and/or eigenvectors is likely to be faster with dense matrix methods, the sparse input matrix will be converted. If fewer eigenvalues and/or eigenvectors would be sufficient, consider restricting this number using the second argument to Eigenvalues. &gt;&gt; Sure enough Eigenvalues[A, 1] completes instantaneously. And the second argument is the *number* of eigenvalues to retrieve. So -1 there either doesn't have any meaning or means 'get all of them'. Either way, it's clear from the above message that this is why it first makes it dense, and therefore blows up. I tried Eigenvalues[A, {16384}] to get *just* the last = smallest eigenvalue (which is what I assume you mean by -1), but it didn't complete in a reasonable amount of time. But judging from what happens for Eigenvalues[A, {5}], which is: Eigenvalues::maxit2: Warning: maximum number of iterations, 1000, has been reached by the Arnoldi algorithm without convergence to the specified tolerance, but the current best computed value has been returned. You can use method options with Method -&gt; {Arnoldi, opts} to increase the size of basis vectors, the maximum number of iterations, reduce the tolerance, or use an estimate as a shift, any of which may help. &gt;&gt; I imagine that the smallest eigenvalue is going to be wildly incorrect, if it ever finishes computing. Matlab might be doing something more sophisticated and succeeding, or it might not be tracking convergence properly and just giving you an incorrect answer (or both, of course). Are you doing some 'experimental' random matrix theory? Just curious. 
The default is actually StandardForm. You can also do Style[something, ShowStringCharacters -&gt; True] to see the quotes. You can even set this using Option inspector for your entire frontend so that quotes always show up.
Thank you! Actually the built-in documentation for Eigenvalues states (under details and options): Eigenvalues[m,-k] gives the k that are smallest in absolute value. In general finding the smallest eigenvalue of A is equivalent to finding the largest eigenvalue of IdentityMatrix - A, as long as the eigenvalues of A are strictly between 0 and 1 (which they are in my actual application, and can always be accomplished by rescaling). But apparently mathematica does not know this pen and paper trick, so Eigenvalues[A,-1] cannot use sparse Arnoldi/Lanczos type methods. So that solves my problem! Regarding the application for this code, I am a physicist doing research on Quantum Mechanics. The matrices I'm working with have more structure along the diagonal than just being random (i.e. entry k is the unsat value of the binary representation of k for a boolean SAT formula), but I tried to simplify the issue as much as possible for the purpose of getting help. :) 
You did not read the documentation for negative values of the second argument.
`ArcTan[Im[Tb[I*omega]]/Re[Tb[I*omega]]]` gets me to the correct answer if I first invert Tb (so that it's all zeros instead of all poles). I did have to apply `FunctionExpand` once to help it out. There is some slight of hand in writing that ArcTan expression which wasn't completely obvious at first. Forgive me if this is already obvious to you, but I found it helpful to write down. We start with: 1/z = Conjugate[z]/Abs[z]^2 so Im[1/z] = -Im[z]/Abs[z]^2 Re[1/z] = Re[z]/Abs[z]^2 which is where you get the minus sign in the ArcTan, and conveniently the Abs[z] cancels out: Im[z]/Re[z] = -Im[z] Abs[z]^2 / ( Re[z] Abs[z]^2) = - Im[1/z] / Re[1/z] Seems like kind of a sneaky hidden step. But I'm also not sure how to coax Mathematica into doing this simplification.
This sequence of commands gets me the right answer: $Assumptions = {Element[w, Reals]} Tb[s_] := 1.05*10^18/(1.05*10^18 + 1.05*10^14 s + 4.5*10^9 s^2 + 100000. s^3 + s^4) Arg[Tb[I w]] % // ComplexExpand % // FunctionExpand % // FullSimplify D[%, w] % // FullSimplify % // Together 
 I love you more than a drunk college student loves tacos 
Great! Thank you so much :) I didn't know about FunctionExpand, useful to know that it exists! Still, there's a small problem with that approach. With it, tg[0] gives 0, but it should be -0.0001, same problem with numerically evaluating the function, and I can't figure out why. EDIT: I was able to reach the correct equation by doing &gt; $Assumptions = {Element[omega, Reals]} &gt;phi[omega_] = Arg[Tb[I*omega]] // ComplexExpand // FunctionExpand // FullSimplify &gt;tg[w_] = FullSimplify[-D[phi[omega], omega], Assumptions -&gt; Element[omega, Reals] &amp;&amp; omega &gt; 0] /. omega -&gt; w &gt;tg[0] and it gave the correct result (0.0001). I still wonder why some approaches (mainly, defining the functions and asking for the numerical result, like mentioned in the OP) give the wrong result! For example, replace phi with &gt;phi[omega_] = Arg[Tb[I*omega]] // FunctionExpand // FullSimplify The result will be 0. + 3.76829*10^-21 I which is dead wrong (a group delay can't be imaginary). This is weird because the only difference was the missing ComplexExpand, but (normal) Expand doesn't cut it. Bug in Mathematica? A slightly different transfer function, T1[s_]:=-(4.30793\*10\^8/(1.14878\*10\^9 + 42075.8 s + s\^2)) with the same process doesn't work either, giving an imaginary number again (I don't know the exact result, but it's supposed to be non-zero, real). To coax Mathematica to give the correct answer with this transfer function, we have to do: &gt;phi[ omega_] = Arg[T1[I*omega]] // FullSimplify // ComplexExpand // FunctionExpand // FullSimplify Without simplifying before ComplexExpand, ComplexExpand has no effect. It seems that ComplexExpand does something, sometimes, that allows the expression to be turned into a form of ArcTan[x, y], which is then solveable correctly.
Thanks - yeah I realize there are about a million ways to do this specific task I posted. I have run into this before, too, and like you can never remember what I did to solve it. I think most of the time I just brute force whatever I'm doing or break it up into additional steps like your Module example. I was hoping there was some way to link a specific &amp; with a specific # (maybe something like &amp;_1 and #_1 could know to correspond to the same task). Looks like it's not built in... 
Thanks for the reply, but I'm not quite sure what you're suggesting. I'm not working with user-defined functions - I'm working with built in Mathematica functions and using # as a placeholder with functions that have such a functionality built in. It's possible I'm simply misunderstanding how your suggestion is related.. if you wind up thinking of it please write back - I run into this all the time and while it's always fairly easy to make a workaround it's really tedious and annoying. 
You are working with user-defined functions; that's what the `&amp;` is for. Instead of using `#` and `&amp;` to define your functions, use the `Function` expression. For example Select[#, Function[x, Abs[x-Mean[#]]&lt;=1 ]] &amp; /@ list declares 2 functions: one using `#` and `&amp;`, and one using `Function`. In fact, if you use `FullForm` you can see that `&amp;` will expand to a `Function` expression.
What /u/sandwichsaregood was suggesting is that # and &amp; are the shorthand for the more verbose Function[x, body[x]] (which is identical to body[#]&amp;). It should be pretty clear how now you have names for the slots so you can distinguish between them. You would want something like: Function[sublist, Select[sublist, Abs[#-Mean[sublist]]&lt;=1 &amp;] ] /@ list or even more verbosely Function[sublist, Select[sublist, Function[ element, Abs[element-Mean[sublist]]&lt;=1 ]] ] /@ list
Exactly, thanks for expanding. I was on my way out the door when I saw this post and I've run into the same issue as OP. This was how I got around it. Alternatively, you could just make a named function outside the Select and use that, but that's not the most elegant solution.
/u/m42a and /u/deutosymmetry both explained what I was getting at, but I'll add something that maybe will make it a bit clearer. &gt; I'm working with built in Mathematica functions and using # as a placeholder with functions that have such a functionality built in. You might have a small misunderstanding here. I'll explain, but if you already know this then forgive me. When you're using Select like this, the # and &amp;'s aren't exactly placeholders. They're Mathematica shorthand declarations of [anonymous functions](http://en.wikipedia.org/wiki/Anonymous_function). You can think of them as placeholders, but it's a bit more subtle than that. You're declaring the body of a function of a single variable that you are then Map'ping (/@ is short form for Map) over a list. The shorthand syntax with # and &amp; is really handy, but it doesn't work very well when you nest anonymous functions inside of each other, as you've noticed. This is because in this case the scope of the lambda terms is ambiguous. You can get around this by using the long form, Function, which let's you explicitly name the variables to avoid ambiguity. 
Awesome - makes sense. Thanks so much!
Yep - gap in my understanding. Filled. Thanks again.
I think one source of problems is asking Mathematica to take derivatives of things like `Arg`, `Im`, and `Re`, which are not complex-differentiable. http://mathematica.stackexchange.com/q/3810/239
Thanks dude! 
/r/HomeworkHelp ?
Since your question is relatively vague, I can't help much other than give general guidelines: * The solution of the equation can be found using DSolve[] (assuming you have some initial conditions). * Use Plot[] to find the trajectory (F) with respect to time (t). * The vector field doesn't make much sense in this case, since you only have one independent variable (t) and one dependent variable (F).
The question is such: The population of fish in a pond is governed by dF/dt = 2F 0.01F^2 -75. F is units of Fish, t is units of time in years. We have to look at projections of the next 20 years and help make policy decisions. (a) how is the fact that people fish in the pond reflected in the equation for dF/dt? (b) Describe what happens to the population for various starting values of F. (By examining vector fields for the system and plotting trajectories) (c) Determine the equilibria, if any, for the system. Are the stable or Unstable? (d)The harvest of fish is limited to H fish per year. And people always fish upto the limit. What is the current maximum? (e) experiment with different values of H. For what values of H are there initial values of F so that they don't die out? (f) what should be the reasonable fish harvesting limits for the pond?
Can you go back and proof read your post? There are some typos that don't make much sense. As for the questions, get started on my first comment. Once you have that, we can move forward. (Paste the code here as well).
I proofread it, thanks for helping! &gt; The population of fish in a pond is governed by dF/dt = 2F - 0.01F^2 -75. F is units of Fish, t is units of time in years. We have to look at projections for the next 20 years and help make policy decisions. &gt; (a) how is the fact that people fish in the pond reflected in the equation for dF/dt? &gt; (b) Describe what happens to the population for various starting values of F. (By examining direction fields for the system and plotting trajectories) &gt; (c) Determine the equilibria, if any, for the system. Are they stable or unstable? &gt; (d)The harvest of fish is limited to H fish per year. And people always fish upto the limit. What is the current maximum? &gt; (e) experiment with different values of H. For what values of H are there initial values of F so that they don't die out? &gt; (f) what should be the reasonable fish harvesting limits for the pond? 
/r/cheatatmathhomework 
 google com "direction field" click search button 
Thank you!
Try using Sort with no second argument (defaults to canonical order). For a list of numbers I believe canonical order is simply least to greatest. If M is your matrix then you'd say: Sort[Eigenvalues[M]] You can also use Less explicitly (which is the default) or Greater to get them greatest to least: Sort[Eigenvalues[M], Greater]
/u/rhennigan is right. I would just like to add that I *always* confuse the two and that the documentation is indeed not as helpful as it could be. The crucial hint in the details is &gt;RandomSample[{e_1,e_2,...},n] never samples any of the e_i more than once. So, RandomChoice[{a,b,c},20] is possible as it is with replacement, while RandomSample[{a,b,c},20] is not. If you can think of a mnemonic to remember which one is which, please let me know.
The problem is I don't only need the eigenvalues sorted. I need the eigenvectors sorted in terms of the corresponding eigenvalue.
My bad - then you'll have to use Eigensystem. There's probably a slicker way of doing this, but here's how I'd achieve this. M is your matrix. Eigensystem returns a list with the first element being the list of eigenvalues sorted according to absolute value and then a list of the different eigenvectors. The following will resemble the default output of Eigensystem with the sorted values: Transpose[Sort[Transpose[Eigensystem[M]], #1[[1]]&lt;#2[[1]] &amp;]] Change to &gt; for greatest to least. Then just take the second element of the output and you'll have your list of eigenvectors.
To use `DSolve`, you need to tell Mathematica that x is a function of t: DSolve[x''[t] == -B x'[t] - x[t], x, t] This should yield you the general solution as a mapping. You can extract x(t) like this: First[x[t]/.%] (where % refers to the previous result, so it will only work if `DSolve` was the last run command.) As you probably know from manually solving the ODE, the general solution for x(t) is a linear combination of two exponentials. They are easier to work with if you separate them (say, into x1 and x2) and make them functions of b also: x1[t_, b_] = Exp[1/2 (-b - Sqrt[-4 + b^2]) t] x2[t_, b_] = Exp[1/2 (-b + Sqrt[-4 + b^2]) t] When you look at the function, you'll see that for |b|&amp;lt;2 the argument of the square root is negative, yielding a complex exponential and thus oscillation, while for |b|&gt;2 you get simple exponential decay. As to the complex exponential case, you'll only be interested in either the real or the imaginary part, since they're only a phase-shift away from being identical. Taking the real part is most intuitive, plus it matches the initial condition of having maximum displacement at t=0. So, you can plot the real part of x1(t) like this: Plot[Re[x1[t,0.5]], {t,0,20}] (here with a damping coefficient of 0.5). Table-ing and whatever else needs to be done with the functions should be evident from the help documents, but feel free to ask if anything's still unclear.
So i got the DSolve working, and thank you so much for that help, i even had some fun using ManipulatePlot[] command and setting ranges for the variables and playing with them which was cool because i could manipulate all possible values. The next part of this set of problems i'm working with is also a little vexxing so i've got this table, and i can make it graph it, i need to use it to approximate values of k and B using m=1 t x(t) {0, 0.348} {0.21, 0.366} {0.42, .365} {.63, .351} {.84, .33} {1.05, .304} {1.26, 0.276} Now i understand how to table and plot and graph, what i don't understand is how to approximate values of k and B i suppose i can try solving the equation for t(0)=0.348 t(0.21)=0.366 etc and from there try to figure out k and B but i'm a bit lost
You probably need to fit the data to a model. I know your system is some combination of sinusoids and exponentials, but for simplicity pretend you're just fitting a quadratic model: f(x) = ax^2 + bx + c. If your data is in the form data = {{x1,y1},{x2,y2},...,{xn,yn}} then the command to perform a fit to the specific model is: NonlinearModelFit[data,a x^2 + b x + c, {a,b,c},x]. Mathematica is very good at fitting functions. Most software requires you to give it initial guesses for the parameters a,b,c but mathematica can almost always figure it out by itself (in my experience at least). I have run into a few situations where this isn't the case. If you need to specify initial guesses a0,b0,c0 for a,b,c then the syntax is: NonlinearModelFit[data, a x^2+b x + c, {{a,a0},{b,b0},{c,c0}},x] If you define the output to be the variable fit then you could do the following: fit=NonlinearModelFit[data,a x^2 + b x + c, {a,b,c},x]; fit["ParameterTable"] (this displays the fit values and statistics). Also, in case you need the reduced chi^2 this can be found using: fit["ANOVATableMeanSquares"][[2]] You can plot everything using: Show[ ListPlot[data], Plot[fit[x],{x,xmin,xmax}]]
This is really, really cool!
It is indeed. The first time I'm not upset by Wolfram's pricing policy.
At the beginning of this code snippet, where you have A[x_] , it should be SA[x_] (I figured this out because otherwise SA is undefined). I don't know what the goal of this code is. But I noticed that m and k are the only values being updated, so I presume those are supposed to be the output. So after you run the loop, type {m , k} to see what those two values are. Or just add that after the end of your code, so it looks like: ... m=6k+5; If[SS[m]==1,Break[]]; k=k+1;] {m,k} If you are asking exactly how to run it, first copy the code to your clipboard, then open Mathematica. Press control-V to paste your code in, then press shift+enter to execute the code. 
Alright, I think I got it thanks. I ended up just having it return m, which is the value I wanted, it's supposed to return the next prime number following a given number.
Good! Also, if you want the next prime above n you can just use NextPrime[n] . :)
Is that a function built into Mathematica?
Yes, exactly. When you explained what you wanted your program to do I thought "there is probably a built in way to do that", so I searched primes in the built-in documentation and it popped out. The built-in help is really helpful!
Thanks so much! Works beautifully.
Alright awesome! Thank you so much, this works. Not sure why, but only translations in the dx direction work. As soon as I try entering a nonzero value for the dy offset, the text that showed the coordinates disappears...? edit: never mind, I was entering dy values too large which made it go off the graph. Thanks again. 
Is the data in the form `{{x1,y1},{x2,y2},...,{xn,yn}}`?
Yes
This is very nontrivial. If you have perfectly monotonic data within each branch of your loops, then it might be easier, however, I'm guessing this wasn't generally the case. The solution I found [here](http://mathematica.stackexchange.com/questions/23828/finding-local-minima-maxima-in-noisy-data) may be helpful. You could implement something like this with the applied field values and essentially extract good estimates for the turning points. However, I tried this with a simulated sinewave with moderate noise and it didn't do a very good job. Another thing you could do is write a For loop where you give it some estimated length of points per branch of each loop (assuming your loops have roughly equivalent numbers of points). Then you could say something like the following. Call your big list of applied field values "field" and the values of magnetization "mag". Let's say data = Transpose[{field,mag}}. Initialize two empty lists: upper={}, lower={}. Call your estimated length len. 1) ofInterest=Take[field,{Floor[len(.9)],Floor[len(1.1)]}] (* Take data within 10% of first estimated turning point*) 2) pos=Position[ofInterest,Min[ofInterest]] (*Find position of minimum*) 3) AppendTo[upper,Take[data,pos]] (*Append list of {{H,M}} values to list "upper" *) 4) data=Drop[data,pos], field=Drop[field,pos] (*Remove from data set*) 5) ofInterest=Take[field,{Floor[len(.9)],Floor[len(1.1)]}] 6) pos=Position[ofInterest,Max[ofInterest]] (*Find position of maximum*) 7) AppendTo[lower,Take[data,pos]] 8) data=Drop[data,pos], field=Drop[field,pos] 9) Repeat 100x I'm too lazy to code that up formally, but that's the most straightforward way I can think of doing it. In the future, if it's at all possible, making each hysteresis loop its own data file is very convenient. Then you can just perform one of those operations on a batch of data sets imported from a list of files and it'll work beautifully. (My undergrad thesis consisted of essentially nothing but hysteresis loops, so I feel your pain.)
http://imgur.com/zQygweb I want to separate the top half of this graph. 
If you wanted to select the "bottom" hysteresis loop from the bottom, you might take your data: e.g. yourData={{x1,y1},...,{xn,yn}} and convert it to a polar form (e.g.): newData={Arg[#[[1]]+I*#[[2]]],Norm[#]}&amp;/@yourData; Then use "Select" to extract the data that falls within the correct angle range for the bottom half. bottomhalf=Select[newData,(angle1&lt;#[[1]]&lt;angle2)&amp;] EDIT: If you want to automate the selection of the top/bottom halves, you might try translating the data set using the negative of Mean[yourData] then use Maximize and RotationTransform to Rotate your data set and maximize the x variance to find an optimium rotation angle which puts the "top" and "bottom" halves above and below the new x-axis. After using "Select" to extract the data then do the inverse transform. 
What version of Mathematica are you using? I'm using 8.0.1. My results are: ?"Function" gives the syntax. ??"Function" gives the syntax and attributes/options. EDIT: [Imgur link](http://i.imgur.com/WNaCwya.jpg). 
Getting the same thing in Mathematica 9.0.1. I think OP might have changed some settings.
I'm using 9.0.1, and I get syntax and attributes/options when preceding by both ? and ??. EDIT: The function that ? and ?? give shorthand for is `Information[]'. I note, for example, that when I write Information[Sin] Mathematica returns System'Sin Attributes[Sin]={Listable,NumericFunction,Protected} The second line is to be expected, but the first should display something like "Sin[z] gives the sine of z." Is System' just filler here? Is my front-end unable to access certain data? EDIT2: I have auto-completed suggestions of commands enabled (as is default). With it on, I can enter a command and press Enter to get a blue drop-down menu to appear. Clicking it, I find my familiar "usage message", although in a style that differs from what I've grown used to. If I turn off auto-complete, I cannot access this drop-down. To show off some of the behavior I'm seeing, [here's a screenshot.](http://imgur.com/8CUQ1Li)
I'm running Mathematica 9.0.1, too. I checked Edit&gt;Preferences and reverted each one to default just to make sure (I don't think anything changed) and tried again, to no avail.
Why don't you type a symbol, and then press F1 immediately (presuming you're on Windows, but a straightforward analogue probably exists in both Linux and MacOS). It's very efficient solution, IMO.
I have been a user since MMA 5 and this has always been the case. 
&gt; but x^2 can't equal 2x. Sure it can. Set x = 2. Then x^2 == 2x. Are you aware that you posted in r/mathematica, not r/mathematics? Just curious. 
God damn it! thanks
You've probably figured it out by now, but RotationTransform is what you're looking for. 
I haven't used mathematica yet, but this made me laugh pretty hard. 
Well I can do the final project on matlab or mathematica, since I know java/c++ it wouldnt be such a pain the ass. BUT playing around with mathematica Ive realized I can do this way quicker and much less lines of code provided that I know how to mathematica :s Thanks for the help!
Also look for "A Physicist's Guide to Mathematica". It's more aimed for those who know how to use Mathematica, but it provides plenty of examples and projects.
Ty!
If you'd like your files to be saved in the same directory as the notebook, try: SetDirectory[NotebookDirectory[]]; Export["example.jpg", Plot[Sin[x],{x,0,2Pi}]] 
So I've written a little code in mathematica that plays Conway's Game of Life, its the the prettiest code, but it is my code What can I do to make this faster/more efficient 
Thanks! Helpful and informative. And no, I'm not cheating on homework.
I tested this on a few cases and for some reason it's not giving me correct answers, e.g. ASPrimeOmega[10, 3, 2] should equal 2, but this gives 1.
Oops, I forgot to mod both sides of the equation. Here is a fixed version: ASPrimeOmega[x_, q_, a_] := Total[Last /@ Select[FactorInteger[x], Mod[First@#,q] == Mod[a, q] &amp;]]
*Clears Throat* I knew that. I was just testing you! But seriously, I can't believe I missed that. I'm rather embarrassed right now, since I didn't properly go through my code and catch that. I'm going to give you full credit for making this project happen. You're my hero!
So, instead of using "x[i][j]", what would you use instead? The only reason I use that is because that's what I've always done. Is there an easier way to do that (define a unique function from a basic outline)?
markov chains all da way c'mon
I have no idea. Can you give some context?
It's hard to tell without any code, but this looks like some kind of internal error in the Mathematica runtime. I don't really know anything about that, but I'd hazard a guess that you've hit on a rare bug of some sort. The safe bet is that you've missed two cases (which may or may not be positive) - if you can't figure out what they were and you definitely need them, you'll probably have to run again. For what it's worth, I wouldn't really recommend Mathematica for any kind of computationally intensive work - a faster language will get you there in an hour and most likely be more reliable.
Suppose this is your expression: expr = 13*a*b^2*c^3*d^4 + 17*b^5*d^5 + 19*a*b^2*c^3*d^9; First, turn this into a four-dimensional table that has all the coefficients: coeffs = CoefficientList[expr,{a,b,c,d}]; The *coeffs* variable is a 4D rectangular array; for each of the variables/dimensions, it runs from 0 to the maximal exponent that occurs for the current variable: Dimensions[coeffs] This gives {2, 6, 4, 10}, indicating the maximum exponents of a,b,c,d are 1,5,3,9, respectively. Using *coeffs* you can find, e.g., the coefficient of a\^b\^2\*c\^3\*d\^4 in your original expression: Part[coefficients, Sequence @@ ({1, 2, 3, 4} + 1)] This gives 13 as expected. The +1 is needed because the coeffiecients start counting from 0, while Mathematica indexes lists from 1. Now we need to generate all combinations of exponents that we are interested in: exponents = Select[Tuples[Range[0, 10], {4}], Total[#] == 10 &amp;] Next if you would like to select the coefficients corresponding to those exponents, you get: Map[Part[coeffs, Sequence @@ (# + 1)] &amp;, exponents] Except that doesn't work, as the *exponents* will also contain elements that cannot be addressed in *coeffs*, because the dimensions are limited to the maximum occurring exponent for each variable. There is probably a smarter way to do it, but an easy way of fixing that is to generate an expression where the maximum coefficients for {a.b,c,d} are guaranteed to be at least 10, e.g. expr2 = expr + a^11*b^11*c^11*d^11; Now you can do: coeffs2 = CoefficientList[expr2, {a,b,c,d}]; It is now a square array, and the dimensions are okay for indexing -- because the exponents of {a,b,c,d} in *expr2*, these go to eleven! To arrive at the answer, do this: answer = Total[Map[Part[coeffs2, Sequence @@ (# + 1)]*Times @@ ({a, b, c, d}^#) &amp;, exponents]] There may be a smarter way to do this, I look forward to seeing better solutions. 
The best kind of correct.
Thank you! It looks complicated but I'm going to see if I can make it work. Would it be OK if I asked some questions further on?
That's it. When I try to run your code I get an error though. &gt;Select::normal: "Nonatomic expression expected at position 1 in &gt;Select[gh,Exponent[#1/. {a-&gt;x,b-&gt;x,c-&gt;x,d-&gt;x},x]==10&amp;]" gh is the name of the expanded version of my expansion.
Ah. That didn't work for me so I just used Part to isolate the pieces of gh and created a list with them. Now the code you first posted works like a charm. Thank you so much. If I could just ask you one more question. I'm trying to repeat the same process with another multinomial, except this one has coefficients not equal to 1. However the code involving Select now gives me the terms but omits the coefficients. How do I get them as well? Also, after after extracting the terms whose exponents add up to a certain number, can I now create a list of those exponents?
Sure. These are my functions that I multiplied together to get my multinomial. (The original set of functions only had coefficients of 1.) &gt;q[a_] := 35 a^2 + 20 a^3 + 15 a^4 &gt;w[b_] := 5 b + 30 b^3 + 5 b^4 &gt;e[c_] := 49 c + 6 c^2 + 4 c^3 &gt;r[d_] := 6 d^2 + 4 d^3 + d^4 Then I have: &gt;gh2= q[a]*w[b]*e[c]*r[d] &gt;list2 = Table[0, {Length[gh2]}]; &gt;For[i = 1, i &lt;= Length[gh2], i++, &gt; list2[[i]] = Part[gh2, i]]; &gt;qlist = &gt;Select[list2, Exponent[# /. {a -&gt; x, b -&gt; x, c -&gt; x, d -&gt; x}, x] == 10 &amp;] By testing out the code, it's the last part where the coefficients get dropped. 
*loveofphysics*'s answer looks a lot simpler than my approach so if that is sufficient for your purpose, go for it! For completeness, I cleaned up my approach (getting rid of the introduction of the expression with an extra term), and made into a generic function, perhaps it is of use: selectTermsWhereExponentsSumTo[expr_, variables_, sumValue_] := Module[ {coeffs, selected}, coeffs = CoefficientList[expr, variables]; selected = Select[Tuples[Range[0, sumValue], {Length[variables]}], Total[#] == sumValue &amp;&amp; And @@ Thread[# &lt; Dimensions[coeffs]] &amp;]; Total[Map[Part[coeffs, Sequence @@ (# + 1)]*Times @@ (variables^#) &amp;, selected]] ]; Usage example: selectTermsWhereExponentsSumTo[ 13*a*b^2*c^3*d^4 + 17*b^5*d^5 + 19*a*b^2*c^3*d^9, {a, b, c, d}, 10 ] which yields: 13*a*b^2*c^3*d^4 + 17*b^5*d^5 
My bad. I forgot to change the list I was referring to which is why I didn't get the coefficients. Thanks again for all your help.
You've made a mistake, but that is the way to go about it. I don't want to tell you the answer since this is obviously a homework/test question, but I will at least show you [this](http://reference.wolfram.com/mathematica/tutorial/ChangingCoordinateSystems.html). 
Stephen Wolfram's lawyers would like to have a word with you. 
It was supposed to be shiny red nylon. But it is very unshiny. It almost couldn't get any unshinier. But I presume it is still nylon.
I will print a spikey dodecahedron if I damn well want to!
I've been in the exact some boat as you have. I noticed the garbage collection issue when I upscaled my code to run on larger problems and parallelized my problem (and each kernels would run out of memory). I replaced all Modules by Block for all functions with purely numeric properties and have had 0 problems with it. 
There's a 'polishing' method for ABS plastic involving acetone vapor. It dissolves a thin outer layer of plastic, whereupon surface tension smooths the surface. Maybe a similar method exists for nylon.
I could be wrong, but I think it has to do with the fact that the FFT returns a set of complex frequencys and their conjugates. For plotting you throw away the conjugates. The docs for Fourier I believe mention this briefly.
I had considered that briefly, but I thought that Abs[] had taken care of that issue. 
Can you post an image
Here's one that illustrates things well: http://i.imgur.com/VjCLA2D.png
I see what you are saying about the "extra" data point introducing seeming noise into the Fourier output, but I don't think that's the problem, so I simplified the test case as much as possible, so that the data are visually apparent: http://i.imgur.com/9qR4G3m.png It seems plausible that the second half of the list walks back the frequency components with pi-&gt;2pi phase, which since I'm not necessarily interested in phase at the moment, I might be better off splitting the Fourier list, inverting part 2, and subtracting it from part 1. Is that accurate, though? Does the Nyquist theorem rule these data useless? My limited understanding of Fourier theory is showing, here.
It looks like what you say has merit, if you check [this](http://www.reddit.com/r/Mathematica/comments/1tjoan/what_is_the_symmetrical_noise_on_the_right_end_of/ce9drad). I'm still grasping at the full picture, though. 
I always wondered why Wolfram never implemented this. It feels so wrong to have this otherwise neat front end that misses this feature. Does anyone know the reasons? I could imagine that it might hog a lot of memory because some objects can be very large, but I can't imagine that it would be too much of a problem.
It would also be nice if in the linux version ctrl+z is undo and not terminate program. I guess that's because ctrl+z terminates a process in the terminal, but I've lost quite a few notebooks because of that.
Ctrl-z in Linux is suspend, not terminate. You can resume it with "fg".
Hmm, but I'm not starting mathematica from the terminal. I wonder how I'm supposed to resume it then. 
Rumor has it it's in version 10. But of course it might be pulled at the last moment if it doesn't work well...
&gt; I always wondered why Wolfram never implemented this I think the answer is obvious: it is quite unclear what the semantics of an Undo would be, given the separation between the front-end and the kernel. Would Undo be limited to the front-end? Would an attempt be made to undo changes to the state of the kernel? It is pretty hard to come up with semantics that are intuitive to most people. What do you think the "Undo" should do? Simply undo the changes to the notebook and ignore cell execution? 
Good point. But I suppose at the very least an undo function could revert changes to the front end only. Would that be a problem if the user is aware of it? I suppose undoing changes to both the front end and the state of the kernel would be ideal for me. Is that too naive? Am I missing something here?
Including the kernel state would effectively mean capturing and saving the entire kernel state prior to each command execution. It's really a semantic nightmare. Suppose I remove a symbol (Remove[x]), and undo the operation, should the symbol be re-enstated? The fundamental problem is that there is an impedance mismatch between the kernel (which handles an imperative, sequential, stateful execution model), and the notebook interface, which is essentially a facade built on top of that; with interaction only happening once you press Shift-Enter. Or at least, that's how it used to be. With Dynamic[] constructs, callbacks between the frontend and the kernel happen as a result of different triggers (e.g. a mouse move). How that would interact with Undo is an interesting puzzle. I think there is quite simply no way to implement this properly. I'm afraid it will always be wishy-washy, working-in-some-cases-but-not-others. 
Yeah that's worrying - but is it still officially called a "prerelease"? Let's hope they're just getting the last bugs out.
If you click the little A (copyable text) on your equation on WolframAlpha it shows you both your input on the site and the equivalent input on Mathematica. For your function this looks like: Integrate[(10 - u) (-u + x), {u, 0, x}]
No problem, just putting that BS in Physics to use.
Deconvolution in general can be pretty tricky. It's an ill-posed problem and doesn't necessarily have a unique solution. It gets even worse if you consider the possibility of noise. There are methods to do it, but they typically require some form of [regularization](http://en.wikipedia.org/wiki/Regularization_\(mathematics\)) to solve the resulting inverse problem. I'm not really an expert on deconvolution, so there might be a solution for your specific case, but there definitely is not one in general that doesn't require adding extra constraints to the problem. ListDeconvolution is not exactly the only one, there's also ImageDeconvolve, but it's basically the same thing. There isn't a continuous version because the algorithms that solve it are discrete optimization methods.
What is [Minus]? This isn't good syntax. Minus is an operator which negates its argument, and has this syntax: Minus[x] which returns -x. Please check the code you pasted - I think something went wrong submitting it to Reddit.
Yes. I think this is the problem. I would like to have the table var full of u[i,j] variables. Is it possible to do?
This is more a Mathematica Quine than anything to do with Twitter. A true Twitter Quine would immediately start self-replicating unless it could read its own history. A perfect Twitter Quine would rate-limite itself and thus self-replicate indefinitely.
They can start by putting in an undo function. 
This makes a Hermitian random matrix: makeH[sz_] := # + ConjugateTranspose[#] &amp;@ RandomComplex[{-1 - I, 1 + I}, {sz, sz}] This makes a unitary random matrix: makeU[sz_] := MatrixExp[I*(# + # &amp;@RandomReal[{-1, 1}, {sz, sz}])] The reason your `UnitaryQ` does not give `True` for `makeU[100]` (say) is numerical inaccuracies: Look at ListPlot3D[ Re[#.#\[Conjugate] &amp;@makeU[100]], PlotRange -&gt; {-1, 1} ] and the same for `Im` and you see it is indeed unitary. In fact `makeU` produces a matrix that's both Hermitian and unitary (it's $exp(i*m)$ with $m$ a symmetric random matrix). Sorry to not answer your actual questions, I'm in a bit of a hurry.
If I may ask a follow-up question, now that that matter is settled, how do I change the distribution for just the diagonal elements? As you may or may not know, the Gaussian Unitary Ensemble has diagonal elements which are normally distributed with mean 0 variance 1 and off-diagonal entries normally distributed with mean 0 and variance 1/2. How can I modify my code to reflect this?
I'm not at my computer so let me get back to this tomorrow. 
Sure, thanks!
I've played around with your code for a little bit now and I've found two things that may be causing the difficulties. First, the output of your Evaluate function isn't evaluating to anything. Run the following code: DSolve[{y'[x] == (x^2 + x y[x] + 4 y[x]^2)/x^2, y[0] == a}, y, x] Evaluate[y[x] /.%] and your output will be: {} y[x] Even if we instead run: DSolve[{y'[x] == (x^2 + x y[x] + 4 y[x]^2)/x^2, y[0] == a}, y, x] Evaluate[(y[x] /.%)/.a-&gt;3] (the only difference is in the second line), we still get the same output. Second, when we leave out the //Quiet function we get the following error message: DSolve::bvlim: For some branches of the general solution, unable to compute the limit at the given points. Some of the solutions may be lost. Plot[] can only plot (piecewise) continuous functions, which y[x] (even if it were able to be output) isn't. I hope this helps!
/u/BillSimpsonxV is correct. Your DSolve[] function isn't outputting a function. If you use the function you are trying to plot: y[x]-&gt;1/2x Tan[2(C[1]+Log[x])] then the following code should work to get you the plot you want: Plot[Evaluate[Table[x/2 Tan[2 (a + Log[x])], {a, 1, 4, 1}]], {x, 1, 4}]
"MIDWIFING INTENSIFIES" wut
How will you know c is at the correct accuracy value if you do not know the theoretical c? Assuming the code works and the value of c is actually converging, then you can write this recursively such that it reruns until the conditions: 1. f[x +- dx] is approximately linear. Compare fits made from the three points {f[x - dx], f[x], f[x + dx]} to make a parabola and then compare to a linear fit of {f[x - dx], f[x + dx]}. Over the interval {x - dx, x + dx}, find the area under the curve of their difference. You want to minimize this number and get it to some prescribed accuracy 2. Use a value of c which decays from some initial guess until you reach your prescribed accuracy. 3. You can refine this more if you reach your prescribed accuracy. Perform a second recursion to refine the estimate for c to even more significant figures. In this way, if the value of c we're looking for is 5.4659, then the first recursion would find 5 at the first sigfig, then repeat until desired significance. If after performing a recursion and the next order finds no results, then go back to the previous one and redo the estimate. This sounds like a really fun problem, and I'd like to code this. Unfortunately, I'm at work, and my copy of Mathematica is at my house. You should also post what differential equation you are trying to solve for.
Well, it is actually two differential equations botched together. Here is my code: CreatePunfl[Nc_, h1_, \[Epsilon]_, rq_, rq1_] := Module[{Qunfl, Qunflp, temp}, Clear[P, Punfl, Punflp]; Qunfl[r_] := 2 Nc (r) Coth[2 r] - Nc; Qunflp[r_] := 2 Nc Coth[2 r] - 4 Nc (r) Csch[2 r]^2; temp = NDSolve[ SetAccuracy[{P''[r] + P'[r] ((P'[r] + Qunflp[r])/(P[r] - Qunfl[r]) + ( P'[r] - Qunflp[r])/(P[r] + Qunfl[r]) - 4 Coth[2 r]) == 0, P[\[Epsilon]] == h1 \[Epsilon] + (4 h1)/15 (1 - (4 Nc^2)/h1^2) \[Epsilon]^3 + ( 16 h1)/525 (1 - (4 Nc^2)/(3 h1^2) - (32 Nc^4)/( 3 h1^4)) \[Epsilon]^5, P'[\[Epsilon]] == h1 + (4 h1)/5 (1 - (4 Nc^2)/h1^2) \[Epsilon]^2 + (16 h1)/ 125 (1 - (4 Nc^2)/(3 h1^2) - (32 Nc^4)/( 3 h1^4)) \[Epsilon]^4}, 100], P, {r, \[Epsilon], 11/10 rq}, MaxSteps -&gt; Infinity, WorkingPrecision -&gt; 40][[1]]; Punfl[r_] = P[r] /. temp; Punflp[r_] = D[P[r], r] /. temp; Punflpp[r_] = D[D[P[r], r], r] /. temp; ] CreatePfl[Nc_, Nf_, h1_, \[Epsilon]_, rq_, rq1_] := Module[{Qn, Qnp, ode, temp}, Clear[P, Punfl, Punflp, Qnint]; Qn[r_?NumberQ] := If[r &gt; rq, Coth[2 r] (NIntegrate[(2 Nc - Nff[x, Nf, rq, rq1])/ Coth[2 x]^2, {x, rq, r}, WorkingPrecision -&gt; 40] + Nc (-1/Coth[2 rq] + 2 rq)), Nc (-1 + 2 r Coth[2 r])]; Qnint = SetPrecision[FunctionInterpolation[Qn[r], {r, rq, 22}], 40]; Qnp[r_] := Tanh[2 r] (2 Nc - Nff[r, Nf, rq, rq1]) - 4 Csch[4 (r)] Qnint[r]; ode = P''[r] + Nffp[r, Nf, rq, rq1] + (P'[r] + Nff[r, Nf, rq, rq1]) (( P'[r] + Qnp[r] + 2 Nff[r, Nf, rq, rq1])/(P[r] - Qnint[r]) + ( P'[r] - Qnp[r] + 2 Nff[r, Nf, rq, rq1])/(P[r] + Qnint[r]) - 4 Coth[2 r]); CreatePunfl[Nc, h1, \[Epsilon], rq, rq1]; temp = NDSolve[{ode == 0, P[rq] == Punfl[rq], P'[rq] == Punflp[rq]}, P, {r, rq, 20}, MaxSteps -&gt; Infinity, WorkingPrecision -&gt; 40][[ 1]]; rbound = Head[P[r] /. temp[[1]]][[1, 1, 2]]; Pfl[r_] = P[r] /. temp; Pflp[r_] = D[P[r], r] /. temp; Pflpp[r_] = D[D[P[r], r], r] /. temp; ] Nff[r_, Nf_, rq_, rq1_] = Nf Tanh[2 r - 2 rq]^4; Nffp[r_, Nf_, rq_, rq1_] = 8 Nf Sech[2 (r - rq)]^2 Tanh[2 (r - rq)]^3; The function to solve for find is P[r] and the free parameter is h1. To start, at best set Set Nc=Nf=rq1=1 rq=\epsilon=10^-3. You will see at h1 \approx 2 P will changebehaviour for large r. I would like for P to be linear at least until 15. From experience, that means h1 has to be finetuned up to about 10^-13. It is a bitch to do this by hand, especially since I will need to generate dozens of solutions for various values of Nc, Nf, and rq and would have to do this procedure by hand everytime anew as h1crit changes... If you could provide some coding help that would be awesome. Your idea sounds intriguing, though it seems quite hard to implement as x, dx would have to be chosen dynamically as I undertand it...
hmm, how would I know though from the parameter error, which way to adjust my solution? 
Oh god my brain just melted. I'm just an undergrad Physics &amp; Math major... But without some intense manipulation, Mathematica fails at non-linear DE solving (as you know). Definitely numerical, but what I had in mind when you posted was like a linear fit of some slice of a 2D surface over some interval, but I haven't taken PDE's, so I can't honestly answer how solve this.
Double enter to add a new paragraph. Like this. Use that to make it more readable.
I think you are overthinking this, don't worry about the math, that is all solved. Because the equation is so complicated, I didn't post it in the first plkace, as I thought it would just be distracting. First of all, it is a second order ODE, just one function of one variable! Second, I know how to solve that ODE numerically no problem, you should be able to paste the above straight into mathematica and run it! All I need is an algroithm that analyses the solution I got, and this algorithm is independent of the ODE in question...
Yeah I mean I was trying to make it so that it could be directly copied and pasted into an open notebook, but thanks so much for the protip!
Your post is a little hard to read, so I am just going to give you some general advice on solving de's numerically where the bc's aren't trivial. Introduce a series solution near your boundary (this is really helpful if there is a divergence too). That series will have two arbitrary constants (per function you are solving for, I only show the case of one, it's easily extended to coupled equations). Use the series solution and it's derivative as the bc's that nd solve sees. You will then create some function F[a_ ,b_]:=NDSolve[...] Where your bc's are a function on a and b. The ':=' allows you to define a function that isn't evaluated until called. Now create a routine that solves the set of equations that were your original bc's for a and b. Where you make a function call to F[a,b] On my phone, I hope that makes sense. 
This is very similar to what I just wrote up in another mathematica thread. Create a function of c F[c_ ]:= NDSolve[...] This way c is a free parameter and you can solve your de all day without manually changing your code. Then depending on accuracy you can solve something as simple as F''[c]==0 I'd graph that first to get an idea of which part of the parameter space Quick and dirty would be to do ListLinePlot[ParallelTable[...]] And very the coarseness of your search. You have to make definitions global to use paralleltable btw. 
You can use this: getDigits[x_, n_, b_] := Module[{y = x, l = {}}, Do[y *= b; AppendTo[l, IntegerPart[y]]; y = FractionalPart[y], {n}]; l]; getDigits[RandomReal[], 10, 3]
I didn't think of IntegerPart and FractionalPart... Silly of me. Thanks a bunch!
I feel using IntegerDigits with the second argument is equivalent to just using BaseForm, no? You're telling Mathematica to code in what base it's in. That defeats the point of the exercise.
I'm aware there are better alternatives, but the point of the exercise was to see what's going on behind the scenes of programs like BaseForm and IntegerDigits. Thanks for the help though. I'll definitely keep that in mind.
Ok. The cutest solution I can come up with is this. Mod[Floor[Rest[NestList[3*#&amp;, x, 10]]], 3] Alternative Floor[3*NestList[FractionalPart[3*#] &amp;, x, 10]]
Wolfram makes that such a bitch. There's gotta be a setting no?
You have given exactly zero information on settings, computer, recent changes, etc. I don't see how anyone can give you help. Based on the information you've given, I would suggest that you verify the integrity of the install, and if that still doesn't work, to uninstall/reinstall using [Revo Uninstaller](http://www.revouninstaller.com/). Revo does a very good job at searching for un-deleted folders/files when uninstalling a program.
I was thinking there is a dynamic updating setting somewhere. I do not suspect there is an issue with my install.
thanks, yeah that is what we ended up doing, I was curious if there was something more straightforward
Then my apologies, I don't know how to help you further. A setting change does not seem like it would fix a program crash.
It doesnt crash, it freezes momentarily, and then promts me to disable dynamic updating. As if "dynamic updating" is somehow set to "always on" I often use dynamic variables in notebooks. 
You're plotting the sin(x) vs the number of points in your table. Set up your table outside of the ListPlot command. One column with the x-values, and the other with sin(x). 
You can plot things in the form `{{x1,y1},{x2,y2},...}`. Thus, ListPlot[Table[{x, Sin[x]}, {x, 0, 4*Pi, Pi/25.}]] does what you want. EDIT: Can be slightly fancier with ListPlot[ Table[{x, Sin[x]}, {x, 0, 4*Pi, Pi/25.}], Ticks -&gt; {Table[{N@t, t}, {t, 0, 4 Pi, Pi/2}], Automatic}, BaseStyle -&gt; {FontSize -&gt; 16} ]
Thank you, I had trouble understanding why /u/icondense 's code worked, but I think you helped me figure it out.
So I tried to use Frobenius, but I ran into a single snag: For each boundary condition, I need to solve two equations with my series solutions since I am working with a system of two coupled PDEs (call my dependent variable u and w). However, when I insert the series solutions for u and w into my differential equation, my solution is of a type u + w' ==0, w = u' Where I've dropped constants. In other words, I can only solve for u if I take w' in the second equation, and then plug it into the first. But now I have a new second-order diffEQ that I have to solve in order to get my function u. The reason this is of concern is because I now have 6 parameters per boundary condition: four arise from the series' coefficients (two for u, two for w), but I also have two additional coefficients from the second-order ODE that appeared because I had to take a derivative in order to actually solve the system generated by inserting the series solution. Is this normal, or does this suggest that my BCs don't fully determine the system?
The key observation is that IntegerDigits can be used with a base that is larger than 36. This is probably because IntegerDigits does not make use of any particular symbol chart. Here is a short function to do as you ask without the ability to pad with zeroes: bcstring[v_] := StringJoin[IntegerDigits[v,58] /. ( (* the rest encodes the symbol chart *) Table[i -&gt; ToString[i + 1], {i, 0, 8}] ~Join~ Table[i -&gt; DeleteCases[CharacterRange["A", "Z"], x_ /; x == "I" || x == "O"][[i - 8]], {i, 9, 32}] ~Join~ Table[i -&gt; DeleteCases[CharacterRange["a", "z"], "l"][[i - 32]], {i, 33, 57}])] I don't usually write functions with optional arguments, so my approach to adding padding would be to just use if-then statements instead of being too fancy: bcstring[v_, pad_:0] :=StringJoin[ If[pad &gt; 0, "0" &amp; /@ Range[pad],{}] ~Join~ (IntegerDigits[v,58] /. (Table[i -&gt; ToString[i + 1], {i, 0, 8}] ~Join~ Table[i -&gt; DeleteCases[CharacterRange["A", "Z"], x_ /; x == "I" || x == "O"][[i - 8]], {i, 9, 32}] ~Join~ Table[i -&gt; DeleteCases[CharacterRange["a", "z"], "l"][[i - 32]], {i, 33, 57}]))~Join~ If[pad &lt; 0,"0" &amp;/@ Range[Abs@pad],{}] ] This padding can be either positive or negative, as you requested. I thought it was strange you want padding with zeroes, instead of 1s (which apparently represent 0 in this symbol chart), but I went with what you stated. By the way, this code is meant to run in Mathematica. 
Awesome, it works perfectly! Thank you. Wanna post your bitcoin address? or I could use a tip bot. And damn, you're good with mathematica. You should consider writing other bitcoin tools in the language - there are many potential uses... There are several tools I would personally pay you for...but it's late, I can ramble to you later...in general, wolfram may not be suitable for *implentations* per se because its a bit of a black box, but I could be wrong - it might be suitable for full blown clients. I know it would be prolific for error analysis and various studies of ECDSA and bitcoin's use of secp256k1. It also has promise in conjuntion with the raspberry pi. Let me know how you wanna be hooked up for this job. Cheers. ---- Edit: as for the padding issue...sometimes concatenation of zeroes is useful, sometimes 1's...the protocol is a mess, I'd have to look at the python libs and see. I CAN write in wolfram, so I'm pretty sure if I needed to I can tweak your code, although you are using some constructs here I am not used to. 
Do you know anything about ECDSA?
You're right - it is 1's we would end up padding the base58 addresses in bitcoin. Zeros are concatenated with the public key. A bitcoin address actually looks something like Base58encode[RIPEMD160[SHA256[00+pubkey]]] + checksum Where + is concatenation and the checksum is something like the first several bits of base58encode[SHA256^2 [pubkey]] But you can look at what if is exactly if you're interested. But your intuition was correct one would concat 1's to these not a 0 (0 was excluded so a person could be able to unambiguously write a bitcoin address by hand)
I think I see the general aim of using the shooting method here, but I will need to sit down and think through this---I have seen the use of the shooting method mentioned for problems involving numerical integration with basic Neumann BCs, so it's reassuring to hear a second opinion that suggests doing the same thing for this system. Can you recommend a numerical methods book or set of lecture notes that would contain this particular method and approach? This is surprising difficult to Google. Thank you very much for taking the time to write up such a detailed and expert response.
Not really. Solving DE's is an art, and everyone is different, so you can only give very general advice on how to solve it. For example, there are a certain class of complicated de's where you can can write U''(x)+h(x) U'(x)=f(x)=(g(x) W'(x))' Meaning that you can write that W(x)= Integral( F(x)/g(x)) + constants where F is the antiderivative of f Recognizing when you can do that, is an art though (there is a formula, but I have only ever used it as a last resort in mathematica, its complicated and typically takes a while to execute). The intuition needed to see whats going on can't be taught in a class. It can be learned, but only over time. If you know your system, you can easily come up with W before you would be able to type in the equations in mathematica. I hate to say this to you, but you are going to have to work it out in the best way you know how. From there, you will probably fail. But its not a real failure, you should learn something from this. Then you can try again and tweak your method based on how the previous one failed. Thing is, and I wished someone had told me this when I was getting my PhD, you HAVE to build a tool box based on experiences and results. You have to put yourself in a position where you can say one of three things 1) I know this method will fail 2) I know it will succeed 3) I think I know where to start- all based on the premise that you have either done this problem or similar problems in the past. ______________ Point is, every problem is different. At this point, its hard to make a textbook to lead you through. My advice would be to build a solution based on cylindrical harmonics, since your problem seems to have cylindrical symmetry. Also the example problem you gave is ill defined. It only has 3 out of the 4 conditions required to fix all of the arbitrary constants. Remember if you have m nth order differential equations you will have m times n arbitrary constants, and therefore m x n extra equations to fix those constants. 
I could use any help you'd suggest!
/u/BillSimpsonxV already explained why you get this result. If you want something numerical, use Sin[50 Degree] // N or N[Sin[50 Degree]]
I would use a language that already has nlp libraries available, like python and java. Doing this all by yourself with Mathematica can be painful, especially if you don' t have a Workbench (the IDE) copy. I would just use Mathematica for fast exploration and prototyping of new mathematical methods and algorithms , with intermediate data generated by other languages and libs.
Your syntax isn't correct. From the [Documentation](http://reference.wolfram.com/mathematica/ref/NDSolve.html): NDSolve[eqns, u, {t, tmin, tmax}] Where "eqns" is a list and "u" may or may not be a list depending on how many variables you solve for. EDIT: Also, I don't see how this is a differential equation...I don't see any dependencies (time derivatives, etc.). 
You really need to learn the syntax. Here's a couple of things that are wrong with your input: 1. Enclose all the equations in braces {} and separate them with a comma, not a semicolon. 2. ln doesn't work in Mathematica. Use Log[ ]. (Notice the square brackets. BTW, I can't tell what you're taking the log of. I don't know if this is what you were trying to achieve, but I got this to return a result. NSolve[{y1 == 1 + 0.2*m1^2, y2 == 1 + 0.2*m2^2, t2/t1 == y2/y1, 1.2*Log[ (m2^2*y1/(m1^2*y2))] - (1/m1^2 - 1/m2^2) + 1.4 (4.006*385/.0254) == 0, m1*p1/t1 .5 == m2*p2/t2 .5, p1 == 608000, t1 == 393, m1 == .044}, {m2, t2, p2}]
Thanks a lot guys! I just started learning Mathematica this week.
Yes, I'm probably using a lot of things incorrectly, just started learning Mathematica. Thanks a lot!
What you want to use is [Solve[]](http://reference.wolfram.com/mathematica/ref/Solve.html). NDSolve[] is for numerically solving a differential equation. The good news is that Solve[] is much easier to use on a syntax level. Check out the documentation for a better understanding. Remember that the Documentation Center is your best friend!
Your problem was that when you do {j, 0, 3} and {t, 0, 2Pi} you are giving some value to the variables, so the derivative function takes a number argument when a variable is needed. You can overtake this problem by replacing ParametricPlot3D[Table[D[f[t,j], {t, j}], {j, 0, 3}], {t, 0, 2 Pi}] with ParametricPlot3D[Table[D[f[t, j], {t, j}]/.{t-&gt;a,j-&gt;b}, {a, 0, 3}], {b, 0, 2 Pi}] I think this will also do it.
I'll likely be buying it after my trial runs out, if that makes any difference !
You're right, I copied the command for my general solution. I ran DSolve[{y[x] + x y'[x] + x2 y''[x] == x7 + Log[x], y[1] == a, y'[1] == .2}, y[x], x] and still got no plot from the result. 
Here you go: sol = DSolve[{y[x] + x y'[x] + x^2 y''[x] == x^7 + Log[x], y[1] == a, y'[1] == .2}, y[x], x]; Plot[Evaluate@Table[y[x] /. sol, {a, 1, 4}], {x, 1, 2}]
Don't copy and paste. What DSolve returns is a list of Rules. Use /. (i.e. ReplaceAll) as /u/iyzie shows below. Learn Rules. Love Rules.
Here is a page on how to make executable scripts with Mathematica (most users only use the interpretive mode, but command line scripts work great): http://reference.wolfram.com/mathematica/tutorial/MathematicaScripts.html The best way to learn about commands and syntax is using the built-in Mathematica support (start the Mathematica front-end and press F1). Use the search function, e.g. search for "For" and you get a page showing you the syntax for a For loop. Here are some general tips to keep in mind: 1. All the built in functions are Capitalized. For, Do, While, If, Plot, Integrate. More specialized functions are given descriptive names in "camel case", e.g. ParametricNDSolve, ListPlot3D, etc. Where matlab favors short but cryptic syntax like 'de2bi' for converting integers to binary, the Mathematica equivalent is the function IntegerDigits. 2. Functions are always called with square brackets e.g. For[i = 0, i &lt; 0, i++, Print[i]]. The only use of parenthesis is for mathematical grouping e.g. (x + 1)^2 . Curly braces {} are used for lists. Mathematica does not really have arrays like the other languages you are used to, instead it has linked lists (which are converted to numerical arrays internally when appropriate). To define a 2x2 identity matrix you could write: i = {{1,0},{0,1}} 3. Mathematica has a lot of reserved words for built-in functions. These are always capitalized. Therefore I recommend using lower case letters for your own definitions. For example, the following letters are reserved words (have a built in meaning): C, D, I, E, N, O. This means if you write e.g. D = 1 you get an error. A lot of newbie mistakes are caused by accidentally using reserved words, so stick to lower case. 4. Mathematica is dynamically typed. This means you don't have to declare what the data types of things are (unless you are using advanced functionality). 5. Learn to use Table[] . In most cases it is superior to procedural loops like Do, and For. Mathematica is a functional language, like Lisp, which allows for very compact syntax using functions like Map, Select, Apply, etc (read these in the help if you want). In most cases I recommend sticking with what you know, go ahead and use loops and If statements, but consider at least learning to use Table[]. OK! I'm at the end of my cup of coffee so I'll end my crash course there :D 
Try Mathematica Navigator by Ruskeepaa
Dynamic, Manipulate
Get [Power Programming With Mathematica](https://www.dropbox.com/s/kllwg6y44p8va5g/Wagner%20All%20Parts-RC.pdf) and read the section on Functional programming, which seems to be Mathematica's preferred programming style.
Does Animate give the ability to freely pick values as well, akin to Manipulate's slider?
Try using PlotPoints -&gt; ControlActive[30, 40] as an option for ContourPlot. ControlActive will return its first argument when controls are being moved and the second argument otherwise (play around with the values to see what looks ok).
This is probably to do with Mathematica lowering the plot quality for the sake of speed while animating. You might be able to avoid this by explicitly setting the `PerformanceGoal` option in `ContourPlot`. I'm not 100% on that, but I'm pretty sure this issue is fixable without resorting to pre-rendering, so it might be worth a go.
I have tried: "PolynomialQuotient[{x^4 - 3 x^2 + 3x - 1},{x^2 + x - 2},x] and it gives me "PolynomialQuotient::poly: "{-1+3\ x-3\ x^2+x^4} is not a polynomial"" I have also tried using Quotient["the above syntax"] and it doesnt work either
Curly braces in Mathematica are used for lists. Try parentheses. What are you going to do with the quotient?
You are correct, sorry I was reading the instructions right off of the Mathematica project sheet. Is the syntax different for finding the quadratic/oblique asymptote that occurs?
Thanks a lot! Now to start the daunting task of memorizing every function available with Mathematica I had the simplify down, I was just missing the 'apart' function.
You have a 4th-order polynomial divided by a 2nd-order polynomial. You don't have a linear asymptote, you have a quadratic one. As x becomes large, x^2 will dominate the denominator, with the remaining + x - 2 becoming negligible. So we can throw away the + x - 2. Divide each term in the numerator by the (now simplified) denominator to yield: x^4 / x^2 - 3*x^2 / x^2 + 3*x / x^2 - 1 / x^2 The last two terms clearly tend towards zero as x becomes large, and so can be ignored. Simplifying, we get: x^2 - 3 That's the asymptote.
Just use Im[z] and Re[z] to get the imaginary and real parts of z
It doesnt work
I believe that this method fails when there is at least one complex variable that does not ultimately expand to known-real variables.
Because Mathematica is untyped, it cannot know whether his "ultimate" variables are real or complex until they're given values, so the expansion will stop with embedded Im[]s and Re[]s.
Thank you!
what would you expect a 3d plot of y = |x| to look like
On the xy plane, it presents as a v-shape. I want to be able to extend the z-plane out so that the plot would be two planes meeting on the z axis, only the planes end at the z axis, not projecting below the x axis
how about &gt;`ContourPlot3D[y == Abs[x], {x, -1, 1}, {y, -1, 1}, {z, -1, 1}]`
I'm fairly certain that's what I did, and was given the 2-dimensional plot, but I'll try again once I'm in front of my computer.
&gt; ContourPlot3D[y == Abs[x], {x, -1, 1}, {y, -1, 1}, {z, -1, 1}] This is still giving me a 2-dimensional plot 
I am learning mathematica ( actually just started ) , could you 0please explain me what have you done in the last line?
Yeah sorry that was a typo. I have both tables defined in my actual notebook and listplots for both which both come up empty, so that's not the problem. I actually just edited the post before I saw this.
The issue is that you are not familiar with using DSolve. Here is the easy fix: sol = DSolve[{x''[t] + 2 x'[t] + 401 x[t] == 30*(HeavisideTheta[t - 1] - HeavisideTheta[t - 2]), x[0] == 0, x'[0] == 0}, x[t], t]; Plot[x[t] /. sol, {t, 0, 10}, PlotRange -&gt; All] Keep in mind that DSolve returns exact symbolic solutions. If all you want to see is an accurate plot, NDSolve is much faster. Lastly, if you want to create this table of data points (which you don't need to do for plotting) then you could do: sol = NDSolve[{x''[t] + 2 x'[t] + 401 x[t] == 30*(HeavisideTheta[t - 1] - HeavisideTheta[t - 2]), x[0] == 0, x'[0] == 0}, x[t], {t, 0, 10}]; dataPoints = Flatten@Table[x[t] /. sol, {t, 0, 10, .1}]; ListLinePlot[dataPoints, PlotRange -&gt; All] The main thing you need to understand is that the output of DSolve (or NDSolve) is not a function, it is a (list of) replacement rule(s). In my examples, I named the list of rules "sol." Everytime I want to talk about x[t] and make mathematica know I mean "the solution to the differential equation", I use sol. So x[t] /. sol means "x[t] replaced according to the rule sol, which replaces the symbol x[t] with the differential equation solution that I named sol." 
Oh perfect, thanks! Yeah, I was confused about whether Mathematica would treat x[t] like a function or solution[t] or what. This makes much more sense now.
Try turning off the discontinuity handling mechanism. Sometimes there are problems that it doesn't handle well automatically This should basically be the Method option for NDSolve Method -&gt; {"DiscontinuityProcessing" -&gt; False}
Getting good financial data is always difficult and sometimes different sources stop working. I would suggest trying Quandl. FinancialData actually doesn't go through WolframAlpha's servers - it uses a number of APIs (chiefly yahoo finance). The data that it can give you really depends on the state of those other services and so it's very possible that certain parts of it don't work. 
Cool. (I'm a soccer fan: from a soccer point of view this is clearly an example of GIGO (garbage in/garbage out). The FIFA ranking are wrong in many ways, and so is the output.) 
Yeah, definitely not a very accurate model, just interesting to see. I might try to do it properly with an Elo model. 
That would be very interesting! 
Thank you so much. I was worried that it was due to a bug; I'm still learning so much these days.
I this task is beyond the scope of Collect[], try using Coefficient[] to extract the information to build up the matrix A.
That makes a lot of sense and helps me out so much! Thanks a lot. I will definitely be able to work this into my notebook. 
Here's the problem: http://projecteuler.net/problem=11 The text file in question: http://pastebin.com/r67jzHPe Here's the .nb file: https://www.dropbox.com/s/wmwv6k4deafnbex/problem11.nb Hope this info helps! 
In this first Do loop, you're using j as an iterator, but then you're attempting to use j as an iterator for Product as well, which won't work. Try using a separate iterator for Product like this: Product[t[i, k + j], {k, 0, j + 2}] Alternatively, for a more efficient method, try using Table instead of Do loops. For a starter point, this will give you all the upper-left to lower-right diagonal products. Table[Times @@@ Partition[Diagonal[T, d], 4, 1], {d, -16, 16}] With a little bit of fiddling, you can modify this to take care of the rest as well.
Thanks for the input! I'm still learning Mathematica, so I hope you don't mind, but how did you come up with that expression? What does "Partition" do? Why use @@@ there?
Also, it was my impression that, in the "Product" expression, both i and j are fixed, so it was okay to use them as iterands, though that line of reasoning may be wrong.
@@@ is shorthand for Apply at level 1 (and on a related note, @@ is shorthand for Apply at top level). So for example, if you have a list someLetters = {{a,b,c},{d,e,f}} it's full form is actually List[ List[ a, b, c ], List[ d, e, f ] ]. You can replace the top level list with some function f with f @@ someLetters which evaluates as f[ List[ a, b, c ], List[ d, e, f ] ], or you can go one deeper with @@@ which results in List[ f[ a, b, c ], f[ d, e, f ] ], or equivalently, { f[ a, b, c ], f[ d, e, f ] }. Since Diagonal gave me the full diagonal instead of just pieces of length 4, Partition let me split it into the appropriate parts. As an example, Partition[ { 1, 2, 3, 4, 5, 6 }, 4, 1 ] will partition the list into length 4 pieces, and the 1 indicates that I want to advance one step for each new set. This gives me {{1, 2, 3, 4}, {2, 3, 4, 5}, {3, 4, 5, 6}}, which is where Times @@@ comes in handy, since it will multiply each of the 4-element sets together.
It looks like you almost already did it... Try this: rules={Sin[z_]-&gt;z,Cos[z_]-&gt;1} The "z" is just a way of naming the Pattern Blank (i.e. the "_" ). So, if you have something like yourstuff=Sin[q+p]*Cos[w+r]+2*Sin[q+r] then, yourstuff/.rules returns p+q+2(q+r) Hope this helps... 
Why not just use Plot3D in cylindrical coordinates? Take your function y(x) and call it r(z), and plot for theta from 0 to 2pi and whatever z bounds you need.
I'm afraid I'm not that advanced.I'm still in calculus ab. I just need to rotate the two functions of x around y= 1. Its a volume of rotation question and I'm pretty sure of myself when it comes to solving it algebraically(as a matter of fact I already did)... But my teacher needs an accurate graph as well. It has to be on an coordinate plane on paper as well, so I wanted to know if I could visualize that somehow to make my graph precise and accurate.
That makes a massive performance increase (it's actually linear in time now; it makes sense that it was ~quadratic in time with the AppendTo thing). However, it's still breaking. I've checked those specific SPE files (by simply calling fetch[___]); the thing is, it breaks at a different point. For example, the most recent run broke at 8130. Another weird thing: say I run it for 2000 files. Sometimes, it breaks, sometimes it doesn't (changing nothing between runs, running it on the same files, must restarting the kernel and reevaluating the entire notebook each time). Stranger, is sometimes if I run it twice it will work the first time and break the second (or third). Once it breaks, it can't open any of the files without a restart of the kernel. In fact, it can't do anything (e.g. running fetch[1] won't even work). I'm a little baffled, but if it comes down to it I have a script in Matlab that I can play with as well.
Lol. nice!
If you'd like, I could share a chunk of the files with you by PM. 10k of these is ~ 11MB. Otherwise, I'll keep playing with it. I really appreciate your help.
Can you give an example where you find a noticable difference? I played around with it for a while, and there doesn't seem to be a real difference at all. In fact, for simple examples like f[i_]:=Prime[x]*Log[x + 1], Product is slightly faster for me. I would have assumed that for finite sequences, both approaches end up doing the same, with minimal time differences due to overhead, and that is indeed my experience.
I don't know if this counts as perceptible (unless if you mean to AbsoluteTiming[]), but [here's one](http://imgur.com/pTc0T2z) using ClearSystemCache[].
 AbsoluteTiming[ClearSystemCache[]; Product[Length[FactorInteger[i]], {i, 1, 1000000, 1}];] takes 3.225185 seconds, while AbsoluteTiming[ClearSystemCache[]; Times @@ Table[Length[FactorInteger[i]], {i, 1, 1000000, 1}];] takes 3.224184 seconds. I'm really no expert on how Mathematica works internally, but my guess is that Product[] actually reverts to the same method as Times@@List unless the sequence is infinite and some minor differences in the timing occur due to overhead. 
Mathematica has built in WolframAlpha integration. Have a simple question to ask Alpha? Type it in Mathematica, and it will return Alpha's output. The limitation is on the number of calls that you can make to Alpha. Not on the number of evaluations that you can have in Mathematica. If you are a student, they offer a reduced price on licenses.
You have to use a specific command to make it evaluate via wolfram alpha. Otherwise it will just be Mathematica code.
Ok thanks, that gives me warm fuzzies. Related question: On WA's site, I am trying to implement this [answer here](http://mathematica.stackexchange.com/questions/19611/quick-hessian-matrix-and-gradient-calculation?newreg=6226bf73032a45b088474916100af7dd). Now, do I need to actually get Mathematica, or, can I implement his answer via the WA website? I tried to, but it does not seem to work. Am I boneheading something simple or do I actually need to get Mathematica? Thanks.
WolframAlpha does recognize some Mathematica commands. However, a quick skim over that page leads me to believe you are going to need the full-blown version of Mathematica. Although I'm sure you can go line by line in Alpha, I would have no desire to attempt that. EDIT: Just something to think about: you need to buy the corresponding license depending on where you are doing your work. If you're a student and doing homework, you can get a cheap version; however, if you are in corporate, you need the full blown commercial license.
Ya, I am just a dude who wants to get it so help with derivations of stuff for my own benefit/learning. Used to be a student, graduated some time ago. 
Ok then. Mathematica is a pretty good "introductory" program because of the built in typesetting. Plus, the help documentation is second to none.
I already downloaded the free trial and I am trying to get something like that question had up and running. Its kinda painful. All I want to do is write a script that will evaluate the Hessian Matrix of the function f(x) = log(z1 + z2). &gt;&lt; 
There is also a Mathematica Home Edition for people who are no longer students, but want Mathematica for personal use. As BillSimpsonxV pointed out things like calculating a Hessian does not use WolframAlpha. By the way, the Mathematica command for doing this is In[1]:= D[Log[z1 + z2], {{z1, z2}, 2}] Out[1]= {{-(1/(z1 + z2)^2), -(1/(z1 + z2)^2)}, {-(1/(z1 + z2)^2), -(1/(z1 + z2)^2)}}
You need [InverseFourierTransform:](https://reference.wolfram.com/mathematica/ref/InverseFourierTransform.html) In[]:= InverseFourierTransform[Sqrt[2 \[Pi]] DiracDelta[a + k], k, x] Out[]:= E^(I a x)
Hey man, Thanks that helps a lot. I just started a tutorial on Mathematica on youtube. I think it is powerful... I want to see if I really really need to buy the actual software. You are right about the syntax... jebus... let me ask you, are the x_ and y_ necessary with the underscores? You seem to use it a lot, what do you think of Mathematica VS say, Sage? Thanks
If we venture back to 2008, performing F^-1 [F[f(x); x-&gt;k]; k-&gt;x] yielded a 2\pi where it should not have been. We contacted Wolfram and they fixed it immediately. The discoverer of this bug requested to be acknowledged in the docs (for some reason or another) but this did not happen. Not particularly interesting, but vaguely related to OP's post.
Right on, thanks. 
Hide it behind a function. I'm not at my desktop to be able to check, but I believe you can do something like `foo[ curve_, range_] := ContourPlot3D[ curve, {x,-range,range},{y,-range,range},{z,-range,range}]` Granted it isn't the most elegant thing in the world but I'm not sure how else it could be done. I've never had much luck with Alpha's range detection with complicated surfaces, it always seems to just miss what I really wanted to see.
I'm plotting simple quadrics ((+or-)x^2 / a^2 (+or-)y^2 / b^2 (+or-)z^2 / c^2 = d). They are centered around zero, and they aren't closed. Right now i'm just interested in the region around zero, and as such my ranges are {x, -range, range}, {y, -range, range}, {z, -range, range}. I was looking for a solution to be able to zip up the plotting instruction since it's taking up much space with a redundant declaration.
It does work indeed! I like this approach, why do you say it's not elegant? I mean, as long as i need to plot around the origin, it allows me to avoid declaring the range everytime! :) Thank you!
Check out the definitions of the inverse Fourier transform and Fourier transform in the mathematica documentation. Different definitions are used in different contexts. In this case, there's a minus sign difference between the two. I believe in some other context the (discrete?) Fourier transform is it's own inverse, which is probably why you're confused.
It just cuts down on the typing. Elegance would be automatically detecting 'interesting' areas around the origin and set the range automatically but that's deep voodoo magic that I don't know how to invoke.
Actually, I was just being stupid.
I'm on a phone right now. Could you repeat the Euler problem you are trying to solve? From the code it looks as though you search for sets of 4 primes that are composed of the same numbers. Is that correct?
To expand on that, I'd say that instead of 4 do loops some list manipulation would be a lot better. Have you tried Tally[p2] for instance? That gives the list together with how often each element occurs. Just pick out each one that occurs 4 times and you're done. I'd be surprised if Tally were more than O(n)...
It's stuff like this that helps newbies out. I'll try it out!
The primes need to be in arithmetic progression? Looks like you'd need to do some additional list manipulation then :) I'll try and give some hints on how you could do that, from the top of my head. I'll leave it up to you to write a sensible program (and manage dimensions correctly etc). Say you have a 1D list of primes plist. ListCorrelate[{-1,1},Sort[plist]] will give you a list of the successive differences in your list. If you have a (nx3) list of numbers, Position[list, {a_, a_, a_}] will give you the position where the three elements of a row are all equal.
I don't even think O(n^2) is necessary. I've got something that runs in hundredths of a second here. I think it just takes a different, more functional, way of thinking to bang this out cleanly. I'm happy to offer hints or a solution as well.
Your code to find the set of arithmetic progressions of primes (length 4) took a couple of milliseconds?! How'd you think about it?
It's matter of thinking functionally (eg: scheme/lisp). `Do[Do[Do[Do[` is imperative thinking and is almost always wrong as soon as you hit the second or third one. Create a set of stuff to look at (eg 4 digit primes), `Select[]` (or whatever) on that set, keep going until you're down to what you want. Here's one of my innermost chunk's (w/ Take[#,3] to make it manageable here): Take[GatherBy[Select[primesBelow[10000], IntegerLength[#1] == 4 &amp;], Sort[IntegerDigits[#1]] &amp;], 3] resulting in: {{1009, 9001}, {1013, 1031, 1103, 1301, 3011}, {1019, 1091, 1109, 1901, 9011}} That runs in 3 milliseconds w/o caching on my MBA. The rest takes longer, but it still taps out at ~0.05s.
Shift+ctrl+t, this is the shortcut to converting the cell to traditional form.
Thanks for the answer, but the shortcut I'm looking for keeps the formatting as InputForm---it just makes it look better.
Found it! It is [ctrl]+[shift]+N
[command] on OSX
You can evaluate TraditionalForm just fine.
What expressions are you writing, if it isn't anything above college algebra the syntax should be fine. Just make sure you get your parenthesis in order. I have silenced that warning, and do a lot of my research in Mathematica. Using that as a shortcut has helped me find some errors in equations and formulas. 
If you want to do simple things you don’t need to buy Mathematica, you can use the free clone [Mathics](http://www.mathics.org/). If later you decide to upgrade to Mathematica, everything you learned is transferable since they use the same syntax.
Dude. Wow. Thanks. All the syntax is the same you say?.... 
Good point. I did manage to find a version that works while keeping it InputForm; see my comment below.
Essentially yes, Mathics is practically a subset of Mathematica. The code you write in Mathics typically can be used directly in Mathematica (in some occasions with minor modifications). The converse is not true; Mathematica has a lot of functionality that Mathics doesn’t. But Mathics covers the basics quite well (taking into account that it is developed by a few volunteers in their spare time). It also has the advantage that you can use it online, so you don’t have to be tied to a particular computer.
Thanks friend that is pretty stellar. I had never heard of this before until now. Ill make sure to give it a whirl. It sounds ideal because I want to get my feet wet without having to commit learning-another-god-damned-language-and-possibly-paying-for-it. :-)
Awesome, I'll use this too, thanks.
For functional thinking, I got a lot out of The Little Schemer and SICP. And ruby's enumerable module. For Mathematica, just do more Euler.
Not sure why you think signal processing is so obvious inside of a black box. There are many ways to take "Fourier"; Mathematica had several conventions to choose from. I think you're correct about the units of frequency, bu there is no real guarantee they are not normalized any which way here. I don't know what mathemtaica is spitting out.
&gt; There are many ways to take "Fourier"; Mathematica had several conventions to choose from. Those conventions only influence the values on the y axis, not the x axis. &gt; I think you're correct about the units of frequency, bu there is no real guarantee they are not normalized any which way here. I understand the DFT quite well and the only thing that *FourierParameters* does is (1) scale the y axis and (2) optionally conjugate the result, which is not important since you take the power spectrum. &gt; I don't know what mathemtaica is spitting out. It's documented with the Fourier function, under "Details and Options". Mathematica has an unusual default convention. Most DFT implementations (eg Matlab, MKL, FFTW) use the convention FourierParameters -&gt; {+1, -1}. The difference is a factor Sqrt[n] in the output values. 
? Orbit diagram ?
cool thanks brother.
Hi /u/fujixd, What you are doing, that is your input syntax, is correct. However when you say &gt; if I am getting the right output I am not sure if this means that you are unable to simplify such expressions manually to verify that you are getting the correct output; I would assume not since you are using MMA, so I am a little confused as to what you mean.
While I don't have an answer for your question I can at least help with the last part. Say you have something like this: In[1] := Solve[a x^2 + b x + c == 0, {x}] Out[1] := {{x -&gt; (-b - Sqrt[b^2 - 4 a c]) / ( 2 a)}, {x -&gt; (-b + Sqrt[b^2 - 4 a c]) / (2 a)}} You can just copy one of the solutions and have Mathematica do the replacement for you: In[2] := a x^2 + b x + c /. {x -&gt; (-b - Sqrt[b^2 - 4 a c]) / ( 2 a)} Out[2] := c + (b (-b - Sqrt[b^2 - 4 a c])) / (2 a) + (-b - Sqrt[b^2 - 4 a c])^2 / ( 4 a) This isn't the best example since it doesn't automatically simplify it for you but it does work out to 0. In[3] := Simplify[Out[2]] Out[3] := 0 (Edited to fix some formatting)
That is quite cute...
I use 'NonlinearModelFit' for these tasks. /u/mccaj pointed you to help for it but, briefly as an example fitting to a sine function: func=offset+amp*Sin[2*Pi*freq*x+phase];(* fit function*) fitparams={offset,amp,freq,{phase,0.0}}; (* fit parameters with a guess of zero for phase*) nlm=NonlinearModelFit[data,func,fitparams,x]; (* evaluating this line creates a function 'nlm'*) The 'nlm' function can be used anywhere as 'nlm[x]', that is, mathematica does the substitution for you. In addition by evaluating nlm["StandardizedResiduals"] you get something that can be used to find the chi squared.... I think? good luck
The dynamic plot has an error message I can't figure out. Both in `example_with_raw_input.nb` and `Main_dynamic.nb`
Almost right from the docs: Manipulate[ Plot[a Sin[b x + c] + d, {x, 1, 4}], {a, 1, 4}, {b, 0, 10}, {c, 0, 10}, {d, 0, 10}]
This is a way of doing it. We will use some nested Table commands. First we have the interior table. I assume that you want to extend this list(not only from 0 to 20 but 0 to 30, and change the step again to 1/4 etc.) This is summed up with the interior table. Table[3 + I j, {j,0 +10 k,9 +10 k, 1/2^k }] with k =0 being the first part. When k =1 we have the second part of your table, etc. The second table just changes k. If you increase the 1 to another value you can extend the list as much as you want. Table[Table[3 + I j, {j,0 +10 k,9 +10 k, 1/2^k }],{k,0,1}] Finally we use flatten because the output of the previous command will be like: {{3 +I,..},{3+21/2I,...},{}....{}} and I assume you want it like {3+I,....,3+21/2I....} Flatten[Table[Table[3 + I j, {j,0 +10 k,9 +10 k, 1/2^k}],{k,0,1}]] 
You want [`FixedPointList`](https://reference.wolfram.com/mathematica/ref/FixedPointList.html).
Make a list of random numbers, calculate the sum of the list, then divide the list by that sum. The list will now sum to 1.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Demon algorithm**](http://en.wikipedia.org/wiki/Demon%20algorithm): [](#sfw) --- &gt;The **demon algorithm** is a [Monte Carlo method](http://en.wikipedia.org/wiki/Monte_Carlo_method) for efficiently sampling members of a [microcanonical ensemble](http://en.wikipedia.org/wiki/Microcanonical_ensemble) with a given energy. An additional degree of freedom, called 'the demon', is added to the system and is able to store and provide energy. If a drawn microscopic state has lower energy than the original state, the excess energy is transferred to the demon. For a sampled state that has higher energy than desired, the demon provides the missing energy if it is available. The demon can not have negative energy and it does not interact with the particles beyond exchanging energy. Note that the additional degree of freedom of the demon does not alter a system with many particles significantly on a macroscopic level. &gt; --- ^Interesting: [^List ^of ^algorithms](http://en.wikipedia.org/wiki/List_of_algorithms) ^| [^List ^of ^numerical ^analysis ^topics](http://en.wikipedia.org/wiki/List_of_numerical_analysis_topics) ^| [^Computus](http://en.wikipedia.org/wiki/Computus) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cfnqnnh) ^or[](#or) [^delete](http://www.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cfnqnnh)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/) ^| [^flag ^a ^glitch](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=Glitched comment report&amp;message=What seems wrong: (optional description goes here\)%0A%0A---%0A%0AReply no. 69602:%0Ahttp://www.reddit.com/r/Mathematica/comments/1ytvxi/is_there_an_algorithm_to_get_a_list_of_numbers/cfnqnhc)
A little late here but keep in mind that they are going to release the Wolfram Language soon and it seems there's going to be a web version. I just [watched Stephen Wolfram talking about that.](http://blog.stephenwolfram.com/2014/02/starting-to-demo-the-wolfram-language/.)
Ah interesting! Curious - but what would the Wolfram Language be able to do? It is a glorified math programming language, or more? Sounds interesting! 
As far as I understand, WL is the attempt to make a language independent from Mathematica. It has all capabilities of Mathematica and Wolfram Alpha so you can integrate live real world data (like weather, geographic, movie data, etc) and also use some sort of natural language to program. At the end, being capable of deploying that. Mathematica can't do that deploying part but I don't know how it's going to work with WL. I saw they have a [seminar today](https://www.wolfram.com/events/live/faster-code-with-wolfram-language-2014/)
Oh neat, sounds like a generalized/natural programming language as you said. If they do it right I imagine it will have a lot of potential.
Shameless self bump. 1. The attached tables contain vectors x0 and functions f (t) = {f1 (t), f2 (t), f3 (t)} Let A be the matrix A ={{-2,1,0},{1,-2,1},{0,1,-2}} You will solve the initial value problem x0 = Ax + f (t) x (0) = x0 in two different ways. In both cases, use FullSimplify to simplify your results, and plot the solutions over the interval t = 0 to t = 2. (a) Transform the problem into three uncoupled problems, solve those problems, and recombine to find the solution. (b) Solve the system automatically using DSolve. My listed eqn is x0 = {-4, 9, -2} f[t_] = {Exp[-4 t]*(9 - 15 t), Exp[-2 t]*(13 - 12 t), (13 t + 3) Cos[t]} 
Little to none. What kind of clarification do you need? I, or another classmate, might be able to fill in the blanks. This is a take home test, so I don't think outside (also random) questions about the test would look good.
You should give us a complete example problem of the same type as the ones you're being asked to solve.
He just sent us this pdf file of an example http://imgur.com/SOeD0Ry When I reach the LinearSolve the output just spits out what I put it in and not the answer... http://imgur.com/rB8mGke 
All the built-in functions begin with a capital letter. 
There is good documentation for the line function in mathematica. Are you having trouble using the function, or are you having trouble figuring out how to get the points?
Start it up. Start posting about more advanced topics you find interesting. What do you want to talk about? How to effectively use pattern matching? Building a type system on top of Mma? Building domain-specific languages? Teaching Mma new relations? Why Mma's scoping system doesn't make any sense? How difficult it is to determine application order? Make the threads.
I'm just worried about it getting buried. I guess I'll try.
Maybe a sticky thread?
Having trouble plotting it. I've seen a lot of examines that use: Show[{Graphics... As a starting point for plotting lines. But I can't for the life of me get something to show up when I press enter lmao.
I use Enter in the number pad :]
You don't need show. Show is for combining multiple graphics. You should use Graphics[{Line[{pt1,pt2,pt3,...,ptn}]}] where pti is a vertex of the polygon you are trying to draw. There's a clever general way to generate the vertices for a triangle, square, pentagon, hexagon, or any n-sided regular polygon. 
Just making sure :)
Or just Normalize[Random[1,5],Total]
I wouldn't make a new sub. Why don't you start posting stuff like that here?
I feel the problem is more that it is very silent. The few help requests are not the problem; the lack of other content is.
I could agree with you on this issue.
Oh...derp. should figured that out. So what you said worked, to a degree. It still outputs 3 values per pixel..but what i tried is: dato = Image[dati /. {r_, g_, b_, _} -&gt; {b}] It gets rid of r, and g. ...but all of them are equal for grayscale. now I just need to get rid of the long decimal places.
now it looks like this, http://i.imgur.com/BVeywPM.jpg due to the decimals...getting closer. 
Nailed it! http://i.imgur.com/JfVM6z2.jpg Exactly what I needed. Plus relief plot can immediately generate what it looks like. 
The built-in docs are (very) extensive and include tutorials. Placing the cursor on some word in a notebook and pressing F1 takes you to the relevant documents page, which, by the way, is live (you can execute everything there). I'd start with the tutorials in the docs. Ask if you can't find them. Also there is a Mathematica stack exchange. 
I use these videos for my students to get them started with Mathematica. I find that a lot of other resources assume basic familiarity with Mathematica (or CAS's in general) that students don't tend to have. http://www.youtube.com/playlist?list=PLNr8B4XHL5kGiUCv2m36zUtE2qf00ojp3
It seems to be a hybrid between Mathematica and Wolfram Alpha's natural language parser and access to its data sets. I personally don't see what all the fuss is about. As a programmer, I am not particularly excited about attempts at natural language parsing. It invariably sucks at anything but the most simplistic tasks. EDIT: Just looked at the website. It's really just .... Mathematica. They did a big Search/Replace from "Mathematica" to "Wolfram Language", as far as I can tell, it's truly weird. Just marketing? EDIT #2: StackExchange suggests it's just rebranding: http://mathematica.stackexchange.com/questions/37557/is-mathematica-an-implementation-of-the-wolfram-language 
Mathematica is an application consisting of two components, the kernel and the front end. The language that the kernel understands is now called Wolfram Language - it didn't really have a name before, so people just used to call it Mathematica code. It makes sense to give the language a name, if the language is going to be available outside the Mathematica environment, such as via the internet or inside a calculator. Wolfram himself obviously is blessed with an generous helping of personal vanity, probably due to his extreme intelligence. (There may not be any room in his brain for simple things such as modesty or the ability to acknowledge the efforts of his colleagues). But also, he's getting to the age where he's starting to see people of his generation dying. The Wolframization of everything he does may be the way he's starting to prepare his legacy for posterity - imprinting his name on his work. Steve Jobs missed this trick - I could be writing this on an iJob...
I don't think anybody knows exactly what the Wolfram Language entails, because it's still under wraps AFAIK. Go to the website and all you get is a place where you can sign up for the future release. That said, I watched the video that Stephen Wolfram produced last week and I was left wondering the same thing -- what makes this different than just plain Mathematica? So far I have no idea. To me, they look identical. I will say, though, that if the Wolfram Language turns out to be a full-featured cloud implementation of Mathematica, I'll be pretty excited. We have a Mathematica site license at my university, and I've been using it in my linear algebra and calc 3 courses (as the professor), and students like it -- but downloading, installing, and maintaining a personal copy has not been a frictionless experience, and students without their own computers are locked out. A web version that's really Mathematica and not just Wolfram|Alpha would fill a niche. But if that's the case I with S. Wolfram would stop calling it a "new kind of" whatever. 
Wolfram Language is the name of the programming language that Mathematica uses; it just never really had a name until now. 
Thank you everyone for your advice! Got a heap to go on now. I was aware of the built-in docs, but not of how useful they'll actually be! Thanks again :)
Don't rain on his new kind of parade!
It sounds like you want to use one of the Nest, Fold, or FixedPoint functions. I can't really narrow it down more without knowing more about the problem. http://reference.wolfram.com/mathematica/tutorial/ApplyingFunctionsRepeatedly.html
I was about to dismiss this article halfway through the first page, but I pushed through the second page. I think it's pretty spot on. Wolfram Language doesn't offer anything new other than an interface to W|A (which is already integrated in Mathematica) and cloud runtime. The language doesn't know about the world anymore than W|A does. Yes, it's clean, it's elegant, and it seems like it could find a niche, but it's not a revolution like SW tries to make every of his 'inventions' seem.
The organization of Mathematica, the way it consistently ties together so many features, is one of it's greatest strengths. When version 6.0 first appeared in 2007, I have never seen something so far ahead of its time. Especially in technology, to be that far ahead of any competitors is unheard of. I remember in the documentation for version 5 and below, they made the statement that over 1000 man-years of design and programming effort have gone into making the system. That's what it took to lay down the foundation for version 6 and beyond. When I first heard of Siri I immediately guessed that it was tied to Wolfram because, again, I know of no other company that is even close to unifying so many kinds of data and computation into one well-organized system. I'm in academia, and nearly everyone I talk to thinks of Mathematica as little more than a slow and obtuse environment for doing symbolic calculus. They are repulsed by the amount of hype and jargon that Wolfram spews out (I agree Stephen has a personality defect in this area). They all comment on the horrible licensing policies, and although many universities have site licenses I rarely encounter people who make extensive use of the system. It makes me wonder if Google, Microsoft, etc realize the potential of this system - they would be foolish not to work on copying it. So when I read articles like this, to me it is just about more of the world catching on to the potential that some people have seen since version 1.0. I have no loyalty to Wolfram, however, and I hope genuine competitors appear before it's too late for them to ever catch up. 
I couldn't agree more. But if his massive ego and all the hype are what it takes to end up with non-astonishing but otherwise really good computational software, I'm willing to put up with it. 
While I agree largely with the sentiment of the article, which I interpret as "Wolfram language is actually has some really good ideas, but it isn't the magic that Steven Wolfram describes and its closed nature seriously impacts its usefulness," I'd like to maybe discuss a couple details. &gt; But the cost in terms of flexibility is prohibitive: If any part of Wolfram can’t do what you want (or do it where you want it), you’re out of luck. This is a bit misleading. The author is mixing up "there isn't a built-in command to do task *x*" with "it is not possible to do task *x*". You can always implement stuff yourself; the language doesn't stop you from doing this and it's what you're supposed to do. &gt; In short, the users of the language “know about” the world, not the language itself. Maybe a bit harsh. Wolfram definitely makes it sound way smarter than it is, but I think this interpretation is not right, either. "Knows about the world" means basically that the language is really a programming language combined with a huge database of random facts that are easy to access. The example with flags is a good illustration of what I think the intent for the Wolfram language: I think of the built-ins like the author is discussing as *examples*. The language is kind of a glue between the giant Wolfram database of factoids, something similar to SQL query. You write your own code that combines information to draw out some interesting conclusion. But I definitely agree wholeheartedly with the author on openess. Unless it is open-source it's going to be a niche product, and there's very little chance Wolfram will release it as open source. Mathematica is popular because it's a self-contained, tailored product. The Wolfram language is basically Mathematica, but repacked as an open-ended tool. As much as I genuinely like and frequently use Mathematica, I can't see myself using the Wolfram language for any serious work as it currently stands.
Yeah, I've always thought that Mathematica's worst feature was Steven Wolfram. He probably really is a genius (it seems so), but his attitude is quite repulsive.
There's now a little more official info [available on the site](http://www.wolfram.com/language/).
Yeah, that's basically what I use Mathematica for (a prototyping language), but I'm saying I think that the SQL-ish setup is the unembelished essence of what Wolfram imagines his eponymous new language as being. As an aside, I also thing Mathematica is wonderful as a data processing language. It's ridiculously concise, albeit often cryptic if you're not intimately familiar. I find it far far more natural than MATLAB, reminiscent of the best parts of APL (but without the space alien keyboard) and Lisp.
You want f[{is__Integer}] := ... then `is` will be a Sequence[] on the RHS of the definition, so if you want to use it as a list, you must wrap it in {}. Alternatively you can use a named pattern. Examples: f[{is__Integer}] := Sqrt /@ {is} or f[list:{__Integer}] := Sqrt /@ list f[list:{__Complex}] := Log /@ list
Thank you very much for sharing! :D I'm going to try that!
Unless your PC is a Raspberry Pi, the answer is no. The Raspberry Pi build is compiled to run only on ARM processors, like what is on a smartphone or most tablets. Most PC's run an x86 processor, which is not binary compatible with ARM. 
Well, it may be possible to use a ARM emulator. That will make Mathematica much slower than a native x32/amd64 build, but it may still be faster than the Raspberry. It will also probably be possible to use a Mathematica frontend on the PC connected to an RPi kernel. Finally, it is quite possible to run Mathematica over X (with the kernel on the RPi and the display on the PC). For some us cases that may be convenient. 
&gt;Well, it may be possible to use a ARM emulator. That will make Mathematica much slower than a native x32/amd64 build, but it may still be faster than the Raspberry. It most certainly was not faster on my i5, but you might see comparable performance with significant hardware. That said, if your goal is to get it for free legally, the license still states that it is only free for non commercial use on Raspberry Pi hardware. So, that would just be inefficient piracy. The other use cases you mentioned are fine. If you've got desktop Mathematica, a remote kernel is still the best way to use the Pi build. 
 g[x_] := g[x - 1]^2 + c; g[0] = 0; scale = 1/1000; iterations = 25; Mandel[d_] := {c = d;, p = g[iterations];, TrueQ[Re[p]^2 + Im[p]^2 &lt; 2]}[[3]] list = Reap[ Do[{If[Mandel[x + I y], Sow[{x, y, 1}], Sow[{x, y, 0}]]}, {x, -2.5, 1, scale}, {y, -1, 1, scale}]][[2]][[1]]; Image[Transpose[Partition[Transpose[list][[3]], 2/scale + 1]]] "scale" is the increment for the test pixels, and "iterations" is how many times it will perform g on the pixel's value before deciding if it will escape. It's *slow* -- ideas for making it more efficient are welcomed. Thanks!
A very simple optimization would be to compile the Mandel function. See: [https://reference.wolfram.com/mathematica/ref/Compile.html](https://reference.wolfram.com/mathematica/ref/Compile.html) You could also use Nest instead of recursively defining g[x]. See: [https://reference.wolfram.com/mathematica/ref/Nest.html](https://reference.wolfram.com/mathematica/ref/Nest.html)
Aw, man, yes -- I really need to start learning about Compile, it seems like a great feature.
WHOA. This is incredible.
The main bit is that the function we intend to call thousands of times is compiled. Specifically, it's compiled to Mathematica Virtual Machine (MVM) bytecode, which executes much more swiftly, lacking the overhead of the main Mathematica kernel. The ParallelMap command is mapping an anonymous function (denoted by &amp;) onto a matrix of values at the second level down (the individual item level, rather than the row level). The slot (#) is the place where each item is inserted into the function. Because the function is entirely self-contained (via Module), we can call it many times in parallel, and the instances won't interfere with each other. Each function instance will get its own locally-scoped variables.
As a asker of questions, I see your point and would like conversations on mathematica....But I have no idea what we'd talk about. "Damn...this program is really cool". Others:"rigghhhttttttt???" Not being facetious, I just was thinking of good topics..and I got nadda. 
I'm not sure in how far this is a question about Mathematica. Do you just need to find the point of a function where the first derivative is zero? For example, f[x_] := (x + 2)^2 - 3; (*define the function*) D[f[x],x] (*first derivative*) then Solve[D[f[x],x]==0,x] gives the value of x for which f is minimal (in this example). 
I'm not even sure that question b) is supposed to be answered with Mathematica. The [range](http://en.wikipedia.org/wiki/Range_%28mathematics%29) of a function usually means either the codomain or the image. The codomain of all these functions is the set of real numbers. The image for f would be the set of all real numbers such that y &gt;= -3. I would assume that range in this case refers to the image, because then Mathematica can be useful to answer the question. Basically you would ask what the minimal and maximal value of f(x) can be. Given that the function is continuous, the image (or range) is the set of all real numbers between the minimal and maximal value. For f, the minimum is obtained at x = -2, and f(-2) = -3. You can find the minimum by taking first derivates using Mathematica's function D and using the first order condition (i.e., set the first derivate equal to zero and solve for x), as shown in my comment above. If you want to be pedantic, you would also have to look at the second derivate to find out if it's a minimum or maximum. You can do so with D[f[x], {x, 2}]
Do you know how to answer the teacher's questions without Mathematica? Because if you don't, Mathematica won't really help you in this case. You first need to figure out how to answer the questions, and then how to do that with Mathematica. Maybe free form input will be helpful, but I doubt that that is the point of your exercise. I can't check the latest version of Mathematica right now, but I think it's implemented there. Wolfram Alpha however will do that: [range of (x + 2)^2 - 3](http://www.wolframalpha.com/input/?i=range+of+%28x+%2B+2%29^2+-+3) [vertex of (x + 2)^2 - 3](http://www.wolframalpha.com/input/?i=vertex+of+%28x+%2B+2%29^2+-+3) 
I hope you can explain it a bit better. Let me see if I understand what you mean. Let's say you have a permutation p of the number 1..n. You then drop the number n from that permutation and are left with a permutation q of the number 1..(n-1). You want to ensure that this latter permutation q is not [1234], etc.? What is the general form of the pattern for n, instead of just n=5? I don't see why you have specifically selected [1234], [1342], and [1324]. Why not [1423]? I don't see the criterion for selecting these sequences. I'm also not sure if the 'drop the largest number and then ...' condition is what you really want. Can you explain more?
We are misunderstanding each other. Consider the pattern [1423]. Remove the largest element (4), and you are left with [123]. This is one of the patterns you don't like. Therefore [1423] is out. Correct? Going from 4 to 5 you change the lists. Why not going from 5 to 6, 7, ...? If you want equivalence classes, do you mean you also want to ignore [2345], etc.? Does that mean that down at 4, you also wanted to ignore [234], etc? You'll have to explain more.
To your first question yes if you want to avoid the pattern [123] then [1423] contains that pattern. Now when I extend to permutation of length 5,6,7,8 I am trying to focus on pattern avoidance of length 4. When I move to permutations of length 6,7,8 I still want the pattern avoidance to be of length 4. If what you are asking is can you use numbers other then 123 or 4 for the pattern, the answer is yes. But the length of the pattern should still be 4 numbers I want to avoid. Like in a 6 digit [135624] that contains the pattern [1234] I would want to avoid in the form of [1356]. I hope this is not becoming more confusing then I started... The reason I am using those 3 patterns [1234],[1342], and [1324], is that of the 24 patterns of length 4 they can all be "equivalent" in result I am looking for to one of those 3 patterns. I just need to find how many permutations of a certain length n, avoid the pattern [1234]. How many avoid the pattern [1342]. And how many avoid the patter [1324]. 
I have a hack way of doing it. I couldn't get FreeQ or MemberQ to do what I wanted, so I converted everything to strings and used StringFreeQ instead: perms = Permutations[{1, 2, 3, 4, 5}]; strings = ToString /@ perms; stringsSubset = Select[strings, StringFreeQ[#, {"1, 2, 3, 4", "1, 3, 4, 2", "1, 3, 2, 4"}] &amp;]; permsSubset = ToExpression /@ stringsSubset It's finicky because you have to write the exact string to be avoided.
Thank you lithium! I am a noob in mathematica, so I don't know what to do with the code you provided, to get it to show the output. And if I have to write each string to be avoided that might not help me when I get to permutations of length 8 unfortunately that would be too many for me to write and I'm trying to find a way to get mathematica to do that for me. 
Ok thanks I got it. That's what I am trying to do is make the rule so that when I get to large lists I won't have to manually write out hundreds of strings to be avoided. :/
I understand you want to count the number of permutations which contain (or don't contain) a given sequence. What I'm asking is, WHICH sequences do you want to avoid? Take permutations of {1,2,3,4,5,6,7}. Which sequences within these permutations do you want to avoid, and by what rule can we generate a list of sequences to avoid? You still have not explained which sequences you want to avoid. Here is an example of a concise and unambiguous statement: "I want to count all permutations which contain a rising sequence of length 4 or greater". Write such a statement.
This code gives you the number of permutations which contain a rising sequence of exactly length n. Change 'values' and 'n' to suit your needs. values = {1, 2, 3, 4, 5, 6, 7}; n = 4; seq = Union[Map[Sort[Part[#, 1 ;; n]] &amp;, Permutations[values]]]; seqStrings = Map[StringDrop[StringDrop[ToString[#], 1], -1] &amp;, seq]; perms = Permutations[values]; strings = ToString /@ perms; stringsSubset = Select[strings, StringFreeQ[#, seqStrings] &amp;]; permsSubset = ToExpression /@ stringsSubset; permsLength = Length@perms; permsSubsetLength = Length@permsSubset; Print["Out of ", permsLength, " permutations, ", permsLength - permsSubsetLength, " contain a rising sequence of length ", n] 'seq' is the list of all rising sequences of length n, created by permuting 'values', truncating it, then eliminating all duplicates.
Thanks!! I will look at it when i get out of work
&gt; But when we get to length 6 there are 513 that avoid the patterns (1234), and (1324), but 512 that avoid the pattern (1342). And length 7 there are 2740 that avoid the pattern (1342), 2761 that avoid the pattern (1234), and 2762 that avoid the pattern (1324). There is no way this is true. The permutations are *completely symmetric* under interchange of labels. That's why the permutation group is called the symmetric group. What I'm saying is there are exactly the same number of permutation of 1..n which have as subsequence [1234] as there are with subsequence [1324] etc. Exactly. The. Same. Number.
That looks good. When I attempt it in W/A my problem is the y1' and y2', as W/A uses y_1 to identify y1, and when i add the prime symbol in any way it refuses to recognize it. Any thoughts on how to translate that to W/A? 
You might try renaming y1 to y and y2 to z.
Do you have a better method for doing...whatever it is the guy is trying to do (which remains unclear to me)?
Oh, I know it's a lousy way to do things. That's why I called it a hack from the beginning. I just couldn't find anything better digging through the documentation. Nothing I could get to work, anyway. Pattern-matching with FreeQ seemed like a good method, but I was not sure how to use it in this manner.
Select, Cases, FreeQ, MatchQ, MemberQ ... these are our best friends!
When i get out of work tonight i will quote from the text more specifically what i am trying to do since i did a shitty job of explaining in my words
In Mathematica this works: [Mathematica snippet](http://imgur.com/PrkyrGZ) And this works in Wolfram Alpha: DSolve[{y1'[t] == y1[t] + y2[t] + Sin[t], y2'[t] == 4*y1[t] + y2[t]}, {y1[t], y2[t]}, t]] 
Wow that's a huge help. Mathematica doesn't give step by step, any chance you know how to translate this to W/A? 
I'v added something that works in Wolfram Alpha to my previous post. Unfortunately W/A doesn't understand FullSimplify and pattern substitution it seems, so the solution is a lot less pretty. I doubt that W/A and Mathematica will be able to show meaningful intermediate steps for a problem such as this. 
That's very helpful. Stupid calculus. Thanks a bunch!
Here is more detailed information of what I need. http://imgur.com/a/oTU2B The first image is a definition of pattern avoidance and the last 3 focus on patterns of length 4. The last image is what I'm trying to do in mathematica "for Sn(1342) we have 1, 2, 6, 103, 512, 2740,15485" "for Sn(1234)...." and "for Sn(1324)..."
That might be how I spend my thursday if we can't come up with anything else...I also posted this question in the mathematica forum some responses might help. http://oeis.org/search?q=1%2C2%2C6%2C23%2C103&amp;sort=&amp;language=english&amp;go=Search ^ More information about the sequences This almost gave the necessary outputs, but not quite. In[1]:= Length[Permutations[{1, 2, 3, 4, 5}]] Out[1]= 120 In[2]:= DeleteCases[Permutations[{1, 2, 3, 4, 5}], {___, 1, ___, 2, ___, 3, ___, 4, ___}] Out[2]= { {1, 2, 4, 3, 5}, {1, 2, 4, 5, 3}, {1, 2, 5, 4, 3}, {1, 3, 2, 4, 5}, {1, 3, 2, 5, 4}, {1, 3, 4, 2, 5}, {1, 3, 4, 5, 2}, {1, 3, 5, 2, 4}, {1, 3, 5, 4, 2}, {1, 4, 2, 3, 5}, {1, 4, 2, 5, 3}, {1, 4, 3, 2, 5}, {1, 4, 3, 5, 2}, {1, 4, 5, 2, 3}, {1, 4, 5, 3, 2}, {1, 5, 2, 4, 3}, {1, 5, 3, 2, 4}, {1, 5, 3, 4, 2}, {1, 5, 4, 2, 3}, {1, 5, 4, 3, 2}, {2, 1, 3, 4, 5}, {2, 1, 3, 5, 4}, {2, 1, 4, 3, 5}, {2, 1, 4, 5, 3}, {2, 1, 5, 3, 4}, {2, 1, 5, 4, 3}, {2, 3, 1, 4, 5}, {2, 3, 1, 5, 4}, {2, 3, 4, 1, 5}, {2, 3, 4, 5, 1}, {2, 3, 5, 1, 4}, {2, 3, 5, 4, 1}, {2, 4, 1, 3, 5}, {2, 4, 1, 5, 3}, {2, 4, 3, 1, 5}, {2, 4, 3, 5, 1}, {2, 4, 5, 1, 3}, {2, 4, 5, 3, 1}, {2, 5, 1, 3, 4}, {2, 5, 1, 4, 3}, {2, 5, 3, 1, 4}, {2, 5, 3, 4, 1}, {2, 5, 4, 1, 3}, {2, 5, 4, 3, 1}, {3, 1, 2, 4, 5}, {3, 1, 2, 5, 4}, {3, 1, 4, 2, 5}, {3, 1, 4, 5, 2}, {3, 1, 5, 2, 4}, {3, 1, 5, 4, 2}, {3, 2, 1, 4, 5}, {3, 2, 1, 5, 4}, {3, 2, 4, 1, 5}, {3, 2, 4, 5, 1}, {3, 2, 5, 1, 4}, {3, 2, 5, 4, 1}, {3, 4, 1, 2, 5}, {3, 4, 1, 5, 2}, {3, 4, 2, 1, 5}, {3, 4, 2, 5, 1}, {3, 4, 5, 1, 2}, {3, 4, 5, 2, 1}, {3, 5, 1, 2, 4}, {3, 5, 1, 4, 2}, {3, 5, 2, 1, 4}, {3, 5, 2, 4, 1}, {3, 5, 4, 1, 2}, {3, 5, 4, 2, 1}, {4, 1, 2, 3, 5}, {4, 1, 2, 5, 3}, {4, 1, 3, 2, 5}, {4, 1, 3, 5, 2}, {4, 1, 5, 2, 3}, {4, 1, 5, 3, 2}, {4, 2, 1, 3, 5}, {4, 2, 1, 5, 3}, {4, 2, 3, 1, 5}, {4, 2, 3, 5, 1}, {4, 2, 5, 1, 3}, {4, 2, 5, 3, 1}, {4, 3, 1, 2, 5}, {4, 3, 1, 5, 2}, {4, 3, 2, 1, 5}, {4, 3, 2, 5, 1}, {4, 3, 5, 1, 2}, {4, 3, 5, 2, 1}, {4, 5, 1, 2, 3}, {4, 5, 1, 3, 2}, {4, 5, 2, 1, 3}, {4, 5, 2, 3, 1}, {4, 5, 3, 1, 2}, {4, 5, 3, 2, 1}, {5, 1, 2, 4, 3}, {5, 1, 3, 2, 4}, {5, 1, 3, 4, 2}, {5, 1, 4, 2, 3}, {5, 1, 4, 3, 2}, {5, 2, 1, 3, 4}, {5, 2, 1, 4, 3}, {5, 2, 3, 1, 4}, {5, 2, 3, 4, 1}, {5, 2, 4, 1, 3}, {5, 2, 4, 3, 1}, {5, 3, 1, 2, 4}, {5, 3, 1, 4, 2}, {5, 3, 2, 1, 4}, {5, 3, 2, 4, 1}, {5, 3, 4, 1, 2}, {5, 3, 4, 2, 1}, {5, 4, 1, 2, 3}, {5, 4, 1, 3, 2}, {5, 4, 2, 1, 3}, {5, 4, 2, 3, 1}, {5, 4, 3, 1, 2}, {5, 4, 3, 2, 1}} In[3]:= Length[DeleteCases[Permutations[{1, 2, 3, 4, 5}], {___, 1, ___, 2, ___, 3, ___, 4, ___}]] Out[3]= 115 In[4]:= Length[DeleteCases[Permutations[{1, 2, 3, 4, 5}], {___, 1, ___, 2, ___, 3, ___, 4, ___} | {___, 1, ___, 3, ___, 4, ___, 2, ___} | {___, 1, ___, 3, ___, 2, ___, 4, ___}]] Out[4]= 105 In[5]:= Length[DeleteCases[Permutations[{1, 2, 3, 4, 5, 6}], {___, 1, ___, 2, ___, 3, ___, 4, ___} | {___, 1, ___, 3, ___, 4, ___, 2, ___} | {___, 1, ___, 3, ___, 2, ___, 4, ___}]] Out[5]= 630
I have good, working, simple code. Give me a few minutes to make it a little clearer.
I'm going to post back up at the top because this is now way too deep. Look out there.
Now that the issue has been clarified (see the scans which /u/Rufio1986 posted [here](http://imgur.com/a/oTU2B)), I have some working code to do this. It is brute force. Note that the OEIS [has an explicit formula](http://oeis.org/A005802) which would obviously be much faster!! (* Consider a list of n elements Sn (some permutation of 1..n) and a list of k elements pk (some permutation of 1..k) with k&lt;=n. Generate all ordered subsets of Sn of length k. Apply pk^-1. Ask if any of those is OrderedQ. *) SubsetsInversePerms[Sn_List, pk_List] := Module[{k = Length[pk], n = Length[Sn]}, #[[Ordering[pk]]] &amp; /@ Subsets[Sn, {k}] /; (k &lt;= n)] (* We don't actually need the above (but I save it in case you want to peek inside). What we want is to check if any term is OrderedQ. *) SubsetsInversePermsAnyOrderedQ[Sn_List, pk_List] := Module[{k = Length[pk], n = Length[Sn]}, Or @@ (OrderedQ[#[[Ordering[pk]]]] &amp; /@ Subsets[Sn, {k}]) /; (k &lt;= n)] (* Example *) SubsetsInversePermsAnyOrderedQ[{1, 2, 3, 4, 5}, {1, 3, 2}] (* False *) (* The values of False are the ones which avoid the permutation. Count the number of permutations in the group Subscript[S, n] which avoid some sequence pk. *) NumSnAvoidingpk[n_Integer, pk_List] /; n &gt;= Length[pk] := Count[SubsetsInversePermsAnyOrderedQ[#, pk] &amp; /@ Permutations@Range@n, False] (* Here we go: *) NumAvoidingPk4[pk4_List] /; (Length[pk4] === 4) := TableForm[ Transpose@Table[{n, NumSnAvoidingpk[n, pk4]}, {n, {4, 5, 6, 7, 8}}]] NumAvoidingPk4[{1, 3, 4, 2}] 4 5 6 7 8 23 103 512 2740 15485 NumAvoidingPk4[{1, 2, 3, 4}] 4 5 6 7 8 23 103 513 2761 15767 NumAvoidingPk4[{1, 3, 2, 4}] 4 5 6 7 8 23 103 513 2762 15793 etc. Indeed this reproduces what is listed in the pages of the book you scanned. I hope you get the idea of how to do this type of thing in Mathematica. Cheers! EDIT: Whoops, I incorrectly copied my code listing; I left out the actual call to NumAvoidPk4.
thank you so much for your help!! Thank you for also explaining why each code is written the way it is and what each line means.. This was a tremendous help and again I appreciate it so much as I didn't think it would be such a difficult task! Edit: Yeh it makes a lot more sense now, thank you so much for your patience and really helping me so much. 
You can actually subscript symbols in *Mathematica* if you want to use several different versions of the same letter. Just highlight the symbol you want to substrict and press control and underscore. 
PS Looking at your code, it seems that you are misinterpreting what the book was saying in a way similar to how I was misinterpreting it. It's not exactly the sequence e.g. [1324] that you want to find as a subsequence (which seems to be what you're doing in this code). It means: check, for all ordered subsets of length 4, if, when applying the permutation (1324)^{-1}, if any of those subsets end up as ordered sets. For example, the subsequence [2345] does not avoid [1234], so [82736415] does not avoid [1234], because [2345] appears as an ordered subset inside there. Got it? See my code above for how to check this—using Subsets, Ordering (for the inverse permutation), and OrderedQ.
No problem, it wasn't really very difficult once I correctly understood the problem statement (made possible by the scans you posted). I hope you can grok the Mma, even though I used some slightly higher level constructions. A lot of the stuff you see above ends up making much more sense once you think of Mma as a functional language. PS One of the nice/cute things about using Ordering and OrderedQ is that you can run `SubsetsInversePerms` on anything for which Mma has an order, e.g. `SubsetsInversePerms[{d,e,a,b,c},{a,d,b,c}]`. PPS Can you give some context as to why this is an interesting thing to consider? And after the fact, since you found the OEIS entry, you can just use the explicit formula, right? You don't actually need this (exponentially!) slow code.
I am a Math major and working on my capstone with a professor that specializes in combinatorics. My presentation will be about this and he asked me if I could write a code to show the differences in the pattern avoidance's of length 4. I thought it would be simple enough task at the time. I just found that OEIS entry right before I sent it to you. If I couldn't get the code I was going to ask my professor if I could use that formula which I did happen to see there. I plan on bringing this to his attention as well. 
This is exactly what I was asking for. Thank you so much for your help. The variable "names" with the names as strings is what I wanted. This is just a basic example but I'm working on something much bigger and this helps out so thanks again.
This is perfect. Thank you very much.
This can be done in one line in Mathematica 10. http://reference.wolfram.com/language/ref/MandelbrotSetPlot.html
I started defining a much bigger matrix (171x171 to be exact) and defined 18 rows manually and defined the other 153 rows as averages of the existing rows. It's large but I checked to make sure it had the proper number of rows and elements. However, at the end S=M+M.M is giving me problems. It's defined correctly, but Mathematica is telling me that when it gets to M.M, it's trying to multiply 2 matrices of different length, which dosen't make sense since they're square matrices. What's worse is i dont know how to share the notebook with anyone and the file has alot of code so it'd be hard to show. If anyone has any feedback on this, I'd greatly appreciate it.
You probably already know this but for posterity we can save some typing by setting M[[1]] = Range[6] ; M[[4]] = M[[1]] + 6 ; M[[6]] = M[[4]] + 6 ;
I defined the matrix and rows using the Array function and carefully calculated the size of the matrix using the Length function on each row. http://www.mediafire.com/view/946gvt52r423u5b/Pokemon_171.nb I hope this is how to properly post the link to the notebook file. I appreciate your feedback. Thank you.
Thanks you. I was looking to have ??f print the pseudocode of the function rather than the function itself. I don't want to include it in the f::usage itself because then ?f would be a little too verbose. Right now I've got a rather contrived work-around where the function takes a second optional boolean argument. The argument defaults to False, but if a user puts in True, the function prints the pseudocode rather than executing. 
I think your problem is directly connected to some double bracing in defining your vectors. This is changing how mathematica is treating your matrix. For example the very first line defines o[[1]]= {{stuff }} as opposed to o[[1]] = {stuff}. If you want to define your entries column by column instead of row by row you might try defining it by rows with single braces and then setting o = o//Transpose before doing any further work. Run the following code to see the difference between how mathematica handles the two objects: M = Array[1 &amp;, {3, 3}] ; M // MatrixForm M[[3]] = {{1, 1, 1}}; M[[2]] = {{1, 1, 1}}; M[[1]] = {{1, 1, 1}}; M // MatrixForm When you try to use matrix operations on something that isn't a standard matrix then things can go screwy as you've seen.
Nice. One thing: When you manually rotate the figure (i.e., grab it with the mouse and spin it) your option for view point is disconnected from control. Options "1" and "2" won't change anything anymore. You can prevent that by adding the option PreserveImageOptions -&gt; False at the very end. 
Here's a working demo of wire slices in the spirit of your figure. Appropriate tweaks can be made to replace the wires with solid squares. It's all on one cell, just paste and press shift enter. http://pastebin.com/aZ9Pp1Lm
Oh wow thank you! I couldn't for the life of my figure out how to fix that. 
I took out the brackets as you suggested and that worked perfectly. Thank you. I think the problem was that when I had double brackets instead of single, rather than treating it as a vector with 171 elements, it treated it as a vector containing 1 vector, or 1 element.
Use backticks (\`) around your LaTeX code to avoid reddit's markdown messing it up. Until then, I don't know what you wrote.
You have no underscores, so we can't see what you wrote clearly, and I don't have a lot of time to analyze it.
Thanks, it doesn't matter now. I overslept and the hw is worthless now.
Changing ln to log worked great! Thank you so much. I still can't seem to get the third equation to work. Thank you for your help! I recently transferred schools. My former college did not use Mathematica where my current college does. Everyone learned how to use the program during their Calculus I class, where I'm just having to learn it now for Calculus III. It's definitely a learning curve!
Ah perfect! I just needed a space between the x and Cos. It was as simple as that!. Thank you so much!!!! You saved me a panic attack later in the week!
Well, for one it'd be more idiomatically expressed (and simpler) using [FixedPoint](https://reference.wolfram.com/mathematica/ref/FixedPoint.html) or [NestWhile](https://reference.wolfram.com/mathematica/ref/NestWhile.html). They're a *lot* more efficient than a while loop as well.
Is it possible to define the rows 2,3,5 using a Do function or some other iterative function?
Here is what I came up with. Its not very good (needs significant optimization) but it seems to work. Instead of just assigning each character a grayscale value as the matlab code does, this one tries to match each 8 by 13 section of the image to a character from your list (hence the performance issues.) img = *your picture here*; img = RemoveAlphaChannel[ColorConvert[img, "Grayscale"], White]; permittedChars = {"|", ")", "(", "/", "\"", "\\", "*", "-", "_", "=", "8", "@", "&lt;", "&gt;", "#", " ", "'", "."}; charImgs = ColorConvert[ Rasterize[Style[#, 10, FontFamily -&gt; "Lucida Console"], "Image", RasterSize -&gt; {8, 13}], "Grayscale"] &amp; /@ permittedChars {height, width} = Floor[ImageDimensions[img]/{8, 13}]; cellList[x_, y_] := ImageTake[img, {13*y - 12, y*13}, {8*x - 7, x*8}] selections = Array[cellList, {height, width}]; comparison[selection_] := Total[ImageData[ImageDifference[#, selection]], 2] &amp; /@ charImgs matchQualityArray = Map[comparison, selections, {2}]; characterSelect[totals_] := permittedChars[[Position[totals, Min[totals]][[1, 1]]]] outputCharacters = Map[characterSelect, matchQualityArray, {2}]; outputCharacters = Transpose[outputCharacters]; outputString = StringJoin[StringJoin[{#, "\[NewLine]"}] &amp; /@ outputCharacters]; Print[Style[outputString, 10, FontFamily -&gt; "Lucida Console"]]
I used this algorithm on [this picture](http://imgur.com/C329FiC) and got this result: / /\ "\ " ". / \ *" """* . ". ' \ / ( \ 8 \ / ) \ ". \ / \ "= / / ( \ \ \ / | \ ) . ( ) 8 \ ( ) " 8 ) ( \ ) ) 8 \ ) .*&gt;/@@/. ) ( ( (/ (@" @\/\ | //""/&gt;&gt;( ( \ \\ " ( \@\ ( )"\. | | ) ) ( (\@ " \@\/\ / ) "( ( &gt; ) (\\/ \\ @/@\ \ ( () "@ ( / 8 (\\@ /" ) \\ |) (\@ \) (/ \ 8 \\/\ (/ \ _ "\\ ( (\"( " /\ 8| ) .@" \@@@&gt;*@__ \ ( ""@\/ (\\\_\ / /(/ @\) ) &gt;" (((\ ) \"@@@_8@@@@\(8@@@@/@\/ (\\\" / ( / ( @\\ \ " (@@@\@") (\ \ @@/@( @@@@@@@@\ @\/ (\\\\"\@@"@@@@@/@@__\_"(\/ ) ( " (@@@"" ( /( ( 8""@ @@@@@@@)/ @\\\\\@ @@@@"""@@"@@@@@@@@@| """)&gt; ( (@" . ( \\ ( 8 @@@@@@@@@@@) \\\@" /) (@@@@@@@"/@ (" ( \ \ 8@" ( " \\| ( ( @@@@@@@@@@@ \" (@@@@@@@@@@@ @ " " ( "\\| \ @ ( ) ( (\@/ ( 8@@@@@@@@@@ (@@@@@@@@@@@ ( " / ( 8@\\\ \ / ( ) \\@ / @@@@@@@@@ (@@@@@@@@@@@ | ( / ( . "@\\ \ " (\ (\\@/ \ "@@@@@@@" @@@@@@@@@@ " (" ( " "@\ ( \@ |\ ( \\@ \ / ""@"" 8@@@@@@@@" / @/ ( " "\ \ 8 @"( (\@ ) \) 8@@@@@@" ( &lt;\/ \ \ \( ) / (\\\) \ """" (\/\\| @ | @ )( / (\\\) \ (/ @) \ \ \' \ \\\\ \) / 8 ( \) (\) ( ' / \\\@ (@ ) ( \) @\| ( ) \\\ / 8\@. \ (\) / @| ( )(\\@ \ 8\ \. / (\/ 8\/ ( " ) \(\@@\ ) \" "&lt; 8 (\\/ \\ ( ) &gt;"" \\@ . 8 "* &lt;@@ \\\/ @\\ ( (" '\" .\ ( "@@&gt;__ __@@\@\\ (\\\ @\\|( ( @ \"( (@@@@)/"""@"@@@@@@@@\@@@@@ "@\\\\@@ (\\\\@\\\)" ".") @@@@@@////(\//\"////@@@@@@) "@@\@@(\\\@@ @\\\ \ ) (@@@@@@\(\@@\@@@@\(/\@@@@@@\ @\@@\\\@@" '\\@ ". ) @@@@@"@@@@@@@@@@@@@@@@@@@@@@ 8@@\@"@" @ \ \ @@@@@ (\@@@@@@@@@@\"@ @@@@@@ | @@" " ( 8@@@@@\@\\@@@@/@@@@@@@ @@@@@@ . \ / @@@@@@"\\@8\\"""@@"@\\@@@@@@@ \/#@@@@@@ 8@ @\@ @\@ \\\@@@@@@ | " "@@@@@@@ ( 8\\" @\\. " @@@@@@) " " 8@@@@@@_ (\\@"/**@\\@*\_@@@@@@) \ @@@@@@@@@@\\@&gt;.__(\\@_ @@@@@@) 8 \ @@@@@@@@@@@\@@@@@@@\\@) @@@@@@\ ) \ @@@@@@@@@@@@@@@@@@@@\@) @@@@@@@8 . (@@@@@@@@@@@@@@@@@@@@@@) @@@@@@@/ (@@@@@@@@@@@@@@@@@@@@@@) @@@@@@@ ( (@@@@@@@@@@@@@@@@@@@@@@) @@@@@@@ ." 8@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@ (\ 8@@@@@@@@@@@@@@@@@@@""@@ @@@@@@@ /"///. @@@@@@@@@@@@@@@@@@@@\_@@ @@@@@@@ ./"///// / @@@@@@@@@@@@@@@@@@@@@@@) @@@@@@@._*@@(////// " @@@@@@@@@@@@@@@@@@@@@@@) @@@@@@@ (/// " @@@@@@@@@@@@@@@@@@@@@@@) @@@@@@@ // " (@@@@@@@@@@@@@@@@@@@@@@@) @@@@@@@ ' \ 8@@@@@@@@@@@@@@@@@@@@""@) @@@@@@@ ' \ 8@@@@@@@@@@@@@@@@@@@@&gt;@@) @@@@@@@) ' \ @@@@@@@@@@@@@@@@@@@@@@@@) @@@@@@@\ \ . @@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@8 \ (@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@ \ " 8@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@ 8 " @@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@. 8_ \ (@@@@@@@@@@@@@@@@@@@@@" (@ @@@@@@@@@ '_ \ ) ""@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@" \ \ 
Here's what I did: patchVal = Compile[{{block, _Real, 3}}, 1 - Mean[Flatten[block]], RuntimeAttributes -&gt; {Listable}, Parallelization -&gt; True ]; patchMap = Module[ {ch, bmp, den}, ch = CharacterRange[" ", "~"]; bmp = ImageCrop[Rasterize[#], {8, 16}] &amp; /@ ch; den = Rescale[1 - Mean[Flatten[ImageData[#]]] &amp; /@ bmp]; Nearest[MapThread[#1 -&gt; #2 &amp;, {den, ch}]] ]; toASCII[img_] := Module[ {patches, characters}, patches = Partition[ImageData[RemoveAlphaChannel[img]], {16, 8}]; characters = Map[RandomChoice[patchMap[#]] &amp;, patchVal[patches], {2}]; StringJoin[StringJoin[Prepend[#, "\n "]] &amp; /@ characters] ] Then running img = ImageResize[ExampleData[{"TestImage", "Lena"}], 1024] toASCII[img] gives this text: \\\======\]&gt;;\71oorlllllllvi111""""""""?"?"??"?"?????"""""""?"""?"""""""""""11tlv"7==================!(/-[lli111111111111"111171 =========\]][=?iuuorlllrrlvi11111"""""""""""""""""""""""""""""""""""""""""""11ivlj"7=\================!(-(\vvj111111111111""jCU$ =======\\\\\\=71uuorllrrrrvt1111""""""""""""""""""""""""""""???"""""""""""""111ivli?==\\\\\\===========*(/-{tlji111111""""vnF$$$ ======\[[\==\=7juIorlllrrllj1111"1"""""""""""""??""1111"1111"""""""""""11"""111ivli"7=\\\\============77_(//*1vt111111""vYU#S#Ff ==\\\[[[\\==\=?jIuorlrrrrrvji1111"1"11"""""""""""""1111111111""""""""""1"1"""11ijvi"7===\==============77&gt;'/|,7lji11""vn##ffU666 \\\\]\===\\\\=?vIIorrlrrrrvt111111111"""""""""""""1""""777?"1111"""""""""11"111iivi"77===============77777&gt;~/|'7lvi1vn$S$U8fU$## \\\]\7?7=\\\\=7j&amp;&amp;uolrrrrlji1111111""""""""""""?7=7==[]{_:__::{[="11""""""11111tjvj17777==========777777777\,/.-\ilYSS#FfUf6$S## \[]=71i?=\\\\=7j0Vuoooocrlvj11111111"""""777?1"7777===\]&lt;{__:**!^^*="11111111itvvlj177777=====7777777777777?=^|.|"SSS$fUUF$UF##F ;;=7v0l?=\\\\=?v43&amp;uoooorrlviti11111111?v11111"?"?7?77=\&lt;{_:*:!!!^^^^*=1vvjiiijvlrv17===77777=777777777777777=^+vSSSFUfU$F6##fFG ]=7l0Cv?=[[[\=?v3LIocccocrlvjiii11111""jvji11""""???77==\;_**+!!^^^!^,~-:[volvlllrl17====7"11?7=77777777777===o6SS#UUF#$f6Fh%$f1 =?r0y&amp;v?=\[[\=?vC4uooocrrrlvjti11111"ivvi111111""????77=\&gt;:**!**!^'-/////./"Iooocol17=====?rwu"7=777777777=="sSd#UUU$#U6$fTnno7= 1u&amp;uI&amp;l?=\[\\=?lVCuooccrcrlvjii11111vvvii1iii1""?777777==]_{{:^~---))--///.._uVIuur17=====7l96u17=7777777==l66#6ff6#6f$FfY0l?=7= uIuuu&amp;l?=\[[\=?vV2uooooorrlvtii11"1vjjjiii111""?77777?77==[*^'')'',,)((---//|/:tnCu17=====7lOS6Vi7=7777==7&amp;SdSahfF#a6Ffa%u"7==\\ Iuuuuul?=\\\\=7v04Iuoorcorlvjiij7"rlvjjtii11"777?77?"1"={*!^^!!^^,)-(--------|..=w0i?=====7vsSSSsr"7=77="ZSSFfffU6fFU6#Y1=77=\\\ uuuuI0r?=\\\\=?vC2&amp;uuoooclllvjl":vllvjjj11""??????11?=_+::****^,,^,'~''(((---//..;nl?=====7vsSSdO?!(-/.^%S$6aaaaUU6hF$u7=7=\\\== uuuuuIr"=\[[\=?lzwVuoooocrlljjl*\lrlvjvi1""11"""117;_{&gt;{___:!!!!^!!^,',('''(----|.&lt;o"=====?c6So\!^-|||.`7S#6fU$F#FfUOi====\\\\== ooooool"=\[][=7vV4&amp;uocrrcrlvjv",7rollvi1111"""117\[\]]{::::***:::!!^,^,,'^*^,)(((-/,;7===711=!^,---()-..=SFfU$#$UUdT"===\\\===== cooooov"=\[;;\7vV4uuocrcoclllr]_"jrllrvj11111"7===7=\&lt;__{{::&lt;__:*:***!!^*:!!^,,^,,^^~_==&lt;*,^,)-(~)((-|..o$U66SSFUaw?===\\\====== cooooov"=[;&gt;&gt;[7jCLuuoooooorlro,_71vvlvjj11117==777==\\;{{;]&lt;_{___{_***:*+!!^!*:++*:_!^*,^,(~)~''(-'^-/.^##FUFS6Ueo7==\\\\\\\==== ooooool"=[;&gt;&lt;\7j0Cuooooooorrol'{=7"1lrlii17777"?======\\[{{&gt;&gt;{_&gt;;&gt;;;{__****__*_&lt;__:!!^'',,,'''~--![{_^-ISF6F##U%o===\\\\\\\\=\== oouuuov?=[;;;\7j0Cuooooooooou1!{\=??jrli?7?"""77777====\\\]\[][[\[[;;{{&lt;{}{&gt;[;__*+^,^^^^^,')~(--:[[=\^"dS66#UFYi===\\\\=\\====== ooooort?=];&lt;;[=iVzIoooooooooI",*;\77"l1?""1"777""777==?7?"?"=7"==\\\=\=?7\=&lt;_:!^^^!!^,,'~((((--_71j1*{dd6FF8fTj===\\\=========== ocoorl17=];&lt;&gt;[=i4zyuooocooooIi~!*\??"j11i1?7?""???77???1jvoo7=1roouunhaZu]{:!^^^^^^^,''')-(!]7iouv=^=FSF$S666v===\\\\\=\======== rrrorli?=];;;[=iV3&amp;uooocoooouy+^!]"77"vj"7?"1??"?7""?1llonTwlj&amp;oru%0d9l7=:*!^^!!^^^^,,'!{\luol17]*"8SFU#Sf8Uo===[[\\\\\\\======= llrrcri?=[;;;[=1Vz&amp;uooooooocoIi'!*\=7j1??11""1"?1"1rVzzT8$Zly%ulLYSii7\!+:**:::+!!^^&gt;?rvj?==[]_*?OSFfU6#$fUu7==[[[[\\\\\\======= lllroov"=];&gt;&gt;]=14wJuooooooorlru",!{}1""11""""?"1oJ4&amp;nhToS9yf8Yn2orv?]!^!*:::{::!!!!\I0rv"1=]_[vad#6UaU$SUf2"?=[][[\[[\\\\\\===== lllrour"=]&gt;&gt;{]=14wVuoooooorlvvlu7-!&lt;"1i1"11""1vLnnuVTUwIYhFUTenIo"7{:*:{_____:!^^,'^=o2&amp;u"7=oSS#6f99USS6Uw1"?\]][[\[\\\\\\\\==== lllrouo"=]&gt;}{;=1VwJuoorcoorljivr1-,1vi111""1c9nT$$T2Vens1Yhdd4t"==:*!:;[__]{*^,~'~-):1wSnu==%##$fheO$S$$T1??==\\[\\\\\\\\\\\\=== llrrouo"=]&gt;{};=1&amp;3Jucrrrrrr11iijl]*jii1""lC%O60#Oh6aTeuy&amp;0bT17]_{={!*{&lt;[\]{+^,'))-//'\u6dZ"\YUUf8e%USF66l7?=\=========\\\\\===== rrcoouo"=;&lt;{{;=1yCuocrrlrrliiiiii17i1??"&amp;YF&amp;U#%Yn6fTTfs4dur?=]{!*=:*[[\]{__*^,'~(-///*1wS#u&lt;06a8eTh6FUFu7?=[\\\\\\===7========== rcooouo"=]{{{;=1&amp;2Iocrrrrrlji11??oI17"jJzn6lS6Yn6#fZfCY6ni7&gt;_[;!!;"1?7=;_:_:*^^^,'(--*1ZSdY=jO%e%TFUf$2??7\\\\\\\[\=====7=777777 rrrrouu"=]{{{{=1JVIorrrrcrrvj177?2s11VYy0Z4oSThTnSST2TSo?\{!:]*\?"7"7luul7;&lt;_!^!!*\"jro4fSO"7TTT%66UfO1??=\\======\==========77? oooouyI1=]{{{;="y5yuoroooul==7==7lo$nLou&amp;v6%TC#Sny8#d#v7{_^^:?C%TaUeuOOo""7=]!',=unnYU8TUSTj=VT%f$FU#u7?=\=================7777? ooouI2C1=]{{_{=1y4uorccro4&amp;\\&lt;=oIU%LZn%2jj#F$hV#SFS$Ov7}:^,[toYhoLsl(^irj1?7;'/"Jnw1\n#$#SZc\I3OFFU#Z"7==================77???77 rrouIL31=]{__{="uyorvvjTJ"7\=iT04uI6wCJrj"yUSSF6$SG%1\{+,=1"?7711""\]{\7"""7;/-77??7vnYa$fnI&lt;oVf$$f9v77=============7777777=\{_: rouyVnYi=]{_:_\"u0urvv1771&amp;yn$sL1vr6OCujvirU##S6$dw1=_^]ll"7==\\\==\[;]=?7"?[-|*[=7"vvue#as2_jn6SUSV??=============777??={:***** uu0Vw%sj7]{___="uVul1"77"lrYsCo11uUS6zuoruroO$S#Sy1=+!rnl1"7=\;{______]==7?"=^.!{\=7"1lTUe%T&lt;?a##$f1?7\=========7777??=_+!!***+! C35wnTTv=[{{_{="uVorviijlou&amp;IYr13TFUF6fTOSv1lSPdV1[^]TUCj1"?7=\;_::_{;\=77""7*.,;\=7?"oa6O%F\=%S9$I?7\========77777??\*+**+!!^,, 2zznZh8v7[{&gt;{&gt;="yzii"71nvioZuui"v88UdSe&amp;T&amp;7"yIkY1='?SSs3l1"?7==\]&gt;{{&lt;[=7??117{/|[==7?1n#hsTd7=odFe"?========777777??]****!^,~~,, V4znT6Fl7[{{{{="&amp;Vli1"o0ol0Vvnv7I56fFSwuojwsd#c"?_rxdU03r1""77===\\[[=71"7?""\'.\==?"u#$8YOdl\"#dl77==========777??;++*+^'',,~)) V43nsTs1=[{{{{\?o&amp;uojiyuvu8i&amp;nji"v6UY6SUu0FSSj{:=nddShoJl11"?7====\\\==""irii"_*==7?r6SUTZ8#Y]?O%?7=========77777"\*++!,'''(((() 25zwZnu?=[;&gt;{_\?u3uo1"T040u%0yvi1"cfV1$anu1=1v=1$$ea#evuj1""?777===\\\==77=]\!!&gt;==?vf$$Ownef$=74v77========77777?7_++^''''~((((- nnYn%Yo?=[;&gt;__\?uwIi"1nujeZ%n42rVi?lo8%01\_1o1n66$UsFFrov1""?77777========_-*~^]=71U6$6%2YTUd17r?7========77777?"=:!^'~'~''(---- Te%ZTYu?\;{{__\?uy1r1iT33Tn%Cjou&amp;&amp;l1Jl"+^\l1i$Sn$$aYh#uuui"""?77771i1""""1"7="?"71h#UFaszweedu7"77=====7=777777?"\*^)(~~))------ a9e%T4c?=;{{__[71ly1"on4$hC2y=JljoIo17"^=i7oFUSFU$9es$5V4ri11"?77=7"111"7=\&gt;_=77iU#US68e22Ow#n=7=========777777"";^--(((-------( UUffhJu"=[{___]7In1ivZc2Fnn471iiJl"1?77{\"%Uf9UUUa8O%Unws0rlj1""7777?""""?77==7rfS$UaUfY3CZwfY\============777?"1_-/---//-(''''' FF6FZrr"7\{{__\?unilJ2ufS0hT71171vc"iv=_uFU6U8Ff6U6h88UTOZn&amp;ov1"?7777===[;\\==I8##U88fFLC0Y5TT\\7==========777?11*//------(-)))' $F#FZul"7[{{{_\?IYo&amp;OYo9h5UO"rYr"""?=loVeUf68%$8FfF6fhh8TOZU8wuj1"?7==]&lt;{;{[=1#Offa%UfUIyJ5znO\\7=========777?"1?,|-((---(',^*&lt;7 $6SS6Cu1=[{}{{\"r"jj$nn%sO$F17l4uj11=71"u6FUsnST6FUF$U8OTfTwnyolj11?7==\[\\\\?&amp;s9hfeUU8&amp;uI40nn\=1i1"""777777?"1i]--(~()',!&gt;1Va#f &amp;nO6U%%r?\&lt;&lt;&gt;{;\iVozdUV%fnVTzi"cu?1ov1li=1z6sZ#Y66FU66Ue8fU3c1""""?77==77=\_!^,,_7lsSS8yuJ50ny\?""11ijvlljiii1jj:),,~~'!}1n6fZCV ??1oVsF4"\;&lt;&gt;{\?11ISddwje0ly%TclvrVl1"7"juooT8SnUU$aOUU8ssUYoi11""?77777=\;_+!!^,'((;oasVwYwsr=7777??""1ilrur1oI_',(~,&lt;iZTw5VIyy 17=="u6z"\{{}{\=&lt;v6S66Zawsn%Z56lYn5ol"77vv1ru$$n8fUa%ffYnoeTc111"777777==\]{_:**!^'-//!lTfZY8177=777777?""1i11j7^(--^&gt;o8JuIuloIu Uc7;\1hn"\{{{{\=7zdS#%ff$avTUF39u4Juoj1?\"Tt=ddsT6#UZU$eJiV6ui"??777777==\\]&gt;{_:+!^~-/|.\6aU$7?777777777?""11?7:--('_l4uuolloocr GO?{&lt;7UO"\{{{_[7"5$#hUS6#2jSYSUnYs&amp;vlIr==val{SdYnUFUT$U%olu6o1""??7777====\\;{_:*!^'-//..\SdU=7=777777??""1"\*!'--':1uuolvruurrl kSi]{7hf"\{{__[71faU#S#SwvuS6%6Sf6nC1Vr=="1=vV6TTaaUUf%u11oec1"?77?77777===\[]{_:+^'--/|..1k377777777?"""11[--'--(:"ouuljluurrcu kdl[{=nU1\{{{{\="TF#S6fTUwC6hOF#hfyfhv?71uuluJuJywafFTJ111Jnv"??7777??777===\[;{:*!,)--/|.(Uo777777777?"11":-,,/-*7iloolluurrouI GPV={=0O1\{{{{[="T6SS9%8$TTfUUTShTzzwj11c1u0O6hh8%f#8Vl1"1Zo1?777777??777====\];{:+^,(-//||7j777777777?""""=_*'-^=ivruouVorououu xGZ7;\r%i=&gt;{{{[7?4fShh$Fa%8seUh#T%fouTTo23i?fUSU#S#f5li1145i??7777777?7777====\[&gt;{:!^'-//||/7ruoli1???77777"?{-(_"luuo0CorouoouY GbU7_{1Tv=;{{_;7jIO$$SUT6%U%%fS6U8To"1uJu&amp;8T6S#SdSh4riijnZv"??7777777???777====\]&lt;_*!,(-//|.*4&amp;0CCL5z40c17=7=,-:"unLy0yrouuoruZf nn2?_:75v=;{{_&gt;"i2#6UU6UFh8TTO6S#Ue6Z17"rvS$SSddSOLriiu9ni"??7777777777?77777===\]{_*^,(-//||"urrouVn9SdZ;!\:'*iYTn53oru00ovozTa Coj7{:=uv=;{{_&gt;11n$$66FaU$6nTZY#UneYswujrY#SSdP#s0oo4TYo1""??77777777777777777==\\]{_*^,--//|^uorroou4nY0[,*\1ChTYnIro250rjrIn%% fVo1[_\ll7;{__&gt;?yUS6UOfUn$808zvz$JhYIYr"o%d#SSS6e%YVrj11"""???7777777=777777777==\[;_:+^,(//|/70uorrrollr?=i0C3zn0rr0nsJlivonT%a UhYo&lt;^*?j7;__:&lt;i%f6F6eOTYaUo$Yo1sZlFsuYrosdSSFsyovji111"""""???77777777=7=7777====\]&gt;_:+^,(-//'y0urvjiijjvrrlluyuoVnnwui1vun8hUh $6fJ*'^\j7]{__&gt;v%$$U8ssn%nI&amp;hCyJvYowUwnOuuyfTLurvi111"11"""""???77777777=7========\]]{_*!^'(-//=Iuucv1111i1"1cuI0y&amp;V0l1"lCe$6T4u EDIT: Also, if you have a webcam, try this for extra fun: Dynamic[toASCII[CurrentImage[]]] EDIT2: Here's my attempt at fewer lines of code: {x, y} = {8, 16}; pd = Rescale[Map[1 - Mean[Flatten[ImageData[#]]] &amp;, #, {-1}]] &amp;; ch = CharacterRange[" ", "~"]; nf = Nearest[MapThread[#1 -&gt; #2 &amp;, {pd[ImageCrop[Rasterize[#], {x, y}] &amp; /@ ch], ch}]]; StringJoin[Riffle[Map[nf[#][[1]] &amp;, pd[ImagePartition[img, Round[{x, 1.2 y}]]], {-1}], "\n"]]
Here's how it looks with OP's test image: `.``````````````````````````````````.~` .````````````````````````````````````````.,/` ..````````````````````````````````````````````^. `__+!*+.|` .-````````````````````````````````````````````````,. =^ `-| `'``````````````````````-````````````````````````````.- !/ `'` ./` ````````````````````/``````````````````````````````|. |_/ ^ -.` - `````````-````````````````````````````````/| |7 ( ^` |` `-` ` ` ````` ./ `" -;.`` ^ `` / .| " *``````/``````+ `,`- `. - ^` 1 `!`````,.`````;````|,l;:```-` ` `( ````* " -.-```=,````|7,--.`|l"!&gt;.`,```````````.-/|/(-!```````^`````````~` :' {'``/"\```)|=`````|1l=,|`^``````````````````_~~(````+```.``````+ `7 *```*"1.```.7^````.i"1_!.,````````````..```-:```(,|!|``-,``````_ " `*```{"1=```!_\````.".="!*|,`````````._j.``.{:`````^=```7.``````*` j `'```*"i=^``{~`!```') `7"^^{```````.{""=```,|!````!1~``==```````|/ `/),,^^=` `,```,1w1j]'"*-'\/.?(//!1?,-`````/;1v1-=//' -.```^7{`.71:````````* .!-`|!\"1v/ `]```|1?pg3=1orukI7Fgb61-""*```^="1r\.^_*+``*``--`[`(11?.````````: !(._1rui77,! &lt;1````?`S"!7: ~nfYU6Fl=^.7"[{?1117]ZmY\zUgg178dTu7uil1+````*````](/|` ',{y":/ .|``^ .*1{```; &amp;|`w77"Yf6U6UU;` _1111?-`/.[: {%ro6F#dyrm"?;````!|````.:``|'(| 77&gt;` *'```/` `!."1,``: =``aUU66666UU6. .7=/ !r=1s666666$//r`=````._`/````=7&lt;^.``(~ `"` {.`````^ ^``\1i^`* `` cU6666666Uv 7UU6666666UC _-.!````_``*````.i?j"='``+` {.``:^``^` `!``/?1i_+` ` .wU66666U0` &gt;6666666666\ , :```.[```*`````/^ ~;1=/`_ )^`.=l.``\* ^````^"1i^' `(``\r%hso[` `TU666666Uo -/``*"|```{``````.! ^?^.^ =`.?\]``^"1`:`````_1{ ` -0U6UUUU1```-,`+??/````7`````.`|, ,(+ \`;` ,.`&lt;"1\:`````|j. `.....` .!;[*``` !_("17|`````1-````^*`~. `= ][ *`:111=`````.1. `.....` `````` =;.`````.v*````+1~`_ ` 1. ^./"11?``````7= `....` [```{|``(i_````"1[`\ _."1i=|`````71\` ``` .~``|?)``{1_```*&gt;i=`; **11j *`````1j.`|. `*``.="^``""!``,` \*`_ `{1"&lt;l\.!````1{ `---` -1.``&lt;""!`{1"(`^` :!` (|` 711^*/``7 .|/(-` `~{11v.`_111^*i17.! [. /1` |*!.+ \ZZw1;*!',!((-((,~(-':_;[\,7ti11ril|{"111"j11{^ ` ` `/'^~ ` `1jnsl1!^^^[=^^_\_^^^"1nnl", `[ir1ul=111v0]j11= `.` `- ]77?on"7:=7"vi7nr7{!710J"77= `i1ry11vur- ,71? `,` `^ `17777]7"11jYZTnTZ11v?\v77777 7Iol&lt;*?` `_` ./ `: ;7777"/[71u4Ys?u%n5l7" 177771 | 7** (.`{`177771=7=71i17/=ro17=?=r7777t` .` '( `,{7"77771`1[,7="` ."=7.=7?r?7771. ^ -` .l777771`-|7=7* i=7+ {`17777?^ `/ /` i777777=:"==1-|.."==v^'-177777_ _ |` .17777777711?l""?7r7=7&amp;^ "77777\`: .. +?777777777?v77777?vv?t&lt; "77777=\` .. _7777777777777777777777&lt; "77777o- .` \7777777777777777777777] "77777" , =7777777777777777777777[ 177777? `,= ?7777777777777777777=*"\ 1777771 .^:^\/ i777777777777777777"]!?\`1777771 .-!:^^^^/(/ `17777???777777777777777[`j7?777r*)+\==!^^^,` |^ '"7777?777???????????77?[|i?7?7?v _!^|` .! ]???????????????????????;(1?????1. *` .+ 7???????????????????"!="_'1?????", -` `_ j???????????????????"\?"!^1??????; -` ``{ |1"?????????????????????1'^"?????"= ..` `{ ;"""""""""""""""""""""""1|!1""""""i .+` `` ```! i"""""""""""""""""""""""j`!1""""""i` '7````````_ .v""""""""""""""""""""1"1v`:1""""""1* =_```````_` \]71i11""""""""""""""1\/7i`_1"""""1i? /='``````*` 
Haha, you can do any video-&gt;ASCII (including webcam) with VLC media player: http://imgur.com/lmhK5zz
Yes, but you would have to find some systematic way of defining them first. I don't see any clear pattern right now.
Check out: RemoveAlphaChannel[img, White]
http://www.mediafire.com/view/7er0n88g1a3dm0q/Reddit_Example.nb Here's an example I made. It's much bigger but I'm hoping the pattern will be understandable now. Your personal feedback has been really helpful so thank you. If you need any further clarification please let me know.
It may also be easier to try to construct this matrix with the Table function instead of Do. I'm not really sure but I'm looking through the Documentation center for examples.
Quickest way is to create a notebook with your definitions and run it when you start Mathematica or a new kernel. 
Thanks! I'm gonna try that!
True, not saving after editing would leave me my "template" notebook again, thanks for mentioning! 
you can create a Palette that runs every time you load Mathematica and create a button that will write these definitions out, that way if you ever pass the notebook to another user or use a different machine the notebook will retain all the necessary definitions 
On the off chance that you don't know about the PhysicalConstants package, https://reference.wolfram.com/mathematica/PhysicalConstants/tutorial/PhysicalConstants.html If you have your own constants that you need to use a lot, I think the best practice would be to make a quick package of your own.
I have indeed not heard of that package ;) But how do create my own package?
The quickest way is to create a file named "StephConstants.m" in one of the folders you get if you type $Path into Mathematica. In that file, copy and paste this: BeginPackage["StephConstants`"] a = 1; b = 2; c = 299792458; EndPackage[] Then in a notebook where you want to use your constants, type Needs["StephConstants`"]
Thanks! Gonna try that! :)
Maybe use findpeaks then fit to the output? Edit: sorry, thought this was the matlab sub. Anyway, this problem should be easily solvable in matlab or octave if you have access to them. 
I'm away from Mathematica right now, but this might give you some hints: http://mathematica.stackexchange.com/questions/5575/how-to-find-all-the-local-minima-maxima-in-a-range
It looks like your data could be fit to a function like: Exp[-a*t]*(b+c*Sin[2*Pi*d*t+e]) You could try to fit the whole profile at once to get the decay constant. It seems like you probably already know about 'FindFit' and 'NonlinearModelFit' for fitting? Good luck. 
Would you somehow be able to define M with a subscript as well? For example when I define Subscript[M, d] = Array[0 &amp;, {3, 3}] and try to replace the first row with Subscript[M, d][[1]] = {1, 1, 1} I get an error message saying "Set::setps: Subscript[M, d] in the part assignment is not a symbol. &gt;&gt;" Do you understand what I did wrong and how to fix it?
Alright, I'll give that a shot!
Yea but that sorta defeats the purpose of using subscripts entirely. I tried using the Notations package and that seemed to work. thanks.
Floating point vs symbolic evaluations?
Very few people will benefit from private tutoring. Make it public so everyone can learn something.
You need more curly braces `ListPlot[{{x1,y1},{x2,y2}...}]`
After you take davebees advice and get the data in the proper format: data={{x1,y1},{x2,y2},...}; Then use 'Fit' or 'FindFit' to fit your data to a line. For example, Fit[data,{1,x},x] or FindFit[data,a*x+b,{a,b},x] 
Thanks, this really helped! How would I add labels to my axes (the Greek letter nu and stopping voltage V_0)? I also want to get the intercept in the graph, but my graph starts from the point closest to (0,0). I want the 1st and 4th quadrant to be seen in my graph.
Fair enough. I use it for a few reasons: *I can't read my handwriting well. *I like to justify many of my answers with in text computations. *I don't have to use an eraser. *And it helps familiarize me with a program that I want to learn. Can you recommend another program if Mathematica is such a turd? 
1.) These are a couple of lines. Take a heuristic approach (that's just a fance term for looking at examples to figure shit out). Start at the left. The first line seems to start at {1/2,0} and end at {10,1/2}. The next line seems to start at {1,0} and end at {10,1}. In fact, they all start at {?,0} and end at {10,?}. And if you look at the first two or three lines, it seems to suggest that the x-value of the start point is the same as the y-value of the end point, so they all go from {i,0} to {10,i}. Also i seems to increase in steps of 1/2. Give it a try. As far as graphics are concerned, you can use the options Graphics[..., PlotRange-&gt;{{0,10},{0,10}},Frame-&gt;True] to reproduce the figure. 4.) Your solution is spot on and very elegant. 6.) I think instead of IntegerList[] you should use IntegerDigits[]. Also, I wouldn't bother with Sort[] and use Union[] instead. Generating the list is easy, and you have probably already done it: ListOfPrimes = DeleteCases[ParallelTable[If[PrimeQ[i], i], {i, 100000, 999999}], Null]; Applying IntegerDigits[] in a somewhat crude way: PrimeDigits = ParallelTable[Union[IntegerDigits[ListOfPrimes[[i]]]], {i, Length[ListOfPrimes]}]; Make your life easier by only using those with six distinct integers: PrimeDigits6 = Select[PrimeDigits, Length[#] == 6 &amp;]; And then Select[Tally[PrimeDigits6], #[[2]] == 148 &amp;]
Start with [this](http://mathematica.stackexchange.com/questions/26174/recommended-settings-for-git-when-using-with-mathematica-projects)...
It would be amazing to get mathematica's graph abilities involved here, calculating properties for arbitrary user defined networks. If anyone is familiar with impedance matching, it's really crappy algebra. This could be something nice.
I don't think spice is as useful as other methods of analysis, for matching, not really. In spice I don't know of a way to vary inductance continuously, or capacitance, etc. Mathematica is great at this. You could even do `Dynamic[Plot[ ....functions ... ] ] ` and slide around the params and watch the graph move about. Im displaced but if I get a second I'll give you real code.
Spice allows you to sweep DC voltage, and frequency though. 
correct me if i'm wrong, but a function f of n should be defined: f[n_]:= right? give that a shot if you haven't.
you're totally correct, unfortunately that returns the same error http://i.imgur.com/zx0d9ae.png
 In[1]:= f(n) := ((A*n^a)^(1/s) + c*(B*(a*c*(B/A)^(1/s)*n^(1 - (a/s)))^(-(a*s)/(a - s)))^(1/s))^s + b*log (1 - n - ((a*c*(B/A)^(1/s)*n^(1 - (a/s)))^(-(a*s)/(a - s)))) SetDelayed::write: Tag Times in f n is Protected. &gt;&gt; Out[1]= $Failed
square brackets?
 f[n_] := ((A*n^a)^(1/s) + c*(B*(a*c*(B/A)^(1/s)*n^(1 - (a/s)))^(-(a*s)/(a - s)))^(1/s))^s + b*log (1 - n - ((a*c*(B/A)^(1/s)*n^(1 - (a/s)))^(-(a*s)/(a - s)))) compiles fine.
thank you!
wow, thank you!!
if you don't mind, what would I use to then take the derivative with respect to n?
 D[f[n],n] should work, lemme know if it doesn't.
worked perfectly. Thanks again...first night using mathematica
No problem, syntax can be a bitch to learn. Glad I could help.
You can also use f'[n] for shorthand if your function has only one argument. Multiple primes are also possible.
For future reference, that error message ("times is protected") occurs because without square brackets, the left-hand side gets interpreted as "f times n".
thanks!
 f[n_] := ((A*n^a)^(1/s) + c*(B*(a*c*(B/A)^(1/s)*n^(1 - (a/s)))^(-(a*s)/(a - s)))^(1/s))^s + b*log (1 - n - ((a*c*(B/A)^(1/s)*n^(1 - (a/s)))^(-(a*s)/(a - s)))) D[f[n], n] solve (D[f[n], n] = 0) 0 Solve[D[f[n], n] = 0, n] Solve[0, n] Maximize[f[n], n] Maximize[b log (1 - n - (a (B/A)^(1/s) c n^(1 - a/s))^(-((a s)/(a - s)))) + ((A n^a)^(1/s) + c (B (a (B/A)^(1/s) c n^(1 - a/s))^(-((a s)/(a - s))))^(1/s))^s, n]
Watch your capitals, what is d/dn, f() vs f[], Solve uses == not =, Log not log. You should really check your code step by step, it's a pain in the ass for someone else and it is a useful skill to learn.
Is that set of points the vertices of `batman`? If so you probably just have a rogue point you need to take out. For the colors you have to define them first, `turquoise=RGBColor[0,1,239/255]` and `navyblue=RGBColor[0,0,128/255]` because those specific ones aren't built into Mathematica.
thanks!!!!! that worked!
My special relativity is not up to scratch unfortunately. However, the following code should help: f[x_, y_, z_] := x^2 + y^2 + z Sin[x + y] Manipulate[ ContourPlot[f[x, y, z], {x, -2, 2}, {y, -2, 2}], {z, -2, 2}] This lets you insert any three variable function into a 2D contour plot, and then vary the third variable. Obviously you can specify the plot range, and the bounds for the changing variable in place of the +-2s provided. Options for contour style and specific contour lines can be looked up in the help navigator at ref/ContourPlot under 'options'.
It is unclear what you mean. Please provide more context.
Well done for spotting that, hopefully I can avoid this in future. Seems my reddit syntax isn't as sharp as my mathematica!
If you need a multi-branch 'decision' in your code, I recommend the Switch[] function. For example, Switch[i, 1, f, 2, g, 3, h] will examine i, and if i=1, will execute f, if i=2, will execute g, and if i=3, will execute h.
I am not sure if i understood what you want, but Manipulate may help you, this is an example Manipulate[Plot[x t^2 + t, {t, 0, 10}], {x, 0, 1, 0.1}] 
essentially, I am asking if it is possible to run a for loop around an entire .nb file and not just a single function.
If what you're asking for is a way to constantly solve for Y with the "newest" or mostly recent value of X without re-evaluating the .nb, try using a Dynamic[x] instead. It will send the new value of X into your function in real-time if it is being changed by another function. 
Try [this](http://mathematica.stackexchange.com/q/3037) perhaps...
Hmm... There are several built-in functions in Mathematica that will probably be of some use to you. The Series[] function expands something as a Taylor series, so possibly something like Plot[Table[Normal@Series[Exp[-x^2], {x, 0, i}], {i, 1, 15}] // Evaluate, {x, -2, 2}, PlotRange -&gt; {-1, 2}] The expansion here is being done around the point x=0, and it diverges outside of -1 to 1.
You probably are better off reading the docs a bit, since this is probably homework. Anyway, as I don't care if you learn anything or not, here's an idiomatic way: Plot[Evaluate[Normal[Series[Exp[-x^2], {x, 0, #}]] &amp; /@ Range[15]], {x, -1, 1}] 
Play around with the Manipulate function also, that way you can dynamically change the order of polynomial in real time, for example.
Not that important, but I don't think the delayed assignment on f is need
What exactly are you trying to `ParametricPlot`? One thing that might be wrong is that you dont have an underscore on some of your assignments (`gck50` and `gck20`).
ah, Evaluate helps sometimes. I forget to try it when I have a bug
Your first problem doesn't make any sense to me. If you revolve the line x=0 about the x axis, you get an infinite plane. If you truncate this plane so it exists between y=0 and y=5, then you have an infinite strip. It's not really worth plotting, as it's not interesting to look at.
If he limits the line from x=0 to x=5 he should get a disk. The second line should give a ring of thickness 1.
It says "revolve the line x=0 around the x axis", which produces an infinite plane. If the truncation is done to the line, then it should be described first, with the revolution second. Order of operations is important here.
You wrote that it's revolved, then truncated. If you want the line to be truncated, then revolved, you should order your statement that way.
Spend some quality time with the rather extensive built-in documentation. Without knowing what you're trying to do it's incredibly difficult to suggest even a limited set of the syntax. I'm pretty sure there's a full-blown algebra tutorial in the docs that covers everything you'd ever want to know and more. e: The "Basic Math Assistant" under Palettes is invaluable if all you're looking for is syntax for a certain function.
If you type = on a new line, you can type "natural language" input and Mathematica will try to interpret it. It will also show you the proper Mathematica code for how it interpreted what you typed. This is a good way to learn the basic commands.
[This should help you figure it out.](http://reference.wolfram.com/mathematica/guide/Mathematica.html)
What have you already tried? What worked? What didn't? Got any ideas, leads, clues or are you completely lost? Is this a homework problem set or are you "setting up" problems for students or friends? What's your background? Why Wolfram Alpha? Do you have any experience with it or just thought it would be useful, and in what way? These are some of the questions that arise from your post.
This is exactly what I was looking for, thank you!
Very cool tip. That's definitely going to come in handy. Thank you. 
If you've gotten to the point of being assigned vector calculus problems, you shouldn't have any issue doing these by hand. Are you planning on simply plugging them into Alpha because you think its a free way for someone else to do the work? Is OP being serious?
 Plot[Table[Normal[Series[Exp[-x^2], {x, 1, s}]] /. x -&gt; t, {s, 1, 15}], {t, -1,1}] is another way to do this
I'm trying to solve an initial value problem for a separable linear first-order differential equation using Mathematica. I already know the answer and am just trying to get better at programming practice. The answer is y=(sinx*sinx)+2sinx. The original problem is dy/dx=2((y+1)^(1/2))cosx with y(pi)=0. What is wrong with my syntax?
careful with your `==`s and `=`s
http://i.imgur.com/ax5DVl8.png Thank you all so much for your feed back thus far. This is the result of taking your advice and replacing y with y[x] and y[Pi]=0 with y[Pi]==0. The Dsolve now seems to be giving me a result I did not expect. Shouldn't it only return the second element from the list of solutions and not the first? Also when I try to verify the solutions, they do not come out as simply "True" or "False" as they should. When confirming the solutions, I also tried FullSimplify, and that had the same result. I get the feeling I'm still doing something wrong. Any ideas? 
Awesome. Thanks again for the responses. Would anyone also happen to know how to plot the solution?
Once you have some function, just use Plot[function,{x,xmin,xmax}].
A difference on the fourth significant digit is not relevant, probably. Your standard error on each measurement will be way higher than that. 
Just post your question here. People are willing to help (including guidance and answers to follow-up questions), but less so via PM. 
We are suppose to graph our solution (something about it being a drum) but every time I try to graph I get the following error RevolutionPlot3D[u8[r, 0], {r, 0, 1}, PlotRange -&gt; {-1, 1}] Dot::rect: Nonrectangular tensor encountered. &gt;&gt; Dot::rect: Nonrectangular tensor encountered. &gt;&gt; Dot::rect: Nonrectangular tensor encountered. &gt;&gt; General::stop: Further output of Dot::rect will be suppressed during this calculation. I can't tell heads from tails in the mathmetica help page. 
&gt; RevolutionPlot3D[u8[r, 0], {r, 0, 1}, PlotRange -&gt; {-1, 1}] What is u8? post all of the code or it will be difficult to help you.
Subscript[U, 0][r_] = Piecewise[{{(1 - 16 r^2)^2, r &lt;= 1/4}}, {0, r &gt; 1/4}] j[m_, n_] = BesselJZero[m, n]; k[n_] = j[0, n]; Subscript[J, 0] = BesselJ[0, k[n] r]; A[n_] = (IP[ Subscript[J, 0], Subscript[U, 0]])/(IP[Subscript[J, 0], Subscript[J, 0]]); uSoln[M_, r_, t_] := Sum[A[n] Cos[k[n] t] Subscript[J, 0], {n, 1, M}] u8[r_, t_] = uSoln[8, r, t]; RevolutionPlot3D[u8[r, 0], {r, 0, 1}, PlotRange -&gt; {-1, -1}] Our solution should look like this graph @ t=0 http://imgur.com/PRvJDwV
&gt; Subscript[U, 0][r] = Piecewise[{{(1 - 16 r2)2, r &lt;= 1/4}}, {0, r &gt; 1/4}] j[m, n] = BesselJZero[m, n]; k[n] = j[0, n]; Subscript[J, 0] = BesselJ[0, k[n] r]; A[n] = (IP[ Subscript[J, 0], Subscript[U, 0]])/(IP[Subscript[J, 0], Subscript[J, 0]]); uSoln[M, r, t] := Sum[A[n] Cos[k[n] t] Subscript[J, 0], {n, 1, M}] u8[r, t] = uSoln[8, r, t]; RevolutionPlot3D[u8[r, 0], {r, 0, 1}, PlotRange -&gt; {-1, -1}] &gt; Our solution should look like this graph @ t=0 http://imgur.com/PRvJDwV 
what is IP? I'm guessing you mean inner product?
Yes
It's not totally clear what you want when you say "each element is at least 2 apart". Is the partition `5=3+1+1` allowed or not? That is, do you only consider distinct parts (e.g. the pair (3,1)) or do you also consider equivalent parts (e.g. the pair (1,1))? Anyway, you'll want to use the function `Differences`, and in the case where you only care about distinct parts, you'll also want to use the function `Union`.
Are you using Mathematica on a RPi or on a PC to communicate to the arduino? I've communicated to an arduino through both but communicating through the computers' respective serial ports is pretty different. On the RPi, the arduino shows up at '/dev/ttyACM[N]' whereas on a PC it shows up as a 'COM[N]' port. For the RPi, from what I understand, you should first disable the ability to log into the RPi from its GPIO serial port. Disabling this will let you use the RPi to talk to the arduino. I suspect this lets the RPi act as a Master rather than a Slave? I don't claim to fully understand... There are instructions online that I can forward once I'm at my computer. After that, using the DeviceOpen[] DeviceReadBuffer[] etc. in MMA acording to the examples on the wolfram site should work. From MMA on a PC (MS-Win), I use '.NET' to open the COM ports. This is a little tricky the first time especially if you are, like I was/am, not super familiar with .NET.Once I'm at my computer (and not on my phone) I can post my MMA code which links to the appropriate .NET stuff if you are interested.
I was trying both, RPI because that is where the platform of my project is and PC just because it doesn't freeze up as much/is much faster than the RPI. As you said, it shows up exactly as /dev/ttyACMx and COMx. However on the PC when i try the serial device open command, mathematica just spits back what i typed whereas on the RPI it shows "DeviceObject" and the little box with class, status, ID. I will look into trying to disable the GPIO Serial port login. In the meantime, if you could please provide me with the links you said I would be very appreciative of your help (even more than i am now for bringing light to this information). 
It's standard in partition theory for "partitions whose parts are at least 2 apart" to **not** count 3+1+1. Plus, if repeated parts were ok, then in his example of 4, he would have counted 2+2.
[Instructions to change serial login on RPi] (http://www.hobbytronics.co.uk/raspberry-pi-serial-port) [Arnoud Buzing's post about MMA on RPi with arduino](http://community.wolfram.com/groups/-/m/t/199023?p_p_auth=171p0NxP) [Another, RPi/MMA related one for examples](http://community.wolfram.com/groups/-/m/t/157461)
My understanding is that the 'DeviceObject' with its associated functions is specific for the RPi. Unless it is under a different/experimental Context in MMA for Mac/PC, the 'Device' functions don't work on Mac/PC.
Make a *small* example of the same type of problem, and post your code in *text* format so we can actually help you. You will likely learn things that will help you with the larger problem.
 n = 15; minDist = 2; Select[ IntegerPartitions[n], Min@Abs@Differences@# &gt;= minDist &amp; ] I learned a new function today (Differences). Thanks!
This is cool, but you should really execute Cell - Delete All Output before saving, to keep filesize reasonable. Your archive is over 100 MB, when it could be less than 1% of that. Also, here's my favorite kick drum equation: kick[t_] := Sin[300 Sqrt[t]] Play[kick[t], {t, 0, 0.32}, SampleRate -&gt; 44100]
I send you a PM.
I'll undercut any offer, with a rate of $0 per hour. My only stipulation is that the help occurs publicly in this thread.
hello, that is most kind. the dialogue is inclusive of a drawing. to see it an email address is needed. once you are familiar with the materials, we can decide, what form of help is appropriate, before, if i may, decide if my work is to be publicly woven. 
Email is not required to share images. Put your image on [Imgur](http://imgur.com/) in a private album, then send me the link in a PM, if it's such a big secret.
its not a secret, its private. and i will decline your help. thank you for your interest. sincerely
doesn't sound like Mathematica will allow me to explore these types of large #s. Simple things like comparing one to another to see which is larger. I don't care to see all of the digits. I have a feeling that there isn't a single commercial package that will do this.
interesting. glad to see that it can at least represent these types of #s. Not sure I have the expertise to come up with the algebra behind them though (looking to be the student).
I can see that - what I have difficulty understanding (at this point) is determining which of these two #s are larger ==&gt; 3↑↑3 and 4↑↑2 [hopefully the formatting keeps if not ... 3 ^ ^ 3 and 4 ^ ^ 2 with carrot symbols replacing up arrows]
I realise this is the Mathematica Subreddit, but if you'd be willing to try something else i'd suggest giving Python a [try](http://stackoverflow.com/questions/4624970/finding-local-maxima-minima-with-numpy-in-a-1d-numpy-array) (check the answer with 25 upvotes). I ran into this problem frequently when i still did my data analysis on Mathematica. Switched to python and it made the whole process so much easier and quicker. You could also use a differences iteration, when the difference changes sign that's a min or max depending on which switch is made pos-neg, neg-pos.
What exactly are you asking help for? If you're looking for someone to write the scripts for you, then you need to bear in mind u/tootiefruitie 's comment. Be aware that the notebooks can be traced to see who/when they were opened and edited by. If you're just after help, check out the website stackoverflow and the mathematica tutorials. Or are you looking to find someone to be your tutor per se, and teach you?
I was so confused
Pretty cool. Thanks for sharing.
 f[x_]:=Block[{bigMatrix,recursiveHelper}, bigMatrix={{x}}; recursiveHelper[x0_Integer,y0_Integer]:=Block[ _your_code_freely_referencing_local_bigMatrix_here_ ]; recursiveHelper[1,1]; bigmatrix ] Notes: I have written recursive functions in Mathematica in precisely the form above - the advantage is that this a natural way to code setup and teardown for my recursive function bigMatrix &amp; recursiveHelper are local to the main Block Your symbols should start with lowercase, and beInCamelCase as is the typical convention recursiveHelper is happily locally defined inside the main Block, with access to the local "bigMatrix" as expected The "Return" value is simply the last expression, but you can use "Return[bigmatrix]" as the last expression if you wish, knowing it is redundant The difference between Module and Block is that Block let you have local assignments to symbols, and Module actually creates new symbols that can have life outside the scope of the Module (obviously, assignments to these new symbols will not clash with any global assignments). The uses for Module are rarer and relatively advanced. Get in the habit for reaching for "Block" first, and switching over to "Module" only if you find you need new symbols that have life outside the scope of your Module.
First a couple of things: You can’t omit the semicolon after RecursiveHelper[1, 1] or you would be multiplying it by the thing in the next line. You can only leave it out if they are independent lines within the cell, but in this case, since both are inside Module, it is considered a single expression, and any whitespace will be interpreted as a product. In this particular case it would work by chance, since it computes initially the first factor of the product (RecursiveHelper[1, 1]) and then the second (Return[bigmatrix]) leaving the function without even trying to carry out the product. Also you don’t need to use Return; a CompoundExpression (an expression composed of other expressions separated by semicolons) will evaluate to its last element. Just remember not to put a semicolon after the last element. If you want to pass a symbol to a function without evaluating it, you can check the attributes HoldFirst, HoldRest and HoldAll. However in this case it’s not necessary, you can make both bigmatrix and RecursiveHelper local to f and you won’t need to pass around bigmatrix in each iteration: f[x_] := Module[{bigMatrix = {{x}}, recursiveHelper}, recursiveHelper[y_Integer, z_Integer] := While[(**), (**); recursiveHelper[(**)]]; recursiveHelper[1,1]; bigMatrix] 
From the documentation on NDSolve: sol = NDSolve[{ D[u[t, x], t] == D[u[t, x], x, x], u[0, x] == 0, u[t, 0] == Sin[t], u[t, 5] == 0 }, u, {t, 0, 10}, {x, 0, 5}]; Plot3D[Evaluate[u[t, x] /. sol], {t, 0, 10}, {x, 0, 5}, PlotRange -&gt; All] The differential equation is first-order in time (t) and second-order in position (x), so it needs three boundary conditions: u[0,x] == 0 which specifies that at time t=0, all positions in x have a temperature of zero, and u[t, 0] == Sin[t] u[t, 5] == 0 which specify that at x=0, the temperature is varied sinusoidally, while at x=5, the temperature is fixed at zero. Note that if we changed the first boundary condition to something like u[0,x] == 2, it would be inconsistent with the sinusoidal boundary condition at the corner {t,x} = {0,0}.
The correct boundary condition depends on what physical problem you're trying to solve. If your boundary condition is a temperature at x=0, then you are setting u[t,0] equal to some function of t. If your boundary condition is a heat flux at x=0, then you are setting the derivative of temperature (with respect to position) equal to some function of t.
I'm trying to simulate something being heated by a pan. And thank you, now I just need to find a meaningful function of t for my example.
I'm not even close to being the best Mathematica user here, but implementing 'four formulas' sounded trivial enough. I'm not sure why OP is so secretive.
My guess, OP is probably working on a hot topic of research that would bring fame.
The possible values you have set for h are not functions, but expressions of x. You could rewrite the last control as {h, {Sin, #^2 &amp;, #^5 - 1 &amp;, Exp}} and the first expression to plot as h[x].
Thank you sooo much!I don't really get all this '#' and '&amp;' stuff tbh only got Mathematica for 3 days now. If you don't mind my asking is there a way to still have the same controlnames as before? -&gt; http://imgur.com/nyQvMyQ Again thx! 
 {{h, Sin}, {Sin -&gt; Sin[x], #^2 &amp; -&gt; x^2, #^5 - 1 &amp; -&gt; x^5 - 1, Exp -&gt; E^x}}
You can always just check "3∈{1, 2, 3}" and see what it evaluates to. It doesn't give true or false. What "3∈{1, 2, 3}" does is call the command "Element[3,{1,2,3}]" which to us looks obviously true, but such things are not obvious to Mathematica. The problem is the Element command only works with valid Mathematica "domains", not with simple sets. So "{1,2,3}" is not a domain to Mathematica, it is just a set. You can try "3∈Reals" for example, and you will get "True", because Mathematica recognizes "Reals" as a domain.
The top two graphs look pretty good... for comparison, though, could you replot the bottom-right graph with PlotRange -&gt; {0,26}?
The only difference I can see can be attributed to scaling; both axis scaling and display scaling.
&gt; There should be no second peak way up at the right side of the transformed data. I would post about this on the Mathematica Stack Exchange, but I'm reluctant because they're actually pretty hostile there. I'm not a mathematician but I have experience working with FT. In most implementations of FFT (that I know of), they keep the mirrored image byproduct of the spectrum, you typically just discard the second half. The peak you see on the right (anything after the half point) is the mirror image of the data on the left. You are typically interested in the first half only. Some more info perhaps: http://dsp.stackexchange.com/questions/4825/why-is-the-fft-mirrored
If you set the FourierParameters to {-1,1}, the result will be identical to what other programs and libraries do (matlab, numpy, fftw, cuda, ...). Any remaining differences are your misunderstanding, there's no way to say it nicer than that. Source: I have worked extensively with FFT implementations in a multitude of environments. 
&gt; the mirrored image byproduct of the spectrum It's not really a "byproduct" -- it's an artefact of FFT'ing real input data that this data is mirrored. Also, the right half is not only mirrored, it is also conjugated. (You won't see that when looking at the power spectrum though.) 
I think you also need to "window" your data before applying the FFT since you are artificially chopping the waveform at both ends. This avoids introducing frequencies where the data abruptly drops to zero. The waveform presumably continues in both directions, but you've only sampled a particular "slice". Beyond this slice the real waveform rises and falls, but your sample is artificially clamped to zero. "Window functions" are designed to handle this problem. [Window Function at Wikipedia](http://en.wikipedia.org/wiki/Window_function) [A window function in Mathematica](http://reference.wolfram.com/mathematica/ref/HannWindow.html) Good luck!
You are seeing the aliased copy of the signal. The "mirroring" is due to aliasing at frequencies above the Nyquist rate. [More on the Nyquist frequency here](http://en.wikipedia.org/wiki/Nyquist_frequency).
There are a few things going on here: 1. Procedural code is not particularly fast in Mathematica - functional code using lots of library functions is usually better 2. You have a lot of overlapping subproblems (redundant work) 3. You are carrying around huge (megabytes) amounts of data in symbolic form, instead of using more efficient floating-point representations I got partway through refactoring it, but ran out of time. I couldn't think of a nice extensible functional way to make the 5-dimensional tables, but I managed to turn p1 into something functional. For n=13, it runs in 33% the time of your code, but I'm sure it can be improved significantly (you should fix the other Graphics commands to match what I did with 'base' and 'first'). The Show command is always going to be slow once there are thousands of line segments, however. n = 3; AbsoluteTiming[ r = 0.5 (1 - Tan[\[Pi]/n Floor[(n - 1)/4]]/Tan[\[Pi]/n + \[Pi]/n Floor[(n - 1)/4]]); v = {Sin[2.0 #*Pi/n], Cos[2.0 #*Pi/n]} &amp; /@ Range[n]; base = Graphics@Line[Append[v, First@v]]; c1 = (1 + r) v; p1 = Transpose[ ConstantArray[c1, n + 1] - r (RotateLeft[v, #] &amp; /@ Range[n + 1])];(* this line is awkward, probably a better way *) v1 = Map[Drop[#, -2] &amp;, p1, {1}]; first = Graphics@{Black, PointSize[Small], Point@{0, 0}, Point@c1, Line@p1}; c2 = Table[c1[[i]] - r*(1 + r)*v[[1 + Mod[i + j - 1, n]]], {i, 1, n}, {j, 1, n - 1}]; p2 = Table[c2[[i]][[j]] + (-r)^2 v[[1 + Mod[i + j + k - 1, n]]], {i, 1, n}, {j, 1, n - 1}, {k, 1, n + 1}]; v2 = Map[Drop[#, -2] &amp;, p2, {2}]; second = Graphics[{Table[{Black, PointSize[Small], Point[c2[[i]][[j]]]}, {i, 1, n}, {j, 1, n - 1}], {Black, Line[Flatten[p2, 1]]}}]; c3 = Table[c2[[i]][[j]] + (-r)^2*(1 + r)*v[[1 + Mod[i + j + k - 1, n]]], {i, 1, n}, {j, 1, n - 1}, {k, 1, n - 1}]; p3 = Table[c3[[i]][[j]][[k]] + (-r)^3 v[[1 + Mod[i + j + k + l - 1, n]]], {i, 1, n}, {j, 1, n - 1}, {k, 1, n - 1}, {l, 1, n + 1}]; v3 = Map[Drop[#, -2] &amp;, p3, {3}]; third = Graphics[{Table[{Black, PointSize[Small], Point[c3[[i]][[j]][[k]]]}, {i, 1, n}, {j, 1, n - 1}, {k, 1, n - 1}], {Black, Line[Flatten[p3, 2]]}}]; c4 = Table[c3[[i]][[j]][[k]] + (-r)^3*(1 + r)*v[[1 + Mod[i + j + k + l - 1, n]]], {i, 1, n}, {j, 1, n - 1}, {k, 1, n - 1}, {l, 1, n - 1}]; p4 = Table[c4[[i]][[j]][[k]][[l]] + (-r)^4 v[[1 + Mod[i + j + k + l + m - 1, n]]], {i, 1, n}, {j, 1, n - 1}, {k, 1, n - 1}, {l, 1, n - 1}, {m, 1, n + 1}]; v4 = Map[Drop[#, -2] &amp;, p4, {4}]; fourth = Graphics[{Table[{Black, PointSize[Small], Point[c4[[i]][[j]][[k]][[l]]]}, {i, 1, n}, {j, 1, n - 1}, {k, 1, n - 1}, {l, 1, n - 1}], {Black, Line[Flatten[p4, 3]]}}]; ] (* Show[base,first,second,third,fourth] *)
I think the O(n^5 ) complexity is inescapable, since the last step creates O(n^5 ) unique line segments. Here is an update incorporating changes you discussed, and some others: n = 13; AbsoluteTiming[ r = 0.5 (1 - Tan[\[Pi]/n Floor[(n - 1)/4]]/Tan[\[Pi]/n + \[Pi]/n Floor[(n - 1)/4]]); v = {Sin[2.0 #*Pi/n], Cos[2.0 #*Pi/n]} &amp; /@ Range[5 n]; base = {Black, PointSize[Tiny], Thickness[Tiny], Line[Append[v, First@v]]}; c1 = (1 + r) v; p1 = Transpose[ConstantArray[c1, n + 1] - r (RotateLeft[v, #] &amp; /@ Range[n + 1])];(* this line is awkward, probably a better way *) first = {Point@{0, 0}, Point@c1, Line@p1}; c2 = Table[c1[[i]] - r*(1 + r)*v[[i + j]], {i, 1, n}, {j, 1, n - 1}]; p2 = Table[c2[[i, j]] + r^2 v[[i + j + k]], {i, 1, n}, {j, 1, n - 1}, {k, 1, n + 1}]; second = {Point@Flatten[c2, 1], Line@Flatten[p2, 1]}; c3 = Table[c2[[i, j]] + r^2*(1 + r)*v[[i + j + k]], {i, 1, n}, {j, 1, n - 1}, {k, 1, n - 1}]; p3 = Table[c3[[i, j, k]] - r^3 v[[i + j + k + l]], {i, 1, n}, {j, 1, n - 1}, {k, 1, n - 1}, {l, 1, n + 1}]; third = {Point@Flatten[c3, 2], Line@Flatten[p3, 2]}; c4 = Table[c3[[i, j, k]] - r^3*(1 + r)*v[[i + j + k + l]], {i, 1, n}, {j, 1, n - 1}, {k, 1, n - 1}, {l, 1, n - 1}]; p4 = Table[c4[[i, j, k, l]] + r^4 v[[i + j + k + l + m]], {i, 1, n}, {j, 1, n - 1}, {k, 1, n - 1}, {l, 1, n - 1}, {m, 1, n + 1}]; fourth = {Point@Flatten[c4, 3], Line@Flatten[p4, 3]}; ] Show@Graphics@Join[base, first, second, third, fourth]
That link is just the online version of the documentation that mathematica has built-in. It's in the help menu. 
 Count[#,True] / Length[#] &amp; [ MapThread[Equal, {{1,2,3}, {4,2,5}}] ] 1 - 3
Fantastic! I'll try that. Thank you so much!
Just tried it and get the same thing. When you run it without the assumptions, Mathematica just spits back the integral you asked for, which typically means that it can't solve it in that form. Sometimes, rearranging or doing some substitutions can help. What application is this for? Is there supposed to be a solution?
Things I would try (in this order): change of variables x = m² + p², try T = 1, T = 2 and so on, series expansion of the exponential. Good luck! 
http://i.imgur.com/5MFDZMP.png Looks promising, waiting for my Professor to email me back and see if it's right. 
The problem is that you're mixing up the "slot" variables with actual variables. When you do something like `f[x_]:=x+1`, the `x_` just denotes a named slot, not a variable. `x` on the right is just a placeholder for the value in the first slot of the function call. Consider that it doesn't matter what the name of x is, you could just as easily define it as `f[y_]:=y+1` and they are exactly the same. `f[x_]` just defines a pattern matching rule that says to substitute an expression of the form `f[arg1]` and replace it with `arg1 + 1`. When you're defining the `rx_` and `ry_` slots, you're not actually defining variables, just placeholders. To explain further, consider how function evaluation works. If we say `f[x_, y_]:=x + y` and we call `f[1, 2]`, here is what happens: 1. `f[1, 2]` matches the pattern defined in the global scope as `f[x_, y_]` with `x-&gt;1` and `y-&gt;2`. 2. `f[1, 2]` is replaced with `1 + 2`. 3. `1 + 2` can be simplifed to `3`. `1 + 2` is replaced by `3`. 4. 3 cannot be simplified using any other transformation rules, so it is returned. You can think of Mathematica as a giant lookup table of transformation rules. It keeps applying substitution patterns until none apply, then it returns that result. It's rather like Lisp in the way it evaluates. Two possible solutions: 1 Use substitution rules with `/.` g[l_, e_, {x0_, y0_}] := l*E^(-(e*Norm[{rx, ry} - {x0, y0}])^2) m[x_, y_]:= (g[.9, 1, {1, 1}] + ...) /. {rx-&gt;x, ry-&gt;y} `/.` is the substitution operator. You've explicitly put symbolic variables `rx` and `ry` in the return expression for `g`. So, adding `/.{rx-&gt;x,ry-&gt;y}` first evaluate `g[.9, 1, {1, 1}] + ...` (because that's in parenthesis, it goes first). Then the resulting expression will have the symbolic values `rx` and `ry` replaced with whatever values were given in the function call (which are aliased as `x` and `y`). 2 Use a closure. Make g a function that returns a function of `x` and `y`. g[l_, e_, {x0_, y0_}] := Function[{rx, ry}, l*E^(-(e*Norm[{rx, ry} - {x0, y0}])^2)] Then you can call something like this: m = g[.9, 1, {1, 1}]; m[1, 2] + (other stuff) -&gt; gives you same answer as before OR m[x_, y_]:= g[.9, 1, {1, 1}][x, y] + ... m[1, 2] -&gt; Gives you same answer The second option is just chaining function calls. It evaluates left to right so it's the same as t = g[.9, 1, {1, 1}] + ... t[x, y] Without the intermediate storage to `t`.
Thank you for your explanation. What you said regarding the 'variables' being symbolic makes good sense. I think for now I will explicitly define g as a function and experiment with variable substitution later. Thank you again.
Yeah, Mathematica basically treats any unknown symbol that it doesn't have a rule defining it as a symbolic variable. Using the closure approach is fine, but I'd say the substitution rule form is a bit more "idiomatic" for Mathematica. Both are common ways to do it, though. The main advantage to the substitution rule approach is that you can also have `rx` and `ry` in the "..." and it'll also substitute in that part as well. The closure / anonymous function approach does incur a very small amount of extra overhead for binding the anonymous function (anonymous function -&gt; function without named arguments, the `Function` call defines one), but it's totally insignificant in this case.
Not quite as cool as Tree(Graham's Number).
I don't understand why this is in /r/mathematicA.
Probably a typo, since A is next to S.
I'm so excited that Mathematica will finally have some sort of modern data structure!
Numerical PDEs look amazing!
Multiple Undo!
Machine Learning is largely statistics, and we have some pretty cool new stuff there: http://reference.wolfram.com/language/guide/MachineLearning.html
Finally! Jesus Christ. I can't believe commercial software can get away with that for so long. Undo?! Have you heard of it?
*Finally*
still not as cool as Tree(Graham's Number) + 1
For any number you pick, I'll go epsilon further!
It had multiple Undo -- you just had to turn it on manually.
This will be the best thing about *Mathematica 10* for me. I don't care what else they shoved under the bonnet, multiple undo is long overdue.
I think you underestimate the complexity of this feature in a system that has client/server (or frontend/kernel, if you will) separation. I would be surprised if it actually worked well for anything non-trivial. What if you do: x=4 Remove[x] What would the status of x be after even a single undo (so, undoing the Remove[])? How does this interact with dynamic evaluation? 
Wait for the associative arrays. 
Then I'll go the square root of epsilon!
Seems like I lied, sorry (
Wolfram employe answers about it: [I implemented a multiple undo mechanism in v10.](http://mathematica.stackexchange.com/a/52374/536)
Except that if you just unroll in the frontend, there will be visual inconsistencies between the frontend and kernel states. 
Unfortunately, it looks like they got a lead designer who bought into the windows 8 / metro school of fugly design. As if somebody vomited a bunch of post-it notes into my browser. 
Wolfram Desktop is a terminal to your Wolfram-in-the-cloud sessions, which you'll pay for via subscription (by purchasing a certain number of CPU credits). Mathematica runs on your machine and you either pay for it up front or pay for a year's license - then you can run it 24/7 with no further outlay.
`ParametricPlot` might be your answer
 s = NDSolve[{g0'[l] == dgdl[l][[1]], g1'[l] == dgdl[l][[2]], g2'[l] == dgdl[l][[3]], g3'[l] == dgdl[l][[4]], g0[0] == gini[[1]], g1[0] == gini[[2]], g2[0] == gini[[3]], g3[0] == gini[[4]]}, {g0[l], g1[l], g2[l], g3[l]}, {l, 0, 20}] alpha = 0.0002; t[l_] := (1/2)*Log[(1 - alpha)/(E^(2*l) - alpha)]; G0[l_] := Evaluate[g0[l] /. s]; ParametricPlot[{t[l], G0[l]}, {l, 0, 6}, PlotStyle -&gt; {Blue}] Nothing shows up with this, I tried :/. It might be an issue with my specific function which takes on very large values rapidly.. but this is why I'm doing the transform: I know what point the functions will diverge at so I can map that to infinity. 
Would Plot[G[F[x]], {x, 0, 10}] work?
Do you need it for something specific that you can't do in sage or matlab? Then it probably is worth it. But, if not, then my advice is to stick to matlab. I feel like they are solving different problems
You might want to consider using the Raspberry Pi edition which is free for non-commercial usage. The current version includes some of the v10 API, but some things (like Classify for example) don't work yet. And be aware that the hardware speed is [very limited](http://www.walkingrandomly.com/?p=5220).
Ah, that would be very useful, I already use raspberry with xbmc for my entertainment centre. I also use simulink with raspberry pi. 
Well Maxima is slow and sage only works as a virtual OS with linux. Matlab is actually my most comfortable platform for computations. I have to use a symbolic software for theoretical physics project I am currently a part of in my research centre. I'll have to do things like plotting fields, special functions with approximation methods, quantum computations and things like that. They do not involve numbers but are hectic symbolic mathematics. 
Advantages of Mathematica over Matlab * More stuff... Mathematica can do all the numerical calculations that Matlab can too and the speed is typically comparable or superior (*if* you do it correctly, see first disadvantage). Mathematica also has infinitely superior symbolic stuff, which Matlab has but few people use. * Better help. The Mathematica docs are hands down the best in the industry. * Better plotting. Mathematica's plots look a lot nicer for less effort, at least IMO. * Basics are easier... e.g. compare Matlab's `fminsearch` to Mathematica's `NMinimize` Disadvantages * Language weirdness. Mathematica is quite unique as a language, something like a crossbreed of APL and Lisp. It's quite a lovely and powerful language once you get the hang of it, but it can be tough for people coming from a more traditional programming language. The biggest drawback is that explicit loops are agonizingly slow, so most people tend to write naive code for Mathematica at first and then wonder why it runs so slowly relative to Matlab. OTOH, when you write stuff correctly it's blazing fast and the optimizing compiler can really make your code fly. IMO the language is actually an *advantage*, but I know a lot of people have trouble with it. * Usage. Matlab is more popular than Mathematica in a lot of fields, so you might have trouble if you work with a lot of people who use Matlab. Conversely, Mathematica is dominant in some areas. * Toolboxes. Mathematica doesn't have the diversity of external packages that Matlab does, though some of the more popular features are included by default, e.g. parallel computing. I'd say this is because it's kind of weird to write a proper package in Mathematica You may want to check with your university or institution. Wolfram offers pretty generous site license terms for Mathematica, so a lot of places offer it for free (the one where I work does). It's more expensive than Matlab for students ($150 versus $50). Overall I'd recommend it. I have used it extensively for years (~v5) and much prefer it over Matlab. In practice, I use a mixture of Python+NumPy+..., Mathematica and C++/C/Fortran for my work and I use all of them pretty extensively. I would buy Mathematica even at full price, which is at least $1000 for commercial use because I find it to be that valuable (I don't have to though because my institution provides it). If you haven't used it before, though, you should try it out first. There's a 30 day trial for free.
It really depends on your circumstances. Are you a student? How deep are your pockets? (or your employer's?) I have a Premier Service license (~ 600 EU/yr) and it's worth it for me. Matlab is a glorified calculator in comparison (and it has a horrific language). I second the idea of getting your feet wet on the Raspberry Pi version, to see if it works for you as a tool and language. 
&gt; Perhaps there are ports on the server side that need opened? Again, you'd think this is the kind of thing the software would be able to catch and provide a helpful hint by this point. As long as SSH is open I think you shouldn't need to set anything else. Can you try connecting via regular ssh and running `math` and see if it launches up? It could be path issues or something like that. I haven't tried remote execution with 10 yet, but it worked without issue on 9.0 for me. I'll go try it now and edit this post. EDIT: Yeah, it isn't working for me either. There's no possibility of firewall issues as neither of the machines are firewalled. According to the error messages, the SSH command is failing but I'm not really sure why. I'll play with it some more. It definitely worked fine with 9 without any fuss.
Try: Numberform[%,ExponentFunction-&gt;Null]
Yeah, I can run math on the kernel machine no problem. In fact, when it tries to connect, you can see the Kernel start up on the remote machine, so ssh is working fine as well. I am actually running 9.0.1. I did reach tech support and they gave me a notebook which outlines how to establish a manual connection. The way this fails, though, is highly confusing because I know my desktop's firewall is off, yet when my kernel machine is trying to connect to my desktop is when everything hangs. It is the remote kernel trying to connect back to the open ports on my desktop which fails. Weird. Am I alone in thinking that this should all be much more bulletproof at this point?
I too use Python and C++. But I think for computational electrodynamics, Matlab is the best. I now have a completely unfamiliar subject at hand and everyone uses Mathematica. I do not get an institutional license though, no one in my university other than people of the research centre use it. And these are all postdocs who have enough money to buy it. However, I have to decisive. I cannot afford to buy something that will not help me in my research in the coming months. 
Thanks, I've downloaded the 30 day trial. About the documentation, are the materials on Wolfram website enough or are there more I should look up for documentation in Mathematica? 
The docs on the web site are the same as the built in docs, which is what I was referring to. The difference is that when you view them in Mathematica, they become interactive and you can play with and change the examples. If you are interested in programming with Mathematica, make sure to check out the language tutorial that's linked from the front page of the help.
Ah, alright. I will do that. 
You can use Mathematica on Raspberry Pi - with very low computing power. Basically any new notebook will do the trick (from CPU/RAM viewpoint). You can't expect quick response for CPU extensive computations though.
[Power Programming with Mathematica](https://www.dropbox.com/s/j2dsyvptnxjd369/Wagner%20All%20Parts-RC.pdf) is a good book. Despite being published in 1996, it's still very relevant. Also check out [Stack Exchange](http://mathematica.stackexchange.com/), where questions are answered in a public forum. Leonid Shifrin, a Stack Exchange user, wrote a book on Mathematica as well. And of course, read the documentation.
If you're looking for very basic instruction, you can check out these videos: https://www.youtube.com/playlist?list=PLNr8B4XHL5kGiUCv2m36zUtE2qf00ojp3 They're a couple versions out of date, but it should get you started with the basics.
Familiarise yourself with the [Erlang](http://en.wikipedia.org/wiki/Erlang_%28unit%29) calculations. There are [some tools](http://www.erlang.com/calculator/) available to assist with the calculations. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Erlang (unit)**](https://en.wikipedia.org/wiki/Erlang%20(unit\)): [](#sfw) --- &gt; &gt;The __erlang__ (symbol __E__ ) is a [dimensionless unit](https://en.wikipedia.org/wiki/Dimensionless_unit) that is used in [telephony](https://en.wikipedia.org/wiki/Telephony) as a measure of [offered load](https://en.wikipedia.org/wiki/Offered_load) or carried load on service-providing elements such as telephone circuits or telephone switching equipment. For example, a single [cord circuit](https://en.wikipedia.org/wiki/Cord_circuit) has the capacity to be used for 60 minutes in one hour. If one hundred six-minute calls are received on a group of such circuits, then the total traffic in that hour is six hundred minutes or 10 erlangs. &gt;In 1946, the [CCITT](https://en.wikipedia.org/wiki/CCITT) named the international unit of telephone traffic the erlang in honor of [Agner Krarup Erlang](https://en.wikipedia.org/wiki/Agner_Krarup_Erlang). &gt; --- ^Interesting: [^Offered ^load](https://en.wikipedia.org/wiki/Offered_load) ^| [^Erlang ^distribution](https://en.wikipedia.org/wiki/Erlang_distribution) ^| [^Agner ^Krarup ^Erlang](https://en.wikipedia.org/wiki/Agner_Krarup_Erlang) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cj93l1k) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cj93l1k)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I've got a mid 2011 MacBook Air, 13-inch, 4GB 1333 MHz DDR3 memory, Intel HD Graphics 3000 384 MB, 256 GB SSD, pretty shitty specs all around and mathematica runs just fine. Have done tons of complex calculations. It might take some time (minutes) but most things we're talking fractions of seconds in processing speed (supposing you're not using procedural programming).
If this is a question about Mathematica, we may be able to help. If it's a question about a physical system requiring a high degree of specialized knowledge, it's less likely.
I am, but there's no guarantee I will know anything useful for your problem.
ok, as for the mathematica ouputs, i have angle/chord/radius results. one iteration of the script, generates said values. in a precise output, say for construction of 10, 7.5, 5, 2.5 degrees, my method approximates from a singular iteration to within 10-500 digits. a exercised a bottom to top, top to bottom set of operations and have a distinct pattern of approximates. i am of the mind that by having an equidistant ±degrees from the designated (7.5˚), a resolution is had for the other fractions; 1/6, 1/12, 1/24, where 7.5 is the 1/8. so, i can't seem to get mathematica to simply add a precise and constructed degree in excess of its value, and also subtract same value from it, so as to perform a final iteration. 7.5+ an infinite stream, - 7.5 = 0 according to output, same applies if try and subtract same excess value from 7.5, 7.5- .0000038573628..=0. i have a word doc showing 1.5 degree reductions from 45˚ and outputs. one can construct from 30, 45, to 3, 4.5, and anywhere in between, or beyond, with this script. first entry [3 digits] represents 1/12, second entry [45] represents 1/8. 1.5˚ reductions to 45, has a 1 degree reduction from 30, and so on, and at 7.5 as the 1/8, 5 is the 1/12. an approximate is such, only because of a predesignated value, but it is nevertheless a precise, not approximate value unto itself, correct? here is the script: digits = 1000; angle = SetPrecision[3, digits]; chord = SetPrecision[2., digits]; radius = chord/2/Sin[angle/2 Degree]; chord = radius*Sqrt[2]*Sqrt[1 - Cos[2*angle/4*3 Degree]]; For[i = 1, i &lt;= 100, i++, angle = SetPrecision[45, digits]; radius = chord/2/Sin[angle/2 Degree]; chord = SetPrecision[2., digits]; angle = ArcSin[chord/2/radius]*2/Degree; chord = radius*Sqrt[2]*Sqrt[1 - Cos[2*angle/4*3 Degree]];]; Print[angle]; Print[2*angle/4*3]; Print[chord] Print[radius] i hope i've been clear? thank you. 
hello, should have also said, i like what happens when i overshoot bottom to top, top to bottom of designated 1/8; top to +7.5, bottom to -7.5. e.g. 7.6, 7.4; this works, but equidistant 'real degrees' from and to, as inputs, i'm having no success, for outputs.
Question 1: What is the problem you're trying to solve? Question 2: Did you intend your script to generate complex numbers (with an imaginary part)?
1. i seem to think i've solved constructing the 'precise' angle/chord/radius for 5 degrees. 2. the script is an extension of a series of geometrically constructive steps. if i can input the equidistant ± degrees from 7.5, i'll have the equidistant ± from 5. complex, irrational, infinite numbers come with the territory. some distances are expressed from quadratic, some cubic, every two for the latter; 1,2, 4,5, 7,8,10, 11, etc.
here is the equation that describes the construction: Angles ≤360/3∞ = radius = (x”) (cos X/12/2)/(sin X/12)) = X/12 • 2/4•3 = X/8/3. there are a different set of formulas that process the above; all describe the geometric steps of construction.
The angle/chord/radius of *what*? Explain your problem as if I've never seen it (I haven't).
 angle first bold entry, angle second bold entry, and chord to second entry. second entries represent X/8. notice the first entry numbers for output; 4.9, 5.0... equidistant offsets for the 7.5 number, reflect equidistantly for the 5 number. i think the best way is to show two iterations to distinguish what i'm wanting to do. you see the two outputs one +7.5 the other -7.5. i want to use the ± degrees of one output and subtract or add for two equidistant offsets. 7.5+, 7.5- by equidistant degrees. subtract excess from 7.5, from 7.5, to have equidistant ±degrees from 7.5. digits = 1000; **bold**angle = SetPrecision[3, digits]; degrees chord = SetPrecision[2., digits]; radius = chord/2/Sin[angle/2 Degree]; chord = radius*Sqrt[2]*Sqrt[1 - Cos[2*angle/4*3 Degree]]; For[i = 1, i &lt;= 100, i++, **bold**angle = SetPrecision[7.5, digits]; degrees radius = chord/2/Sin[angle/2 Degree]; chord = SetPrecision[2., digits]; angle = ArcSin[chord/2/radius]*2/Degree; chord = radius*Sqrt[2]*Sqrt[1 - Cos[2*angle/4*3 Degree]];]; Print[angle]; Print[2*angle/4*3]; Print[chord]; 4.99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999984447651395606378416997049787638715855903218055861179088853811923110496490361292879020181165866859231210693394415231752052751350618950824908033055132136339114071771205072176922343602852019181155263742697038022599696252827912468740454075186757469188274368902439773634281080602107148154066114153227882883348430750994246699450505844736563960617426258124255789783421934950349158972433637617211268775740652104982850818738604490580129481021773530478894118557535779146320356014334727852614985789877422116175794461830286793227326367387455461655294309258008478455162245556428122843771183393395364417938567222943659175202578735525710738190507048821465579611795302294275 7.49999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999976671477093409567625495574681458073783854827083791768633280717884665744735541939318530271748800288846816040091622847628079127025928426237362049582698204508671107656807608265383515404278028771732895614045557033899544379241868703110681112780136203782411553353659660451421620903160722231099171229841824325022646126491370049175758767104845940926139387186383684675132902425523738458650456425816903163610978157474276228107906735870194221532660295718341177836303668719480534021502091778922478684816133174263691692745430189840989551081183192482941463887012717682743368334642184265656775090093046626907850834415488762803868103288566107285760573232198369417692953441413 digits = 1000; angle = SetPrecision[30, digits]; chord = SetPrecision[2., digits]; radius = chord/2/Sin[angle/2 Degree]; chord = radius*Sqrt[2]*Sqrt[1 - Cos[2*angle/4*3 Degree]]; For[i = 1, i &lt;= 100, i++, angle = SetPrecision[7.5, digits]; radius = chord/2/Sin[angle/2 Degree]; chord = SetPrecision[2., digits]; angle = ArcSin[chord/2/radius]*2/Degree; chord = radius*Sqrt[2]*Sqrt[1 - Cos[2*angle/4*3 Degree]];]; Print[angle]; Print[2*angle/4*3]; Print[chord]; 5.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000869193499775621026133873332355191551836193323783517780783021809066496403431418446111595620782426826370481748645757989603213584925060300324333862376471008069481325652014870638155847197370612184156815106906864017454411361241301270460721838325057318268562309774728154992134097838612398028735462980921432747052147422493911528530364692571603531868900390060632933006147492118682054004035407280570639853365513775836724468402237575257845569940440338534823348805931936825644432547945918370985811860699229105820396357805533256066200734880623951634830199227450983472296138530309150376905150144779281856660693480404041189201946780352369216161488847261059278012475208970376 7.50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001303790249663431539200809998532787327754289985675276671174532713599744605147127669167393431173640239555722622968636984404820377387590450486500793564706512104221988478022305957233770796055918276235222660360296026181617041861951905691082757487585977402843464662092232488201146757918597043103194471382149120578221133740867292795547038857405297803350585090949399509221238178023081006053110920855959780048270663755086702603356362886768354910660507802235023208897905238466648821918877556478717791048843658730594536708299884099301102320935927452245298841176475208444207795463725565357725217168922784991040220606061783802920170528553824242233270891588917018712813455563 
i noticed reddit truncated the numerals, not showing the irrational stream that follows after 300 9's or 0's.
how is best to send you a drawing?
or, you could run the script yourself for this, then i want from the output to subtract the difference from 7.5, and add it to 7.5. i can't seem to get mathematica to do that. digits = 1000; angle = SetPrecision[**3, digits]**; chord = SetPrecision[2., digits]; radius = chord/2/Sin[angle/2 Degree]; chord = radius*Sqrt[2]*Sqrt[1 - Cos[2*angle/4*3 Degree]]; For[i = 1, i &lt;= 100, i++, angle = SetPrecision[**7.5, digits**]; radius = chord/2/Sin[angle/2 Degree]; chord = SetPrecision[2., digits]; angle = ArcSin[chord/2/radius]*2/Degree; chord = radius*Sqrt[2]*Sqrt[1 - Cos[2*angle/4*3 Degree]];]; Print[angle]; Print[2*angle/4*3]; Print[chord];
thank you. i'm sorry. how best to transmit the drawing? to further add to the confusion, i'll reiterate. if i operate the script from 3 degrees to 7.6 degrees (top to bottom), and another operation from 30 degrees to 7.4 degrees (bottom to top), i'll have two radii, and two outputs, one for 7.399999, 4.999, and 7.599999, 5.000...and we will know that 7.5 will be precisely constructed from a simple bisection of the difference. this is what i want to do, from the output results of the script. please advise how best to transmit the drawing and accompanying notes. thank you.
Upload images [here](https://imgur.com/), then link back to them.
Thanks - will amend it 
so, a chord/angle of 45˚, or 4.5˚ construct an approximate chord/angle of the X/8 (target) at hand (arbitrary), to an accuracy 10-300, 500, from a singular constructive step. a singular constructive step, generates a radius/chord/angle, of precise distance/radius, ±angle X/8. constructing equidistant offsets, from precise approximates to target angle, makes possible the isolation/construction of the targeted angles/chords/radius. 
you could say, we have 1.5 equilateral triangles at all times/radii of 2 equilateral triangles; A+B. in reference to any angle b,v,c for any angle X less than 360˚. all angles X/8∞ are constructed by/comprised of 1.5 equilateral triangles, of 2. hope this makes sense now??
Not even slightly. I suspect there is a language barrier, because none of your descriptions come across as precise or unambiguous.
i've been doing all the talking. why don't you ask a question so i might know where you are not getting what i'm saying. i've shown the construction, the equations if you want them, and the mathematical script. all i want to do is to run the script interchanging some of the outputs. l namely i want to run an output 30 to 7.4, and 3 to 7.6, and have an equidistant output for 7.5, and 5 degrees. but in place of the 7.4 and 7.6 i want to use the real numbers i get from the singular approximation from a top to bottom, or ceiling to floor operation. i've produced the approximations and they are precise. if you want to see the mathematica outputs for one degree intervals, i can send those. i really thought you could decipher things by reading the mathematica script itself?? can you operate a mathematica script? it may be you don't know how to read a drawing?? maybe you didn't see the roll over notes? run the script, the outputs are not ambiguous, and are precise. geez, i don't get it. strike a circle, mark points a,b, strike line segments from a, b to v. you have the angle a,v,b. it equals 1/12 of X. that means 12 times the value of the angle = angle X. X/8 means 8 times the value equals angle X, for 6, and 24. they all equal angle X, and angle X is trisected, since two time X/6 = X/3. what's not to get? and where's the language barrier? you should understand a line length as a chord can be constructed as a 45 degree angle, or a 3 degree angle, or a 1.5 degree angle. any angle can have a chord length of any measure. when that happens, a new quad set is constructed on the new radius. run the script to see radius outputs, chord of X/8 outputs, angle of A; a,v,,b, and angle of D, b,v,c. its all there, and it is precise. you do have to think you know. i know how to draw, i gathered the equations that describe the step by step construction. i then had the equations transcribed into mathematica language. and the operations of the program generate approximations of high accuracy, and from that point i want to solve, and have the solution. i just can't mathematical to perform a simple adding or subtracting of differentials ± degrees, i already have calculated. if none of this makes any sense to you, then i'm out. thanks
 Angles ≤360/3∞ = radius = (x”) ((cos X/12/2)/(sin X/12)) = X/12 • 2/4•3 = X/8/3. unambiguous enough for you?
I tried your input, but I had to change constantpart to: constantpart = Pi/n^2 Total[Exp[-Abs[x - #]] &amp; /@ x, 2] Which I think does what you wanted. Minimize does indeed return In[13]:= result = Minimize[{estimator[{l}, {1}], l &gt; 1.1}, {l}] Out[13]= {-1.14307, {l -&gt; 10.4754}} However, I also observed this: In[14]:= estimator[{l}, {1}] /. result[[2]] Out[14]= -1.14307 While on the other hand: In[15]:= estimator[{l /. result[[2]]}, {1}] Out[15]= 0.153956 I therefore concluded that your use of L as the minimization variable may have been the source of your problem, since you use l in the equation for h[]. Replacing L with K gives: In[16]:= result = Minimize[{estimator[{k}, {1}], k &gt; 1.1}, {k}] Out[16]= {0.000016033, {k -&gt; 4.04309}}
You could maybe check out /r/suggestalaptop ? :)
I'm not a mathematician, but I don't see why you can't just use a variable to represent the function, and find the integrand in terms of that variable. e.g. To find Ssinxd(sinx), y = sinx, Sydy = (1/2)\*y^2 + c = (1/2)\*(sinx)^2 + c
It's because my function includes terms in both cos(x) and cos(2x), and I want to integrate wrt cos(x). 
You're trying to do [Lebesgue integration](http://en.wikipedia.org/wiki/Lebesgue_integration)? See [this post](http://mathematica.stackexchange.com/questions/42047/is-it-possible-to-calculate-a-lebesgue-integral-in-mathematica) for some help and caveats, but tl;dr is you can't do it in a generic way, but there's a cheaty way to do it using `NIntegrate` and AQMC integration. If that's not what you meant, then can you explain a little more what it is you're trying to do? 
Do you mean [inner product](http://en.wikipedia.org/wiki/Inner_product)? Because `inner`(`sin`(x), `cos`(x)) = 0 like you said in your question (for the right choice of inner product). That isn't really the same thing as integrating "with respect to another function" (which is basically Lebesgue integration, see my other comment). Unlike Lebesgue integration, inner products are quite doable in Mathematica. It's just normal integration, `integral`(f(x) g(x)) defines an inner product "weighted by" `f` (or `g`, it doesn't really matter). cosInner[f_, x_]:=Integrate[f[x] * Cos[x], {x, 0, 2Pi}] Now cosInner[Sin, x] -&gt; 0 cosInner[Sin[2#]&amp;, x] -&gt; 0 Is that what you're looking for? The second one above uses an anonymous function (`Sin[2#]&amp;`), which I can explain if you like. But keeping it nice and simple, you just multiply by the weighting function in your integral. 
Ah, I think this may be what I'm looking for, thanks! 
if you have a list like a={1,2,3,4} you can do `a*2` to multiply it by 2, and `a^2(ctl+6)`. If you have a matrix, b={{1,3,5,7,9},{2,4,8,10}} you can access the first list by b[[1]] and then multiply by 2 like `b[[1]]*2` ..etc
By the way put ^2 there it calls "square it"
i really forgot that, i thought it was sth. like the second power of..
I already did it, but thank you!
A bit more directly: Reduce[(Transpose[P].{{2, 0}, {0, 3}}.P == {{1,0},{0,1}}) /. (P -&gt;{{a, b}, {c, d}}), {a, b, c, d}, Modulus -&gt; 5]
Input: RSolve[{x[n] == x[n - 1] + x[n - 1] dt, x[0] == 1}, x[n], n] returns the following output: {{x[n] -&gt; (1 + dt)^n}}
Thanks everyone!
For some reason, I get a "recursion depth exceeded" error when I try to evaluate the RSolve expression. Am I making a silly mistake? Thanks!
I highly recommend first searching to see if other people have done something similar. Second head over here http://mathematica.stackexchange.com/ you can post your code for people to test and probably get more views than here. 
I think there is an easy way to convert the equalities from Reduce to rules, but if you used Solve[] instead of reduce you could get nice output with something like: Solve[(Transpose[P].{{2, 0}, {0, 3}}.P == {{1, 0}, {0, 1}}) /. (P -&gt; {{a, b}, {c, d}}), {a, b, c, d}, Modulus -&gt; 5]; MatrixForm[{{a, b}, {c, d}} /. #] &amp; /@ %
 (MatrixForm[Simplify[{{a, b}, {c, d}}, #]] &amp;) /@ % This gets you half-way there, but it's still or statements rather than a list.
The easiest way to do this is just put all your matrices in a list. Then use Fold and Dot. So something like this EQN[listofmatrics_, n_]:=Fold[Dot,IdentityMatrix[n],listofmatrices] where n is the dimension of your matrix. 
Yeah it would be. 
In addition to the other excellent answer: Yes you can. Check out http://reference.wolfram.com/language/tutorial/FunctionsWithVariableNumbersOfArguments.html for details
Pretty cool, do you have this saved as a .cdf?
Thanks a ton! I'm very glad that I didn't have to entirely rework the problem, so thank you very much for that.
If you're not constrained to use a Heaviside step function, you can get an even better fit using a sigmoid function like arctangent or the logistic function (shown here). If the collection of points is assigned to 'data': model = a + b/(1 + Exp[c x + d]); solution = FindFit[data, model, {a, b, c, d}, x]; model /. solution Show[ ListPlot@data, Plot[model /. solution, {x, -0.002, 0.005}] ]
If you leave a space between the strings you multiply them, which doesn't make much sense. You have to use the operator &lt;&gt; to concatenate strings: set = {"A", "B"}; Do[Print[set[[i]] &lt;&gt; " is not necessarily equal to " &lt;&gt; set[[j]]], {i, 2}, {j, 2}]
actually it turns out it's supposed to model the power of a gaussian beam passing through a hole, and the power is dependent on how much of the hole is being covered by a blade. All this to say I think the guess is supposed to have the form of a gaussian integrated over the area of a circle, but with part of the circle (illustrated as a secant line running through some point x) being blocked off. It's not an easy solution!
That sounds like an ugly integral for sure.
Would you like fries with that too? Show your code, we can help fix it. Nobody's gonna do your homework for you. You didn't even say please.
Could you use UnitStep instead of HeavisideTheta?
Apparently not. Inputting NonlinearModelFit[data, a*UnitStep[x - b] + c, {a, {b, 0.00123}, c}, x] gives me the error "The Jacobian is not a matrix of real numbers at {a,b,c} = {1.,0.00123,1.}." You might need a differentiable model for NonlinearModelFit to work. HeavisideTheta is differentiable everywhere in its domain (which does not include zero), but UnitStep is not differentiable at zero and is defined there. 
D[x*_*, y*_*, z*_*] evaluates to zero, since it is interpreted as the derivative of x_ with respect y_ and z_. If you want to use it as an unevaluated pattern you can write: D[f1, c1, NonConstants-&gt;{n1}] /. HoldPattern[D[x_, y_, z_]] :&gt; Inactive[D][x, y]
It's of course possible to do, you just have to be extremely careful about evaluation order. The problem is that the LHS of the rule is being evaluated greedily, before the rule is applied with ReplaceAll (/.). This is a common issue with Mma ... evaluation order is all over the place. You could have determined what was going on by using Trace to inspect the evaluation. Here's one way to do it: D[n1, c1, NonConstants -&gt; {n1}] /. Verbatim[D][x_, y_, rest___] :&gt; Inactive[D][x, y] here is one that is probably better for some reason: D[n1, c1, NonConstants -&gt; {n1}] /. HoldPattern[D[x_, y_, rest___]] :&gt; Inactive[D][x, y] I can't really tell you when you should use Verbatim vs. HoldPattern. This stuff is beyond my experience. Note the use of `rest___` (which didn't actually need the name rest; it could have just been `___`) in order to match any number of optional arguments—0, 1, or more than 1. Also notice that I used a RuleDelayed (:&gt;) instead of Rule (-&gt;) because the RHS of the rule depends on the LHS of the rule—this is important if for example there's already a value bound to x or y. While I'm espousing Mma wisdoms, here is another approach to what you were trying to do: use Dt. Here's how: Dt[f1, c1] /. Dt[v, ___] :&gt; 0 /. Dt -&gt; Inactive[D]
Thanks for pointing out the Dt function, but while it simplifies things here, later on (when I replace n1 with a potentially large function) I will need either to convert the Dt to D or type out a rather long list of constants.
volumetricPlot[latticeType_] : Module[ {img = LatticeData[latticeType, "Image"], r = LatticeData[latticeType, "PackingRadius"] }, Show[ img /. Sphere[pt_, r_] :&gt; {}, Map[ RegionPlot3D[(EuclideanDistance[{x, y, z}, #] &lt; r), {x, -1, 1}, {y, -1, 1}, {z, -1, 1}, Mesh -&gt; False, PlotStyle -&gt; Opacity[.5] ] &amp;, Cases[img, Sphere[pos_, _] :&gt; pos, Infinity]] ] ] volumetricPlot["SimpleCubic"]
This is supposed to draw a closely packed unit cell of a lattice. It works when you use volumetricPlot["FaceCentredCubic"] or volumetricPlot["BodyCenteredCubic"], but the radius for simple cubic isn't big enough for some reason.
The source data structure provides spheres two units apart and a packing radius of 1/2. The code isn't 'wrong', the balls listed just don't touch.
This is not a clean paste, in future experiment with 'Copy As', and quickly paste to a new book (or kernel) to avoid getting corrections to errors you haven't made, but have presented.
Or simply use PasteBin
Could you recopy this? The code doesn't work
Next time, try posting your code, instead of a screenshot. By looking at it, the first thing I would try is: NDSolve[eq, {u, v, w}, {x, 0, 1}] 
Pretty sure it's because you have R12==.1 R16==.1 at the top. The error message is indicating that the DE evaluated to a symbolic value at a test point, but to use NDSolve the system must evaluate to numeric values at all test points. `R12` and `R16` are supposed to be set to constant values right? Use a single `=` sign. `R12==.1` is the statement "R12 is equal to .1", whereas I am pretty sure you meant `R12=.1`, which is "Set R12 to .1". You probably also want to put a semicolon at the end of those lines in the beginning to suppress extraneous output.
Two issues I see immediately. First double equals is a conditional. If you were to use an If statement, you'd use == . Secondly ndsolv is a function(al) of the functions you need to solve over some range of variable. That's why you get the error about needing 3 arguments. Finally there is a 3rd issue I would consider, but haven't looked deeply into your problem. There is a difference between x in the interval (0,1) and the interval [0,1]. Often times there are issues considering one but not the other numerically. 
Not sure if it's the only problem, but: - The first argument in Solve[] needs to be a condition, i.e. ' == ', not an expression, i.e. ' = ' - l1ea1 should be written as l1*e*a1, same goes for l2ea2 and f1Sin[] should be written as f1*Sin[] - The last expression should not have a semicolon at the end. I fixed up the code, see if your Mathematica can evaluate it: Clear["Global`*"]; d1 = v1*Cos[Pi/6]; d2 = v1; d3 = v1*Cos[Pi/6]; f1 = d1/l1*e*a1; f2 = d2/l2*e*a2; f3 = d3/l1*e*a1; e = 200000.0; a1 = 2000.0; a2 = a1/3; l1 = 2000/Sin[Pi/3]; l2 = 2000; ssss = Solve[f2 + 2 f1*Sin[Pi/3] - 100000 == 0, v1]
Thank you so muchit works now. Just curious what does the line v1=v1/.ssss[[1]] do?
To explain that, some background: Solve always yields a list of solutions, because in many problems, multiple solutions can exist. Each solution is itself a list of *substitution rules*. So ssss is a list of lists containing substitution rules. A "substitution rule" could like like 'v1 -&gt; 10', for example, which would mean something like 'replace v1 by the value 10'. Finally, the syntax 'expression /. rules' means: apply the 'rules' to the 'expression'. Now we can see what v1 = v1 /. ssss[[1]] does: * ssss[[1]] selects the first solution in the list of solutions ssss. It is a list of substitution rules, containing one rule: { v1 -&gt; *solutionvalue* }. * v1 /. ssss[[1]] applies this to the expression v1, meaning: in the expression "v1", replace any occurrence of the symbol 'v1' by *solutionvalue*. The result is simply the *solutionvalue*. * Finally, the v1 = .... part assigns the solution value to v1. 
I use [VectorPlot](http://reference.wolfram.com/language/ref/VectorPlot.html). You can normalize the vectors and remove the arrowheads if you want just want the lineal elements. You'll need to solve for y' of course, but that's trivial: y' = (t^2 e^(-t) + y)/t. So you'd have VectorPlot[{1,(t^2 e^(-t) + y)/t},{t,tmin,tmax},{y,ymin,ymax}] or VectorPlot[Normalize[{1,(t^2 e^(-t) + y)/t}],{t,tmin,tmax},{y,ymin,ymax}] depending on preference.
Use subscripts for constants. I know they are a hassle to type every time, but Mathematica's typesetting becomes really powerful when using it to the fullest. Sum[Subscript[c, i] F[x], {i, 1, 5}]
&gt; But now I want to know if I can subscript those with a song as the subscript and a real honest emotion as a superscript AND have it all in bright pink and have it gently waving back and forth? The answer is very likely to be yes. But just because you can do something it doesn't mean you should. Having said that, I agree that Mathematica in general can be a mess and unpredictable at times. I myself have just started using subscripts (with some caution still) and I would be surprised if it didn't work in this situation. I guess we are just saying what everybody already knows: Mathematica is awesome while it works, until it doesn't. Thanks for the warning!
DSolve is returning replacement rules. Beyond that, it's using undefined constants. And even beyond that, it's returning pure functions, instead of just plain algebraic expressions. So we evaluate the variables in question (x, y) by executing the replacement rules of 'solut', use our own replacement rules for C[1] and C[2], and finally evaluate the pure functions by applying them as the head of an expression: (head)[t] solut = First@DSolve[{x'[t] == -4 x[t] + 2 y[t], y'[t] == 3 x[t] - 2 y[t]}, {x, y}, t]; assumptions = {C[1] -&gt; 0.7, C[2] -&gt; 0.3}; Plot[{ (x /. solut /. assumptions)[t], (y /. solut /. assumptions)[t] }, {t, 0, 1}] There is probably a more elegant way to accomplish this.
I'm using MMA to calculate the overlapping area of two polygons. When the vertices of the polygon are created with the Tuples function, it generates an error. Tracing the output with Trace yields identical results until an error is generated.
thanks, it was just some stupid homework problem completely unrelated to the class.
EDIT: I can reproduce your error -- hang on As a side note, your style is very non-idiomatic. You really should use f[x] rather than f@(x) in code that you want others to read. 
I agree that the behavior seen is incorrect. I think I found the root cause. At first I thought it might have soimething to do with the fact that you specify the literal numbers in p1av with explicit machine precision (trailing apastrophe) but that doesn't affect the issue. One thing that it is striking is that the internal representations of p1av and p1bv are quite different, even though they look the same and are evaluated as identical. Specifically, ByteCount[] shows that their internal representations are different, evaluating to 472 resp 224 on my 64-bit Linux system. As it turns out, the "Tuples" function generates a 'packed array' (see [here](http://www.wolfram.com/technology/guide/PackedArrays/)) whereas the p1av assignment does not. If you do Needs["Developer`"] And then insert a p1bv = FromPackedArray[p1bv] right after the present p1bv assignment, the error will disappear. Vice versa, if you insert p1av = ToPackedArray[p1av] right after the present p1av assignment, the error will also start to appear on polygon a. So the problem is in the erroneous Region* function's code handling of the PackedArray representation. The existence and usage of a PackedArray should be transparant to the user, and any violation thereof is a bug. If you report it, it will be useful to mention that the problem is related to PackedArray, this will help Wolfram to solve the issue.
Packed arrays - I should have known! Thanks for finding the solution. I'll append that information onto the ticket.
I don't think the q is necessary: p[n_, x_] := 1/(2^n n!) D[(x^2 - 1)^n, {x, n}]
Not strictly, no. But if you want to evaluate p[n, x] where x is anything but a simple variable name (p[n, 5] or p[n, Cos[t]], for instance), you do. Otherwise you have D[(5^2 -1)^n , {5, n}], which gives zero (or an error, can't remember off the top of my head :P). 
You'll want ToString[] and Export[]. Stop thinking in terms of For loops, that's not the Mathematica way. Map over lists instead. For loops are painful in Mma and there's rarely a good reason to use them. Unfortunately you can write FORTRAN in every programming language, but that doesn't mean you *should* write FORTRAN in any programming language.
Oh. Oh wow. That may actually be of assistance. Thank you! :-D Hopefully this will allow me to do my error propagation much quicker. Taking an hour for two simple calculations is very inefficient.
It will take a time investment to get used to the MM format, but it is well worth the initial pain. Feel free to ask any specific questions about how to format equations or defining functions, I'd be glad to help. 
&gt; f[x,y]:=Sqrt[x^2 +y^2 ] This code will not work when you call f[1,2] or f[2,3]. You need to use underscores on the lefthand side to stand for blank patterns: f[x_,y_]:=Sqrt[x^2 +y^2 ] 
The person above had an error in their code, to define a function you should use underscores like this: f[x_,y_]:=Sqrt[x^2 +y^2 ]
They are there in the source! Reddit's formatting looks like it stole them.
Is there a configuration folder that you can maybe rename (not delete) as an experiment?i I wouldn't recommend mucking with the registry. Also, you might consider creating a test user account, logging in there, and starting MMA. If that works then it may be your user settings.
The StackExchange user Oleksandr R. seems to have created a fancy package for handling error propagation (and covariance in general). It's probably more than you're looking for, but in case you want to explore the rabbit hole, [check it out here](http://mathematica.stackexchange.com/questions/16793/create-an-adaptive-amount-of-local-variables-for-error-propagation#16803).
Nothing, sadly. Crashes just as much. I've already contacted their Support but haven't gotten anything back yet. Still, thanks for the link.
I tried to buy this book. But it seems to be available only in the US store, not in the EU. I can't even see the price of it, nor can I get a preview.
Hmm that's nasty. Please update here if you find a solution, I'm interested to hear about it. 
I recommend not using %, as it creates tangled code which breaks easily (as you've discovered). Instead, assign the output to a variable using the = operator, storing that value for later use: x = 2; y = 3; z = x + y The first two lines 'store' values in the variable names x and y. The semicolons suppress output from those lines (so nothing is printed to the screen). The last line has no semicolon, so it displays its result (in addition to storing it in the symbol 'z').
That worked! Yay, thank you so much. At first it wouldn't but that was simply because I forgot to reevaluate the notebook. I don't really understand this syntax though and I'd like to. What does x[t]/.s mean? What is the difference between that and x[t]./s[[1]]?
The /.s blah blah replacement rules are confusing.
This is the way to go. I also recommend against using In[2] or Out[2] in your code, as it is difficult to restructure your code later on. When writing code just remember which things you need for later and save them in variables like /u/lithiumdeuteride shows. 
Thank you so much for posting this, I'd been stuck on this for a while now and couldn't figure out why Mathematica didn't like my multiple derivatives of Cos[t]. Cheers!
If you're really desperate, search through your strings until you get the string at the end of the title. Then find that position and parse the data into title and usable data. It's what I did when I had a nasty chart I had to seperation with star parameters.
Alternatively, you can use "-1" to refer to the end of the array: Import["File"][[13;;-1]]. This is a general feature, so data[[-1]] refers to the last element of data, data[[-2]] refers to the second-to-last element, et cetera.
Thanks, that link worked.
I don't think that's the correct syntax for a For loop in Mathematica.
You're using a number as an iterator here: Sum[(-1/(2 Pi) E[-b q] BesselJ[1, b]/BesselJ[0, b]), {1, i}] Mathematica doesn't know what you want to sum over, and expects the first part of {1,i} to be the name of the summation index. Something like {i,1} would be alright, as would {x,1,i}, but not as you have {1,i}. You've got a few other problems going for you as well. You want a semicolon after b = BesselJZero[0, i] N is a poor choice of variable name since it is already the name of a built-in function. You want to use underscores in F[u_, n_] := to define a function. Using E[-b q].../.q-&gt;u isn't going to do anything different from just E[-b u] as far as I can see in this program. Also, the plot isn't going to give you anything interesting since when it will be evaluated, d will be a constant and you'll get a straight horizontal line as your plot. I assume you want something else, but I'm not sure what. Clarify what you want to happen and I'll help you out. 
Basically I want to plot a complicated solution to a boundary value problem with the following specifications:: Using Mathematica, plot the induced charge density (in appropriate units) as a function of z/a, for z = 0 . . . 3a, keeping Nmax = 3 terms in the Bessel-Fourier expansion. Repeat the exercise for Nmax = 1, 2, 4. Comment on the convergence of the Bessel-Fourier series. I have the physics done, but I don't know how to use mathematica and it wasn't required for the class but the professor wants us to use it. Its bullshit.
To clarify, u=z/a? Also, what do you want to summation to be over? What does the i^th term of the summation look like? Is it supposed to be implicitly defined by b[i]? If not, write it out in regular math language and I'll help you implement it. 
I want to do (-1/(2 Pi a))(Sum-from m=1 to infinity- (e^-(km)z) (J1((km)r)/J1((km)a))) where - km=(xm)/a; xm - the mth root of the J Bessel function. -J1 - the 1st Bessel function -a- is the radius of the cylinder for which this boundary value problem corresponds to
If I've understood you correctly, this should be what you're looking for. If there's anything you don't understand, let me know. I put some extra options in the Plot function just to make the plots look a little nicer. F[a_, n_] := Module[{i, b, d}, For[i = 1, i &lt;= n, i++, b[i] = BesselJZero[0, i]; d[u_, i] := Sum[(-1/(2 Pi) Exp[-b[j] u] BesselJ[1, b[j] u]/ BesselJ[1, b[j] a]), {j, 1, i}]; Print[ Plot[d[u, i], {u, .01, 3}, PlotRange -&gt; All, PlotLabel -&gt; "Order " ~~ ToString[i] ~~ " Approximation", AxesLabel -&gt; {"r/a", "d"}]] ]; ] F[1, 3] 
Also, why is the domain from {u,.01,3}? Does the function not evaluate at u=0?
When defining a function, if you put an underscore after a variable's name, you're telling Mathematica that variable's name is just a dummy name that you're using only within the definition. If you don't type the underscore, then you're using the actual value of variable itself. For example, the code i=1; f[i_]:=i f[2] returns 2. On the other hand, the code i=1; f[i]=i f[2] returns f[2] because Mathematica only knows what f[1] evaluates to. This is because you told it f[1]=1 when you typed f[i]=i. 
Oops, sorry. An artifact from my debugging. It should be just {u,0,3}.
Ah, nice! 
Hello! Not at all, late is a relative thing. I have decided to give mathematica a try. I actually got the trial version for the third time now. I have to say, I am liking it. It is very helpful. Thank you for the reply, much appreciated! :)
I'm glad. You may find [this page](http://www.wolfram.com/mathematica/new-in-10/) useful because it contains a lot of cool examples of what you can do with Mathematica. I like [this one](http://www.wolfram.com/mathematica/new-in-10/geo-related-properties/visualize-depth-and-position-of-earthquakes.html) very much where you can plot earthquakes in 3D with very little code.
The variables x and y need to be separated with a space.
&gt;Also, it is a good habit when working with functions to to define them like &gt; f[x_,y_]:=Exp[x+y](x^2+x y) &gt;instead of just defining a new expression &gt; f=Exp[x+y](x^2+x y) &gt;like you did. Ah yeah, I was just treating everything like simple variable assignment before. I can see how this is better. Still getting used to what Mathematica is/how it works/what it can do. Anyway thanks, it's all working now.
I use functional programming a lot, but if each iteration takes substantial memory then Map is a memory hog (and fixing it requires kludging with Hold[], etc). Table is a little better, but when it comes to simple loops involving large data and File I/O I use For loops.
Yes, FullForm[f[x_, y_]] returns f[Pattern[x,Blank[]],Pattern[y,Blank[]]] but that is describing the command's structure, not the structure defined by the command. What is more relevant to talk about is f[x_,y_]:=Exp[x+y](x^2 + x y) FullForm[f] which returns f On the other hand, f=Function[{x,y}, Exp[x+y](x^2+x y)] FullForm[f] returns Function[List[x,y],Times[Exp[Plus[x,y]],Plus[Power[x,2],Times[x,y]]]] which is different, but no more indicative of being a function. And I don't know why you won't take the documentation's word for f[x\_,y\_]:= defining a function. 
A good paste (try right click, Copy As, Input Text) is a good start.
No, it's a series of problems that help you learn all the methods on Mathematica. I'm doing this on my spare time as I'm trying to get better at it.
Make the substitution u = x arctan(x) hence du/dx=[x/(x^2+1) + arctan(x)] This will change the integrand to (1+u^2 )^(1/2) You might want to play around with TrigReduce or replacement rules to get a nicer final answer
You almost never want Timing. You almost always want AbsoluteTiming. 
Thank you!! I am getting time results now - not the results that I want but I think that is more with my initial programming than anything, cheers!
The amount of time it takes to evaluate your examples is less than the granularity of Timing, i.e. your computer is too fast for Mathematica to really know how long it took to evaluate. On my computer, Timing[N[re1[86]]] takes 0.000574 seconds to evaluate. What you want to do to evaluate your methods is wrap Timing around more than one use of your functions. For example, on my computer, ClearSystemCache[] Timing[N[re1 /@ Range[1000]]][[1]] ClearSystemCache[] Timing[N[re2 /@ Range[1000]]][[1]] returns 2.469764 and 2.123208 seconds respectively. All I did was test your functions out on the first 1000 integers and check how long the whole thing took. 
% is useful, but I only use it when I have multiple expressions on successive lines of the same input cell. 
Evaluating this: f[x_] = x + 1; g[x_] := x + 1; h = # + 1 &amp;; Map[{Head[#], FullForm[#]} &amp;, {f, f[x], g, g[x], h, h[x]}] Gives this: {{Symbol,f}, {Plus,Plus[1,x]}, {Symbol,g}, {Plus,Plus[1,x]}, {Function,Function[Plus[Slot[1],1]]}, {Plus,Plus[1,x]}} Which shows that the pure function *h* is the only function among all the 'functions' listed which actually has the head *Function*. This would cause *h* to match patterns differently than the others. It matches the pattern _Function, whereas *f* and *g* match the pattern _Symbol and *f[x]*, *g[x]*, and *h[x*] match the pattern _Plus.
It is not inexplicable, they have different heads. Check my reply to your comment's parent.
That is all true. However, the fact that h has the head Function isn't because it's more of a function than f or g. It's because its outermost function is the "Function" function. I don't imagine you would say that the Plus function is itself not a function because its head is just "Plus" and not "Function". 
Have you tried the manipulate command?
I tried the manipulate command. manipulate plot 1 = ax +6y + z, however, I cant really see how changing "a" changes the plane. 
How do input planes into parametric plot? Also, is this for the online or offline mathematica on wolfram?
I assume you're using wolfram alpha? Since I don't have pro, could you make a screenshot of the result?
I don't know if it works with Wolfram Alpha, works with Mathematica though. If you want the full flexibility with manipulate, it should be something like this: Manipulate[ParametricPlot[1==ax+by+cz],{a,-5,5},{b,-5,5},{c,-5,5}]
Well, you have to do what I'd have to do: Just look up ParametricPlot in the Wolfram Documentation and see what the proper syntax is.
Thanks. That's also a much more elegant solution.
Please post valid code, like this: Subscript[\[Lambda], \[Alpha]]
Subscript[\\[Lambda], \\[Alpha]] and Subscript[\\[Lambda], \\[Beta]] are, as far as Mathematica is concerned, two separate and unrelated expressions. Differentiating with respect to the first expression means the second one is treated as a constant. If you want alpha and beta to take on numerical values, such that the summation will contain the subscript used in the differentiation, I recommend this: With[{\[Alpha] = 1, k = 5}, D[Exp[Subscript[\[Lambda], \[Alpha]] x]/Sum[Exp[Subscript[\[Lambda], \[Beta]] x], {\[Beta], 1, k}], Subscript[\[Lambda], \[Alpha]]] ]
Thanks, that's helpful but still not quite what I'm looking for. Basically I'm trying to see how close I can get Mathematica to be like working with pencil and paper in this case. Ideally parameters like `k` would remain symbolic and not take a concrete value like 5. Is there some way to specify that `\[Alpha]` is a non-negative integer and then have Mathematica recognize that must mean that the sum over `Subscript[\[Lambda], \[Beta]]` must include `Subscript[\[Lambda], \[Alpha]]`? 
Thanks, I'm gonna try it out!:)
In Mathematica "QuasiMonteCarlo" is actually a deterministic method, it uses a deterministic sequence of points to estimate the value of the integral. The standard monte carlo method is pseudorandom and can be given a seed: NIntegrate[x^2 Sin[x], {x, 0, 2}, Method -&gt; {"MonteCarlo", "RandomSeed" -&gt; 1223}]
I might suggest going about this problem a different way... the code you ultimately end up writing will be dependent on the names of the data passed in. If there is anything that will be fixed in nature (maybe SAMPLE) then just create the SAMPLE list manually. For the other data sets a kind of python-y way of doing it would be: For column n in AIN0 - AIN6 { data[n]["NAME"] = list[0][n] data[n]["DATA"] = list[All?][n] } Then just reference the data column by column: Print[data[0]["NAME"]] Plot[data[0]["DATA"]] Sorry for the syntax and examples... haven't used Mathematica for a while. There are certainly better ways to do this, too! :p
That's great! Thank you very much! Could I impose on you to explain to me what's happening to make it work? Or how it works at all? I'm still learning syntax. By the way, I accidentally deleted that ninth element in the first sublist when I was copying it from my Mathematica. Sorry about that, and thanks for catching it I'm editing to correct that.
 # is the slot in an anonymous function &amp; denotes the preceding expression is an anonymous function /@ maps a function onto a list
The version that "loveofphysics" wrote is what I would write too, but here is a more readable version for those familiar with other common programming languages. list = Transpose[list]; For[count = 1, count &lt;= Length[list], count++, row = list[[count]]; Evaluate[ToExpression[First[row]]] = Rest[row]; ] The first line does a matrix transpose on the data (you can test that on its own). Then we start a for loop that goes through the transposed list, row by row. First[row] takes the first element of a list (it is equivalent to row[[1]]), and Rest[row] takes all the elements after the first (it is equivalent to row[[2;;]]). This business about Evaluate[ToExpression[]] is being used to change a string (like "SAMPLE") into the symbol SAMPLE which can be assigned a value. 
QMC is always deterministic. The points it uses generally have better properties, especially when you get into high dimensions. 
That is so fantastic and teaches me so much. Thank you.
Thank you, I understand it better now. The help is much appreciated.
Well, I'm manipulating data from a file that another person has made. That information is generated by an analog-to-digital converter which is reading values into an Arduino-type microprocessor. I'm not certain that that person will consistently use the same heading names. Also, every time I read that data in, I use a new Mathematica notebook, so there shouldn't be any trouble with previously declared variables. I hope I'm not using Mathematica as a hammer when it's really a finer tool, but I'm just trying to take raw data and make it look a little more understandable with graphs and some simple arithmetic operations. I would appreciate your take on these ideas if you have more to add. Thanks for the response!
We had to do that for first-year physics — everything had to be neatly laid out in Mathematica, which was great in that it meant we didn't need to typeset an entirely new document and that the tutors could see all the inputs and thus where people went wrong, all in a nice digital format.
ty!
It might be easier to get it working with Manipulate: Manipulate[ f = m a; "f = m a \n " &lt;&gt; ToString[f] &lt;&gt; " = " &lt;&gt; ToString[m] &lt;&gt; "*" &lt;&gt; ToString[a] , {m, 1, 10}, {f, 0, 10}, {a, 0, 1} ]
There should be far more efficient ways to do what you have in mind (and I hope somebody has enough time to come up with it here), but here's a simple answer to the exact question you asked: DeleteCases[ Union /@ Table[ Table[temp = Mod[n^2, m]; If[PrimeQ[temp], temp, 0], {n, 1, m - 1}], {m, 1, 20}], 0, 2] Note the semicolon after the definition of temp. You can execute any code within the Table environment before you get to the actual job for the Table. So defining a temporary variable that stores the value you are interested in and that can be recycled could speed things up. However, I gave it a try and found that in this particular case, this doesn't help at all -- in fact, it gets slower. 
f1 being what the function is when it's an integer, f2 when it's not
Thanks, it works!
The DeleteCases isn't even necessary. OP could use Select instead of the If, and since 0 isn't prime it will automatically get removed. On my machine this more than doubles the performance.
There is a very similar approach based on IntegerQ instead of Integer as a head. Consider the two approaches: In[] := f1[n_Integer]:=g[n] In[] := f2[n_?IntegerQ]:=g[n] Now let's say that we wanted a symbol `x` to be considered an integer, for the purposes of evaluating the `f` function. In the first case, you could force evaluation with f1 as follows: In[] := f1[x] Out[] = f1[x] In[] := f1[Integer[x]] Out[] = g[Integer[x]] In the second case, you can do a little better: In[] := f2[x] Out[] = f2[x] In[] := IntegerQ[x] ^= True; In[] := f2[x] Out[] = g[x] Hopefully you can see how the second case is more flexible.
$MinPrecision should be what you're looking for, but I can't actually get it to work with your example. Very frustrating. Block[{$MinPrecision = 64, $MaxPrecision = 64, eye}, eye[n_] := SparseArray[{{i_, i_} -&gt; 1.}, {n, n}]; MatrixExp[eye[2^10], {1.}~Join~(0. &amp; /@ Range[2^10 - 1])] ] still gives your original error. 
Ah, I see now. Thanks for pointing that part of the documentation out. I found the problem. This works now: Block[{$MinPrecision = 64, $MaxPrecision = 64, eye}, eye[n_] := SparseArray[{{i_, i_} -&gt; N[1, $MachinePrecision]}, {n, n}]; MatrixExp[ eye[2^10], {N[1, $MachinePrecision]}~Join~(N[0, $MachinePrecision] &amp; /@ Range[2^10 - 1])] ] Unfortunately, it's not much less unwieldy than just using SetPrecision. 
It is definitely conditional bc this is for the g field inside and a sphere and outside which depends in the regions... I popped it into Mathematica and got this: http://pbrd.co/1tTSg4c 
&gt;I need to show the lines on the surface where t= Pi/8, 3Pi/8, etc. These equalities define planes, not lines in 3-dimensional space. I'm assuming you would like to draw the intersection of these planes with your surface?
In case you are looking for said intersection, try this Show[{ Plot3D[Cos[x - t], {x, -5, 5}, {t, 0, 5}, AxesLabel -&gt; {x, t, u}, PlotLabel -&gt; "1D Wave", LabelStyle -&gt; Directive[Blue, Bold]], ParametricPlot3D[{ {x, Pi/8, Cos[x - Pi/8]}, {x, 3 Pi/8, Cos[x - 3 Pi/8]}, {x, 5 Pi/8, Cos[x - 5 Pi/8]}, {x, 7 Pi/8, Cos[x - 7 Pi/8]}, {x, 9 Pi/8, Cos[x - 9 Pi/8]}, {x, 11 Pi/8, Cos[x - 11 Pi/8]} }, {x, -5, 5}, PlotStyle -&gt; Thick] }]
Brilliant, this is exactly what I had in mind. Thank you so much!
Generally, Mathematica wraps long output inside "&lt;&lt;" and "&gt;&gt;". If I'm not mistaken, the "1" inside means that there's only one expression, but it must be a long one, since it is not printing it. Edit: If you try "exp // Short", you will see the same kind of notation.
Thanks for the answer.
Question-- is there a way to export Mathematica outputs to LaTeX or Word format equations? Using Mathematica to create large matrices and would love to export my answers to an essay. 
To pick one row out of a matrix/table use matrixname[[i]]. To pick one column out of a matrix/table use matrixname[[All,i]]. Does that answer your question?
I think so. It makes sense, at least, I can't believe I hadn't thought of doing the double square brackets. I'm not sure yet whether it's working, though, as I need to see if my contour plot works
I don't really understand your code. y is a dataset or a function? If it's a function y[x\_, a\_, b\_, c\_, w\_] := a Erf[Sqrt[2]/w (x - b)] + c you'll want to use y[i], but if as you say in the original post, y is a dataset and you want the i^th column, you want to use y[[i]], not y[i]. 
okay, yes I'm being vague here. the y[i] dataset is completely different from the y[x[i],a,b,w,c] function. I should have named them differently. let's say that the y[x,a,b,c,w] can now be called function[x[i],a,b,c,w] and the sum uses (1/sigma[i]^2 )(y[i] - function[x[i],a,b,c,w])^2 where function[x,a,b,c,w] is the Erf one I defined in the last comment. My new question is this: how do I communicate that for the x-values in this defined function, I want to use the first column in the data set?
Thanks so much! This was very helpful.
That's the right sort of idea, but I was more just trying to get the answer in the format: Out[1] {{x -&gt; 0.00823362 ± Error}} The propagation isn't a problem the true answer is "x -&gt; 0.00823362 ±0.0001526787" I was just wondering if there was any function or way of doing this in Mathematica without writing out the whole propagation formula. Edit: Forgive my degree of accuracy with the error number I know its not a proper format for an error - I'm just copying from the excel cell.
The double brackets are shorthand for Part[]. `data[[1]]` is the same as `Part[data,1]`
Please reformat your question to show where you have underscores, e.g. by prefixing your code with four spaces. That way, your code will be shown as typed, including underscores. f[x_] := x^2 Reddit's formatting messes up your syntax otherwise, and it's very hard to comprehend what you are trying to do. 
Very impressive!
Thank you, this worked great!!
Thank you! Working on the assumptions part, but so far so good.
Paste code, not images of code. Nobody wants to re-type your function.
ClearAll[pXX] Unprotect[pXX] pXX[T_;/-25 &lt; T &lt; 200, v_] := Module[{w1, w2, w3, w4, R = 0.08206(*liter atm/Kelvin*)}, w1 = R T/v; w2 = (B R T - A - (Subscript[C, 0]/T^2)) (1/v^2); w3 = (b R T - a) (1/v^3) + (a\[Alpha]/v^6); w4 = (c/T^2) (1/v^3) (1 + (\[Gamma]/v^2)) exp[-\[Gamma]/v^2]; w1 + w2 + w3 + w4 /; 0 &lt; pXX &lt; 1000] Protect[pXX] With these parameters: paramCO2 = {A -&gt; 1.03115, B -&gt; 0.040, Subscript[C, 0] -&gt; 1.124*10^4, a -&gt; 3.665*10^-2, b -&gt; 2.6316*10^-3, c -&gt; 1.04*10^3, \[Alpha] -&gt; 1.35*10^-4, \[Gamma] -&gt; 0.006};
Your syntax is all wrong. `(liter atm/Kelvin)` is not a proper comment. It should be `(* comment *)` Your function arguments also have the wrong syntax. A proper function looks like this: `f[x_,y_]:=RHS` Can you give an example of the calculation you want the function to perform, written in normal mathematical notation?
Your function is wack, yo. Try it like this: g[x_, \[Theta]_] := (1+x)/(1-x) (x-1.5)/(x+1.5) + (1-x)/(1+x) (x+1.5)/(x-1.5) + 2 Cos[\[Theta]] xVals = {2, 3, 4}; pairs = {#, \[Theta]} &amp; /@ xVals; Plot[g @@ # &amp; /@ pairs, {\[Theta], 0, 10}]
mah nigguh
This should be on the sidebar. Mods plz.
Try this instead: RSolve[ { x[t + 1] == -x[t] + y[t] - 8, y[t + 1] == -3/10 x[t] + 9/10 y[t] + 4 }, {x[t], y[t]}, t ]//Simplify It gives me an answer very quickly. I think it has some trouble using some of its fancy algorithms on floating-point numbers, which makes it try other things that don't work.
Great! It works. Thanks a lot. 
Well, for one thing you should almost *never* use an explicit loop in Mathematica as they are very slow. Using Map/Apply/Thread will be 1-2 orders of magnitude faster. But, if I understand your question, you just want to try various finite difference schemes on a grid? You can do that in multiple dimensions very compactly with [ListConvolve](http://reference.wolfram.com/language/ref/ListConvolve.html). E.g., standard forward differencing looks like this: dx = .001; X = Range[0., 10. - dx, dx]; f[x_] := x^2 kernel = (1./dx) {1, -1}; pX = ListConvolve[kernel, f /@ X]; But if you're concerned so much about accuracy, why don't you use a second-order correct scheme like central differences?
 ContourPlot[Tan[x^y] == Tan[y^x], {x, 0, 10}, {y, 0, 10}] interesting function though, what are you trying to do with it? edit: you can increase the perscision of the graph by doing: ContourPlot[Tan[x^y] == Tan[y^x], {x, 0, 10}, {y, 0, 10}, PlotPoints -&gt; 25] 25 took awhile for my computer to draw, but you could try higher or lower to get a better picture of the graph
Got to be some caching going on. The evaluation order must actually be different internal to Mma (try it even with `-Prime[n]+Prime[n-1]`, which is mathematically the same as the first one, but has the runtime of the second one). Sadly you will have practically no way to figure out why, because of Mma's closed box.
Try switching the commands. If the results change its a caching issue.
Or ... reuse as much computation as possible. ps = Prime/@Range[10^4]; Drop[ps,1] - Drop[ps,-1]
When pasting in code, indent each line with four spaces. That tells Reddit to display it verbatim, with a monotype font: f[x_,y_]:=x^2 + y^2
I ran into this exact problem. I can't find the original notebook, unfortunately, but I know for sure I used [SphericalPlot3D](http://reference.wolfram.com/language/ref/SphericalPlot3D.html) instead of contour. 
It wasn't easy, but it did work nicely in the end. I wish I could find an example for you, sorry!
this is the syntax error i get: Syntax::sntxb: Expression cannot begin with "[T((\[PartialD]/\[PartialD]T)p)+v((\[DifferentialD]/\[DifferentialD]v)p)]".
Try this for the integral in your third function. Integrate[v Derivative[0, 1][p][T, v] + T Derivative[1, 0][p][T, v], {v, Subscript[v, i], Subscript[v, f]}] 
Thank you so much for the help
I can't really read your handwriting. Could you type up what you want us to solve? I see things that look like "Krw" and "MKro" and "Swi" and I don't know what they mean or even if I read them correctly. 
see edit. hope that makes sense. 
I'm on mobile, so I can't test to see the bottom command is slow, but a faster command should be Differences[Prime[Range[10^4]]]
First, you should pick names that aren't disallowed. In Mathematica, `*` and `_` have special meanings and can't be used in names. Do all of your parentheses represent functions? In Mathematica, parentheses are used only for grouping operations. Function calls are done like this: `f[x]`
Hi, Every variable is a function of S. The underscores are just used to represent subscript.
Please name all of the variables you will be using, then name all of the functions, and list which variables they are functions of. No * or _ allowed.
 {d1, d2} = Transpose/@{{x1,y1},{x2,y2}}; ListPlot[{d1,d2}]
That's ridiculously cool. Thanks!
Is F a function? Which variables is it a function of? What is devF? A new variable, or the derivative of F? If it is the derivative, which variable is it differentiated with respect to? Your problem is underspecified. Unless you ask a complete question, I cannot help you.
F is a function of (S), which i had previously named S*. devF is the derivative of F with respect to (S). Sorry about the poor notation, im still getting to grips with computational mathematics. 
a 30 second Google search came up with [this](http://reference.wolfram.com/language/ref/WeatherData.html) link, which uses the following code DateListPlot[WeatherData["KMDZ", "MeanTemperature", {{2007, 1, 1}, {2007, 12, 31}, "Day"}], Joined -&gt; True] It says in the documentation that the first argument can also be given as {lat, long} coordinates.
This was awesome! Thanks
Do you have data (a list of (x,y) pairs), or do you just have a graph in some other format? With the data, it's quite easy—just sort the pairs by distance to some fiducial (x0,y0), and then make a cumulative distribution function in terms of distance; the derivative of the CDF is then the PDF of density of points within some dr. Or you can Map the distance function over the list of points and then just use Histogram[]. Anyway, more details would always be better. I hope you have the actual data, not just a picture of a graph. [Pedantry: It's not a script, it's a notebook. And don't use loops, loops are not the Mathematica way.]
I'll try that again but when I tried it before It was giving me the variance of the columns anyways :/
thanks Bill, will upload both the files when i can. Thanks
I fixed it: z = 0; a = 5.29177*10^(-11); r[x_, y_] := Sqrt[(x^2) + (y^2) + (z^2)] Theta[x_, y_] := ArcCos[z/r[x, y]] Phi[x_, y_] := ArcTan[y/x]; Psi1[x_, y_] := (1/(8*Sqrt[\[Pi]]*((a)^(3/2))))*(r[x, y]/a)* Exp[-r[x, y]/(2*a)]*Sin[Theta[x, y]]*Exp[I*Phi[x, y]] (*n=2,l=1,m=1*) Psi2[x_, y_] := (1/(8*Sqrt[\[Pi]]*((a)^(3/2))))*(r[x, y]/a)* Exp[-r[x, y]/(2*a)]*Sin[Theta[x, y]]*Exp[-I*Phi[x, y]] (*n=2,l=1,m=-1*) px[x_, y_] := (1/Sqrt[2])*(Psi1[x, y] - Psi2[x, y]) py[x_, y_] := (I/Sqrt[2])*(Psi1[x, y] + Psi2[x, y]) pz[x_, y_] := (1/(4*Sqrt[2*\[Pi]]))*((1/a)^(3/2))*(r[x, y]/a)* Exp[-r[x, y]/(2*a)]*Cos[Theta[x, y]] (*n=2,l=1,m=0*) s[x_, y_] := (1/(4*Sqrt[2*\[Pi]]))*((1/a)^(3/2))*(2 - (r[x, y]/a))* Exp[-r[x, y]/(2*a)] (*n=2,l=0,m=0*) SpA[x_, y_] := ((1/Sqrt[3])*(s[x, y])) + ((Sqrt[2])/(Sqrt[3]))*(px[x, y]) SpB[x_, y_] := ((1/Sqrt[3])*(s[x, y])) - ((1/Sqrt[6])*(px[x, y])) + (1/Sqrt[2]*(py[x, y])) SpC[x_, y_] := ((1/Sqrt[3])*(s[x, y])) - ((1/Sqrt[6])*(px[x, y])) - (1/Sqrt[2]*(py[x, y])) GraphicsColumn[{ContourPlot[(Abs[SpA[x, y]])^2, {x, -10*a, 10*a}, {y, -10*a, 10*a}], ContourPlot[(Abs[SpB[x, y]])^2, {x, -10*a, 10*a}, {y, -10*a, 10*a}], ContourPlot[(Abs[SpC[x, y]])^2, {x, -10*a, 10*a}, {y, -10*a, 10*a}]}, ImageSize -&gt; 500] Usually it's best to define things as functions when you can. Edit: I formatted it better
I'm not very well versed in Mathematica but the page you linked is from Mathematica documentation itself which you can open as an executable notebook inside Mathematica. Just go to help (inside Mathematica app) and search help for StreamPlot and you will find probably find the same page as an help file in executable state.
I'll take a look at that, maybe it's just a version thing? Thanks!
Looks like there's some good info on [StackExchange](http://mathematica.stackexchange.com/questions/14160/plotting-a-phase-portrait).
l = {{x1, y1}, {x2, y2}, {x3, y3}} If you want the second object for example you type l[[2]] If you want the x2 from the second object you use l[[2,1]] similar for y2 using l[[2,2]]
How do you want to access this data exactly? Depending on what exactly you want you can look into replacement rules, functions, or association tables. For instance: list={{x1,y1},{x2,y2}...} gety = Association[Table[list[[i,1]] -&gt; list[[i,2]], {i, Length[list]}]]; then gety[x1] will return y1 etc. If you want to return some default value for when a given x is not in your list, you can use Lookup[gety,x,default].
Sorry should have clarified. I am confused about part b
I'm guessing that should work. Give it a try, and let us know how it goes. Also be sure to think about what should happen when x and/or x-2 is not in the list you specified. 
Sorry for asking again, When x1 is a decimal number, it doesn't work. I've tried the KeyExistsQ function and it only works if x1 is an integer... As keys are associated to only strings, is there anyway to work around this? http://mathematica.stackexchange.com/questions/59201/only-string-keys-supported-in-datasets-association-query
Ah, thanks so much!
That's really unfortunate, as these association tables are new and I wanted them to have a good use. Anyway, I don't have the latest mathematica installed, so I can only give you this workaround which doesn't use associations at all. list = {{1, 2}, {3, 4}, {1.5, 2.5}}; Do[ gety[list[[i, 1]]] = list[[i, 2]] , {i, Length[list]}]; getydefault[x_, default_] := If[NumericQ[gety[x]], gety[x], default] Here gety[x] functions with doubles, and you can use getydefault[x] if you want to return a default value in case your x is not in the list you use. One small caution though: gety[1.5] will return 2.5 in this example, but gety[3/2] will not, since mathematica distinguishes between a fraction and a double. 
The free tier gets 1000 'credits' a month. Running an evaluation doesn't necessarily cost you any credits. Things like CloudDeploy, sending email, etc,... does consume credits. Here is a full overview: http://www.wolfram.com/cloud-credits/
Are you using equation (5) from the Mathworld page?
yeah. sorry, i should have made that more clear
I can explain this. Mathematica first computes Plot[Exp[-x], {x, -2, 10}] making some default decisions about what the plot range should be. Then it computes Plot[Exp[-x], {x, 0, 10}, Filling -&gt; Axis] again making default decisions about what the plot range should be. If you look at these two separately, you'll see that this one doesn't have the y-axis go up as high as the first one. In fact, it only goes up to around y=0.41. When you combine these two with Show[...] the viewing window is decided based on the first input. The second plot doesn't get recomputed in this, so where the shading gets cut off is where the top of the image produced by Plot[Exp[-x], {x, 0, 10}, Filling -&gt; Axis] So, you can like, just add this option to the second Plot[...] PlotRange -&gt; {{0, 10}, {0, 1}} Leik, u no, Show[Plot[Exp[-x], {x, -2, 10}], Plot[Exp[-x], {x, 0, 10}, Filling -&gt; Axis, PlotRange -&gt; {{0, 10}, {0, 1}}]]
You do have seven independent variables, don't you? Year, Expend, MalHeight, MalWeight, HIV, Vacc, Primary. I'm not sure what your issue is. 
He has 6, a phantom variable is showing up. The primary is the dependent.
Year is not a variable here. I'm trying to take it out of the regression, but it won't run.
Then take Year out of data1. Make data1 = Transpose[{LifeExp, Expend, MalHeight, MalWeight, HIV, Vacc, Primary, Year}] lm = LinearModelFit[ data1, {x1, x2, x3, x4, x5, x6, x7}, {x1, x2, x3, x4, x5, x6, x7}] lm["ParameterTable"] into data1 = Transpose[{LifeExp, Expend, MalHeight, MalWeight, HIV, Vacc, Primary}] lm = LinearModelFit[ data1, {x1, x2, x3, x4, x5, x6}, {x1, x2, x3, x4, x5, x6}] lm["ParameterTable"] Note you have to take x7 out of lm as well. 
That's the area where the function is so large that it doesn't fit into your plot range. To get rid of it, in your Plot3D command write: ClippingStyle-&gt;None Also, you don't have to manually include axes like that, you can just put AxesLabel-&gt;{"x","y","z"} In your Plot3D command. Overall, it should end up looking like this to get the same results: Plot3D[x^2 + y^2, {x,-10,10}, {y,-10,10}, AxesOrigin-&gt;{0,0,0}, PlotRange-&gt;{-1,20}, ClippingStyle-&gt;None, AxesLabel-&gt;{"x","y","z"}]
You stated that you wanted x from -10 to 10, but y only up to 20. That's why it can't plot the regions that are too far out.
Oh okay, seems like a dumb mistake.
&gt; data1 = Transpose[{LifeExp, Expend, MalHeight, MalWeight, HIV, Vacc, Primary}] When I try this, it gives the error message: "The first two levels of {LifeExp, Expend, MalHeight, MalWeight, HIV, Vacc, Primary} cannot be transposed." Which means the LinearModelFit and ParameterTable no longer work either.