This works for me: Year = {1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012}; LifeExp = {65.75542194, 66.02913797, 66.35422729, 66.47252015, 66.68187339, 67.00571375, 67.27774655, 67.63551041, 67.78536631, 68.14012681, 68.40961239, 68.77332608, 69.112771, 69.44603955, 69.77768623, 70.03408911, 70.39283274, 70.58285803}; Expend = {5.79342973, 5.892716281, 5.902880517, 5.972483901, 5.982100626, 5.999886577, 6.108663805, 6.207548665, 6.410941176, 6.420144275, 6.454817874, 6.476339664, 6.478014223, 6.5500518, 7.03034124, 6.898745491, 6.849864013, 6.914290853}; MalHeight = {32.35779772, 32.44117635, 34.96999989, 31.76086922, 30.27307694, 32.3931008, 29.84090898, 25.29130428, 31.26956519, 26.49259263, 26.35981088, 28.8466667, 26.09310347, 25.33600033, 27.46500005, 26.72228566, 29.14666653, 19.56999998}; MalWeight = {19.21019133, 17.49705894, 21.4599999, 17.4166666, 16.15384617, 17.44480942, 17.13333336, 13.30434762, 17.49130447, 12.90740759, 13.50173831, 15.79111107, 14.73103446, 11.38399998, 13.44210526, 13.01645349, 16.84000012, 11.16999984}; HIV = {2.103225599, 2.306793131, 2.489804707, 2.624950732, 2.720157989, 2.775275104, 2.798596616, 2.781921177, 2.74439563, 2.688154091, 2.625596232, 2.593131092, 2.535131451, 2.49580248, 2.452158683, 2.416761676, 2.377299082, 2.346456852}; Vacc = {80.19075221, 80.20151626, 79.98999164, 80.49606754, 80.49105856, 81.5984411, 82.31233772, 82.72732682, 83.60517387, 84.53192251, 86.0038077, 86.50255602, 87.46557047, 87.86167503, 88.46279731, 88.55050884, 88.67013584, 89.06421959}; Primary = {77.50598927, 77.05645894, 80.60628575, 81.71376951, 81.6033522, 81.94811179, 84.35361242, 85.8118358, 86.67353538, 87.0362881, 87.22013127, 87.9350917, 88.73646552, 87.61104548, 88.26222392, 88.96815981, 89.74695402, 89.93833245}; td = TemporalData[{LifeExp, Expend, MalHeight, MalWeight, HIV, Vacc, Primary}, {Year}] ; ListLinePlot[td] data1 = Transpose[{LifeExp, Expend, MalHeight, MalWeight, HIV, Vacc, Primary}]; lm = LinearModelFit[ data1, {x1, x2, x3, x4, x5, x6}, {x1, x2, x3, x4, x5, x6}]; lm["ParameterTable"] Output is [1](http://i.imgur.com/lyxyYQC.png) [2](http://i.imgur.com/lZRuzq8.png).
It works! Thank you so much, I don't know why it wouldn't run when I took out "Years" before, but this is exactly what I was looking for.
Thank you for the help, the Print statement made it much easier to see where the evaluation was stuck. It seems that because the summation function evaluated from i=1 to 4 and I had not defined vInitial[1], vFinal[1] or pVdW[1]. The problem now seem to be coming from the other indexed vFinal[i] definitions. 
See `NestWhile`. But also just use `FindRoot`, unless this is a programming exercise.
Wow, that is older than I realized. I see the version 5.2 comment...Guess that makes sense for an early 1990's package. Thanks for taking the time to look at it!
Yes, I only need correct matrices as I am solving for the dynamics of a robot arm. Thanks for the input. The code runs but does not compute some of the functions-- i.e. RigidPosition[], RigidAdjoint[], and their inverses. Hmmm... I've asked the professor but he isn't responding via email thus far.
Well, considering 5.2 came out in 2005, I would say that doesn't make a whole lot of sense. 
Didn't know the release date of 5.2, hmm.
Well, I caught a dumb mistake on my part-- had MatrixForm[] acting on some of my functions too early on in the code, so the later functions would not evaluate. It appears to be healed now. Thanks for your patience and for looking at the packages!
See also: [`FixedPoint`](http://reference.wolfram.com/language/ref/FixedPoint.html). It's basically the same as `NestWhile`, but it's a bit more intuitive for this usage (to me at least) to think of it as a fixed point iteration.
The numerical scheme need not converge, or may take prohibitively long to do so if it does; also, the problem states to terminate after a certain condition is met. Therefore `FixedPoint` is the wrong solution to this problem.
`FixedPoint` accepts options for limiting the maximum iterations and for determining "sameness" (e.g., you could use `SameTest-&gt;Abs[#1-#2]&lt;epsilon&amp;` to stop when two successive iterates differ by `epsilon`). It can be used in place of `NestWhile` here; you can always change a `FixedPoint` into a `NestWhile`, it's basically just a special case. In any case, both will work just fine. For example, Newton's Method (which should be helpful to OP as well) is: Newton[f_, x0_?NumericQ, eps_, imax_:25]:=FixedPoint[ # - f[#] / f'[#] &amp;, x0, imax, SameTest-&gt;Abs[#2-#1]&lt;=eps &amp; ]
After running a Trace of the function for the final enthalpy it seems like the error is coming from the indexed definitions of vFinal. I'm not sure how to change it so that the computer will be able to evaluate it inside the final function. Clear[EnthalpyRxn]; Off[Solve::rantz, NSolve::rantz] EnthalpyRxn[Tfinal_, pfinal_] := Module[{EnthalpyRxnI, pVdW, heatcapacity, vInitial, vFinal, T, v, \[Nu], hc, hp, q, i}, EnthalpyRxnI := -94.051(*Kcal/mol*)- (2*-57.798(*Kcal/mol*)); pVdW[1] := 0; pVdW[2][T_, v_] := Module[{R = 0.082(*liter atm/Kelvin mole*), a = 5.464(*liter^2 atm/mole^2*), b = 0.03(*liter/mole*)}, R T/(v - b) - a/v^2]; pVdW[3][T_, v_] := Module[{R = 0.082(*liter atm/Kelvin mole*), a = 3.59(*liter^2 atm/ mole^2*), b = 0.043(*liter/mole*)}, R T/(v - b) - a/v^2]; pVdW[4][T_, v_] := Module[{R = 0.082(*liter atm/Kelvin mole*), a = 24(*liter^2 atm/ mole^2*), b = 0.026(*liter/mole*)}, R T/(v - b) - a/v^2]; heatcapacity[1][T_] := 2.673 - (116900/(T^2)) + 0.002617 T; heatcapacity[2][T_] := 7.219 + 0.002374 T + (2.67*10^-7) T^2; heatcapacity[3][T_] := 5.152 + 0.015224 T - (9.681*10^-6) T^2 + (2.313*10^-9) T^3; heatcapacity[4][T_] := 6.947 - 0.0002 T + (4.808*10^-7) T^2; vInitial[1] := 0; vInitial[2] := v /. Flatten[NSolve[pVdW[2][298, v] == 1, Reals]]; vInitial[3] := v /. Flatten[NSolve[pVdW[3][298, v] == 1, Reals]]; vInitial[4] := v /. Flatten[NSolve[pVdW[4][298, v] == 1, Reals]]; vFinal[1][Tfinal, pfinal] := 0; vFinal[2][Tfinal, pfinal] := v /. Flatten[NSolve[pVdW[2][Tfinal, v] == pfinal, v, Reals]]; vFinal[3][Tfinal, pfinal] := v /. Flatten[NSolve[pVdW[3][Tfinal, v] == pfinal, v, Reals]]; vFinal[4][Tfinal, pfinal] := v /. Flatten[NSolve[pVdW[4][Tfinal, v] == pfinal, v, Reals]]; \[Nu][1] := -1; \[Nu][2] := -2; \[Nu][3] := 1; \[Nu][4] := 2; hc := \!\( \*UnderoverscriptBox[\(\[Sum]\), \(i = 1\), \(4\)]\(\[Nu][ i] Integrate[\(heatcapacity[i]\)[T], {T, 298, Tfinal}]\)\); hp := \!\( \*UnderoverscriptBox[\(\[Sum]\), \(i = 1\), \(4\)]\(\[Nu][ i] Integrate[ T\ D[\(pVdW[i]\)[T, v], T] + v\ D[\(pVdW[i]\)[T, v], v] /. T -&gt; Tfinal, {v, vInitial[i], vFinal[i]}]\)\); Normal[EnthalpyRxnI + hc + hp, ConditionalExpression]]; 
also, I think the somewhere it might be regression in the wrong order -- cause looking data the coefficient should not be negative to begin with.
Sorry - Not Okun's Law
I stand corrected.
I tested your function, but FixedPoint doesn't take 4 arguments. Should `SameTest` be a pattern test using `/;` instead? How could I this apply to my problem?
Hmm my bad, it looks like `FixedPoint` doesn't let you specify both a step limit and sameness function. This might be a bug, I swear you could do it before. Edit: I showed the same thing using `NestWhile` in my other comment. If you leave off the max iterations it works though: Newton[f_, x0_, eps_] := FixedPoint[# - f[#]/f'[#] &amp;, x0, SameTest -&gt; Abs[#2 - #1] &lt;= eps &amp; ] You apply this method using `FixedPoint` or `NestWhile` (the syntax is basically the same) to your problem by replacing the second line with the recursion you gave. At each iteration, `FixedPoint` and/or `NextWhile` calls your sameness test or while condition with the first argument being the previous iterate and the second argument being the one before it (so iterate `i` and `i-1`). For `FixedPoint`, if the function returns `True` then it terminates and returns the final value, whereas `NestWhile` terminates when the while condition evaluates to `False`, which is why I find `FixedPoint` to be a bit more intuitive. I used an anonymous function for the test (`FixedPoint` by default uses `SameQ`), where `#1` represents the first argument and `#2` the second, but you can write it out explicitly if you prefer or use the named form for anonymous functions (`Function[]`). Edit again: Oh, I didn't notice that your actual recursion also needs the previous iterate. You can do that by just passing it between iterates. That's a bit tricker, something like (again, same thing applies with `NestWhile`): Newton[f_, x0_, eps_] := FixedPoint[ {Last@#, Last@#-f[Last@#]/f'[Last@#]}&amp; x0, SameTest -&gt; Abs[Last@#1-Last@#2] &lt;= eps &amp; ] // Last where now `x0` needs to be a pair, because your function expects a pair of {xold, xnew} as its input. Basically, you make it so that instead of just returning the next iterate, your recursion returns the current iterate and the next one as a pair. That way it can use both values when computing the new iterate. This is starting to sound a bit complicated, but it's not really that bad. 
Well, not completely. It looks like there's some odd glitch where you can't specify both a number of iterations and a sameness test. I swear you used to be able to, but it looks like you can't now. However, the solution with `NestWhile` looks basically the same, except that you reverse the condition (`NestWhile` terminates when the condition evaluates to `False`, the opposite of `FixedPoint`'s behavior). Newton[f_, x0_?NumericQ, eps_, imax_: 25] :=NestWhile[ # - f[#]/f'[#] &amp;, x0, Abs[#1 - #2] &gt;= eps &amp;, imax ]
Isn't the point of an exam to test what *you* know, not what Reddit knows?
Yep, I've made 4/5 of it, and the last one I can't figure out which function to use. So no I'm not asking anyone to make it for me, just if someone might know what functions to look up. 
If we don't know specifically what you need, we can't tell you what functions to use.
I'm having a hard time wrapping my head around all of this. I get a bit confused by the `#`-signs and why some are `#1` and `#2`, but that's probably because of my lack of experience with it. Also, the Last@ is only for the x`i-1`, right? So in my case it would look something like: FindZero[f_, x0_, x1_, eps_] := FixedPoint[ {# - f[#]*(# - Last@#)/(f[#] - f[Last@#])} &amp;, {x0, x1}, SameTest -&gt; (Abs[Last@#1 - Last@#2] &lt;= eps &amp;) ] This doesn't work however. I get a lot of errors which are hard to recognize. One of them though, is `"Infinite expression 1/0 encountered."`. I can't thank you enough for taking your time to do this for me. You are very helpful and I appreciate it. 
Holy.... Wow... You just made sense of everything I had been struggling with. The work you put into this to make me understand is just incredible. Some of it I knew beforehand (`@` and `//`), but you applied it and put things into perspective. Again, I can't thank you enough - people like you are what make reddit. May your sandwiches be forever awesome - just like you. 
No problem, thanks for the gold. There's a reason my students usually plan to set aside at least an hour if they want to ask me a question :). Mathematica is a nice tool and is pretty elegant for a lot of uses, but it is quite a bit different from the programming languages most people are used to and it can be hard to wrap your head around. PS: because of the quirk I mentioned with `FixedPoint` where you can't specify an iteration limit and a `SameTest`, if you use this function with something that doesn't have a zero it'll run forever. You can use `NestWhile` instead if that's a concern, just make sure to reverse the condition (`FixedPoint` continues while `SameTest` is false, whereas `NestWhile` continues while the condition is true.)
It's not hard to see you care about students understanding (must be hard on the work hours at times, though) :) I think I'll go ahead and use `NestWhile` then.
I'm new to this, but did you declare i[t] with `=` or with `:=`? I think you should use the latter here. Better clear the definition you have at the moment.
Oh yeah I fixed it now :))))!
Try removing the function from q, so try q=integrate[I[t],t]. Integrate (with these parameters) computes an indefinite integral, so already gives a function. 
Does it work without the ?NumericQ? Does it work without the :10? If so, I'm not sure why the combination doesn't work.
Put a semicolon after the first b.
I assume you've tried putting the ?NumericQ behind the 10 at some point? Some more tricks you could try: Try defining the separate versions and looking at their Fullform. Perhaps by studying their full form you could piece together how to get both. I cannot do this for you as I'm currently on my phone. A workaround could be to use the ?NumericQ version, and define the default behavior explicitly by e.g. Asd[]:=Asd[10]. This works poorly though if you want to use multiple default arguments, but could work well enough depending on your purpose. 
Yeah, that won't work in my case unforntunately. `FullForm` didn't do anything either. Thank you very much for the suggestions, though. 
I'll try messing around with it tonight to see if I can come up with something. One other suggestion you could try. Try and make and combine two functions. So make asd[x_:10]:=asdalternative[x]; And have asdalternative[x_?NumericQ]:=x+1; Not elegant by any stretch, but it's something to try.
Why the colon? That's for default values like the 10, no? asd[b_: ?NumericQ : 10] := b + 1 Information::ssym: NumericQ:10 is not a symbol or a valid string pattern. &gt;&gt;
After the b: asd[b:_?NumericQ : 10] := b + 1 The general way to have a named pattern with a default value is *name*:*patern*:*value*. When the pattern starts with an underscore you can omit the first colon, but for general patterns you need to write it. For example: l:{_, _}:{1, 1} In this case the pattern starts with an underscore, but without the first colon it is parsed as: b_?(NumericQ : 10)
I have been searching for a day for this. I couldn't get the information you just wrote out of the documentation. THANKYOU.
http://www.reddit.com/r/Mathematica/comments/2poa50/when_making_a_function_how_do_i_set_a_default/cmyj6ue
That is true. However, your proposed method is not the proper way to deal with that situation; a temporary variable is created that leaks into the outer environment. If You do '??q' after your proposed assignment, you will see it. If you want to guard against this, you should use Block rather than Module, as such: Block[{t}, q[t_] := Evaluate[Integrate[i[t], t]]] Examining 'q' afterwards (using '??') will show that this results in the desired delayed assignment, with a clean right-hand side in terms of 't'. 
Using Module instead of Block does indeed have a performance cost. It has to create a brand new symbol, insert it anywhere in the inner expression where some other symbol appear, and if you keep referencing it, it will consume some memory (in my system close to a kilobyte). However I use Module by default to localize variables, and Block only when I explicitly want its behaviour. In part it is because Module defends itself against other scoping constructs. For example With[{x=0}, Block[{x=3}, x]] is incorrect, while With[{x=0}, Module[{x=3}, x]] is correct, and With[{x=t}, Block[{t}, D[t x, t]]] the local variable t in the block interferes with the global variable t giving 2 t, while in With[{x=t}, Module[{t}, D[t x, t]]] the t in the Module is a true dummy variable and the result is t as you would expect. A more insidious problem is that in occasions the functions inside the scoping construct may depend in some way on a global variable with the same name as the variable you are trying to localize. With Module it doesn't matter, the scope will only refer to the variables that you explicitly see in your code. With Block you can get some surprises if you use functions inside of which you don't know or you don't remember the inner workings. So although Block is negligibly more efficient than Module I think the latter provides a better abstraction of the idea of local variables.
For me it is not so much about efficiency as it is about not obtaining the desired result. Doing '??q' shows that the temporarily created local 't' symbol (something like 't$123') is now part of the definition of q. Surely that is not the desired result. This is pretty much the result of the awkward implementation of lexical scoping in Mathematica. What Module[] does isn't *really* lexical scoping; it is an approximation of actual lexical scoping by using generated symbol names that are supposed to be temporary - except that they aren't really, as '??q' demonstrates. 
My suggestion is to get your graph working without manipulate first, and then wrap a manipulate around it piece by piece. If you give me some sample code I'd have a better idea of what you're trying to do.
Hey So I was able to somewhat create what I wanted, and I just have one issue on making it look good My code: &gt; Manipulate[Module[{H, \[Theta], r2, r1}, H = Sqrt[height^2 + (baseRadius - topRadius)^2]; \[Theta] = 2 Pi *(baseRadius - topRadius)/H; r2 = topRadius H/(baseRadius - topRadius); r1 = r2 + H; Pane[Row[{With[{a = baseRadius, b = topRadius, h = height, n = 30}, Show[{Graphics3D[{Polygon[ Table[{a Cos[(2 \[Pi] i)/n], a Sin[(2 \[Pi] i)/n], 0}, {i, n}]], &gt; Polygon[ Table[{b Cos[(2 \[Pi] i)/n], b Sin[(2 \[Pi] i)/n], h}, {i, n}]]}], RevolutionPlot3D[(h (a - t))/(a - b), {t, b, a}, Mesh -&gt; False]}, Boxed -&gt; False, ImageSize -&gt; {300, 300}, SphericalRegion -&gt; True]], }], ImageSize -&gt; {605, 300}]], &gt;{{baseRadius, 22, "base radius"}, IntegerPart[topRadius] + 1, 200, 1, Appearance -&gt; "Labeled"}, {{topRadius, 12, "top radius"}, 1, IntegerPart[baseRadius] - 1, 1, Appearance -&gt; "Labeled"}, {{height, 1}, 10, 150, 3, Appearance -&gt; "Labeled"} ] I want to create just one manipulate that changes the manipulates in the other 3 sections the same number for every tick (baseRadius 1, topRadius 1, height 3)
This is not am answer to your question, but RandomSample does exactly the same thing.
The first argument to NestList should be a function which ingests the same kind of data that it returns. Since you're starting that function off with an argument that's a list of length 2, namely {x,y}, the function should return a list of length 2. That way, the function can be called again on its own result. Your anonymous function is: { RandomChoice[{#[[1]] - #[[2]], #[[1]] + #[[2]]}] } &amp; That's a list of length one, and the list's single element is the random choice between x+y and x-y (when applying the function to {x,y}). I recommend changing your function so that it returns a list of length 2. For example, this function would work: { RandomChoice[{#[[1]] - #[[2]], #[[1]] + #[[2]]}], RandomChoice[{#[[1]] - #[[2]], #[[1]] + #[[2]]}] } &amp; It calculates two independent random choices, thus creating a list of length 2.
Thank you! That works!
Yea, I realized that I was doing it all wrong and found a demonstration project on it and modified the code
If you do a Trace of the evaluation you can see it is constructing an augmented matrix and doing a Det on that. The Det finds that augmented matrix is singular and that appears to be part of the problem.
Ok. Any solution in sight? Or is it just easier to accept that factoring out of a vector, a quantity with a unit, is not advisable in Mathematica?
I don't know where the problem comes from, but giving a unit to 0 makes it work: Cross[{Quantity[1.2, "au"], Quantity[0.8, "au"], Quantity[0, "au"]}, Quantity[20, "km/s"]*{-Cos[55 Degree], Sin[55 Degree], 0}] though I would probably factor the first unit out: Cros[Quantity[{1.2, 0.8, 0}, "au"], Quantity[20, "km/s"]*{-Cos[55 Degree], Sin[55 Degree], 0}]
It would appear that I have misunderstood what EquatorialAngularVelocity gives. It does not give an angular velocity. It does not give phase i.e. radian per time. It gives revolutions per time! Most of all it seems as if Wolfram completely misunderstands the word "angular velocity"?? I've found two workarounds that are equivalent: 1. PlanetData["Earth", "EquatorialAngularVelocity"]* Quantity[2 Pi, "1/rev"] 2. 2 Pi*PlanetData["Earth", "EquatorialFrequency"] Both give expected value of 0.000072921150 1/s in SI (which is approx. 2Pi/(3600*24 s). I prefer the second workaround for bevity, but it's not elegant :/
Well I'll be... To be honest, I thought that it was the initial declaration of "Hey, here's my If statement, here's what the options are..." I forgot to add in the [source of where I adapted the code from](http://mathematica.stackexchange.com/questions/11200/dynamically-choosing-which-manipulate-controls-to-use), so I was a little fuzzy with what was actually going on. Thank you so much for that! Much appreciated! Now that you've actually pointed it out, it makes a lot of sense...
You're welcome!
2
I think that's more than a hint :) 
http://reference.wolfram.com/language/ref/GroupBy.html GroupBy[list, First-&gt;Last]
Have you checked this page? http://mathematica.stackexchange.com/questions/33006/how-to-position-text-labels-automatically-to-not-overlap-other-graphics-elements
Well, as much as I love mathematica, and think it is the best thing since sliced bread, I think you should realize that this is not really a good application of Mathematica. It is a MATLAB problem. Numerical methods are better suited to MATLAB, while symbolic methods are better suited to Mathematica. Sad, but true... What I can recommend, however, is a package called MATLink. http://matlink.org/ It allows you to control MATLAB's kernel from Mathematica's front end. I use it all the time, and it is a very powerful tool. I know this doesn't answer your question, but it might help you get a better result in the long run.
Thanks! I sorta realized that, but unfortunately my lab has a Mathematica liscence but not a MATLAB one &gt;.&lt; I'll look into MATLink - thank you!
In addition, if you're going to be working with these variables a lot throughout the notebook, you could also throw everything into the global variable '$Assumptions', like so: $Assumptions = {Element[{z,L}, Reals], z&gt;0,L&gt;0}; Here I told Mathematica that all variables are real, and also tacked on the property that they're positive.
You only need to specify they're positive, since then they are obviously real
I tried solving it with: NSolve[{iiR[r, t] &gt; 1/1000000 &amp;&amp; iiR[r, t + 250*10^(-6)] &gt; 1/1000000, t &gt; 0, r &gt; 0}, {r, t}] (iiR[r,t] is the function I wrote in the description I(t) ) But it just prints out the equation, no solution (I'm new to mathematica so I don't know the reason :/)
http://i.imgur.com/7BbWaPm.png With NSolve, you often have to put in a bit more effort. Also, 1.7 gigaohms is a tonne of resistance... like few microns of air gap or something :\
Ahhhh, ok. I corrected my function and did current[t_, r_] := (18.1818/r)*Exp[ (t/r)*4.54545*10^11 ] Reduce[{current[t, r] &gt;= 10^-6 &amp;&amp; t &gt;= 250*10^-6 &amp;&amp; r &gt; 0}, r, Reals] The result involves the unusual function ProductLog[...] giving the interval for r: 0 &lt; r &lt;= (4.54545*10^11 t)/ProductLog[25000 t] You should be able to find values for different t. e.g when t==250 * 10^-6, Reduce[ current[250 * 10^-6 , r] &gt;= 10^-6 &amp;&amp; r &gt; 0, Reals ] 0 &lt; r &lt; 7.80186*10^7 or less than 78 M ohms. ProductLog is also known as the lambert W-function and there is probably some approximation to it using a series that engineers use as a rule of thumb. In the other question: the power dissipation over the load (resistor) will be P = V^2 / R watts. When R is close to zero, the power shoots up towards infinity and the resistor burns out in a tiny ball of flames as all the electrical energy is converted to heat. Hope that helps; I'm in my 3rd year of Computer Science in the UK but I did electronics when I was at school so I have only a little knowledge of the subject.
This type of issue is an ongoing problem with me. Mathematica assumes all of the most obscure mathematical possibilities, and I don't understand how to use assumptions to come up with something a normal guy like me would find useable. I also don't know what this output means, or what condition the conditional output relies on. 
I Usually try plotting the region to get a feel for it, maybe a clue for where to go next.
The conditional output depends on the second argument of the function ConditionalExpression. This part is just the one that controls the behavior of C[1], and here it says that C[1] must be an integer. I'd format your query as FullSimplify[Solve[Tan[a] == Sin[b]/(1/c + Cos[b]), b], Assumptions -&gt; {Im[a] == 0 &amp;&amp; Im[b] == 0 &amp;&amp; Element[c, Integers]}] but the result is the same. Note that the arctangent function in your answer has two arguments: ArcTan[x,y] gives the arctangent of y/x, taking into account the signs of x and y. To learn more about syntax, query functions preceded by question marks: ?ArcTan Since the square roots in your answer don't simplify, I wouldn't expect a simpler answer.
I mean inside the argument for arctan. There are two entries separated by a comma.
When you can't figure out a Mathematica function then look at the documentation and always click on the "Details and Options" item to see more and often critical information. There are two ways to use ArcTan. One way has a single argument, the other has two arguments, separated by a comma. Think of Tan, you could have Tan[1/1] or Tan[-1/-1] Those are pointing in opposite directions. But ArcTan[1] has no idea which you want, while ArcTan[1,1] or ArcTan[-1,-1] does. On your first post above, Mathematica just can't win. If it ignored all the special cases and you ever found that what you were assuming, but not telling it, gave a different answer then you would be furious, but if you have to give it all of what is in your head then you aren't any happier. As for this being "a simple problem", I don't think I agree. If your problem had only integers and addition, subtraction and multiplication then the answer would be simple. Throw in division and the problem gets more complicated. Throw in multiple trig functions and then problem is almost always anything but simple.
I could be wrong but I think that having `Element[a, Integers]` above the Solve statement does nothing. You should instead pass those in as assumptions to FullSimplify as seen here: [http://puu.sh/euxf5/fb4e434cbc.png](http://puu.sh/euxf5/fb4e434cbc.png)
http://12000.org/my_notes/rankTest/test.htm &gt;Matlab and Mathematica results are almost identical. This is most likely due to the fact that they both are linked to optimized versions of same numerical libraries. On windows this will be intel math kernel library
If we are simply solving for I(250*10^-6 ) then the problem can be easily solved with NSolve[10^-6==18.1818/r*Exp[-4.54545*10^((11*250*10^-6)/r)],r,Reals] This will give you two resistance values. {{r -&gt; 0.00398802}, {r -&gt; 193007.}} You can then simply check if the current is greater than 10^-6 in each of the 3 regions. (i.e. r &lt; r1, r1&lt;r&lt;r2, and r&gt;r2)
Are you sure it shouldn't be 10^-11 ?
http://reference.wolfram.com/language/CUDALink/guide/CUDALink.html
thank you so much!!
Let me know if you guys do anything novel with CUDA, as I've been interested in it but have yet to take full advantage.
I have the SAME exact issue. Same exact error on my desktop, but Mathematica works fine on my laptop. I wonder if it's our OS version? My copy of windows 7 ultimate isn't exactly uhm.... legit. Is this the same for you? EDIT: It was the OS Version! I updated to Service Pack 1, and now Mathematica works. I suggest you do the same, if you haven't already fixed it :)
Column[] is just a formatting function; once it "applies" its format, you can't really interact with the result anymore as a mathematical object. Try numer1 = {1,2,3,4,5}; numer2 = {6,7,8,9,10}; result = numer1/numer2; Column[result] Same thing bit me when I tried to take the dot product of two MatrixForm[array]s.
I try that but when I do it I get for example" 1/6,7,8,9,10 , 2/6,7,8,9,10... What I'm trying to do here is I have two columns of data: LNDhat is one column &amp; Maturities is another one. To no avail.
Maybe the issue is that you want it to convert into decimals i.e. 1/6 = 0.166... ? You can convert your result to decimal form this way: c1 = {1,2,3,4,5}; c2 = {6,7,8,9,10}; result = N[c1/c2] The "N" function converts an exact value like 1/6 (which is treated symbolically by mathematica) to a numeric value 0.166... . 
I figured out it was a formatting issue, it was more the fact that I had lists of two numbers and wanted to divide them respectively.... If you guys have any helpful nelson sigel modelling templates that'd be great.
When you put "var" inside plot function's bounds it becomes a local variable with respect to the plot function. (The exact wording from the help is "Plot treats the variable x as local, effectively using Block.") That means that if the expression in "plot" does not explicitly contain a reference to the variable being plotted, mathematica will not know how to substitute the numerical values for "var" into the expression. So, you just need to plot something like Plot[f/.var-&gt;tempvar, {tempvar,min,max}]. This takes the "x" in your expression and converts it to the local variable being plotted. This is a little bit of a patch-up, so it won't, for example, allow you to do fancy things like integrate with respect to x^2. That sort of thing could also be engineered, I think, by implementing the chain rule explicitly. I also wrapped it in an "Evaluate" so that it only performs the substitution once. This can speed things up considerably if the plotted expression gets complex. Code /w this change: DynamicModule[{f = x^2, var = x, min = 1, max = 10}, Panel[Column[{Row[{Underoverscript[Style["\[Integral]", 36], InputField[Dynamic[min], FieldSize -&gt; Tiny], InputField[Dynamic[max], FieldSize -&gt; Tiny]], InputField[Dynamic[f], FieldSize -&gt; {{10, Infinity}, {1, Infinity}}], "\[DifferentialD]", InputField[Dynamic[var], FieldSize -&gt; Tiny]}], Dynamic[Plot[Evaluate[f /. var -&gt; tempvar], {tempvar, min, max}]]}]]] Apologies if I've got any terminology or language wrong; I program but I am not a programmer. Mathematica has some way to describe this situation more explicitly using what I think is called a context.
No problem! Code on, my friend. I'd love to see what it looks like when it's done&amp;mdash;you're taking advantage of some functionality that I haven't really explored and would love to learn about.
Well, here is what I have so far. It works, but the variables act like they are out of scope (they turn red, but it still works). Frankly, I ended up patching the whole thing together, and don't really understand what the scope of each variable is. Basically, it is a tool for teaching about integrals. It lets you show Riemann sums for any equation over a given range. Definitely not code I'm particularly proud of, but at least it does what it is supposed to... ClearAll["Global`*"] Module[{f = x^2, var = x, min = 1, max = 10}, int = Dynamic[(\!\( \*SubsuperscriptBox[\(\[Integral]\), \(min\), \(max\)]\(Evaluate[ f /. var -&gt; x] \[DifferentialD]x\)\)) // N]; Panel[Column[{Row[{Underoverscript[Style["\[Integral]", 36], InputField[Dynamic[min], FieldSize -&gt; Tiny], InputField[Dynamic[max], FieldSize -&gt; Tiny]], InputField[Dynamic[f], FieldSize -&gt; {{10, Infinity}, {1, Infinity}}], " \[DifferentialD] ", InputField[Dynamic[var], FieldSize -&gt; Tiny]}], Row[Prepend[ Column[{RadioButton[Dynamic[method], #], #}] &amp; /@ {"Left", "Right", "Midpoint", "Trapezoidal"}, "method "], " "], "", "number of rectangles", Row[{Slider[Dynamic[n], {1, 100, 1}], " n=", Dynamic[n]}], Dynamic[Show[ Plot[Evaluate[f /. var -&gt; tempvar], {tempvar, min, max}, PlotRange -&gt; {{min - (max - min)/5, max + (max - min)/5}, Automatic}, ImageSize -&gt; Medium], If[method == "Left", sum = \!\( \*UnderoverscriptBox[\(\[Sum]\), \(i = 1\), \(n\)]\(( \*FractionBox[\(max - min\), \(n\)]\ Evaluate[ f /. var -&gt; \((min\ + \ \((i - 1)\)\ \*FractionBox[\(max - min\), \(n\)])\)])\)\) // N; Graphics[{EdgeForm[{Thickness[0.003], Orange}], Opacity[0], White, Table[ Rectangle[{min + i (max - min)/n, 0}, {min + (i + 1) (max - min)/n, Evaluate[f /. var -&gt; (min + (i) (max - min)/n)]}], {i, 0, n - 1}] }], Graphics[]], If[method == "Right", sum = \!\( \*UnderoverscriptBox[\(\[Sum]\), \(i = 1\), \(n\)]\(( \*FractionBox[\(max - min\), \(n\)]\ Evaluate[ f /. var -&gt; \((min\ + \ \((i)\)\ \*FractionBox[\(max - min\), \(n\)])\)])\)\) // N; Graphics[{EdgeForm[{Thickness[0.003], Orange}], Opacity[0], White, Table[ Rectangle[{min + i (max - min)/n, 0}, {min + (i + 1) (max - min)/n, Evaluate[f /. var -&gt; (min + (i + 1) (max - min)/n)]}], {i, 0, n - 1}] }], Graphics[]], If[method == "Midpoint", sum = \!\( \*UnderoverscriptBox[\(\[Sum]\), \(i = 1\), \(n\)]\(( \*FractionBox[\(max - min\), \(n\)]\ Evaluate[ f /. var -&gt; \((min\ + \ \((i - 0.5)\)\ \*FractionBox[\(max - min\), \(n\)])\)])\)\) // N; Graphics[{EdgeForm[{Thickness[0.003], Orange}], Opacity[0], White, Table[ Rectangle[{min + i (max - min)/n, 0}, {min + (i + 1) (max - min)/n, Evaluate[ f /. var -&gt; (min + (i + 0.5) (max - min)/n)]}], {i, 0, n - 1}] }], Graphics[]], If[method == "Trapezoidal", sum = \!\( \*UnderoverscriptBox[\(\[Sum]\), \(i = 1\), \(n\)]\(( \*FractionBox[\(1\), \(2\)] \*FractionBox[\(max - min\), \(n\)]\ \((Evaluate[ f /. var -&gt; \((min\ + \ \((i - 1)\)\ \*FractionBox[\(max - min\), \(n\)])\)] + Evaluate[f /. var -&gt; \((min\ + \ \((i)\)\ \*FractionBox[\(max - min\), \(n\)])\)])\))\)\) // N; Graphics[{Orange, Table[ Line[{{min + i (max - min)/n, 0}, {min + i (max - min)/n, Evaluate[ f /. var -&gt; (min + i (max - min)/n)]}, {min + (i + 1) ( max - min)/n, Evaluate[ f /. var -&gt; (min + (i + 1) (max - min)/ n)]}, {min + (i + 1) (max - min)/n, 0}, {min + i (max - min)/n, 0}}], {i, 0, n - 1}] }], Graphics[]], Graphics[{Red, Thick, Line[{{min, 0}, {min, Evaluate[f /. var -&gt; min]}}], Blue, Line[{{max, 0}, {max, Evaluate[f /. var -&gt; max]}}]}] ]], Row[{"Riemann Sum:", Dynamic[sum]}], Row[{"Exact value:", Dynamic[int]}], Row[{"Error:", Dynamic[(Abs[sum - (\!\( \*SubsuperscriptBox[\(\[Integral]\), \(min\), \(max\)]\(Evaluate[ f /. var -&gt; x] \[DifferentialD]x\)\)) // N] 100)/((\!\( \*SubsuperscriptBox[\(\[Integral]\), \(min\), \(max\)]\(Evaluate[ f /. var -&gt; x] \[DifferentialD]x\)\)) // N)], "%"}]}]]]
I realized this is a very good place to learn some hacks and tricks, and there are many cool pictures generated with codes shorter than 128 characters (= 140 - StringLength["@wolframtap "]). Mathematica is a really amazing tool!
How about this code: &gt; x[t_] = x[t]/.DSolve[eqnx,x[t],t][[1,1]]//Simplify &gt; y[t_] = y[t]/.DSolve[eqny,y[t],t][[1,1]]//Simplify &gt; param = Table[{x[t],y[t]}/.{g-&gt;10,u-&gt;300,v-&gt;520},{k,{.01,.02,.03}}] &gt; ParametricPlot[param,{t,0,110}]
Thanks, but it just outputs the problem back. And yes I have the other variables defined. I think the problem is that RandomVariate only works with built-in distributions. Apparently I need to define a "Distributional Generator" somehow http://reference.wolfram.com/language/tutorial/RandomNumberGeneration.html#DefiningDistributions It's super complicated and I'm totally lost. 
My data range is actually 0-180. http://imgur.com/GETsi1j
&gt;Your x's look funny in the second statement. What is this? Have you tried using normal x? The statements with the funny ex's are outputs. Mathematica changes them all to x for some reason when it gives the output for ProbabilityDistribution. The actual variable I want to variate is "y". &gt;The first function has a domain for y from 0 to 1.1. Are you sure the domain for x in the same interval? y is supposed to go from 0 to 1.1, and x goes from 0 to 180. I think I have all the inputs specified right because I fooled around with it for hours, but I may just be using the functions all totally wrong. I really have no idea. Thanks.
The [PartialD] symbol is just that; a symbol. If you want the differential operator, it's used like this: D[f[x], x] That's the derivative of f[x] with respect to x. To find the commutator of two operators, first define the operators: pOp := \[HBar]/I*D[#, x] &amp; xOp := x # &amp; which sets the momentum operator 'pOp' as an anonymous function (signified by the trailing &amp;) whose argument is the slot #, and whose result is the derivative of that argument with respect to x, multiplied by hbar over the imaginary unit. The := is 'set delayed', signifying that the result is calculated when the function is called, rather than calculated immediately (which is what = does). The position operator 'xOp' merely returns its argument, multiplied by x. Another way to write these operators would be to give names to their arguments, instead of just making them the # of an anonymous function: pOp[arg_] := \[HBar]/I*D[arg, x] xOp[arg_] := x*arg Now we define the commutator of two operators, acting on a test function: commutator[op1_, op2_, f_] := (op1@op2@f - op2@op1@f)/f The function application operator @ is right-associative, so the terms in this expression are really op1[op2[f]] and op2[op1[f]]. I divide out the test function so it won't appear in the result. Now we try commutator[xOp, pOp, f[x]] // Simplify which returns I \[HBar] as it should. We can also check if the momentum operator commutes with itself commutator[pOp, pOp, f[x]] which returns zero, as expected.
Is the integral of your distribution function from `-\[Infinity]` to `\[Infinity]` equal to 1? That would be the first thing I'd check.
That's sorta what I was hoping to do somehow with Interpolation.
The x's with dots above them are formal symbols and can't take global values because they are Protected. Anyway, the first symbolic ProbabilityDistribution fails because a,b,c,d and a nasty integral. Secondly, when you insert those values you have to make sure the square root is always non-complex over the region. If you do NSolve[-(6.96504 - 6.5608 x) (0.0184983 - x) == 0, x] you find out that 0.0184983 &lt; x &lt; 1.06161 so you need to adjust your range for ProbabilityDistribution from {y, 0, 1.1}. In fact, if you now NIntegrate your big square root thing with the values and the new range, you get a nasty little imaginary component. Therefore I decided to wrap the Sqrt[...] in Re[...] because the imaginary component is tiny and can probably be ignored. Well, I hope I entered all your values correctly - here's a pic of my notebook output http://i.imgur.com/xMXqe2a.png
Thank you so much for your detailed response this helps a lot!
Let's say you have a set of replacement rules after using FindFit: fit = FindFit[dataTable, a*x + b*y + c*z, {a,b,c}, {x,y,z}] You can then turn this back into a regular equation that something like Plot can interpret using the "/." operator: a*x + b*y + c*z /. fit You might also consider saying "/. First[fit]" if returning a list bothers you, and you only want the first solution that FindFit gives. You seem to be working in four dimensions, so I'm not sure what the best method of visualization would be; it's up to you. Something like ContourPlot3D may be useful.
What is the obvious thing to you that you want foo[21] to return? Using either = or := here do the thing that seems obvious to me, return 2a.
As I said, I don't want to transform `m` into a function, because it would depend on too many parameters and make it burdensome to add or remove parameters. Also, my real usecase is more complex than this silly example: think of `m` as a set of differential equations with a lot of symbolic parameters and `foo`as a function which solves them after replacing only some parameters by numeric constants.
So, if I understand it correctly from the picture, you have several curves of the form `yi=fi(x)` and you want a function that takes a value of `x` and gives you back all the `yi`'s? I will start assuming you have formulas for the curves. First, I'll simulate your family of functions: f[i_] := Function[x, x^2 + .1*i] Plot[Through[(f /@ Range[10])[x]], {x, 0, 1}] ==&gt; Plots something like the curves you showed You can enter functions of different forms like this: f1[x_] := 3 x^2 f2[x_] := Cos[x] f3[x_] := Sin[x^2] To evaluate it, use `Through` X = Range[0, 1, .1]; Y = Through[{f1, f2, f3}[X]]; ==&gt; Y[[1]] is {f1[x1], ..., f1[xi]}, Y[[2]] is {f2[x1], ..., f2[xi]} etc Now, if you have discrete data it's more annoying. You need to deal with the often extremely irritating `Interpolation`family of functions. They much prefer if your data is structured on a grid, but I'm not going to get into that. Let me simulate discrete data via the same method as given above: X = Range[0, 1, .1]; Y = Through[{f1, f2, f3}[X]]; Now, construct interpolating polynomials for `X-&gt;Yi`: interpFuncs = Map[ Function[ yi, Interpolation[Transpose[{X, yi}]] ] ] (* Same as interpFuncs = Interpolation[Transpose[{X, #}]] &amp;/@Y *) evalInterp[x_] := Through[interpFuncs[x]] Now, `evalInterp[.5]` will give the interpolation of each curve at .5. `evalInterp[.5][[1]]` is then the interpolation of curve 1 at .5. 
These curves are standard child growth curves used to determine whether the height and weight are normal for that child and how these values develop. The graph is represented as sd-value on y axis, age on the x axis and the curves represent height of child. I have now understood that as I have 3 points x,y and z (curve), this is actually a surface. I should now somehow fit a surface function to my data. As a result I should have this sd = f(age, height) and solve this for age, so I can plot the result in a 2D graph with those curves.
These curves are standard child growth curves used to determine whether the height and weight are normal for that child and how these values develop. The graph is represented as sd-value on y axis, age on the x axis and the curves represent height of child. I have now understood that as I have 3 points x,y and z (curve), this is actually a surface. I should now somehow fit a surface function to my data. As a result I should have this sd = f(age, height) and solve this for age, so I can plot the result in a 2D graph with those curves.
Oh, that's actually a very different problem. What the curves represent are actually *contours* of the surface. You need to reconstruct the surface given several contours. I know how to do this, but I'm in a hurry at the moment so it will have to wait. Check back later and I'll try and edit in an answer. For reference (because it makes the solution more or less complicated, depending) how are the curves defined? Do you have equations or just points? If points, are they evenly spaced in the horizontal direction? 
These curves are generated from points. Thus, I really have x, y and z from which a surface should be constructed. Indeed these are contours. Didn't know that term before. In the data below 120.0 is the height of a child. 1, 2, 3 (not in order here, but you can see there is also 1.1, 1.2 and so on) these are the years (e.g 1.2 years old). The last value (e.g. 18.42) is the standard deviation. X Age Y Standard deviation Z Height Here is a part of the actual data: &gt; {"120.0":{"1":18.42,"2":10.66,"3":6.68,"4":3.97,"5":1.93,"6":0.29, "7":-1.01,"8":-2.07,"9":-2.97,"10":-3.66,"11":-4.17,"12":-4.57, "13":-5.02,"14":-5.74,"15":-6.76,"16":-7.88,"17":-8.76,"18":-9.31, "19":-9.65,"20":-9.88,"1.1":17.36,"1.2":16.38,"1.3":15.45,"1.4":14.59, "1.5":13.79,"1.6":13.06,"1.7":12.39,"1.8":11.78,"1.9":11.2,"2.1":10.17, "2.2":9.71,"2.3":9.27,"2.4":8.86,"2.5":8.47,"2.6":8.09,"2.7":7.72, "2.8":7.37,"2.9":7.02,"3.1":6.36,"3.2":6.05,"3.3":5.75,"3.4":5.47, "3.5":5.19,"3.6":4.93,"3.7":4.68,"3.8":4.43,"3.9":4.2,"4.1":3.74, "4.2":3.53,"4.3":3.31,"4.4":3.11,"4.5":2.9,"4.6":2.7,"4.7":2.5,"4.8":2.31, "4.9":2.12,"5.1":1.75,"5.2":1.58,"5.3":1.4,"5.4":1.23,"5.5":1.07, "5.6":0.91,"5.7":0.75,"5.8":0.59,"5.9":0.44,"6.1":0.15,"6.2":0.01, "6.3":-0.13,"6.4":-0.27,"6.5":-0.4,"6.6":-0.53,"6.7":-0.65,"6.8":-0.77, "6.9":-0.89,"7.1":-1.12,"7.2":-1.24,"7.3":-1.35,"7.4":-1.45,"7.5":-1.56, "7.6":-1.67,"7.7":-1.77,"7.8":-1.87,"7.9":-1.97,"8.1":-2.17,"8.2":-2.27, "8.3":-2.36,"8.4":-2.45,"8.5":-2.55,"8.6":-2.63,"8.7":-2.72,"8.8":-2.8, "8.9":-2.89,"9.1":-3.05,"9.2":-3.12,"9.3":-3.2,"9.4":-3.27,"9.5":-3.34, "9.6":-3.41,"9.7":-3.47,"9.8":-3.53,"9.9":-3.6,"10.1":-3.72,"10.2":-3.77, "10.3":-3.83,"10.4":-3.88,"10.5":-3.93,"10.6":-3.98,"10.7":-4.03, "10.8":-4.08,"10.9":-4.13,"11.1":-4.22,"11.2":-4.26,"11.3":-4.3, "11.4":-4.34,"11.5":-4.38,"11.6":-4.42,"11.7":-4.45,"11.8":-4.49, "11.9":-4.53,"12.1":-4.6,"12.2":-4.64,"12.3":-4.68,"12.4":-4.72, "12.5":-4.77,"12.6":-4.81,"12.7":-4.86,"12.8":-4.91,"12.9":-4.96, "13.1":-5.08,"13.2":-5.14,"13.3":-5.2,"13.4":-5.27,"13.5":-5.34, "13.6":-5.41,"13.7":-5.49,"13.8":-5.57,"13.9":-5.66,"14.1":-5.83, "14.2":-5.93,"14.3":-6.03,"14.4":-6.12,"14.5":-6.23,"14.6":-6.33, "14.7":-6.44,"14.8":-6.54,"14.9":-6.65,"15.1":-6.88,"15.2":-6.99, "15.3":-7.1,"15.4":-7.22,"15.5":-7.33,"15.6":-7.44,"15.7":-7.55, "15.8":-7.66,"15.9":-7.77,"16.1":-7.98,"16.2":-8.08,"16.3":-8.18, "16.4":-8.27,"16.5":-8.36,"16.6":-8.45,"16.7":-8.53,"16.8":-8.61, "16.9":-8.68,"17.1":-8.83,"17.2":-8.89,"17.3":-8.96,"17.4":-9.02, "17.5":-9.07,"17.6":-9.13,"17.7":-9.18,"17.8":-9.23,"17.9":-9.27, "18.1":-9.36,"18.2":-9.4,"18.3":-9.43,"18.4":-9.47,"18.5":-9.51, "18.6":-9.54,"18.7":-9.57,"18.8":-9.6,"18.9":-9.62,"19.1":-9.68, "19.2":-9.7,"19.3":-9.73,"19.4":-9.75,"19.5":-9.77,"19.6":-9.8, "19.7":-9.82,"19.8":-9.84,"19.9":-9.86}}
Seems possible, though I've not tried myself. http://reference.wolfram.com/language/ref/format/GIF.html
Mathematica has extensive and well-written documentation and usage examples for the majority of its functions. To access documentation for a particular function, put the cursor in/on it and press F1. However, knowing which functions are worth studying may not be immediately apparent. I recommend starting with the Introduction and Basic Advice sections of [this answer](http://mathematica.stackexchange.com/questions/18/where-can-i-find-examples-of-good-mathematica-programming-practice/259#259).
Just play around with things; the documentation is *unbelievably* good. If you don't understand something about Mathematica, the documentation will allow you to understand it. If your lack of understanding is more about the *mathematics*, though, you'll have to start elsewhere.
Answering my own question sorta: If the original images came from a video (say from a video capture feed from a Astrophotography camera, and you want to do image stacking): You can import the video object and split it up into frames...pretty nifty. Example: g1 = Import["ExampleData/clip.mov", {"Frames", All}]; 
Rather than paste images one by one into the notebook, put them in a specific directory, and then you can do Import /@ FileNames["/path/to/images/*.png"] to create a list containing all of them at once (replace png with jpg or whatever format you're dealing with). Note: If you're on Windows, you'll need to escape your backslashes in the path like so (change drive letter as needed): Import /@ FileNames["C:\\path\\to\\images\\*.png"]
Define a function that takes input cityA and cityB, and outputs the graph you want. comparisonGraph[cityA_,cityB]:= WolframAlpha["moving from "&lt;&gt;cityA&lt;&gt;" to "&lt;&gt;cityB&lt;&gt;" salary $42,500", IncludePods -&gt; "Input", AppearanceElements -&gt; {"Pods"}, TimeConstraint -&gt; {30, Automatic, Automatic, Automatic}, PodStates -&gt; {"PriceComparisons__Show prices", "EquivalentSalary__Show history"}] Now you want to execute this function for many values of cityA and cityB. Make a list like this: cityList = {"Seattle","Los Angeles","Atlanta","Boston"}; (* etc *) Now use a table cityTable = Table[comparisonGraph[cityA,cityB],{cityA,cityList},{cityB,cityList}] This will give the output you asked for. You can turn it into a grid with Grid[cityTable]
Hmm I'm not sure. I am not sure how to go about doing that actually. I will try investigating this tomorrow and get back to you. Thanks for the reply though!
[How to open a command prompt in Windows 8](http://pcsupport.about.com/od/windows-8/a/command-prompt-windows-8.htm)
This is fantastic! Actually having somthing to work with let me realize my original WolframAlpha query wasn't quite what I wanted. My final code: costofliving[city_] := WolframAlpha[ "cost of living index " &lt;&gt; city, {{"Result", 1}, "ComputableData"}, TimeConstraint -&gt; {60, Automatic, Automatic, Automatic}] cityTable = Table[costofliving[city], {city, cityList}] Grid[cityTable] cityTable[[All, 1, 1]] Export["G:\\Cost of Living\\CoL_index.txt", cityTable[[All, 1, 1]], "Table"]; Export["G:\\Cost of Living\\cities.txt", cityList, "Table"]; I realize that most of this isn't necessary but I was checking myself every step, making sure I understood the output of each cell. I probably could have stayed in Mathematica for the rest of my calculations but I'm far more familiar with structures and matrices in MATLAB. That is why I exported to .txt files.
Mathematica's symbolic power, as well as its Plot and Manipulate commands, make it an excellent tool for teaching algebra and functions. To demonstrate how plot of a * sin(b * x) changes for different values of a and b? Manipulate[Plot[a*Sin[b*x], {x, 0, 10}, PlotRange -&gt; {-5, 5}], {a, 0, 5, 0.1}, {b, 0, 5, 0.1}] You can't do that so easily with chalk. There are other languages which are better for teaching programming. Most of them cost nothing.
Well, this is not the way to do it. `Do` and `AppendTo` to create lists are not the right way. Beside this, your assumptions how anonymous parameters work with `Nest` is not correct. Look at this example which shows what goes wrong in your `Nest` call Nest[{#1, #2, #3} &amp;, {1, 2, 3}, 1] Your `FirstGen` is supplied as only *one* and as the *first* anonymous parameter. What you want is Nest[# &amp;, {1, 2, 3}, 1] or (only to make it clear what happens) Nest[{#[[1]], #[[2]], #[[3]]} &amp;, {1, 2, 3}, 1] If you want to rest of your code fixed, then please submit a minimal, *working* example where you strip everything unnecessary off.
I didn't know the iterator in Table would work that way. Do you happen to know how to Nest the whole thing, using Firstgen as the initial input?
You were right, I thought I had to use Do because I could never get table to work the way I thought it should. Now I know how to use the iterator in Table. Still working on Nest though. Thanks for the help. 
I've never used the `Nest[]` function before, sorry :-/. Luckily the Mathematica help is pretty superb. It sounds like you're trying to do some recursion stuff, is that correct? Use `Firstgen` as your initial state, perform some actions on it and get result `Secondgen`. Then you want to perform those same actions on `Secondgen` to get `Thirdgen` and so on? If that's the case, you might be able to do the following. First, define a new function for your transformation. In my example, I do some simple arithmetic for each component of the vector. After the function is defined, you can nest it. Firstgen={{1, 1, 1}, {2, 2, 2}, {3, 3, 3}, {4, 4, 4}}; action[vectorList_] := Table[{i[[1]] * 5, i[[2]] + 3, i[[3]] - 1 }, {i, vectorList}]; Nest[action, Firstgen, 2] Out: {{25, 7, -1}, {50, 8, 0}, {75, 9, 1}, {100, 10, 2}} Nest[action, Firstgen, 3] == action[action[action[Firstgen]]] Out: True All you have to do is modify the `action` function to fit your needs. If you use `NestList[]` instead, you'll get to look at every output from `0` to `n`: NestList[action, Firstgen, 2] Out: {{{1, 1, 1}, {2, 2, 2}, {3, 3, 3}, {4, 4, 4}}, # Nest[action, Firstgen, 0] == Firstgen {{5, 4, 0}, {10, 5, 1}, {15, 6, 2}, {20, 7, 3}}, # Nest[action, Firstgen, 1] {{25, 7, -1}, {50, 8, 0}, {75, 9, 1}, {100, 10, 2}}} # Nest[action, Firstgen, 2] (and sorry for using Python line comments) 
In general, never use the "%" reference notation for anything other than quick calculations. Instead, assign your solution to a new function: soln[t_] = u[t] /. First@NDSolve[{u''[t] == (omega 2 a/b) Cos[u[t] - omega t] - (g/b) Sin[u[t]], u[0] == Pi/4, u'[0] == 0}, u, {t, 0, 100}] Animate[Graphics[{Point[{a Cos[omega x] + b Sin[soln[x]], a Sin[omega x] - b Cos[soln[x]]}], Line[{{a Cos[omega x], a Sin[omega x]}, {a Cos[omega x] + b Sin[soln[x]], a Sin[omega x] - b Cos[soln[x]]}}], Circle[]}, Axes -&gt; True, PlotRange -&gt; {{-3, 3}, {-3, 3}}], {x, 0, 100}, AnimationRate -&gt; 1]
So your external function is called with 3 numerical arguments and returns a single number (the energy you try to minimize), yes? Furthermore, what do you use for minimization on the *Mathematica* side?
Your solution works. A person familiar with Mathematica might write: (# - R)&amp; /@ M Which in slightly more readable form is equivalent to Function[v,v-R] ~Map~ M
It should correspond to the actual dc value. So really belongs to neither side
I think the DC is the first element in the list (the docs call it the "zero frequency")? I made a mistake it's actually even numbered lists that come out with this odd-man-out center element between the conjugate pairs , which makes sense since the conjugate pairs are odd numbered all together with the zero frequency since it is not given as a conjugate (i.e. not repeated in the second half of the list). It makes sense just as a property of numbers there needs to be a pivot for an odd length symmetrical list of conjugate pairs, I'm just puzzled as to what it represents frequency wise. It is not a conjugate of the zero frequency (which would be the zero frequency again), but it does seem to be a real number in random real valued lists I've tested (so it does seem to represent a zero freq/DC of some kind ) but that raises another question all together as to why even numbered lists have a second distinct zero frequency in the conjugates whereas odd number lists do not? Thank you for the input. 
Following Mathematica's convention of numbering list elements starting with 1, its i'th element corresponds to frequency: freq[i] == (i-1) * baseFrequency. where baseFrequency is equal to 1 / (time of all samples), which is 1 / (numberOfSamples / sampleFrequency). So, freq[i] == (i-1) * sampleFrequency / numberOfSamples So that is part of your answer, you can just put in the number and get an answer. But to really understand it, you need to go a bit deeper. A discrete signal (i.e., a signal sampled at discrete, equally spaced times) exhibits "aliasing". This means that sinoid signals at frequency f1 and frequency f2 that have identical amplitude and phase are precisely identical, if f1 and f2 are separated by a multiple of the sample frequency (read that a few times, slowly -- it is VERY central to any understanding of the DFT results). Try, for example, this: f1[t_] := Sin[440*2*Pi*t] f2[t_] := Sin[(48000*17 + 440)*2*Pi*t] s1 = N[Table[f1[i/48000], {i, 0, 10}]] s2 = N[Table[f2[i/48000], {i, 0, 10}]] Aliasing means that the calculation given above is a simplified version of what is really going on: freq[i] == (i-1) * sampleFrequency / numberOfSamples + k * sampleFrequency This is true for *any* integer value of k. So the i'th element in the FFT actually corresponds to an infinite number of frequencies in the source signal that was sampled. That's what aliasing is: different frequencies in the source signal all look indistinguishable in the sampled signal. There is a lot more to this. I highly recommend the following book to gain a deep understanding of what the FFT does, and how you should interpret its results: http://www.amazon.com/Understanding-Digital-Signal-Processing-3rd/dp/0137027419 That book will give another important piece of the puzzle: what the rightmost elements in the FFT result really mean. Rather than interpreting them as "high" frequencies, it is much more useful to interpret them as negative frequencies. When looked at them in this way, the second element and the last element have the same, but opposite-signed frequencies, as have the third and next-to-last element, and so on. If you grasp that, it becomes obvious why a real valued signal gets this conjugated flipped version of the spectrum. 
Something quick and dirty (gives some errors, but plots anyway): x[t_] := Cos[t] y[t_] := Sin[t] xi[tt_] := x[t] - x'[t]/Sqrt[x'[t]^2 + y'[t]^2] NIntegrate[Sqrt[x'[t]^2 + y'[t]^2], {t, 0, tt}]; yi[tt_] := y[t] - y'[t]/Sqrt[x'[t]^2 + y'[t]^2] NIntegrate[Sqrt[x'[t]^2 + y'[t]^2], {t, 0, tt}]; ParametricPlot[{{x[t], y[t]}, {xi[t], yi[t]}}, {t, 0, 2 \[Pi]}]
 h[t_]:= Sin[2\[Pi] g[t]t] (* but the frequency keeps going up and up*); Are you sure that second "t" should be there? [Here](http://i.imgur.com/s2VHCRm.png) is the output I get. With that t, your frequency should increase linearly with time.
I thought the same initially, but soon realized I was wrong. [This](http://imgur.com/IS81JsL) is what I got. EDIT: Oh, nvm. I figured out that I made a mistake here... As you see in the image,`Sin[a]` graph is significantly different from `Sin[b]`, where `a[t_] := If[ EvenQ@Floor[t/Pi], 2, 1 ]` and `b[t_] := 1.5 + .5 Sin[t]`. Comparing `Sin[b]` and `Sin[b t]` gave me the right idea.
You have no separation of scales. Your 'carrier frequency' ranges between 1 and 2, but you are 'modulating' this at a 'modulation frequency' of 1. If you want to see your expected behaviour, shoot for at least a factor of 10 between the carrier and modulation frequencies. For example, let wmod=.05, and then write f[t_]:= (0.5+0.5Sin[2\[Pi] wmod t]); 
The solution of @duetosymmetry is a good way and should be preferred. Nevertheless, let me give a completely different approach that works by creating a temporary function `f` which looks at each element once and sums up the times. After that, the same function `f` is used on the tube names to create the final (ordered) output: func[d_] := Module[{f}, f[n_, t_] := f[n] += t; f[_] := 0; f @@@ d; {#, f[#]} &amp; /@ Union[d[[All, 1]]] ] The result of `func[data1]` is then {{Central Line,21. hours},{Circle Line,32. hours},{District Line,21. hours}, {Metropolitan Line,5.4 hours},{Northern Line,16.2 hours},{Victoria Line,37. hours}} The key to *remembering* the values in `f` is the line `f[...] := f[n] += t` which is called memoization.
Very nice, thank you! Check out this neat little recursive pattern matching solution my lecturer showed: func[a___, {b_, c__}, d___, {b_, e__}, f___] := func[a, {b, c + e}, d, f]; 
That's definitely easier to write. The tradeoff is that it will be slower, because 1) the pattern is computationally expensive to match, and 2) it will have to re-scan and re-apply the pattern many times before no more patterns match (i.e. it's done).
Not the original guy but the /. notation is used as a replacement rule. So anything on the left of the /. will be replaced by the given association on the right. For example: a /. {a-&gt;b} will result in "b" being returned. Without being able to see his answer I can't say what he was trying to do with the "First@" but my guess is that he was extracting the function from the result and then using a replacement to get the interpolation function based on the association. So assuming he had x/.First@result then what will happen is the first set of solutions will be taken and then the function corresponding to "x" will be extracted and used rather than the full solution list. See: ref/ReplaceAll and ref/First 
Holy shit
Do you know how I can restrict n to only integer values? Also, I get an error saying the Plot function called 1 argument when two were expected. Any idea what's going on?
ahh right then you might be in the same boat as me. When I connect to an external monitor, the GUI runs extremely slow and eventually crashes my system. There's a bug for this and it isn't properly fixed even in v10.01 http://mathematica.stackexchange.com/questions/54593/mathematica-10-formatting-notebook-contents . It could be related to switchable/hybrid graphics systems. One option is to upgrade your graphics adapter if you can. If this problem is happening on your primary display - perhaps try connecting an external display. If your graphics driver was recently updated you might want to roll back to an earlier version. That's all I can think of doing. If you need plots urgently and nothing else works, you can still export plots using the command line by doing this for example: Export[ "C:/Users/myusername/Desktop/plot.png", Plot[x^2 , {x,0,1}, ImageSize-&gt;512] ]
If you are still stuck with slowness, most of List processing functions can be wrapped into [`Parallelize[]`](http://reference.wolfram.com/language/ref/Parallelize.html) Sometimes it was giving me 15x speed increase even on an old 2 cores Athlon.
As to why you can't use symbolic ICs,`NDSolve` by definition *must* have all numeric values... it doesn't make sense to try to solve a symbolic system numerically. `DSolve` can be used with symbolic ICs if the system is possible to solve analytically. I'm not sure really how `Module` or `NumericQ` would help here; they can be used to fix related errors, but not the one you're describing. However, I'm pretty sure I can help you out if you explain a little more what you want to do. For instance, post what you're trying to enter now with `NDSolve` that you expect to work, but is not.
In general how would you optimize a constraint in an ODE, assuming that an analytic solution can't be found? 
It does but the time of flight is a transcendental equation and needs to be solved numerically (you can get a decent approximation with perturbation assuming slow v). everything else is 'yes'
What f[x] are you trying to run? Some functions are much faster than others.
also I think something else is going weird because the optimal theta is independent of v. Take my code with a pinch of salt because I don't have the mechanics knowledge. /u/Bloaf 's way of doing it looks most sensible
Just because the time of flight is unknown, that doesn't mean you can't use the analytic solution. You can get the time of flight from the analytic solution of y(t) by numerically minimizing |y(t)| subject to the constraint t&gt;0, which you can then plug into x(t) (or by root finding, which is what I think you were going for). However, you *don't* have to use `NDSolve`. I've been fiddling with it now for a bit too long, so I'm going to stop. The following code should give you an idea of what to do, though I give the caveat that it's not working quite right for me so use it more as a guide: system = { x''[t] == -k*x'[t], y''[t] == -k*y'[t] - g, x[0] == 0., y[0] == 0., x'[0] == v*Cos[theta], y'[0] == v*Sin[theta] }; parameters = { k -&gt; 40., v -&gt; 55., g -&gt; 9.81 }; xfinal[th_] := Module[{xt, yt, tmax}, {xt, yt} = {x, y} /. Flatten@DSolve[ system /. parameters, {x, y}, {t, 0, 10} ]; tmax = NArgMin[ {Abs[yt[tp] /. parameters /. theta -&gt; th] &amp;[tp], tp &gt; 0}, tp ]; Return[xt[tmax] /. parameters /. theta -&gt; th] ] NArgMax[{xfinal[theta], theta &gt; 0, theta &lt; Pi/2.}, theta] 
First, you should paste valid Mathematica code. Second, you should indent that code by 4 spaces, and it will show up in a better format.
Thanks, I updated it with some spaces, it should look a little better now.
I think it's just uncomfortable with replacing i^n with (-1)^(n/2) . Probably something you have to do manually. Edit: or just replace *n* with *2m* does convince it. My code: FullSimplify[FullSimplify[(2 I^n E^(-a k) (-1 + E^(a k)) n \[Pi] S Sin[(n \[Pi] x)/a])/(Ð (a^2 k^2 + n^2 \[Pi]^2) (1/L^2 + (n^2 \[Pi]^2)/a^2)) /.n -&gt; 2 m, {Element[n/2, Integers], n &gt; 0}] /. m -&gt; n/2] Basically what I did was tell it to FullSimplify (instead of Simplify), with the replacement n-&gt;2m, so it will kill the imaginary unit, and then FullSimplified with the replacement m-&gt;n/2
Oh wow! Thanks, it looks like it works just the way i wanted!! Awesome, thank you so much! : D
A good point, and this sort of thing is often encountered in mathematica. I guess it's not much different from what happens when you plug in an integral that it just can't evaluate. Nonetheless, I think it's clear that this is a slightly more nontrivial quine.
http://i.imgur.com/RPimYh8.png Also, if you have mathematica 10+ you should be able to do TimeSeriesResample[TimeSeries[data],sampleInterval] and it will resample irregular TS too. http://www.wolfram.com/mathematica/new-in-10/time-series/resample-time-series.html I seriously recommend getting v10 if haven't already. Interpolation seems to be asked about a lot here and v10 offers a great deal more control over timeseries data.
Wow, awesome
Try Manipulate[t, Evaluate[r] ] That will work but it's *RISKY* because let's imagine you have an assignment t=3 somewhere in your program, then r changes from {t, 0, 10} to {3, 0, 10} and Manipulate will complain. It's far better to know your iterator variable in advance and build the Manipulate in the normal way. http://stackoverflow.com/questions/7138827/define-control-as-variable-in-mathematica
Try setting the items individually: start = 0; end = 10; Manipulate[t, {t, start, end}] It's because MM is looking for which variable to use, in your case ``t``. Then in your NDSolve: solutions = NDSolve[Join[eqns, init] /. parameters, variables, {start, end}];
meta: How is this post related to mathematica? the linked page contains neither the phrase "mathematica" nor "wolfram".
Oh hey, a very similar question was asked only a few posts down the page http://www.reddit.com/r/Mathematica/comments/2xwv0p/optimizing_initial_condition_ndsolve/
yea I still can't get it. NDSolve just won't cooperate.
Yea that's basically what I was trying in the second method, revised it's: Manipulate[ Module[{sol = NDSolve[{lag == 0, lagl == 0, theta[0] == t0, theta'[0] == 0, l[0] == a, l'[0] == 0}, {theta, l}, {t, 0, 100}, MaxSteps -&gt; 500000]}, ParametricPlot[Evaluate[{theta, l} /. sol], {t, 0, 10}]], {k, 0, 5}] Which still doesn't work. Do I need to write theta and l as a function of k and t and then give NDSolve a rectangular domain of k,0,x and t,0,y?
Does it work if you remove the manipulate and input a value for k?
yeah.
I ended up getting it: traj[k_, a_, t0_, m_, T_] := Module[{nsol, graph, pr}, nsol = NDSolve[{l[t] theta''[t] == - Sin[theta[t]] - 2 l'[t] theta'[t], l''[t] == Cos[theta[t]] - k (l[t] - a), l[0] == a, l'[0] == 0, theta[0] == t0, theta'[0] == 0}, {l, theta}, {t, 0, T}]; graph = ParametricPlot[ Evaluate[ l[t] {Cos[theta[t] - Pi/2], Sin[theta[t] - Pi/2]} /. Evaluate[nsol[[1]]]], {t, Evaluate[nsol[[1, 1, 2, 1, 1, 1]]], Evaluate[nsol[[1, 1, 2, 1, 1, 2]]]}]; pr = Max[Abs[FullOptions[graph, PlotRange]]]; Show[graph, PlotRange -&gt; Max[pr, a], ImageSize -&gt; {400, 400}]] Manipulate[ traj[k, a, t0, m, 50], {k, 1, 5}, {a, 1, 10}, {m, .1, 10}, {t0, .1, Pi}]
Sorry not sure what you mean. I know it has solutions. I can see them [here](http://www.wolframalpha.com/input/?i=NSolve%5BExp%5Bi*k*2*0.01%5D%2F369.6%3D%3D%281%2B0.0095%281-BesselJ%5B0%2Ck*0.003%5D%29%2Fk%2F0.003+%2B+I*BesselK%5B1%2C2*k*0.003%5D%2F2%2Fk%5E2%29%2F%28-1%2B0.0095%281-BesselJ%5B0%2Ck*0.003%5D%29%2Fk%2F0.003+%2B+I*BesselK%5B1%2C2*k*0.003%5D%2F2%2Fk%5E2%29%2Ck%5D). Why is Mathematica not finding them? 
Hm. So, then what is /@? I've always used f/@ expression for map. Is that the same thing? Thx.
Alright. That seems right. I can't find a difference between them either. I appreciate the answer.
This page explains the syntax 'a@b': http://reference.wolfram.com/language/tutorial/OperatorInputForms.html I had never seen it before. It is definitely something different than Map.
&gt;De gustibus non est disputandum. There is no accounting for tastes...
Not as quine related but this is kinda scary. After this post I discovered definition can be used to self modify functions in some pretty disturbing and hacky ways. http://i.imgur.com/IVQ8ule.png
Thanks, a lot of stuff I didn't know before. Regarding the CirclePlus, how can I make it left/right associative so Ican just type a+b+c ?
Maybe Table[ToExpression["q"&lt;&gt;ToString[i]&lt;&gt;"[t]"], {i, 1, 6}]
Represent the index as a function parameter: q[i_,t_]:= ...
I'm curious is there a reason people are downvoting this qustion? I just want to better understand the etiquette of this subreddit.
I wouldn't worry about it. We don't have much traffic here, so downvotes can't really suppress things. Your post is a perfectly good one to bring here.
Gah, no. String manipulation is always bad. You have an expression tree at hand which you can manipulate, why would you want to bring string manipulation into it?
Why don't you use a simple table? Table[F[i] + F[j] == G[i] - G[j], {i, 3}, {j, 3}] 
If you really want the rules then maybe this: clear[i, j]; rules = Flatten[Table[{Rule[i,m], Rule[j,n]}, {m,4},{n,4}], 1]
I recommend visiting http://demonstrations.wolfram.com/ and think about how you'd implement some of those demonstrations. You can download the notebooks as well (unhiding any initialization tabs). http://demonstrations.wolfram.com/topic.html?topic=Mechanics&amp;limit=20 I use Mathematica for machine learning, statistics, computer vision and image processing. I stated out four years ago writing very procedural code with lots of loops and tables - my code now makes use of the functional aspects of the language (anonymous functions, Map / Apply, Module etc). It has made my code more efficient and more compact, not to mention easier to debug. Pure functions and good scoping means fewer strange side effects and more predictability. Focus on being efficient and learning to use as much built in functionality as possible. At this stage it will be useful for you to learn everything there is to know about DSolve, NDSolve and calculus. Here's a great wolfram blog post on a projectile problem http://blog.wolfram.com/2010/09/27/do-computers-dumb-down-math-education/ Finally, have a ramble around the wolfram documentation looking for something to do. I discovered many fast ways of doing things and cool, well written examples in there - esp. the Neat Examples and Applications sections. The documentation is excellent (even if there are still many undocumented functions) and I've never had to pick up a book and only occasionally visit mathematica stack-exchange http://reference.wolfram.com/language/ http://mathematica.stackexchange.com/
100,000x slower sounds a bit much. If you're super careful about exact vs. numerical evaluation, using built in functions whenever possible (instead of rolling your own) you should be similar to other high level languages. There's also Compile, NETLink calls to functions in DLLs and GPU stuff but you have to think a lot about the types. Posting this for anyone who reads http://blog.wolfram.com/2011/12/07/10-tips-for-writing-fast-mathematica-code/
Making a Mandelbrot zoomer is a nice exercise.
Thanks, good ideas.
Haha definitely going to do this. If only to impress nerd friends. 
Well, I'd be inclined to agree since I've written image segmentation code in mathematica and feature extraction has been awfully slow (although I've never encountered 100,000x slower before until today). I don't see their product as a language in the same way as I'd look at C or Python or whatever - more as a suite of tools, so Compile (with CompilationTarget-&gt;"C") and NETLink are forgivable. I get your point about staying within Mathematica as well - as soon as you start wandering out to implement your own data structures things can get much slower. I guess the best way to view Mathematica is as a monolithic collection of built-in functions. They can only be stiched together so much before the overheads in Mathematica's evaluation strategy catch up with you. I wouldn't say trying to optimize mathematica code was a total waste of time though (unless you didn't need mathematica in the first place) - if I'm giving a demonstration and I have a Manipulate[...] in there and need it to change smoothly I'll need to optimize. Switching out to some other language might not be an option because I want to use their plotting functions or some complex mathematical functions I haven't got time to re-implement myself in another language.
You should really post your code to be critiqued. Here's something I think should work for you. If data is in the format data={{x1,y1},{x2,y2},{x3,y3}} then the code to find local extrema is ydata = Transpose[data][[2]] yextrema = Table[((ydata[[i]] &gt; ydata[[i - 1]]) &amp;&amp; (ydata[[i]] &gt;ydata[[i + 1]])) || ((ydata[[i]] &lt; ydata[[i - 1]]) &amp;&amp; (ydata[[i]] &lt; ydata[[i + 1]])), {i, 2, Length[ydata] - 1}] Pick[data[[2 ;; -2]], yextrema] Basically, for each y-value other than the first and last, check if it is either less than both of the ones around it or greater than both of the ones around it. For all the ones that are, pick the {x,y} pair from the data set corresponding to those y-values. Note this code only works if the data is in x-coordinate order. If it's out of order, you can just do data=Sort[data] before everything else.
Make an interpolating function f and use FindRoot to find interpolated abscissas x where f'[x] goes through zero. Check the sign of the second derivative f''[x] to ensure that you are finding local maxima rather than local minima.
Why not just yextrema = Transpose[data][[1,#]]&amp; /@ Select[Range[2, Length[data] - 1, ydata[[#]] &gt; ydata[[# + 1]] &amp;&amp; ydata[[#]] &gt; ydata[[# - 1]] &amp; ]
You'll just find maxima that way, not minima. Also, OP said they were trying to use Pick, so I wanted to show them how to properly go about using it. Otherwise, your version is fine too. I was just trying to make it easier for OP to understand. 
The terms are related by a_n = Sqrt[2+a_n-1]. So you want something like NestList[Sqrt[2+#]&amp;,Sqrt[2],5] [Here at wolfram alpha.](https://www.wolframalpha.com/input/?i=Nestlist%5B%28Sqrt%5B2%2B%23%5D%29%26%2CSqrt%5B2%5D%2C5%5D) Or in longer form, f[x_]:=Sqrt[2+x]; NestList[f,Sqrt[2],5]
I know. I was giving you another method so you can check your answer.
you can learn about the color channels and how images and video sequences are put toghther. Then you can apply derivative filters to see how they work. Creating 3D images, parsing 3D images from video... It all helped me learn the programmatic and graphing aspects of Mathematica. I think a great thing to do is to find a good Mathematica demo you like on youtube and follow it..easy to learn it that way than just rote memorizing functions, etc. (at least for me.)
You can plot a collection of functions by passing a *list* of functions as the first argument (to both Plot[] and Plot3D[]). So, for what you want to do, f1[x_, y_] := 15 (1 + 10 x) y^10 f2[x_, y_] := 15 y^10 (x + Log[y] + 10 x Log[y]) f3[x_, y_] := -((x + Log[y])/(x*Log[y])) Plot3D[Evaluate[{f1[x,y],f2[x,y],f3[x,y]}],{x,0,2},{y,0,1}] Or, to be just a little fancy, Plot3D[Evaluate@Through[{f1,f2,f3}[x,y]],{x,0,2},{y,0,1}] EDIT: The code above will do what you *described*, but there's a much better way to do what you *want*. By playing with the RegionFunction argument of Plot3D, you can exclude regions where one surface dips below another, a la Show[ Plot3D[f3[x, y], {x, 0, 2}, {y, 0, 1}, PlotStyle -&gt; {Blue, Opacity[0.2]}, Mesh -&gt; None], Plot3D[f1[x, y], {x, 0, 2}, {y, 0, 1}, RegionFunction -&gt; Function[{x, y, z}, z &gt; f3[x, y]], PlotStyle -&gt; Opacity[1], Mesh -&gt; None ] ] which will give something akin to [this](http://i.imgur.com/RCnUolc.png) for various combinations of your surfaces (f1 &amp; f3, f2 &amp; f3, respectively).
you're a gentleman and a scholar. Thanks so much! 
You're welcome! I have so much fun coming up with cool ways to visualize things in Mathematica - I'm glad I could help! :D
One thing: People will presumably downvote this, but seriously, you are a high-school student, don't spend your (or your parents') money on it, just get an illegal version. Consider this: you learn how to use the software as a student; later when you join the workforce you will tell your boss to buy the software you already know how to use, and everybody is better off. Ok, the student edition is cheaper, but a cost of 0 would be better for the society. This applies to all kind of professional software tools, by the way. There are also open-source alternatives, though there is no real drop-in replacement. The closest one is maybe [SAGE](http://www.sagemath.org/) - it also has a cloud version. Another thing: Mathematica is a very useful tool, however I see the danger of a student relying it too much, and never properly learn/practice the underlying mathematics. So I would recommend against using it as a calculus homework aid, it kind of nullifies the point of homework. Also quite often you have to "help" Mathematica to get usable results - again you won't be able to do that without proper understanding of the underlying principles (and, unfortunately, without some understanding of how Mathematica itself works...)
I just realized that I already have access to Mathematica through the Raspberry Pi. But thanks anyway. :)
Raspberry Pi Mathematica is something I don't fully understand. If there is one thing Mathematica is not, that's being fast. Actually it's horribly slow even on a very-high-end PC, so I cannot imagine how that works on a very a limited Pi (I have a Pi too, and I started it once as a test - it looked borderline unusable without even trying anything more complex than 2+2) 
Mathematica is perfectly usable on the Raspberry Pi 2.
Well, the fact that you didn't find it useful *for a particular task*, doesn't make it useless in general (I guess for example a shovel would also appear useless for your PhD? In any case it seems you managed to finish that PhD even using Mathematica...) I personally find it useful for mathematical experimentation, and for cross-checking complex computations. Sometimes it is a pain in ass, yes. So are the competitors (Maple, SAGE, etc), just in different ways. I also can't stand the programming part. Does that make Mathematica useless? I don't thinks so.
The licence is ridiculous. You can only install on one computer. You can't change that computer without contacting Wolfram and getting permission (which also means that if your hardware on your computer changes significantly, or even the OS, you need to go back to Wolfram support). Oh, and if you purchase the student version you need to pay to upgrade to the full version once you stop being a student. I could live with the last requirement if I were free to install it on all my computers, but the restriction is a deal-breaker — it's no wonder that things like this are widely pirated. Edit: And because I didn't explicitly state it, I don't think it's a good idea to buy, *especially* for a high school student.
What's the problem with buying it? Also, with the web only edition, would the installation problems be a non-issue?
The new 1GB Raspberry Pi 2.
I think this has to do with the fact that you're inputting the "natural language" input to Mathematica by hitting = once (notice you have the = in a box), but really you just want to input to the standard Mathematica input. When I use the standard input and plot the same thing, I get a very different result, seen here: [here](http://i.imgur.com/EkRB9cg.png). Maybe the natural language input is getting confused somehow. 
Thanks, I was able to figure out how to plot my functions after some trial and error using the standard input. 
As a post-doctoral researcher in theoretical physics I use every single day... However I do feel that it is severely overpriced... So I think that you should really think twice about buying a license... I do feel that it is a wonderful tool though... 
Before you buy anything double check with your school, they might have an agreement with Wolfram which allows students to use Mathematica for not cost.
Looks like you actually can't in Maple, unless I'm mistaken. I'm pretty new to Mathematica -- can you point me in the right direction in terms of where I can find help on this? 
huge help -- thanks!
Yes, You might want to familiarize yourself with tensors http://reference.wolfram.com/language/guide/SymbolicTensors.html but it requires specifying your assumptions first. I'm not sure how complete the simplification rules are because some of this seems a bit basic. http://www.wolfram.com/mathematica/new-in-9/built-in-symbolic-tensors/derive-and-verify-vector-identities.html http://mathematica.stackexchange.com/questions/3242/can-mathematica-do-symbolic-linear-algebra
Excellent -- thanks!
There are many ways of going about this. If you have an inequality like this you should use Reduce[ f[x] &lt; 6 ]. http://reference.wolfram.com/language/tutorial/TheRepresentationOfSolutionSets.html There's FindInstance[...] but you have to be specific about the domain and constraints otherwise it will take an eternity searching or return nothing. Also, SolveAlways[...] finds parameters that make equations valid https://reference.wolfram.com/language/ref/SolveAlways.html?q=SolveAlways
A little bit late but I hope this helps. You don't need to buy it because probably the [Wolfram programming cloud](http://www.wolfram.com/programming-cloud/) is enough for your and it's free.
I need to start trying to think in a way where the use of that becomes obvious. I was playing around with it once, and saw how it could be useful, but it seems like I need to expand by programming perspective to more readily recognize when to use it. 
When I first started, it took me a while to appreciate how powerful transformation rules are, that is before even considering pattern matching. Consider this example of how Mathematica represents JSON as a set of nested rules: A JSON object is represented as a list of rewrite rules, and we can extract values merely by applying that 'list of rules' to the name. "score" /. {"name" -&gt; "player1", "score" -&gt; 1337} 1337 Here's a larger example of filtering and projecting, where we extract the names of players exceeding a certain score. **example.json:** {"leaderboard" : [ {"name" : "player1", "score" : 1337}, {"name" : "player2", "score" : 10}, {"name" : "player3", "score" : 987}, {"name" : "player4", "score" : 789} ]} **code:** json = Import["~/Desktop/example.json"] {"leaderboard" -&gt; { {"name" -&gt; "player1", "score" -&gt; 1337}, {"name" -&gt; "player2", "score" -&gt; 10}, {"name" -&gt; "player3", "score" -&gt; 987}, {"name" -&gt; "player4", "score" -&gt; 789}}} "name" /. Select["leaderboard" /. json , ("score" /. #) &gt; 900 &amp;] {"player1", "player3"} 
() are as in usual math. [] are around function arguments. {} are around vectors or matricies. Almost everything else is a function. Module is roughly function with local variables and code, the last expression in it is the result. Google Mathematica functionname to get the online documentation for functionname. Piecewise is roughly the switch or which from other languages. Table builds vectors or matricies. That may be where you want to concentrate. vector[[n]] extracts the n'th item. Subscripts start at 1, NOT 0. matrix[[i,j]] extracts an item from the i'th row and j'th column of the matrix. That should get you started.
For a long time, I didn't take advantage of the `Compile` and `CompilePrint` commands. Compiling key pieces of code to MVM bytecode or C can easily result in an order of magnitude increase in speed. `CompilePrint` allows you to see if your compiled code contains references back to the kernel (calls to `MainEvaluate`), the elimination of which increases speed.
I am starting with a function of more than one variable, say two (x,y). I would like to minimize the maximum of the function in the following sense: Find the maximum of f(x,y) over all y in the domain as a function of x, then minimize that over all x. In short, find the x which minimizes the maximum of f(x,y) over y.
There are so many little things I could find. I used this one (from the reference for Sequence) recently {a, b, F[x, y], G[w], F[z, y]} /. F -&gt; Sequence {a, b, x, y, G[w], z, y} Useful for extracting arguments out of unevaluated functions.
I think you need to ask a more specific question, but it seems like you want to plot the resonance curve. To do that you're going use NDSolve to numerically solve your differential equation. Find the amplitude of your solution and store that in an array. Repeat the above process iterating over a range of driving frequencies. Once you've done this you can plot the amplitude response vs the driving frequency. You should get a curve that looks like this http://i.stack.imgur.com/NNPJz.png.
Sure thing; I'll upload when I get home (within the hour).
Thanks I actually got it just a few hours ago!
You might want to start with something like this: ParametricPlot[{2 y^2 + 3 y + 1, y}, {y, -5, 5}] You might want to tweak the PlotRange option on that though, since it comes out a little bit stretched. 
Oh perfect, thanks a lot ! :)
I think PlotRange can be used in the Show command. You'll need to give it predefined ranges though.
Just because you *can* do it, `Rotate[Plot[2 (-x)^2 + 3 (-x) + 1, {x, -5, 5}], -\[Pi]/2]` :P
Yes, the way you do it: First compute the Differences[..] of the list. There are exact linear trends in (integer) data when there are runs of the same number in the differences - or similarly when there are runs of zeros in the second differences. Here's my attempt: http://i.imgur.com/Sm2YLeX.png
If you want to cheat just type the sequence into https://oeis.org/ EDIT: oh I didn't realise this was /r/Mathematica 
If you can construct a small simple reasonable example that demonstrates clearly unreasonable behavior and you can gently and politely not do anything to offend anyone connected with Wolfram when you present this then you can have some chance of getting a problem corrected a year from now. For example, long before parallel anything a run-away calculation could easily not let you get control. Simple examples were politely presented and it was claimed that this had been fixed. Then more examples were politely presented and it is claimed that these should be fixed soon. If you can then politely show even more examples then maybe someone will look at and fix those. But that isn't going to solve your problem tomorrow. Different subject: Have you tried using TimeConstrained? I don't know that would work with parallel constructs, but it would be interesting to know.
I wrote this some time ago, should suit you https://janhermann.cz/blog/prg/2014/08/18/mathematica-manipulate-function-plot.html
ReleaseHold[Hold[f[a,b]] /. f -&gt; List] will give you {a,b} just by replacing the head with List, However, if you don't know the definition of f beforehand then I'm not so sure, so I came up with this hacky one liner: ToExpression[ StringReplace[ StringSplit[ToString[Definition[f], InputForm], ":="][[1]], "f" -&gt; "List"]] http://i.imgur.com/Q9Dx9KI.png Be careful, this will probably break in some weird cases. For other things related to argument extraction, look into sequence: https://reference.wolfram.com/language/ref/Sequence.html
Most[Level[HoldForm[f[x, y]], 2]] would work also. That function of yours looks a bit odd; I think it's scanning for unique symbols present in the expr that have global context. The DeleteDuplicates means it will only produce {a} if you fed it some function g[a,a]. The Infinity means the Cases happens at all levelspecs so you end up with a flattened list {a,b,c,x,y} for some function g[a,b,{c},{x,y}] instead of the actual argument list {a,b,{c},{x,y}}. For me, that function only works if you know the arglist beforehand which seems pointless and you might as well just turn the head into a list and do a Flatten and delete duplicates for exactly the same effect.
 SetAttributes[isSymbol, HoldFirst]
Hey thanks for taking a look. Here's the [two equation](http://pastebin.com/) system I'm working on. I'm basically looking to pick out any terms that have a 0 in the index. So terms like q10, q10^(1,0) and u0 u0^(1,0) . I had a partial solution but it didn't save for some reason. I'm working on it again now.
Mathematica lacks a construct that is analogous to structs in other languages, that has pleasing syntax ('house1.numberOfWindows'). Your (ab)use of association maps is an attempt to work around this. I don't know that there is a better way to do it than what you do, but unfortunately it is still far from pretty. To be honest, unless you need symbolic mathematical functionality (do you?), you may be better off using a language that is actually suited to writing programs. Much as I love Mathematica, it is not very well suited for implementing simple, readable algorithms. Here's a discussion on StackExchange that may interest you: [struct equivalent in Mathematica?](http://mathematica.stackexchange.com/questions/990/struct-equivalent-in-mathematica) 
I do want symbolic functions. My goal is to assert certain things about the system, then simplify all the basic equations (e.g. mass balances, etc) such that I end up with a set of constraints on the flow rates in terms of the other system parameters. What I'd end up with is a *region* of flow rates where it is possible to satisfy the assertions I made. I could simply type them all out, but once everything is said and done, there are on the order of 100 equations and variables that I'm considering.
It would be kinda cool to have a public Mathematica repo everybody could contribute to. 
Only if there is some form of quality assurance in place.
Well, it could be somewhat useful even without QA :)
The problem is that you've given r a circular definition. Are you maybe thinking of ParametricPlot? With that function, you can define plot variables in terms of independently varying parameters.
Any given curve has to have some kind of parameters to determine its shape though. If you're looking to draw curves without labeled axes, you can use the Axes-&gt;False plot option so that when it's plotted, the plot range isn't shown, but Mathematica still needs to have some idea of the range, even if it's arbitrary (e.g., {r,-1,1}).
I believe that you are correct that Mathematica cannot do what your blackboard can do. Perhaps a slightly better example will show more clearly why it cannot do this. Mathematica plot this! a*x^2 +b*x+c AND I refuse to give any numeric values for a,b,c or even the range of x. Your blackboard can easily conceptually say this is a parabola, or a degenerate straight line and can say conceptually that it might be concave up or concave down and might have any position at all, but Mathematica often does not handle "abstract" things well or even at all, like vectors of unknown size, matricies of unknown size, sums or products of abstract expressions or over abstract ranges, abstract functions that aren't concretely defined or plots of "abstract" functions. Worse, Mathematica does not have, in several or many different senses, "mathematical maturity", which means that like a bright student can be given a few words about something in mathematics, figure out what you really want and start filling up your blackboard with a sensible presentation. I'd be really interested in seeing a list of a few applications, excluding any programs that require me to simulate holding a piece of chalk and drawing it manually, that will sensibly plot my parabola above.
I've found it helpful in the past. A better resouce is the in-built help menu. There are plenty of examples in there. Notable exception is for the Combinatoria library which doesn't have much documentation.
Great, I think you understand me. I don't work with maths software every day, so I am not sure what the software "landscape" is like or how these programs are used professionally. It seemed very odd I couldn't do the first task I wanted to. I do know that internally Mathematica has to work with "values" - in fact internally it **must** work with floating point numbers (approximations of real numbers) because that's how CPUs work. The symbolic language sits on top of this foundation. Even so I can't see any valid reason why Mathematica can't simply abstract a value back to a symbol for the user. After I don't care whether it's representing my 'r' as '1.00000000000000000' internally as long as it displays r. Another way of thinking about it, it's nothing more complicated than the assignment 1:=r. So it seems you can't even construct something the Ancient Greeks could draw in the dirt. Found one very interesting program called [Geogebra](http://www.geogebra.org) that I've been playing with for the last hour. Much closer to what I needed but not quite there. Seems like the best solution is still a blackboard! 
Sorry, I missed it. Here is your slightly updated [notebook](https://www.dropbox.com/s/ippr54k1445xmte/PistonReddit.nb?dl=0). Feel free to ask any questions.
QA could be code reviews before merging into a specific branch. The branch and code would be referenced in a post in the subreddit and suggestions could be made. 
In your example, you're asking Mathematica to plot p(r) as r goes from -2r to 2r. Do you mean you'd like to plot p(x) as x goes from -2r to 2r?
It's a very simple fix... Plot[p[r],{r,-2,2}] the last two numbers in the list are the lower and upper limits of where you want to plot.
You appear angry with the software in that it can't guess what you want, and frankly, I don't really understand why. As BillSimpsonxV said, trying to plot f(x) = a x^2 + b x + c for arbitrary a, b, and c, simply *can't* be done in full generality, even on your blackboard. For instance, if a = 0, you don't have a parabola anymore. And what would you plot if any of those coefficients (or arguments!) are complex? You *have* to make an assumption about the structure of your mathematical object somewhere, and Mathematica leaves it to you to make such assumptions. It's vastly easier to make one initial assumption than it is to tighten the infinitude of possibilities down until you get something abstract-but-concrete-enough for your purposes. If software doesn't do what you want, then it doesn't do what you want. But trivializing Mathematica at every turn and comparing it to, frankly, *completely* different tools with *completely* different use cases will serve only to frustrate both you and other commenters.
Numerical integration routines such as those used by NDSolve do not necessarily conserve energy manifestly in mechanics problems like this - it is typical to see a subtle drift in the total energy. Only specialized methods, known as symplectic schemes, will conserve energy (on average) in a problem such as this.
If you are going to use Combinatorica then you have to buy a copy of "Computational Discrete Mathematics, Combinatorics and Graph Theory with Mathematica" by Pemmaraju and Skiena. They wrote the original Combinatorica. Even that book could be better and more helpful, but it is the best there is and is in my experience essential.
This fixes the first few waves of errors but I think you still have a ways to go with this. With[{amin=0.25, amax=0.85, Talow=217, Taupp=283}, aocean[T_ ]:=Piecewise[{ {amax, T&lt;=Talow}, {((amin-amax)/(Taupp-Talow))(T-Talow)+amax, Talow&lt;T&lt;=Taupp}, {amin, Taupp&lt;t}}]]; With[{emin=0.1, emax=0.5, Teupp=283, Telow=273}, eps[T_ ]:=Piecewise[{ {emin, T&lt;=Telow}, {((emax-emin)/(Teupp-Telow)) (T-Telow)+emin, Telow&lt;T&lt;=Teupp}, {emax, Teupp&lt;T}}]]; With[{Ls=1.310^6, s=0.310^-5, T00=283, B=0.133037694}, li[T_ , el_ ]:=(1/(Ls s))((2 Ls s el+B (T-T00)s+1/4)^(1/2)-(Ls s^2 el+B(T-T00)s+1/2))]; With[{Q=362.2, gam=0.3, a0=0.25, a1=4.110^-7, Ls=1.310^6, k=1.74, T0=154, Ct=1, Cl=0.7}, solution=NDSolve[{T'[t]==(Q/Ct) (1-(gam (a0+a1 Ls el[t])+(1-gam) aocean[T[t]]))-k(T[t]-T0), el'[t]==el[t]^-(1/2)((1-eps[T[t]]) li[T[t]]-el[t]), T[0]==285, T'[0]==-1, el[0]==0.78, el'[0]==1}, {T, el}, {t, 0, 100}, MaxSteps-&gt;3000]] BUT you have defined li as a function with 2 arguments and used it with only one argument. That must be fixed. There are lots of other guesses at what you needed. And you have 2 initial conditions for each of a pair of first order ODE, which is too many. If I guess and eliminate the second IC for each of those and I guess you wanted li[T[t], el[t]] instead of li[T[t]] then I can get it to solve with complaints about stepsize. The plot of that is I assume meaningless, but it is possible to get there with all these changes. Compare your code and mine, character by character inside Mathematica and see how many of my guesses are correct. Then test it carefully before you depend on the results.
Shouldn't it be *NDSolve[{y'[x] == y***[x]***(6 - x y[x]), y[0] == 1.4},***y***, {x, 0, 3}]*?
http://i.imgur.com/GJbnAZ2.png I made the corrections and I'm still getting the same error?
Are you sure it's okay to use Mathematica's built-in Euler's method? I'd guess that your instructor intended for you to implement it yourself.
Suppose fa=f[a],ga=g[a], etc. Simplify[Reduce[{c fa+d ga==ha, c fb+d gb==hb, c^2+d^2==1}, {c, d}]] and sort through all the alternatives until you find the one that applies to your case. If you can supply some additional information then it might be possible to make that much easier.
&gt; You appear angry with the software You appear to be offended that I don't like something about the software. Are you a Wolfram employee per chance? Essentially your point - at least the relevant part - is that curves changes shape depending on their values so you can't plot them. That's correct, but not for the curve I was trying to plot (not the example). And in either case Plot does not even attempt to draw the 'shape' of something without numerical values - that's a genuine constraint of Plot that's not always a constraint of the function. For example it doesn't allow us to exclude certain problem values in the domain definition. I wouldn't generalise this criticism to all of Mathematica, but certainly there's an element of expectation vs. reality. Mathematica has always been highly pumped by Stephen himself, has had plenty of time to evolve and you naturally expect a lot from it. It turns out its not always the magical platonic land of pure symbolic manipulation he describes. In this case we proved Mathematica can't symbolically manipulate a mathematical object *graphically* without making certain assumptions we may not want to in the problem at hand. It's not an issue algebraically.
Here http://imgur.com/qwsgZ50 Firstly, the result returned by NDSolve is usually a replacement rule, replacing your dependent variable with an InterpolatingFunction of some kind. The replacement rule generated by your code is {x-&gt;x} which will be useless (hence the recursion). The reason why: First[NDSolve[{y'[x] == y(6 - xy[x]), y[0] == 1.4}, **x**, {x, 0, 3}, StartingStepSize -&gt; 0.05, Method -&gt; {"FixedStep", Method -&gt; "ExplicitEuler"}]] The **x** is an independent variable and shouldn't appear as the second argument to NDSolve. The second argument should actually be **y** if you look at the documentation. Once you have the interpolating function y, you can get values from it by using y like a function, e.g Plot[y[x],{x,0,3}] or generating a Table with {x,y[x]} as points
http://imgur.com/FTEBdBf If C^2 + D^2 == 1 then you know every point {C,D} lies on the unit circle. You can immediately parametrize the function as Cos[t]f[x] + Sin[t]g[x]. Given your NDSolve output is an interpolating function Y[x], you want to minimize the square error: se = (Y[x] - (Cos[t]f[x] + Sin[t]g[x]))^2 Because there's no point writing the code to do all that, FindFit is a perfect candidate for this. I fabricated the interpolating function h(x) as Y[x] in my image for sake of generating a good example problem. The sample points you choose from your InterpolatingFunction (the result of NDSolve) should be chosen within your range (x=a,x=b) by using the argument to Table[yourfunction, {x,a,b,yourstepsize}]
Thanks!
So your title should be more descriptive. Is this for a class? I hate to be the one to say read the docs, but they tell you almost exactly how to do this problem https://reference.wolfram.com/language/ref/DSolve.html. You just have to change the function. 
With [BooleanFunction](http://reference.wolfram.com/language/ref/BooleanFunction.html), you can create a logical expression that satisfies a given truth table. With [BooleanConvert](http://reference.wolfram.com/language/ref/BooleanConvert.html) you can express it in different forms.
Not sure I entirely understand, but could you use PlotRange for this? Maybe something like PlotRange -&gt;{0,Max[data]} This would always set 0 as the lower bound to your plot, and the maximum of your data as the upper bound. 
If you wanted to make it more flexible, you could use this: PlotRange -&gt; {Min[Min[data], 0], Max[Max[data], 0]}
I don't know how to do it exactly. However, a right-click and "Get Coordinates" will get you close.
I don't think there's a builtin function that'll let you do multi-level pattern matching. Your best bet is to search row by row, looking for the pattern -- if the only pattern you're looking for is the one you have, just search for rows with three x's in a row. Let the position of the middle x be (x,y); then just check (x, y-1) and (x, y+1) for x. Then return (x,y), or alternatively return {(x-1, y), (x, y), (x+1, y), (x, y-1), (x, y+1)}.
I edited the code in the link to match what you asked for. I think this will work pretty nicely for you. TracePlot[expr_, {var_, xmin_, xmax_}, opts___] := Column[{Dynamic[ Block[{mouse = MousePosition["Graphics"] /. None -&gt; {0, 0}}, Column[{Show[Plot[expr, {var, xmin, xmax}, opts], Graphics[Point[{mouse[[1]], expr /. var -&gt; mouse[[1]]}]]], {mouse[[1]], expr /. var -&gt; mouse[[1]]}}]]]}];
Fixed one mistake and simplified slightly. This pattern={pre___,{a___,X,___},{b___,X,X,X,___},{c___,X,___},___}/; Length[{a}]==Length[{b}]+1==Length[{c}]; MatchQ[board, pattern] returns True or False depending on whether your cross is there. Now instead of using MatchQ can you see how to use some substitution operations to return the position of the cross? Length might help with that.
I will try this approach later on while I am at home. I hadnt considered something like this. I am not sure how to return the position of the cross. I will have to experiment. This problem is related to Pokemon Shuffle. I want to see, given a particular case of symbols which figures(including the +) are able to cause even a small chain reaction. Maybe I am approaching this problem from the wrong angle.
You need to specify the spatial domain for the problem. You're going to need another boundary condition at the left side of your domain, too.
If you can''t stand doing it by hand, here's the pro way of doing it if you've got time and need to be exact. http://imgur.com/5eF03dS http://pastebin.com/w15AW6Yq
This looks perfect, thank-you sincerely! Coming from a very novice perspective, how would I define wrdlst? Should I so something like, wrdlst={"phrase1","phrase2"} ?
Yes I think. I assume when you mean something like (q10^(1,0))[t0,t1]) you really mean Derivative[1,0][q10][t0,t1], which is better for copying as an input form If by freeze out you mean remove, you should be able to remove t1 completely by doing: DeleteCases[yourequations,t1,Infinity] then you just need to change the Derivative[1,0] and Derivative[2,0] into Derivative[1] and Derivative[2] respectively , since you've lost the t1 variable. Putting it all together you get: eqnNew = ReleaseHold[ HoldForm[Evaluate[ DeleteCases[eqn, t1, Infinity]]] /. {Derivative[1, 0] -&gt; Derivative[1], Derivative[2, 0] -&gt; Derivative[2]}]; As it turns out, that gets you an equation you can solve symbolically with DSolve[eqnNew, {q10,u0},t0] or you can go ahead and use NDSolve. Hope that helps. my results compressed, run this: {q10, u0} = First[Uncompress@ "1:eJztWcFOhDAQBQGXo5+gf8DGk16JnjwQ4tHLaiBpwi5qIfrZ/\ \ oEyLSyUFgILS0qcPTTbwkxn5j0eLb15TcPYNAyD2kXzRGgWX6h7YZ5E1Cr+\ \ fGw9PuoWzWN+eMtIehB9ULieebFVDQZJTmMHetA8k31Eax/hDjzsEgI+\ \ CAzza3BrkH5FnxQuPCjtN0Xjp/v3JPomBpj/\ \ Fj82fUBaXmK7GQ25FuZhLslPp3E5SiAjnlZtxe6EEJM+IzldCJUbl+\ \ VqxStUj7hyvB2hQk1e7r1b/\ \ 27Lq2l3xTvUwXCo9AmalZdz5sjAFtxX06hmVtAh1Ram2qiQxBJOwPtYP8R7EbwXi8GRHSB\ \ N1kOTUY7MysJnHuLNAEj7KodLldUQpV7LsijZ+gAf83WhJ6WsQFG7+uu/\ \ WO5VuIZksv6lPBmqoO5wdnJwVlHELdGyYKrea6aitJ1F0idNTr2G1lhCauzzE/TyE78+\ \ iaqFgqUV+ChY/wTMURt7XROUpIpJrjuEbxPpitqDW0ZEb543R/\ \ 86SYl1WTPcc54Jue49pzgZKqjuSOpPP/4Ui5jbCsxtOQnUfI35NttxH24N9Dzuc+\ \ QYEOX1oHzqaR1k9wfnyxxI"][[All, 2]] ...and don't forget any numerical evaluations after subbing in your values can have tiny complex parts. Remove these with a Chop[...]
I've finally discovered that mathematica *does* give you a choice of kernel in an undocumented feature of Classify[] as answered in this Mathematica stackoverflow http://mathematica.stackexchange.com/questions/14987/machine-learning-svm-algorithm Classify[xtrain -&gt; ytrain, Method -&gt; {"SupportVectorMachine", "KernelType" -&gt; "Linear", "SoftMarginParameter" -&gt; 2}] I can only assume the default KernelType is an RBF kernel for now until we have more documentation. Other examples of parameters I've been able to find Method -&gt; {"SupportVectorMachine", "KernelType" -&gt; "RadialBasisFunction", "MulticlassMethod" -&gt; "OneVersusAll"}, There is apparently a choice of Linear, Sigmoid, Polynomial, RadialBasisFunction, Automatic
You want to use the Map function. Its shortcut is "/@". To make a function Map over a list do: function/@list For your example, it sounds like you want to do something like: Solve[E^(x*#) == p, x] &amp; /@ {1, 2, 3, 4, 5} Where Solve[E^(x*#) == p, x] &amp; is a pure function. # is like the variable and &amp; ends the function. If you're unfamiliar with it, play around a bit.
Perhaps use Assuming or $Assumptions like this: Assuming[x != 0, Simplify[y/x == 0]] which gives y == 0 or the alternate notation Simplify[y/x == 0, x != 0] which also gives y == 0. That same use of Simplify can eliminate the extra conditions returned by Reduce, but by itself Reduce does not seem to use assumptions.
In my opinion, using a condition works better than using if-statements everywhere. pattern /; test evaluates the pattern only if the test evaluates to true, so you can do things like f[x_] := Sin[x]/x /; x != 0 so f[3] gives Sin[3]/3 but f[0] just returns f[0].
 Row[{Button["Subtract!",X-=5],Button["Add x3!",X+=15]}] Should do what you want, but good luck moving it anywhere. Mathematica isn't quite renowned in UI construction. There's also [this](https://reference.wolfram.com/language/tutorial/CustomInterfaceConstructionOverview.htmll) if you need something a little more comprehensive.
If you have a list of positions, just use ListPlot
Well, they are actually just images. When you paste it in, the software automatically replaces the compressed data with the image. I do definitely understand your concern though. 
To get to the last 3 digits of a nonnegative integer, you need to look at the rest after dividing by 1000. This is called the 'modulo' operator, and Mathematica implements it as the *Mod* function: Mod[123456, 1000] 456 To do this with the last digits of 2-to-the-1000th-power, you can use it directly: Mod[2^1000, 1000] 376 However, this still needs to evaluate 2^1000 fully, which is 302 digits. This is not a big deal for Mathematica, but it becomes impossible if the intermediate result doesn't fit in memory anymore. For example, 2^1000000000000000000 has over 300 million billion digits, so that won't fit. It turns out however that the operation of taking powers and then doing modulo has applications (for example, in number theory and cryptography), and there is a clever trick for it. Mathematica implements this as PowerMod: PowerMod[2,1000,1000] 376 PowerMod[2,1000,1000000000000000000] 376 They turn out to be the same! This is not a concidence (it is interesting to figure out why this happens). It's much faster, too -- on my machine, these are some timings in seconds: Timing[Mod[2^10000000000, 1000]] // First 0.833782 Timing[PowerMod[2, 10000000000, 1000]] // First 0. 
Your line Mod[2^1000] should read Mod[2^1000,1000] Great response, though!
There's a few ways I can think of doing this. In Mathematica, I would do [\/u\/sidneyc's](http://www.reddit.com/user/sidneyc) solution, but I came up with a few solutions before noticing this was /r/Mathematica (one of the solutions was [\/u\/sidneyc's](http://www.reddit.com/user/sidneyc)). I don't have access to Mathematica at the moment, so there may be some errors in my code. Also I haven't written Mathematica in years (I had to google For loops lol) (* These solutions assume non-negative integer powers *) (* One solution *) power (* = some user input *); init = {0, 0, 1}; Do[{ 2 init, If[init[[2]] &gt;= 10, { init[[2]] = init[[2]] - 10, init[[1]] = init[[1]] + 1 }] If[init[[1]] &gt;= 10, { init[[1]] = init[[1]] - 10, init[[0]] = init[[0]] + 1 }] init[[0]] = Mod[init[[0]], 10] }, {power} ] (* Another solution *) power (* = some user input *); (* A lookup table because there are a finite number of possibilities *) (* There are 95 (I think, I did it by hand) *) (* If you will be running this many times, you may just have lookup = {{0, 0, 2}}; and apply memoization to the algorithm *) lookup = {{0, 0, 2}, {0, 0, 4}, {0, 0, 8}, {0, 1, 6}...}; If[power == 0, {0, 0, 1}, { If[power &lt;= 7, lookup[[power]], { (* The 7 and 88 may be incorrect if I made a mistake when solving by hand *) power = power - 7, power = Mod[power, 88], power = power + 1 }] }] (* Interesting side note. m how many of the final digits to pay attention to, n is the period m n 1 4 2 22 3 95 *) (* Yet another solution *) power (* = some user input *); init = 1; Do[{ 2 init, init = Mod[init, 1000] }, {power} ]
I've used this as a start for many students that I've had: https://www.wolfram.com/broadcast/screencasts/handsonstart/
Maybe not quite a tutorial, but a very useful handout I used when learning Mathematica: http://douglasbaldwin.com/Mathematica_Handout_2010.pdf
I don't think this fraction has a term a/n^2 but a useful function for splitting up fractions into simple components is Apart which will output a/n - a/(n+1)
OK, I did some research, and (kinda) figured it out. The answer is not straight forward (if there is a better way, please let me know). I first tried using Mouseover[], but that won't work since the Graphic my mouse is over is different from the Graphic that is showing the magnified version. What I finally did was to wrap the two Graphics (but NOT the plot) in a Pane. Then, I used MousePosition[{"Graphics",Pane}]. This restricts the MousePosition to the Pane, so mousing over the plot does not effect the magnification object. Still, if you accidentally mouse over the magnification oject, it still goes haywire, so the solution is not perfect...
Functions referencing other function is not very likely to be the cause of your slowdown unless you are working with very large numbers of functions (probably well over a thousand, but I've never worked with that many before, so even that might be fine). Obviously, for any real help, you need to post your code. 
&gt; Is this because my computer is just slow, or is it mathematica? No. It's probably you. 
If you post your code so far (enclosed in backticks or indented by 4 spaces), we'd have a better idea of what you are trying to accomplish. It's unlikely we will write something this complicated from scratch.
Wow, thanks a ton. That's very odd. Do you know where exactly the bug is? Is it with RegionInteresction or Triangle or Dot? 
Even with /u/Mathematico's help, I'm still having some weird issues. The List@@@ trick doesn't help when I try to use Manipulate. Manipulate[ Block[{t}, t = Dot[RotationMatrix[\[Pi]/4], #] &amp; /@ {{a, 0}, {a + Sqrt[Csc[\[Theta]]]/Sqrt[Sec[\[Theta]]], Sqrt[Sec[\[Theta]]]/Sqrt[Csc[\[Theta]]]}, {a + Sqrt[Csc[\[Theta]]]/Sqrt[Sec[\[Theta]]], -(Sqrt[Sec[\[Theta]]]/Sqrt[Csc[\[Theta]]])}}; t = List @@@ t; {Graphics[Triangle[t]], Area[RegionIntersection[Triangle[t], Rectangle[{0, 0}, {1, 1}]]]}], {a, -2, 1}, {\[Theta], .01, \[Pi]/2}] gives the same error message as before Area::reg: "RegionIntersection[Rectangle[{0,0},{1,1}],Triangle[{{0.33234,0.33234},{0.800937,1.82217},{1.82217,0.800937}}]] is not a correctly specified region. " Even though it can plot the triangle, it can't find the area of intersection between the triangle and the square. Then to see where the issue was, I tried doing something trivial and replaced the triangle in the intersection with nonvariable disk. Manipulate[ Block[{t}, t = Dot[RotationMatrix[\[Pi]/4], #] &amp; /@ {{a, 0}, {a + Sqrt[Csc[\[Theta]]]/Sqrt[Sec[\[Theta]]], Sqrt[Sec[\[Theta]]]/Sqrt[Csc[\[Theta]]]}, {a + Sqrt[Csc[\[Theta]]]/Sqrt[Sec[\[Theta]]], -(Sqrt[Sec[\[Theta]]]/Sqrt[Csc[\[Theta]]])}}; t = List @@@ t; {Graphics[Triangle[t]], Area[RegionIntersection[Disk[{0, 0}, 1], Rectangle[{0, 0}, {1, 1}]]]}], {a, -2, 1}, {\[Theta], .01, \[Pi]/2}] and I still get an error message RegionIntersection[Disk[{0,0},1],Rectangle[{0,0},{1,1}]] is not a correctly specified region. And of course just typing in the command Area[RegionIntersection[Disk[{0, 0}, 1], Rectangle[{0, 0}, {1, 1}]]] works fine just as expected.
Where are `h`, `ma`, and `mi` defined?
h is a list of values from an excel file where are all the mins and max of all the picks ma and mi are abreviations for mins and maxs of n picks
Why don't you try something like ... Show[ ContourPlot3D[ x^2 + y^2 == 2 z^2, {x, -10, 50}, {y, -10, 50}, {z, -10, 50}, ContourStyle -&gt; {Red, Opacity[0.2]}, RegionFunction -&gt; Function[{x, y, z}, z &gt; 0], Mesh -&gt; False], ContourPlot3D[ z^2 + y^2 == 6 x^2, {x, -10, 50}, {y, -10, 50}, {z, -10, 50}, ContourStyle -&gt; {Blue, Opacity[0.2]}, RegionFunction -&gt; Function[{x, y, z}, x &gt; 0], Mesh -&gt; False], ContourPlot3D[ x^2 + z^2 == y^2, {x, -10, 50}, {y, -10, 50}, {z, -10, 50}, ContourStyle -&gt; {Green, Opacity[0.2]}, RegionFunction -&gt; Function[{x, y, z}, y &gt; 0], Mesh -&gt; False]] And maybe add something using RegionPlot3D to shade in the intersection ...
Ok, thats the deal.I can't seems to get this code to work. In my mind is ok-go, but then again I'm not the brightest mind ever. All I get is a bunch of errors. It's a messy code, just a draft really... w = 254 t = 12.7 T = 667223 L = 3048 s = 3 * d dh = d + 3.75 n = nh * nv Fu = 3998950 cp = 0.071653 cv = 4.56 Fmaxvij1 = 53.397 * Pi * d^2 Fmaxvij2 = 10.679 * d * t * Fu Fmaxpl = 0.75 * Fu (w - nv + dh) f = cp * (L + s * (nv - 1) + 2 * e) + cv * nh * nv NMinimize[{f, Fmaxvij1 &gt; (T/n), Fmaxvij2 &gt; (T/n), Fmaxpl &gt; T, w &gt;= (2 * e + (nv - 1) * g), nv &gt; 0, nh &gt; 0, e&gt;= 1.5 * d, g &gt;= 3 * d, d &gt;= 12.7, w &gt;= ((nv - 1) * g + 2 * e)}, {nh, nv, d}] Basically, I got a bunch of constraints and I don't know how to use them.
thanks so much /u/mminsky ! i just wasn't using Show and the RegionFunction option together in the way that would produce what i wanted. here is what i have come up with now (with your help) Show[ ContourPlot3D[(y^2 + z^2)/Tan[30 Degree] - (x + 5)^2 == 0, {x, -50, 50}, {y, -50, 50}, {z, -50, 50}, ContourStyle -&gt; {Red, Opacity[0.2]}, RegionFunction -&gt; Function[{x, y, z}, x &gt; -5], Mesh -&gt; False], ContourPlot3D[(x^2 + z^2)/Tan[80 Degree] - (y + 5)^2 == 0, {x, -50, 50}, {y, -50, 50}, {z, -50, 50}, ContourStyle -&gt; {Blue, Opacity[0.2]}, RegionFunction -&gt; Function[{x, y, z}, y &gt; -5], Mesh -&gt; False], ContourPlot3D[(x^2 + y^2)/Tan[75 Degree] - (z + 5)^2 == 0, {x, -50, 50}, {y, -50, 50}, {z, -50, 50}, ContourStyle -&gt; {Green, Opacity[0.2]}, RegionFunction -&gt; Function[{x, y, z}, z &gt; -5], Mesh -&gt; False] ] though when i try to add something like RegionPlot3D[ (y^2 + z^2)/Tan[30 Degree] - (x + 5)^2 &lt; 0 &amp;&amp; (x^2 + z^2)/Tan[80 Degree] - (y + 5)^2 &lt; 0 &amp;&amp; (x^2 + y^2)/Tan[75 Degree] - (z + 5)^2 &lt; 0, {x, -50, 50}, {y, -50, 50}, {z, -50, 50}, PlotPoints -&gt; 50 ] to the Show[] function i get some pretty weird results, i.e. shading where i think there shouldn't be shading. this is due to the RegionPlot3D[] taking into account areas of the graphs that are not plotted by the ContourPlot3D[] functions. though i am not sure how to properly limit the ranges inside the RegionPlot3D[], especially since the RegionFunction option isn't used within RegionPlot3D[]. if i just try to use the ranges built into RegionPlot3D i can accomplish what i need with two cones as can be seen from the simpler example below Show[ ContourPlot3D[(y^2 + z^2)/Tan[30 Degree] - (x + 5)^2 == 0, {x, -50, 50}, {y, -50, 50}, {z, -50, 50}, ContourStyle -&gt; {Red, Opacity[0.2]}, RegionFunction -&gt; Function[{x, y, z}, x &gt; -5], Mesh -&gt; False], ContourPlot3D[(x^2 + y^2)/Tan[75 Degree] - (z + 5)^2 == 0, {x, -50, 50}, {y, -50, 50}, {z, -50, 50}, ContourStyle -&gt; {Green, Opacity[0.2]}, RegionFunction -&gt; Function[{x, y, z}, z &gt; -5], Mesh -&gt; False], RegionPlot3D[ (y^2 + z^2)/Tan[30 Degree] - (x + 5)^2 &lt; 0 &amp;&amp; (x^2 + y^2)/Tan[75 Degree] - (z + 5)^2 &lt; 0, {x, -5, 50}, {y, -50, 50}, {z, -5, 50}, PlotPoints -&gt; 50, Mesh -&gt; None] ] but it gets more complicated with 3 cones and seems like kind of a hack way to do it. any idea how to best remedy this? the additional shaded part which i would like to eliminate can be seen when you graph the following Show[ ContourPlot3D[(y^2 + z^2)/Tan[30 Degree] - (x + 5)^2 == 0, {x, -50, 50}, {y, -50, 50}, {z, -50, 50}, ContourStyle -&gt; {Red, Opacity[0.2]}, RegionFunction -&gt; Function[{x, y, z}, x &gt; -5], Mesh -&gt; False], ContourPlot3D[(x^2 + z^2)/Tan[80 Degree] - (y + 5)^2 == 0, {x, -50, 50}, {y, -50, 50}, {z, -50, 50}, ContourStyle -&gt; {Blue, Opacity[0.2]}, RegionFunction -&gt; Function[{x, y, z}, y &gt; -5], Mesh -&gt; False], ContourPlot3D[(x^2 + y^2)/Tan[75 Degree] - (z + 5)^2 == 0, {x, -50, 50}, {y, -50, 50}, {z, -50, 50}, ContourStyle -&gt; {Green, Opacity[0.2]}, RegionFunction -&gt; Function[{x, y, z}, z &gt; -5], Mesh -&gt; False], RegionPlot3D[ (y^2 + z^2)/Tan[30 Degree] - (x + 5)^2 &lt; 0 &amp;&amp; (x^2 + z^2)/Tan[80 Degree] - (y + 5)^2 &lt; 0 &amp;&amp; (x^2 + y^2)/Tan[75 Degree] - (z + 5)^2 &lt; 0, {x, -5, 50}, {y, -50, 50}, {z, -5, 50}, PlotPoints -&gt; 75, Mesh -&gt; None] ] 
thanks! exactly what i was going for.
First of all, you need to use backticks (\`) or blockquote with four spaces to quote your Mma expression so that Reddit's markdown doesn't munge it. Your code was Range[10]/.{x_/;PrimeQ[x] -&gt; x^2} All of these things are covered in the Mma documentation. The operator `/.` is shorthand for `ReplaceAll`. The left argument is an expression, and the right argument is a rule or list of rules which are applied to the left hand argument. `Range[10]` is simply the list of numbers `{1,2,3,4,5,6,7,8,9,10}`. `{x_/;PrimeQ[x] -&gt; x^2}` is a rule that says "replace all primes with their square". To the left of `-&gt;` is the compound expression `x_/;PrimeQ[x]`. `_` is shorthand for `Blank[]`, which matches all expressions. We have a temporary binding `x_` which is really shorthand for `Pattern[x,Blank[]]` meaning the symbol `x` can match any expression. The operator `/;` is shorthand for `Condition`. It says that `x_` only matches an expression when `PrimeQ[x]` is true. `PrimeQ` just returns `True` or `False` if `x` is prime or not. The right hand side, `x^2`, should be obvious. The above code is actually written poorly. The better way to write it is Range[10]/.{x_?PrimeQ :&gt; x^2} Here we use `?` which is shorthand for `PatternTest`. It is less powerful than `Condition` because the second argument can only be the name of a function (which returns `True` or `False`). But this is exactly what the `Condition` is used for above, it's not a complicated condition. So we should use the simpler (and potentially faster) `PatternTest`. Also notice that we use `:&gt;` which is shorthand for `RuleDelayed` instead of `-&gt;` which is just `Rule`. That's because the *right hand side depends on the pattern on the left hand side*. This means we want to wait to evaluate the RHS of the rule. For example, let's say you had previously defined `x=Pam` somewhere earlier in your code. The first code (the one you gave) would replace all primes with `Pam^2`. The second code will still replace all primes with their own square. Get it?
/u/duetosymmetry's answer is spot-on, but I think this is pretty scary stuff for a novice. The short Mathematica expression given and the answer touch on several advanced topics in Mathematica usage: pattern matching, immediate vs delayed rules, and syntactic sugar (with nasty, non-intuitive syntax) vs full forms of expressions. I think it is a terrible choice by your professor to expose students to Mathematica in this way. Mathematica is a very powerful system but it also complex. In case you feel a bit overwhelmed, rest assured that that is perfectly normal. If you are interested in getting to know Mathematica as a tool (which could serve you handsomely in later life), a much shallower learning curve would be to learn a few functions, explore its representation of data, and only then venture into stuff like pattern matching once you have that basis. Pattern matching is a pretty big part of Mathematica and one of the reasons why it is as powerful as it is. Once you master Mathematica, a tool like Matlab will seem to be a mere calculator -- the only appeal of which is that it is easier to use. But my advice would be to *take it slow*. 
@#:&gt;ing great answer.
+1 great stuff. You should post about it here: http://community.wolfram.com you may get some good feedback. 
Good idea.
Not exactly related to your question, but I found it useful to put "clean code" into separate .m files. It is also useful for merges.
 I understand that there is already a great on included, but I just wanted to see if I could do it on my own (no tutorials or internet searches). Here is my progress so far. I know the code doesn't look so great. I am having troubles with the fact that Mathematica doesn't have good object support (classes would be amazingly useful here).
jesus, I'd rather not, I'm not really good at this... l = 15; g = 386; w = 60; e = 30*10^6; k = 10; d = 0.286; i = (b*h^3)/12; m = w/g; ke = (1/k + (l^3)/(3*e*i))^(-1); ww = Sqrt[(ke/m)]; f = b*h*l*d; ContourPlot[{ww == 8, f == 1, f == 2, f == 3, f == 4}, {b, 0.5,1}, {h, 0.2, 2}, PlotLegends -&gt; "Expressions"] ok, thats an example with two function ww &amp; f (b,h). I want to do the same thing, introducing the third variable using Manipulate.Like this. f[x_, y_, z_] := x^2 y Cos[z] Manipulate[ContourPlot[f[x, y, z], {x, 1, 10}, {y, 1, 10},ColorFunction -&gt; "DarkRainbow", PlotLegends -&gt; Automatic], {z, 1, 3}] Ok my actual functions are: mu=0.9*as*fy*d*(1-0.59*(as/(b*d))*(fy/fc)) d=h-c pmax=0.025 pmin=0.0033 p=as/(b*d) c=0.065 cc=100 cf=2 L=1 cr=610/907.18 dd=7850 fy=420*10^6 fc=35*10^6 f=cf*(2*h+b)*L+cr*as*L+cc*d*b*L and I want to plot something along lines of: Manipulate[ContourPlot[{f,mu==400*10^3},{b,h,as}],{as,0,10}] 
 x = Range[1, 10]; g1[x_, z_] := NIntegrate[Sin[y], {y, 0, x}] + z Map[g1[#, 5]&amp;, x] or g1[#, 5]&amp; /@ x This maps the anonymous function g1[#, 5]&amp; (whose argument is #) onto each element of the list x. The reason your code didn't work is that custom functions don't have the `Listable` attribute by default.
Depending on your desired precision/accuracy, the Monte Carlo methods can be massively faster than the Global Adaptive thing it typically uses for an "Automatic" method. Interestingly enough if you have a nice integrand sometimes the symbolic processing can speed things up, but it can easily run into an overflow issue that'll eat ram until you're fried. I keep it off and often start with "AdaptiveQuasiMonteCarlo" and work down to "MonteCarlo" for speed. Of course ther are some ways to tweak the Monte Carlo methods, too--recursion, max points, etc. It also depends strongly on how your integrands behave. Are they highly oscillatory by any chance?
Nope, no oscillations, quite nice looking positive areas, just a lot of nested integrations make it slow. I will try the monte carlo method, thanks! Edit: Btw I though that as both of the Integrands are very similar, maybe I could somehow make mathematica only calculate `suppy` and `tunnelUtot` once for each `U` and then use it for both of the integrations, but that's probably quite complicated.
Wow.... Well, now I feel stupid. And I considered myself to be a pretty good mathematica programmer. How did I miss this? Many thanks, u/duetosymmetry...
Interesting but, frankly, I don't understand why you would want to use Mathematica for this. 
With associations, you essentially don't need it because you get "duck typing" for free. If you're going to bring up multiple inheritance, please rethink the decisions you've made in your life ;)
Going off topic from this thread, but you seem to be somebody who would know the answer to my question. I've been wishing that there was a programming language which combined some of the elements of Haskell (strictness, purity) with some of the ideas of Mathematica—mainly homoiconicity, so that I can simply enter raw expressions and deal with them algebraically but also evaluate them when desired. Have you ever come across something like this?
Well, the rotate[] is actually three separate rotations, but I'm not sure whether RotationMatrix[] could do that or not, I didn't actually know about that function. Your last two points are right on. I was developing the code from my (sketchy) memory of vector maths, and so I just used the projection, without realizing that projecting onto a principle axis was the same as taking that component (tl;dr, I got confused about which coordinate system I was working in, and thought I had to do a projection). Also, I have updated the code using Association[], and it is a lot cleaner now, though it is not yet finished. I will also remove the dot products, as per your remarks... Thanks for the feedback.
Wow. I had no idea how big a deal it would be... Thanks for the information.
Join[A,B,C] is the same as Join @@ {A,B,C}. For example Join @@ Table[{n,n^2},{n,1,5}] will output {1, 1, 2, 4, 3, 9, 4, 16, 5, 25} Does this solve your problem?
This this what you are (roughly) looking for? testdata = RandomReal[1, {100, 2}]; ListPlot[testdata] binned = First /@ BinLists[testdata, {0, 1, 0.1}, {0, 1}]; averages = Mean /@ binned[[All, All, 2]]; averagepoints = Transpose[{Range[0.05, 0.95, 0.1], averages}]; Show[ ListPlot[binned], ListPlot[averagepoints, PlotStyle -&gt; PointSize[Large]] ]
It's a special case of the "Apply" command. If f is a function, then f @@ {x1, x2, . . ., xn} is the same as f[x1, x2, . . ., xn] In general, you can use @@ to replace the "head" of any expression -- in the usage above we're replacing the "List" head by f, but I'm not sure I've ever used it for anything else. 
Yeah, I discovered the BinLists function and after a bit of toying around, I managed to get it to work. Thanks.
I didn't read the code you provided, so I can't say why it doesn't work, but what you're trying to do is called [Gray codes](https://en.wikipedia.org/wiki/Gray_code). The Mathematica package Combinatorica has this functionality built in. You can accomplish what you're trying to do with the code pos = Position[MinimumChangePermutations[Sort[list]], list][[1, 1]] MinimumChangePermutations[Sort[list]][[1;;pos]] If you're dealing with very long lists, this code will be slower than optimal since it will generate all permutations before outputting just the ones you want. You can make the code better by looking at the source code for MinimumChangePermutations and make it just stop once you get the final list you want. Another possibility, if I've misread what you're looking for, is that you don't want permutations in canonical order, but would like to get from the sorted list to the unsorted list quickly. In that case, I think you're probably best off just using the steps in [Bubble Sort](https://en.wikipedia.org/wiki/Bubble_sort) as your intermediate permutations, and then listing the steps backward from the ordered list to the list input to bubble sort. 
Thanks for this. Yeah, I felt as though my code was just getting to be too much of a monstrosity from being bogged down in permutation cycles, etc. I think either of your methods would work, though I particularly liked the reverse bubble-sort idea: Reverse@NestWhileList[#/.{front___,p_,q_,back___}/;p&gt;q:&gt;{front,q,p,back}&amp;,list,Not@OrderedQ[#]&amp;] 
Graphics3D is the lowest level representation of 3D graphics in Mathematica, just as Graphics is the lowest level 2D graphics representation. Other functionality that creates 3D graphics, like Plot3D or ParametricPlot3D create a Graphics3D object (while for example Plot and ContourPlot create a Graphics object). Everything that exists within the object can be seen explicitly with InputForm[Graphics3D[...]]. Smooth figures like spheres or cones will not be reduced to polygons because they are not represented that way in Mathematica; the expression Sphere[{x, y, z}, r] is already in its most primitive form.
Ah brilliant! You're quite right, I did exclude the negative. I didn't realize on mobile that the ellipse missed the peak. My full code has multiple peaks scattered around, so I picked a bad one for this question. I appreciate your shifting it to demonstrate the functionality. Tools like Join are what I love about Mathematica. Thank you so much for your help; this is exactly what I wanted!
Do it recursively! t[1] = 20 t[n_] := 110 - 110*Exp[-0.01*t[n-1]] edit: direct replacements use = and not :=
Read the documentation for the function `NestList[]`. Or, for a more specialized function, look at `RecurrenceTable[]`. Searching through the documentation is an important skill to learn when using Mma, since the number of builtin functions is huge. Another important skill to learn is to identify whenever you are thinking in terms of FORTRAN. Yes, you can write FORTRAN in any language you like, but it won't be pretty or idiomatic or fast. When you start a question with 'using a for loop to...' notice that you are asking a FORTRAN style question. Mma is not FORTRAN. `For[]` is almost always slower than another solution.
I'm not exactly sure why that is. It might be related to the fact that ImageDimensions isn't based on display size for the image and how RasterSize works. Regardless, I think using ImageSize instead of RasterSize should suit your purposes. ImageDimensions@Rasterize[Graphics[Disk[]], ImageSize -&gt; 15] gives {15,15}.
Thank you for your reply. This is working better, (but still behaves oddly sometimes...) I'm even *more* confused, since I thought ImageSize only had to do with the display size, and not the actual image...
You are a lifesaver. No one at my university was familiar with mathematica and mathematica support was not terribly helpful. THANK YOU SO MUCH. IT WORKS PERFECTLY.
Count 'em: N[Exp[Pi*Sqrt[163]], 100] Edit - To make it easier to extract the decimal fraction, I amend my suggestion to this: N[Mod[Exp[Pi*Sqrt[163]], 1], 100]
Because you don't actually need more. Here's a simpler way: In[1] := N[Exp[Pi*Sqrt@163] - Floor@Exp[Pi*Sqrt@163], 20] Out[1] = 0.99999999999925007260
Oh, I see now. They want the amount of 9's *directly* following the decimal point... I was thinking of all the 9's that keep coming with higher precisions.^(I feel a bit dumb now) Thanks for your time;)
So, basically it sounds like you're trying to multiply two lists? You could do it this way: Table[k[[i]] stuff[[i]], {i, 5}] Generally, Table is the most useful function for doing any kind of iteration over lists. edit: Almost forgot--If you're just trying to multiply every element in a list by the same value, you can just do it the same way you'd multiply scalar values: k = {1,2,3,4,5} k2 = 1.05 k 
Make your simulation a function with the parameters you want to vary as the functions arguments: sim[a_, b_, c_] := Module[{x, solution}, solution = First@NDSolve[{ a x''[t] + b Sin[c x[t]] == t, x'[0] == 1, x[0] == 1 }, x, {t, 0, 2}]; x[t] /. result /. t -&gt; 2 ] Then try varying the parameters: sim[#, 1, 1] &amp; /@ {0.9, 1.0, 1.1} `&amp;` indicates the preceding expression is an anonymous function (whose argument is `#`), and `/@` maps this function onto the list of trial values.
I'm not 100% sure this is what you're after, but I suspect you can do what you want with just ``StandardDeviationFilter`` and ``MeanFilter``. Let's take [Lena](http://i.imgur.com/iGMn55p.png) as an example picture. 1. [Desaturate your image](http://i.imgur.com/tbH7vUD.png) so we just work with brightness: bw = ColorConvert[pic,"Grayscale"]; 2. Run a [`MeanFilter`](http://imgur.com/a/Ipfj7#ogUtHk4) and [`StandardDeviationFilter`](http://imgur.com/a/Ipfj7#yARWEcO) on it to replace all color values with the mean and standard deviations within a given pixel radius: means = MeanFilter[bw,3]; stdevs = StandardDeviationFilter[bw,3]; 3. Convert the two new images into arrays of real-valued pixel brightneses with `ImageData`. {meanVals, stdVals} = ImageData/@{means,stdevs} 4. Process accordingly. filtered = stdVals/meanVals^2 5. Find the maximum. Position[filtered, Max[filtered]] If you think you have to use `While` loops in Mathematica, you probably haven't explored all of your options ;) This is at least the first half - the zeroing bit you can do with a while loop, but something like `NestList` or `Nest` with the proper function will work much better.
You can certainly automate! You'll probably want to convert the entire image to a real-array with `ImageData` first, then do all operations on that before you put it back together with `Image`, but the automation should be straightforward. If you define two functions, `FindBrightestPixel` with the above process, and `ZeroPixel[img_, {x_,y_}]`, then your iteration is just a repeated application of `ZeroPixel[img, FindBrightestPixel[img]]`. Of course, this'll be kind of slow because you have to recompute a whole lot of brightnesses after changing one pixel, so you can speed it up by either * Maintaining the brigtnesses as an array and updating only the neighborhood within it that changes (what you described) or * Finding all brightnes values greater than a threshold at the outset, and zeroing them all simultaneously (*not* what you described, but potentially a close analogue for a whole lot less effort). 
In short, lets say I had a formula when simplified looks like: ( 52a^3 + 34a^2 (a x + b)^2 + 22a (a x + b)^4 + 4 (a x + b )^6 )^2 Assume it starts in it's expanded form. What operations could I use to get it into the form I have above. Simplify[%], FullSimplify[%], etc... do not take me back to it. I have 100s of formulas I need to simplify that will always simplify into something that looks like: ( C[0] + C[1](ax+b)^1 + C[2](ax+b)^2 + C[3](ax+b)^3 + ... )^{1,or,2}
First things first, find out if your university offers some way of getting a free license. Both universities I've been to did. If not, there is a free trial you can get. I think it's a month long or something. I'll come back and give some examples of how I use it later, but I can't right now.
Eh... You'll probably be able to use maple or matlab at school anyways. I'd say pass.
 (g==x &amp;&amp; a==0 &amp;&amp; f*y != 0) || (g-x != 0 &amp;&amp; (y==-(a*f)/(4*(g- x))-Sqrt[(a^2*f^2)/(4*(g-x)^2)-(2*a*d)/(3*(g-x))+ (2*a^3*d^3-9*a^3*c*d*f+27*a^3*b*f^2+Sqrt[-4*(a^2*d^2- 3*a^2*c*f+12*a*b*(g-x))^3+(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+27*a^2*c^2* (g- x)-72*a^2*b*d*(g-x))^2]+27*a^2*c^2*(g-x)-72*a^2*b*d*(g- x))^(1/3)/(3*2^(1/3)*(g-x))+(2^(1/3)*(a^2*d^2- 3*a^2*c*f+12*a*b*g-12*a*b*x))/(3*(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+Sqrt[-4*(a^2*d^2- 3*a^2*c*f+12*a*b*(g-x))^3+(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+27*a^2*c^2*(g-x)-72*a^2*b*d* (g-x))^2]+27*a^2*c^2*(g-x)-72*a^2*b*d*(g-x))^(1/3)*(g- x))]/2-Sqrt[(a^2*f^2)/(2*(g-x)^2)-(4*a*d)/(3*(g-x))- (2*a^3*d^3-9*a^3*c*d*f+27*a^3*b*f^2+Sqrt[-4*(a^2*d^2- 3*a^2*c*f+12*a*b*(g-x))^3+(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+27*a^2*c^2*(g-x)-72*a^2*b*d* (g-x))^2]+27*a^2*c^2*(g-x)-72*a^2*b*d*(g-x))^(1/3)/ (3*2^(1/3)*(g-x))-(2^(1/3)*(a^2*d^2-3*a^2*c*f+12*a*b*g- 12*a*b*x))/ (3*(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+Sqrt[-4*(a^2*d^2- 3*a^2*c*f+12*a*b*(g-x))^3+(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+27*a^2*c^2*(g-x)-72*a^2*b*d* (g-x))^2]+27*a^2*c^2*(g-x)-72*a^2*b*d*(g-x))^(1/3)*(g-x))- (-((a^3*f^3)/(g-x)^3)+(4*a^2*d*f)/(g-x)^2-(8*a*c)/(g- x))/(4*Sqrt[(a^2*f^2)/(4*(g-x)^2)-(2*a*d)/(3*(g-x))+ (2*a^3*d^3-9*a^3*c*d*f+27*a^3*b*f^2+Sqrt[-4*(a^2*d^2- 3*a^2*c*f+12*a*b*(g-x))^3+(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+27*a^2*c^2*(g-x)-72*a^2*b*d* (g-x))^2]+27*a^2*c^2*(g-x)-72*a^2*b*d*(g- x))^(1/3)/(3*2^(1/3)*(g-x))+(2^(1/3)*(a^2*d^2- 3*a^2*c*f+12*a*b*g-12*a*b*x))/(3*(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+Sqrt[-4*(a^2*d^2- 3*a^2*c*f+12*a*b*(g-x))^3+(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+27*a^2*c^2*(g-x)-72*a^2*b*d* (g-x))^2]+27*a^2*c^2*(g-x)-72*a^2*b*d*(g-x))^(1/3)* (g- x))])]/2 || y==-(a*f)/(4*(g-x))-Sqrt[(a^2*f^2)/(4*(g-x)^2)- (2*a*d)/(3*(g-x))+(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+Sqrt[-4*(a^2*d^2- 3*a^2*c*f+12*a*b*(g-x))^3+(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+27*a^2*c^2* (g- x)-72*a^2*b*d*(g-x))^2]+27*a^2*c^2*(g-x)-72*a^2*b*d*(g- x))^(1/3)/(3*2^(1/3)*(g-x))+(2^(1/3)*(a^2*d^2- 3*a^2*c*f+12*a*b*g-12*a*b*x))/(3*(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+Sqrt[-4*(a^2*d^2- 3*a^2*c*f+12*a*b*(g-x))^3+(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+27*a^2*c^2*(g-x)-72*a^2*b*d* (g-x))^2]+27*a^2*c^2*(g-x)-72*a^2*b*d*(g-x))^(1/3)*(g- x))]/2+Sqrt[(a^2*f^2)/(2*(g-x)^2)-(4*a*d)/(3*(g-x))- (2*a^3*d^3-9*a^3*c*d*f+27*a^3*b*f^2+Sqrt[-4*(a^2*d^2- 3*a^2*c*f+12*a*b*(g-x))^3+(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+27*a^2*c^2*(g-x)-72*a^2*b*d* (g-x))^2]+27*a^2*c^2*(g-x)-72*a^2*b*d*(g-x))^(1/3)/ (3*2^(1/3)*(g-x))-(2^(1/3)*(a^2*d^2-3*a^2*c*f+12*a*b*g- 12*a*b*x))/ (3*(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+Sqrt[-4*(a^2*d^2- 3*a^2*c*f+12*a*b*(g-x))^3+(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+27*a^2*c^2*(g-x)-72*a^2*b*d* (g-x))^2]+27*a^2*c^2*(g-x)-72*a^2*b*d*(g-x))^(1/3)*(g-x))- (-((a^3*f^3)/(g-x)^3)+(4*a^2*d*f)/(g-x)^2-(8*a*c)/(g- x))/(4*Sqrt[(a^2*f^2)/(4*(g-x)^2)-(2*a*d)/(3*(g-x))+ (2*a^3*d^3-9*a^3*c*d*f+27*a^3*b*f^2+Sqrt[-4*(a^2*d^2- 3*a^2*c*f+12*a*b*(g-x))^3+(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+27*a^2*c^2*(g-x)-72*a^2*b*d* (g-x))^2]+27*a^2*c^2*(g-x)-72*a^2*b*d*(g- x))^(1/3)/(3*2^(1/3)*(g-x))+(2^(1/3)*(a^2*d^2- 3*a^2*c*f+12*a*b*g-12*a*b*x))/(3*(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+Sqrt[-4*(a^2*d^2- 3*a^2*c*f+12*a*b*(g-x))^3+(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+27*a^2*c^2*(g-x)-72*a^2*b*d* (g-x))^2]+27*a^2*c^2*(g-x)-72*a^2*b*d*(g-x))^(1/3)* (g- x))])]/2 || y==-(a*f)/(4*(g-x))+Sqrt[(a^2*f^2)/(4*(g-x)^2)- (2*a*d)/(3*(g-x))+(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+Sqrt[-4*(a^2*d^2- 3*a^2*c*f+12*a*b*(g-x))^3+(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+27*a^2*c^2* (g- x)-72*a^2*b*d*(g-x))^2]+27*a^2*c^2*(g-x)-72*a^2*b*d*(g- x))^(1/3)/(3*2^(1/3)*(g-x))+(2^(1/3)*(a^2*d^2- 3*a^2*c*f+12*a*b*g-12*a*b*x))/(3*(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+Sqrt[-4*(a^2*d^2- 3*a^2*c*f+12*a*b*(g-x))^3+(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+27*a^2*c^2*(g-x)-72*a^2*b*d* (g-x))^2]+27*a^2*c^2*(g-x)-72*a^2*b*d*(g-x))^(1/3)*(g- x))]/2-Sqrt[(a^2*f^2)/(2*(g-x)^2)-(4*a*d)/(3*(g-x))- (2*a^3*d^3-9*a^3*c*d*f+27*a^3*b*f^2+Sqrt[-4*(a^2*d^2- 3*a^2*c*f+12*a*b*(g-x))^3+(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+27*a^2*c^2*(g-x)-72*a^2*b*d* (g-x))^2]+27*a^2*c^2*(g-x)-72*a^2*b*d*(g-x))^(1/3)/ (3*2^(1/3)*(g-x))-(2^(1/3)*(a^2*d^2-3*a^2*c*f+12*a*b*g- 12*a*b*x))/ (3*(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+Sqrt[-4*(a^2*d^2- 3*a^2*c*f+12*a*b*(g-x))^3+(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+27*a^2*c^2*(g-x)-72*a^2*b*d* (g-x))^2]+27*a^2*c^2*(g-x)-72*a^2*b*d*(g-x))^(1/3)*(g- x))+(-((a^3*f^3)/(g-x)^3)+(4*a^2*d*f)/(g-x)^2-(8*a*c)/(g- x))/(4*Sqrt[(a^2*f^2)/(4*(g-x)^2)-(2*a*d)/(3*(g-x))+ (2*a^3*d^3-9*a^3*c*d*f+27*a^3*b*f^2+Sqrt[-4*(a^2*d^2- 3*a^2*c*f+12*a*b*(g-x))^3+(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+27*a^2*c^2*(g-x)-72*a^2*b*d* (g-x))^2]+27*a^2*c^2*(g-x)-72*a^2*b*d*(g- x))^(1/3)/(3*2^(1/3)*(g-x))+(2^(1/3)*(a^2*d^2- 3*a^2*c*f+12*a*b*g-12*a*b*x))/(3*(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+Sqrt[-4*(a^2*d^2- 3*a^2*c*f+12*a*b*(g-x))^3+(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+27*a^2*c^2*(g-x)-72*a^2*b*d* (g-x))^2]+27*a^2*c^2*(g-x)-72*a^2*b*d*(g-x))^(1/3)* (g- x))])]/2 || y==-(a*f)/(4*(g-x))+Sqrt[(a^2*f^2)/(4*(g-x)^2)- (2*a*d)/(3*(g-x))+(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+Sqrt[-4*(a^2*d^2- 3*a^2*c*f+12*a*b*(g-x))^3+(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+27*a^2*c^2* (g- x)-72*a^2*b*d*(g-x))^2]+27*a^2*c^2*(g-x)-72*a^2*b*d*(g- x))^(1/3)/(3*2^(1/3)*(g-x))+(2^(1/3)*(a^2*d^2- 3*a^2*c*f+12*a*b*g-12*a*b*x))/(3*(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+Sqrt[-4*(a^2*d^2- 3*a^2*c*f+12*a*b*(g-x))^3+(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+27*a^2*c^2*(g-x)-72*a^2*b*d* (g-x))^2]+27*a^2*c^2*(g-x)-72*a^2*b*d*(g-x))^(1/3)*(g- x))]/2+Sqrt[(a^2*f^2)/(2*(g-x)^2)-(4*a*d)/(3*(g-x))- (2*a^3*d^3-9*a^3*c*d*f+27*a^3*b*f^2+Sqrt[-4*(a^2*d^2- 3*a^2*c*f+12*a*b*(g-x))^3+(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+27*a^2*c^2*(g-x)-72*a^2*b*d* (g-x))^2]+27*a^2*c^2*(g-x)-72*a^2*b*d*(g-x))^(1/3)/ (3*2^(1/3)*(g-x))-(2^(1/3)*(a^2*d^2-3*a^2*c*f+12*a*b*g- 12*a*b*x))/ (3*(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+Sqrt[-4*(a^2*d^2- 3*a^2*c*f+12*a*b*(g-x))^3+(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+27*a^2*c^2*(g-x)-72*a^2*b*d* (g-x))^2]+27*a^2*c^2*(g-x)-72*a^2*b*d*(g-x))^(1/3)*(g- x))+(-((a^3*f^3)/(g-x)^3)+(4*a^2*d*f)/(g-x)^2-(8*a*c)/(g- x))/(4*Sqrt[(a^2*f^2)/(4*(g-x)^2)-(2*a*d)/(3*(g-x))+ (2*a^3*d^3-9*a^3*c*d*f+27*a^3*b*f^2+Sqrt[-4*(a^2*d^2- 3*a^2*c*f+12*a*b*(g-x))^3+(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+27*a^2*c^2*(g-x)-72*a^2*b*d* (g-x))^2]+27*a^2*c^2*(g-x)-72*a^2*b*d*(g- x))^(1/3)/(3*2^(1/3)*(g-x))+(2^(1/3)*(a^2*d^2- 3*a^2*c*f+12*a*b*g-12*a*b*x))/(3*(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+Sqrt[-4*(a^2*d^2- 3*a^2*c*f+12*a*b*(g-x))^3+(2*a^3*d^3- 9*a^3*c*d*f+27*a^3*b*f^2+27*a^2*c^2*(g-x)-72*a^2*b*d* (g-x))^2]+27*a^2*c^2*(g-x)-72*a^2*b*d*(g-x))^(1/3)* (g- x))])]/2) &amp;&amp; y != 0) || (g==x &amp;&amp; f==0 &amp;&amp; a==0 &amp;&amp; d*y != 0) || (g==x &amp;&amp; a*f != 0 &amp;&amp; (y==-d/(3*f)-(2^(1/3)*(- d^2+3*c*f))/(3*f*(-2*d^3+9*c*d*f-27*b*f^2+Sqrt[4*(- d^2+3*c*f)^3+(-2*d^3+9*c*d*f-27*b*f^2)^2])^ (1/3))+ (-2*d^3+9*c*d*f-27*b*f^2+Sqrt[4*(-d^2+3*c*f)^3+ (-2*d^3+9*c*d*f-27*b*f^2)^2])^(1/3)/(3*2^(1/3)*f) || y==- d/(3*f)+((1+I*Sqrt[3])*(-d^2+3*c*f))/(3*2^(2/3)*f* (-2*d^3+9*c*d*f-27*b*f^2+Sqrt[4*(-d^2+3*c*f)^3+ (-2*d^3+9*c*d*f-27*b*f^2)^2])^ (1/3))-((1-I*Sqrt[3])* (-2*d^3+9*c*d*f-27*b*f^2+Sqrt[4*(-d^2+3*c*f)^3+ (-2*d^3+9*c*d*f-27*b*f^2)^2])^(1/3))/(6*2^(1/3)*f) || y==- d/(3*f)+((1-I*Sqrt[3])*(-d^2+3*c*f))/(3*2^(2/3)*f* (-2*d^3+9*c*d*f-27*b*f^2+Sqrt[4*(-d^2+3*c*f)^3+ (-2*d^3+9*c*d*f-27*b*f^2)^2])^(1/3))-((1+I*Sqrt[3])* (-2*d^3+9*c*d*f-27*b*f^2+Sqrt[4*(-d^2+3*c*f)^3+ (-2*d^3+9*c*d*f-27*b*f^2)^2])^(1/3))/(6*2^(1/3)*f)) &amp;&amp; y != 0) || (g==x &amp;&amp; f==0 &amp;&amp; a*d != 0 &amp;&amp; (y==(-c-Sqrt[c^2- 4*b*d])/(2*d) || y==(-c+Sqrt[c^2-4*b*d])/(2*d)) &amp;&amp; y != 0) || (g==x &amp;&amp; f==0 &amp;&amp; d==0 &amp;&amp; c==0 &amp;&amp; b==0 &amp;&amp; y != 0) || (g==x &amp;&amp; f==0 &amp;&amp; d==0 &amp;&amp; b != 0 &amp;&amp; a==0 &amp;&amp; y != 0) || (g==x &amp;&amp; f==0 &amp;&amp; d==0 &amp;&amp; a*c != 0 &amp;&amp; y==-(b/c) &amp;&amp; b != 0) || (g==x &amp;&amp; f==0 &amp;&amp; d==0 &amp;&amp; b==0 &amp;&amp; c != 0 &amp;&amp; a==0 &amp;&amp; y != 0) 
Lol
What you want to do is solve a general quartic equation. This is indeed possible in closed form. As you can see from the comment of /u/BillSimpsonxV , it's an unholy mess. Instead of using that expression, it's much better to follow the steps that *lead* to that construction. You can google for the solving quartics, or you can try to follow the expressions given [on Wikipedia](https://en.wikipedia.org/wiki/Quartic_function#General_formula_for_roots).
I would play around with wolfram alpha for a while first, it has a lot of the same functionality for free. If you find your self using it every day: buy mathematica 
I am aware.
Look into the "Method" option for GraphPlot. Also VertexCoordinateRules.
Thanks for the ideas!
I can't replicate your results. For me (10.2.0.0) RegionQ[EmptyRegion[3]] and RegionQ[DiscretizeRegion[EmptyRegion[3]]] both return true. I've tried some simple intersections and while they take a while to compute they do eventually return, what looks like, the correct answer. Could you reply with an example of two ellipsoids, e1 and e2 such that RegionMeasure[RegionIntersection[e1,e2]] takes too long / never finishes? For the record Wolfram is aware of several outstanding bugs to do with RegionMeasure[].
I think you can email them via support@wolfram.com or use http://www.wolfram.com/support/contact/email/. They do provide a phone number but I'm unsure how much joy you'll get. There must be a discrepancy in our versions of Mathematica to explain the difference in the RegionQ[] test. My guess is that you'll find that this bug will be fix in a later version. That doesn't help you much now unfortunately. I can confirm that the RegionMeasure calculation takes far too long. Interesting there is a similar bug report for this already (for RegionMeasure[RegionDifference[...]]). I'd still contact Wolfram with each of the two bugs, though.
You can try Mathematica for free using the [Wolfram Programming Cloud](https://www.wolfram.com/programming-cloud/)
The difference is in what you get. https://www.wolfram.com/programming-cloud/pricing/ http://www.wolfram.com/mathematica/pricing/industry-individuals.php?online TL;DR: **WPC Free version:** 0.2GB storage. 100 API calls a month. 1000 credits a month (For deployment). **Mathematica lowest version:** 2 GB storage. 1,000 API calls a month. 5 free viewers (allows 5 people to use your deployment without paying cloud credits). 
But I see you can also pay for the WPC and get more stuff than Mathematica online and cheaper. I don't know, it seems pretty stupid to have two different product names just for different pricing schemes when the background software is the same. IMHO is silly and confusing. Thanks for the links though
thank you. i needed the radius for r2 printed, and the angle should be in the 5 degree range. so, i'm not sure what happened. r1 = 21.83460130981065" t = 0.14290687632083" s1 = 21.83448439429152" r = 1.09250794268549" s = 1.09016879931776" r2 = 22.92465319360928" solve = 5.000203498097416˚ i need for the M script to extend the 1000 digits and the 5.000203# isn't doing that, its giving simple round off like numbers, so for the below script, i want to enter the 5.000203498097416˚ and have many numerals, 1000 digits. A = (5 + 1/4) Degree; TA = (7 + 1/2) Degree; r = Csc[A/2]; For[i = 1, i &lt;= 10, i++, A = 2*ArcCsc[r]; chord = 2*Csc[A/2]*Sin[3*A/4]; r = chord*Csc[TA/2]/2; Print[N[{A/Degree, chord, r, 3/2 A/Degree}, 1000]]; Print[NumberForm[N[A/Degree, 80], DigitBlock -&gt; 3, NumberSeparator -&gt; " "]]; Print[NumberForm[N[TA/Degree, 80], DigitBlock -&gt; 3, NumberSeparator -&gt; " "]]; ] 
You might find more feedback if you are less vague in your title and use formatting in your post.
You again! Your question is just as unintelligible as last time.
If you are a student, pirate the software and hone your skills. Later, when you are a professional programmer, your employer can buy the professional license. Everyone wins.
and you're just as much of a twit as you were the last time. keep your unhelpful comments to yourself
I had a [similar issue](https://www.reddit.com/r/Mathematica/comments/380pe4/issue_with_regionintersection/) before. There appears to be a bug.
He's right though.
if you had taken the time to copy and paste the so-called spam like text into a mathematica notebook,you'd see the operations and results. apparently your brilliance has blinded you, to the reason why maybe some people post here for help, not criticism, so in this sense you're an idiot, along with your pom pom waving cheerleader sidneyc. 
here's your copy....if you had taken the time to copy and paste the so-called spam like text into a mathematica notebook,you'd see the operations and results. apparently your brilliance has blinded you, to the reason why maybe some people post here for help, not criticism, so in this sense you're an idiot, along with your pom pom waving cheerleader sidneyc. 
You appear to have some mental issues. 
If Mathematica returns "{}", your system doesn't have any solutions. If it returns "{{}}", you have infinite solutions. (I may have that backwards, but it's one or the other.) Does that help? I haven't run your code (yet), but that may be enough.
It returned "{}", however I'm failing to see why my system would have no solutions.
I'm not sure mate. I can't seem to recreate what you've got, the differentials in equations 2 and 4 scupper me. Also, if I simplify the system and set p1 = p2 and thus reduce the number of unknown functions. I still get a no solution return from Mathematica.
You want to solve a differential equation. `Solve[]` is for algebraic equations, not differential equations. For the latter there is `DSolve[]` or `NDSolve[]`.
&gt; pdel = 0.4; pminusdel = 0.1; rhoplusrate = 0.4; rhominusrate = 0.1; Ltot = 500; popsize = 20000; rholoci = 70; rhosize = 0.6; &gt; wm[Ldel_, rho_] := Max[0, 1 - 7*(rho*Ldel/Ltot + (1 - Ldel/Ltot)*rho^2*pdel/(pdel + pminusdel))]; wa[Ldel_] := (1 - (1 + 7/9 + 7/9)*10^-8)^Ldel; ws[rho_] := 1/(1 - Log[rho]*10^-2.5); selection[Ldel_, rho_, newLdel_, newrho_] := wm[newLdel, newrho] * ws[newrho]/(wm[Ldel, rho] * ws[rho]) - 1; pfix[Ldel_, rho_, newLdel_, newrho_] := (1 - E^(-2*selection[Ldel, rho, newLdel, newrho]))/(1 - E^(-2*selection[Ldel, rho, newLdel, newrho]*popsize)); logrhorate [Ldel_, rho_] := (pfix[Ldel, rho, Ldel, rho / rhosize] rhoplusrate (Log[rho]/Log[rhosize]) / rholoci - pfix[Ldel, rho, Ldel, rho * rhosize] rhominusrate (rholoci - Log[rho]/Log[rhosize]) / rholoci); Ldelrate [Ldel_, rho_] := pfix[Ldel, rho, Ldel + 1, rho ] * pdel *(Ltot - Ldel)/Ltot - pfix[Ldel, rho, Ldel - 1, rho] * pminusdel * Ldel/Ltot; VectorPlot[{logrhorate[Ldel, 10^logrho], 100 Ldelrate[Ldel, 10^logrho]}, {logrho, -4, -1}, {Ldel, 0, 500}, PlotRange -&gt; {{-4, -1}, {0, 500}}]
I added the code above, it's a bit of a mouthful.
I think color might be the way to go, I'll try that. I think I tried to use log(x,y) and it didn't work, but I'll try again. Thanks.
There have been many posts over the years about the large size of pdf files from Mathematica. If you Google reduce pdf file size you can find free "optimizers" that can sometimes drastically reduce the size. If you Google mathematica reduce pdf file size you can find some suggestions for this, sometimes even within Mathematica.
"Solved" is perhaps too optimistic. And different people get different degrees of success, depending on the pdf they are generating, which was why I couldn't just say "do this" and you would have the answer.
Ooh, thanks. What does PlayRange do?
Thanks so much!
`PlayRange -&gt; All` rescales the signal to avoid clipping (amplitude going off-scale low or high), which would create unwanted distortion.
I'm not sure exactly what you mean. What code did you use? You can use Plot to draw a waveform you intend to use as input to Play, though it's usually better to leave out audio tone frequencies (such as 440) when you do that. Plot can be helpful in visualizing which waveform you're trying to get before feeding it to Play, but Plot is not specifically audio-oriented. 
Without seeing the code this question seems very close to "I got some stuff and some stuff don't work. What?" Just reading the documentation I would do this D[f[x1, x2, x3, x4], {x1, 2}] D[f[x1, x2, x3, x4], {x2, 2}] but without the code this is just guessing. Almost always when MMA just echoes the input you haven't used the correct syntax.
Okay, thanks. I'll try it.
Not exactly sure what you mean. As far as I know Mathematica expands sums right away. Maybe you can post your code?
Yes! So first i'll describe my problem: I have two equations set up for an economy, this economy has 1 product and a varying number of firms producing this product. In this economy, the goal is for each firm to figure out what the price of their product will be and how much profit they will make, each firm will sell their product for the same price and have the same profit. I have a price function (highlighted text is code, so if you see any syntax errors don't be afraid to critique): &gt;p = 100 - Sum[Qn,{1,n}] This is the function for price of sum commodity, if no one was making it, it would cost 100 units of money, but obviously at least one person has to produce it. So for each firm producing it, their output cheapens the price. Then I have a profit function: &gt;pi[Q_] = p *Q - 10*Q This function determines the profit of each company in the market. For every unit they sell (represented by variable Q) they make revenue, whatever p is (this is shown in p*Q) however their is also a 10-money-unit-cost associated with creating each product, so i subtract away 10*Q. I want to maximize this function, so in order to do so I want to take the derivative of the pi function with respect to Q, treating the summation of Q's as a constant, and then **after** taking this derivative, I want to convert this summation to &gt;(n-1)*Q + Q because i am creating a reaction function, a function that will allow my hypothetical firms to realize what quantity of products (Q) to produce. At this point, and only after this point in the calculation, the firm will treat all Q's as equal, so a summation from 1-to-n of different Q's is equal to n*Q, or in my case (n-1)*Q +Q. I then want to go through the standard maximization process, setting the equation equal to zero and solving for Q in terms of n, for purposes of taking the limit at n --&gt; infinity or whatever number of firms i'm working with. I hope this makes sense! Again if it seems too convoluted for you to help I will understand, but thank you so very much for your time. 
So first off I don't think this is a problem you really need Mathematica for. Some basic calculus should suffice. Secondly, I think you made a few mistakes in setting up your equations. I don't think this makes a lot of sense &gt;p = 100 - Sum[Qn,{1,n}] Instead I would say something like the price decrease is proportional to the total supply of products available. The total supply is equal to the number of products Q produced by each firm times the number of firms N. So N*Q. Thus, &gt;p=100 - aNQ The factor a is the decrease in price of producing one additional unit. In general it will depend on Q, but for now let's assume it's constant. Your pi function seems okay. &gt;pi = p Q - 10Q Plugging the first equation in the second we get &gt; pi (Q) = (100 - aQN) Q - 10 Q &gt; pi (Q) = 90 Q - aNQ^2 To maximize this we take the derivative and set that equal to 0. &gt; pi'(Q) = 90 - 2aNQ = 0 &gt; Q = 45/(aN) That's the amount of products each firm should produce to maximize profits. The factor a and number of firms N are parameters. 
`MatchQ` only matches the full expression, so in this case `{a}` can only be `{g, t^2}`, which contains `t`, rendering the match false. However in the replacement, as `Times` is `Orderless` (commutative), `Flat` (associative) and `OneIdentity` (`f` is equivalent to `Times[f]`), `{a}` can be `{g, t^2}`, `{g}`, `{t^2}` or `{}`. Two of those possibilities don't contain `t`, so they are valid matches. If `a` matched `g` (which is the case, but irrelevant for the result) then the original expression which is equivalent to `Times[Times[g, f], t^2]` would become `Times[Times[g], t^2 ]` evaluating to `Times[g, t^2]`. If `a` matched the empty sequence, the expression would became `Times[Times[], g, t^2]` which again would evaluate to `Times[g, t^2]`.
The pattern matcher matches on the subexpression `g f` binding `a = {g}` (which is free of `t`) and replacing it with just `g` so the whole expression becomes `g t^2`. 
From what you explain, I would suggest to convert the video into something less memory intense before importing it to Mathematica? see for details: http://superuser.com/questions/23425/convert-a-video-to-black-and-white-using-avidemux-on-ubuntu Another solution could be to import just a certain number of frames. For this you should first export each frame of your video into e.g. jpg pics and then import them one by one in Mathematica.
I assume the OP had some reason for the "80 or so". Is some sort of computerized selection or sorting occurring? If not, onel1978's solution is perfect. 
Use the function plotGrid shown [here](http://mathematica.stackexchange.com/a/37467/9490)
... Or quadratics... I'm not a mathematician. In the form of (x1 - constant)^2 + (x2 - constant)^2 ... xn. Thanks!
It would be helpful if you posted exactly what you were working on, but it sounds like you want to use Minimize or NMinimize.
Your problem statement is unclear, it could mean a number of different things. Please show a specific example of what you are trying to do, but with 4 or 5 terms rather than a thousand.
I think what you're looking for is [Roots](https://reference.wolfram.com/language/ref/Roots.html), [Solve](https://reference.wolfram.com/language/ref/Solve.html), or in your particular case, the closest you might get is using [NSolve](https://reference.wolfram.com/language/ref/NSolve.html)
Pretty cool. If it needs any improvement, it's that some levels are much easier than others. difficulty should improve gradually. Other than that, it's pretty cool.
As much as I love simple math problems and enjoy solving them while running, how is this related to mathematica? I think it belongs more on r/math then here.
It is. The right place is /r/learnmath, that's where the folks at /r/math would steer you towards. 
A small update: I've managed to get two manipulable links. The problem I can't figure out now is the angle of the second link. As I mentioned earlier, the angle should be measured from the first link, but at the moment I measure it from the x axis. My current code is: &gt;Manipulate[ Graphics[ {PointSize[.025], Line[{pointA, {len1*Cos[phi Degree], len1*Sin[phi Degree]}, {len1*Cos[phi Degree] + len2*Cos[del Degree], len1*Sin[phi Degree] + len2*Sin[del Degree]}}], Point[{0, 0}], Point[{len1*Cos[phi Degree], len1*Sin[phi Degree]}], Point[{len1*Cos[phi Degree] + len2*Cos[del Degree], len1*Sin[phi Degree] + len2*Sin[del Degree]}]}, Axes -&gt; True, PlotRange -&gt; {{0, 8}, {0, 8}}], {phi, 0, 90, 1}, {del, 0, 90, 1}] Also, if I try to take the equations for the point coordinates out of the Manipulate object, I get an error message saying that mathematica does not recognize the point coordinates because of $CellContext. I'm not exactly sure what is up with that. I tried to bypass this by putting the equations for the point coordinates to Initialization option of Manipulate, but then moving the slider does not change the value of the point (or at least the graphics do not update). It seems that I hit another bug in my code by trying to bypass a bug. EDIT: I've solved the above problem. Mistakes I had: using same name for variables in manipulate and initialization, incorrectly defining initializations. I went along with defining equations separately and using SaveDefinitions option for Manipulate.
Can't help with programming it now, but you can take a look at those: [Inverse Kinematics](http://demonstrations.wolfram.com/InverseKinematics/), [Robotics](http://www.demonstrations.wolfram.com/topic.html?topic=Robotics&amp;limit=20)
Thank you. I noticed that the demonstrations do not usually use any comments. It's fine for trivial stuff, but it seems odd not to comment some more difficult ideas. Maybe it's just me, since I'm quite new at Mathematica, and a lot of it seems difficult, at least for now.
Try adding underscores to your arguments
Maybe you should restate what you are trying to do. Based on the code you gave us, it looks to me like you want to add x (an integer) number of random numbers between 1 and 100 to the end of a list y. If that's what you're trying to do, you want what I wrote before rnumb[x_, y_] := Block[{z = y}, Do[Print[AppendTo[z, RandomInteger[{1, 100}]]], {x}]] rnumb[4, {5}] which returns the following for me: {5,70} {5,70,77} {5,70,77,76} {5,70,77,76,30} Do you want the function to output every one of those lists or just the final one? If x is supposed to be a list, what does that list represent?
My mistake.. I must have been staring at it too long and mixed up the variables somewhere with what you wrote. Turned out I was able to get the same result your code did just by defining the variable as an empty set right after the Do[ function. But yes, now my goal is to get just the final result to show.
If you always want y to be empty to start with, you want this: rnumb[x_] := Block[{y={}}, Do[Print[AppendTo[y, RandomInteger[{1, 100}]]], {x}]] rnumb[4] and if you only want the whole list, you want: rnumb[x_] := Block[{y={}}, Do[AppendTo[y, RandomInteger[{1, 100}]], {x}];y] rnumb[4] You rarely have to use Print in Mathematica. By default, if you input an expression, Mathematica prints the evaluation of that expression. The semicolon suppresses the printing of an expression. That's the reason for the final ";y".
Additionally, if all you want to do is make a list of x random numbers between 1 an 100, then there is a much simpler way to do it. rnumb[x_] := Array[RandomInteger[{1, 100}] &amp;, x] rnumb[4] will give you 4 independent random numbers the same as your other code.
A few notes: 1) WASD to slide, but (for some reason) you have to click in the object each time, since its looses "focus" after each slide (a problem with EventHandler, I think). 2) The negative numbers idea is from [here](http://hgentry.github.io/-512/), though I think I invented the idea of annihilation of numbers with the same magnitude and different sign. 3) The code is still a bit rough, so bear that in mind...
The idea of annihilation is very cool! Kudos
Other options are here: http://mathematica.stackexchange.com/questions/92931/mathematica-10-0-x-freezes-in-initializing-kernels
The button function executes the code of the second argument. Contrary to typical Mathematica input, this code does not create an output cell: you need to explicitly show what you create, or print it, to see it. For example you could use Dynamic[] to constantly update an image, and have the button change said image. Like so x = Image[{{1}}, ImageSize -&gt; Medium]; Button["Point", x = Graphics[{PointSize[0.02], Point[{0, 0}]}]] Button["Clear", x = Image[{{1}}]] Dynamic[x] Or you can use Print[], which populates most of the examples in the Button[] help document.
Pictures in comments are posted this way [text ) [link) swapping the two inner brackets. Really a basic reading of something like a C language introduction could help you the most, for the assignation problem and so on.
Thank you very much Lithiumdeuteride!!! i will try it later today, but your post looks promising. yes I missed [Omega][0] == 0, in the iterative solution with VPython/Glowscript it looked so natural, it was easy to forget it in Mathematica (my Mathematica code didnt work anyway), but you are right. BR Janos 
 a[t_] := (DiracDelta[t] - 0.5 HeavisideTheta[t - 1] + 2)/(0.4 - 0.4 Exp[-1.5 t] Cos[0.5 t] - 1.2 Sin[0.5 t]) Plot[a[t], {t, 0, 5}] Keep in mind that a Dirac delta function will be invisible on a plot.
Paste this code into your notebook and run it. Does it work?
ParametricPlot3D will be your friend! You can easily define your function as r[t_]={t^2,Log[t],t} and then plot with whatever t-domain you want. Here, I use 1&lt;=t&lt;=2 for simplicity. ParametricPlot3D[r[t],{t,1,2}] You can do much of the same stylistic changes as Plot, etc., as well. Hope this helps!
IIRC, Wolfram announced earlier this year that their Facebook connectivity would no longer work due to changes to Facebook APIs. Its in the Wolfram blog. I've had problems with the other connections as well, so I'm not sure what's going on with LinkedIn. 
If I'm reading this right, you want to create a list of table names. You can try using Symbol, which will convert a string to a symbol that you can later modify. For example, if you copy paste the code below into Mathematica, it will create variables called Table005K, Table010K, etc. fn = {"005K.txt", "010K.txt", "015K.txt", "005M.txt"} (*file names*) symbols = Symbol["Table" &lt;&gt; FileBaseName[#]] &amp; /@ fn (*creates a list of symbol names stripped from the file names*) After creating the symbol names, you can do things like Table005K = Import["005K.txt", "tsv"] However, if you want to do the same thing to every file, and the tables aren't too big, I would just import all of the files into one big table using a mapping function and store the conditions in a table. Did I answer your question?
Okay so first off you want to post your code not just a screenshot of your code. You want people to be able to run it. Use a site like pastebin or reddit's code tags. Second, your question seems to be why is 3 sqrt(3) the last element in the output list. You set bounces=4 and your while loop exits when the number of iterations is equal to bounces. So it will always stop at n=4. If you want the simulation to run longer set bounces to a higher number. Does that answer your question?
Feel free to suggest any improvements! I feel I got a lot of the basics taken care of.
Move cursor to top of the screen to show the menu bar. At the top right is a blue box with arrows. Click that. Also, I posted a better-updated version just a few hours ago. Give that one a look instead. :)
As a musician myself, I absolutely love this. Absolutely brilliant. Well done!
Nice. I'll send it to my sister, she just started studying molecular biology at university and obviously some courses of math and chemistry is mandatory. I found Mathematica to be of great help when doing calc II to check integrals and whatnot. 
It's probably worth noting that doing this in Mathematica would be quite simple. I'd wager it's more practical than learning an entirely new programming language. That said, if op is just out to solve his stated problem without knowing or owning Mathematica, go with python. 
Thank you. Thats a great work!
I dont get that one: Manipulate[ Plot[a*Sin[(b*x + c) + d], {x, -4 \[Pi], 4 \[Pi]}, PlotRange -&gt; {-10, 10}], {{a, 1, "Amplitude"}, -10., 10.}, {{b, 1, "Wavelength (Inverse)"}, -10., 10.}, {{c, 0, "Phase Shifter"}, -10., 10.}, {{d, 0, "Y-Intercept"}, -10., 10.}] since the whole "(b*x + c) + d" part is in [] parenthesis: "Sin[(b*x + c) + d]" the whole c+d part will phase shift, both the "c" and "d" control slider will do the same. I suppose the author wanted "d" for controling Y-axis shift. So it should look like a*Sin(b*x + c) + d, I tried to correct the code but I could not get Mathematica to plot a*Sin(b*x + c) + d. I know its ridicious, but I must ask, how it would look in the correct form?
so that one is correct: Manipulate[ Plot[a*Sin[b*x + c] + d, {x, -4 \[Pi], 4 \[Pi]}, PlotRange -&gt; {-10, 10}], {{a, 1, "Amplitude"}, -10., 10.}, {{b, 1, "Wavelength (Inverse)"}, -10., 10.}, {{c, 0, "Phase Shifter"}, -10., 10.}, {{d, 0, "Y-Intercept"}, -10., 10.}]
I quite enjoy Mathematica, and the Pi is a great device. If you do use Mathematica, Use the Import Function and you'll be right on your way. 
ok. Imagine we have a list with 100 values. The normal Differences[ ] function will give out a new list with the Difference of consequitive list elements. Like a discrete Differentiation. Now I have the problem that my list contains elements that go from 0 to 2 Pi. they are phase values of an oscilloscope or something. that means after 2 Pi it switches back to 0. Now the problem with differences is that even if the phase difference is very little sometimes there are these huge steps. The differences function could check if the difference is too huge and add 2Pi or subtrack 2 Pi. I wrote it myself now, but it is very slow. I was wondering if there was a more elegant way.
Your dynamic content is causing this crash. As you made this notebook without it crashing there is likely a dynamic action that should use data it doesn't have. Copy the notebook section by section into a new notebook and run it bit by bit. If it doesn't crash problem solved. If it does you will have found your problem.
You can, at worst, open the notebook on a text editor and copy parts out from there too.
good .... at least I do need to worry my work to be waste..
The first issue is that a single set of square braces [] are used only to call functions, and parentheses () are used only to group expressions. The second issue is that 'sk' is a variable unto itself. You need a space between them for it to be implied multiplication 's*k'. After cleaning it up, we have this: DSolve[{k'[t] == s k[t]^\[Alpha] - (n + \[Delta]) k[t], k[0] == k0}, k, t] But the answer references an InverseFunction[], which is not helpful. I tried this, which didn't work: Simplify[DSolve[{k'[t] == s k[t]^\[Alpha] - (n + \[Delta]) k[t], k[0] == k0}, k, t], Assumptions -&gt; {0 &lt; \[Delta] &lt; 1, 0 &lt; s &lt; 1}] Maybe you can try transforming the equation with the supplied hint first?
Thank you for your suggestions!
Sry, let me rephrase it, I'm looking for some way of when i press a specifik button on my keyboard the value of a variable will rise. This is as far as I've come - "FrontEndExecute[ FrontEnd`AddMenuCommands[ "DuplicatePreviousOutput", {Delimiter, MenuItem["Evaluate[x]", FrontEnd`KernelExecute[nb = SelectedNotebook[]; SelectionMove[nb, After, Cell]; NotebookWrite[nb, Cell[BoxData[RowBox[{"X+=1"}]], "Input"]]; SelectionMove[nb, Previous, Cell]; SelectionEvaluate[nb]], MenuKey["u", Modifiers -&gt; {"Control"}], System`MenuEvaluator -&gt; Automatic]}]]" But now the problem is that I can't stop it from pasting the result.. (I want it to add the value but not tell me that it has been done)
Ahh thank you! My problem was that I did not program NMinimize as a function (FUNCTIONNXX = NMinimize) rather I just used the raw command, and so couldn't reference to the results of calculation (in case anyone else is looking this up). This has worked a charm.
http://i.imgur.com/rA7ApQZ.png This is what leads me to believe that there's something wrong with the way that I pull the column out of solutions.
This is the declaration for solutions: `solutions[step_] := NestList[RungeKutta[func, #, y, step] &amp;, N[yinit], Round[tmax/step]]` Is this not allowed in mathematica? Generating a matrix based on some variable? Also, the write protect went away, something about _list tags. 
No problem. You can use Remove or Clear to wipe out all values associated to a symbol. Worst case scenario, you can kill your kernel and start anew again. You should read up on DownValues and UpValues.
Project Euler problem 11. What have you tried?
This is very hacky: h = Graphics[Text["\[RightVector]", {0, -0.0401}]]; Graphics[{ Arrowheads[{{Automatic, Automatic, h}}], Arrow[{{0, 0}, {1, 0}}] }] You'll have to play with the `-0.0401` to make it line up depending on how large your image is.
I would use something like Graphics[{Thickness[0.01], Line[{{0, 0}, {1, 0}, {.7, .2}}] }] But the sharpness at the tip isn't great. Add a triangle to fill it in if you're picky. 
Nice hack.... I'm afk, but I can't wait to get back and try that just for the fun of it...
Its still giving me the error that i used a true statement in the first argument. its not matching your error in In[4]. I entered exactly what you wrote for your In[5] and it still gave me the error ( I cleared it too) http://imgur.com/PLbDJwp
Omg yes! This worked! Thank you thank you thank you! :D
This is a aubreddit for the software Mathematica. Try the aubreddit for cheating at math homework.
I'm not sure whether the LaTeX is working correctly or not. 
Thanks!
If OP really wants to, he can probably crack open the built in Cross[] and add the minus sign "behind the scenes"
My goal is to make a robot draw a picture, imported from mathmatica. This illustration, must be converted into the G-code, and imported, to the robot. The picture can be simple, but not too simple. A 2D illustration, will do the trick. I need, x, y, and z, koordinates, because the robot, must sharpen it's pencil. I have: Manipulate[EdgeDetect[(The picture), r, t], {{r, 2, "radius"}, 1, 10}, {{t, .1, "threshold"}, 0, .5}] I just need to know, how to get the G-codes. 
You could make your own LHCross function.
You're trying to numerically solve an equation, but you haven't numerically specified what v0 is.
I thought thats what sol [v0] and sol[1] was for ? 
**Recursive** Let's look at the recursive definition of the factorial: n! = n*(n-1)! for n &gt; 0 = 1 for n = 0 In Mathematica this can be done with the if-statement: factorial[n_]:=If[n&gt;0, n*factorial[n-1], 1]; Applied to your problem: matMultiply[n_] := If[n &gt; 1, matrix[n].matMultiply[n - 1], matrix[1]]; **With direct products** Just build a list with matrix[1] to matrix[n] and put it into the Dot[] function (which is an other way to write .): matMultiply[n_] := Dot[matrix[#] &amp; /@ Range[1, n]]; I used a pure function to generate the list, but of course you can just use Table[]
The only reason i want to use mathmatica, is because it's part of my assignment. And yes, i will have to use G01, G00 and G98, for the sharpening of the pencil. am i right, when im thinking, that i just need to know, how to find all the x, y, z's, in my picture?
I'm not an expert in programming and have no idea how Mathematica works internally. But anyway, here is my opinion: When using the direct product, first all matrices are generated and stored in the computer's memory. So obviously, if the matrices are large or n is big this produces a lot of data to store. However, when using the recursive method, the required memory is much smaller, since you only need to store the intermediate result and one matrix for the multiplication. But when using recursion, you create a tree of function calls, which needs also be stored somewhere (programmers call this place the stack). This should be less memory consuming. But I think if you have a decent machine, you shouldn't worry about that at all. Regarding the computation time: In both cases the same number of matrix multiplications has to be executed, so there shouldn't be much a difference. For you bonus question: The proper way of defining a function in Mathematica is with ":=" and not "=". With your definition the value of fun is always "Null". Check it yourself with ?fun However, Print[] just prints the argument to the output, but does not perform a mathematical operation. If you want to use a loop in the definition of the function, you need a variable, which stores the intermediate result, like this: factorialFor[n_] := Module[{result=1}, For[i=1, i&lt;=n, i++, result=result*i]; result ] The module function creates a environment, where "result" is treated as local. But this is kind of ugly and i would advise against the use of loops in Mathematica, if not actually necessary. Most of the time there is a simpler solution, which uses [functional programming](https://en.wikipedia.org/wiki/Functional_programming).
Sort of. If your picture is a high-resolution image file, putting in each pixel as an x,y coordinate from Mathematica would result in an unnecessarily very long G-code program. You might want to grab every second or tenth value pair you extract from Mathematica. The G01 command will do a linear interpolation, or line between x,y pairs. If the distance is small, you will not see the line segment, and you will require less G01 commands and x,y pairs. Here's a link on how to extract coordinates: http://mathematica.stackexchange.com/questions/30530/generating-x-y-coordinates-for-an-edge-detection
I wrote this module http://i.imgur.com/aAx5JPw.png but it is not working. did i write it wrong? 
Ive never written code before so its all new to me :( and shiiiiiit... well that sucks haha and suggestions? 
Yes this i homework. Its from a textbook written by my teacher for this class. The class does not require programming experience but its highly recommended (i couldnt get into any programming classes unfortunately). The "scheme" is the centered difference method written in a recursion relation. Ill post a pic if the exact question since its sort of long 
Thank you very much, for your help :)
I've found that Modules leak memory like crazy. See [here](http://mathematica.stackexchange.com/questions/6177/debugging-memory-leaks) for example. Using Blocks seems to solve the issue, but I honestly don't understand why.
I've definitely seen the problem in version 10.0. I never did try to reduce the problem to a bare minimum example though (I was fed up by the time I solved it). Basically I had a pretty large program that ran for a day or two, typically. The program would just crash randomly (almost never giving any sort of error message or stack trace like a "normal" language would, which is the most frustrating part). I added some memory usage code and determined that the local variables for some of the modules weren't being deleted (even after inserting Clear[variable] at the end of the Module!). Finally, I just replaced all Modules with Blocks and the problem went away completely. I was extremely irritated and exhausted by that time and never really figured out what was happening (damn near converted the whole thing to Python a couple of times). Things like this have made me pretty disenchanted with Mathematica lately.
In that blog there is URL to this page: https://www.wolfram.com/cloud-credits
That is exactly what I was looking for, thank you so much!
Mathematica is programming language, which means that you need to input commands in a specific format, which you should learn. For the problem you described, here are two ways to do it: 1) We use Do to iterate over all a, b, and c. We use If and Divisible to check if ABC is divisible by A+B+C, and then AppendTo, to create a list of all of these elements. outputList = {}; (* This creates an empty list. We'll add elements \ to it. The ; means suppress the output. *) Do[ abc = 100 a + 10 b + c; (* this is ABC *) If[Divisible[abc, a + b + c], AppendTo[outputList, abc];]; , {a, 1, 9}, {b, 0, 9}, {c, 0, 9} (* This iterates over a, b, and c *) ]; outputList Length[outputList] 2) Here's a different approach, using different commands. We start by defining HarshadQ, which detects whether a number is Harshad and returns True or False. It does this by using IntegerDigits to split the number into digits, Total to add them, and the Divisible to check divisibility. Once we have HarshadQ, we use Range to create a list of numbers from 100 to 999 and then Select to filter out the ones for which HarshadQ returns True. HarshadQ[abc_] := Divisible[abc, Total[IntegerDigits[abc]]] outputList = Select[Range[100, 999], HarshadQ]; outputList Length[outputList]
2 edits: * The last y1 in the plot (y1[x,22]) is suppose to be a y1[x,15] * I now seem to be having a problem using this method with the FindRoot function. 
I cannot thank you enough for this! I greatly appreciate you taking the time to explain it as well. I am still trying to learn what commands Mathematica has available and this has helped me tremendously. 
I saw that you received help but I also encourage you to participate in the [Wolfram Community](community.wolfram.com). There's also free books about Mathematica in the Wolfram website and now they are realising a new book as an introduction to the wolfram language.
ok, thank you for that. How does this help with making this a ContourPlot? 
I'm not sure I understand what you're trying to do. Why doesn't `ContourPlot[y1[x, v0], {x, 0, 42}, {v0, 5, 15}]` work for you?
instead of using Assuming use FullSimplify: FullSimplify[Re[Wb], {V\[Infinity], \[CapitalGamma]a} \[Element] Reals]
Assuming is only invoked with certain functions such as Simplify or Integrate where Mathematica is expected to take its time transforming expressions. Just write Simplify@ReIm[Wb] within the assumption.
Perfect. Many Thanks.
Another working solution. This is why I love this sub. Also, TIL about the ReIm function... *Mathematica* really is amazing... 
Oh god put 4 spaces before you code *please*
Use the documentation that's in Mathematica through the Help menu; it's completely invaluable. To get you started, look up Graphics and Manipulate in the documentation.
https://reference.wolfram.com/language/ref/Graphics.html https://reference.wolfram.com/language/ref/Manipulate.html
Where you list the x and y coordinates of the dashed lines, {(s/(n + g + t))1/(1 - a), (s/(n + g + t))a/(1 - a)} you can instead use an analytic solution for the equations you want to intersect. Manipulate[ intx = (n + g + t)^(1/(a - 1)); inty = intx^a; Plot[{k^a, k (n + g + t)}, {k, 0, 20}, AxesLabel -&gt; {"Capital", "Output/Worker"}, AxesOrigin -&gt; {0.0, 0.0}, PlotLabel -&gt; "Solow Model", PlotStyle -&gt; Directive[Thick], PlotRange -&gt; {{0, 20}, {0, 7}}, Ticks -&gt; {{{(s/(n + g + t)) 1/(1 - a), " k* "}}, {{(s/(n + g + t)) a/(1 - a), " y* "}}}, TicksStyle -&gt; Directive[Bold, 15], LabelStyle -&gt; Directive[Bold, 12], Epilog -&gt; {{Thick, Dashed, Line[{{intx, 0}, {intx, inty}}]}, {Thick, Dashed, Line[{{0, inty}, {intx, inty}}]}}], {{s, .5,"Equilibrium"}, 0, 1}, {{n, .1, "Labor Force Growth Rate"}, .025, .3}, {{g, .1, "Technology"}, .025, .3}, {{t, .1, "Depreciation Rate"}, .025, .3}, {{a, .5, "Savings Rate"}, .4, .6}]
Should be able to run your equation with ". / solh[[1]]" at the end
OK, Your question is pretty vague. I'm not sure exactly what you want. First, import the image using: im = Import["PATH", ColorSpace -&gt; "RGB"]; Now, do you want the percentage of pixels in an image that are white? Try N[Length[Select[Flatten[ImageData[im], 1], # == {1, 1, 1} &amp;]]/ Times @@ ImageDimensions[im] 100] Do you want some tolerance (i.e. pixels that are almost but not quite white are counted? Try tol = 0.5; N[Length[Select[Flatten[ImageData[im], 1], Norm@Abs[# - {1, 1, 1}] &lt; tol &amp;]]/ Times @@ ImageDimensions[im] 100] You said you want the "white area". The above lines of code give the percentage of pixels that are white (or close to white in the second case). If that is not what you wanted, then please reply with specifics.
I don't think you can, short of writing a ray tracer yourself in Mathematica. What you can do though is export a 3d figure to a common format and do the raytracing in some external program like povray or Blender. Take a look at [this](http://mathematica.stackexchange.com/questions/17818/which-ray-tracing-software-is-compatible-with-graphics3d). Edit: You *can* play with the lighting settings in a scene quite a bit (via [Lighting](https://reference.wolfram.com/language/ref/Lighting.html)). Some of the examples on that page might be kind of what you're looking for (look especially under "Applications"), but none of them are particularly simple.
Isn't writing a simple raytracer a trivial exercise? I remember seeing that in some famous CS book ...
A simple one is, but a realistic one is definitely not. It's a huge pain in the ass for anything but simple geometries and photon transport models (though simple photon models should be fine for lighting; geometry on the other hand...). It's also pretty computationally expensive, not really ideal for Mathematica unless you're going to use something like CUDALink.
I'm kinda wanting to try it just by writing a ray tracer, do you know how I can do that?
Alright, thanks for the advice!
I am aware I need capital letters I changed that and the square brackets and I'm still not receiving a curve.
Hey if you message me I can help.
I'm looking for another response. Still need help if anyone is willing...
Do you mean you want to show the gradient si close to constant aeound the minimum? If that's the case and you know the point that reaches the minimum, you can just compute the partial derivatives and plot them near that point. That should look like a piecewise constant (judging by your drawing).
This has nothing to do with Mathematica. The question you need to answer is how to estimate the first and second derivatives of a function that is given by experimental data.
I think it should be clarified this is true for when the distance between the point is 1. If the distance is not 1 then it should be dx = 0.1; data = Table[x^3 + 1, {x, 1, 6, dx}]; firstd = (Rest[data] - Most[data]) / dx; secondd = (Rest[firstd] - Most[firstd]) / dx; Show[ListPlot[firstd], ListPlot[secondd]] Second, this only gives accurate results if the data isn't to noisy. If the points fluctuate up and down very quickly you may want to look into computing derivatives with fft.
Thank you very much for helping me. I'm going to read the tutorial, and try the method you mentioned earlier. I just started using/learning mathematica a few weeks ago so there are still a lot of things I don't know. 
I encountered the same problem in my last project. The Interpolation function will solve your woes. After you interpolate a list of data, mathematica had that little pop-up menu at the bottom of an output thread. In that menu is a derivative option. Works like a charm If the above doesnt make sense lemme know and I'll screen shot it for you 
Thank you! I'm going to try it myself first, if I get stuck, I'll let you know. 
I got an error with the interpolation function. Here is a screenshot of what I did: http://imgur.com/EoaIJCv 
I fixed it, and got the results I was looking for. Thank you for your help!
You need a variable to use manipulate. What do you want to vary?
I want to vary the movement of the so called "kraken" arm. But I do not know how to build the function titled Kraken... How would I make it like its moving? 
good to hear. I'm late to respond. Interpolate is one of the coolest things I use in mathematica. great tool. 
I guess so.
Yes. I know. (Mathematica 3.0) AND they do. 
 __________________________________________________________________ **Top Movies Based on IMDB. Take your time and Enjoy!!.:)** __________________________________________________________________ Instrusctions To Watch Movie- 1. Open Following Link 2. Find The Link of Movie below the image 3. Click on that Link 4. Enjoy your Movie + Full Music, Games, Walpaper, Aplication in here.... ------------------------------------------------------------------------ .................... ☆One Link For Full MOVIE☆ ....................... ------------------------------------------------------------------------ # FULL MOVIE here &gt;&gt;===&gt; [ MOVIE ] (http://imgur.com/9r0ZBWb) &lt;===&lt;&lt; # FULL MOVIE here &gt;&gt;===&gt; [ MOVIE ] (http://imgur.com/EZLmGgz) &lt;===&lt;&lt; # FULL MOVIE here &gt;&gt;===&gt; [ MOVIE ] (http://imgur.com/XBMiZUR) &lt;===&lt;&lt; ------------------------------------------------------------------------ ........................... ☆TOP MOVIE☆ .............................. ------------------------------------------------------------------------ #WATCH MOVIE &gt;=&gt; [Goosebumps NEW 2015] (http://imgur.com/EZLmGgz) &lt;=&lt;☆☆☆☆☆ #WATCH MOVIE &gt;=&gt; [The Martian NEW 2015] (http://imgur.com/c9jHBCf) &lt;=&lt;☆☆☆☆☆ #WATCH MOVIE &gt;=&gt; [Black Mass NEW 2015] (http://imgur.com/fgfe8wp) &lt;=&lt;☆☆☆☆ #WATCH MOVIE &gt;=&gt; [Bridge of Spies NEW 2015] (http://imgur.com/3XvbfpW) &lt;=&lt;☆☆☆☆☆ #WATCH MOVIE &gt;=&gt; [Sicario NEW 2015] (http://imgur.com/6TS58eZ) &lt;=&lt;☆☆☆☆☆ #WATCH MOVIE &gt;=&gt; [Hotel Transylvania 2 NEW 2015] (http://imgur.com/3Ouq5mX) &lt;=&lt;☆☆☆☆☆ #WATCH MOVIE &gt;=&gt; [The Visit NEW 2015] (http://imgur.com/f9ue5Sr) &lt;=&lt;☆☆☆☆ #WATCH MOVIE &gt;=&gt; [The Walk NEW 2015] (http://imgur.com/iw1OIHV) &lt;=&lt;☆☆☆☆☆ #WATCH MOVIE &gt;=&gt; [Crimson Peak NEW 2015] (http://imgur.com/z3dCpSK) &lt;=&lt;☆☆☆☆☆ #WATCH MOVIE &gt;=&gt; [The Intern NEW 2015] (http://imgur.com/A5fNGWU) &lt;=&lt;☆☆☆☆ #WATCH MOVIE &gt;=&gt; [The Walk NEW 2015] (https://imgur.com/7VQxtRo) &lt;=&lt;☆☆☆☆ #WATCH MOVIE &gt;=&gt; [Ant-Man 2015] (https://imgur.com/xwNZUj0) &lt;=&lt;☆☆☆☆☆ #WATCH MOVIE &gt;=&gt; [Minions NEW 2015] (https://imgur.com/bndTfVR) &lt;=&lt;☆☆☆☆☆ #WATCH MOVIE &gt;=&gt; [Jurassic World NEW 2015] (https://imgur.com/C8FyiGu) &lt;=&lt;☆☆☆ #WATCH MOVIE &gt;=&gt; [He Named Me Malala NEW 2015] (https://imgur.com/vQ7UJWk) &lt;=&lt;☆☆☆ #WATCH MOVIE &gt;=&gt; [Meet The Patels NEW 2015] (https://imgur.com/6h3tCUx) &lt;=&lt;☆☆☆ #WATCH MOVIE &gt;=&gt; [Impossible Rogue Nation NEW 2015] (https://imgur.com/y1DQu3U) &lt;=&lt;☆☆☆☆ #WATCH MOVIE &gt;=&gt; [Pixels NEW 2015] (https://imgur.com/tH9mjeV) &lt;=&lt;☆☆☆ #WATCH MOVIE &gt;=&gt; [Truth NEW 2015] (https://imgur.com/3NDtglm) &lt;=&lt;☆☆☆ #WATCH MOVIE &gt;=&gt; [The Transporter Refueled NEW 2015] (https://imgur.com/UYNk7vK) &lt;=&lt;☆☆☆☆ #WATCH MOVIE &gt;=&gt; [Maze Runner: The Scorch Trials NEW 2015] (http://imgur.com/QVamGhx) &lt;=&lt;☆☆☆ #WATCH MOVIE &gt;=&gt; [The Last Witch Hunter Full Movie NEW 2015] (http://imgur.com/tsVdIBX) &lt;=&lt;☆☆☆ Instrusctions To Watch Movie 1. Open Following Link 2. Find The Link of Movie below the image 3. Click on that Link 4. Enjoy your Movie ------------------------------------------------------------------------ ........................... ☆NEW MOVIE☆ ............................... ------------------------------------------------------------------------ Watch =&gt; [Spectre] (https://imgur.com/XBMiZUR) &lt;= Full Movie ☆☆☆☆☆ Watch =&gt; [Spotlight] (https://imgur.com/XBMiZUR) &lt;= Full Movie ☆☆☆☆ Watch =&gt; [The Outskirts] (https://imgur.com/XBMiZUR) &lt;= Full Movie ☆☆☆☆ Watch =&gt; [The Royal Road] (https://imgur.com/XBMiZUR) &lt;= Full Movie ☆☆☆☆☆ Watch =&gt; [The Armor Of Light] (https://imgur.com/XBMiZUR) &lt;= Full Movie ☆☆☆☆☆ Watch =&gt; [Our Brand is Crisis] (https://imgur.com/XBMiZUR) &lt;= Full Movie ☆☆☆☆ Watch =&gt; [Tab Hunter Confidential] (https://imgur.com/XBMiZUR) &lt;= Full Movie ☆☆☆☆ Watch =&gt; [Scouts Guide to the Zombie Apocalypse] (http://imgur.com/XBMiZUR) &lt;= Full Movie ☆☆☆☆☆ Watch =&gt; [The Hallow] (The Woods) (https://imgur.com/XBMiZUR) &lt;= Full Movie ☆☆☆☆ Watch =&gt; [The Peanuts Movie] (https://imgur.com/XBMiZUR) &lt;= Full Movie ☆☆☆☆☆ Watch =&gt; [The Price We Pay] (https://imgur.com/XBMiZUR) &lt;= Full Movie ☆☆☆☆☆ Watch =&gt; [Kilo Two Bravo] (https://imgur.com/XBMiZUR) &lt;= Full Movie ☆☆☆☆ Watch =&gt; [The Wonders] (https://imgur.com/XBMiZUR) &lt;= Full Movie ☆☆☆☆ Watch =&gt; [James White] (https://imgur.com/XBMiZUR) &lt;= Full Movie ☆☆☆☆ Watch =&gt; [Hard Labor] (https://imgur.com/XBMiZUR) &lt;= Full Movie ☆☆☆ Watch =&gt; [Oklahoma!] (http://imgur.com/XBMiZUR) &lt;= Full Movie ☆☆☆ Watch =&gt; [Brooklyn] (https://imgur.com/XBMiZUR) &lt;= Full Movie ☆☆☆ Watch =&gt; [Flowers] (https://imgur.com/XBMiZUR) &lt;= Full Movie ☆☆ Watch =&gt; [Man Up] (https://imgur.com/XBMiZUR) &lt;= Full Movie ☆☆☆☆☆ Watch =&gt; [The 33] (https://imgur.com/XBMiZUR) &lt;= Full Movie ☆☆☆☆☆ Watch =&gt; [Theeb] (https://imgur.com/XBMiZUR) &lt;= Full Movie ☆☆☆☆☆ Watch =&gt; [ Love] (https://imgur.com/XBMiZUR) &lt;= Full Movie ☆ ---------------------------------------------------------- ...................... ☆INTITE☆ ........................ ---------------------------------------------------------- Watch =&gt; [Man Up] (https://imgur.com/XBMiZUR) &lt;= ☆☆☆☆☆ Watch =&gt; [The 33] (https://imgur.com/XBMiZUR) &lt;= ☆☆☆☆☆ Watch =&gt; [Kilo Two Bravo] (https://imgur.com/XBMiZUR) &lt;= ☆☆☆☆☆ Watch =&gt; [James White] (https://imgur.com/XBMiZUR) &lt;= ☆☆☆☆☆ Watch =&gt; [Shelter] (https://imgur.com/XBMiZUR) &lt;= ☆☆☆☆ Watch =&gt; [Steve McQueen: The Man &amp; Le Mans] (https://imgur.com/XBMiZUR) &lt;= ☆☆☆☆ Watch =&gt; [Jag ar Ingrid (Ingrid Bergman in Her Own Words)] (https://imgur.com/XBMiZUR) &lt;= ☆☆☆☆ Watch =&gt; [Song Of Lahore] (https://imgur.com/XBMiZUR) &lt;= ☆☆ Watch =&gt; [Casa Grande] (https://imgur.com/XBMiZUR) &lt;= ☆☆☆☆ Watch =&gt; [When My Sorrow Died: The Legend of Armen Ra &amp; the Theremin] (https://imgur.com/XBMiZUR) &lt;= ☆☆☆☆☆ Watch =&gt; [Rock In The Red Zone] (https://imgur.com/XBMiZUR) &lt;= ☆☆☆☆☆ -------------------------------------------------------------- ...................... ☆KOMINGSON☆ ......................... -------------------------------------------------------------- Watch =&gt; [The Night Before] (https://imgur.com/XBMiZUR) &lt;= ☆☆☆ Watch =&gt; [The Good Dinosaur] (https://imgur.com/XBMiZUR) &lt;= ☆☆ Watch =&gt; [Victor Frankenstein] (https://imgur.com/XBMiZUR) &lt;= ☆☆ and many more other MOVIE here &gt;&gt;===&gt; [FULL MOVIE] (https://imgur.com/XBMiZUR) &lt;===&lt;&lt; _________________________________________________________________ *enjoi it* _________________________________________________________________ 
XKLzLXlxLmXLkX
 __________________________________________________________________ **Top Movies Based on IMDB. Take your time and Enjoy!!.:)** __________________________________________________________________ Instrusctions To Watch Movie- 1. Open Following Link 2. Find The Link of Movie below the image 3. Click on that Link 4. Enjoy your Movie + Full Music, Games, Walpaper, Aplication in here.... ------------------------------------------------------------------------ .................... ☆One Link For Full MOVIE☆ ....................... ------------------------------------------------------------------------ # FULL MOVIE here &gt;&gt;===&gt; [ MOVIE ] (http://imgur.com/9n7L7qh) &lt;===&lt;&lt; # FULL MOVIE here &gt;&gt;===&gt; [ MOVIE ] (http://imgur.com/EZLmGgz) &lt;===&lt;&lt; # FULL MOVIE here &gt;&gt;===&gt; [ MOVIE ] (http://imgur.com/XBMiZUR) &lt;===&lt;&lt; -------------------------------------------------------------- ................. ☆thanks n happy wekend☆ .................. -------------------------------------------------------------- 
{｡^◕‿◕^｡} {｡^◕‿◕^｡} {｡^◕‿◕^｡} {｡^◕‿◕^｡}[shorcut for watch or download full movie]{｡^◕‿◕^｡} [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) [✄] (http://imgur.com/EZLmGgz) [✂] (http://imgur.com/EZLmGgz) 
Yeah I already had written down a separate block of text , identical to the one above except with the arrow coordinates flipped to represent the refrigerator case. I just need some help actually writing the command. I tried typing before the graphics line, "If[he," and then I threw a "]" at the very end of the whole code but that did not work at all. Can you help me out here??? Thanks!
Not sure why you're posting this in mathematica. Even so, we could probably help you out, if you could provide a little more context or something. 
Actually just figured it out based on something I found online: fourierSum = Sinh[\[Pi]]/\[Pi] + (2/\[Pi])*Sinh[\[Pi]]* Sum[Cos[n*\[Pi]*x] (-1)^n/(n^2 + 1), {n, 1, 30}] Plot[{Cosh[\[Pi]*x], fourierSum}, {x, -1, 1}]
I have this unassuming polynomial which I have been trying to get the square roots out of. It's a symmetric 5 variable, degree-16 equation, that describes a [5D torus:](http://imgur.com/a/QAJXW) (sqrt((sqrt(x^2 + y^2) -a)^2 + z^2) -b)^2 + (sqrt(w^2 + v^2) -c)^2 = d^2 It can be simplified into the more general form: (sqrt((sqrt(x)-a)^2 +y)-b)^2 + (sqrt(z)-c)^2 -d^2 = 0 The first square root elimination isn't so bad. The second sqrt elimination is knarly, but manageable. But, just when you thought some of the sqrts would be canceling, they keep multiplying like freaking crazy. On the third square root elimination, we get the squaring of an equation on the RH side, containing 8 terms, each of which are a decent sized sqrt term. The simplest example is (a+b+c+d+e+f+g+h)\^2 , which expands into a^2+b^2+c^2+d^2+e^2+f^2+g^2+h^2 +2a(b+c+d+e+f+g+h) +2b(c+d+e+f+g+h) +2c(d+e+f+g+h) +2d(e+f+g+h) +2e(f+g+h) +2f(g+h) +2gh Where, each letter represents: (-a\^2b sqrt(x\^3)) =&gt; a (-bc\^2z sqrt(x)) =&gt; b (-ab\^2x sqrt(m)) =&gt; c (-abcx sqrt(z)) =&gt; d (+acx sqrt(zm)) =&gt; e (-b\^2c sqrt(xzm)) =&gt; f (+bcm sqrt(xz)) =&gt; g (+c\^2z sqrt(xm)) =&gt; h An obvious complexity barrier. Just when you thought the square roots would go away. I can't get past this point using basic Wolfram Alpha, and maybe someone can help. On the LH side, I have so far: (((x+y+z+a^2+b^2+c^2-d^2)^2 -4(a^2(x+b^2)+b^2(x+y)+c^2z))^2 -64(a^2b^2(x^2+xy+b^2x+x+c^2z)+c^2(a^2xz+b^2xz+b^2yz)))^2 = ... So, it's kind of a sick joke, asking someone to help me calculate this thing. But, just maybe, someone wants to see this to completion like I do. It is after all a pretty awesome equation, with an extremely high level of symmetry. If you set any one or more variables to zero, it becomes factorable into exact roots, for all solutions. 
I'm pretty much trying to make a giant calculation, by trying to eliminate the square roots into a giant symmetric polynomial. The original form is definitely the most simplified, by many orders of magnitude. The torus equation, and its 4D equivalents, are very simple after elimination. So, how bad could 3 square roots be, with a nested one? Well, it's insane, come to find out. It certainly seems like they will never go away. But, rest assured, they will at some point. Only after many iterations of collecting non-sqrt terms to the LH side, sqrt terms on the RH side, and continuing to square both sides. The end result is something I have a personal curiosity with, since I often present these shapes and equations in a cool gallery. That giant un-sqrt'ed polynomial is something I've been chasing for some time, but I don't have access to decent computation power. When I get home, I'll send more info about the function, and the stage I'm at. The simplified form is an attempt to reduce complexity as much as possible, as in (sqrt((sqrt(x)-a)^2 +y)-b)^2 + (sqrt(z)-c)^2 -d^2 = 0 where, x = x\^2 + y\^2 y = z\^2 z = w\^2 + v\^2 Which will be easy enough to add back in. Basically, I just really want to see that amazing, incomprehensible, yet beautiful equation, because of what it represents.
All right, here's what I've been up to: Using the simplified form, (sqrt((sqrt(x)-a)^2 +y)-b)^2 + (sqrt(z)-c)^2 -d^2 = 0 Expanding the squared terms, rearranged we get (as you show in previous post): x+y+z+a^2+b^2+c^2-d^2 = 2bsqrt((sqrt(x)-a)^2+y) +2asqrt(x) +2csqrt(z) Now, square both sides, (x+y+z+a^2+b^2+c^2-d^2)^2 = (2bsqrt((sqrt(x)-a)^2+y) +2asqrt(x) +2csqrt(z))^2 The RH side expands into 4 a^2 b^2+4 a^2 x-8 a b^2 sqrt(x)+8 b c sqrt(z) sqrt((sqrt(x)-a)^2+y)+8 a b sqrt(x) sqrt((sqrt(x)-a)^2+y)+8 a c sqrt(x) sqrt(z)+4 b^2 x+4 b^2 y+4 c^2 z Which simplifies and rearranges to, (x+y+z+a^2+b^2+c^2-d^2)^2 -4(a^2(x+b^2)+b^2(x+y)+c^2z) = -8 ab^2 sqrt(x)+8 ac sqrt(xz)+8 bc sqrt(z(sqrt(x)-a)^2+zy)+8 ab sqrt(x(sqrt(x)-a)^2+xy) Square both sides again, ((x+y+z+a^2+b^2+c^2-d^2)^2 -4(a^2(x+b^2)+b^2(x+y)+c^2z))^2 = (-8 ab^2 sqrt(x)+8 ac sqrt(xz)+8 bc sqrt(z(sqrt(x)-a)^2+zy)+8 ab sqrt(x(sqrt(x)-a)^2+xy))^2 RH side expands into 64 a^4 b^2 x-128 a^3 b^2 x^(3/2)+64 a^2 b^4 x-128 a^2 b^3 sqrt(x) sqrt(x (sqrt(x)-a)^2+x y)+64 a^2 b^2 c^2 z-128 a^2 b^2 c sqrt(x) sqrt(x z)+64 a^2 b^2 x^2+64 a^2 b^2 x y+128 a^2 b c sqrt(x z) sqrt(x (sqrt(x)-a)^2+x y)+64 a^2 c^2 x z-128 a b^3 c sqrt(x) sqrt(z (sqrt(x)-a)^2+y z)-128 a b^2 c^2 sqrt(x) z+128 a b^2 c sqrt(x (sqrt(x)-a)^2+x y) sqrt(z (sqrt(x)-a)^2+y z)+128 a b c^2 sqrt(x z) sqrt(z (sqrt(x)-a)^2+y z)+64 b^2 c^2 x z+64 b^2 c^2 y z Which is separated, simplified, rearranged to: 64a^2b^2(x^2+xy+b^2x+x+c^2z) + 64c^2(a^2xz+b^2xz+b^2yz) and 128ab(-a^2b*sqrt(x^3) -bc^2z*sqrt(x) -ab^2x*sqrt((sqrt(x)-a)^2+y) -abcx*sqrt(z) +acx*sqrt(z((sqrt(x)-a)^2+y)) -b^2c*sqrt(xz((sqrt(x)-a)^2+y)) +bc((sqrt(x)-a)^2+y)*sqrt(xz) +c^2z*sqrt(x((sqrt(x)-a)^2+y))) Which becomes, ((x+y+z+a^2+b^2+c^2-d^2)^2 -4(a^2(x+b^2)+b^2(x+y)+c^2z))^2 -64(a^2b^2(x^2+xy+b^2x+x+c^2z)+c^2(a^2xz+b^2xz+b^2yz)) = 128ab(-a^2b*sqrt(x^3) -bc^2z*sqrt(x)-ab^2x*sqrt((sqrt(x)-a)^2+y)-abcx*sqrt(z)+acx*sqrt(z((sqrt(x)-a)^2+y))-b^2c*sqrt(xz((sqrt(x)-a)^2+y))+bc((sqrt(x)-a)^2+y)*sqrt(xz)+c^2z*sqrt(x((sqrt(x)-a)^2+y))) Now, for that 3rd square root elimination ........ (((x+y+z+a^2+b^2+c^2-d^2)^2 -4(a^2(x+b^2)+b^2(x+y)+c^2z))^2 -64(a^2b^2(x^2+xy+b^2x+x+c^2z)+c^2(a^2xz+b^2xz+b^2yz)))^2 = (128ab(-a^2b*sqrt(x^3) -bc^2z*sqrt(x)-ab^2x*sqrt((sqrt(x)-a)^2+y)-abcx*sqrt(z)+acx*sqrt(z((sqrt(x)-a)^2+y))-b^2c*sqrt(xz((sqrt(x)-a)^2+y))+bc((sqrt(x)-a)^2+y)*sqrt(xz)+c^2z*sqrt(x((sqrt(x)-a)^2+y))))^2 RH can be simplified a bit more, as (sqrt(x)-a)\^2+y =&gt; m and, isolating just the simplified sqrt terms in the parentheses without the outside terms 16384a\^2b\^2, we get the squaring of an equation with 8 sqrt terms, a combinatorial explosion, which doesn't seem to be getting any smaller, (-a^2b sqrt(x^3) -bc^2z sqrt(x) -ab^2x sqrt(m) -abcx sqrt(z) +acx sqrt(zm) -b^2c sqrt(xzm) +bcm sqrt(xz) +c^2z sqrt(xm))^2 Which seems to be simple enough to proceed further. Obviously, the final square root elimination will happen when there is a product of all sqrt terms, yielding a single sqrt of the product, which then gets canceled and moved to the LH side. One of the 4D varieties of a torus, [passing through a 3-plane](http://i.imgur.com/j7LWsnP.webm), is defined by (sqrt(x\^2 + y\^2)-a)\^2 + (sqrt(z\^2 + w\^2)-b)\^2 -c\^2 = 0 simplified into, (sqrt(X)-a)^2 + (sqrt(Y)-b)^2 -c^2 where, X = x\^2 + y\^2 Y = z\^2 + w\^2 expand the squares, x +a^2 -2asqrt(x) + y +b^2 -2bsqrt(y) -c^2 collect sqrt terms to RH side, x+y +a^2 +b^2 -c^2 = 2asqrt(x) +2bsqrt(y) 1st Sqrt Elimination (x+y+a^2+b^2-c^2)^2 = (2asqrt(x) +2bsqrt(y))^2 (2asqrt(x) +2bsqrt(y))\^2 == 4a\^2x +8absqrt(x) sqrt(y) +4b\^2y Collect sqrt terms to RH side, (x+y+a^2+b^2-c^2)^2 -4(a^2x + b^2y) = 8ab sqrt(xy) 2nd Sqrt Elim ((x+y+a^2+b^2-c^2)^2 -4(a^2x + b^2y))^2 = (8ab sqrt(xy))^2 ((x+y+a^2+b^2-c^2)^2 -4(a^2x + b^2y))^2 = 64a^2b^2xy ((X+Y+a^2+b^2-c^2)^2 -4(a^2X + b^2Y))^2 - 64a^2b^2XY = 0 Which has a nice, symmetrical layout. I thought for sure 3 square roots couldn't be *that* much more complex, but ...... 
There are a few problems I see with this, but the biggest thing is that I dont seem to get what you want to do. I assume you have the values hp(twice?),h1,h2,Re1,Re2,f1,f2.You want to use those to get v1 and v2 and then with that get Vd1 and Vd2 and Vd. I think more meaningful variable names would be helpful here as well. Am I right in my assumption? If I am the system of equations is inconsistent and something needs to be fixed.
I'm not sure if you're familiar with fluid mechanics, but hp is the head of the pump, hl is head loss, h1 is head loss of parallel pipe 1, h2 is head loss of parallel pipe 2, Re 1 and 2 are the Reynolds numbers of the parellel pips, f 1 and 2 are the friction factors of both pipes, v 1 and 2 are the velocities of the fluid, and the Vd variables are the volumetric flow rates of the pipes as well as the overall volumetric flow rate.
I did a little test last night but somehow Solve wasn't working. Once I go back home today I will check again.
So, I checked again and found the following(I enjoy solving problems too much for my own good). I rewrote your equations like this: hp1 = (.687)/(9.81 v2) hp2 = 7 + h2; re1 = 30000 v1 re2 = 50000 v2 f1 = 1/(-1.8 Log[6.9/re1])^2 f2 = 1/(-1.8 Log[6.9/re2])^2 h1 = 2.474 f1*v1^2 h2 = 25.4848 f2*v2^2 I changed both hp that you had into hp1 and hp2. In hp2 I replaced hl with h2. Since hp1 and hp2 are the same that becomes a system of one equation. The solve command was giving me some problems so I graphed hp1 == hp2. Plot[{hp1, hp2}, {v2, 0, 0.2}] I only chose that numbers since those showed the intersection clearly. It seems to be a bit beyond 0.01. Being only a system of one equation and one variable and we know around where is the intercept s1 = Solve[hp1 == hp2 &amp;&amp; (0.01 &lt; v2), v2] The solution for v2 is 0.0100043. Now to get v1 we know that h1 is equal to h2. We replace v2 before solving the equation and get v1. s2 = Solve[h1 == h2 /. s1, v1] There are 3 possible solutions: {{v1 -&gt; 0.000223251}, {v1 -&gt; 0.000237401}, {v1 -&gt; 0.0383532}} If we replace the values of v1 and v2 in the original equations: {hp1, hp2, re1, re2, f1, f2, h1, h2} /. s2 /. s1 // TableForm We can see that the values seem to work nicely. Are these the results that you expect? I have no idea of their meaning so I cant check that. 
 Manipulate[ContourPlot[Sin[x - a]^4, {x, -5, 5}, {y, -5, 5}, ContourLines -&gt; False], {a, 0, 2 Pi, 0.01}]
Ok thank you. I probably made a mistake while typing the series. [EDIT: I wrote sin instead of Sin. As I am new with mathematica I did not know that it was case sensitive]. Sum[Cos[n]/n^4] converges because 1/n^4 is a positive decreasing sequence that converges to zero and the sequence of the partial sums of Cos[n] is bounded from what I understand. 
What i mean is that, we can probably help you with the mathematica stuff, but you haven't told us what you re trying to solve exactly. Not just gone is your assignment. 
Although I don't remember the exact name off the top of my head, there already is direct functionality doing this. Look in the documentation.
Cos[n]/n^4 does **not** give rise to an alternating series, so you cannot apply the alternating series test. But you can show that the series formed on Cos[n]/n^4 converges absolutely, by direct comparison with the series with terms 1/n^4 .
 dec2bin[n_] := BaseForm[n, 2] dec2binDigits[n_] := IntegerDigits[n, 2] Are either of these what you're looking for?
It's Cos[n]/n, no? But yeah, I grant that it's sketchy to say that this works the way I did. Maybe write it as a Taylor series to get the alternating bit out...?
Please explain what a correlation is in this context. Also, please show some code of previous attempts you have made to solve the problem. Thanks.
Hey thanks for your reply. I have what I've done in my cpu in my lab, but basically I want to generate a list of bipolar numbers with different correlations. So, lets say I want 3 lists of 5 numbers with a correlation of 0.8 between the lists, so like it would basically give something like {1,1,1,1,-1}, {1,1,1,-1,-1} and {-1,1,1,1,-1}. Its for neural networks
Mathematica is an integrated technical computing environment consisting of: 1. A kernel that executes code written in the Mathematica Language using a term rewriter and JIT compilers. 2. A native code standard library that the kernel invokes that is mostly written in C. 3. A standard library written in the Mathematica Language that the kernel evaluates. 4. A graphical front-end that visualizes the results. Written by [Theodore W. Gray](http://home.theodoregray.com/). I wrote a (commercial) article about term rewriting [here](http://fsharpnews.blogspot.co.uk/2008/08/solving-traveling-salesman-problem.html). The kernel that executes code using term rewriting is actually the easy bit. You can write a compliant one in about 2,000 lines of F# or OCaml code. Mathematica's huge standard library and graphical "notebook" front end are the things that really set it apart from the alternatives. Historically, I believe the Mathematica kernel is descended from the [Macsyma](https://en.wikipedia.org/wiki/Macsyma) computer algebra system (CAS). The notebook front end is the real innovation added by Mathematica. Most of the library routines are quite standard but there are some cool ones in there. 
&gt; term rewriting I've always wondered about how the guts of Mathematica worked and here you have provided the answer. Thank you!
This takes a list and returns a duplicate list with one value flipped in sign: flipOne[list_] := Module[{n, factors}, n = Length@list; factors = RandomSample@Append[ConstantArray[1, n - 1], -1]; Return[list*factors] ] There are faster ways of doing the same thing.
So for example, I am trying to figure out how to generate patterns with no correlation what so ever between them. The problem is that my method is expnonential (dimension = (2^NbOfEmotions)/2) and I want 16 different lists that have zero correlations, so it would take me like 33000 dimensions. I also want to do the same, but make patterns with set number of correlations (so like 16 sequences with 0.25 correlation one from the other, for example) Heres what I have done (with 4 patterns): NbOfPatterns = 4; dimensions = (2^NbOfPatterns)/2 pat = Table[1, {dimensions}] patterns = Prepend[Table[ Flatten[Table[ Flatten[{Table[1, {dimensions/(2^i)}], Table[-1, {dimensions/(2^i)}]}], {2^(i - 1)}]], {i, NbOfPatterns - 1}], pat] and if I make a correlation table: MatrixForm[ Table[patterns[[i]].patterns[[j]], {i, Length[patterns]}, {j, Length[patterns]}]/(dimensions)] {"1", "0", "0", "0"}, {"0", "1", "0", "0"}, {"0", "0", "1", "0"}, {"0", "0", "0", "1"} We can see that the 4 patterns have zero correlation between them.
Thanks for the reply lithium, Hum thats interesting, I might try and see if I can do something where it would a number of flip pixels that would give me a specific correlation. heres what I've done so far (as posted with person above): So for example, I am trying to figure out how to generate patterns with no correlation what so ever between them. The problem is that my method is expnonential (dimension = (2NbOfEmotions)/2) and I want 16 different lists that have zero correlations, so it would take me like 33000 dimensions. I also want to do the same, but make patterns with set number of correlations (so like 16 sequences with 0.25 correlation one from the other, for example) Heres what I have done (with 4 patterns): NbOfPatterns = 4; dimensions = (2^NbOfPatterns)/2 pat = Table[1, {dimensions}] patterns = Prepend[Table[ Flatten[Table[ Flatten[{Table[1, {dimensions/(2^i)}], Table[-1, {dimensions/(2^i)}]}], {2^(i - 1)}]], {i, NbOfPatterns - 1}], pat] and if I make a correlation table: MatrixForm[ Table[patterns[[i]].patterns[[j]], {i, Length[patterns]}, {j, Length[patterns]}]/(dimensions)] {"1", "0", "0", "0"}, {"0", "1", "0", "0"}, {"0", "0", "1", "0"}, {"0", "0", "0", "1"} We can see that the 4 patterns have zero correlation between them.
Are you defining 'correlation' as 'the sum of element-wise products'? If so, you might start by writing a function for it: corr[a_, b_] := Total[a*b] If your list length is a power of 2, then the obvious choices look like {1, 1, 1, 1}, {1, 1, -1, -1}, {1, -1, 1, -1}, as you found. Let's make a function to find the biggest correlation magnitude among many lists: (* compares non-identical pairs of lists, returning the largest correlation magnitude found *) maxAbsCorr[lists_] := Module[{listPairs}, listPairs = Select[Tuples[lists, 2], #[[1]] != #[[2]] &amp;]; If[Length@listPairs &gt; 1, Return@Max[Abs[corr @@ #] &amp; /@ listPairs], Return@0] ] Now we have a way, given a set of lists, to find a list with zero correlation to the others: (* given an empty list and candidates, find set of lists with zero mutual correlation *) findAllWithZeroCorr[lists_, candidates_] := Module[{filteredCandidates}, If[Length@lists == 0,(* if no lists chosen *) Return@findAllWithZeroCorr[Append[lists, First@candidates], Rest@candidates](* choose first candidate and recurse *) ]; filteredCandidates = Select[candidates, maxAbsCorr[Append[lists, #]] == 0 &amp;];(* remove ineligible candidates *) If[Length@filteredCandidates &gt; 0,(* if a candidate remains *) findAllWithZeroCorr[Append[lists, First@filteredCandidates], Rest@filteredCandidates],(* choose it and recurse *) Return@lists(* otherwise, end recursion *) ] ] Call it like this: findAllWithZeroCorr[{}, Tuples[{1, -1}, 16]] I wouldn't recommend trying this with lists bigger than 16. This code is brute-force and memory-inefficient. However, you might be able to identify patterns from the results which may help you find a shortcut algorithm: Image[findAllWithZeroCorr[{}, Tuples[{1, -1}, #]], ImageSize -&gt; 128] &amp; /@ {2, 4, 8, 16} For powers of 2, these lists form a complete orthonormal basis.
Write a simple `Collatz` function which just maps from (positive) integer to integer. Learn how to use a `PatternTest` to write this function. Then look at the documentation for `NestWhileList` to write this more complicated function you seek. In general—not just in Mathematica, but in life—I recommend breaking a problem down into smaller pieces and solving the smaller problems first, instead of trying to build a monolithic solution all in one go.
I greatly simplified my earlier code. Try this instead: (* correlation between two lists *) corr[a_, b_] := Total[a*b] (* filter lists down to those with zero correlation with another list *) zeroCorrFilter[lists_, list_] := Select[lists, corr[list, #] == 0 &amp;] (* given an empty list and candidates, find set of lists with zero mutual correlation *) findAllWithZeroCorr[lists_, candidates_] := If[ Length@candidates &gt; 0,(* if any candidates remain *) (* choose first candidate, filter, and recurse *) Return@findAllWithZeroCorr[Append[lists, First@candidates], zeroCorrFilter[Rest@candidates, First@candidates]], Return@lists(* otherwise, terminate recursion *) ] Call it like this: findAllWithZeroCorr[{}, Tuples[{1, -1}, 16]] or Image[findAllWithZeroCorr[{}, Tuples[{1, -1}, #]], ImageSize -&gt; 128] &amp; /@ {2, 4, 8, 16}
Are there any real alternatives to mathematica?
This might get you started. No idea what the function is supposed to look like, but you should be able to figure the rest out. Manipulate[ Plot[s*x - s*10, {x, 0, 20}, Filling -&gt; Axis, PlotLabel -&gt; "Long", AxesLabel -&gt; {"Ft", "Profit in thousands of $"}, PlotRange -&gt; {{0, 20}, {-10, 10}}], {s, -1, 1}] 
I have completely stopped using Mathematica now. After many years of trying I've found Mathematica to be so unreliable as to be useless. I do mathematics by hand and program using F# on .NET which is much faster and more reliable. 
you should be able to specify a value for each plot to fill to. look at documentation for Filling to see exact syntax.
I did, but I don't understand it well enough to get it to work. I spent a frustrating amount of time on this and it just continually gave me errors saying it wasn't a valid interval to fill... :(
I currently only have my phone with me. that's why I was so brief. if you don't have a answer before I can actually try your code in Mathematica, I'll reply again...
Here is something quick: game[word_String] := Module[{man, len, gallows, alphabet, guessed, right, wrong, chars, pos}, man = {Null, Circle[{0 , 0}, 0.1], Line[{{0, -0.1}, {0, -0.5}}], Line[{{0, -0.2}, {-0.2, 0}}], Line[{{0, -0.2}, {0.2, 0}}], Line[{{0, -0.5}, {-0.2, -0.8}}], Line[{{0, -0.5}, {0.2, -0.8}}]}; len = StringLength@word; chars = Characters@word; guessed = {}; right = Table[" ", len]; wrong = {}; alphabet = {"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"}; gallows = {Thickness[Medium], Line[{{0, 0.1}, {0, 0.3}}], Thick, Line[{{0, 0.3}, {-0.4, 0.3}}], Line[{{-0.4, 0.3}, {-0.4, -1}}], Line[{{-0.6, -1}, {-0.2, -1}}], Line[{{-0.4, 0.2}, {-0.3, 0.3}}]}; Dynamic@ Framed[Column@{Row@{Show[Graphics@gallows, Graphics@man[[1 ;; Length[wrong] + 1]]], Column@{Row@Table[right[[j]], {j, 1, Length[right]}], " ", Row[Table[ Style[wrong[[j]], Underlined], {j, 1, Length[wrong]}], " "]}}, If[right == chars, "You Win"], If[Length[wrong] == 6, "You Loose"] , TableForm[Button[alphabet[[#]], If[right != chars &amp;&amp; Length[wrong] &lt; 6 &amp;&amp; ! MemberQ[guessed, alphabet[[#]]], If[MemberQ[chars, alphabet[[#]]], pos = Position[chars, alphabet[[#]]]; For[k = 1, k &lt;= Length[pos], k++, right[[pos[[k]]]] = chars[[pos[[k]]]]], wrong = Append[wrong, alphabet[[#]]]]; guessed = Append[guessed, alphabet[[#]]]] ] &amp; /@ Table[i, {i, 1, 26}], TableDirections -&gt; Row]}] ] It's not pretty, but it gets the job done I guess.
in Mathematica you can highlight something with the cursor and press F1 (or something else on Mac) to pull up the documentation page for it. `f@x` is just shorthand for `f[x]`. `/.` is for replacements (do what i said for more info)
I prefer Maple sometimes, in particular for differential geometry (although i guess, you could also buy atlas 2 for mathematica to do that). In other cases, Mathematica proved to be superior.
This was very helpful. I've been able to figure it out using this. Thank you :)
This tutorial emphasizes on learning the basics of Wolfram Language. So, users with version 8 can follow along with ease. 
look into Band or DiagonalMatrix
Thanks, this is what I needed. I'm having trouble implemeting a few rules though. Here's what I have so far (I'm using n=4 in this case like my previous example) test = SparseArray[{Band[{1, 1}] -&gt; 0, Band[{2, 1}] -&gt; A, Band[{1, 2}] -&gt; B, Band[{1, 5}] -&gt; T, Band[{5, 1}] -&gt; T}, {16, 16}]; test // MatrixForm How would I make each 4th (counting diagonally) A and B equal 0?
Sorry, I'm pretty new to mathematica. When I copy and pasted this in to a new notebook nothing happened when I ran it. Am I missing something here?
its a function, call: BuildMatrix[4]//MatrixForm 
Got it thanks, Could I ask a final question? Say if instead of going A A A A 0 2A 2A 2A 2A 0 3A 3A.... I wanted it to go A A A A 0 A^2 A^2 A^2 A^2 0 A^3 A^3 ... I tried changing [B offdiag, -1] and [A offdiag, 1] to[B^offdiag, -1] and [A^offdiag, 1], but it gave me: A A A A 1 A^2 A^2 A^2 A^2 1 A^3 A^3 ... How would I edit the code to be able to handle powers without changing the 0's to 1's. I really appreciate the help, without this I'd have to try and write a 10,000x10,000 matrix by hand.
That's perfect, thanks. If you ever want to take me up on my offer, just PM me.
4 spaces before a line treats it as code. use pastebin
1) What do you mean by "app"? 2) How would you formulate the question mathematically? 3) How do you get from the formulation of the question to an answer?
So what do you actually need to do to get Mathematica to answer your question?
I just need to know how to code it like : Solve[ or Nsolve or something
You need to do your own homework. That's sort of the point.
&gt;All H does is look at the [[i,j]] entry of our input array, then multiplies that entry by all of its neighbors and takes the sum of those products. Sounds like an Ising model? :) Take ar, drop the first row, append a row of zeroes at the end, and multiply this by the original ar. The gives an array where the value at i,j is ar[[i,j]]ar[i+1,j]]. Then we just have to do the other three pair combinations (e.g. drop the first row, prepend a row of zeroes). To make the code more readable define zeroes = Table[0,{Length[ar]}]; then the result of adding all these pair products will be result = Total@Flatten[ar Append[Rest@ar, zeroes] + ar Prepend[Most@ar, zeroes ]+ ar Transpose@Append[Rest@Transpose[ar], zeroes] + arTranspose@Prepend[Most@Transpose[ar], zeroes] ] this takes about 1 second on my machine for an array of size 1000 x 1000. The run time scales like the number of elements in the array.
Ah yeah, f@x is just a shorthand for writing f[x]. Append[list,element] makes a new list with element tacked on at the end, Prepend[] is similar but tacks on the element to the beginning. 
Okay, I think I get what's going on. One thing I don't see is how this is extensible to the "diagonal" elements, but I might just be missing something simple again. Also, for my case, I want to get the actual matrix of these integers out, at least for this part of the calculation. (Later, I'll be exponentiating each entry, but not yet.) This is just the sum of the arrays sans flattening and totaling, were those an oversight on your part, or foresight for something I should be doing? Thanks again! EDIT: Oh, could I add the diagonals by basically removing a row /and/ a column, then adding a row /and/ a column of 0s and doing a similar operation? I think I could!
Hey! Slight update, just in case you're interested: I posted on SE at the same time I posted here yesterday—somebody has a great idea to use convolution; it works even faster than your method managed to work and has a similar conceptual elegance. Here's the implementation: HFFT[ar_] := ar*ListConvolve[-{{1, 1, 1}, {1, 0, 1}, {1, 1, 1}}, ar, {2, -2}, 0] as seen here: http://mathematica.stackexchange.com/questions/102152/optimizing-a-series-of-basic-matrix-operations-scaling-doesnt-seem-right-with-m?noredirect=1#comment277383_102152
Usually I use SparseArray for stuff like this, and try to think of clever rules to help decide when to give certain elements particular values. Here is a simple example I was writing the other day A[x_, y_, n_, m_] := SparseArray[{{i_, i_} /; i &lt;= m -&gt; x, {i_, i_} /; i &gt;= n*m - m -&gt; x, {i_, j_} /; i &lt;= m &amp;&amp; j == i + m -&gt; y , {i_, j_} /; i &gt;= n*m - m &amp;&amp; j == i - m -&gt; y, {i_, i_} /; i &gt;= m + 2 &amp;&amp; i &lt;= n*m - m - 2 -&gt; 4 }, {n * m, n * m}, 0] MatrixForm[A[1, -1, 5, 6]] Hope that helps you see a different method than what has been said before. 
 Solve[{t,t^2,t^3}=={1+2s,1+6s,1+14s},{s,t}]
Could you explain your idea a bit better? Maybe I should go to sleep first too.
sounds great, thanks!
You might want to read up on the differences between clear and Remove.
Evaluation -&gt; Quit Kernel will clear all stored values from the current session, essentially allowing you to start anew.
Executing `Quit` from within a notebook also works. If you were using multiple kernels for parallel computation, there's also `CloseKernels[]`.
You can use Wolfram Language online for free from the [Development Platform](https://develop.wolframcloud.com/app/) and play there with the book.
I will try that later today. What I played around with yesterday was constructing a for loop for the vertical lines. I got the vertical lines - but in different graphs. I was not sure how to elegantly combine them. But I'll give your idea a try after class today. 
Try passing it to one of the other forms like InputForm and see if the output works better for you
Why swap to matlab?
Because i dont know how to use differential equation solvers in Mathematica.
Your expression seems faulty. "[Sqrt]" is not a meaningful expression in the context of what you are doing. 
Do you have Perl installed? My lab uses a Perl script for this that I could send a Dropbox link to. You have to list the functions you want it to create, but it's handy. 
Hmm yeah I was able to reproduce the error. Not really sure what's causing it though. You can try playing around with the WorkingPrecision option for FindMaximum. But it seems like you're getting the right output, so you can also just suppress the warning.
I'm guessing it must have something to do with how `Manipulate` passes the input values into the expressions within. I tried wrapping the whole thing in `Quiet` but the warnings still came out. I'll try putting `Quiet` inside of the `Module` around `FindMaximum` since that's the real source of the warning. Edit: Yup, moving `Quiet` inside of `Module` does the trick.
I was able to reproduce it outside of Manipulate, so I don't think that's it, and yep Quiet inside Module is the way to go.
... what does the project involve? Mathematica has capabilities in a wide array of areas. Anything you can explain about your project will be helpful in finding someone to help you. For example if you are looking to do some physics models with Mathematica you wouldn't want an expert in Mathematica's chemistry capabilities... 
Well, you can basically forget the `For` construction if you want to write elegant Mathematica programs. Did you manage to work it out with BillSimpsonxV's advice?
Its a simple physics model of protein mechanics under forces, what i really need to is figure out how to take this plot i have and create an animation of what it would look like solving a differential equation for putting one protein under force. 
Well why don't you start with getting Mathematica to solve the differential equation. If you post the equation in the subreddit we can help you figure that out. From there you can work on the animation.
Let's define a function which generates circular iterations: circularIter[list_] := NestList[RotateLeft, list, Length@list - 1] We can call it for your specific problem like this: Map[p[[#]] &amp;, circularIter@{1, 2, 3}, {2}]
Ok, I'll bite, why is this posted under /r/mathematica? Fuck it have an upvote, Happy New Year 32 minute old account, smoke weed everyday, or whatever.
Not at the moment. Limited space and I kinda need it on my laptop, if possible.
Does your license include access to the cloud version? It actually works pretty well.
Weird solution. You should definitely try to submit the bug to Wolfram. Not sure how to go about that though.
You could code an interpreter for your new syntax within Mathematica but that's probably not what you want. My advice is, if you're learning a new language, learn it all the way through, with all its quirks and details.
I can say with near certainty there is no way to do this (that is feasible for the average user).
If you really can't stand the syntax, you still have the [free-form input](https://imgur.com/yJZPmY1) (hit the `=` key when you create a new cell), but I am far from sure you can decently use Mathematica this way.
n is a known fixed number that I determine earlier in the program.
What is your function that checks if a configuration is valid/reachable? That may provide clues to not have too large a search space. 10^12 elements is not little. A function that finds all moves reachable from the current value(and then all moves reachable from THAT position etc.), may end up more useful than enumerating all configurations and checking their validity.
I don't have much to offer here; visualizing has never been my strong suit. But I would like to point out that you can simplify your code by including ct=0 in the initialization of your Module, as so: solveHanoi[n_, start_, aux_, end_] := Module[{ct = 0}, If[n == 1, {ct++; Print["Step " &lt;&gt; ToString[ct] &lt;&gt; " : Move from " &lt;&gt; start &lt;&gt; " to " &lt;&gt; end];}, {solveHanoi[n - 1, start, end, aux]; ct++; Print["Step " &lt;&gt; ToString[ct] &lt;&gt; " : Move from " &lt;&gt; start &lt;&gt; " to " &lt;&gt; end]; solveHanoi[n - 1, start, end, aux]}];] Then you don't need to add "ct=0" to your call of the function.
I would recommend the Wolfram Community or Mathematica Stackexchange. You should find good help there if you show you've already put effort into the project.
I worked at WR. It probably is pretty simple to patch the software, but I bet they're waiting for the next release to add it to production. It's not that the software is that complex, its that this simple patch doesn't merit its own software update.
Thank you for the hint! I was indeed playing with `DeleteDuplicatesBy` but your equivalence function is quite nice. I will go with the even shorter form DeleteDuplicatesBy[l, Sort[# #[[All, 1]]]&amp;]
actually, PrimeQ in mathematica doesn't have the other mersenne primes stored in it either, although wolfram alpha seems to know about them.
Thanks, Reverse did the trick :)
&gt; Many years ago there used to be a hack that would try to get MMA Gah, really?! We'd they remove that; people often do work real numbers. I can't really the specific function; rather I was picking out problems from Textbooks in order to try and solve them in Mathematica (I'm new to mathematica) But the problem looked *roughly* like this: (Not exactly the same) (2 \[Pi] R^2 Sqrt[(R + z)^2] (z + z Sqrt[(-R + z)^2/(R + z)^2] + R (-1 + Sqrt[(R - z)^2/(R + z)^2])))/((R - z) z^2 (R + z)) The answer I was given was: (2 \[Pi] R^2 Sqrt[(R + z)^2] (z + z Sqrt[(-R + z)^2/(R + z)^2] + R (-1 + Sqrt[(R - z)^2/(R + z)^2])))/((R - z) z^2 (R + z)) (You're really going need to convert this to traditional form to read this) Anyways, you can clear see that there should be some obvious simplifications to be made - unless you worry about complex numbers. In this case, I can get away with just specifying That z and R are both real in FullSimplify[]....although using regular Simplify[] gives an incorrect, (or at least misleading), answer. (It keeps telling me conditional: = 0 if True, which is very unhelpful.)
define your potentials ala phi[r_,theta_]:= some function of r, theta then you can write it in cartesian using replacement rules such as phixy[x_,y_]:=phi[r,theta]/.{r-&gt;Sqrt[x^2 + y^2 ],etc etc} define your electric field components Ex[x_,y_]:=-D[phixy,x] and similar for y then use StreamPlot to see the Efield figure out the equipotential curves on your own :)
Yes, I've run into almost this exact problem before, fitting the solution to a differential equation to experimental data as part of a lab I assigned for a class I was teaching. I think it is related to the fitting routine hitting a local minimum in the fitting error and it returns early on a solution that isn't actually a good fit. It seems to be especially likely to happen when fitting sine and cosine series, I'm guessing because of their periodic nature. You can get around this by playing with the fitting method. See if /u/BillSimpsonxV's choice of Conjugate Gradient works and if not you can also try `Method-&gt;NMinimize`, which will do a more thorough search for a global minimum. If that *still* doesn't work then post back here and I'll show you the extreme option.
Cheers!
There are several problems with your code. Firstly, functions in Mathematica are written with a capital first letter and with parameters within straight brackets, not parentheses. So instead of `exp(-2602*t)` you should have written `Exp[-2602*t]`, and likewise for `log`. Secondly, the `=` symbol is not the symbol for equality but for "immediate affectation", which means that after something like `t=Log[(1-u[t])/0.0035]/-2602`, then `t` will be replaced everywhere it occurs by the right-hand side of this expression, which is not what you want. Equalities are created with the `==` symbol, for instance in `Solve[x^2+x==1,x]`. Thirdly, the construct `Plot` does not work like this. You have to provide an expression as a first argument, and a variable range specification as a second argument: `Plot[Sin[x],{x,0,Pi}]`. Finally, what are you trying to do? Plotting `u[t]`? `z[t]`? What is the role of the first equation? I advise you to have a look at the [latest tutorial](https://www.wolfram.com/language/elementary-introduction/) to learn some elementary aspects of programming with Mathematica, with which you seem unfamiliar. With this help, I bet you will really quickly learn how to fix your code so that it works.
The best I can think of is GridBox[Table[{i, \[Placeholder]}, {i, 0, 5, .25}], ColumnAlignments -&gt; "."] // DisplayForm
Your answer is the second proposed construct on the [documentation page](https://reference.wolfram.com/language/ref/Plot.html) of `Plot` :)
Look, I am trying to learn mathematica by importing random functions.As for what I am trying to plot, u[t] and z[t] function.Either way thank you, your feed back is appreciated.
ClearAll["Global`*"] will clear all variables and user-defined functions, but leave your whole notebook intact!
I covered that with the "probably illegal", I think. If you're willing to put a torrented executable on a usb stick and run it on somebody else's computer, well, the world is your oyster. 
No. Straight brackets are only used for function arguments, for grouping (eg. `(1-u[t])/0.0035`) you should have kept the parenthesis. Now look at the [manual page for Plot](https://reference.wolfram.com/language/ref/Plot.html) and try to figure out from the examples shown there how you can plot your functions.
Show your code.
Well it took me about an hour to do 50 atoms which gives a 2500x2500 matrix (or 6250000) on a low end i3 (1.3Ghz dual core) . This is 100 atoms which gives a 10000x10000 matrix (or 100000000 elements). My i3 and 4gb of ram couldn't even begin handle that. If it could, judging by the number of elements it would take me about 16 hours : / Thanks for trying though.
Thanks
Two new resources just came out which seem to be pretty close to what you are looking for: * [the Elementary Introduction to the Wolfram Language](http://www.wolfram.com/language/elementary-introduction/): a tutorial book (freely available online) intended to give the layman a taste of what programming in Mathematica feels like, although it just scratches the surface since it will not teach you anything about its uses in science and research. * [the Wolfram programming lab](https://lab.open.wolframcloud.com/app/), which will allow you to follow along the book even if you don't have a license of Mathematica. That said, if you need to quickly get to speed to use Mathematica for research (for example), or if you already know how to program, this is probably not the approach I would recommend (I can also give some hints for this if requested).
Fair enough. However, I find learning best through implementation. So, I'd say to look for domain-specific implementations so that you can already understand what's being done and focus on how it's being done.
Thanks for the response :)
I find your LaTeX quite hard to read and I can't even see all of it since each block is displayed for whatever reason on a single line (I can only see the beginning of the block which begins with `[;h_{1_t} =`). Could you maybe show us a rendered version, or even just rewrite it a little? Replace the `\leq` by `≤` for example, remove the formatting commands, etc. I think that would really improve the readability of your question.
Oh, ok, sorry, I didn't know of this plugin. That said, I like better my browser without plugins but I can read well your question on SE and I will think about it :)
Good point my h_1 won't be defined at [0.2,0]. In fact, I don't need to solve h_1 out there, because I patch on a single interface solution (I am only interested in solving this coupled system where the h_1, h_2 and h_3 share the same domain). Thank you for pointing this out. Let me reformulate the question. Let's say I want to solve over the domain [0, 0.1], where h_1, h_2 and h_3 are all well defined by a(x), b(x) and c(x) at t=0. These a(x), b(x), and c(x) smoothly connected. I then want to solve for h_1, h_2, h_3 in this domain such that h_2 remains connected to h_1 and h_3 smoothly, and h_1 and h_3 remain at pinned to the ends of the domain. Formally, the IC and BCs would be: h_1[x,0] = a(x) h_2[x,0] = b(x) h_3[x,0] = c(x) h_1[0,t] = a(0) h_3[0.1,t] = c(0.1) h_2[max(x),t] = h_3[max(x),t] h_2[min(x),t] = h_1[min(x),t] I believe this problem is correctly posed. Once again, thank you for pointing out my error. Any ideas on how I would input these boundary conditions into Mathematica?
No problem, thank you for your time. 1) The first derivatives need to match. 2) I guess the constraint I'm trying to impose is this. The "ends" of h_1, h_2 and h_3 can move around in time and I want it so that the ends of h_2 stay smoothly connected to the ends of h_1 and h_3. I don't really know how to put this, as h_2 may not be monotonic, so it may not be its maximum value or minimum value. I guess the constraint is that the points of h_2 and h_3 at their "biggest x" stay equal (and similarly smallest x for h_2 and h_1)? But these points may not necessarily be the maximum values of the function, nor the argument after the first time step. I don't know if I've been very clear here?
OK, I think I see what you mean with the ends of the `h_i` but why can't you state it like this? h2[0.1,t] = h3[0.1,t] h2[0,t] = h1[0,t] and the derivatives: h2_x[0.1,t] = h3_x[0.1,t] h2_x[0,t] = h1_x[0,t] Edit: Oh, because the positions of the *meeting points* between `h2` and `h3`, and `h2` and `h1` are probably also allowed to move in `x`…
I assume your first If statement would be the detection of the zero pivot. Once you've detected the zero pivot you could either run a loop or something like MemberQ and Position to find a suitable candidate. Possible patterns to detect nonzero elements would be `_?(#!=0&amp;)` or `x_/;x!=0` In either case you would probably need another If statement to either throw the warning or exchange the correct rows. HTH
Thanks for the response. Exactly, the meeting points are allowed to move, so I don't think these boundary conditions would work.
isn't mathematica great? -one reason I don't use it.
But still comment at /r/Mathematica? And how often do you try to turn all of your code into a string? Is that really a reason you don't use it?
I've been using Mathematica for about 10 years. Yes it's amazing and yes it's also buggy as hell and crashes frequently. 
x^2 + 1 /. x -&gt; 1
And, I'll just add that "/." is assigning a rule. So, the line might read (in normal English) "x squared plus one, such that x goes to 1". This is one of *Mathematica*'s most powerful features. Rule assignments and assumptions are two features that make the language flexible and powerful. Definitely worth taking a look at the tutorials for them.
Put four leading spaces in front of a line of code to stop most of the reddit formatting changes. damage[level_,attack_,defense_,base_,modifier_]:=((2*level+10)/250*attack/defense*base+2)*modifier; Then damage[1, 2, 4, 6, 3] returns 804/125 and a decimal point in any of that or wrapping it in N[] will give you a decimal approximation if you want that instead of an exact fraction. Mathematica is fanatic about correct capitalization and [stuff] is completely different from (stuff) is completely different from {stuff}.
That's not how notebooks are intended to be used, so the behavior isn't necessarily surprising. I don't think there is a quick and easy way to fix that behavior, but it might be worth sending the NB in to tech support so they can review the crash.
&gt; it goes down the list of definitions in order This is correct in this case, but not [in general](http://reference.wolfram.com/language/tutorial/TheOrderingOfDefinitions.html) (or at least the way you said it can be misleading). Edit: By the way, f = Switch[Length@#, 2, Mean@#, 3, f@Rest@#, _, 0] &amp; ;)
OK, good point about ordering of definitions. I thought about using `Switch`, but decided it was less clear. The recursion also seems less intuitive for a beginner.
Links to offensive material are not allowed in this subreddit. Please refer to the sidebar for more information.
If you are having trouble plotting a dynamic graph may be helpful. Manipulate[Plot[E^(x^2/a), {x, -10, 10}], {a, -10, 10}]
&gt; "r''[x]is not a quantified system of equations and inequalities." Show the code that gives you this error.
D[r[x], x] = (2 E^(x^2/a) x)/a Solve[(2 E^(x^2/a) x)/a == 0, x]= {{x -&gt; 0}} Solve::ifun: Inverse functions are being used by Solve, so some solutions may not be found; use Reduce for complete solution information. &gt;&gt; D[(2 E^(x^2/a) x)/a, x]=(2 E^(x^2/a))/a + (4 E^(x^2/a) x^2)/a^2 Solve[(2 E^(x^2/a))/a + (4 E^(x^2/a) x^2)/a^2 == 0, x]={{x -&gt; -((I Sqrt[a])/Sqrt[2])}, {x -&gt; (I Sqrt[a])/Sqrt[2]}} I got rid of the error on the second derivative but i still get it on the first. Is this how i would solve for P.O.Is? I still have no clue how to do the others 
Thanks for your help! 
Integrate[x Cos[x], {x, Pi/2, 3 Pi/2}]
thank you that worked? will you be online still? I could use some help with this assignment I'm on? 
PM me and I may be able to help you
What have you tried?
Take x and the angle ϕ as coordinates, calculate the first fundamental form g in this coordinates, then the surface is given by [; A = \int_0^{2 \pi} \, d\varphi \, \int_0^1 \, dx \, \sqrt{\mathrm{det} g_{x \varphi}} ;] In this coordinates g is diagonal, so this will be quicker by hand than with a CAS. 
OP, I suggest you read the name of this subreddit more closely. This sub is for the C.A.S. *Mathematica*. It is not (as such) a maths related sub. Thx.
I see this post is a bit old, but I think it is one of the biggest stumbling points I had/have when thinking about problems in Mathematica. Specifically, I have a hard time picking just one of the methods below. First, as others have pointed out, you can replace x with 1 using a replacement rule. This is both powerful and general, but [it can be slow](http://blog.wolfram.com/2011/12/07/10-tips-for-writing-fast-mathematica-code/) (when using more elaborate patterns.) x^2 + 1 /. x -&gt; 1 Second, you can use a With or Block. This has some limitations (e.g. x has to be a *symbol* instead of a *pattern,* this can get in the way when using variables that have *subscripts*) With[{x=1}, x^2 + 1 ] Block[{x=1}, x^2 + 1 ] Note that if you've got the equation saved in a variable, you need to tell Mathematica to actually **Evaluate** the equation with the temporary x value like this: eqtn = x^2 + 1 With[{x=1}, Evaluate[eqtn] ] You could also just make your equation a function: eqtnFunc[x_] := x^2 + 1 and call it with eqtnFunc[x] when you want a symbolic equation, otherwise eqtnFunc[1] However, if you've got equation saved in a variable, and you want to turn it into a function, you can do either one of these: eqtn = x^2 + 1 eqtnFunc1 = Function[{x}, Evaluate[eqtn]] eqtnFunc2[x_] := Evaluate[eqtn] then call those eqtnFunc1[1] eqtnFunc2[1] 
Try CAPITALIZING Sin and see what happens. Also try VectorPlot[{x,-y},{x,-100,100},{y,-100,100}] and see what you get. Mathematica is FANATIC about correct capitalization and use of () versus {} versus [] and those all mean completely different things to it.
Thank you!
Yes. Read the help page about lists, and arrays. Helps with notation.
Do you know the difference between Set and SetDelayed?
I tried that but it generated errors. Code looks like: Interpretation[{x = Sin[t], .... And switching it to " Interpretation[{x := Sin[t], ...." is giving me ""Local variable specification \ {x:=Sin[t]... contains \ x:=Sin[t], which is not a symbol or an assignment to a symbol."
Yeah, so you need to do the same thing with f, x, and y. Make sure you underscore both variables in f
What have you tried?
I no nothing of encryption techniques. That being said, you need to provide more info here. Who gave you this? Is it encrypted or encoded? It looks like it is encoded. Also, I don't know if encoded is the appropriate word here... Do you know the approximate length of the message? Going off of that, should the slashes signify spaces between words or different lines of code? What I would start with its to see if there are any/many repeated sets of characters. If there are common repeated sets of characters, I would then re write the message with those repeated bits signifying either spaces (between words) or the letters E or S. then see if it makes semantic sense. Looks fun. good luck
im supposed to use frequency analysis to decrypt this but I can't figure out If there is spacing or not or what does / signify 
Maybe you can use the viterbi algorithm to find the space characters http://stackoverflow.com/questions/195010/how-can-i-split-multiple-joined-words/481773#481773
Killer response, love the article.
Mathematica is many things, but a Frankenstein monster is not one of them. A Frankenstein monster looks like the engineering software I use that decided to require the use of 3 different scripting languages in different places.
You can perhaps use the 'MinRecursion' option, forcing the integrator to subdivide the integration domain. This lessens the chance of the integration to miss the part of the function where all the action is. Your example function evaluates fine (to 2.5) with MinRecursion-&gt;2, for example; and you could use larger values for your real problem. A more robust solution could be to look for a deformation of your integration space (by substitution of variables) that makes the behavior of the integrated function less 'wild'. But that's a lot harder.
Personal philosophical differences I guess. There's no one language for everyone. 
&gt; I'm not sure that changing MinRecursion would fix it, though. Well it gets Mathematica to give an answer without warning, which means that the numerical integration algorithm no longer has reason to suspect the result it produces is bogus. &gt; Just set the AccuracyGoal I'd like and then quiet the error? I am not sure that is going to work. I think you would have to increase the WorkingPrecision, which makes things *slow*. I think increasing the MinRecursion is better. &gt; but I also know that the answer probably isn't actually 2.5, so... what's going on exactly? The answer to your integral is actually (incidentally) very very very close to 2.5; it's something like 2.4999999999999999999999999999999999999999999999999999999999999999999999999999999999999999998616103... I got this from integrating your sample function using Integrate first to x, then to y; this gives a closed-form solution in terms of PolyLog[] that can actually be evaluated numerically to high precision.
You could (algebraically or numerically) solve for the Tintercept within the `Manipulate` block, then plot from 0 to 1.1 * Tintercept.
Have a look at this reference page: http://reference.wolfram.com/language/ref/D.html. It will show you how to specify a derivative. 
Mathematica is **not** able to evaluate that integral (for a=2+√3).
The answer you want to get is only true if x is real, so Mathematica is right to not give you it in general. From the Mathematica documentation, Abs[z] is left unevaluated if z is not a numeric quantity. So, there 's not much to be done without a work-around. Try defining your own function, say: abs[z_] := Sqrt[Re[z]^2 + Im[z]^2] Then Simplify[abs[x + 4 I], Assumptions -&gt; x &gt; 0] returns Sqrt[16 + x^2] as desired.
`Simplify` uses `ByteCount` to determine which form of an expression is simplest. IF we run ByteCount@Sqrt[16 + x^2] ByteCount@Abs[x + 4 I] we see the second expression is smaller. We can get a feel for the relative size of the expressions by inspecting their full forms: FullForm@Sqrt[16 + x^2] FullForm@Abs[x + 4 I]
The whole point of the SE post(s); my mistake for being unclear.
There's also a support page up which is essentially the same. http://support.wolfram.com/kb/23626
 s[t_]:=Sum[a[n],{n,0,t}]; DiscretePlot[s[n],{n,0,25}] Edit: Fixed Typo
`I` and `D` are protected symbols, representing the imaginary unit and the differential operator, respectively. Better choose something else: DSolve[{ i'[t] == -c i[t] b[t], b'[t] == m i[t] b[t] - w b[t], d'[t] == (c - m) i[t] b[t] + w b[t] }, {i, b, d}, t] Well, that output isn't helpful. Looks like we have to numerically integrate: tFinal = 5.0; c = 1.0; m = 0.5; w = 0.7; solution = First@NDSolve[{ i'[t] == -c i[t] b[t], b'[t] == m i[t] b[t] - w b[t], d'[t] == (c - m) i[t] b[t] + w b[t], i[0] == 100, b[0] == 1, d[0] == 0 }, {i, b, d}, {t, 0, tFinal}]; Plot[b[t] /. solution, {t, 0, tFinal}]
Post your code.
I actually got it to work... I wasn't defining my functions carefully enough and when I fixed that, I got it to work 
Contour plots usually take an equality as their first argument. Try this: ContourPlot3D[Abs[z]/2 - 1/(Sqrt[2 x^2 + y^2]) == 0, {x, -2, 2}, {y, -2, 2}, {z, -2, 2}]
Awesome, thank you. What is the double equality telling wolfram?
In the most recent versions, you can just type a few (English? or whatever language it is set to) words, and it will ask it you want to change to a text input cell. That way, you may not need to convert it beforehand. Try that, and see if it works.
From the [implementation notes](https://reference.wolfram.com/language/tutorial/SomeNotesOnInternalImplementation.html): &gt; For indefinite integrals, an extended version of the Risch algorithm is used whenever both the integrand and integral can be expressed in terms of elementary functions, exponential integral functions, polylogarithms, and other related functions. Adding assumptions didn't help at all so I think Mathematica probably first runs a test to see if it can compute the antiderivative and this integrand probably fails because it is irrational (or something like that).
I think they are trying to comment a selection, but are getting a text cell instead. You can right click and do it through the drop down menu, but the question is about the keyboard shortcut specifically. I think changing the MenuCommandKey value in the stylesheet is the way to go: http://stackoverflow.com/questions/4209405/customizing-mathematica-shortcuts 
Yes, it has something to do with graphics drivers. I remember there being a hacky solution for some Linux distribution..
Try starting mathematica with `mathematica -mesa`option from the command line.
Thanks! It is much more readable now.
Q[T_]:=... D[Log[Q[T]], T]
There should be a Knot Theory package. Just type Needs["KnotTheory`"] to import it. http://katlas.org/wiki/The_Mathematica_Package_KnotTheory%60
`MapThread` does what you want. Based off of one of the examples in the docs for `MapThread`, this function should do what you want: cmpMatrices[s2_, s2_] := MapThread[ If[#1==0 &amp;&amp; #2==0, 0, ArcTan[#1, #2] / 2] &amp;, {s1, s2}, 2 ] Example: cmpMatrices[IdentityMatrix[3], IdentityMatrix[3]] &gt;&gt; { {Pi / 8, 0, 0}, {0, Pi / 8, 0}, {0, 0, Pi / 8} } You can do it other ways and you should be able to do it with `For` or `Table` like you mentioned so you probably just had a typo. Using `MapThread` though is probably the most "Mathematica-like" way to do it and it's also probably the fastest for what it's worth. 
Go through the documentation of graphics functions and show them the "neat examples" part.
The first thing you could do is write a function repeatedpisum[n_] := Sum[Pi/2^i, {i, 1, n}] to express those sums. Then you could make an array to get the list of disks and circles like Flatten[Array[{ Circle[{0, Pi/2^#}, Pi^#], Disk[{0, repeatedpisum[#]}, Pi/2^#, {\[Pi], 2 \[Pi]}] }&amp;, howevermanyyouwant]] Also note that the sums you're doing are geometric sums which can be simplified down rather easily, which could reduce computation time if you're going to be doing a huge number of these.
Sorry, small typos. Wrote Pi\^# where I meant repeatedpisum[#]. The following code works. halfcircles[n_] := Graphics[Flatten[ Array[{Circle[{0, repeatedpisum[#]}, Pi/2^#], Disk[{0, repeatedpisum[#]}, Pi/2^#, {Pi, 2 Pi}]} &amp;, n]]]
 avg3x3[M_, x_, y_] := Total@Flatten[Table[M[[x + i, y + j]], {i, 0, 2}, {j, 0, 2}], 1]/9 S1av = Table[ avg3x3[S1, 1 + 3*i, 1 + 3*j], {i, 0, Dimensions[S1][[1]]/3-1}, {j, 0, Dimensions[S1][[2]]/3-1}] // MatrixForm (I think the dimensions of S1 must be multiple of 3, check it out...) 
 Theta = {{1, 2, 1}, {3, 0, 1}, {0, 0, -1}}; Show[MatrixPlot[Theta], Table[Graphics@{Red, Circle[{i - 0.5, j - 0.5}, {0.1, 0.05}]}, {i, 1, Length[Theta]}, {j, 1, Length[Theta[[1]]]}]] Is this what you are looking for? I'd need to know more detail.
almost thanks. i have a ellipmatrix which is a table of ellipsis and a matrixplot of a function theta. i changed your code in Show[MatrixPlot[\[Theta] ], Graphics[ellipmatrix ] ] the 2 output are combined, which is ok, but they are not on the same scale, i must fix this secondary problem. 
I think that would be easy to do. If you send me the code. I'll take a look at it. Graphics in *Mathematica* can be tricky, but once you get the hang of them, they are quite powerful.
I totally understand. Good luck on the project.
Can anyone explain what the syntax error is here? I am new to Mathematica and can't figure out what the issue is. Thanks.
Brackets can't be used for grouping in *Mathematica* You have to use parenthesis. Brackets are used to contains arguments to functions.
In the link the author graphs out some complicated equations. I need some help on graphing those.
I would start by defining the differential equations in Mathematica, then integrate them with [NDSolve](http://reference.wolfram.com/language/ref/NDSolve.html), and finally plot the trajectory with [ParametricPlot3D](http://reference.wolfram.com/language/ref/ParametricPlot3D.html). You can find plenty of examples on the two pages I linked, good luck!
You want to use NDSolve. Also let this be a lesson to people. When you write a computational paper make the code accessible. 
Thank you!
({1,0} + #) &amp; /@ {{3,54},{4,94},{5,156}}
f[x_,y_]:={x+1,y} f @@@ {{3, 54}, {4, 94}, {5, 156}}
The first way seems cleaner. Thanks. *Very* useful. I would have hated to go through the entire list and change each value manually.
 list = RandomReal[1, {4, 3}] &gt; {{0.833576, 0.939086, 0.00454274}, {0.991294, 0.198851, 0.30559}, {0.687801, 0.800932, 0.366325}, {0.793422, 0.121792, 0.524458}} list[[All, 1]] += 1 &gt; {1.83358, 1.99129, 1.6878, 1.79342} list &gt; {{1.83358, 0.939086, 0.00454274}, {1.99129, 0.198851, 0.30559}, {1.6878, 0.800932, 0.366325}, {1.79342, 0.121792, 0.524458}}
I'm away from my computer now, but isn't + listable? I'd expect that you could just type list + {1,0} but I might be wrong. If not, Map is definitely the best way to go. EDIT: Got home and checked; "+" is listable in the sense that you can add scalars to every element of a list, but you can't add a list to every sub element of a list. You can if the dimensions are transposed, though (namely, then both lists would have Length 2), so you could do (for no real reason) Transpose[Transpose@list+{1,0}] and that would work okay. Using `Map` is ~4x faster on a list of length 100k on my machine, though! Also, /u/ARandomScientist , just in case you don't fully understand the idea being used here: We use `#` and `&amp;` to define a pure function. Namely, you can use a function without predefining it. `Map` takes any function—pure or not—and applies it to each top-level element in a list. In a list of pairs, it would just apply the function to every pair. The following two pieces of code are equivalent: f[x_]:=x+{1,0}; Map[f,list] vs. #+{1,0}&amp;/@list `#` is the stand-in for your variable (the input can be a list of arbitrary dimension and rank, an image, a function—anything!) and `&amp;` just gets thrown onto the end of your pure function to indicate that you're done defining it. Then, `f/@x` is just infix shorthand for `Map[f,x]`. This follows the theme of Mathematica having many ways to invoke a given function—namely, `f[x]`, `f@x`, and `x//f` are all equivalent, so functions have prefix, infix, and postfix notations in general. Using `/@` for `Map` makes the *idea* of mapping much more intuitive, imo, and makes the code much more readable. Cheers!
This reminded me of another cute (yet inefficient) way to do it: list/.{x_,y_}-&gt;{x+1,y+1} /u/ARandomScientist , this searches your list for *any* pair of *any* elements. If it finds one, it replaces it with a new pair where the first element has been incremented up by 1. It's definitely slower, but you can use it a little more generally than the map function, e.g.: list/.{x_Integer,y_}-&gt;{x+1,y+1} would allow you to cleanly only add 1 to the first entry in a pair if that number is an integer (or any other type of your choosing, like Real or Positive). It's not the top choice for your use case, but could be useful in the future!
Here's a solution that uses Plus's listable-ness: Transpose[{{3, 54}, {4, 94}, {5, 156}}] + {1, 0} // Transpose Not as clear as Map, though.
Yeah--that's the same as the solution as I proposed, right?
I'm definitely asking more from the community with this but could you show me how to do this for one main differential equation in the paper that I had in the post?
I'm pretty sure it gives the output in the form of a rule not an equation I think when I was doing that I had the very tacky solution of just copy and pasting it into a new line and throwing a plot around it I'm sure there's a much more elegant way though
This comment will be easier to read as a notebook, so here you go: [Click here to download and read it](http://s000.tinyupload.com/download.php?file_id=64644996956487270625) in Mathematica. --- Take a look at the [online help for DSolve](https://reference.wolfram.com/language/ref/DSolve.html), specifically the second syntax. I think the little explanation is pretty self explanatory. Now, the way you give multiple equations to Mathematica is with the `&amp;&amp;` operator. So I could express your system of equations as: `y'[x] == 1 - (y[x])^(2 + x) &amp;&amp; y[0] == 1` This is fine so far. But if you try to feed this to DSolve, you'll see pretty quickly that Mathematica has no idea about a closed-form solution. `DSolve[y'[x] == 1 - (y[x])^(2 + x) &amp;&amp; y[0] == 1, y, {x, -2, 2}]` (Go ahead and copy paste this and evaluate it. Mathematica returns your input unchanged.) Luckily, all you want to do is graph it. To do that, you just need a y-function that evaluates numeric values; you don't need a symbolic solution. This is exactly what NDSolve does: it stands for Numeric DSolve. `NDSolve[y'[x] == 1 - (y[x])^(2 + x) &amp;&amp; y[0] == 1, y, {x, -2, 2}]` Evaluate this too. Mathematica returns a list of solution sets, each of which is a [replacement rule](https://reference.wolfram.com/language/ref/Rule.html). I would highly encourage you to become familiar with these because they are the at the core of the Mathematica engine. But for now, the only thing you need to know is that NDSolve returns a list of possible solutions, and each of these solutions can be applied to an expression using the [`/.` ReplaceAll operator](https://reference.wolfram.com/language/ref/ReplaceAll.html). So we'll keep the first solution in the list in a variable, then plot. `soln = %[[1]]` This just means "get element number one of the list `%`." (% is the previous result in Mathematica.) Now plot. Note the use of ReplaceAll to use the function created by NDSolve. `Plot[y[x] /. soln, {x, -2, 2}]` You actually picked the most boring solution in the solution family of this equation -- it's just a straight line!
you could also write it as {#1+1, #2}&amp; @@@ {{3,54},{4,94},{5,156}}
http://blog.wolfram.com/2013/05/17/making-formulas-for-everything-from-pi-to-the-pink-panther-to-sir-isaac-newton/ This gets a bit involved, possibly beyond what your professor is asking, but is worth the read anyways.
Ok. Here is a bit of code I came across on a forum. I modified it a bit. It fits a bezier curve to a given algebraic expression. I think it might be useful to you, since mathematica plot objects can be a bit odd sometimes... bezier[f_, x_, n_: 100] := Module[{pts, dist, k, coeff, diff, a1, a2, t}, pts = Table[{t, f /. x[[1]] -&gt; t}, {t, x[[2]], x[[3]], (x[[3]] - x[[2]])/n}]; dist = Norm /@ Differences[pts]; k = 0.5; coeff = Rest[dist]/(Most[dist] + Rest[dist]); diff = Differences[pts, 1, 2]; a1 = pts - Join[{{0, 0}}, k (1 - coeff) diff, {{0, 0}}]; a2 = pts + Join[{{0, 0}}, k coeff diff, {{0, 0}}]; BezierCurve@Flatten[{a1, pts, a2}, {{2, 1}}][[2 ;; -2]] ] Then, you can use this code (which I wrote for another project): elem[f_, x_, p1_, p2_] := Module[{fs, xs, \[Theta]0, \[Theta]1, \[Theta]2, transform, df, di}, df = Sqrt[(p2[[1]] - p1[[1]])^2 + (p2[[2]] - p1[[2]])^2]; di = Sqrt[(x[[3]] - x[[2]])^2 + ((f /. x[[1]] -&gt; x[[3]]) - (f /. x[[1]] -&gt; x[[2]]))^2]; \[Theta]0 = ArcTan[x[[3]] - x[[2]], (f /. x[[1]] -&gt; x[[3]]) - (f /. x[[1]] -&gt; x[[2]])]; \[Theta]2 = ArcTan[p2[[1]] - p1[[1]], p2[[2]] - p1[[2]]]; xs = {x[[1]], df Cos[\[Theta]0] x[[2]]/(x[[2]] + x[[3]]), df Cos[\[Theta]0] x[[3]]/(x[[2]] + x[[3]])}; fs = (df Cos[\[Theta]0])/(x[[2]] + x[[3]]) f /. x[[1]] -&gt; 1/(df Cos[\[Theta]0]) (x[[2]] + x[[3]]) x[[1]]; \[Theta]1 = ArcTan[xs[[3]] - xs[[2]], (fs /. xs[[1]] -&gt; xs[[3]]) - (fs /. xs[[1]] -&gt; xs[[2]])]; transform = AffineTransform[{RotationMatrix[\[Theta]2 - \[Theta]1], p1 - RotationMatrix[\[Theta]2 - \[Theta]1].{xs[[2]], fs /. xs[[1]] -&gt; xs[[2]]}}]; GeometricTransformation[bezier[fs, xs], transform] ] Use it like this: Graphics@{elem[x^2, {x, 0, 10}, {0, 0}, {5, 5}], elem[E^x, {x, 0, 2 \[Pi]}, {5, 5}, {0, 7}], elem[Cos[x], {x, 0, 1}, {0, 7}, {0, 0}]} It plots a mathematical functions, but uses an affine transformation to transform it so it starts at point A and ends at point B. Now, you can just build up the curves and other functions to make your shapes. This way, you won't have to mess around with parametric plots or other complex stuff...
Thanks for the very thorough explanation! I might just have to break up my sketch into various small functions like you said where each grid is basically a function itself. Tedious but might be the only way. 
Thanks for finding that! I'm sure I'll be able to put that to use. 
So you might want to check out the docs on [numerically solving PDEs](https://reference.wolfram.com/language/tutorial/NDSolvePDE.html). You want to solve Laplace's equation on a non simple domain. So what you're going to want to do is using Mathematica's region functions to specify domain. Then you're going to specify [Dirichlet boundary conditions](https://reference.wolfram.com/language/ref/DirichletCondition.html) on the boundaries of that domain. Dirichlet conditions are where you specify the value of the function. Neumann conditions are where you specify its derivative. I got you started on specifying the region. You can also plot it with BoundaryMeshRegion disk = Disk[{0,0},2]; rectangle= Rectangle[{-100,-5},{100,5}]; \[CapitalOmega]=RegionDifference[rectangle,disk]; d\[CapitalOmega]1=RegionBoundary[disk]; BoundaryMeshRegion[\[CapitalOmega]] Here is how you specify the boundary conditions. I defined the region d\[CapitalOmega]1 to be the circle on which the potential has v=5. \[CapitalGamma]1=DirichletCondition[v[x,y]==5,{x,y}\[Element]d\[CapitalOmega]1]; \[CapitalGamma]2=DirichletCondition[v[x,y]==0,y==-5]; \[CapitalGamma]3=DirichletCondition[v[x,y]==10,y==5]; \[CapitalGamma]4=DirichletCondition[v[x,y]==0,x==-100]; \[CapitalGamma]5=DirichletCondition[v[x,y]==0,x==100]; It seems the problems is infinite in the x direction. I'm pretty sure the way to handle that numerically is to make the x extent of the problem much bigger than the y extent and set the potential equal to 0 on the x boundaries. Try making sense of all this, and reply to this comment if you have questions about how to use NDSolve with this info.
Thank you a lot for your response. Everything seems to be working with your approach to the problem, and it hasn't been necessary to specify the border conditions for the x boundaries as you said. However I have run into one problem. As you can see [here](http://imgur.com/s6bQYRe) for some reason it doesn't recognize the inner border of \\[CapitalOmega], so the plot gets weird at that point, namely because theoretically there should be potential v=5 inside that circular area.
What I would do is just map the fit to successively more points of the dataset. Define a table of your data with successively more data points included: dt=Table[data[[1;;i]],{i,2,Length@data}]; And then map the fitting operation onto that table using a pure function: fits=Fit[#,{1,x},x]&amp;@/dt; Then, whatever method you have to find the r-squared (or whatever) values could be mapped to `fits`: rs=rsquaredfunction/@fits Then you could see all of the respective values, and find out where it drops below the value you'd like. You could also automate this as follows: Pick[dt,#≥.97&amp;/@rs] Or if you wanted just the one with the most data points that still fits your criterion: Pick[dt,#≥.97&amp;/@rs][[-1]] ...but I'd check to make sure that nothing funky happened. Please let me know if this works/doesn't work/you have any questions!
Replacing that, the plot is almost as I wanted. The weird thing in the inside of the circle is no problem as it is not contained in the region we are interested in. But there is a weird thing in the plot that should not be there. I can live with it, you have already helped more than enough, but do you have any clue on why [this](http://imgur.com/KgnhhyQ) happens? I'm going to sleep now, so I will read your response tomorrow. Thank you for all of your help and advice, you are awesome. Edit: The weird part I refer to is located at the lower part of the graph, in case you don't see it.
You have \[CapitalGamma]1=DirichletCondition[v[x,y]==5,x^2+y^2&lt;=2^2] You want \[CapitalGamma]1=DirichletCondition[v[x,y]==5,x^2+y^2==2^2] Try switching that and see if it's fixed. If you want to solve for the potential inside the spherical conductor I think you have to do that separately. You can never really be sure what's going on under the hood with Mathematica, but you usually can't specify the value of the function over a region when numerically solving BVPs. You can only specify it on the boundaries. This is what I have laplace=D[v[x,y],{x,2}]+D[v[x,y],{y,2}]; disk = Disk[{0,0},2]; rectangle= Rectangle[{-100,-5},{100,5}]; \[CapitalOmega]=RegionDifference[rectangle,disk]; \[CapitalGamma]1=DirichletCondition[v[x,y]==5,x^2+y^2==2^2]; \[CapitalGamma]2=DirichletCondition[v[x,y]==0,y==-5]; \[CapitalGamma]3=DirichletCondition[v[x,y]==10,y==5]; \[CapitalGamma]4=DirichletCondition[v[x,y]==0,x==-100]; \[CapitalGamma]5=DirichletCondition[v[x,y]==0,x==100]; sol=NDSolve[{laplace==0,\[CapitalGamma]1,\[CapitalGamma]2,\[CapitalGamma]3,\[CapitalGamma]4,\[CapitalGamma]5},v[x,y],{x,y}\[Element]\[CapitalOmega]]; ContourPlot[Evaluate[v[x,y]]/.sol,{x,-10,10},{y,-5,5},PlotLegends-&gt;Automatic] Contour plot: http://i.imgur.com/jtsDxpo.png
The documentation has examples of how to use `NDSolve` and also more complex applications.
 I have done a few tweaks and I think I have finally got what I wanted. When plotting the function I have replaced the {x, xmin, xmax} structure with a {x,y}\\[Element]\\[CapitalOmega] structure, as Mathematica seemed to struggle to calculate the values inside the circle (which is normal given that it is not part of the domain). I have also done [this other arrangement](http://imgur.com/lXqnSr1) and everything seems to be running smoothly. Finally I am trying to get the electrostatic field out of this potential function, which I have done with the Grad[] function and I have [plotted it](http://imgur.com/312OHit) with StreamPlot[]. I think that is all I was supposed to do, so thank you a lot for your help. :)
Looks good. Nice job.
I think that the issue *might* be (I don't use NDSolve that often) the fact that you have a bunch of functions of `t`, then you put a `'` on the whole thing, *then* you put *another* `[t]` at the end. If you think about what you've written, it has terms like the derivative of `Sin[h[t]][t]`, which I doubt Mathematica likes. Instead, try something like: f[t_]:=Sin[h[t]]*h'[t] Now, `f` is a function of `t`, so you would be well within your rights to ask Mathematica what the derivative of `f` with respect to `t` is: In[8]:= f'[t] Out[8]:= Cos[h[t]] h'[t]^2 + Sin[h[t]] h''[t] Which I think is more like what you want. Hopefully that helps; please let me know if you have any questions!
You ought to follow the correct mathematical notation. When you say x=r'[t] * Cos... the left hand side is (intended as) a function (function x), but the right hand side is a number (the substitution value of the function t -&gt; r'[t] * Cos..). You see, they are different objects. So if you make the right hand side a function (Function[{t}, r'[t] * Cos... ], or if you make the left hand side a number x[t] (the value of x at t) then you will be good. So if you write x[t_] = ... then x'[t] will come out right. Of course you have to use the correct notation for the rest of your code as well, like Lag = m/2*(x[t]^2 + ...) etc.
You could always use the shortcut. 1.0*10^5 would be: 1.0*^5
Where can I find that setting?
Perhaps you can glean something from [this](http://pastebin.com/Hiwh7HP2). Unfortunately, I can't give credit to the original programmer, as I don't know their name. Great code though.
I have 10.0 and it does what you want. How about using ListLinePlot instead?
does PlotLegends -&gt; LineLegend[labels] work?
Here you go. In[1]:= data = {{1, 1.2}, {2, .5}, {4, .3}, {6, .2}} In[2]:= best = Fit[data, {1, x, 1/x}, x] In[3]:= Show[ListPlot[data], Plot[best, {x, 0, 10}]] I randomly came up with data that approximately matched the 1/x form. If you post your data I can try to see what is going wrong.
Manipulate[x+y,{x,1},{y,1}]
It's okay, it was an easy mistake to make.
Beautiful! Thank you so much. :)
Using the RegionFunction option. The documentation contains pretty good examples. (ref/Plot - Options - RegionFunction)
I'd also like to know the policy for upgrading from 10.x to 10.y, and for 10.z to 11 whenever 11 comes out. What's covered by an initial purchase, what's a discounted upgrade, what's an out-of-band full-price purchase. (Home edition here.)
You'd usually have to buy an upgrade (from 10.0 to 10.1, from 10.1 to 10.2 etc.) The only free updates would be bugfixes (like the recent 10.4.1) The upgrades are not free, but are discounted compared to the full version. You should be able to see the upgrade price somewhere in the Wolfram store. Upgrades from 10.x to 11.x probably will be discounted as well, at least the upgrades from 8.x to 9.x to 10. were (I didn't use it before). If you just bought a version shortly before a new one comes out, you might be lucky and get the update for free. That being said, if you want to keep current with all versions, you might want to look into the annual subscription for the Home edition. At least in the last couple of years, this would have been the cheapest option. This one you have to pay annually (obviously), but it entitles you to all versions that come out during that year. 
I guess I'm not sure about where you're seeing this option for step-by-step solutions. [Screencap of Mathematica 10.2](http://i.imgur.com/OW3Ykia.png).
this has nothing to do with mathematica
I like it. Can you share your function for reproducing this with us?
Would this work [listdensityplot?](http://reference.wolfram.com/language/ref/ListDensityPlot.html#2137729815) 
[Here](http://imgur.com/a/OBslp) is the screenshot from my Mathematica 10.2. I think you are using other type of input.
So is there a way to fix my issue? I'm sorry for not expressing myself properly
Absolutely- [here's a link to a cloud notebook of it.](https://www.wolframcloud.com/objects/6685e66c-9adf-4d9a-a9ba-b7c2390a5350)
DensityHistogram may be what you're looking for. You can even choose whatever color function you like 
Its only a couple lines in Mathematica...
I don't know if it's the best way, but I can recommend the way I and many others learned it: problem sets. Best if you can find some assignment in a field you already know well, then you can focus on Mathematica part.
In addition to just working problems and focusing on the syntax and functional aspect like everybody else has explained, if you're interested in the *concepts* behind the language, [this](http://www.mathprogramming-intro.org/) is a great (if long) read.
Seconded. Really good book.
Sorry for taking so long to respond but I wanted to make sure I logged in to thank you for your help. I'll definitely experiment with that tomorrow when I have time. Many thanks!
Nice. Although my approach would have been running "wget" instead.
For years I find the built-in guide is always the best. Go to Help-Wolfram Documentation, spend a day going over Core language section, you'll be good for most regular use. 
&gt; IN = Table[function[x,y], {x,y,z}] This isn't the correct usage of `Table` but I believe that I understand what you are asking. `Plot` has the `HoldAll` attribute: In[1]= Attributes[Plot] Out[1]= {HoldAll, Protected, ReadProtected} which means that the arguments are not evaluated before the head is parsed. A consequence of this is that `Plot` "sees" one function argument (with head `Table`) instead of the three that you would expect if the `Table` sub-expression was evaluated. You can work around this by wrapping the `Table` sub-expression with an `Evaluate`: Plot[Evaluate[Table[x^n ,{n,0,2}]],{x,0,2}] 
use Evaluate[variable] instead of variable
Thank you - that makes sense. I will give this a try. 
It depends on a few factors. If the editors get slammed with a lot of submissions at once, it slows down the process if you happen to be at the end of the queue. But generally you'll hear back about your submission within a week (sometimes up to two). If your project doesn't need any edits, it will be published almost immediately upon review. If there are formatting or content issues, you will have to fix and resubmit (and keep fixing and resubmitting until you get it right). I highly suggest reading/following the Authoring Guidelines very closely. I think there is also a .nb with "Demonstrations Tips" that you should check out. Finally, this subreddit is pretty much dead. You might try stackexchange or Wolfram's own forums for a more lively discussion.
Haha thanks! I guess even though the sub is dead I still got a pretty good answer. I followed the guidelines pretty religiously so I'm hoping it should be an immediate publication. I was just curious about how long it takes because I hit the upload button and now just sort of wait with no confirmation it's under review. I'll peek around stackexchange/wolfram when it gets to ~2 weeks no response. Thanks for the answer!
So this is what I did first: l = {10, 9, 7, 8, 9, 7, 5, 3, 2, 3, 1}; l //. {foo___, a_, b_, bar___} /; a &lt; b :&gt; {foo, a, bar} It works, but apparently Mathematica is not smart enough to implement that linearly so you end up with a quadratic complexity. ~~Instead you can use `Delete[l, Position[Differences[l], _?Positive] + 1]`which is maybe a little less readable but linear in the size of the input.~~ Edit: Sorry, it is me that is not smart enough to come up with a correct solution on the first try. The one above will not suppress several elements in a row in certain cases. Iterating it until fixed point does indeed the job, but it is still quadratic on some inputs: FixedPoint[Delete[#, Position[Differences[#], _?Positive] + 1] &amp;, l] The following does the same, but much faster (linearly in the size of the input): Fold[If[#2 &lt;= Last[#1], Append[#1, #2], #1] &amp;, {First[l]}, Rest[l]] and you might also want to have a look at LongestOrderedSequence[l, #2 &lt;= #1 &amp;] which will select maximal decreasing runs in the input.
You did the same mistake as me by assuming that it is sufficient to compare an element to the previous one. As a consequence, your program will fail on, for example, `{10, 9, 6, 8, 7, 5}` (returning `{10, 9, 6, 7, 5}` instead of `{10, 9, 6, 5}`).
Ah, sorry, you're right. However, it is sufficient to apply it iteratively until it reaches a stationary point. This does work: yourlist = {10, 9, 6, 8, 7, 5}; f[yourlist_]:= DeleteCases[ {yourlist[[1]]}~Join~ Table[If[yourlist[[i]] &lt;= yourlist[[i - 1]], yourlist[[i]]], {i, 2, Length[yourlist]}], Null] FixedPoint[f, yourlist]
True. I missed the part where OP said their input list was large. Your fast version is obviously a much better way to solve the problem, but I was going for the simplest to understand. Maybe I sacrificed too much code quality for clarity.
Actually it may be not so bad for OP to see all these various implementations, and yours might even be reasonably fast in less pathological cases than this particular input… :)
Here's what I got so far: i = 1; len = Length[data]; While[i &lt;= len, If[ Max[data[[1 ;; i - 1, 2]]] &gt;= data[[i, 2]], data = Drop[data, {i}]; len = len - 1; i = i - 1;]; i = i + 1; ] Problem is this works if the numbers are increasing, not decreasing... any ideas?
Not elegant, but it works, wahoo!!! Thanks again everyone.
You need to have Mathematica installed on your computer to execute this file. Start Mathematica, then use the `Open` dialog box to open your file. You should see it as a succession of cells that you can evaluate one after the other with `Shift+Enter`, or the `Enter` key of the numeric keyboard. Alternatively, you can run the file from command line with `MathematicaScript -script yournotebook.nb` (this works on Linux, I don't know about Windows or Mac).
How do you select the path to the input file? Does the code have a UI? Alt+v+o evaluates all the cells in a .nb file, but if you have to select the path, then there should be a way to select it. Shift+enter evaluates a single cell, which can be thought of as a block of code that evaluates together.
Hey! I was desperate so I created a topic in here too: http://mathematica.stackexchange.com/questions/119146/use-of-manipulate-function-iterative-method?noredirect=1#comment322349_119146 Could you take a look? I've put the code I tried to create in there, but it's not working at all :-( I created a While function and tried to insert it on the Manipulate function, but obviously that didn't go well... any help or path to be followed would be awesome!
Thank you for your comment. I put the path to the input file in the very beggining of the code: (*---------- Section 1: File import ----------*) Off[General::spell];Off[General::spell1]; (*Input Section 1*) (*I1.0 - Set data file directory*) FileDirectory="C:\Users\apl\Desktop\math"; (*I1.1 - Set data file name - See file Sample.dat for the correct data format*) FileName="sample.dat"; (*I1.2 - Set wavelenght normalization intervals (nm) - LNexpi&lt;LNexpf*) LNexpi=400; LNexpf=650; (*I1.3 - Vertically translate spectrum? yes-&gt;1, no-&gt;0*) rescale=0; (*I1.4 - Set the desired value of Absorbance at 1000 nm*) Abs1000nm=0.002; (*End Input Section 1*) Sample.DAT is the sample file that came with the .nb file (I've already figured how to format the input file correctly). I tried to press shift+enter and was met with this message: "You are running in a mode which does not allow computations. Contact Wolfram Research (http://www.wolfram.com) about enabling additional capabilities."
Your code is garbage ;-) But don't worry about that, it is pretty usual for people new to programming or a new language. I'd suggest you to split up the problem into several pieces instead of trying to solve it all in one shot. First, you need to define the `Cg` function. This is a critical part of the computation, so if you don't get that right you are not going anywhere. Forget about the manipulate, the algorithm and all that and just define Cg[zeta_] := (* Insert here the equations 46-48 such that it automatically selects the right one to apply depending on the value of zeta. You can use `If` statements or a `Piecewise` function (look it up in the doc). *) Then, give sensible values to all of the parameters (`J`, `W`, `L`, etc.) and plot your function with `Plot[Cg[x/L], {x, x0, x3}]`. The function should be continuous on the whole interval. If it is not, then you did something wrong: go back to the definition and double-check with the article's equations. When you have that, come back and we'll talk about the rest of the algorithm.
I may miss something here, but what is the point of the fix point search when its solution is obviously `Cg = Jq beta (1+R)/Pe` (from (48))? (By the way shouldn't it be `Jg` instead of `Jq`?)
Hey, I was finally able to describe my function: I used Co=0, since Co is the parameter that I need to adjust in the iterative method. I actually can literally CUT the iterative method by using R=0, if I don't find a way to do it. Better than nothing, I guess. Anyway, here's the function: Cg[x_] := Piecewise[{{(J*Exp[Pe*x/W]/(Pe^2))*(1 - Exp[-Pe*L/W] ) + (R/(R + 1))*Co, x &lt; 0}, {(J*((1 - Exp [Pe*x/W - L/W])/Pe^2) + x/(W*Pe)) + (R/(R + 1))*Co, 0 &lt;= x &lt;= L}, {((J*L/(W*Pe)) + (R/(R + 1))*Co), L &lt;= x &lt;= x3}} , 0] Using sensible values to all of the parameters: Plot[ Piecewise[{{(10^5*Exp[20000*x/3]/(20000^2))*(1 - Exp[-20000*25/3] ) + (R/(R + 1))*0, x &lt; 0}, {(10^5*((1 - Exp [20000*(x/3 - 25/3)])/20000^2 + x/(3*20000))) + (R/(R + 1))*0, 0 &lt;= x &lt;= 25}, {((10^5*25/(3*20000)) + (R/(R + 1))*0), 25 &lt;= x &lt;= 35}}, 0] , {x, -10, 35} ] The graph looks A LOT like the ones on the articles where R=0, so I'm probably doing it right, thanks! Now, the next step would be to implement the iterative method? Edit: Hey!!! I just created my Manipulate[] with the function above and it worked 100%!!! Thank you! Do you have any ideas on how to implement the iterative method so I can use the R*Co/(R+1) therms instead of setting them as 0? 
 Clear[f, x, n, a, b, p1, p2, p3]; f[x_] := Sinh[x]; n = 5; a = 0; b = 4; increment = (b - a)/n; p1 = Plot[f[x], {x, a, b}, PlotStyle -&gt; Thick, AxesLabel -&gt; {x, y}]; p2 = Table[ Graphics[{EdgeForm[{Thin, Blue}], Opacity[0.4], Blue, Rectangle[{i, 0}, {i + increment, f[i + increment]}]}], {i, a, ( b*n - b)/n, increment}]; p3 = Table[ Graphics[{EdgeForm[{Thin, Red}], Opacity[0.4], Red, Polygon[{{i, 0}, {i, f[i]}, {i + increment, f[i + increment]}, {i + increment, 0}, {i, 0}}]}], {i, a, ( b*n - b)/n, increment}]; Show[p1, p2] Show[p1, p3] aa = 0; at = 0; xi = 0; t = 0; For[j = 0, j &lt; n, j++, xi = xi + increment; aa = aa + f[xi]*increment;] For[k = 0, k &lt; n, k++, t = t + increment; If[t == 0 Or t = n, at = (b - a)/(2 n)*f[t], at = (b - a)/(2 n)*2 f[t]]] at = N[at, 4]; aa = N[aa, 4]; ae = N[ \!\( \*SubsuperscriptBox[\(\[Integral]\), \(a\), \(b\)]\(f[ x] \[DifferentialD]x\)\), 4]; Print["Rectangles: ", aa, " Trapezoids: ", at, ", Exact: \ ", ae, " Percent Error Rectangles: ", (aa - ae)/ ae*100, "%", " Percent Error Trapezoids: ", (at - ae)/ ae*100, "%"] 
There is already Or[t==0,t==n] or t==0 || t==n But apart from that I think that your trapezoid integration is wrong: you never update the value of `at` and you should use 2 values of `f` at each step: the one on the left of the trapezoid and the one on the right. I find `27.6966` for the trapezoid integration.
Also, if I used NIntegrate, I get the same answer as you. But isn't that number attained using more than my "n" number of trapezoids?
Well, you can see it like that indeed. When I teach it to students I usually tell them to sum up the area of the trapezoids (like you did with the rectangles but with trapezoids instead). To compute the area of a trapezoid you can imagine that you clone it, rotate one part by 180° and assemble the parts to form a rectangle of length `a+b` where `a` and `b` are the lengths of the two parallel sides. The area of the initial trapezoid is half the area of the rectangle. Hence, at = Sum[(f[a+i*interval]+f[a+(i+1)*interval])*interval/2, {i, 0, n-1}] but you reorder the terms it is equivalent to your formula. The last mistakes in your code are: * `k` should go all the way up to `n` in the `For` loop; * you should compare `k` to `0` and `n`, not `t`; * you should increment `t` only after incrementing `at` in the `For` loop.
Are you sure? `NIntegrate[f[x], {x, a, b}]` gives me `26.3082`. `27.6966` was what I got for 5 trapezoids.
That amazingly worked just fine! Neat. Actually after that I finally managed to get things rolling and wrote quite a lot, thank you very much!! :-) I created the whole manipulate[] function with the NIntegrate inside it and it's working 100%! However, the only thing I'm missing now is the iterative method. I need to create a function that has inside it the 3-steps-function, the integration AND the iterative method... Here's what I tried: Cg[x_]:=Piecewise[{{(J*Exp[Pe*x/W]/(Pe^2))*(1-Exp[-Pe*L/W] )+ (R/(R+1))*Co,x&lt;0}, {(J*((1-Exp [Pe*(x/W - L/W)])/Pe^2+x/(W*Pe)))+(R/(R+1))*Co,0&lt;= x &lt;= L}, {((J*L/(W*Pe))+(R/(R+1))*Co), L &lt;= x &lt;= (L+10)}},0] parameters=N[{J-&gt;10^5,Pe-&gt;20000,W-&gt;3,L-&gt;25,R-&gt;0.5}]; Co= 0; AvgC2=50;AvgC1=1; While[Abs[(AvgC2-AvgC1)/AvgC1]&gt;= 10^-6, AvgC1=AvgC2; Co=Cg[35]; AvgC2=NIntegrate[Cg[x,J,Pe,W,L,R]/.parameters,{x,-10,35}]/45 ] However, this doesn't actually make that much sense... I'm struggling a lot with this, there are so many things inside others that my mind hurts lol, but I'm sooo close to the solution.. Btw, I can send you the whole Manipulate function I created by PM if you want to take a better look at it, I guarantee that it looks a lot better than this script above, lol.
You are almost there indeed. Try defining and using `Cg` in a consistent way (at some places you call it `Cg[x]` and at some others `Cg[x,J,Pe,W,L,R]`). I would suggest you to define more functions: for example `avgCg` which would take `Co` and the list of parameters and return the average concentration for that `Co`. Then `fixedpointCo` which takes only the list of parameters, does the fixed point search using `avgCg` and returns the last `Co` it finds. I am pretty sure it will be clearer this way and take off some pain from your mind ;)
I searched all over the Mathematica forums, but I don't seem to understand how to adapt the FixedPoint function for my problem: Cg[x_, J_, Pe_, W_, L_, R_, Co_] := Piecewise[{{(J*Exp[Pe*x/W]/(Pe^2))*(1 - Exp[-Pe*L/W] ) + (R/(R + 1))* Co, -10 &lt; x &lt; 0}, {{J*((1 - Exp [Pe*(x/W - L/W)])/Pe^2 + x/(W*Pe))) + (R/(R + 1))*Co, 0 &lt;= x &lt;= 25}, {((J*L/(W*Pe)) + (R/(R + 1))*Co), 25 &lt;= x &lt;= (25 + 10)}}, 0] parameters = N[{J -&gt; 10^5, Pe -&gt; 20000, W -&gt; 3, L -&gt; 25, R -&gt; 0.5}]; avgCg[Co_] := NIntegrate[Cg[x, J, Pe, W, L, R, Co] /. parameters, {x, -10, 35}]/45; fixedpointCo = FixedPoint[avgCg[#], 0] I don't know how to aplly the stop condition of Abs[(Cgj+1-Cgj)/Cgj]&lt;=10^-6, nor the sintaxe envolved in the FixedPoint.. Could you help me with this?
Hi, I spent the whole weekend programming &amp; writing and almost forgot to thank you!! You were an angel by helping me that much! If you need something any day feel free to send me a PM. I really hope you have a nice week, thanks again!!
:) No worries, I am always up for some programming exercise and it has been fun working on this article that is quite remote from my field. Have a nice week too!
You could try finding the average value of the vertical components in a given area. I'm not versed in geographic terminology, but I'm sure there's something that incorporates spatial displacement and the rate of change of spatial displacement. Those mean values would likely do a good job of informing you of local topology.
I'm not very familiar with webdev at all. I think you are right about how Mathematica imported the URL, but I found a simple workaround. I just changed the Import option from "Data" to "FullData" and it was able to find the information available in the URL's source code and unavailable from the webpage generated by it. Import["http://www.mtggoldfish.com/index/ZEN#online", "FullData"] Thanks for the help.
If you can isolate the row of lists that you want to manipulate, you can use something like f[list1_, list2_] := {list1, list2 + ConstantArray[{list1[[1, 1]] -list2[[1, 1]], 0}, Length[list2]]} There are probably more efficient or more compact ways to execute this. If you want to apply this transformation to many rows in your table at once, you can use Apply[]. Something like f[#[[1]],#[[2]]]&amp;/@ rows will work, if your rows are formatted as a list with elements of the form {list1, list2}.
Other solution: if `ls` is your list of N lists that you want to all "align" with the first one, then ReplacePart[ls, {l_, i_, 1} :&gt; ls[[1, 1, 1]] - ls[[l, 1, 1]] + ls[[l, i, 1]]] will do them all at once. Example: ls = {{{2, 1}, {3, 4}, {6, 8}}, {{1, 1}, {2, 5}, {7, 6}}, {{5, 5}, {9, 3}, {10, 8}}} will give {{{2, 1}, {3, 4}, {6, 8}}, {{2, 1}, {3, 5}, {8, 6}}, {{2, 5}, {6, 3}, {7, 8}}}
Related question: is there something like the Lisp quasiquote form? I can't find anything in Mathematica that allows me to build expressions as easily as quasiquote does in Lisp.
 SetAttributes[f, HoldAll] f[x_Symbol, y_Symbol] /; x &gt;= y := Defer[x]; f[x_Symbol, y_Symbol] /; x &lt; y := Defer[y]; x = 2; y = 3; z = 4; f[x, y] f[y, z] f[z, x] y z z
That is pretty cool. I had to try it with the following to ensure it worked like it seemed to. a = 10; b = 5; f[a, b] a
Mathematica comes with pretty comprehensive documentation that also has introductory sections that are geared towards people who never used the language before. Basic concepts like lists, expressions, evaluation, pattern matching, and substitution, are covered and can be read by novices. Mathematica is already a useful tool if you understand those concepts. However, true *mastery* will take a lot of practice and studying code. I cannot judge what level you're aiming for, of course. One pitfall to avoid is writing imperative-style code in Mathematica. Things like explicit loops (Do[], For[], ...) are supported in Mathematica, but code that uses them is almost invariably bad. You will have to get used to a more functional style of programming. (This is a bit similar to R: explicit loops there are also a code smell). Good luck on your journey, it's well worth it. 
Couldn't tell you the "proper" way to do this, but I would probably do something like: 1. Fit a constant to your elevation data with LinearModelFit[] 2. Use the average sum square of the residuals as a measure of how not-flat the terrain is.
very easy, you can probably just download it and start typing. if you don't know how to do something, just search the documentation and there's probably a built in function that does what you want
I disagree. I wholeheartedly disagree. To say that would be to compare it to something like the TI-inspire. That would, I think, be a terrible understatement of *Mathematica*'s potential. I have made a chess AI, a basic 3D rendering tool (without using any of the built-in 3D graphics methods), a drawing tool, 2048 (game), and many, many more random projects while just bored and messing around. These are things that the tool wasn't originally designed to do, but it has grown far beyond a mere C.A.S. A lot of people complain about the graphics functions. And, I will admit they take some getting used to. But, once you get the hang of them, it becomes a very powerful tool for making graphics as well. When I was an undergrad, I made most of my figures in *Mathematica*, and got a lot of positive comments from people about how clean and professional they looked compared with most student's hand-drawn figures. Also, the most powerful aspect of *Mathematica* (besides the C.A.S. part) is its "high-level" functions. It comes, in the box, with many extremely specific, extremely useful functions. These are things that I could program, but it would take a fair amount of effort. Having them built in is extremely useful. Finally, the MathLink API is extremely powerful. I have not personally done anything with it, but I am a big fan of the MATLink package which uses MathLink to send commands to the MATLAB kernel. With that package, I can execute both *Mathematica* and MATLAB code from within my notebook file. Since *Mathematica* is weak in numerical methods, this flexibility is extremely powerful, and is a direct result of MathLink. I recently completed a Masters in engineering, and I used *Mathematica* to build up a UI for doing data analysis on composite de-lamination testing. It was an invaluable tool, and was far more than just an advanced calculator. tl;dr Mathematica is more than an advanced calculator (granted, it is a very good C.A.S., but has grown beyond that as well). It has high quality graphics, data analysis, machine learning, and many other capabilities. It also has the very powerful MathLink API.
Actually, for many of the same reasons, I don't see why we'd want to think of Mathematica as more than an advanced calculator. Its high level math functions teach students to believe in black boxes without ever needing to look further. If I needed a reminder of that, I'd recall memories of undergraduate physics and engineering students who need to be weaned off Mathematica (or believing matlab to be comparable to actual coding..). I may have a biased view because I'm a computational physics phd student, but viewing Mathematica as more than just and advanced calculator is a proper way to stop learning relevant maths.
Ok. I'm in agreement with you on that point. The "black box" thing is a problem. Still, I like having the "quick and dirty" features for when I need a quick solution. My advisory always made sure we could do the numerical methods, but having them pre-coded is nice on occasion. I *can* do without them. I worked on a vortex panel method in Java once, and had to code everything in myself. When you called *Mathematica* advanced calculator, I thought you meant more along the lines of saying that is was *only* good for analytical maths. It is good for more than that. I think that it can be a significant problem, since students don't learn how to solve the problems themselves, but for professionals and advanced students, I think it can still be a very powerful tool. 
You're not using the argument correctly. See [here](http://reference.wolfram.com/language/ref/Plot.html) for details of how to use the plot function. 
Think about what you need to know to plot something. You have the function, which relates x values to y values. To get y values, you need x values. You need to supply mathematica with those in a second argument.
Mathematica is the kind of program that I would expect to analyze a function and pick a range for plotting that represents the function's features.
there is also 2 introduction by Wolfram, one for programmers and one for elementary. both are free on the Wolfram-page to work through. Progs: https://www.wolfram.com/language/fast-introduction-for-programmers/ Elementary http://www.wolfram.com/language/elementary-introduction/ i did 12 chapters on the elementary one with all exercises, was quite fun to see you can put things together. the documentation is wonderful and the best its full on your computer, so you can work without internet everywhere. the elementary also has a pdf file floating around int he web, so you dont need the webpage. i think because of the great and well produced amount of docs and introductions, mathematica is easier to learn as maple for example, i tried it, but the tutorials i found were not helpful. now i can atleast do basics things in mathematica, which i need for physics and some mathematics. and when i need more i just grab the introductions and the inbuild docs. just reading you have knowledge in java, C++, then it should be easy for you, because your mind is trained to work with the syntax.
Yeah, I'm studying it now and I truly enjoy how well organized the instructions are. 
Are you experienced with Mathematica? I started studying this program and I was thinking about posting some follow up questions on reddit.
i know some basics, but nothing to deep. most of the time i just read the documentation when something comes up. but you could tag me in the questions, maybe i can help you.
Sounds good. Thank you
it is actually a fairly remarkable documentation effort. probably the best i've ever seen for any product.
That is just an empty comment. Text inside of (**) is ignored by the interpreter.
I just purchased MM10 not even a month ago :-|
not a lot more info, but: http://meta.mathematica.stackexchange.com/questions/1877/mathematica-11-sneak-peeks-from-wolfram-european-technology-tour-2016
I got an email saying they were giving me version 11 for free because I just bought version 10. Call them, they are usually quite nice.
It has arrived. Recent purchasers will be getting emails about free upgrade.
Your question is a bit vague. Perhaps it helps if you use more than the bare minimum of three question marks.
I see no mention of Mathematica anywhere.
I'm not sure this is in the right subreddit. 
Version Number : 11.0.0.0 Platform : Linux x 86 (64-bit)
What makes it computationally useful to calculate the exponential function using hyperbolic functions instead of other numerical methods?
i've never understood appropriate usage of # and &amp;, do you have any good references beyond the documentation? or should i just read that again and think harder
"Computationally useful" doesn't enter into this, it's just what OP commands Mathematica to do. First, he tells Mathematica to *symbolically* work out integrate the Exp[-x] function from 0 to 123, yielding the sinh, cosh expression, Then, he tells Mathematica to evaluate the symbolic result numerically, using machine-precision arithmetic. It is quite possible to force Mathematica to do numerical integration, in that case you'd just NIntegrate instead of Integrate; you wouldn't have to use the N afterwards. NIntegrate[Exp[-x],{x,0,123}] yields '1.'. 
Symbolically, the indefinite integral of Exp[-x] is -Exp[-x]. Hyperbolic functions are a needless complexification of this from where I sit. Mathematica agrees with me: In[3]:= Integrate[Exp[-x], x] Out[3]= -E^-x
All true. What is your point?
here http://i.imgur.com/xRG6piN.png i get the same with all other functions.
windows 8.1 x64.
Ok no idea then, sorry. Your problem sounds like a font problem, I've experienced (and solved) similar problems in Linux, but I've never seen that in the Windows versions. If nothing else works, a full re-install may help.
i pressed ctrl+enter instead of shift+enter, im embarrassed now :D its working now. 
With regard to decomposing the exponentials, this isn't clean but it mostly works: testexpression = Exp[I x + 4 y] f[5] + Exp[4 I (x - y)] f[7] notExp[x_ + y_] := notExp[x] notExp[y] outexpression = testexpression /. {E^x_ :&gt; notExp[Expand[x]], Exp[x_] :&gt; notExp[Expand[x]]} What we're doing here is redefining the exponential function with a custom version and telling mathematica that the custom version gets expanded into products, but not that it can contract back from products. When you're done you can take outexpression = outexpression/.notExp-&gt;Exp to get back a meaningful expression.
Hey thanks, that helped a lot. It seems to have reduce exponentials from three terms to two terms, but I'm having trouble reducing it further. Any other ideas? https://www.wolframcloud.com/objects/dbb79edd-30ac-4a3b-a36e-e7d66bf30de9
haha yeah i pressed enter and ctrl, i didnt noticed that it changed in my mind, i knew it was shift-enter. but well its working again, v11 is incredible, love it. 
I understood perfectly and the obvious answer is, "Because it is flippin' awesome."
Thank you. I have a bad habit of under-emphasizing how excited I am.
Nothing useful, just confirming your finding on Debian 64-bit. The "Play" button is just grayed out and inactive; Play[] and other sound functions works fine. It does work in the Windows and OSX versions. Perhaps a bug report is in order, although they probably know of this deficiency already.
Like in the case of a cell being evaluated, or something like a manipulate? From what I remember of issues I've had, manipulates are pretty much self contained. I am not sure if there is a way to stop a manipulate on an error. I think if it exists, it'd be in the details section of the help page. There could also be a way to do it with catches.
Already tried that. It's not something that is abortable. I think it has to do with the continuous evaluation of live objects, like interactive stuff in the notebook.
I didn't even notice the message, it is so tiny and faded. I see it now though.
 mean[num_]:= Mean[Select[Out[1108], Last[#]==num &amp;]]; You should replace Out[1108] by whatever cell currently holds the table in your picture. Then you want mean[1], etc. Select[] is not always the fastest but it doesn't look like you actually have that much data here.
Click the link. I looked around some, this would essentially be plotting vectors end to end, as far as I can tell.
You'll need to download the accompanying cdf file at the end of the blog entry. `pointListToLines` is defined about halfway through that file. Your code works once the `pointListToLines` function has been defined.
The declaration **Subscript[a, b] = c** stores this rule in the symbol **Subscript** (you can check it evaluating **??Subscript**). **Subscript** belongs to the context **System**, so clearing all the symbols from **Global** won't affect it. You can write instead: a/: Subscript[a, b] = c Now the definition will be stored in the **Global** symbol **a**, and it will be deleted when you execute the command **ClearAll["Global`*"]** 
Wait, so when I define a variable as a letter with a subscript, it acts differently than if I just define it as a letter? 
See [this](http://www.mathprogramming-intro.org/book/node93.html) excellent explanation.
Yes. Although in StandardForm the expression **Subscript[a, 1]** will seem to have **a** as the dominant symbol, internally the outer symbol is **Subscript**. An command like **f[a, b[1], c[d[2]]] = 3** will store the assignment in the outer symbol **f**. If you want to bound it to **a**, **b** or **c** you would have to precede it by **a/:**, **b/:** or **c/:**. You can't assign this rule to the symbol **d** because it's too deep within the expression.
Ah, okay. I assumed that I could just do subscripts to make the notebook look a little cleaner and that it wouldn't change anything. Thanks!
PolarPlot is made exactly for this, eg. PolarPlot[1+Cos[x],{x,0,2Pi}] Remember to always check the help documentation if you are not sure how to use a function.
I've tried that and everytime it's just a blank graph. It just shows the positive X and Y axis with no data on them. 
The Euler-Cromer method is identical to the Euler method, but with one change: instead of using the previous time step's velocity when calculating the new position, you use the current time step's velocity. Euler loop body: * Update acceleration: a(i) = &lt;function of x(i-1)&gt; * Update velocity: v(i) = v(i-1) + a(i)*dt * Update position: x(i) = x(i-1) + v(i-1)*dt Euler-Cromer loop body: * Update acceleration: a(i) = &lt;function of x(i-1)&gt; * Update velocity: v(i) = v(i-1) + a(i)*dt * Update position: x(i) = x(i-1) + v(i)*dt where 'i' is the current step and 'i-1' is the previous step. This is only way to write the loop (the form I prefer). It's possible, for instance, to put the acceleration update at the bottom of the loop with a bit of rearranging. Note that when writing the loop this way, the Euler-Cromer method seems to be the more consistent approach.
So when I am writing the velocity and position update in the Euler method I would write it like this? (for example): v=v+a*dt x=x+v*dt And then the function of x(i-1) would be whatever I get for my position? EDIT: with my mass spring system I get dv/dt=(-kx)/m. That is what I would put in for a(i) correct?
The reason I did the vi=For[stuff] is because I thought I needed the values of the loop in order to graph the thing. I can't quite figure out how to get it to graph.
Ok so I got my Euler-Cromer code working. The only issue I'm having is that at the end I'm using a Print command to get the values of x(i), which is working. But I can't select them all to drop into excel. Have any ideas on that?
A Wolfram Cloud (which requires a subscription, but gets you access to Mathematica Online) app is available for iPad, which gets you a custom keyboard with access to common symbols. However, it's still better optimized for good ol' keyboard-and-mouse.
Plot3D wouldn't be my first choice. ConvexHullMesh or Graphics3D would be a more natural fit. That said, if you want to use Plot3D then it's easiest to express the height of the right pyramid with a [Piecewise](http://reference.wolfram.com/language/ref/Piecewise.html) function. eg) Piecewise[{ {function that describes the upper-left quadrant, (x &gt; 4 &amp;&amp; y &gt; 4)}, {function that describes the lower-left quadrant, (...), .... }]
Maybe I'm not understanding your question, but [why not this](https://reference.wolfram.com/language/ref/Pyramid.html)?
Get a Raspberry Pi - $35 and all Raspbian distros come with Mathematica.
Lol, of *course!*
Yeah, it's great. And the Wolfram Cloud app for Android is really good. 
It is fixed in the 11.0.1 update!
Why don't you show us your attempt so that we have something to work with.
I was hoping for something more recent than the 90s, but yes it's looking like I'll just have to work at turning the python code into Mathematica code. I'm already fairly procieient with Python, but I'd like to be better at the functional style of programming that's possible in Mathematica which will be a lot harder to translate from python. 
[removed]
Note that the Mathematica binaries are compiled for the Raspberry 1, and it doesn't use the improved instruction set of the Raspi 2/3. So you are unlikely to see improvements other than improvements from a higher clock. Mathematica comes with a benchmark tool: https://reference.wolfram.com/language/Benchmarking/ref/Benchmark.html Many months ago I ran this on my fast desktop machine, as well as on Raspberries (1/2/3). The conclusion is that it is very slow indeed, even on the Raspberry Pi 3; order of magnitude: 100x as slow as my desktop machine -- depending on the task. If you really want I can re-run this on a Raspi 3 and give details, but that will take some effort, since the Raspi is now running a distro without Mathematica. It is still 'somewhat usable' though, not for number crunching or heavy-handed symbolic manipulation, but for simple things. The neural networking stuff is out, I think. Also, I think the Raspi version is still v10, and the NN stuff is new in v11. I would have to check, though. To give you some perspective, I remember running Mathematica 1.0 on an Apple Macintosh II back in 1988, and that was useful for simple things, too. That particular machine had a 16 MHz processor and 8 MB's of memory. The Raspi 3 blows it out of the water in terms of performance.
Thanks for the quick response, lots of good, important information here. I won't ask you to reinstall Raspbian just to benchmark Mathematica, but I do hope that someone here or on the RPi subreddit still has raspbian so they can benchmark for me. I didn't realize that the Pi didn't get Mathematica 11 which is a little disappointing but not the biggest deal. Yes there's still things one can do with very little power, but I'd like to not be held back like that. 
How long would relatively simple things take?
Use the Notepad stylesheet. Format -&gt; Stylesheet -&gt; Utility -&gt; Notepad. This will set the default input cell type to Text. You can insert Mathematica expressions into the Text cell via "inline cell" (Ctrl-9 to begin and Ctrl-0 to end). Inline cells can be "evaluated in place". This evaluates the inline cell and replaces the input with the evaluation.
 firstOnEnd[{x_,xs__}] := {xs, x}
Note that this looks similar to the Haskell but it quite different under the hood. Specifically, Haskell is using singly-linked immutable lists whereas Mathematica is using arrays and, consequently, prepend and decapitate are constant-time in Haskell but O(n) in Mathematica. A more faithful equivalent in Mathematica would be `{1, {2, {2, Null}}}` but I'd note that Mathematica does not do tail call elimination so idiomatic functional code will stack overflow quickly and Mathematica uses reference counting (like Python and Swift) which is extremely slow. 
Your code and explanation make it much more clear! Thanks a lot for that already. I still have a few questions. So does it look like something like this if you would write it down (http://imgur.com/a/lnmh8)? So if I get this right, the code works like this: 1. First, it fills in the easiest one's, so the one with only one option. In this sudoku that would be '9' in the second row for example. 2. Then it tries all the combinations with the possible numbers for each cell. If a grid is found that violates the rules, it is deleted and when a grid is found that does not violates the rules, it is chosen. My questions: - Does it try all the combinations, even it's not a possible number in a cell? So say for the first cell, it will try 1, 2, 3 etc, even if it is no option? - And makes it all possible grids, or makes it one and then check if it is the good one, if not delete it and make another one, check is that is right one etc.? I can't say it enough, but thanks again! 
Yep, you got it! You are welcome :)
I had a bit of time so I ran the Mathematica benchmark on Raspi 1/2/3, also at different clock speeds. The Raspi has Mathematica 10.3.1 bundled in the latest Raspbian image. The speedup on later Raspies compared to early ones is pretty impressive. The Raspi3 runs at 1200 MHz compared to a stock Raspi1 at 700 MHz. Mathematica on Raspi3 feels reasonably responsive. I also did a few simple calculations. If you don't do numerical heavy lifting, it's a somewhat usable setup. You can get a million digits of Pi in 4.15 seconds, a million digits of Pi raised to the power E in 150 seconds, and solve the generic quartic equation symbolically in 42 ms. Those things will take 20 ms, 8 seconds, 6 ms on a fast machine, respectively -- to give you an idea of performance. Also, 2D and even 3D graphics feel surprisingly workable. If you want I can provide you with notebooks with benchmark results. However, I don't know if you can open them. Drop me a PM if you want them. 
thanks! I ended up getting a RPi 3, and I found mine ran those same tests about 10% faster than yours, though I did it using only the back end, no front end so maybe that's why? Yeah, I agree, this thing actually runs pretty well I'm happy with it. I've finally finished setting everything up so I can access it via SSH and VNC from my ipad from outside networks so now I basically have (slow) Mathematica online but with no time limits on computations.
Uhm... use [Solve](https://reference.wolfram.com/language/ref/Solve.html)[ eqn1 &amp;&amp; eqn2 &amp;&amp; eqn3 &amp;&amp;.... &amp;&amp; eqnm, {x1, x2, ..., xm}]?
PolarPlot[r[t], {t, Pi/6, (1/3 + 1/6) Pi}] Or shift the range by Pi/3 for the others.
 x1 -&gt; -3.73761 x2 -&gt; 1.06279 x3 -&gt; 2.32448 x4 -&gt; 1.90181 x5 -&gt; -1.89901 x6 -&gt; -3.34811 x7 -&gt; -2.40839 x8 -&gt; 2.88679 x9 -&gt; 8.33216 x10 -&gt; -0.780352 x11 -&gt; -1.25435 x12 -&gt; -1.544 x13 -&gt; -2.11018 x14 -&gt; -1.93775 x15 -&gt; -3.77434 x16 -&gt; 2.9947
What about this: RevolutionPlot3D[{Sin[t] (1 + Cos[t]), -Cos[t] (1 + Cos[t])}, {t, 0, Pi}]
I would use that, but the unit is on using ParametricPlot3D and setting parameters that would let me rotate my functions
You are misunderstanding something. **Array** is a built-in function that **constructs** a **List** or a nested **List**. It's like **Map**, but it automatically maps the function from 1 to the desired length. For instance, Array[Sqrt, 10] yields {1, Sqrt[2], Sqrt[3], 2, Sqrt[5], Sqrt[6], Sqrt[7], 2 Sqrt[2], 3, Sqrt[10]} (Note how the square root operator was mapped from 1 to 10) TL;DR: You can't really compare the two. (it's like comparing the addition operator with the number 5).
Is Array literally just /@Range[a,b] with a new name? They certainly have similar runtimes.
&gt; Map, on the other hand, unpacks the input list (in this case, the output of Range), which makes the evaluation slower and less memory-efficient. Oh, wow! I didn't know that. I guess it doesn't matter much because I'm usually acting on rank-2 `List`s rather than just indices, but I'll keep that info filed away for future use.
I don't know what your adjacency graph looks like nor how crowded it is, but this could be a starting point: height = 10; width = 10; spins = RandomInteger[1, {height, width}]; adjacency = RandomChoice[{200, 1} -&gt; {0, 1}, {height*width, height*width}]; coordinates[{height_, width_}][n_] := Reverse @ PadLeft[IntegerDigits[n - 1, MixedRadix[{height, width}]], 2] links[{height_, width_}][adjacency_] := Line[{1, 1}/2 + coordinates[{height, width}] /@ #] &amp; /@ Position[adjacency, 1] MatrixPlot[spins, Epilog -&gt; links[{height, width}][adjacency], DataReversed -&gt; True] Edit: fix ordering.
I am not allowed to use the GCD, my task is to write a function that finds the GCD of two numbers.
I have it done on paper i now need to write it in mathematica.
What about LCM? a b / LCM[a, b] gives GCD.
Thank you i corrected those things but my problem at the moment is: My A is 52, b is 20 and r is 12. Now when the while loop runs for a second time i want to have a = 20, b = 12. But if i write a=b and b=r, it does not work. Is there a way to make this work?
I would use AdjacencyGraph: https://reference.wolfram.com/language/ref/AdjacencyGraph.html If you look into options you can change the color of certain sites
The first argument of Map should be a function, therefore you have to abstract D[f,var] to be a function of the variable which you differentiating with respect to. Using pure function it looks like this: D[f, #]&amp; Or you can use anonymous function: Function[{var}, D[f, var]] Now, this function can be mapped to the list of variables. Note that you can also use grad[f_, vars_List], which means that in the second argument only expressions with head List are accepted. I prefer this solution over using test functions like ListQ. Also, let me note that one can simply use D to obtain the gradient: D[x^2 + y^2, {{x, y}}] See the 4th usage in the documentation of D. You've probably already known these things, in this case, sorry for the unnecessary extra information.
I usually use the `_Head` syntax to test my arguments' types, and `?` or `/;` only to test their values.
_List and _?ListQ differ in performance: L = ConstantArray[{}, 1000000]; MatchQ[L, {___List}] // Timing MatchQ[L, {___?ListQ}] // Timing You're right, test functions are more versatile, but when I can, I use head restriction instead of test functions. If you don't find the test function you need as a built in, you can make your own on the spot using pure function e.g.: F[x_?(0&lt;#&lt;10&amp;)] := ... 
Thank you for your reply. Do you know how I could shade a specific region of the surface of the cylinder a different colour?
In that case I would use ParametricPlot3D, so I could apply ColorFunction to change the color of the plot according to the coordinates and/or the parameters. Something like this: ParametricPlot3D[{Cos[u], Sin[u], v}, {u, 0, 2 \[Pi]}, {v, 0, 4}, PlotStyle -&gt; {Opacity[0.8]}, Mesh -&gt; None, Boxed -&gt; False, Axes -&gt; False, Lighting -&gt; "Neutral", ColorFunction -&gt; Function[{x, y, z, u, v}, If[z &gt; 1 &amp;&amp; x &gt; 0, White, Gray]], ColorFunctionScaling -&gt; False]
http://www.megafileupload.com/kt0B/Project_4.nb 
I'm an idiot I figured it out. Hopefully I'll get number 2 tho. 
Oh wow, that makes so much sense! Thank you so much :) 
Well, if you want to use the difference formula yourself like that, then you probably want to actually compute the limit as h goes to zero: Limit[ (f[x+h] - f[x])/h , h -&gt; 0 ] should give you what you want. Of course, you could (and probably should) also just compute D[f[x],x].
I am curious about hearing more about how to use Mathematica as a back end. My use of its cloud functions suggests that real life use of it is about 100x the cost for say R and AWS.
Why do you think Mathematica would be good for back end?
Addressing all of the comments: I don't mean just a backend, but an entire product. Here's some ideas: - A human anatomy explorer. using the anatomy dataset, explain how things fit together, how they work, provide exploded views of complicated parts, show common motions, etc. You can use this for diagnosis as well -- imagine a demonstration of every type of common ankle sprain and the ligaments that are affected. - Maybe I want users to be able to sign up, connect their Facebook, and do a custom analysis of their account, cross-referencing their posts with curated data like the weather, etc. 
please see my response: https://www.reddit.com/r/Mathematica/comments/5c3kme/how_can_i_build_a_product_with_mathematica/d9tnlw4/
please see my response: https://www.reddit.com/r/Mathematica/comments/5c3kme/how_can_i_build_a_product_with_mathematica/d9tnlw4/
It's been done, it's called WolframAlpha.
This isn't true at all, really. As long as you're paying for a license that allows commercial use then you can do almost anything with it. Of course, if you're paying 100 for a student license then you can use that to turn a profit for commercial use... For example, a ton of people create products deployable as CDFs, which any end user can use on CDF player free of charge, etc.... 
Currently Mathematica is not well designed for the development of standalone applications, although I suspect to see a gradual change in this regard in the future as we move toward a proper "Wolfram Language". I am currently an intern at Wolfram Research, so I use it almost daily, however I am still very new to the company. I'm sure there are plenty of others that may have more insider knowledge than I do. As far as open source goes, I'm not sure at the moment. I had spoken to Stephen about this during the Wolfram Summer School and he seemed to have a position that was not necessarily "against" going open source, but going OS seemed unlikely. I'm personally all for it, but I could understand that a good portion of WR's income comes from Mathematica licenses and we need to feed people haha
I share all of u/iyzie 's points. I have been using Mathematica for about 8 years now for algebraic manipulations (high energy physics theory) and it is an amazing tool for that. When I was in grad school I was never really any good at computer languages but had used Python and took a class(read "slept through a class") on c++. I latched onto Mathematica because it was what my advisor and peers used so troubleshooting was somewhat easy to do. It was very useful for its plotting versatility. I could run all my equations with numbers and generate publish ready plots as well as export to LaTeX. One of the downfalls is that not many theorists are good at coding. At least in my experience. Once I got a pretty good grip on C++ and started rewriting all my codes into that, I realized how slow Mathematica is. I did make it to the final round of candidates for a position at Wolfram. They do have lots of program developing going on, but only for corporate customers. What I mean is, you and I are only ever going to see Mathematica. If your company however wants to have a Wolfram-Alpha type program, you can pay them to develop it for you because I think Mathematica is really the only access you have to their compiler. 
Excellent points, let me elaborate on a few counter-arguments, because I think they offer some value. * First, it doesn't matter if (language x) is n-times faster than (language y) if it takes n^10 more time to write, debug, parallelize, document and maintain code in language x. Granted this only applies for small values of n; and perhaps could justificate a missing dlopen() capability of mathematica (although Rlink and JLink are often useful); we could use more foreign interfaces to better integrate mathematica in "dot-coms" software stacks. And again, I stress the lack of a proper way to integrate with version control software (although they have unit testing now). * I suspect that wolfram research's edge is in financial computing, likely ranging from backtesting to estblishing models, perhaps used by Quants leveraging wolfram's consulting ressources, then selling those models to various financial/insurance corporations. I doubt they have much to do in real-time processing, due to the strict latency requirements. Perhaps Wolfram Research should offer options to disable garbage collection and offer better message parsing interfaces; yet maybe also include their own "vectorial" or timeseries database into the mathematica namespace. * Licensing doesn't have to be complicated, yet, I observe it is, and worse, it has been a moving target. I see that their cloud storage currently offers only 15GB, while 15PB would be a prerequisite to do anything moderately meaningful (plus, companies often like to maintain their own stack, as they have strict requirements as of how data is handled, think compliance, security, etc.) * That being said, there's not much integration between AWS and mathematica (cloud or on-prem) that leverages s3, kinesis, redshift, dynamodb, etc. or even standard queuing systems. It would be useful to use this in the same namespace, without having to invoke foreign interfaces that is. * Maybe the port of mathematica on the pi and other "cheap" computing devices will drive its adoption. I would like to see a similar offering for corporations, perhaps a better licensing scheme that makes sense for production systems (dynamically scalable) or a free version of mathematica with reduced capabilities.
I have been using Mathematica almost daily for a little over 8 years now, for work and fun. Beside the notebooks I actively work on, I constantly have an untitled Mathematica notebook open on my screen to quickly do calculations, prototype an algorithm or plot something. I would say that I am a rather experienced user (not wizard though, just more proficient than most people I know) and that it is one of my favorite languages. But I do have some critics. Some of my likes and dislikes are self-contradictory (like praising the graphical capabilities but ranting about the graphical interface), don't be surprised. **Likes:** * *The notebook format*: interlacing inputs and outputs is really the killer feature in my opinion, it feels so natural that sometimes I wonder how people can work with separate graphics (à la MATLAB); * Super-easy to do and pretty out-of-the-box *visualizations*; * *Pattern-matching* taken to the extreme and *functional programming*, which makes "the Mathematica way" particularly concise and elegant; * Lots of *high-level built-in functions* that "usually just work", yet it remains possible to select precisely the algorithm that you want to use and its parameters (and you don't have to purchase a toolbox each time you need to compute a cosine); * Amazing *documentation*; * A sane and consistent *syntax* overall. I sometimes have to program in MATLAB, oh boy. **Dislikes:** * I miss vim and I hate to use the mouse; * Not really a language to program in, rather a language to program with (I think that the purpose of the Wolfram Language is not to let anyone write more than one-liners. If you need more than 8 lines to define a function, you are almost certainly doing something wrong. But in the rare cases where there is no other choice, it is a real pain.); * Closed-source; * I found some recent additions either half-done or distracting (to not say useless): `TimeSeries`, `Association`, `Dataset` are a few I can think of. I spent an absurd amount of time trying to understand how they worked and what more they gave me in comparison to what I did before they were introduced, only to decide that I should just ignore them and keep working with plain lists like I always have. I might edit this later should other things come to my mind.
Very interesting. If you like vim, and don't like the mouse, have you ever played with writing scripts as .wl files in vim and then executing those scripts through the wolfram kernel? There's even the UseFrontEnd command for when you need to generate graphics. What exactly do you mean by 'Not really a language to program in, rather a language to program with '. Do you mean it's more to be used as a tool alongside other languages?
I like it's graphing, the rich mathematical toolkit, the fact symbolic manipulation isn't bolted on. I have mixed feelings about its evaluation rules, e.g., if I haven't defined 'f' and I ask for 'f[x]' I get 'f[x]'. Most of the time using it interactively that's what I want, but when I'm trying to write a little program or function, it's often not. It's licensing is probably the worst issue though because although I've built up my own small library of functions, I feel like they're a bit of a waste. I can't take-it-with-me anywhere. It's not really worth sharing because the inaccessibility of the application makes any open source code moribund on delivery. Also for being a rather expensive application, it has crashed on me many times, and for the most part it's not updated. When they do bug fixes those go into the new upgrade that you have to pay for. Overall I still pop it open for quick calculations but it's falling out of my workflow.
What sort of work do you do and what other languages do you like to use?
&gt; have you ever played with writing scripts as .wl files in vim and then executing those scripts through the wolfram kernel? I have never really done that, mostly because the force of Mathematica is its interactivity: you enter a couple of lines, you get a graph back, you type another line, you have another graph, etc. It would probably take some work to be able to use an external editor while saving the interactivity and the notebook format. &gt; What exactly do you mean by 'Not really a language to program in, rather a language to program with '. I am not sure I choose the right words here (it was late in the night and it sounded nice). What I meant is that I would not really call "programming" what I do in Mathematica. Sure I apply functions to expressions, use recursion, compute fix points, etc. And in the huge majority of cases it is enough. But I would never write a 50-line program in Mathematica (although I am aware that someone programmed a Minecraft clone in Mathematica in way more than that and it actually works), for the same reasons that I don't use C as a calculator, or Python to write an operating system. Mathematica is an amazing tool to *explore* problems, not to *build* other tools.
What sort of work do you do and what other languages do you like to use?
Ah, fair enough. I wonder how easy it would be to make something like a command line notebook interface. Basically vi, but with cells and in each cell there's a command to evaluate which makes a sub cell below with the output, and if there's graphics it just opens them in an x-window So if you don't 'program' in Mathematica, what languages do you use for your programming needs?
I've been really interested in Haskell lately but haven't had the time to try and learn it. Do you use it much? Do you like it?
I first used it for school, then to solve some problems on Project Euler that called for Haskell. I like it because it is unique in its kind (although I should also mention OCaml, or they'll take back my computer science master). But I lack the practice to use it more than that, and I can do without it, that's why I am not actively maintaining my Haskell knowledge.
Now that I'm out of academia, I'm using C# mostly. If I had cause to want to build something with more numerical capabilities, I'd go with Julia though it's still immature; it's at least exportable. If I wanted a Notebook like environment, I'd use R.
Set the c values, make a table with the x values, then make a table of {x, Solve[equation using x values from tables]}. then list plot and show both this and the data you want to compare it to. Should be quite straightforward
I wrote this on my phone on a bus. So may be some syntax corrections needed and apparently don't know left from right 
Mathematica supports comments, even when you can "just write it into a plain text cell" because every programming language supports them. The Wolfram Language is different from the Mathematica front end, and you can write code in WolfLang independent of it, where there are no plain text cells.
this is what i was thinking. is there a guarantee that we are getting the correct answers for this equation?
You can use pattern matching on x in your definition of f(x). https://reference.wolfram.com/language/tutorial/PuttingConstraintsOnPatterns.html
Hey, did you try to do a PlotStyle input in your Plot definitions to set the colors? When you do the two plots it probably defaults to the same colors and then when you do Show they're both defined the same way. 
Awesome! Glad it worked! 
When I use this I just get the number I gave for `userInput` out.
* Make a line plot of * a list of random integers where * the nth integer is between 0 and n. Try to read and do this from the bottom up.
IDK why. Did that happen each time? Maybe you got lucky and got it first time? If not, I'm not sure why that would happen. I don't have *Mathematica* at the moment, so I can't check it myself...
&gt; Plot[Sign[5-x], {x, 0, 10}] Thank you, it's always nice to know multiple ways.
Try this: userInput = Input["Enter a number between 0 and 100"]; NestWhileList[RandomInteger[100] &amp;, RandomInteger[100], # != userInput &amp;]
&gt; I'm not sure why that would happen. The While loop exits when num == userInput, and you return num at the end. What else did you think would happen?
Oh. I made a typo... Meant to output "output" Now I feel dumb... 
This works. This works really well, actually. But could you walk me through what's going on here? My understanding is that `NestWhileList` will apply a function, generating a list in the process, so long as a condition is true.
yes, so it starts with a random integer (the second argument) and continually applies the function RandomInteger[100]&amp;, then stops when "current number != userInput" is false. NestWhileList then returns a list of all the values that were used. the function in the first argument is like defining f[x_] := RandomInteger[100] the parameter isn't actually used, it just generates a new random number.
Yes. `NonlinearModelFit` would work. Syntax: `NonlinearModelFit[data, function, constants, variables]`
Post your code, not pictures of your code.
Don't put Pi in brackets.
Oh, its not, that just happened from the copy paste. Any other issues?
 Try ClearAll instead of just Clear. Sometimes multiple definitions of a function can be hard to follow.
When in doubt, you can access the manual by running commands like ?sin It will tell you that this isn't a function, but will link you to the online documentation, which you can use to search for Sin[]. Running ?Sin will then tell you the syntax from within the notebook frontend.
Ok, I think I got it! Thanks! I used: ListLinePlot[Table[RandomInteger[n], {n, 0, 100}]] I think they just wanted me to look at the graph and make the list length to be 100. I tried setting the list length to be from 0 to n but I don't think that actually makes any sense mathematically without defining n =.=
Just saw the movie and this was all that I could think about... Another main character was using Matlab though.
Maybe also try with /r/programming
Do you have any code to look at? At first glance it looks like your plots are kind of "switching". In other words, your plotting one eigenvalue for a while, then switch and plot a different one.
I think you're looking for the cross product. Given two vectors tangent to the surface, say the derivative with respect to s and the derivative with respect to t, if you take the cross product of the two you'll get a vector perpendicular to both. Since both those vectors were tangent to the surface, the cross product will be perpendicular to the surface, or normal to it. [Here are your spheres with normal vectors added](http://imgur.com/a/4zH0U) And here's the code I used to generate those. I'm a Mathematica novice, so I apologize for any dumb stuff. (* define a function to create vector arrows *) MyVector[start_, vector_, len_] := Graphics3D[ {Thick, Blue, Arrow[{start, start + len * vector /Norm[vector]}]}, Axes -&gt; True ] (* define the two spheres *) surface1[s_, t_] := {Sin[s] Sin[t], Cos[s] Sin[t], Cos[t]}; sphere1 = ParametricPlot3D[surface1[s, t], {s, 0, 2 Pi}, {t, 0, Pi}]; surface2[s_, t_] := {Sin[2 Pi s^2] Sin[t], Cos[2 Pi s^2] Sin[t], Cos[t]}; sphere2 = ParametricPlot3D[surface2[s, t], {s, 0, 1}, {t, 0, Pi}]; ds1 = D[surface1[s, t], s]; (* vector with respect to s *) dt1 = D[surface1[s, t], t]; (* vector with respect to t *) (* vector orthogonal to both, normal to the surface *) norm1 = Cross[ds1, dt1]; (* ditto for surface2 *) norm2 = Cross[D[surface2[s, t], s], D[surface2[s, t], t]]; (* draw a bunch of norm vectors, avoiding infinities at t=0 and t=2Pi *) normvectors1 = Table[ MyVector[surface1[s, t], norm1, .5], {s, 0, 2 Pi, Pi/4}, {t, Pi/8, 7 Pi/8, Pi/8} ]; (* show the vectors and the sphere *) Show[sphere1, normvectors1, PlotRange -&gt; All] (* ditto for sphere2, avoiding infinities at s=0 *) normvectors2 = Table[ MyVector[surface2[s, t], norm2, .5], {s, .05, 1, .05}, {t, Pi/8, 7 Pi/8, Pi/8} ]; (* show the vectors and the sphere *) Show[sphere2, normvectors2, PlotRange -&gt; All] 
What happens if you type in ?ServiceExecute and run the command? And are you on Mathematica 10 or an earlier version? ServiceExecute is a new command from 10.
Since it's a parametric formula, you'll have to find values for s and t that generate the point you want. Then just plug those into the "norm1" formula. Define the surface and normal vector: surface1[s_, t_] := {Sin[s] Sin[t], Cos[s] Sin[t], Cos[t]}; ds1 = D[surface1[s, t], s]; dt1 = D[surface1[s, t], t]; norm1 = Cross[ds1, dt1]; Try the point defined by s=Pi/4 and t=Pi/4. Here's the (x,y,z) coordinate: surface1[Pi/4, Pi/4] Output: {1/2, 1/2, 1/Sqrt[2]} And here's the normal vector: norm1 /. {s -&gt; Pi/4, t -&gt; Pi/4} Output: {1/(2 Sqrt[2]), 1/(2 Sqrt[2]), 1/2} (1,1,1) isn't actually part of the surface; that's a little bit outside of the sphere. 
Not at my desktop now, but I have version 11. The following returns one result, something about "The World of Hillary Clinton - Google+" results = ServiceExecute["GoogleCustomSearch", "Search", {"Query" -&gt; "garlic", MaxItems -&gt; 10}] 
What does this have to do with Mathematica?
Mathematica has yet to release an iOS version and MathStudio is a great alternative. MathStudio also works completely fully-featured free in your web browser which Mathematica also does not offer yet. The promo codes provided let you download the paid version for free.
I used the code 3TAPPAEWNN6M. I've never seen this app before, I'm interested to try it out. Thanks for the codes.
Does the notebook attempt to load data from an external file like a .txt file in a specified directory? If so it's possible that the directory exists on your friend's computer but not yours. This would obviously cause errors on your end. Without seeing the code this is my best guess. 
What do you mean by range, exactly? The spread along the x-axis, or the spread along the y-axis?
Ok. The form I gave earlier assumes equal x ranges for both functions. To do what you want, you need to make multiple Plot[]s, and combine their representation with Show[], e.g. Show[ Plot[Sin[10*t], {t, 1, 4}, PlotStyle -&gt; Red, PlotRange -&gt; {{0, 4}, Automatic}], Plot[Sin[15*t], {t, 0, 3}, PlotStyle -&gt; Blue] ]
The general format for NDSolve is sol = NDSolve[{g1'[t]==eqn1,g2'[t]==eqn2,...,g1[t0]==g1int,g2[t0]==g2int,...},{g1,g2,...},{t,t0,t1}] g1 = sol[[1,1,2]] or Evaluate[g1[t]/.sol] g2 = sol[[1,2,2]] or Evaluate[g2[t]/.sol] gn = sol[[1,n,2]]... try defining non differential equations outside the NDSolve enviroment like m[t_]:=m0*(1-YT[t]-YV[t])
 (*VARIABLES THAT WILL BE CALCULATED*) f[t], T[t], YT[t], should be (*VARIABLES THAT WILL BE CALCULATED*) {f[t], T[t], YT[t]},
You might want to look into using NonlinearModelFit, which outputs a model that you can then ask for the parameter uncertainties