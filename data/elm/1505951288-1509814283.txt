Totally agree with this point — a rushed job will result in degradation of quality and regrets down the road.
I think there is no need to have toGetter/toSetter But I would love setters in a similar way we have getters. Unfortunately there are no plans for it in a near future
What are the elm 0.19 features?
I'm not sure I see how https://github.com/rtfeldman/elm-spa-example/blob/master/src/Main.elm#L440 could be improved by auto generated setter functions or the ability to convert a getter in to a setter. Did you link to the right code? I'd expect the code to have some huge list of generic field setters. eg. -- Setters for every field name I have in a record -- setPizza: a -&gt; {m| pizza: a} -&gt; {m| pizza: a} setPizza a b = {b| pizza = a} setCheese: a -&gt; {m| cheese: a} -&gt; {m| cheese: a} setCheese a b = {b| cheese = a} I'm still not sure I get a specific use case for converting a getter to a setter though. 
This was discussed [at length](https://github.com/elm-lang/elm-compiler/issues/984) with, unfortunately, no final decision. This sort of thing would be amazing, although the toGetter/toSetter would be a type-nightmare as observed by others here.
I agree, as long as there's a way to get both the setter and getter with one call so you don't need to duplicate code.
Ah, didn't know that. Funny that they suggested the same syntax as me :P Thanks for the tip.
Well, I'd also need the ability to have case blocks that can use constants in the match expression for sure. Maybe more.
Don't know what OP was referring to specifically. This is all I could dig up.. https://github.com/elm-lang/projects/blob/master/roadmap.md
You can use nested `if else` for that. `case of` blocks are for pattern matching against literals.
[removed]
That’s a bit silly though. It doesn’t make sense to allow matching on 1 but not a declared constant 1. if/else isn’t a substitute for pattern matching imo. Not for readability at least. 
It makes a lot of sense. You *need* `case of` to pattern match against literals, you don't need to pattern match against constants. You can match against constants with `if else`.
What does that even mean? A constant is just a name for a literal. If I need to match against one I need to match the other. They are the same thing except the name. 
I too would love a getter/setter pair notation of some sort. Perhaps someday.
A constant is a name for a value. Values exist at runtime. A literal is distinct from the value it represents. A literal exists at compile time. It's the syntax in the language for constructing a value. A `case of` block matches on patterns. You can write a pattern by taking a literal and replacing parts of it with placeholders to represent values you wish to extract from the value you're matching the pattern against. 
A constant is constant (duh). Meaning it can be replaced by the literal it is defined as at compile time by the compiler at will. That’s very common for compilers to do. I know what a case block does. You don’t seem to understand the most basic things about compilers though. 
&gt; The immediate thing to think about is what problem you're solving :) So, what pain is this actually addressing? Why do we have getters? What problem do they solve?
Until then: code generators. 
 A literal is part of the language not any part of compiled output. Certainly a compiler can replace any instant of a constant with the value it represents, but that's not a literal.
Ok. And what was your point?
Here is some model: type alias Model = { someField : Int , email : String , name : String } Some initial value: init = { someField = 0 , email = "aleksey@example.com" , name = "aleksey" } I want to move "user" model ("email" and "name" fields) to another module, using extensible records, like this: module User exposing (..) type alias User model = { model | email : String , name : String } initUser model = { model | email = "aleksey@example.com" , name = "aleksey" } -------- module Main exposing (..) type alias Model = { someField : Int } init = ... -- What must be here? Is there any way to split the initial value as I do it with type? Thanks!
I think your point would be stronger if you didn't include the punctuation-mark analysis.
You will want to return a Cmd msg with a msg to start the animation. Here’s how to turn a msg into Cmd msg, but be aware of the tradeoffs https://medium.com/elm-shorts/how-to-turn-a-msg-into-a-cmd-msg-in-elm-5dd095175d84 You might as well search how to perform the animation without having to update the DOM 2 times. 
Have you seen https://github.com/mdgriffith/elm-style-animation ? It might solve your problems :)
Use [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame) with http://package.elm-lang.org/packages/elm-lang/animation-frame/latest. The scheduler uses it to render the view so any `Msg` that you queue will run straight after that.
I think you really want to look at using `andThen` when working with Monads and pull it apart into more digestable pieces. E.g. findCourse id courses = courses |&gt; List.filter (\course -&gt; course.id = id) |&gt; List.head findLesson id lessons = lessons |&gt; List.filter(\lesson -&gt; lesson.id = id) |&gt; List.head dropFlashcard id flashcards = flashcards |&gt; List.drop id |&gt; List.head findAndDropFlashcard courseId lessonId flashcardId courses = findCourse courseId courses |&gt; Maybe.andThen (\course -&gt; findLesson lessonId course.lessons) |&gt; Maybe.andThen (\lesson -&gt; dropFlashcard flashcardId lesson.flashcards) So here findAndDropFlashcard will return `Nothing` of `Just flashcard` which you have above in your let block. How Maybe.andThen works is it takes a function which works with the type you're working with (e.g. \course -&gt; ... as above) and must return another Maybe (i.e. List.head returns Nothing of Just, so a Maybe). If Maybe.andThen encounters `Nothing`, it simply returns `Nothing` and doesn't run the function. If it encounters a `Just`, it grabs what you have (e.g. `Just course`) and feeds that into the `andThen` function `\course -&gt; ...` I'm not familiar enough with elm yet but is there a "takeFirst" function? Filter |&gt; Head seems quite repetitive takeFirst pred xs = case xs of [] -&gt; Nothing x :: ys -&gt; if (pred x) then Just x else takeFirst pred ys takeFirst (\c -&gt; c.id == courseId) courses -- is the same as this but without the looping through filter courses |&gt; List.filter (\c -&gt; c.id == courseId) |&gt; List.head * edited to improve code formatting
sorry, I'm punctuation-sensitive :-)
The problem with these frameworks is that they all have a ton of logic implemented in JS with a programming paradigm that is completely different from the way Elm works. I guess you could take a hello world of all your candidates and try to apply the 4 approaches you listed on each one of them as an evaluation exercise. Though, I wouldn't be suprised to find a few hours/weeks/months in that there were fundamental concepts that are just painful to maintain in the long run with a hybrid approach. I would probably try to use the CSS of framework X and implement the JS in Elm, I did just that with bootstrap stuff but on a much smaller scale, admittedly. Good luck
Agreed, by now --- just happened across the likes of `elm-mdl` and `elm-mdc`, will probably jump on the latter as a foundation for starters.
I'm working on simple cart modal in default spree website with changing product quantity
quasar-framework with vuejs. 
I admit it looks damn nifty. Are you using this in an Elm app though? Is keeping Vue+Q components and Elm model in sync a headache, or a smooth process?
no, no Elm. Plain VueJs
I don't have much to add to aabrook's approach for handling the model as it's currently structured, so I went at this from the other direction and thought about redesigning the model. It looks like you're typically looking up specific lessons, courses, and flashcards by an ID or index, so it feels natural to replace `List` with `Dict`. By using dictionaries instead of lists you can avoid having to iterate through a bunch of other values on the way to the one you're interested in. This will let your code be faster as well as more readable. And the compiler will also stop you from having multiple courses etc with the same ID, ruling out a whole class of possible bugs (aka Making Impossible States Impossible^TM). I made a few simplifying assumptions before I fiddled with the problem: * You'll have access to the whole model when performing this update, and all you really need to do is return an updated model * You can create the `Encounter` record somewhere else (so I don't have to think about getting the current time) * You'll only need to update the current flashcard, in the current lesson, in the current course So here's my take [edited for format - turns out in Reddit you make code blocks by adding 4 spaces to the start of every line, not by surrounding the whole block with backticks]: import Dict exposing (Dict) type alias Model = { courses : Dict String Course , courseId : String , lessonId : String , flashcardIndex : Int } type alias Course = Dict String Lesson type alias Lesson = Dict Int Flashcard type alias Flashcard = { front : String , back : String , encounters : List Encounter } type alias Encounter = { isKnown : Bool , time : Float } addEncounter : Model -&gt; Encounter -&gt; Model addEncounter model encounter = let updateCourse = Dict.update model.lessonId (Maybe.map updateLesson) updateLesson = Dict.update model.flashcardIndex (Maybe.map (\flashcard -&gt; { flashcard | encounters = encounter :: flashcard.encounters })) newCourses = Dict.update model.courseId (Maybe.map updateCourse) model.courses in { model | courses = newCourses }
There's `find` in the elm-community `List.Extra`. Found it by searching its type signature at http://klaftertief.github.io/elm-search/?q=List%20a%20-%3E%20(a%20-%3E%20Bool)%20-%3E%20Maybe%20a
This is a bit of a tangent, but the notation of spaces separating everything only made sense to me once I understood [currying](https://en.wikipedia.org/wiki/Currying). Behind the scenes, every Elm function takes exactly one argument. You're used to thinking of `add a b = a + b` as a function that takes two numbers and returns another number. But as far as Elm is concerned, this is just another way of writing `add = \a -&gt; (\b -&gt; a + b)` - that is, `add` is a function that takes a single number `a` and returns a new function that I'll call `add_a`. This `add_a` is now a function that takes another single number, `b` and adds `a` to it. (Infix operators like `|&gt;` and `&lt;|` complicate this a bit but you can ignore that for now. They're basically just convenient ways to avoid parentheses. (I like parentheses :D)) ---- As for `Html Msg`, have some more names for it. It might not help directly, and you definitely don't *need* to know any of these terms, but when you come across explanations for the same idea in a different context you'll be able to connect it up. Another way to say `Html` is a *parameterized type alias* and a *higher-kinded type* (as others have mentioned) is to say that `Html` is a *[type constructor](https://en.wikipedia.org/wiki/Type_constructor)*, or a *type operator* which has [kind](https://en.wikipedia.org/wiki/Kind_(type_theory) `* -&gt; *`. The concrete type `Html Msg`, where `Msg` is whatever specific message type your app has defined, is a *functor* - that is, it's a thing for which it makes sense to have a `map` function. You could say it's a strategy for producing a value of type `Msg`. [This SO answer](https://stackoverflow.com/questions/13134825/how-do-functors-work-in-haskell/13137359#13137359) gives a decent summary of how functors are used in Haskell. Like Elm's `Html`, Haskell's `IO` is a thing where you can't just pull a value "out" and use it raw in the rest of your program, but mapping over it still makes sense.
Awesome, thanks! I think I'll be spending time with elm-search in future.
So far I only found a single CSS framework with no JS whatsoever : http://bulma.io
I haven't been doing software for that long, but long enough to witness interesting patterns. Some projects require full teams, other require dedicated singletons. My favorite projects keep coming from the latter. I'm proud to be a part of this community and I fully support your ability to take this project in the right direction. We're all itching for more, but I really do appreciate your resolve to stick with "correctness" over "quickness". After all, that's what this is all about, and why I'm here. So I say take your time. It's much appretiated
I wrote out the function using Maybe.andThen and it's still pretty big, but it definitely looks better. Thanks. type alias Model = { courses : List Course , courseId : String , lessonId : String , flashcardIndex : Int } type alias Course = { id : String , lessons : List Lesson } type alias Lesson = { id : String , flashcards : List Flashcard } type alias Flashcard = { front : String , back : String , encounters : List Encounter } type alias Encounter = { isKnown : Bool , time : Float } getCourse : String -&gt; List Course -&gt; Maybe Course getCourse id courses = find (\course -&gt; course.id == id) courses getLesson : String -&gt; List Lesson -&gt; Maybe Lesson getLesson id lessons = find (\lesson -&gt; lesson.id == id) lessons find : (a -&gt; Bool) -&gt; List a -&gt; Maybe a find test xs = xs |&gt; List.filter test |&gt; List.head getAt : Int -&gt; List a -&gt; Maybe a getAt index xs = xs |&gt; List.drop index |&gt; List.head getFlashcard = getAt findAndDropFlashcard courseId lessonId flashcardIndex courses = getCourse courseId courses |&gt; Maybe.andThen (\course -&gt; getLesson lessonId course.lessons) |&gt; Maybe.andThen (\lesson -&gt; getFlashcard flashcardIndex lesson.flashcards) addEncounter : String -&gt; String -&gt; Int -&gt; Encounter -&gt; List Course -&gt; Maybe (List Course) addEncounter courseId lessonId flashcardIndex encounter courses = getCourse courseId courses |&gt; Maybe.andThen (\course -&gt; getLesson lessonId course.lessons |&gt; Maybe.andThen (\lesson -&gt; getFlashcard flashcardIndex lesson.flashcards |&gt; Maybe.map (\flashcard -&gt; let newLesson = { lesson | flashcards = flashcard :: lesson.flashcards } newCourse = { course | lessons = List.map (\lesson_ -&gt; if lesson_ == lesson then newLesson else lesson_ ) course.lessons } newCourses = List.map (\course_ -&gt; if course_ == course then newCourse else course_ ) courses in newCourses ) ) ) 
This looks a lot cleaner. I'll try this implementation because it looks a lot better and I like how it makes impossible states impossible. The assumptions are pretty safe to make since I can't imagine giving the user having the ability to add an encounter for a flashcard that they aren't currently viewing. Even if that assumption didn't hold true, I could always just have the courseId, lessonId, and flashcardIndex be parameters in the function. Thanks!
 it's the same thing: init : User Model init = { someField = 0 , email = "aleksey@example.com" , name = "aleksey" } The [ending of the records documentation](http://elm-lang.org/docs/records#record-types) has an example that might shed more light.
The next major version of Ionic is being implemented as web components / custom elements. It should be usable from pretty much any way of building web apps, including Elm.
https://ellie-app.com/Npw2y38a1/0
A bit of refactoring: https://ellie-app.com/5CqKrcJ6ya1/1 * you don't have to inline as much - put stuff in a top-level value, that will flatten the code a bit! * `asFooIn` argument-flipped variant of the `setFoo` pattern comes in handy here if your pipeline goes from the bottom up (deepest values -&gt; build into the broadest values) EDIT: to explain a bit: type alias Foo = { bar : Bar } type alias Bar = Int setBar : Bar -&gt; Foo -&gt; Foo setBar bar foo = { foo | bar = bar } asBarIn : Foo -&gt; Bar -&gt; Foo asBarIn foo bar = { foo | bar = bar }
This is such a frustrating concern. Just hire people and train them to use Elm! That's the only way industry is going to move on to better things. 
Thank you, that sums it up nicely. I've had some more time with Elm and I can write simple applications with it now. I've even gotten over the urge to break up stuff in components. After 20 years of imperative programming (every other language) and declarative SQL, functional is very different. Evan keeps saying to ignore that urge to build components, and he is right. Object-oriented thinking just doesn't apply! As for the compiler, every time I build something, I know it will do what I wrote it to do. This is so different from writing something in PHP, the contrast is laughable. 
Reading https://groups.google.com/forum#!searchin/elm-dev/kernel%7Csort:relevance/elm-dev/bAHD_8PbgKE/X-z67wTdCAAJ right now, seems pertinent. Still so much in flux, I see. Ah well
I don't think you are giving credit to how much complexity this would add to the language for how little gain. I could sit at a coffee shop all day scribbling down neat little syntaxes I might want. (Or I could steal any of the millions Haskell has). But one of the benefits of Elm is that the language is small on purpose. This makes teaching easy, excellent tooling possible. There are trade-offs, but this way, the complexity stays in the programs and away from the language.
You can encapsulate a getter and a setter with a lens. I don't think it's possible in Elm, and it has a really weird type signature. 
A lot of them are yes. There’s also result types and many of those things you listed are from things you can’t do in Elm like file IO. 
Thanks!
`Maybe` is often used to indicate the possibility of failure. Getting the element at index `n` from a list will fail if `n` is out of bounds, so returning `Maybe` makes perfect sense in that situation.
You can define a `worker` and have it encapsulate the business logic. You would then send the worker messages and each message will trigger sending the model back to JS. You would then listen for these models and react in your GUI appropriately. [Here is the counter example adapted to show how you could do this.](https://ellie-app.com/gSM3Hfzbza1/0) 
That's just awesome and I hadn't found `worker` before. Still using ports but the apparent cleanliness of the approach is pretty compelling indeed. Will play with how that approach performs and scales in practice.
After what must be a few months of wanting an excuse to try Elm I’ve just started rewriting the website login page using it. Initial impressions are really positive, some error messages are kind of cryptic, not because the error messages are bad (they’re great), it’s just my lack of familiarity with Elm. Another great thing is that to add Elm into the project was amazingly easy. I just added a new rule containing two new loaders into our webpack config and I was away. Here’s to many more lines of Elm!
&gt; I know that Elm can handle Null values using MayBe Maybe doesn't 'handle' null values. It is a way of representing something similar to null values, but the *concept* of 'null' being a possible alternate value for every value in the language just doesn't exist in Elm. You have to be explicit when you use Maybe. A function or method which can produce `null` or an exception is just expanding the return type of the function and the language has an alternate resolution path for exceptions. These are *not* a required language feature. Take a look at [Http errors](http://package.elm-lang.org/packages/elm-lang/http/1.0.0/Http#Error). In another language you might implement these as exceptions. Instead, Elm implements them as a data type and eventually some function is going to have to account for every possibility in that list (even if that means just ignoring it). You can't have unhandled exceptions if you don't have exceptions.
Hello! I'm trying to decode a recursive JSON object: { "title": "Post Title" "comments": [ { "text": "Comment 1", "comments": [ { "text": "Comment 2", "comments": [] } ] } ] } Originally I represented this structure using following two type aliases: type alias Post = { title : String , comments : List Comment } type alias Comment = { text : String , comments : List Comment } And the decoder looked like this: decoder : Decoder Post decoder = decode Post |&gt; required "title" string |&gt; optional "comments" (list decodeComment) [] decodeComment : Decoder Comment decodeComment = decode Comment |&gt; required "text" string |&gt; optional "comments" (list (lazy (\_ -&gt; decodeComment))) [] Elm compiler hinted that recursive type aliases are not allowed, so according to [the advice](https://github.com/elm-lang/elm-compiler/blob/master/hints/recursive-alias.md#less-obvious-but-nicer) I transformed Comment type alias into this: type alias Comment = { text : String , comments : ChildComments } type ChildComments = ChildComments (List Comment) But now I'm not sure how the decoder should be changed. Everything I tried seems like not even close to the correct version. Any help with the decoder is appreciated, thank you! 
There are some good answers in here already. There are a lot of differences between Elm and Java but a more fundamental difference is in languages like Java null *is a subtype* of most types. In Java if you declare something as a `String` you don't know at compile time if that variable is actually is String or null. If you have `myStringList.get(0)` you don't know if the return value is null. As a result you have to check for null frequently, or strategically add runtime exception handlers. These types of problems don't happen in Elm because null *is not a subtype*.
&gt; Does elm have the necessary API to access the local filesystem and execute external programs? Inside Elm proper no. You'd have to use something like node and Elm ports to talk to it. I'm assuming node has local filesystem stuff of course...
Afaik, browsers (and by extension Elm) don't have native write access to the filesystem. But what you can do is write an app on [Electron](https://electron.atom.io/), which is a platform for building cross-platform UI's with web technologies. Google around and you should find some guidance on getting elm and electron to play nice You can do the entire UI and command building process in elm, and send the commands over a port that uses electrons apis to manipulate files. 
I can see two ways to write the `decodeComment` function. #1: decodeComment : Decoder Comment decodeComment = decode Comment |&gt; required "text" string |&gt; optional "comments" (map ChildComments (list (lazy (\_ -&gt; decodeComment)))) (ChildComments []) In this example, I used Json.Decode.map to turn a `Decoder (List Comment)` into a `Decoder ChildComment`. #2: decodeComment : Decoder Comment decodeComment = decode Comment |&gt; required "text" string |&gt; optional "comments" decodeChildComments (ChildComments []) decodeChildComments : Decoder ChildComments decodeChildComments = decode ChildComments |&gt; custom (list (lazy (\_ -&gt; decodeComment))) In this example, I made a separate decoder for `ChildComments`, and the two decoders reference each other. 
That’s hard to argue in the real world when the main concerns are time, money, and returns on investments.
Absolutely, but Elm can help w.r.t. cost. 
Either you go Node + ports (the "official" way), or you go native/"kernel" modules. This is all a trip into a bit discouraged-from territory, but it works (my Slack bot works this way): https://github.com/ElmCast/elm-node It exposes: File.read : String -&gt; Task Error String File.write : String -&gt; String -&gt; Task Error () NodeProcess.exec : String -&gt; Task String String Which you can transform into `Cmd`s.
If running on users' own machines you have to consider installation of nodejs or somehow packaging up your scripts with the nodejs libraries/runtime as an executable. On top of porting out to Node from Elm. Electron is definitely one option to avoid this hassle. Personally, when I've had similiar situations at work (though not with files in multiple directories), I've just had users drag and drop files onto a shortcut to a VB script. You get the file paths as args. Easiest UI possible ;) But sounds like you do need a form of some kind given their files are spread out. And you might need a bit more security than this quick and dirty way. ;) 
Any of those cryptic errors keeping you from making progress? Would love to help if you're stuck.
You would want to use something like Electron, the problem is that the Electron API's you will want to use do not exist in Elm so you will have to do a lot of ports. I hope that someday there is an Elm Electron package that would let you do all the things you might want to do in Electron, but that won't be for a while I expect. 
Thanks for reaching out. I’d really appreciate being to run a couple of easy questions past you. I’ll give you a quick message once I’m all fired up behind the computer.
I don't know how complicated a GUI you need but you say it could be done with a bash script so maybe consider something like [this](https://github.com/chriskiehl/Gooey)? I haven't used it myself but I seems like it does exactly what you want: wrap one-off Python scripts you want so share with other people who can't handle a CLI.
I'd agree the compiler should catch this. You should probably file an issue on Github.
I'm making the final preparations for elm-conf! Got schedule boards, speakers, venue, food, badges, and videos all sorted. Just little catch up things left to do!
Works great, thank you!
yes, this should be prevented, just found the corresponding issue in elm-lang/compiler https://github.com/elm-lang/elm-compiler/issues/1570
Still pumping out my Elm/Haskell E-Commerce site: https://github.com/Southern-Exposure-Seed-Exchange/southernexposure.com Finished the add to cart forms for registered &amp; anonymous customers on the Category &amp; Product pages, as well as a basic Shopping Cart page that allows customers to update quantities &amp; remove items: https://github.com/Southern-Exposure-Seed-Exchange/southernexposure.com/blob/master/client/src/Cart.elm Now I'm adding in various things to finish off the shopping cart page, like shipping methods, taxes, coupons, &amp; surcharges. After that, I got a couple of other cart features(like merging an anonymous &amp; registered cart when a user logs in), then I'll start the checkout! Beginning to see the light at the end of the tunnel :) 
Personally, if Ionic does everything you need, I would not just use it as-is. Yes, you **could** wire it into Elm application logic, but the complexity and work involved would probably far outweigh the benefits you'd be getting from Elm. 
There's also Picnic: https://picnicss.com
Thanks.
I constantly click into these sorts of threads with an answer in mind only to notice OP wasn't asking the question. :P
And of course you can reintroduce a runtime error by forcefully unwrapping a `Maybe`: unwrapMaybe : Maybe a -&gt; a unwrapMaybe maybe = case maybe of Nothing -&gt; Debug.crash "IndexOutOfBounds" Just a -&gt; a Something that can be useful in library code.
I don't know if there's another talk, but [Matthew Griffith's talk at Elm Conf Europe 2017 is on YouTube](https://www.youtube.com/watch?v=NYb2GDWMIm0 ).
After more than a year of work, I have made www.rexpad.com public beta. RexPad is a nimble collaborative note-taking app. Both the editor and the data structures for real-time synching are written from scratch in Elm with some JavaScript sprinkled in. The backend is Elixir/Phoenix.
Thanks for the reference. Gooey looks quite good; I need to check it out to see if it fits my requirements. I need a little more than just reading arguments using GUI interface. The user should also be able to re-order/remove the arguments after they are read.
&gt; Electron is definitely one option to avoid this hassle. Looks that way. I am checking out Electron.
I was looking for an excuse to try out Elm :) I guess that will have to wait for my next project.
I will try to come up with better headlines then :)
Can anyone recommend resources to get me up to speed with using the Http library, decoding responses, etc.? For whatever reason, it's one of the only pieces of the Elm ecosystem I haven't interacted with yet and I'm finding the documentation sparse and confusing. I spent the afternoon trying to get a proof-of-concept up and running, but kept running into problems - particularly getting the types to line up between my decoder (which requires a nested custom decoder ...) and `Http.send`.
If you're like me, sometimes an example is better than documentation. Check out the `SubmitForm`and `LoginCompleted` messages in the login page of the elm-spa-example as well as the decoders at the bottom of the same file: https://github.com/rtfeldman/elm-spa-example/blob/master/src/Page/Login.elm#L98 Feel free to reply here or in Slack if you're still stuck.
This is really cool — thanks for sharing!
thanks
I will check out the above. Thanks for the tip and the offer to chat further! :)
You make a small mistake near the end of your video. Clojure is not weakly typed, it is strongly typed but it is also dynamically typed. Dynamic and weak are two different things.
Looks very promising! Could you please share the source?
Hi, thanks! Of course, it's all open source (MIT licensed). Here4 is at: https://github.com/here4/here4 and this world is currently hacked into the 'roads' branch of Dreambuggy: https://github.com/kfish/dreambuggy Ping me if you need any help building, either here or on the Elm Slack -- I'm usually on #gamedev as kfish.
In fact, there *is* another Elm Firebase library that's updated for 0.18. Its called, err, [elm-firebase](https://github.com/pairshaped/elm-firebase). It's not complete, but it's got database and most of auth implemented.
Looks nice
Post example https://github.com/simonh1000/file-reader/blob/master/examples/Ex4-filepart.elm#L151
Please don't do that!
Any problems with rich text editor? What did you use?
I have built the editor from the ground up using contenteditable as it is central to the application, and as I want special features like live diff views.
Until you understand what is going on better, you should separate the HTTP and the JSON decoding. Are you able to share example JSON and your attempt at a decoder, perhaps on [Ellie](https://ellie-app.com/new)? If you need a lot of back-and-forth (and this kind of problem often does), the folks in the Slack #beginners channel have seemingly-endless patience for helping with these issues.
Thanks for the suggestions. I've made some progress on my particular problem and will try to find some time to write up a tutorial or, at least, document and share the code.
I will have a look. Thank you!
My favourite way of explaining the benefits of immutability, is... saying it's analogous to a config file. Once you set a config you never have to worry about it
This has got me thinking--not about the specific problem in this question, but about nested data structures in Elm in general. From watching talks by Evan Czaplicki and Richard Feldman, I get the strong impression that deeply nested data structures are not considered a good idea in Elm. So I started thinking about what would happen if we took their advice to extremes, and tried to avoid using nested data structures *at all*. Would it be possible to represent deeply nested data in a different way, while still preserving the relationships between pieces of data? So then I thought... isn't that what relational databases do? You keep the data in tabular format (perhaps each table could be a list of tuples or a list of lists in your model), and you model the relationships by storing references from one table to another, instead of embedding one piece of data inside another. This limits the depth of the data structure, because you can't have tables within tables or rows within rows. If you've already got a relational database on the server side (SQLite, Postgres, etc.), then this might also an upside in terms of communicating with your Elm app. Instead of converting from your backend tables into deeply nested JSON, transmitting it to Elm, and then worrying about how to translate it back into some structure that's going to play nice with Elm, you could have a very similar table-ish structure on both sides, and you wouldn't need to do so much wrangling to get data from one side to the other. At the moment, it seems like I'm spending a lot of time fiddling with deeply nested objects just because I'm sending the data by JSON, and JSON allows/encourages me to create deeply nested objects. But that's because JavaScript likes dealing with nested objects, and I'm not using JavaScript either on the frontend or the backend. Is it possible that a flat, relational-database-style table structure might be a nicer, more Elmish approach? But I am just a beginner and I don't know much about computer science, so I'm guessing that there's probably an obvious downside to this that I'm not seeing. Perhaps it would actually be more complicated to do all the table joins etc. in Elm and you're better off just sucking it up and dealing with deeply nested data when there's no other choice?
That's absolutely brilliant!
Thanks for writing this!
Thank you! If you try it out I'd love to hear your thoughts and suggestions if you have any.
Well done! We use Elm at work, which I enjoy, but I also like TypeScript. I'll definitely be playing with this soon.
It's great for flags. You can use a decoder but if you didn't get your flags right it's usually not recoverable.
Any chance for source code?
well done! Do you have any idea/project for Flow support?
Thank you! I've found typescript to be a great fit for interop with Elm since there are a ton of libraries with @types/&lt;library&gt; type declarations you can use to get type-safety for JS libraries, and it has some nice language features like discriminated union types. The next set of features I'm thinking about experimenting with are around handling port subscriptions with a union type in a single subscribe function, similar to how the Elm update function works (so it won't compile if you forget to handle a case). I haven't played around with Flow yet, what led you to choose that over typescript? I don't have any plans to support Flow at the moment. If there's a lot of demand then I would consider it, but in the meantime you could certainly fork the project if you're interested!
Yes, please don't. I'm pretty sure it's never OK to use Debug.crash, I think it's meant to be used if you absolutely have to build your project to test one particular thing. I don't recommend typing that in your source code, ever, if you can help it. Debug.crash basically is a NotImplementedException as used in .Net, no application should ever have one of those in it. 
I wonder why Evan put that in Elm. He must have had a reason but I can't think of any.
It is basically there to allow you to test things while not everything is implemented
I just chose it for a new project (4 months ago) involving Elm + React Native. The main reason is that I already worked with Typescript for more than 2 years and I didn't like it, thus I wanted to try something different. Furthermore, it came almost for free with the React Native project. Now I know I dislike Flow as well :-) but still, I need a type checker on the React Native codebase.
No, not in the short run at least. The editor is highly optimised and integrated for the current use case, and it would be a big task to extract it. Sorry.
I understand, but Evan's suggestion is to wire up the application first so that it runs, and then to slowly add stuff so you can compile and test at all times. I have found that to work great. I suppose there could be exceptions to that workflow. Basically your update case msg of... statement looks like a bunch of UpdateMsg -&gt; model ! [] at first.
I agree I would love there to be some kind of option to disallow Debug.crash. If nothing else you can make your build reject it with a grep. 
Maybe elm-make could reject it if you omit --debug (maybe it does - I haven't tested)
Or just flag them if you do --warn, I would like to see a --warn-as-error flag as well
Its perfectly fine to use Debug.crash in your code, in certain circumstances. Think about putting an 'assert' in Java code - it causes a runtime exception if the assert fails. You could take asserts out of production code, but there should be no harm in leaving them in. This is because you tested the code thoroughly and verified that it only fails assertions on inputs that can never happen in production. If they do - its a bug, and you get a nice stack trace telling you where the bug is, and you will be fixing it and adding to the test suite for the next release. It is similar in Elm. In many cases you can use the type system to rule out errors at compile time. In more complex cases, and because Elm lacks more advanced FP features like type classes, it can be harder to build static compile time checks for errors. So you may have a function that can only accept positive integers, and Elm does not have a type for positive only integers. Your function could fail with (Maybe) Nothing if it is passed a negative input. If your function is not a library function exposed in a published package, so you control all the ways in which that function is called, you could also use Debug.crash to fail when presented with a negative input. Your tests will confirm this is ok. Comparing Elm with Java - Maybe is like a checked exception. Debug.crash is like a runtime exception. Just as in Java, you might throw a runtime to indicate a code path has been reached that should be impossible. 
Maybe and Result are equivalent to checked exceptions in Java. Debug.crash is equivalent to a runtime exception in Java. You should never do a Debug.crash in a function exposed in a published package, and if you do it should be considered a bug to be fixed or a package to be avoided as buggy. Runtime exceptions are nasty surprises. Elm strongly favors checked exceptions and graceful recovery from errors.
Your boss should hire me.
At the Elm Europe conference, there was a company that made software for reviewing videos for French TV, I am sure you can find the talk online. They said that in order to hire they just had to find developers familiar with functional programming and that these developers could get up to speed with elm in a matter of days. Most computer science graduates over the last decades will have learnt lisp, ML or Haskell, so already there are plenty developers to be found.
Have you broken your model into meaningful data structures already? Are there noticeable split points where you can break one data structure out into its own module? Without more information or code all I can say at the moment is the page that consumes these data structures doesn't necessarily have to be complex if that complexity / verbosity can be encapsulated into modules, modules that house specific data structures.
I have a similar scenario coming up and it has been rolling around in the back of my head, so I'm glad for any discussion about it! Re. validation, I made a [library](http://package.elm-lang.org/packages/ericgj/elm-validation/1.0.1/Validation) that wraps up input field state together with validation errors, a bit similiar to how RemoteData saves you from having to store a bunch of external flags for loading state. That may or may not be helpful to you, and I welcome suggestions. I'm not sure what you mean by open-close state. Is this something the user initiates (e.g. toggle button), or is it a function of their input (e.g., if X is chosen from this dropdown, then show these extra fields, otherwise don't) ? If it's the latter, I would try to find a way let your form model type itself guide this. If it's the former, you could wrap your model or parts of it in a `type Toggle a = Open a | Closed` or whatever, but not sure if there's much advantage to this over just `type Toggle = Open | Closed` state for however many sections you have to toggle.
You can use a [zipper](https://en.wikipedia.org/wiki/Zipper_(data_structure). You have two lists. the Top list has all the records that you have already processed, and that list is stored in reverse order, so that the top of the list is the previous record. The Bottom list has the next record at the top of the list and the last record at the bottom. Then, you have the current record in the model, and you use a union type to deal with the different configurations of any one record. edit: Sorry about the link. the wikipedia link has an embedded right parenthesis, and it messes with Reddit's hyperlink syntax, just follow the first redirect option. Honestly, I was hoping for a better article on zippers, but I can't find something with useful pictures.
I actually found the first is the best since the firebase API is already so simple. Ports as Json.Value.
The information in the form is about a complex process that requires a lot of parameters. I guess I could break the fields into segments but this only introduces more complexity and it will not solve the extra state/messages issue (it will only push it into another file). 
&gt; I'm not sure what you mean by open-close state. If one implements a dropdown, let's say with Bootstrap, the dropdown needs to have its own open/close state. &gt; Re. validation, I made a library that wraps up input field state together with validation errors, a bit similiar to how RemoteData saves you from having to store a bunch of external flags for loading state. Interesting! You gave me an idea. I could have a parallel structure that mirrors the form data with the same fields but with different types. I will explore this tomorrow with a fresh mind. Thank you! 
&gt; Am I getting the routing completely wrong? Why doesn't the import work? Most likely you are defining or importing another `s`. For example, if you have an `import Html exposing (..)` in the same file, you will have a clash with `Html.s` Narrow your imports or use it like `Url.s`. 
Then I get this compile error The 1st entry has this type: Url.Parser ((Route) -&gt; c) c But the 2nd is: Url.Parser ((String -&gt; Route) -&gt; c) c Not sure what to make of it
`Unsubscribe` takes a `String` as an argument. You are not supplying the said `String` You either need to use something like `Url.map (Unsubscribe "someString") (s "unsubscribe")` OR, more likely use something like `Url.map Unsubscribe (s "unsubscribe" &lt;/&gt; string )` if you want to match something like `/unsubscribe/something` 
It's hard to say a whole lot without seeing the code. If the requirements dictate inherent complexity then some file will own that complexity. IMO it's better for a module to encapsulate that, perhaps in an opaque type, than to leak that complexity into the code for the actual page.
What `Msg` updates the model that the table is displaying? You can fire off a `Cmd` when the update function handles that Msg. Also, see the [Dom.scroll](http://package.elm-lang.org/packages/elm-lang/dom/1.1.1/Dom-Scroll) module.
Great, thanks! Works just fine The only problem I have left is, if I manually type "localhost/unsubscribe/", I get a 404. I could solve this on the backend, but I want to avoid that. I can navigate perfectly with back/forward buttons however. I'm calling the ```parseLocation``` Method from above every time I click a button (for testing). Then, what happens automatically is UrlChange location -&gt; let newRoute = parseLocation location in ( Model input emailValidationMessage newRoute (Url.parsePath url location :: history), Cmd.none ) The Urlchange obviously works from within the app, why doesn't it from "the outside". Above that, I have simple type type Route = Home | NewRoute for which I change the value with ```newRoute``` as seen above. In view I simply ask which type Route is and adjust my view to that. Thanks man, you really helped me out a bunch here
Have you tried just doing it when you add the new row? Something like AddNewRow data -&gt; ( { model | addNewRow data model.table }, scrollBody () ) ? Also you may find this library easier for scrolling than dealing wiht ports: http://package.elm-lang.org/packages/elm-lang/dom/1.1.1/Dom-Scroll 
jinx!
Lol. Indeed.
I tried firing off the Cmd on the update (that is what my current code is doing), but the table scrolls to the row above the newly added row instead of the last row. If I understand correctly, that is because the currently displayed table does not yet show the new row.
That makes sense, thanks for the context. What did you dislike about typescript? It's certainly not perfect, but I wonder if they've addressed any of your pain points since then. I've found that the "strict" flag makes it a lot more robust.
You could try a delay. Check out [Process.sleep](http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Process#sleep).
Do you think there might have been a reason to restrict native.......
On the train on the way to my hotel now! Really looking forward to meeting a few people I've only ever interacted with online, and of course watching the presentations. 
My understanding is that it's a policy decision, for the elm-lang.org package repository. It makes sense for things like general-purpose data structure packages -- it's a useful bit of assurance to know that the basic language libraries I use have no native-code dependencies. That policy doesn't necessarily match everyone's use cases, hence the interest in things like grove and elm-github-install. These are just a mechanism, you could implement a policy like elm-lang.org's on top of them.
This is a big Foot-Gun™. I do understand the need that created this tool but it provides way too much freedom. It also ties Elm too much to the npm ecosystem. 
if only all that effort to make such a technically interesting project would go into making pure elm packages that are missed
Wish I was going!!!! Can't wait to watch the videos 😩 Have fun! I'm hoping for a preview of 0.19 🤞 
People are writing native code all of the time via Ports, Native Code modules and Effects Managers. They just cannot share them with others. Until now. 
You don't have to use the npm features to benefit. For example, if you happen to write Native Code that doesn't use npm modules, then Grove still will let you share your work with others saving them from having to REWRITE the same library. Also, you don't even need Native Code to benefit. Just the linking to local repos feature is worth using Grove. I started writing it because I really needed a better way to work on multiple repos at the same time.
In the last year, I've written about 30,000 lines of BACKEND Elm code (node based). Grove comes out of the difficulties that I experienced during that time. For example, the features like linking to local libraries is extremely useful. At times, I'll be modifying over 15 repos at the same time and it's a nightmare without linking and I got really tired copying code into `elm-stuff` or creating links manually. Also, there are some real difficult problems with Elm Packages that rely on npm packages. Doing that manually was not a pleasant option. I suspect the "pure elm packages that are missing" are based on your experience. I don't doubt you're not correct in that assessment. But I don't want to just have Elm in a browser. It's too amazing to limit. We're putting Elm in Electron, on the backend using node, in the phone using Cordova and in a week or so in a Raspberry Pi (personal project). Grove lets me do all of these things and share them with others.
[removed]
I do not deny that the current ecosystem could be improved. I do not deny the usefulness of a tool like `grove`, I even contemplated creating one myself. The place where I see a problem with this tool, as with `elm-github-install`, is in diverging too much from the core ideals of Elm. It opens an easy road to a lot of troubles. A beginner has no way of understanding what they get themselves into if they use this tool. Personally, I think that the authors of this tool should do a better job in making the risks explicit. What I think would be useful is a warning for beginners at the top of the Readme page and a link to another page that better explains the tradeoffs inherent in using this tool. It should at least be labeled experimental and for advanced use only. 
The inclination of the Elm community to cater to beginners and coddle them is both admirable and frustrating. Javascript doesn't care if you're a beginner and it's 100% dangerous. Most beginners are learning and using it and not Elm (hopefully that will change some day) and they are building things that people use without any coddling necessary. With such a beginner focus, it really alienates seasoned professionals (I've been programming longer than most Elm developers have been breathing). I understand the need to market the language to the world. But market it to the whole world not just beginners. Another frustration, while I'm on a roll, is this idea that Native is dangerous. Before most of us discovered Elm, we were all writing in Javascript. Yes, it's a terrible language, but nobody died. Sure, code crashed, but we fixed it and moved on. Now, with Elm, we act like a runtime error is the plague. Grove will let beginners benefit from packages with Native code that more experienced developers put out into the world. Will some of that code throw runtime errors. Yes, just like some Elm code that suffers from compiler bugs. Will the world keep spinning on it's axis. Yes.
I share the same frustrations, but jediknight has a point. Part of Elm marketing is "no runtime errors", if that is true, good or bad is another issue. So putting a warning that the tool can break Elm safety, doesn't break Elm marketing and also the world will keep spinning on it's axis. 
It works using `Dom.Scroll`. I added a message `NoOp (Result Dom.Error ())` that does nothing (just returns `(model, Cmd.none)`). In the places where I want to force a scroll to the bottom, I replaced `Cmd.none` with `Task.attempt NoOp (Dom.Scroll.toBottom "table-id")`.
So yeah, Evan and the core contributors are not competent enough to create a package ecosystem which allows installing and publishing native modules etc. Dude, there’s a reason to why it is this way. 
The support for private Gitlab repos is much welcome, thanks for your work.
Would you consider Haskell a beginners language? It doesn't allow you to execute native code without a port style wrapper, is it coddling beginners? Maybe there is something you don't know about the interactions between imperative languages and FP style languages that you aren't considering and there is a reason for these boundaries and barriers existing. If you want to have a "dangerous" language, why have types? I mean why bother with them, they just get in the way. Just write everything in assembly for maximum power. Native is extremely dangerous when you combine it with a language that assumes all code is stateless and immutable. When the runtime starts to make that assumption about your native JS and you've got a bug in your native code (which the nonexistent compiler for it didn't catch) then it is going to fail in spectacular and hard to debug ways. It's also dangerous because the language developers might drop this undocumented feature, in favour of a more convenient but still safe wrapper. With regards to runtime errors, if I can write a program where my compiler can guarantee it won't crash, this is a good thing. Having a program crash doesn't give me anymore power, it just makes me look like an idiot for writing shitty code. This isn't about coddling beginners, its about writing high level tools that behave correctly. Semantic versioning enforcement and omitting native code are two things that ensure this. Any seasoned programmer would have engaged with the existing package manager maintainer before beginning this endeavour, with his first point of action to try and integrate the features into the existing tool rather than fork it. 
That's not what I asked.
Do you believe this is an arbitrary policy or perhaps there where deep seated and rather complicated technical reasons behind it?
Good bye semantic versioning enforcement, great.
Wow this is snappy! Great work. Love the performance.
Open source includes the power to disagree with an entire reason explaining why something isn't some way or another. I understand the original reasons from Elm explaining why some packages cannot be shared but I also see how different perspectives of empowering the user at different risk levels make sense. I also share the feeling that Elm currently prioritizes for beginners and this is not something a beginner would feel the need to have. This tension is even though potentially awkward also positive in the sense that if a lot of people follow this line it opens and important conversation as to why there's a significant divergence in a part of the community. It's in any case a win for Elm because there's more people using the language!
Could try this: app.ports.scrollBody.subscribe(function() { window.requestAnimationFrame(() =&gt; { const body = document.getElementById("body") body.scrollTop = body.scrollHeight }) }) 
I would love for you to share your experiences with back end elm!
Source: https://github.com/Janiczek/dwarves I have always thought about how should one architect and implement the "multiple agents behaving based on their goals and world around them" part of Dwarf Fortress. This week, I decided to simply try! And voilá :) (There are bugs, like multiple resources on top of each other, dwarves eating when the resource underneath them got depleted, etc., but the meat of the project is there.) If anybody has tips for simplifying the codebase / making it better, I'm all ears!
Thanks! Snappiness is certainly something that we are striving for. Makes a big difference to the user experience.
elm-github-install (elm-install) already lets you reference any git server or local filesystem package.
Instructions to play? It seems simple but I did not understand
Right now there's no interactivity - it's "watch-only" :) In the spirit of Dwarf Fortress, buttons like "Build a chair" or "Fell a tree" could be added - but the player wouldn't have a say as to who would go do that task.
No Urist?
Grove does so much more than that, for example, it supports linking to local repos. Check out the readme to see the differences. One difference is that elm-github-install is written in Ruby and Grove is written in Elm. 
Wow, all responses here are pretty negative. I thought the elm community was supposed to be nice almost to the point of annoying political correctness. This project is awesome, keep up the good work. Having alternative ways of solving problems is a good thing. 
Thanks! It's pretty great how fast you can build stuff out in Elm + Haskell. Was dreading this project for a while(especially when I was a Django programmer :P) but turning out to be much easier to write, understand, &amp; refactor. I'll probably stick a staging site up soon so people can check out more than just the code...
I don't know why I struggled with this for half a day. It's so simple, after all. Anyway, big thanks to Ilias in #testing for helping me see the light.
Wow this is really great, well done!
I understand why people make tools like [elm-github-install](https://github.com/gdotdesign/elm-github-install). I use elm-github-install to install [elm-phoenix](https://github.com/saschatimme/elm-phoenix) which lets me talk to phoenix web sockets. This package has been waiting for official "approval" [for over a year](https://groups.google.com/forum/#!searchin/elm-dev/elm-phoenix%7Csort:relevance/elm-dev/MD5r5P3Tl7Q/nicA-0AdAgAJ). There might be ways to accomplish this with ports, but frankly if it weren't for that package, I wouldn't be using Elm. This Grove package looks like a lot of time and effort was put into it. The organization behind it has a lot of public Elm repos on GitHub that looks like they are serious about pushing the envelope in terms of applying Elm "outside of the box". Kudos to that. All that being said—and without knowing more about the history of this package—I think it would be nice if juggernauts like the person(s) behind Grove would communicate more with community leaders. Would it be so hard to jump on a plane to elm-conf, show this to Evan personally, before dumping it on Reddit? I believe there is room for both experimentation and stability in the community if the messaging is right.
 I'm not sure what to say other than Elm is a great language and works nicely under node. Check out our WebSocket, emailer, AWS SNS and Postgres Effects Managers and other elm stuff on Github under panosoft. Also check out our elm-node organization on GitHub. 
Of course it's not arbitrary, it's a well-thought-out policy to ensure elm-lang.org stuff doesn't have unnecessary dependencies or introduce runtime exceptions.
This goes for all things, really. Taking notes and repeating key concepts are the foundations of learning. Listening to conference talks, watching YouTube tutorials, and reading books is a waste of time if you are unable to practice the code along with it. 
Wait so what happens in elm when you compile a decoder that has insufficient parameters for the type constructor?
If you leave off one or more of the fields, you essentially end up with a curried constructor. Assuming the decoder has a type annotation, that would get you a type mismatch error. E.g. if i had this type with 2 fields type alias Person = { id : String , name : String } (the implicit constructer is `Person : String -&gt; String -&gt; Person`) and then say I wrote a decoder that only accounted for the first field, `id`: personDecoder : Decoder Person personDecoder = decode Person |&gt; required "id" string that would throw a compiler error — something like: The definition of `personDecoder` does not match its type annotation The type annotation for `personDecoder` says its a: Decoder (Person) But the definition is a: Decoder (String -&gt; Person)
&gt; If you want to have a "dangerous" language, why have types? So that you can avoid accidental dangers, and only take risks that you actually want to take? Elm's emphasis on type safety above other considerations is pretty unusual, even among statically typed languages for which safety is a big selling point. This is *not* to say I think Elm should turn around and try to be like other languages - it's different, and *that's the point of Elm*. But you can get a lot of benefit from a good type system without the all-or-nothing attitude. For comparison, Rust and C# have the `unsafe` keyword, OCaml lets you disable array bounds checking, Go has the `unsafe` package... And since you call out Haskell as an example... Haskell has `unsafePerformIO` and all manner of other footguns, and its `head` and `tail` both throw exceptions when given an empty list. It also has boatloads of compiler options and extensions, some of them pretty weird and, yes, dangerous. It's exceptions aren't even type safe themselves: [https://existentialtype.wordpress.com/2012/08/14/haskell-is-exceptionally-unsafe/](https://existentialtype.wordpress.com/2012/08/14/haskell-is-exceptionally-unsafe/). I'm not sure what you mean about Haskell not allowing native code - that's not something I'm used to hearing about outside languages primarily aimed at compiling to JS. &gt; Any seasoned programmer would have engaged with the existing package manager maintainer before beginning this endeavour, with his first point of action to try and integrate the features into the existing tool rather than fork it. Evan has made it abundantly clear that this isn't a direction he wants `elm-package` to go in and that such features will not be integrated. Nobody benefits from repeating that discussion. Evan's time and OP's time are both better spent building cool stuff for the Elm community.
Thanks for the reply, stuff this that is why I think elm is neat!
Wow, this is poetic. I ended up watching the last surviving dwarf for a while waiting for him to die from hunger but he never did. Apart from that, watching this thing made me feel like I've learned a lesson.
Not sure exactly what lesson. Feels like I need to meditate on this.
I didn't mean to make a negative statement. I should explain myself. Since you are competing with *elm-package* it would be useful for the community if you would make it clear that this package stands against what elm stands for. Or communicate in some way how should people treat this project. I find it damaging to name a list **Problems that Grove solves** and put **Native packages are forbidden** on top of that list. For the sake of honesty I think the readme should be mended to make it clear it is diverging from elm as an ecosystem and treats decisions considered good in the elm community as "problems" in your projects. Reading the readme gives the impression you are solving issues that elm-package is slow to address, not that elm-package is actually fighting for them as features :). In any case, I think everyone here appreciates the technical aspect of your project!
Are there streams of the elm-conf going on this weekend? And if so, where can I watch them live or afterwards?
The Elm community seems to be pretty hostile if you go against the grain like this package seems to. They are very opinionated and very aggressive about those opinions.
&gt; The Elm community seems to be pretty hostile if you go against the grain like this package seems to. They are very opinionated and very aggressive about those opinions. Like I said in response to another comment - annoying political correctness is another facet of this "aggressiveness" regarding their attitudes.
[removed]
&gt; Wow, all responses here are pretty negative. Well, at present the project is setting Elm beginners up for some really unpleasant surprises, and many of us feel protective towards beginners. :) To be clear: 1. There are certain implementation details of Elm that are walled off behind a sign saying "Never ever depend on these, because using them can result in horrific bugs, their APIs and implementations will change drastically without warning, and they may disappear from the language at any moment." 2. Beginners normally can't get burned by these because they are not exposed, by design, anywhere in the Elm package ecosystem. They're just implementation details. 3. This tool directly exposes them, without warning users about the risks involved. Effect managers might get removed from the language, with no replacement. Native might get rolled into binaries and no longer accessible from packages. There is no limit to the amount of breaking changes that might happen to these implementation details, because they are implementation details that are *explicitly* unsupported. Beginners get no indication from the README that any of these risks are there. When they get burned, they won't think "why didn't Grove warn me?" they'll think "I had a bad experience with Elm," and it's understandable why that would be frustrating for Elm community members.
I'm sorry about all the flack you're getting from people, thanks for creating this, I think that I'll maybe help us have private packages. I'm sorry your getting such a angry response. I think this might be a great bridge till Elm package can support private packages. 
&gt; Another frustration, while I'm on a roll, is this idea that Native is dangerous. Before most of us discovered Elm, we were all writing in Javascript. Yes, it's a terrible language, but nobody died. Sure, code crashed, but we fixed it and moved on. **Now, with Elm, we act like a runtime error is the plague.** Yeah, we do. This is the ecosystem we want to build, and we're not shy about it. You are free to believe that Elm should be more like JavaScript, but if I were you I'd expect nonstop disagreement from the Elm community at large. :) There are other great language communities that have different design goals. For example, [Reason](https://reasonml.github.io/) is designed to embrace the JS ecosystem, including seamless (arbitrary JS) interop and `npm` support. The Reason community is full of good people pushing boundaries in exciting ways. If you want an ML family language with those characteristics, why not use the right language for the job?
Those are valid concerns, and they should probably add some disclaimers. However when I commented a lot of comments were just negative without mentioning any valid concerns. That made me a little sad.
I appreciate you pointing out risks beyond potential loss of type safety. It makes a more compelling case than I'd seen before, and has shifted my opinion noticeably. That said, I don't expect anyone will mistake Grove for the official package manager, given that its README clearly states that it's not, and none of the official Elm documentation, guides, etc. even mention it. Give beginners a little credit.
I'm still hoping this will change as the community grows and attracts different sorts of people. But yeah, if I were working on a project that goes against the grain like this, I'd want to talk with community members who are actually interested in the project and think it could be worthwhile - not current leaders, whose disapproval is a foregone conclusion.
Apparently the creators did jump on a plane to elm-conf; the next day, a few people mentioned to me that they'd talked to them before flying back.
It's frustrating to me when our desire to avoid repeating past mistakes is framed as hostility to innovation. It has to be okay for us to say "we know where this road leads because either we or other communities have gone down it, and we don't want to suffer the same fate." For example, Go allowed installs from GitHub. I've talked to people who use Elm and have used Go extensively, and they say the Go folks wish they could go back and undo that feature because it hasn't gone well, but now it's too late because so much of the ecosystem now relies on it. How can we say "let's not make the same mistake" in a way where it doesn't come across as hostility to innovation?
Hmm. I think my disagreement might be in how much distinction we see between the official ecosystem (the language, platform, official package manager, etc) and the stuff the rest of the community builds on their own initiative. I am in favor of being very cautious about what's officially supported, and you've convinced me that elm-package shouldn't allow unsafe packages. But "we don't want to support that" is very far from "we don't want you to build that." It's the second one that I'm uncomfortable with.
Anytime :D
I have run into this problem before but did not find a solution. One of the possible solutions would be to add a message filter option to the message history window, like Redux dev tools. Should only be a couple of lines of work if the debugger is also in Elm.
Does the debugger take pull requests? that might be an easy win.
A tale as old as time, the classic example is not doing the problem sets in a math class. Sitting in lecture isn't going to do it.
Plenty of people have experimented with backend elm, custom native modules, etc. Not many people have released these to public repos, but those that have often put EXPERIMENTAL DO NOT USE IN PRODUCTION warnings on them. None of this seems problematic at all, in fact it's likely healthy, good for people to learn the internals of their tools and all that. At the very least harmless. But this tool (a) doesn't put any such warning up, in fact makes a point of saying it is used in and was developed for apps in production, and (b) enables others to use it to bypass community standards. It's hard not to see *it* as hostile and foolish, and also stifling innovation. What happens when Native (soon to be Kernel) needs to drastically change? When something besides effect modules proves more useful? More people depending on this means it's harder to change and forks are more likely. Elm is trying to not repeat the mistakes of other language communities, and part of that is discouraging bad user habits. Not experimentation. Sorry to be so preachy about it but as an elm user I feel very strongly the principals of the language must be protected in public libraries and tools.
It seems like languages like PureScript are much more aligned with your goals. Why not use a language like that? It seems like it'd be a lot less work to get what you want.
Rust allows you to include git dependancies - it just doesn't allow you to publish packages that use those to the official registry. This is super useful for production use cases and for initial prototyping. You can have your cake and eat it too.
Enter [`jinjor/elm-time-travel`](http://package.elm-lang.org/packages/jinjor/elm-time-travel/latest). It allows you to filter out some `Msg`s from the log and leave others. (The drag'n'drop example is great for showing that.) The disadvantage is that you have to replace `Html.program` with `TimeTravel.program` -- it's not just changing a compilator flag.
Can someone explain the benefit of testing decoders? Unless they are super complex I don’t see any benefit, maybe I’m missing something?
Political correctness would be the opposite of what you describe. It would be “it’s fine, all ideas are valuable and all innovations are good”, while as I see in this thread, the majority says the opposite. Let’s at least not call it some innapropriate, emotionally charged term.
This looks promising, I'll have to try it out :)
My tests are a check on the structure—often nested—and that the key names are correct and map to the right record attributes.
Lol, totally heard the first part of that sentence I'm missies Pots voice. 
I agree that there are alternate designs (e.g. being able to include packages from the local filesystem, which for my money seems the most useful with the least downside), but this project is very directly doing the thing that the Go community already tried and regretted. Not every new thing that comes out is progress, and we have to accept that reality. Some things are steps in the wrong direction, and people who point that out aren't against innovation, they're *for* moving in the right direction.
&gt; But "we don't want to support that" is very far from "we don't want you to build that." As someone who has spent a lot of time saying "I know you read on this blog post that this would be a good idea, but the approach the official Guide recommends doesn't have the problem you're running into," I'm keenly aware of how quickly beginners go beyond what's "official." The outcomes may may not be as far apart as they look on paper. ;)
Do you reach out to those blog post authors to point out important deviations from the way the guide does things? As someone who frequently blogs about Elm, if I'm perpetuating an anti-pattern then I'd want to know what it is and why it's specifically an anti-pattern.
You may have found these already but it has been discussed in: https://github.com/elm-lang/virtual-dom/issues/79 https://github.com/elm-lang/virtual-dom/pull/77 And progress tracked in: https://github.com/elm-lang/virtual-dom/issues/98
This seems like a waste to me. Instead of making sure the code is correct once when written/generated you run a fuzzer over and over and over and over. It slows your tests and wastes CO2. 
That's a good point. I could definitely be more proactive about reaching out to authors than I have been in the past!
&gt; I welcome all constructive comments I don't want to join the debate but I do want to point out that you listed many benefits assuming native packages would be allowed, but haven't made concessions on what realistically would be the negative impacts to beginners, seniors, the community, and other aspects. I'm not going to speculate on what those negative impacts would be, but I'd encourage you to level out the argument by trying to come up with any caveats and trade-offs.
Thanks for the feedback. I definitely see your point. Since decoders mapping to records are all about order, it is important to me to have a check especially since my records are growing/changing. For decoders specifically, the fuzzer is acting more as a factory than anything. It would seem more rational to have an actual factory instead of a fuzzer—do you know of any?—but in terms of it being slow, that hasn't been the case for me. I have around 250 fuzz tests that run in well under 2 seconds.
IMHO I don't think Native packages need to be in the official Elm package repos, as long as installing deps from *other* external/local repos works just as flawlessly smoothly and transparently (without needing extra/alternative/3rd-party package managers). However I found the documentation on writing Native and Effects Managers *very* thin, would be nice if these "superhero" topics became first-class citizens in terms of docs. Well, it's FOSS and I admit I too haven't taken the time to fill the gaps and contribute. Sure I can hack my way into anything without much handholding on-a-long-enough-timeline, but everyone's gonna pick their battles. Will say that *for the time being*, having compared Elm's "Native &amp; Effects-Managers &amp; Ports" story with PureScripts "FFI" philosophy, I've opted for the latter for at least another year or two I guess. Sure, the former is "safer / more fool-proof / less shooting-in-the-foot", *but* FFI isn't something you write every day and change every day and keep expanding continuously. When you get down to it, you ensure you got everything right, you double-check your JS+PS, you test, and it's done. Whenever so rarely the JS side gets an update, you know exactly what to change and what to test. Don't need all the safety gear and it really gets in the way for me mentally. Every somewhat seasoned programmer gets the FFI idea instinctively, "declare stuff `external` incl signatures, excl implementation; make sure the linker finds it". That's just *straightforward*. I get that Elm's *long-term* goals align very well with what I think they should go for --- but in the *meantime*, I wanna be productive today =)
I like to create pipelines by extrapolating things out into functions. For your case, something like this: update : Msg -&gt; Model -&gt; ( Model, Cmd Msg ) update msg model = case msg of ShowModal value -&gt; model |&gt; setModalValue value |&gt; showModal ! [] setModalValue : String -&gt; Model -&gt; Model setModalValue value model = { model | modalValue = value } showModal : Model -&gt; Model showModal model = { model | isModalVisible = True } 
&gt; I also noticed that the upvotes on the posting were 90%. While I don't believe that the majority is always right, it does speak volumes about the feeling in the community. Clearly, native code is an issue for many of us. The Reddit community is not reflective of the Elm community at large. The Slack channels are the main location of the Elm community, whereas the Reddit has more people from other communities. Native is not something that comes up there -- though it does come up. &gt; Typically, Front End developers are more junior than Back End developers. So it's not surprising that much of Richard's focus is on the beginner/junior programmers. And I respect his desire to protect them. But as a very non-junior programmer, a culture of beginners is alienating to the seasoned professionals who love Elm. This is not a fair assessment and I'm not sure what you're basing that on. Frontend developers are just frontend developers. You do not "graduate" from being a frontend developer to become a backend developer. There is no focus on junior programmers in the Elm community. There is a focus on providing great tooling to frontend developers that did not exist previously. &gt; For any language to thrive, it needs senior/experienced developers to help build the ecosystem that the rest of us will use. An environment that is solely focused on protecting the beginner/junior developer shackles the very people who you want to embrace Elm and create the advanced libraries and tools that the rest of the community will benefit from. A false premise: Elm has protection for _all_ programmers regardless of experience. &gt; At this year's Elm Conference, everyone who demonstrated a project that they had worked on, mentioned that they had written some Javascript code to accomplish their objectives. Some Javascript code is not the same as Native code. While many people I have spoken to have needed Native code to do something in production, they have needed it less and less with the more recent releases. &gt; I would posit that any serious application developed in Elm will require some Javascript code in it. Effects Managers usually require Javascript code. Elm's Port mechanism is to support Javascript interop. Ports are not the same as Native code. It's important to not group them together: ports are a supported, documented way for an Elm program to interact with Javascript. Native is not. &gt;Now, I hate Javascript as much as the next guy, but the fact is, at least at this point, Javascript is an integral part of Elm. And if done properly, as Evan has done in the Elm libraries, Javascript can be written to be safe. Runtime errors still exist. Writing perfect JS that does not crash is _hard_ and has taken years of bug reports to perfect. &gt; First, it alienates senior developers by effectively telling them that they cannot be trusted. In fact, the only developer who can be trusted to build safe Native libraries is Evan. I really don't like the lines you draw of implying that senior developers can't mess things up. I've yet to meet a single senior dev who hasn't introduced a bug into a code base. A runtime error in Elm has a big impact: it will crash your entire application and prevent it from working. Elm works by trusting the native code you wrote lines up with the types you tell Elm. If those mismatch, runtime error. Forgot to handle an edge case, runtime error. Didn't cover all browsers, runtime error. This is not the Elm experience. The Elm experience is about having a compiler that can verify and ensure what you wrote will work, no questions asked. Opening this up changes the fundamental way in which Elm works, and completely changes the experience that people have writing and using Elm. The thing is, there _are_ languages out there that already give you that: Purescript, Typescript, Flow. They don't have the same goals and experience as Elm, and that's awesome. You have to accept that by using Elm in a way that is not supported nor promoted by Elm itself, you are going to be running into walls like these. That's the choice you made by adopting Elm on the backend. Everyone else is writing Elm on the frontend, as it was _designed_ to do. The problems you face are not the problems of the community at large. Languages like PS and TS _are_ designed to work on the backend and the frontend. Elm is not. It is only designed to target the frontend right now. That being said, I agree, overall, that the Elm _community_ does need a way to share native code or unpublishable packages. Using Elm in production often requires some fix, whether it be local storage, tricks for handling for text editors, or alert handling. While ports can solve some of these problems, there are edge cases that block people and I'm a very big fan of _sensible_ pragmatism. But it should _never_ be the first resort, and I will happily help people to avoid needing native at all costs. In most cases, it's not needed at all. Packages need to be shared between internal projects, without being public. Therefore, I welcome the addition of an alternative package manager like Grove. I don't believe you should be presenting it as suitable for those who don't need it, however. Many people do not need native nor private packages. It would be great if you could amend the readme to fully cover all the downsides that Grove opens up to the user: runtime errors, type mismatch, lack of semantic versioning, etc.
Hey. First off, I want to say thanks for sharing your opinion here. One of the things I love about this community is our ability to hold constructive conversations in public, transparent spaces like these. I agree with everything that /u/eeue56 said in his comment, so I won't rehash those point. But I do want to comment on the following: &gt; In fact, the only developer who can be trusted to build safe Native libraries is Evan. I don't think you intended it, but this sentence reads to me as resentful. I want to dispel the illusion that some developers are more trusted than others. As has already been said, *no* developers can be trusted, no matter how experienced they are. Human error is universal. Elm helps us fix that. Native modules are restricted to core libraries not because Evan wrote them, but because changes to core are considered holistically and rolled out slowly. You've watched Evan's keynotes, so you know his design philosophy: consider everything together, collect opinions, prioritize and release slowly. It's especially important that this strategy is applied to native modules. It would be wonderful if there were a way to allow them to be published AND to enforce this philosophy, but I don't think it's feasible. 
You don't. Messages don't capture what you want to happen, they capture an event. If you need to peices of logic to happen in response to one event then you have both those things happen in the update due to the single message.
You're right I did not mean it resentfully.
Might be a silly comparison, but this reminds the crisis in the gaming industry in the 80's, when the abundance of bad games in the market eroded customer confidence - making the whole industry suffer. One of the ways to tackle the crisis was the "Nintendo Seal of Quality", that gave credibility to titles with proper QA. I believe that this approach can be replicated: if a package has 100% source code in Elm, give it a nice "No Runtime Exceptions" ribbon / seal. Does it contain native code? Then display a red banner with a warning sign and a message "Proceed with caution: this package contains native code, voiding Elm's guaranties of no runtime exceptions and semantic versioning. Only use it if you know what you are doing! If not, ask for advice in our Slack channel. You can learn more about the dangers of native code in this link". I believe that a good part of the frustration in this issue comes from being unable to share work in a "official" way.
Glad to hear it! Words are hard and Internet words are harder 😁
Thanks. So I need to update my ModalMsg to take two arguments instead of one then, I think. I think that'll do it, just need to puzzle through the elm-bootstrap stuff and understand the Modal.config signature and how to tweak their sample code to construct a ModalMsg w/ two args in the middle of all the `|&gt;`'s. 
I'm struggling with how modify the message when it needs to be passed into the elm-bootstrap passage I'm using. In their example code, http://elm-bootstrap.info/modal, they define `ModalMsg` as type Msg = ModalMsg Modal.State Then their `Modal.config` is expected to be passed a `ModalMsg` by signature config : (State -&gt; msg) -&gt; Config msg So when I first started thinking about your response, I thought I would just extend `ModalMsg` to type Msg = ModalMsg Modal.State String But that breaks their API. Can you suggest a way around this? Do I need to setup something like the following? type Msg = ModalMsg Modal.State | ShowModal String ModalMsg update : Msg -&gt; Model -&gt; ( Model, Cmd Msg ) update msg model = case msg of ShowModal value msg -&gt; model |&gt; setModalValue value |&gt; update msg model ModalMsg state ( { model | modelState = state }, Cmd.none )
I figured out that I could curry the String in so that ModalMsg still evaluates to (State -&gt; msg) when passed to config. Seems a little weird to be passing an empty string sometimes, so I probably don't have it right, but I do have it working.
A beginner experiments, runs into problems, asks for help, and comes away knowing the official approach *and understanding why it's better*, because they've seen what goes wrong without it. That sounds like success to me, not a disaster to be averted, as long as it stays easy for beginners to get that kind of help. (And if too large a fraction of Elm-related blog posts are putting forth bad ideas, maybe what we need is more posts putting forth good ones?) I feel like most of what I've learned in programming has come through failed experiments, and those failures were often how I reached a deeper understanding of what I was doing. Though I can't prove it's not just some kind of hazing mentality on my part.
Isn't inclusion in `elm-package` exactly that thing you just described?
"The package manager" doesn't because "the package manager" is `elm-package`. What an unofficial alternative does or does not allow shouldn't impact that.
Dom.Scroll.toTop id is not working for my site. I update my model, adding new content, and issue a Dom.Scroll.toTop command to an id in the new content. I get back a result indicating success but the browser does not scroll to the selected id.
2 seconds is infinitely longer than zero. And how often do those tests run? If it was generated it would be 0 times 0. Now it’s 2 times what? Thousands? Tens of thousands over time?
Do you know of a good factory library for Elm? Do you have anything helpful to add here? Or just angry math?
It’s trivial to write a code generator. And this is in fact what we do at work and an early variant of that is open source on my private github https://github.com/boxed/elm-cog My lib isn’t terribly good or interesting. You should probably write your own because it’s simple and it will suite your use case better. Math that doesn’t support your current position isn’t “angry” btw :P Reality isn’t angry or sad or nice or cruel, it just is. 
Ok, sorry for the retort—I felt like I was clear earlier about knowing that the fuzzer is less than ideal for these tests; and that you were trolling me. elm-cog looks cool — thanks for making it public — although for this particular case I think I'll try doing something in pure Elm. In lieu of a factory library, I'm currently doing `fuzzWith { runs = 1 }` in places where actual fuzzing doesn't make sense. Again, not ideal.
We’ve found that using our back end language for code generation has other knock on positive effects so I’d recommend that. It makes it trivial to keep the back end and front end in sync for example: just generate code for the front end based on the back end code. This at least works nice for Python when done in a declarative style which we do. 
Right, definitely makes sense. I just read your [blog post](https://medium.com/@boxed/code-generation-is-terrible-and-great-b07ce54d382a) on this as well and it looks like a win for sure. (Wouldn't it be cool if Elm got macros?) I'm using Elixir currently on the backend—certainly possible there as well. I like the idea of keeping things in sync although my API and models/decoders in Elm are a little tricky especially in terms of relationships and data that is not always included (think GraphQL). At any rate, it does sound like code generation and a language like Elm would make a good team. Thanks again for mentioning.
I agree macros would be nice. But for our cases where the backend is a different language I think pure code generation might actually be better, if it’s in the back end language. Well... or if one generates both to Elm and the backend language I guess. 
&gt; There is no focus on junior programmers in the Elm community. Are you kidding? A lot of design decisions have been made *precisely* with the junior programmer in mind. &gt; I really don't like the lines you draw of implying that senior developers can't mess things up. I've yet to meet a single senior dev who hasn't introduced a bug into a code base. It's not the point he is making though.
Are the talks available somewhere online?
&gt; Are you kidding? A lot of design decisions have been made precisely with the junior programmer in mind. No, I am not kidding. I'm fairly aware of the design decisions, considering I'm often involved in them in some manner. The focus is making _Elm as a language_ easy to understand. This applies globally, to both senior and junior developers. There is no focus on junior developers. You are not a junior developer if you haven't used a pure, immutable language with types before. There are millions of senior developers who have not ventured into ML-based languages before. Elm is designed to be a _well thought out_ language. Not a _junior first_ language. 
Fair enough, not the junior programmer; the *beginner* then.
Painful experience with Haskell community ? 
I agree with you. I only dabble in Elm from time to time but I started a new project and chose React over Elm mostly because I wanted to use WebStorage and indexeddb. Elm doesn't have any libraries that supported this. I wanted to get my project done not research the best way to use ports to accomplish my goal of communicating with indexeddb so I ended up just using React where I can import anything. I understand a community written native library may not be as well done and behaved but I feel like I should get an option to accept that risk and use one. I think the current policy could also be slowing research and development of the best way to do these things. Many times third party libraries have been used as the basis for core design. For instance when Java rewrote their date library they heavily borrowed from the work of Joda time. Is Elm missing out on that community driven development by making it a pain to share native?
Yes and no. Currently, packages that do not meet the requirements for publishing and left out in the wild. Novice users can and do enter into shady alleys when dealing with concepts they do not understand (when I was learning I nearly downloaded a modified version of Elm's compiler in order to chain some Ports calls). If dealing with JS is necessary, then it is better to do it at home - where you can ensure that the proper warnings have been given. Also, being unable to split my work into private packages and share it with my team adds to the frustration ("sorry, the repo url does not contain github.com, so elm-make won't run").
My 0.02 ... I'm a senior dev that is working for a place with about 15k loc of Elm and we've done everything we needed with ports and mostly love it. The guarantees we get from isolating Elm and JS is heavenly. Now when there is a problem we only really have to worry about &lt;200 loc of JS or a small portion of Elm code. I realize that our situation may not be the same as everyone else's, but I love not having native code because then I don't have to worry that someone used it because they could figure something out. Just my anecdotal opinion ;)
I appreciate your posting about a topic you feel strongly about in a civil way. I know it's not always easy, so thank you for that! &gt; Imagine I develop my own library for accessing the browser's local storage. I suspect that I'm not the only one who wants to do this. But there is no way for me to share what I've done. We can still share using the Internet. If I publish my JS interop code as a Gist and link people to it, saying "hey here's the workaround I used; you can copy/paste what I did and use it too," it feels like a hack. **Good!** If there is one thing I have learned in my time as a programmer, it is that **hacks should feel like hacks.** They should come with warning signs, the bigger the better. There *should be friction* to implementing them, so our lizard brains don't take shortcuts our conscious brains regret later. That way, if we really need to use something risky, we'll put in the extra effort to do it that way only when there really is no alternative. I agree with /u/eeue56 that advanced users like us benefit greatly from keeping JavaScript as far away from our Elm code as possible. It's not just beginners. If my project needs risky hacks to unblock progress, I'm better off if they are sectioned off and clearly marked in my code; that way, if a crazy thing happens, I don't have to scour my third-party dependencies for potential culprits. It's a huge benefit to anyone, no matter how much Elm programming they've done. In [this post](https://www.reddit.com/r/elm/comments/6saztw/when_will_elm_grow_up/dlbfyjo/) you said: &gt; I'd hate to see Elm a decade down the road full of crap like JavaScript. Whether or not you want it to be true, Grove pushes Elm down that road. You've talked about some of the things you hope Grove will be used for, so let me point out some other use cases it facilitates: * Wrap React.js in an Elm API, because someone's boss said "you can use Elm, but only if you can still directly access the entire React component ecosystem we were using before" and that team thought "sounds like a plan." They couldn't publish the results of this effort on `elm-package` because it's a thin layer of Elm on top of several thousand lines of JavaScript, so they put it on Grove as "`elm-react`: everything you love about Elm and React, all in one great library!" Now we have competing virtual DOM strategies in Elm, a language where the selling point "there's one way to do it, and all the libraries work really well with each other because they build on a common foundation" used to be true. Grove directly facilitates this happening. * `elm-redux` is up next, because React isn't designed for the Elm Architecture and that team's `elm-react` code base is not quite gelling with Elm the way they'd hoped. Then of course `elm-redux-sagas`, for familiarity with the old `redux-sagas` they had in their JS code base, which they didn't want to have to change. Does that sound far-fetched? Let me introduce you to [purescript-redux-saga](https://pursuit.purescript.org/packages/purescript-redux-saga/0.3.1). Now we have competing state management strategies to argue about, and who knows how long before `elm-mobx`, `elm-cyclejs`, and `elm-throwback-to-signals` enter the mix along with their vocal proponents. Grove directly facilitates this happening as well. * Promises as an alternative to Tasks, for familiarity and compatibility with existing JavaScript promise-based libraries. Don't want to believe this could happen? Take a look at [purescript-promises](https://pursuit.purescript.org/packages/purescript-promises/1.0.0). Again, tools like Grove very directly push Elm in this direction. I think the best thing anyone who would "hate to see Elm a decade down the road full of crap like JavaScript" could do to prevent that from happening would be to push back hard against promoting Grove as the "Advanced Package Manager for Elm." [Evan's view of how to set the Elm ecosystem up for long-term success](https://groups.google.com/forum/#!topic/elm-dev/bAHD_8PbgKE) is that it should be all about Elm code built on more Elm code, with the bare minimum of JavaScript only at the very lowest level of the kernel. That this will undoubtedly slow down the development of the ecosystem, but that such a slowdown *is a price well worth paying* for a great ecosystem. The fact that you think "Elm is the best language I've programmed with in my 36 years of software development" yet reject one of the most crucial decisions its creator ever made to make it so nice, is hard for me to wrap my head around. I believe you when you say that you have thought long and hard about this, but I hope you can understand why I see this path as a net negative for Elm.
I agree and continue to hope for something like rust's unsafe block coupled with a decoder for some sort of safe, sanctioned ffi.
I think you have a bad approach, and are threatening to break things for people that rely on Elm's stable core. It would be better to propose your ideas on elm-dev - there is very clear guidelines there on how to go about getting native code in the Elm kernel - it is not right to ignore those guidelines that are requested in a respectful manner. I use elm-github-install for testing (to pick up local changes without a package publish), and also for kernel hacking (to substitute my own hacked version of say the virtual-dom). But for anything I publish I respect the ideas behind a more carefully evolving and small and stable native core. The right way to go about introducing more native code into Elm, is to discuss it on elm-dev. Propose what you want to go, do the research and write up as a white paper, get people to buy into your idea, or understand why they do not make an acceptable API for something in the Elm kernel. It is true that Elm kernel moves too slowly for people. It is also true that not many people are prepared to engage with the official route as it is a lot of work. But I think more people should try it. The official package repository is a very strong offering at the moment. Perhaps Grove will just be a sideshow. Interesting to see where this goes though; it does hit at the underlying cathedral/bazaar dilemma.
I see you saw the security of classic gaming consoles talk as well 😀 Were you at strangeloop this year or did you watch online? 
I don't think you understand what I meant here - the Elm slack channel has a bot that pounces on usage of the word guys with a message "terms like guys can make some people feel excluded". That is the aggressive political correctness we mean.
I love Elm precisely because it enforces me to stay away from native Javascript code as much as possible. And when I write or use native code, I'm REALLY aware of it. That's why my Elm apps have no runtime errors, and I'd like them to stay that way.
over and over again: "but how then do side effects work? how does one write to local storage or do a http request? how can you say all is pure but still have effects?" I get the impression after presenting elm to someone new to functional programming that they suddenly feel doubt over some unspoken hidden magic somewhere since at first sight one cannot have both purity and effects.
&gt; Runtime errors still exist. Writing perfect JS that does not crash is hard and has taken years of bug reports to perfect. This is true but also not always relevant. In some cases, the needed JS Kernel code is so small that one can easily cover all the ways it could break. A few iterations from the original author and the library is ready for analysis by a senior Elm developer like yourself. A few more iterations with the help of the senior developer and the library would be as solid as the rest of the Kernel code on `elm-lang`. The JS code is simply too small to break. This is the case for LocalStorage, it is the case for FileReader. In both cases there is about a page of JS code. The main problem is that there is no way to extend the ecosystem to allow for this new needed functionality. There is no intermediary way between the official libraries and the chaos of a random github repository. If I need a FileReader I'm left with betting on the first google search result which in this case is a good bet but in other cases it might not be. My preferred way is for us to have a place where one could find libraries that might not be as rock solid as the rest of the core but still solid enough to be useful. I guess [@elm-explorations](https://groups.google.com/forum/#!topic/elm-dev/bAHD_8PbgKE) that Evan talks about could be a place like this if Evan would be OK to trust a small team with filtering and accepting projects in this space rather than just doing it himself. Instead of having `Random Dev -&gt; Evan -&gt; Accepted Library` we would have `Random Dev -&gt; Senior Elm Dev Team -&gt; Accepted Library -&gt; Evan -&gt; Official Library`. This would mean that a group of senior Elm developers could have between them enough knowledge to detect a reasonable proposal and reasonable proposal would have a training ground for its API to be shaped into a solid reliable form worthy of the core. 
Not the beginner either. Experts appreciate having very strong type safety and pure functions as much as if not more than beginners. I'm an expert because I've been programming for 30 years. I would choose what Elm offers over most other languages because it makes it easier for me to think about large code bases and worry less about errors.
I agree with the title of this post: "Elm needs a better Native Code Policy". If Elm is going to cover the whole of the Html5 API, there is a lot of work to do. Native code needs to be opened up a little more to let all the enthusiastic and experienced developers who use Elm contribute to it. There is an official route to doing this, which is to discuss on elm-dev, to be prepared to work hard and write up a white paper comparing a proposed API with other approaches and so on. The trouble is, I don't see anyone doing that very much. What is needed is a streamlined process for contributors to native to work with, that they feel confident about being able to get their contributions into the kernel. This process would need some quality gateways to ensure that contributed code is well tested, runs on all browsers, doesn't cause runtimes and so on. That is going to take up a lot of someone time to do, so it would need to be shaped in such a way as to minimize the burden on any one individual; to reduce the overhead and increase the transparency. Grove and elm-github-install could help with this as they will let us share native packages that are not white listed. Once those packages are stable enough and have great APIs, there should be a way for them to get into the kernel. If Elm doesn't learn to tap into this enthusiasm and energy then progress towards complete coverage of Html5 will be too slow for many.
One of the best talks I've seen around this question is [Boundaries by Gary Bernhardt](https://www.destroyallsoftware.com/talks/boundaries). It explains this idea of having a purely functional core as the main part of your app with a very thin imperative (impure) shell that executes the effects. This is what we have right now in Elm, a pure core expressed in Elm with the runtime acting as the imperative, impure shell that executes the effects in a controlled and managed manner. 
I agree very much with this. My point was that a lot of Elm design decisions (mostly the choice of *not* including features, but also the inability to share "native" code) have been made with the beginner in FP in mind, and it has been said publicly numerous times. I like Elm but I don't use it because it tries to shelter me. OP's complaint is similar. Elm limits you much more that with just static typing and pure functions. To this day you still cannot program a piece of software of arbitrary complexity with Elm. It is too strong of a limitation. The fallback then is Javascript. But apparently, by OP's remark, sharing Javascript code has its own hurdles. Although I recognise the value of those limitations I also acknowledged that it will frustrate the people that can be trusted with their skills; call them senior developper if you want.
Is the editor built with Elm or with JS? It is very nice!
What are the top left/right links on a note? (Left has a "j" for me and right has "new") They change colors of the note but I'm not sure what they do.
Thanks. It's almost entirely built in Elm, including the conflict-free replication data type that is used for the real-time synchronization. Some parts are in JS due to missing web APIs, and there is also one part that is in JS for performance reasons.
To the left, you see the initials of the author of the section, and to the right, you can see when things were written. Clicking on the author, it will highlight all text by that author. Clicking on the timestamp will show a diff of what has changed since then. The UX and onboarding is very much work in progress, so your feedback is very useful.
“Don’t you have to write a lot of boilerplate?”
I wish the answer wasn’t “yes, a lot”!
Isn't everything always coupled to everything? The common answers seems to be: "Don't worry about it, the compiler will help you touch all your code until it type checks again" which doesn't seem adequate to me.
Working on a showcase for [elm-json-schema](https://github.com/1602/elm-json-schema): json-editor ([source](https://github.com/1602/json-editor), [demo](https://1602.github.io/json-editor/)), if you want to try it out you can drop this link onto the webpage: [json-schema](https://raw.githubusercontent.com/json-schema-org/json-schema-spec/master/schema.json) I want to tidy up editing experience: make it more obvious that user can click on `}` to add new property, add autocomplete, advanced validation, fallback to editing nodes as plain text.
I'm refactoring my backend from websockets/Elixir to Firebase. 
First, I want to thank you for the time and effort you went through thinking this out and offering a thoughtful counterpoint, not just hating. I think pretty much everyone in the community recognizes that both sides of this equation have pros &amp; cons. I would point out that in addition to safety, Evan emphasizes over and over again, that taking our time leads to rethinking APIs and coming up with a better way to do things. That’s a big part of what’s great about Elm. That said, the slow pace of progress at wrapping the entire web API is frustrating to everyone. Centralized control by someone as thoughtful as Evan leads to a high quality API and codebase...but wrapping the entirety of the web api is going to take more than one person. Sigh. I think something like grove could be a nice approach. Elm-package could offer a higher gauruntee of safety, while grove could offer a little more risk, for more flexibilty. Perhaps there could even be a middle ground classification—packages that include native code, but which has been vetted by some central authority as reasonably safe, but which isn’t guaranteed not be replaced by a better, core api someday. Expanding the central control over the language could also be helpful. There are some very smart and thoughtful people in this community. Perhaps some could take on API design for some of the non-wrapped parts of the web API, with mentoring and consultation from Evan. Although that’s now asking him for a lot of work. It’s definitely a challenge. On the one hand, we definitely don’t want Elm to become the Wild West. On the other, I think the amount of use and the size of the community is demanding faster progress on enabling the language to do more things easily and well. What’s important is keeping it high quality.
I wrote up some docs on [breaking import cycles](https://github.com/elm-lang/elm-compiler/blob/dev/hints/import-cycles.md) here that may also be useful. The plan is for the compiler to point you to this document from the error message for import cycles, so if there are any questions you think it should address more directly, please let me know!
I appreciate you taking the time to talk about these things. I've read and reread your comment multiple times and thought about it for a good part of a day before responding because I wasn't sure how I felt about it. The argument that Grove is damaging to Elm bothered me the most not just because I disagree with it but because that's the last thing I would want to do (more on this later). I think we have philosophical differences that can be summed up in two words, "Power" and "Protection". These are opposite poles of the same spectrum. Lean too far one way or another on this spectrum and you risk undermining the larger goals. It's clear that I'm favoring the "Power" side and you the "Protection" side. Whether either of us leaning to far toward our favorite pole or not, is debatable, but I think we can both agree that we'd love to have our cake and eat it too. Unfortunately, this is difficult if not impossible by definition. So, the best we can hope for is a balance but that doesn't solve these differences. It only means we're willing to land somewhere in the middle still compromising the other for our favorite. I'd like to argue why I choose "Power". I suspect my personal history is to blame for this bent having started very close to the metal in the early days of microprocessor programming in Assembly Language which is the ultimate power. But I also think it has to do with my experience of being asked to solve business and engineering problems over the last 3 decades and that software technology has always afforded me the power to solve those problems. Elm is the first technology I've encountered where the community is actively discouraging people from expanding the reach of the language, e.g. do not run it on the backend, avoid node, don't write your own Effects Managers or Native Code, etc. This would be fine, if it offered alternatives. But all we get are promise of future solutions. It's not that I don't trust or believe that those making these promises don't mean well or won't deliver on them. It's just I have problems to solve and businesses cannot wait on vague promises. To restrict Elm to just the front-end and users to only sanctioned advanced libraries makes Elm far less powerful which runs counter to you larger goal for Elm, viz. having Elm go mainstream. The reason Javascript took over the world was its ubiquity. Note here, I'm not suggesting that Elm follow in its footsteps. What I am pointing out is that for Elm to garner the success we all desire for it, it needs to be a powerful tool for solving many problems in many different environments. Since Elm is Turing Complete, it is far more than just a sophisticated DSL for web development. But because of the Cathedral development process and the size of the team is small, it's impact is equivalent to a DSL. And you may be saying to yourself, that fine. We are willing to be patient so we can build it "right". But you're idea of "right" may not be mine. In fact, your idea of "right" today might not even be your idea of "right" tomorrow. You're solution may be great, but it may not work ideally for my problem. Or it may be only 80% of what I need and without any access to the more powerful tools, I cannot remedy this. Or you may decide that an Effects Manager to talk to a Postgres database isn't a priority. And even if you did, are you seriously going to write all of the Effects Managers? For everyone in the world? And in a timely manner? A Turing Complete language with such restrictive policies is effectively NOT Turing Complete. Overly favoring Protection over Power can also mask the fact that this is a Control issue. Being a control freak myself, I appreciate the allure of such control. We imagine the perfect world that we can create if we can just get enough time to think and build. And if we can set the right rules in place, nothing can threaten our perfect creation. But the grip one must maintain to wield such control can crush and then all is lost. There have been some good suggestions in the comments of this post regarding how to streamline moving code into the Kernel and mechanisms for getting 3rd party libraries sanctioned. While I don't have a strong opinions regarding any of these, they are possible approaches to finding a good position in the middle of the spectrum. I think we would all benefit from allowing the excitement of the community to help propel Elm into the mainstream. I'm developing an Elm layer on top of Nodebots for 2 reasons. First, bots are cool. Second, I want to introduce Elm to people who want to do bots but don't know or like Javascript. Regarding Grove. I think many of your scenarios you mentioned are still possible without Grove. In fact, elm-github-install has been around for over a year and none of those have occurred. And even without elm-github-install, you can manually install unsanctioned libraries. This goes back to the issue of Control. There is no way you're going to be able to control the things people want to do with Elm. Every great technology since the beginning of time has been used as intended and unintended. Imagine if hammer manufactures had the burden of making a useful hammer that couldn't be used to crush someone's skull. Even if this could be accomplished, it would certainly be a less useful hammer than one that could. And I suspect very few people would buy such a hammer. Bad libraries would be unfortunate because they'd lead many down a bad road. But maybe the ecosystem would be better if some rogue libraries existed. They could be experimental. Those willing to experiment would be taking a risk sure, but it may be that the rouge library becomes something far better than expected and worth incorporating. Grove is nothing more than a tool for allowing people to streamline working outside of the current system. Something that is going on all the time and I'd argue a good thing. Dissenting ideas are healthy for the community. They keep us from settling for local maxima. They are incubators for innovation. Hell, Elm is a dissenting idea from Haskell, Javascript and a host of other languages and ecosystems. Without dissent, Elm runs the risk of becoming a religion with a few high priests preaching the dogma to the masses who cannot be trusted to venture outside of the church. I'm pretty sure that nobody wants that. One of the biggest reason I wrote Grove was because as soon as I have one line of Native Code in a library that my application uses, I can no longer use the standard package manager. Also, as soon as I have one line of non-open source code, I can no longer use the standard package manager. elm-github-install solved these things, but what pushed me away from that was there was no way to install locally using soft links. And working in Node, we needed a good way to deal with npm modules which is complex. These are real problems that aren't just mine. I built what I deemed a better hammer. I cannot control how anyone uses that hammer whether they use it to drive in screws or crush skulls. It's not the tool's fault. It's either ignorance or malice on part of the wielder. You could rid the world of hammers and people would still find some way to do bad things. This post was about suggesting that Elm needs a better Native Code policy and I still believe that. If you were to remove everyone from the community that has Javascript code in their Elm project, the community would be decimated. So taking a position of "No one should be writing Native Code" isn't solving our original problem. Also, when people hear the rhetoric in the community that maybe Elm isn't right for them, or if some feature isn't officially supported then they cannot use Elm right now, or maybe they should be using another language, it creates a culture that isn't very welcoming and those comments aren't addressing the underlying problem that lots of code still needs to be written and those few allowed to write Native Code are busy doing other things. With the current policy of ostracizing libraries with Native Code and by publicly discouraging any unsanctioned development, you limit the free flow of ideas and risk driving such development underground or worse, away from Elm. I hope this comment is constructive and sheds some light on a different perspective to the issues faced by some in the community, from someone who is very enthusiastic about Elm and its future, and who wants nothing more than to see Elm succeed. 
Actually have that video recorded and being edited now. 
But, I want packages that I install to be able to secretly break the guarantees that Elm provides. The health of Elm can only improve by locking more of our packages into the JS ecosystem. You aren't trying to make the language or community better, you are just infantilizing developers by not giving us the power we need to do real programming. /s
I don't feel like this is a very productive comment. The goal is to ensure that there is no misunderstanding of the goals and aims of Elm. It's okay if someone doesn't understand why some things are the way they are: this is what the original post was about, to help others understand the position of Elm on Native and how we got there. 
What are the tradeoffs of having a senior set of Elm developers managing @elm-explorations? This is what I'm trying to understand. Why not trust your closest allies? From outside it looks like you are trying to do everything and failing because of too much stuff to do and to compound on this it looks like you don't trust anyone. As far as I see it, this has nothing to do with the difference between Python and Ruby or with taking the Elm the language in one direction or another. It has to do with people other than you being trusted to work with Native/Kernel, being trusted that they can do just as good of a job at it as you. So, what are the tradeoffs of having a people like Richard or Noah or Luke go through a **checklist** with potential Kernel Extensions and having these explorations available for the people who want to try them? Just to be clear, I'm not talking here about wrapping React or other crazy stuff like that, I'm talking here about the Web Platform, about access to LocalStorage, FileReader and the like. 
I want to preemptively reduce conflict here! I definitely do not think this is a fair representation of other perspectives. Imagine I enjoy working in a typed functional language, but my work _requires_ direct interop with jQuery stuff for some reason. The decision made in Elm does not work for me, and if I like Elm a lot, this is really sad! It's so close to working for me! Why not make the simple fix?! I may even be quite mad. How could they do a good job over there and make such an obvious oversight over here?!?! So I think the root is actually enthusiasm about the quality of the ecosystem. The thing that makes it so subtle and hard to talk about online is that "a loophole for my situation" seems fine in isolation, but the overall effect is quite serious.
First, I recommend reading [this section](https://github.com/elm-lang/projects/blob/master/roadmap.md#where-is-the-localstorage-package) of the roadmap document I published recently. Second, I do not publish all of the personal interactions I have publicly, so I can share some information about that. ## On Trusting People and Collaborating I already work with the people you mention on these sorts of things. For example, Brian created elm-benchmark which will live in elm-explorations. Noah and Richard wrote some kernel code for elm-test. John and Andrey made WebGL what it is today. I have talked to Fred about LocalStorage and we agreed about the big problems there. (It turns out doing LocalStorage correctly is very hard and "just let me have an early version" has serious downsides as described [here](https://github.com/elm-lang/projects/blob/master/roadmap.md#where-is-the-localstorage-package).) Richard, Aaron, and I have each worked on LocalStorage a lot as well. There are many other situations like these that work out in varying degrees, but in the interest of time-management, I do not write up every single one of these interactions with the full set of tradeoffs and difficulties we discussed. So there are a bunch of folks I trust on this, and we actively work together on all sorts of things around this. I tried to describe how this set of people grows in my talk [Code is the Easy Part](https://youtu.be/DSjbTC-hvqQ). In the past I have recorded and shared "API design sessions" to make it more obvious that this is how things work already, but I have not done a ton in the later phases of 0.19. Perhaps doing more of those videos can serve as more direct evidence that the thing you want already happens. ## On a "Native Review" Process We already tried this. For about a year. We had a native review process with ~10 reviewers, and three OKs were needed for something to get through. None of the reviewers were happy with the process or the results it produced, so we decided to move away from that strategy. We were all hopeful we could move faster and get the quality we wanted, but it just did not work.
We tried 100% exactly this idea in 2014. I was one of the reviewers. The end result was that it made things go even slower, and people got even more upset with how things were progressing. I don't want to start a huge tangent on this thread as to all the reasons why, but please believe me that this sounds like a good idea on paper (it did to us too!) but it is not that simple in practice.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [Why Elm needs a better Native code policy](https://np.reddit.com/r/programming/comments/73uwzu/why_elm_needs_a_better_native_code_policy/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
&gt; It's okay if someone doesn't understand why some things are the way they are Does this attitude explain why elm-lang.org doesn't seem to have anything to explain what these 'goals and aims' are? It's alright if people don't know them?
&gt; I definitely do not think this is a fair representation of other perspectives. Then you seem to be missing some of the perspectives out there. Go read some of the more toxic criticisms of Elm. I take the point that it isn't fair because people aren't actively engaging against the aims of Elm, but the point of my statement, which doesn't seem to have been received, is that people *aren't* making these claims, their complaints are ignorant of Elm's aims. How are people supposed to learn them? Blog posts? The mailing list? Reddit? Ain't nobody got time for that. There is no coherent, accessible document which sets expectations for the whole language. One-off patches to this communication gap which are posted in forums which lose visibility over time are a terrible place to put them. Please, just make a single document which explains what Elm is about and why some things are more difficult and put it at most one click away from the front page of elm-lang.org.
It used to be a lot for me but that was back when I was heavily using nested records. I don't as much anymore and the boilerplate has gone down. Yea it's still more boilerplate than plain JS. It happens to be less boilerplate than Redux. But I'm ok with that trade-off because of the advantages I get.
I think it’s easy to overlook places where you have boilerplate and not see that you do too. 
I'm not scrolling to a particular id. I'm scrolling the entire table to the bottom.
Yea, that's fair. At the same time I think it's also easy to overlook where boilerplate is actually reduced. [Here is an image](https://cdn-images-1.medium.com/max/1400/1*ySYUKlXaxyE_qn81CxzDvA.png) from one of my blog posts. Getting the same functionality and type guarantees in JS would actually require more boilerplate so I'm not sure it's a one-sided thing. Elm adds some boilerplate but it also makes a lot of boilerplate unnecessary too.
Personally I don’t compare to JS but to ClojureScript with reagent and to a lesser degree to Python. Both win over elm in ability to express your code DRY. Both lose because of lack of type guarantees. But macros in Elm would be nice I think, and something like instar (my clojure lib) for data structure manipulation would be much nicer than the quite hobbled APIs we’ve got now. Ultimately though I agree somewhat with Evan that macros and such would produce long term problems. That is his priority. But mine is to write code _now_ so code generation it is. It’s the poor mans macros after all :P
I think having a document like that could be helpful. I was thinking of making one specifically about this question, but perhaps it'd be better to frame it as about the whole language as you say. Good idea, and thanks for clarifying!
It seems like the root concern is that the current policy limits the growth of Elm and the set of projects it is good for. I agree, but I also think it is the better path for the language. I am choosing it consciously. ### On Author Responsibility Perhaps the root of the disagreement is here: &gt; I built what I deemed a better hammer. I cannot control how anyone uses that hammer whether they use it to drive in screws or crush skulls. It's not the tool's fault. I very strongly disagree with this sentiment. Here are a couple examples: - When a language allows runtime errors, I do not think it is right to say "I cannot control how people use my language" and put the responsibility on the users as if you did not add an exception feature. - When a library easily exhibits terrible performance, I do not think it is right to say "I cannot control if people write code that way" as if you do not literally control how people code with the API design. - When a compiler produces bad error messages, I do not think it is right to say "I cannot control if people struggle with that" because you 100% can improve their experience. A package ecosystem that does not _enforce_ semantic versioning will have libraries that do not follow semantic versioning. A package ecosystem that does not _require_ no runtime errors will have runtime errors. Check literally any package ecosystem. You can blame the package author, but shuffling responsibility in this way has never improved the root problem in any example that I know of. I feel that terms like "beginner-oriented" are used as a way to write off this perspective on responsibility. I think that is a rhetorical trick that glosses over the possibility that something that needs expert knowledge has design problems. ### Implications I am taking a pretty odd approach on these topics, and I 100% agree that it limits the growth of Elm. I 100% agree that it means you cannot use it in certain places even thought it _could_ be nice. Elm is already a healthy community that can support itself without more people showing up. In my view, growth is not worth it if requires that we degrade the quality and guarantees of the language. It's fine to be a small community with a specific goal! I think as long as Elm keeps its focus on quality we will _always_ have a niche, and growth will come as we cover more cases with the same level of care as before. I know that is disappointing to folks who are on the borders of what Elm can do, but I don't think we can have both. There are languages like ReasonML and PureScript that make other decisions on these points. If you do not like those ecosystems, perhaps that is _because_ they make other decisions on those points. I tried to get at this in [this other post](https://www.reddit.com/r/elm/comments/73ubxo/an_explanation_of_elms_policy_on_native_code/). I also 100% agree that it pushes some problems to JS **through ports**. I am excited for Murphy's elm-conf talk to come out because I think it makes it clearer how to use ports in a way that feels nice and minimizes the repeated code you are worried about. Through ports, you can use `npm` or `yarn` or whatever you want. That may not work for you. That may not be the design you like. That is fine. My point is that I don't think the "easy path" or the "direct path" actually goes to the right place. ### Meta Finally, I want to say thank you for writing up your perspective like this. I know that can be super hard to be constructive when it feels like folks are attacking your work, so I really appreciate you overcoming that. I am not sure we will come to an agreement here, but I hope we understand each other better now.
[removed]
I think we're currently missing part of the solution. The elm side is pretty good but when we transition to the often required JS side of the app we have to abandon most of the safety we looked for in Elm. However, I don't think it falls on Evan to find a solution for the part that lives outside of Elm's border and I'm sure that in time somthing will emerge there.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/altjs] [An explanation of Elm's policy on "native code" \[r\/elm\]](https://np.reddit.com/r/altjs/comments/73w27u/an_explanation_of_elms_policy_on_native_code_relm/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
I presented something at ElmConf that might be helpful. https://github.com/pzingg/css-transition-examples Use requestAnimationFrame in JS or Elm, or Process.sleep Elm task.
I was thinking about this as well... I think my presentation of ports has lead to a lot of confusion that I did not fully see or understand. Murphy's talk from elm-conf highlighted this really well, showing (1) his expectations of how to use ports and how that was annoying and (2) how switching to the intended usage pattern helped a ton. It is super hard for me to predict (1) and write docs that anticipate it, so I think his talk will help me improve my presentation in the guide a bunch! Point is, once that talk comes out as the first nice (in practice) resource on the intended _usage_ of ports, I think we should revisit this idea of improving things on the JS side. Perhaps there is a way of writing `npm` modules that makes them a nice fit for the intended usage pattern of ports... Possibly! * * * EDIT: Murphy's talk is out! You can watch [here](https://youtu.be/P3pL85n9_5s).
I did a talk at ElmConf about CSS Transitions for simple, easy animations. See https://github.com/pzingg/css-transition-examples
Ideally, I would love unsafe Elm on the JS side with direct JS interop. But I think the efforts required to provide that would be tremendous and may not be worth sinking your time into.
sorry youre getting so much flak for this! as someone whos mostly used elm with electron/node i appreciate the effort and will most definitely check this out!
I can confirm it would be a huge effort :) Separately, I honestly think other tools will be better for the problem of "write nicer JS" when it comes to line-by-line improvements to existing JS code. I also don't think that is a critique of Elm, just an observation that different goals lead to different design choices. I.e. Elm is not *for* working with side-effecting functions directly, and that is encoded deeply into the language and compiler.
I read through the doc, and that's a great write up on the problem and various strategies, whereas I only presented one. I can't think of anything to add to your doc, but if I come up with anything, I'll let you know. Thanks for reading my post!
[removed]
This week I've been polishing [pace.ninja](https://pace.ninja), the simplest (and Elm-iest!) running pace calculator in the world. Feedback greatly appreciated!
As far as I understand things, you have two options to interact with with the backend server. 1. you let the browser do a post request by setting up the form to submit to an address 2. you do a `XMLHttpRequest`. You seam to be doing the second (`elm-lang/http` uses `XMLHttpRequest`) and expecting the effects of the first type of interaction. You have two choices. 1. you use a simple form post to ferry the login information and let the browser handle the redirect (you set the form action to an endpoint that handles the authentication and redirect). 2. you handle the reply from the server and [navigate to the redirect URL](http://package.elm-lang.org/packages/elm-lang/navigation/2.1.0/Navigation#newUrl). Both are valid choices and which one is appropriate depends on your taste. I tend to go with the second. :) 
Are there any plans to expand Ellie? I'm particularly interested in the ability to use multiple files (to showcase splitting code into modules). I'm also curious about the idea of creating a facility to access a large, curated set of examples through some menu. 
What I'm getting at from this post is basically: **If you don't like Elm or the ecosystem, don't use it go find an other FP language.** I think this is a very limited / aggressive approach and here is my perspective/reasoning: **I love the language** in general, the simplicity, the user friendliness, the fact that it's pure, etc. basically it's really easy to work with. I've tried to use the other FP languages and I allways came back to Elm because they are cumbersome to use. The problem comes from the fact that the framework (TEA) is bound to the language and the interop (ports) is bound to the framework, and since there is now way of publishing alternatives, others are trying to make it better (Fresheyeball/elm-return, toastal/return-optics, debois/elm-parts, etaque/elm-response, folkertdev/outmessage) but failing to make a difference. I've been experimenting with an alternative myself (https://github.com/gdotdesign/elm-html) using vendored stuff (Inferno and JSS which are both tested and good libraries), but I've given up on it because it would be really hard from this point to get people to use it because of the framework (TEA) and JS interop (port) lock-in. I've also made `elm-github-install` because **I had and saw the need** and since then it's suggested alternative (as the fallback) if the site is down and used by quite many people. I've also made an alternative packages site (http://elm-directory.herokuapp.com https://github.com/gdotdesign/elm-directory) which shows the documentation of every installable package from Github for (0.18), but I've never publicised it because I though that you would consider it an attack on the langauge and (you) and not an improvement, experiment or a way to move forward (also why I didn't discuss it openly). This attitude is what made me stop hanging around slack and stop posting things in Reddit and the mailing lists. I think you are missing an opportunity to use people like me. I'm not considering myself as a rockstar programmer but I think I'm good and I'm getting better constantly and I could had been useful. I had a really good impression when I started with Elm, I was enthusiastic, I wanted to help develop the language by giving my opinion (or even code). Since then my experiences changed that, mostly everything I suggested or tried was ignored. I see Elm now as a language which has doesn't put it's users at the front and I've accepted that and I'm using it less and less. In my opinion you should **let Elm be a language** and not a framework and let people do what they want because that freedom that makes a language wide spread. If you need an example check out Crystal (crystal-lang.org) I consider them a good example how a language should be developed (quick releases, that fixes bugs and introduce new features, decentralized package system, etc...). I uderstand that Elm it's still in development but deep down I'm hoping that you will to put up a warning to the site saying that the langague is "Experimental use at your own risk. Also bound to the only framework available." so people like me does not invest in the langague before it's ready. Forgive me if I this seems like a vent (because partly it is) and I hope that you don't take this as an attack on you or the language because I think that you did a great job developing Elm (the language) I just don't think you should take the burden of developing the framework for it too.
&gt; Are there any plans to expand Ellie? In terms of feature set, not really. Ellie is meant to help communicate in conversations about Elm, whether it's about an issue someone is trying to resolve or a topic a teacher is explaining during a workshop. Any new features need to be in service of that goal, and it's my belief that it won't take very many new additions in order to achieve an acceptable coverage of possibilities in this realm. &gt; I'm particularly interested in the ability to use multiple files (to showcase splitting code into modules). Regarding my previous point that Ellie is about enhancing conversation about Elm, I think multiple modules would be a hinderance. We don't talk to each other by exchanging links to Medium posts, we share brief thoughts as they come to us that build on each other in a natural way. I think bringing the possibility of large examples to Ellie doesn't fit with the overall goal. I also think that once we're dealing with multiple modules we're talking about the beginning of building an actual project and it's probably time to download the elm platform anyway. &gt; I'm also curious about the idea of creating a facility to access a large, curated set of examples through some menu. This isn't currently planned because (a) I'm not convinced it fits in with the Ellie mission and (b) the ux, design, and technical challenges here are non-trivial and if they aren't in service of the Ellie mission then they aren't worth the investment. That said, I'm not totally convinced that some sort of example showcase wouldn't fit in either. So I'm not saying "never" on this one like I am with multiple modules, just not until it becomes clear that it would be a good idea.
&gt; Are there any plans to expand Ellie? I should mention that real time collaboration is a new feature that will be coming soon. I demonstrated this at Elm Conf US last week but the video isn't out yet so most people wouldn't know that by now.
&gt; just not until it becomes clear that it would be a good idea. My main source of inspiration for this is Kathy Sierra's presentation on badass developers, [specifically the ending where she talks about brains being very good at pattern matching](https://youtu.be/FKTxC9pl-WM?t=1228). A very large set of high quality examples might be a boon for the people just starting out with elm. The thesis is that if a beginner could look at and, most importantly, be encouraged to fork/alter a lot of examples (make them their own), their brain might pattern match on useful approaches faster. This large set of examples could be outsourced to the people already teaching Elm as they would benefit tremendously from this large set. &gt; I think bringing the possibility of large examples to Ellie doesn't fit with the overall goal. The main thing that cannot be showcased with Ellie right now is splitting code into modules. What I had in mind was something limited, more in line with the idea of a gist than with that of a full repository. Having 5 file slots would be more than enough to showcase extracting some code in a view file or having some `elm-css` code live in its own file. 
Hello, I want to share with you https://momentum.earth that we (me as a programmer and a designer friend) did over the course of the last year. You can use the app to create lists to structure your ideas into actionable steps. Based on "getting things done" from David Allen. The navigation and ui concept is a new approach directly linked to "getting things done", that might be a bit confusing first. It is a single page app and pwa(progressive web app) with service-worker and offline mode. The UI is written in elm and is connected via ports to xStream(CycleJS). CycleJS manages the events between elm, firebase, indexedDb, web crypto api and a javascript drag &amp; drop implementation. The most benefiting part with elm is that I can mess around in about 11000 loc without much worry :), I just let me guide back to a compilable version with the compiler (of course logic errors still occur ;) 
&gt; My main source of inspiration for this is Kathy Sierra's presentation on badass developers This is really neat and you've got some good points about having a starting point for beginners. I'll give the talk a few watches and see what it inspires design-wise. Thanks!! &gt; Having 5 file slots would be more than enough to showcase extracting some code in a view file or having some elm-css code live in its own file. What you consider a missing feature is what I consider intentionally excluded functionality. I understand how such a feature could be used, I just don't think it's a good idea. I'm afraid we'll just have to disagree about this.
&gt; I'll give the talk a few watches and see what it inspires design-wise. One of the best examples of this approach I've seen so far is the wxPython Demo. Now I'll admit that that would be a level of complexity that is quite high but still I thought about mentioning it in case you might what to take a look at it for inspiration. What I loved in the wxPython Demo is the simple 2 levels tree structure: chapters and the name of examples in each chapter coupled with a simple filter. This allows for easy discovery and exploration of patterns. 
Awesooooome! Keep up the fantastic work Luke! 
&gt; The common answers seems to be An honest, direct answer is "no." 😉
I also wish that you would give a more useful answer when asked a question like that, so we agree there. 😛
Well I do. Which is why we now use Elm at work :P
"How would I convince my boss to use it?" is the most common one I hear these days.
"Why do commas go at the front of the line?"
"Are there enough off-the-shelf libraries, or do you have to DIY things all the time?"
"When will 1.0 be out?"
"Is there server-side Elm?"
"How steep is the learning curve compared to something like TypeScript?"
"How hard is it to hire experienced Elm developers?"
"Is it hard to get new developers who don't know Elm ramped up?"
"Can Elm run on iOS/Android?"
"Real world" apps use Native, the community know this and that's why we are looking for package alternatives. Yesterday Ellie went opensource https://github.com/lukewestby/ellie and it's an example. 
"Why is JSON encoding/decoding so tedious?"
I really appreciate that elm the language is integrated with the TEA, because everything seems to snap into place once you follow it. I understand the wish to use elm in other contexts or architectures, but I think that would make the “snapping together” go away. I am sure you are familiar with a similar thing in JS with Promises, Callbacks and Generators. While you can plug them together somehow, errors still get swallowed and there is just so much duplication to adapt libraries to the different architectures. Building robust WebApps with reusable parts is a hard enough problem to dedicate a whole language to it. That said, you mentioned different approaches and of course they are legit because someone felt motivated enough to put effort into implementing them. But I think you cannot expect people to embrace or even open up to them if it compromises the general development experience of elm with TEA. If others see the usefulness as well, they will be able to exist as separate but related projects.
[removed]
as the author of ellie let me offer that most of that code will be rewritten to use ports. there's no reason for things like code mirror to be implemented with native code beyond that i was curious how it might work, and now that things are open source it'll be best to build those things the ordinary way. the stuff that stays as native code will be to enable running the compiler in the browser which i don't think is a common enough usecase to justify openning up javascript ffi as a first class language feature. --- &gt; **UPDATE:** i think it's important to note that the reason i'm moving that code over to ports is not because of pressure from anyone, or a blind desire to conform to the opinion of other highly visible elm contributors, or an illuminati conspiracy or anything like that. it's because the code to do these things over ports is objectively, structurally better than doing them with native. i don't believe that any official version of native could change that. ports are Actually Good™ and embracing them wholeheartedly will do wonders for the js parts of your programs.
I dont think that having alternatives would make thing less snappy. It would be your choise to mix architectures and have conflicts or stick with one and have snappyness (having a TEA package and just use that). It's the same in the JS world.
&gt; It's the same in the JS world. In a nutshell, this sums up my opposition to this approach, and my preference for the way /u/wheatBread has been running things. 😅
Right ;) JS is bad because it has alternatives.
Thank you for sharing [`elm-directory`](http://elm-directory.herokuapp.com)! I wish had known about it sooner; it's better than the standard package site in every way. It shows package dependencies, easily allows you to browse different versions, shows a timestamp indicating when the code was last updated, shows Github stars as a proxy for popularity, and tells you which packages utilize effects managers and/or native code. On top of having better features, it has excellent visual appeal and looks great on mobile. I think it speaks volumes about this community that you felt reluctant to share this wonderful tool that you obviously spent a lot of time working on. Had you shared it, you would have been criticized for "misleading newcomers" or something like that. I get that Elm wants to have high quality libraries and tools, and that there should be one agreed upon way to solve a given problem. Elm would be likely be a mess if there were multiple, competing virtual DOM implementations, for example. But at the end of the day we're programmers; if we think our tools are lacking, we build our own. Elm is the only community that I know of where these sorts of explorations and experiments are discouraged. I remember a while back there was a thread on elm-dev about improving the packages site by including Github stars or download counts as way to indicate the popularity of a package. The response was ["it's better to have a no signal than a misleading signal"](https://groups.google.com/d/msg/elm-dev/-0SJ8sT_sNA/dbuW6VtIAAAJ). Sure, this is just one comment, but it's indicative of an overall unwillingness to try new things. The attitude of "we need to think about this problem until we come of with the perfect solution" is admirable to a point, but it's frustrating when it never leads to experimentation. I've been using Elm in side projects for the past 2 years, and about a year ago I fought hard to convince my team to try out Elm in production on an internal app. There was some push back, but once I showed them the benefits of purity, immutability, and FP principles, the team was pretty excited to give it a try. After 12 months, despite having a lot of success and minimal runtime errors, we've decided to use React/Typescript in future projects. We didn't make this decision over night, and it had little to do with the language itself. We simply lost faith in the leadership of Elm. My team needs a clear roadmap. We need a community that is growing. We need a language that prioritizes fixing [compiler bugs](https://github.com/elm-lang/elm-compiler/issues) instead of letting issues persist for years. We need to have the ability to contribute to the language/framework if something is missing or broken. It really sucks to move away from Elm. I'm sure I'll revisit it in the future. But I can't afford to invest any more time in a language and community that is declining instead of growing.
Still working on my Elm/Haskell E-Commerce site: https://github.com/Southern-Exposure-Seed-Exchange/southernexposure.com Finished up the Shopping Cart details page by adding Shipping Methods, Taxes, &amp; Seasonal Surcharges, then made it all work for un-registered Customers as well. Added tracking of the current count of items in a Customers cart which change when users add/remove/update items, log in, register, or log out. I propagate these changes to other tabs via LocalStorage. I added the Quick Order page which is basically a form in a table where you can enter a bunch of SKUs &amp; quantities at once. Useful for Customers that like to flip through our print catalog &amp; enter stuff at once. I tried to use an autocomplete for the SKU field(modifying it to also accept product names) but it required all the options at once, instead of querying the backend server which lagged the hell out of the page(we have ~1500 SKUs...). So I reverted to simple text inputs for now. Of course I later found [sporto's elm-select](http://package.elm-lang.org/packages/sporto/elm-select/latest), which does API querying to fetch the options, but time is getting short so I'll probably revisit that after v1.0. That wrapped up the [Cart stuff](http://bugs.sleepanarchy.com/versions/66) so I released a new version, spun up a VPS &amp; setup a public staging site so anyone can check it out now: https://staging.southernexposure.com Be warned, I haven't implemented thumbnailing so all the product images are huge. Next up is the Checkout! I need to replace contact addresses w/ billing/shipping addresses, create the checkout procedure, add a DB model for orders(adding them to our migration script), &amp; integrate it all with Stripe. After checkout is done, I have some miscellaneous &amp; admin things I'll try to squeeze in, as well as integrating the site w/ our Order Managment system &amp; preparing for deployment. Release date of the next version of Chrome is in ~2 weeks, hoping to have a minimal replacement ready by then... 
building context: https://www.youtube.com/watch?v=P3pL85n9_5s&amp;feature=youtu.be
This was a great talk, one that I will keep as a reference for people who might want to interact with JS. 
Looks like they're getting published [here](https://www.youtube.com/channel/UCOpGiN9AkczVjlpGDaBwQrQ/videos).
Maybe most "Real world" apps have some part that are not common enough to justify opening up javascript ffi. Ours use canvas to resize images. Using Native is a common usage. 
the difference is that there are no practical downsides to using ports to do image resizing with a canvas, whereas there are in the case of writing a build manager for a compiler. if it was possible to have used ports for ellie's compilation system and to have finished writing it this year then i would have used ports
[removed]
This is the first time I am seeing the elm-directory project. It looks really great, and I would love to have improvements like this on the package website! I just scanned through the history of the elm-dev mailing list, and I found posts from you, but none about the things you are mentioning here. How are we supposed to collaborate on things we both want if we never communicate? Making it easier for companies to use Elm with private code is _extremely_ important. Making the package website better is obviously great. You are saying you feel ignored, but the elm-directory work has never been shared where I'd see it before now. (I have not seen it before today.) I don't feel like that is me ignoring things, and I don't know how we can collaborate without communicating. I feel like there has been a pretty serious miscommunication here, so I'll reach out on another channel to try to chat and see what happened. In the meantime, I'm sorry you ended up feeling this way while doing some great work.
This was really helpful. I went home and refactored one of my port-heavy apps almost immediately, and I like the difference in mindset more already.
A big downside of ports (and Cmds in general) is that they aren't composable. They can't be chained together like Tasks. This is not a trivial downside.
In the thread on elm-dev you mention, **my** response was to try to lay out constructive steps that would plausibly lead to integration with the actual website [here](https://groups.google.com/d/msg/elm-dev/-0SJ8sT_sNA/d8sGnTP1FAAJ). So I feel like this is cherrypicking info to fit a particular narrative. Anyway, I am sorry you feel that Elm is a declining community (despite the fact that each elm-conf is larger and more companies are using Elm today than ever before) and that it does not have a clear roadmap (despite having [a roadmap](https://github.com/elm-lang/projects/blob/master/roadmap.md) that outlines the next two or three releases) and that compiler fixes are not prioritized (despite the fact that a ton of improvements are implemented for 0.19) and I hope it will be a better fit when you circle back.
[removed]
While I can't(/won't) speak to your other points, I've bookmarked `elm-directory`, and will probably never go back to my old ways of finding Elm packages (which was a combo of raw Google Fu and `package.elm-lang`). Thanks for sharing!
Definitely check out [Murphy's talk from elm-conf](https://youtu.be/P3pL85n9_5s). Ports are not meant to be used that way, and they are a lot nicer when used as intended. I'll be trying to communicate this better in my learning resources as well. 
First and foremost, thanks to you (and Richard) for being so kind and understanding about the difficulty of being on the other side of this argument. Even though many disagreements were had, I never felt marginalized. Thanks to you both for that. # Better Hammer Analogy I think a better analogy for the hammer that's more inline with your thoughts is a car. I can engineer a car to be safe by installing seat belts, airbags and a dozen or more safety features and do my best to make sure that I've protected the driver and passengers from harm. And I wholly agree with such efforts. But I cannot stop a driver from speeding or driving while intoxicated. If I did try to engineer such restrictions, it would not increase the safety for most users, but it would hamper operations for 100% of the customers. This what I call "solving the 1% problem". My point was that people can and will do bad things intentionally. I cannot design to avoid that. What I can design for, is the unintentional bad things and I think that's exactly what you're aiming for. I'm not arguing against that position. I respect it. The comment of making a "better hammer" is analogous to increasing the power of the engine. This would allow race car drivers on the proper road and under the right conditions to drive much faster. Will this increase the number of regular drivers who speed? Probably. But these are choices people make even though they know full well that they should not. Is it my responsibility to protect people? I think it is. Is it my responsibility to protect people from themselves? I don't believe it is. If I did, I would do it at the expense of those race car drivers who are fully capable of utilizing the extra power safely. It wouldn't be fair to punish them because a few people intentionally misuse the product. # Ports I happen to bump into Murphy on the bus from the museum back to the hotel the night of the Elm Conference and I was telling him the main reason I don't use ports was that I couldn't partially apply state parameters to the message returned from a port call. This forced me to store such state in the Model instead of the message which is how I do it with Native Code since they return tasks. He mentioned that maybe what was needed was a port that returned a Task. I think I could remove the need for Native code if such a mechanism existed. I also think that Effects Managers could also be avoided if this mechanism existed. (I haven't thought about this long enough to be sure.) In any case, I think such a feature would be useful and was worth mentioning here. # Conclusion In the next release, I will add a section to the Grove documentation warning people as to the dangers of using such a tool. I suspect you are correct that we won't necessarily agree completely, but I certainly understand your position better and respect it. And I appreciate being heard and treated with respect in return. This is exactly what makes Elm's community something I want to be a part of. Thank you. 
I have been starting to see that "no" a little more and there has been some more information on this lately as in your recent talks! (thanks) But it's still a question worth answering I think because I don't feel it's totally clear yet. My impression of course!
Sorry, that was unkind of me. I need to chill out about this topic. My apologies. ❤️
Wow, great talk thanks!
This is all good stuff, but I think the information was presented in a misleading way. I don't think the single port approach solves the problems mentioned, like "what if Elm gets a duplicated 'update' message". As far as I can tell, the single port approach is really just a way of cutting down on some of the boilerplate that is needed to define the interactions between the actors (Elm and JS) -- in the end, you still end up having to pivot on all the different kinds of messages you need to pass between them, and the single port approach doesn't really help define what those interactions will look like. It seems to me like the real winner in this case was the decision to let JS own all the data. This is what allowed the interactions between Elm and JS to be greatly simplified, and it's the one big takeaway that I got from this talk (+1 for having a single source of truth!). Obviously Murphy did mention this, but I think he gave the single port approach more credit (and screen time) than it deserved.
Great talk. Reminds me of how I ended up using Phoenix channels with Elm. 
Extremely new... I'm trying to understand something that I can't explain after reading a stackoverflow about this issue. In the 03-form.elm of the [Introduction](https://guide.elm-lang.org/architecture/user_input/forms.html) it suggests to &gt; Add a "Submit" button. Only show errors after it has been pressed. I noticed the [onSubmit](http://package.elm-lang.org/packages/elm-lang/html/2.0.0/Html-Events#onSubmit) Html.Events form helper and thought this would be the correct event to use for the submit input. type Msg = Name String | Password String | PasswordAgain String | Age String | Submit String view model = div [] [ input [ type_ "text", placeholder "Name", onInput Name ] [] , input [ type_ "password", placeholder "Password", onInput Password ] [] , input [ type_ "password", placeholder "Re-enter Password", onInput PasswordAgain ] [] , input [ type_ "number", placeholder "Age", onInput Age ] [] , input [ type_ "submit", onSubmit Submit ] [] , viewValidation model ] This causes this error though The 4th and 5th entries in this list are different types of values. 68| [ input [ type_ "text", placeholder "Name", onInput Name ] [] 69| , input [ type_ "password", placeholder "Password", onInput Password ] [] 70| , input [ type_ "password", placeholder "Re-enter Password", onInput PasswordAgain ] [] 71| , input [ type_ "number", placeholder "Age", onInput Age ] [] 72|&gt; , input [ type_ "submit", onSubmit Submit ] [] 73| , viewValidation model 74| ] The 4th entry has this type: Html (Msg) But the 5th is: Html (String -&gt; Msg) Hint: It looks like a function needs 1 more argument. I've come to the conclusion that it is due to the fact that onInput is (String -&gt; msg) -&gt; Attribute msg and onSubmit is msg -&gt; Attribute msg but I don't understand the types it is saying and why I can't use onSubmit or if there is a way to use onSubmit in this situation. * I hear that all types in the list need to be the same but in what list? The div? * What does `The 4th entry has this type: Html (Msg)` mean? * Is `(String -&gt; msg) -&gt; Attribute msg` saying that `onInput` takes a String &amp; some arbitrary msg type and returns a Attribute msg? * `Hint: It looks like a function needs 1 more argument.` makes me think I just need to add one argument to the onSubmit and I can use it in this situation but I have no idea what. Can I make onSubmit work in this situation? Thank you in advance.
Is it?
Importantly, it's not a single port pair for all communication. It's a single port pair for communicating with a single actor where an actor owns some data or some kind of resource. The asynchronous nature of actors means that you have to handle the possibility that the actor might not get your message (JS threw an exception), or you might not get it's reply(because it threw an exception and forgot about your message). Duplicate or nonsense messages are handled by discarding them, missing replies are handled by timing out and trying again. It would be nice if there was some libraries in Elm to make handling the error conditions inherent in the actor model a lot easier. 
"&lt;module&gt; does not expose &lt;function | value&gt;. Maybe you want one of the following?" Oh, you meant questions asked by people. Hmm. "What's wrong with Javascript?" At which point I give up the pitch.
&gt; How are we supposed to collaborate on things we both want if we never communicate? Sorry to sidetrack the conversation here but maybe something can be done about communication on your side too. In the beginning of this year I tried to open a conversation about implementing web-components/custom-elements in Elm on `elm-dev`. Richard asked about the API and from what I remember, there were some concerns expressed in Slack that this would lead to "mutation-as-a-service" thing. There was no proof of how this could be done and I even tried to produce such a proof, and failed. I mentioned this and what I remember receiving was silence. I don't remember receiving any input from you altho I remember Richard mentioning the fact that he discussed with you about it. In the end, I got discouraged and abandoned the exploration. 
&gt; missing replies are handled by timing out and trying again What do you mean? As far as I understood the talk I got the idea that there is no such thing as "reply". And since elm makes no assumptions after sending a message out to JS there doesn't seem to be anything to retry or time out. Did I get it wrong?
So the real problem is that the `Msg` you send along with the onInput attribute has an associated `String` type. You may want to take a look at the [Html.Events docs](http://package.elm-lang.org/packages/elm-lang/html/2.0.0/Html-Events) and see how the type signature for onInput and onSubmit differ (hint: one has a `Msg`, the other has a `Msg String`). Both `Password` and `PasswordAgain` are events that need to pass along the `String` value of the input, so you correctly have | Password String | PasswordAgain String What you should do is update your `Msg` definition to look like this type Msg = Name String | Password String | PasswordAgain String | Age String | Submit 
Made that one, even talked about NoRedInk in it https://www.youtube.com/watch?v=9Kw_XePFNYY
Did that one https://www.youtube.com/watch?v=nQEBesOf94I&amp;t=3s
&gt;[**Can I build Server Side Applications in Elm? [3:17]**](http://youtu.be/nQEBesOf94I) &gt;&gt;Can I build server side applications in Elm? Not yet, as for why well its a bit complex but this should explain some of the reasons why it has not been attempted yet &gt; [*^Pain ^Free ^Web ^Development*](https://www.youtube.com/channel/UCMXPX2dNVZUIArP7r8PCO4Q) ^in ^Film ^&amp; ^Animation &gt;*^430 ^views ^since ^Aug ^2017* [^bot ^info](/r/youtubefactsbot/wiki/index)
I think your points (and most points in these comments) would be improved by dropping the "but think of the beginners" rhetoric. It's a distraction. Let's instead take for granted that Elm is trying to solve issues that all developers face, just like you wouldn't defend static typing by suggesting that it prevents only beginners from making mistakes. But there is definitely a zero-tolerance attitude in Elm that can be alienating or even insulting at times. For example, on the page where you'd expect documentation about how an effects manager works, the docs instead seem to dismiss your curiosity with something like "don't write them, there should only be about 5 effects managers in all of Elm". Which is fine as a disclaimer, but when alongside such superficial docs, it starts to feel like "you shouldn't have to know". When things are left opaque, then practitioners are left credentializing in idiosyncrasies and creating misguided solutions. It seems like I went off on a tangent, but I think some of it underlies these discussions that use the hypothetical beginner as a proxy instead of speaking directly.
In the interest of clarity, when I say "beginners" I'm thinking of people just starting with Elm not necessarily absolute beginners. The first experiences with a language are important for that language's adoption. Coherence in communication is also important. If the front page of elm-lang.org promises something and the experience of using the language is very different, then the language suffers. One of my favorite experiences working in elm is the kind of brave refactoring allowed by the guarantees that the languages makes. Purity is one of those guarantees. If this guarantee is broken by some library that chose to do the expedient thing rather than the right thing, the experience of programming in Elm suffers. Semantic versioning is another promise that I think should not be broken. 
Thanks. Can you advise me where I can read (find examples) about autotentification, authorization? except the documentation elm, servant, jwt handbook.
I make UUIDv4 tokens &amp; pass them in the header to routes that require authentication. You can see my login/register/edit routes here: https://github.com/Southern-Exposure-Seed-Exchange/southernexposure.com/blob/master/server/src/Routes/Customers.hs Frontend pages here: https://github.com/Southern-Exposure-Seed-Exchange/southernexposure.com/tree/master/client/src/Auth &amp; HTTP req w/ token function: https://github.com/Southern-Exposure-Seed-Exchange/southernexposure.com/blob/master/client/src/Api.elm#L183-L185 
From the outside it just seems that Elm has a [huge bus factor](https://github.com/elm-lang/elm-compiler/graphs/contributors) and a [stagnating pulse](https://github.com/elm-lang/elm-compiler/pulse/monthly). It would be lovely to see a more open attitude to outside contributions and experiments, and to see Elm become a more growable language, even if it does remain limited in its abstractive power for the forseeable future. This is of huge importance if you are looking to invest in using Elm at a company, and have to be worried about being blocked on a single person on the other side of the world if you run into some serious issue or limitation. My current source of confusion is: why on earth are you the one spending time on SPAs? Couldn't that work be delegated out to other contributors? I would love to see Elm used more widely, and to see more folks benefit from its great qualities, but I really hesitate in recommending it these days with much passion due to the uncertainty surrounding its future.
&gt; How can we say "let's not make the same mistake" in a way where it doesn't come across as hostility to innovation? Have a clear path for something new. Put as many reasonable checkpoints as you want (to avoid the mistakes) but allow determined people to get through. You would then be able to point to this checklist and say, project so-and-so is stuck at level X and it would be obvious why it is not approved. This would provide an **objective standard** instead of personal preference. Right now there is no clear way to contribute Native code and everything *seams* arbitrary. Take the case of localstorage. You might think that [this section](https://github.com/elm-lang/projects/blob/master/roadmap.md#where-is-the-localstorage-package) explains why there is not support for localstorage. It doesn't. There is not enough information there to be distinguished from FUD. It should have linked to an analysis of the situation that would have made clear the issues. I remember reading something about the 5mb limit of localstorage around the time when name was changed to `persistent-cache` but not even that is mentioned. &gt; If a library like this is released, it will need to be supported forever because we cannot just switch to a better API when we figure it out. Seriously? You can drop support for the Signals and not break a sweat but not be able to switch to a better API for something like localstorage? How come? &gt; Programmers may store important information on thousands of computers out in the world, and losing that data could hurt their business. Why would a new API alter the stored data from the user's computer? Wouldn't a new API allow access to this information? This phrase make ZERO sense. The same situation goes for the server-side issue. &gt; what happens when a user keeps a tab open for a while? If you share types directly, changing types will break their code. How is this not FUD? If the server code changes, you have a new version of the app and there are mechanisms to allow for access to multiple versions of the server API if one wants that. There are mechanisms to detect new versions of the client and instruct the user to refresh, if one wants that. This is an issue that has nothing to do with how ready is Elm to move to the server. This is a sensitive topic and the communication around it has not been adjusted to compensate for the sensitivity. Instead of acknowledging the innovation that some of the people exploring Native try to bring and help them get so good at it that what they produce is indistinguishable from what Evan produces, the narrative is to vilify them. So, create this **objective standard** that would allow a random user to contribute Native/Kernel code. Make it exhaustive and highly visible and these discussions will end. P.S. [Reframing "native" code as "kernel" code](https://groups.google.com/forum/#!msg/elm-dev/bAHD_8PbgKE/X-z67wTdCAAJ) does little to solve this issue because instead of "How do I write Native code?" the question becomes "How do I write Kernel code?". This issue has not affected people who "want to wrap JS libraries" but people who want to contribute useful things. There are people who do want to write kernel code and there will always be. 
"in apps with hot loops (like animation, game ticks) and on slower mobile phones, what's the perf like and what kind of options do have to deal with it?"
Earlier you said I need to trust people more. This sounds like an example of where I was doing that. Separately, I tried to find this post and cannot. All I can find is a post on Elm Discuss in a thread that's like 40 long. I can no longer reliably read that list because of the volume and other changes. Maybe I missed it though, in which case, I tried to talk about situations like this in the second post I mentioned about how to get involved: &gt; I tried to talk about how this works in [this talk](https://youtu.be/DSjbTC-hvqQ), but there is no simple recipe. It's not like "the secret" where if you visualize it, it will happen. Maybe the API just sucks. Maybe it's great, but a fundamental premise of the library is off. Maybe it's great, but it's not higher priority than other things going on. Etc. Some ideas seem promising to me. Others do not. I must prioritize. I cannot collaborate with everyone who wants that. My point is that with *no* communication, there is no hope of collaboration.
&gt; let Elm be a language and not a framework and let people do what they want because that freedom that makes a language wide spread But this is Elm's killer feature for a lot of us. Elm's unified architecture vision is a breath of fresh air coming from JS where every team I work with uses a wildly different architecture with deep idiosyncrasies to achieve the same goal of a declarative UI. If I wanted to bring my own abstraction every step of the way, I'd use Purescript. I just think the social pains Elm is dealing with right now are what it's going to take to arrive at something more compelling than just another language.
[I was referencing this thread from elm-dev](https://groups.google.com/forum/#!searchin/elm-dev/pseudo$20web$20components%7Csort:relevance/elm-dev/bWahty1vc_I/LrgdzSBPGAAJ). Web components will get implemented with or without Elm. I just thought that it would be amazing to be able to do it in Elm. The proof of concept that I manage to do in January was promising enough in my perspective and I thought it could have been a way to solve some of the boilerplate that people complained about. &gt; My point is that with no communication, there is no hope of collaboration. I agree but if you are not available and you are **the only one that can do it** how are we to move forward? 
/u/leftsaidtim, In a large app, how do people name these messages? When there a lot of forms, do you normally prefix the constructor with some sort of Form indicator -- like `LoginPassword` and `SignupPassword`? Or do you create different data Message types for each functionality and then create a sum type that is a combination of these different types for an App-level message? 
Just to be transparent, while I've been writing elm off-and-on since mid-2016, I really wouldn't consider myself an expert. That said, I did recently see [some great advice from /u/rtfeldman](https://www.reddit.com/r/elm/comments/5jd2xn/how_to_structure_elm_with_multiple_models/dbuu0m4/?st=j8deky9l&amp;sh=c2a40a82) - who I would consider to be an expert in the field of elm. Short answer: he recommends doing exactly what you suggested - union types. edit: you might also appreciate [Matthew Buscemi's post](https://medium.com/@matthew.buscemi/high-level-dependency-strategies-in-elm-1135ec877d49) about how to handle "dependencies" at scale in Elm.
IMHO the roadmap is unsatifactory, I note that it has been created on 28th April, last edited 8th May and never updated later. From the roadmap there is no way to know how faraway the next stage is. There is no way to know if something planned for 0.19 has been canceled for whatever reason or if something not planned will be included. 
The following will be added at the very top of the Grove readme in the next release of Grove: # WARNING: This is NOT the official [Elm Package Manager](https://guide.elm-lang.org/install.html#elm-package). Grove can install official and non-official packages. If you use Grove to install non-official packages, realize that those packages offer NO GUARANTEES regarding RUNTIME ERRORS. 
tgelu, no, I think you're thinking the right way. If I understand correctly, what jessta is saying is that, even though there's not concept of a response built into the communication model of ports, we still may have the need for a response conceptually. If you ask JS for information, and that information never comes, it's up to you to decide when to try and ask for that information again.
derp_b0t, totally valid feedback. Thanks for the points! I conflated two separate methods of solving ports pains, and I didn't do a good job of defining each solution and what pain it addressed. Now that I've given the talk I'd like to be able to restructure it a bit and make the point that the pain with ports involves the *way* the ports are used, and not so much the syntax around using them.
I appreciate that. Thank you, and thank you again for talking through this!
Although other people have touched on this, I think Elm being a concise language actually means you have less code in the end despite it all. It's easy to miss when you're so used to ignoring all the curly brackets and the tons of variables. I think in a lot of ways Elm has traded explicitness for boilerplate. Monads to some degree (with do syntax) help with this, but then you have people being like "What....". It's a hard balance. The good news is over time we'll find these really common places and be able to provide shortcuts when it makes sense. 
Ugh, my co-workers always hit me with this, "but it's pre 1.0"
Many times it starts out super coupled and as needed you can make things less decoupled. Coupling is nice because it's simpler and less code (fewer translation points). The best part about Elm is that you can _actually change things_ whereas in JS people usually don't even try because they know it's probably going to be a nightmare. 
I get this a lot at work as well. They are used to React which has a rediculous amount of libraries. 
I'm working on my next "advanced types in Elm" post finally
Great, very practical talk. I look forward to looking into accessible-html! EDIT: I like the way the library is designed not as a 'framework' but as in essence functions that make it easy to follow the WAI-ARIA spec. Very useful! 
That helps a lot. Thank you
Why do the newer versions of the core seem to be missing quite a bit of functions? For example, in core 4.0.0 there is no onInput or onSubmit.
Nothing as exciting as anyone else here, but I’m learning Elm. Working through the Pragmatic Studio course, and really enjoying what we’ve done so far. I could see building web apps with it.
that makes sense. Thank you for clarifying!
Let me ask you a question: when you last installed a package, did you pay close attention to the version number it had? Or did you just run `elm-package install --yes rtfeldman/elm-css`? What's to stop someone from publishing under 0.x.y forever? This might seem like a simple fix, but think of the implications. Elm's package system relies on being able to tell packages what version they are, and how they relate to the previous versions. In a world where `0.x.y` exists, native or not, this no longer makes sense.
&gt; You are saying you feel ignored, but the elm-directory work has never been shared where I'd see it before now. (I have not seen it before today.) I'm not talking about `elm-directory` I've never shared it before. I was talking about other things, for example: - there was a discussion about the DOM API around `getBoundingClientRect` here: https://gist.github.com/rtfeldman/5f015adbdfbba541c7e7e1409b6efeef lot's of us contributed our ideas and then you created https://github.com/elm-lang/dom/blob/master/src/Dom/Size.elm which has totally different API (I have my own implementation in https://github.com/gdotdesign/elm-dom) - we clearly communicated that we would like a simple `LocalStorage` wrapper / implementation, we got https://github.com/elm-lang/persistent-cache as solution which is not even released, so naturally people made alternatives (~6) http://elm-directory.herokuapp.com/?search=localstorage http://elm-directory.herokuapp.com/package/gdotdesign/elm-storage http://elm-directory.herokuapp.com/package/Jegp/elm-storage - when I publicized `elm-github-install` I mostly got negative comments (not from you) that it would ruin the package ecosystem, which haven't happened yet and it is useful for many people (http://elm-directory.herokuapp.com/package/panosoft http://elm-directory.herokuapp.com/package/wende) - there is the 2 space vs 4 space issue in elm-format https://github.com/avh4/elm-format/issues/210 where there is actually a comment that calls out to you to decide this (which is interesting in on itself), where clearly the compromise would be configuration... - there are PRs from me that never got merged: https://github.com/elm-lang/core/pull/695 https://github.com/elm-lang/http/pull/17 - there were some discussions in elm-slack that are probably gone now where I tried to explain things All these things makes me feel ignored: I've given my opinions, ideas and work and none of it made it into anything useful, so naturally I stopped contributing directly. To be clear, I'm not saying that it was intentional, clearly you have a lot of things on your mind at a given time but it is how I experienced it. 
&gt; Let me ask you a question: when you last installed a package, did you pay close attention to the version number it had? If I need a package I usually search `package.elm-lang.org` before I install it. I do not pay too much attention to the actual version number but if 0.x.x would be available and visually different, I would know what I'm getting myself into. Also, when `elm-package` installs something it can also highlight packages that are at 0.x.x as an extra help to signal the use of development versions. &gt; What's to stop someone from publishing under 0.x.y forever? Nothing, but the message they will be sending is that the package is not yet ready for production. If someone has a different opinion about the stability of a certain package they are free to use it knowing that they are taking a risk. It is the same case with Elm being 0.x.x. Some businesses see this as a sign that the language is not yet ready, some decided to trust the language and go along even if there is the possibility of code breakage. It is a risk-benefit analysis and the decision should be in the hand of the developer. &gt; Elm's package system relies on being able to tell packages what version they are, and how they relate to the previous versions. In a world where 0.x.y exists, native or not, this no longer makes sense. Of course it makes sense. If a 0.x.x library upgrades and breaks the API, the developers who relied on that library will have to change their code to adapt if they want to use the new version. It is the same thing that is happening now when the MAJOR number changes. The price you pay if you use something that has no API guarantees ([as described by the semantic versioning schema](http://semver.org/#spec-item-4)) is that you might be doing this more often. It is a price that, in certain contexts, for certain benefits, some of the developers will be willing to pay gladly. `elm-package` could collapse the MAJOR and MINOR numbers into one number and still use the PATCH number for cases where the API did not change. Installing a 0.x.x package could also have stricter constrains e.g. `"0.18.0 &lt;= v &lt; 0.19.0"` instead of `"0.18.0 &lt;= v &lt; 1.0.0"` 
It sounds like a good compromise to me on the surface, but would it actually work? I don't know enough about how elm-package detects/enforces semantic versioning. Say a native package reached 1.0 — would elm-package be able to guarantee semantic versioning from that point on? Is there anything that prevents runtime errors from being introduced post-1.0. — Would there have to be official approval for every non 0.x release, even patch releases? Is there a risk that there might come a 0.x package that is way off-base, yet so overwhelmingly popular that it becomes a liability for all other Elm development?
I’ve got another idea that’s even more explicit: the namespace of the package could indicate native non-core status. So instead of foo/bar you’d have NATIVE/foo/bar. No way anyone would miss that like you could miss the version starting with “0.”.
&gt; It sounds like a good compromise to me on the surface, but would it actually work? I do not know. This is why I said that it is a potential solution. No one knows the future. &gt; I don't know enough about how elm-package detects/enforces semantic versioning. Say a native package reached 1.0 — would elm-package be able to guarantee semantic versioning from that point on? I don't see why not. The algorithms that evaluate the API should work the same. It is worth mentioning that they should work just as well with 0.x.x releases. The only difference is that instead of recommending a MAJOR number change, they would recommend a MINOR number change. &gt; Is there anything that prevents runtime errors from being introduced post-1.0. — Would there have to be official approval for every non 0.x release, even patch releases? This is an issue of good faith. If someone has a track record where they have improved their development version to the point where is good enough to be tagged 1.0.0, I think they can be trusted that they will do the best that they can to avoid errors. &gt; Is there a risk that there might come a 0.x package that is way off-base, yet so overwhelmingly popular that it becomes a liability for all other Elm development? This can be taken care off by making explicit a set of objective guidelines that need to be followed. Think of it as a checklist that each Native package would have to obey by. Bad actors that do not follow the guidelines and refuse to take corrective actions can be banned from the official repository. This would minimize the scenario that you are describing. 
I'm fine with this too. I would be ok even with `elm-package install UNSAFE/user/project` and with each project in this category required to have an `UNSAFE.md` file that details why is it tagged like that. 
This sounds like a better idea, indeed.
I don't think a version number is a strong enough warning that you could have runtime exceptions, many beginners it people who missed it in the docs will just see a package, install it and be confused.
Elm n00b here so take what I say with a grain of salt. ## Semantic Versioning In general the semantic way to indicate an _experimental_ release would be to append it as a pre-release. Examples: * `1.0.0-experimental` * `1.0.1-experimental` However, I agree with /u/dustinfarris in that it implicitly suggests a review process for each experimental release. [Evan](https://www.reddit.com/r/elm/comments/73ubxo/an_explanation_of_elms_policy_on_native_code/dnt9sk3/) and [Richard](https://www.reddit.com/r/elm/comments/73ubxo/an_explanation_of_elms_policy_on_native_code/dntacx7/) have already commented about the "Native Review" process and how it failed. ## Effects of JavaScript in Packages Assuming it solved the quality concern this still does at least a couple things: * strains resources (for review) * blurs focus * reduces portability From [Evan's 0.17 "native" policy](https://groups.google.com/forum/m/#!msg/elm-dev/1JW6wknkDIo/H9ZnS71BCAAJ): &gt; It ties us to JS way more. I guess not many folks know this, but Elm is designed to be 100% independent of JS. It happens to compile to JS now because that was the right thing to do, but in a decade, I expect we'll be compiling to something more efficient. There is a small set of "native" stuff for now, but that means supporting the entire ecosystem on a new platform is fairly easy. ## Why Elm Is Better Than That What I appreciate about Elm is the steadfast attention to quality. I stand by the mantra "It's better to do it _right_ than _right now_." That way we don't end up with many ways to do the same thing. When I do code review in a JavaScript code base today I take a long time and usually request more test coverage. Even then I _assume_ I've missed something. There's no guarantee. When I use Elm I feel much more confident about the code simply because it compiled! What a different, but welcome feeling. If a new package is introduced in Elm I don't have to spend time comparing it to the 30 other packages like it to see if it's the right choice. I would rather wait for a thing to become part of the kernel if it makes sense. Until then I know I can contribute by finding ways to write pure Elm...which I prefer to do anyway!
&gt; Evan and Richard have already commented about the "Native Review" process and how it failed. What I'm proposing is something a little bit different. The libraries would reach 1.0.0 after spending some time in development. In this time, their API can be improved, the amount of JS used minimized (if possible). They can get better and better in quality while still being available to the developers willing to take that risk. &gt; What I appreciate about Elm is the steadfast attention to quality. me too. &gt; I would rather wait for a thing to become part of the kernel if it makes sense. Until then I know I can contribute by finding ways to write pure Elm...which I prefer to do anyway! That is a perfectly fine attitude to have, just be aware that different people prefer different things. 
Hey hello, i'm going to do a quick oral presentation of ELM, I was just looking around for recent actualities/news reguarding the language that I could mention, I hope this is the good place for this kind of questions, thanks for your help! 
Good discussion. Thanks for clarifying. What I'm implying (and should clarify) is that even when a package with "native" code reaches `1.0.0` it still has JavaScript in it. This means we can't automatically enforce semantic versioning via `elm-package` going forward. Even if a minor/patch release comes out and it has no changes to the public API it could be a breaking change. Therefore, it seems to me that every "native" package _release_ would first have to be labeled as `x.x.x-experimental` requiring the review process. You're right, though. It's probably just different mentalities. Different strokes for different folks, eh?
Would be really interesting if we could compile elm as a front end to OCaml and compare compile times. 
Part of the problem is that people don't take into account the lost productivity of writing all the tests they need to to validate types and runtime errors when they consider the compile time. The other issue that comes up is that people rarely consider what their import tree looks like. This is important in good software development, but seems to be almost completely ignored in the JS sphere and by extension JS coders who move to elm. 
[removed]
Nice! This is absolutely phenomenal :)
&gt; Even if a minor/patch release comes out and it has no changes to the public API it could be a breaking change. I don't see how that's possible without malicious intent. 
There is a known problem with case statements that match on multiple values in a tuple structure. The exhaustiveness checks end up thrashing badly. I believe 0.19 fixes that and probably brings general improvements. It would be interesting to know how many lines of code and how many modules they have. Love Elm but the wait for a fix for some of these long known bugs is hard.
We have a channel in the Elm Slack dedicated to this, #compile-time. There are some known issues that cause the compiler to be slower than it should be, and those fixes will be coming in 0.19. Until then, there are lots of known approaches for reducing compile time -- some of them are easy, others are harder. Join #compile-time for more info
This is a good question. It's not entirely obvious, but if you see enough examples from a year ago, and look at recent examples, it definitely smells like something strange happened. It really depends on where you look, but you should probably be looking at the most recent docs for elm-lang/html, and specifically Html.Events (since input and submit are both events). http://package.elm-lang.org/packages/elm-lang/html/2.0.0/Html-Events One thing that happened in the course of elm versions 0.16 to 0.17 and 0.17 to 0.18 is that the core libraries changed ... quite a bit. To the best of my knowledge, Evan has been moving libraries that exist on github under his own personal name and moving them into the elm-lang organization as they become more stable. Granted, part of being "stable" is removing cruft and making sure the API is rock solid, but it's also confusing for many people coming to the language right now. In order to better understand some of this, you might want to read [the 0.18 release guide and migration docs](https://github.com/elm-lang/elm-platform/blob/master/upgrade-docs/0.18.md) There are also release and upgrade docs for previous versions, so you can quickly scan those and get a sense of what's been in flux for the past few releases. Hope this helps ! Thanks for asking such good questions.
I dunno man, that sounds like some class work (or at work, a presentation for your actual job). You should probably do your own research. It's not that hard to go on the internet and view free videos from past elm-confs, if you're really interested you should just do it!
And then BuckleScript to JS :)
Rephrase: &gt; [Those complaining about long compile times of strongly typed languages] don't take into account (1) the lost productivity of writing all the tests they need to to validate types [would ascertain in strongly typed languages] and (2) [the time spend hunting] runtime errors [...] I totally agree! 
Maybe one can optimize compile times by re-implementing the compiler in a compiled language like C++ / Go / Rust? Isn't JavaScript a bit too sluggish for such a number-crunching task compiling is?
The compiler is written in Haskell. You may install it through npm but it just fetches a pre-compiled binary.
sounds exciting to me :) i hope you'll continue to enjoy it
Of course. That way it’d be really comparable. 
Is it possible to distill the knowledge from #compile-time using something less dinamyc (a wiki, FAQ)? IMO slack is nice for quick help, but not so much for documentation.
Here is a video on that https://youtu.be/IZA9HN9NA2U
&gt;[**If Elm is Pure, how do you actually get things done? [4:10]**](http://youtu.be/IZA9HN9NA2U) &gt;&gt;Elm is a pure language with no side effects, so how do you actually make it do useful things like interacting with a server via AJAX or even get the time of day? You use Managed Effects, that's how this video explains it. &gt; [*^Pain ^Free ^Web ^Development*](https://www.youtube.com/channel/UCMXPX2dNVZUIArP7r8PCO4Q) ^in ^Science ^&amp; ^Technology &gt;*^480 ^views ^since ^Oct ^2017* [^bot ^info](/r/youtubefactsbot/wiki/index)
Did that a while back https://youtu.be/nY0Uo3e_GnY
I am collecting information for this.
&gt;[**Why Elm has JSON Decoders [3:06]**](http://youtu.be/nY0Uo3e_GnY) &gt;&gt;One point that people often make is that they don’t understand why Elm code requires json decoders. &gt; [*^Pain ^Free ^Web ^Development*](https://www.youtube.com/channel/UCMXPX2dNVZUIArP7r8PCO4Q) ^in ^Howto ^&amp; ^Style &gt;*^230 ^views ^since ^Aug ^2017* [^bot ^info](/r/youtubefactsbot/wiki/index)
Yes, there is a gist of the information.
For the curious, these are the gists pinned in that channel: - https://gist.github.com/eeue56/4fbf9fedfb03479410d7a21be69f2f3a - https://gist.github.com/zwilias/7ed394ec0e9c6035e1874d19b721e294 - https://gist.github.com/eeue56/621bdaec6eea6666b0fd91f27001eba0
I didn't attend but thanks for the summary! 
Here is a use-case that I experienced myself a while back: I asked for code reviews from experienced FP devs by sharing code that I wrote. One of the mentors tried to teach me opaque types and how they can improve my API, reducing breaking changes down the line by decoupling internal implementation from API etc. He wanted to extract part of the module to an opaque module, but sadly ellie was not an option for us, as he was unable to share the opaque module and how it would be consumed. He ended up having to create a github repo just to share the code with me. Wasn't a big deal, but my reaction was "oh... kinda sucks that ellie doesn't have this feature yet". If you think that it's better to keep it simple in 90% of the situations (and I would agree), maybe consider adding a setting somewhere to allow this (disabled by default)? It would have improved my experience with ellie (at least this one time :p).
A this compile time is a problem. However almost everyone is compiling their JS anyway with Babel and not getting any of the type checking. 
It's impossible (or perhaps impractical) to tell if a change in JS is a breaking change. Just think of the fact that you can change objects with [] or prototypes or getters and setters or async stuff or eval... There's thousands of ways to have unexpected side effects or random runtime exceptions. It would be very hard to handle all cases, most even popular libraries don't in JS.
I think the core of the problem is that Evan wants to have _as little JS code as possible_ yet still get everything done. The reason for the name change to Kernal was to communicate that this isn't some hidden feature it's just an implementation detail. It's just enough code to bootstrap Elm and no more. JavaScript is very hard to write in a bullet proof way and the general way you make that happen is by lots of people "testing" it on production. Meaning anytime you try something newish or less popular in ecosystem them you would have a high likelihood of running into runtime exceptions. I personally think that github/elm-github-install is sufficient for experiments. Still summerize I think that expanding the web platform is the way to go. That way it creates JS code that everyone uses and is therefore battle tested. Not only that but it will never have to change because it's so reusable and generic. 
I absolutely loved this talk! The comparison between Elm and JS (and other things) is amazing. It made it obvious to me that JavaScript folks (myself included) are used to things going at a blinding pace (hence all the reasons people rage about issues that go unanswered), however it's ok to go slower. Another interesting implication is that fact that perhaps Elm will never be widely popular, but that's probably ok too, it will please it's users. 
I'm going to respectfully disagree. I personally think the analogy is limited and inaccurate. For example, in the analogy Chanel gives you all pieces of clothing you need, but in reality elm still has functionality missing for which it uses JS (ports). Using the same analogy, it is like if Chanel didn't provide you with something essential like hats (storage APIs to say something), so to wear a full model you'd have to go back to H&amp;M every single time (project) by mail (ports) or freeze your head off. It gets a bit ridiculous to compare, so sorry for that. I think there are some powerful lessons in the talk about coherent design and explaining the intentional limitations of the elm project &amp; libraries but I would have enjoyed more straight forward delivery. The example of the style libraries and the plot library were very interesting.
Oh wow really? I found Elm to be the fastest compiler I've worked with but I've never done anything of appreciable size. So far just a typing test as a side project. This is interesting to hear though.
Great to see this being taken seriously in the community :)
To be fair, Chanel is a very mature fashion house, with things like distribution, venues, marketing, etc. more or less figured out, where the Elm foundation is still being built.
Well it was more to check if i hahdn't forgotten anything game-changing that could've happened, that could've been omitted in my sources. For a 5min speech even a tiny comment can be relevent. Anyway the presentation went well enough without added details. Thanks for answering thought
There are some bugs in the 0.18 compiler (fixed on master) which trigger pathological slowdowns in the compiler. In the meantime, if your compile times suddenly spike, people on Slack are available to help with ways to dodge these cases!
Well maybe. But slow compile times can break your flow so it’s a real problem. It’s also pretty silly to just pretend compile times are irrelevant because they probably save time/embarrassment in the long run. At some point compile times are slow enough to actually not make it a good trade. For example compile time measured in days or weeks. So now we’re just haggling over the price. 
Delphi used to have the progress bar counting lines turned off by default because just showing it was slowing down compilation times for projects under 10k lines. This was early 90s hardware. Just to give some perspective :P
Two points I really liked about this talk was "don't confuse elegance with snobbery" quote and the tensions of keeping a coherent design. The analogy is definitely a stretch but Tereza used it very effectively.
I don't see why you couldn't use http://package.elm-lang.org/packages/elm-lang/core/5.0.0/Platform#program in an extension or just have a normal elm app with ports
I used it to make a Chrome App which is quite similar to an extension and it was quite painful. But this was way back when before `Task` was even introduced (elm-lang/core was at 1.1, now at 5.5) so it was a bit of a different beast. One of the pain points though was the JS interop along with the JSON encoding and decoding required to communicate between the background and the foreground. I am not sure that has been solved yet (but I am only following Elm from the sidelines at the moment so may have missed something). Here is [the source code](https://github.com/kasbah/mooltipass.hid-app) though it probably won't help you very much.
Thanks! Do you happen to have experience working with ports to do this? I'm wondering if it's easier than JavaScript, among other things.
Perhaps this isn't helpful but Elm really just needs a dom node to operate. compile with: elm-make src/Main.elm --output=main.js Then in some HTLM somwhere: &lt;div id="main"&gt;&lt;/div&gt; &lt;script src="main.js"&gt;&lt;/script&gt; &lt;script&gt; var node = document.getElementById('main'); var app = Elm.Main.embed(node); // Note: if your Elm module is named "MyThing.Root" you // would call "Elm.MyThing.Root.embed(node)" instead. &lt;/script&gt; Reference: https://guide.elm-lang.org/interop/javascript.html Not sure how GWT works but essentially that's how to do it. 
I'm sure Chanel started without being fully complete. I think the main thing about Elm (perhaps difference to the analogy) is the fact that it's become popular at a very rapid pace, far before it's complete. Which is a good thing! It's the problem of success. It's validating because it means that what it's currently built makes people happy. People like having bulletproof software, an ecosystem that works well together and doesn't break and random times (left pad). sometimes they don't fully realize that their ideas of good features (Direct JS interop, JS in elm packages, etc...) would slowly turn Elm into just another JS-alt language. Although I know many people feel agitated by Elm's slow development, they have to realize that there are tradeoffs to be made when you "let people go wild" or adopt a community-based roadmap. JS is a good example of this. Features are constantly being added like Classes, Async Syntax, Generators, Etc... without thinking about the cost of learning or if those produce readable code or fast code rather than just convenient code. Haskell is an example of committee-based decision making, hence all the tons of language extensions, when they probably should have said, "I don't think we need that" and we all would have been better for it. Perhaps it may seem like Elm is going at a snails pace, and it is compared to the blinding speed of JS development! Neither are wrong but I personally like the tradofs that Elm is making. I feel like Elm meets my needs 95% of the time, the other 5% are easily solved by ports or other methods. 
Hi [kasbah](/u/kasbah)! I worked on that app for a month or so and I thought it was really well designed. It implemented a protocol for managing a USB device, and having union types and pattern matching makes it easy to handle state machines correctly. Also I remember a really clean, enforced separation between foreground and background concerns. I imagine that trying to do all that in raw javascript would have gotten bug-ridden very quickly.
Used it, love it. (Chrome omnibar extension, searches entities in CRM app using REST API as you type, lets you open them fast by selecting them.) Some JS boilerplate to connect ports, and then bam, let's write some Elm :)
&gt; JS is a good example of this. Features are constantly being added like Classes, Async Syntax, Generators, Etc... without thinking about the cost of learning or if those produce readable code or fast code rather than just convenient code. I agree with most of your points, but I think this quote misrepresents the effort and thought that goes in to language design in TC-39 and the value it produces. JS wants engine implementors to make the code people write run fast, not make people write fast code. Features build on each other and attempt to solve real problems. Asynchronous programming has been hard for people to understand in JS since the very dawn of the language. Promises confuse people which async/await attempts to solve. Most devs don't understand prototypal inheritance, so classes attempt to sweep it under the rug. I think Elm and JS have wildly different goals, and wildly different approaches, but they are both trying to do good work. Modern JS language design feels like an experiment to figure out what happens if they try to include every single good idea, and while doing so, include some false positives as well. Any random web developer can contribute a proposal to TC-39. Some of the new stuff is icky, but the JS I write in 2017 is easier to write correctly and maintain than the JS I wrote in 2007. Language design in Elm is fascinating and I love the results. The deliberate, thoughtful, un-rushed approach takes lots of discipline and I think Elm is popular partially because of that discipline. It feels like polishing a diamond vs the JS approach of building an ant colony. People in JS are doing good and interesting work as well, just approaching it in a completely opposite direction.
Hi Conrad! Yes, I probably painted too bleak a picture. It was actually a lot of fun to work on for a while and there were a lot of other reasons why it wasn't very successful in the end (it was re-written in JS pretty quickly). Part of it was also my lack of experience doing front-end stuff and my reluctance to use HTML and CSS (I wanted to do everything using Elm's `Graphics` because I love it). Anyway, I still think `Tasks` would have helped a lot and that going Elm -&gt; JSON -&gt; JS -&gt; Chrome Messaging -&gt; JS -&gt; JSON -&gt; Elm was too much boilerplate and hard to manage. 
Maybe a better way to phrase that question would be: I am looking for the best elm resources + news, I'd like to research recent happenings for a presentation I'm doing etc. etc.
After following the Elm+Webpack tutorial, is it recommended to minify the JS output in production? Any recommendations on that? EDIT: And is there support for source maps?
Right, that app was all using Graphics and Signals, both of which don't exist any more. Fun times!
I haven't tried it but I'm sure you could and write a blog post about your experience!
I 100% agree with this post. JavaScript is awesome but as you hinted it has far different design goals. JavaScript is the _only_ native language to the browser so it has to be all-inclusive. Also, it has to maintain legacy code so taking away bad features isn't really an option at this point. Thanks for rounding out my answer. 
You could just run `webpack --optimize-minimize`. Or use the UglifyJS plugin in your webpack config for more options.
What about using TypeScript / Flow to enforce semantic versioning thus providing type safety for Native packages? That way it's a win-win.
I guess that this would bring significant complexity into the mix as it would mean that one would have to rely on yet another tool. In my perspective, the JS part should be kept at a minimum. The code should be as mechanical as possible. Typescript/Flow are useful if you write a lot of code in JS. This should never be the case with Native. 
Replacing such a small part with elm probably doesn’t make much sense. You won’t get much of the advantages and you’ll certainly get a lot of problems mixing systems. Writing some small utility programs or converting whole pages seems like a much better way to introduce Elm to the org. 
We use Elm at Day One for both our Safari an our Chrome browser extensions: http://dayoneapp.com/extensions/
Let's just say i'm not an english main :)
Pure Elm WYSIWYG editor.
Thanks! This looks really neat. And encouraging :)
Parser library that implements the Earley algorithm and transforms EBNF grammars so I can port my [nearley.js](https://nearley.js.org) grammar. 
This is a very progressive and detailed introduction on the subject and a nice prequel to Richard Feldman's ["Making Impossible States Impossible"](https://www.youtube.com/watch?v=IcgmSRJHu_8). I'm sure the author put a lot of time designing its slides and it shows, it's a traditional but beautiful presentation. A subject that is not treated is that by using union types instead of booleans, we lose the power of using the language native boolean algebra (`&amp;&amp;`, `||`). We have therefore to develop new specialized operations to combine several *"states"* like `RemoteData.map2` for the `RemoteData` example. I think that it's usually worth it, but I wonder if there are some advanced cases where it's not, maybe for example when it could be practical to use boolean expressions simplication rules.
Native Elm Auth0 client that would allow logging in and sign in by code
[removed]
Doesn't pattern matching basically give you an equivalent of the boolean operations, but extended?
Afaik graphics was just moved out of core. 
I'm not sure. If we take the `bookFlight` example from the talk, and want to compute something when any one of the arguments is true: With booleans: if isPremiumCustomer || hasCheckLuggage || preferWindow then ... else ... With unionTypes: case (CustomerType, LuggageChecking, WindowPreference) of (Premium, _, _) -&gt; action (_, LuggageChecked, _) -&gt; same action (_, _, WindowPrefered) -&gt; same action Note that I still think that union types are in most cases a large improvement, because of all the arguments explained in the presentation (booleans loss of information and blindness and because union types allow to combine several booleans in a single type). The `RemoteData` type allows to avoid tons of fragile and unexplicit code. But this may not be just an *"all or nothing"* situation.
A feature complete UI library like Antd (for React) that is easy to use and customize / extend.
maybe your case can be simplified with: case (CustomerType, LuggageChecking, WindowPreference) of (Regular, LuggageUnchecked, NoWindowPreference) -&gt; anotherThing (_, _, _) -&gt; something ... since your first 3 branches is just doing the same "something".
- A simple audio library, similar to this: https://github.com/kittykatattack/sound.js - A full featured 2D sprite library like Pixi (http://www.pixijs.com) with a animation state player/manager, texture atlas support, and a fixed-time-variable-render game loop. 
Absolutely. However what I meant is that `case of` acts like `if ... else if ... else`, and the pattern itself is like `(&amp;&amp;)`, but there is no `(||)` nor `not`. What you have done is using boolean algebra to replace all `or` by `and`. Because `a || b || c == not (not a &amp;&amp; not b &amp;&amp; not c)`, your simplification is then: if not isPremiumCustomer &amp;&amp; not hasCheckLuggage &amp;&amp; not preferWindow then anotherThing else something Therefore, because an `or` expression can always be replaced by an `and` one, and because `not` can be explicitly integrated in the union type itself, I suppose we can say that we have an equivalent to boolean operations, but I don't think it is *"extended"* nor that it is as powerful without additional specialized functions. Overall, a tagged union of 2 nullary constructors is however a very limited special case of union types, so union types are a lot more powerful.
&gt; A simple local storage system to avoid having to write a lot of customer JSON decoders just to save and load user data. There are a [few `localStorage` libraries](http://elm-directory.herokuapp.com/?search=localstorage) that provide a nice Task-based API. My personal favorite is [`fredcy/localstorage`](http://elm-directory.herokuapp.com/package/fredcy/localstorage/1.0.0/LocalStorage). These libraries include Native code so you'll need to install them with [elm-github-install](https://github.com/gdotdesign/elm-github-install) or [elm-grove](https://github.com/panosoft/elm-grove).
Wow, elm running in ghcjs in multiple web workers, amazing.
Awesome, thanks for this. I've been using https://github.com/sonnym/elmenv for a few years now, and it's been really useful whenever a new compiler release comes around (so far I've transitioned elm-shadertoy/dreambuggy/here4 from elm-0.12 all the way through 0.18). How does elm-forest compare to elmenv? it looks like it might have a different approach?
A library that could turn numbers into the format that twillio expects (+15007000) from arbitrary strings. Most tricky being handling random country codes. 
In use they seem pretty similar in that they both manage versions, and proxy command to appropriate versions. Brief comparison: * `elmenv` looks for a file called `.elm-version` in the current path (or parents), `elm-forest` looks for `elm-package.json` in the current path (or parents). * `elmenv` compiles from source, so has more options for version to install (`elm-forest`). This means you have to have haskell/cabal ready, but it's very cool. * `elmenv` provides shims for `elm-&lt;something&gt;`, `elm-forest` makes them available under `forest something` (as elm platform does). * `elmenv` keeps the same cli interface for elm. (`elm-forest` changes `elm ...` to `forest ...`) * `elm-forest` is project based (uses `elm-package.json` to make decisions). This means outside of project you'll get an error (along the lines of `Not in an Elm project`). `elmenv` has a global default (or resorts to trying any "globally" installed Elm) if it can't find a `.elm-version` file. In terms of flexibility, the installation from source makes `elmenv` slightly more flexible. The cli transparency would make configuring related tools easier as well (no change). I guess `elm-forest` is more geared towards my own personal preferences: * If I'm trying to run an elm command somewhere I shouldn't, stop me. * If I'm in a project, just work (select appropriate version, install it if needed, ...) * Require as little mind space as possible * `elmenv` requires a (very) small amount of configuration, and the version used may not line up with the version specified in `elm-package.json`. Of course, `elm-forest` renames the main command (`elm` -&gt; `forest`), so they are basically on-par here. But they may not line up with the preferences of anyone else. In terms implementation, `elmenv` uses bash shims for `elm` and `elm-*` commands, while `elm-forest` is a javascript "binary". tldr; `elmenv` seems to aims for transparency, `elm-forest` aims for translucency. `elmenv` provides more options, `elm-forest` "just works, as is" (not to imply that `elmenv` doesn't).
A little low info density (and low overall info) in this clip.
That makes sense. I could start with a single widget.. But again, not sure how I would deal with click handlers and what not. Because of the nature of our application, replacing a "full page" means replacing the whole front end. Our application is divided into widgets which add functionality to pages as you need it.
Well then it sounds like you should find a better target for Elm. 
A parser for iCal data (https://tools.ietf.org/html/rfc5545)
I'm not aware of any plans to update the docs. Is there anything you need help with? 
Hi, The point is this: I want to teach Elm to my students (undergraduate level) and it's not so good say "Elm is great but docs are, sometimes, incomplete". Do you understand the point?
[removed]
Of course. Have you mentioned this on the Slack channel? The main people of the Elm community are more responsive over there. 
On nothing, elm doesn't work anymore. Can't install it with `npm install -g elm`. There is a few issue but it seems nobody care
mhm - it seems something personal ... I can install it without any problems - opal → npm install -g elm npm WARN deprecated node-uuid@1.4.8: Use uuid module instead /usr/local/bin/elm -&gt; /usr/local/lib/node_modules/elm/binwrappers/elm /usr/local/bin/elm-repl -&gt; /usr/local/lib/node_modules/elm/binwrappers/elm-repl /usr/local/bin/elm-reactor -&gt; /usr/local/lib/node_modules/elm/binwrappers/elm-reactor /usr/local/bin/elm-package -&gt; /usr/local/lib/node_modules/elm/binwrappers/elm-package /usr/local/bin/elm-make -&gt; /usr/local/lib/node_modules/elm/binwrappers/elm-make &gt; elm@0.18.0 install /usr/local/lib/node_modules/elm &gt; node install.js Downloading Elm binaries from https://dl.bintray.com/elmlang/elm- platform/0.18.0/darwin-x64.tar.gz + elm@0.18.0 added 92 packages in 13.173s
I'm working through @rtfeldman's Elm in Action and learning a lot =) Great book!
https://github.com/elm-lang/elm-platform/issues/218 https://github.com/elm-lang/elm-platform/issues/215 The second one is open for more than 2 MONTHS !
Hi, Both issues list the proper solutions: fixing npm permissions by following this guide - https://docs.npmjs.com/getting-started/fixing-npm-permissions#option-2-change-npms-default-directory-to-another-directory If you're facing a different issue or need help with anything whatsoever, please do ask! :) I, and many others, absolutely care.
Yes I know I read it. But I have no any other npm package with this issue when installing globaly. And when I want to to learn a a new language, if event the installer doesn't work, I am just very scared for the further. I have done some elm a year ago so I know it's great but for any newcomer it's a total turn off
check this - http://package.elm-lang.org/packages/elm-lang/core/latest/Task - http://package.elm-lang.org/packages/elm-lang/core/latest/Platform - https://becoming-functional.com/tasks-in-elm-0-18-2b64a35fd82e
i think you're pretty much there but i wouldn't keep a model specifically meant to represent buttons within your program's model directly. for things like buttons that don't require their own state i find it's generally better to define what your view function needs as a type and then derive that type based on relevant data from your model and from messages that express meaning in terms of your business logic. ellie's buttons are defined by a `view` function and a `Config msg` type https://github.com/lukewestby/ellie/blob/master/client/src/Ellie/Ui/Button.elm#L43-L51 and they are used by creating a config in terms of other data in the application that might be a little more meaningful than a button model. for you this would mean making your `Button` type parametric in the `msg` you want it to send and then creating those `Button`s that you pass to `buttonView` within the calling view function rather than storing them in your model
I can imagine. The npm installer is the most convenient way of distributing the binaries without writing, maintaining and supporting separate installers for all the different platforms out there. Sadly, npm does weird things with global installs that contain such "wrapped binaries". I hope this doesn't give the impression of anyone not caring, though. People try very hard to make the language and platform extremely accessible, but there's definitely a lot of room for improvement, still.
I'm trying to explain lenses in [/An Outsider's Guide to Statically Typed Functional Programming](https://leanpub.com/outsidefp) and failing badly. There are interesting design-thinking things to say about composition and polymorphism (even in Elm), but the whole topic is one of those typical static FP things where you have to understand *everything* before you can say *anything*. Trying to find a friendly, Elmish, approach is not going well. 
Great Q&amp;A. The video panning from speaker to speaker was a little slow.
There is also [elm programming](http://elmprogramming.com). Sadly tasks are also not finished there yet.
Why do they exist when we have Cmd?
I think tasks are for Cmds that could fail. The example that's used on the [tasks page](http://package.elm-lang.org/packages/elm-lang/core/latest/Task) is an http request. 
It doesn't seem necessary. If the Cmd can fail, it'll send back a Msg, like here: http://package.elm-lang.org/packages/elm-lang/http/1.0.0/Http
[removed]
Under the hood, the http module uses tasks. 
They serve different purposes. A `Cmd` is a bag of effects without any ordering, and any of which may _or may not_ result in a value being produced. Examples of `Cmd`'s that don't result in a value include outgoing ports, writing on a websocket or changing the url through `Navigation.newUrl` or `Navigation.modifyUrl`. These two properties (no ordering, no guaranteed value production) make Cmd's very nice for modeling outgoing effects. You can take this arbitrarily nested, opaque bag of effects, and flatten it to a list of effects which you tell the runtime to execute, in whichever order and with whatever degree of concurrency as the _runtime_ deems appropriate. The flipside is that this makes them hard to compose. Functions like `andThen` or `map2` introduce ordering and requirements for producing values. This is where tasks come in. Tasks describe a computation, which may involve effects. Compared to commands, tasks have very strict ordering (i.e. sequential), and *must* always produce a value or fail. Those properties make them very nice for composing computation. You use them to create an arbitrarily complex task that may exist of many steps, any of which may involve some side-effects - as long as those side-effects come with a guarantee of producing a value or resulting in failure. To make everything come full circle; the only way to actually execute tasks is to make it into a command, and put that into the bag of effects we hand to the runtime by returning it from `update`. TL;DR: Commands and subscriptions are for stream io, tasks are for monadic io within that stream.
The value of Tasks is that they can be sequenced with`andThen` and exit early on failure. Cmds can't be sequenced and can't fail, when you need these additional abilities you need Tasks. 
What a great talk..
Awesome talk!
Cool! I’d love a blog post about the failed methods you’ve tried and how you came to these methods too. Optimizing teaching is a super interesting topic I think, one which I have only spent time with as a dance teacher and my experience there only partially applies obviously. 
Building front end for a payment processing solution. Loving every moment
I love it that the talk is based on the principles the talk proposes, like "find motivation". Being able to use Elm at work is great motivation for learning how to teach it.
Ah man, I think I've used these failed methods for almost 100% of my teaching to co-workers. Much needed. 
Excelent presentation. I like the focus in teaching in a way understable more than shoot about elm
[removed]
Really nice post, a really simple problem and solution that can be understood by anyone, unlike some posts that explain a new language with a fairly complicated problem haha 
Out of curiosity (new to Chrome extensions), I built a bare-bones extension composed of three apps (one persistent background app, a content app, and a popup app) that use Chrome message-passing + Elm ports to keep a single model synced between them. https://github.com/danneu/elm-chrome-extension
&gt; Now everyone can use Grove with the level of safety that they desire. I can't say how much I appreciate this. I've been using Elm for ~2 years. I'm not a beginner. I'm not a junior programmer. I care deeply about runtime safety (I wouldn't be here if I didn't care), but I also need to get shit done, and there are lots of great libs out there that will never be approved because they contain [Native code](http://elm-directory.herokuapp.com/native-packages) or [Effects managers](http://elm-directory.herokuapp.com/effect-manager-packages). I'm beating a dead horse here but having a nice Task interface to `localStorage` is a big deal to me, and the only way to get that is by using a Native package like [fredcy/localstorage](http://elm-directory.herokuapp.com/package/fredcy/localstorage). I accept the risk that this may cause runtime errors (although I'm fairly certain it won't because I've reviewed the source code). I also accept that this code will completely break once Elm 0.19 is released and Native is renamed to Kernel. I'm okay with that because, for my business needs, the benefits of having a larger pool of packages to choose from and not having to use ports outweighs the risk of runtime errors. Thanks for your work on Grove. I plan on using it as my primary package manager going forward.
So glad to hear you like it. Now with safeMode you can turn it on locally for some repos that don't need Native code and leave it off globally. Or turn safeMode on globally and selectively turn it off for the few repos that need Native code. Cake and eat it.
Great job (haven't look into the code).
Ok, that's cool.
Very cool! A few random thoughts: * Elm has a built-in [degrees](http://package.elm-lang.org/packages/elm-lang/core/latest/Basics#degrees) function which could be useful; e.g. I'd probably write [this line](https://github.com/talhoffer/pyramid-maker/blob/dc586badac5f62c197dc4e430f7a9690e0b27b7a/src/Drawing.elm#L212) as `angle / degrees 1` * In `Config.elm` is `canvasSize.pixels` actually an independent parameter? I'd be tempted to just do something like use `toString canvasSize.x ++ "px"`... * I think `edgeAngle` could simply return `atan2 y x` * Is there a reason `randomPairGenerator` uses `Random.int` instead of `Random.float` if you're just going to cast the values to `Float`s later? I also personally think that it's a good idea to have separate types for points, vectors and unit vectors since some operations only make sense one some of those (or particular combinations of them). It's nice to have the type system verify that haven't tried to add two points together or call an operation on an arbitrary-length vector that only makes sense on unit vectors. I've actually published my own [`opensolid/geometry`](http://package.elm-lang.org/packages/opensolid/geometry/latest) package that does this - it has separate `Point3d`, `Vector3d` and `Direction3d` types (plus `Triangle3d`, `Plane3d`, `Axis3d`, `LineSegment3d`, corresponding 2D versions of everything and a ton more stuff). If you're planning on working on more 2D/3D geometry projects in the future, I'd love it if you gave it a shot! Always looking for feedback on useful new features, missing/confusing documentation etc...
Thank you very much for taking the time to have a look at it! Your observations are all on point. In fact `canvasSize.pixels` _is_ an independent parameter, but to get the svg aliasing for lines to look good, it's true that the size should correspond to the pixels. Your other bulletpoints are all things that I will integrate. I agree that using points for vectors was a shortcut for now, but it was also a good exercise. I would love to clean up the math, in which case I'd definitely have a look at your package instead of reinventing the wheel. It looks very extensive and I love your illustrations. I wonder how easy it is to hook up mouse dragging using your library, since you are using `List`, whereas I could only manage to do it with `Array` since I had to keep track of the indices.
That was fun.
I've recently made Grove so that you can use it completely in safe mode: https://redd.it/75ipdv
This is pretty awesome 😁. I'm very tempted to use this in safe mode, just verify that in CI. So far I haven't had to reach for private repos but hopefully someday I'll have that problem. 
If you haven't already see the Elm conf talk, "Teaching Em to beginners"
This is really slick. Very clean design!
This is my first contribution to this subreddit. If you have any tips or tricks to make it better, I would love feedback.
Thanks Luke, I will check that out!! (Really enjoyed your Elm Town interview too - and thanks so much for Ellie!!) Rex 
That's an interesting point - I suspect you should be able to accomplish a similar effect with `List.indexedMap` though. For example instead of Array.set index draggedPoint pyramid.basePolygon you could do something like (if `basePolygon` was a `Polygon2d` from `opensolid/geometry` instead of an `Array Point2D`): pyramid.basePolygon |&gt; Polygon2d.vertices |&gt; List.indexedMap (\( i, vertex ) -&gt; if i == index then draggedPoint else vertex ) |&gt; Polygon2d.fromVertices to update only the chosen vertex to the dragged point while leaving all the other vertices the same. (Less efficient because you're creating an entirely new list, but your polygons are pretty small.) Or just use `getAt` and `setAt` from the [`elm-community/list-extra` package](http://package.elm-lang.org/packages/elm-community/list-extra/latest/List-Extra). I'll have to think about this, it may make sense to change the internal representation of `Polygon2d` etc. to be an `Array` instead of a `List`, and then allow getting/setting individual vertices efficiently... 
The inability to share native code has nothing to do with beginners in FP. It is to ensure the Elm kernel does not grow without restraint, in order to keep Elm portable in the future to a non-javascript environment; specifically, WebAssembly.
I fail to see the relationship with the Elm kernel. 
I always thought the easist way to do that is to rerender the scene with each object havin a plain unshaded colour and the look at the colour of the pixel you clicked on.
&gt; The second one is open for more than 2 MONTHS ! `npm` broke a lot of packages. I just had some "fun" with `nodegit` the other day. So, this is not really an elm issue. Please try to update to `npm` 5.5.1 as that fixed a lot of issues like this. Maybe it will fix things for you too. If that doesn't work, please use one of the suggested fixes. I understand that this might look like people don't care but trust me, they do care. The kind folks from NoRedInk are frequently working with upstream libraries on which Elm depends and are actively trying to fix the things that can be fixed. Just few days ago I saw a discussion about fixing some bug in the Haskell compiler that ends up impacting Elm's performance in certain contexts. 
I discussed this as well with the folks on the elm #webgl slack. This technique is more efficient, and there currently is not way to get the color from a pixel with the webgl library.
Working on https://github.com/Namek/elm-spreadsheet inspired by https://jsfiddle.net/ondras/hYfN3/ - this would probably be a nice small demo for a local meetup where I'm going to show off later this month to spread word about Elm.
That’s so cool! Any chance you want to share how you designed this ? More interested in the approach than the actual code ! 
I have been vaguely been thinking of writing a blog post or two, or perhaps submit a proposal to Elm Europe conference. What parts are you most interested in?
Oh gosh, here goes a few hours of my life.
How you approached the rendering especially to keep in sync the state between then dom and you data Structure ? 
The contenteditable generates events (keypresses, mutation observer, selection changes and so on) that are handled by the Elm update function. Internally, the Elm keeps the CRDT (Conflict-free Replication Data Type) as the document representation. On events it generates a patch to the CRDT that is distributed to other clients together with cursor updates. Then there is the reactive rendering going from the CRDT to an intermediate structure, then to Html Msg, and lastly, the dom is updated by the Elm runtime. After the update, the selection might also need an update. So there is no syncing going on. Rather events come in, and the content editable is rerendered like any HTML. There are many edge cases and browser inconsistencies to address, so while it easy to get started, it is a lot of work to get something stable.
cool! I'll try it out, and then maybe we can continue this discussion on another channel. I'd be interested in what Elm actually optimizes in terms of `Array.set`, I thought it also just returns an entire new array. I also found it to be tricky to sort the polygon array at the right places, and keep track of which point is where.
Very excited to see object picking in Elm! I don't get to focus on WebGL as much as I'd like, so it is great to see others pushing what is possible. Anyway, great work, and please let me know if there seem to be principled ways to improve the core WebGL support!
I have a question about multiple union types in a single module. I suspect I am missing something in my conceptualisation of Elm's union types. I am writing a module that has many tens of union types in order to define a closed vocabulary in a sort of domain specific language. The problem I am having is that it would appear that type values have to be unique across types. So, for example, the following would not be permitted: type Animal = Cat | Parrot type Carnivore = Wolf | Cat As `Cat` is named in more than one type (compiler says *Naming multiple top-level values Cat makes things ambiguous. When you say Cat which one do you want?*). Yet I can't see how you could use `Cat` outside of the context of its type, so where does the ambiguity occur? By forcing unique names I am having to create contrived value labels (equivalent to `CaCat` and `AnCat) to avoid clashing. Not only does this seem clumsy, but semantically, it seems wrong. A unique thing 'Cat' can be a type of carnivore and a type of animal. Is there a way of elegantly creating a hierarchy of union types that allows me to reuse type values in other types? If not, what is the preferred style for dealing with this kind of representation?
I was there at ElmConf. It was a good talk. I'm coming from this, I confess, from an old-time language geek perspective. It's less "I wish I could write JavaScript without annoying runtime errors" and more "I want my language to show me new possibilities". I think I've figured out a good order in which to present lenses. It makes a nice introduction to "law-based development", in that once you start wanting simple functions to get and "set" nested structure values, the lens laws do in fact help you think more clearly about what you're trying to accomplish. That's way more compelling, I think, than the usual static FP presentations of, say, monoid laws or functor laws. ("Oh! The fact that lists are a monoid makes me realize... actually nothing about how appending lists should work.") That is, there's a good idea that I think should be introduced to the Elm community from the mainstream static FP community (as I, a novice, understand it). 
I'm a beginner too, but you could rename type Carnivore to Carnivores and write (Please forgive the iPhone code formatting) type Animal = Carnivore Carnivores | Herbivore Herbivores Then in your pattern match: case msg of Carnivore localCarnivore -&gt; case localCarnivore of Wolf -&gt; --wolf processing behind Cat -&gt; --cat processing begins You're left writing 2 case statements but only write Cat once. I'm not sure if that's an improvement to your use case. 
Extending our production SharePoint elm app with a new feature and mentoring a fellow dev on another elm app (our organization's third; baby steps)
Ah, OK, that makes sense, thanks. So we use parameterised types to represent hierarchies with the base of the hierarchy being the type itself, the value being the first level, and further parameter(s) representing the next level(s). Would other experienced Elmers agree this is an appropriate use of types to model data?
Elm/Haskell E-Commerce Site: https://github.com/Southern-Exposure-Seed-Exchange/southernexposure.com https://staging.southernexposure.com/ Started on the check out process. Got the basic page in with address selections/forms, an order summary, &amp; a success page. Right now it just works for registered customers &amp; w/ no payment method. Refactoring &amp; committing some extra address code now, then going to make it work for anonymous users. After that I can work on the Stripe integration, add things like coupons &amp; priority S&amp;H, then make it send confirmation emails. After that I need to allow admins to issue refunds from an admin, add thumbnailing/media management, integrate exporting information to our order management system, then do some cleanup work &amp; get deployment figured out. I'm in a rush cause the next Chrome will show security warnings(the current site only uses HTTPS for specific pages), once I have a minimum replacement done I can work out the smaller non-crucial pieces as well as plenty of refactoring. 
ah, sounds really smart! But the content editable is more stateful than a normal div, isn't it? If I generally render a content editable in elm I can't get rid of the state without doing innerHTML hackery. Did you use a different approach there ? 
Really cool. On my phone the 16th notes aren't evenly spaced though, kind of rubato. 
Espessially the last link was very helpful
I am not sure what you mean. Once the DOM is updated and the selection is set, I have represented all there is in my internal structure. There are lots of other problems though, like handle properly translating cursor positions and responding to MutationObserver due to spell checker and other things.
I strongly recommend you do not store meaningful information in the DOM for later consumption. Partially because reading out information from the DOM is a pain, but also because it has reliability issues given the partial-rerender promises Elm makes. Basically, it could wipe out your elements or attributes if it doesn't know about them. I hear what you mean about there being boilerplate in keeping the form information synced into the Model. In practice, it isn't a lot of boilerplate, and you can always use e.g. a Dict and a general message to sync things if you want, and that'd wipe out the boilerplate but cost some safety / explicit error checking on the form data. 
The solution to problem 1 is simple, as you point out: &gt;Having the modal DOM element always exist but just be hidden. Since there should never be more than one modal displayed at any given time, I don't really see any conflicts. Regarding the second problem, Richard Feldman has a really good example that I believe solves your problem in an elegant way: https://github.com/rtfeldman/elm-spa-example
If you have an application with many modals, each of which requires their own javascript initialization function, then there is a conflict, no? I've seen the elm-spa-example, I don't recall there being any multi-page wizards / complicated modal dialog flows. Is there something I'm missing?
Do you have any examples of how you (or others) wrote this boilerplate? It seems to me that it requires registering onInput events for every form input, creating new message types for each such input, and handling those messages in the update. For a complicated wizard with dozens of inputs, this seems like a lot.
Seems like you see the picture -- all I can say is that it really isn't all that much, and you can (if you feel the need) make 1 Message, HandleForm String String, and make your onClicks be HandleForm "fieldname" and handle the msg with a Dict update. That's not bad but I haven't found myself doing this. Honestly, even though it's predictable code with lots of Msg types, I haven't ever had any problems with it, or found myself spending a lot of time on the boilerplate-y stuff.
As a mental model, the way the `view` is used is closer to an implicit subscription with the side-effect of rendering DOM (sort of like `WebSocket.listen tagger` has the side-effect of first opening a websocket connection). In other words, it's as if there were a function `listenForDomEvents : Html msg -&gt; Sub msg` which is automagically called with your `view model`. Now, given that `Html` isn't a monad (I'm not sure why it would be?), and subscriptions aren't monadic (they're part of the stream io interface through which your program talks to the outside world; which allows embedding monadic IO through `Task`s), requesting access to some underlying monad isn't that simple: it simply isn't there to begin with. In Elm 0.18, you do have 2 guarantees, tho: - view rendering is queued using `RequestAnimationFrame` - view rendering is queued _before_ effects are dispatched These, combined with the knowledge that `requestAnimationFrame` callbacks are executed in the order in which they were queued, imply that wrapping your `app.ports.foo.subscribe(..)` callback in `requestAnimationFrame` means the view will have rendered before your port's callback is actually executed. All this to say: you made the right choice, going for animation frame. I don't think of it as a delay as such: it's effectively queueing an action to happen after rendering the view.
You could always do code generation to handle all the boilerplate. That’s what we do at work. 
Thanks for the explanation. For what it's worth, I wasn't confused about the mechanics of `view`, and I know `Html` is not literally a monad. But even so, `Html.program`and co are essentially driving the sequencing of effects, e.g. driving a monad. So what I was asking about was, since we can't control the sequencing by driving the machine ourselves, what do we do about it? I think `requestAnimationFrame`, while nicer than an actual `setTimeout`, is still a bit of a hack. It would be better and probably less fragile to be able to control the sequencing directly. In particular, are the 2 guarantees that you mention about Elm 0.18 written down anywhere? Are the liable to be broken in future versions? For the record, since I view this as a little bit of a hack, I went with an all-javascript solution (similar to what was written in the referenced SO solution) as opposed to an elm solution like `elm-defer`, which, while clever, requires a bit more work. Thanks for taking the time to respond.
Thanks for the suggestion. I'm working on implementing something similar to what you suggest, but in a more type-safe way: if your form input state is a record `InputState`, make your message `HandleForm (InputState -&gt; InputState)`, e.g. the parameter is the function that updates the `InputState`. Then `update` just applies this function when it gets the message. These updater functions can be constructed with lenses, like `focus` or whatnot, if you want to get fancy.
I came to the same conclusion long time ago and here is an example: https://ellie-app.com/gNjS9T5rfa1/0. By the way, I think all "frameworks" that use virtual DOM have the same problem. 
Thanks! Right now I'm focussing on making more examples of how things can be done in WebGL with elm. I have not run into things that cannot be done yet, and the people on the #webgl slack channel are crazy helpful!
I mean I can't render the content editable in elm this way (semi pseudo code) : view : Model -&gt; Html Msg view model = div [] [ div [] [ text "Editor" ] , editor model ] editor : Model -&gt; Html Msg editor model = div [ contenteditable True ] [ div [] [ text model.title ] , div [] [ text model.body ] ] So I was wondering how are you rendering the thing ? 
From the RexPad code: Html.Keyed.node "div" [ Html.Attributes.class "editable", Html.Attributes.contenteditable True, ...] [...] Check the RexPad DOM tree with the browser development tools to see what is there. All is rendered through Elm.
cool! Thank you so much for the answers! Your editor works really well btw! Great job! 
&gt; interaction between rendering and ports &gt; FWIW I've chosen the animation frame delay for my own problem. ✅ That's the way to do it! &gt; There are two natural places to store this state: in the model and in the DOM elements themselves In Elm the natural place to store application state is definitely in the model! I recently ran into someone at a meetup who had built a similar "wizard" system like the one you're describing - for https://www.warbyparker.com/eligibility - and representing it in the `Model` turned out to be great because it meant he could do things like: * Rule out invalid states at compile time * Tell at compile time exactly what data has (and has not) been gathered so far at each state * Easily refactor any of the steps or transitions between them, with no fear that any data will be missing at the end of the path This is for sure the way I'd suggest modeling it! &gt; Let me be clear that I'm overall happy with Elm and hope my comments are taken as constructive criticism, or would be happy to be shown the error of my ways. It's all good! These are totally reasonable questions to ask. 😃 After a couple years of full-time Elm work, I've built things like these often enough to know the answers to these questions off the top of my head - (1) use `requestAnimationFrame` on the JS side, and (2) put application state in the model - but I remember that they took time to learn when I was starting out! Best of luck, and hope Elm continues to serve you well. ❤️
&gt; It seems to me that it requires registering onInput events for every form input, creating new message types for each such input, and handling those messages in the update. For a complicated wizard with dozens of inputs, this seems like a lot. I'd recommend doing that. 🙂 Forms remind me of SQL queries. As programmers we like to think "I shouldn't have to write all that by hand," and the inevitable result is things like ORMs and form builders. Every ORM and every form-building system I've every used, in every language, has ended up being a net negative for readability, maintainability, performance, and overall productivity. Productivity is the biggest one: they save me a few minutes up front, and then cost me an hour later when I inevitably need to implement something unusual that doesn't quite fit the mold of the way the ORM or form builder wants things done. The projects where I had the best time working with relational databases were the ones where we wrote SQL by hand from day one, and stored the results in plain vanilla data structures. The best times I've had working with forms were where I wired up the inputs by hand, so it was easy to customize and remained blindingly obvious how everything worked even after I had to make custom tweaks that were off the beaten path. My advice is to optimize for productivity over the 6 month period, not over the 6 day period, and write it by hand instead of doing anything fancy. YMMV, but that's my two cents. 🙂
I don't know whether it could apply to your case, but for my application, I decided to not use Elm's view. I'm using Elm worker and React Native, and using only either of the two as the view solves a lot of issues.
This! I am very happy to learn from this thread about using `requestAnimationFrame` in my port code. I was having the exact same problem as OP but I was using timeouts to solve it. But this is not a satisfactory solution because future changes to the runtime could break it. It would be far better if the runtime provided a function with the signature `delay : Cmd msg -&gt; Cmd msg` that would enqueue port commands after the view changes. Or maybe it could be handled over in the Javascript side with a the port subscribe function indicating that the callback should be enqueued and not called directly.
I don't agree with any of that. I mean, I don't have an opinion for elm specifically, but for python it doesn't apply. The django ORM (maligned as it is) is vastly superior to hand coding SQL because it composes very cleanly. As for forms, well I agree that all the ones I've seen before has sucked, because they can't handle customization beyond the trivial (and sometimes not even that). This is why we ended up writing our own form lib at work: https://github.com/TriOptima/tri.form which actually CAN handle arbitrary customization at all levels without boilerplate. We had to invent some new ways of thinking about how to call functions but we could do that in python :P We did/do have code that just does the copy paste thing for creating forms but that's a total mess because they don't do things like marking required fields and adding that feature after is impossible, because it's a copy paste horror show with hardcoded everything. 
``` app.ports.foo.subscribe(function (someId) { requestAnimationFrame(function () { // do whatever with `someId`, the view has rendered :) }); }); ``` 
&gt; for python it doesn't apply. The django ORM (maligned as it is) is vastly superior to hand coding SQL because it composes very cleanly. I haven't used Django specifically, but everyone said "it composes very cleanly" (sometimes with exactly those words!) about every other ORM I ever tried. Most recent one was ActiveRecord. All of them have been a convenience at the start of the project and increasingly a burden as the project grew over time. The point where the burden outweighed the convenience came after a few months. I don't know what Django is or isn't maligned for, but maybe it would be the one to finally change my mind. I've never worked on a Python back-end, so I can't really say. Like I said, YMMV, but I am personally in "fool me four times, shame on me" territory. 😉
Aside: for databases, I think *query* builders are great. If that's all Django does, then maybe I would indeed like it!
Source code is at https://github.com/vishaltelangre/elm-tic-tac-toe.
Very nice and clean code! Thanks for sharing.
That's pretty neat. I sent this to my mom, she's on a 1,000+ day run streak.
keep up the good work bud!
Thanks!
i'm glad to see i'm not the only one!
It's a little ironic that you're saying this because in a sense getting "closer to the metal" is exactly what i'm asking about, except not for SQL/ORMs, but for HTML and Elm. Like, I'm glad that `Html.program` encapsulates TEA best practices, but it seems like there could be times where it would be useful to be able to break out of the rigid sequencing and have more direct control, especially for things like Problem 2 above. In any case, it looks like I've converged to solutions which others recommend and seem reasonable, so perhaps this need for control is unwarranted. 
This is probably for the best. "Do one thing well" is a good motto to stick by.
[removed]
It pretty much is. At least the selection part. The code base I’m on is something like 15 years old with even some code left behind with manual SQL from before Django even existed publicly and that stuff, to the extent it’s still left, is a problem because it’s just a stringly typed mess to the side. 
As for form builders I also relate. I’ve checked out many form libs for Python and they all have the same problem you describe. Which is frustrating. Actually our form lib grew out of our table generator lib tri.table where the same problem exists. We developed our strategies for customization there and then wrote the form lib after because we needed the flexibility. These libs can accommodate customization like inserting a html attribute or changing the template for an entire row/cell/input/whatever with no boilerplate. 
I'm one of the people who would love to see multiple files support in Ellie but I will readily admit that the value of implementing this is quite small. It is a nice to have. :) 
Nice, I was looking for something like this a few weeks ago. I do get an error though when I try to run it: rake aborted! LoadError: cannot load such file -- standalone_migrations 
Basically, the 'UpdateAddress' input field is prefilled with the value from the input in the 'Register' step that has the same position as the 'UpdateAddress' input. If the input in the 'ChooseProperty' is the first line in the div, it will have the value of the first input in the 'Register' step etc.
I'm pretty sure this is to do with Elm determining the minimum necessary steps to get from DOM A to DOM B, which probably doesn't end up changing the value of the input... What if you try setting the value of the input to the model value so that they stay in sync?
That works, but this does seem like a bug to me.
I agree... I do definitely think it's a bug, but I kind of understand why it's happening, the part that sucks is it forces you to think about the implementation of the runtime, which we shouldn't have to
There are 2 ways to manage this: - make the statefulness of the DOM explicit by setting the `value` of each input to reflect the value you have in your model (https://ellie-app.com/rg6MGsRzHa1/0) - help the virtual-dom's differ implementation differentiate nodes that can't be reused by assigning keys to them using `Html.Keyed` (https://ellie-app.com/rdpXDGKsXa1/0) Both options come with tradeoffs: - Setting the `value`, in combination with the view being rendered asynchronously, means that if the user types fast enough (i.e. multiple keypresses within a single animationframe, ~16ms) the cursor may jump. - Using keys means you have to manually mark things as being "different" and need to take care not to accidentally reuse identifiers. However, it's worth noting that in 0.19, the first option should work properly as it will trigger synchronous rerenders after DOM-events. Long story short: it's a known behavior, which does come as a surprise. I feel calling it a bug is a bit strong as the code in the OP explicitly does _not_ manage the input's `value` property, meaning the DOM is allowed to manage that state. There is no way for Elm to recognize that, other than by telling Elm that these inputs are actually different things that can't be mixed.
I think the slowdown you were seeing was indeed related to `elm-reactor`, albeit indirectly: the debugger (which is loaded by default when using `elm-reactor`) records all messages and captures the state after each message. When dealing with animations that use `requestAnimationFrame`, that amounts to 60 such actions taking place per second. Especially when the state grows a little more complex, this can make your application lag.
Very much agree with this. What I'll add, is that in forms you'd typically be using a 'name' attribute to identify each field, so it's not far fetched to use that same idenitifer for the Html.Keyed node.
that standalone_migrations is if you want to use that for your database migrations, you can also just do it in haskell
Good point, however, if this situation is possible, there should at least be a compiler warning when you do not handle attributes that can cause situations like this one imo.
It is required in the rakefile, so every command you run requires it to be installed. That was my problem. Do you have an example how to use a database with persistent together with servant?
right, i was getting at if you aren't using it, you could take it out of the rakefile otherwise just `gem install standalone_migrations` Um, I don't have an example, but I use postgresql-simple in my project at work. https://hackage.haskell.org/package/postgresql-simple
Right, understood. Thanks, I will give it a try.
no problem, if you have any questions let me know.
This guy uses both mysql and postgres. He also uses haskell for his db migrations. https://github.com/Southern-Exposure-Seed-Exchange/southernexposure.com/tree/master/server/scripts
That is a real nice example of a servant app. Much appreciated
Nice and clean, but as an exercise, you might try improving your model. A benefit of Elm's type system is that by choosing the right data structure, you can avoid bugs by making it impossible to represent invalid states in the first place. Here, your representation of the board is a list of cells, where a cell is a coordinate, and the ownership. But this means that it's possible to have a Board with a cell owned by both players, a cell with no specification of the state, or a cell to be both owned and unowned. (Your code probably doesn't ever get in those states, but I can't be sure without spending time examining the code carefully -- that's one reason it's better to make it impossible in the first place.) So the exercise is: how can you change the model to make all those states impossible to represent? 
I don't think having functions in messages is a good idea, and I do not believe that using lenses ultimately leads to nicer code. It may produce slightly fewer lines in certain places, but the distinction between concise and cryptic code is very important IMO.
In addition to this, OP calls ALL view functions on each Msg. You definitely want to use lazy, lazy2 and lazy3. To OP: change the cell view to not accept the entire model, but just the cell. This way in your grid you use lazy when calling the cell view.
Sadly, This is hard to do because there is a valid use-case for not using the `value` attribute on an input form and no way for Elm to know that you don't intend those two inputs fields to be the same one. The problem is that the DOM holds state that Elm can't know about so for the virtualdom style development to work in the browser we just pretend that the DOM doesn't hold this state that we can't know about with various work arounds for the few times when we actually do care. You'll see React and other virtual-dom style libraries encounter the same issue and their solution is the same.
Yes, though the code doesn't allow it the model can have multiple cells pointing to the same CellLocation. I will try to address the cases you mentioned to make it impossible to represent the model with invalid states. Thanks a lot for reviewing it!
Thanks for this. Good to have such a real world project available as opensource :) I learned quite a few trick reading the source code. It seems this project does not use `servant-elm` though, which should be able to generate a wrapper for the Elm (FE) side, based on the API spec on the Haskell (BE) side. Like here in `servant-elm-template`: https://github.com/tlentz/servant-elm-template/blob/master/client/elm/Generated/ApiTypes.elm
Is seems `standalone_migrations` is just included but not used by this project at all. Right?
Right.
The problem is that ORMs map query results into canonical objects like User class instances. But this isn't trivial. Only in the most trivial app do you always return a canonical User (for example) in every query. But once you start limiting the projection or extending it, you either need multiple canonicalizations (like FullUser vs PartialUser) or your User class essentially is entirely nullable. Or you need ad-hoc structural typing per db function. What you see in most ORMs is that your canonical classes pretty much have all nullable properties which isn't much different than nullability errors with stringly typed access.
For our case it’s fine. Django allows you to select just some fields and then you get tipped back. Obviously this is Python so everything is technically billable all the time anyway :P In practice it’s not a big deal since we run all our installed instances in house. But if I worked on code that was shipped to a customer I’d be singing a different tune. In fact that’s why we’re going for Elm on the front end because that IS shipping code, albeit only to the browser. 
If you wanted to make the other player computer controlled you could use this search library to implement it: http://package.elm-lang.org/packages/the-sett/ai-search/latest Although, that does not have a minimax algorithm in it yet: https://en.wikipedia.org/wiki/Minimax
Do I need to use JWT and the servant "Generalized Authentication"? 
Thanks. I was thinking about to add an ability to play against the computer. I will see if I can use the `the-sett/ai-search`package if possible.
Can you please take another look at the model now? I changed the board to use Dict instead of a List of CellLocation.
I'm working on a clone of Typeform. Someone has already done it with Tellform (using angular1). I'm using tachyons for most of the styling and I'm probably going to go with Phoenix for backend data (if I get that far). Hope to make a blog series about it to share in the future! 
I agree this is a good reason not to include it, but mostly I use Ellie to prototype an idea or start a beginner off so they don't have to install the elm environment. 
I have a bunch of things going this week around Elm * Starting an **Elm In the Enterprise** whitepaper * Setting up a talk on Elm to be given later in the month in Amsterdam * Building a short video course on Scaling Elm Apps * More videos on [Pain-Free Web Development - YouTube](https://www.youtube.com/c/PainFreeWebDevelopment) Plus some Erlang for somewhere
Hey man! What the advantage of Haskell above Phoenix as a Backend server? I'm just curious right now, because I'm using Phoenix + React, but looking forward to use Elm + some backend tech soon in my next projects.
The syntax is similar to elm and if you use servant-elm, all your elm types can be generated from your haskell types so you don't have to write encoders, decoders, or your types twice.
If seems you need a back-end language as well. Elm is not suited for that. Haskell comes to mind (more Elm-like, integrates well with forinstance `servant-elm`), maybe together with python. Or write all of the backend in Python (it has a lot of good libs for data science). Or Julia/R/Fortran. Even though Elm is a great tool for FE, and your project may largely be a front-end project, I still would encourage you to spend at least as much time on picking your tools for the BE (where I suppose the number crunching will happen).
Yeah, I'm pretty certain I will have to settle for java on that... Haskell or clojure would be a dream but I don't think I can sell that. :( The heavier lifting for the analysis will be done in the BE, but I suppose that the simpler tools like linear regression can be done directly in the FE as well - then again, we will have to find out. So, I take it that tool wise etc. you think that Elm is sufficient? 
I'm working on a interactive binary decoder. A somewhat old and very work-in-progress demo can be found here: https://s3.amazonaws.com/interactive-binary-decoder/index.html At the bottom of the page are buttons for the different types that can be decoded, and you "paint" them on onto the bytes, seeing the decoded value as you do. Decoding U64 is currently broken because there is no way to natively decode 8 bytes into an int value in javascript. The need for this arose as I was attempting to reverse engineer a binary protocol, and I realized no good tools to my knowledge exist for doing something like this. Also, it seems like it could be a cool feature to add to my NES debugger, which I posted here last week:https://youtu.be/YC2FvozglPc
When I and SpankTrain's team were deciding backends we looked at Pheonix but we hated all the boilerplate involved. Basically, you either write your types once or twice in 2 different languages.
Like you mentioned yourself it seems that a graphing library is essential to your project. Better check out available solutions for yourself. I think if there aren't any and you're going to write lots of native code or ports your colleagues will be pissed, especially if they aren't really interested in the benefits Elm can provide.
I have experience doing something kinda similar. One particular issue that I ran into was efficiently transmitting binary data to the Elm client and interpreting it. The naive and very inefficient approach is to serialize bytes into a JSON array of ints. This is easily supported in Elm, but depending on how many bytes your sending over the wire, is inefficient in a lot of different ways. I ended up writing a native module to accommodate this, which kinda negates some of the "niceness" of Elm (I also had an intermediate solution where I packed 4 bytes into each int of the JSON array and teased them out in Elm). Anyway, the answer is "If you don't require the use of native browser APIs that aren't supported via an official package, it should be a good fit." It can still be well-suited even if you need to drop into ports or write native code, but the latter is not documented at all. 
For problem 1 I think the cleanest (but maybe not practical yet) solution you can use is [Web Components](https://www.webcomponents.org/). That way, Elm doesn't need to know anything at all about "initializing modals". /u/rtfeldman has [a great talk about using them in Elm](https://www.youtube.com/watch?v=ar3TakwE8o0).
Video linked by /u/lone-scientist: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Elm and Web Components - Richard Feldman](https://youtube.com/watch?v=ar3TakwE8o0)|React Vienna|2016-12-05|0:24:38|126+ (100%)|6,024 --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/lone-scientist ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=doi649g\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v2.0.0
&gt; you think that Elm is sufficient? For your front-end: yes. 
&gt;Yeah, I'm pretty certain I will have to settle for java Try at least Kotlin. It's a better Java made by Jetbrains (so top notch IDE support) and it's fully interropable with Java and easy to pick up by a Java user.
Unless there's a web component that does the job.
Thanks for the pointer! That looks like a great solution.
A great thing about Elm is that it reduces stupid politics. There's no conflict over formatting, whatever comes out of elm-format is the right format. No fight over which framework you use. Etc. That saves a lot of sanity.
&gt; Try at least Kotlin. Wanted to say this, but did not dare to.
We appreciate the work you've put in here!
Since you listed elm-css, have a look at styled components and the elm port: https://github.com/styled-components/elm-styled It's honestly amazing, I wouldn't fantom to go back to anything else for styles (less, sass, elm-css, you name it). I used it in react before, and the elm type system and and pure functions take the concept to the next level. It's pretty much a perfect fit.
I just started using style-elements. I don't have a lot of CSS experience and it's been a joy to work with. Easy to get started and easy to do all of the basics. I've only encountered one roadblock (absolute styling) and I was helped out by going to the respective Slack channel.
Looking forward to using https://github.com/tesk9/accessible-html 
Related to / following up on `elm-mdl` is the in-progress (AFAICT) https://github.com/aforemny/elm-mdc
Didn't know there was a package for tachyons! I would highly recommend trying it (the css, not sure about the elm package but I'm sure it's great), it works great for views / components (React) and is the most component I've ever felt with CSS. Just tack on some classes and you're good!
That demo is pretty cool!
What do you use to install elm-styled, given that it has native code?
https://github.com/gdotdesign/elm-github-install https://github.com/panosoft/elm-grove
I absolutely love tachyons as well! I'm so much more productive with it. However I'm working on a project with elm-tachyons and I'm considering ditching it. Don't get me wrong it does exactly what it's supposed to, it adds auto completion to my editor, but that's the only benefit I get. The downside is a bigger build file and a bit more verbose view code. Definitely not trying to dissuade you from using it, just sharing my experience so far. 
That tool was released relatively recently. What were you using before its release?
There's the elm-plot library that I've been eyeing for my next visualization project. Maybe look into that. Besides other benefits that you and others have listed, the Elm type system is great at modeling complex objects declaratively, yet still simple. The compiler has your back for development and refactoring, which (besides purescript) none of the popular FE frameworks have. The package system also has garuntees about their versoning which will save headaches later (compared to using npm with browserify/webpack) 
`elm-github-install` was released over a year ago. Before it, people would either have to copy&amp;paste and modify the JS files or manually install it in elm-packages by manually doing what elm-github-install is doing. 
Thanks. 
[Here is the Counter example adapted to the inversion of control pattern.](https://ellie-app.com/p5ghy3rpCa1/0) The `Config msg` record acts as the interface. You can also view the use of higher order functions as being a form of inversion of control. The signature of the function acts as the interface. 
For visualization (graphs?) you could use c3.js through ports.http://c3js.org
To add to @jediknight's answer, one pattern I have had to accomplish "local-ish" state is to have things saved in a `Dict` and then have a default when the id (I used position in the list of the div) isn't found, same goes for updating the state. This allows the view to drive the state to some degree. In my case, I had a bunch of accordion dropdowns (all or none could be open) that each needed to have their visibility status (Visible or Hidden) to be saved in the model but didn't really need/want to have their HTML saved in the model. Not sure if that makes sense. I've been meaning to write a blog post about this pattern. Not sure if that's what you want though. I think @jediknight's answer probably answers your question better. 
I think the more direct question to ask is: how do you write maintainable Elm code at scale? (My answer: https://youtu.be/DoA4Txr4GUs)
Much better! This is exactly the kind of thing I was thinking of.
As of today Elm seems like the wrong thing. Python on the other hand absolutely crushes in the scientific field. Look at bokeh for interactive plots and numpy etc is unparalleled. Jypiter notebooks is the goto solution for interactively interacting with data of course, but you said you didn't want the users to write any code... If you do use Elm, be prepared to do a lot of work yourselves, that you would have gotten for free with python.
One down vote with zero reads on medium... heh
Just ran into this, don't know much about it other than the README: https://github.com/elm-bodybuilder/elegant
I'm guessing the author is _starting to get it_ but still doesn't totally _get it_.
First, I'm glad that people are trying Elm in production and posting their findings. The "*major language issues*" is however puzzling to me. They seam to stem from the fact that the author is not using type annotation enough. Weird errors are all but unavoidable when you don't provide the compiler enough information. It is like you are expecting the compiler to read your mind. :) I usually avoid expoing functions that are not properly annotated. Regarding positional arguments, I wonder if the author has another language in mind that does this better. 
Just a list of things the author didn't like or understand. Didn't tell me anything really about the experience of using Elm in production.
I'd be fine if the author _never_ gets it. Articles like this that are nothing but whiney complaints are hostile to the community.
Not to mention that you could make a type class for tuples of the arguments you wanted and get the equivalent of java or C++ default args or do the same with records to get keyword args like in python or a combo to get args and keyword args... I don't think this guy has done much type based programming, which is fine but its worth learning before you write something on medium
Maybe if you read the article? I have many constructive suggestions in there. 
This is a complaint article by someone who hasn't given themselves time to learn to THINK in Elm. This kind of list is common when you first start a language. It takes a good year of coding every day before you can think in a new language.
Did you read it fully? Because I wrote quite clearly that I use type annotations not just on 100% of all functions but I often also add extra, ostensibly unnecessary, let declarations with type information just to get the error messages closer to the problem. I don’t see how I could possibly provide even more type annotations than 100% of functions, tiny functions AND sub expressions. I’m open to ideas though. 
Expand what you mean by type classes. I don’t see how it relates to functions. Do you mean having all your functions just take one argument all the time in the form of a record, and how would you then create a record with default arguments? I mean, without massive code duplication obviously. 
Well, “in production” here means more “writing non-trivial code” I agree. But “Elm first impressions” was already the title of another post in this Reddit and I felt that reusing the title wasn’t very nice :P I’m open to another title if you have a suggestion. And please be constructive. What didn’t I understand do you think?
Can you be more specific? Maybe point to something I can read to learn? Or talks or something...
Many of the things on the list aren’t that though. I agree that my dislike of currying probably falls into that umbrella but it’s also something that I was surprised at hitting often. I think it’s important to point out problems of newbies and not just ignore them off handedly like you just did. In fact I think Elm succeeds exactly because Evan has more respect for this than what you just showed. 
I think some of the response you're getting is simply from the organization of the article. When I was reading it, it seemed like you didn't like Elm at all, but then at the end you emphasized some things you really like about it. It's possible that many people stopped reading before finishing the article and never saw what you liked about Elm. It might be more effective to start with what you like, then list the things you wish were different, and finish with your overall impression of the language as a whole. Don't worry, though. Keep it up. :)
I am currently leaning in the direction of answering your question like this: Type variables and partial record type signatures allow for a kind of "dependency inversion at the function level." This is a position I am still in the process of refining. https://medium.com/@matthew.buscemi/high-level-dependency-strategies-in-elm-1135ec877d49
This is me feeling somewhat silly, but the last time I actually made web application that managed users, it was in 2003 and I was using PHP. I kind of want to move on from that. So... how the heck do I make a login page that sets a user session? This doesn't seem like it should be difficult but I can't find mention of it in docs, and my memory basically ends at "something something session cookie something PHP magic". I did find https://github.com/elm-lang/cookie but it just says "you want to use the local-storage or session-storage packages instead" and neither of those appear to exist."
It's missing elm-ui, a UI components library to web apps.
Whats elegant ?? Whats the purpose of this package?? Reading the README, it seems explain more about BodyBuilder than Elegant.
You can use a type class to relate a group of types with a function (which can be called with any of those types but that has different implementations). This means you can say that (a,b) can be the first argument of one of those implementations and have another that takes just a. Then the other can provide a default argument (or do something completely different) and tada you have two functions with the same name. They're super useful though I think they're probably more usable in Haskell (unless elm has got rankNtypes now). I am trying to be civil. I meant no disrespect in saying that the author was inexperienced with type classes and I'd like to apologize for my incivility.
&gt; Currying is annoying. Here we have currying in JavaScript, which I have to write all the time: foo.bind(this, "bar") And in Elm: foo "bar" If you had the same mindset that I did, you would welcome this syntax rather than suggest a specific operator for currying. This is one example. There are more, especially when we read your first article. I would love to write more about this because it's fascinating, but I have to take the kids to the park.
I'm working on a `Quill.Delta` module that allows decoding and rendering [Quill deltas](https://quilljs.com/docs/delta/).
I have seen your posts on /r/elm for quite some time now. For many months at least. I remember your user name specifically because it tends to appear in threads that have a notable level of miscommunication and misunderstanding. It sounds like this is not intentional on your part, but it seems to happen nonetheless. I have created some [rules](https://github.com/elm-lang/forum-rules/blob/master/README.md) to help moderators handle cases like this, where it is confusing how to prioritize everybody's needs, especially when everyone has good intentions.
This mirrors a lot of my experience of elm in production. It is great, truly the best tool for the job, but there are some sharp edges: * Absolutely JSON decoders. * A few missing API functions, or things that aren't exported and should be. * The worst errors I get now are due to ACCIDENTAL partial function application, just like this article numerates. * The syntax documentation is indeed missing 25% of the syntax.
I don't mind it. It's like being a Democrat who want to know what the Republicans are thinking.
I actually don't think these kinds of articles are dangerous to the community. I *do* think the kind of negativity this person is getting in response to the article is bad for the community and presents Elm users as hostile to any criticism.
Here's another one. &gt; Using the type inference instead of explicitly typing all functions... Leaning on type inference would initially seem beneficial because the compiler _can_ infer, so make the machine do more of the work because it's a machine and we don't care about its feelings. Usually I agree with anyone on that last point, but in the case of what amounts to inline documentation I argue for the feelings of future readers of your code. Elm does two things very well in this regard. 1. It does not require you to specify the type of everything, as you pointed out, unlike Java for example. This is especially helpful in let...in statements where you don't feel the express need to document the types of transient inner thingies that are not exposed to other users of your codez. In those situations you can blast out some code with or without type annotations just to get to that sweet sweet return value at the end of the function. 2. When you do use type annotations, they don't clutter up the place. Compare this to TypeScript where type annotations inflate your code horizontally. The simple choice to make type annotations appear above functions has significant readability benefits. Finally, that type annotation acts as a sort of assertion for the compiler. When you write your function, write the type annotation first. Then the compiler won't let your off the hook until your function honors its arguments as expected and returns the thing it claims. This is semi-related to your quote: &gt; ...it’s annoying to not be able to assert at compile time... but regarding what follows in that sentence: &gt; ...that certain invariants are true, like list constants having the same length... Elm the language may not have an answer for, but a coding paradigm may be able to help you with. For that, I direct you to this youtube video, [Making Impossible States Impossible](https://www.youtube.com/watch?v=IcgmSRJHu_8&amp;t=5s).
This doesn't really explain why someone would want to curry in the first place. "*Callbacks*" In React often times I want to pass a function to a component/element with some default arguments, either I have to do this: &lt;div onClick={() =&gt; this.getPost(id)} /&gt; in Elm this isn't needed so I can just do this div [onClick (getPost id)] [] Is that needed? No. However, I find it nice. It's also nice for making customized functions like so: doubleList = List.map ((*) 2) doubleList [1,2,3] -- returns [2,4,6] sum = List.foldl (+) 0 sum [1,2,3] -- returns: 6 Often times when I'm writing code for my people that aren't used to this, I avoid it because it can cause confusion. 
In React we have instead done: &lt;div onClick={this.getPost.bind(this, id)} /&gt; Maybe we should just be using an arrow function there. Derp!
Be aware of some drawbacks https://www.reddit.com/r/elm/comments/6scicd/what_are_elm_pitfalls/
On another note, if that sum function had the type annotation, sum : List number -&gt; number it wouldn't cause as much confusion. 
I feel that the author wrote this post as an endorsement to Elm but people read it as a negative one and strong reactions ensued. This probably surprised the author even more, which we can see in his responses. I have not contributed anything to the Elm Community so I cannot suggest this community should do but I have generally found engaging in dismissive remarks usually helps no one -- imagine some Elm newbie reading threads where people are dismissive and what will they think? Will they want to explore the language if they worry the community is going to be dismissive of their ignorance too? With that out of the way, here is what I took away from the article. I have tiny experience with Elm and less than intermediate-level Haskell knowledge so take it for what it is worth. 1. 'No run-time errors' is awesome 2. JSON Boilerplate -- I tend to agree with this one. Maybe people who have done a lot of Elm work may feel differently but coming from Haskell, being able to say `instance FromJSON SomeDataType where parseJSON = genericParseJSON defaultOptions { fieldLabelModifier = titleCaseToDelim '_' }` is just pretty sweet. 3. I don't know the general sentiment here about JSON coding/decoding but it cannot be 'if you want something like that, just use Haskell'. I don't think we need `Generics` or anything like that.. If there is a simple tool like `elm-format` for JSON, it probably will be just fine and solve most of the boilerplate. The author's own tool seems useful but probably not not as nicely integrated as something like `elm-format`. This does not have to be a language problem. 4. Currying and type errors: I think anyone who spends enough time in compiled languages (similar to Haskell) will not worry about this at all -- you will be able to quickly spot why the type error happened. So I would say the author just needs to give it some time. 5. Type inference: I always annotate everything and if I don't, I am not going to get helpful error messages. Over time you learn that figure out the types for the function is just as important as the code so you write them out first. Tiny functions usually don't require much attention as they are supposed to be small and type errors there are easy to spot. 6. Positional arguments: I have never had any issues with this one and if I have more than 3-4 args, I probably need to refactor my code. As noted by others, you can also easily solve this problem by moving to a record and use it as a single arg. 7. Reusing GUI: This has been my concern as well but I have not faced the issue yet so I cannot complain about it until it is really a problem. I have read this (https://guide.elm-lang.org/reuse/) and I think it is a reasonable solution but need to work on a large scale project to really understand whether the concern is warranted. 8. Missing functions: This may be so. Generally in Haskell, whenever I have `fromMaybe` (Elm's `withDefault`), I always worry that I am doing something wrong. I check my code a few times to see if I can avoid it. So a thing to check will be, if `withDefault` has to be invoked so many times, may be the downstream code should be changed? Why worked with `""` when you could be using `Nothing`? 9. Simpler `map`, etc: This is not something I love about Elm too. I know mention of Typeclasses leads to unproductive debates. That said, I think I will be ok with a slightly more verbose syntax for the benefit of safer code. Although I will gladly take a generic map / filter :) 
And maybe read my best practices https://gist.github.com/rofrol/fd46e9570728193fddcc234094a0bd99
After rereading the list I stand by my original assessment. After a year, I'd love to hear if you still agree with the shortcomings you wrote about. I suspect you won't with many of them. Like the list comprehensions. Especially after you get used to writing your code differently, i.e. using |&gt;. 
A lot of folks are frustrated by having to write JSON decoders. **First**, I think the idea of generating JSON decoders is based on an incomplete view of data interchange formats. I do not think the historical examples support the theory that generating the code in Elm is the right answer, so I wrote about this extensively in my post. Please read it through! **Second**, I have observed that decoders make more sense if you learn them in the right order. Specifically, learning about `Maybe`, then about `Result`, then about `Decoder` gives more scaffolding to the necessary concepts. That ordering exists in the guide, but many folks prefer to learn through playing with code. Right now the compiler just yells at you, but my dev branch will instead detect type mismatches that involve the `Decoder` type and gives a link to documentation aimed at helping folks new to these concepts. Without that error message, I suspect folks end up wasting hours or days stuck at this exact moment. I suspect that also explains the fervor that people have at first, and how it tends to reverse later on. My theory is that having better error messages will help with the learning curve and could even point folks to the broader vision outlined in my post. **Finally**, I think it makes sense to explore points (1) and (2) fully before deciding that the language should be more complicated. I understand that not everyone agrees with this kind of conservative strategy, but I think it has served Elm very well so far and do not want to give up on it.
&gt; For some reason we think JSON is a thing that is fine. It is not a great choice on basically every metric that matters to building reliable, efficient, and flexible applications. My view is that JSON is perfect for and should only ever be used as data-interchange-format from/to external 3rd-party systems. Not between your/your systems' individual services/apps under own control (protobuf etc advisable). Not as ad-hoc databases. Not for config files. JSON feels as sucky as XML nowadays because it's abused for *everything* rather than the one applicable use where it shines. Reasons being of course the abundance of fast decoders in virtually every (other, cough :) language (in Go you just write out a record type and that becomes "the JSON schema to unmarshal-into", in JS of course it's even simpler). Anyway, projects that want to interface with "the messy real world" in ways that their users desire, expect or appreciate are going to continue looking for "a good decode story". Surely someone has written a simple Elm module-code-generator that operates from a given JSON or JSON Schema Definition file? Some things can and should be furnished by "a healthy and growing ecosystem", not necessarily the core-language / core-libs team. &gt; I think the idea of generating JSON decoders is based on an incomplete view of data interchange formats That may or may not be true for each individual case, but when ya gotta the job done, ye gotta get the job done =) 
Good writeup! I see decoders as a non-trivial part of my codebase: Making them strict has the advantage that I eliminate certain possibilities I would later have to handle somewhere else, making them more “optional” might need to react to missing values in some ways. I think some of the frustrations are based on the fact that elm is the first language for some people that requires this explicitness in the form of decoders. I had to write them before for Go and I miss writing them whenever something “deep inside” our js-code breaks because a certain structure was just assumed but never enforced up until that point. That said, should the docs have links about how to generate code in popular formats in popular languages?
I hope people will look more into things like "JSON Schema" where you now have a `.format` file for JSON. Some of the strengths of other interchange formats can be achieved even when you stick with JSON as the format for whatever reason.
Thanks for the article, here's my 2 cents. &gt; Currying is annoying Currying is essential to a lot of things and once you learn to use it, it can save you a lot verbosity. The fact that it's not explicit is good, because everything can be curried, so once again, if it was explicit it would just be more verbose. Furthermore, when you really internalize the fact that everything can be curried, you will rarely run into a situation where you'll be surprised by it. &gt; type errors instead of compiler errors Type errors are also compiler errors. &gt; Using the type inference instead of explicitly typing all functions often leads to hard to understand errors far from the place where I made a mistake. The best advice here is always type annotate anything that is exposed. Type annotation is your documentation verifiable by the compiler, which is really powerful. &gt; Positional arguments are a bad default in all languages, and the total lack of keyword arguments is even worse. Your experience will differ when you get more experience with ML-based languages :) You can trust people who say so on this. &gt; Lots of boilerplate Elm could have less boilerplate for the price of learnability, I think that's a good trade-off for now, at least until the adpotion and education in pure FP improves. Besides, when you compare the amount of boilerplate with a lot other languages, it is really not that bad. If anything, Elm can be more concise than most. &gt; Json decoders/encoders... From my own experience, you will learn how to write these very quickly the more you use them. I do use Pipeline and never had any issue with positional arguments. Besides, the fact that it makes you think about how you communicate with the outside world is a good border protection. &gt; I do miss some kind of compile time logic thing What exactly do you mean by "compile logic thing"? There are lots of compile logic things already :) &gt; like list constants having the same length I'd recommend having a look at LiquidHaskell for such things. In Elm your best option would be to write test, looks at *elm-community/elm-test* package. Except.equals lengthA lengthB Not that hard :) &gt; case blocks having at least the same number of cases as a union type Compiler already does this, unless you put in a hole that eats everything (underscore). &gt; Reusing GUI elements is not so nice. We haven’t resorted to effect managers yet, but instead we’ve ended up with the model-update-msg triple (in some places) that we’ve been warned against many times. You're probably craving component based GUI, but that's not the Elm way, because components imply hidden internal states, eternal source of bugs. Instead, Elm is better suited for function based GUI. In fact, any design pattern you might have learned in OOP or anywhere else is usually just function in ML-based langs. I'd recommend you watch this talk from creator Elm himself: https://www.youtube.com/watch?v=jl1tGiUiTtI &gt; evancz/url-parse UrlParser.elm doesn’t expose parseParams and toKeyValuePair, trying to force you to use a very complex parser API even for simple things The API is actually very simple by design once you learn to use it. Anyway, if you see something you don't like, create issue or PR against the repo, it's all open source, but first I'd recommend to ask questions (e.g. on Slack), that might clarify some of the misunderstandings you appear to have. &gt; No support for trailing commas creates silly looking code with commas in front of lines. What is silly looking is just a matter of perspective, I for one love it, it goes really well with my spacemacs/vim setup, just stop worring about manually formatting your code and use *elm-format*. Consistency ftw. &gt; Dict.getWithDefault is missing. It's not missing, it's just too trivial and the API is cleaner that way. Once again, if you think you know better, go ahead and submit PR : &gt; No constants in case expressions. case "no constants?" of "no constants?" -&gt; "says who?" _ -&gt; "meh" In fact, you can do much more than that in case expressions. Hope that helps.
I agree we should not bake JSON generators directly into the language at this time until interchange formats are explored properly. That said, people are using Elm today with legacy backend solutions I think helping people become a bit more productive with JSON Decoders today should not hurt the overall language development and can help with adoption. In my experience most encoders and decoders are written in a mind-numbing way. So why not help automate that part with some tools? Maybe it can be similar to `elm-format` where, on save, you get updated encoders / decoders or even Webpack type solution which takes care of it before build time. Golang use of tags for JSON is a decent option too but that requires language support, which I am not sure is worth it at this time. 
&gt; First, I think the idea of generating JSON decoders is based on an incomplete view of data interchange formats. Reading the documentation gives the impression that JSON is the officially endorsed way to go in Elm. I tried to find a a way to do GraphQL in Elm but nothing seems to be production quality today.
Massively agree with this. I love Elm, but I think it's useful to have dissenting voices as well as super-enthusiastic ones. I think u/kankyo does a service to the community in expressing opinions and ideas in a fairly balanced way, even if I don't agree with all of them. If some of those opinions are misguided, then it shows the community that we have more work to do to explain what the design decisions and trade-offs are, and why we believe the Elm way is the best way. For one thing, I see Evan has just published an interesting post on JSON and code generation and why he doesn't think it's a good idea. If u/kankyo hadn't raised the idea of code generation several times over the past few months, perhaps Evan might not have been spurred to clarify his position on this and the community would be none the wiser?
Massively agree with this. I love Elm, but I think it's useful to have dissenting voices as well as super-enthusiastic ones. I think u/kankyo does a service to the community in expressing opinions and ideas in a fairly balanced way, even if I don't agree with all of them. If some of those opinions are misguided, then it shows the community that we have more work to do to explain what the design decisions and trade-offs are, and why we believe the Elm way is the best way. For one thing, I see Evan has just published an interesting post on JSON and code generation and why he doesn't think it's a good idea. If u/kankyo hadn't raised the idea of code generation several times over the past few months, perhaps Evan might not have been spurred to clarify his position on this and the community would be none the wiser?
Massively agree with this. I love Elm, but I think it's useful to have dissenting voices as well as super-enthusiastic ones. I think u/kankyo does a service to the community in expressing opinions and ideas in a fairly balanced way, even if I don't agree with all of them. If some of those opinions are misguided, then it shows the community that we have more work to do to explain what the design decisions and trade-offs are, and why we believe the Elm way is the best way. For one thing, I see Evan has just published an interesting post on JSON and code generation and why he doesn't think it's a good idea. If u/kankyo hadn't raised the idea of code generation several times over the past few months, perhaps Evan might not have been spurred to clarify his position on this and the community would be none the wiser?
Massively agree with this. I love Elm, but I think it's useful to have dissenting voices as well as super-enthusiastic ones. I think u/kankyo does a service to the community in expressing opinions and ideas in a fairly balanced way, even if I don't agree with all of them. If some of those opinions are misguided, then it shows the community that we have more work to do to explain what the design decisions and trade-offs are, and why we believe the Elm way is the best way. For one thing, I see Evan has just published an interesting post on JSON and code generation and why he doesn't think it's a good idea. If u/kankyo hadn't raised the idea of code generation several times over the past few months, perhaps Evan might not have been spurred to clarify his position on this and the community would be none the wiser?
Massively agree with this. I love Elm, but I think it's useful to have dissenting voices as well as super-enthusiastic ones. I think u/kankyo does a service to the community in expressing opinions and ideas in a fairly balanced way, even if I don't agree with all of them. If some of those opinions are misguided, then it shows the community that we have more work to do to explain what the design decisions and trade-offs are, and why we believe the Elm way is the best way. For one thing, I see Evan has just published an interesting post on JSON and code generation and why he doesn't think it's a good idea. If u/kankyo hadn't raised the idea of code generation several times over the past few months, perhaps Evan might not have been spurred to clarify his position on this and the community would be none the wiser?
Massively agree with this. I love Elm, but I think it's useful to have dissenting voices as well as super-enthusiastic ones. I think u/kankyo does a service to the community in expressing opinions and ideas in a fairly balanced way, even if I don't agree with all of them. If some of those opinions are misguided, then it shows the community that we have more work to do to explain what the design decisions and trade-offs are, and why we believe the Elm way is the best way. For one thing, I see Evan has just published an interesting post on JSON and code generation and why he doesn't think it's a good idea. If u/kankyo hadn't raised the idea of code generation several times over the past few months, perhaps Evan might not have been spurred to clarify his position on this and the community would be none the wiser?
Thank you, that's pretty insightful.
Oh that's a great idea, thanks!
Very true :)
&gt; currying People keep just repeating that argument but I don’t find it convincing. Explicit is better than implicit. But as I wrote in the article: it could probably be remedied by syntax highlighting. &gt; type errors are compiler errors Oops. Yea that was sloppy writing on my part. I meant an written mismatch error. &gt; always type everything that is exposed That’s the advice yes but I think that is way too little explicit typing for a nice development experience. &gt; json decoders [..] I never have problems There are several articles on this subreddit about using fuzzing to test these against the type of errors that happen because of the problems I pointed out. This seems quite obviously stupid to me. Fuzzing to make sure your arguments are in order is absurd quite frankly. &gt;&gt; list having the same length [AS A UNION TYPE] &gt; [use tests to assert length] Wow. You just cut off that sentence. I’ve put back the relevant part so it’s obvious again why you just talked about something unrelated. &gt; case blocks No they don’t do this. Only in one case: where the cases are on the matching side. That doesn’t cover parsers, only serializers. &gt; [no components] That’s the wrong talk. You should have linked to “scaling Elm” by Richard Feldman. In any case I’ve watched both. The latter many times in fact. Still doesn’t help for all cases. &gt; Dict.getWithDefault [too trivial] That’s not how to make a nice to use language. WithDefault is also trivial. Why is that included? &gt; no constants in case That’s a literal, not a constant. But yea literals are constants in a way. I didn’t want to write a long piece of text for something that the reader could surely figure out from the one sentence. I guess I was wrong. I will update the article when I get time. 
You guys do know that generating decoders for trivial structures (the majority of the use cases) is implemented for ports and it's just not exposed in any meaningful way. :)
It seems that it collects the styles defined on DOM elements and puts them in a CSS file.
Second link from the top?
My issue with JSON decoders is that **I'm forced** to write them. I am being asked to do something that an algorithm does better and more reliably in maybe 80% of the cases. **Elm already can generate adequate decoders and encoders for ports.** Why not have the same algorithms automatically generate decoders and encoders for certain constrained types? The language does not need to get anymore complicated in order to accomplish this. A mechanism for automatic generation of the serialization code would also be useful in the case where something other than JSON is wanted. If I don't write the serialization code and instead I use a serializer, I can serialize to Cap’n Proto, edn, protobuf, xml... whatever. The main idea is that the serialization information is already present in the types of the objects being serialized and being forced to manually write the same information is an error prone, frustrating process. Now, there is, of course, the case where one needs to deal with very weirdly formatted data and libraries that allow for a more fine grained decoding/encoding of information are useful, but the use of these libraries should be the exception, not the norm. 
What API functions do you find missing?
Considering I use |&gt; all the time, explicit currying would be quite annoying. I also don't see why `Dict.getWithDefault key default dict` Would be better than `Maybe.WithDefault "default" &lt;| Dict.get key dict` (see, nice currying). Functional composition for the win =)
&gt; People keep just repeating that argument but I don’t find it convincing. **Explicit is better than implicit.** &gt; ... but I think that is way too little explicit typing You just answered yourself :)
&gt; Currying and type errors: I think anyone who spends enough time in compiled languages (similar to Haskell) will not worry about this at all -- you will be able to quickly spot why the type error happened. So I would say the author just needs to give it some time. Apart from it maybe not being feasible to implement, what do you think of the author's solution to this problem (the `partial` keyword). I kind of like it in the "Elm should be easy for new comers" context (I've been intimidated by errors due to simple currying mistakes in Haskell myself)
I’ve been using GraphQl extensively in my Elm app (including live queries) and very happy so far. Json encoders/decoders still in use because that’s how requests/responses are serialized for the backend (absinthe) — requests are graphql strings under a “payload” Json key, and responses are pure Json. Essentially everything on the decoder side is a “maybe” because the response payloads can and will be anything. 
Well said. Let's not forget that u/kankyo writes about using Elm in production, which is a great thing in and of it self. :)
&gt; Considering I use |&gt; all the time, explicit currying would be quite annoying. Good point.
It would be nice to have a `.format` file of some form that could then be compiled to Elm, Erlang, Elixir, Haskell, Ruby etc. I don't think this would require changes in Elm itself. It would also be nice if one decoder could somehow speak ProtoBuff and JSON (I don't know if that is possible) and that the request could use HTTP Content Negotiation to tell the other side what options it could send in. 
Private message from banned OP for posterity: &gt; Here we have currying in JavaScript, which I have to write all the time: foo.bind(this, "bar"). And in Elm: foo "bar" The first isn't actually currying, it's partial application. Currying is where you get automatic partial evaluation just by supplying too few parameters. &gt; If you had the same mindset that I did, you would welcome this syntax rather than suggest a specific operator for currying. Again, see above about the difference between partial evaluation and currying, but an operator wasn't the only suggestion. One was simply syntax highlighting. I am basically saying that invisible partial application is bad. Not that it's bad that is has nice short syntax. My response: Now that I think about it, that would make currying in JS a chain of arrow functions, or calling a higher order function. About the proposed operator though, I maintain my support of the status quo. One of the arguments against using Elm is that it's a new language. My counter-argument is that it's a small language and therefore can be learned quickly. Every language-specific operator that gets added increases its size and idiosyncrasy.
/u/kankyo is banned now.
but I thought the author thinks that [elm is wrong!](http://reasonablypolymorphic.com/blog/elm-is-wrong) and he [rejects it!](https://hackernoon.com/a-small-dive-into-and-rejection-of-elm-8217fd5da235). Am I mixing something up?
A good number of my projects end up needing the "Extra" libraries for one or two functions, especially http://package.elm-lang.org/packages/elm-community/list-extra/6.1.0/List-Extra Date used to not expose all of its constants so it was very hard to work with and I saw other libraries redefining them, but it looks like that is fixed. I would definitely like Dict.getWithDefault, very common use case.
Can agree with the find function, also that there are some pains with Date. I don’t see the point of Dict.getWithDefault though, it saves almost no code.
I am not sure adding another language construct will be beneficial. I like the fact Elm is very simple and adding a keyword just to help beginners probably not the right approach. Anyone seriously using Elm long enough will outgrow this feature and they will hate it when they will have to use it every time they need to do any sort of partial application. Since I am so used to looking at these types of error messages, it is hard to know how to improve it. If you have suggestions then you can let the core team know. For example, if I do this: f x y = x + y double x = x * x double (f 10) https://ellie-app.com/nmJ228ntga1/0 I get a useful error message: The argument to function double is causing a mismatch. Function double is expecting the argument to be: number But it is: number -&gt; number Hint: It looks like a function needs 1 more argument. Maybe if the error message said function `f` needs one more argument then it would have even more? What I am not a fan of is a language making you do mundane tasks that a tool or a library could do a much better job of. Whether you are a pro or a beginner, the time to write a _simple_ Decoder will probably be a function of your typing speed and not your skill-level and that's why I wish it was automated. 
As true as that might be, promoting something from an implementation detail to a fully-supported feature is not without risks and the document speaks to this.
Typescript is a better version of JavaScript. I would say Elm is a better way to write HTML applications. The comparisons to JavaScript are appropriate though with a Redux/React/JavaScript audience. 
(TypeScript + ImmutableJS + Ramda + React (with PureComponents exclusively) + Recompose + Redux) == crippled Elm.
(I am the post's author here) It makes sense to take Elm as more domain-specific than JS or TS - that's right. Anyway, IMHO, TS's type inference is quite limited and what its type system offers falls short compared to what Elm provides. With it, you may have static types; though you are forced to be explicit about them and still do not get near the safety provided by Elm's type system.
You forgot to mention Jest.
&gt; IMHO, TS's type inference is quite limited Meaning? It worked for me when I relied on it a few months back. Curious to learn about its limitations you see. &gt; and what its type system offers falls short compared to what Elm provides But only by very little. Not sure when you last informed yourself about this, but current-gen TS' type system is *surprisingly extensive and expressive* for an imperative/bracy language and any ML-ish (Haskell/Elm/etc) hacker would probably be fairly impressed with its powers. We're talking OOP standards (interfaces/class inheritance/generics), union types, type guards, builtin nullable (`Maybe` sort of thing) etc.. Also if you go along that route, I could go "what Elm's type system offers falls short compared to what PureScript provides" ;) now I'm a big fan of the Elm concept don't get me wrong, but one should be fair: TS is pretty damn neat given its (current and near-future) adoption &amp; reach. And its authors have a long history with type systems and a familiarity with ML-style type systems. TS is a nifty little transpiler to keep in mind when in a real-world project you can't convince the project stakeholders to go for Elm or PureScript or so --- no JS person would really mind a TS code-base for obvious reasons.
Super important what you say about creating a reusable debounced thing, Elm has terrible problems with Reusability. I have been using Elm for three months now in a large project in production, more than 15k lines now. It borrows from Elm spa example and that helped a lot but we still keep copying thing all over the place, we also needed to have a debounced call and it's nonsense how much code this takes. 
Yikes! I hope this development doesn't get buried because of the low amount of upvotes. This doesn't sit well with me. I drank the Elm kool-aid (my love of the language practically got me into programming) including complete agreement with the polarizing development philosophy since the beginning. I have seen previous interactions with this kanyo fella on the forum and feel this is overkill. His social skills might be a little blunt and lacking for some but to create this whole "friendship" definition of the elm forum out of nowhere and then immediately ban him ex post facto with no appeal? Not good. And then I actually read his article! This makes even less sense now as it seems clear this is punishment for disagreements about his earlier criticisms (shared by more than some probably care to admit) of the language despite his growing use and advocacy(!) of Elm in production. I guess this is what politics looks like in the programming world or am I just totally misunderstanding this?
You might be interested in [elm-cog](https://github.com/boxed/elm-cog) by /u/kankyo that does decoder code generation. Not sure if it fits every project, but shows that rolling your own generator isn't too tall a task if you need it badly.
I'm glad someone picked up the baton on the material design library! Seems really useful if one just wants a UI without worrying about CSS and I was worried that elm-mdl had gone unmaintained.
Note, I've never used TS before on anything that's not an example but I only find it limited by the fact that there's no guarantee that _everything_ is type-checked correctly. From what I understand you're pretty dependent on people overlaying type annotations onto a library not written in TS. While this probably remains correct most of the time it does seem a little sketchy compared to the 100% guarantee of Elm. However! Overall though I agree that the TS people have done something **amazing**. Made a compiler that can actually provide type annotations in a language that is very, very hard to type check. 
I just do a very simple debounce using Time.every, and a state variable of "AwaitingDebounce" to enable that subscription. Anything fancier I just do with ports, because I have to manipulate timers directly. It works fine, we send out to JS that we want to reset a timer, and JS sends a message back when a specific timer is done (but we can also have it do work). We may or may not care anymore, that's fine.
&gt; From what I understand you're pretty dependent on people overlaying type annotations onto a library not written in TS. While this probably remains correct most of the time it does seem a little sketchy compared to the 100% guarantee of Elm. Ah, I get you. Well. Those "kinda-schema"/header files (`.d.ts`) are somewhat the equivalent there of Elm's ports or PureScript's FFI in a way. In so far as they describe JS modules, there's then of course the same kind of sub-100% guarantee as with written ports.
&gt; I am being asked to do something that an algorithm does better and more reliably in maybe 80% of the cases. You see decoders as trivial, when they are not. Deriving decoders from types is wrong in so many levels. If I change a type, I want the compiler to complain and tell me that some decoders need to be updated. Then I can think about the actual JSON and update them accordingly. If the decoders are generated from the type itself, I have no protection whatsoever. The same thing happens with many ORMs that autogenerate database tables based on the attributes of your classes. If your decoder is trivial, it is just coincidental duplication. It might stop being trivial anytime. Also, I rarely write trivial decoders. Most of the time I'm making types more explicit and mapping things to `EmailAddress` or `URI`. I want my types to be as precise as possible, not just JSON in Elm.
&gt;&gt; IMHO, TS's type inference is quite limited &gt; Meaning? It worked for me when I relied on it a few months back. Curious to learn about its limitations you see. Something I encountered recently while I was playing around with doing something in TS was I was using a function (from react-dnd but it's not important). Types that are imported are: function DragSource&lt;P&gt;( ..., ..., collect: DragSourceCollector, ... ) ... type DragSourceCollector = (connect: DragSourceConnector, monitor: DragSourceMonitor) =&gt; Object; Yet TS complains about infering an `any` type on `collect` and it's arguments when I define and use it: function collect(connect, monitor) { return { connectDragSource: connect.dragSource(), isDragging: monitor.isDragging() }; }; DragSource(ItemTypes.CARD, cardSource, collect); I would have expected it to easily ave infered those types and it made me think TS will probably slow me down more than it will help me at this stage. 
&gt; Explicit ??? is better than implicit ??? That's like saying "wet ??? is better than dry ???". Have a look around at more than one pure FP language and soon you'll understand that currying this is NOT some accidental feature. &gt; way too little explicit typing No one is stopping you from typing more. &gt; Wow. You just cut off that sentence Sorry if I offended you by skim reading through the list of what seems to me like non-issues. &gt; No they don’t do this. Only in one case: where the cases are on the matching side. That doesn’t cover parsers, only serializers. Cool, what do you propose to solve that? &gt; WithDefault is also trivial. Why is that included? API design decisions? If don't like them, make your own, it's that easy. &gt; That’s a literal, not a constant. I misunderstood what you meant by this. Elm actually had guards before that would let you do that, but they were removed because they were unneccessary addition to the core language. Anyway, you can still do something similar to guards with e.g.: http://package.elm-lang.org/packages/Fresheyeball/elm-guards/latest
&gt; If I change a type, I want the compiler to complain and tell me that some decoders need to be updated. I like decoders generated from the **server**'s "API" types :) https://hackage.haskell.org/package/servant-elm
The issue is that the **server** and the **client** have different use cases. Because of that, I rarely want to translate server's "API" types 1:1 into Elm. Maybe a `String` in the backend becomes an opaque type like `Slug`, `AuthToken` or `EmailAddress` in Elm. Server data and client data do not have to look the same. Different use cases, different types, different guarantees.
You bring up some good points. While I disagree on a few, I wanted to get your thoughts on a two of the smaller ones: 1) For two cases you have as examples of poor looking code, Elm does provide a way of writing them in a slightly cleaner syntax: -- Instead of foo = withDefault ( Dict.get "foo" params) foo = Dict.get "foo" |&gt; Maybe.withDefault "" -- Instead of that list comprehension [x.y for x in bar if x.z != 2] -- List.map .y (List.filter (\x -&gt; x.z /= 2) bar) bar |&gt; List.filter (\x -&gt; x.z /= 2) |&gt; List.map .y I think both of these solutions read a little easier. Does this change your opinion? As for pattern matching against named constants, you can do that in a way though it is a little more verbose (though I'd argue Elm is doing this as well as you can). data SpecialInputType = ZeroCharacterCode | OtherCharacterCode Char foo : SpecialInputType -&gt; Int foo inputType = case inputType of ZeroCharacterCode -&gt; 0 OtherCharacterCode c -&gt; Char.toCode c Now you have constants that you can case against. Granted, you have to assign the value to that constant elsewhere, but you can easily do that in a function later on as you see in the foo function.
Thank you for sharing the "recipe". It's indeed something I hadn't think of, but it's a shame that the language in a way pushes you to JS ports as a solution. I do like the approach of Elm being as independent as possible. If the language has a way to reuse things a little more easily I would very much like to be proved wrong.
Heh, now that you mention it, I *did* run into such corner cases as well. Not often as I give top-level funcs typed signatures, but yeah with anon-funcs aka lambdas, sometimes ran into it still.
I normally write out top level type signatures for the core logic of my own program, it helps me design it around the data flow. But if I am using someone's lib and doing sort of "exploratory programming" I really like to rely on the inference and I think TS is not powerful enough for that. 
It is very good at function re-use, the problem is that any complex UI behavior requires multiple functions with complex return types. If you think in terms of re-using some state manipulation, re-using some view functions, it's a little easier to understand, but again... we instinctively want widgets, and widgets are objects. Some widgets can just be a "view" function though.
&gt; Curious to learn about its limitations you see. I haven't used TS but I've used Java. Apologies if TS is dissimilar from Java in this regard, or if Java has changed since I last studied it. One thing I like about Elm is there's no `null`. In Java, any object might be `null`, so programs crash with the dreaded "NPE" (NullPointerException) unless you remember to check for null. Not saying checking for the empty case isn't good or necessary, it's just that in Java the type system doesn't *enforce* it for you. so it's basically like JavaScript where you don't know what's happening in your program. "i'll just add another null check here oh god i hope it doesn't crash." Elm has this concept of `Maybe x` which gates against the empty case if the situation calls for it, but your program won't compile unless you properly handle the empty case. If you're handed a string, you know it's a string, by god. If you're handed a maybe string, you'll need to handle both the "nothing" and "okay this is actually a string" cases before anything will compile.
&gt;As true as that might be, promoting something from an implementation detail to a fully-supported feature is not without risks and the document speaks to this. That is true but what I'm arguing is the point that if the idea of generating decoders is bad/wrong/not for Elm then why it is implemented at all. Ports would have been easily got a `String` or `Json.Value`and force you to decode them yourself but instead decoders are generated for them, why? because it makes the developers life easier, so why not allow the same developers to use that feature directly?
&gt; If I change a type, I want the compiler to complain and tell me that some decoders need to be updated. This is your preferred approach. I see things differently. I view serialization as something that should be automated. If I change a type and the serialization of that type doesn't change, with automated serialization my work is done. There is no decoder to be updated because there is no need for the said decoder. If the type of the serialization changes, then I will have to change the server to match the new type BUT, in the client, the job is still done. &gt; If your decoder is trivial, it is just coincidental duplication. It might stop being trivial anytime. Define trivial. Give me some example of something that is not trivial. &gt; Most of the time I'm making types more explicit and mapping things to EmailAddress, Slug, UUID or URI. Out of curiosity, do you create new wrapper types for `EmailAddress`, `Slug`, `UUID` or `URI` or are you aliasing String? Do you encode/them them to anything other than their direct string representation? 
For me, 80% of the derivation is fairly trivial where I am just mapping to the backend API 1:1. Based on the comments on this thread, I would say, a good number of people will fall under that umbrella as well. I would not remove the ability for people to write Decoders manually -- I think we are just looking for ways to automate something that is done without much thinking right now. This is how it is for me in my Haskell code, where I am deriving `ToJSON` and `FromJSON` instances using Generics initially and over time if the types get complex, I will create a simpler representation manually. 
I find this action disturbing. Please can you explain how you applied the rules? Can you point me to the list of relevant elm goals? thanks
I'm no mod. Just happen to've had contact with /u/kankyo. He's not able to let us know he's banned (as he's banned), and I thought it is best to at least let others know it happened.
What I meant is that if you write a backend-for-frontend, you do not care so much for having a "specification" that is independent of your code bases (as not software will use the same interface). So all you care for is a typed boundary between the BE and the FE. You can then tweak the types to fit the domain on each side. Having generated JSON encoders/decoders is a huge feat in this specific usecase.
Please, forgive me for the misunderstanding. My questions are for the mods.
Well, you have to either explicitly declare type signatures with that horribly intrusive syntax or you get no type checking at all... On plus, if you look at more than the type system, you also immutability as a very remarkable safety feature that Typescript fails to address! 
No worries. I should have been more explicit.
It's not only that... In Elm you have full type inference! You do not need to declare the types of any values and still you get 100% type coverage, and a bit aside from that: everything is immutable: That gives you very strong guarantees about each portion of code, making it much easier to reason about; maintain; and test.
Sure ML-ish languages are better in numerous way, no question --- if you *have the choice* to use them. Just wanted to share that I was positively impressed at the number of high-level type system features it does sport. Which makes it the excellent choice when you cannot introduce an ML-ish FP language outright into a project/team/code-base. TS designers hit that sweet spot where you can sneak it in and out of any JS code-base without great concern.
Just make sure you [replace the offending characters](https://stackoverflow.com/a/26354677/626515). 
Where did author found quote from Simon Jones about Haskell being useless ? 
I think it's a bit misleading to conflate JSON decoders being auto-generated with them being built into the language. Haskell has auto-derived JSON in the Aeson library, but it's just that: a library. The Haskell language itself has no built-in knowledge of JSON support. This way, you get all the benefits of removing the boilerplate without any of the issues of hardcoding something as unprincipled as JSON into your language itself. I know Elm isn't designed to be like Haskell, and maybe this isn't the direction you'd want to take the language, and that's totally fine. But it is misleading to pretend that option doesn't exist.
&gt; useless https://www.youtube.com/watch?v=iSmkqocn0oQ
&gt;[**Simon Peyton Jones - Haskell is useless [6:23]**](http://youtu.be/iSmkqocn0oQ) &gt;&gt;Simon Peyton Jones talking about the future of programming languages &gt; [*^bunidanoable*](https://www.youtube.com/channel/UC3FjUi9Ny0MTHiH_A-Ja5rg) ^in ^People ^&amp; ^Blogs &gt;*^188,215 ^views ^since ^Dec ^2011* [^bot ^info](/r/youtubefactsbot/wiki/index)
If you can rely on 3rd party services like Branch.io (I use it) it can be way easier.
Thanks for your comment. You made me notice that my quote is not a word-by-word quote. I've fixed the article so that it lets this clear and it links to the video.
A Problem i can see with that approach is that your model likely gets bigger than what you can store inside the URL. I'd suggest saving the data on a server in a content-addressed hashtable and referencing the hash in the URL. This solution needs a server though, and some form of spam protection :/
&gt; That is true but what I'm arguing is the point that if the idea of generating decoders is bad/wrong/not for Elm then why it is implemented at all. IMO that's the point of keeping something an implementation detail— You are not bound to support it if it ends up not being suitable. Considering where Elm is *right now* it *is* suitable, but I can certainly understand an aversion to making it a core language feature. It definitely seems like the kind of thing where having a tool to do this is a happy middle ground, and my understanding is that there is such a tool. I haven't used it, so I can't speak to its usefulness, but considering the vast number of things people would like to see in Elm, I'm surprised automatic decoding is so high on the list.
Yup, that was the winning idea at my job, to (and I'm not making this up) "Elm-ulate" rather than to Elm.
It's really antagontistic to claim that you're trying to be civil...
But serialization solves a totally different problem than your client does. If you couple your serialization format with the types that you end up using to implement your client use cases, then you lose a lot of potential guarantees. I would rather work with `Question.Slug`, `Question.Title`, `Question.Body`, `URI`, `AuthToken`, and `EmailAddress` in my problem domain than just use `String` everywhere.
&gt; something that is done without much thinking right now But maybe **this** is the issue. Not every piece of code that feels trivial or looks the same needs to be abstracted away. Decoders solve a totally different problem than your types do. Coincidental duplication. &gt; This is how it is for me in my Haskell code, where I am deriving ToJSON and FromJSON instances using Generics I'm not arguing it is not convenient, but that doesn't mean it is right. In Haskell the issue is exacerbated because you end up tying your types to only one decoder/encoder.
&gt; You can then tweak the types to fit the domain on each side. This sounds like "decoding" backend types into client types, and vice-versa.
Hey can you put your youtube videos in a playlist in the order that they should be watched in?
It's an intruiging puzzle, thanks for making that! Some scoring would be nice (maybe using localStorage :D).
Love it!
It's a relic from when `graphics` was part of core, and those functions were available by default. I think an up to date example using currently existing functions would indeed be very nice :)
Also, there are some types like `any` that give you a quick and easy escape hatch to the safety of the type system. I'm afraid that when the type signature is "hard" the temptation is to just go towards more generic types rather than simplify that implementation. In Elm, this isn't an issue because it has no concept of `any`. There are probably some ways you could use TSlint to prevent some of this, but probably not all of it. Again though I stress that TS/PS are awesome and honestly they fill different roles and needs in my opinion. 
Beat it in 69 moves baby
33 moves! Neat game.
This game can be played with single player, or multiple players, taking turns only turning their color.
25 moves! ...Then 44
I honestly think that this is an early design decision that is honestly not that great of an idea to use. It throws exceptions whenever you pass the wrong thing. Yes it should be a Result but that misses the point of not encouraging people to tightly couple their model to how the sever sends data. 
Hey, just want to say thanks for spending the time on thinking carefully about these problems, but then also putting those thoughts in writing. It's very useful for many of people, even beyond the Elm community!
I've used JSON Schema before, but it's got a really ugly surface syntax and people seem to hate writing or reading it. I much prefer RAML's type syntax, but alas the ship might have sailed on this one... :(
I've personally found Elixir quite frustrating to use because of all the type errors, and poor support for the joyful refactoring/maintenance experience that comes with typed languages like Haskell, Elm, Rust, Swift, etc. Also don't really think that the Ruby syntax works all that well for encouraging functional, expression-oriented code. That was my experience at least. If you're interested in learning some Haskell (I'd highly recommend it), I hear very good things about http://haskellbook.com/ - just be sure to do the exercises! Otherwise, just dive in on a project. Don't listen to anyone who says you need to understand category theory or monads to start - you don't. Some good advice here as well: http://www.haskellforall.com/2017/10/advice-for-haskell-beginners.html
That is your option and it is OK to have facilities that allows that. The thing is that this in an advanced use of the type system and I also think that it is one way of approaching safety. There are other ways to ensure that a string has the proper value. I understand defensive programming and I'm all for that but it has its tradeoffs. What I'm proposing is not a way that takes that away from the people who want to use it but a way that allows the people who, for some reason, do not want to pay the price of defensive programming to have a simpler way. 
49 steps! This is addictive... Nice game
&gt; There are other ways to ensure that a string has the proper value. I would like to know how. The only way I can think of is to check the value every time, but what do yo do if the value is incorrect? You write most of your functions so they return a `Result`? Isn't it better to capture that scenario while decoding, as soon as possible?
You should look into this, its the algorithm behind Google Wave: https://en.wikipedia.org/wiki/Operational_transformation I don't know of any implementations in Elm.
First try 50 moves, second try 20. This is awesome!
Very fun! You should make it be more mobile friendly! I mostly just need to be able to zoom out, or have a smaller board
Good idea, I will look into this
I will be on the road soon, so I will try to make up some playlists of various groups of videos,
+ redux loop
Nice game!! So cool and addictive! How can I play this on multiplayer mode, though???
Hey man, this is nice!!! It seems to be really a advantage above the Phoenix, if looking in this angle. But I'm having a doubt about the server performance. One of the bigs benefits and win for using a Phoenix server is its concurrent, scaling, high tolerance and performance. In this context how Servent/Haskell can compete? Thanks for your reply though. : ) 
Ah, yeah!! My bad, sorry.
Oh.. would be cool if this were there. Reading it, my impression is that is missing some more about Elegant itself and your role in the party. Maybe some more examples could solve it, since the repo name seems to be related just for Elegant?? Thanks for you reply!
First try, 20 moves. My record is 9! Also, I found a bug in the code. You define `frameLength = 200 * millisecond`, but then call `Process.sleep (frameLength * millisecond)`. So you are multiplying by millisecond twice. Of course, since in Elm, `millisecond == 1`, it doesn't actually change anything, but it still feels wrong.
And what about the "history" of realtime / push notifications here ?? Phoenix has it backed directly through Channels. You guys is using something like this with elm / haskell ? 
Oh, thanks u/bjzaba for your kind reply and recommendations!!! I've touched Haskell in academy years ago, and should be cool play with it again.
Gonna fix this tomorrow, thanks for the heads up
There is already a branch where I implemented permalinks, so you can share any puzzle with a friend and see who can solve it faster. This needs to be fleshed out though, I have to make sure the PRNG always behaves the same. https://gitlab.com/MazeChaZer/knobster/tree/feature/perma-link I might develop this further with a real multiplayer mode, but I can't promise anything
&gt;For some reason we think JSON is a thing that is fine. It is not a great choice on basically every metric that matters to building reliable, efficient, and flexible applications. This sentence is kind of a tautology because you define your own limited criteria to disqualify JSON, kinda like wondering why people use Node when your criteria is "something faster than Node". Well, what about all the other more convincing criteria? Also, I don't really see how it's Elm's concern what an API's endpoint returns. That decision is generally made at a higher level than just "what's easiest to do in my Elm client?" That sentence just felt out of place.
Perhaps you could also help updating the official servant elm example :) https://github.com/haskell-servant/example-servant-elm/issues/3
I turned the screen on the side and it improved it.
Fixed in [121518eb91648f8f879e9d5bc5b0601d9f4de2f7](https://gitlab.com/MazeChaZer/knobster/commit/121518eb91648f8f879e9d5bc5b0601d9f4de2f7)
This is awesome! :) Can't wait to try out the multiplayer version and figure out the optimal math behind it!
this game is fun as heck. thanks for sharing!
I just pushed a few fixes that should improve the situation :) Some people will probably still have to scroll sideways in portrait mode, I'm thinking about making the number of knobs configurable there.
I'd love to share this on twitter. Are you okay with potentially 13k people seeing it? Want to do more work on it first? Never there? Anyway, I think it's a really cool game! I figured how to get single digits sometimes :)
I just started using mdgriffith's [style-elements](http://package.elm-lang.org/packages/mdgriffith/style-elements/latest), which takes a slightly different approach to layout and style compared to traditional HTML/CSS. I am liking it so far! I was always rubbish at CSS though, so if you are a CSS ninja you may want to stick with elm-css.
I don't see what's wrong with just doing regular old CSS and then using it like normal in Elm (just use the `class` html attribute). Everyone always links these packages for doing it some wacky way but I just use CSS like normal.
I second this. Also, on the same note, doing animations with Elm doesn't have to be all "track position and whatever in model, use libraries to move stuff"... sometimes it can just be plain CSS animation!
I created a haskell/servant/elm project template that already has everything needed if you are interested in writing your backend in haskell. This also includes generating elm code from your haskell code so you don't have to write your api calls/types multiple times. https://github.com/tlentz/servant-elm-template
Yeah, we just use scss in ours that is compiled and thrown into the elm app with webpack.
I use plain old tachyons, not even the elm package, and I'm very happy with it! The atomic classes fit very well with view functions, and it's the most fun I've had doing css. Worth the time to learn the scales and classes, and this is an even better version of the docs my coworker built https://tachyons-tldr.now.sh/#/classes 
That's awesome, thank you so much! *.* Can you give me a few more days? I should probably make the CSS more backward compatible and I would like to include a logo/winning animation.
&gt; Am I right assuming this is what most people use doing css in Elm? Or is there something I'm missing? I seriously doubt it. The CSS in Elm story is still very far from being solved. From my own work, for now, the best experience is to just stick to SCSS. Implementing CSS in Elm would mean that when you change some CSS style info, you would have to recompile some of the elm files. This opens the road to some very bad experiences as you scale the app. You could end up with sometimes tens of seconds of compilation time for a simple style change and I have yet to see the authors of either `elm-css` or `style-elements` address this with a complex enough example and a strategy to avoid these compilation times. These being said, you can use `elm-css`, just make sure that the CSS files are not imported into your app's code (i.e. keep them parallel to the rest of the code so they get compiled independently of the rest of the code). Eventually, `style-elements` or a similar solution (layout separated from style) will emerge victorious and we will have an official way to do CSS in Elm that might be way better than SCSS. 
I also find that good ol' CSS is what I'm most productive with. Then again, I'm writing hobby apps as a one man band. Larger projects with unwieldy CSS may benefit from the tools that the Elm community has to offer. 
Interesting. How do you reconcile this approach with the **"We do not think in terms of reusable components."** from the Guide? 
In The UI Explorer, your views are just pure functions. *"So we think in terms of reusable functions"* and not in components :-)
Most developers just use traditional CSS and then embed Elm into the HTML and CSS into the HTML. As browser renders HTML generated by Elm, it also adds CSS to these elements from the traditional CSS file. For development I use [a webpack template](https://github.com/welf/elm-webpack-starter) with Elm and Bootstrap which is recompiled after I change and save anything Elm or CSS files. 
It now occurs to me this might be a bug in Elm, and not just browsers keeping a hidden buffer for autoconplete text that they preserve but can't reconcile with assignments to input.value. I'm down to help the Elm crew if it turns out to be fixable on that end, PM me or leave a link here for how to either test that this is Elm or submit a patch.
That sounds really cool! I am deeply scared of Haskell and have spent the last few months trying to get my head round Elixir, so I'm not sure if I want to change horses at this stage. But if it all goes wrong with Phoenix, I promise I'll take a look!
Alright, I don't think it's too bad. We are using this in production right now. Good Luck!
That means all your view functions take arguments with information to generate the messages they emit? Or how do you take care of for instance having a form with a button and many msgs to set the fields and make them generic so that you can integrate them elsewhere? Or do you define the messages and externally the users has to map everything back to their own message types?
The trouble I've had with CSS animations (specifically transitions) is described here: https://www.youtube.com/watch?v=Zje8MN9whF0&amp;feature=youtu.be 
I haven't used it myself, but there might be something useful here: https://github.com/carleryd/elm-hipster-stack
Check out [Google Cloud Firestore](https://firebase.google.com/docs/firestore/). It's like a newer, better version of Firebase that has a more expressive query syntax.
Yes, it's not sufficient for every type of animation you may want, and the animation libraries have their place. I wrote "sometimes (...)" :)
Sure thing! Just message me when you feel it is ready to go! And if you want to be cc'd in there, let me know your twitter name :) You can send me a direct message in reddit as well so it's not all posted here if you prefer.
&gt;I don't see what's wrong with just doing regular old CSS Nobody said it was wrong. How about we reframe the question: *I want my CSS to be statically checked and compiled along with my HTML and program logic. How can I do that in Elm?* I'm not sure what exactly your comment adds to the discussion. If people wanted to do things the "regular old way" then they probably wouldn't be using Elm in the first place.
I have a project where I'm using elm-css and I love it. Here are some relevant files to check out for examples of how I'm doing it: - [Stylesheets.elm](https://github.com/bgourlie/rs-nes-debugger-frontend/blob/master/src/Stylesheets.elm). - [Styles.elm](https://github.com/bgourlie/rs-nes-debugger-frontend/blob/master/src/Styles.elm) - [Main.elm](https://github.com/bgourlie/rs-nes-debugger-frontend/blob/master/src/Main.elm#L675) Let me know if you have any questions!
I'd argue that statically checking styles doesn't make a whole lot of sense.
I've actually wanted to do this very thing. create-elm-app is pretty awesome. I think the nieve approach would be to _just not have Phoenix serve up the assets_. Just host the frontend on a CDN using netlifly or S3 or something like that. Then just write a plain old API in Phoenix. It'll probably serve up the assets at about the same speed as Phoenix anyway (if not faster). As long as they are under the same domain name they should be able to communicate without CORS issues. I know it seems nice to have Phoenix run the build tool but it cripples a lot of the UX of it in my opinion. Also, this makes the front-end and the backend loosely coupled. Sadly I have to deal with some legacy stuff or else I would do it this way. Right now I'm doing raw webpack which works pretty OK for the most part. You can still stick them in the same repo just have separate deploys. 
For what it's worth I have given the package some much needed 💖 as of late. However like you stated raw tachyons really isn't bad. 
I couldn't disagree more. Example: You have classes and IDs that are referenced in your HTML, program logic, and CSS. In your world, the former two are represented as Elm values. In your CSS, they would be string literals. If you make a typo when specifying a class or ID anywhere in your Elm code, you will get a compile error (or more realistically, immediate feedback from the editor). If you need to refactor a class name or id, your editor can do it with 100% accuracy in just a handful of milliseconds. But, now you have to go and manually change all occurrences in your CSS by hand. Or you use find and replace, which is error prone. You are also context switching, working with a separate CSS preprocessor syntax and compiling those assets separately. This is all a huge waste of time.
Thanks for the contribution! I really want to try the package soon, looks great.
Besides the static checking advantages that bkv mentions, there's the fact that many CSS values are derived from application state, and it's nice to be able to render them together with other application logic, rather than via a set of fragile string conventions, or maintain them separately in your CSS preprocessor. (I have not used elm-css or style-elements, so far I've used a mixture of plain CSS for 'structural' and other styling not derived from app state, and inline for app-state-derived styling. It's not ideal but I prefer it to exclusively class-based styling.)
Tachyons for the win! 
React style: Inline Style for the win
Hi ! I don't know if i clearly got what you are asking for. But let me try to answer with what i understood. When you decide to put your views in UI Explorer, you don't have to change the messages they emit. You are free to use the messages that you have defined in your App. UI Explorer will internally map those messages to a silent one. You can check the toggle button example that illustrates that. When [running in the App](https://kalutheo.github.io/elm-ui-explorer/examples/simples/index.html), The view emits a custom Toggle Message once clicked. But in the [UI Explorer](https://kalutheo.github.io/elm-ui-explorer/examples/simples/explorer.html), it's message is mapped to a silent internal "NoOp" message.
It sounds like you did a lot with ports, any design or even general advice when using them?
Thanks! I did see that project already - from what I can tell, they're not using the HMR feature (at least, they don't seem to include elm-hot-loader in their webpack configuration file).
Yes, this is probably not a bad option... in fact, since I'm not even using the back-end for anything yet (except to serve up the compiled Elm code), I have the even more naive option of just copying my Elm code from my current Phoenix project over into a create-elm-app project and running the dev server there. But once I start working on the back-end side of my app, it would be nice to have everything working together in one place. I'll take a closer look at the config files and see if I can get it working. I imagine it will just take a few hours of fiddling around with file path variables and cursing a lot...
Check out Murphy Randle's elm-conf talk on using the actor model when creating ports: [The Importance of Ports](https://youtu.be/P3pL85n9_5s). A few key points: * don't think in terms of request/response * let JavaScript own the data * Add a single pair of ports for incoming/outgoing information
Yeah, that solves my question. Thank you!
You can put this question on the slack channel. You'll get a response faster
https://ellie-app.com/4DDZ2QrT3a1/0 I think using a "wrapper" around your program may give you more flexibility. In this specific example, I'm showing a very minimalistic list of encoded messages and a way to edit those and replay them, but the idea is sort of the same: - record messages - allow exporting them (by sending them to a server rather than by printing them to the screen, presumably) - allow importing them (perhaps by sending them into a port or providing them as flags)
Few day ago this thread compiled quite a list containing both UI libs, CSS libs and in-betweens. https://www.reddit.com/r/elm/comments/7713wm/elm_ui_libs
Put `user` inside a [Maybe](https://guide.elm-lang.org/error_handling/maybe.html) type like this: ``` type alias Model = { user: Maybe User } ``` then you will have to use pattern matching to extract the user while checking if empty or not. 
 type alias Model = {currentRoute : Navigation.Location, user : Maybe User} init : Navigation.Location -&gt; (Model, Cmd Msg) init location = {currentRoute = location, user = Nothing} ! [] A union type with a empty kind of value is also an option. eg. you could define `type User = User {id : Int, email : Maybe String, username : String} | NoUser` But then you have to write all the function for pattern matching on that and checking for a `NoUser` value. The Maybe type already has all these kinds of functions. http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Maybe Functions like `Maybe.map` that allow you to apply a function to the user if it exists and do nothing if you haven't fetched it yet. http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Maybe#map
I continue working on elm-json-schema experiment (https://github.com/1602/elm-json-schema), this week I add generators to produce random values based on json schema. At the same time working on a showcase for aforementioned experiment, a project called json-editor (https://github.com/1602/json-editor), will deploy some editing experience improvements this week.
I've got this unfinished [directed graph editor](http://janhrcek.cz/graph-editor/) which I'd like to get back to soon. The next big feature to implement when I have more time is automatic force-directed layout using [elm-visualization](http://package.elm-lang.org/packages/gampleman/elm-visualization). So far working on it was real pleasure and I'm excited about how simple and solid the implementation turned out to be :-)
This is brilliant!
Can you share some more code? I think the problem can't be using `Html Msg` view where `Html msg` view is expected - it's a subset, so the error you would get would be "Hey, this `Html msg` is too general, it will be `Html Msg`!" ... Not sure about when your error message would show up. Give us code! :)
This is how I did it. It's nice to see support for the style I used. I group up relevant data when JS side has changed, and push it through. Both sides just react to changes to the other. There's no Request/Response.
I've been working on a dart scoring application in Elm. I've been spending more time up front trying to define really specific union types and it's been a lot of fun. I ended up writing a [blog post](https://becoming-functional.com/type-driven-design-in-elm-f8ad90e642aa) describing the experience of doing type-driven design.
Did a fair amount of refactoring of the interactive binary decoder I posted last week. Found a much nicer way of visually representing decoded spans of bytes, which also simplified the code quite a bit. If you decode some longer strings of bytes (U32, F32, U64, Ascii) and then resize the window horizontally, it looks pretty cool to see all the spans re-orient themselves! https://s3.amazonaws.com/interactive-binary-decoder/index.html
There is no such thing as null in elm. Think about the type signatures of each of your functions and how you're using them. If you need value to be optionally specified then you need to handle that explicitly. 
Hi, I need the simplest possible full code that I'd be able to copy-paste to Ellie-app. The code should just print numbers from 1 to x. For example, 1 to 10, 1 to 20. If anyone would help with this lowly task, it would be highly appreciated.
I wouldn't be surprised if most Elm developers go through a process where at first they want to use Elm for everything, then they develop an appreciation for ports, then they develop an appreciation for leaving some stuff in Javascript so that the Elm app stays smaller and simpler.
From the point of view of your Elm app, you're initializing the app with `/#/profile` as the current location. Luckily, when using `Navigation.program`, the initial location is provided to your `init` function. So in your `init` function, you'd handle the above 2 cases.
I just finished my cheat sheet viewer: http://sakisan.be/cheatsheet It contains the collection of cheat sheets from duckduckgo's instant answers: https://github.com/duckduckgo/zeroclickinfo-goodies/tree/master/share/goodie/cheat_sheets/json
There are two types of url changes, a hard url change and a soft url change. The hard one occurs when you type something into an address bar, when you click the reload button or when you click a link to another location if you don't use hash based addressing. The soft one occurs when you programmatically change the url (for example using `Navigation.newUrl`). Because hard url changes exist, you need to handle these changes by properly treating the `Location` information your main `init` function receives. 
Another way you could do it is to define a state machine for your application. In the initial state, you have no user, after log in you have a user: type State = Initial | LoggedIn User Of course, this corresponds to the structure of the type Maybe. But a state machine can be useful as more states get added to you application. For example, after logging, there might be a call to fetch the data for the users dashboard. To start with the screen shows not logged in, then it shows logged in in the title bar but with a spinner in the main window, then with the dashboard rendered once that data is fetched. type State = Initial | LoggedIn User | WithDashboard User Dashboard Then you can write some helper functions around State -&gt; State transitions. Just an idea for you. Personally I find it immensely helpful to sketch out state machines to describe the state that backs my UI.
Does this scale? It seems difficult to consistently keep adding handling for each new URL or possible URL?
So is a redirect from the backend a hard or soft url change?
I've been thinking about this a bit too; for things like Google Maps, it made sense because that set of interactions was fairly well-defined, and the interface between two made sense. The video I linked to at the end of the post seems to better facilitate this as well.
hard, if the browser is going back to the server and getting a redirect, then your page and all it's state no longer exists. A soft change is defined by your browser setting the URL but not asking the server for anything. If you are going back to the server for any reason then your page state is lost, this applied not just to elm but any webpage. 
Thank you for the suggestion. That does seem helpful. And this `State` resides in the `Model`, correct? 
I have read this just recently: https://becoming-functional.com/improving-elm-routing-with-union-types-cc483c219b2a The article explains how can you replace your `currentRoute` as a generic `Location` with your own type. That will make your model less abstract and easier to reason.
I'm not sure why you would want to do this? Am I missing something? I definitely see the value of a compile-time checked CSS file, but I wanted it emitted as a normal CSS file for my browser to load, cache, etc.
I am completely sympathetic to the points laid out in this article. However, from the perspective of my nose to the grindstone, the whole dealing with data interchange aspect of my code is a very un-fun situation. Maybe some schema would solve this, but I never did like SOAP very much. The major pain points of JSON decoding are: 1. It is repetitive code, but still requires focus and time investment because it IS non-trivial, as pointed out, and there are many ways to make mistakes. 2. You almost immediately run into the need for a 3rd party library to decode JSON objects with more than 8 fields. 3. The "maybe" decoder eats errors and is a massive newbie trap. When you have optional keys, you want the decoding to fail if the object is present and not what you expect, not silently become Nothing! I use this decoder a lot in Rails app: {-| True if the key is present. The value might still be null. -} hasKey : String -&gt; Decoder Bool hasKey key = (maybe (field key (Json.succeed True))) |&gt; Json.andThen (\keyOrNothing -&gt; case keyOrNothing of Just _ -&gt; Json.succeed True Nothing -&gt; Json.succeed False ) 5. JSON decoders can eat up as much as half of my time before I ever get to write any application logic.
Sorry for the double question, but isn't this bad when you want to access the user data? Since being in `WithDashboard User Dashboard` makes you use a `case of` expression to extract the user data, but when you are in the dashboard view (for example), you already know you're at that particular state.
Depending on your application structure, you may want to split off the way you actually handle location changes from your `update` so you have a single function you can call from both `init` and `update`. In other cases, you may want to limit the possible entrypoints for your applications. I guess what I'm trying to convey is that this does not imply duplicating code :)
Do tell if you figure it out. Good luck. 
I published an second pass on a tree structure editor, with demo available here: http://elm-arborist.peterszerzo.com, and package here: http://package.elm-lang.org/packages/peterszerzo/elm-arborist/latest. I really wanted something that can hold and represent any data structure and any html view of each node, and I was surprised how clean it comes out in Elm. Also, writing layout algorithms in Elm is joy. Started out super scary, but still joy.
I was trying to hack together my own trial of using Elm to implement lambda functions and came across this. Looks good! I'll be digging into more over the next week.
Yes, in the Model.
I see what you are saying - you already know you are in the dashboard view because that is the current route. I was kind of simplifying things by imagining an application with no router, and how the not logged in, logged in, data fetched flow would work for that. In practice I tend to write applications with several 'pages' that I navigate between using a router. The user 'session' is part of the top-level model (Maybe Session). Then within each 'page' of the application I build a state machine. Every page that needs a Session gets one passed into its 'init', 'update' and 'view' functions. The route handler ensure that all routes to pages requiring a log in, take the user to a log in prompt on the way there, if they are not currently logged in. See this in Richard Feldmans SPA example, which is a highly recommended resource to learn from: https://github.com/rtfeldman/elm-spa-example/blob/master/src/Page/Article.elm#L45
I want to decode a complex string coming in an http response: ocd-division/country:&lt;country_code&gt;(/&lt;boundary_type&gt;:&lt;type_id&gt;)* I created more expressive types to hold the values. I made a decoder for boundary strings (&lt;boundary_type&gt;:&lt;type_id&gt;) and then expected to make a higher level decoder for the entire string which would delegate to the smaller decoder. I then realized I was out of my depth! I imagine this confusion is because of my unfamiliarity with functional style and elm decoders leading me down a bad path. So if you recommend approaching this problem in an entirely different way, I am open minded! Thanks for your time https://ellie-app.com/bd5ty4Xbca1/0
Hi! I have a problem with understanding of **never** function (not **Never** type!). [Docs](http://package.elm-lang.org/packages/elm-lang/core/latest/Basics#never) say: &gt; So the never function is basically telling the type system, make sure no one ever calls me! How is it possible? In the docs example code they use it to map Html Never producing function, so now it cannot be called? But it is apparently called, because we will see "combined" html's.
I don't know if it is appropriate here or not, but this week we started to use elm in production. We started to migrate some parts of complex app from react to elm and I think I'm falling in love :) Really fantastic experience. Just wanted to share with someone :)
Basically, think of it as a way of telling the compiler that a branch is unreachable. The key is that there are no values of the Never type. So the never function is saying "if you give me a value of type Never, we must be in unreachable code, so I will "give" you a value of whatever type you need. The code actually just crashes, but it will never be run. It's just a way of pleasing the type checker, letting it know that if code is unreachable, that you don't need to produce an actual value of the given type. It's the exact same idea as the "you can prove anything from False" in logic.
1. With extensible records, you can not repeat yourself when you define multiple records and each of them contains same fields. Define repeated fields in an extensible record and use it defining other records. If you'll need to add in the future another repeating field in all those records, you simply add it to an extensible record and it appears in all records based on it. 2. You can write "polymorphic" functions for differently shaped records. For example, if you have several records and each of them has fields { name : String, description : String } you can define those fields in an extensible record and use it as a base for other records: type alias TextInfo a = { a | name : String, description : String } type alias FirstRecord = TextInfo { otherField1 : Int } type alias SecondRecord = TextInfo { otherField2 : ComplexType } And when you need to write a function to update these fields, you write one function with type signature changeTextInfo : String -&gt; String -&gt; TextInfo a -&gt; TextInfo a changeTextInfo newName newDesc record = { record | name = newName , description = newDesc } and this function will work with FirstRecord as well with SecondRecord. 
I took another stab at it, and came to the conclusion that `Decoders` are not meant to partially decode a string. Rather, decoders should entirely consume a json field. With this perspective I got it working! https://ellie-app.com/bd5ty4Xbca1/1 Altho it works, I would still like some feedback on how to simplify or stylistically improve any of my code. Thanks for your feedback!
Thanks for an answer! I still confused about *but it will never be run* part. How is it possible if we see the result of mapped function in the example code? Well, I tried to look at **Html.map** &amp; **never** signatures: Html.map : (a -&gt; msg) -&gt; Html.Html a -&gt; Html.Html msg never : Never -&gt; a And if you just replace **a** with **Never** and **msg** with **a** it starts to make sense. Is it correct to say that type checker will do next steps? * it will take a look at our **view** function (for example, it returns **Html Msg**) * it will take a look at Html.map signature ("ok, according to **view** signature I will expect **msg** to be **Msg** because it is our final result") * it will analyse our second function (it returns **Html Never**) * finally it will notice our **never** function ("ok, I will assume that **a** is going to be **Msg** to fulfil the whole type chain") 
[Massive Decks](https://github.com/Lattyware/massivedecks) is a card game (CaH clone) written in Elm. We do a small amount of animation using CSS. Ideally, I think the form of animation we do (change the state, let the browser handle the animation) is by far the best if it can work for you. Manually animating involves a lot more model and work.
Okay, so there's a lot going on here. First, let's look at the `Never` type: type Never = Never Never This is quite confusing at first, so a better way to write it would be type Never = NeverConstructor Never This says that the only way to create a `Never` value is to apply its constructor to an existing `Never` value. So you can only create one if you already have one, which means that there's no way to bootstrap this. The important takeaway is that *the never type has no values*. So we, as humans, know that if a value of type `Never` is in scope, that this code will never be run. So, generally we don't write code using `Never`, because it's pretty useless. But what it helps with is taking generic code, and using parts of it, putting `Never` for the parts that can never happen. When could this come up? For example, with the [Result type](http://package.elm-lang.org/packages/elm-lang/core/latest/Result#Result), we chain together some operations, but we want to signify that this particular operation will never fail. f : Result Never Int -&gt; Int f x = case x of Ok i -&gt; i Err n -&gt; never n The compiler requires that all of our case-expressions be exhaustive, and it has no way of knowing that `Never` is an empty type. So the `never` function gives us an escape hatch. It says "if you've done the impossible, I can conjure a value of any type." The compiler is happy because it can instantiate `never n` to type `Int`, since `never` has a polymorphic return type. The programmer is happy because we didn't have to come up with some "dummy" `Int` value, and our code clearly shows that this branch is unreachable. If you look at the code of the `never` function, it just crashes, but it's safe to put in code because, unless the typechecker is broken, you won't be able to call it, so it shouldn't ever crash the program. Another possible use case is for something like this: type GenericInt x = Neg x Int | Zero | Int type alias MyInt = GenericInt () type alias MyNonNeg = GenericInt Never This lets us write one type with constructors and a type parameter, and we can write code that's generic in the parameter. Then, we choose the parameter either to be `()`, which is the empty tuple, or `Never`. The type `()` is the dual of `Never`: it has exactly one value, with no useful data. So now, we have two types, `MyInt` and `MyNonNeg`, and we're guaranteed that we can't ever make a `MyNonNeg` with the `Neg` constructor, since it would require us to make a `Never` value. But we can use `Neg` for `MyInt`, since we totally can make a value of type `()`. We can now pattern match on code without knowing if we have a `MyInt` or `MyNonNeg`, but if we know we have a `MyNonNeg`, we can just use `never` as a dummy value for the `Neg` cases.
There are 2 ways "hiding" things: you can use [opaque types](https://medium.com/@ckoster22/advanced-types-in-elm-opaque-types-ec5ec3b84ed2) or make use of the package manager, as seen here for example: https://github.com/abadi199/elm-creditcard. You'll notice that there is a module called `CreditCard.Internal`, but it is not exposed in elm-packages.json. This way only the package itself can consume this code.
I didn't understand at first, but then I had ye olde moment of clarity in the bathroom. I would have to re-rig my DOM tree so that _all_ the cards are plopped under one, position: relative, parent node. Each of those cards would be position: absolute and assigned some CSS class that determined its placement. Then to affect an animation I would just swap a card's CSS class, provided I have some CSS transition defined like the example you provided. Does that make sense?
There is no way to automatically reexpose things in Elm. Making new functions and type aliases as you did is the only solution but the resulting code is quite clean and very explicit. Regarding union types type alias Msg = MyModule.Update.Msg You said it doesn't compile but it definitely should. If you also want to expose its constructors, remember that they are just functions. So if you have code like this type Msg = SetName String You can create functions like setName : String -&gt; Msg setName = MyModule.Update.SetName and then expose them. However, the module that then imports those functions looses ability to pattern match on your Msg type. There is no solution for this as I understand. 
Made sense to me.
Thank you! The **Result** example was exactly what I needed!
If you need absolute fine-tuned control over position, that'd probably do it. Of course, it is a little rubbish that it means you have to make sure your entire hierarchy of dom elements lives under that one, and you can't just use built-in rendering. So it goes I guess. Ideally, CSS transforms would somehow support moving DOM nodes, but I guess that's too much to ask for.
Hi there, I think you are correct in that Decoders are good for decoding a field and not so much a partial field. You can however use functions to transform the value by using Decode.map. Also, you may want to look at one of the parser libraries https://github.com/elm-tools/parser as it may make your job of parsing the string easier. In short: Decode.string |&gt; Decode.map (\string -&gt; &lt;Parser magic here&gt; )
I like that graph editor. I like it a lot.
That's what I feared. At least I know I haven't missed something. I'll continue to just put each module in a single file, except maybe separate out the stuff I call widgets and operators. And focus on making each module small overall rather than breaking them down into smaller files. Thanks.
Wait a minute! When you said is should compile, I thought you meant elm should allow it to compile. The reason it wasn't compiling for me is because I was declaring my module like this: module MyModule exposing( Msg(..) ) &amp;nbsp; I've been fiddling around and changed it to module MyModule exposing(..) and that did compile!
Wait a minute! When you said it should compile, I thought you meant elm should change. I've been fiddling around and found out why my code wasn't compiling. &amp;nbsp; I had module MyModule exposing( Msg(..) ) Which caused a compile error. But this works module MyModule exposing(..) and later in the file I have the: type alias Msg = MyModule.Update.Msg Which does get exposed. &amp;nbsp; Pattern matching doesn't work as you said. But I can do: type SuperModuleMsg = = MyModuleMsg MyModule.Msg And then if I want to do pattern matching later on I need to include MyModule.Update and do: case msg of MyModule.Update.MyMsg -&gt; ... That doesn't look too bad to me.
What edkv says - and make sure Update.elm exposes Msg. But the bigger question is why split out your modules like this to begin with? It is extra work and more indirection for no real gain I can see. You can hide internals using opaque types and controlling what gets exposed, no? I would at least include Model and Update in your top level module. If you consider the kind of ideal use of an Elm module is to define a single data structure + its basic operations, it doesn't usually make sense to split Model from Update. I you have not seen it, Evan's Life of a File talk from elm europe is worth taking a look at.
 module MyModule exposing(Msg(..)) The problem is that this syntax exposes a ``Msg`` union type and its constructors but in your code the ``Msg`` is an alias of a union type, not a union type itself. So the ``(..)`` bit causes an error (you didn't mention which error you had, hope I figured it out correctly based on your code). You can expose it like this: module MyModule exposing(Msg) Also, why do you need to pattern match on that ``Msg`` type in an importing module? What problem are you trying to solve? Perhaps there is a better way. 
Alright, Evan convinced me. I'll stick to large module files unless I notice it to get too hard to manage.
I'm making a Drag and Drop List. I just uploaded the [code to github](https://github.com/AaronCZim/elm-dnd-list) in case you want to see. &amp;nbsp; There are two modules right now, the DnDList module, and Drag (a submodule). Drag uses a downloaded Mouse package to track drag and drop actions. DnDList uses Drag to determine when to change the order of the String items in the list. &amp;nbsp; In my module I pattern match Drag messages within the DnDList update function so that when a drag is finished DnDList updates the order of the items in the list.
Splitting out Model, Update and View into separate files is not a good idea. I started out with elm splitting out into files called Types (Model, Msg), State (update, init, subscriptions) and View (view) since I had no clue and this was suggested to me by some blog post as a good way to organise code - it isn't. But I think you are on the right track now by following Evan's advice. I now tend to create one .elm file for each 'page' in an SPA. Splitting out into separate files things like re-usable pieces of view code, utilities, and HTTP code for interacting with the back-end API. Generally speaking keep a Type together in the same file with the principal functions that operate on it. And that means keeping Model, Msg, init, subscriptions, update and view together in the same file. Until you start to discover good reasons to split things out.
this is a perfectly fine place for that! :D
We (hurwitzlab.org) are cleaning up our shiny new www.imicrobe.us Elm interface that we released last week. It hooks into the Cyverse.org API to access data and compute resources at TACC (Texas Advanced Computing Center).
Nice! Super speedy (I was expecting some delays because of the 3rd party API, but nothing that I even noticed), and very easy to understand and use. :) I'm surprised it seems so insistent I wear a hat. Would it be possible to have hover or click-to-expand text explaining why something was recommended?
Hahaha, this is probably because I hard coded "light rain" as the weather condition just to get the beta up. Once weather conditions is properly assessed you might get suggestions sans hat!
Feather icons for elm: https://1602.github.io/elm-feather-icons/ Tool to render beautiful SVG icons from elm code.
Looks cool
Getting elm-platform@dev running on my machine
Why not a package? Great anyway! :o
I would love to see downloads like they have on NPM (see here for example, on the right: https://www.npmjs.com/package/react).
Actually there are 992 installable packages from Github, that's including effect managers and native modules. From those, 85 have native modules and 29 have effect managers. That would mean that there are ~200 packages which are not on package.elm-lang.org. Check out http://elm-directory.herokuapp.com :)
wow! didn't know about elm-directory :-) thanks!
So folks know, the official package repo does not include "native modules" to ensure that (1) Elm is totally free from runtime errors, (2) that the Elm ecosystem will be portable to different runtimes and platforms in the future, and (3) that the code gen strategy can change easily making all Elm code more efficient. I try to say more about that [here](https://www.reddit.com/r/elm/comments/73ubxo/an_explanation_of_elms_policy_on_native_code/), and I urge people not to depend on what is essentially an unofficial/undocumented back door, especially given the plans about kernel code I outlined many months ago.
The site is getting updated a bit in the next release, so it'll be easier to get time of publication for all packages. That'll make it nicer to make timelines of this. I'd like to have more data available though! In fact, that's [one of the projects](https://github.com/elm-lang/projects/blob/master/README.md#package-search) on my big projects list where there's a nice opportunity for contributing to the community with code.
So the main Elm process and the webworker written in Elm as a headless Platform.Program communicate over ports. It seems a reasonable way to do it. I am tempted to wonder whether something along the lines of this API can be modified/extended. It might need 'join' and some way of passing messages between threads added to it: http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Process Perhaps with a little bit of native code and kernel hacking a new Program type could be invented, that allows a new program to be dynamically created. This program would wrap the creation of a child process as a web worker, and provide the API to spawn/kill/join/send/receive against it. I'm sketchy on the details but I think it could be done. 
The author is interested in AI algorithms, and needs those to be handed off to a background thread, so that long running computations do not stall the UI thread and make it unresponsive. This is the same use case that I encountered when developing my ai-search package. I came up with a not very nice solution by implementing explicit time-slicing. When iterating a search, the search can find a Goal or Complete without finding any goals. It can also return a continuation (Ongoing), that will perform the next step of the search. By using continuations the search steps can be interleaved with UI events, so the UI does not get starved out. But it is not nice to have to do this, I would much rather find a way of doing it with web-workers.
It's an interesting point. I think the problem is in the structured clone algorithm limitations for webworkers API. You cannot send functions to the threads. However we could find a way to send a serialized object or function, but I don't know if this is possible beacuse these limitations: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#Supported_types The Elm's guys have ruled out implementing workers in Elm, beacuse the concurrent webworkers model is not very good :(. 
You right. I have been researching about webworkers, because if you block the UI thread with an expensive process (like AI algorithm), the browser will blame you and then this one can crash. You could have a lightweigh AI algorithm (like a simple path-finder) in the main thread without problems, but if you want to have a procedural algorithm or evolutionary computation, you cannot do it in the main thread. In Elm lang, you have two options: 1- Coroutines: Just like your example with continuations (however, this is not real concurrency). 2- Webworkers: With my approach or another. But keep in mind the limitations that these have.
Yes, it doesn't sound like it is going to be made a priority: https://github.com/elm-lang/elm-compiler/issues/1203 But Evan states that: "I do think you could get Elm running on separate workers totally independently." "I don't think it's blocked on any compiler or core tools stuff." Richard's attempt makes use of ports and not native/kernel modules: https://github.com/rtfeldman/elm-web-workers Despite his comments about it not even being POC quality, it looks like a pretty good starting point to me.
But yes, point taken about not being able to pass functions, and this certainly limits the design options available for the concurrency model. You can see why javascript will not allow a continuation to be passed to a web worker though - otherwise it would be very easy to allow the worker to access the DOM and other browser functionality that is not exposed to the workers. I still think that restricting inter process communication to just what can be expressed as a Json.Encode.Value is useful enough. After all that is the same restriction that ports imposes?
I suppose a 3rd option is: do it on the server side. But there is all those client side CPUs out there, idling away and just waiting for some work... ;-)
Not exactly number of downloads, but [elm-directory](http://elm-directory.herokuapp.com/) shows the number of Github stars for each package. It's a nice estimation of the package's popularity.
In the past I had always reached for `Maybe` in this type of situation. However I've now come to prefer using Union types. Something like: type User = None | LoggedInUser userinfo Then I would write a helper function to determine whether a user was logged in or not (given the User type as an argument) and return the userinfo etc. 
Sure thing, this concept can be converted into a package easily, that's probably what I will do next, since people have found it useful.
Nice! I like it! A feature to work on next could be geting the user's location, either from https://github.com/elm-lang/geolocation or allow them to enter a zip code.
I worry that the kernel packages will become popular and someone somewhere at work will run into runtime errors with confusing stack traces and get a bad impression of elm. While elm directory is nice, I feel like it will be a conduit for this.
That's why the package repo does not allow them, and that's why I keep commenting about this when folks say "I made a way around the restriction" as if that is a positive thing that aligns with Elm's goals or as if the code there will continue to work across releases (which it definitely will not)
This appears to be the same functionality as [Html.Attributes.classList](http://package.elm-lang.org/packages/elm-lang/html/2.0.0/Html-Attributes#classList). What additional functionality does this provide?
Here we go: http://package.elm-lang.org/packages/1602/elm-feather/latest Just published, hopefully it will stay in registry (never published anything before, don't know the rules for moderation of registry).
It's already in the standard library and the implementation is simpler. classList : List (String, Bool) -&gt; Attribute msg classList list = list |&gt; List.filter Tuple.second |&gt; List.map Tuple.first |&gt; String.join " " |&gt; class
Oh no! Didn’t even know that this existed, hadn’t come across it before! I’ll pull down the package so as to not clutter the list. Thanks for pointing out some awesome new core functionality!
I was really surprised that it existed in the core library too. Feels like module has almost entirely just raw html stuff and then suddenly this little helper function too!
This is great, thank you!! (The registry doesn't do any moderation except "`elm-package` won't publish anything with native modules or effect managers that's not whitelisted on [here](https://raw.githubusercontent.com/elm-lang/package.elm-lang.org/master/native-whitelist.json) or [here](https://raw.githubusercontent.com/elm-lang/package.elm-lang.org/master/effect-whitelist.json)" -- so, your package will stay there ;) )
Trying to compose programs with middleware (the hope is one could mix and match between different middleware functionality, like "Log errors to an URL", "Time travel debugger", "Navigation") https://github.com/Janiczek/middleware/blob/master/src/Main.elm
Great minds think alike :)
Nice! Thanks for sharing 
&gt; &gt; downloads &gt; gh stars and also the reverse dependencies please! (mean response time to gh issues... ok I stop)
Hi everyone, I am starting a new project and the back-end is implemented with Phoenix, I am very interested in the channels feature. I was wondering what is the standard way of dealing with Phoenix Channels in Elm, I have seen many different ones like the NoRedInk, but they seem a bit outdated. Thanks everyone
original classNames accepts string or object, but for that you would probably wrap elements with union.
I have added a Navigation example, see (reload) the demo. *[This](https://github.com/Janiczek/middleware/blob/master/src/ExampleProgram.elm#L20-L33)* is how the user program currently looks like. For this (Navigation) functionality it seems to me that using Cmds/Subs is better than using *.program or this middleware pattern, because it's more explicit where the LocationChanged msg comes from. (But, other uses like time-travel debugger would seem to be better suited with this pattern.)
So....does anyone know how to remove a package from http://package.elm-lang.org?
For someone who just uses Html.program. What's the use case of using multiple programs? 
Navigation.program provides additional functionality beyond the vanilla program, so it's conceivable that a complex program may want lots of functionality that is granted by multiple program-creating functions. I'm still new to all this, so I'm not sure. It's my best guess!
Simple invoice view helpers because I got annoyed with LaTeX when I had to add things to a template to comply with local laws. https://gitlab.com/DrBearhands/elm-invoice https://jsfiddle.net/a7jhyzfq/
Thanks for answering. It makes sense indeed. I wonder if it wouldn't be easier if for example Navigation would just provide more access to its internal functions?
IMO Navigation should just be a subscription of `Location` changes.
On my fresh Fedora install when I needed "libtinfo" (I think for stack or GHC, IIRC) I found I needed the package "ncurses-compat-libs". Maybe the same for "Void".. try everything with ncurses in the name I guess =)
See you there! 
I can query xbps-src some more. The only other `ncurses` package I found was `ncurses-term`. Tried installing that already and it did do much. Maybe it's a matter of installing those packages and installing Elm again?
Would ask around in "Void" places, really. Most "mainstream-ish" distros the pkg for libtinfo is easily identified &amp; installed =)
Hope you enjoyed it! I'd imagine I talked to you at some point but your username is not giving me too many clues =)
I think the best approach is to publish a patch update where you change the README and description line in elm-package.json to say "DEPRECATED: Just use Html.Attributes.classList instead" or something along those lines. The package will disappear once Elm 0.19 is out (at which point only packages updated to 0.19 will get displayed).
Really Enjoyed. Meeting people who are willing to hand a helping hand on this subreddit and on Slack is great. I'm Prince btw. 
&gt; I’ll pull down the package so as to not clutter This is why I like the Elm community. 
Navigation probably has `program` because the apps using it frequently need to route based on the initial Location, thus special `init`.
On my system (arch) libtinfo links to libncurses: `libtinfo.so.5 -&gt; /usr/lib/libncurses.so.5` Maybe you can do the same? 
Ah, hey Prince! Great talking to you at the meetup, hope you got some good ideas on how to structure your app/navigation
I ran a `sudo find / -name "libtinfo"` and got squat. I think it's because ncurses doesn't get compiled with whatever option is needed to produce `libtinfo.so.X` 
But do you have a `libncurses`? If so, you don't need `libtinfo`, as `libncurses` provides it's functionality (or is the same thing?). I only have the `libtinfo` symbolic link because I installed this [aur package](https://aur.archlinux.org/packages/ncurses5-compat-libs/) which creates a symlink during [installation](https://aur.archlinux.org/cgit/aur.git/tree/PKGBUILD?h=ncurses5-compat-libs): # fool packages looking to link to non-wide-character ncurses libraries for lib in ncurses ncurses++ form panel menu; do ln -s /usr/lib/lib${lib}w.so.5 "$pkgdir/usr/lib/lib${lib}.so.5" done ln -s /usr/lib/libncurses.so.5 "$pkgdir/usr/lib/libtinfo.so.5" So if you do have `libncurses` then you can probably just create that symbolic link yourself.
Ah ha! There IS some `libncurses.so.*` in `/usr/lib/` (I just did `find / -name "libncurses*" 2&gt;/dev/null`). Specifically /usr/lib/libncursesw.so.6 /usr/lib/libncurses.so.6.0 /usr/lib/libncursesw.so.5 /usr/lib/libncursesw.so.6.0 /usr/lib/libncursesw.so /usr/lib/libncurses.so /usr/lib/libncursesw.a /usr/lib/libncurses++w.a /usr/lib/libncurses.a /usr/lib/libncurses++.a /usr/lib32/libncurses.so.6.0 /usr/lib32/libncursesw.so.5 /usr/lib32/libncursesw.so.6.0 /usr/lib32/libncursesw.so.6 So how do I need to create the symlink with the proper `libncurses.so.*`? `ln -s` what?
Great! Now all you need to do would be: `ln -s /usr/lib/libncursesw.so.5 /usr/lib/libtinfo.so.5` This should work (on my system libtinfo.so.5 links to libncurses.so.5 which links to libncursesw.so.5 which links to libncursesw.so.5.9. You don't have a libncurses.so.5, so I think using libncursesw.so.5 should do) 
Boom it worked. Thanks man! 
I use Elixir/Phoenix and it's never done me dirty.
Elixir is great, but I miss Elm's ecosystem and language simplicity, and a type-system :(
I found out about this recently: https://github.com/wende/elchemy... I am not sure how stable. There is some discussion around it being used along side Phoenix but I am sure this is all experimental at this stage
If you're drawn to the type system and ML syntax then the next step would probably be Haskell or OCaml for the server. 
Depends on what the backend is doing. I've used both Python and Haskell for the backend to an Elm app. Haskell is overkill if the backend is IO-heavy, so if all you are doing is passing input over to a database, then go with Python or Clojure (don't have to mess with the IO monad). If you need/want the type safety then go Haskell. Clojure + ClojureScript is a great choice as well because then you get to use one language for the entire stack :)
You're welcome ;)
Use what you're familiar with! Trying to learn two new languages at once will probably slow you down. Once you become more comfortable with elm, and you end up liking it, definitely give Haskell a try. Imo it's the most "elm-like" analogue for general purpose programming and definitely worth having in your toolbox. 
I suggest checking out [this project](https://github.com/rtfeldman/elm-spa-example) which Richard Feldman created especially as an example of an Elm app with multiple pages at “real world” scale. Here is a writeup of how it works: https://dev.to/rtfeldman/tour-of-an-open-source-elm-spa It uses a lot of techniques that you might not need, or might not need at first – start simple and only add abstractions as you need them. The basic thing is that the app’s model ends up having a union type of all the pages in the app: https://github.com/rtfeldman/elm-spa-example/blob/master/src/Main.elm#L31-L41
 &gt; Clojure + ClojureScript is a great choice as well because then you get to use one language for the entire stack :) That is a benefit but for me personally I think it's beneficial to understand different typing systems in depth. I'm more self taught than anything: in college (not a 4 year school) we're learning *some* JavaScript (I really don't like it), Java and C# (both are "meh") and I had a course on PHP (which I never want to do again). 
and `elm-format`... 
I have made a trimmed down template based on the architecture if you want to get started fast. https://github.com/simon-larsson/elm-spa-template
In short: the loop ends when that Maybe is a Nothing, at which point the value passed to Maybe.withDefault is used as the decoder without calling `loop` again. The function passed to Maybe.map gets called only when the `Maybe a` is a `Just a` – when it’s `Nothing`, the function is not called and `Nothing` is returned. So you never end up with `loop 1 [Nothing]` being called. So what’s happening is each index gets an attempted decoding, if it succeeds then the Maybe is a Just and the next index is attempted to add to the list that’s accumulating. When it’s a Nothing, that means the last numbered index was not a field of the object, so it bails out by returning `Decode.succeed xs` as the “base case” of the recursion process. 
Elixir 1.6 has an inbuilt formatter. ‘Mix format’ I think it is
Wonderful! I'm interested how that will play out as Elixir is a more chaotic programming language than Elm. 
I'm interested in making a browser-based game using Elm. For drawing the canvas I want to use Javascript but I'm not really sure how to achieve this. I know about Ports (and vaguely how to use them), but how would I structure it so that the Elm app calls a Javascript draw function every frame (or just every time the model is updated)?
**Haskell mode on** fmap :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b instance Functor Maybe where fmap func (Just n) = Just (func n) fmap func Nothing = Nothing **Haskell mode off** The Maybe module documentation could be (kind of) improved for people like me. "Transform a Maybe value with a given function." **Unless Maybe a has a value of Nothing.** **map sqrt (Just 9) == Just 3** could be more explicit, and becomes **map sqrt (Just 9) == Just (sqrt 9) == Just 3** Then for **Nothing** it could be mention that in place fo applying the function, Nothing is returned *immediately*. Anyway, thanks James. 
I use Erlang, because I have been using it for years, Elixir would also be a good choice 
I just beat it in seven turns!