I've [previously commented](https://www.reddit.com/r/programming/comments/992qe5/elm_019_released/e4la034?context=3) on the things I dislike about elm. That's not the same as "reasons it's not more popular", but I do think it's related.
I like Elm and as you have said, I somewhat feel like it is the least worse frontend stack I have used among the modern frameworks. But almost everything you mentioned strongly resonate with my feeling of Elm and that’s why I don’t advocate for it at work.
My hot take: - ports produce a lot of boilerplate for very simple tasks. - opaque types are hard to reason about and don't provide the type safety anyone wants - the standard library is too small for real-world use cases (inb4 someone tells me they have a real world use case which elm works fine for) - the language approximates Haskell without most of what makes Haskell great. 
I think not being popular also contributes to it not being more popular. When considering a SPA the React, Vue, Angular, etc ecosystems are much bigger, which make them easier to try out or adopt at work.
Because it is too great for them. The more popular something is, the more likely it is to be stupid.
Cynically speaking, people are lazy morons and would rather write jQuery hacks?
Number two is the big one that keeps me from using it for a real app. 
This is not cynical. This is disrespectful and mean. You're better than this. Be excellent to the others. 
Yeah, I agree
I've used it for a couple of projects, and I think it's just not mature enough yet. Yes, it works reliably in production when sticking to one version, but upgrading to 0.19 breaks compatibility all over the place. It's also just frustrating when features are removed. I hope that the next releases are more frequent, and have fewer breaking changes.
But don't JS libraries release new versions on a daily basis?
I really like Elm the frontend library, but not Elm the excessively limited language.
Fifth: Typescript 
Elm is doing something radically different -&gt; practical, purely functional programming. Hard to be different. Plus, React is the most popular programming framework ever. Even 1% of React's take up is a success.
Because there is no marketing team behind it. Yes, I mean it, look at ReasonML, the moment it launched various React thought leaders started hosting all these new Reason conferences and workshops, social media (Twitter, Reddit) was bombarded with it. A lot of time was spent on the official website, unlike Elm's, where 0.19 docs still have broken links and wrong information half a year later. In less than a year Reason passed Elm as the third most used language on the front-end and it's not because people are extremely excited to use OCaml on the front-end, it's because they have PR people and the creator of the language doesn't spend all his time policing every single thread on Reason's forum.
I don't know others why they didn't choose ELM but in my case I found ReasonML more useful. So people have other choices too. ELM is nice but I felt like limited then I quickly switched.
release and \*break\* the hell out of everything with no check whatsoever... Sorry, I've upgraded react-native two days ago on a large codebase -\_-
The alternative (JS on npm) offers you: 1 - daily (or hourly...) updates 2 - unknown breaking changes (not even the maintainers know them sometimes) 3 - broken semantic versioning At least in Elm if you can't upgrade, what you have works fine. I'm still on 0.18 because \*it just works\*. No rush :-)
The problem is that new Elm versions break backwards compatibility, so no libraries work anymore. Javascript has a lot of problems, but not that problem. 
&gt; Interop with existing Javascript can be confusing, and the most recent version of Elm has made it more difficult (not passing judgment here, just sayin). I used to advocate elm, get friends to try it, I would teach it at work and got it adopted for projects at work. But then 0.19 showed us that Elm doesn't care if users suffer and there's no way around its new restrictions. And when we tried to reach out we and others were met with an extremely hostile response (threads removed &amp; locked, etc.). Now, I actively discourage elm and we've transitioned every line of code away. It's a nice language, but it's not a language that we can use in production anymore. Your mileage may vary but 0.19-like decisions can happen at any moment, for any reason, and that's incredibly scary and discouraging.
&gt; The problem is that new Elm versions break backwards compatibility, so no libraries work anymore. While some libraries are left behind by their authors, most important libraries are available at or very shortly after the release of a new Elm version. Also, please note that Elm encourages a style of programming that rests less on external libraries than something like JS. In other words, fewer dependencies. This means that in practice there are very few library issues that need to be addressed. 
In what aspect? Elm is more expressive than any other mainstream language.
Elm is to Elmish as Smalltalk was to OO. Maybe? Influence a new way of programming without becoming the defacto standard language for said way. Hmm. 
I'd actually like to dispute that. Rust is mainstream-ish now, and has a much nicer type system. I like Elm records, but that's basically the only advantage it has (in type system terms) over Rust, which has actual typeclasses (traits), unlike Elm's bodged-in `comparable`. Funnily enough, despite basically using the C++ approach for it, it has *better* custom operator handling than Elm now. As I said [here](https://www.reddit.com/r/elm/comments/azwo7p/a_journey_from_elm_018_to_019/eid5zr2/), I mean "limited" as in "doesn't really trust the user".
Depends on what you mean by "real app". I've lost a lot less time to language upgrades than some of the horror stories on here by KISS, and have a lot of Elm apps in production. When Elm upgrades, the compiler tells me exactly what is broken and an automatic updater does the first 50% for me. When an npm library updates, who the f\*ck knows? I hate my npm-package-heavy projects so much more than my Elm projects.
That incompatibility is the main blocker. I learned elm back in 2016 (iirc) only did a few toy projects, interested in Haskell and functional programming back then. Then the breaking changes between versions occured and i am sure i don't want to use it in my work projects for that reason alone. I mostly stick to typescript since then. I mean Evan Czaplicki is sure as hell a very brilliant person, and Elm is a nice language, but IMO he's killing Elm's momentum by doing that.
Can I ask what you transitioned to? I'm also facing moving away from Elm due to the restrictions in 0.19 which will cause me huge/impossible problems. I really like the Elm architecture and it has worked extremely well for my uses, and a strict type system has been a great help, so I'm looking for something similar. I don't find React or other mainstream JS libraries very tempting. My main options at the moment seem to be [bucklescript-tea](https://github.com/OvermindDL1/bucklescript-tea) along with [philip2](https://github.com/darklang/philip2) to help convert. Do you know of other good options?
I feel exactly the same way you do. I also use Haskell on the backend, so it would be really sad to give up a static type system on the frontend. I moved to ReasonML. It has active developers and corporate support (FB uses it production which gives me a lot more confidence about its stability and future), a static type system (ML's system instead of a Haskell-like system, so there's something to adapt to), and an awesome implementation of React. Far better than the js one. It's a very mature compiler, just based on a standard Ocaml compiler. You can use it on the frontend or the backend. Performance is crazy good, like native js or better. But it is far newer, so examples/docs are less well-developed, but I could always find enough answers.
Looks interesting but sadly it’s in the middle of my workday
I really like what Elm is doing, but you have to admit that it's a steep step from commonly known languages like JavaScript if you're not used to the purely functional approach. Also, some of the recent changes were justifiable, but still very controversial. The guys avoided providing a Foreign Function Interface for a good reason, but this doesn't help the fact that using ports can result in bloated code for simple stuff. I think the language itself is very well designed and definitely better than a lot of frontend languages out there, but the tooling feels lacking.
I think it’s also a different approach. Evan as the creator of elm has expressed at multiple occasions that the is thinking about elm long term, and that getting things right is more important to him than getting things fast. I am seeing this being reflected in many decisions: - don’t allow too tight of a binding to js. It certainly makes development slower in the short term but could enable compiling to other targets in the farther future without many changes - enforce your own package ecosystem. Again that’s slower, but yields better results in the long term - slower release cycles - enforcement of semantic versioning. It doesn’t allow you to upgrade on the first day of a release if your dependencies haven’t, but when they do you can be sure that tings still work as before In terms of growth goals elm might be more comparable to ember, who is still usable and evolving after years. What I want to say that exponential growth is not the only curve to grow by where often the decline is similarly exponential. Be aware that depending on where you ask you will get very different responses. This subreddit seems to be followed by a lot of people who have decided that elm does not fit the needs of their projects. It you ask the same question on the elm Slack or discourse, who are mainly populated by active elm Users, the responses would surely be different. If you want to hear Evens definition of success, have a look at this https://m.youtube.com/watch?v=uGlzRt-FYto
Cool, thanks so much for sharing!
*Hewwo sushi drake!* It's your **2nd Cakeday** hello_from_denmark! ^(hug)
Dillon is awesome!
You could have 100,000 references to the message created in memory, all pointing to the one instance. That is a different scenario to having the messages created on the fly.
Large projects welcome then I guess?
Yes, large projects would help to test if the reducing mechanisms are effective
Yes, exactly. The bigger the better!
&gt;the [Map.! bug](https://github.com/elm/compiler/issues/1851) Why is the issue locked if it is still open?
Its a meta-issue, only a collection of failure cases. Its locked, so it stays an overview and people submit new issues instead of commenting the meta issue.
Same here. /u/dillontkearns will it be recorded and uploaded to YouTube (or other hosting)?
Hello /u/Brasilikum and /u/Magnetic_Tree. Yes, it will be available for one week after the event is over 👍 Just go to the crowdcast URL above after Tuesday to watch the recording!
Great, looking forward to watching!
&gt; Another is less chance of messing things up in the update function by using a potentially outdated entity (not sure this would occur in practice in well-designed code, but it seems at least theoretically possible). I think this can go both ways. If the entity is outdated, you might *want* to do something with the value-as-was, not the value-as-is. Or at least to notice that it's outdated. (E.g.: your entity has an id, a value, and a flag "saved". You don't want to set that flag if the value that was saved is different from the current value, so you need to pass around the value and not just the id.)
My view on the matter, its a tradeoff. But this seems like pre-mature optimization. By sending complex objects, you turn towards 'trusting the server' more. Meaning implicitly: the server contains the up-to-date info and the client is just a 'dumb view' of the state on the server. For me, this makes the update function very simple, because the server is sending you a whole brand new object, you just swap it out with the old one and thats it. No more fine grained deltas and diffs that need to be figured out at runtime, just a new state to be swappped out and rendered (that may have only changed very little). Obviously the downside is higher bandwidth usage and more re-rendering. But I find in almost every case the slightly higher costs are paid for with much simpler and maintainable code. The only time I would switch to 'slim' messages is when you are sending tiny diffs of huge blobs of data and/or are getting into the 100s of thousands of concurrent users, which for 99% of people, is never. So I usually strike a balance, try to have 'coarse grained diffs': Say you have a list of objs that can be appened to, break that into 2 msgs, an `Init [Obj]` and `Concat [Obj]`. Dont try to make the whole thing work with only either a single msg message that sends the entire state every update or single `Append Obj` message that will send 100 seperate appends per init. In summary, bandwidth is cheap, developers (and bugs) are expensive. Try to keep your code as simple as possible for as long as possible. Only buy into the extra complexity if you know it pays for itself, otherwise keep to the simple (slightly wasteful) ways. You'll thank yourself later thart you kept it simple.
I don't know if it is on purpose, but you have a typo: ``` let menu = model.menu updatedMenu = { menu | title = "Hello, world!" } in { model | menu = updatedMenu } ``` Nevertheless, that kind of typo is exactly why I find nested updates so annoying.
What i also catch myself doing is something like: ```elm let menu = { model.menu | title = "Hello, world!" } in { model | menu = menu } ```
I might have been unclear; I was only thinking of client-side, and was only thinking about the MVU loop, i.e. messages/actions being sent from the client's \`view\` and being handled in the \`update\` function. No server communication involved.
Usually you want to keep your records as flat as possible. If that's not possible you should add helper functions to update nested records.
Entity IDs are the way to go, especially with an immutable language, to avoid the possibility of synchronisation issues. Richard Feldman spoke about this on his [great talk on immutable relational data](https://www.youtube.com/watch?v=28OdemxhfbU).
Extreme nesting is discouraged. For simple nesting you can extract the relevant records in the parameters of the function: update msg ({ menu } as model) = case msg of UpdateMenuTitle title -&gt; ({model | menu = { menu | title = title}}, Cmd.none)
Haha, no that was not on purpose but I guess it illustrates that this can give some small bugs :)
Why is it discuraged? Because nested data in itself is a bad practice or because Elm is not good at dealing with it?
Why is it discuraged? Because nested data in itself is a bad practice or because Elm is not good at dealing with it?
It's not always bad practice, for example in SPAs it makes sense that the model contains the pages of your app in [subpages](https://github.com/rtfeldman/elm-spa-example/blob/master/src/Main.elm). However as you've experienced it increases complexity quite a bit and they're cumbersome to work with. In languages like Haskell you use a library called lenses which is [extremely complex](http://hackage.haskell.org/package/lens). It can also easily lead to bugs with inconsistency. This all gets mitigated if you have flat structures from the start. If I recall correctly [this talk](https://www.youtube.com/watch?v=28OdemxhfbU) gives some examples of what you can do instead.
Extreme state partition is considered bad practice in Elm. You could read more about structuring code in the [Structure](https://guide.elm-lang.org/webapps/structure.html) page of The Guide. The relevant bits are the ones from the `Components` subsection. Historically, the Elm Architecture tutorial used to describe a way to split code into modules that would contain their own model, view and update BUT this got abused. Some folks took this to an extreme and there were a lot of discussions about inter-component communication, discussions that would have not happen if the state would have not been split as aggressively as it was. So, the whole "component" idea has been considered a bad idea and has been discouraged ever since. There is still place for this pattern, for example, when implementing highly complex pages BUT, it should be used with great restrain. Also, there were discussions about all kinds of extensions of syntax that would make handling nested state better. There was even a library ( [focus](https://github.com/evancz/focus) ) where getting and setting deeply nested code was explored. The conclusion of this exploration was: &gt; I have yet to see any code that follows The Elm Architecture that gets better by adding this library. Elm actively tries to be good at not letting you shoot yourself in the foot. Some people dislike this, some have no clue how much pain this saved them. 
Yeah I was just thinking of that talk actually. Elm made me appreciate SQL as a bonus :P Thanks for the answer!
Thanks for the reply. Good points to think about. Yes I noticed that while frustrating at times, I have been benefiting from the restraints of Elm so far. Usually after a couple of functions I realize that I can just reuse a function very easily because I had to think about making it smaller much earlier hehe.
You are almost there. Can you work out how to get from `Decoder (List (String, Service))` to `Decoder (List Service)` ? 
Thanks! Interesting talk. However, it does not address my specific question. I am well aware of the "dicts as tables" approach and use it extensively in my models to avoid multiple sources of truth, nested record updates, etc. :) However, my question was specifically about whether it's okay for e.g. the view to send whole complex domain objects (and not just object IDs) in messages to the update function.
Wouldnt that then introduce the possibility of sync issues if, for example, your program receives a message with `Person` object, however that person's `age` is different from what's in your entity model?
\#635 and #537 have been rotting since 2014. It should have been taken care years ago. &amp;#x200B; see [https://github.com/elm/compiler/issues/1375](https://github.com/elm/compiler/issues/1375)
Yes, that is certainly generally possible. It might not happen in practice if, for example, an update to a `Person` will always cause a re-render, passing the updated `Person` to the view which is then what the view will attach to the message. To be clear, I don't doubt that IDs in messages is generally the more robust solution (as in has the least probability for bugs); I just find it to cause some consternation regarding lots of lookups in `update` and handling of seemingly invalid/impossible error cases regarding missing entities ("seemingly impossible" here being true if one considers the view an up-to-date reflection of the model - whether that is a valid assumption is also something I'll happily take inputs on). Hence my question about insights into this issue.
Thanks for your reply. You've understood the problem I see, but I'm asking precisely because that's the bit that I can't work out. Something to do with mapping using Tuple.second maybe, but I just cannot get it to work.
Looking at that video made me wonder if you can model pages as relational data but I'm not sure.
You have two levels to map through: the `Decoder` and the `List`. Maybe start with `List (String, Service) -&gt; List Service` ?
Op said it was a different message payload for each button so it can't be the same segment of memory for each one.
You will need to decode it as a Dict and then discard the keys. Take a look: https://ellie-app.com/52mRbtk58Wja1
When you mix values and types together, that's known as dependent types. For instance, a "number between 0 and 10" would be a dependent type. Idris is a language that has those. Elm does not. I think what you want will have to be represented with runtime checking, not types. For instance, one way to go would be to make a data structure like a Set or [TSet](https://package.elm-lang.org/packages/bburdette/typed-collections/latest/TSet). Here the uniqueness is enforced by runtime checks, not by types. You could also make an opaque type where the user doesn't have access to the data structure constructor directly, they have to use a function instead. Your uniqueness constraint could go in that code. 
For my small hobby SPA and my novice level skills, the migration form 0.18 to 0.19 has been pretty straightforward except the loss of websockets. The dates and times changes initially appeared daunting, but were quick and more elegant. A recommendation of [time-elements](https://github.com/github/time-elements) was a big help. I find the new HTTP model to be much easier and friendlier. &amp;#x200B; The loss of websockets left me with the biggest task, namely figuring out a replacement. The community has been plenty clear about what adopting 0.X releases entails. * Continue on 0.18 * Roll your own through ports * The kind folks on Slack were quick to point out [elm-websocket-client](https://github.com/billstclair/elm-websocket-client/) * Switch to long-polling, probably using [elm-sweet-poll](https://github.com/NoRedInk/elm-sweet-poll/), and enhance my backend to add the end point. &amp;#x200B; All are viable and I'll probably use one of the 3rd party packages. But they are heavier than 0.18's websockets. Both ship with examples, but I'm reluctant to figure out how they work . &amp;#x200B;
Try modeling this things in functions, as i can think you have to different things, guilds, and actions. type Action = Sail | CollectTaxes | Build | Sell Int | Buy Int type Guild = Merchant | Solider 
I would probably use an approach closer to 2. Except rather than have a Sail,Explore,Research I would have Sail,Explore,Research,SailAndExplore,SailAndResearch,ResearchAndExplore. That is unless the order you choose them matters.
If you have three choices, and you want to select two, that can be represented by just telling me which choice you DIDN'T make. How about this (Using Approach 2) type GuildAction =NoAction |OneExplorerAction ExplorerGuildAction |AllButNotExplorerAction ExplorerGuildAction |OneSoldierAction SoldierGuildAction |AllButNotSoldierAction SoldierGuildAction ! . . . (and so on) This way you only specify one action, either the one you are doing, or the one of the three that you are ignoring. But, we can do better than this. //Keep the approach 2 types from the original post type GuildAndAction = ExplorersGuild ExplorersGuildAction | SoldiersGuild SoldiersGuildAction | MerchantsGuild MerchantsGuildAction | BuildersGuild BuildersGuildAction type Actions =NoAction |OneAction GuildAndAction |ExcludedAction GuildAndAction Now, your types represent what you want, and there can be no illegal states. You do have to be careful as you code at the input phase, because now, going from having selected one action, to selecting two actions means your code has to figure out which is the "left-out" action and return that.
Remember that the most important is to make impossible states impossible through the exposed API, so if this is not possible with types only, restricting exposed functions can help to achieve correct states for users of the API (maybe just another module), even if impossible states are possible inside the implementation. Pushed to the extreme for the fun, it is possible to make an API that enforces the Seafall rules by using phantom types (another example is the [elm-css phantom-types branch](https://github.com/rtfeldman/elm-css/tree/phantom-types). [Here](https://ellie-app.com/535dbdWgJWJa1) is an Ellie example. It enforces: * choose a first action, then a second one or `pass` * actions must be from the same guild * actions must not be the same * actions are ordered * `sail` and `pass` work for any guild (you could have specific guilds `sail` versions if preferred) You can try to play incompatible actions and see that it does not compile anymore. I believe however that such an API is so strict that it may not be really usable in an application. This will compile: play joinExplorers sail explore == (Sail, Just Explore) play joinExplorers explore research == (Explore, Just Research) play joinExplorers explore pass == (Explore, Nothing) play joinSoldiers sail raid == (Sail, Just Raid) This won't compile: play joinExplorers sail raid play joinExplorers pass explose Here is the code, remember to use this technique with great moderation, only when it really makes sense: module Seafall exposing ( Action(..) , play , joinExplorers, joinSoldiers, joinMarchants, joinBuilders , sail, pass , explore, research , raid, collect , buy, sell , repair, build ) {-| @docs Action @docs play @docs joinExplorers, joinSoldiers, joinMarchants, joinBuilders @docs sail, pass @docs explore, research @docs raid, collect @docs buy, sell @docs repair, build -} type Action = Sail | Explore | Research | Raid | Collect | Buy | Sell | Repair | Build type alias Acted turn = Turn { turn | acted : Yes } type Turn actions = Start | FirstAction Action | Turn Action (Maybe Action) type Yes = Yes type No = No joinExplorers : Turn { acted : No , sail : Yes , explore : Yes , research : Yes , raid : No , collect : No , buy : No , sell : No , repair : No , build : No } joinExplorers = Start joinSoldiers : Turn { acted : No , sail : Yes , explore : No , research : No , raid : Yes , collect : Yes , buy : No , sell : No , repair : No , build : No } joinSoldiers = Start joinMarchants : Turn { acted : No , sail : Yes , explore : No , research : No , raid : No , collect : No , buy : Yes , sell : Yes , repair : No , build : No } joinMarchants = Start joinBuilders : Turn { acted : No , sail : Yes , explore : No , research : No , raid : No , collect : No , buy : No , sell : No , repair : Yes , build : Yes } joinBuilders = Start sail : Turn { turn | sail : Yes } -&gt; Acted { turn | sail : No } sail = do Sail explore : Turn { turn | explore : Yes } -&gt; Acted { turn | explore : No } explore = do Explore research : Turn { turn | research : Yes } -&gt; Acted { turn | research : No } research = do Explore raid : Turn { turn | raid : Yes } -&gt; Acted { turn | raid : No } raid = do Raid collect : Turn { turn | collect : Yes } -&gt; Acted { turn | collect : No } collect = do Raid buy : Turn { turn | buy : Yes } -&gt; Acted { turn | buy : No } buy = do Buy sell : Turn { turn | sell : Yes } -&gt; Acted { turn | sell : No } sell = do Sell repair : Turn { turn | repair : Yes } -&gt; Acted { turn | repair : No } repair = do Repair build : Turn { turn | build : Yes } -&gt; Acted { turn | build : No } build = do Build do : Action -&gt; Turn a -&gt; Turn b do action turn = case turn of Start -&gt; FirstAction action FirstAction firstAction -&gt; Turn firstAction (Just action) Turn firstAction secondAction -&gt; Turn firstAction secondAction pass : Turn { turn | acted : Yes } -&gt; Turn { turn | acted : Yes } pass turn = case turn of Start -&gt; -- impossible due to types Start FirstAction firstAction -&gt; Turn firstAction Nothing Turn firstAction secondAction -&gt; Turn firstAction secondAction complete : Turn { turn | acted : Yes } -&gt; ( Action, Maybe Action ) complete turn = case turn of Start -&gt; -- this is wrong, but this cannot happen with the exposed API ( Sail, Nothing ) FirstAction firstAction -&gt; ( firstAction, Nothing ) Turn firstAction secondAction -&gt; ( firstAction, secondAction ) play : Turn a -&gt; (Turn a -&gt; Acted b) -&gt; (Acted b -&gt; Acted c) -&gt; ( Action, Maybe Action ) play join firstAction secondAction = join |&gt; firstAction |&gt; secondAction |&gt; complete 
That's brilliant thanks. As I suspected it's really obvious quite once you see it.
I came up with this as a quick challenge (it works), although there may be a cleaner solution (less maybes?): &amp;#x200B; \`\`\`elm type Route = Home | Products | Contact &amp;#x200B; &amp;#x200B; fromUrl : Url -&gt; Maybe Route fromUrl = Parser.parse routeParser &gt;&gt; Maybe.andThen identity &amp;#x200B; &amp;#x200B; routeParser : Parser (Maybe Route -&gt; Maybe Route) (Maybe Route) routeParser = Parser.map parseFragment (Parser.fragment identity) &amp;#x200B; &amp;#x200B; parseFragment : Maybe String -&gt; Maybe Route parseFragment fragment = case fragment of Just "home" -&gt; Just Home &amp;#x200B; Just "products" -&gt; Just Products &amp;#x200B; Just "contact" -&gt; Just Contact &amp;#x200B; \_ -&gt; Nothing
Ellie doesn't seem to work for me at the moment, so I'll paste it here: Given this union type: `type Route` `= Home` `| Products` `| Contact` I assume that you want to write the following function: `fromUrl : Url -&gt; Maybe Route` Here is a quick implementation, there may be a cleaner solution though: fromUrl : Url -&gt; Maybe Route `fromUrl : Url -&gt; Maybe Route` `fromUrl =` `Parser.parse routeParser &gt;&gt; Maybe.andThen identity` &amp;#x200B; `routeParser : Parser (Maybe Route -&gt; Maybe Route) (Maybe Route)` `routeParser =` `Parser.map parseFragment (Parser.fragment identity)` &amp;#x200B; `parseFragment : Maybe String -&gt; Maybe Route` `parseFragment fragment =` `case fragment of` `Just "home" -&gt;` `Just Home` `Just "products" -&gt;` `Just Products` `Just "contact" -&gt;` `Just Contact` `_ -&gt;` `Nothing`
This looks like exactly what i needed! Appears that I was over complicating things in my attempts. Thanks 
You could also use [the trick used by elm-spa-example](https://github.com/rtfeldman/elm-spa-example/blob/master/src/Route.elm#L59-L65). 
This.
If it's just classes based on a condition, then `Html.Attributes.classList` is what you're looking for.
These attributes are just examples, in reality I conditionally add all sorts of attributes
Take a look at the code for classList. You can make functions for other attributes and use them similarly. 
I've run into this pattern a lot and it always feels bad. It also comes up when you need to add children or css styles conditionally. One approach I've used is to do something like this: &amp;#x200B; view : Model -&gt; Html Msg view model = let attr1 = if model.condition1 then [ class "abc" ] else [] attr2 = if model.condition2 then [ id "xyz" ] else [] in input ([type_ "text" , class "abc" |&gt; justIf model.condition1 , id "xyz" |&gt; justIf model.condition2 ] |&gt; filterMaybe ) [] justIf : Bool -&gt; a -&gt; Maybe a justIf condition x = if cindition then Just x else Nothing filterMaybe = List.filterMap identity But I'm not a huge fan of this either. The fact that you have to wrap the whole thing in another set of parenthesis makes it not much cleaner imo.
You can construct the attributes using `List.concat`: addIfNeeded : Bool -&gt; Attribute msg -&gt; List (Attribute msg) addIfNeeded isNeed attr = if isNeed then [ attr ] else [] view : Model -&gt; Html Msg view model = input (List.concat [ [ type_ "text" ] , addIfNeeded model.condition1 (class "abc") , addIfNeeded model.condition2 (id "xyz") ] ) [] Alternatively, you can have some kind of `none` attribute that you return conditionally. orNone : Bool -&gt; Attribute msg -&gt; Attribute msg orNone isNeed attr = if isNeed then attr else Html.Attributes.property "none-placeholder" (Json.Encode.bool False) view : Model -&gt; Html Msg view model = input [ type_ "text" , orNone model.condition1 (class "abc") , orNone model.condition2 (id "xyz") ] [] 
Hey, is it uploaded anywhere else?
Here's how it might look if you took the same approach for attrs ``` view : Model -&gt; Html Msg view model = input (conditionalAttrs [ ( class "abc", model.condition1 ) , ( id "xyz", model.condition2 ) , ( type_ "text", True ) ] ) [] conditionalAttrs : List ( Attribute, Bool ) -&gt; List Attribute conditionalAttrs attrs = attrs |&gt; List.filter Tuple.second |&gt; List.map Tuple.first ```
Looks like there is no current solution. I wonder how easy it would be to add an Attribute.Batch function
It's only on crowdcast. Is that not working well?
You could use a helper function like this: consIf : Bool -&gt; a -&gt; List a -&gt; List a consIf cond x xs = if cond then x :: xs else xs &gt; consIf True 0 &lt;| consIf True 1 &lt;| [2,3] [0,1,2,3] : List number &gt; consIf True 0 &lt;| consIf False 1 &lt;| [2,3] [0,2,3] : List number &gt; consIf False 0 &lt;| consIf True 1 &lt;| [2,3] [1,2,3] : List number You example would look like [ type_ "text" ] |&gt; consIf model.condition1 (class "class1") |&gt; consIf model.condition2 (class "class2") -- ... |&gt; input 
You can try [arowM/html](https://package.elm-lang.org/packages/arowM/html/latest/).
This is delicious. Thank you.
One way to do that would be create a type that has three properties to hold the indexes and then [fold](https://package.elm-lang.org/packages/elm/core/latest/List#foldl) over the list and add each of the indexes to the proper list in that type. However since fold doesn't seem to have access to index you can use [indexedMap](https://package.elm-lang.org/packages/elm/core/latest/List#indexedMap) first to make a tuple with the index and value. something like this: ``` type alias Indexes = { Negatives: Int List , Zeros: Int List , Positives: Int List } source = [-1,-1,-1,0,0,0,1,1,1] start = { Negatives = [], Zeros = [], Positives = [] } folder (index, value) state = match value with | 0 -&gt; { state with Zeros = index :: state.Zeros } | x when x &lt; 0 -&gt; { state with Negatives = index :: state.Negatives } | x when x &gt; 0 -&gt; { state with Positives = index :: state.Positives } source |&gt; List.indexedMap Tuple.pair |&gt; List.foldl folder start ``` take this as pseudocode as I just typed it into here and switching between f# and elm causes me to make silly syntactical errors :(
\`\`\` getIndex : ValueType -&gt; List Int -&gt; List Int getIndex valueType = let compare = case valueType of Zero -&gt; (==) 0 &amp;#x200B; Positive -&gt; (&lt;) 0 &amp;#x200B; Negative -&gt; (&gt;) 0 in List.indexedMap Tuple.pair \&gt;&gt; List.filterMap (\\( i, a ) -&gt; if compare a then Just i &amp;#x200B; else Nothing ) \`\`\`
``` getIndex : ValueType -&gt; List Int -&gt; List Int getIndex valueType = let compare = case valueType of Zero -&gt; (==) 0 Positive -&gt; (&lt;) 0 Negative -&gt; (&gt;) 0 in List.indexedMap Tuple.pair &gt;&gt; List.filterMap (\( i, a ) -&gt; if compare a then Just i else Nothing ) ```
Looks good. A few pointers though: 1) Traditionally, the different values of the custom type are called \`Cons\` and \`Nil\`. That's just history though, I like your names better. 2) \`snoc\` and \`map\` are not stack-safe. With a big enough list, they will crash at runtime. \`elm/core\` implements \`map\` and \`filter\` using \`foldr\`. 3) You'r implementation of \`foldr\` is correct and stack safe. There are different ways of making it faster though. You could use pattern matching to apply the function at up-to four elements at a time (loop unrolling), but this isn't stack safe so you need some way of handling that. You could take a look at how \`List.foldr\` is implemented in \`elm/core\`. The implementation is in pure Elm.
Here is an approach where the result is a dictionary where `-1`, `0` and `1` are keys and the values at those keys are the lists of indexes: https://ellie-app.com/58kYbf8c7Bpa1
Thanks for the tips, I have seen Cons and Nil used, I might put a comment in about them just for some historical context and to make it easier for people to google other examples. &amp;#x200B; To be honest, I did see the way Elm's List was implementing map and how foldr was using what you're calling loop unrolling, but I didn't understand them and didn't want to implement them without understanding why/how they do things. I'll dig into stack safety and educate myself a bit more before I make the updates.
 signIndexes : Order -&gt; List Int -&gt; List Int signIndexes compareTo0 l = List.indexedMap Tuple.pair l |&gt; List.filterMap (\( idx, a ) -&gt; if compare a 0 == compareTo0 then Just idx else Nothing ) signsIndexes : List Int -&gt; ( List Int, List Int, List Int ) signsIndexes l = ( signIndexes LT l, signIndexes EQ l, signIndexes GT l ) &gt; signsIndexes [-1,-1,-1,0,0,0,1,1,1] ([0,1,2],[3,4,5],[6,7,8])
When solving anything conditional like this I personally prefer "if" naming. For this kind of situation you could define "attributeIf" like below &amp;#x200B; attributeIf : Bool -&gt; Attribute msg -&gt; Attribute msg attributeIf condition attribute = if condition then attribute else Html.Attribute.class "" view : Model -&gt; Html Msg view model = input [ type_ "text" -- if you'd rather read "attributeIf first" , attributeIf model.conditionOne &lt;| class "abc" -- if you'd rather read your actual attribute first , id "xyz" |&gt; attributeIf model.conditionTwo ] [] &amp;#x200B; Class is, as far as I can tell, the safest "none" attribute. Adding an empty class into your list of attributes should never change the way your HTML renders. Similarly, you can even implement a function like `viewIf` using the same principal but with an empty text node instead of empty class. &amp;#x200B;
It might help looking at the code that the elm compiler generates for these functions. :)
How to watch it ? I don't want to sign up just to watch a video. Maybe you should consider post this into something more discoverable?? Youtube is a great place.
Does anyone else find it a little concerning that there aren't more questions being posted here?
Maybe somebody could point me in the right place here. My question is about the Elm initialization method used. &amp;#x200B; &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Boom&lt;/title&gt; &lt;script src="elm.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script&gt; Elm.Main.init({ node: document.getElementById("app") }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Is there a way to compile my application to not need this "Elm.\[module\].init" method of initialization? I am looking for something I can give to a client and all they need to do to is include the javascript in their header (or body), without also having to include an extra "script" block with some inline code.
I think you could add an extra step when you compile, like this: elm make src/Main.elm --output=app.js echo "Elm.Main.init({ node: document.getElementById('app') });" &gt;&gt; app.js The first line creates the `app.js` file, and the second line appends a bit of extra stuff. Then when someone else adds `&lt;script src="app.js"&gt;` it will have that extra part. But now you have to be sure to put this script below the creation of the node with `id="app"` Does that help with your situation?
Yes. I haven't tried this solution yet.. but I don't know why it wouldn't work. I don't know why I didn't consider something this simple.
I think it's just a case of community migration. I used to post questions here every once in a while, but it's just so much faster and easier to get feedback on Slack.
Could always just create the node in the start-up script.. Or put an event listened for content loaded and start it there
Great question! Elm is very different from languages that allow for side effects (randomness being an example of a side effect. More common side effects might be HTTP requests or logging to the console), in that Elm does not allow for side effects inside of functions. Instead, you have to tell elm, *hey elm, can you please do a thing that does side effects? And can you then tell me what the outcome is?* so you might have a function like `generateRandomInt` that tells elm to do side effects, meaning that it returns a Command: generateRandomInt -&gt; Cmd Msg Where `Msg` is what elm will eventually produce. Once elm does the side effect, you can then access the value within your update function! Here's an example: https://ellie-app.com/5cN5SwSRV4Ya1 p.s. You should definitely read through [the guide](https://guide.elm-lang.org/effects/random.html) if you already havent!
I have finished the guide like 3 times already just i dont understand the entire type system. There are things like Cmd i have no clue where they are defined from. Coming from Rust where everything so explicit elm feels like dynamically typed everything is just floating around
And i already dont understand one thing all the examples are adding a ton of app logic on top of the thing i already dont understand. Official docs for random for instance writes the description of generate function but instead off giving an example uses another function named pair. If i dont understand single generate how am i supposed to understand the pair one or am i supposed to use everything in pairs always
In Elm, there is actually no function that *returns* a random number. This can be very frustrating at times but there is a good reason for it. Elm is a purely functional language and it takes that pureness very seriously. If there was a `random` function, then it would return a different value each time you called it which would make it impure and break a lot of the cool things that Elm does for you. &amp;#x200B; If you do want to get a random number, you have to move that randomness outside of your code and into the Elm runtime. [This is a good code example for how to do that](https://guide.elm-lang.org/effects/random.html) At a high level, this is what's going on in that code: In Elm, your `update` function takes a message the old state and returns a new state along with a *command*. The command is something that gets sent to the Elm runtime and requests some asynchronous process to start, like "start downloading this URL" or "send this value to JavaScript". In the case of random numbers, you can use `Random.generate` to say "start generating a random number for me." You can register a message for this so when the task is done, it comes back into your `update` function as an ordinary message. &amp;#x200B; This works pretty well for most things but it can feel a little over the top for a random number. Often, you can get around using actual random numbers by doing something deterministic. For example, when I have needed to make unique identifiers for things, instead of using random ones I got them from a counter in my model that I incremented each time. If you initialized this counter randomly at the beginning of your program (see [flags](https://guide.elm-lang.org/interop/flags.html)) and then took some weird hash function of it every time you wanted to use it, you could get something very random looking without ever breaking determinism.
For all practical purpose, Elm is not a scripting language. It is used in conjunction with the Elm Architecture. Cmd's are used with the Elm Architecture, as you can execute them in your update function. There is no way ever that you'll be able to have a function just return a random value in a vacuum.
but thats the point i dont want Cmd Msg i need just an int and i cant find the definition of neither Cmd nor Msg anywhere in the docs as i understand Msg is a generic type but what is Cmd then
Going to respond to both of your comments in here. &gt; And i already dont understand one thing all the examples are adding a ton of app logic on top of the thing i already dont understand. I understand. I had a similar feeling when I was learning elm. What I would recommend is for you to build something tiny first. I tried building a to-do app as one the first few things for example. https://github.com/gDelgado14/elm-todo-mvc There's not much advice I can give other than to recommend you break examples down into smaller pieces to make sure that you indeed understand what you're reading. &gt; There are things like Cmd i have no clue where they are defined from. Coming from Rust where everything so explicit elm feels like dynamically typed everything is just floating around A lot of programming languages have types "floating around", even rust. In Rust, you don't have to import `Vec` to use it. Same thing with `Cmd` and a few other types for Elm. So the fact that Elm implicitly imports its standard library shouldn't be new to you since you use Rust, which also implicitly imports its standard library. In my opinion, I think the thing you're getting the most confused about is functional reactive programming, which Elm is trying to get you to do, and can be very confusing when first learning about it. Here's a [great video](https://www.youtube.com/watch?v=Bt10M34vSwo) explaining what FRP is in the context of Elm.
It's part of the standard library. And is used to signal intent to the elm runtime that you want to do a side effect (HTTP requests, page navigation, etc). https://package.elm-lang.org/packages/elm/core/latest/Platform-Cmd
Another thing that might help... just want to show that Rust and Elm have very similar type systems. in Rust you have: enum Option&lt;T&gt; { Some(T), None } Elm has the same thing, but the syntax is different. type Maybe a = Just a | Nothing Hope that helps.
in that case i can simply do \`case of\` on the maybe type but in Msg case in the random.generate it also doesnt work and i can find the definition for cmd anywhere
https://package.elm-lang.org/packages/billstclair/elm-websocket-client/latest/
One thing that's different from rust is that there's a "runtime" part of elm. The runtime is what calls your init, your view, and your update functions. To communicate with the runtime, you send it Cmds. It sends back Msgs. Elm is a deterministic language - given the same inputs, elm should always return the same outputs. Randomness in elm would break this determinism, so randomness is not allowed in elm. Instead, randomness is handled by the runtime. You send a Cmd to the runtime, and it sends back a Msg with your random number in it.
Kind of promise i guess but the actual point is how would i get the data back in a callback or something i just need the data i dont want to update the ui or anything else i just want an integer
In your update function you'd need to return your (model, cmd). And, you'd need to handle the reply that contains your random number. &amp;#x200B; For instance, the user presses a button producing a ButtonPress msg (you'd set this up in your view ftn), and then when the button press is recieved you pass a Cmd to the runtime, and the runtime gives back a random number wrapped in MyRandomInt. \`\`\` type Msg = MyRandomInt Int | ButtonPress &amp;#x200B; type alias Model = Int &amp;#x200B; update : Msg -&gt; Model -&gt; (Model, Cmd Msg) update msg model -&gt; case msg of ButtonPress -&gt; (model, Random.generate MyRandomInt ([Random.int](https://Random.int) 0 (A.length rgs.noteSet))) MyRandomInt itshere -&gt; (itshere, Cmd.none) \`\`\`
Thats the point i do not want to update anything in ui i simply want my Int and do whatever i want to do with it
the model isn't the UI - the model is the data that your program is allowed to access. That's where you store data in between processing Msgs.
Update does not just update the UI, it updates the state of your app. Often a change of the state means also a change of the UI, but not always.
fwiw Elm isn’t really FRP anymore, that talk is great though.
I did one in 0.18. The actual application isn't finished but that websocket example worked just fine. I know it's not 0.19 but I figured it might help if you get no other answers. https://github.com/mmachenry/crosstalk
For a practical example, you could look at how I use randomness in my pet Tetris game. I use the procedure described on https://package.elm-lang.org/packages/elm/random/latest/Random all the way down under "Generate Values Manually". I would recommend you do the same, as it is probably easier to wrap your head around. Here is the function that generates random numbers: https://github.com/ulrichsg/elmtris/blob/master/src/Field.elm#L14 And here is the one that calls it: https://github.com/ulrichsg/elmtris/blob/master/src/Logic.elm#L47 Key takeaways: - The process has two parts. First you set up a generator (eg. `Random.int 0 6`). Then you invoke `Random.step`, passing in the generator and a "seed". You get back a random value and a new seed. - The seed is part of my application's model. Every time I generate a random value, I replace it with the new seed returned by the generator. If I didn't, the RNG would keep returning the same value over and over again. - The initial value for the seed should come from outside the app (because it should be random itself). I handle that while initializing the app (see https://github.com/ulrichsg/elmtris/blob/master/docs/index.html#L18 for the Javascript side and https://github.com/ulrichsg/elmtris/blob/master/src/Main.elm#L28 for the Elm side).
If you want to start from the begining and gradually build on your understanding, the book Elm in Action is pretty good.
&gt; Kind of promise i guess but the actual point is how would i get the data back in a callback or something i just need the data i dont want to update the ui or anything else i just want an integer That's not how Elm works. In Elm every time you need some data that doesn't come from a pure function, you ask the Elm runtime and then you *forget about it*. Asynchronously the runtime will answer your demands, and send those answers to your update function as messages. As far as your update function is concerned there's no difference between a message that comes back because you requested an Int or for any other reason. So you have a stream of requests to the runtime going out (render my new model, give me an Int, etc.) and a stream of messages coming in. You shouldn't start your experiment with Elm by generating random number, get some building blocks before.
You can't have an int that's one of features of elm. All functions are side effect free and generating a random number is a side effect. The only way to get a side effect in elm is to dispatch a command to generate one and process the received message when it's been generated.
Checkout [this repo](https://github.com/MattCheely/elm-port-examples), it contains a small example that shows how to do this via ports. I think for the moment that's the way to go
There is a cultural influence from the JS world (where it doesn't seem so common to use bash scripts or make files) and I think it leads a lot of folks into thinking a fancy build is needed for hello world. I see how it got like that, but I hope the same doesn't happen in Elm! Anyway, I use bash scripts for all of my Elm projects that need something past \`elm make\`, and it works pretty well! This is how the [elm-lang.org](https://elm-lang.org) website is built actually! [https://github.com/elm/elm-lang.org/blob/master/build.sh](https://github.com/elm/elm-lang.org/blob/master/build.sh)
I agree. I have seen the same behavior in several languages actually, and I am also hoping that this practice doesn't become culture forced. Using a bash script for a custom make command is perfect for my situation. Thanks again.
Thank you.
A lot of people have mentioned \`Random.generate\`, but that won't make any sense until you're up to speed with The Elm Architecture (which will come in due time). But there's a second way to get a random int out of a generator: \`Random.step\`. This function takes a \`Generator thing\` and returns a \`thing\` (Elm's convention is to use \`a\` but \`thing\` may be easier to grok at first). However, it also takes a \`Random.Seed\` and returns a \`Random.Seed\`. These seeds are the state of the random number generator. \*\*If you pass in the same seed, you get the same random number.\*\* Therefore, it's important to take the new random seed and store it somewhere (like \`Model\`). Where do you get a random seed in the first place? With \`Random.initialSeed\`. Start by passing this any int you like; later you can get a random value passed in to the Elm program. So to recap: \`Random.step [Random.int](https://Random.int) (Random.initialSeed 12345)\` will produce a random-looking integer, but it will be the same integer every time you run the program.
About this, I remember a thing which happened to me in 2016 when I passed a demo Elm app to a colleague of mine. I used a Makefile to build it: it was just fast to set up. After some googling was "this Elm thing won't work with everyone, what is the make command?". It turned out that he had never used a Makefile before (!).
Yes. I should publish it in facy
Can you give an example the decodes and encodes a record named `Foo` with a field named `foo` that is of type `String`?
With my module that would be Meta.object Foo |&gt; Meta.field "foo" .foo Meta.string |&gt; Meta.buildObject It would give you a Meta Foo with an encoder and a decoder as fields
That looks great API wise but I'm curious to take a look at the implementation. Can you provide a github repository or share the code somehow?
Done. I should document it tbh
Because of a functional purity, elm's random implementation has to work a little differently. This is due to the fact that functions in elm are expected to return the same value given the same input. The random module offers 2 ways to get random numbers, [Random.generate](https://package.elm-lang.org/packages/elm-lang/core/latest/Random#generate) and [Random.step](https://package.elm-lang.org/packages/elm-lang/core/latest/Random#step). `generate` takes a message(`(a-&gt;msg)`) and a generator. This will give you a random value each time depending on the generator, but does require you to send it through a message which isn't always ideal. `step` is I believe what you want to look at. It requires a generator and a seed. The seed is just a long number that acts like a timestamp for randomness. For the given seed, it will always return the same random number, but the generator can change what that number could be. `step` is convenient to generate multiple random numbers since it also returns a new seed as the second parameter in the tuple. So you can use step to create a random number and then use the returned seed to create another random number.
Wow. I would love to see this published
There's much more activity on the [discourse](https://discourse.elm-lang.org)
I do not really know what's going on with the `npm` installer, but all it does is download files from [here](https://github.com/elm/compiler/releases/tag/0.19.0) and put them in directory like `/usr/local/bin/`. So it's always possible to just skip all the JS code and download the binary directly!
This looks like a known npm issue: https://github.com/avh4/elm-format/issues/377 Your screenshot looks like you're running as root. So, either re-run that command as a regular user/without sudo or follow [the workaround](https://docs.npmjs.com/getting-started/fixing-npm-permissions) rtfeldman linked to in the GH issue.
I also had problems when I was enthusiastic about trying out elm. Killed the enthusiasm, moved on, will try again later in life.
Today seems like a great day to retry.
Eh, I have other more exciting things on my "non-essential learning" list. Someday I'll see how it's going again.
You don't need to install elm with npm. It's one binary you can just download manually. Npm is really bad.
Yeah, NPM is wonky. I sometimes get this too; removing node\_modules (I don't install stuff from NPM globally) and trying again sometimes helps.
Thanks for your answers guys and gals I managed to just download the binary directly and moved it to /usr/local/bin. It was surprisingly quick and easy (much smaller executable file size than I expected!) Checkmate, NPM!
^ Yes, I just fixed the issue by simply getting the binary manually. Super quick and easy, no need for NPM.
You don't use a `Generator` to generate random numbers. You command the elm runtime to do it for you, and the runtime will reply back to your program with a `Msg`. ``` type Msg = GetRandomInt | GotRandomInt Int generateIntCmd : Cmd Msg generateIntCmd = Random.generate GotRandomInt (Random.int 0 100) ``` Here we make `generateIntCmd`, a command which says "generate a random int between 0 and 100 and reply back to me using `GotRandomInt` message". We then give this command to the elm runtime. Suppose the `GetRandomInt` message is received from a button click, then in the `update` function: ``` update msg model = case msg of GetRandomInt -&gt; (model, generateIntCmd) GotRandomInt randInt -&gt; -- update the model with the randInt here ``` [FULL CODE](https://ellie-app.com/5dQSSBkbRJ9a1) Note that you can't use `Browser.sandbox` anymore, you'll need something like [Browser.element](https://package.elm-lang.org/packages/elm/browser/latest/Browser#element).
stil4m/elm-syntax has one! also, I have one (WIP) in elm-in-elm/compiler but it's very incomplete right now.
This is tasty. Thanks!
All this crap from NPM is the one reason why I love Elm and it's own package ecosystem. Isn't Elm installable from Yarn?
there also is [github.com/elm-in-elm/compiler](https://github.com/elm-in-elm/compiler) (WiP)
I ask questions all the time lol, just in the main subreddit
I didn't clean the code up at all, but it should work. [https://ellie-app.com/5ffyVZgZRSYa1](https://ellie-app.com/5ffyVZgZRSYa1) You run multiple parsers with List.indexedMap so that the row information is not lost. List.partition helps you split that into DeadEnds and successful parse results, and then some filterMap to get rid of the Result wrapper.
Doesn't using `String.lines` and `List.indexedMap` feel a bit like cheating though? Ideally I'd end up with a `Parser` type so that I only need to process the entire source once rather than scanning it once for `\n` characters before splitting using `String.lines`. I'm thinking [`Elm.loop`](https://package.elm-lang.org/packages/elm/parser/latest/Parser#loop) is the way to go.
Lets suppose that: * a statement is one or more \`Char.isAlpha\` followed by a symbol \`;\` * you want a \`Parser.DeadEnd\`, not a \`Parser.Advanced.DeadEnd\` * a statement can be followed by \`\\n\` or the end of string &amp;#x200B; The trick is to use \`Parser.Advanced\` and its \`context\` to keep the list so far, then to convert the result to the one you want, ie: \`(List Parser.DeadEnd, List Stmt)\`: module Stmt exposing (parse) import Parser exposing (Problem(..)) import Parser.Advanced as A exposing ((|.), (|=)) type alias Stmt = String type alias Parser a = A.Parser String Problem a type alias DeadEnd = A.DeadEnd String Problem parse : String -&gt; ( List Parser.DeadEnd, List Stmt ) parse str = case [A.run](https://A.run) stmts str of Ok stmts\_ -&gt; ( \[\], stmts\_ ) Err deadEnds -&gt; let stmtsSoFar = List.map .contextStack deadEnds |&gt; List.map (List.map .context) |&gt; List.concat |&gt; List.reverse in ( List.map toSimpleDeadEnd deadEnds, stmtsSoFar ) parser : Parser (List Stmt) parser = A.succeed identity |= stmts |. A.end ExpectingEnd toSimpleDeadEnd : DeadEnd -&gt; Parser.DeadEnd toSimpleDeadEnd deadEnd = { row = deadEnd.row , col = deadEnd.col , problem = deadEnd.problem } stmts : Parser (List Stmt) stmts = stmtsHelp \[\] stmtsHelp : List Stmt -&gt; Parser (List Stmt) stmtsHelp soFar = A.succeed identity |= A.oneOf \[ A.succeed identity |. A.end ExpectingEnd |= A.succeed (List.reverse soFar) , A.succeed identity |= stmt |. A.oneOf \[ A.symbol (A.Token "\\n" (ExpectingSymbol "\\n")) , A.end ExpectingEnd \] |&gt; A.andThen (\\newStmt -&gt; A.inContext newStmt (A.lazy (\\\_ -&gt; stmtsHelp (newStmt :: soFar))) ) \] stmt : Parser Stmt stmt = A.succeed String.append |= A.getChompedString (A.chompIf Char.isAlpha UnexpectedChar) |= A.getChompedString (A.chompWhile Char.isAlpha) |. A.symbol (A.Token ";" (ExpectingSymbol ";")) |&gt; A.andThen (\\stmt\_ -&gt; A.inContext stmt\_ (A.succeed stmt\_)) &amp;#x200B; Let's try it in \`elm repl\`: \&gt; import Stmt \&gt; Stmt.parse "a;" (\[\],\["a"\]) : ( List Parser.DeadEnd, List Stmt.Stmt ) \&gt; Stmt.parse "a;\\n" (\[\],\["a"\]) : ( List Parser.DeadEnd, List Stmt.Stmt ) \&gt; Stmt.parse "a;\\nb" (\[{ col = 2, problem = ExpectingSymbol ";", row = 2 }\],\["a"\]) : ( List Parser.DeadEnd, List Stmt.Stmt ) \&gt; Stmt.parse "a;\\nb;" (\[\],\["a","b"\]) : ( List Parser.DeadEnd, List Stmt.Stmt ) \&gt; Stmt.parse "a;\\nb;\\nc" (\[{ col = 2, problem = ExpectingSymbol ";", row = 3 }\],\["a","b"\]) : ( List Parser.DeadEnd, List Stmt.Stmt ) \&gt; Stmt.parse "a;\\nb;\\nc;" (\[\],\["a","b","c"\]) : ( List Parser.DeadEnd, List Stmt.Stmt ) &amp;#x200B; It would be better to use \`Parser.Advanced.Loop\` instead of the recursive function \`stmtsHelp\` though to avoid stack issues.
This is great, thanks for your help!
Ah, this is a way using `Parser.Advanced.Loop`, by storing the `List Stmt` in the problem instead of the context. It's more logical after all: module Stmt exposing (parse) import Parser import Parser.Advanced as A exposing ((|.), (|=)) type alias Stmt = String type Problem = Problem Parser.Problem (List Stmt) type alias Parser a = A.Parser () Problem a type alias DeadEnd = A.DeadEnd () Problem parse : String -&gt; ( List Parser.DeadEnd, List Stmt ) parse str = case A.run stmts str of Ok stmts_ -&gt; ( [], stmts_ ) Err deadEnds -&gt; let stmtsSoFar = List.concatMap (.problem &gt;&gt; toStmts) deadEnds |&gt; List.reverse in ( List.map toSimpleDeadEnd deadEnds, stmtsSoFar ) toStmts : Problem -&gt; List Stmt toStmts (Problem _ stmtsSoFar) = stmtsSoFar toSimpleProblem : Problem -&gt; Parser.Problem toSimpleProblem (Problem problem _) = problem parser : Parser (List Stmt) parser = A.succeed identity |= stmts |&gt; A.andThen (\soFar -&gt; A.succeed soFar |. A.end (Problem Parser.ExpectingEnd soFar) ) toSimpleDeadEnd : DeadEnd -&gt; Parser.DeadEnd toSimpleDeadEnd deadEnd = { row = deadEnd.row , col = deadEnd.col , problem = toSimpleProblem deadEnd.problem } stmts : Parser (List Stmt) stmts = A.loop [] stmtsHelp stmtsHelp : List Stmt -&gt; Parser (A.Step (List Stmt) (List Stmt)) stmtsHelp soFar = A.succeed identity |= A.oneOf [ A.succeed (A.Done (List.reverse soFar)) |. A.end (Problem Parser.ExpectingEnd []) , A.succeed identity |= stmt soFar |. A.oneOf [ A.symbol (A.Token "\n" (Problem (Parser.ExpectingSymbol "\n") soFar)) , A.end (Problem Parser.ExpectingEnd soFar) ] |&gt; A.andThen (\newStmt -&gt; A.succeed &lt;| A.Loop (newStmt :: soFar)) , A.problem (Problem Parser.UnexpectedChar soFar) ] stmt : List Stmt -&gt; Parser Stmt stmt soFar = A.succeed String.append |= A.getChompedString (A.chompIf Char.isAlpha (Problem Parser.UnexpectedChar soFar)) |= A.getChompedString (A.chompWhile Char.isAlpha) |. A.symbol (A.Token ";" (Problem (Parser.ExpectingSymbol ";") soFar))
Awesome. I guess the simple `Parser` module is out of the question and I should just use `Parser.advanced` fully
Well, with the simple `Parser`, you can use a two pass parsing, one without `end` and a `backtrackable stmt` to get the list, one with `end` to get the `DeadEnd`: ``` module Simple exposing (parse) import Parser exposing (..) type alias Stmt = String parse : String -&gt; ( List DeadEnd, List Stmt ) parse str = let secondRun = succeed identity |= stmts |. end in case run stmts str of Ok stmtsSoFar -&gt; case run secondRun str of Ok _ -&gt; ( [], stmtsSoFar ) Err deadEnds -&gt; ( deadEnds, stmtsSoFar ) Err deadEnds -&gt; ( deadEnds, [] ) stmts : Parser (List Stmt) stmts = sequence { start = "" , separator = "\n" , end = "" , spaces = succeed () , item = backtrackable stmt , trailing = Optional } stmt : Parser Stmt stmt = succeed String.append |= getChompedString (chompIf (\c -&gt; c /= ';')) |= getChompedString (chompUntil ";") |. symbol ";" ``` It will be less efficient though.
Perhaps related: The worst programming languages to learn in 2019 https://www.techrepublic.com/article/the-worst-programming-languages-to-learn-in-2019/ Thoughts?
That’s the sense that I was getting... that the community is evaporating. It seems like they may just be migrating elsewhere but to me it feels like a loss of momentum.
Hasn't Evan done like 2 or 3 talks addressing why Elm will never aim to compete in the hype popularity contest this kind of article exemplifies? Discourse and Slack are where the community mostly hangs out.
Also check out [drathier/elm-interpreter](https://github.com/drathier/elm-interpreter), together with the talk [A native Interpreter for elm](https://www.youtube.com/watch?v=afMD-hkWPsQ).
Well, that's fine that it's not a goal, but this article mentions specifically some metrics, such as community engagement, which are lacking. I don't see how that's not a big deal.
It would make it much easier for people to help if you put your project in a public repo so it could be inspected.
Is it not working for you with `elm-bootstrap` or with any package? What are you importing exactly and can you give more information in general?
i have updated the question with repo info
It only complains about the bootstrap package html seems to be working fine
Thanks. As a first hint without running the code. The error message says "unknown import". The code is `import Bootstrap exposing (CDN, Grid)`, but the modules aren't names that way. [https://package.elm-lang.org/packages/rundis/elm-bootstrap/latest/](https://package.elm-lang.org/packages/rundis/elm-bootstrap/latest/) On the right there is a list of module names for the package. And the example on the first page is with the following imports: ``` import Bootstrap.CDN as CDN import Bootstrap.Grid as Grid ```
Thanks that solved the issue
I believe the reason for the error message is simple: that package doesn't expose a \`Bootstrap\` module. [https://package.elm-lang.org/packages/rundis/elm-bootstrap/latest/](https://package.elm-lang.org/packages/rundis/elm-bootstrap/latest/)
Your import section should probably look something like: import Bootstrap.CDN as CDN import Bootstrap.Grid as Grid
I hate to see that. :( Fortunately, your Elm experience transfers seamlessly to F# / .net core, where "Elmish" architecture is currently all the rage. So much so that i have been coming here to help me learn Elmish. It's open source, multi-platform, and you can create Elmish desktop and iOS/Android/WPF mobile apps with Fabulous as well as web with Fable. Even better, the so called "SAFE Stack" allows you to program your Elmish front-end and your back end API in the same language. F# is a fantastic multi purpose, "functional first" language, plus your get all the goodness of .net core and its oss community!
You also have elm-json-codec that does exactly that: &amp;#x200B; [https://package.elm-lang.org/packages/prozacchiwawa/elm-json-codec/latest/](https://package.elm-lang.org/packages/prozacchiwawa/elm-json-codec/latest/)
Hey Alex ! &amp;#x200B; I love everything you've done for Elm, keep up the good work :) &amp;#x200B; I haven't tried Elmstatic yet but it looks promising
I don't really understand what your problem is, but here are three quick things I noticed: * I feel like `ChoosenConstraint` living in a file called "Constrains.elm" feels wrong. Maybe rename the file to "Constraint.elm" and the type to `Constraint`. * `ConstraintContainer` does not make any sense to me. But I feel like it could be replaced with `Maybe Constraint`. * Why do `RemoveConstraint` and `SelectContraint` have different types? This feels wrong. Making both `Constraint` would still work.
Thanks for the response, essentially someone picks a constraint they want to add, they enter the details in the fields that came visible and press an add button to add the constraint to the list. The issue is each constraint has different fields, I managed to have a list of them by boxing the constraints in a type. That's why you see constraint container, this code is a work in progress as I have tried to write it a few times. What I can't find the best way to do is the UpdateField. I was looking for a way to structure the Update to take the change in values in the easiest and most type safe way possible.
Thank you!
I think I understand now. 1. Type are not Union types. so something like ``` elm type Field = Int | Bool ``` is not valid, instead you need to do something like ``` elm type Field = IntField Int | BoolField Bool ``` 2. I see your problem now and the quick answer is: Use Maybe. The long answer will come later today.But its definitely a difficult problem.
Amazing! :D
Here is a working example: [https://gist.github.com/Orasund/4f562ba1c6678f79fd932f72bdb6b570](https://gist.github.com/Orasund/4f562ba1c6678f79fd932f72bdb6b570) There are a few things i've changed, so if you have questions, please keep asking ;)
What I still don't get my head around: &amp;#x200B; Why is random considered impure in functional programming? I mean, I would get the point if we could generate truly random numbers, but aren't all computer generated number only pseudo-random? So what is wrong with using a PRNG with the current system time as a default seed? If I would (could) call this function at the exact same time, it would give me the exact same result, so what is the problem? Is it because we don't know the exact time beforehand? But the same is true for any input to the apps we write (e.g. the order in which people click buttons, what data our algorithms are applied to)? Or is it really just to separate everything we know beforehand from everything we only know at execution time?
I really appreciate your help here /u/Orasund. It is late here so I can't look at your example in detail but I will check it out tomorrow! Just wanted to thank you as you went above and beyond and provided a great learning experience.
🙈 Thanks for the Platinum.
&gt; I would say productivity, understandability and correctness not necessarily in that order) matter the most to me when I'm evaluating a framework/language/environment. It's leagues above anything in the JS world when it comes to these things and the ecosystem has been getting a lot better. The quality of the packages is very high because of the rigor of the language. I've been using Elm wherever it makes sense at this point for 2 years now. The only place where it hasn't made sense is certain complex libraries in JS haven't been matched in Elm yet like graphing for instance. But in that case I just embedded a React graph inside the Elm app. &gt; it looks like there's some bad blood after the .19 update. The release cycle/transparency is definitely quite different than other major projects but the language is so beneficial that at this point I don't really worry about it too much since I know even the current version will still be better than any alternative for years. The biggest problem I've run into is that sometimes a compiler warning won't make sense so I'll have to `rm -rf elm-stuff` but I've just added that into my automatic build script so whenever it happens I'll kill the process that watches the files, and when I start it again it'll do that automatically. &gt; How bad was the .19 update for that use case? I don't use it in an agency but because everything is typechecked it was pretty painless. I'd say it took about a week or so to migrate 40,000 lines of code, which was beneficial because of all the new features it brought along which allowed me to kill off some old javascript code and use the new Browser package. I have no QA team so there were a few minor bugs that were discovered on an internal tool once it was live but they were very easy to fix.
&gt;The only place where it hasn't made sense is certain complex libraries in JS haven't been matched in Elm yet like graphing for instance. Check out the amazing [elm-visualization](https://github.com/gampleman/elm-visualization) library!
I wouldn't worry about updating to new major versions, there were a lot of broken APIs in 0.19, but if I compare that to the struggle we have updating react dependencies every couple of months it's nothing. The lack of platform support should worry you though, most large application take advantage of a lot of browser APIs like localStorage, cookies, websockets, Intl and various pure JS functions that are not available in Elm. People here would like you to think that you can just use ports for these stuff, but depending on your application it may turn out that half of your data flow includes ports and you may question if using Elm is even worth it.
Thanks for bringing up platform support. I had meant to mention it, but I forgot. I didn't know about localStorage and cookies not being supported. Missing websocket support might be a dealbreaker for me. Elixir/Phoenix is currently the front-runner for what I start using on the back-end. I'm aware that channels can work without websockets, and that there are replacements for elm/websocket while it gets designed, but starting off on a stop-gap seems less than ideal.
The Ports capability makes it easy enough to manage websockets in Elm via JS, I wouldn't let that hold you back.
\&gt; if I compare that to the struggle we have updating react dependencies every couple of months it's nothing Couldn't have said it better. \&gt; depending on your application it may turn out that half of your data flow includes ports and you may question if using Elm is even worth it. Totally agree with that. I'm currently starting a brand new project after 2 (amazing) years of Elm development. In this new project, performances in suboptimal networks are a key feature. I'm not sure I want to use Elm again mostly because of the lack of Websocket support. Still thinking...
I saw that it looked easy enough. My concern was more that if I start a bunch of client projects on Elm/Phoenix, I'll want to switch back to elm/websocket as soon as the API is done being re-designed. I suppose if I'm being honest, it's not likely anyone other than me will force a switch back to elm/websocket so that can happen whenever it's convenient.
The .19 complaints are from people who ignored the fact that the version number starts 0. - backwards compatibility is not assured because the language isn't yet "finished" or "stable" depending on your interpretation of those words. I can see that it's irritating that your code no longer compiles in a newer version but it's not like .18 was removed from time and space ;) I'd say Elm works great for frontend development and that where it lacks, its FFI is there so you have the ultimate escape hatch. The only reason I'm not using Elm is that I want a fat client app that works offline and shares logic with the server, where my code is in Haskell, and it's quite a faff to support that cleanly. Since this is an odd use-case I'd nearly entirely advocate using Elm.
I definitely wouldn't worry about Websockets, I'll reply to the other comment on concerns around Ports in general though.
I agree with the sentiment around local storage etc. - my app ended to bring hard to follow as my data flow kept going in and out of ports. I don't feel that Websockets are a problem in the same sense unless your logic is very intertwined.
Unrelated to Elm, but what are your thoughts/feelings about running your backend in Haskell? I've wanted to try it, but haven't been able to work up the courage. I've used Haskell on and off on the side over the last 7-8 years or so, but I wouldn't consider myself an expert and am not confident that I could be productive, at least compared to how productive I am in Rails.
&gt; The .19 complaints are from people who ignored the fact that the version number starts 0. - backwards compatibility is not assured because the language isn't yet "finished" or "stable" depending on your interpretation of those words. The complaints that I've seen mostly aren't about losing backwards compatibility in the abstract, but about specific decisions that people think make the language worse. &gt; I'd say Elm works great for frontend development and that where it lacks, its FFI is there so you have the ultimate escape hatch. Case in point - 0.18 had a much stronger escape hatch than 0.19 does. I liked that escape hatch, and I'm annoyed that I no longer have it. If I had never had it, I would still be annoyed at not having it.
My dayjob is largely Java so it's taken me a while to get up to the point where I feel fairly confident with Haskell (part of that journey was learning Elm which I found a much easier intro!) The webserver side of my app was written when I was really a true beginner with Haskell and I used warp/wai/wai-websockets - I have to be honest here because I did struggle a bit especially with "how do I run a loop in a functional language?" and "why does ByteString exist?" and of course "wait, there's Lazy and Strict ByteStrings? I hate Haskell!" - anyway, having gotten over those feelings I managed to get it up and running without too much pain (which I think is impressive given how new I was to the language!) A quick [non-websocket example](https://github.com/ahri/dotfiles/blob/7e093c093594536b48db4b9d0eea70176d9815f5/bin/hs-script.hs#L491-L576) is available bundled into a script I use, so you can see that it's fairly straightforward. Haskell is easily my favourite language these days, despite the long self-taught journey. Given that you've used Haskell on and off I assume that you'd be able to get going more quickly than me, and since you're able to dedicate contiguous hours to it during the day I suspect that your learning would be massively accelerated. That said, Elm+Elixir seems like the normal combination just based off my lurking in this subreddit. As a sidenote I would warn you off doing Haskell -&gt; JavaScript for reasons of commercial pragmatism; the options imho do not offer a compelling solution and the mismatch between Haskell's laziness and JS' strictness is quite annoying at times. I'm currently writing an Elm-like framework for Haskell to leverage the React/Redux ecosystem, and I _still_ wouldn't recommend it unless you have a strong use-case requirement like I do: compile times are way longer than for Elm, and the benefits you get with type classes are debatable (as you can see in any thread on this subreddit that demands type classes for Elm!) - especially if you're not already really comfortable with Haskell and leveraging all those extra goodies :)
I guess I'm in the camp that feels no ownership over the language decisions anyway, more for reasons of pragmatism than anything else - I can't control what Evan does with his zero-point releases so why pretend? Nobody deleted 0.18 so if I'm ever bothered by it then I can sit on 0.18, or fork it, or whatever I personally choose to do with the control I have. As it is I think it's a good time (0.*) to be making what he thinks are good decisions to focus and clarify the language in the direction that he sees fit. Personally I like the direction that Evan is taking the language since plenty of alternatives exist anyway - it's good to carve out a well-designed niche. But my opinion is irrelevant and that's fine.
Not OP You probably won't be for a while. In contrast to Elm, Haskell can often be much denser. This is obviously not a reason against it. In fact, there are many things you will win instead, performance included (specially vs rails), but you'll probably want to do some training with it first. You can use `scotty` to a quick sinatra like experience. I honestly haven't digged much deeper, but I think `yesod` is the most similar to the django/rails/laravel usual frameworks.
&gt; How bad was the .19 update for that use case? People who stayed away from shortcuts (Native code) had a decent time updating the code. As far as I understand, the update was bad for people who used Native code to extend the runtime. Even there, most were able to just move to ports. The speed of the new compiler was such a huge jump in quality of life that it made most update projects worthwhile. A lot of people with large codebases saw compile times dropping from minutes to seconds for full compilations. The update was a positive thing for most. I did not have Native code and the update of the largest codebase I had was an OK experience.
I could be wrong, but I though Ellie was written in Elm 0.18 and then compiled what was written into 0.19. though I'd heard that on a podcast with the creator.
To quote from [this discord thread](https://discourse.elm-lang.org/t/examples-of-using-codemirror-ace-monaco-text-editors-in-elm-apps/2797/2): [Ellie](https://ellie-app.com/new) uses CodeMirror via a Web Component. [Here](https://dev.to/lukewestby/talk-when-and-how-to-use-web-components-with-elm-f85) is a presentation explaining how.
I'm going to be pretty blunt: Do *not* use Elm in a production setting. Evan, as brilliant as he is, obsesses over how other people use his language and demands a level of control that I haven't seen before from a language designer. The 0.19 release broke things in an aggressive manner, going beyond simply breaking some APIs, putting in mechanisms to prevent people from running their own kernel modules. The core Elm folks only made this worse by gaslighting anyone who took issue. Their go-to talking point was something to the extent of "if we allow kernel modules then people will try to use jquery in Elm." It was an entirely manufactured argument that ignored the many legitimate use-cases for desiring access to kernel modules while doing real work with Elm. Consequently, [interest in the langues has faded drastically](https://trends.google.com/trends/explore?date=today%205-y&amp;geo=US&amp;q=%2Fm%2F0ncc1sv). Elm still lacks native support for many modern browser APIs, and due to the native kernel restrictions, there is no way to provide these on your own.
Yeah, the editor I made is not upgraded to 0.19 but there's no blockers and the upgrade should be simple and easy. &amp;#x200B; There's no full-featured pure Elm editor that I know of though.
Using Elm in production is, in my experience, awesome (reliability, maintainability, compiler as assistant, types documenting the flow of data, etc. etc.) and I dread the moments I have to dive into JS legacy code. The 0.19 upgrade was just big enough that we had to wait a bit for dependencies to upgrade, and not just dive into it, but afterwards it was mostly mechanical work. Nothing horrible, and the compiler had our back every step of the way.
I don't think I feel ownership in the language decisions. I do feel invested in them, because I rely on elm in my day job.
I'm really skeptical of this viewpoint; what's forcing you to upgrade to 0.19? The reason I'm skeptical is because I use Java at my dayjob and we're on Java 8 - it doesn't matter how many versions Oracle spit out, we just don't need to upgrade unless some critical dependency does, and we don't depend on much (which is the situation for every single person in the Elm ecosystem, and definitely true for anyone depending on kernel modules because their dependencies can't upgrade anyway.) Java 12 just came out and I've not seen any Oracle employees with pitchforks coming to force us to do anything. Similarly Evan gave us 0.18 and gave us 0.19, both of which are now available to you. Besides, you can fork it if you're that bothered. The graph you linked doesn't show any change in trend around the 0.19 release so I'm not clear on what that data demonstrates? Also if you switch to "worldwide" it's even less of an issue.
&gt; I'm really skeptical of this viewpoint; what's forcing you to upgrade to 0.19? Is your argument really "You can use Elm in production, but only if you stick to an old version that will no longer be supported?" &gt;The reason I'm skeptical is because I use Java at my dayjob and we're on Java 8 Java 8 is an LTS release with a well-defined support schedule. It's hard to even search for Elm 0.18 documentation or packages. &gt;Java 12 just came out and I've not seen any Oracle employees with pitchforks coming to force us to do anything. Similarly Evan gave us 0.18 and gave us 0.19, both of which are now available to you. Again, comparing Elm (a relatively unknown language supported mostly by a single individual) to Java (one of the most common and well supported programming languages in existence) is comparing apples and oranges. &gt;Besides, you can fork it if you're that bothered. I'm not bothered. I'm just giving sound advice. &gt;The graph you linked doesn't show any change in trend around the 0.19 release so I'm not clear on what that data demonstrates? People knew about the kernel modules far in advance of the 0.19 release.
Yes my argument is indeed that if you're willing to use Elm 0.18 you're not that bothered about it being supported because you didn't care about a zero point release on a niche language coming from an otherwise unknown company. Your linked graph in no way backs up your point.
&gt;Yes my argument is indeed that if you're willing to use Elm 0.18 you're not that bothered about it being supported because you didn't care about using a zero point release on a niche language coming from an otherwise unknown company. The entire context of this discussion is *using Elm in production* which is precisely when you should care about these things. &gt;Your linked graph in no way backs up your point. Elm was trending up in popularity, and around the time the kernel module changes were announced, it started trending down in popularity. The same trend line holds for both US and worldwide.
I'd say the context of the thread is that the OP is already considering a zero point release of a niche language for production, and that your response is more about changes specific to Elm from 0.18 to 0.19, rather than a more general comment about production readiness of a language. Perhaps I misinterpreted? I had a quick look for Elm 0.19 announcements but I'm unable to verify what you said. I'd be impressed to see a big shift in traction of a language after an announcement detailing removal of a feature that always seemed frowned upon in 0.17 (which is the last time I used Elm). I'll trust your statement unless anyone else dissents.
[kernel module announcement](https://groups.google.com/forum/m/#!topic/elm-dev/bAHD_8PbgKE)
I've been working on [a pure-elm text editor](https://github.com/SidneyNemzer/elm-text-editor), but it's only a proof-of-concept at this point. Your best bet at the moment is to use CodeMirror or Ace in a web component.
Thanks for that. It is an impressive correlation.
\&gt; How bad was the .19 update for that use case? I was lucky enough to upgrade 0.18 to 0.19 three weeks ago: \~30k LOC migrated in 3 days (plus tests). I was prepared though: got gradually rid of Native Modules before Christmas, stopped using the literal tuple constructors, tried to avoid \`toString\` in the new code. Probably the **smoothest** migration I had ever experienced in 6 years. Nothing compared to any weekly JS update. Not even close. The reason why I would nonetheless **avoid Elm in production** for a new project is that **the Web API is not complete** and with the current FFI we end up with a lot of boilerplate. I just don't feel like using ports for storage and WebSockets and having some mixed JS/Elm boilerplate to maintain. I did it already, and the Elm &lt;---&gt; JS interop requires just too much code in my opinion. That said, **I would definitely use Elm if I could avoid the use of those missing APIs**. That's it.
0.19 was broken on release and the way Elm releases in secret, many library authors never played with a release candidate so packages went weeks/months without upgrading. I personally PR'd several libraries to be upgraded since authors often used Elm on side project and didn't have the time to upgrade. Some never did upgrade so I had to just pull it into my project and upgrade (namely was `elm-these`). There's a number of outstanding bugs in Elm's core libraries that simply aren't addressed or PRs not merged because that's not how the closed way Elm upgrades itself. Personally this frustrates me enough to where while I still use it at work and grit my teeth, I've been doing hobby projects in PureScript with the Spago package manager and Halogen (v5-RC) for UI. I think the ability to use type classes and interop with JavaScript syncronously (something Ports can't do) are godsends sometimes. Unlike the can of worms off adding Reflex or Miso via Haskell/GHCJS, PureScript is an easy as a npm install away with integrations with tools you probably know like Webpack, Parcel, etc. I'd add it as a serious alternative worth checking out over Elm if your problem domain goes outsides Elm's limitations or your worried about not being about to write Kernel code.
I'm eager to get my hands on a good text editor!
As the Beginners Thread is quite empty nowadays, how about we remove this Thread completely and instead introduce a "Question" tag for posts?
The lines of code is a slanted metric for Elm, as the formatting in Elm is especially line heavy.
&gt;Looking for opinions on practical use, rather than remarks on the Medium article. Thanks, but I'm looking for opinions on practical use, rather than remarks on the Medium article.
If you are stuck with JavaScript, it seems better than nothing. But it lacks a lot of the safety guarantees Elm has: 1. JavaScript and TypeScript have Runtime Exceptions 2. TypeScript has no proper algebraic data types, and therefore no Hindley-Milner type System that makes it possible to model state accurately 3. elm has only immutable datatypes, which prevent even more errors 4. Elm is a functional programming language and has exhaustive pattern matching that requires you to handle *all* cases. AppRun uses strings for that, and that is horribly unsafe, hard to change and debug. If you change the name of one „message“ in Elm, you get Compiler errors. In JS/TS, you have to change strings all over your code, and you’ll only see errors at runtime.
For me the biggest difference is that you're stuck using JavaScript meaning the clearest objective negatives are: 1. No types (unless you use TypeScript) so you get runtime exceptions instead of compile time errors, subjectively I think this massively reduces productivity 2. No tracking of effects, so reasoning about anything becomes much more difficult when compared to Elm - in Elm everything is pure and the runtime does all the effectful stuff Positives: 1. You have the whole JS ecosystem available without the hindrance of dealing with Ports/Subscriptions 2. You get to hide state in Components (this could be a negative if you really like all the state in one place) 3. Easier on-boarding of JS devs - I think this one is a bit muddy because Elm is so easy to learn
I recently started implementing a basic vim emulation editor in elm. It's in an early stage, and just for fun. Demo: https://andys8.github.io/vim-emulation/ Source: https://github.com/andys8/vim-emulation
From the small amount of documentation (on the github page; they seem to want you to buy a book...) it looks basically like Hyperapp.
Typescript has ADTs: &amp;#x200B; type ResultError&lt;T&gt; = { type: 'error' payload: T } type ResultSuccess&lt;T&gt; = { type: 'success' payload: T } type Result&lt;S, E&gt; = ResultSuccess&lt;S&gt; | ResultError&lt;E&gt; Look for "Discriminated Unions" here: [https://www.typescriptlang.org/docs/handbook/advanced-types.html](https://www.typescriptlang.org/docs/handbook/advanced-types.html)
You are right and I habe edited my comment. But I think that due to the verbosity of declaring them, they’ll likely get used less than in Elm (by the average programmer at least).
Thank you for the replies, they were helpful.
KeeperB5, your comment ID had a Happy Number in it! The Happy Number was 10, and your comment ID was el8tk10. Here's a link to what Happy Numbers are: https://en.wikipedia.org/wiki/Happy_number, and if you're willing to risk YouTube links, here's a video explaining them: https://www.youtube.com/watch?v=kC6YObu61_w. Comment ID's are unique 7 character strings which identify comments in the sea of Reddit. I'm a bot, beep boop. Downvote to delete this comment.
Members of the organising teams of all four major Elm conferences – Danielle Pham (elm-conf), Blake Thomas (Elm In The Spring), Thibault Assus (Elm Europe), and Erik Wendel (Oslo Elm Day) – come together to discuss what goes into a successful Elm conference, the lessons they've learned along the way, and what we can expect at their next conference! Discount codes: * **SPRINGTIME10** 10% off [Elm In The Spring](https://www.elminthespring.org) (26 April 2019) * **ELMTOWN10** 10% off [Elm Europe](https://2019.elmeurope.org) (27-28 June 2019) _valid until end of April_
Could you share more on the lacking packages? What wasn't in there for you? How would you imagine "temporarily fixing a package"? Seen some pattern from other technologies? Besides, note that the Elm versions are 0.18 and 0.19 and NOT 1.8 nor 1.9
Hi, the package I meant specifically was datepicker. They responded quickly on github, and they were really supportive [github](https://github.com/CurrySoftware/elm-datepicker/issues/26). The thing I wanted to do is to be able to get their sources, add my patch build a package locally, and install it and use it instead of the official package until they release a new version or fix my issue. Building and installing a package from local source is just something you sometimes have to do. I think my analogy with unsafePerformIO fits. I understand why a single source of packages is otherwise beneficial.
They should have gone with an expression instead of a statement... ^^/s
I appreciate your enthusiasm for sarcasm, but to become a master you mustn't use /s. *I'm a human being, and this action was performed manually.*
Thanks for the write up. Let me ask you something. Since you know haskell. Did you try other way to make front end development with haskell? How did you decided to jump into the elm wagon?
I've never tried front end in haskell. I did haskell \~5-7 years ago, only mentioned it to show that the ML style languages weren't completely alien concept to me. I found Elm after playing with React.
This week I started analyzing the elm compiler towards finding a way around this limitation. I considered either making a proxy that cheats the compiler or forking the compiler to add to either allow any package to have Kernel code or to be able to have a local whitelist of trusted repositories. Would you be willing to collaborate?
How can I get the X and Y coordinates of a click?
I might be missing it, but is there a currency package for Elm? I'm trying to make a little budgeting app and found the Money module, which seems to be more about representing different kinds of currency than about storing a monetary value: [https://package.elm-lang.org/packages/Chadtech/elm-money/latest/](https://package.elm-lang.org/packages/Chadtech/elm-money/latest/) &amp;#x200B; Am I missing a basic type for money? I would want it to take in a number (or two numbers), able to add/subtract, and have a string representation that includes a symbol.
You may be able to do this with elm-units: https://github.com/ianmackenzie/elm-units
It waxes and wanes, and I think it lowers the barrier to entry nicely. Not everyone will be comfortable making a top-level post, and it's just a couple minutes for me to post every week. 😃
You will need to use `on "click"` instead of `onClick`, and write a decoder that grabs the event info you're interested in. The decoder probably looks like this if you want the screen coordinates of the click: Decode.map2 (\x y -&gt; { x = x, y = y }) (Decode.field "clientX" Decode.float) (Decode.field "clientY" Decode.float) But that will give you an `Attribute { x : Float, y : Float}` and you probably will want to wrap it in an actual `Msg` type.
As a React-Redux dev, I've heard Elm follows the same patterns as Redux. Is it really that easy to just start replacing components of a React project piece by piece, and can we continue using the same NPM packages until we find Elm alternatives?
It's very possible! Here are the guides you want: [https://github.com/elm-lang/elm-platform/blob/master/upgrade-docs/0.17.md](https://github.com/elm-lang/elm-platform/blob/master/upgrade-docs/0.17.md) [https://github.com/elm-lang/elm-platform/blob/master/upgrade-docs/0.18.md](https://github.com/elm-lang/elm-platform/blob/master/upgrade-docs/0.18.md) [https://github.com/elm/compiler/blob/master/upgrade-docs/0.19.md](https://github.com/elm/compiler/blob/master/upgrade-docs/0.19.md) There is also a tool that will help with the 0.19 upgrade [https://github.com/avh4/elm-upgrade](https://github.com/avh4/elm-upgrade)
\- If you need to use missing API's or synchronous JavaScript calls, especially local storage, stay away. (Websockets + ports is probably not a big deal though.) \- If you don't need the things it's bad at, Elm is a GODSEND. It combines what is normally a huge mess of bullshit into a single, relatively simple tool. This is a win, even though the language is "different" and "weird". In practice, I have found Elm to be *very* heavy on boilerplate and initial design, bulletproof when deployed, and utterly trivial to maintain or refactor. So when you are getting started it can *feel* like a massive waste of time, but with practice you can learn to stop writing code you don't need, stop over-designing things, and just write simple apps that you can maintain in 6 months and be completely sure that you didn't break anything. AND you didn't have to dive into a massive NPM rat's nest. One language, one compiler, bulletproof result.
Oh perfect, these are exactly what I was looking for. Thank you!
I don't think it's that straightforward. You could potentially start by replacing parts of pages with Elm components, but it's not like you can share your Redux store between Elm and React or anything like that.
We use Elm inside a react-redux app and here's how we do it: * Mount the Elm app componentDidMount, passing some redux state as flags * When the redux store needs to be updated, a port is fired from the Elm app and, if needed, the React app responds by sending a response to Elm * Complicated React components become web components rendered by Elm * Some styled-components configs became css variables so that the config could be shared between styled-components and elm-css
WAT
This discussion will give you a 10-minute demo off some of the different frameworks. Followed by a panel discussion where we answer your questions and compare the different solutions out there. We will be demoing and discussing the following GraphQL Frameworks: \- (**PostGraphile**) by maintainer, Benjie \- (**Prisma**) Novvum CTO, Rohit Ravikoti \- (**Hasura**) founder, Tanmai Gopal \- (**AWS Amplify**) , Nader Dabit from the Amplify team \- (**join-monster**) Blissfully CTO, Aaron White &amp;#x200B; More details here: [https://discourse.elm-lang.org/t/choosing-a-graphql-framework-for-your-elm-app-expert-panel-with-demos](https://discourse.elm-lang.org/t/choosing-a-graphql-framework-for-your-elm-app-expert-panel-with-demos)
I added a comment with some details. I'm the author of elm-graphql, and I get a lot of questions from people in the Elm slack about which GraphQL framework is the right choice. So I invited the maintainers of several major GraphQL frameworks to come discuss them with the elm community. We'll have a specific focus on things that elm devs would want in a backend. Type-safety (so you can get end-to-end type-safety with elm-graphql), minimal &amp; declarative backend, performance, etc. Hope that helps!
Thanks for clarifying. I might check it out!
Neat! I think it will be a really interesting discussion. If you haven't tried GraphQL yet, it works really nicely with Elm! I talked about why it's such a good match at elm conf last year, that's a good place to start if you're curious: [https://www.youtube.com/watch?v=memIRXFSNkU](https://www.youtube.com/watch?v=memIRXFSNkU)
What has this to do with elm?
It's almost the opposite of Elm: An untyped, JS/HTML-like language with mutable state.
I agree with you generally, however, I would probably not make the claim that Elm is easy to learn. The syntax really is simple, but most developers are usually trained on imperative languages (as far as I know, and from my experience), and it takes quite a bit of time for them to really understand how to think in a functional style. JS kind of aspires to be a functional languages, but I don't think it's a good language to learn this paradigm, since it cannot force any sort of discipline on you and proper understanding of core concepts
I really liked that they went this way with the language, but I think it would be even neater if they had proper tagged unions and some sort of pattern matching.
How is this community not interested in different ways of thinking about reactivity? This topic is Elm's forte.
That's a good observation.
I would say it's COMPLETE opposite of Elm. Plus to what you said: 1. elm is very limited in methods of interoperability with JS code (the only allowed way is by using ports). 2. elm generates huge bundle even for small programs (you always need its runtime). 3. elm is using virtual dom. 4. elm is restricted to its architecture (model-view-update), you literally can't write code in another way.
I would say elm primary topic is safety, not reactivity. I didn't switch to elm because it was faster, i switched because of its types and the pure functional experience. Don't get me wrong, this talk was interesting, but its just not something i did expect in /r/elm
Will a recording be available? The time is going to be 3am in my time zone, so I won't be able to watch live. I'm curious about using GraphQL with Elm.
You said somewhere you don't get what is a type or where does a thing come from. Use an editor which allows you to jump into definition of a thing under cursor. I recommend https://github.com/klazuka/intellij-elm
&gt; I would say elm primary topic is safety, not reactivity. I see the safety aspect of elm as really boring. Haskell has been doing it for 20 years. Meanwhile Elm has re-modeled its reactivity system about 3 times now.
why is this topic Elm's forte? After removing mailboxes and signals Elm is basically not reactive at all. You can achieve the same level of "reactivity" with react + redux :)
Hey Alex! Timezones are tricky. Yes, I will post this one on my website once it's recorded. If you have any questions, feel free to share them here and I'll try to work them in during the panel.
It will be indeed a great tool to get things done. No boilerplate, no setup, make a prototype and ship in a few hours a product. But for big projects I wouldn't think in using other language/framework than Elm, due to it's type safety and performance.
It is another approach, maybe someday Elm can drop virtual dom to get even a better performance?
Well, you'd think that the Elm community is knowledgable on reactivity based upon the different language and project level constructs that Elm has used. You sound like you are, at least haha.
That would probably be a combination of \`andThen\` and \`succeed\`. You can decode the primitive, \`andThen\` feed that result to a function that will \`succeed\` with your tuple. &amp;#x200B; [https://package.elm-lang.org/packages/elm/json/latest/Json-Decode#succeed](https://package.elm-lang.org/packages/elm/json/latest/Json-Decode#succeed)
seems the Json decoder is a bit buggy it does not strip out the whitespace and fails for a valid schema telling \n is not an int for now i think ports are the only way to go
The json decoder is usually pretty good, so I'd be surprised if that were true. If it weren't my bedtime I'd try this out in Ellie. Hopefully I'll remember tomorrow. :)
Can you give a larger sample of the JSON? The sample you gave isn't even valid JS syntax (mismatch brackets).
How do you create an Elm contact form with ajax that is when submitted the webpage is not refreshed?
[Here is an Ellie showing how to do that](https://ellie-app.com/5mVX9SVykNfa1). The tuple decoder is: tuple2 : Decoder a -&gt; Decoder b -&gt; Decoder ( a, b ) tuple2 a b = Json.map2 Tuple.pair (Json.index 0 a) (Json.index 1 b) Javascript doesn't really have the concept of tuple. It is generally represented as an array (this is what the decoder assumes). Of course, if you control both the encoding and the decoding, you can use whatever format you want for the tuple.
Check out the (docs)[https://guide.elm-lang.org/architecture/forms.html] for a guide how to write a form, and then use (elm/http)[https://package.elm-lang.org/packages/elm/http/latest/] for the ajax part. I hope that was helpful, else you can also post your current code and i'll look over it ;)
Their point is mainly, people don't use it so your opportunities on the job market are limited. Which is valid. Growth of the ecosystem is also a valid concern. Even though it's kind of a chicken-or-egg problem (and this is a pretty lazy article), if you don't want to be pioneering but instead use stuff that everybody uses (which is a valid requirement for a lot of companies), then you probably shouldn't use Elm.
[removed]
This article is horrifically lazy, and likely written by someone who's never written a single line of Elm - or interacted with the community in any way, shape, or form. Just another shitty website looking for clicks. Almost every article on this site is by the same author, and has the same tone of "I read some statistics and extrapolated an entire article out of them".
Its true, is lazy article without any facts or stats.
Seeing that Elm and Svelte are both compile-time systems. Seems possible.
Isn't Slack terrible in terms of not asking the same stuff over and over again? And it's highly isolated as a means of communication. As a casual elm observer, it does appear like the community is dead. I wouldn't know that things are bustling unless I'm a Slack user. Wouldn't it be better to have better searchable historical documents that people can reference? Better documentation, more re-usable libraries for common use cases, larger database of FAQs
Most debating is emotional and fact finding is just a means to reinforce a existing preference. Uncovering the managers actual concerns are can help actually progress a conversation. Don't assume it's the content of her/his arguement. And Then some verbal judo can help. E.g. is stack overflow a reliable place for accurate answers , best practices or is it just as easy to find well meaning responses that are insecure, not maintainable, or don't scale in your work context ? How might having more questions on stack overflow mean that a technology really has an underlying problem? Etc etc
This whole site reads like a collection of BuzzFeed-Clickbait-Titled-Shills for tech.
I hear WhatsApp &amp; Discord are both doing complete rewrites, because they saw that Erlang was at number three in this "article". Apparently they have decided to swap to Python because clueless schoolkids asking a zillion homework questions on Stackoverflow is a clear sign that if you want scalable, fault tolerant, massive concurrency that will handle huge spikes without collapsing, then Python with its bolted on async options and it's GIL is obviously the way to go. The lost revenue from having hordes of extra servers that Python requires over Erlang and hiring a bigger dev team to do the same amount of work, is just an unfortunate consequence of switching to a "superior" choice like Python. All further tech decisions at WhatsApp and Discord will be based on the other high quality articles that 'Subham Kapiswe' produces.
Personally, Elm (core) and lot of packages documentation is better than a lot of mainstream language, framework and libraries. For curiosity, when you tell "elm need more re-usable librairies?" , like what ? FAQs like stack overflow is not perfect. The technologie and methodology evolved and some response are ephemeral. Too much response on stack overflow are outdated and used by to many programmers. But yes, some questions need to be persisted. For blog post, its true, we need more good blog post like we have.
&gt; For curiosity, when you tell "elm need more re-usable librairies?" , like what ? Really just more UI frameworks. I still don't know the best practice way of making a UI in elm for a production app (some use html, some use css, some use pure elm constructs, etc). But it would also be nice to have elm bindings to more than just web sockets and localStorage. Is there a chart of how much of the browser API is covered by elm? &gt;For blog post, its true, we need more good blog post like we have. Would be nice to see what's going on with the core developer team from time to time. I know it is time consuming to write updates, but for long stretches of time, it seems like elm is almost abandoned.
I wonder if Elm could ditch the vdom and keep it's nice API as well.
Don't take this tiny Reddit group as the community, most of us are on slack and discourse
When you talk about UI frameworks , like angular-ui ? Personally, i use Elm.Html module with sass. I wrote my own UI module for each project because each project has unique style. You can use [https://package.elm-lang.org/packages/rundis/elm-bootstrap/5.1.0/](https://package.elm-lang.org/packages/rundis/elm-bootstrap/5.1.0/) if you looking type css framework. Your probably right for native browser api. Perhaps we can use ports to use it.
This was very entertaining, thanks :)
Bravo, very apt analogy
&gt;When you talk about UI frameworks , like angular-ui ? Right. Originally, I believe Elm wanted to be a full replacement for the whole web ui stack (html, css, javascript). I think that kind of backpedalled as more and more people started using regular bootstrap style frameworks, like yourself. The elm-ui package I believe is furthest along, though, in this department, I think. &gt;Your probably right for native browser api. Perhaps we can use ports to use it. That seems to be the obvious solution. However, the community is a bit half and half on this. Some native browser api's have their own packages already.
Source?
To play devils advotate, for people looking for a job, Elm would be a very poor choice to focus on. The job market is probably one thousand the size of JavaScript, and there are many more who would *like* to work with Elm than there are positions available. &amp;#x200B; If you're a team that's looking to write more reliable and maintainable web apps though, there's no better option. I mean, these are the alternatives: * JavaScript - everyone agrees that it's not a great language * TypeScript - just JavaScript with some type checking on top * ReasonML/Fable/PureScript - more or less equivalent to Elm but even smaller communities And I haven't heard anyone seriously argue against the core principles of Elm - pure functions, static typing, no nulls (except some people like Rich Hickey I guess, who think dynamic functional is the way to go). &amp;#x200B; Here's a more reasonable article: [https://redmonk.com/sogrady/2019/03/20/language-rankings-1-19](https://redmonk.com/sogrady/2019/03/20/language-rankings-1-19/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=language-rankings-1-19) As you can see on their chart, Elm is above average on GitHub, although behind on Stack Overflow no doubt because the community happens to use Slack instead.
Look into `mdgriffith/elm-ui` To me, it's the most exciting thing in frontend dev right now.
If it's hard to find elm jobs, isn't that an advantage for your boss? It would mean that there are more devs for fewer positions and those a pretty eager to get an elm gig
The pragmatic programmer book states that you should learn at least one new language each year. You don't learn them to use in production of course. You learn them because each language as something valuable to teach you. I learnt some basics of Haskell and today it changed completely the way I code in Java. So this article is completely stupid from its first sentence. Now from manager point of view, I work on a Java project. To recruit someone it takes at least 6 month with dozens of interview. Yes there is more choice on the market but there is also 70% that don't care about software development and they just want money to put food on the table at the end of the day. That's clearly people I don't want in my team as a developer. Smaller communities does not have this kind of problem imho.
I think the problem is at the very beginning: \&gt; Do we have any stats to argue agains this text ? I don't have, because there are no sensible stats in the article. It is an highly opinionated text: either you trust Subham's opinion or you don't. There are no facts in what he says, unless Tiobe + StackOverflow answers \_count\_ is all what you value about a programming language.
If your boss is using a listicle with a Drake meme to make business decisions, it might be time to find a new job.
If there are unsupported browser APIs you're trying to target, it's probably better to think of Elm as the *framework* more-so than the language (although it's one and the same). By default, Elm and its core libraries provide all of the tools I've leaned on frameworks for in the past (state management, data binding/vdom, reusable UI). When viewed through that lens, I think it makes more sense that you wouldn't really see much in the way of Elm UI frameworks. \`elm-ui\` being an obvious exception since it's totally rethinking how we deliver UIs on the web from the ground up. I'm also really looking forward to better browser API support, though. Can't wait until I don't have to write any more JS glue!
Is there a need for the selection information to be coupled to the display information? Ie. what about: type alias Model = { selectedA : Maybe A , selectedB : Maybe B -- that's selections done. Now for displaying: , display : Display } type alias A = {a : ()} type alias B = {b : ()} type Display = DisplayNothing | DisplayA | DisplayBoth
Right, that would be the first approach, but the problem with it is that a state in which something is displayed which has not been selected is possible, and I'm trying to do the opposite. Also, a B can be selected without an A with that model.
Right, that would be the first approach, but the problem with it is that a state in which something is displayed which has not been selected is possible, and I'm trying to do the opposite. Also, a B can be selected without an A with that model.
Ah, right. I've misunderstood the requirements. What about: &amp;#x200B; type Display = DisplayNothing | DisplayA A | DisplayBoth A B type Selected = SelectedNothing | SelectedA | SelectedBoth
Thanks, but that would cure the second problem, yet not the first. :) I could end up with a model like this: { selected = SelectedNothing , display = DisplayA { ... } } That is, displaying something that's not there (not been selected).
In your original post you said you need the model to remember the selections even if they aren't to be displayed, right? The way I understand it, it's in agreement with that spec... &amp;#x200B; I guess I'm having trouble visualizing the requirements. Can you say what's the usecase? That might paint a better picture.
It has to remember what's been selected even if they're not displayed, but not the opposite case, that is, display something that's never been selected. This is what I'm trying to do. It's a table with Mandarin Chinese syllables. Once you click one, it will display a list of characters that are pronounced like that syllable. When you click a character, it displays information about the character. Once you close the character info display, or then the list of characters, for animation purposes I don't want to clear the selected data, only note that it's not being displayed. By the way, I just reread the code I wrote in my original post and noticed the case expression is wrong… Sorry about that, I'll fix it.
 type Selection = SelectedNone | SelectedA { a : A , display : Bool } | SelectedBoth { a : A , b : B , display : DisplayFull } type DisplayFull = DisplayNone | DisplayA | DisplayBoth All six scenarios: 1. selected none, displayed none = SelectedNone 2. selected A, displayed none = SelectedA { ..., display = False } 3. selected A, displayed A = SelectedA { ..., display = True } 4. selected both, displayed none = SelectedBoth { ..., display = DisplayNone } 5. selected both, displayed A = SelectedBoth { ..., display = DisplayA } 6. selected both, displayed both = SelectedBoth { ..., display = DisplayBoth }
Ohh right, after my post I came to the conclusion that flattening out the six options would probably be my best choice, but you have the better way by putting "selection" first, which gets rid of the Maybes. 👍 Thanks!
Glad to help, and thanks for the patient explanations! 😉
No way, you're the patient one that stuck around despite my crappy explaining. 😅
You can't encode tuples directly into JSON so you have to decide what sort of structure you want. Are you okay with a list of lists of lists? e.g. `[ [ [1,1], [3,4] ], [ [2,3], [2,5] ], ... ]` If so, you can write an Elm function to encode each element in your top level list to produce a `Value`, map it over the top level list, and then call `Json.Encode.list` on it. Example (note this code is untested): -- Convert each pair of tuples to a Value tuplePairToListPairEncoder : ((Int, Int), (Int, Int)) -&gt; Value tuplePairToListPairEncoder ((x1, y1), (x2, y2)) = Json.Encode.list [ Json.Encode.list [ Json.Encode.int x1, Json.Encode.int y1] , Json.Encode.list [ Json.Encode.int x2, Json.Encode.int y2] ] linesEncoder : List ((Int, Int), (Int, Int)) -&gt; String linesEncoder lines = lines -- convert the elements in the lines list using our conversion function |&gt; List.map tuplePairToListPairEncoder -- do a final conversion of the List (Value) to a Value |&gt; Json.Encode.list -- convert the Value to a String |&gt; Json.Encode.encode 0
A generic encoder for a 2-tuple can be implemented as follows: tuple2Encoder : (a -&gt; Encode.Value) -&gt; (b -&gt; Encode.Value) -&gt; ( a, b ) -&gt; Encode.Value tuple2Encoder aEncoder bEncoder ( a, b ) = Encode.list identity [ aEncoder a, bEncoder b ] Now we are able to encode a `line` using the previous encoder: lineEncoder : ( ( Int, Int ), ( Int, Int ) ) -&gt; Encode.Value lineEncoder ( a, b ) = Encode.list identity [ tuple2Encoder Encode.Int Encode.Int a , tuple2Encoder Encode.Int Encode.Int b ] The rest is as simple it gets: `Encode.list lineEncoder model.lines`. I created a [working example on Ellie](https://ellie-app.com/5p5KrLSTncka1) for to play around with. Hope this helps.
Elm [dropped reactivity for simplicity in 2016.](https://elm-lang.org/blog/farewell-to-frp)
You need to choose a way to represent your tuples. JavaScript doesn't have them. What /u/sbruchmann proposed is what most people use - a list of two elements. (Later when decoding, you can verify it has only two elements, so no danger there.) You could also encode as an object like {first: a, second: b} if you wanted to.
best: productivity over the long-term. worst: lack of large-scale adoption means fewer libraries and less buy-in from colleagues.
Best: Makes functional programing easy. Worst: Its dependency to JavaScript. There are a lot of people comming from the JavaScript-World that feel like Elm needs to be more like a JavaScript-Framework. But Elm in its pure form has nothing to do with Javascript, thats just the elm/browser and the compiler. If we would have a webAssembly-compiler and maybe some sort of elm/server we would see a clear difference.
Elm in it‘s current form is very nice but it‘s lack of browser api support is holding me back from using it for large scale stuff. Ports are imho too inconvenient. Once this story improves I‘ll use it over JS/TS any day.
thumbs up: elm-ui thumbs down: scarcity of elm jobs
Best: Elm UI Row polymorphism without subtype ((almost) decidable typechecker) Worst: The "every detail should be best practice" attitude from the main contributors. This appears in multiple ways such as the strong resistance against any build-tool and external package management. This result in huge mental workload for building even a small toy app, and is quite a disastrous experience for beginners without a mentor. And the random removal of forum posts. (I agree with locking, downvoting, hiding or archiving posts for sufficient reason, but removal is the attitude of putting head in sand)
Best: when it compiles it works (mostly). Also, yeah, elm-ui is really a thing. I even ported it to Kotlin and married it with snabbdom. Worst: Elm is open sourced but that doesn't help much. Pull Requests are mostly ignored, the internal tooling lacks. Forks are not happening because "community".
You seen the pinned posts in #jobs on Elm Slack? 😅 That downside is an upside for a company considering Elm: you'll have no problems hiring an Elm programmer.
Best: maintainability, compiler as assistant, algebraic data types and strong static type system (these are all kinda related). Worst: compiler bugs taking long time to fix in the official releases, pull requests and issues on core libraries taking long time to get an answer and/or resolve. (This is related to Elm being developed by one person ➡️ limited time. But that brings good design choices and I like those, so I tend to turn the blind eye on these negatives.)
Best: elm-ui and haskell-based syntax. Worst: I think there's some missing component in elm to solve the complexity of Http, Encoding/Decoding, random number generation, time etc. I'm not sure what the solution would be, but having to add 10 lines of code in 4 entirely different places in your code-base just to get one random number.
Best: purity Worst: removing interesting features because the bottom denominator might not understand something and becoming the go of functional programming (I'm sure elm will never have typeclasses and maybe next they'll limit tuples to length 2)
Best: easiest on-ramp into the world of pure functional programming. By far. Worst: the way the community is managed from the top. Trying to globally optimize an entire ecosystem from within one person's mind comes across as controlling and opaque. Note that "taking tough calls to improve the language" isn't the problem. For example, removing backticks and rallying everyone around `|&gt;` pipelines was a total win, even though it caused churn. What is frustrating is things like keeping infix operators in the language, *but only for Evan*. I'm glad there's a [use case he likes](https://github.com/elm/parser). But killing [other use cases](https://github.com/krisajenkins/formatting), while keeping the language feature, simply drives people away to less hostile ecosystems.
Best: dictatorship Worst: dictatorship
Also, worst: no server targeted production-grade runtime available.
Best: High reliability of compiled code Worst: Very difficult to make re-usable UI components. There's no good way to make a Select2 in an easy re-usable way since all state has to be managed by the main program, not the component.
Perhaps Elm will drop the virtual dom in 2020 :)
Best: refactoring experience with the compiler. Worst: relying on slack as a place to get help and answer questions. Super inefficient and means people are asking the same questions over. Reusable answers in stack overflow would be much IMO. 2nd Worst: the community associated drama. I am not a a contributor barely pay attention to leadership or governance etc issues of any of the open source projects I use. The fact someone like me is aware of any friction/drama at the top is a bad sign.
When I was still working in JS I found few times that Select2 specifically is actually a poor thing. I always came up to a point when it didn't work in some cases/browsers, was not configurable enough so I had to write my own dropdowns for performance/looks/browser-compliant/styling sake. Although, at first hand it looks promising. And it's been with most of ready things. It happened that it was cheaper (less time consuming) to implement own crafted solution than having big library with 80% features I didn't need and problems as a bonus. However, it comes with experience and it depends on your needs or client's demands.
Could you come up with examples of those frictions/dramas? You mean things like 2 vs 4 spaces in the elm-format? Something else?
&gt;I answer to question about stack overflow last week. Stack overflow is not perfect. The technologie and methodology evolved with time and some response are ephemeral. Too much response on stack overflow are outdated and used by to many programmers. But yes, some questions need to be persisted.
This is golden, thank you :D
This is the first time I've laughed at one of these in years. Bravo!
Best: Safety and ease of use, and performance. I am maintaining solo 40k loc, and I am introducing changes, new features without sweat nor headache. &amp;#x200B; Worst: elm-mode for emacs is dog-shit. Worse. But still I stick to emacs and check compilation errors, go to file manually and do the fix. Also I find anoying people that complain because of lack of updates on Elm compiler. I have been developing same project since 0.17, and I don't understand why people worry so much about on which pace other people are delivering something new. Current state of Elm is stable, and sure we can (Maybe (List NiceThings)) but I would be super fine that Evan retires now and freezes the project. I would still use it, and keep using it, because it is LIGHT YEARS AHEAD OF ANY OTHER CODE-IN-BROWSER SOLUTION (my educated opinion)
You know, at first I wanted to write what a piece of distespectul sc*mba*gs, but than I watched and changed my mind. It‘s funny for real!
Have you used it since 0.19 came out? It greatly improved browser API
I'm struggling with some basic application layout. I'm trying to put together a small demo app that follows a login workflow and when finished it drops you on a page with a small API console that lets you type some things into text fields, press a button, see the results. &amp;#x200B; The login workflow went smoothly. I run an http request as part of the init, change to a loading state, and then either redirect to the provider or display a welcome message after sending an http request to my server to validate the token. The API console is where it all falls apart for me. &amp;#x200B; Coming from React, this would be easy. Once the user is logged in, I'd create a component that takes the username as a prop and let it worry about how it needs to render itself. In Elm, it seems like I need to create another state for my model to transition into and have a separate branch of my update function that handles this, and another set of helpers to check for this state. &amp;#x200B; Do I really need to build up a massive update like this? Ideally I'd be able to use a \`Browser.sandbox\` initialized with the one parameter and render it.
You could take \`Select2\` and replace it with \`ReactSelect\` and the complaint would be similar. It's hard to have reusable elements that you can compose into a view.
I'm also new but can't you just do a HTML canvas with coloured rects?
Thanks for the reply, i'll give it a try. Ideally i would want to implement the dataset directly from its csv format and then carry out the editing of the colours
Not sure I totally understand the part you're struggling with, but here is an Ellie showing how to display different pages and switch between them: [https://ellie-app.com/5qWDfLK6c3za1](https://ellie-app.com/5qWDfLK6c3za1) The page type in my example is just tags to distinguish pages, but it could also carry the state needed for each page (eg login errors for the login page, or API key for the console page). Does this answer your question?
I guess that's my problem, the main state needs to manage everything. I got it working, I can post pretty much the entire file in a gist tomorrow when I'm back at my work computer. It's only about 300 lines with a fair amount being type declarations and I certainly wouldn't mind feedback. It just doesn't feel good. I feel like I should be able to define some layout in the main portion and have each input on my API console be some isolated piece of code with its own view since I'm only pushing some user data down into them then letting them do their own thing. Instead I end up with a big main program with model state like ``` type alias session = { username : String, id : string } type alias profile = { some body from api reply } type alias sessionWithProfile { currentUser : session, profileResponse : profile } type alias sessionWithSearchResults ... type alias sessionWith... ``` and each part of the api console ends up setting the model to one of the sessionWith types. It means my update has to to a type switch on the message and then another type switch on the model. Each one only needs to worry about one or two model types so it's not exactly combinatoric but it certainly feels like I'm getting there sometimes.
You realize that +,-,*,/,// are all infix operators? Its actually very common to have infix operators (because maths written in (reverse polish notation)[https://en.wikipedia.org/wiki/Polish_notation] is hard to read.) Typically, a Language has a few infix operator and does not allow users to define their own. So Elm is not doing something weird here. Its just that Even though it would make sense to give infix operators to package creators, it didn't work out for him. And that's okey, because Elm is still in its 0.X state. Even should be allowed to make big changes, instead of carrying a bag of mistakes around.
Best: the algebraic type system, elm architecture, the design philosophy of having few, but internally consistent and well designed language constructs Worst: no private package repository, ports can be tiresome when you need them for simpler JS api calls that could work simply through a FFI
I meant user-defined infix operators. I understand the 0.X thing, and that features come with tradeoffs. If Evan decided that user-defined operators were a net lose, and removed them from the compiler, I would respect that. (As with my example of removing backticks.) What I find difficult is keeping the feature in the compiler, actively using it, promoting [packages](https://package.elm-lang.org/packages/elm/parser/1.1.0/) exposing it, but restricting it so only a handful of blessed people are allowed to use it. Even for private use or experiments, from which they might report back useful experience. There are two Elm 0.19 language definitions implemented in a single binary: one where `infix` is a keyword, and one where that name can be used for anything. Access to the former is restricted to a few people. I believe this is one example of the sort of mindset that drives some people reluctantly away from Elm. This also ties into other comments on the thread about Elm being "only sort of" open source: if someone has a requirement or idea to enhance `elm-parser`, they can't just fork and experiment as usual. The compiler says "no".
It might be that you know more than I do... But from my understanding infix can only be defined in elm/* packages. But elm/* is the standard library. The reason why elm/parser is not a part of elm/core is because Evan likes smaller version numbers and therefore new packages or more "experimental" stuff will get their own repository.
I understand that Elm is not the best choice to use right now, but Elixir (7th on that list)? Really?
IIRC, that article based its results on how much Stack Overflow is used?
I'm not sure I understand your point. Wherever it lives, elm-parser is just a package (not part of the compiler) and Evan believes it is a better one with user-defined infix operators. So there are valid use cases that outweigh the cost of supporting this language feature. It's just that Elm 0.19 actively prevents other people seeing if their use case might also benefit.
[removed]
My point was that the elm/* packages have direct function calls to the compiler(they can directly speak to javascript). They are NOT regular packages. That's why I have no problem if infix operators live on in the elm/* space.
Ah I see. Yes, I can see your point. I do see kernel code and user-defined infix operators as very different though. Kernel code breaks Elm's regular safety guarantees, so protecting the boundary of the trusted codebase has a lot of tangible value. User-defined infix operators are as safe as any other regular Elm function. So what's being policed is not implementation safety, but API expressiveness.
Seems to purely talk about jobs for the languages. Written for people who market themselves as "X" (e.g. Java) Programmers. I spent some time learning Elm becuase I enjoyed it and it actually made me a better coder overall. Having another language on my CV doesn't hurt either. Most places I've worked look for people who care about problem solving and know multiple lanagues. We've even hired people who barely know our core languages because they can get up to speed pretty quickly.
I think this list needs to be looked at in perspective. There are a lot more contract jobs than product companies, and it's much more unlikely that a company will contract out a job for a niche language. &amp;#x200B; At my previous job, we used Elm every day with our own product, but never saw any contracts coming in that requested it.
Yeah, I think it would be good to see a gist. Pretty sure you shouldn't need all those types! Hard to advise without a bit more context though. In the meantime, perhaps these posts I wrote might help?: [https://korban.net/posts/elm/2018-07-27-splitting-elm-code-into-multiple-files/](https://korban.net/posts/elm/2018-07-27-splitting-elm-code-into-multiple-files/) [https://korban.net/posts/elm/2018-06-14-modules-in-elm/](https://korban.net/posts/elm/2018-06-14-modules-in-elm/) &amp;#x200B; You \*can\* separate each page into its own module, but you'll still need to wire it into the main model and update function.
These rankings are meaningless and harmful. They are part of populistic and sensation seeking journalism. In my 30 years in IT i didn't see more harmful languages for the education of new generation of sw developers than Python and JavaScript. Two languages leading every programming language rankings put there. Regretfully it's not their quality but loudness and vast mass of unskilled (not judging the reason for lack of skills) developers seeking help, which makes them popular.
I wouldn't say Python is bad. You can get a lot done with little knowledge. Great for our data science team. They are far from experts in Python but that not needed for them to achieve what they need. But it is very bad language to start with if someone wants to be a programmer. It does not teach you about ton of low level stuff that you need if you are building something bigger that should run in production. Last but not least &gt;I came for the language, but I stayed for the community. &amp;#x200B; And I hate JS so I would not like to comment on that. :)
Sorry for the delay there, I got caught up at work today. Here's that gist: https://gist.github.com/mlh758/142a00a4e3ddd1dcedc06e533d8adfac It won't do much if you try to run it, the sampleapp.cerner.com url is something I overrode in my hosts file so the login/redirect workflow would run through. I'll read the articles you wrote.
In the first article: &amp;#x200B; `On the flip side, I’ve also seen a different type of complaints about how the Elm architecture forces parent components to manage the state and structure of all children components, or how there is no good alternative to using model-update-view triplets for code organisation.` `I think what those people are missing is that similar wiring exists in JavaScript as well (for example), it’s just hidden in the framework du jour.` &amp;#x200B; This isn't exactly true. For better or worse you can manipulate just about any part of the dom and register event handlers from anywhere in plain old JavaScript. This can be wildly infuriating to read, but it does mean that you can fire off a function, expect it to put an interactive element on the page, and not have to worry about anything it's doing. Not that it works out so cleanly all the time, hence my interest in Elm...
I guess I wasn't comparing to total anarchy :) I think you'll agree that this sort of approach doesn't scale, hence most non-trivial applications rely on some sort of framework these days.
So it looks like you're trying to encode all the states of your application in the model type. That's not needed. Instead, you can have a model which is a record: type State = Loading | Failure | ProfileUserLoadFailure type alias User = { username : String , userToSearch : String } type alias Model = { state : State , currentUser : Maybe User , profileUser : Maybe ProfileUser } init : () -&gt; ( Model, Cmd Msg ) init _ = ( { state = Loading, currentUser = Nothing, profileUser = Nothing } , Http.riskyRequest { method = "GET" , headers = [] , body = Http.emptyBody , url = "https://businesslogindev.cerner.com/user/token" , expect = Http.expectJson GotToken tokenDecoder , timeout = Nothing , tracker = Nothing } ) Then, in `update`, you'll write something like: GotProfileUser result -&gt; case result of Ok user -&gt; ({ model | profileUser = Just user }, Cmd.none) Err _ -&gt; ( { model | state = ProfileUserLoadFailure }, Cmd.none ) The key point is that you can represent the state of your model as an (evolving) record rather than a series of states encoded in a custom type.
Elixir
I agree that it doesn't scale well in total anarchy, but the plethora of reusable components in React and Angular speak to the potential benefits when you constrain that behavior with a framework into something useful. I rarely have to shuffle state more than one layer with react components which is a far cry from carrying all the behavior back to a central main function. The code base is split up into isolated interactive behavior that I can reason about in isolation. It's nice being able to drop an element on the page, let it do its thing, and just retrieve its value either when I need it or as it changes through a callback. It makes interacting with stateful elements like a searchable select much more straightforward. &amp;#x200B; I can clearly see there are some substantial benefits to Elm, and I'm going to keep going with it, but at work a lot of the time we have a lot of interactive elements on the page, maybe some modals, formatted editors like CKEditor all playing together, possibly executing automatic saves... I'm not sure I would like having to carry all of that logic back to one central update function so far from the area that was concerned with the behavior. &amp;#x200B; I'll follow your suggestions above though on my demo app though, and add a couple more items to the API console and see if that assuages some of my concerns.
Yes to me Elixir feels way more too similar to Ruby. I personally much prefer Erlang. I've tried 3 times to use it and read the entire doc of cowboy and wrote some non production code in Erlang, and to me I feel better with Erlang. But the tooling and deployment is not as straight forward as Go's single binary.
This led to a *much* simpler update function and I was able to clean out most of the branches of my view. The view helpers check the maybe now for the bit of the model they care about and render or not. &amp;#x200B; This doesn't alleviate *all* of my concerns about trying to scale up the interactivity of a page but it definitely has a clearer path forward than the approach I was taking before. Thank you for taking the time to help out.
"Thank god you never found Prolog", lol.
I use Go on the backend and Elm on the front end. Pros of Go: - Easy to learn in a weekend - Good standard library - Excellent at gluing together databases and marshaling/unmarshaling data. The struct tags are extremely useful here where you can define how a struct looks like in json and (for example) Google Cloud Datastore and it works so easily Cons: - Nil. This is a solved problem in most modern languages. It’s surprising they didn’t implement an Optional type. - No sum types - Error handling. Related to the sum types, I would like to know the various kinds of errors that are possible and handle them appropriately. For example, I was using a csv file reader and there were different types of errors you had to check for (end of file, end of file but bytes in buffer, file not found, etc). I couldn’t just write a switch statement and have the compiler tell me if I was missing anything, I had to reference the doc to make sure I was covering all the cases).
Rust or Haskell make a lot more sense from a feature parity and functional programming consistency point of view. Also Go doesn’t have genetics and they are a major feature in most modern languages. They’re a critical anti-boilerplate tool.
I just remembered that for Elm 0.18 there was this alternative: https://github.com/gdotdesign/elm-github-install Quick googling also showed me this: https://github.com/Skinney/elm-git-install
I'll keep this one: http://imgur.com/gallery/6Q8gz82 I have this feeling that one day...
of course, I was mainly referring to the "developing experience" not at all on concept and programming type. I personally would prefer Erlang, but the tooling and deployment makes me nerveous. Haskell is something I would enjoy. But again, the issue with those, from my humble point of view, is the experience of 1) getting started 2) developer day-to-day flow and 3) deployment. After 5 years of Go, I admit that I'm tempted to build a SaaS with a FP backend to truly experienced how it is.
As someone who is currently writing the backend for my Elm client in Golang, I've been actually really disappointed in Golang. Its type system seems like a half measure, from the lack of enums to the nil type, and it honestly makes me feel LESS safe than writing JavaScript, and here is why: Writing in a language with a solid type system enables me to write code that, for the most part, eliminates impossible state at compilation time. Writing in a dynamic language also enables me to accomplish this to some degree, albeit performing many of the same checks at performance time. Meanwhile to accomplish the same thing in Golang, I feel like I would have to spend an excessive amount of time writing code because the type system gets in my way, and doesn't provide the same safety as other typed languages. Take my opinion with a grain of salt, I've only been writing Golang for a couple months, but I definitely wish I had persevered with Rust right about now
I hear Go is pretty solid! I've been using rust just because I want to learn it. But rust doesn't really strive for simplicity the same way Go does (at least so I hear), although they have pretty good error messages. I like that Go compiles to a single executable and that it's fast.
I think the ease of use is comparable with Elm, but I also feel like you're getting a whole lot less for that ease of use in Golang. I agree that Rust is more appropriate for an Elm Dev, but it's definitely not as easy to get started in as Golang. Speaking as someone who has been dabbling in rust for about a year
That's great! As your application grows, you'd actually take a hybrid approach between what you were initially trying to do, and using Maybes the way I did. It's best not to have lots of Maybes in your model. There are also ways of splitting the code off into modules which help you deal with complexity. But this isn't something that can be explained in a comment – there's a whole chapter in my [book](https://korban.net/elm/book) about organising code!
There are ways of breaking down both the model and the update function into manageable pieces. Sure, ultimately there's only one model and one update function, but there's nothing stopping you from moving 99% of a code for a UI widget into a separate module, where it's clean and maintainable. There's perhaps an extra bit of wiring you have to do compared to React, but it enables the benefits of atomic state and predictable side effects.
I've been using python with mypy. It's neat-o!
I am using Go for the backend of my Elm app, and generally happy. I have been getting very curious about doing a backend in F#.
Qatalife thanks. You answer helped me to decide something important and realize something important about my own values.
That’s cool, I’m glad for you!
Too funny 😂
As far as random numbers go, I just learned recently that if you need to use random numbers in a submodule, you can just track the `Seed` and generate a new random number and new `Seed` by using `Random.step`. if the results need to be reproducible, you can just have your user input a seed. If things need to be truly random through and through, you only need to `Random.generate` once and use the resulting number as an initial seed for all your submodules that need to generate random numbers. I'm pretty sure this is how the library was intended to be used, but I really didn't know `Random.step` existed until like two days ago.
&gt; Also Go doesn’t have generics and they are a major feature in most modern languages. They’re a critical anti-boilerplate tool. ...he said in an Elm forum. ;)
1. she 2. elm should have typeclasses but it’s no excuse to shoot yourself in the foot when picking your backend language
Wouldn't that imply that using Elm is shooting yourself in the foot when picking your frontend language? The way I see it, Go's lack of generics is very similar to the necessity of writing JSON decoders in Elm. It feels like boilerplate, but it forces you to think critically about every part of your model and prevents you from making mistakes. In practice, writing Go servers, I've never really felt the need for generics. Writing servers in Go feels to me a lot like writing frontends in Elm. The tool fits the problem well.
From my minimal use of Haskell, I can tell you that it's a joy to use. Just taking it slow with a practical problem and working my way through it beginning with a minimal POC made it work for me. I had tried the theorical route first but that felt like too much at once. One thing I find refreshing in Haskell os how good the type system is and how easy you can refactor without breaking things. This is what made it possible for me to build slowly from a MVP to bigger and bigger projects without losing confidence in my code.
Weird because I write servers in Rust and occasionally in Swift, and generics are a standard part of what I use to accomplish code reuse. But if you’re not used to a tool it makes sense you wouldn’t know when or how to use it. I can’t see any positives to using Go when even more qualified languages exist and are readily available. Saying that you don’t need generics is just obvious naivety since they’re literally the most requested feature for Go 2.0. To your point about it preventing you from making mistakes all I have to say is “huh?”. It forces you to write more code. More code means more mistakes. It’s not rocket science. Also we all just use the JSON decoder creation tool https://noredink.github.io/json-to-elm/
Go does not need generics. Don't DRY yourself out. Code readability is paramount, even if it means repeating a little code. There is a reason the vast majority of the internet is being rewritten in go.
Generics are readable, you’ve just never learnt how to read them.
It is not naive. It is based on my experience, which involves a lot of writing servers in Java as well. As you may know, Java has generics. I have used them. Many times. I also have used them in Flow and C#. I am very familiar with generics and their use. Nevertheless, I do not miss them in Go. You're right: it's not rocket science. It's computer science. The assertion that "more code means more mistakes" is not true. Compare a project with many unit tests to one without any. One contains more code, yet it almost certainly has fewer mistakes. Or compare an Elm project to a jQuery project. Again, the one with more code also probably contains fewer mistakes. This is not *universally* the case, but it is certainly *sometimes* the case, and I maintain that this is such a case. Just because many people want a feature does not mean the feature is *required*. Personal preference is all well and good, but it is not fair or logical to make blanket objective statements out of such things. Go has seen significant adoption despite its lack of generics, just as Elm has despite its lack of type classes. In fact, Go has seen much greater adoption than Elm, so it seems strange to me to defend one while criticizing the other over what are effectively equivalent features given the paradigmatic differences. And no, we do not all use that tool. For instance, I do not use that tool. Granted, I also did not know that tool existed, but after trying it out I am pretty sure I won't start using it either. Here's why: If I provide the input `{"foo": "bar"}` the tool will assume that `foo` is a `String`. But what the tool does not know, cannot know, is that `foo` is a `Maybe Foo`, and `Foo` is `"bar" | "baz" | "quux"`. It cannot possibly know this, and I do not expect it to. I suppose I could use this as a starting point, but as a personal matter I do not generally like automated code generation (this coming from someone who wrote Java for years). It feels imprecise and presumptuous to me. I find the exercise of writing JSON decoders helps me challenge my assumptions about my data, and I feel the same way about Go's lack of generics. I find it stops me from taking the easy solution of throwing a bunch of prepackaged complexity into my project and forces me to think critically about what I'm actually trying to accomplish. Does that mean I sometimes end up writing very repetitive code? Sure. But I also sometimes find myself writing very repetitive Elm code and that doesn't bother me either. Fair enough if you do not feel the same! But I would at least appreciate it if you did not reduce my opinion to "obvious naivety" just because you do not share it. It's rude, and I might add it's also against the [code of conduct](https://github.com/elm-community/discussions/blob/master/code-of-conduct.md).
That's fairly presumptuous of you. I can do that too, watch. I've probably spent more time writing and using generics than you have spent writing code your whole career.
So which is it, are they unreadable or are you deftly able to read them?
Elixir and Erlang are really semantically the same, so whichever syntax you prefer you should use. You can call Erlang libraries from elixir with ease, and can also call elixir from Erlang, with slightly less ease. Go's strength is in its deployment imo, one of the best languages for that. But the developer ergonomics of go are... Lacking imo. Granted, it's been quite some time (and versions) since I last used go, and I've never used it for a production server. But in my opinion it felt much too low level and procedural for my liking. I'm much more interested in languages like Haskell, elm, or even elixir where you can be declarative about what you want to do without worrying always about the how. Personally I see go as perfect for a tooling language, something I'm going to write once and run a lot. But for something like a production server I'm going to be working on a lot I don't want to be bothered by having to implement a for loop every time I want to map, or reduce, or filter some data.
I love working on elm+go stacks because going full imperative to full functional really makes myself a better programmer. Also it fucks with the head. The whole generics thing is so overrated, functional composition is where its at. Besides, go isn't really even OOP. I find it strange you would recommend rust. Most of my use with it has been with crap that needs stoopid performance or embedded devices. I &lt;personally&gt; think that the trade off for developer workflow isn't worth it server side, where there are as nearly many RFC tickets as client side. XD
you should use linters. when writing go, there are really two mantras you should follow that will mostly produce bugless code. 1. 100% code coverage. This is why its so easy to test and get coverage in the compiler. 2. NEVER use _ to ignore an error. By extension, all the linters should come up clean. a couple of things from your post: 1. enums absolutely exist through the use of iota. Although I strongly don't recommend it, enums are a trash concept from c, and are only good in languages where they serve and integral role (aka elm, haskell, ReasonML). This is why go libraries like gqlgen code generate enums. 2. I have a buttload of hours in rust and go. Go is designed for web servers, rust is not. The way that I see it: Would I write if in python if I could =&gt; use Go Would I write it in c if I could =&gt; use Rust 3. Copy is fucking efficient as hell in go, there is no need to return pointers unless it's a massive struct or something. Removes most null checking, although your linters should catch if you don't check for nil :] 4. Strict Typescript and Go have ~about the same safety in my book. Please tell me that's what you mean by javascript ; ;
I can’t see how going back and forth between programming paradigms makes you better? Learning functional programming definitely makes you a better programmer but that’s a once-off. Rust’s strict type system eliminates bugs that occur in other languages (such as Go), most importantly Null pointer exceptions do not exist in Rust. So yes, Rust is great in situations where you need speed or safety, but it’s also great in situations where neither is needed but since when is speed or safety a bad thing?
Well its a bad thing when it offsets development time. I equate go to python and rust to c, in terms of both product allocation and development time. Also, you're making it out like nil pointer errors are the source of most bugs. in both rust and go it's mainly the stupid programmers, so I don't really see nil as that much of a game changer (besides, testing handles all that). In rust land, the borrow checker is super nice coming from a c background, but it eliminates errors specifically relevant to low level programming, not programming in general. You're not wrong that rust is faster or safer, but go is definitely simpler with more utility.
But how can you say some of this stuff with a straight face? “Lack of generics causes me to think harder about the actual problem.” No, it just causes you to think harder because it’s a missing language feature. Defending it isn’t naive, it’s simply obtuse. And citing unit tests as an example of when more code produces less bugs is again obtuse. You’re not wrong, you’ve just completely missed the point. More _production_ code will lead to that much code. I would think that would be obvious, but clearly not.
If you think the vast majority of the internet is being rewritten in go you need to get out of your silicon valley bubble.
https://reddit.com/r/programmingcirclejerk/comments/bkk826/go_does_not_need_generics_dont_dry_yourself_out/
Despite what you may think, it is not my mission to convince you to adopt my practices or preferences. But I can assure you that that is what they are. And I guess I will also have to ask _you_ to stop violating the code of conduct. Or perhaps you are unaware that "obtuse" is a synonym of "stupid" and is a completely inappropriate insult to hurl at the other members of this community.
It's not even true here. This person is just a maroon.
&gt; I equate go to python and rust to c, in terms of both product allocation and development time. Have you actually written anything useful in all four languages? This is an extremely superficial comparison that only half-makes-sense if the only things you know about Rust, Python and C came from /r/golang
sshhhhhhh
Yeah, it's the same idea... But it doesn't do ADTs 😝
I write production code in all four languages. And yes it is a superficial comparison and everything has a place somewhere.
I don’t feel any pressure to adopt your software practices. I do feel compelled to chime in when something that’s said online makes me twitch because of how inaccurate it sounds to me. The argument that the addition of generics somehow causes lazy solutions, and conversely the absence of generics causes more well-thought out solutions sounds like an excuse to me. You can address that instead of hiding behind a code of conduct.
&gt; There is a reason the vast majority of the internet is being rewritten in go. i just
I'm not hiding behind anything. I'm asking you to comport yourself in a civil manner. I do not have the time to spare on exhaustively detailing my position to the satisfaction of someone who has likely already decided their mind on the matter. What's the value? Now stop being a jerk.
This is your brain on lol-no-generics
Go is dogshit. It's slow, it lacks generics. There is no real reason to use it over the many other languages out there
I'm just learning Elm, and as part of my stumbling around I wanted to create a schedule, with a bunch of events, each associated with a timestamp, ordered so that the timestamps were in ascending order. Eventually I discovered `List.sortBy` to keep my events sorted by timestamp, but until I figured that out, I was trying to represent my schedule as a `List (Int, Activity)` and got a baffling error message: This argument is: List ( Int, Activity ) But `sort` needs the 1st argument to be: List ( Int, Activity ) Full example code is at https://ellie-app.com/5srPWrvj2kza1 if you want to fiddle with it yourself. It turns out that `List ( Int, String )` works fine, but a custom type does not. Like I said, I worked around this on my own, but I would like to understand what went wrong here so I can avoid similar errors in future. If it helps, I'm familiar with Rust and Python, but not JavaScript or Haskell (which I think are Elm's main audiences).
I'm no expert, but I'd suggest this is due to your 'Activity' type not being a \_comparable\_ type (i.e. 'can be compared'). The comparables are Elm defined, which is why you need to use sortBy. The compiler error looks like a red herring. \[Happy to have corrections from others :-)\]
That makes a lot of sense, thanks!
I have a few "stupid" questions for everyone coming to this post. * In what timezone are the times? * will the talk be livestreamed?
First, \`handleKeyDown\` signature should be \`( Int -&gt; msg ) -&gt; Attribute msg\`. You should have something like this: [https://ellie-app.com/5szn8wR3cYDa1](https://ellie-app.com/5szn8wR3cYDa1) &amp;#x200B; Here, \`keyCode\` is a json decoder to get the key code of a keyboard event. Once we have the key code, we wrap it with your custom event (\`tagger\`). Then We put the event in the structure that the \`custom\` handler needs. Finally, we pass it to the custom handler with the event name.
Write the back-end in whatever you're comfortable with. For me I like F# (because it is an OCAML syntax language like Elm - so in many cases it's indistinguishable).
I'll give you back the point someone took away :p As far as the enums go, that's kind of my point is I wish that Golang had a more robust type system in general, hence why I feel like Golang is a half measure in that respect. As far as JavaScript, I wasn't talking about typescript (as that is actually at complication time too), but typescript actually has a pretty decent type system considering how dynamic the language it's accommodating is. When I write JavaScript though I like to write lots of functions that will generate errors if the inputs are invalid. For example like a string that you really only want to be capable of 3 values or something to that effect (which would be very effectively solved by enums in another language). Regarding using \_ to ignore an error I haven't done that before yet, but I have forgotten to do something with the error before and it kills me that just fails silently. Thats way harder to do in Rust and Elm. And regarding Rust, I know it's not a popular opinion but I personally like it for web. It's got some killer performance, there are frameworks like actix that are actually pretty decent and the language feels similar in many ways to Elm, albeit much less functionally oriented. My personal struggle with Rust isn't using it as a web technology but simply using it at all, I haven't managed to wrap my head around how the standard language works yet, especially when async starts getting mixed in. And I've been working with async concepts in other languages for years. Again this is just my opinion, and I'm sure I just haven't discovered the "go way" of doing things for many of these issues I'm having. So far I just haven't enjoyed my time with Golang as much as I have with languages like Elm or JavaScript
Mixing up your serialization models with internal models is not good practice IMO. Haskell has a tool that creates JSON instances for datatypes but in my experience rarely is the internal model the data I want to send. For example if someone queries for User data then the password should not be sent along. In this case writing manual serializers is the correct thing to do but people often out of laziness tweak the models to derive your json serializers automatically instead. This is one of the reasons Elm doesn't have it. Also if using the JSON decoder tool it's a red flag except for simple cases. JSON data often has a nested structure but Elm records should be flat and relational as nested records are bad practice, except for a few cases. Richard Feldman has a [good talk on this](https://www.youtube.com/watch?v=28OdemxhfbU).
Quick side note: For game development we have a own repos: https://github.com/rofrol/awesome-elm-gamedev
Reminds me of Elm finder (https://www.elmfinder.org/), although Elm finder allows sorting by a few metrics like number of stars. It also shows commit frequency in a neat little graph.
I Love it. Also if you want to find new packages: https://libraries.io/search?order=desc&amp;platforms=Elm&amp;sort=created_at
Huh, I’ve never seen it. Will check it out. I guess there’s a bit of a discoverability issue with the tools as well.
Elm Finder creator here. What kind of bug do you mean? Elm Finder has one problem. I don't have time and knowledge to categorize all the packages that there are. &amp;#x200B; When it comes to data sources I also have a problem with that. The only way for met to get new packages automatically is JSON from [package.elm-lang.org](https://package.elm-lang.org). I created this thing over a weekend from [djangopackages.org](https://djangopackages.org) fork, so I would be more than happy for any tips on how to improve that.
Sorry, I should have linked the issue. Specifically, libraries.io relies on a route from package.elm-lang.com that was removed. https://github.com/librariesio/libraries.io/issues/2347. I believe no new data has come in since the route was removed (although I didn’t look very thoroughly, maybe some data doesn’t come from libraries.io) I should also say that it was a great idea! I’ve been thinking about making a similar tool, but I wasn’t sure how to maintain up-to-date stats from GitHub. I didn’t know about libraries.io, which makes things a lot easier! (Assuming it’s working lol)
Ah, libraries.io is actually the data source for Elm Finder. Notice the most recent package was in 2018... here’s the issue I mentioned: https://github.com/librariesio/libraries.io/issues/2347 Maybe if we get more eyes on this, someone will come along that can fix it!
There really is. I couldn’t remember the name “Elm Finder” so I had to dig through my browser history!
I fixed footer to clear confusion. Elm Finder takes data directly from GitHub and Elm packages.
Really?! Sorry to spread misinformation then. Going to go back and edit all my comments.
I can't wait almost 2 months to watch this :(
Thanks. I even fixed broken search because of this. Since I had opened IDE it was hard to resist.
A language needs to be at least one of the following to be worth learning: 1. Popular - e.g. learn JavaScript, C#, Java, C++ etc. to get a job. 2. Educational - e.g. learn Haskell to learn more about programming concepts The one that stands out as bad on the list is CoffeeScript as it is losing popularity, there are much better alternatives (e.g. even ES6 itself) and there is nothing educational to be learned from CoffeeScript.
* nyc * idk
It's very unlikely that a function will require all the properties in your `AppState`. One thing I do is to have the `AppState` as a type alias and then only accept the properties I need using extensible records: ``` viewThing : { a | propertyA : String, propertyB : Bool } -&gt; Html msg -- somwhere else viewThing appState ``` Another thing you can do is consider having a shallower view hierarchy. I have a function which composes a bunch of different views onto a page like so: ``` type alias Config msg = { errorList : Maybe (Html msg) , filterBox : Html msg , outlookList : Html msg , companyName : Html msg , details : Html msg , history : Html msg , form : Maybe (Html msg) , actionPad : Html msg } viewPage : Config msg -&gt; Html msg view components = div [] [ components.filterBox , components.outlookList -- and so on ] ```
In our app, we just pass down this AppState (we call it Flags) however deep we need. No problem.
\+1 to using extensible records. The best Model structure is a flat record :)
Thanks for the answer. Well, my concern was not that I'm passing the full AppState, however, the boilerplate code needed to do that (if you have a look into the example in the linked article, you can see how the Reader monad can greatly help with that in Haskell) Having shallower view hierarchy might help, but I have \~25 different screen, some of them very complex, so I need to have some structure there.
I agree that it's not really a problem. I was just wondering, whether I can do better.
Is passing around the AppState to your view functions a big issue?
Revisiting this again, there is no reason why you can't implement the reader monad in Elm : [https://ellie-app.com/5vH8Z54JmsRa1](https://ellie-app.com/5vH8Z54JmsRa1) A few things to note: * I haven't generalised this example to any Config type, to make it easier to understand * I still strongly recommend you don't follow this pattern, and instead have each view only accept the properties it requires from the config. So in the example `viewA` should be `viewA : {c | propA : String } -&gt; Html msg` , or even better: `viewA : String -&gt; Html msg`
It would be interesting to know if @rtfeldman changed his stance on typeclasses.
Forgive a noob question, but isn't the Model already the idiomatic shared state?
From what I can tell, the article first assumes that every module needs to have its own Model/View/Update. Then they have additionally a shared State that gets passed between them. I've reasonably started a similar structure. My model looks something like this: ``` type Model = LoadingPage | Guest Config | User Config User.Model | Admin Config Admin.Model {- In User.elm -} type Model = { user: User , -- things used for my view } {- In Admin.elm -} type Model = { user: User , -- admin realted stuff , -- things used for my view } ``` Here the `User` would be my "shared State". That said I don't believe that the way they do it in the article would be best practice. I rather would point you towards [Richards Feldman talk on his elm-spa-example](https://www.youtube.com/watch?v=RN2_NchjrJQ).
Thanks!
We follow the architecture presented by Richard Feldman, so each Module has its own Model/View/Update which is explicitly passed down from the higher level Modules. If we then want to divide a module of a page into smaller reusable modules, there might me information that needs to be available in several modules, similar to your `User` example. For example, we introduce a filter Module from which the user can select and apply filters to a list which resides in a different Module. **Updates must now be propagated between these two modules**, i.e., a change in Module A must also be visible in Module B. For this, we explored the shared state approach and found that it worked since it retained the single source truth principle and it strengthened the separation of concerns. It is argued that this can be avoided by not splitting up modules in the first place (see [The Life of a File](https://www.youtube.com/watch?v=XpDsk374LDE)), but we think in a lot of cases it still make sense to split up a module (see Discussion).
Yes, like Orasund showed, a model can be used by many modules. It is however difficult to propagate a change of a model in between different modules. The article explores the idea of solving this problem using a shared state (as opposed to one huge module).
Ok, I think I understand. Thanks!
My current side project uses a very similar approach. It's currently less than 1000 LOC so it provides a non-trivial yet non-overwhelming example of using shared state. Check it out **[here](https://github.com/parlez-vous/site)** The inspiration for this design came straight from this project: https://github.com/jxxcarlson/elm-shared-login
&gt; A language needs to be at least one of the following to be worth learning: &gt; 1. Popular - e.g. learn JavaScript, C#, Java, C++ etc. to get a job. 2. Educational - e.g. learn Haskell to learn more about programming concepts Or... 3\. Fun.
I believe he will give the same presentation as [the one he gave at Philly ETE 2019](https://www.youtube.com/watch?v=5CYeZ2kEiOI) a few days ago.
That is one of the metrics. Funny thing about SO is that you can get the % of unanswered questions for a given topic too. Elm does better in that regard than its competitors last I checked: React, Vue.
That list is actually nonsense, sorry. Kotlin is now the official language to develop in for Android, and it's a very good language at that, so any inclusion in a "don't learn" list is really nonsensical
I will see it, thanks a lot :D
Im still stuck with converting json to records From ```json { "ATL": { "teamCity": "Atlanta", "teamName": "Hawks", "logoURL": "https://logohere.tld", "players": { [ { 123454: "John Smith", headshotURL: "https://pic.tld" }, { 124553: "Joe Smith", headshotURL: "https://pic.tld" } ] } }, ... } ``` To ``` type alias Teams = { teamHome : List TeamHome , teamAway: List TeamAway } type alias TeamHome = { name : String , city : String , players : List PlayerHome } type alias PlayerHome = { name : String , headshotURL : String } ``` im trying it by: ``` decodeAllTeam = map2 Teams (field "teamHome" teamHome) (field "teamAway" teamAway) teamHome = map3 TeamHome (field "name" Json.Decode.string) (field "city" Json.Decode.string) (field "players playerHome) playerHome = map2 PlayerHome (field "name" Json.Decode.string) (field "headshotURL" Json.Decode.string) .... ```
&gt; Overall, these numbers seem to indicate that the ecosystem is growing steadily. I'm not so sure. I note that of those nine numbers, I think there are seven that I would basically not expect to go down until the elm community is super dead, and two that did go down. (One ambiguous one: based on my own behavior, I don't expect people to typically unsubscribe from /r/elm if they leave the community. I might be wrong there.) So okay, there's been 30% growth in number of users on github. (I assume that's "number of users with at least one published elm repo"?) But as you note, that includes new users, users who were previously active and are still active, and users who were previously active and have now left the community. How many are in that last group? We don't know. We do know that fewer repositories have been updated recently, *even though there are more repositories*. Down from 7.6% to 4.2% in the last month. There are any number of possible reasons for that, so I don't think this is strong evidence of a decline. But I don't think it can be taken as evidence of growth, either. You acknowledge this, &gt; the growth in those numbers doesn’t necessarily show that the current pool of active Elm developers has grown, but it does show that new people keep getting involved in the Elm community at least for some time. But if new people get involved but old people leave at the same rate, I don't think that's what people usually mean when they talk about growth. (The article talks about the elm "ecosystem" and I'm talking here about the elm "community". I acknowledge that these are not quite the same thing. But I think my comment here is relevant to the concerns mentioned in the first paragraph.)
This post is not about elm or even compilers/language versions in particular, I hope its okay for me to post this. I do think it applies to the elm language situation. Maybe a more frequent release schedule might be beneficial? Haskell recently switched to a more frequent one, it should be possible to learn advantages and disadvantages from that. What are your thoughts?
Haskell has more than one person on it, and more importantly is a very mature language. Don’t forget elm isn’t even version *one* yet. Evan’s choice for a long release cycle is deliberate and well thought out. In a vacuum, quicker releases would be nice. Especially for some of the significant compiler bugs. But I think we will appreciate his choice in the future.
Your points have some merit (hence my disclaimer that you pointed out). However, note also that there is growth both in package numbers *and* in package authors. Those people were engaged enough with Elm to learn how to create and publish packages, which is a far higher bar than just taking the language for a spin. Note also that people bothered to publish 3300 new repos on GitHub – also a higher effort than simply reading the Elm guide and saying "nah, not for me". There is also anecdotal evidence like the uptick in job postings since the 0.19 release that was pointed out to me. Unfortunately, it's hard to get numbers on that. A new conference also started out this year (Elm in the Spring). So all of that gives me some confidence that there is real expansion of the community and the ecosystem.
&gt;Your points have some merit (hence my disclaimer that you pointed out). However, note also that there is growth both in package numbers *and* in package authors. Those people were engaged enough with Elm to learn how to create and publish packages, which is a far higher bar than just taking the language for a spin. &gt; &gt;Note also that people bothered to publish 3300 new repos on GitHub – also a higher effort than simply reading the Elm guide and saying "nah, not for me". Sure, but again, these numbers are basically never going to go down. So the fact that they went up says very little. I agree that there are people joining the community, but nothing in the article suggests that more people are joining than leaving. &gt;There is also anecdotal evidence like the uptick in job postings since the 0.19 release that was pointed out to me. Unfortunately, it's hard to get numbers on that. &gt; &gt;A new conference also started out this year (Elm in the Spring). &gt; &gt;So all of that gives me some confidence that there is real expansion of the community and the ecosystem. Perhaps. Then the thing to take away is not "Overall, these numbers seem to indicate that the ecosystem is growing steadily", but "these numbers don't tell us much, but we have other reasons to think the ecosystem is growing".
Noitch. This smacks of enterprise support for Elm. I love the part about &amp;#x200B; \&gt; Community Libraries: Improvements and Bugfixing
I agree with u/bmzimmerman &amp;#x200B; When I started learning Elm, yea the RNG and JSON stuff was a trip. Now, it ain't nothing but a thang.
IIRC, no typeclasses because it makes the compiler error messages worse. So yea, that would also be pandering to beginners. But that's an honorable goal in a language that needs to grow. :)
There are some excellent UI thingies out there that I have used in the past. These come to mind: &amp;#x200B; [https://package.elm-lang.org/packages/CurrySoftware/elm-datepicker/latest/](https://package.elm-lang.org/packages/CurrySoftware/elm-datepicker/latest/) &amp;#x200B; [https://package.elm-lang.org/packages/NoRedInk/elm-sortable-table/latest/](https://package.elm-lang.org/packages/NoRedInk/elm-sortable-table/latest/)
Oh, it's coming. Evan, as I understand, has been meticulously planning a future for an Elm that targets WebAssembly. Go check out his interviews on elm-town. He gives a lot of insight into why he tends to make the decisions that he does. It's pretty impressive how much forethought is being given by Evan and the core devs.
I really love Elm and I use it a lot but I‘m always in fear that Evan will stop working on it and I will regret my choice. It would be reassuring if it had an agenda and frequent release cycles. But then again, it isn‘t the project of a large corp and Evan is mostly working alone on it. I understand his priority here.
Evan answers the reason why he doesn't want to do more frequent releases in this video [https://www.youtube.com/watch?v=uGlzRt-FYto](https://www.youtube.com/watch?v=uGlzRt-FYto)
Yeah, these are sadly numbers that point towards a decline :( I wonder how much that has to do with the "secret factory" approach. I love elm, but without a really strong community it's never going to get big.
Python is a really good and well though out language though, compared to so many others. The problems it has lies with its nature more than its implementation.
I think this post might help you: https://korban.net/posts/elm/2018-01-23-decoding-json-to-nested-record-fields-in-elm/ It's based on using the `Json.Decode.Pipeline` package, which makes it easier to deal with complex structures.
In what way are you concluding there is a decline?
Absolutely. Coffeescript loses there too. Elm, Haskell, Lisp, 6502 assembler would be in my 'fun' list. I should probably move somewhere with better nightlife.
He is working on it full-time at NoRedInk When I feel like it’s been quiet I just check up on his Twitter @czaplic to see what he’s up to. And if I’m really paranoid I just check the commit logs on elm/compiler https://github.com/elm/compiler/commits/master You can see he s actively working on it even just last week. That should gives you some peace of mind.
I started a different approach, mainly because i didn't want to create a lot of types that then get used only in one function. So instead i would write something like ``` bookFlight {to="Name", isPremium=True} ```
yeay! A meetup near me. Sadly I can't come this month. Hopefully next month will suit me better. I would love to give a small presentation about my [game engine](https://package.elm-lang.org/packages/Orasund/pixelengine/latest/).
Nice! Would love to see it :) Just subscribe to the meetup and you will get notified about the place and date of the next one.
Am I crazy in thinking keeping dependencies current is a non-issue or even an anti pattern? I've suffered negative consequences from upgrading which are due to even the best of maintainers finding it hard to avoid introducing breaking changes. The consequence of not updating is that you're open to security issues not being patched or bug fixes not getting applied. In the former situation I find it's not enough to upgrade dependencies on a frequent basis in order to avoid unrecognized security issues, rather I need to do understand what the issue is and shepherd the security upgrade manually to make sure it's applied correctly. I do this simply by reading blogs, twitter feeds, and forum posts on a frequent basis to make sure I'm aware of what's the latest with the libraries/frameworks I use. In the latter case I find the introduction of breaking changes to be a bigger hassle than fixing dependency issues as they specifically come up.
It's definitely a very different experience between NPM and elm dependencies. I can understand the fear of introducing breaking changes by updating (even minor or patch release) NPM dependencies. &amp;#x200B; With elm, since you can't have different versions of dependencies, you tend to have to keep most packages up to date or else you won't be able to update any of them (if you need a bug fix or new feature, for example). For example, I'm the author of elm-graphql, and that package depends on the elm/http package. When elm/http had a major update (breaking API change), I released a new version with the latest elm/http ASAP. Because if I didn't, users would be locked in to the old package version for all of their other dependencies. &amp;#x200B; I think there's probably a more sophisticated way to manage dependencies in the elm ecosystem that could avoid some of these issues (for example, specific functions could be versioned). But that would take time to take shape. For now, I often find myself avoiding dependencies altogether when possible. For example, I will copy-paste functions from the elm-community/\*-extra packages (like list-extra) because it can create this sort of dependency gridlock, just for the use of one small helper function. &amp;#x200B; But other than that, I find that with the help of a good suite of unit and end-to-end tests, it's been a great experience to just always use the latest elm dependencies whenever possible. NPM dependencies are scarier to update because you don't get the same guarantees that API changes are non-breaking with minor and patch releases. But even so, I like having a tool that helps me keep track of what is outdated, and that gives me the changelog and diffs in one place, and tells me whether updating breaks my build. It makes it more manageable even to have that information, and I tend to like updating dependencies relatively frequently to avoid updating a ton of dependencies up several versions all at once.
Wow, this looks really cool. Why have I not known about this? I follow everything that happens in the #gamedev channel on the elm slack. If you are not yet on this channel, I urge you to join ;)
I'm not active on slack, I didn't know at the time if #gamedev was still used. But if you say so, I should probably start using it more.
The channel is pretty active. I'm mostly a passive reader only, but it's great to know what's happening in the elm gamedev niche.
I see this approach used in JavaScript quite a lot. I think both approaches make sense, I like this method because of how easy records are to create in Elm.
If you have a twitter account, try making a tweet asking this with #elmlang or @elmlang in it. That will probably get some retweets from Elm folks and probably reach a wider audience!
something beyond yearly blog posts would be nice. I would help a lot when trying to convince people to board the ship (and also reduce the usage of "me" and "I did" in these posts, it make the language look like a personal project)
Your comment would make a great addition to the post. I remember that Joe Armstrong also talked about something like versioned functions at one point, and it was a very interesting idea that stuck with me. A lot of stuff that we do is so arbitrary and shaped by nothing other than historical reasons.
I can always recreate the issue when I Throttle for slower internet speed.
In the onclick update message, set the image src to "". The new one gets loaded once the update function updates the model which happens after your xhr request. So the old one will stay until the new one loads fully.
I've definitely seen behavior that matches this, but never figured out why. Problem goes away if the new image is in the cache, which made it virtually impossible to debug, considering how strange the behavior is.
You most likely need to [add "keyeds"](https://guide.elm-lang.org/optimization/keyed.html) to your image elements.
If your images are in a list then this is likely because the vdom isn't correctly guessing which nodes to reuse. Take a look at [https://package.elm-lang.org/packages/elm/html/latest/Html-Keyed#node](https://package.elm-lang.org/packages/elm/html/latest/Html-Keyed#node) which allows you to give a unique key to each item in the list so that the vdom is able to correctly determine when children have been added and removed.
I haven't played with it myself yet, but just out of curiosity how does the vdom react when all of your list items have like unique id attributes already? Can it still have problems, or is that a legit alternative to Html.Keyed?
Hi there. &gt; I instead created a FormState type alias containing each of the states of the form, and went down to one UpdateForm FormState message to update it in Main.elm. That was definitely the right step. Looking at your Model definition, this was looks very clean. &gt; I moved the form rendering function into another file. Let's say it has the following signature (I'm omitting two other params because they'll only confuse the issue right now) Here I would suggest a naming convention: create two new folders: `Data` and `View`. Put the definition and all helper functions into Data.LifterForm and the rendering functions into View.LifterForm. Next rename the `lifterForm` function into `view`. And rename `stringToFloatField` to `fromFloat`. &gt; maybe you need to know what a FloatField is? Sorry about that. They're defined in here and the relevant part is copied below. Your `FloatField` seems unnessary. What is the reason why you modeled it that way? &gt; Taking inspiration from lenses in Ramda, I could see rewriting it with a magical function that takes a field access function, a record, and a value and returns a new record of the same type with the value updated at that field Sadly this will not work. How about `stringToFloatField &gt;&gt; (\newAge -&gt; { state | age = newAge }) &gt;&gt; updateMsg`?
This got me thinking; We should start a "Elm Cookbook" GitBook where we collect interesting problems from /r/elm, discourse and slack and the solutions as well as additional resources like useful packages and videos. This could be also used to quickly answer repetitive questions and serve as a record for "good practices".
&gt;Hi there. Hi!! Thanks so much for this very detailed reply and for reading my code! I know reading other people's code can be annoying and I'm sure you have enough of it in your day job so seriously thank you immensely. &gt; create two new folders: `Data` and `View`… So this idea sounds healthy and cool to me and I'm certainly going to try it and see if I like the look, but I thought I read somewhere that what we might think of as code smells in JS (long files, view next to model) are ok in Elm. But now reading the [No Red Ink style guide](https://github.com/NoRedInk/elm-style-guide/blob/master/README.md) I see that this splitting and all the naming conventions you mentioned are described in there, so for sure! &gt; Your FloatField seems unnecessary. What is the reason why you modelled it that way? So I was thinking of it as a way handle controlling the input value while also knowing the `Maybe Float` of the input all the time, but now that I think about it I can just store that value as a `String` all the time and only convert it to a `Maybe Float` when converting it to a `Maybe Feat` &gt; How about ``` stringToFloatField &gt;&gt; (\newAge -&gt; { state | age = newAge }) &gt;&gt; updateMsg ``` That's the one right there! Lovely! Except now I won't have to do `stringToFloatField` at all so it'll be even shorter. Thank you again!!
&gt; I thought I read somewhere that what we might think of as code smells in JS (long files, view next to model) are ok in Elm. That's right, they are perfectly okay. Its only as your project grows that you need to start splitting the file. My own rule of thumb is to start refactoring if a file has more than 600 lines of code. &gt; But now reading the No Red Ink style guide I see that this splitting and all the naming conventions you mentioned are described in there, so for sure! I didn't know about that, this style guide looks great. I fully stand behind what they say about refactoring: * If a module has a looong list of imports, consider refactoring * If a function can be pulled outside of a let binding, then do it * If your application has too many constructors for your Msg type, consider refactoring &gt; I was thinking of it as a way handle controlling the input value while also knowing the Maybe Float of the input all the time, but now that I think about it I can just store that value as a String all the time and only convert it to a Maybe Float when converting it to a Maybe Feat Exactly! Have you already heard of "Making impossible states impossible"? If not, i recommand checking out (the talk)[https://www.youtube.com/watch?v=IcgmSRJHu_8] by Richard Fieldman. &gt; Except now I won't have to do stringToFloatField at all so it'll be even shorter. It might be that now my solution is an overkill. Personally I don't see any problem with ``` Input.onInput &lt;| \newAge -&gt; updateMsg { state | age = newAge } ``` (I just noticed that you can actually replace the brackets with a `&lt;|` pipe ;)
I'm not 100% but I've never heard it mentioned that the id attribute is given special consideration by the vdom.
Even if it's not given *special* consideration, it ought to help weigh in on the diffs or something right? "This part of the content is the same between node A and B" should help it determine that A ought to be shifted to B instead of destroyed and recreated, right?
I am thinking of purchasing Elm In Action by Richard Feldman. Can someone confirm that it has been updated for Elm 0.19? I looked on Manning, but could not find that information. Thank you.
I took a look at the book preview and the examples are `0.19`. The book is a work in progress so some parts of it might not have been updated. The final book will most likely be updated to whatever version of elm will be available when it will be published.
&gt;If your application has too many constructors for your Msg type, consider refactoring This is, I think, the main consideration that motivated this for me. I took all of your advice, even expanding it to do the same with `UnitDropdown` inside of `LiftForm.State`. I really like that I can have both ``` import Data.LiftForm as LiftForm import View.LiftForm as LiftForm ``` in Main and then call all the same functions with the same names as `Browser.element` gets: `view`, `init` and `subscriptions`
Thank you. It is helpful to know that the examples are 0.19, and that it will be likley updated to most recent version of Elm when it becomes available. I think I am going to buy it.
Be careful! If a function `foo` is in both Modules, you need to write `Data.LiftForm.foo` or `View.LiftForm.foo` instead. 😉
Very cool
Everybody knows that composition is cooler than inheritance, so my model is a record whose fields are generally other records. That means I often want to write something like: { model | somefield = { model.somefield | otherfield = model.somefield.otherfield + 1 } } Unfortunately that fails - it seems that Elm only accepts a variable name in the record-update syntax, not an expression, so I have to say something like: let old_somefield = model.somefield new_somefield = { old_somefield | otherfield = old_somefield.otherfield + 1} in { model | somefield = new_somefield } ...which is a bit clunky. Of course, Elm uses structural typing for records, not nominal typing, so maybe the lesson I should learn here is "avoid nesting records". Accordingly, it'd be really nice if there were some way to make a type alias for "a record whose fields are the union of the fields of record types X and Y", maybe something like: type alias Point3D = Point2D + { z: Float } Is there some Elm idiom I'm missing, or are such features in the same pile as "typeclasses" and "operator overloading"?
I've been waiting for this!
Nice! I hope I can make this work with emacs since the elm mode doesn't do a great job of things like auto complete.
Its called a extendable record: ``` type alias WithZ a = {a| z: Float } type alias Point3D = WithZ Point2D ``` That said. I am wildly guessing that you might not want to use that. It makes things more complicated than they might be. The are a few things you might want to look at. 1. Pattern matching for records: `({somefield} as model)` 2. Create new types alias for your sub records and write functions to operate on them. Here a [small example](https://orasund.gitbook.io/elm-cookbook/frequently-asked-questions-1/how-to-update-nested-records). 3. You can take that to an extrem and define a opaque type, that is a type in its own file that does not expose its constructors. But better one step at a time ;)
Has anyone gotten vim Ale's error checking and completion to work?
Isn't working. Will be need to change the executable path I think. Tomorrow I will send a request for this
&gt; Debugging looks awful and is largely unhelpful No, I don't agree with that. Elm is a 100% pure functional language and has a kickass debugger that shows what's in the model at all time so it's super easy to debug from the repl. It's super easy to debug the bit that's not giving the right values while ignoring the rest. &gt; You cannot install Elm packages from anywhere other than the official package repository. It's indeed a pain point. &gt; Most of the tutorials / examples online are out of date due to v0.19 I didn't find the move to 0.19 very jarring. &gt; The docs are incomplete Never had an issue with that.
&gt; You cannot install Elm packages from anywhere other than the official package repository. That's a _feature_.
We're not talking about Kernel being off limit but about private repositories.
Right, I know. For my part, and from where I'm sitting: "it's in the main package repository or you can't share it at all" is a feature. Short-term, it can be frustrating; long-term, everybody always has access to the same packages, from the same places. I understand why some people may disagree with this, but I for one welcome the core team's insistence on doing things in a very particular way.
It also means it's hard to write proprietary code in Elm.
I'd say it's harder to keep proprietary libraries (or any code that's not in the main repository) up to date.
I'd say the walled garden point is the main point here. But is it strictly a reason why Elm isn't ready yet?
&gt; I didn't find the move to 0.19 very jarring. This seems like a carefully-worded statement given that you must know the 0.19 move *was* painful for a lot of people.
The linked post is about the learners. They don't have tons of code to port and they certainly didn't use kernel code yet.
&gt; But Elm isn’t all roses. It seems great on paper but I’ve found developing a real, production system with it has issues. Here are the biggest pain points from my brief time with Elm to date: It's kind of fun to think of the counterfactual where Elm came before javascript: But javascript isn’t all roses. It seems great on paper but I’ve found developing a real, production system with it has issues. Here are the biggest pain points from my brief time with javascript to date: * No inherent type checking. Sure you can try to use flux or typescript, but there's no guarantee the third party libraries you want to use support them which will mean you'll have holes in your type system. This has led to emergency runtime errors that have driven us off course during hours, killing productivity. * Language semantics differ wildly between code bases depending on whether ES6 or experimental features have been enabled in any particular project. Remembering which projects support which features can be a real pain. * Setting up a build system to support JSX/ES6 syntax has gotten easier but still requires numerous packages and configuration files. * The language has no way of guaranteeing that functions are side effects free. Did you modify that object or copy it? Are you sure? If not, you might end up causing a bug on the other side of the code base. * Package bloat. My node_modules directory is currently almost 500MB and the vast majority of those are indirect dependencies. This makes development in places without good internet connections much tougher and less accessible to less developed places. Coming to the conclusion that javascript is better for the reasons listed in the article is an example of status quo bias imo. That's not to say the concerns aren't valid, and in fact the debugging state of affairs is even worse than mentioned because it has been broken for me since 0.19 with the Map.! error, but Elm overall is still way better for many types of projects imo.
It just means people have to use git submodules. Are there languages where private repositories are a big problem for the community at large?
I learned Elm to escape all of these things about Javascript. I could not agree with your post more.
Perfect use of the counterfactual nice job
&gt; Elm is a 100% pure functional language and has a kickass debugger that shows what's in the model at all time so it's super easy to debug from the repl. It's super easy to debug the bit that's not giving the right values while ignoring the rest. The article does mention it: &gt; There is an Elm debugger (imagine Redux devtools) but that doesn’t work for our app so we can’t use it — using certain message types (think of Redux actions if you’re from React-land) cause the debugger to throw up.
&gt; That's not to say the concerns aren't valid, and in fact the debugging state of affairs is even worse than mentioned because it has been broken for me since 0.19 with the Map.! error, but Elm overall is still way better for many types of projects imo. A broken debugger is a complete deal breaker for a lot of reasonable people.
Be a conservative about programming languages. - Programming is hard no matter what. - No language makes it significantly easier across the board. - The benefits of one language over another are typically marginal, and when those benefits are significant they almost always are balanced in large part by costs of similar magnitude. - Be very skeptical whenever you hear a value judgement like that one language (or one practice, etc.) is "good", "bad", "better", "worse", etc. Ask what these words mean. Often they stand in for a phrase like "aesthetically pleasing" rather than "empirically proven to reduce bugs/development time/etc." - If the claim *is* that &lt;Thing X&gt; is "reduces bugs/development time/etc", then see that evidence for yourself. (It almost never exists!) - Often what *does* make one language easier to use, faster, etc. isn't the language itself. It's factors like "this aesthetically-lousy language is insanely popular and can I find answers for any problems I ever have, while my perfectly-designed language derived from my deep love of category theory has like 6 companies using it in production". Concerns like this are *not* "status quo bias".
Server side rendering, is that like static html generation: [https://korban.net/posts/elm/2019-04-16-elmstatic-upgraded-elm-019/](https://korban.net/posts/elm/2019-04-16-elmstatic-upgraded-elm-019/) I'm doing local storage in my code, with ports. Its not hard, but might be worth an example if there isn't one on github already. Re websockets I'd like to see some example code for that, its a blocker for one of my projects.
I mostly agree. Its still changing too fast and features do get removed without deprecation (which is fine since its still at 0.x)
I don't see how the conclusion ("I don’t think it is currently the fastest or safest option") follows from the post. A bit unfortunate that he makes unsupported claims. For those who are interested in SSR, you might want to check out https://github.com/rogeriochaves/spades For internal packages, there is https://github.com/Skinney/elm-git-install The other issues are well known and have been hashed out multiple times here on r/elm and elsewhere, I think.
Have you seen https://github.com/Skinney/elm-git-install for installing internal packages? The doc issue is something in the Elm guide. I wrote a post about it: https://korban.net/posts/elm/2018-10-12-elm-guide-missing-part-url-handling-browser.application/
There are always going to be cases where people choose a different path, and that's good! But I think that a lot of the resistance to change ignores the state of affairs in javascript world that everyone has been acclimated to the oddities and pain points over many years whereas Elm, like many things that are new, is being held to different standard which is that it must exceed javascript in every way otherwise it's not "production ready." The debugger issue has been a minor issue for me since you can get a poor man's version by using `Debug.log` with the Msg in your update function.
&gt; If the claim is that &lt;Thing X&gt; is "reduces bugs/development time/etc", then see that evidence for yourself. (It almost never exists!) I agree these ideas should be interrogated and tested as much as possible but the reality is that designing and conducting studies rarely happens because it's rarely economical and other studies may not even be applicable to the exact circumstances of the project that you're working on. This leaves you with two options: either blindly stick with the status quo or make a judgement call based on experimentation and the opinions of experienced developers. I have seen a development team sink endless amounts of resources into an established language that was a bad fit for the project because that's what they've always done and they're too risk averse to try something new. In contrast, I'm also working at a company where we've experimented with Haskell, Go, Elm, Ruby, Javascript and use the one that's a best fit for the project. This experimentation has made me a better developer and allowed me to have more tools in my toolset when I approach a problem. Some require more safety, some require a wide ecosystem of libraries, others require the ability to prototype quickly. My advice is to experiment often with programming languages and trust your experience to determine what's best for your project. Just because everyone is using some existing popular language doesn't mean it's the right solution, it's often just a function of how long it's existed and what the competition was when it became popular.
I agree with many of the cons the author raises, but would not give them all the same weight the author gives them. In my mind the pros outweigh the cons (by far, even). But, yeah, it's not perfect. We Elm developers have mostly learned to live with the small hiccups - there definitely is some Stockholm syndrome going on. But, again. It's much better than living in the JS world - I get assured of that everytime I have to fix something in our legacy JS codebase.
Yeah, I wonder why it's taking so long to have a fix for the Map.! problems....
Glad to see somebody read my post :) SSR has largely the same implementation but isn't the same as static HTML generation. With SSR, the goal is to produce dynamic, JavaScript-driven pages which happen to be pre-populated with content (so that various crawlers can get the text out). With static HTML, the goal is to run Elm code once to generate the view, and then serve that view as an HTML page. For Elm SSR, you should look at https://github.com/rogeriochaves/spades. The approach is to compile Elm, then execute the resulting JS with `jsdom`. I used the same approach in Elmstatic.
That's an unusual concern :) The compiler goes 1-2 years between releases, most people complain that it's too slow. My view on things like no deprecation is that Elm is an interesting experiment in software development. Consider the bigger picture: supporting deprecation has a large cost for the compiler developers, and potentially even for users. Maybe the overall cost of requiring code upgrades if you want a new compiler has a lower total cost?
I would add that integration tests are impossible (no way to check if endpoints are correct with a test in Elm) without running something like cypress and that it's very very cumbersome to do animations. In fact I've never seen an Elm app that is heavy with animations and tests.
&gt; Coming to the conclusion that javascript is better for the reasons listed in the article is an example of status quo bias imo. But the article didn't come to that conclusion. It compared Elm-the-framework to React, Vue, and Angular, not Elm-the-language to JavaScript. All of these frameworks (or libraries as the case may be) have bindings in different AltJS languages. In fact Angular's TypeScript version is the canonical one.
&gt; But the article didn't come to that conclusion. It's titled "Elm and why it’s not quite ready yet." This suggests JS with or without the ecosystem is ready which would imply that it is better. The point I'm making is that if Elm had preceded JS I think that JS would be dismissed for all the faults that I listed. This post is holding elm to the standard that none of its massive advantages count towards production readiness but some of the minor disadvantages do. To me this is a textbook example of status quo bias. &gt; It compared Elm-the-framework to React, Vue, and Angular, not Elm-the-language to JavaScript. Partially, it's also talking about runtime errors, package management, debugging, etc.... The argument in the article is about production-readiness and all my arguments are countering the idea that Elm isn't production ready and JS is. &gt; All of these frameworks (or libraries as the case may be) have bindings in different AltJS languages. In fact Angular's TypeScript version is the canonical one. That's great but most projects have other dependencies beyond that such as utility libraries, time handling, charting, etc... All of which you have to check to make sure support the type system you're using if you want all your code to be covered. In elm you get that for free and never have to check.
iPhones are the king of walled gardens and I don't think anyone would say they aren't ready.
Elm is not ready yet because of compiler complaining about tabs that aren't there. Also, the formatting sucks.
As someone who was interested (and invested) in Elm in the past I can only agree with that post. In my opinion: the good parts didn't change over the years (they are what pulls people in), and sadly the bad parts didn't change either - as I remember 0.16 had the same exact problems then what 0.19 has now (small Web API coverage, closed development, closed package management, much boilerplate) - only the APIs and internal things changed. (shameless plug) That's why I created [Mint](https://www.mint-lang.com): to get the same parts from Elm which are good and do things differently for the bad. If you are interested I have a [series going over on dev.to](https://dev.to/gdotdesign/getting-started-with-mint-3k2o) which details the language and there is the [guide](https://guide.mint-lang.com) as well.
Personally, I'm using elm for a bit over a year now and i completely love it. My own metric of "goodness" is "how long does it take for me to get an idea to a working program/game." I used Php, Java/Processing, C++, Angular, Node.js, Vue. The fastest it took me for a prototype was about 2 hours with Vue.js. But then I straggled to maintain it, taking over 2 Months until my game was done (mainly because of debugging). With Elm, it takes about 8 hours for a prototype and then about 8 hours to finish it and I love it. Previously I always hit a point where refactoring was nearly impossible and maintaining a nightmare. A lot of games are left in a zombie-like "do not touch" state with no possibility for them to be ever done. Meanwhile, in Elm, after my first game I noticed that I could extract the underlying engine into its [own project](https://package.elm-lang.org/packages/Orasund/pixelengine/latest/) and now I'm just finishing one game after another. AND I'm returning to my games, trying to keep them up to date with new changes in my engine. I don't know any more how I could even write games in angular, php or even c++. *shiver* But I do know that elm is definitely "ready" for the things that I need it for.
Yes, you make a great point about JavaScript. But the article is not really about JavaScript 🙂 &gt; All of which you have to check to make sure support the type system you’re using Yeah you do, but firstly a lot of them have bindings and secondly if they don’t you can write the bindings yourself. Anyway this whole topic doesn’t need to be rehashed, we all know that Elm and other AltJS languages approach interop differently and what the tradeoffs are.
Nice post (:
Thanks :)
Completely agree.
&gt;Coming to the conclusion that javascript is better for the reasons listed in the article is an example of status quo bias imo. &amp;#x200B; I wonder where you read this? There's nothing like that in the article.
Sure. And there is a huge corporation behind it, fixing bugs and releasing hotfixes. Oh, and they release XCode updates quite often :-)
Your post reflects my own notes for the project I'm starting right now, and I came to the same conclusions: after 2 years I'm giving up on Elm for the time being, won't use it for the current project.
Compares using Elm with using React/Vue which both require you to use Javascript: &gt; A major point that cannot be overstated — using tried and tested front end systems like React or Vue mean you get access to an extremely large library of high quality packages, tools and community support. Specifically mentions JS: &gt; You can use Elm. It’ll work for the most part and it might avoid some of the headaches you may get with other front-end solutions, but you’ll be giving up a smorgasbord of fantastic open-source ready-to-use packages, key features like Server Side Rendering (yes I know GoogleBot now parses JS), thousands of tutorials, a large, thriving, passionate community, and complete and robust documentation. Yes, you may have to write some tests (but you should really be writing business logic tests anyway!). Says Elm is not the fastest or safest option, and that’s what matters most: &gt; I love playing with new languages and paradigms, Elm’s been quite interesting to get to know — but contrary to the promises, I don’t think it is currently the fastest or safest option, and sometimes that’s what matters most. Did you read the article?
I have the MEAP for Elm in Action. I also suggest Fairbank, Programming Elm, from Pragmatic Programmers. It’s excellent, comprehensive, and updated for 0.19 as well.
&gt;The docs are incomplete When I found the *TODO* tag instead of the parser example it was really a bad surprise. It gave me a bad impression about Elm. Fortunately there are several PRs to fix that (such as [this one from 8 months ago](https://github.com/evancz/guide.elm-lang.org/pull/156)) and I'm wondering why one of them is not merged yet. Now it backfires on Medium…
It's harder to experiment with libraries that might not be ready for prime time yet. Or to patch bugs with libraries and check if a dependent project works with a new version of the library, and the patch fixes the problem.
This is great.
My only real agreement is that having the community in Slack makes everything that goes on completely invisible from the outside. I do think it is ready in the sense that it solves a tremendous number of issues with JavaScript and has been very stable for me in production and easy to upgrade, whereas any of the garbage mile-a-minute frameworks I installed from npm have just been pure technical debt after release.
Honestly, I don't see where the author says that javascript is better than Elm. The comparison is fair. The whole point is that Elm is not production-ready yet: who says JS is better? All the parts you quoted apply to Javascript as well as to Typescript.
The article is explicitly comparing JS to elm. Just because he doesn’t say the words “javascript is better” doesn’t mean that’s not what the article is about. &gt; The whole point is that Elm is not production-ready yet: who says JS is better? So you’re arguing that the author’s intent was that JS is not better than a non production-ready language and therefore we should either stop developing web apps for production or use some unmentioned language like PureScript or something.
&gt;More compiler bugs in 0.19 than any other version. And we waited &gt;2 years for it.
I think that the author's intent is only to reflect on Elm based on the way it is evolving. Nothing more. I don't know one single FE developer who will tell you that JS is better than any of the available alternatives, but an impressive amount of the developers I know feel more comfortable with a language which can be hacked if needed, and frameworks/libraries with a regular release schedule and roadmaps open to the community's suggestions. That's it.
Cool! 😎
Iphones are a completely different history than Elm.
Really promising project. But, please, please, don't use React. Use something really "stellar", in speed, simplicity and much more, like SvelteJS 3.0. You will not regret it to make that change.
&gt; I think that the author’s intent is only to reflect on Elm based on the way it is evolving. Nothing more Then either you didn’t read the article or are refusing to concede your original incorrect point. I specifically cited three paragraphs saying the things that you’re claiming are not there. &gt; I don’t know one single FE developer who will tell you that JS is better than any of the available alternatives, but an impressive amount of the developers I know feel more comfortable with a language which can be hacked if needed, and frameworks/libraries with a regular release schedule and roadmaps open to the community’s suggestions. That’s it. Non sequitur.
I'm aware of Svelte but I'm afraid the underlying principle is incompatible with Mint, the main issue is that Mint is built to use Virtual DOM and Svelte uses compiled templates which you can update with data. In theory React can be replaced with either [Inferno](https://github.com/infernojs/inferno) or [Preact](https://preactjs.com) (or any compatible API) but they are not 100% compatible yet.
Maybe, if Mint take similar approach like Svelte (maybe getting compatible with it), abandoning the Virtual DOM, the language will shine beyond the React family (virtual dom frameworks) limits. The API of Mint is a pleasure to read. Excellent work, astetically!!!!
&gt;Maybe, if Mint take similar approach like Svelte (maybe getting compatible with it), abandoning the Virtual DOM, the language will shine beyond the React family (virtual dom frameworks) limits. There are trade-offs for both approach (and now thinking about it I might write a post about them), but the bottom line is that the ideal would be somewhere in between. Probably I'll try to come up with something in the future though, but for now I think it's more important to spread the word and get to a stable version within a reasonable time-frame. &gt;The API of Mint is a pleasure to read. Excellent work, astetically!!!! Thank you, it's great to hear :)
You can find a tutorial about Elmo [here](https://boby.dev/posts/fp-for-the-ui-part-1/) . It's about creating an indie card deck game with Rick and Morty. Have fun!
Some benchmarks would go well with claims of a 1000x speed-up.
It's just 100x :P The title is provocative on purpose. The point is just that it has a much much lower time complexity compared to the naive approach. It's polynomial Vs logarithmic complexity. The example in the readme shows what this would mean when you have a big dictionary to match. 128 times less computation in the worst case, which could translate into 100x speedup. But it's not always 100x faster, it depends on the length of the matching and the size of the Dict.
The Elm Slack should be replaced with something that has persistent records that can show up in google search results. A lot of time is spent in those channels answering questions and it's all lost very quickly but it could really come in handy for newcomers and others. I didn't even know it existed until long after I started using Elm but that information can be so valuable that I'd even be willing to use IRC.
Slack is fine for casual discussion, but I think technical questions should be directed to Stack Overflow, or something similar
I think both are necessary. There will always be questions on Slack because they can get quicker responses. Also there are channels that are specifically dedicated to specific areas like #visualization which has people who can answer those types of questions. It’s less likely that people with deep knowledge of those specific domains will see your question on Stack Overflow.
I'm just not a fan of using a proprietary tool for open source development. I don't have a slack account so that door is just shut to me.
Sure, what I mean is that maybe the initial question comes in the slack channel but both the question should then be moved to SO and answered there. That way the user gets a quick response and every other developer in the world get to find the answer by searching.
Watch ["The Hard Parts of Open Source" by Evan Czaplicki](https://www.youtube.com/watch?v=o_4EX4dPppA) and read https://discourse.elm-lang.org/t/what-is-constructive-input/977 for more context. IMO all these kind of posts do is distract Evan and the core team even more from working on the compiler and core libraries. He's working hard on some really cool compiler optimizations for 0.19.1 and I can't wait for it. Yes, that means pull requests will take time to respond to. No, it's not necessarily bad.
Is there a roadmap showing time line to a 1.0 release? Until then, given the tight central control over the language, aren’t any talks of Elm being ready for production a bit silly? The guy releasing the language doesn’t think it is ready.
I don't know what criteria you consider adequate for being classified as production ready, but a ton of companies are using the language in production: https://github.com/jah2488/elm-companies
That would be very inefficient and most people won’t copy and paste their conversations into SO. Also not every question would fit into the SO model. Some of them are back and fourths about how to debug an issue or which library is best for a particular problem. It’s much better to just post that online automatically and have it be searchable.
Apart from the documentation section, this article seems to be entirely about things that people outside of the core team can do. So it's not clear to me why you're worried about it distracting them.
What 0.19.1 will bring?? No comunication at all.
I don't call this "a ton of companies".
How about a slack bot that dumps all the messages into a searchable archive? I guess that would probably violate a TOS.
Kind of agree, but it was more than I expected.
It could also turn into a 100x slowdown because the dictionary is expensive to build. Add some benchmarks that show at which point the lower complexity kicks in and you'll be much more likely to find people willing to use this than with vacuous provocative claims.
Could not agree more! I think slack is terrible for questions and answers. I really hope people move to using Elm Discourse instead of slack.
What's this have to do with Evan and the core team? This seems more like: we could open something like https://elixirforum.com/ except for elm. You know, an idea to improve the community. Are you worried Evan will be so distracted by this it'll keep him from work?
Not my criteria, the language developers not releasing 1.0 speaks for itself imo.
Feedback I have from industrial use (including personal use) is that debug blows up for any app having significant model size. I still use it sometimes, but I'm forced to use it for subsets of the app, or mocking with minute amounts of data. I also would like to have a better interface when it comes to looking at message content.
&gt;He's working hard on some really cool compiler optimizations for 0.19.1 This is great! &amp;#x200B; You know what is also great? To have a hint of what "really cool compiler optimizations" are...
Wait sitting on a chair so you do not get tired.
This is fantastic and is extremely valuable for providing a great Elm development experience. Massive thanks to all those involved!
Anyone who wants to know how the involvement of FS/OSS projects with Slack will turn out, should just look at the involvement of the Linux kernel project with BitKeeper back in 2005.
Using Slack or any other chat system as a knowledge database is so wrong and got way too common. If the community relies on slack as knowledge base or long term FAQ or documenration, that is the real bad smell - not slack's free tier. Somebody just startet a wikibook with common questions. That would be one way to persist recurring topics from the elm slack. Now we only need to convince the slack community to use it.
Linus Torvalds is going to write an awesome chat application that becomes the industry standard?
I can't wait. It will be obviously called `spit`, the Stupid Publishing system for IT.
...I need this
I personally like the IRC option suggested in this post. It's a proven and mature communication system that many other communities rely on. &amp;#x200B; I love Slack for companies but running and OSS community on Slack's free tier just doesn't make a ton of sense to me.
Hi there, I am using ports sort of understanding them but I never have the feelings to fully understand them and always go back to the wiki book. Maybe I need some other explaination to finally have the "oh right" effect to understand the difference and usage between in and out ports.
Could I suggest implementing a thumbs-up type system for voting on a package's quality? It still suffers from the same problems as gauging package quality by GitHub stars, but perhaps it's something to think about.
Is it the computer being slow to load? I am doing something image heavy in js rn &amp; I have to preload the images using new Image () before showing them on the page so they appear in the dom instantly
How do you test yesod serving an elm frontend on your machine? E.g elm requesting a resource or being served some JSON.
If you mean testing the Elm frontend, we used puppeteer (wrapper around headless chrome) to do integration testing.
What a great talk! Thanks for sharing. I only just realized that most of the Elm in the Spring talks got uploaded last week, so this has sent me down an wonderful rabbit hole.
As a matter of fact, in one of his latest talks, Richard Feldman lists that as a major upside to NoRedInk's elm adoption.
I mean more how to serve an elm js file with yesod
You missed a really great chance to call it `vimulation`.
I think the Elm ecosystem is surprisingly good, and it's not really the community that is holding Elm back. It's mentioned often, but the lack of communication from the core "team" creates a lot of unnecessary uncertainty. A lot can be learned from the Rust community in how they communicate and interact with the community. One small thing that I personally wish for, is more point releases, instead of always going big-bang with a few years in-between. Heck, it's now more than a year since the last compiler update ([https://github.com/elm/compiler/releases](https://github.com/elm/compiler/releases)). There's 388 commits since then, and I'm sure we could have been at 0.19.12 by now, if we wanted to. This is not to start any more discussions on this point, but it's honestly a thing holding me back from introducing Elm to my team. I'm wavering between Elm and PureScript (which is not as smooth as Elm, but at least feels like I can impact the direction of).
What? The core team can ignore this post if they want. People in a community shouldn't discuss ideas? Not all ideas would need the core team. Anyone can set up an IRC channel right?
I can't find the link right now but Evan said he doesn't want anyone to talk publicly about upcoming features until the release post is out so that there's no miscommunication.
The core team has been promoting Elm as production ready for years now: https://www.youtube.com/watch?v=FV0DXNB94NE
Trying to upgrade to 0.19.0 but it’s not working need help I’ve tried to do the npm and .exe route and both still give me a 0.18.0 when I check the version
I highly recommend [this talk](https://youtu.be/P3pL85n9_5s) on ports by Murphy Randle. It clicked for me, though, after listening to Murphy expound on his talk on [Elm Town #33](https://elmtown.simplecast.fm/ports-again-murphy-randle).
`npm uninstall -g elm &amp;&amp; mom install -g elm`?
No difference, 0.18.0 still showing
Oof. I just recently backed up all my data and reinstalled my whole system because I broke npm beyond recognition trying to fix a similar problem. Not saying to do that. Just saying that npm is shit so don't feel bad. Try `npm uninstall -g elm` and `which elm` and see what you get. If there's a path, delete that elm binary, then try to `npm install -g elm` again. I'm no expert but this might work and can't hurt.
Would deleting my current elm projects help? They are just the guides/tutorials on elm-Lang.org
Not at all likely. That should have no bearing on the problem.
They really should bring their project management inline with their apparent views on the project. Nothing screams “we might decide to fuck this whole thing up at any time” like trying to pass 0.x releases as production ready.
My biggest issue with the elm docs is the fact I never understood what update: Msg -&gt;Model-&gt;Model update msg model = Etc. The top type initialization confused the hell out of me until I saw some videos Working with elm and I realised what that all meant. It took me forever to realise you are telling the function or variable what type it is or arguments it takes in, then defining it.
just download elm directly from the github releases tab. Npm is just awful all around
I know i first downloaded the .exe file then did npm uninstall elm. It some how worked. Before that I was doing uninstall then install which Was going up a version then down. Felt so dumb afterwards lol.
I started [https://github.com/Razzeee/tree-sitter-elm](https://github.com/Razzeee/tree-sitter-elm) and [https://github.com/elm-tooling/elm-language-server](https://github.com/elm-tooling/elm-language-server) for similar reasons. At the moment it feels like we should either rework or spend some time on improving elm-analyse, elm-test and elm-format. &amp;#x200B; The other things I can think of is a new debugger, where this [https://github.com/opvasger/elm-devtools](https://github.com/opvasger/elm-devtools) is already pretty promising. Or a improved version of the [https://package.elm-lang.org/](https://package.elm-lang.org/) frontend, acting on the same backend data, but trying to improve it. Should be hosted and useable. And if the used ideas get traction might be something that could influence the official frontend.
I'm currently working on a library for dealing with bits (https://github.com/zimmydev/bitstring). It seemed to be missing from the ecosystem, so I decided to rear it. You’re more than welcome to submit PRs, and it would actually help me get more familiar with github.
It might be interesting to check out https://github.com/elm/projects.
There needs to be a wiki, knowledge base, or much more activity on Stack overflow or something. Slack is totally invisible from the outside.
The most important functionality that is missing in Elm is private package registries and packages with JavaScript. I think this two should be tied together. For professional use private registries like you have in [npmjs.com](https://npmjs.com) is a very important feature. Also, this would allow to bring back a feature that has been removed in elm 0.19: the ability to add javascript functions. And it is silly, because now they are super easy to write compared to version 0.18. So, private registries with Kernel module support would bring back all the people that got pushed away or will allow to upgrade people who is stuck on version 0.18 for this same reason. You could check the work done by [https://github.com/CurrySoftware/compiler](https://github.com/CurrySoftware/compiler). They also extend the compiler to add removed functionalities from elm-reactor with the last release.
With javascript we lose most of the compiler optimizations and code guarantees that the app won't crash in runtime. Soon we will have everything implemented in pure elm, so going back to allowing js is obviously a waste of time. But I agree we miss private packages.
"Soon", as within five years. I don't think that we will "soon" become independent of js.
This was hands-down my favorite talk at Elm in the Spring! All the talks were great, but the benefits addressed in this one are practical and immediately applicable to your code. And Noah is quite the personality, too, I really enjoyed him.
I am talking about professional use. It makes no sense to have a team of very good developers and not being able to extend the Elm functionality in no other way than to forking the compiler and splitting the community. It is like saying that the only good developers in the world are the Elm development team. I have been working with JavaScript development for 19 years. I can cope the risk that my project, with my own private packages, breaks because of my faulty code. I really like the idea behind not allowing JavaScript on official repositories and I agree with it, but, the same way the Elm team knows how to *properly* write JavaScript, there are many other good JavaScript developers in the world.
&gt;Soon we will have everything implemented in pure elm Pure Elm means using ports for browser APIs that the Elm team did not implement in Kernel code. Then, if the Elm team was strictly focused on ports, there would be no rendering at all done by Elm. Would you be comfortable by using ports for rendering, or do you appreciate the fact that you can simply type \`div \[\] \[\]\` and you get a div?
Implementing your data structures 50 times using code gen sure is readable. They lied to you at your bootcamp if they said the vast majority is being rewritten in Go. Awful and misleading comment.
More detailed [write-up](https://groups.google.com/forum/#!msg/elm-dev/1JW6wknkDIo/H9ZnS71BCAAJ) by Evan on the topic.
I second elm language server. Currently in VS code, only errors within the currently edited file are shown. You need to compile the project to see errors in all files.
Surprisingly, I got from 5 votes to 3 votes. Downvoting comments on reddit should be for irrelevant comments, not for comments that you don't like: [https://www.reddit.com/wiki/voting#wiki\_voting\_on\_comments](https://www.reddit.com/wiki/voting#wiki_voting_on_comments)
Thank you for the link, but I think I have already read most of what that there is on the internet regarding this topic.
Hey, sorry, maybe I should've made it more clear. I linked it mostly for other people to learn about Evan's view on this. I think he wrote a really elaborated explanation there, and it left me completely convinced that it's the right way.
_And my dad can totally beat up your dad._ -/u/dazzford probably
That’s not necessarily the case. Reddit randomizes vote count to confuse spam bots: https://www.reddit.com/r/OutOfTheLoop/comments/21id6d
Thanks! I didn't know that.
Was wondering the same thing. I’ve seen a lot of old PRs that fix a typo in a compiler error message or update the documentation, and I don’t understand why Evan just won’t merge them, considering that he pushes (similarly small) commits every day.
You can try this, for the time being. It can still be improved I guess. [https://marketplace.visualstudio.com/items?itemName=Elmtooling.elm-ls-vscode](https://marketplace.visualstudio.com/items?itemName=Elmtooling.elm-ls-vscode)
`update` is called to process incoming Msg objects. There's a post explaining how you can create a custom Cmd Msg, which will lead to your application receiving a Msg you provided: [https://medium.com/elm-shorts/how-to-turn-a-msg-into-a-cmd-msg-in-elm-5dd095175d84](https://medium.com/elm-shorts/how-to-turn-a-msg-into-a-cmd-msg-in-elm-5dd095175d84) I'm not an Elm pro so I will refrain from further advise - maybe someone more experienced than me can also chime in.
Thank you, I will read through it shortly... Now im dealing with the issue of my Elm.Main.Init() embedded html is not working with css...
The short answer is `update` (along with all the other top level functions, `view`, etc.) is called by the runtime, not by you. Whiting `onclick myMsg` is a declarative way of telling the Elm runtime that when someone clicks this element, myMsg should be fired. The runtime will then send this message to you `update` function, along with your model/state. There is an equivalent to onClick for any kind of browser event you might want to capture. If you want to call `update` at another time, you can use a Cmd (or Task) or it can just call itself recursively. It is called by the runtime which interprets its result, but it is still just an ordinary function after all.
This already exists, https://discourse.elm-lang.org/
Reading the guide, and trying to understand custom variables. In the following page: https://guide.elm-lang.org/error_handling/result.html I see that Result is defined: &gt; type Result error value = ... I thought, maybe defining a custom type we have to list the in the variables we are going to use. But then I get confused. Because in a example a little below in the same page of the guide.: &gt; type Error = BadUrl String | Timeout | NetworkError | BadStatus Int | BadBody String Here after the custom type Error no additional thing is declared. Why we should add error and value? Only because these are type variables?
The variables are for arbitrary types. For examples: ``` type Maybe a = Just a | Nothing ``` if we then use for example `Maybe Int` then the possible values are `Just Int` or Nothing. So the variables `a` may be any type you want. Lets look at the Error definition again: ``` type Error = BadUrl String | Timeout | NetworkError | BadStatus Int | BadBody String ``` we could change things up and say: ``` type Error text = BadUrl text | Timeout | NetworkError | BadStatus Int | BadBody text ``` or ``` type Error status = BadUrl String | Timeout | NetworkError | BadStatus status | BadBody String ``` or even ``` type Error url status body = BadUrl url | Timeout | NetworkError | BadStatus status | BadBody body ``` I hope that was understandable.
&gt; don't DRY yourself oh the irony
Thanks @Orasund I think I get why type variables. &amp;#x200B; What seems strange, and I would like confirmation is the following: in a custom variable definition, seems to me that if we are going to use a type variable, then we have to write it down before the equal sign. Like the error and value in Result type or text variable in the Error custom type you wrote in the third code as an example of a type variable. &amp;#x200B; But if we are going to use normal variables, like String or Int. There is no need to write'em down in the definition before the equal sign. I hope a made myself clear. &amp;#x200B; Is it then needed to write down all the type variables, before the equal sign, when defining a custom variable?
Yes and Yes. The compiler will tell you if you have forgotten to write a missing variable before the equal sign.
Yeah, that wouldn't be very different from GitHub stars, so I'm hesitant to implement anything like that.
Nice blog. You should post on medium too, for better visibility.
Hell yea. Why is it I don't find this cool stuff until I come to a post about Elm not being ready. :/
I'm a student with beginners knowledge of Elm, but I'm gonna email Ari just in case my opinion is relevant! Hope I can be of some use and repay the community, even if it means by doing a simple interview. Keep doing the Lords work Evan! :)
I love your writing and I am really enjoying your book. Your explanations seem to hit the right level of detail to grasp elm's concepts and really understand their benefits. I bought your book after hearing you on elm-town and I am looking forward to more blog posts like your first 3. It really helps me writing ideomatic elm code.
I definitely think supporting private packages would be a big plus. So would being able to compile offline (without github)!
Thanks! I’ve actually been cross posting these to my [Medium](https://medium.com/@elpapapollo), but I like to space it out a couple of days.
Thank you for the feedback! I’m so glad that you’re finding the book and blog posts helpful.
I am a potential newbie here. &amp;#x200B; Everything is on Slack? Free-tier Slack? No history-slack? &amp;#x200B; Project looks dead from outside. There is a bunch of unmerged pull requests and no replies. Also a closed garden. Debugger doesn't work. And currently docs are down (missing). &amp;#x200B; At this point I am not sure I want to learn it since I might like it.
I just started learning Elm today but the first thing I noticed is that the VScode support seems to be pretty broken, though it's not directly part of Elm it gets in the way a bit, especially when formatting on save etc doesn't work.
Very nice, I’ve been working on something similar for TOML, it’s not ready yet though.
I had the same problem, but after listening to the maintainer of the Intellij Plugin on an episode of [Elm Town](https://elmtown.simplecast.fm/it-just-goes-on-and-on), I desided to try Intellij instead. It's also not perfect but definitely better than VSCode.
Excited to play with it! Thank you for the effort!
Correct. Development is continuing and they way they work an unmerged pull request might be progress down the line anyway, but the Slack is imo a very bad thing.
[https://package.elm-lang.org/packages/elm/url/latest/Url#percentEncode](https://package.elm-lang.org/packages/elm/url/latest/Url#percentEncode) \- worth reading the accompanying comments
Yup, I read it and talked about it in the post. Next time please read carefully before commenting.
Ouch? A bit too harsh? To be fair, my first thoughts seeing this reddit post were: "They're genuinely asking, that link is probably to something like StackOverflow with exactly the same question" and I almost answered it here, but then I saw this thread. ... so I can absolutely see how this confusion started.
Kudos to providing the recommended alternative as well as the answer.
That came out pretty assholey.
web-sockets. how did 0.19 ever launch without it?
Er, yeah, I hadn't even seen the link, just thought somebody needed some help, so I did...
Hey @opsb, I apologise if I came across as too harsh. That wasn't my intention. I will be more mindful of my responses in the future. And thank you for trying to help out. I can see how the title of the post might be misleading. Lol.
Quality post. Thanks!
Richard Feldman's [comment](https://discourse.elm-lang.org/t/message-types-carrying-new-state/2177/5?u=dwayne) on the topic.
Yes it is really nice if you don't need a lot of the browser apis. I've tried several other frontend approaches with Haskell, F# and PureScript but they don't feel as polished as with Elm.
Can you share an ellie-app snipped? &amp;#x200B; [https://ellie-app.com/](https://ellie-app.com/)
[https://ellie-app.com/5TSKPr7C48La1](https://ellie-app.com/5TSKPr7C48La1) &amp;#x200B; It's not much, but I think it demonstrates the issue I'm experiencing. Clicking on one of the content divs should scroll it to the top. Occasionally it does, but the behaviour is not consistent or repeatable.
If you need browser apis you can use [Typescript interop](https://github.com/dillonkearns/elm-typescript-interop) so you can stay typecheked all the way to Elm.
Just make sure you're aware of [this bug](https://github.com/dillonkearns/elm-typescript-interop/issues/17) if you use it (basically there are some nasty parsing bugs you can run into unless the library moves off elm-ast)
This is awesome! I still have one more chapter of HtDP to go through and I think I'll use Elm for it. Thanks for the inspiration.
Nice. I was not aware of this book.
It's not given as much love as SICP, but it's actually quite a sophisticated book.
Very nice. Is there a way to go back from the tutorial screen?
Reloading the page or playing though the tutorial. 🙈
Hahaha. Great work still
I'm wondering how easy it would be to use the language server to build a [CoC](https://github.com/neoclide/coc.nvim) extension to support Elm
It would be pretty easy, it already supports Coc, just not as tight of an integration as it could be.
NICE
Been using it recently, its a very useful package and saves 50% of the boiler plate involved in writing encoder/decoders. Highly recommended.
Awesomeeee! Can’t wait to check this out
/u/Orasund, have you thought about sharing it in the Elm Discourse?
Yeah, but I'm not sure if I should. Right now that is. I feel I would need to say a few words as well. I'll wait a few days, I also want to hear what they said at Elm Europe about games, and then I'll properly post it together with some thoughts about how to structure a game compared to a website.
#1 book is elm in action? I bought the meap 3 years ago and its still not done. I'm waiting to see if Star Citizen will get published first.
Glad to hear it helped 😊
Thanks =)
Do publish it here when ready!
I highly recommend Alex Korban' s [Practical Elm for Busy Developer](https://korban.net/elm/book/). Astonishing, to say the least.
I recommend ["Programming Elm"](https://pragprog.com/book/jfelm/programming-elm) by Jeremy Fairbank. It takes you through Elm's pieces by working on code projects that resemble actual web apps you would build. In contrast I originally learned Elm through very simple examples like incrementing a counter so I think the Elm ecosystem as far as book learning goes is much improved. I am already experienced an Elm dev so I used Jeremy's book to solidify what I already know and to learn 0.19 way of doing things and I attest it's solid.
It’s ssuuuuper close according to Richard! I’m very excited!
what is star citizen?
I asked the author to help me to buy it by giving a bit discount.. but that didn't happen. Else I'd buy it too.. I liked the TOC of this book.
I guess. I'm still interested, but they just announced cutting the TOC from 10 to 8 chapters to "get the book out quicker". After 3 years, I'd rather him not cut content now. Just finish the thing.
A crowdsourced game that has been "in development" for years now. It's almost a running joke as to when, or if, it'll ever actually come out.
But it lost its most interesting chapter: How to scale the Elm architecture to bigger apps :-( I'd have rather waited a bit more and get that chapter...
I'm a big fan of the https://www.knowthen.com/elm-for-beginners (free). There's a paid course following it if you want to get more into various topics.
Hi there. Thanks for opening this thread. Are there tools to handle animation like in Vue.js with the \`transition\` and \`transition-list\` tags or maybe some good animation modules for Elm? I must say that Vue.js makes it so easy to do cool transition animation and I would like to know if I can have this kind of experience or something similar in Elm. Thanks!
There's a great talk about it from elmconf: https://youtu.be/DBVHxkMBfF4 Hope it helps :p
https://guide.elm-lang.org/webapps/navigation.html
Some things can be trickier to get in the beginning. In your case, you need to move outside of the `sandbox`. The `Browser.sandbox` is perfect when you want to play with some ideas or when the component you are implementing is completely sandboxed (it doesn't communicate with its surroundings). The next level Elm app `Browser.element`, can receive `flags` and you can send the current URL to the Elm app through the flags. Here is [ the default Ellie modified to show this](https://ellie-app.com/5YFj3h3VjV9a1). (Please note that the URL shown there is not what you see in your browser because the Ellie output runs in a iFrame. On your server it should display the URL you see in your browser.)
Awesome, Ill check this out. Thanks for sending an Ellie as well. :)
Actually, Can you explain the main : Program {url:string} Model Msg And the \{url} ,\msg,\_ I have never seen that curly brace syntax before.
Yeah, sorry about that. I was in a hurry and I wrote in some shorthand. `{url}` is used to pattern match against a record that has the field `url` in it. It extracts that specific field as a declaration in the current scope. So, if you have this code: type alias Flags = { url : String } toUrl : Flags -&gt; String toUrl { url } = url `{url}` extracts the `url` field from `Flags`. `Flags` can have multiple fields. `Program {url:string} Model Msg` is the type of Program that this `element` has. A `Program` has 3 type parameters: `Flags`, `Model` and `Msg`. In this particular case I used an anonymous type declaration. I could have made it explicit by using an alias like this: type alias Flags = { url : String } main : Program Flags Model Msg `\msg model -&gt; ( update msg model, Cmd.none )` is an anonymous function (lambda). You can declare a function using the function declaration `functionName arg1 arg2 = arg1 + arg2` or you can use a lambda `functionName = \arg1 arg2 -&gt; arg1 + arg2` Anonymous functions are useful when you need a function as an argument for some other function like in `List.map (\item -&gt; item +1) items`. You could make things explicit and declare a `add1 item = item +1` and then use `List.map add1 items` but sometimes it's easier to just use a lambda. Feel free to ask more questions if what I wrote above isn't clear. These functional programming details can be tricky if this is your first exposure to a pure functional language.
Im so dumb. As much as I have used list.map and that didnt click in my head. This is not my first functional language, but it is the one I have put most of my time into really trying to learn the paradigm. That pattern match is a really cool feature I had not seen before and I definitely will be making more use of that. Thanks a lot for all of your help. I really hope elm blows up in the future because it has saved me from so many JavaScript headaches. I really need to learn json.decoders next so I can figure out how to write an onChange event, but that is for another day lol. I am using materializeCss and it has a date picker that I have fill in a date in a input element with elms onInput event, but my datepicker does not trigger it so I actually have to add an event listener in JavaScript to listen for an onChange event to call the onInput event. Really redundant but it works for now, that's something I can change easily later when I have the more important kinks worked out.
&gt; Im so dumb. As much as I have used list.map and that didnt click in my head. I too felt dumb in the beginning. I still do from time to time. Some of these things are tricky but I believe that they are worth learning. &gt; I really need to learn json.decoders next One project that takes you slowly but steadily through the JSON decoders is [elm-demystify-decoders](https://github.com/zwilias/elm-demystify-decoders). It was created by a senior community member that spends a lot of time in the beginners channel. I highly recommend it.
You are a wealth of knowledge and resources 🙏😇
Oooh damn. Buying this on payday.
Huge congrats Jeremy!!
Excellent work, Jeremy! What a hell of an achievement. Amazon UK says it’ll ship in 1-3 months. Who cares? It’s an instant purchase.
The trick is to let css do the stacking. I did the same thing here, using elm-sortable-table: https://zfoh.ch/zurihac2019/projects.html I can share the (crappy) source code if you want.
Thanks! Prag Prog has an exclusivity period for a month, which explains the longer lead time for Amazon.
Thank you!
That looks great! I’d love to see the source code.
Thanks bud that was really interesting. Some good things to try out!
Hey, very cool so far! Do you know if there's a way to fail a Codec? E.g. when I need to write a \`Codec Date\`, I want to make sure the format is correct before I can use the value in Elm. Thanks!
Sure, here is the repo: https://github.com/2mol/zurihac-projects-page And the relevant css commit is [here](https://github.com/2mol/zurihac-projects-page/commit/000c58f8287d35b6170bcde77722256bd62a5216#diff-462164442f53aab6707df346e4a2d0e8)
Lol no, let me totally add it to the todo list. In the meantime you can use oneOf and constant
Thank you \^\^
How is the language itself doing? The Elm repository on GitHub seems a little quiet and we're a long way from 1.0. Is it still being developed?
Thanks! Looks like this might be the way to go.
As a busy person, I don't have much spare time to learn Elm, so it's always nice to see short "tips and tricks" like this and learn new stuff on the go. Thanks!
yes. I'm guessing you were looking at the wrong repos. Check out https://github.com/elm. Elm has a very slow update cycle. and the creator of Elm does not like to give promises, thats why we generally do not know when the next update will come and what it contains, right until a few months before it drops. From what we know the next update will be 0.19.1. Personally I'm guessing its coming at the end of this year (but that's just a feeling, so please don't quote me on that). 0.19.1 will contain major bug fixes and more performance improvements (0.19 was all about performance, it seems like there is still a lot that can be improved). Right now nobody knows about 0.20 and with nobody I mean even the creator of Elm himself does not want to think about 0.20 for right now.
From reading [https://package.elm-lang.org/packages/kirchner/elm-selectize/latest/Selectize](https://package.elm-lang.org/packages/kirchner/elm-selectize/latest/Selectize) it appears to include a fairly extensive set of css in the rendered html. Could you not use css with those?
I've switched to using web components for things like select boxes and date pickers, never looked back.
Which web component do you like for select elements?
You're welcome.
So for a drop down where you can filter items by typing, I usually use vaadin components. They do a bunch of others too
Even if 0.19 got us big performance and compile-time improvements, i'd say the biggest improvements were the changes to the standard library. Mainly the Browser package
Great project, thanks for it. &amp;#x200B; Just a little suggestion: samples could be triggered on key down (and not key up) to avoid some laggy effect.
You're welcome. &gt; samples could be triggered on key down Thanks for the suggestion. I was going for consistency with button click. If you click and hold down a drum pad nothing happens until you release. Similarly, when you key down and hold it nothing happens until you release (key up).
Yeah I guessed that, but as a musician, it does not seem natural to me: you have to anticipate the little delay you have on releases and it makes hard to play a rythm. For instance, you can check this out: [http://sampulator.com/](http://sampulator.com/) [https://www.virtualdrumming.com/drums/online-virtual-games/hip-hop-drum-kits.html](https://www.virtualdrumming.com/drums/online-virtual-games/hip-hop-drum-kits.html)
Bought the eBook two day ago, seems really good so far :) I wanted to get the hardcopy but shipping is quite expensive to Europe.
[https://ellie-app.com/62ytV57pRnKa1](https://ellie-app.com/62ytV57pRnKa1) &amp;#x200B; Here you have it working. You have to subtract the viewport y to the element y and then add the viewport scrollTop to this value in order to have final scroll position.
Ahh mega! Thank you, this is fantastic!
Oh those sites you shared are really nice. And I see what you mean. I'm not a musician so that's why I chose that clumsy option. I took note of it [here](https://github.com/elm-school/drum-machine/issues/1), but I won't get to it anytime soon. You're free to contribute the change if you like.
You are fluent in Emoji. I love it.
[✌](https://emojipedia.org/victory-hand/)[😊](https://emojipedia.org/smiling-face-with-smiling-eyes/)
Yup I must have been looking at the wrong repo. Thank you.
I myself am a big fan of VSCode with the new remote extensions, I can have my whole Elm toolchain in a container but still use the editor on the host and then you can specify which extensions you'd like to run inside the container via .devcontainer.json Docs: [https://code.visualstudio.com/docs/remote/containers](https://code.visualstudio.com/docs/remote/containers)
That's interesting. Thanks for sharing!
Thanks for the writeup, I always love posts that go through both the failures and thought processes before arriving at the actual outcome. Good stuff!
Wow！Good job!
Great idea. Unless I missed it, mind giving an overview of how it works? What are the steps used to reduce?
I implemented this as part of my bachelor's thesis, which documents all passes with some examples: https://gitlab.com/matheus23/elm-reduce/raw/master/thesis.pdf There is also a file that lists the exact implementation locations for all passes, in case one is curious about the actual implementation: https://gitlab.com/matheus23/elm-reduce/blob/master/Passes.md
Cool. Congratulations for finishing your thesis.
Thanks!
I approve! Here's the [thesis](https://pp.ipd.kit.edu/publication.php?id=pkrueger19bachelorarbeit) if you want to give it a read.
Perfect, I'll update the links!
The first link doesn't work, but I found the thesis in your update. I'll have a read, it looks very well put together. Congratulations on finishing your thesis!
I thought Elm apps don’t have bugs
I see you're missing a /s there I guess. However, I still want to point out that this project is about improving bug reports for bugs in the **elm compiler**, not in elm programs.
I totally am! Not trying to be a dick here. Cool project!
I love this. I think many people had a similar idea when asked why Elm doesn't support typeclasses. The great thing about passing around a record of functions is that it makes it trivial to have multiple implementations of a single typeclass. The only thing I'd say as to why this idea isn't widespread is that Elm is more on the newbie-friendly side of the spectrum compared to Haskell and purescript, which is why I think we just have repeated functions like `List.map` and `Set.map`.
I agree with almost everything, except for the "advanced" languages argument. &amp;#x200B; I agree that newbies can live without Monoids just fine. However I don't consider magical language constructs such as \`appendable\` a simpler concept to comprehend than a record of functions. &amp;#x200B; Also every newbie is likely to eventually come to a point, where he'll need a dictionary with keys, which are not primitives, only to discover that the language has no solution to offer. And that I consider not an example of going for a simpler solution to a problem (as opposed to "advanced"), but ignoring the existence of a problem instead. Ignorance never produces anything good.
Do you use Elm for your frontend work and incorporated this technique? It would be awesome if you could write a little bit about the experience if so.
Yeah I resort to [AnyDict](https://package.elm-lang.org/packages/turboMaCk/any-dict/latest/), not ideal. But I don't think there's much reason to comprehend `appendable` or `comparable` in the first place. The guys where I work who I've introduced Elm to have been working fine for a few months without any mention of those. Saying that, I'd love a typeclass system if it made decoders easier.
Can this be used for any Haskell based compiler or just the Elm compiler?
This can only be used for the Elm compiler. We need the reducer to be language-specific as it replaces function bodies with certain Elm constructs, for example. But there is quite some infrastructure in Elm-reduce that would help writing another reducer for a haskell-based compiler, say something like haskell-reduce.
I would actually not vote for the language to go typeclasses all the way: i.e., with implicit instances and etc. I actually do share Evan's worries that that would make too many new things to learn for the beginners and having typeclasses look in your eyes from the beginning the way they do in Haskell or PureScript, can definitely be frightening to newbies. Also even in Haskell some people (including myself) sense something wrong about the way they are implemented and used. So I'm against implicit instances mosdef. Actually, implicit values altogether (just look at Scala - eek!). I find that restricting Elm in that direction can actually cause some good research in other areas (including explicit typeclasses). What I am lacking in the language badly though is higher-kinded polymorphism and forall-quantification. Everytime I implement any advanced abstraction, I end up having redundant type-variables sprawling around. This again I consider a result of false bias in the design of the language: they were going for simplicity, they thought that forall-quantification is hard to understand, so they dumped it considering non-existent all the cases where it was irreplaceable. Because of that and the lack of higher-kinded polymorphism, we can't even have something as simple as functors.
I do use Elm for the frontend work in production, but I haven't much incorporated this library into my production code yet. I simply haven't gotten to the problems that it approaches. The initial mission of the project is to erase the misconception that typeclasses are impossible to implement in Elm and to show that existing problems can be solved more generically using them. Hopefully the community will catch up and that would drive us to a beautiful future, where Elm has higher-kinded polymorphism and forall-quantification.
How does `onUrlRequest` work under the hood? i.e. how does it intercept when the user clicks a link? Are there failure modes where some links won't get caught? ([Apparently yes](https://github.com/elm-explorations/markdown/issues/1), but it's not clear whether the cause of that is known.) Broadly speaking, the only ways I can think of to do it are: * In the `html` package, add an `onclick` handler to every `a [href "..."]`. (I couldn't find any evidence of that on github.) * Register an `onclick` handler on the whole page, that notices when the target is a link and extracts the href. But there may be ways I'm missing.
How can I properly uninstall packages? I tried manually editing \`elm.json\`, but now the reactor complains about the missing packages...
Okay, looks like it's during rendering. Search for uses of `_VirtualDom_divertHrefToApp` in https://github.com/elm/virtual-dom/blob/master/src/Elm/Kernel/VirtualDom.js and https://github.com/elm/browser/blob/master/src/Elm/Kernel/Browser.js.
If you want someone to do your work for you, just post the question on Stack Overflow like everyone else.
I don't see the appeal of doing this challenge. What is so interesting about it? Why is this an Elm specific challenge? There are no side effects in the challenge, so its definitely not about the purity of Elm. I also not see a problem of it being about functional programming, two recursive functions should do the trick. I'm also not seeing any interesting use of the TEA or it being a nice example for using pipelines. So what's the challenge about?
The trick is to post the question *and* a horrible answer so that everyone feels the need to correct you
Good questions. Here's some context: I'm writing a [calculator app in Elm](https://github.com/elm-school/calculator) that works only with rational numbers (since I'm only doing +,-,\*,/ with rationals). As part of that project I wanted to display the decimal representation of the rationals. I wrote the [code](https://github.com/elm-school/calculator/blob/375b155150dafaab3c46d71ccbdf563fb87ac48d/src/Rational.elm#L91) this morning and I found it neat and simple to write in Elm. So I decided to extend the challenge to anyone who might have been interested. I find it to be a nice example of where you'd want to write unit tests to ensure you implemented the algorithm correctly. Elm's type system won't save you here. (Though the challenge itself isn't about you writing the tests since I already wrote them for you.)
Any good and relevant points made in the article are overshadowed by the condescending tone. This is a pretty good example of how *not* to evangelize functional languages.
Cool story
I think it is purposefully provocative, and got me to click on it. Good writeup
Case in point. I just [discovered and fixed a subtle bug](https://github.com/elm-school/calculator/commit/87c49787dea873d1897317ffce799f6ae5b76586) where I wasn't returning the appropriate sign.
[elm-json](https://github.com/zwilias/elm-json/blob/master/README.md#example-uninstalling-a-package) can uninstall packages, or at least remove them from the dependencies.
I think there are plenty of beginner tutorials, but not enough teaching how to structure an application and good module design.
Thanks for your helpful comment. I appreciate it.
Is there any application in particular that you'd like to know how to structure? Or any module that you're having (or had) trouble designing?
I think it's sometimes difficult spotting when to make a new module. I've seen Evan's and Richard's YouTube talks about it, and it generally goes: 1. Split a function when it gets to big into smaller ones 2. If you find that many small functions are revolving around a data type, put that into a new module But in those short talks they can only go through one or two toy examples. I personally would like to have more examples which are a bit less obvious and a bit more real life. - Do I create a module for my view functions? (A tutorial explaining [this answer](https://www.reddit.com/r/elm/comments/9t9pc1/if_a_view_function_relates_to_a_specific_type_do/e8v2afo?utm_source=share&amp;utm_medium=web2x) would be great) - Do I have a single module for all REST service URLs or do I hide the url behind a "get" function in the module for the data type I'm trying to get? I used to think if I have a `getPeople` url then I should have a `Person` module with a function `getPeople : (List Person -&gt; msg) -&gt; Cmd msg` which hid the URL and the `Person` decoder. But it looks like [Richard may disagree](https://github.com/rtfeldman/elm-spa-example/blob/master/src/Api/Endpoint.elm). When should I go for one and not the other? - Similarly with decoders, all decoders in one module or a non-exposed decoder in the module for the data type, which is used with the "get" function? - How can I structure the app if it has various pages? Are things different if the pages need to share some data?
Nice! This is useful info. Based on the link you shared it seems that you got into many of these problems yourself. Can I learn more about the app that you were trying to build? Things like functionality, number of pages, data involved, etc. Maybe there's a useful subset in there that could be the basis for a tutorial.
I would love to see a tutorial about just the language outside of a web app context. My biggest hurdle in learning the language is the ways I can understand and define and interact with complex types. The compiler errors aren't always that helpful, e.g. I'll get an error that there's a type mismatch but the way the compiler prints out the expected type is not exactly the same as the way the type signature is written, like using "number" instead of "Integer" and what is "comparable"? That term is not defined anywhere in the docs. The type system seems to be the most powerful and complex part of this style of language but it seems all Elm tutorials expect people to already know the type system. I've started reading Haskell books to try to catch up on that end. Any recommendations on learning the type system?
I would love a collection of best practices and/or ideomatic elm „recipes/coolbook“. I have looked for something like that does not seem to exist yet. 🤷🏻‍♂️
This exactly. I want to see details about modules, json decoders, creating your on event listeners with "on" so I can you onchange instead of onInput. Etc etc
&gt; Any recommendations on learning the type system? Start here: - https://guide.elm-lang.org/types/ - https://guide.elm-lang.org/appendix/types_as_sets.html - https://guide.elm-lang.org/appendix/types_as_bits.html &gt; I've started reading Haskell books to try to catch up on that end. http://haskellbook.com/ chapter's 4, 5 and 11 are also good. There are exercises as well to test you knowledge.
Second this. the official doc is also pretty damn good. You need nothing else to get started. You can build a full SPA from day0.
Sure. I’ve made a few apps for production now and all of them kind of shared the same problems. All of them were: 1. CRUD apps 2. With authentication, sometimes basic sometimes OAuth. All involved getting a token from somewhere and sending it in the request header with every REST request 3. With client and server side validation 4. With multiple pages I can spend more time discussing the specifics of the projects but I’m not sure if that will result in getting stuck on the details?
I think these are fairly trivial problems though. To me what I haven’t gotten past after quite some time with Elm is good application architecture.
Exactly. I was agreeing with you and adding the two other things I want to see. Also subscriptions.
Tools to handle binary Websocket support content inside elm components Anytime I have to do these things I either have to add ports and take away the magic or drop into purescript and take away the magic
The language server support is pretty new. I'm not sure that there are a lot of people using it with Emacs yet. You might get better results asking in the #elm-language-server channel on Slack. That said, if you're after getting Elm support in Emacs instead of specifically the language server, here's my config: https://github.com/BrianHicks/dotfiles.nix/blob/master/config/emacs/lang/elm.el
Thanks
I just finished integrating authentication via the `auth0-spa-js`. I recommend you use `ports` and this package. Follow this guide: [https://auth0.com/docs/quickstart/spa/vanillajs/01-login](https://auth0.com/docs/quickstart/spa/vanillajs/01-login)
I prefer doing the auth on the JS side, that way QA can send debug histories without leaking their passwords.
Authentication is one thing. Using auth0 (a 3rd party service provider that uses JWTs and stateless sessions for authentication) us a whole other thing. If you want to learn how to authenticate users, you can look at my example app on github: https://github.com/parlez-vous/site/ This app doesn't use JWT's, stateless sessions, or 3rd party service providers. I instead store opaque session tokens in the browser's localstorage and transmit that token over to the server to retrieve the associated user and validate the session server side (stored in db for the time being). I've modeled sessions as a binary state: Either you're a Guest or you're an Admin (see [here](https://github.com/parlez-vous/site/blob/master/src/elm/Session.elm)). I know there's lots going on in this app, so feel free to reach out and I can clarify further.
I got curious about LSP after writing this config and switched over. I'm not sure it's going to be forever—it makes my computer heat up a lot—but here it is for now: - Elm config: https://github.com/BrianHicks/dotfiles.nix/blob/24d7dc8a666e66b6795cb80cde95fd8cdfb5082b/config/emacs/lang/elm.el - emacs-lsp config: https://github.com/BrianHicks/dotfiles.nix/blob/24d7dc8a666e66b6795cb80cde95fd8cdfb5082b/config/emacs/language-server.el
Hey thanks for providing an example from your github, really appreciate it! I'm currently looking through it, I will let you know if I need help with.
I have a working example with the PKCE oauth2 flow. I'll open source it and post it back here later.
It's bad practice to store tokens (or other sensitive data) in localstorage or sessionstorage. Any JS on your page can access it.
I'm aware. But I kept running into this sort of problem when implementing it via httpOnly cookies: https://stackoverflow.com/questions/3342140/cross-domain-cookies How would you get around this snag? For context: I have the elm app hosted on one domain, and I have my server hosted on a subdomain.
I have a hobby app example with using auth0! [https://gitlab.com/freiguy1/playground](https://gitlab.com/freiguy1/playground) the elm app is in $/web.
I was planning to fiddle with the elm-tools/parser package. However it is not supported in 0.19 yet. Anybody knows the current status of its migration to 0.19? I am also open to other alternatives (if there exists any).
is there any tool or command to lookup fast and easy on the repl or on the web a list of functions and types a module has? What's the best way to discover functions and types in each module? Going to far maybe, is there a Hoogle (from haskell) like tool? or a help(function) from the iphython world?
Great thank, I'll try it
It's all very conditional. 1) I have no clue. I've built several PWAs, never built anything in electron. Are you dealing with stuff that couldn't be done in the browser? You may not need electron. Web apps can do a LOT of stuff. If you NEED electron, out of the gate, talk to the folks in slack. But it seems to me that even if you do feel like you need electron, but you don't need anything outside of web functionality, I'd save that step for last, no need to Wade into murky waters out of the gate. 2) not sure, I'd ask slack. 3) I really don't have much context on this project. Worst case scenario is you spend a lot of time on this project, but become more familiar with elm. Elm may be right for your project, it also may not be what you need. If you're using GraphQL, elm has an amazing library to generate a lot of the code and types you need. I love it. From my experience, building things without elm starts faster, but accrues technical debt quickly and development slows down considerably. Elm takes a bit to get it started, but it's painless to refactor and it's basically impossible to unknowingly shoot yourself in the foot. Elm forces your code to have structure, so it takes a while to get things in a good place, but once you're there, it's very nice to make fixes. I build with elm whenever I can, and whenever elm makes sense for the project. Good luck!
I completely forgot to ask on slack, I will do that for sure! For 1, we need a desktop application as we are using the windows api to extract screen frames for data processing as part of the application.
Hello! 1. My SaaS is an Electron Elm app, and it works just fine!. I use `Browser.document` and on the JS side `const app = Elm.Main.init({flags: ...});`. HTML looks like: ``` &lt;body&gt; &lt;script src="./dist/elm.js"&gt;&lt;/script&gt; &lt;script src="./js/renderer.js"&gt;&lt;/script&gt; &lt;/body&gt; ``` (`elm.js` is just the output of `elm make`, `renderer.js` is the part where I do `Elm.Main.init`.) I don't have a tutorial but I can help you if you have any additional questions! 2. I use Webpack without config, just to build the JS parts. I have to run `elm make` myself before I run Webpack, so in this particular project I don't use `elm-webpack-loader`. But in my company's app we use Webpack + `elm-webpack-loader` (and even `elm-hot-webpack-loader`) without any problems. Again, ask more specific stuff and I will try to help! 3. I guess we need a little bit more context. Is that a "proof of concept", with motivation of "this is how it would look / how much faster / smaller / ... this would be in Elm instead of JS"? If you're the only person working on it and the rest of the team is chugging along with the JS version, I'd maybe reconsider or at least timebox your efforts. Also, if you succeed to rewrite it, what then? Will the rest of the team adopt it, throw away the JS version, and start learning Elm? I think you have to choose a path forwards that will make sense to everybody. Most teams start with some inconsequential part written in Elm, while the rest of app is in JS, and evaluate after a while. Is it OK so far? Do we hit problems? Do we want to grow the Elm : JS ratio, or do we scrap the idea? Guerilla plans like "I'll rewrite it over the weekend, and just dump it on them" don't work I fear. (Although I get these ideas myself ;) )
You probably want [elm/parser](https://github.com/elm/parser) which is the 0.19 equivalent!
As mentioned in [this SO answer](https://stackoverflow.com/a/23086139/7486612), you can allow a cookie to be accessed by any subdomain (but not other top level domains!) That means if your cookies is set for `example.com`, then `myapp.example.com` will have access, but `example2.com` will NOT have access.
Found out that the VSCode with the elm-languaje-server provides info very fast about functions of a module once.
This package could help: https://package.elm-lang.org/packages/hakonrossebo/elmdocs/latest/ However the cache is 5 months old.
Thank you for all your feedback! For the electron app, I wanted to user Browser application since provides the added benefit of making the application more reactive, as compared to vanilla javascript. However I keep getting the UncaughtError that "Browser.application programs cannot handle file:///home/.../.../index.html". IFor the webpack loader I tried to follow this guide: https://github.com/johnomarkid/elm-electron-webpack but I keep getting a lot of errors when trying to npm install elm-webpack-loader as it get stuck on a broken const from the binwrap-install
Browser.application - can you elaborate on how does it make the app more reactive? To me, it adds URL-handling stuff, but in Electron the URL is hidden from the user and probably not going to change at all. Maybe I'm missing something... elm-webpack-loader and binwrap-install - what are your versions of node and npm or yarn? That might play a role.
If I recall correctly, I did end up going down this road a few months ago and it didn't work well for me. Perhaps this was simply because I don't understand something.
In case anyone is interested, I ended up using the [*pablohirafuji/elm-syntax-highlight*](https://package.elm-lang.org/packages/pablohirafuji/elm-syntax-highlight/latest/) package and overlaying an invisible `textarea` on top of provided highlighted code block. I believe there's really no better alternatives with currently web technologies.
The author of the package provides a [demo](https://pablohirafuji.github.io/elm-syntax-highlight/) where he does the same thing.
I like Elm, I like MTGA. Double thumbs up!
I agree that Browser.application does not make anything more reactive, it just provides extra features to deal with URL routing (which you don't need in electron).
A pity there's no Richard Feldman this year. Looking forward to it though.
Can you share a paper or tutorial that explains "for all" quantification? I'd like to understand it better.
It's interesting to note that Evan remarked on this possibility when he released [extensible records](https://elm-lang.org/news/0.7). &gt;Part of why I am dragging my feet on adding typeclasses to Elm is because records, first-class modules, and typeclasses do a lot of the same things ([records and modules](http://research.microsoft.com/pubs/65409/scopedlabels.pdf) and [modules and typeclasses](http://www.cse.unsw.edu.au/~chak/papers/modules-classes.pdf)). There have been one or two proposals to [unify first-class modules and typeclasses](https://people.mpi-sws.org/~dreyer/papers/mtc/main-long.pdf) as well. I want to make sure Elm is getting the best of all of these features, so I have been doing a lot of research to make sure I do not make the wrong choices here.
Yes that's it! I can't believe how I couldn't find that... Thanks a lot!
I'm a mobile app and web developer (Swift, PHP, Typescript, React, etc). I just found out that I'll be rewriting a complex legacy application in Elm for work. I've never worked with the language before, but I know that people who write in Elm tend to love it. Looking at the official guide on the website, I'm not sure I fully understand how the syntax is read or how module structuring is supposed to work. Can somebody point me in the direction of A) a language feature walkthrough, and/or B) a simple To-Do app tutorial? Thanks - looking forward to loving this language with you all.
Sure. https://ocharles.org.uk/guest-posts/2014-12-18-rank-n-types.html