Using another tool for that isn't too difficult, e.g. [elm-live](https://github.com/tomekwi/elm-live) or just about any js build tool out there if properly configured (webpack, grunt, brunch, ...). But I agree, it would be nicer to have that functionality already integrated in `elm-make`
There are many ENV variables and certain states passed through the server as a flag to `programWithFlags`. I have two sizable applications in production that go beyond simple needs that `elm-reactor` manages to provide.
I think this is out-of-scope for the core Elm tools. The core language devs should focus on features and tools which are difficult or impossible to implement without tight coupling. Increasing the effort to maintain Elm should only come when it is a large win. I think that this is just too small a gain given the complexity of needs for compile/deployment that people have and the large number of existing projects which can do the job.
FYI: I'm contemplating removing the `webView`, allowing for native UI only. Not sure though.
&gt; you're thinking that calling document.getElementById would be slower than traversing the document tree? I'd expect `getElementById` (a constant time hash map lookup, is my undesrstanding) to be faster for finding a given element than traversing to it from the root, for sure! I guess what I should have said is [Elm's virtual DOM library was recently rewritten to optimize performance](http://elm-lang.org/blog/blazing-fast-html-round-two), and it's hard to imagine it wouldn't be a step backwards in terms of perf to go from what it's doing now to `document.getElementById`. 😄
For what it's worth I've found that live reloading can often be quite problematic. If it ever fails you end up thinking your code changes aren't making an effect when in reality you code isn't changing. However, if people do build a live reloader I want it to be like Clojurescripts figwheel! 
Thank you!
Since you are updating the model before passing it to `withFilters`, why not just let `withFilters` handle the field accessing? withFilters model = { model | filters = createFilters model.currentTitleSearchField model.currentDescriptionSearchField model.currentFilteredTags } Then you can greatly reduce the noise of your update branches: UpdateTitleFilter titleSearch -&gt; { model | currentTitleSearchField = titleSearch } |&gt; withFilters =&gt; [] 
Awesome episode!!! Murphy, I still have no idea how Tasks work - and I've been using Elm "in production" with 3000+ loc apps (and getting paid for it!) for more than a year :) I barely ever use Tasks, and when I do I just copy/paste some code that I know works somewhere else. - Rex
Elm is an all-in-one development environment. Or, more exactly, a Zen Garden of Eternal Bliss. Elm's goals have always been to reduce developer friction and increase the pleasure of coding, and I'm sure that the only only thing holding this back are some technical tradeoffs that are not worth making at the moment. - Rex
Ports is really the chosen path. However you could perhaps do something tricky with injecting script tags on the page through the view. Also you could try to do basically the same thing except with web components. I personally would just use ports. 
You can also just use the ++ operator and have your function return an empty list or a list with only one item. 
To add to this answer, in elm there's only your data and then there's views of that data. They are decoupled completely. For instance you may think that whenever the chat is open you and receive messages which requires a web socket connection to start and when the view goes away it should end. Seems logical. However what if you want to get them and surface them as notifications instead? Then you'll be happy their decoupled. Or perhaps you have a airplane feature that closes the connection? This mindset affords you flexibility. 
Ports is the way to do it, but I think it would be possible to write an interface between Elm and the JS library so that for each functionality of the library you use you have a port that calls that function - then you just need to import the module and link up the ports you actually need for that app in your main file - in other words, a reusable Elm module with associated JS file that expose some behaviour. Could even make it so you abstract a set of behaviour into a single port if multiple functions of the US are used as a single behaviour in the apps
The problem you'll run into, though, is wrapping up the ports so that the main app knows they exist and is all tidy - so it won't really be full encapsulation. I would just do some rough prototyping: build what you want to occur then abstract away more of the functionality into a module until the module is stand-alone enough that it could easily be imported into other apps.
[removed]
If you're OK with possible runtime exceptions, you could look into a native module: https://github.com/eeue56/take-home/wiki/Writing-your-first-Elm-Native-module I dunno how accurate that is, it's from last year. But I'd just use ports.
oh wow, I totally missed that opportunity! Updated gist to incorporate that suggestion: https://gist.github.com/rtfeldman/913e88a9254b3e3ff7473c6747e267f4 import Rocket exposing ((=&gt;)) -- Rocket comes from https://github.com/NoRedInk/rocket-update refreshFilters model = let filters = createFilters model.currentTitleSearchField model.currentDescriptionSearchField model.currentFilteredTags in { model | filters = filters } update : Msg -&gt; Model -&gt; ( Model, List (Cmd Msg) ) update msg model = case msg of Noop -&gt; model =&gt; [] UpdateTitleFilter titleSearch -&gt; { model | currentTitleSearchField = titleSearch } |&gt; refreshFilters =&gt; [] UpdateDescriptionFilter descSearch -&gt; { model | currentDescriptionSearchField = descSearch } |&gt; refreshFilters =&gt; [] UpdateTagFilter tagSearch -&gt; { model | currentTagSearchField = tagSearch } =&gt; [] SubmitTagFilter -&gt; { model | currentFilteredTags = model.currentTagSearchField :: model.currentFilteredTags } |&gt; refreshFilters =&gt; [] AddTagFilter tag -&gt; { model | currentFilteredTags = tag :: model.currentFilteredTags } |&gt; refreshFilters =&gt; [] RemoveTagFilter tag -&gt; { model | currentFilteredTags = List.filter (\t -&gt; t /= tag) model.currentFilteredTags } |&gt; refreshFilters =&gt; [] 
&gt; build two adapters Thank you! Could you explain what you mean an adapter? 
I agree, I will stick with ports :)
let's say that you have some JS object and some methods you would want called on it. Instead of providing a port for each method, you provide a single port and you give that port the information needed for the JS to figure out what to call (you could use a JSON). In JS the adapter would be a switch that would check for some field in that JSON and do whatever it needs to be done. In Elm you could have a series of functions that convert some Elm types to the appropriate JSON to be sent through the port. 
Emcscripten is a pretty nasty requirement. One assumes this is just a fun proof of concept. 
well, webasm seems to be getting standardised right now, and it can compile to webasm, so this might be serious
This is really cool. Obviously rust's syntax doesn't lend itself to this pattern quite the way elm's does, but it's still a great architecture for writing apps. Also, reading the docs, I learned about the [conservative_impl_trait](https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md) RFC, which, if you use rust, looks pretty nice.
[removed]
This is true, conceptually they aren't any different. It's certainly possible to write your messages to contain functions that when applied to the model return a new updated version of the model. eg. type Msg = Write (Model -&gt; (Model,Cmd msg)) update msg model = case msg of Write func -&gt; func model But putting functions in messages is discouraged because it's harder to read and can't be easily serialize for storage. ie. the new debugger doesn't work if you put functions in your messages. There is a lot of value in having a serializable high level description of actions that can be taken within your program. 
It should be noted that you don't have to pass data back and forth with strings - you can pass Json.Encode.Value objects through ports (see https://guide.elm-lang.org/interop/javascript.html, the "Customs and Border Protection" section). So if you create JSON encoders/decoders for your types, you can just encode/decoder to and from Value objects and pass those around without the additional overhead of converting to and from strings.
&gt; How is a command not a hidden write only (from users code) FIFO queue of commands on your model Commands are the only way in Elm to make side effects happen. In JS, you could write `fireHttpRequestRightNow()` and it would fire a HTTP request right when you invoked that function. In Elm, you cannot write a function that does this when you call it. Instead, if you want a HTTP request, you need `update` (or `init`) to return a `Cmd` which describes the HTTP request you want done. So the main purpose of commands is not to be a queue of changes for your model, it's to perform effects that cannot be performed any other way. :)
&gt; How is a command not a hidden write only (from users code) FIFO queue of commands on your model? You can implement it like that if you want. The way it is right now is that the command queue is returned together with the model instead of within the model. You can create a custom Command data type that describes the commands that you want your system to execute and then put those commands in some FIFO in the model. At the topmost level of your app you will then have to empty that FIFO queue and convert your custom Commands into actual commands that the Elm runtime understands. If you find that easier to use, do it like that. It will take some effort to adapt the available cmds to this new structure but that's a one time cost. 
Very informative article. I have two comments: &gt; In Elm, data is dumb No bloody way! :) Elm data is one of the smartest data there is. You can teach it to do all kinds of useful tricks. Here is [a talk](https://www.youtube.com/watch?v=IcgmSRJHu_8) where Richard teaches his data to protect the users from shooting themselves in the foot accidentally. That's smart data man! :) I think that there is a better bet if the smartness is moved from the code to the data. Smart data, dumb functions. :) &gt; These gurus of OOP disseminate their lore of design patterns and code smells meant to guide their followers of when to extract an object, and how. Design patterns movement started with Christopher Alexander's 1977 book "A Pattern Language" however, he moved on and kinda abandoned those findings for something deeper and more profound that he names **Theory of Centers**. The `structure preserving transformations` that he talks about with centers transforming to emphasize other centers, centers growing or disappearing as the project goes through time, this resonates deeply with how I've been coding in Elm. I think this has been made possible because of the mentioned separation between effects and computation. Elm has a great opportunity to bring Christopher Alexander's newer theories into the programming world and to make the transition from Design Patterns to Living Code. 
A little late to the party, but this is interesting: https://github.com/matthieu-beteille/gipher
How do you guys maintain type safety throughout your stack (what do you do with your backend)?
When possible, I treat the data as JSON stored as an opaque blob. This means only Elm even touches it. It's obviously a totally inadequate method for a lot of uses, but I'd say maybe 50%+ of things can do this (some things don't even need a backend -- I'm a big fan of localstorage persistence). 
I'm confused about how to focus on an element. I'm trying to use `Dom.focus` and `Task.perform` and I'm getting an error. I'm not sure how to use Dom.focus correctly. Here's the code part of the code where I'm trying to focus on an element with id "input-box": main = program { init = ( Model "" [] (States [] (State "" []) []) , Task.perform (always NoOp) (Dom.focus "input-box") ) , view = view , update = update , subscriptions = subscriptions } Here's the error I'm getting: -- TYPE MISMATCH -------------------------------------------------- src/Main.elm The 2nd argument to function `perform` is causing a mismatch. 182| Task.perform (always NoOp) (Dom.focus "input-box") ^^^^^^^^^^^^^^^^^^^^^ Function `perform` is expecting the 2nd argument to be: Task.Task Never b But it is: Task.Task Dom.Error () Hint: I always figure out the type of arguments from left to right. If an argument is acceptable when I check it, I assume it is "correct" in subsequent checks. So the problem may actually be in how previous arguments interact with the 2nd. Detected errors in 1 module. I'm not sure how to convert `Task.Task Dom.Error ()` to `Task.Task Never b`. I'm sort of confused about the `Never` type in general too.
Your intuition is correct, union types are a list of tags.
Are there any real (meaning, not too simple) examples of routing? The tutorials around Navigation and url-parser are either contrived or old. I would expect a real example to handle back-button/history and retain the ability to go directly to a URL. I have looked around a fair amount and can't find anything, so if it exists...sorry! Thanks for doing this, btw.
[removed]
Minor nitpick: the formatting of this document needs some love. Add a `float: left` to each image and the text will flow around the image, instead of creating a single a line of text with a huge line height. I'd also add a `margin-right: 10px` to each image to give it some space.
Feel free to PR, I'm terrible at layout stuff and haven't had time to look at this in ages.
You might want to check out https://github.com/rundis/albums There´s also a blog series associated, part 6 http://rundis.github.io/blog/2016/haskel_elm_spa_part6.html covers some bits on navigation. 
Thank you so much! I really appreciate you taking the time to give a good response!
I use Haskell(mostly with the Servant package).
&gt; once you create a particular data value, it has **no runtime behavior or smarts** on its own I know, I know... That's why I put all those smileys. Elm's ADT are amazing. :) 
Yes, you can have an update function like this: update: Msg -&gt; Model -&gt; Model I have such a thing in my code, when I wrote an update that doesn't produce any further effects.
Richard's Talk from ReactiveConf 2016 - [Elm and React in production](https://www.youtube.com/watch?v=3FNKaGm3gk0) - is quite good and presents the best way to approach integrating Elm in production. 
If it's not too much work, some exercises would be nice. IMO the biggest problem with LYAH is that it doesn't have any.
You need to be specific when calling this ambiguous function: Html.form or Html.Attributes.form
And as a bonus you can do: import Html.Attributes as A exposing (..) Then you can write `A.form` instead of `Html.Attributes.form`, which can be nice at times.
A-ha, this is nice, I didn't think of that :)
you can check my example. I'm using node express for server https://github.com/rofrol/elm-navigation-example
Pivotal Tracker is using it: https://www.pivotaltracker.com/blog/Elm-pivotal-tracker/
How long did it take new devs to get up to speed? What was their background? Do you feel you develop faster?
Very cool idea. On mobile at the moment so I can't play with it just yet. Have you been able to check what the impact on compile size is? I.e.; is the compiler able to spit out something meaningfully smaller than sum of the three apps if they were separate? I could see this being a great resource saving strategy if the compiler is able to eliminate duplicate boilerplate. 
Not so familiar with elm or how your router is working, but "the idea of chaining generic functions together to progressively build an inferred type" sounds a lot to me like an HList (heterogeneous lists.) It's an extremely powerful structure in statically typed environments, but as you correctly observed the resulting types are pretty gnarly. As long as you don't have to declare a specific instances type (inference becomes something to prioritize) you can get a lot of mileage out of this.
I think this is a bug in the toInt implementation causing a loophole on the type system. I can imagine you can work around this by converting to Float and then rounding the result to Int (and maybe checking if you just lost some fractional part). But really, the toInt function is buggy and must be fixed.
Cool, I'll report it on the Elm core repo then.
I'll be there in spirit! Living in New York right now (and the NYC meetup is great) but I'm a Toronto native...maybe I'll get lucky and one of the next Elm Toronto meetups will be during my next visit back =)
It looks like `NaN` and `Infinity` can be both `Int` and `Float`. Interesting find! &gt; (0/0) NaN : Float &gt; round (0/0) NaN : Int &gt; (1/0) Infinity : Float &gt; round (1/0) Infinity : Int If your `NaN` is an int, you can convert it to a float with `toFloat`.
A web framework like Phoenix is not going to be as performant at serving static assets as Apache or Nginx. The tools available for caching static assets served from these sorts of servers are also very mature. If you are just planning on using Phoenix as an API server, then separating the static front-end code into a separate deployment path allows you to not use any of the static-file or dynamic HTML libraries and you can focus on just the API. If you are going to serve dynamic HTML from Phoenix, then you are going to have all of these libraries loaded anyhow, and it might be worthwhile to simplify your development and deployment processes by using everything in a single tool.
Paths are absolute (not relative), and your entry point is what you defined in elm-package.json under source-directories. Note that it is an array, so you can add multiple entry points!
Thanks for the tip. I hadn't heard of HLists. I'm new to this style of programming. I'm glad this has already been studied so I can learn from past work. 
`elm-package.json` has a `source-directories` field, which in an *array* of paths where modules are expected. You can import any module found under any path. (Modules with dots in their name are expected to be under directories of the same name.) Paths can start with `../` to reach into outer directories, but the reason this is relevant is that *you should have a second `elm-package.json` in the `tests` directory*. Your test dependencies like `elm-community/elm-test` should be listed in this file, but not the one at project root. This ensures that projects that depend on your library do not depend on you testing dependencies. You can find more information [here](https://github.com/elm-community/elm-test#running-tests-locally).
This is a bug. `round` should check for these special values and return... zero, most likely. The `Int` type should be safe for indexing and indistinguishable from machine integers (at least until you get very large).
Google Closure Compiler works amazingly good for Elm apps. What are you using for minification?
It's UglifyJS.
There's another project (elm-native-ui) that does this. It's built on top of React Native. Check it out: https://github.com/ohanhi/elm-native-ui
The example shows each of the routes "/a", "/b" and "/c" are separate apps, each with it's own model. What about sharing some state between these apps? Like, e.g. logged user data? 
I'm not sure it's always wanted to handle all outputs in a function, or if it's possible at all. I don't think you can do this in haskell either.
I meant that you can't make it a compile-time error if you forget to handle all outputs. Correct me if I'm wrong, how would you do such a thing?
By changing the language? I don't understand the question. If the outputs are a union type you just need to check that all cases are covered in the output, just like you can cover all inputs in a case. 
I really liked this post, the specific examples where great. Thanks so much for sharing. 
This is brilliant, thank you so much! This is going to be insanely helpful for beginners!! I had one question, will this bit of JSON work with any elm project to load in stylesheets at runtime? "stylesheets": [ "https://fonts.googleapis.com/css?family=Open+Sans" ] 
FYI you can use monads in Js if you want.... https://curiosity-driven.org/monads-in-javascript I enjoy elm, but the ecosystem in react is much richer. I consider react plus typescript to be a good trade-off. It won't catch all the issues that elm does, but it collects a lot more than plain es. It saved me months of work to use react components. If I were to use elm, my app would be more robust, but have fewer features and polish. That said, all the fiddling with webpack that react requires is pretty annoying.
Why not just set the input as disabled when needed? No need for complex-ish events. 
Isn't the problem that the appropriate element for this ui pattern is a radio input and you're recreating radio buttons with checkboxes?
That's exactly right. I actually made that PR comment a few hours ago :) However, when we went down the path of using `onWithOptions` we found its documentation a little confusing so I wrote this post primarily as an example of how to use `onWithOptions`.
My problem with onWithOptions is you can't prevent default based on some property of the event, e.g. to make a text box that accepts some characters but not others.
Oh, cool! No idea why this didn't turn up when I was trying to figure this out. Thanks for replying. I think one difference is elm-live looks like it is just for live reloading, whereas broccoli manages the entire build + live reload.
I cannot figure out how to make a reusable view. (The Autocomplete I'm using is my own module, not the one in the repository) I keep getting an error like this: The 3rd and 4th entries in this list are different types of values. 311| [ h3 [] [ text "Settings" ] 312| , div [] [ text ("Active study tags: " ++ (toString model.settings)) ] 313| , div [] [ text "Add: ", Autocomplete.view ] 314|&gt; , div [] 315|&gt; [ button [ class "btn btn-primary answer-button", onClick CloseSettings ] [ text "Cancel" ] 316|&gt; , button [ class "btn btn-primary answer-button", onClick SendStudyTags ] [ text "Update" ] 317|&gt; ] 318| ] The 3rd entry has this type: Html Autocomplete.Msg But the 4th is: Html Msg Hint: Every entry in a list needs to be the same type of value. This way you never run into unexpected values partway through. To mix different types in a single list, create a "union type" as described in: &lt;http://guide.elm-lang.org/types/union_types.html&gt; I tried to fix it by adding the module's Msg type to my main Msg type Msg = Reveal | .... tons of stuff ... | Autocomplete.Msg And I've tried various other things like changing all my Html Msg to Html msg but I cannot get this to compile. The view in question is extremely simple, defined in the Autocomplete.elm file type Msg = UpdateQuery String type alias State = { query: String } view : Html Msg view = div [] [ input [ class "form-control", placeholder "Add tag", onInput UpdateQuery ] [] ]
Thank for explaining that! -Rex UPDATE: I just checked out create-elm-app. That's pretty amazing, I didn't know about it at all! I stopped using elm-webpack-started because of the complex configuration, so this looks like a fantastic answer. 
Monads in JS... hmmm... aren't those just semicolons?
Take a look at [Html.map](http://package.elm-lang.org/packages/elm-lang/html/2.0.0/Html#map). The example in the docs is a bit confusing, but that's what you can use to wrap html that sends `Autocomplete.Msg` in html that sends `Msg`. 
Welcome to Elm! I think you'll like it here. What the error is telling you is that `ul` expects its second argument to be a list of `Html` values, but it's actually getting a list *of lists* of `Html` values. This is because `toTodoItems` returns a list of `Html` values (since `todos` is a list, and mapping over a list gives another list), and you're wrapping that list in *another* list by putting it in square brackets. You should be able to fix the error by replacing `[toTodoItems todos]` (a list with a single item, which itself is the list of `Html` values that you actually want) with `(toTodoItems todos)` (which is just the inner list itself, not wrapped inside anything). Hope that helps!
Yes, that's my biggest gripe with it as well. My use case has to do with routing and simulating how the `Link` component works in `react-router` and similar libraries. Might be worth it to gather all these use cases so that a possible api change/addition can be considered.
Good point! elm-live definitely the goto solution in such a case. For me, just getting started, I'm at home using broccoli to manage asset tree management, rev tagging, etc. The drop-in plugin to do live-reloading is a welcome bonus!
OK, so if I am reading correctly, those functions are the high-order ones, they just return another functions which will actually produce Int, Strings, records and what-else in exchange for JSON input (or fail with text description). Your last sentence is something I am still thinking. Look at this snippet, especially the use of `Time.Date.fromISO8601`: import Time.Date exposing (Date, date) -- Bogdanp/elm-time import Json.Decode as Decode exposing (Decoder) type alias Announcement = { id : String , ordinal : Int , subject : String , body : String , duration : Maybe Duration , enabled : Bool } type alias Duration = { start : Date, end : Date } decodeDate : Decoder Date decodeDate = Decode.string |&gt; Decode.andThen decodeDate_ decodeDate_ : String -&gt; Decoder Date decodeDate_ s = case Time.Date.fromISO8601 s of Err err -&gt; Decode.fail err Ok date -&gt; Decode.succeed date decodeDuration : Decoder Duration decodeDuration = Decode.map2 Duration (Decode.field "start" decodeDate) (Decode.field "end" decodeDate) decodeAnnouncement : Decoder Announcement decodeAnnouncement = Decode.map6 Announcement (Decode.field "id" Decode.string) (Decode.field "ordinal" Decode.int) (Decode.field "subject" Decode.string) (Decode.field "body" Decode.string) (Decode.field "duration" (Decode.nullable decodeDuration)) (Decode.field "enabled" Decode.bool) Is it possible to combine the `decodeDate` and `decodeDate_` into one (without anonymous function)? Looks like JSON decoders use `Result` and still, I had to repack the date… Or is there anything less in code to simplify?
Whoa. How do you do that?
As an aside, the `Json.Decode.mapn` functions are a pain to use. Check out [json-decode-pipeline](http://package.elm-lang.org/packages/NoRedInk/elm-decode-pipeline/latest) for an alternate way to decode JSON objects. &gt; Is it possible to combine the decodeDate and decodeDate_ into one (without anonymous function)? Check out [json-decode-extra](http://package.elm-lang.org/packages/elm-community/json-extra/2.1.0/Json-Decode-Extra) for [Json.Decode.Extra.fromResult](http://package.elm-lang.org/packages/elm-community/json-extra/2.1.0/Json-Decode-Extra#fromResult). This allows you to re-write `decodeDate` as: decodeDate : Decoder Date decodeDate = Decode.string |&gt; Decode.andThen (Decode.Extra.fromResult &lt;&lt; Time.Date.fromISO8601) 
Ah, yes! I thought the `[]`in the second argument was the expected syntax and not an actual List. Thank you so much 😄
&gt; I saw the elm-decode-pipeline, but I could not see how is it better than Decode.mapX. It's not that it does something different, just that it makes less noisy code. It separates the transformation of the JSON elements and their use in your Elm data structure. It also lets you play around with a common FP pattern which improves composability. &gt; I was looking for it in Json.Decode and couldn't find :) There are several of these elm-community/foo-extra packages which have convenience functions of this sort. It's worthwhile to check them when you aren't finding what you are looking for in the standard library.
&gt; How can a function produce some result or transform something into something else, having no input? Decoders are not functions, they are a strategy for decoding *any* JSON. A `Decoder Int` will, for any piece of JSON (possibly some deeply-nested value), either produce a value of type `Int` or fail. So where does the JSON data come in? ``` decodeString : Decoder a -&gt; String -&gt; Result String a ``` This is the function that ties decoders and JSON strings together, giving you that value or an error message. Hopefully this helps resolves the "having no input" part of your question; here's where the input is. (`decodeString` used to be much higher up in the module docs; I wonder if it should be moved back?)
Yeah, I think the problem is that Ruby has exceptions and language support for catching them. Elm deliberately has no such construct. And I agree I don't want `Result`s in my arithmetic.
The problem with a CONTRIBUTING.md or a PR template is that one would have to add them to every repo. Also, I know from experience that many people ignore these documents. No, this is just something people need to be told, a community standard. I don't mean this in an angry or vindictive way, just an FYI.
[removed]
by far the most useful tool in the elm realm.
[removed]
Use Http.toTask and Task.andThen (if latter requests depend on data received from earlier ones) or Task.sequence (if the requests are independent of each other). 
Just click the plus button next to the editor and then the embed button (&lt;&gt;). Then paste the full url to the snippet and you're good to go!
I agree that the documentation is a bit awkward. If you do go to the MDN article you will see: &gt; Note that submit is fired only on the form element, not the button or submit input. (Forms are submitted, not buttons.) The `onSubmit` event only works with `form` elements and it only sends a `Msg` without attaching any payload to it. It is really just used to prevent the form from *actually* submitting and trying to change the page and to alert you that a submission was attempted. If you want to know what is actually in the form elements, you need to track those separately using events like `onInput`.
I work on my [library](https://github.com/astynax/tea-combine), which will help me combine TEA-apps with minimal "glue code". So I really pleased to see, that somebody has similar ideas! I thought about combining the whole programs too, but I decided that such composition will be too constrained. When I compose Programs, I can't have access to the views so I can't create complex layouts for subprograms. I can only switch between them. This can be enough for programs-"pages", but won't work for me. My current design is based on separate model/view/update combinators: main = beginnerProgram { model = Counter.model &lt;&gt; CheckBox.mkModel "1" &lt;&gt; CheckBox.mkModel "2" , view = Counter.view &lt;|&gt; CheckBox.view &lt;|&gt; CheckBox.view , update = Counter.update &lt;&amp;&gt; CheckBox.update &lt;&amp;&gt; CheckBox.update } This approach looks more verbose, but it is more flexible...
Interesting. How should you define "FormSubmitted" in your update function then? Is it a built in Msg that you do not need to define?
You have to define it (or something like it) as part of your `Msg` type. type Msg = FormSubmitted | UpdateNameField String | ... 
Is this the session that was recorded in September? If so, is it safe to assume that it targets version 0.17?
It was recorded on 0.17, but I've updated the examples in the repo to 0.18. I think only the HTTP section was significantly different. :)
When I click the "Watch a free lesson" I get a message saying: "This video is not authorized to be embedded here."
I'm not sure if that's an easy question, but... could anyone explain how the "Html msg" type works? I notice that it's a type alias for "Node msg = Node". In particular, what does the "msg" do in this type? Is it only used for pattern matching somewhere?
That makes sense, I'll add that real quick. 
Done. Tell me what you think. 
Nice! Do you want feedback on the code or the UI or both? Is this the repo? https://github.com/justgage/ElmInputSearch
There has been a lot of discussion on the mailing list about approaches to CSS in/outside Elm. See for instance [this thread](https://groups.google.com/forum/#!searchin/elm-discuss/css%7Csort:relevance/elm-discuss/AC6cqdeKDOs/b5H-1tKGAQAJ). It is definitely not an area where there is agreement about the "one best way to do it".
That feels more natural ;) ... However, there is some weird issue with Firefox (working OK in Chrome) when you select a suggestion using the enter key and then press esc. I've cloned your project and run elm-reactor and apparently, even though you update employeesName on UpdateForm, which in turn updates the input value on the view, when pressing Esc, Firefox triggers an "onInput" event *with the previous value of the input*, thus, reversing the suggestion selected with Enter... I really don't know why that happens! Maybe someone more savvy can help. In the meantime, you can either revert the "Esc" behavior, or keep a buggy behavior on firefox. Maybe you can use [this workaround](https://www.reddit.com/r/elm/comments/5s1bx4/elm_preventdefault_and_onwithoptions/ddg78ty/) to prevent the default behavior of Esc and avoid the onInput from triggering on firefox... Whether such a small feature is worth that much trouble is up to you hehe
The first impression is OK. The thing I would change would be to show a little bit more complicated example. Validating a String is so simple (e.g. you can use your model's String property all the time) that no one looks or the answers until they come to something non trivial. Take for example a date input. This is interesting when you have to map String to Maybe Date, and you have entered "1". "1" is not a valid date, so you cannot store it in your primary structure ("1" would ma to Nothing), but you have to store it somewhere until user finish typing a valid date. There is one more thing. In my first tiny app, with 3 input fields total, I decided to store those fields in my model as `FormField a` where `a` was a data type like this: type alias FormField a = { value : a , error : String } Model: { login: FormField String, password: FormField String }`. Pros: one place to store everything. Cons: assuming you have your data downloaded for a table and then for a form, you would have to write two decoders: one for simple type, like `{ login: String, password: String }` and second decoder for the "form" version of that.
Both 😀. 
I honestly think it's mostly just programmers who use Esc. I'm perfectly OK with catering to them but probably not if it's too much work. 
I'm not the best person to answer, never having seriously explored using Elm for layout or styling (except a few inline styles for managing global-ish things like colors), but I would scan through that discussion on the mailing list to see what the limitations and benefits of each approach are. My understanding is only `elm-css` lets you generate actual CSS. The other Elm solutions let you build up inline styles in composable ways, which is great, but at the same time they are limited (no pseudo-selectors, no media queries, etc.) 
I use it by `singleton` by name... I've had to change structures a couple of different times on projects and it's just nice to go from `Maybe.singleton` and `Result.singleton` by changing it's module name than keeping track of `Just`, `Ok`, `Decode.succeed`. I mean `apply` is `&lt;*&gt;`, but anything would be alright. I think it's fine and nice to include it so it's there and people can choose to consume it or not. I know I use `|:` a lot when I'm decoding JSON. Something with a `?` could convey an is-it-valid sentiment.
Call me an unlawful FP noob, but I'd vote strongly for `valid` over `singleton` - I agree that `singleton` only really makes sense for list-like data structures. And as limiting as they can be compared to `andMap`, I do like the simplicity of `map2`, `map3` etc. Maybe we need a new convention - put the powerful-and-uniform-but-relatively-cryptic Haskelly stuff like `andMap` and `pure` in a submodule like `Validation.Lawful` or `Validation.Monadic` or something =)
Ah the raging Elm API debates... I'm a bit on the 'outlaw' side too. ;) I was thinking to add `map2` and `map3`, but follow the lead of RemoteData and say "If you want more `mapN` functions, see the documentation for `andMap`".
I kind of wish there was a pure elm responsive CSS framework would be awesome. Even if it was mostly fluxbox based. 
In the meantime I found http://package.elm-lang.org/packages/krisajenkins/elm-cdn/latest really nice for just getting something up and going. 
I would not say Elm is not good enough. Its just that composing a larger app out of smaller reusable components requires a lot of boilerplate (e.g., the main update function redirecting specific sub-messages and sub-models to specific components as in the [sorted table](https://github.com/evancz/elm-sortable-table)). While having the main update explicit helps prevent a ton of bugs that can (and do) arise when you combine components in an imperative language, I still believe Elm can make things easier. I think [this discussion](https://groups.google.com/forum/#!topic/elm-discuss/FHmv9hBdSA0/discussion) shows clearly the confusion about what the best way to write a large app is. At the same time, I believe the Elm community will figure this out.
Not sure if others will find it useful, but I did a write-up on this, really just to get it straight in my own head. YMMV. https://gist.github.com/greim/75c1c4a7c39b5b8d37edffe7f0aa8660#what-does-html-msg-actually-mean
The [Date documentation](http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Date) is a little sparse. How can I whip up a "zero" date to use when initializing a record. For example: type alias Transaction = { date : Date , amount : Float , description : String } test = Transaction ? 0.0 "" 
&gt; elm-format Anything you don't like about it and would want to be changed? 
Is it possible to return 2 html elements from the main *view* function when using **Navigation.program**? The expected result is **Html Msg** but what I really want is **List (Html Msg)**. Something like: view : Model -&gt; Html Msg view model = [ navView model , div [ class "container-fluid theme-showcase" ] [ page model ] ]
There has to be a root element which can be accomplished by wrapping those two elements in a div. view : Model -&gt; Html Msg view model = div [] [ navView model , div [ class "container-fluid theme-showcase" ] [ page model ] ]
Thanks for the pointer :) When you refer to OO best practices, do you mean the idea of breaking things down into components that each do their own state management? Assuming yes, then I was going to ask why Elm's approach works well despite the fact that you don't get isolation (and hence reusability) as you do in a component. But thinking it over, I guess you only lose the isolation of the model in practice, since Elm uses function purity as a sort of moral equivalent to component isolation. And even then, it's not many models used in components that are actually completely isolated. Am I on the right track? The next thing I think freaks people like me a bit out, is that I guess your `update` function would just be a giant pattern matcher over all the messages you can get from the view? Or is there a nicer way of organizing it?
&gt; guess your update function would just be a giant pattern matcher over all the messages you can get from the view? Or is there a nicer way of organizing it? Well, both! It's where all messages go, yes. But there's no reason you can't simplify it into a small clean function that delegates to more specific functions. For example, let's say you have an application for a public library. Your have messages for dealing with things that happen to books, like `AddBook`, `RemoveBook`, `LendBook`, `ReturnBook`. But then your library starts carrying CDs, DVDs, videogames, audiobooks, ebooks, magazines, and other things. So you have `AddBook`, `AddGame`, `AddCD`, `AddDVD`, `RemoveBook`, `RemoveGame`... and it becomes a giant unwieldy pattern-match to deal with those messages, and `Msg` has lots and lots of potential values you have to write out. Is that the sort of thing you're worried about? You can deal with that by saying "an `Operation` is adding, removing, lending, or returning; a `Medium` is a book, CD, audiobook, ebook, DVD, game, or magazine; a `Msg` is an operation on a medium." Then you could write an update function for each medium specifically, like `updateBook` explaining how books get added, removed, lent, returned, etc. And the main `update` function would just pattern match on the medium type. Is it a book? Call `updateBook`, that function handles that. Is it a game? Call `updateGame`, that function handles that. And then it's `updateGame`'s job to figure out what the operation is and what to do for each operation on a game. And you can do that as many times as you want. Your library might add messages `update` is still where all messages go to start with. But `update` is perfectly happy to pattern match on *part* of the message and delegate to helper functions based on that.
This is spot on. I always end up searching for "Elm [insert feature]", click the docs, realise my mistake and search for "Elm [insert feature] example". The Python docs are another great example of API documentation mixed with a couple of examples.
The *real* problem I'm trying to solve is how to convert a Dict String String To a record type I'm using type alias Transaction = { date : Date , fullDescription : String , amount : Float } Where certain keys in the dict correspond to record fields. I am still learning all the tools and tricks you use to do things in functional programming, so I was trying to understand whether fold could get me where I wanted to go using the list of Dict keys. Since fold needs an initial value, I was thinking of what the "empty" record would be to use as a starting point, hence the "How do I just get an arbitrary or 'empty' Date value" I got far enough down that line of thinking to get the sense that its probably not the way, though I'm still working on the solution.
http://package.elm-lang.org/packages/elm-community/result-extra/2.2.0/Result-Extra#combine ?
Oh wow, totally missed that package. Very nice, thank you! EDIT: Oh man, there are a lot of useful functions in here!
I'm not a web developer, so I'm not familiar with these things. Is it currently possible to build a sophisticated front end entirely in Elm? Essentially, a full replacement for needing to write JavaScript? I was speaking with a web developer who claimed that you'd likely have to write portions of your front end in basic JavaScript and then interact with it in Elm. Is this the case? 
Would you still be using `AddBook`, `RemoveBook`, `AddCD`, `RemoveDVD`, etc?
&gt; Richard's advice generally applies to an *individual logical page* within that application. Oh—to clarify, I think [the comment at the top of this thread](https://www.reddit.com/r/elm/comments/5jd2xn/how_to_structure_elm_with_multiple_models/dbf79tt/) is 👍 about the general way to organize things above that level. I was just responding to [that comment's first reply](https://www.reddit.com/r/elm/comments/5jd2xn/how_to_structure_elm_with_multiple_models/dbftw6q/).
&gt; When you refer to OO best practices, do you mean the idea of breaking things down into components that each do their own state management? Exactly! &gt; you don't get isolation Good news: not only do you get isolation, it's more granular than the OO kind! 😄 In Elm you isolate using modules—specifically, modules that expose union types but not their constructors. You can [use this to isolate state](https://github.com/evancz/elm-sortable-table), e.g. for [reuse](https://guide.elm-lang.org/reuse/), but you can also use it to isolate which functions may inspect and/or create even *stateless* values! Here's a more long-form talk on this: https://www.youtube.com/watch?v=IcgmSRJHu_8 &gt; I guess your `update` function would just be a giant pattern matcher over all the messages you can get from the view? Or is there a nicer way of organizing it? Yep! See "when `Msg` gets too big" [here](https://www.reddit.com/r/elm/comments/5jd2xn/how_to_structure_elm_with_multiple_models/dbuu0m4/).
https://github.com/hyperapp/hyperapp
Are you familiar with how to do Http requests in Elm and use their result? Have you seen [this example](http://elm-lang.org/examples/http)? 
Did you proofread it? 🤔
Quite frankly, you need to read the documentation and tutorials. [This](https://guide.elm-lang.org/architecture/) wouldn't be a bad place to start.
You need to map the Cmd you receive from each module, or... in other words, to lift the message that it produces to the message of the parent. mainUpdate : Msg -&gt; Model -&gt; (Model, Cmd Msg) mainUpdate msg model = case msg of ModuleXMsg moduleXMsg -&gt; let (newModuleXModel, moduleXMsgCmd) = ModuleX.update moduleXMsg model.moduleXModel in ({model | moduleXmodel = newModuleXModel}, Cmd.map ModuleXMsg moduleXMsgCmd ) This kind of trouble is part of the reason why nested Elm Architecture was abandoned. :) 
I'm toying around with making a budgeting app. You can export banking information from each bank, generally as a .csv. I want to store the information in a normalized structure type alias Transaction = { date : Date , fullDescription : String , amount : Float , tags : Dict String String -- Arbitrary key value pairs , bankData : Dict String String -- The original data } So I need to map from each different .csv schema to the normalized structure using some sort of mapping. This way each time you do an import, the bank can be determined. In JSON: [ { "bank": "Chase Bank", "headers": [ "Type", "Trans Date", "Post Date", "Description", "Amount" ], "headerMap": { "date": "Trans Date", "fullDescription": "Description", "amount": "Amount" } } ] In Elm: type alias Schema = { bank : String , headers : List String , headerMap : Dict String String } So the *real* *real* problem is: 1. Get CSV data as string from Port 2. Convert from string to Elm data structure 2. Scrub data and normalize it based on data that describes mapping from input sources to normalized data structure 3. Get data to record so that I can work with it in meaningful ways. I didn't really like any of the existing CSV packages. --This was easier to work with for me Dict String String -- Than this type alias Csv = { headers : List String , records : List (List String) } I wrote a function to parse the CSV strings parseCsvString : String -&gt; Result String (List (Dict String String)) parseCsvString csvString = let contents = csvString |&gt; lines |&gt; filter (\line -&gt; not (isEmpty line)) |&gt; map (String.split ",") headers = withDefault [] (head contents) records = withDefault [] (tail contents) in if headers == [] then Err "The csv file did not contain any data." else if records == [] then Err "The csv file had headers, but was missing records." else if withDefault [] (head records) == [] then Err "The csv file had headers, but was missing records." else if headers == withDefault [] (head records) then Err "The csv file must have a row of headers as the first line" else Ok (map (zip headers) records) zip : List String -&gt; List String -&gt; Dict String String zip headers record = Dict.fromList &lt;| map2 (,) headers record Then you can determine the schema of a particular CSV by passing the dict keys and a list of schemas in to the following function. determineSchema : List Schema -&gt; List String -&gt; Result String Schema determineSchema schemaList headers = filter (headersMatch headers) schemaList |&gt; head |&gt; fromMaybe "Could not find matching schema" headersMatch : List String -&gt; Schema -&gt; Bool headersMatch csvHeaders schema = diff (Set.fromList csvHeaders) (Set.fromList schema.headers) == Set.empty So now I know which dict fields correspond to which record fields in Transaction. So now I need to feed each record in my List (Dict String String) in to a function with annotation dictListToTransactionList : Schema -&gt; List (Dict String String) -&gt; Result String (List Transaction) I have something that works, but its ugly. dictListToTransactionList : Schema -&gt; List (Dict String String) -&gt; Result String (List Transaction) dictListToTransactionList schema dictList = map (dictToTransaction schema) dictList |&gt; combine dictToTransaction : Schema -&gt; Dict String String -&gt; Result String Transaction dictToTransaction { bank, headerMap } dict = let date = getValue headerMap "date" |&gt; Result.andThen (getValue dict) |&gt; Result.andThen Date.fromString amount = getValue headerMap "amount" |&gt; Result.andThen (getValue dict) |&gt; Result.andThen String.toFloat fullDescription = getValue headerMap "fullDescription" |&gt; Result.andThen (getValue dict) in case ( date, amount, fullDescription ) of ( Err err, _, _ ) -&gt; Err err ( _, Err err, _ ) -&gt; Err err ( _, _, Err err ) -&gt; Err err ( Ok d, Ok a, Ok f ) -&gt; Ok { date = d, amount = a, fullDescription = f, tags = Dict.singleton "Source" bank, bankData = dict } getValue : Dict String String -&gt; String -&gt; Result String String getValue dict key = dict |&gt; get key |&gt; fromMaybe (concat [ "Key '", key, "' not in dict" ]) I am positive that there is a better way to represent my data to make all of this easier, but I'm still learning how to use the tools functional programming provides to frame problems appropriately and attack them from the right angle.
Hmm interesting. That is a bit confusing. Is that just to make sure that the Cmd is actually sent? I guess I can understand the reasoning. It just seems a bit strange as it either limits the size of your apps, or forces you to have one incredibly large Main file with lots of different segments. Or am I just missing something here?
Sadly I did not 😔. I was kind of in a hurry. It's kind of a rough draft at this point. 
I went down this road and it worked in the sense that music started coming from my speakers, but I couldn't figure out how to add a mute or pause function. Unfortunately, audio element attributes are not conducive to this; you have to make imperative commands in JavaScript for such things.
So I guess the most similar representation of Cmds in other languages would be like Promises in javascript? It's saying I will return this data when this task is being executed? Okay yeah that makes more sense. I guess I just didn't understand why you need to map the ModuleXMsg. Am I right in saying then is that all that's doing is allowing the higher level function to get access to the data by converting the types? Or what happens if you don't Cmd.map? Say I do something that goes in to a module, runs a variety of updates based on some Cmds using the update function defined before to create a string. If I don't use Cmd.map can I then not use the string in the higher level function? Surely even without the Cmd.map the moduleXModel will update?
Okay, cool. I guess the Cmd part of update I understand (again...only on a single module app). But the Cmd.map bit I'm still not totally sure I understand. Why is it necessary to do the final mapping if the ModuleX.update has been run? Hmm, really? I guess I thought it would easily fit into smaller apps that can be structured together! So it's more of a multidimensional aspect? Like lower levels and higher levels work together to provide the final App rather than each being able to run separately? Yeah I've just never got to the stage of an Elm app that's required several different modules really. Just another stepping stone in trying to figure it all out :)
I still consider myself an Elm beginner, however I have a pet project where I'm using something similar. Main update: https://github.com/werner/madison-elm/blob/master/src/elm/Update.elm#L32 The component update: https://github.com/werner/madison-elm/blob/master/src/elm/Components/Warehouses/Update.elm#L14
`Cmd.map` is a way to allow you to create a function which returns a `Cmd something` and turn it into a `Cmd Msg`. For example. randomCmdFun : Int -&gt; Cmd Int Your `update` function has to produce a `Cmd Msg`, not a `Cmd Int`, so you might have this: type Msg = RollDie Int | RandomValue Int update : Msg -&gt; Model -&gt; (Model, Cmd Msg) update msg model = case msg of RollDie sides = (model, Cmd.map RandomValue (randomCmdFun sides)) RandomValue val = -- handle incoming random value You had to call `Cmd.map` because if you hadn't, then the types wouldn't be correct. `RandomValue` takes the `Int` from the `Cmd Int` and wraps it into a `Msg`. &gt; Hmm, really? I guess I thought it would easily fit into smaller apps that can be structured together! Application components *that don't need to communicate with each other* are usually fine; the problem comes when you start trying to handle communication between application components. If a sidebar has a theme selector which needs to change text in the footer, it becomes nasty to try and wire that up if every sub-component is built as if it were a stand-alone application. I think many of us have been trained to worry a lot about architecture from frameworks which are brittle and thus cause us anxiety when we think about going in and fixing things. Elm is different in that it provides much more confidence when refactoring. Feel free to write messy code that works, then go back and refactor it, knowing that if it compiles (and you aren't intentionally cheating) that things will be fine. If you ever find yourself asking how an event from some place in your code is going to communicate over to some other part of the code, then you have likely gone astray and probably need to re-think your state management.
One of them, a few more people have contributed after my initial release. Thank you :) 
Brilliant work! It's really cool that you have a link to package documentation in the search menu, but do you think it might be nice to also include a link in the packages section on the left side? One more possible improvement related to package installation/removal. Following compilation, you disable the compile button. It gets enabled again following a modification to the source code, but it would also be convenient if it was re-enabled following changes to the installed packages.
I think you should change the cursor from the "text select" cursor to the "normal select" while hovering over the match list.
Ah, it's disappointing to see you were describing components. You should know that pattern of components is considered bad practice in Elm. Rather, you should write reusable functions instead of reusable components.
It's great to see all your code layed out like this. Quite a piece of work! When you say "I am positive that there is a better way to represent my data", do you mean you feel the final model could be better, or that the parsing/intermediate representations could be better ? It looks like a fine solution to me (it works, right?), under certain assumptions about the source data (see questions below). The one stylistic thing I would recommend is to use `Result.map3` or `Result.andMap` instead of that final case on the three results. (It may speed up compile time too). It seems your source data is quite dynamic. Is that unavoidable? For instance: - Do users provide the schemas, or are there a fixed number of schemas? - If the latter, could you predefine parsers for different expected file structures rather than have dynamic schemas? - Could the source files somehow specify their schemas directly rather than having to match a set of expected headers? If you could simplify the problem to matching a source file to a static schema, you could parse directly from the csv without going through the several extra layers of potential failures that `Dict String String` and matching header lists introduce. But I don't know if that's practical in your case or not.
urgh that compiler button bug was something i meant to fix before releasing! oh well. totally agree about the docs link, in fact it's already in our list of feedback. any other ideas share them at https://paper.dropbox.com/doc/Ellie-Feedback-nrhwTg2djHc3r5fjcO39D thanks!
Have you shared this on Elm discuss yet?
&gt; Or what happens if you don't Cmd.map? You will get a type error. You can avoid using Cmd.map by configuring the update function but that's an advanced topic. &gt; I guess I just didn't understand why you need to map the ModuleXMsg. In Elm, you have the Model or the State and if you want behavior (transformation of the State) you need a program. That program is like a loop where the runtime waits for messages and then calls `update` with the message and the old model to get the new model (the new state). After that it calls the view to convert the state into html. now, the only way to get side-effects is to return Cmds from the update. The runtime will execute the command, and put back the result as a message inside the loop. Then, update will use the message to create the next state which will get displayed. This is The Elm Architecture: model, update, view and you have only one state, one update and one view. However, you can decompose each of those and get to this Component like situation. If you split the Model, update and view and group some of those bits into a module, that module will have it's own Msg. If you want to integrate that into the main thing you will need to lift that Msg to the level of the top Msg. This means that the Cmd the update returns needs to be converted so that it becomes a top Cmd Msg. This is done with `Cmd.map`. 
Brilliant and beautiful. Love it.
Quickly looking at https://ellie-app.com/app.b4ee58bb.js can tell you that some parts are written in it, if not all It also seems to make use of elm-css, seeing how classes/IDs in https://ellie-app.com/main.b4ee58bb.css are named
Thanks a lot, that's some good material there :) I personally work on a really big web app (100k+ lines of JS/TS I would wager) in my day job, and I think I'm at a point where I can see how I might structure it in Elm in a nice way. After all that I've seen so far, I think the biggest blocker for me in reaching a nice concept, was actually the mixing of different kinds of state that having one model implies. Now I can at least imagine designing a model that can accomodate this, without resorting to components that track a bunch of state :D
Since ports/initializing the app are "border control", while things like event listener events are "inside" the application, the former just reports an error on the JS side while the later uses Decoders. Elm promises type safety inside Elm, but at the border, JavaScript is just expected to do the right thing. Since the error is reported on the JS side, no unreliable type makes it into Elm. Whether this is the right behaviour or not is up to you, but I personally am okay with being careful with what I send into Elm and not having to deal with Result types once I'm inside. The less external JS there is, the less you'll have to worry about, too.
I'm not an experienced elm developer, but I'm struggling to find a solution around internationalisation. Curious to get feedback on this as an idea. It is possible that the native module &amp; npm approach rules it out entirely but thoughts would be welcome. In particular I'd be keen to learn how to do Native modules in Elm 0.18.0 or how to fix whatever mistake I made. 
Okay cool yeah, that makes sense! Thanks for the explanation, appreciate it! I think I was thinking this was more similar to React where updates can come from any component. Didn't realise communication between components in Elm was a bit more tricky. Think I've got my head around it, thanks for taking the time to explain :)
You can send a `Json.Decode.Value` through ports. If you want to use a decoder, go for it! The automatic conversions are a convenience from before decoders were a thing. There are obviously arguments on both sides about switching entirely to decoders (which I have thought through before) but I won't be revisiting that decision for a while.
Not really, I guess I'm using the word component wrong, as you can see [here](https://github.com/werner/madison-elm/blob/master/src/elm/ViewHelpers.elm) I'm using reusable functions. However you need a way to organize your code. TBH I'm not coming from the Javascript world, so I'm not very familiar to the use of components. I see them as modules, so the warehouse "component" is a folder with a bunch of functions that handle all the work related to warehouses, if you take a look closer you can see the code base look more like a Rails application than a Javascript one.
When you say there are arguments to both sides, what are the arguments for not using decoders?
I can't tell you that you're wrong :) I think you see what I'm saying, but I can also see that it's not really acceptable in its current form if the core value of Elm is safety. I would hazard a guess that the Elm team/creator feels that JS interoperation is temporary and that the real application of Elm is as a standalone thing... and in the meantime, it's worthwhile not having Result types wrapping what will one day be obsolete, or a config file or something. I know that Elm is looking towards WebAssembly as its compilation target, so this point will one day be moot. Elm has improved on Haskell in quite a few ways in terms of safety, but as you can see, there are yet more angles to improve on... and to remove these problems, you would have to find not just a solution (the easiest is a Result type wrapper), but a solution that doesn't hinder beginners and also devs coming from JS (in teaching my business partner Elm, multi-parameter Types were quite the new concept).
Talks that focus more on using Elm for design. How it integrates and aides good design. Less on Elms relationship to itself, and how it compares to javascript.
After a [first look at web assembly performance](http://www.stefankrause.net/wp/?p=405), it would be interesting to see a conference talk on its implications on elm. 
I think if you are creating a library then do not go for `Cmd`s, use `Task` instead. You can produce a task or two, combine/map them as you're pleased and let the consumers of your lib decide to push it to TEA using `Cmd`. Or maybe they would like to combine it with their's own tasks and only then make it a `Cmd`. Look at the `Http` lib. If you need one HTTP call you can ask the lib for `Cmd` right away. If, on the other hand, you want some combination of that HTTP request with other tasks (be it another HTTP or something else like random number, UUID, you name it) then you just let `Http` pass you the `Task`. EDIT (supplementation) &gt; Is there no way for a Cmd to be run outside of an update function? The issue is that for a module you can't really have an update (as far as I've seen) so does that mean it's impossible to run something like Time.now, or Random.generate from within a module? Or is there something I'm missing? As I said above, `Cmd` are required to actually execute the `Task`. You do not need to execute anything to be able to use the results of those tasks though. I know it sounds oddly :) but it's true. You want your module `Time.now` or `Random.generate` and then generate UUID? Not a single `Cmd` you need. Just get the task representing now, a task representing random numer, combine those two values into UUID and let your user decide if they want it all as a `Task` or `Cmd`. They will choose `Task` if they need your UUID to combine it with something else or they will pick `Cmd` if they want receive it in update function as-is.
Well, that's weird. I have just looked at the `Random` package (for the first time) and there is no way to get a `Task` of random value like `Time.now` gives you a task of current time value. Now I am confused… That would be a subject candidate for a separate discussion, I guess. EDIT: [Why Random does not use `Result x a` (like Http, Time,…), but the custom `Generator a` instead?](https://www.reddit.com/r/elm/comments/5tltoh/why_random_does_not_use_result_x_a_like_http_time/)
Well conceptually speaking, you generally want to use Task to describe computations that could fail. Random will never failso you don't need full Task behavior. So a better question would be why does Time need to be in a Task?
You don't need a side-effect to use a pseudo-random number generator (e.g. use Random.step). Http and Time both require a side-effect to function, thus why they must produce a Task. There should be a way to generate a Task from a Generator. I have no idea why one is only allowed to make a Cmd directly. I think we could have something like (swiped from [here](https://github.com/mgold/elm-random-pcg/blob/master/src/Random/Pcg.elm#L105)): generateTask : Generator a -&gt; Task x a generateTask generator = Time.now |&gt; Task.map (round &gt;&gt; initialSeed &gt;&gt; step generator &gt;&gt; Tuple.first)
I am starting to realise this. For OO programmers there is a lot to unlearn. I have a desire to break the problem down in an arbitrary way based on making visual sub-components, but that doesn't necessarily suit Elm. I am taking on the make it work then refactor it functionally approach in my current side project.
Awesome! Would be great to hear how it works out. :)
Hi! I organize elm-conf. The things we want to see: - real-world experience reports. Meaning: we solved X using Elm, here's how it worked or didn't work. - using Elm in new and interesting ways, especially in the liberal arts. Last year we had web audio and storytelling make a big splash. - Advanced techniques beyond "pls to meet TEA". Scaling TEA up has become an open question this year. There aren't a lot of good large open-source examples here; I suspect that they may rest in large closed-source codebases. And some things that are less likely to make the cut for elm-conf: - general type trickery, especially at a high mathematical level. Category theory is nice to know, but we choose elm-conf talks based on what will be *useful* to the audience. - too much focus on JavaScript, or hating on JavaScript. There's a middle path here, but last year we got some submissions that came out with guns blazing. Tearing other languages down is generally not appropriate. - Not focused on Elm. We got a submission about an NFL linebacker last year. That one was pretty easy to reject. ;) Edit: and consider this a first draft / rough outline of ideas. We're getting our CFP page ready now, it's going to have tons of resources on writing good proposals. We'll also be offering submitters a round of feedback this year, to make sure we give everyone a fair shake (except if you submit a talk on an NFL linebacker. Instadecline.) Keep in mind that extremely late submissions (read: the day of the deadline) will probably not get as good feedback as those submitted early.
This is amazing! Is there any way to use CSS in here?
To newcomers in Elm, it may not be very obvious that it does not work, or that it "makes no sense". Type alias Records DO come with their own constructors in Elm, so it is not strange that one may think "if it works on other constructors, why not on record constructors". In any case, I thought it useful to point out that one cannot combine Records, literals, and case expressions in Elm. Your explanation "* pattern matching works by matching a value to a value-shape: a list is matched to a list shape, a sum type is matched to a constructor shape, a tuple is matched to a tuple shape… and a record should be matched to a record shape aka " Is really helpful. Most types let you combine the pattern with literals, like `( 14, x )`. But Elm does not have a way to do that with record types. Thanks for clarifying!
I love it. A lot better than I expected from a first project. I didn't check the code but just by using it. Minor bug report: it seems to show Auckland and Wellington too far North. I'm looking on a mobile device. Also no flights to Melbourne, Brisbane, Perth etc. from Sydney.
yep! just add it to the html document in a `&lt;style&gt;` tag or bring in a file with a `&lt;link&gt;` tag
&gt; Using webasm would require implementing garbage collection so... no trivial task. You're thinking asm.js. wasm will have garbage collection, it's just not done yet. 
Elm has strict evaluation and no cyclic data structures, so garbage collection actually is not that hard. Smart pointers should suffice.
Is there a good starting guide on elm with websockets? Specifically I'm doing this with a phoenix backend.
Have you seen http://package.elm-lang.org/packages/lukewestby/elm-string-interpolate/latest and http://package.elm-lang.org/packages/lukewestby/elm-i18n/latest note the second needs to be updated to 0.18? I think your experiment is cool. Although I think there might be a nice way to do it in pure elm.
Thanks! Good references. The first is interesting but doesn't handle full ICU internationalisation syntax. I have limited experience but I'm quite keen to keep with that syntax as I assume it is well designed for the purpose. I have seen elm-i18n and reference it in my readme. It is essentially and understandably abandoned in favour of a more type safe approach. Thanks again!
My first elm (and phoenix) application uses websockets. You can take a look at https://github.com/michie1/wrs_elm or if you want I can tell you a bit about the workings.
Hello all. Nice to meet you. Why **onClick** is triggering **onSubmit** in form? The code is in https://runelm.io/c/jer. As you can see clicking button always returning "Submit". But if you see the debugger, it's returning "Click" first then returning "Submit".
I only get "Click", no "Submit". In Chrome 56. But do you need to wrap your fields in a form? It seems like more grief than it's worth every time I've done it.
Thank you very much for caring about making elm better! :) Also, that site looked pretty insanely good to me! Very nice choice to use typeform!
Smart pointers seem like an awful lot of overhead for an FP language. You'd probably want a generational collector 
How do I upload a file and send it through HTTP? I read somewhere that elm doesn't support that yet. There's the elm-ui library that uses native Javascript to prepare the file data, but I was wondering if there was a more straight-forward way. 
It's not really possible to properly finish this if you're not using Elm: "How serious is your use of Elm" does not include the option "I don't use Elm", likewise for the question about elm-format.
welcome to the elmluminati!
**Update** - Finished the app now to match TodoMVC implementation. I've created my first elm app [elm-todo](https://github.com/grierson/elm-todo), however I would appreciate some feedback on how it could improved. For example, I am unhappy with the Main.elm/filterTodos implementation as it takes a Todos.Model which stores the Add todo input field in addition to the current todos, causing more data to be passed to the function then needs be. Secondly, it causes the issue of having to explicitly specify the todos whereas I feel that it would be more pragmatic if just the todos were passed. Visibitity.All -&gt; todos Visibitity.Completed -&gt; List.filter .completed todos Visibitity.Active -&gt; List.filter (not &lt;&lt; .completed) todos *NOTE - I just basically followed the [Redux documentation](http://redux.js.org/docs/basics/ExampleTodoList.html) to implement this todo app.
Thanks for your reply. Weird i'm testing it in Chrome too. The button is for adding item to cart form.
 onInput (UserMsg &lt;&lt; SetPassword) Holy cow, how do I only learn about this now? This literally solves all the dilemmas I was having in terms of code splitting and organisation without any of the downsides of "components". Thanks for sharing.
Looks gorgeous!
Then an issue against the elm-format repo might be appropriate, if you're so inclined. :)
I see. You can always have ports to access those APIs but I don't know any specifics regarding that, sorry :(
The fade in is imo a bit annoying. When it's done fading in and animating it seems to redraw and then the font weight increases a bit. Safari.
Argh, I thought I had removed that... probably just need to override the `-webkit-animation` or somesuch. I don't have time right now, could you please open an issue on the repo?
Done, good luck with the presentation!
When I have questions like this I like to search github for examples of projects. I typically try to envision the page design I'm interested in, and then search by the language extension and libraries used
Thank you for the compliment, it made my day. 
Could you please open this as an issue on the repo? I don't want to lose it.
https://github.com/BrianHicks/elm-subreddit-theme/issues/1
Thanks for the tip! Will subscribe right away.
From my understanding elm dev is only for people who need help with their project. This is on the other hand question / suggestion so I think reddit is appropriate place for it. 
[removed]
Is there a good way to get Elm to work on a network that isn't directly connected to the Internet? The default Windows installation tries to access package.elm-lang.org for even the most basic operations.
Would be sweet if all elm packages came with an ellie example on the docs page.
* worth it: yes, it is probably worth it to learn elm, independent of if you actually use it, just for the fact that its an extremly simple functional programming language, and learning it helps you structure your code diffentently/better even in other languages. * small projects: i would argue yes, there is no reason why it would not, and its super easy to write small projects in it. * animation: packages.elm-lang.org has a search function. 
Learning Elm will improve the way you write React applications anyway, whether you end up using Elm for production apps or not. So it's worth learning just for that. Elm having a smaller ecosystem and being even more incompatible with the browser environment will give you some challenges you'd not encounter in React or jQuery, so you should be prepared for some things that used to be easy now being hard and some things that used to be hard/impossible now being easy. For short-term projects adding predictability in terms of how buggy your application can get is important, Elm will help make your ability to estimate the amount of work involved in something more accurate. For animation I recommend http://package.elm-lang.org/packages/mdgriffith/elm-style-animation/latest 
That would be sweet, so I've added one :)
Read about [The Elm Architecture.](https://guide.elm-lang.org/architecture/) There is no more FRP in Elm. You have one state, one update function and one view or way to render the state as DOM. Subscriptions are like automated drivers that put messages into the main message loop based one some logic that involves the current state of the model. (e.g. you can have a subscription that puts messages every 30 seconds if the model has some flag turned on. when the flag is turned of, the subscription stops) Please be aware that the information you find on Elm can be seriously outdated. The language evolved a lot in the last two years. 
&gt; TL;DR: When you work on shorter projects and need to be able to do animations and page transitions, is Elm worth learning? Definitely worth learning but don't lean too much on Elm in the beginning. Don't try to do everything in Elm in the shorter projects. Just use it like one of the other tools, similar to how [NoRedInk approached Elm](https://www.youtube.com/watch?v=3FNKaGm3gk0). As time goes by, you will have your libraries of Elm code and you can delegate to Elm more end more responsibilities. 
Have you looked at F#/Fable?
Is that the whole line or does that line start with PATH=...? What happens when you run `which elm-format`? What OS are you using? Finally, did you launch Sublime with an icon or with `sub`? 
Amazing !
This is so amazing to listen to. Keep up the good work, can't wait for the next episode
This is possibly a stupid question, but is there a nice/robust way of getting the XY of the svg? (for e.g. in case of window resizing)
Thanks! I think I'll have to read about ports, then.
You may be right, but I don't see why it should be much overhead to keep a reference count in the objects.
I'm working on [elm-benchmark](https://github.com/BrianHicks/elm-benchmark). The high-level API is gelling nicely! I'm hoping I can release the first public version this week or next.
In my playground app I used a String type for dates and I'm changing that to the Date type. In the meanwhile I'm making a pull request to improve the date format of my native language for elm-date-extra.
Thanks looks interesting. My reservation is with any JS transpiler from a functional language is there is a mental overload to thinking about how your code is getting compiled. I.e. it is a leaky abstraction, especially when using frameworks. 
This library is awesome and just what I was looking for! Thanks!
I've been making [Game of Life](https://github.com/BobWhitelock/elm-game-of-life) in Elm for a little while now, with some extra features like time travelling. I'm quite new to Elm and this is the most complex Elm program I've made so far, so it's been useful for experimenting. If anyone has any feedback or suggestions for anything then that would be much appreciated. I should probably start making something new soon as this is pretty much finished, but I've recently just been enjoying adding new features and loving how easy Elm makes this! 
Hey, I made a thing which is pretty similar. http://package.elm-lang.org/packages/Logiraptor/elm-bench/1.1.0 I haven't had a chance to update it for the latest version of elm. 
Actually I've worked on something similar to what you propose this weekend: https://github.com/gdotdesign/elm-html-styles. It uses native stuff with CSSOM to provide a virtual-dom like system for the sytles of elements.
&gt; One reason why not to do this is that it's considerably more computationally expensive (and memory-intensive) than doing it at build time and generating a static stylesheet. Maybe that wouldn't matter at first, but what about as pages grow in complexity? And what about on mobile? &gt; How can one go about testing this? I mean, you mention that it is more computationally expensive but how much more? 10%? 100%? 1000%? 
I made http://package.elm-lang.org/packages/norpan/elm-html5-drag-drop/latest/Html5-DragDrop
Goodness. That's incredible work. Thank you for sharing it, this is gunna save me a whole heap of time. Also very interested in elm-spec, great stuff!
Thank you! I've some comments on the Ui.Chooser is you're interested :) 1. Is there a way to prevent the dropdown menu from hiding when user scrolls down\up the page? Like hide on outer click\select only. 2. What's the `id` field purpose in the `Item` type alias? 3. No clear way to make it an async typeahead. `onInput` handler combined with `searchable` could help. Maybe it could be a separate component with different `value` field of type `Item`. Another special `thank you` for using 2 spaces ;)
You're welcome, I'm doing this for people to use so any feedback is welcome :) 1. It's that way because of some specific interactions of `position: fixed` elements, which the drop-down part is. I can go into specific details if you like. 2. The `id` field is just a placeholder at the moment, it will be used when the list is converted to use `Html.Keyed`. 3. There is a plan to separate it into different components to reduce it's complexity (Ui.ChooserSingle, Ui.ChooserMultiple), and one could be that has the async functionality.
a small stylistic comment, I would use `update` instead of `set`. `set` is associated with mutation and this is not what's happening. 
1. To break it down: * `absolute` cannot be used in cases where the element that has the drop-down is located in a scrolled element (not `overflow: visible`), having a `position: fixed` element there will not be clipped * using `fixed` with `getBoundingClientRect` is really convenient because they share the same coordinate system * if you are interested you can checkout out the source: https://github.com/gdotdesign/elm-ui/blob/master/source/Ui/Helpers/Dropdown.elm 2. `value` could be used but `id` is more explicit 
Good point. `set` may indeed suggest in-place-mutation, which is not what's happening of course. I use `set` instead of `update` in my own code, because I use the `update` naming for other helper functions, with typical signatures of `updateSomeThing : SomeSubMsg -&gt; SubModel -&gt; SubModel`. So if I encounter a `set`, I know it is related to an immutable record-update. But if I would start again, `update` probably is more Elm-y.
I think `set` is okay *because* Elm is immutable - there isn't much room for confusion. I have used `set` naming with immutable.js, assuming that when dealing with immutable.js there is no mutation.
Is there some fundamental reason why the syntax couldn't be something like: { model | currentMovie.rating = newRating } It would be so much more convenient and I can't see any real reason why the compiler would not be able to figure out the necessary details behind the scenes.
TL;DR My understanding is that Evan prefers modular structures, with explicit (boilerplate) (immutable) getters and setters over syntactic sugar. There is a Focus library ([here](http://package.elm-lang.org/packages/evancz/focus/latest/Focus)) made by Evan, for updating nested records. The docs there include: &gt; Warning! It is possible that the concept of a Focus is harmful to code quality in that it can help you to be lax with abstraction boundaries. &gt; By making it easy to look deep inside of data structures, it encourages you to stop thinking about how to make these substructures modular, perhaps leading to messier architecture and some extra conceptual complexity. It may also make your code slower by encouraging you to take many passes over data, creating lots of intermediate data structures for no particular reason. Use with these risk in mind!' The README on that library also contains this: &gt; The deeper problem may be that lenses are best when they are bidirectional, whereas a Focus is only in one direction. The issue is then that making proper lenses is not necessarily possible without changing the language itself. &gt; In any case, I have yet to see any code that follows The Elm Architecture that gets better by adding this library.
I'm working on a turn based multiplayer game, with mqtt. https://elm-dice.herokuapp.com/ 
Update sounds like mutation just as much to me...
Let's say you have two 'pages' in your app. They each have independent state, care about different messages, and don't need to actively communicate to each other, so this is a great place to split them off into separate pieces. One way of doing it (which maintains the state of each page separately for sake of simplicity of the example): update : Msg -&gt; Model -&gt; (Model, Cmd Msg) update msg model = case msg of PageOne pageMsg -&gt; let (newPageOne, cmd) = PageOneModule.update pageMsg model.pageOne in ( { model | pageOne = newPageOne }, Cmd.map PageOne cmd ) PageTwo would look similar. As the ElmTown discussion suggested, be wary of using this pattern without considering if it is the right thing for your code. If the two 'pages' needed to interact, then this pattern quickly gets in the way, but since they don't it allows for elegant separation of concerns.
Immutable values from a larger context are a bit of a gray area here. Conceptually, we *could* pass these values into the functions as arguments. This is because for the execution time of the function, the value does not (shouldn't) change. It does cause problems in implementing certain sorts of compiler optimizations if the compiler isn't aware of the implications of this function call, so there is a bit of a problem there. The benefit of implementing it this way is you don't need to actually pass around the environment variable, which can be a bit problematic. As for the implementation, native code can certainly break the purity of Elm and it is a major reason why it requires special authorization to be in the official repository. You are right to be skeptical, but sometimes we have to balance purity vs. pragmatism.
&gt; A few months ago, I decided I was going to learn Haskell. &gt; I’m finally able to read through Purescript/Haskell source code. Damn, I wish I had your brain :)
I'm pretty curious to know how often you felt like you had to reach for more "advanced" design patterns. I've more than once felt friction (and boilerplate fatigue) when trying to implement things the Elm way instead of reaching for monadic types more common in a certain other language. (Worse still, I'll sometimes end up just using ports if I feel a line or two of JavaScript carries less mental overhead than 20 new lines of Elm boilerplate). I'd also be curious to read the nitty-gritty code of how you handled mount commands (especially for page transitions) and dealt with refreshing the global cache of your app from subcomponents.
&gt; Until now I was sure I can safely assume there is no way to "sneak" some values into running application and everything I need should be in main model. &gt; Am I missing something? Once you go Native, you can violate the Elm promises. Sometimes I believe that the rules can be broken but a lot of care needs to be taken and there is very very little guidance here on what constitutes a reasonable bend of the rules. One practical example is Debug. `Debug.log` has an obvious side-effect of writing to the console. It should be a Cmd of some sorts but this would make it utterly impractical. Breaking the rules here is (in my view) OK. Another practical example that I thought about would be a function that takes a stylesheet and some Html and mounts a CSS stylesheet to the head. Such a function would have practical value and one could argue that the the result is the same every time but it is easier to misuse than Debug. You can get into situations where different parts of your program could overwrite each other's side-effect and have different output. Another practical example would be defining a custom element as an `Html.node`. Behind the scenes you need to make sure that the first time that node is created you register the element so, you need that side-effect and you need to keep state behind the scenes to make sure you don't register it a second time. Such a function, again, could be easily misused but it has practical usefulness. In the case you pointed out, I think it might be the case of such a pure enough function. If you only call `Ui.Helpers.Env.get` once in the entire execution of the program (let's say in the init), you should be safe enough. Of course, it would have been better to make it a Cmd and thus make it explicit that it will return different values but I guess the author chose otherwise. 
I think it's generally best to keep making applications, and when you run into a problem in real life, you may be in a good position to write a package. The best packages are created by people who have real experience in a particular domain. That means you at least have lots of real examples so you have a good intuition of how your API design would feel in practice, but I think the best packages also include some mentorship from more experienced package authors. And ultimately the goal is *great* packages, not *more* packages. For any particular domain, I want 1 great library, not 10 average/bad libraries. I think [this talk (at 14m05s)](https://youtu.be/DSjbTC-hvqQ?t=14m05s) outlines the outlook here most clearly! After you watch that section of the talk, there's also the [projects page](https://github.com/elm-lang/projects/) which outlines some ideas.
Done. https://github.com/gdotdesign/elm-ui/issues/63
&gt; I think the best packages also include some mentorship from more experienced package authors. Is there a list of experienced package authors that might be open to mentoring? &gt; And ultimately the goal is great packages, not more packages. For any particular domain, I want 1 great library, not 10 average/bad libraries. Do you have a few examples of packages that you consider to be the kind of quality that you would want in the Elm ecosystem? Do you have a few packages that can be partially used as examples? e.g. packages that excel in API design but maybe lack in documentation/examples/testing and the other way around, packages that excel in how they are constructed but maybe need more more thought/maturity into API design. 
I've written about it at length before but fundamentally there's a problem with a lack of introspection. Could be dynamic or compile time reflection, doesn't really matter (although I'd prefer the latter in most cases). This shows up in the crazy amounts of error prone boilerplate one needs to write for example when converting a union type to/from a string. 
Breaking down elm app to multiple module. You really have to give a lot of thought to make sure you design good data flow inside the app. However, when you figure out, Elm let you change the code without much hassle. 
In the interest of clarity, where do you experience the most troubles with this? Is it at the borders (communicating with JS or getting/posting data to a server)? If Elm would have automated serialization (kinda like port automated serialization on steroids) would most of this pain go? 
Apparently it's still a problem. &gt; On October 27 (less than two weeks after the Google announcement), John Mueller, on his Webmaster Central Hangout, [confirmed](https://www.youtube.com/watch?v=i_xnKznRNCc) that Google indeed still has problems with Ajax. [Source](http://searchengineland.com/can-now-trust-google-crawl-ajax-sites-235267) Also I may be wrong but it [looks like](https://github.com/elm-lang/virtual-dom/issues/29) server rendered elm is just to render the initial html with the first database call in the server. It will still be a "dynamic" single page app with AJAX calls that you can only navigate with javascript.
I looked at just trying to get a select box to be type safe based on a union type and that was impossible. After that experience I decided to stop researching Elm, at least for a while. Serialization helps partly but I still need to be able to enumerate (simple) union types. "Deriving enum" from Haskell or OCaml does this. Another reason why I started to look more at OCaml. 
1. Interop. `Reinvent the wheel or die integrating react component` attitude makes Elm almost impractical in day-to-day tasks. I might be wrong, but Elm should push it's benefits like guaranties on business logic and data handling, but provide a sane way to interoperate with the **huge** JS ecosystem. 2. Haskell-influenced docs, libs. `You don't understand what's going on here and need examples? Are you stupid?`Well, yeah, I guess I am. &gt; merge &gt; : (comparable -&gt; a -&gt; result -&gt; result) &gt; -&gt; (comparable -&gt; a -&gt; b -&gt; result -&gt; result) &gt; -&gt; (comparable -&gt; b -&gt; result -&gt; result) &gt; -&gt; Dict comparable a &gt; -&gt; Dict comparable b &gt; -&gt; result &gt; -&gt; result Those are daily issues. Not touching the `meta`.
Parsing Expression Grammars, PEG.js for Elm, but that's only because it would be more efficient for the project I'm working on but I'm too lazy to do it… Don't think many other people would find it useful…
1. syntact sugar for setters (ex: $name : String -&gt; Model -&gt; Model) and other ways to avoid boilerplate. 2. An official way to do styles without using less/sass/css and preprocessors, only Elm, would be cool. (elm-css needs to be compiled too :c ) 3. Better Svg api 4. An message, view or an mechanism to do something when Elm crashes on runtime. ``` model |&gt; $state Playing |&gt; $timestart model.time |&gt; $current levelInfo.level |&gt; $info.name "Gabriel" |&gt; noCmd Imagine creating a form with more than 20 fields. It would be +20 type constructors and +20 branchs in the update to implement. With setters, the boilerplate to update many fields would be removed. type Msg = UpdateField (a -&gt; Model -&gt; Model) a update msg model = case msg of UpdateField setter value = setter value model ! [] view model = div [] [ input [ onInput &lt;| UpdateField $firstname ] [] , input [ onInput &lt;| UpdateField $lastname ] [] , input [ onInput &lt;| UpdateField $nickname ] [] ] 
I'm new to this but my understanding is there is not a server side rendering story for elm yet but it is a focus for the next release (I think!) I think that the same concerns apply to any site where the content is in javascript. A while ago Google announced that it would start to run javascript when crawling the web so maybe it isn't such an issue from the perspective of Google but I imagine it will still be considered best practice to use proper server side rendering when support lands.
I would just like toss my vote for * An official way to do styles without using less/sass/css and preprocessors * syntact sugar for setters 
I'm curious about what the preferred approach for selectively including different bits of Html in a view function. I tend to end up in situations where I have a `div` which has three different children and some rules for when to display each one. So I end up with: div [ class "form" ] ([ h2 [ class "title" ] [ text form.name ] ] ++ (locations model) ++ (products model) ++ (other model) ) But that means that the 'locations', etc, functions need to return a list. When they should return single elements then it becomes harder or you have to return single element lists or empty lists or you can make everything return a maybe and then do a `List.filterMap identity` over the whole lot... I don't know if I'm being clear but I assume it is a common experience that others will have had. Any tips on the nicest pattern to apply in these situations?
I think I could write something on this. I promise to post it here on /r/elm. Maybe Friday? 
&gt; An official way to do styles without using less/sass/css and preprocessors, only Elm, would be cool. (elm-css needs to be compiled too :c ) You can use `elm-css` with a `node "style"` approach as documented [here](http://faq.elm-community.org/#how-can-i-load-css-or-other-resources-in-elm-reactor). You can also move to pushing the generated stylesheet directly into the head through a port if performance becomes an issue. 
Implement it and benchmark it in a bunch of scenarios. :)
Manually deciding how to encode and decode a model to and from JSON. In Go, any data structure can be converted into JSON by doing json.Marshal(...). Converting it back from JSON is as easy as json.Unmarshal(..., &amp;v) In Elm, you have to explicitly define the Json Encoder and Decoder. In particular, it's something that should be symmetric. It's very easy to make mistakes in either. It's easy to leave out fields in the Encoder. It's possible to write a Decoder that doesn't match the Encoder. A mismatch isn't caught at compile-time and when you encounter the error at runtime, it tends to be difficult to debug. What's particularly infuriating about this is that there's an internal JSON representation of the model but unless you use Native, there's no way to use it.
I disagree with you on Elm having "Haskell-influenced docs." They're both minimal, but I'd say the rational for this on Elm's part is the exact opposite of Haskell's. Haskell docs usually lack a 10,000 foot overview, but leave a breadcrumb trail for understanding through deeper reading. Elm docs don't have that breadcrumb trail, but they do have the 10,000 foot overview. Both are essential, and I find it a little frustrating how frequently I turn to Haskell docs when I'm stuck with Elm problems. As a broader point, I know that a primary goal of Elm is to be accessible to users who lack the theoretical foundations of functional programming. Still there are areas of Elm that I don't think I would ever feel comfortable with had I not had some *a priori* understanding. Elm tries so hard to be "simple" that it elides explaining how even fundamental concepts work (like certain m-word influenced control flow computations). Honestly, if I'd never heard of Applicative, `Json.Decode`'s suite of `map` (formerly `object`) functions might have been the last Elm documentation I ever bothered to read. I wouldn't just gripe about this if I hadn't noticed some pretty strong pushback from the top on this very point. I remember one (talk? conversation?) where Evan seemed to give the impression that the docs were his thing and that he wasn't particularly interested in criticism there. To be clear, Evan's done an unbelievable job with the language, and I deeply respect his reasoning and can-we-do-better attitude. But now that I've learned the basics, I feel like there's no more "official" material to turn to to understand the language.
Maybe I'm wrong on mentioning `Haskell` at all here, sorry. The thing that I've seen before in Haskell docs *only* is hiding the function param names. Just imagine, you're looking into the `Dict` docs, found a function that kinda looks like what you want - `merge`. But what is there in the docs for you? &gt; merge &gt; : (comparable -&gt; a -&gt; result -&gt; result) &gt; -&gt; (comparable -&gt; a -&gt; b -&gt; result -&gt; result) &gt; -&gt; (comparable -&gt; b -&gt; result -&gt; result) &gt; -&gt; Dict comparable a &gt; -&gt; Dict comparable b &gt; -&gt; result &gt; -&gt; result WHoa! That's a lot of params. No examples. But you're reading the docstring. And it looks helpful, but your newbie's head starts to hurt, since you're trying to figure out each of the params and not to loose the track of *the actual problem you're solving*. And then each of the params's params(first three functions) catch your interest. Scene 2: you're searching github.com for `language:Elm Dict.merge` since there could be an examle of usage. And there is! Nice! But you're still not sure what's what and why. Scene 3: you're browsing the elm-lang/core on github looking at the `Dict.merge` implementation. Here's a `one-more-line` that's missing from docs: &gt; merge leftStep bothStep rightStep leftDict rightDict initialResult = Scene 4: Everything is illuminated! Now you know exactly what, why and how. Of course, you've lost the track of your original task as a side-effect of this investigation. Next time you'll solve this one easier. Or not 🤷‍♀️ PS. Sure, eventually you'll find a `Dict.union` and it will satisfy your daily needs just fine :D
Have you given [style-elements](http://package.elm-lang.org/packages/mdgriffith/style-elements/latest) a go?
I understand why the Elm/NRI team doesn't encourage Native modules, but in the real world JS interop is a necessary evil, and sometimes ports are really inconvenient and ugly. I really wish that: 1. There was a way to install packages with native modules from 3rd parties. Maybe from `git://` URLs like NPM? Or maybe behind an `--unsafe` flag or something? 2. The Elm/NRI team wasn't so condescending/patronizing when you ask about Native modules. The whole "*there's probably a better way that you haven't/aren't smart enough to think of*" attitude is really off-putting. 3. There was any actual documentation on Native modules. Having to dig through `elm-lang/core` for examples gets old.
How you handle authentication/authorization and sessions would be interesting.
This is really nice (especially the filters on recipes page). Is the code up on github?
1. Nice! I didn't know about that, I will definitely have to try that out. 2. I also agree that Native modules should be discouraged, and usually there **is** a better way to do things, **however** some things simply must be implemented in Javascript. For example, any mapping library, analytics, certain UI components, etc. In these cases ports are fine for special cases, but if you need something reusable then ports are not a great solution. I've heard of web components as an alternative here, but [realistically](http://caniuse.com/#search=web%20components) those aren't usable without a bunch of polyfills.
Sorry no, but there will be code examples in the write-up.
&gt; I've heard of web components as an alternative here, but realistically those aren't usable without a bunch of polyfills. Realistically all you need is a little bit of Custom Elements support that can be provided by a very small polyfill like: https://github.com/WebReflection/document-register-element With that in place you can mimic web components to an acceptable degree with everything implemented in Elm in a way that's very similar to The Elm Architecture. 
What is wrong with something like this? ``` selectBox : (a -&gt; msg) -&gt; (a -&gt; String) -&gt; List a -&gt; Html msg ```
You can use `text ""` as an empty element. So then you can do things like `if hasLocations model then (locations model) else (text "")`
A basic [TodoMVC](https://github.com/grierson/elm-todo) app using [Rogério Chaves'](https://medium.com/@_rchaves_/structured-todomvc-example-with-elm-a68d87cd38da#.98ubcgdaf) approach for scaling an Elm app.
Did you just watch the videos or did you work through the exercises as well?
I did not work through the exercises, but I've referred to the exercises GitHub repo to inform a lot of my own code/structure.
You mean "just use a list"? 
(1) Boilerplate code: Want to an accountNumber field? then You need 1. an accountNumber field in your model, 2. an AccountNumberChange message constructor, 3. a case in your update function to handle the AccountNumberChange and then 4. a mention of accountNumber to represent that update. Finally you need to 5. get that value in the view and 6. also wire up the AccountNumberChange message to an event. If it is a child control, its worse! (2) No interop with dom-changing controls. The calendar control is a solved problem, but you can't integrate with your favourite one due to the virtualdom. 
Yes it's a bit tricky though. `elm-lang/http` only supports progress events for downloads but fortunately I needed upload progress myself a while ago so I made a fork and created a pull request for it https://github.com/elm-lang/http/pull/17. You can use my fork `gdotdesign/http` at version `1.0.1` until it's merged (if ever) with the same API as the download progress. If you need I can set up an example, like the https://github.com/gdotdesign/elm-ui-examples/tree/master/file-upload one.
Basically I mean what [this article](https://medium.com/@debois/elm-components-3d9c00c6c612) states. Maybe OP didn't used TEA that much, maybe he didn't try to write reusable components and went with the _reusable functions_ approach. Having not written myself a sufficiently large app in Elm, I'm curious about it
[removed]
After logging in, I noticed something else. I would reconsider putting each post into a scrollable text box. It makes it frustrating to scroll down the page with a mousewheel. 
I'm surprised how little documentation there is on this topic. Most of the tutorials I have followed ([evancz/elm-todomvc](https://github.com/evancz/elm-todomvc/blob/master/Todo.elm), [Pragmatic Studio](https://pragmaticstudio.com/elm), and [Elm in Action (So far)](https://www.manning.com/books/elm-in-action)) are all single file projects. The only resources I have found which explain how to scale TEA are [Structured TodoMVC](https://medium.com/@_rchaves_/structured-todomvc-example-with-elm-a68d87cd38da#.oho7wn4kl) and [Redux tutorials](http://redux.js.org/docs/basics/ExampleTodoList.html) 
[2] I would love an Elm equivalent to [Clojuredocs](https://clojuredocs.org/).
I agree, it's also quite annoying on mobile. Previously it was a fixed height box and the overflowing text was just hidden. I've also tried just making all the text fit (variable height). The scrolling will probably be replaced by any of those alternatives in future commits.
You can have the deserializer return a Result. That's not really a problem API wise. The problem, as I see it, is that you are forced to write Json decoders even if the runtime knows exactly how to represent the datatype and you don't really care. 
[removed]
So, at work I have published your article on my room's chat. After 5 minutes everyone was competing who's on higher level :D At the end we agreed the winner would be a first peron on level 40, hehe
What is the functionality that you want from Clojuredocs? Isn't it somewhat similar to [elm-search](http://klaftertief.github.io/elm-search/) ?
Dropbox. Sync your webapps
I think there is a possibility that the piped setters, when there are more fields, could be much slower, because they create new object on each step. What about using mappers, like this: type alias Movie = { title : String , director : String , rating : Int } type alias Model = { currentMovie : Movie } mapCurrentMovie : (Movie -&gt; Movie) -&gt; Model -&gt; Model mapCurrentMovie mapper model = { model | currentMovie = mapper model.currentMovie } … update : Msg -&gt; Model -&gt; ( Model, Cmd Msg ) update msg model = case msg of SomeMsg -&gt; let newModel = mapCurrentMovie (\currentMovie -&gt; { currentMovie | title = "Some Title" , director = "Some Director" , rating = 10) model in newModel ! [] So there is no need to define setters and as…ins for each leaf property. The mapper can also be used for opaque structures.
That's perfect, thank you. I didn't know about elm search. &gt; What is the functionality that you want from Closure docs Mainly the list of community examples you find under most operators, I find that is the main thing that helps me grokk how a function works.
&gt; Absolutely, JSON decoding is my single biggest source of spending hours googling and reading the docs, unexpected bugs, eating errors, badly formatted errors on my JS console, and general wasted time in my code. There is so much boilerplate to create to interact with any backend feature, and Json.Decode is a very difficult library for an FP newbie at the best of times. This will save you lots of time: http://noredink.github.io/json-to-elm/ Also, prefer the pipeline way to the Json from the standard library.
Eventually, part 3 of Elm in action should cover this: https://www.manning.com/books/elm-in-action We still have some waiting to do until it's written though.
General signature: `$name : a -&gt; {b | name : a } -&gt; {b | name : a }`. Might need to use `@` because `$` is used as a delimiter in the generated JS, but yes this might be possible.
There is parametric polymorphism: List.reverse : List a -&gt; List a If you want to use that on TEA, that would be something like: init : Model a update : Msg a -&gt; Model a -&gt; (Model a, Cmd (Msg a)) view : Model a -&gt; Html (Msg a) type Msg a = DoSomethingWith a | ... type alias Model = { thing : a , ... } So that people can use it with: usage1 : Model Int usage2 : Model (String, Float)
I built this [trivial app](http://github.com/tulsidas/round-robin-elm) to generate round robin fixtures
It reminds me of the childhood game that I used to play. One problem is with the timer, the player can just wait and skip their turn, so game just stalled forever. Anyway amazing game !
Oh, I think I was playing with you as "Ehh!" I did skip my turn a few times by accident because the timer ran down while I was thinking. Once or twice, I chose in the last second and the server didn't pick it up. Anyway, ggs :)
Thank you! Yes definitely. I think It would be good to have a random line selected when timer runs out.
Thank you! &gt; I might have actually been in a few games with you, if you were going by "Roman" Yes :D &gt; It would be good if skipping your turn randomly drew a line somewhere, so you can't just force other players to make a bad move by not making a choice. exactly what I am thinking &gt; If someone doesn't make a move for a while (maybe 3 turns?), it would be nice if they were kicked to save time. yes need to think about it &gt; This isn't as muc a suggestion as a note, but a few times I made a choice in the last second, it showed up in the game, and then disappeared. I can only assume the server didn't register it in time and behaved as if I skipped the turn. Yes I noticed that. The reason is that the actual timer that decides to advance to the next player is run by the game owner. If you click and the timer was already running out at the owners browser your click is swallowed. Need to change it.
I was thinking about this problem. I think a hardcoded list and a List.map might be good enough. If you update the list, everything else will update. 
You should explain what you mean by "model polymorphism" and why you want it (i.e. what problem you hope it solves). But, broadly speaking, it is usually not useful to give a TEA model a type variable. It may include many other types which have type variables (and define what those are). But you generally should be certain about what your model is. It's possible to write view helper functions that accept the entire model but can only access a defined subset: ``` displayName : { a | firstName : String, lastName : String } -&gt; String displayName {firstName, lastName} = firstName ++ " " ++ lastName ```
Documentation. If the Elm dev team took off just one release cycle to work exclusively on top quality docs it's one of the best things that could ever happen. - Rex
Audio! If you could port this simple JS library, it's all we'll ever need: https://github.com/kittykatattack/sound.js 
In one of the Elm Town episodes they were talking about this and I think the suggested solution was to use [`Test.filter`](http://package.elm-lang.org/packages/elm-community/elm-test/3.1.0/Test#filter) for now. Edit: Yup, it's episode 8, [Testing in Elm Town](https://elmtown.github.io/2017/01/02/Testing-in-Elm-Town-Ep-8.html). The relevant discussion starts at 22:38. Edit 2: Uh, sorry, it's seems like they don't discuss this stuff at 22:38. Anyway, I know about `Test.filter` either from the Elm Town or the mailing list.
What problem are you trying to prevent by using union types? You could use a tuple with (Label, Id) or whatever. You could even make these types that hide their implementation (wrap a string, possibly with validation) and therefore have some guarantees around them. It just depends on what you want to accomplish. 
You could use a union type in your model type type Platform = Mobile | Desktop -- think of a better name Naturally you'll have to update this based on screen width. Then in your view function you could do view model = case model.platform of Desktop -&gt; viewDesktop model Mobile -&gt; viewMobile model Don't know if this is the best idea. Just my first thought so take it with a grain of salt. 
Maybe a command line option to run a single test would solve the problem of committing an incomplete suite?
The next version will include a `todo` function that allows you to describe an unimplemented test, and it always fails. That wouldn't help you here but it's similar enough to maybe consider the idea.
I know rspec lets you specify a particular file and line number to isolate a test. I don't know how feasible that is in Elm but it sounds like it would be helpful. I just thought of something: isolating a test will mess with the random seed distributing, so the test will have a different random seed when isolated vs. entire suite. (This will only matter when the seed is specified explicitly; if it always changes this is fine.)
This is how JUnit handles the problem. It works great in Java because almost 100% of Java developers use Netbeans/Idea/Eclipse or similar IDE and it all let you just run the test under the cursor. Same solution in in Elm will mean manually copy'n paste from editor to console. It is so much easier just to mark the test with some flag using nothing but the simple editor.
It seems the hard part would be determining which test was at a particular line number. rspec also has an `--example` option which allows you to filter the tests by name https://relishapp.com/rspec/rspec-core/docs/command-line/example-option. Implementing that with Test.filter seems straight forward. To make it easier to pin down which test you were choosing exactly you could allow a `--format named` option which printed the full name for each test as they were run (similar to https://relishapp.com/rspec/rspec-core/v/3-5/docs/command-line/format-option#documentation-format but with the names flattened rather than shown in a tree).
That sounds like a good way to implement what jediknight was talking about in the other comment. My goal would be to eventually have 2 completely separate builds so that I'm not sending unnecessary code to either platform.
This is great advice, thanks! I think "keep it incremental" is one of the mantras I keep seeing in Elm programming. Definitely sounds like the practical path.
That's really interesting! Seems worth considering for sure.
While I appreciate the sentiment, I too would say being able to run a single test is immensely helpful. The way we deal with the issue of committing such a configuration by accident on my current project (a JS/TS setup), is to have our linter (which runs in our delivery check) fail if it finds some word we have marked as forbidden. By marking fdescribe/fit/etc. as forbidden, we still get to use them during development, but we won't commit them by accident. I don't know how an equivalent setup might look in Elm, but I think the option of running a subset of tests is quite important 🙂
Just checked it out. All solid changes.
I think you should keep everything together but make two entrypoint point files that you'll compile separately. Then use the Google Closure Compiler with advanced optimisations (Elm supports that) to shake out code that's not called.
Elsewhere in the thread, somebody had the idea that isolating tests would cause the suite to always fail. Of course it would tell you that all the tests passed and the only reason for failure was the filtering. What do you think of this?
If you're asking how to update multiple fields of the model there's a { model | a=2, b=3 } syntax. However if you're doing a HTTP request you could have a union type that has States like: type RemoteData = NoData | Loading | Data d | Error e then just make everything else a view of that state. For instance the disabling of the button would only happen on the loading state. Is that what you were asking?
There was a thread here a while back asking if the elm team is accepting PR's that add examples to docs / beef up docs in general. Great response from community, silence from the actual maintainers. Pisses me off. Because no one is going to submit a PR unless they know it might actually be accepted.
The idea of an explicit `only` function in the source code, that causes a suite failure, seems to have broad support here. Let me float a few other options. These aren't necessarily mutually exclusive. * Each failing test prints out a shell command to run only that test, with the same seed as before. The test can be identified either by description (easy to implement but descriptions aren't globally unique, nor should they be required to be), or by a file and line number (more difficult, less reproducible if the file is edited, but exact if it isn't). * `elm-test --only-failures` runs all tests that failed the last time they were run. (This requires keeping state in the file system.) * `elm-test --stop-on-failure` (or similar) runs all tests until a (non-todo) failure is found. This could be combined with the above as one works through failures. * `elm-test --new` would run all tests that have never been run before. Running a subset of the test suite through any of these command-line options would not cause a suite failure, since it's exactly what you asked for and the source hasn't changed. I think these are all in line with being "helpfully unhelpful" instead of giving you the freedom to shoot yourself in the foot (e.g. rspec's pending and focused tests). Thoughts?
elm-benchmark is published! :D https://www.reddit.com/r/elm/comments/5wii9r/introducing_elmbenchmark/ I'm gonna work on some secret projects this week. I'm excited to share when I can!
My humble opinion: the `only` flag is easier to use for the scenario described in this thread at the beginning. It would solve the problem being able to focus on a single test (or test suite) and at the same time it would be safe, assuming the test would fail at the end. For the other use cases, the `--stop-on-failure` would be nice too: when many tests fail, the amount of errors is overwhelming sometimes. I can see some situations when I would be happy to use with that flag until everything is green again. 
I made my first native module this week: [ByteArray](https://github.com/bgourlie/rs-nes-debugger-frontend/blob/master/src/Native/ByteArray.js). Currently it exists inside the debugger I'm working on, but I may pull it out once I flesh it out, document it, and put it through its paces.
[removed]
This is really neat. Nice work!
Thanks!
I suffer from Elm's API calling process. From a http request to results/error control then to returned JSON, lastly result usability within elm. Something like this in JS: $.get( "https://api.github.com/users/nytimes/repos", function( data ) {//I can use data here already!}); Becomes this in ELM: https://gist.github.com/freakingawesome/7f86ed7683cfeeec4557 All of the apps that I have worked on have had multiple internal API calls. I could not even imagine doing a big project in elm. Each API request would need its own decoders, auth and a lot of boiler code to do something that should take moments to code. Also I do not like reloading dependencies for each elm.js file/component on a page. If I have a header and a footer both embedded to their own divs, and had compiled footer.elm and header.elm to js, they might contain the exact same dependencies. Why reload them? We should be able to double embed elm files across the page, with an init flag showing the location (this is a header or a footer).. 
Totally agree with Serializedrequests. It is not simple. Noredink json decoder is great! Does it work with more complex JSON like: {"foo":"cat", "bar": [ {"for": "dog"} ] }
So I have a list of records e.g. [ { id = 1 }, { id = 2 }, { id = 3 } ] and I need to retrieve the last record ID in the list and increment it. So my update would change the model to be the above plus { id = 4 } So two questions: 1) Since it's a linked-list would it be more efficient to turn it into an array first to access the last index? 2) I have no problem getting the last element, but every function I can find just returns a "Maybe" instead of an Int and I can't seem to increment it due to an error that says something along the lines of "LHS is a Maybe, expected a Number" 
&gt; force consumers to program in html rather than elm, which seems worse. I was talking about using web component in elm. Instead of going Native and implementing your own tricks, you could encapsulate the functionality into an external file and then use it in Elm through something like `myComponent = node "my-component"` This way you can program against that functionality using the standard `elm-html` API which is great IMHO. 
&gt; Each API request would need its own decoders, auth and a lot of boiler code to do something that should take moments to code. I don't like writing decoders either but, to be honest, I love the explicitness of error handling in Elm. I think that it is one of its most powerful features. &gt; Also I do not like reloading dependencies for each elm.js file/component on a page. I don't really understand what you describe here. Traditionally, if you have multiple Elm implemented components that share a lot of code, you bundle them all in a `elm.js` like `elm-make Header.elm Footer.elm Login.elm --output=elm.js` and then you use them var headernode = document.getElementById('header'); var footernode = document.getElementById('footer'); var loginnode = document.getElementById('login'); Elm.Header.embed(headernode); Elm.Footer.embed(footernode); Elm.Login.embed(loginnode); 
&gt; 1) Since it's a linked-list would it be more efficient to turn it into an array first to access the last index? Yes, it would be more efficient. Lists are useful when you do something with the whole list not with one of its elements. &gt; every function I can find just returns a "Maybe" Lists can be empty so, retrieving elements might fail. If you don't want this, you can use something like [List.Nonempty](http://package.elm-lang.org/packages/mgold/elm-nonempty-list/3.0.0/List-Nonempty) that has an API similar to List but without the Maybe. It does this by controlling the list creation so that it makes sure that there is always at least one element. 
Why can't elm expose a `getCurrentModel` function that simply returns the application model? The only way to instantiate any of the Html programs (beginnerProgram, program and programWithFlags) is to either give it a model or init (which then also returns a model). Elm can guarantee that `getCurrentModel` will return the model with no side effects and it can guarantee that it will never fail. A co-worker just recently built something in React/Redux where a deeply nested component (inside of loops and stuff) had to display something that lives in a different branch of our application state. It was a breeze with react-redux `connect()`. I was just thinking about this in elm, and the only way would have been to pass down the model to like 5 levels of functions. I'm not saying that it's a deal breaker, but I'm trying to figure out why elm couldn't do it, without losing any of its guarantees. A simple function with this signature `getCurrentModel : Model` That can be used like so: viewCourse : Course -&gt; Html Msg viewCourse course = let model = getCurrentModel in div [] [ text &lt;| (course.name ++ model.sessionUser.email ++ model.routing.currentUrl) ] This could come in handy in situations where you loop through categories, then loop through years, then loop through XXX then through YYY to finally display a course for example. If you decide to add something all the way down, you don't need to change all other functions to just pass down something they are not interested in themselves anyway. Am I missing something about how elm works under the hood, or is it just a design decision? Also what would stop anyone from writing a native elm package that does exactly this? How can elm guarantee that the update function gets the current Model as an argument, but couldn't guarantee that this function would return the very same Model? Thanks!
I'm working on a simple Progressive Web App right now. It is inspired by the Clear iOS app. https://github.com/hugobessaa/elm-clear. Wanna learn the ways of building PWA's with Elm.
All kinds of animation stuff! I'm working on [elm-curve](https://github.com/mdgriffith/elm-curve) with some much needed and appreciated collaboration from another elm fan(Ian, you on reddit?). The idea is to make an awesome interface for curves which can interconvert to svg curves. elm-curve will set the stage for elm-style-animation to do awesome stuff like animate along a curve/path, create animations that "auto draw" a path, and to be able to morph *any* path into *any other* path. I'm also toying with the idea of using elm-curve in order to capture any easing functions used in elm-style-animation so that an animation is serializable/exportable by the debugger. I published [elm-animation-pack](https://github.com/mdgriffith/elm-animation-pack) for helping to manage the boilerplate of having a lot of animation states. I'm not really 100% on if it's a good idea or not as it is essentially just a Dict for animation states with a convenient interface, but I figured I'd put it out there to see what people thought.
Much love for all the thinking about ergonomics that goes into your tools. :D I'm curious if you've given any thought to building a constraint layout engine in Elm. Seems like the next step from elm-style-elements to me. Some sort of Cassowary implementation might be useful!
&gt; Cassowary Thanks, man! :D It's been really cool watching your design and implementation progress on elm-benchmark. I can't wait to get some idea of how elm-style-animation performs! I had never heard Cassowary, it looks really interesting. I'm definitely going to check it out for ideas to bring to style-elements, thanks for the tip! 
Pure Elm: http://package.elm-lang.org/packages/evancz/elm-sortable-table/latest Web components: https://www.webcomponents.org/search/data%20table
&gt; Ian, you on reddit? I am indeed! It's been a fun collaboration, I think it'll end up with something pretty cool...
It's not a matter of ability, both of them have access to the underlying JS, both can do the same things. Oh well... maybe it's just my weird mind but I feel like Native is more seductive than JS that somewhat decoupled from the actual Elm program. 
Functions in Elm are pure. They can only give output based on their input. So getCurrentModel cannot be written in Elm. And that's the whole point! You know the input to a function explicitly. You know that viewCourse ONLY depends on the course parameter. This is what makes Elm what it is. Yes, you need to pass down the parameters. And that's a good thing when you try to understand what's going on in a year's time.
ad 1) I am not sure if converting a list into an array just to get the last element would be more efficient that just scanning the list, because crating an array out of list means the whole list has to be scanned anyway… ad 2) If something returns, for example a `Maybe Int` and you want to do something with that `Int` you have always two options: 1st is to unwrap the Int using `Maybe.withDefault` or `case … of`, in that case you have to provide some default value and from now on you are using integer, or 2nd option is to "stay" wrapped within `Maybe` and just map one Maybe into another, so you can hold and transform your values without unwrapping until you are at the very end. The 2nd approach has a benefit that in case of `Nothing` at the early stages, everything will be skipped, because mapping `Nothing` will just return nothing immediately.
Thanks for your answer. I get what you are saying but I'm still a bit confused. What about the following code, would you agree that it is pure? type alias ArbitraryRecord = { foo : String , bar : String } getArbitraryRecord : ArbitraryRecord getArbitraryRecord = ArbitraryRecord "fooValue" "barValue" viewCourse : Course -&gt; Html Msg viewCourse course = let arbitraryRecord = getArbitraryRecord in div [] [ text &lt;| (course.name ++ arbitraryRecord.foo ++ arbitraryRecord.bar) ] If yes, why couldn't we swap ArbitraryRecord for the current model that we gave to elm in order to start the app in the first place? We're not asking for some Task that could fail such a retrieving some DOM or anything like that. We know it's there, we know elm has it. Retrieving the current model CANNOT fail as we had to supply it to elm or we couldn't even start the program to start with. I fail to pin-point where it's different from the above example. What is the difference that I'm not seeing?
Thanks for your reply, I answered to norpan above about where my confusion comes from. Thanks for the info about Elm-UI, I'll have a look. Regarding the caching of functions, I did not realise that elm did it out of the box. I thought that they always run the view function and diff (shadow dom thingy). So you are saying that given the following signature `viewCourse : Course -&gt; Html Msg`, the function will only be run if Course actually changes? I can probably answer this myself with elm Debug, I'm simply asking as you seem to be knowledgeable on how it works.
[removed]
Don't we need u/evancz s code splitting release for it to be a prpl app?
The command lets you take actions, such as sending data to a port, websocket or an Ajax call. In order for the system to be type safe it must *ALWAYS* return a command, so in this case it returns Cmd.none which does well, nothing. But in some other branch of the case it might issue a command which does do something
See also: - [Infinite scroll in Elm @ StackOverflow](http://stackoverflow.com/q/35226037/2014893) - The [Intersection Observer API](https://jeremenichelli.github.io/2016/04/quick-introduction-to-the-intersection-observer-api/)
&gt; Elm guarantees that if you call a function f it will always give the same result if you give it the same parameters. That's true as long as you do not use native functions. Using native means you can get whatever you want, like current time or some environment variables (see Elm-UI). Use native wisely or not at all.
I wanted to avoid the concept of native functions. Don't use them unless you are making a library and encapsulate them in tasks or really really really make sure that they are pure. Using them to avoid passing arguments to the view function is not something I would recommend. It makes reasoning about the view functions that much harder, and it takes away the ability to use Html.Lazy and other optimizations.
Decode.succeed is what I would have used in the core library. Looks good to me! 
There's also this http://package.elm-lang.org/packages/elm-tools/parser/latest, written by Evan, and in my opinion, a lot easier to use. I still don't know how to use elm-combine, but with elm-tools/parser, I can pick it up and use it very quickly.
FWIW you can use https://github.com/mpdairy/elm-frontier to take advantage of the runtime's knowledge for some stuff.
[removed]
Looks great! Congrats :)
Others have covered the technical part quite well. I think in Elm you'll see this trade off a lot. Less ability to abstract things away for more explicit and bullet proof code. In Ruby and JavaScript you can create magical APIs that just make things that you want happen however that's a trade-off for clarity. I've rarely been impressed with how readable the implementation of some DSL or abstraction heavy thing. I do find it interesting that I haven't ran into your problem very much personally. Perhaps you're nesting too much? 
Yeah, I think that I get it now. This is when you'd use dependency injection in OO to avoid the whole situation where you have to set up a "world" for testing purpose. So if anything, instead of `getCurrentModel`, elm could implement some magic and always inject the current model when you add the `Model` type annotation. This would probably cause other issues with currying though, and on top of this nobody likes magic (aka "things you just have to know" (angular $scope anyone?)). Unless there was a special syntax for injected stuff. But even then... Conclusion: `getCurrentModel` is terrible, magically injecting the model is pretty bad too. This leaves us with only one acceptable way of doing it, which is the current way. Thanks for the clarification (and all others that helped me!). Much appreciated.
**Nesting data in models** My elm app is growing a bit and it is starting to feel natural to nest the data in the model a bit. I've tried to avoid it because updating nested data structures feels like it is a bit of a pain syntactically. Given that `{ model.nestedData | property = value }` doesn't work. But my model currently looks like this: type alias Model = { campaigns : List Campaign ... , page : Page , createCampaignName : String , createCampaignStartDate : Maybe Date , createCampaignEndDate : Maybe Date , createCampaignFilterLocationString : Maybe String , createCampaignActivityTemplateIds : List Int , createCampaignFocusListIds : List Int , createCampaignSelectedLocations : List Location , createCampaignErrors : Maybe (List ( Field, String )) , viewCampaignListFilterCampaignsString : Maybe String , startDatePicker : DatePicker.DatePicker , endDatePicker : DatePicker.DatePicker } Where all those `createCampaign*` entries are because I have an 'create campaign' form. I'm about to start adding another form for another thing and I don't want another ten top level entries in my model. I haven't seen any big elm code bases. Just small examples. I've heard Richard Feldman talking about having big models &amp; big update functions and it not being a problem. I've seen the warning in the [Focus library docs](http://package.elm-lang.org/packages/evancz/focus/2.0.1/Focus) and so get worried about using that. I found the [Structured TodoMVC example with Elm](https://medium.com/@_rchaves_/structured-todomvc-example-with-elm-a68d87cd38da#.qoi9fwicm) blog post very interesting and maybe that is the way forward but then the handling around merging the `(Model, Cmd Msg)` return from the sub updates seem awkward. I've looked into [Elm Return](http://package.elm-lang.org/packages/Fresheyeball/elm-return/latest) and [Elm Response](http://package.elm-lang.org/packages/etaque/elm-response/3.0.0/) and whilst they must help they don't seem to clean everything up completely. I'd love to hear about people's experiences and what direction they end up going in. Nested data? Nested updates? I understand that somethings in Elm just take a bit of boilerplate and it is a small downside against the huge wins of the development experience but I'm curious to know what trade offs people have embraced. Thanks! 
Soon you'll stop seeing this as a problem and instead see it as a solution. A solution to the problem of refactoring and testing. When all functions have their dependencies explicitly listed in the function type, refactoring and testing is easy. When testing you just send the data to be tested and see if the result is the expected one. When refactoring you just change the function code to be the way you want it and fix all the type errors.
Working on my functional programming babelfish project, changed it from a readme to a SPA based on elm-taco and elm-mdl. https://hakonrossebo.github.io/functional-programming-babelfish/ Repository here: https://github.com/hakonrossebo/functional-programming-babelfish Would be great with some feedback and contributions on content and functionality.
API looks very nice! Thanks!
My app is also small, it has now 3 pages. It's model looks like his: type Model = NoData | AnnouncementListPage (WebData (List Announcement)) | AnnouncementItemPage (WebData AnnouncementForm) | PayoutCancelledListPage (WebData (List Payout)) This is actually an Elm app inside Angular 1.x app, and both of them share main view. When route is recognized by Elm, it displays the page and Angular shows there nothing. This is how my main Update looks like: update : Msg -&gt; Model -&gt; ( Model, Cmd Msg ) update msg model = case Debug.log "msg" msg of RouteChanged route -&gt; case route of Routing.NotFoundRoute -&gt; Model.NoData ! [] Routing.AnnouncementListRoute -&gt; Modules.Announcements.ListUpdate.routeChanged model Routing.AnnouncementItemRoute id -&gt; Modules.Announcements.ItemUpdate.routeChanged model id Routing.PayoutCancelledListRoute -&gt; Modules.Payouts.CancelledListUpdate.routeChanged model ChangeRoute route -&gt; model ! [ Routing.go route ] Reload -&gt; model ! [ Navigation.reload ] AnnouncementList listMsg -&gt; Modules.Announcements.ListUpdate.update listMsg model AnnouncementItem editMsg -&gt; Modules.Announcements.ItemUpdate.update editMsg model PayoutCancelledList listMsg -&gt; Modules.Payouts.CancelledListUpdate.update listMsg model Its important to note that even though my models, updates and views are separated, all of them returns top level `Model` and top level `Msg`s. Each update has it's own mapper like this: mapAnnouncementForm : Model -&gt; (AnnouncementForm -&gt; AnnouncementForm) -&gt; Model mapAnnouncementForm model formMapper = case model of AnnouncementItemPage webItem -&gt; AnnouncementItemPage (RemoteData.map formMapper webItem) _ -&gt; model So an update looks like this: update : ItemMsg -&gt; Model -&gt; ( Model, Cmd Msg ) update editMsg model = case editMsg of Response response -&gt; Model.AnnouncementItemPage response ! [] SubjectEdit subject -&gt; Model.mapAnnouncementFormItem model (\item -&gt; { item | subject = subject }) ! [] BodyEdit body -&gt; Model.mapAnnouncementFormItem model (\item -&gt; { item | body = body }) ! [] DurationEdit duration -&gt; Model.mapAnnouncementFormItem model (\item -&gt; { item | duration = duration }) ! [] etc… And this how `ItemMsg.elm` looks: type ItemMsg = Response (WebData AnnouncementForm) | SubjectEdit String | BodyEdit String | DurationEdit (Maybe Duration) | ToggleBank String | ToggleCurrency String | ToggleEnabled | Submit | SubmitRemove | SubmitResponse (WebData ()) How do you like it?
I think a tool like `elm-github-install` or `elm-proper-install` can be hacked to solve this issue. 
Though I could be wrong, I believe that this very consideration (of private packages) is being addressed with the next version of Elm. Keep your eye on it for the next couple of months.
Thank you very much for sharing such a complete run down. It does help to see. The mapper &amp; setter combination looks nice &amp; clean. I'll try to follow a similar pattern. Though it feels like you don't have nested records in quite the same way as I am thinking. Though maybe you do and I'm missing something. Seem like you have records inside union types rather than records inside records. I can see how some of the techniques could be applied, I think. Thanks again!
You are right. I have no records inside records so far. But if I had, I think I could create another mapper and use it for the update branch.
&gt; It's OK for some, for example the Elm-UI toolkit has a function Ui.Helpers.Env.get which calls native code and brings you back some environment value anywhere in your code. I think I might be misunderstood by using "OK" in that phrase. It's actually far far away from "OK", it's just the sad reality that **some** people find it OK, create a library. Does anyone care? 
This has been done mostly for self-study as there is already a good unit testing option elm-test https://github.com/deadfoxygrandpa/elm-test. Wanted to ask for a quick code review/feedback and also ask what libraries can be studied as good examples of Elm coding practices. Thank you for your comments.
Elm recently got accepted into the Google Summer of Code (http://elm-lang.org/blog/google-summer-of-code-2017) so you may want to look into the suggested projects and see if something interests you.
I see that your documentation uses forms like `eql(2, 3)`, that is, C-style function calls. In Elm this is written `eql 2 3`. If there's another function before it, wrap the whole thing in parentheses: `test "2 and 3 are not equal" (eql 2 3)`. Instead of `module Test exposing (Test(Suite, Test))`, keep `Suite` and `Test` (the value) private so that you can change `Test` (the type) later without a breaking change. Declare `module Test exposing (Test)`. I see you have code like `it message expectation = Test message expectation`. This is fine, but sometimes it's nice to say `it = Test`. Instead of creating a function and then applying the arguments, you just assign one value to another, that happens to be a function. This may seem like a syntactic trick, and it is, but it's also a clue about the semantics of first-class functions. You run all the tests and then display the result. This works for the demo that you're doing but a more sophisticated test runner will run the tests reactively, updating information in the UI as it becomes available. (This means that tests have to be run lazily, not when they are defined, which is one of the changes that prompted version 2 of elm-test!) Good job on your first big Elm program, and thanks for putting it up for code review!
Thanks for the advice. I will try pointing to the clone in source_directories. &gt; you can write some! Definitely down with helping out, but adding tests in the absence of any at all would be a separate initiative. For the moment, I need some additional functionality to move forward with my project.
This did work for me, thanks again. I updated the post.
Implementing some http://elm-ui.info/ "components" into my pet project.
Yes, it is very cool, but so is splitting things out into smaller functions. caseInsensitiveEq : String -&gt; String -&gt; Bool caseInsensitiveEq left right = toLower left == toLower right Then you can write: List.filter (caseInsensitiveEq query &lt;&lt; .name) people EDIT: per /u/dustinfarris I missed a piece.
Ahahahah :D Nice!
Ah, great suggestions! Thanks for the feedback. I updated the project accordingly. Took me a second to figure out your last suggestion on moveToString then I realized it was taking advantage of currying. What a language. Loving it!
Also lots of Elm projects have a demo folder. This is an easy way to play with things in elm reactor or something like that
[removed]
Could you speak on the benefits over this abstraction vs just using a dictionary at the top level? I imagine you could just have a few dictionaries at the top level with you data denormalized. What benefits does your store abstraction provide? 
Could you speak on how this is related? I don't see how a store abstraction is related to communication between "parent and child." I see a store abstraction as a means to cache your data and normalize your data. (But I'm not certain about this -- so would love second opinions!)
This library is a pattern for writing Stateless Components. Not necessarily for front end only. We developed this for backend Elm first. But it works great on the front end too. This solves the problem of how to build large scale apps in Elm. If you read the first part of the reader.md you'll see when it's useful. 
I've seen many people (1) go down this road, (2) end up unhappy with the result, (3) try scaling without organizing their code in terms of "components," and finally (4) report back that scaling became nice once they did so. It can definitely be a challenging mental shift to make! Here is [my advice on scaling Elm apps](https://www.reddit.com/r/elm/comments/5jd2xn/how_to_structure_elm_with_multiple_models/dbkpgbd/). This has worked for our 96,000 lines of production Elm code, it has worked for numerous others who have tried this approach after being unhappy with the "component" approach, and I bet it would work for you too. :)
We went with a monorepo, so our project structure is root |- server (phoenix) |- client (based on elm-webpack-starter) For integration testing we use Wallaby. This allows you to do concurrent full stack testing using a pool of phantomjs instances. There's a bit of work to get this setup, locally we run a single webpack server which is used for development in the browser but also to run the tests (the Elm app's configuration is passed in via query params). In CI we build the Elm app first and put it in phoenix's static folder. Our other project uses rails + ember which we also had as separate projects originally. We've now migrated that to a monorepo as well, favouring full stack testing using capybara over ember integration tests with mirage. I'd be curious to know what your experience has been, but ours was that without full stack tests we were getting bugs in production because the stubbed mirage services were able to go out of sync with the backend API. 
Generally in this situation I would almost always prefer a single repo. I find it tends to make things a lot simpler to manage this way. For example a simple bug fix may require a back and front end change, and with a single repo these can be made in one commit since they're closely related; with two repos you would need to make 2 commits and lose some of the context of the change, or have to manually mention how to get the other commit (which may break if e.g. commit SHAs change because history is rewritten). One repo also makes it possible, or at least significantly easier, to `git bisect` to find the cause of an issue, and gives you a common place for shared things like development tools, tests, documentation, shared configuration etc. Only advantages I can think of to multiple repos is that this may help development if they really will be separate projects which just happen to communicate through infrequently changing apis, but this is almost never the case (a change in one will normally prompt or require a change in the other, so why not show that they're related). And I guess if you want only one project to be open source it would make sense to split them up. 
When I started Elm I was using [Ramda](http://ramdajs.com) for like two years already. We had exactly the same "wow" effect back then.
It would probably be good to link to your blogpost about this here? https://hackernoon.com/error-handling-in-elm-7ffaf9ff3f8#.9b74klk6t
[removed]
Elm works great on the backend running under Node. I'd rather write Elm than JS. Not all backends use HTTP protocols. We're happen to be using Websockets as a Transport protocol (I wrote my own websocket client and server Effects Manager since Elm's front end let a lot to be desired and there was no backend.) Some of our backend services are stateless while others are stateful. But you must maintain state during complex operations that span many Async calls even though that state lasts only as long as a single stateless API call from the client. And clearly you need to maintain state for stateful services. Your point about them being different domains is exactly why I think most front end developers won't create something complex enough to require this library. But since we're going to be developing an Electron app on the front end, we can share code across the front and back ends and will need this library on both fronts. I'm a bit confused about your statement about "private state in objects" since Elm doesn't have either.
Yeah, in terms of the relationship of Phoenix to Elm, it's 100% API driven over websockets. I'm wondering if there might be an interesting Elm SSR solution that involves Phoenix templates, though. It's something I've considered experimenting with. If that were to work out, a monorepo would make a _lot_ of sense. I've enjoyed having 2 repos because I feel like I can clear my head of backend or frontend concerns and just focus on one or the other. But I suppose I could do that without having separate repos—just a mindset, after all.
I don't think there's an Elm SSR as of yet, but it shouldn't be too complicated to set one up (assuming you're following TEA). Since you'll run your your apps init and render the first views for that initial state and then return that, then by the time your Elm JS is downloaded it will just repeat that step again and re-render. Although I do see potential issues if your apps initial state returns some effects (depending on what those effects are). One really interesting approach for an SSR however would be to modify the Elm apps state so it is already initialised (so that step won't be repeated in the client), however I'm not sure how complicated that would be to do (would need to take a look at the generated JS to better understand how to approach it). Reason why I've taken to keeping the projects separate in my case is because the backend API is the exact same API I'm using for all of my client side components (web frontend, mobile, etc.). So the backend is essentially just a service. So the benefits of keeping my frontend apps in alignment with the backend (as far as commits) is quite minimal (the API won't be making breaking changes but rather deprecating things first). The benefit to keeping the projects separate is that it keeps the projects fairly lightweight (if a developer is working on the frontend, they don't need to also download all the backend project files too), I think it also leads to a much clearer separation of concerns, and lastly makes it dead simple to decide if I wanted to create a completely new frontend from scratch that could be done in another new project instead of adding to the old (adding more commits to it). Only benefit I could see to integrating it with the backend is as you mention taking advantage of an SSR. But in my case mobile is where majority of the users will be so I think just using a CDN for the static Elm app, and just optimising the serving of content from the API is a better focus than combining them. 
Oh, wow. Wallaby (for Elixir) looks great! Thanks for clarifying. Yeah, my Google search turned up wallabyjs (and a bunch of other non-programming-related Wallabys)—but not this. For anyone else following along, here's a short post from the author of Wallaby I found on Elixir Forum about the difference between Wallaby and Hound: https://elixirforum.com/t/wallaby-vs-hound/443/4
I think this is worth trying. I plan to do basically this and see how it goes. Agree about the CDN. I'll have to explore how to automate uploads to S3, fingerprinting, etc. There are a couple broccoli plugins that should help out here.
There is https://github.com/eeue56/elm-server-side-renderer, it doesn't do anything fancy like rehydration in the client but it will give you an initial view to send to the client which you can then replace with the Elm DOM when it's ready.
Would you mind posting some non-contrived Elm code that you think would be improved by typeclasses, and what the improved version would look like?
It sounds like you're thinking of `deriving`, which is a code generation language feature. In Haskell that language feature happens to be implemented in terms of typeclasses, but there's no reason it needs to be. That said, I agree that there's an opportunity for a code generation language feature to improve JSON decoder creation. :)
Aren't Dicts the example? You can't operate safely on multiple Dicts without a guarantee that the same comparison is being used on each. (Or rather, you can, but only by sacrificing efficiency.) And that is the solution used in core, but in a nonextensible way. I want to be able to use my own types as keys without giving up safety.
[This](https://groups.google.com/forum/#!topic/elm-discuss/oWfARte8DJU) thread has a lot of examples. But the above code _could_ look something like this instead: NotReady time -&gt; Router.init model.location |&gt; wrap (\routerModel -&gt; Ready (initTaco routerModel) &gt;&gt; .=appState) RouterMsg where wrap is a function that looks something like this: wrap : (partOfModel -&gt; model) -&gt; (nestedMsg -&gt; msg) -&gt; (partOfModel, Cmd nestedMsg) -&gt; (model, Cmd msg) wrap setter tagger (part, newCmd) = ( setter part, Cmd.map tagger newCmd) I'm not suggesting that this is the best part - but this is something that is complained a lot about on the Slack, and by people I talk to when I see their Elm in production. They need a way of managing sending messages to nested update functions, and the simplest change would be so they don't need to write out `(\nestedModel -&gt; { model | nested = nestedModel})` each time (originally posted with my non eeue56 account, trying to unify my nickname everywhere!)
What about user defined types as keys in a Dict? Elm already has typeclasses but they are compiler magic. Usually magic is not very elegant design, especially for a language, IMO. I guess maybe another way of saying this is that if typeclasses really aren't useful num, appendable and comparable wouldn't exist. Are we saying that only those three use-cases are valid for typeclasses? That seems rather silly. EDIT: Now I also wonder about flipping this: Show how some Elm code would look if those built-in typeclasses DIDN'T exist. I would bet the code would be far worse off, or maybe in some cases even not expressible?
[removed]
Progress bars! Elm-package uses special characters to make a little progress bar appear as things are being downloaded. From the looks of it, your terminal is using some strange font which doesn't handle whatever character elm-package uses. FWIW, this kind of question might be better asked on the [elm-slack](https://elmlang.herokuapp.com/) where you would get an answer right away. :)
Thanks! I figured it was some bullet or something. I develop on Windows 10/Powershell and for some reason that's usually the "least popular" platform so things are sometimes wonky on it. 
You can just download and set a font like https://github.com/powerline/fonts if you want those symbols.
Nope, but I will keep an eye on it! Looks good thanks!
There are a few compiler messages like that which don't work well on Windows command shells e.g. https://github.com/elm-lang/error-message-catalog/issues/183 One thing which may be interesting to try is Bash on Ubuntu on Windows (using the WSL). Apparently that is getting better and better.
Typeclasses would provide a solution to the `comparable` problem, which is clearly not contrived and that I find quite annoying. Same for the absence of very common and useful functions that are not provided in Core and that I seem to implement for each types (like `mapM`) in my codebases. 
Hmmm, tricky. Problem is that I don't think I can fix that without using native code.
Could you open an issue with the code you use and version of firefox? I can't seem to reproduce it (I put draggable on a div and it worked in my firefox)
I'm: - planning a UI and node test runner for elm-benchmark - reading about logic programming. It's cool!
I added framebuffer output to my debugger. [Here's a screenshot](http://imgur.com/a/MR2Aa) of it displaying the first frame I've successfully rendered (sans sprites)!
&gt; Typeclasses would provide a solution to the comparable problem, which is clearly not contrived and that I find quite annoying. I agree it's annoying, but I think the solution is that union types should be `comparable` - and I predict that they will be in the future. &gt; Same for the absence of very common and useful functions that are not provided in Core and that I seem to implement for each types (like mapM) in my codebases. I suspect we'll have to agree to disagree on whether Haskell's `mapM` meets the definition of "very common and useful" for the average Elm programmer. ;)
What if you flipped it around and put the implementations in different modules? User.add user User.delete user Feed.add feed Feed.delete feed Conversation.add conversation Conversation.delete conversation This would follow the pattern of existing Elm modules with similar functions - `List`, `Array`, etc.
That seems to have less downside, certainly - and I suspect it would make sense for stuff like equality (e.g. if you want to make a custom `Dict` that's performance-optimized for certain use cases, but want it to do `==` based on contents of the dictionary rather than internal storage details).
Inside Store each operation does the following: 1. Applies the operation to an optimistic State 2. Creates a Push that's sent with elm-phoenix 3. The push is added to a queue that waits for a response 4. The response from the server is received and decoded 5. The operation in the queue is updated with the response 7. If the server response was an error trigger an error tagger 8. Whenever the head of the queue contains successful operations (response received from server) they're flushed and applied to a pessimistic version of the State. While you could potentially make the separate steps available to allow each module to build it's own implementation this would mean that there was nothing to enforce that the steps had been applied correctly (not to mention the inconvenience of having to write them out for each module). The solution naturally seems to favour inversion of control. One option I've considered is that the API accepts a record as a parameter for every Store function e.g. Store.add User.meta user Store.remove User.meta user Store.add Project.meta project Store.remove Project.meta project where meta is type alias Meta = { buildPush : (Operation -&gt; User -&gt; Phoenix.Push) , decodeOperation : (Json.Encode.Value -&gt; Result Error Operation) , applyOperation : (Operation -&gt; State -&gt; State) } I think this would be workable, but it does look an awful lot like typeclasses with more boilerplate. 
Hi /u/yourmagicisworking! While I'm not an Elm expert, I would say that you could add a type constructor to the `Msg` in entities.elm (or wherever your are managing that state) called `updateUser` which take a new `User` object. How this would get passed up to the root, I'm not totally sure.
As a heads up, I'm new to Elm. How about storing both the BooksModel and the ElectronicsModel on the Model at the same time then adding a third field indicating which one was the appropriate one to use in the view?
Cool - love to see how it turns out! :D
&gt; I suspect we'll have to agree to disagree on whether Haskell's mapM meets the definition of "very common and useful" for the average Elm programmer. ;) Oh, but I completely agree with you! **I** find this annoying.
I made an experiment with dynamic types in elm: https://github.com/norpan/elm-dynamic-types
Good feedback! I will fix that, thanks!
I had the same problem with powershell. I use this line to set the encoding to utf-8: [Console]::OutputEncoding = [System.Text.Encoding]::UTF8 
Very nice! I'm just starting a project where i need a nice UI, looking at elm-mdl, elm-ui and now this :) Regarding table interactivity (which I will need), should be able to integrate with http://package.elm-lang.org/packages/evancz/elm-sortable-table/latest right? I'll try it and let you know.
Thanks! This is the answer I was looking for!
What properties are you looking for exactly? Elm vs JS: Elm is as suitable for math as JavaScript since in the end JavaScript's operators and number type (64-bit float) are used during runtime. Additionally to a generic number type Elm provides an `Int` type, but the underlying float leaks from time to time, see https://github.com/elm-lang/core/issues/831 and linked issues.
Wow. Thank you for sharing this - I'm still trying to wrap my head around how to use Elm in real-world scenarios, and this provides a solution to many of the things I've been struggling with.
Fixed!
The discussion is probably a bit old now, but there's something I think nobody has mentioned yet. I'm building an application from multiple microservices, each having its own view. The idea is that each microservice, including it's user interface, can be developed by its own team with virtually no interaction with the other teams. My main app is in elm, but I would like to integrate the UI of each microservice. Note that the UI is not necessarily a whole page but can be only a widget on the page. I don't necessarily want to impose elm to each team because that would defeat the purpose of using HTML+CSS+js as the lingua franca: I don't care which tooling or language the team uses as long as I have plain js HTML CSS to integrate. Right now, the only approach I could see is using webcomponents. So I need two things: 1. Being able to integrate a webcomponent (that party sort of works) 2. Being able to write webcomponents in elm
Have you seen [this proof-of-concept](https://github.com/pdamoc/elm-box) ? It is an exploration on what could be accomplished with a little bit of JS that handles the behind the scene declaration of a custom element, mounting of the JS and communication via the attributes. 
The interface state is part of the data, as this is a purely functional language, so yes, that goes in the model :)
Yes, but now that I read my comment again I think a small part is missing. The line should read `export PATH="$PATH:~/scripts"`. Or the way I did it is to copy the `elm-format` file to /usr/bin. (/usr/bin should be on your path by default.) The difference is that in the first solution the elm-format executable is only accessible by your own user, while with the /usr/bin solution it can be used by any user.
Hey, Phoenix peeps :-) I threw this together so I could get elm-css stylesheets compiled for my Phoenix project. Mostly copies from the elm-css cli, but would love it if others could kick the tires and let me know how it can be better.
This is really exciting.
Thank you! What finally did the trick was copying `elm-format` into `usr/local/bin` (I'm on a Mac and `user/bin` is apparently only system writable.)
Let me preface by saying HOLY SHIT - I wish I had started learning elm early. Elm is scratching a mysteriously deep itch in so many ways and the documentation, tutorials, online editor, editor plugins, and error messages are AMAZING. It is...incredible. Anyway: I'm attempting the last challenge question on the bottom of this page: https://guide.elm-lang.org/architecture/user_input/forms.html "Add a "Submit" button. Only show errors after it has been pressed." My question is thus: How do I capture / send the data of each html element into the update function? for example, the model used to look like: view : Model -&gt; Html Msg view model = div [] [ input [ type_ "text", placeholder "Name", onInput Name ] [] , input [ type_ "password", placeholder "Password", onInput Password ] [] , input [ type_ "password", placeholder "Re-enter Password", onInput PasswordAgain ] [] , viewValidation model ] In this case it seems easy because each element has its own `onInput`. But when we put the function into a submit button, how do we do it? I changed the model to this (introducing a new type constructor `SubmitForm` to the Msg type, and using it in the submit button: view model = div [] [ input [ type_ "text", placeholder "Name" ] [] , input [ type_ "text", placeholder "age" ] [] , input [ type_ "password", placeholder "Password" ] [] , input [ type_ "password", placeholder "Re-enter passwd" ] [] , viewValidation model , button [ onClick SubmitForm ] [ text "Submit" ] ] How do I capture the values inside of the 4 input fields and "send" them to the `update` function? And having mentioned the update function, how would I structure / pattern match on the model, if I am sending the whole model to the update function? For reference, this is the original update function: update : Msg -&gt; Model -&gt; Model update msg model = case msg of Name name -&gt; { model | name = name } Password password -&gt; { model | password = password } PasswordAgain password -&gt; { model | passwordAgain = password }
You still update each field individually with an onInput. Simply add another field to your model like so: `isSubmitted : Bool` which you can initialise to False. Your button now dispatches a Msg that updates this to True. Your view has access to this, so it's super easy to conditionally show the errors. Happy to help out more with code if you need, but this is the philosophy behind it.
I love this framework :)
Curious, what do you like about it? I honestly don't understand how this has many stars.
It brings the architecture of elm with the simplicity of javascript. Instead of getting React/Redux/React Router/etc.. Or Vue/Vuex/Vue Router/etc.. You just have hyperapp. It has it's own state manager, its own router, and can use both JSX or hyperx. It can also support pure h calls if you feel so inclined. It's simple and clean and still maintains the pure aspects of functional programming It's also just 1kb, soo that's nice :P
This week I worked on porting over bass-css to elm. Thinking of maybe diverging it a little bit to make it easy to document new combinations of the bass selectors (so you can still have patterns but they are easier to update all at once) https://github.com/justgage/elm-functional-css Also worked on porting an example version of an a project at my work to show how how awesome Elm is.
This looks great! Did you write your own virtual dom?
What motivated your decision to write your own, if you don't mind me asking?
&gt; Each failing test prints out a shell command to run only that test, with the same seed as before. Of the four, this is the one I'm most confident we should do. There are a few other options besides description and file/line number: * Hash of the "fully-qualified description" (that is, description plus parent descriptions) which actually is globally unique. (So you could do `elm-test --only-test a3cf9d`) This presumably makes reproducibility easy, but you'd never be able to pass it in by hand because you'd have no idea what the hash would be. * Filename and test index (e.g. `elm-test UserTests.elm --only-test 5` to run the 5th user test) - this is similarly easy to reproduce, albeit more brittle to adding tests beforehand - or to moving the test in question to a different file. It's also realistic to put in by hand, but only in small test files...where narrowing to one test is probably less useful.
based on*
The "wording" of the API is closer to ELM than Cycle/Vue/Purescript, but does it really bring something new? Edit: does it have server side rendering?
&gt; does it have server side rendering? There are a few community based SSR solutions already &lt;https://github.com/hyperapp/hyperapp/pull/28&gt;, but we want to offer this out of the box. Soon. &gt; does it really bring something new? No, but it delivers a near-to-Elm experience in an accessible form from which you can profit immediately. [This](https://www.youtube.com/watch?v=oYk8CKH7OhE) and [this](https://github.com/fantasyland/fantasy-land/issues/204#issuecomment-262427123) comes to mind.
In JavaScript land using React I use the lifecycle methods to initialize and dispose of side-effects/handlers. That convention has proven very useful.
Could not get through 2 minutes of this with such bad audio. 
I've fixed that in the most recent video, I'll try and fix the audio and reupload the first 2.
&gt; Do I have to manually send another Cmd on another port to unsubscribe when I have a page change? I guess that's basically the only way to cleanup correctly at the moment.
&gt;If views are typically defined in Elm functions, perhaps it's not for me, or you can educate me on how the benefits outweigh the drawbacks. Much like React's "it's just JavaScript", this is "it's just Elm". You can call functions to compose and create views in any way you like without being limited by markup. It's offering you a much more powerful version of the much-hyped web components, right here, right now. &gt; To me, using regular markup in template files lets my interface layouts be declarative; having to build DOM nodes in a function makes it feel procedural (a la Swing). This is a pure functional programming language, so there's no side-effects to keep track of and you're essentially programming behavior in a declarative manner. That's why Elm maps so well to the problem domain. &gt; In other words, in the screenshot below, how can the thing on the right be considered better than the original markup on the left? Syntax-wise, except for the "text" function calls, they're the same exact thing just indented differently and using squared instead of angled brackets. This is too much of a culture shock for some people (it was to me but I was able to overcome it after I learned how deceptively simple it is) which is why React uses JSX as a preprocessor to raw HTML manipulating functions (also because JavaScript doesn't have a DOM API as good as Elm's). There's an equivalent for Elm called [elmx](https://github.com/pzavolinsky/elmx) which may help you map the concepts better at first, but trust me, you *really* wanna get over the difference and enjoy the full power of the Html package.
Elm is functional, that means everthing is declarative.
&gt; No, but [...] I appreciate not pretending to do anything new! Also, thanks for the GitHub link, very interesting issue to follow. For the record, I really think the project is interesting, and will most likely use it... I just like to probe. 
That will save me an awful lot of commenting out/in :)
I guess you can also keep state on JS side and match against that. For example, you can keep a `currentSubscription` and check against it on the init of each page (in the hander of the port that get's called on init). If it is non-null, unsubscribe in JS, subscribe with the new path, and make the new path the currentSubscription. 
&gt; educate me on how the benefits outweigh the drawbacks. The HTML template on the left side is just "random text" that your program doesn't understand. That means: - You can easily make a typo that creates invalid HTML. Different browsers may "repair" your HTML differently, and/or it may cause performance problems. - You can easily make a typo that creates an invalid template, which you won't notice until runtime. If the problem is in an infrequently-used template (or an infrequently-used "mode" of your template) your customers may notice before you do. - You can easily make a mistake when using/nesting your template, such that it creates invalid HTML. - You must manually "wire-up" connections between templates. When you have a Button template that's supposed to be passed the ID of a DIV to show/hide, you won't know if you made a typo until run-time. All these problems are impossible in Elm because they are tested at compile time. In a normal language, you would need to write and maintain a large test suite to have any chance of finding these problems. In Elm, they come "for free", so you can focus on higher-level problems that the compiler can't trivially check. Down the road, you will want to DRY up your HTML. You can do that with a template language, but then you will have to flip-flop between a wimpy template language and your "real" language. Edit: formatting.
&gt; it delivers a near-to-Elm experience I assume you mean near-to-Elm *architecture.* 😉 If it were achievable to get anywhere near the Elm *experience* in JavaScript, I doubt so many of us would bother embracing a whole new language! 😁
Yes, you're definitely spot on. I tried with "architecture" too, but it lacks the rhythm I was aiming for when I constructed the expression. I guess hyperapp is like a good old fashioned tea you can get at your local convenience store/supermarket; it's cheap and anyone can have it. Elm is hemp :)
This is just JS, not a cross-compiled language — there is no compiler, so yes...
I'll clarify one point. I shouldn't have posited the declarative vs procedural, as yes, I understand that Elm is declarative. What I mean to ask is, since the final output is html, wouldn't it be better just to write that, with templates containing bindings to Elm, rather than have to create lists of nodes in Elm that just end up getting transpiled to html? 
&gt; since the final output is html, wouldn't it be better just to write that, with templates containing bindings to Elm, rather than have to create lists of nodes in Elm that just end up getting transpiled to html? This is a great question! The trick is that this isn't quite accurate. The final output is actually [DOM nodes, not HTML](http://stackoverflow.com/questions/4110081/difference-between-html-and-dom). The DOM is the in-memory representation of the structure of the page. When you Inspect Element on this page, what you're seeing is the current DOM. HTML is a language that can describe a DOM structure. It's a popular way to describe it, but it's by no means the only way! There are plenty of other ways to represent a DOM, including the approach Elm takes. In practice, it turns out that [this approach has excellent performance](http://elm-lang.org/blog/blazing-fast-html-round-two) compared to libraries that use HTML to represent DOM structures, such as Ember, Angular, and React (via JSX). :)
If you're producing static HTML than the difference is largely irrelevant. You may as well just write the HTML. The Elm compiler will prevent you from producing HTML with dangling tags, but you can achieve that with a html linter. The real reason to use a proper programming language to produce your HTML is that it allow you to reduce repetition. Say you have 1000 items that you want to display in a list in your HTML, you can type out all 1000 html list tags or you can: eg. ``` Html.ul [] List.map (\x -&gt; Html.li [] [Html.text x]) yourList ``` It's also useful if you want to do something dynamic, like showing something in your html if the user is logged in and something else if they're not. eg. ``` if userLoggedIn then Html.text "Logged in" else Html.text "Not Logged in" ``` There exist various html templating languages that allow you to mix some logic in to your templates in various ad-hoc ways. But they're universally underpowered and take away most of the programming tools that allow you to control complexity and reduce repetition. With a proper programming language generating your HTML you can create functions, compose them together, put them in seperate files and directories and distribute them as packages. 
Aha, that point right there about programming the DOM may have just changed my life. Well, at least the way I think, if not my life. Thank you! 
Hey, your link broke. Looking forward to checking it out!
I like that I don't have to convince my editor to correctly highlight, indent, etc.. Elm, Html, (and CSS) in the same file. 
`if userLoggedIn then Html.text "Logged in" else Html.text "Not Logged in"` probably looks nicer as `Html.text &lt;| if userLoggedIn then "Logged in" else "Not Logged in"`
I'm still struggling it a bit myself but as a data point: I've ended up creating a folder for each 'domain object' I have. eg. I have a 'LocationList' folder that has its own Model, Update &amp; View files. I started off having a 'View' folder that was going to have 'LocationList.elm', etc, files in it but felt that I liked the contained groups of files. It is different to the old 'Elm Architecture' approach as the `update` method in `LocationList/Update.elm`returns a full `(Model, Cmd Msg)` object rather than a submodel &amp; subcommand. This removes or perhaps just redistributes the boilerplate around combining submodels &amp; subcommands in a manner which I think is a net positive. I think that the old 'Elm Architecture' sub model &amp; sub command approach is not recommended any more.
There is #elm on freenode.
Is it really worth fracturing the chat just to get on an open source platform? The main hub for Elm is Google groups, and that's not open source.
All the pointers to further resources are great! Regarding the "A note to javascript developers" section: In general, I'm suspicious of "Don't use components, use X!" arguments, because no concrete value of X (view functions, well encapsulated models) is going to apply in any and all situations. And, annoyingly, you kinda need to have some elm under your belt to understand what reuse techniques look like in practice and when its appropriate to use one over the other. Imo, emphasizing the two point list (1. model the problem, 2. write your view) and especially "Its easy to change things in elm" will be more persuasive to the prospective learner than focusing on specific reuse techniques. 
Writing elm code in vscode has been the most enjoyable programming experience of my life. A lot of that is how great elm is, but the elm/elm-format plugins are fantastic.
elmjutsu is great - I use it mainly for go to definition. Do you have it on vscode?
no...don't have it on vscode :( There was a request for it on the github but the author said he had no experience writing for vscode. So unclear if it'll become available anytime soon. 
agree! I love vscode too. However, I'm following the tutorial from pragmatic studio and looks like their plugin is a bit more Elm aware than my vscode is. 
I was able to figure out a solution to this, you can see it all in this repo: https://github.com/polyfish42/jsontosheet (Look in the GoogleSheet.elm file). Thanks for your help!
I haven't looked at this yet but, in advance, thank you! I'm a complete elm newb so having something like this will *really* help, especially with the SPA side of things.
It's glad that can help you!
This is yet another sample app I wrote to explore whether Elm is ready for production use. Well, I'm now convinced it is! Hopefully this will be an helpful resource for people getting to know Elm. It is modeled after the popular [react-hn](https://github.com/insin/react-hn) project albeit it doesn't use a realtime api (would have been cool!)
Really interesting! I'm curious if you've thought about nesting your [stories routes](https://github.com/alpacaaa/elm-hn/blob/master/src/Types.elm#L42-L46) into another union type? Something like this.. type Route = StoriesRoute RouteName StoryList | StoryRoute { id : String, story : WebData Story, collapsedComments : Set.Set String } | UserRoute { id : String, user : WebData User } | NotFoundRoute type RouteName = TopStoriesRoute | NewestStoriesRoute | ShowStoriesRoute | AskStoriesRoute | JobsStoriesRoute I don't know if it's better or worse, just curious in your thoughts on it since on a true production app those kinds of decisions may come up when using a tagged union for your model.
Actually you already have a similar type [defined already](https://github.com/alpacaaa/elm-hn/blob/master/src/Types.elm#L107-L112). That would replace `RouteName` in the above example.
This might be useful, but I didn't try it because I don't trust any application where I need to connect with another account. I also didn't have time to look at your elm code, however, I quickly looked at the github link and noticed something else. You should really learn how to use git properly. You currently have the compiled elm code along with all your dependencies inside your repository. These aren't things that belong under version control, you should only put your actual source files in git. So create a `.gitignore` file at the root of your repository and write the following in it: `elm-stuff/` `main.js` Then make git forget about these file: `git rm --cached main.js` `git rm -r --cached elm-stuff/` 
Thanks! I think you're totally right, I much prefer your version. Will give it another look tomorrow :)
Without knowing more, have you tried using a union type? type Event = EventA PropA PropB PropC | EventB PropA PropD PropE | EventC PropA PropD PropE It's not *entirely* clear how you intend things to work, but all of these could be stored in a list together and then when you go to display them. List.map eventView events eventView event = case event of EventA propA propB propC -&gt; eventAview propA propB propC EventB ... And so on.
Nice, I replaced it everywhere.
This was a really good call, I didn't like the way I originally implemented it and I'm glad you pointed it out. Here's [the commit](https://github.com/alpacaaa/elm-hn/commit/80121a6856496d1a8a4ccaf9052f1188804f0853) where I made the changes. Looks so much better, thanks!
There is http://elmlang.slackarchive.io/
Exactly, the model, update and view live in your `Main.elm` and the rest of the files help this main to be expressive, to do it's job as simply and clearly as possible. For example, in the case of ToDoMVC, you don't have a `storeModel` cmd BUT, you can implement one and it can be as complex as it needs to be. Maybe it stores the data in local storage, maybe it contacts some server and stores it there... that's not really a concern of the `Main.elm`... all Main cares about is the ability to store exposed as a Cmd. Another example would be the `Components.elm` that helps the pages to express things simply by providing an extension to the current `Html` module. It extends it horizontally by providing more components. And it extends it vertically by providing higher abstractions like `row = div [class "row"]` 
You can pass clicked button as a parameter in your Msg, then you can modify it any way you want in your update function. https://ellie-app.com/FQZ3dBS3LYa1/0 
Thanks! But how would each button next perform it's own unique action when clicked?
Love this! I am slowly getting around to thinking in the required way to achieve code like this. It is almost like your are writing backwards in the UpdateButton id function. I love the power of let and in, I can't wait to use it more. 
That's Awesome, Peter! :) In your opinion which of those do you think is the best (but which I mean least about of boilerplate and most robust reuse?). Also, would using indexedMap avoid having to track the id?
Ah, now I see... then I would probably just move that part to a helper function and combine the two: https://ellie-app.com/FQZ3dBS3LYa1/1
If you have a list of things, I think it makes sense to use one message and some for of identifying the item from the list. Personally, I would go with the IDs outside the button option. Using indexedMap should be fine if you don't alter the list (add/remove elements). Even if you alter it you should be fine but it is conceivable to get into a situation where the two indexes might get out of sync. 
Elm is certainly still in development. So far, its goals have been in providing tools for generating dynamic HTML web pages, which is a similar space to what React targets. Its longer-term goals are always up for discussion, but it is likely aiming to be an alternative to JavaScript itself. We shall see what happens as WebAssembly gets going.
Hello, I have problems adding onClick handler to input with disabled attribute. It works just all right though if input element is not disabled. Is there anything I can do to make this work? The example code [is here](http://pastebin.com/vBrng8CC), you can paste it to [Elm-try](http://elm-lang.org/try) to check it online (sadly Elm-try doesn't support gists). Thanks in advance.
Sorry, it looks like it's browser limitation, I'd better just stylize it to look like "disabled".
Why is WebAssembly relevant? Just curious
Personally, I have treated Auth info as regular data. I have Auth related requests to the server that live in the API/Backend.elm and I have a type that encapsulates User data in Main.elm But if it feels more natural for you to extract that, sure... go for it. The main thing is not to stress too much about it because Elm allows for very easy refactoring. In other languages, decisions like these weigh heavily but in Elm you can do a large refactoring quite easily. 
Elm actually predates React, and Redux was directly inspired by Elm. So it couldn't very well have been created to replace them! ;) Elm on the server is on the road map, but realistically a few years out. It's a big project to do well!
Was wondering about that, for some reason I assumed it wouldn't work. I'll clean it up, thanks.
Another quick question: could you comment on why you recommend using IDs, as opposed to jpanasiuk's solution with didn't used them? 
Ok. Thanks for all the feedback. I'm diving in and we'll see what happens. I think I'm going to sort of mimic the Phoenix(1.3) contexts I've set up on the backend—seems like a decent starting point—and go from there.
Very interesting, thanks! -Rex
Not to mention more compact and faster.
I would hope that ELM could be full stack, and one could build from database to UI experience inside one language. I think those creating ELM dream of this as well.
I'm curious about this as well 
Sorry about the issues with the first Upload. Please Watch the talk here https://youtu.be/UamZi1jVbe8 
Searched on google and probably is this video: https://www.youtube.com/watch?v=QTdL76CFXDw
&gt;[**Let's Elm Episode 3: Decluttering with Dicts [11:19]**](http://youtu.be/QTdL76CFXDw) &gt;&gt;In this episode of Let's Elm, we're decluttering our update function using Elm dictionaries. &gt; [*^Acodemic*](https://www.youtube.com/channel/UCl-Z6MS13rRV2Tnn3_oIPuQ) ^in ^Science ^&amp; ^Technology &gt;*^25 ^views ^since ^Mar ^2017* [^bot ^info](/r/youtubefactsbot/wiki/index)
I've actually added a link this time! Feedback is appreciated.
Do you feel that by moving your data to a Dict from a record you lose some static guarantees? What do you think are the tradeoffs?
You're right, it is a bit of a trade off, I briefly mention that it might not be the safest way to do things. However, given the target application itself, I'm recording so many different fields I thought it be easier to manage one message per section. Thanks. I'll tag the commits for the various episodes, that'll make it a bit easier to find the appropriate code, and I'll look into Ellie.
Just for my own interest, here's a version of your code replacing IDs with `indexedMap` https://ellie-app.com/GJYJv5vqnba1/0 Yes, I see what you mean about those two indexes - it could become a bit dodgy in a more complex scenario. If I were going to be adding elements which needed their own unique ids, should I manage then by creating something like an `idCounter` on the model, and update it each time I add a new element? - Rex
[removed]
Hi Everyone! I took the solutions generously provided by /u/jpanasiuk and /u/jediknight in this thread and combined them, with comments, here: https://ellie-app.com/GKfmDNxMhta1/1 The buttons change their state, and when they're clicked, they change the state of the model. I can think of about a gazillion different projects where this would be a useful starting point. Can anyone suggest any ways to improve this (greater simplicity or greater understandability)? - Rex
I was thinking the same thing, I don't entirely understand what this project does because the README is pretty bare.
You can use (Json.Encode or Json.Decode) Value type. It will allow you to inspect the object (if needed) and to pass it around without changing.
I was about to post something silly, but after reading your question again I think what you're looking for is List.scanl function :) https://ellie-app.com/GTyhqqf6VZa1/0 (you could even simplify it further using point-free notation) directionsToPoints = List.scanl move
Nice implementation! You could also have used List.map. Here is a version of that, using the same code as above: https://ellie-app.com/GTNrTykCzPa1/0 In general, if you have an input the same size as your output (in this case, the list of directions is the same length as the list of resulting points), then first try to think if you can accomplish your function using map.
Thanks!
 dirToPnts origin dirs = snd $ List.foldr (\ (prev,list) new -&gt; (prev+new, (prev+new):list) (origin,[]) (reverse dirs) or something similar, no need to be recursive when it maps to a fold. Edit: ignore this, it is a manual implementation of scanl which is better to use, see /u/jpanasiuk comment
I don't know what's best in this case, but making two functions is an extremely common pattern for recursive functions! I usually name them `func` and `funcHelp` like this: directionsToPoints : Point -&gt; List Direction -&gt; List Point directionsToPoints point directions = directionsToPoints point directions [] directionsToPointsHelp : Point -&gt; List Direction -&gt; List Point -&gt; List Point directionsToPointsHelp point directions revPoints = ... Again, this is pretty common when you have more complicated recursion.
Jesus I said the same exact thing to my wife when I read his article 2 days ago. 
Ah, yes, in that case, scanl is what you want :) I didn't read the original post carefully enough...
Would be great if you referenced elm-static-html in there ;)
Hi, one thing I would add here is allow buttons to trigger commands (instead of always returning Cmd.none). Here I also used List.Extra.repaceIf and changed some names here and there, but that's just cosmetics https://ellie-app.com/H8Gr46zF8Ta1/1
I'm writing the frontend for a management tool for cannabis clubs in Elm. Rocky start as some of the regulars in Slack can attest ;) but I've got a pretty good set-up now that follows TEA and uses elm-css for styles. Pretty damn awesome to have so much compile-time safety for web!
Awesome!! That turns it into quite a powerful little monster :)
Elm prefers to keep the state structure quite flat. In a large webapp, one would split the functionality into pages and have each page handle its data with maybe a little bit of help from top-most level (e.g. session info about the current user). Intricate nesting of state is, as far as I understand, discouraged. Aggressive splitting of functionality into "components" it is also discouraged. There is a section in the guide that handles [reuse](https://guide.elm-lang.org/reuse/) in the case of more sophisticated view items. 
I just finished gist export and collapsing code panels for Ellie's front end. Later this week I'll be working on laying the groundwork for multiple Elm versions in Ellie in preparation for 0.19 as well as continuing preliminary exploration on a fancy elm repl a la http://mancy-re.pl/ I've got a couple options available to read information about an Elm program from .elmi files now, and I wrote a little electron program with Elm that accepts series of expressions from user input and returns both the type information and the evaluated result of each expression. I'm starting to think about design and UX. Part of that UX will be creating different ways to represent the output of an expression. For example, if we can tell that the type of an expression is a VirtualDom.Node we can iframe in the program from the filesystem. If it's a record or a List or a Dict we can do an expando view, etc. If it seems feasible to take this on in addition to maintaining Ellie and doing client work it'll be #2 in a series of tools I want to build to make the experience of getting to know Elm more visually appealing and interesting. Also, since there's no server and essentially no overhead cost beyond time we could open-source immediately and accept contributions and bug fixes. Should be fun!
i think this might win for most loc in an ellie project!
Cool, thanks for the reply. It makes sense in a traditional web app with pages and like, but what about a SPA with a large state to keep track of? It's just going to be a large .elm file?
Maybe our use case is unique then. We have a react/redux app that has a large state and is a SPA, but there are is no concept of moving to "another page". I was just trying to think of how that model would look as an Elm app.
Hi! So there may be a couple of different answers to this. First of all, in Elm version 0.18 you have built-in debugger available by default in elm-reactor. So if you open your project in elm-reactor, you should always have debugger available in bottom right corner. At this point it's a simple tool, but still very helpful. It's possible that when you used Elm before it just wasn't available yet! If you have a problem where your code doesn't compile and you are confused by the message it's giving you, there is a repository for collecting such issues https://github.com/elm-lang/error-message-catalog If your code compiles, but it doesn't behave correctly, in my experience the debugger + a few Debug.log's are usually enough to catch the problem. Elm code tends to be simple and declarative (no mutating/reassigning variables, pointer trickery etc), so I think there is less need for this style of debugging. And if you still want step-by-step debugging to dig in into how things work internally, there is no first-class support for that (like source maps), but you can access compiled Elm code under Sources in Chrome, place breakpoints and all that stuff. If you don't want to dig through the internal Elm code (like all the A2, A3, A4... functions and such), you can select them all and choose "Blackbox script" option. That way you will be able to "debug" your compiled code... Not sure if you want to do that, though, you will probably only get more confused ;)
you can define 2 animations and trigger the animation by toggling between them using some kind of switch in the model (I used the field `odd` for this) https://ellie-app.com/HkFrPKpKn2a1/2 Of course, this does not create the same effect (old text just disappears) but maybe it's good enough. 
I'm working on a web app for modelling a certain type of protein structure at the moment. I've made a little RESTful API backend with Flask and written the front end in Elm. This week I've mostly been working on usability and polish really, not long and I'll wrap it up for publication.
I'm trying to learn Elm these days, but although I like the language, my development workflow is a painful, paleolithic edit-compile-run cycle. I'm aware of elm-reactor, but it doesn't really seem to be suitable for anything more than simple toy apps. How does a typical interactive development setup for non-trivial Elm projects look?
&gt; and it's working just fine Glad to hear that. My CSS skills are very very primitive and I should not be trusted in that domain but... if it works for you... it works. :) 
I published two packages over the weekend: * [RemoteData.Http](http://package.elm-lang.org/packages/ohanhi/remotedata-http/latest) - a package full of HTTP verb functions, all returning `WebData a` as in the one from Kris Jenkins' [RemoteData](http://package.elm-lang.org/packages/krisajenkins/remotedata/latest) * [AutoExpand](http://package.elm-lang.org/packages/ohanhi/autoexpand/latest) - reusable auto expanding textarea in pure Elm Not sure I'll have much time to code on my free time this week, though.
Makes since, and looks much cleaner, thanks!
Yep. I also helped a bit with elm-css :)
I'm sending just one model for form so I have only one msg: input [ type_ "text" , value model.bibliographyDescription , onInput &lt;| updateNewMsg &lt;&lt; (\v -&gt; { model | bibliographyDescription = v }) ] [] type Msg = UpdateDataSetsNew DataSetsDetailsModel.NewModel
Wow, thanks!
I took the scanl suggestion into consideration and revised my project accordingly. Good stuff! [Dragon Curve](https://github.com/tmountain/dragon-curve)
You must, it is one of Elm's killer features! :)
Elm was designed to facilitate maintainability and extensibility of medium to large scale apps. Actually, you might need to get above a few thousand LOC to see how awesome the language is. Have you seen [this video](https://www.youtube.com/watch?v=3FNKaGm3gk0) ?
Awesome, that's great news. I haven't, putting it on my list to check out later. Thanks! 
&gt; Actually, you might need to get above a few thousand LOC to see how awesome the language is. `elm-format` can help with this.
Could you please give an example of a problem that you would like to solve? Do you need many math-libraries, then, elm is not a good choice. On any case, purely functional languages are better than imperative ones for math. See this: [Eleven Reasons to use Haskell as a Mathematician](http://blog.sigfpe.com/2006/01/eleven-reasons-to-use-haskell-as.html) If you consider math problems, I would prefer imperative languages over functional ones only for speed (C++) or library support (python).
So are you saying if there isn't a native module for something, I have to write it myself? Edit: that actually makes perfect sense. I was confusing native with first-party.
Thank you this is super helpful! Got ahead of myself apparently... 
It's a superb replacement. Once you get the hang of it you'll never look back. 
I started 2 years ago but I only worked on vacations and very irregularly. So I don't know how much time in total it took me. Thanks for the comment, it makes me feel better about the code.
I love simple but beautiful little examples like that ... it just makes me happy! :)
I would love this change! A few times I've found myself peeking at the source code for some libraries, just to see the names of the input parameters. It doesn't happen often, but sometimes the type signature just doesn't cut it.
Type aliases are a lightweight solution to this problem. For example: type alias Pattern = String leftOfBack : Pattern -&gt; String -&gt; String
I think this is a little too hard on Elm. Ports are really not that hard to set up and for most web apps the primary thing you're going to do is send requests to the server and you can already do that in Elm. Yes, it makes some things harder but at the end of the day you can still refactor things and _actually know_ that found all the places that needed to be changed. I think we forget how big that is. JavaScript land is crazy. 
My blog is written in Elm, it's one of this first things I made, so keep that in mind when looking at the code. https://github.com/ChrisWellsWood/chriswellswood.github.io PS You can see the site in action here https://chriswellswood.github.io
You can check out this hacker news clone, should be pretty easy to follow along. Routing is implemented with elm-navigation. https://github.com/alpacaaa/elm-hn
Monads are a deep and interesting topic. In this context, the OP just means other datatypes similar to `Maybe x`. `Maybe`, `Result`, `List`, and other similar types all share some common properties which make them monads. In a language like haskell, you could write a single function which works for _any_ monad, but in elm, you can't. This is because elm doesn't have any feature equivalent to Haskell's typeclasses.
I sometimes use `&lt;|` instead of `()`. Eg. `toString &lt;¦ getAge person` Instead of `toString (getAge person)`
I'd say, that it depends on thinking style. More imperative like thinking style supposes |&gt;. Take this, convert it to that, calculate something else from that... More declarative like style supposes &lt;|. I need this. Well, this can be taken from that. That is actually something else...
Completely agree. We have this in the documentation for .net. Also the types and parameter names [pops up in intellisense](https://i-msdn.sec.s-msft.com/dynimg/IC829254.jpeg). I think exposing the second line is better than inline type annotations because it's become the convention now.
This is awesome. Out of curiosity, did you use any libraries to do the folder and file management on the left pane? Edit: nevermind, [found it](https://github.com/erkal/kite/tree/master/kite-libraries/file-system/src/FileSystem).
while this might be a good idea, I don't feel like it solves the real problem. The real problem is that the docs aren't good enough to figure out what the function does. I think a much better alternative would be have good code examples! These are most direct way to show how the function works. It has the added benefit of being able to elm-doc-tests . https://github.com/stoeffel/elm-doc-test/blob/master/Readme.md. Although this may not be true I think having the parameters names exposed could make people lazier in the docs because they could make the assumption that their name makes it "obvious" and thus not requiring documentation. Naming things is hard and different names mean things to different people especially those who don't speak English as a first language. Code is more universal.
To add to this I would say, start with a working example and compile often. The mistake I made early on was to edit too many things and not compile. The compiler gives more meaningful errors when there's less things broken about your code. I think editor plugins are ideal for this purpose because they check at least every time you save. 
Interesting projects! I think the auto expand "component" might actually be more useful to me as a function. Maybe taking in the config and the text and returning the height. That way I could use it on normal text areas. Probably would be less varbose too. 
&gt; Is using non-published packages recommended for noobs? NO! The packages that cannot be published on the official repository are a very dangerous thing to meddle with when starting with Elm. I have created such packages and they are nice for exploring advanced concepts and trying to push the capabilities of Elm BUT, when starting out, it is best to stay within the original framework and solve the kind of problems that Elm can solve officially. After you have produced enough functionality with Elm and are confident that you understand sufficiently well how Elm works, then you can venture into the dangerous terrain. &gt; the module I’m looking at is Fresheyeball/elm-node That module has not been updated for two Elm versions, and, most importantly it is a pre 0.17 module. I would not recommend investing beginner time in anything bellow 0.17. If you want to integrate Elm with Electron, ask for support in the #electron channel (Slack) BUT, again, I would suggest to do this after you get comfortable with Elm. 
Let me answer anyway: I only use `elm-community/undo-redo` and a small hashing library, `FNV` that can be easily avoided. `elm-community/undo-redo`is great, because it is simple and works well. If you want to undo-redo, just go with that library. Another note, file-system makes sense on its own. You don't need to use it with graphs. You can use it with any file type. But all files must have the same type. 
I guess you’re right and I should get myself busy with the frontend part and get comfortable with Elm first, and only deal with the backend after that. I was just thinking I’d build a proof-of-concept that is capable of reading and writing files at all, but I guess I’m overthinking it. Thanks for your answer!
This is how I think about it. I can either wrap in (), or just use &lt;|. I typically use &lt;| when building a list of HTML elements. For example, div [] &lt;| List.map f elements
Yes, constructors (Foo/Bar/Baz) of a type (Msg) are *both* ordinary functions, as well as special constructs for matching purposes. `Foo` is a function; specifically it has type `String -&gt; Msg`. Most ML-style languages follow this basic convention.
&gt; Is this a valid way to break up big update functions? Not really. Catch all cases are OK in development (temporarily) but I believe that they should be avoided in production. I believe you are making your code more fragile by using them. Splitting the Msgs in categories is a way better approach in my perspective. 
After a bit of trial and error, this is what I ended up doing in a side-project of mine: The main update: https://gist.github.com/ryan-senn/d6731568a5b5eac893d7719f55e36c67#file-update-elm The login update: https://gist.github.com/ryan-senn/d6731568a5b5eac893d7719f55e36c67#file-loginupdate-elm So pretty similar, the difference is that I use union types to split my Msg into smaller chunks, and the update function only deals with those as you can see here: `update : LoginMsg -&gt; Model -&gt; (Model, Cmd Msg)` The main Msg: https://gist.github.com/ryan-senn/d6731568a5b5eac893d7719f55e36c67#file-msg-elm The login Msg: https://gist.github.com/ryan-senn/d6731568a5b5eac893d7719f55e36c67#file-loginmsg-elm This is part of a single page application which has about 20 pages and around ~120 Msg I think. Took me a while to get to this final way of structuring my code, but I like it so far.
Thanks so much for capturing this! Defiantly brings some clarity about tasks and cmds. 
&gt; I understand basics of the type system, but Parser takes parameters and the type uses a constructor of the same name. Please explain what does it mean? The `Parser` type in your example is a union (or sum) type with only one constructor. The way they are defined is like this: type Parser a b = Parser (State a -&gt; List (State b)) ^ ^ ^ ^ ^ ^ keyword | name of type | generic type arguments | constructor name | first constructor argument The `a` and `b` are the generic type arguments of the type: in C# or Java it would look like this: `Parser&lt;A, B&gt;`. In your example, it means that you have a Parser which parses things from type `a` to type `b`. The constructor `Parser (State a -&gt; List (State b))` takes a function that given a `State a` returns a list of zero or more `State b`. The constructor and type can have the same name, but are not the same: the type is used in type annotations and for type checking, while the constructor is essentially a function which returns an instance of the type. Union (a.k.a. sum types) can have multiple constructors: type Maybe a = Just a | Nothing This is the complete implementation of the build-in `Maybe`-type. To create an instance containing e.g. a `String` you call either the `Just` or `Nothing` constructor, passing in arguments as needed: if String.isEmpty str then Nothing else Just str The constructors can also be used for destructuring any data inside it, using pattern matching. To get your string out of the `Maybe String` used above we can do this: case maybeStr of Just str -&gt; str Nothing -&gt; "There is no string" **NOTE:** *It is usually preferable to use Maybe.map and Maybe.withDefault instead of pattern matching all over the place. Pattern matching is very verbose and hurts readability.* In contrast, a `type alias` is just assigning a (new) name to an existing type: type alias State value = { visited : List String , unvisited : List String , params : Dict String String , value : value } type alias Email = String type alias GivenName = String type alias Money = Int The purpose of using a type alias is mainly about readability and documentation: by giving a type a more descriptive name I can make my code easier to understand. If I had a method to calculate the order total, using a type signature of `List OrderItem -&gt; Money` would be easier to understand than `List { quantity : Int, price : Int } -&gt; Int`. One reason for using a union type instead of a type alias, is that when exposing (i.e. exporting) functions in your module you can hide the constructors of a union type making it impossible for any other module to poke around in the internals your your module's implementation. Consider the following module definition: module MyParser exposing (Parser) type Parser a b = Parser (State a -&gt; List (State b)) Since we expose the type, but not its constructor (this would require using `exposing (Parser(Parser))` or `exposing (Parser(..))`), no user of this module knows how to destructure the Parser-type and all interaction with your parser library have to happen through the MyParser-module. There is no change of an outsider *hacking* your internals, causing confusing bugs. Also, it makes it safe for you to modify how the internals of your module operate, since they are strictly isolated. &gt; How do I understand type systems better? Look up sum/union types and product types. They are the basic building blocks of all functional programming languages. The Elm Lang Guide has a section about its type system available at https://guide.elm-lang.org/types/. &gt; Are there any good resources to understand functional programming for a OOPs guys? This book comes recommended by OOP guru Robert C. Martin: https://leanpub.com/fp-oo. I haven't read it myself but it looks promising. I come from OOP myself, and I think that the difference between OOP and FP is overstated. At the end of the day, writing good OOP is basically writing good FP. It's just that using a functional language makes it sooo much easier. &gt; Should one learn F# or Haskell (with much better FP documentation) before learning ELM? I hope not! ;)
I don't understand, Elm has the syntax it needs to have in order to be functional by default. 
Structuring a program in an ML provides certain facilities that aren't available in a language with javascript'ish syntax, if that is a word. Obviously. So the way to think about how you put the pieces together makes you think in a different (objectively) way since most of the seremony javascriptish (algolite?) forces upon you, is nonexistent because everything is an expression or everything is a value. Could elm be a JavaScript and what would that really change? 
Looks pretty neat. Thanks for sharing! Couple of queries.. 1. How would you handle "redirect" to Login page for not-logged-in users? For handling that "root" update like OP mentioned looks like a good option. 2. LoginRequest -&gt; { model | loginModel = request model.loginModel } ! [ Api.loginRequest model.loginModel.email model.loginModel.password ] I am pretty new to Elm, what's the significance of "! []" here?
You could just make it look like JS though, right? Being syntax and all : )
This is an ML with JS syntax - https://facebook.github.io/reason/#syntax-basics but I don't know the details, so maybe you are right...
Great, I think we will adjust the T-shirt to have that on instead..
Here's a small example comparing the tupling of Maybes: Elm: maybeThree : Maybe a -&gt; Maybe b -&gt; Maybe c -&gt; Maybe (a,b,c) maybeThree ma mb mc = ma |&gt; andThen (\a -&gt; mb |&gt; andThen (\b -&gt; mc |&gt; andThen (\c -&gt; Just(a,b,c)) ) ) And Haskell: maybeThree ma mb mc = do a &lt;- ma b &lt;- mb c &lt;- mc pure (a, b, c) Or using Applicative Syntax: maybeThree ma mb mc = tuple3 &lt;$&gt; ma &lt;*&gt; mb &lt;*&gt; mc
Could you give an example of what you have in mind? One where everything is still functions. 
something like this &gt; https://facebook.github.io/reason/#syntax-basics 
I can't really read your examples - but I generally really like Elm format...
I agree. Pls read my reply above on this https://www.reddit.com/r/elm/comments/620w34/elms_biggest_mistake/dfj0n6g/
True. But what you might find (on elm-discuss for example) are recurring questions on `why Elm doesn't have * like Haskell?` and the answer (usually) is like `Well, because Elm is not Haskell` ;) And I (personally) don't like any comparisons of Elm to Haskell because of the Haskell's motto: "avoid success at all costs". I'd be very uncomfortable working with Elm if it had this kind of motto to evolve with.
Did you know it's a commonly misinterpreted motto? It should be read "avoid (success at all costs)" rather than "avoid success (at all costs)". One definitely much more negative than the other!
Elm's biggest mistake is not syncing with Elixir's syntax. If Elm could be seen as a frontend framework for Elixir as opposed to an entirely different language, those two would dominate future web development
Why though.
&gt; update : LoginMsg -&gt; Model -&gt; (Model, Cmd Msg) I have figured it out exactly the same. The key is to make all sub-update functions exactly like this: they take specialized message and root model and produce root model and root message. It is very flexible, you can publish any kind of message from within any module, for example you can create a button to redirect to PageX from the update function of PageY (typical use case). Just import the appropriate message from side-module and publish it.
i think elm tries to simplify things just a bit too much. coming from haskell, i really want to like elm... but i find myself frustrated with the lack of options for abstraction. the push towards a narrow set of tools and patterns almost seems condescending as well. if you take a look at elm's official pseudo-lens library "focus", you'll see the readme and comments are all discouraging you from using it. it's like, for what purpose then was this written? just to tell people they're wrong?
Make it easier for JS ppl to move over (like Rubyists &amp; Elixir) and make it obvious to Haskellers that it is not Haskell : )
This is a quote by SPJ https://news.ycombinator.com/item?id=1960243 Sometimes I'm afraid of Elm taking the "research path". 
Next level: they're shit anyway
How can full page reloads be handled at API only backend with Elm SPA? I was completely stumped by (!), now it makes sense, Thanks!
Nice to know that I'm not the only one that came to this conclusion :)
If you're dealing with a list as the OP mentions then you'd use the Traversable typeclass here, so it would be just a call to *sequenceA*, no need to define a new function or anything: Prelude&gt; sequenceA [Just 1, Just 2, Just 3] Just [1,2,3] Prelude&gt; sequenceA [Just 1, Just 2, Nothing] Nothing Functional programming is mostly about working with structure. Not being able to work at the most efficient, and in my mind readable, abstraction level makes things more difficult and leaves a lot more room human error. Edit: wording
I think the biggest issue with trying to make the syntax feel "familiar" is that sometimes people have a problem separating their old mindset from the new one that a functional language requires. It's something that trips up newer elixir programmers. I think Elm's departure from JS syntax, while working in the same frontend space, makes that transition period more abrupt. (Though, as you point out, maybe too abrupt.)
How would you iterate without recursion and without mutable variable references? Fold is implemented as a recursive function.
Allow me to ask "Why in hell would we remove recursion? It's such a powerful tool"
Power is not necessarily a good thing. Power and complexity are correlated, and I rather keep things simple - esp when the power may not be even necessary (fold can do almost everything recursion can)
Removing recursion would make it impossible to traverse custom defined data structures, like trees. Sure, you can do most List things with a fold, but now you're stuck using lists for everything.
I think it's because Elm has been designed for Elm users, not JavaScript or Haskell users. - Rex
To me the main argument is to avoid crashes - right now you can still pretty easily crash an Elm app by calling a recursive function on a large data structure. It's particularly worrying because it's the sort of bug that can show up only once you start testing with large amounts of data (or in production, if you only ever test with small test cases). Just yesterday I got a runtime error in the Elm debugger since it was trying to introspect a large mesh (a few thousand vertices) that I loaded from JSON to render in WebGL - it was fine with little cubes and the like but got a stack overflow when I tried to load the Stanford teapot model. I don't think the answer is to do away with recursion entirely, but I think stuff like compiler warnings for recursive functions that aren't tail recursive could be useful. And in the long term perhaps function annotations so you can declare that a certain function should be tail recursive (so it should trigger a compile error if it isn't) or explicitly not tail recursive (so the compiler won't even issue a a warning).
Why is this dowvoted? Turing completeness inherently makes languages not completely defined. Programming languages as is already aren't fully Turing complete because they don't have infinite tape/memory. So it's clear being Turing complete isn't a requirement for being a productive language. Ensuring the language only supported bounded recursion instead of unbounded recursion, would ensure that no programs ran till they crashed, but still would cover 99% of all programs today. The future of programming languages will be to remove Turing completeness and move closer to mathematical purity and being well / completely defined. Removing dynamic typing via Hindley-Miller typing goes a long way to eliminating classes of program failure, and I believe removing *unbounded* recursion from languages will be next.
thanks - enlightening!
What are you hoping to gain by doing without this? How are we supposed to conceptualize what a fold does if not recursion or loops? I have never been clear on why some people are so gun-shy when it comes to recursion.
I like conversion, but it can get complex in the wrong hands
what the fuck is wrong with you? first the "shouldn't elm look more like javascript" and now this? i sure hope you are trolling.
My favourite part of Bulma is that it comes with no JS whatsoever. Unlike, any other CSS framework I saw so far.
Can you report the performance bug to https://github.com/elm-lang/virtual-dom/issues so it's recorded for later? Lazily converting to expando would be pretty tricky, but if you can make an [SSCCE](http://sscce.org/), that will make it way easier to sort out.
Done - although having looked at the `virtual-dom` issues list I think what I encountered is really a duplicate of [#80](https://github.com/elm-lang/virtual-dom/issues/80) and [#86](https://github.com/elm-lang/virtual-dom/issues/86), so I've added my SSCCE as a comment on #80 instead of opening a new issue.
No worries, I have not communicated this stuff clearly yet. It'll get there! Also, the new issues is great! Thanks for working through this with me :D
You are posting statements implying you have answers, but are not supplying any.
I think it's an interesting discussion to have, especially given /u/VeggiePaninis' response.
The languages are Turing complete, the machines they run on aren't and we specifically and intentionally limit the size of problems we solve to fit within those limitations, but the general case of those problems requires a Turing machine. Unbounded recursion (the while loop) is essential in any program that needs to deal with any form of communication or user input, where knowing the bounds requires knowing the future. You can limit unbounded recursion for a certain subset of programs but web applications definitely have requirements too general for such a limitation. A common example is polling a server, "while we haven't got a response, request again every 2 mins". How many times should we poll the server? 
&gt; The languages are Turing complete, the machines they run on aren't and we specifically and intentionally limit the size of problems we solve to fit within those limitations, but the general case of those problems requires a Turing machine. Agreed, but this is just another way of saying what I was saying. We don't require the full power of infinite recursion to be productive. There are definitely situations where we don't know how long to iterate. So maybe a better more accurate statement is "removing the ability for unbounded recursion to produced undefined program results". In haskell terms the difference between running fold vs scan on an infinite datastream. In the case you called out, we would label the server poll results as co-data, and appropriate for co-recursion, since we don't know how long we'd have to poll for. But we could statically prevent any code from calling 'tail', 'max', or any other function whose behavior would be undefined on this infinite stream of data. This allows us to eliminate classes of invalid programs. [1] http://www.tac-tics.net/blog/data-vs-codata 
&gt; We don't require the full power of infinite recursion to be productive. Yes, we do. A huge percentage of useful software is one way or another based around event loops that are infinite and process requests - for example all sorts of network daemons, DBMs, heck, even simple GUI programs. These programs hang in an infinite loop _by design_. When processing requests, we need to allocate arbitrary amounts of memory. Of course, we don't want programs to _actually_ allocate an arbitrary amount of memory (potentially larger than what's available on the actual machine), and so having the program respect some upper bound is a nice thing, but this upper bound cannot be statically defined as part of the program's source code, because we need to change it dynamically. It's a matter of configuration. 
What is the community's view on hosting functions in the state? I'm curious because I was doing it once, too.
Yeh, but I think it reflects expectations. If you look at Elixir you don't complain about lack of purity, static type checking etc. But if Elixir looked like Haskell perhaps many would...
Aw, that's super disappointing. Do we know what the lifespan on the existing elm-mdl library will be? Is there a path forward with components?
In general I'd say it's definitely not recommended - it has some immediate and clear drawbacks like not being able to serialize the model or introspect it in the debugger (usually desirable and useful, just not in this specific case!) and I think there's a more general sense that it's easier to follow your application's logic if the model is pure data. For example, the README for the [elm-sortable-table](http://package.elm-lang.org/packages/evancz/elm-sortable-table/latest) package strongly recommends not putting functions in your model, going so far as to say that rule is "one of the core rules of the Elm Architecture".
I think the Elm-formatted one looks beautiful - it's really personal :)
Awesome!!!
The project this presentation is on is open source. https://github.com/dailydrip/firestorm
You can use another stack instead of the call stack for that. There are non-recursive implementations for tree traversals and whatnot, but they are slower, a lot more harder to comprehend and so on. Removing recursion is a dumb thing. 
I like the ability to easily expose a snippet as a function (much better than Angular's directives or filters). This is somehow similar to the JSX. What I like even more, is the type system backed into it. You can browse the commands and find it's usages in those view functions. You can change something in commands and compiler will check if the bindings are still OK. This is something I have never seen before. 
Sure :) But that's not my point. The beauty of s-expressions (Lisp syntax) is above all else to me. There's nothing simpler than that(nothing that I'm aware of). But when it comes to readability (large chunks of Clojure code e.g.) - it's a mess :(
&gt; enlightening Uh, I don't think so. I'm calling BS on that post in general and on this claim in particular: &gt; Ensuring the language only supported bounded recursion instead of unbounded recursion, would ensure that no programs ran till they crashed, but still would cover 99% of all programs today. First off, I don't see how the writer of this arrived at the conclusion that bounded recursion prevents crashes. Stack overflow (and related conditions) is **not** caused by infinite recursion but rather by recursion beyond a certain (_finite_) threshold. Bounded recursion in and of itself doesn't prevent that unless you have a reliable way to figure out the safe bound, which you typically don't have. (You'd need to only target a specific hardware + software configuration, think spacecraft.) Second, I'm not buying that such a language would cover 99% of programs, I'm not going to believe that unless backed up by solid evidence. Which IMHO would amount for a scientific breakthrough worth of awards. Besides, you complained about recursion being complex. You do realize these ML-style languages are _way_ more complex than simple recursion, right? 
Thanks for the link!
I love that the HTML generating code is just Elm. JSX is it's own thing, and you have to do conditionals and loops by wrapping them in specially-defined constructs, which is really ugly. But in Elm, you can use `List.map` or any of its fancier cousins to create the children of a DOM node, and everything Just Works.
Looks awesome! I like how you've set up the subscriptions/state management, a little more clear/explicit than `elm-mdl` in my opinion. Performance of all the various components seems good even on my phone...I'll have to give it a try! Now if only Bootstrap provided a slider...
Haskell has 2 main HTML DSL's (domain specific languages), blaze and lucid. Both kinda feel somewhat comparable to elm's html package.
This example is really useful. It should be in the official documentation. I gave up on Elm for a project I was working on (though I plan to return to it at some point and finish the Elm version) because I was attempting to do what you did here but couldn't get it working. The key thing I learned from your example that I was doing wrong was trying to map the submodule-specific message types to the main message type back in the main update function. Instead, I'll do it like your example, where the submodule wraps its return value in the proper enum variant of the main msg type before returning it.
Look, if you rebuild your web app to be totally in the frontend with Elm, Angular etc then you will make it so that people who turn off JavaScript or have really old browsers can't use it. The questions you have to ask are 1) How many of those users do you have 2) Will loosing them hurt you more than the upsides of the change
Real time communication has its place. But I am not a fan when it comes to tech chat somehow. Keep up the good work dude - really appreciate it!
You have full instructions in the README. `elm-live src/Main.elm --output=app.js --open -- --debug`
Downloading elm-live as we speak (NPM is slow on the train) somehow I thought it wouldn't give me the debugger. Thanks for your patience and help : )
Bummer, tx for the heads up the faulty link ! 
Yup, something like that slider would be great! I agree autocomplete would be more generally useful to more people though.
Do this instead: sudo apt-get install nodejs sudo npm install -g npm sudo npm install -g elm
Follow RusinaRange's advice. This tutorial is old. Plus the build script that's hosted on Github returns a 404, so its not even completable.
Thanks for your concern, really appriciate it. We do our best to check license and/or contact projects before using their logos, and will continue doing that. 
Hello, Elm people. I've just added Elm support for this tool I'm writing. Please see screenshots on the link to understand what it does exactly. The title is misleading, it doesn't only link to the Elm Package directory documentation, it also does internal module linking (when some file imports another module from the same package). Although I've done some personal projects on Elm, I'm not an active Elm coder, therefore I would appreciate feedback from hard Elm users who browse source code on GitHub: does it help? Where is it failing? Could someone else be implemented? Thank you very much.
That worked much better, Thank you!!
Subscribed and watched them all! Waiting for the next one :) Thank you!
You are lucky to have found Elm so quickly - imagine it takes years for people to sift through the amount of not-as-good-as Elm languages to reach this place... If I could have skipped Java &amp; Python etc. I'd have years of my life back : )
I'm working on the elm-conf website. Hopefully I'll get it up this week for the CFP period to open next week. :D
I'm not sure if it can or not. It can be packaged into a self-contained executable. However It's generally more suited for web servers and things of that type. Glad I could clarify :). 
The points against lazy evaluation were interesting too; I hadn't heard them put quite that way.
I got it! serviceDecoder : Decode.Decoder (Dict String Item) serviceDecoder = Decode.at [ "services" ] &lt;| Decode.dict ( decode Item |&gt; required "name" Decode.string |&gt; required "command" Decode.string)
Self-promotion is what this thread is for. You're good. :)
I suggest you use an Array instead of an list. There you can just `Array.get` the correct index and then `Maybe.withDefault` away the Maybe. You know it will never return a `Nothing` anyway. Edit, updated: https://ellie-app.com/QdWNZD8jc4a1/1 Old version: https://ellie-app.com/QdWNZD8jc4a1/0 If you want to get rid of the intermediate Maybe value, then you need dependent types. With those you could use a modulo function `% 10 : Int -&gt; Int&lt;0, 12&gt;` where the strange `Int&lt;0, 12&gt;` ensures that you only get positive values below `12`. But A) this seems like overkill, and B) Elm doesn't support his.
I would also be interested what experiences people had with this.
Hi! I've done this. Actually, my first project using Elm in production involved this. It works pretty well, overall. One of the headaches you'll run into is needed to use ports a lot if you want to use native phonegap functions. We can help you out with that though. I recommend joining the [Slack](https://elmlang.slack.com) and we'll be able to help you. 
very interesting, a real-word case study. Thanks for sharing! I'm also happy to see that the biggest problem you had were the well know ones: the non-imperative interaction with the DOM and the CSS modules.
It *is* my talk, and I'm glad you found it interesting! :)
Indeed, it feels less clunky to just use a basic list or array. Also `|&gt; Maybe.withDefault` looks like a good way to have terse expressions in those cases. I need to look more into this kind of helpers. It makes me realize that I'm actually looking for a `findIndex` function. Just went with a recursive definition: indexForNote : Note -&gt; Scale -&gt; Int indexForNote note scale = case scale of [] -&gt; chromaticLength n :: rest -&gt; if n == note then 0 else 1 + (indexForNote note rest) At first I was tempted to write it down like this :) But it looks like pattern matching does not work with dynamic value (yet!) indexForNote : Note -&gt; Scale -&gt; Int indexForNote note scale = case scale of [] -&gt; chromaticLength note :: _ -&gt; 0 _ :: rest -&gt; 1 + (indexForNote note rest) 
Perfect, thanks!
Oh, OK, that makes more sense. The answer from jediknight should give you some ideas. Am I right in assuming the module that this function is defined in also sets some kind of state via the `Scroll` message? In that case you want to provide some wrapper from this message type to the message type of the call site/parent. That's `(Msg -&gt; msg)` in jediknight's second example below. This is kind of the classic Elm architecture way of doing it. Each place you use it will need a msg to wrap the Scroll message, and a corresponding update case. Alternatively, if you manage scroll state externally, you can simply inject the handler: view: msg -&gt; List (Html msg) -&gt; Html msg view onscroll rows = div [ onScroll onscroll ] rows 
Damn, that's a great talk and recruiting video! The only thing I'm missing in the end of the video is where the company is located. I see London, Melbourne, New York and San Fransisco mentioned on their [jobs page](https://www.cultureamp.com/jobs.html). u/kyank 
That is far from where I am. But as a developer - I think the strategy of using a tech people love is a good one. For the last years I've been working entirely in Clojure, because I love the language. While I'm only one data point, the companies I've contracted for have thus been successful thanks to using Clojure and thus getting the labour of my and my colleagues. Again thanks for a great video. 
Our Event Sourced Datastore on top of Postgres. It's called Slate and it an immutable database and written in Elm. It's still in alpha at https://github.com/elm-slate. 
I'd say you're correct that Task and Promise are similar in concept and use. A big difference is that Tasks can be defined without executing them, and Promises execute immediately. You can find a WIP version of the Elm Guide page on Tasks on Github: https://github.com/evancz/guide.elm-lang.org/blob/master/docs/error_handling/task.html 
I have a question about "when" a function is actually called. Given a simple "random gif" application: getRandomGif : String -&gt; Cmd Msg getRandomGif topic = let url = "https://api.giphy.com/v1/gifs/random?api_key=dc6zaTOxFJmzC&amp;tag=" ++ topic request = Http.get url decodeGifUrl in Http.send NewGif request decodeGifUrl : Decode.Decoder String decodeGifUrl = Decode.at [ "data", "image_url" ] Decode.string init : String -&gt; ( Model, Cmd Msg ) init topic = let waitingUrl = "https://i.imgur.com/i6eXrfS.gif" in ( Model topic waitingUrl, getRandomGif topic ) main : Program Never Model Msg main = Html.program { init = init "cats" , view = view , update = update , subscriptions = always Sub.none } When the program is run, 1. When is `Html.program` actually called? 2. When is `init "cats"` actually called? I'm trying to understand whether or not `init "cats"` returns and is bound to the record before `Html.program` is called. 
Starting preliminary work on a side project idea of mine: An app for crowdfunding "conversation bounties". For example: say I really wanted to get snoop dogg on the elm town podcast. I set up a $100 bounty for that conversation that anyone else can contribute to. Then, if murphy and snoop agree on a certain minimum amount and the community reaches it, they split the bounty and produce the podcast episode. It looks like its going to be a haskell/elm/postgres web app on heroku, with stripe for payments and twitter for identity. Writing the backend business logic in an elm-y style (modeling the state of a bounty with a tagged union and an update function to step it along) was surprisingly straightforward!
&gt; I'm trying to understand whether or not init "cats" returns and is bound to the record before Html.program is called. `init "cats"` is evaluated and the value it returns is used to construct the record that is passed to `Html.program`. Then `Html.program` is evaluated and a `Program Never Model Msg` value is produced. The Runtime uses this value to start and run the program when you call `Elm.Main.fullscreen()` or `Elm.Main.embed(someNode)` from JS. 
 module Main exposing (..) import Html exposing (Html, program, text, button, div) import Html.Events exposing (onClick) type alias Model = Int initialModel : Model initialModel = 0 init : (Model, Cmd Int) init = initialModel ! [] view : Model -&gt; Html Int view model = div [] [ text &lt;| toString model , button [onClick &lt;| model + 1] [text "Push me"] ] update : Int -&gt; Model -&gt; (Model, Cmd Int) update msg model = case msg of i -&gt; i ! [] subscriptions : Model -&gt; Sub Int subscriptions model = Sub.none main : Program Never Model Int main = program { init = init , view = view , update = update , subscriptions = subscriptions } 
If you have atom with elmjutsu + hyperclick, you can ctrl+shift+click (customizable) on Html, and it will go to the definition. It will take you to `Html.elm` where you will see this: type alias Html msg = VirtualDom.Node msg `msg` (small cap) means some type, so `Html` is parametrizable. `Msg` (large cap) means specific type. If you have code: type Msg = ButtonClicked viewButton : Html Msg viewButton = button [ onClick ButtonClicked ] [] `view` function will return `Html Msg`, because its message isn't passed as a parameter. If you want to pass the message as a parameter, the inferred returning type for `viewButton` will be `Html msg` type Msg = ButtonClicked viewButton : msg -&gt; Html msg viewButton msg = button [ onClick msg ] [] view: Html Msg view = viewButton ButtonClicked You can set `viewButton` to always return Msg (specific type) type Msg = ButtonClicked viewButton : Msg -&gt; Html Msg viewButton msg = button [ onClick msg ] [] view: Html Msg view = viewButton ButtonClicked Another case is with `onInput` which requires function `String -&gt; msg` type Msg = UpdateInput String viewInput : Html Msg viewInput = input [ onInput UpdateInput ] [] view: Html Msg view = viewInput If you want viewInput to take message as a parameter: type Msg = UpdateInput String viewInput : (String -&gt; msg) -&gt; Html msg viewInput msg = input [ onInput msg ] [] view: Html Msg view = viewInput UpdateInput
I think the lack of a message was throwing me off - you never see 'void' in Elm... V good explanations all - thanks
You will see this sort of thing in a lot of places, a list with no elements is a `List a` the type of `Nothing` is `Maybe a` and the type of html which doesn't produce a message is `Html a` (or `Html msg` as a hint for documentation purposes, they are the same). &gt; why couldn't 'Html msg' be just 'Html' when there are no messages emitted Perhaps it could, but that would be more complicated to understand what you are reading when looking at the code. There are a bunch of edge cases which would need to have syntax to resolve and most of the time there is going to be something in there. For example: div : List (Attribute msg) -&gt; List (Html msg) -&gt; Html msg The `msg` here is indicating that the messages generated by the list of `Attribute`s and the list of `Html` children have to match in type and it will produce `Html` that produces that same type of message. I can only think of `text` from that module which always returns `Html` that doesn't generate a message.
Awesome thank you! I will take a look at the WIP version.
I don't know of a way to ignore the result of a `Task`, but if you have a `NoOp` message and use [`Html.Lazy`](http://package.elm-lang.org/packages/elm-lang/html/2.0.0/Html-Lazy) on your top-level `view` function then there should be no real performance concerns since no DOM (virtual or otherwise) will actually be rebuilt/modified.
Great talk /u/kyank! One thing I'm curious about us regarding your CSS issues; have you looked at elm-css and how it integrates into Elm, and would it solve your pain you think? I realize it would be quite different because you lose the CSS module capability (presumably), and it should still play nice with the teams you have using React, but I'm curious :)
It's not ideal but you could do something like this: module Main exposing (main) import Html exposing (Html, a, text) import Html.Attributes exposing (href) main : Html msg main = let url = "https://www.google.com/" in a [ href &lt;| "javascript:window.open('" ++ url ++ "', '_blank')" ] [ text "Hello" ] 
I actually thought you might be able to do something similar with `Html.Attribute.property` and just add a custom `onclick` property to an arbitrary element but I haven't been able to get that to work. If all else fails you could set up a port that you use to call javascript that adds appropriate handlers. That's definitely not ideal either though.
Is there an elegant way to access the property of the new model when handling a message in `update`? For example, given: update : Msg -&gt; Model -&gt; ( Model, Cmd Msg ) update msg model = case msg of Increment -&gt; ( { model | counter = model.counter + 1 , increments = model.increments + 1 } , Cmd.batch [ increment () , storage model.counter ] ) Say that instead of `storage model.counter` I wish to use the new counter value of the new model, which is the first value in the `(Model, Cmd Msg)` tuple. I could use a `let`: Increment -&gt; let newModel = { model | counter = model.counter + 1 , increments = model.increments + 1 } in ( newModel , Cmd.batch [ increment () , storage newModel.counter ] ) Note the use of `storage newModel.counter`. Is there a more elegant way to do this, that doesn't require a `let`? 
It works! Thank you!
Use something like [remote-data](http://blog.jenkster.com/2016/06/how-elm-slays-a-ui-antipattern.html) or [elm-web-data](http://package.elm-lang.org/packages/ohanhi/elm-web-data/latest). 
Playing around with a 'visual CSS Grid builder' in between projects https://github.com/ericgj/css-grid-builder
I did manage to get something working to do this using Native code. This was with webGL v1.something and was a while ago and I was in the midst of messing with a pile of stuff so the details are a bit vague in my mind... I've pulled out what looks like the relevant stuff into a gist: https://gist.github.com/roovo/04881726413fcd78b0e91ade50c92bab As I said, this was with webGL v1. In essence I found that you could just tell WebGL that a canvas was just a Texture (as per using what was loaded using - the old function - WebGL.loadTexture) then it all just worked. I've just looked at the v2 code in WebGL and it looks a bit different so some/much tweaking could well be required). The native code in the gist was just the way I built a canvas with some text tagged as a Texture for WebGL to use. Note that the canvas node in the code I've posted is just attached to the document - and isn't managed by elm - this may not be the best idea... not sure if you'd end up with a pile of nodes building up over time (I was just experimenting)....
Writing a dashboard integrating Google Visualisation , Google Sheets API v4, oauth and Google Sign in API.
I have a few changes to make to Elm-Canvas, which is a project Ive been working on with a few others to make the canvas api more accessible within Elm. In the last month we've gotten some really good feedback that we need to incorporate: https://github.com/Elm-Canvas/elm-canvas And then, this huge in-browser image editing application that will at some point use said canvas library. This is by far the largest Elm project Ive worked on, with three SPAs, each with like 40 modules and counting. https://github.com/Program-House/CtPaint
While I think that it's great to share community packages, I'm not sure if this is the best answer to give in this situation. The question seems to be "how does this work in elm/TEA". My interpretation of the question is that OP wants help to understand how it works, he's not necessarily after a pre-made solution. To answer the actual question, you want to store this in the state. The easiest way would be to store this as a boolean, for example: ` type alias Model = { ... your existing model , isRequestLoading : Bool } ` As per your example, clicking a product will send a Msg to your update function, and I assume that you do something like this in that particular branch: ` case msg of HandleClick -&gt; model ! [ apiRequest ] ` What you want to do, is update `isRequestLoading` in your model at the same time like so: ` case msg of HandleClick -&gt; { model | isRequestLoading = True } ! [ apiRequest ] ` Now you can simply check for that property and display the spinner accordingly. When the response comes back, you can update the model to set `isRequestLoading` back to false. Now the challenge in a real app would be: how do I handle multiple requests? If I launch request 1, then request 2, request 1 finishes, but request 2 is still pending... What then? Your model would be: request 1 sets isRequestLoading = True, request 2 sets isRequestLoading = True, request 1 finishes sets isRequestLoading = False, although there is still a pending request. Realistically you would need to replace `isRequestLoading` with a List or Dict of ongoing requests, and clear them out when they complete. And you would show the spinner if that list contains more than 0 entries, as it means that some request is pending.
Hey, folks. Help me grok `Task Never a`. What does it mean for a task to have an error type `Never`? That any task that *does* return any kind of error in its Elm code will result in a compiler error? And, on a higher level, does the `Task.perform` signature change from Core version 4 to 5 mean that any task that *can* result in an error should be run via `Task.attempt`?
Update: the reason I was asking is that as of today, [Richard Feldman’s course on Elm](https://frontendmasters.com/courses/elm), which is pretty great, by the way, but also obviously outdated on some points, because Richard talks about 0.17, recommends doing http requests like this: let task = Http.get responseDecoder url in Task.perform HandleRequestError HandleRequestResult task Not only has `Task.perform` signature changed since then, turns out you don’ need it at all in that particular case, because we have `Http.send`that returns `Cmd msg`, so the above can (and should?) be done as: let request = Http.get url responseDecoder in Http.send HandleResponse request 
An interesting read! However it seems they sort of talk beside a big point of "task ports". My example is not so much communicating with the outside world in a general sense but more communicating with the browser, using in Elm unimplemented browser APIs. The responsibility would be completely on the javascript side to return a result, but right now the only way to call these API:s is to write "Native" code, or to make "dual ports", one for sending a command, the result of which is then returned in a subscription and need to be paired with the call without any guarantee of the order of the results etc. The question is, why is it worse to have a Task not return a result than to have this other mechanism not deliver a Msg? In both cases you'd get nothing. Especially if Native becomes Kernel and even more unapproachable (which in itself is probably a good thing), then we really need a way to have the user make Tasks, or something similar to be able to use the browser APIs. For databases, websocket-like stuff, http calls etc, that have internal state, then effect modules are probably better, but for calling a function to get some crypto random or to access LocalStorage? Seems like it's too much to create an effect module for that, just look at the code in my example above. That level of simplicity should really be available if people are going to be able to use browser apis productively.
Depending on exactly what you're doing you might be able to combine a WebGL scene with CSS 3D transforms on normal HTML elements, like in this example: https://github.com/w0rm/elm-webgl-playground#css3delm
everything we are telling is a "story". But some titles are better at reflecting what the story is. It's like adding the word "movie" to every movie. What if "Retune of Jedi" was called "Retune of Jedi Movie" or "La La Land" was called "La La Land movie". How much "movie" adds value or information to the content that is presented there? 
At least it made me think =) No, it did a lot of sense, but... for instance, will `.map2` still give me an error if I mix `Task Never a` and `Task String b`? Looking at its type I think it should, because `Never` and `String` are different types, but maybe `Never` is special because it never happens, so it never actually harms anyone.
You liking Typescript? I've thought it might be a good choice the current stuff written in Babel. 
We currently have an application written in AngularJS that has huge internal state; we routinely store hundreds of megabytes of numerical data in web browser's memory. This brings us competitive edge over other applications in the same domain, as we avoid costly server round-trips for most operations this way. We do depend on tricks like storing data in flat float-only arrays (modern JS engines optimize this specific case into pretty much a plain C array). Obviously we're not using all data at the same time, the views only show small percentage of that data at a time. I am thinking of trying Elm for the next version. I searched for any information about efficiency of the Elm implementation, but all information that I could find was about Elm's speed was about its shadow DOM implementation (maybe I just couldn't figure out the right keywords to search?). Hence my question: what is real-world Elm performance when the *model* object is huge? Were there any case studies published? Are there any known problems?
I figured out a shitty work around in the mean time. I am taking the synchronous code from Google and putting it into its own HTML file. I then use an iframe in Elm in order to load that into where I want my ad to be in my Elm application. I'm able to see my ads when I do that, however, it sucks because there are about 4 iframes for every ad now.
I've been trying the `elm-tools/parser` library for parsing ICU messages for internationalisation. I'd like to build up a i18n solution for Elm but I'm not sure how far it can go or how nice an API I could manage. Fun to try the parser though.
I don't think your experience is all that novel. I'd chalk it up to the cutting edge and excited developers overselling. Elm is still the most enjoyable language that I've ever used in my 35 years of programming despite its early shortcomings. I suspect that I'm like many using Elm who can foresee the promise and is willing to struggle a bit until we get there. 
My point was, the command produced by `fetchList` is different every day (the query string changes), unlike e.g. `Time.now` which is always the same (i.e. "tell me what's current time").
Does it produce the same output for the same input?
Elm's tooling is not "easy" but it's there, the compiler error messages are brills. It's impractical to judge it against a general JS app generator as thats just not what it's intended to do. The biggest problem with the documentation is probably the fact that it doesn't adequately describe strong type systems at a high level which would seem like the biggest hurdle for JS devs that are exploring Elm. I have Elm running in production and if I never write another line of JS I'm stoked. I guess the thing is you have understand the reasons for moving and the benefits.
It seems the solution for very big sites is to split pages into separate Elm "applications", wether that is a master model/update/view/etc that glues together a bunch of pages each with its own model/update/view/... or literal Elm applications (ideally with a single m/u/v/...) for each web page (one for /login, one for /list1 and so on). TEA simply doesn't deal well with nesting or "componentization" so you don't want to nest things more than a level deep if you want to keep boilerplate down to reasonable levels.
If you don't want to use webpack then use elm-live which does everything you need for live-reload and auto compiled to js: https://github.com/tomekwi/elm-live Elm tooling mostly refers to auto-format, auto-complete, ~~test-coverage~~ unit-testing and amazing compiler. Those are the most important. Elm is still growing so if you don't see a tool that you need you have the opportunity to create one for yourself and the community.
I learn to scale Elm by using this example: https://github.com/afcastano/elm-nested-component-communication You should also ask this question in slack: http://elmlang.herokuapp.com, I'm sure many great people will provide their experience and resource. There are many other example if you search the term "Nested component in elm" or "multiple module" or "structuring in elm" etc. There are many discussion about this but I wish there is a main resource that put all this together too.
The `form` is the argument of your function and for the same `form` the `Cmd` will always be the same, that's why it's pure. This function only produces `Cmd`, but doesn't actually execute it, so there is no side effect. 
What's funny is that in Elmtown podcast regarding Elm in Production, Richard Feldman specifically says that components are the wrong way to talk about / think about Elm. However, the didn't give a counter-example / right way to think about Elm.
I've written about scaling a somewhat contrived example [here](https://medium.com/@ckoster22/scaling-elm-by-example-a27312134d0a) I've also written about a strategy for modeling your application state [here](https://medium.com/@ckoster22/elm-models-as-types-d913002b58fb) which I believe can show benefits as an application begins to scale. If you're curious to peek at a non-contrived example I have an open source example [here](https://github.com/ckoster22/lightning-talk-app). I've struggled to find open source examples much bigger than that out in the wild so I created and keep that one around for this very reason. The ideas I've written about may not completely answer your questions about large-scale production apps, but I hope they're at least conversation starters. Reach out if you have questions!
Thx for the hint, I will definitely try that. Is there also some Way to bundle assets and minify the compiled js without another tool. Oh and you wrote that the tooling refers also to test-coverage. Could you please point me to the tool to generate coverage? I found elm-test for unit tests and the like, but nothing to generate coverage. Thanks again for the advice. Of course I know, that elm is not as mature as other languages and I will definitely use and support the language where I can to help it rise in popularity. I was just a bit confused by all the positive things I read that only seem to be partly true in a production environment. The compiler is definitely amazing.
That sounds great.
I will be messaging you on [**2017-04-18 07:05:57 UTC**](http://www.wolframalpha.com/input/?i=2017-04-18 07:05:57 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/elm/comments/65s0g4/resources_regarding_scaling_elm_apps/dgd8fwu) [**3 OTHERS CLICKED THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/elm/comments/65s0g4/resources_regarding_scaling_elm_apps/dgd8fwu]%0A%0ARemindMe! 1 day) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! dgd8g1a) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
Thanks for explaining me the "functions are pure" part. What about testing? In OOP world we mock or stub objects and prepare a test environment with these doubles injected. How could I test if the `fetchList`, when executed, would ask the server the right question? That would require replacing `Time.now` in test. Or maybe not, since all it does is just asking the "what's the time" question. Nothing to mock here. In OOP it's easy to write a not-testable code. If you want to test a non-testable code you have to refactor it first. Does the rule apply to FP like Elm? How would you test `fetchList`? Is it testable "as is"?
I mean to say about elm-test, sorry for the mistake. As above said, there is not concrete test coverage yet.
My [first elm-app](https://playground.ahrengot.com/local-flicks/) uses geolocation, the Flickr API and infinite scrolling through ports. I hit a lot of brick walls building this, but I think I finally get most of the basics in Elm. JSON decoding is still a mystery to me and it seems unnecessarily convoluted for a beginner. I grasp the concept of a decoder, but the error messages when I do something wrong are usually more confusing than helpful. The #beginners channel on Slack came to my rescue more than a handful of times so *thank you* to everybody in there! The source code is here: https://github.com/Ahrengot/elm-local-flicks and I would love to hear about all of the things I’m doing wrong or inefficiently.
This isn't just about scaling an application. It's really a problem of partitioning. Modules can solve the partitioning problem but only to a point. I write mainly backend Elm under node and when dealing with databases my components can become complex quickly. I developed a library to remove most of the boilerplate that's involved with this process. I've used this in my Event Sourced Database Engine that's developed on top of Postgres called Slate. It has up to 7 levels deep at some points (once you build an API on top of Slate). Without this technique, or something like it, I could never have developed this system. Please read the documentation since it explains when to use this approach (and hence, when NOT to). Not every situation requires a Stateless Component (as I call them). The library is: [elm-parent-child-update](https://github.com/panosoft/elm-parent-child-update).
Hi folks, I'm trying to learn Elm and I'm doing some pet projects to be able to build cool things with this cool language. At this moment I'm working on an app for creating invoices with a cool template. You check it out [here](http://gabriel.perales.me/invoizr/), and you can have a look into its code [here](https://github.com/gabrielperales/invoizr). Contributions are welcome!
My guess is that when those articles referred to "tooling" they specifically meant Elm's compiler? The compiler has literarily saved me months of debugging time. Personally I avoid webpack like the plague. (but, if you really need it, there is create-elm-app: https://www.npmjs.com/package/create-elm-app). I agree that Elm's docs need a lot more work. -Rex
Hacking code coverage into (my fork of) elm-compiler! Sadly, it's more of a Haskell endeavour than Elm one :D
We're over 100,000 lines now. The fact that we are not a SPA has absolutely nothing to do with whether "components" are a good way to scale Elm applications. Here is one of our pages: https://www.youtube.com/watch?v=3FNKaGm3gk0&amp;feature=youtu.be&amp;t=10m24s This one page is thousands of lines of code and has no notion of "components" to organize it. It used to be in React, based around React Components, and the component-less Elm code is much easier to maintain. I posted some thoughts on how to scale Elm applications here: https://www.reddit.com/r/elm/comments/5jd2xn/how_to_structure_elm_with_multiple_models/
I find myself writing a lot of the same code over and over again, so my question is more of a general one: What are some tools you guys use to simplify code or save yourself from repeating boilerplate? I'm thinking of stuff similar to Json.Decode.Pipeline.
You provide anecdotal evidence with little or no detail to back up your position. It could very well be that their situation did not warrant such an architecture. And if that was the case then we'd agree. And I suspect that in the front end it will more times be true than not. But there are times when the level of complexity, as I've seen in my backend Elm code, warrants factoring out at least the Msgs. I have a library that has 6 layers. This layered approach is a time tested architecture used in Operating Systems to Network Protocol Stacks and more. The alternative you're suggesting would pollute the top level Msgs with each level's Msgs all the way up the stack. And how would you deal with two instants of that stack at different levels in an architecture. Not to count the complexity of the Model in such a situation. Having said this, I will concede that these cases are rare for most developers. But I don't want to assume I know what situation they are in or the level of complexity their architecture is at. I suspect this is an experience problem. My experience with Elm is all backend. I have very little front end experience using Elm. I suspect your experience is the polar opposite. So perhaps, that's how we are on opposite sides :-)
I was reading your post already http://pietrograndi.com/server-side-rendering-with-elm/ But I have concern with presenting google bot different content than normal user, which Google advises against. And there could be some ranking penalty. &gt;For optimal rendering and indexing, always allow Googlebot access to the JavaScript, CSS, and image files used by your website so that Googlebot can see your site like an average user https://developers.google.com/webmasters/mobile-sites/mobile-seo/common-mistakes
&gt; I feel that the conventions of Elm will end up being different in many ways to the conventions of other frameworks—and trying to force what you're used to on Elm is a waste of time IMO. I just wanted to say that I think this is a selling point of Elm - i.e. here's how things can be so much better. As those differences start to become formalized in the community, they need to be sold/advocated/espoused in a more visible manner.
Hi everyone! I'm working on a GUI for my game engine. It's my first real project using Elm and so far it has been a delightful experience. It's still way early in development but if you would like to check it out, here are some demos -&gt; https://www.youtube.com/channel/UC8MulhCq3zTvXamTQwtLzPQ I'm brand new to this community and super excited to work in the realm. Elm is my first functional language and it has been so much fun.
There is a difference between rendered in javascript (client side), and rendered in javascript (client side) that then does a request to the server that then displays the content. The article only seems to touch html that is dynamically generated by javascript (which google indexes fine). The issue is with a page that dynamically renders a spinner, makes a request, then updates the content dynamically once the response comes back. If you want to display the content with javascript as mentioned in your article, you need server side rendering (or have the server send the already populated content in javascript that then creates the dom). I'm bad at explaining things :/
"Large-scale" is quite vague. I understand the general motivation -- you don't want to get far into it to discover "Elm can't do something" or "my code is a complete mess". But I'm not sure how productive the question is without some more details of the app(s) you are building or hoping to build, and the pain points you are finding. Otherwise we get into religious discussions around the term 'component', which I don't think is what any of us want. That said, I have found these tools/approaches below helpful for some problems I've encountered in Elm apps with &gt;1 level of `update`. **But please note, like any abstraction, I don't recommend introducing any of them until you actually need them**, otherwise you will end up with more complexity than you need, and you may be better off backing it out. Knowing when to reach for an abstraction takes time and familiarity with different situations. - [elm-sortable-table](https://github.com/evancz/elm-sortable-table) -- a clear example of how to do reusable UI as described in the elm guide - [elm-taco](https://github.com/ohanhi/elm-taco) -- for passing down and updating application-wide state - [remotedata](https://github.com/krisajenkins/remotedata) -- for encapsulating remote data state - [elm-state](http://package.elm-lang.org/packages/folkertdev/elm-state/latest) -- for reducing boilerplate and fragility in complex 'update graphs' - [OutMsg pattern](https://groups.google.com/forum/#!topicsearchin/elm-discuss/OutMsg/elm-discuss/qhLsLThplUo) -- alternative to passing up Cmds, where only the top level update generates Cmds from messages passed up 
Got a little further on my CSS Grid experiment, demo now up here: https://ericgj.github.io/css-grid-builder/
In Elm you cannot directly inject HTML strings, so many XSS problems are eliminated by the language. Otherwise I've found nothing special about Elm when it comes to security. Treat it the same as any other front end project.
What is this post supposed to accomplish? Everything written here is well understood and either in the process of improving or just not something you are going to get differently from Elm. There are several languages and platforms that would fit your apparent requirements much better so why not try them instead of making a new user profile so you can post this? This entitled attitude that users have is the primary cause of burnout for open source maintainers. Why would you expect Evan to participate in the community more if he's just going to be spending half his time processing non-constructive complaints like this? Open source developers don't owe you anything. If you don't like it and you don't see a clear path to make the changes you want then _try something else_.
I am sure /u/rtfeldman could give useful input here. If you have not read the excellent post [defense against the dark arts CSRF attacks](https://dev.to/rtfeldman/defense-against-the-dark-arts-csrf-attacks), do it now!
`import Main exposing (..)` is something you should never have. You probably mean `module Main exposing (..)`. This looks like a bug in the compiler. I've logged in in the error-message-catalog. https://github.com/elm-lang/error-message-catalog/issues/93 
Indeed! I didn't mention Elm by name in that post, but if you are using [the usual way of sending JSON from Elm to the server](http://package.elm-lang.org/packages/elm-lang/http/1.0.0/Http#jsonBody), it'll set the `application/json` header for you...and all the remaining suggestions in that article are strictly server-side. :D
&gt;What was the motivation to make this package instead of using elm-plot? Someone has spent time and effort to make a library and share it with the Elm community. Whether or not it's your intent, you're coming off as saying, "Why did you waste your time doing this?"
Elm is a full programming language, and is best suited for designing dynamic, interactive applications. You certainly could use Elm for it, but I'm not certain it's the right tool for the job. Something like Hakyll might be more what you are looking for, for a static site.
I actually implemented this before. It's implemented on an old version of elm, but migrating it shouldn't be too hard. Basically It works by having a central `posts.json` file which contains metadata for every post. When you click on the post it fetches the raw markdown file from the server, renders it and displays the html. Fell free to use any of my code for your own. :) https://github.com/JustusAdam/betablogger **Edit**: Since this (by necessity) a one page application I also implemented url rewrites to make sure navigation the the "back" button in the browser works. Although I am not 100% sure anymore that I finished that.
This looks pretty cool, albeit a bit too advanced for my little Elm-knowledge, yet. One thing that confuses me, though, is that you state that you use jekyll in one of your posts. Did you move from jekyll to elm or viceversa? Edit: Haha, just had a look at your github profile and realized that we are both living in the same city...
Thanks for the response. Yeah I was already thinking that a static site generator might be better suited for the job. I wanted to check other options, though. I am looking for something small to learn elm, but maybe a blog is already a bit too much for me to handle. Therefore I will probably use a ssg to create the blog and learn elm writing a few simple web-apps.
&gt; Elm is a component-free language whose community is desperate to talk about components. But Elm's leadership seems to believe it's mostly a solved problem. Writing re-usable Elm is a solved problem. Writing components with self-contained state is not the Elm way -- people are obsessed with components because that's how it's done in other languages. &gt; Elm is not a pragmatic language--it favors near-perfect solutions over good-enough solutions. I disagree. There are some things that aren't perfect, like decoders, but Elm is pragmatic in the language features it has. A super fast DOM, a simple language without the complexity of alternatives, error messages, etc. &gt; Elm does not interoperate well with "foreign" functions, i.e. javascript. Some of its biggest pain points are "ports" and JSON encoders. It will probably continue to live an experimental ascetic existence. In a best-case scenario, its community will re-write the world's code and replace javascript's objects and components. The same could've been said about writing HTML in the days of only elm-graphics, or how people were all writing their own un-typesafe frameworks in the days of Signals. This will be addressed with time. &gt; Elm's guide--the equivalent of the Elm community's bible--is "owned" by the language's creator. He prefers not to have suggestions or contributions around this work. There are tons of community resources in the form of tutorials, blogs, and examples. I would not refer to the Elm guide as the bible myself. It's just one of many books, generally laying out the best way to approach things. &gt; Elm's center of power rests in one company. Communication with the outside community is regular, but public discussion around issues that people have is usually not integrated quickly (or at all) into the kernel, except in rare cases. While it's somewhat true that Elm does have a center of power, it's false that that nothing else is taken into consideration. For example, the next release is focusing on making SPAs better to work with. This is not something that is vital to NRI. The change from Signals to the current system wasn't something that affected NRI, either. Neither were the heavy use of backticks. &gt; Elm's creator talks a lot about community, but interacts infrequently with the larger community. Speaking as the face of the Slack group, it is not such a big problem as people seem to think it is. Most people who has asked if they could speak to Evan actually didn't need to speak to Evan, they just had a question about some parts of Elm they didn't know about. Those that _did_ have a problem that Evan needed to address, Evan replied to. For example, see [here](https://github.com/elm-lang/elm-make/issues/159). &gt; He is worried newcomers will adopt bad practices, but spends more time explaining how scary the bad practices are than leading the way with good practices. To give you some perspective on how much Richard does, here's a small list of things he does to show _good practices_ to the Elm community. - [Speaks](https://www.youtube.com/watch?v=6EdXaWfoslc) [at](https://www.youtube.com/watch?v=3FNKaGm3gk0) [many](https://www.youtube.com/watch?v=IcgmSRJHu_8) [conferences](https://www.youtube.com/watch?v=FV0DXNB94NE) - Discusses endlessly on elm-discuss, elm-dev, this subreddit and the Slack channel. - Is writing a book to help people both understand and write better Elm - Runs [workshops](https://frontendmasters.com/workshops/elm/) to help teach people Elm - [elm-test](https://github.com/elm-community/elm-test) To claim that he's not working to help give good examples is ridiculous. His talks get referenced all the time. &gt; Elm has very few large "successes." These few successes shape the dialog around how code should be written. There is a strong sense of a "right" and "wrong" way to do things, with little room for a playful attitude. Elm has more and more successes each day. You'd be surprising on the number of companies using Elm at a large scale. The reason why there is a right way to do things is because the wrong way ends up giving you heartache. If you're frustrated, this post is not the right way to go about solving that. This is not a constructive post, and I hope my response goes to show that to anyone else.
You can also inject things via elm-markdown pretty trivially
Use what works FOR YOU.
Maybe [this article](https://medium.com/elm-shorts/updating-nested-records-in-elm-15d162e80480) can help you. This is an acknowledged problem and will probably be solved in a future version of Elm. Also, you can "fix" the example5 and example6 by using aliases: myRecordMyUser = myRecord.myUser example5 = { myRecord | user = { myRecordMyUser | age = 19 } } myRecordUser = myRecord.user example6 = { myRecord.user | name = "John" } 
Hey /u/lukewestby! That's a perfectly valid question, and thanks for the clarification. I guess it's a mix of both :-) I did a quick research to see if there were libraries I could use but none of them seem to be exactly what I wanted. Some because of the features, others because of the design, others were abandoned projects. I basically searched for "chart" at the package index and looked at a couple of "awesome-elm" lists, and didn't come across elm-plot this way. Maybe searching for "plot" would have been smart, I blame my English for that (:-p). I just checked it out and it looks really great even though it doesn't have pie charts which I needed. Still, I could have chosen to contribute to another library and make them what I needed. At the moment I thought it wouldn't be hard to just write *something that works*, and tried writing something quick to see how that worked out. I had never written any SVG nor done much graphical work before, and I had so much fun that after a couple of days of coding it developed into the current API and I was really happy with the result. I wasn't until I was finished that I decided to publish and share it (that's why the announcement came with v2.0.0 and not before). Thanks for taking the time to write!
Thanks for your library. I've been able to cook up an example for the front-end, and as a result I've corrected some code in the example within the docs (made a pull request for this).
It doesn't know about time values. Currently, for line charts you just give it series of float (x,y) pairs (and their labels). For my use case I actually needed to plot data over time, but using numeric timestamps did the job for me. If you find any specific features that would be useful for other use case please feel free to open an issue! Since I'm not an expert of the subject I preferred to share a minimal API and make it evolve based on concrete needs.
Whoever created an anonymous Reddit user less than a day ago—just to write this post—is a coward. Go home, you're drunk.
No. I just removed it. Sadly there is no read only scope. It's strange, because I could choose which private repositories I want to allow to access. But I've heard already many times that others must either allow to access all or cannot pass through authentication.
In some situations I've ended up doing: newData = model.data |&gt; (\d -&gt; { d | prop = newProp }) It is far from ideal but it saves you creating a variable for `model.data` first and so in some situations can compress things a little. Really just an inline version of the interesting article that /u/jediknight has linked to.
I think is because you are doing "myRecord.myUser" in line 22, myRecord doesnt have myUser. You can do this: example5 = { myRecord | user = updateUserAge myRecord.user 25 } updateUserAge user x = { user | age = x }
&gt; I have asked Richard Feldman myself how to structure big apps and the answer is simply to follow the compiler. That's not great advice for big code and clearly there are no guidelines for big apps, the elm guide isn't growing and there's a huge patronizing attitude by trying not to reveal documentation of certain parts because the users will abuse the system. For examples it's nonsense that the only documented interop way with JS are ports which force async calls even when they're not needed. Guidelines are coming. I agree that the problem is that there's a lack of good examples. For you, I recommend reading [this](https://github.com/noredink/elm-style-guide) to give you a better idea of how Elm works at scale. More docs will come with time. &gt; In general, Elm (Evan) is secretive about roadmap and progress. He's always evaluating ideas privately more than anything and you can tell because there are rarely commits in the public repos which clearly shows either no work is being made (I don't think this is the case) or everything is on closed doors. This _used_ to be true, but frankly I don't think it's that true any more. I used to be one of the people who were vocal about this, pushing for more open development. Check out the elm-dev mailing list. Lots of readable, informative updates. Only solid updates make their way to elm-discuss and elsewhere, but Evan tries to keep us informed on elm-dev. &gt; Components may not be the Elm way, but a huge amount of problems are easily solved with internal state (animations for instance or very UI only behaviour not related to the app's domain data) and that's why it's a pain in the ass to release libraries in Elm. You always release helper functions but everything has to touch everything all the time. Isolating things in Elm can be really tricky and I myself have considered how to simplify things, for instance CSS transitions, and always end up with hard APIs or wrapping Program. Reusability is truly an Elm problem probably related to lack of a more generic programming style. I don't want to get into this discussion here, but "a huge amount of problems are easily solved with internal state" is true in OOP languages. Elm is not an OOP language. To try and solve problems in Elm with approaches from OOP is not really a good idea. I agree there's not an ideal way of dealing with animation right now, but that is something that can be addressed. The majority of your views do not need to be animated in that way. Show me some code on Slack, and I will show you how to write it in a reusable way ;)
Ah that was just a typo, thanks for spotting. :)
As far as other useful data *representations* go I've come across two others that are interesting. [Non empty lists](http://package.elm-lang.org/packages/mgold/elm-nonempty-list/latest) [A union type for representing async state](http://package.elm-lang.org/packages/krisajenkins/remotedata/4.3.0/RemoteData#RemoteData) Neither are really data structures per se but both are practical and useful.
I gave a talk on union types at a local meetup and came up with this RemoteData example as a demonstration of their value. [Before - without RemoteData](https://ellie-app.com/wvpRRNSpJ3a1/2) [After - using RemoteData](https://ellie-app.com/wvrJJFjWzGa1/0) Hopefully that's the sort of thing you're looking for.
Searching for "zipper" may be more successful than searching for "zip list", because what /u/rtfeldman describes is called zipper in Haskell (where a zip list is something else.) Zippers provide a focus on parts of data structures, and the idea carries over from lists to other (e.g. tree shaped) types. Learn You A Haskell has a [chapter on zippers](http://learnyouahaskell.com/zippers) where you can learn more about this idea. If you are interested in more background, search for the Functional Pearl "The Zipper" by Gérard Huet. If you want technical details about how general the idea is, look at "The Derivative of a Regular Type is its Type of One-Hole Contexts" by Conor McBride.
How did you like the Learn You as a Haskell book?
TIL. Let's not do that :P
thanks so much
I'll try to make a gif tonight. The idea behind it is having a scrollable list of elements that can be selected one by one or all at once with the checkbox at the top. At the same time you are able to filter the list by typing in the input above and choosing if the filtering is of elements starting with or that contain the entered text. There's also a button that tests a port to get all the selected values from js and logs them in the console.
Here is a quick example I pieced together the other day for someone on elm-discuss: https://groups.google.com/d/msg/elm-discuss/WDDrFq-uP58/kVNJoFMlDwAJ 
I think simple refactoring is what I do on an hourly basis as I write code to remove repetitive code. I'll stop in the middle of coding something because I can see that what I've just written is going to be repeated only minutes from now. I'll factor it out then if it's simple. If it's complex then I'll copy paste and edit the new black. Then I'll compare the differences (basically all the things I edited) and refactor.
There is a blog done in Elm by Jack Franklin [elmplayground](https://github.com/jackfranklin/elmplayground), also I forked it I did some improvements in [my branch](https://github.com/gabrielperales/elmplayground/tree/gabrielperales). Have a look to them, and see our different approaches to do that blog in Elm.
Thanks, will definitely check those out
For non hash based, you can use still use Elm Navigation and use `Navigation.modifyUrl`. I wrote a blog post that discusses this [here](https://medium.com/@zenitram.oiram/a-beginners-guide-to-making-a-single-page-app-in-elm-d1a89d3845fa). 
Thank you @pinkyabuse. I've just read your post and I'm figuring out how to apply the Approach 1: I would like my link to have the form of `/edit?id=xyz`. If I apply your approach 1, I'd rather have a link in the form `/#edit?id=xyz`which is then rewritten in the address bar as `/edit?id=xyz` right? But the source link still contains the hash. Am I missing something? Thanks!
If you want help you're gonna have to meet people more than half way. What EXACTLY did you change it to? Also, what was the error message?
I assume it would be a non valid web socket 
I'm not OP
&gt; Caveat: I did not read it as a beginner. Did you read it as a Haskell beginner? :)
No.
In Python this is solved with an Ordered Dict (I think?) and there seem to be some elm projects with the same name: - http://package.elm-lang.org/packages/folkertdev/elm-ordereddict/1.1.0 - https://github.com/danneu/elm-ordered-dict Could they be of use?
Are you using elm-reactor? It has time-travel debugging which tracks every change to the model.
FYI, the time-travel debugging isn't specific to elm-reactor anymore, you can always enable it in `elm-make` using the `--debug` flag.
I don't think sets preserve order.
Maybe what you are missing is a way to put debugger stop points from Elm? That would let access the Dev tools in a way but maybe the compiled code would require a lot more exploring because I'm not sure elm creates readable Js.
One of the things that I've found to be very tedious while working on my game is keeping the websocket API / client decoders / encoders in sync. Especially since Elixir doesn't do type checking for your API. So instead; I tried making a code generator, where you write the API specification on the server side and it would generate Elm code with Decoders / Encoders / Type definitions of the API calls. I've been working on this game project for a few months now. And as of writing this I'm actually quite shocked to see that this generated Elm API file is now 3.7k LOC. I can't imagine having to maintain so much code by hand, not to mention having to write tests for them. However when everything is generated like this, I can't find a reason to actually write tests for my API. Edit: After posting it felt a bit like I'm trying to hijack this thread, but that's not really my intention. I'm just wondering more if there's any reason to write tests if you generate your API?
&gt; If your function is relatively long/complicated/recursive then just being able to see the model after each update doesn't seem that valuable to me. If your function is like that... make it simple. That's the magic of Elm, it allows you to split long/complicated functions into smaller more manageable bits without having to worry about code breaking unexpectedly. 
I agree that the debugging experience is quite different and that it is less often required to stop the world and look around. However, I personally feel that the ability to do this still adds significant value and have had numerous occasions where it has taken me a lot of time to debug something that would have been very easy to debug in javascript. Given the target of Elm to be beginner friendly and appeal to javascript programmers, I personally find it a significant negative. Thanks for the comments! 
I hear you and it would be awesome for Elm to have a first class experience for everyone. Unfortunately there are no solutions, only tradeoffs. If Evan would stop everything and focus on getting these bits around the debugger experience right, he would have to give up working on other issues that I and a lot of other Elm users consider more important. Right now, I think that debugging Elm is GoodEnough™. It is however a different experience from debugging JavaScript. I understand the frustration but sometimes it's just part of getting accustomed to another set of tools and approaches. It's all about the trade-offs. I remember being very frustrated when I started with Python moving from Eclipse to SciTE but I soon learned to enjoy the new environment and got by just fine. The benefits of Python outshone its drawbacks. Same with Elm. You'll get some parts of the programming experience that will be better in Elm some, less so. It is up to you to decide if the benefits outweigh the drawbacks. 
You do not want source maps, they wouldn't help you. ~ You want to use the reactor either directly or by using something like https://github.com/halfzebra/create-elm-app ~ Avoid writing any looping function that could possibly run infinitely. Use well defined helpers like fold, and map. ~ Elm debugging is actually shockingly easy, but it has a ramp-up period and you have to get used to it.
I think there is! Integration tests are important to make sure you're not using badly generated code. Plus they can still catch scenarios like my post where the interaction between two units is bad. I view generated API code as more of a time-saver for expressing myself than actually giving me more safety. Example: I use gRPC at $dayJob and still test all my handlers to make sure the system works how I think it works.
I just add 1 to the URL to break it.
Sounds interesting. I guess I imagined maybe source maps would be the easiest way to get some benefit but if there are better ways with bigger benefits, great! I guess I have become very accustomed to using breakpoints to examine what is going on. It always seemed to me that the pure nature of the language should make this type of step-by-step debugging easier to implement and hence slightly frustrating that it wasn't there. In fact I always imagined that the pure nature of the language should make it easy to even edit/change the internals of a function during debugging. Overall I love writing elm and the positives absolutely outweigh the lack of breakpoints. However I still feel that (in my case) the combination of elm plus step-by-step debugging would make a significant improvement to my productivity.
In additional to making sure that your client and server agree, the *safety* goal of fuzzing should also include defense against malicious packets sent by hackers. This is especially a problem in games. There are a significant number of people who find hacking games to be more fun than playing them.
Use elm make --debug when building your app. It usually gets me to the problem pretty quickly but there are time I wish I could step through and inspect like standard JavaScript code.
Is it really necessary to have these meta discussions? We all have different opinions and sometimes people just need to work harder. I do understand the perspective and when I'm learning new things I like to be told by people that already know them that they find it easy. If the people who already know how to do something don't think that thing is easy then we have a real problem. I'm not afraid of doing difficult things or offended by being told to just work harder and I think it's a fallacy to think that everything, especially in programming, should be easy or even understandable the moment you pick it up. That being said I understand where you're coming from, but on your same tone I don't think discussions like yours are any more constructive than you think mine is. Frankly that's what the down-vote button is for. My feelings won't get hurt.
I think it is necessary. In many communities, it is socially acceptable to be harsh towards beginners, and I think leadership plays a huge role in this. For example, the designers of Haskell are lovely folks, but they do not really comment on culture. I think that allows the culture to become sucky for beginners. I don't want that to happen here, and I don't think the downvote button expresses *constructive* feedback. It says "this is bad" not "I think this could be better if ..." I think I could have done a better job being constructive, so I'll try harder! ## Background Evidence A common pattern in communities is: 1. There is a weakness in the language. 2. Newcomers are aware of this weakness. 3. Instead of acknowledging the weakness, the community pretends it is a strength. In JS a weakness is that you get a bunch of silly bugs. You can protect against this with tests. Some community members then say, "well, good programmers write tests anyway, so it's not actually a weakness." In Haskell a weakness is that folks have a hard time learning all the type class stuff. Newcomers are very aware of this. Some community members then say, "well, this is so fundamental to programming that you basically cannot program well without out, so it's not actually a weakness." Any community can fall into defensive patterns like this, defining "good programmers" as whatever covers up their weaknesses. I think it hurts the community, and I want to actively discourage it from happening in Elm. Hopefully that helps clarify why I think these meta discussions are valuable! ## Recommendation I think it is good to convert "X is true" to "**I think** X is true **for Y**". So in this case, the two perspectives can be expanded to: 1. I think debugging is hard for my graph traversal. 2. I think debugging is easy because my experience has taught me these other techniques. I think this framing leads to more productive conversations.
I just started learning Elm last Thursday to build a [reference table](https://www.github.com/solkaz/xeno-gifts) for collectable items in Xenoblade Chronicles. Coming from React (and Redux), I've found Elm to be pleasant and easy to use, even though the syntax is different (I've looked at Haskell before, so it's not completely foreign). 
And that's exactly how the core library sets and dictionaries work! So, *if your key is a `comparable` type*, it works great.
Great post Brian. Aside from being a useful technique in its own right, I think it can serve as a really good introduction for people new to property/fuzz testing too. This post also inspired me to revive an idea I had a while ago for building up two-way encoder/decoder pairs together with one DSL to make things a bit more convenient and to reduce the likelihood of errors. I put together a proof of concept here: https://ellie-app.com/324L33RBW5Wa1/0 Does anyone know if others have explored this before? Is this something that other people would want to use?
This is a really good point! But I assume you'd agree that these tests should be written on the server side to see how the server handles them?
I think that is relevant advice and is generally what I try to do as well.
I think this would be the best solution for the moment, I will start using the Debug.crash function to drop into the javascript debugger. Not ideal (would be nice to stay in elm) but the generated code is understandable if you squint!
look at my example. it uses urls without hashes. There is no query string example yet https://github.com/rofrol/elm-navigation-example
I'm rewriting an old app that I built with angular a year ago. This is an app to explore artists using the Spotify API, you can search by an artist and then explore the related artist and generate a playlist with these artists. This is not ready yet, I'm woking in it in my free time. There's no README yet, but you can see some previews on my pull request, there are some GIFs of the application. https://github.com/FidelisClayton/elm-spotify-mapper https://github.com/FidelisClayton/elm-spotify-mapper/pull/6 https://github.com/FidelisClayton/elm-spotify-mapper/pull/9
While I agree that "being clever" is an antipattern, I don't think point-free style qualifies as "clever". Currying, altho a little bit unfamiliar at first if one comes form a language where this is not available, is an amazing skill. This is very handy when one creates these unnamed functions on the fly when some other functions need a function. `List.partition ((==) 2) [1,2,3]` reads elegantly to me. It might not be super-duper obvious to an absolute beginner but once one understands what's happening there, the language use becomes more powerful. The ability to think in terms of functions is very handy in functional languages. `List.foldl (+)`is a function with the signature `number -&gt; List number -&gt; number` that is obtained by partially applying `List.foldl` Elm has very few but powerful constructs. Currying and functional composition are part of this very short list of powerful ideas and they are definitely worth learning well. 
Imagine removing all operators fro the language. Now how do you like your language? Not much huh? Missing that addition operator or the forward apply? If so then you are advocating for only certain individuals to be able to create operators, viz. language developers and other individuals not, viz. programmers. That's elitist.
Awesome idea! Maybe you can make a channel in elm slack? I would love to contribute ! 
&gt;That "power" is in the ability to create these without having to wait years for the language to change if ever. This is a purely hypothetical, never-realized benefit. The typical use-case for custom operators *isn't* "Oh, haskell is missing the addition operator and the devs are taking too long to implement it!" The typical use-case is "I want to make a really clever DSL!" Which speaks to the point of OP's article.
This is anything but hypothetical. Look at Javascript. How long did we wait for arrow functions, spread operator, await/async, etc.? And like I said before, just because someone will misuse a tool, doesn't call for its banning. How many carpenters would be outraged at the banning of hammers because someone decided to use it to smash a car window? Yes, someone, somewhere is going to abuse this power, but that doesn't make the power bad, just the abuser's actions.
&gt; The typical use-case is "I want to make a really clever DSL!" Which speaks to the point of OP's article. Exactly. Could someone provide an example of not clever DSL uses of user defined operators? I cannot provide such an example and the point in this article is against that type of use cases. I think the weight lies on those in favor of custom operators.
The other implementations actually use gitter for communication, But I can create a channel there. :D edit: I think it's not open to anyone create a channel in Elm Slack, I will ask around to see how it works there. =/
&gt;How long did we wait for arrow functions, spread operator, await/async, etc.? These aren't operators in the sense that we've been talking about them. These are entire language features that happen to have a new operator associated with them. &gt;And like I said before, just because someone will misuse a tool, doesn't call for its banning. The tool may not be banned, but new tools will certainly be made that prevent misuse. Entire abstractions have been created for the sole purpose of disallowing misuse: - Mutation is powerful. Why ban it just because people will misuse it? - Manual memory management is powerful. Why do certain languages ban it just because people will misuse it?
Just for the record, manual memory management was abused and the abstraction to solve the problem can still have memory leaks. And "banning" mutation is not what's happened. We still mutate. We just do so via copies. Your original comment that I object to is the banning of customer operators. You didn't provide an alternative abstraction to disallow misuse.
It's great for code comprehension if the set of custom operators is small, well-understood and with somewhat "intuitive" (subjective, but that works for 1-man projects just fine) semantics. Who cares that "everything is a function under the hood", just separating certain operations or combinators out into the family of non-letter/digit infix symbols and the rest into plain old functions can aid greatly in writing and later understanding more (perceivedly) composable code-bases. Don't like them, don't use them!
If you like to use |&gt; or &lt;| in Elm, as many of us do, then imagine that these did not exist. These would be great candidates for using the feature of custom operators, at least until they were added to the language (if that ever happened). NoRedInk has very useful piping operators for JSON. I've created operators for Maybe.withDefault, Maybe.map, Result.withDefault, Result.map. Why? Because my codebase uses these functions more than nearly any other. I too have created my own piping operators for JSON (much more lightweight than NoRedInk's approach).
&gt;manual memory management was abused and the abstraction to solve the problem can still have memory leaks. The abstractions are not about preventing memory leaks (although they help); It's about preventing unsafe memory management gotchas that have resulted in countless zero-day vulnerabilities. &gt;And "banning" mutation is not what's happened. We still mutate. We just do so via copies. That's not mutation then, is it? &gt;Your original comment that I object to is the banning of customer operators. You didn't provide an alternative abstraction to disallow misuse. How about the primary abstraction used by functional languages? You know, *functions.*
I just had my first pull request to an elm library merged! You can check out my humble contribution here: http://package.elm-lang.org/packages/elm-community/list-extra/6.1.0/List-Extra#splitWhen
I think I'd take a good language over a popular one.
Doh. That's true. I just got excited about security fuzzing :P
Translation: I'd take a job where I get to use a good language over a popular one. Unfortunately, your job prospects just got a helluva lot smaller.
I wasn't speaking specifically about marketability, just my preferences. But trust me, I've programmed mainly in bad languages to keep the lights on.
`&gt;&gt;` can often be more efficient than `|&gt;` as it can avoid creating intermediate values. eg. -- requires going over the list twice and creating new list at each step [1,2,3,4] |&gt; List.map (\x -&gt; x+1) |&gt; List.map (\x -&gt; x+2) -- only requires going over the list once, applying both functions to each value List.map ((\x -&gt; x+1) &gt;&gt; (\x -&gt; x+2)) [1,2,3,4] 
&gt; But what are you going to do when the community grows up? Elm isn't frozen, it's just taking things slow, which is a good strategy for a language, since design choices can never be undone.
What would be the utility of Movable? What would be the information that you encapsulate there? Is it a Bool that incapsulates the idea that "this one can move"? 
I think it has more to do with the convention of people that use the language. Haskellers prefer &gt;&gt; whereas Fsharpers prefer |&gt;. I personally thing |&gt; is more readable.
Here is how I think about it. They both are used for piping stuff together. `|&gt;` is useful when you have a value and you want to put it through one segment of `pipe` after another and get a value out the other side. `&gt;&gt;` is for connecting bits of pipe together in advance to create a longer pipe that you can then push a value through later. If you have the value around and you want a value out the other side then then you'll probably use `|&gt;`. But if you want a reusable longer section of pipe then you can construct it with `&gt;&gt;`. `&gt;&gt;` is also useful for situation where you don't have direct access to the value like `List.map` so you might do: List.map (.name &gt;&gt; String.toLower) users Because you are preparing a function for something else to use in the future. This is less clear than I'd hoped but maybe it helps.
The process is you ask at #admin-help, and @eeue56 most probably will create the channel for you.
Learning Haskell after learning Elm might not be such an unpleasant experience. Another popular alternative is Elixir (Phoenix framework). Elm will eventually become available on the backend but that is probably years away. As far as I understand, the focus is to make it a solid implementation on the first platform (browser) before moving to other platforms (backend). 
Fsharp has always had the composition operator (&gt;&gt;), as well as the forward pipe operator (|&gt;) from its OCAML heritage (similar to Elm). So I think it's inaccurate to say that it's due to Fsharpers have one preference and Haskellers another - the two operators have different meanings.
Well, you can easily check if it is possible. You might want to consider whether it is what you actually want, though. Why not just do type alias Model = { encoding : Json.Encode.Value } function model = model.encoding |&gt; Json.Encode.encode 0 The type you have for `Model` only makes sense if you want to apply the `encoder` for one `Model` to a different `Model`.
It is possible to store functions, however,Evan has warned explicitly against putting them in your model. 
The people from Thinkster set a gitter chat: https://gitter.im/realworld-dev/elm
There is absolutely no need to put functions in a model. Put the parameters there instead and call your function with it. 
i was thinking i would be like this: type Movable = Vertical Direction type Direction = Down | None
Very cool. Worth a tweet. https://twitter.com/RandomPundit/status/857407636928516096
need-more-da-ta
Oh... I get it now. If you want to restrict the movement in some way, yeah, it is advisable to add a field that captures the constrain. I would not name it `movable` but rather `direction` and capture that as angle and magnitude or maybe `vx`&amp;`vy` like in the [Pong Example](https://ellie-app.com/32WvCryfYSwa1/0)
Really cool idea! I will keep an eye on this ;)
You should definitely announce this on the mailing list
That's a good idea! I will. Thank you :+1:
this is seriously exciting! 
Thanks!
this is cool tech for sure and I bet it was a lot of fun to write, but i don't exactly see this being very practical. elm isn't a general purpose language: it's a bit of a haskell-lite geared specifically towards front end development. so what this project does is give you an elm-like mini-haskell way to write elixir code. if you want a more functional style syntax, why not just write erlang?
a cool type system on the Erlang VM ? Kind of like https://github.com/alpaca-lang/alpaca 
Even more so to me! I was trying to do static typing for Erlang VM for a very long time already, and it seems like this time it has straight way ahead of it
Pretty new to elm (only started a couple of days ago), so just working on a variety of little scripts atm using the playground to familiarise myself with the language, with the current goal of working towards a full Todo app (original I know!). https://github.com/scottrangerio/elm-practise/tree/master/scripts
And, r/erlang &amp; r/elixir :) They'd also like this over in Hacker News. Though HN is so flooded lately you might have to submit it a few days in a row before anyone notices. Awesome work!
**Here's a sneak peek of [/r/erlang](https://np.reddit.com/r/erlang) using the [top posts](https://np.reddit.com/r/erlang/top/?sort=top&amp;t=year) of the year!** \#1: [How do Erlang Microprocesses work internally?](https://np.reddit.com/r/erlang/comments/4sogzb/how_do_erlang_microprocesses_work_internally/) \#2: [GRiSP, a Bare Metal Erlang VM for IoT](https://www.grisp.org/) | [1 comment](https://np.reddit.com/r/erlang/comments/5gxls9/grisp_a_bare_metal_erlang_vm_for_iot/) \#3: [10 Essential Erlang Tools for Erlang Developers](http://tutorials.pluralsight.com/erlang/10-essential-erlang-tools-for-erlang-developers) | [1 comment](https://np.reddit.com/r/erlang/comments/4v1vwl/10_essential_erlang_tools_for_erlang_developers/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/5lveo6/blacklist/)
Design choices can be undone at will, any time, as long as you are willing to break backwards compatibility.
I don't remember where I heard this, but my understanding was that one of the risks is that it may be explicitly disallowed in the future.
High five! :D
Specifically the elm-dev mailing list. When doing projects like this, it's best to share your work *early* with the core developers. Having a project like this actually be nice is difficult, and ultimately would require coordination IMO.
Elm currently has nothing to do with frontend, except for ports and the libraries. It's just a nice simple *statically typed* functional language. Ocaml is nearly dead, and it's not even close to Elixir's activeness or community. Trust me. I'm new to Elm, but I've spent a good amount of time in Erlang/Elixir community to know that. PS. Even if noone will. I'm sure that I'm gonna use that :)
This is not the same as Elm on the backend. This is transpiling an ML language like Elm to Elixir. The introduction of things like a magical `meta` value, the use of `ffi`, pattern matching being entirely different. This is a project with ML-inspired syntax which transpiled to Elixir. 
Elm has _everything_ to do with the frontend. All of Elm's infrastructure and tooling is based on the assumption of Elm running on a web-platform, not the backend. Your language is _not_ the same as Elm as it currently stands. Elm is not merely syntax, but the syntax for your project is not the same as Elm's either. 
Well yeah, I guess. You can shoot yourself at will, any time, as long as you are willing to not have a foot anymore. Look at Python.
@eeue56 I think you're mistaking libraries for the language. The language IS Elm. But you can't use existing libraries. And the language is as similar to elm as Elm-AST is with one caveat regarding Types / Tuples as stated in FAQ
I don't understand the origin of your strongly biased opinion. I'm aware that this idea has its flaws and some solutions are more than hacky. Every idea is like that. But that's far from a reason to just delete a project. The syntax is compatible with elm, and it's supposed to. Because I use elm-make as a type checker right now. Runtime might differ. But after all you can't ever expect the browser and BEAM to behave identically, can you?
The origin is my experience ;) At no point have I said you should delete this project. You might remember me answering some of your questions on Slack, even. The syntax is not currently compatible with Elm. Please see the other reply for that.
Hex isn't an alternative to rebar. Hex is a package management system that works with varity of build tools, including rebar. :)
You're right. There was few typos in the example and elm-make parses without any errors now. That's enough for me to call it Elm. But I see we won't come to an agreement here. I hope you'll change your opinion some day
I think that's a very good idea. I'll definitely take that into consideration
For sure. A lot depends on the maturity and install base of the language.
I'm am confused about syntax. I'm working though the tutorials and I'm getting hung on Types. I know I could plod on, but I really want to nail these shapes into my noggin. So we have this: view : Model -&gt; Html Msg view model = div [] [ h1 [] [ text (toString model.dieFace) ] , button [ onClick Roll ] [ text "Roll" ] ] And I'm having a hard time parsing how the div has a return of the correct type. div : List (Attribute msg) -&gt; List (Html msg) -&gt; Html msg So like if I wrote out a call: div [] [] div is taking in a list of Attributes and msg or is Attribute (as a function itself) taking a msg? Digging further type alias Attribute msg = Property msg yet further property : String -&gt; Value -&gt; Attribute msg I feel like I'm going in circles. I guess I need to know. What is msg? How does div work on a list of attribute, which works on a list of Html and return an Html msg. 
I found this post quite helpful in my thinking about how to structure a model: https://groups.google.com/forum/m/#!topic/elm-discuss/4t29f7DGPKc It appears that many people immediately reach for some type of store abstraction thing -- but in most cases rerequesting the data is probably fine! And much simpler. If the time comes when rerequesting the data is slowing things down -- then reach for some kind of caching abstraction. Would love to hear others thoughts on this. 
The question is whether you want to evaluate a statement to get a value back (|&gt;) or build up a new function by combining smaller functions (&gt;&gt;). If you already have your arguments to pass through your pipeline, usually you use |&gt;. If you want to build up functions, or if you don't have your arguments (like the function you supply to a map or filter) use &gt;&gt;. In general, &gt;&gt; allows you to write "points free". Here is an example: List.all (\item -&gt; item |&gt; .myProp |&gt; isOdd |&gt;) myList vs. List.all (.myProp &gt;&gt; isOdd) myList Some people prefer the second example because it has less noise, but also because it expresses what is happening, rather than how values get applied to things.
You can put functions in a record just fine. That is often useful for a record of configs, where some of the configs are functions. *However*, as others have said, do not put functions in your model. The reason for this is your model should be serializable for various reasons, including making the elm debugger work. There should be no reason to put functions in your model either, as functions are not stateful, so you can just have them as constants at your tops level, or pass them in to your init/update/view when you define them in Html.program.
I love Reddit arguments with happy endings!
yeah, I noticed now, should have held my excitement for after reading the entire code :D Yes, I'd call it ML-flavored-elixir :P Still nice, but agree very far from elm on the backend! 
It is code smell to need to mess around with deep record nesting. The function doing this has to know about too many things and it makes it overly complex. While the model might have deeply nested records, each level of that nesting should be exposed via a function in a module which knows all about the structure of the record so that the functions which rely on it don't have to. This is why we are encouraged to think in types. We should ask ourselves, "What concept does this type encapsulate?" and then "What is a sane API for interacting with this type?" Then you can hide the details of implementing the API in a module.
FWIW, Alpaca isn't tied to Rebar. I have an experimental mix compiler that makes it pretty easy to run Alpaca in Elixir projects. But targeting Erlang makes it easier to interoperate with the whole BEAM family. I hear you on the dev experience. We're nearing a tipping point with Alpaca when installing and using it on projects is going to be a lot easier.
Running current Elm in Rails 5 application, proprietary app unfortunately, maybe I can get the relevant parts out though. The new Webpacker gem in Rails 5.1 might be very handy, I'll upgrade today probably, will report back if that makes stuff easier. 
Just to reiterate my last few sentences. Can you (readers) share your real use cases? If you agree with my sentiment, that's great. Post your Model and let's make that data available for discussion. If you disagree with my sentiment, even better. Post your Model and please briefly describe how you've use abstraction to make nested record updates a non-issue.
Just as a reminder, people have been posting plently of "data available for discussion" over here: https://groups.google.com/forum/#!topic/elm-discuss/oWfARte8DJU
That was extremely helpful, thank you. :) So if I got this strait... (Attribute msg) and (Html msg) and Html msg are all union types? (And the () show that they 'evaluate' first or together as the single type for List?) And msg corresponds to any type I define, and by convention you place your 'unknown' msg's in Msg as same sort as defined in this union type here and handle it in update? type Msg = Increment | Decrement | Reset So, if I wanted I could rename my Msg to Whatever and have update take a Whatever, and view to return a Html Whatever. So, I guess my last remaining question is how does elm know to use Msg or Whatever without explicitly saying so, because it seems to be figuring stuff out behind the scenes. I tried defining another type (like Msg and Whatever together), but I couldn't make any sense of what was going on. Like there is a Model type declared, but it doesn't try to use that.
Ah, ok. That makes sense. I hadn't considered the type signature of beginnerProgram. Thank you for taking the time to explain that to me. :)
Awesome!
I was going to recommend reading more about [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS) but the fact that it works in Jquery is throwing that theory off. What does the OPTIONS request look like?
Oh, I thought it was elm-dungeons and dragons :( Though this is cool too :D
Can you point out some things you're having trouble with? Some might be code that could be clearer, but if you're having trouble understanding​ language concepts, we'd be happy to help talk through them
 Host: localhost:7000 User-Agent: .... Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Access-Control-Request-Method: POST Access-Control-Request-Headers: content-type Origin: http://localhost:8000 DNT: 1 Connection: keep-alive
I think I get the code now, I just had to keep reading it and refresh my memory of some Elm concepts. Also, drag and drop apparently has a unique API even if you implemented it in JS so that adds to the confusion a bit. I think the other commenters are correct -- I'm just not used to recognizing the common design patterns yet because I'm new to Elm. Thank you anyway!
I'm not sure relying on dialyzer for type checking is a good idea for an ML language. Would probably be better to look into implementing a Hindley-Milner+row polymorphic type system yourself, like the [Alpaca Lang](https://github.com/alpaca-lang/alpaca) folks do. You would then also run up against figuring out how to do type migrations on the BEAM - something I'm not sure the Alpaca people have done yet... maybe it would be good to compare notes with them? I would echo the feelings others have expressed though - this doesn't respect the semantics of Elm enough to justify the name. As it is, it's just syntax. :/
I think http://package.elm-lang.org/packages/elm-lang/html/2.0.0/Html-Attributes#property is what you are looking for to set `srcdoc`.
The problem with `srcdoc` is that it accepts a String type, I was wondering if theres a way to map a Html Msg type to String type so I could use an elm view with the `srcdoc` attribute.
When you are looking for a function, try Elm Search: https://klaftertief.github.io/elm-search/?q=Html+msg+-%3E+String None of those results look promising, so it is likely that there isn't a way of extracting the HTML formatted string representation of an `Html msg`.
Oh sorry, I read too quickly. I don't think elm Nodes expose the information necessary to do that. I think for now you're going to be stuck doing something like your jquery approach.
Let's continue the discussion in our other thread but briefly I think this example doesn't accurately reflect the concern raised for two reasons. 1. This example is very contrived and I mentioned in the OP that the nested record update problem in particular appears in complex apps, such as Single Page Applications. 2. Adding or removing fruit from a list doesn't demonstrate a nested record update. What would demonstrate the problem is if a property on `Apple`, for example, was modified (assuming `Apple` was a type alias and not a tag in a tagged union). Modifying a property on a record nested inside of a list would demonstrate a nested record update pain point.
Yeah, I see more where you are coming from. I think it helps me to start from the point of view of what my views are going to need and "work backwards" to the model. How are we actually using the books, authors, shipping addresses, on what pages? Read-only, or can users make updates? Do they need to be presented sorted? Can the user delete from or insert into the middle of a list? Are they used just for lookup from another model? Is every user role going to edit the same book attributes, under what state, etc. All of these questions and many many more impact the data structures you use. There is not one canonical way to store data, we're not designing a database with a single well-known interface (SQL). We're designing an interface around a wider set of constraints than "a book has one author and an author can write many books", etc. So... anyway a key discovery I made, for the kind of apps I am working on, is something analogous to, or a variety of, Command-Query Responsibility Separation. Some data you just need as read-only lists/arrays/dicts, to use in a number of different pages of the app. This is separate from data your users are actually going to update in a form. The form data is a representation of a state _transition_, not the _current state_ of the underlying entity, and may look quite different depending on the role of the user doing the updating, its current state, etc. This works for the kind of apps I'm working on, with multiple user roles and very structured updates. I would imagine it might be overkill for a typical consumer-facing app, where the models are more directly manipulated, or in an editor app (for example), where the whole data model is loaded up front on init, and the in-memory model is directly updated without a server roundtrip. But my proposal is to work backwards, the needs of the UI will shape the model, and you may well find out you don't need a generic Store concept (database cache, etc.) at all. Re. many-many relationships, I have never seen a UI that let you edit the 'intersection table' from both sides at the same time. You want to edit one one-to-many or the other at once. So even if you are directly manipulating models, it seems quite possible you could store the data as e.g. type alias Book = { ... , authors : List AuthorId } type alias Author = { ... , books : List BookId } 
Re: working backwards from the views - I think this is the source of our differing approaches. At work we consider this an anti-pattern on our Redux applications and I'll explain why. Like Elm, in Redux there is a *single source of truth*. Redux is also a good state management solution for *Single Page Applications*. (both of these constraints are important) Since the general idea is to not duplicate state, and because we don't necessarily want to constantly re-retrieve data every time the user navigates to a new page, then we have to be very careful and deliberate in how the Redux store is organized. Months of lessons learned have taught us that we **should not put View Models in the Redux store**. What do I mean by View Models? I mean the data in exactly the shape the view is expecting. It doesn't make sense for us to put that in the store because **we have many different views of the same data**, and if we instead put view models in the store then we have **state duplication** and will ultimately have state synchronization issues, which defeats the purpose of using Redux. Additionally, if we did put View Models in the Redux Store and a view changed drastically (because of UX, or customer needs, or product owner whims) then the subsequent view may have different view model requirements and the old view model part of the store can't be reused and will likely be discarded. Rather, if we put data in the Redux store in a normalized format and a *view-agnostic* format then our Redux store can be our single source of truth, we "work forward" from the data to the views by inserting a data transformation layer on top of the view that converts *Model* to *View Model*. Taking a step back, I realize Redux is not Elm but they're close enough for the purposes of this conversation. I'm coming from a Redux background. I'm coming from Redux lessons learned on large applications on medium to large development teams (current product team is 30+ devs). Naturally, I bring these best practices over to my thinking on Elm and several of those best practices implicitly have some sort of nested record structure. *On a Production scale application, specifically for the single page application we build, it doesn't make sense to have a totally flat, monolithic Redux store*. This is the source of the mental disconnect in my mind that I mentioned in the OP. It seems obvious to me that a minimum of 3 levels of nesting would be required for the types of applications we build and likely for how other Single Page Apps are built. Sorry I rambled on for a bit. tl;dr - I think you're talking about view models inside of the application state and we don't do that
I wonder what I would do without Reddit. Thank you so much 
Thank you I will watch it. I shouldt end up in a problem with an empty list as i want to use the randomness to get predesigned obstacles put in a random order in to another list. I dont want to remove from the original list, or if i do i will add it right back in 
Our main reason for wanting to use CSS Modules is that we have a library of standard React components whose styles we want to share when building Elm equivalents. Yes, we could replicate the styles in elm-css, but we'd rather avoid that duplication and keep our styles portable.
I've found that the best place to start with reading any Elm code that follows The Elm Architecture is the update function. The update function binds the whole program together so you can get a general sense of what types of messages are coming in and what the effect on the model is. From there, you can figure out how the thing is displayed in the view or controlled either via some control in the view or some subscription. 
Personally i like to think of &gt;&gt; as a tool for creating empty pipes that are not containing any fluid (data). When you use the |&gt; pipe operator, you create a pipe that contains liquid, which is harder to repair (refactor) and to combine, because it contains fluid. Note that the |&gt; is not an associative operator, whereas &gt;&gt; is associative, which gives you more flexibility for combining functions together.
Nice article, thanks for writing this up. I really like the formatting of your blog—complete with embedded Ellie!
Thanks! If you're writing in Hugo you can just copy the shortcode: https://github.com/BrianHicks/brianthicks.com/blob/master/layouts/shortcodes/ellie.html And you use it like this: {{&lt; ellie project="yourprojectid/version" &gt;}}
Playing around with Web Audio API with Elm, trying to program a simple sound synthesiser. Aslo, trying to figure out how to connect create-elm-app with zeit.co the best way.
Check my example https://github.com/rofrol/elm-navigation-example I'm using simple node express server and browsersync to refresh browser 
That looks awesome! :D
Is there a specific reason you're doing things like `\world -&gt; \comps -&gt; x` instead of `\world comps -&gt; x`?
Thanks, I was looking for `Maybe.Extra.unwrap`
Cool, I'm glad someone's looking at doing ECS in Elm! I have a stab at ECS API in my "unfinished projects" localhost folder, got a bit stuck when I started and haven't looked at it since. Still have to flesh out filtering based on components, the whole systems thing, etc... Oh well :) tryModel : Model tryModel = emptyModel |&gt; addEntity [ Score Player 0 ] |&gt; addEntity [ Score CPU 0 ] |&gt; addEntity [ Ball , Rectangle { centerX = 50, centerY = 50, width = 5, height = 5 } ] |&gt; addEntity [ Paddle Player , Rectangle { centerX = 10, centerY = 50, width = 5, height = 50 } ] |&gt; addEntity [ Paddle CPU , Rectangle { centerX = 90, centerY = 50, width = 5, height = 50 } ] 
I think you misunderstand. I'm not even dealing with multiple timezones. I'm talking about getting the current date into Elm, in the timezone the user expects -- his or her own. The easiest way to do that is in javascript-land, it would be a major PITA to "convert to the local timezone at the last possible moment" in pure Elm.
For the beginners, like myself, what are ECS libs for?
Thanks! This is very helpful.
Interesting. That looks like components as a union type, whereas Slime tries to avoid that by hiding types as much as possible. I'd be interested to see your approach fleshed out too, if you ever get back around to it.
I just came across Elm today and have watched a couple of Richard Feldman's YouTube videos and got a very high level overview and understanding of how it works. I must admit that I am also a newbie to functional programming. So one thing that sticks out to me based on my initial perusal of Elm is the lack of for and while looping constructs. Is this something that I just totally skipped over or does the language actually not support these basic constructs that are considered pretty standard in others? If it is missing, I have a suspicion that the functional programming nature of the language has something to do with it.
You should be using ports for this. See [here](https://guide.elm-lang.org/interop/javascript.html)
Or web components. Edit: The logic usually goes that if it's something you embed in the page, you should use a webcomponent. Otherwise a port.
ok, now I'm interested in learning this. Any recommended reading or blog you can point me to?
There's a wiki dedicated to the subject: [here](http://entity-systems.wikidot.com/). Articles pop up on /r/gamedev every once in a while (e.g. [3 here](https://www.reddit.com/r/gamedev/comments/1f83c5/3_articles_about_component_entity_systems/)). If you're not doing ECS in Elm, virtually every language has a library for it (e.g. I use [Ashley](https://github.com/libgdx/ashley) when making games with libgdx). Good luck :)
For issue number one, I have a special workaround: https://www.reddit.com/r/elm/comments/5uqa13/those_fancy_date_pickers_in_elm_watch_this_no/?ref=share&amp;ref_source=link Works nice so far, I have extended it a little bit since then, configuration parameters are passed through element's attributes.
There was a post [2 months ago](https://www.reddit.com/r/elm/comments/5vh1fi/where_do_you_suffer_most_while_programming_in_elm/?st=j28llv6n&amp;sh=c0cf92fd) if you want to explore pain points. &gt; Let's share the pain and try to find solutions! A word of warning as I've been this road before: “To love without knowing how to love wounds the person we love.” - Thich Nhat Hanh If one rushes to solutions without fully understanding what Elm is actually trying to do, the solutions might become a way to amplify the problems. Just like with the [Hydra](https://en.wikipedia.org/wiki/Lernaean_Hydra), you cut one head and a couple more pop up. Evan is trying to kill the Hydra, not to quickly chop off its heads one by one. 
Thank you for the link! Probably I was not clear enough. I don't intent to influence the language in any way, I like the way it is heading. But I assume where are practical tasks which are difficult to be done (or even can't be done) in Elm. The point here is to find solutions or workarounds you could use in your app right now if such tasks appear. The language itself and the philosophy behind it are great, but if one is using it in production, it would be nice to know the boundaries of what difficulties you will have and how to deal with them. Does it make sense?
&gt; Does it make sense? Yes, it makes sense. With ports and web-components one can implement probably everything available to Javascript in Elm. A production app would most likely have Javascript in it but if it's 90% Elm and 10% JS, that's a good place to be. In a lot of cases it's almost all Elm with just a couple of lines of JS on the other side of ports handling the needed but still un-assimilated web platform or some convenience functionality that rests on mutating the dom. So, the general solution (ports) has been available for a long long time. The problem is that people seam to have some kind of a repulsion to using ports and want solutions that feel more like regular Elm. This creates a lot of frustration. :) 
Yeah, you are right! I aim those who have "a repulsion to using ports" mostly. If we could find examples of tasks familiar to most JavaScript developers and compare their solutions in JavaScript and in Elm using ports, that would be nice for community education, I think.
&gt; So one thing that sticks out to me based on my initial perusal of Elm is the lack of for and while looping constructs. Is this something that I just totally skipped over or does the language actually not support these basic constructs that are considered pretty standard in others? Elm is a declarative language. Most other languages that you can think of are imperative. I think that this is the biggest paradigm shift facing an Elm beginner but once you get it, your code will improve even in the other languages (most support some form of functional programming). Take python for example and the task of adding 1 to every element from a list of numbers. The imperative way to do it would be like xs = [1, 2, 3] result = [] for x in xs: result.append(x+1) The declarative way: xs = [1, 2, 3] result = [x +1 for x in xs] or xs = [1, 2, 3] result = map (lambda x : x+1, xs) The declarative way is faster in python because the compiler can optimize the fact that the same function is applied over the entirety of the array. This means that the function application can run in parallel. In the imperative way, you have no guarantees. Every step can alter or interrogate the global state. 
You could sum it up with: &gt; In elm is painful to cope with stateful APIs About the WebComponents integration, I think it is a good start and it is used also in Richard's book (Elm in Action). I'm using ports extensively and I understand your doubts :-)
Sounds almost like have derivable typeclasses would make this trivial
Your `nextFruit` function and `fruitList` must stay in lock step. That is, `fruitList` must "know" that `Orange` is the first in the iteration. A better approach would be to allow `nextFruit`'s first parameter to be a `Maybe Fruit` and then **it** determines what's first. nextFruit : Maybe Fruit -&gt; Maybe Fruit nextFruit maybeCurrentFruit = case maybeCurrentFruit of Nothing -&gt; Just Orange Just currentFruit -&gt; case currentFruit of Orange -&gt; Just Lemon Lemon -&gt; Just Apple Apple -&gt; Nothing Then `fruitList` can start by calling `nextFruit` with `Nothing` and end when it gets `Nothing` back. And now if `nextFruit` changes its order, it won't break `fruitList`.
But thing is, derivable typeclasses seem not to be in the roadmap. This is just an experiment to overcome this limitation.
Glad to help. 
Representing cyclic graphs is really nice in Elm! It fits [in a tweet](https://twitter.com/czaplic/status/859835338981687296)! type alias Graph a = Dict Int (Node a) type alias Node a = { edges : List Int , info : a } I do this *all the time* in the compiler. In practice, I think this is way nicer than how it works when you have mutation.
Thanks I will change it to case instead
I read a blog post recently about **Phantom Types**. I can't find the link but briefly from memory it's when there's a parameterized type on the left hand side that doesn't appear on the right hand side of the declaration. type MyThing a = Thing1 | Thing2 I wasn't really following the form validation examples from the original blog post which looks like it was copied from a common Haskell explanation. Could someone explain a practical use case for using phantom types?
&gt; Limit the size of a stream. Make sure to call this at least once on a stream before calling toList on it; especially for an infinite stream. Seems like you would want to have separate types for limited streams and unlimited streams and only provide `toList` for limited streams.
I played with that a little. It ended up feeling pretty clunky when coding. There end up being use cases for streams outside of toList as well. For example, with these async changes you can subscribe to a Stream. There's no problem at all with infinite streams yielding values every second at all. If I split the Stream types in terms of finite/infinite then I'll end up having to make two versions of other things like subscriptions needlessly (internally or otherwise).
Missing characters in the input fields. Look at the screenshot of the result, attached in the README.md, and at the Main.java.
This is so cool. I had no idea there was a gamepad api
Very cool! Here are a few things I'd think about if I wanted to improve the API: * you can set up a subscription to poll for GamePad data instead of running through `Cmd`. * It'd be really cool if the buttons had a union-type name. Something like: `type ButtonName = DPadLeft | DPadRight | DPadUp | DPadDown | Start | Select | RightBumper ...` * You can capture the axes data a set of coordinates for each analog stick: `type alias GamePad { --...some earlier stuff , analogLeft = (Float, Float) , analogRight = (Float, Float) }` Again, very awesome.
Arrays are nice if your keys are consecutive integers starting from zero. I find that my keys are often strings or other things, and that they are not densely packed. You can of course do a mapping to integers, but it has never been a performance issue. Better to do it nice than to optimize for some fear that does not manifest in practice.
I would go with a custom type instead of two Bools, as you really only have 3 states (not nudged, nudged, engaged). Two booleans cover 4 states. You'll also want to prevent the default behaviour of the checkbox. I did a quick sketch here: https://ellie-app.com/36hptgwD2s8a1/0. Please note that this is *a* solution, not *the* solution. You will most likely want to extend and/or customise my example.
Right after publishing this package I was informed about some prior art: http://package.elm-lang.org/packages/prozacchiwawa/elm-json-codec/latest The APIs are similar in many ways, but differ especially when it comes to building specifications for objects and other more customized things.
First of all, please note that this is not a commonly required technique. It's something that you could easily never need, and is usually not worth the added complexity, but I've found some use for it recently so I'll give an explanation. You can use a phantom type parameter to constrain how different values of the type can be used in different situations. Taking your `MyThing` example, you could do something like this: type MyThing a = Thing1 | Thing2 type Thing1Type = Thing1Type type Thing2Type = Thing2Type thing1 : MyThing Thing1Type thing1 = Thing1 thing2 : MyThing Thing2Type thing2 = Thing2 You can put these functions in your MyThing module and only expose the types without directly exposing the Thing1 and Thing2 constructors, meaning that other modules can only construct MyThing values with thing1 and thing2, which have their type parameters specified merely because they're annotated with them. Then you can have some of your functions work on all MyThing values, and other functions can be made to only work on `MyThing Thing1Type` or `MyThing Thing2Type`: myThingNumber : MyThing a -&gt; Int myThingNumber myThing = case myThing of Thing1 -&gt; 1 Thing2 -&gt; 2 thing1Arithmetic : MyThing Thing1Type -&gt; Int -&gt; Int thing1Arithmetic myThing n = myThingNumber myThing + n Here's an example of where I've used this technique recently: https://github.com/jamesmacaulay/elm-graphql/blob/a4e3cff7c8c8c09963fc3a7051a116d34b547237/src/GraphQL/Request/Builder.elm#L117-L125 The operationType parameter of the Request type is a phantom type. The functions in the module provide ways to produce Request values with either Query or Mutation as the operationType, and the only reason that type parameter is there is to keep queries and mutations separate to prevent performing a mutation when you only meant to perform a query. I do this by having separate functions that only work with each kind of Request: https://github.com/jamesmacaulay/elm-graphql/blob/a4e3cff7c8c8c09963fc3a7051a116d34b547237/src/GraphQL/Client/Http.elm#L51-L68 I hope that helps. 
Made a small fractal explorer using the great elm-graphics library. https://cust-c.ffm.system.im/elm/mandelmbrot/index.html Code is here: https://github.com/sheyll/mandelmbrot
That helps. Thanks!
Finally got around to learning Elm and decided to make a small simple app that shows changes you make live in a fake device, using iframes. code: http://github.com/praveenperera/elm-device-preview demo: https://praveenperera.github.io/elm-device-preview/
I just found it and I would like to hear some thoughts about the elm analysis they made: I think it is a bit too shallow, although the point of elm not being backed by a tech giant is correct in my opinion.
A sort of work-diary application to help with multitasking. Right now is just in an experimental phase, nothing fancy. Added support to use it as a chrome extension, with 99% support to fully operate it with hotkeys (pending to focus a text field when entering edition mode) https://github.com/arnauorriols/multitaskOS
You can use JS debugger to determine which function causes the problem and if possible, rewrite it to be tail-recursive ([example](https://github.com/truqu/elm-base64/pull/13/files)). Elm should then take care of the tail-call optimization, at least for the [simple cases](http://elm-lang.org/blog/compilers-as-assistants#tail-call-optimization).
Also, if you're not already, you should definitely jump on the [elm slack](https://elmlang.herokuapp.com/). There's a gamedev channel that would definitely be interested in this and could probably give more nuanced feedback than I can on reddit :)
Hey, did you see my last PR? I'm improving it, take a look: https://github.com/FidelisClayton/elm-spotify-mapper/pull/21
I guess I don't see the point. I use languages according to what's appropriate, not what's popular. I'm reminded of [Beating the Averages](http://www.paulgraham.com/avg.html): &gt; We knew that everyone else was writing their software in C++ or Perl. But we also knew that that didn't mean anything. If you chose technology that way, you'd be running Windows. When you choose technology, you have to ignore what other people are doing, and consider only what will work the best. I tried to get into React, but I could never get over my aversion to the obvious red flags, like using strings as messages instead of union types. I'm not steeped well enough in the frontend webdev zietgeist to say if Elm will ever displace React, but it has already displaced every JS framework in my personal universe. 
This [one](http://eeue56.github.io/json-to-elm/) does decoders :)
This article misses the point. It sounds like elm has the goal to me dominant over React. No reason given
Post this offer on https://elmlang.slack.com/ chanell #jobs
Do you have the debugger enabled? I have gotten stackoverflow errors while using the debugger that I otherwise don't get.
Having a non turing complete language cant be the issue, just a big-enough list is enough to make elm crash. See this https://github.com/elm-lang/elm-compiler/issues/1521 A non-turing complete language can handle small lists with no problem. A stackoverflow by the compiler is not something that should happen becuse your list is too long, you can always ofc. Crash with incorrect recursion, but if it crashes even without recursion its def a compiler issue.
This is so helpful, thank you very much!
It's a great question, and I think a decent number of folks struggle with this. I recommend against arbitrarily drawing module boundaries along these lines. Breaking out view functions into another module seems reasonable, but creating a directory for `view` and `update` and `model` seems like it will go badly in the long run. This is like organizing your codebase into directories for `foldl` and `map`. They are just functions, not really *concepts* that exist in your application. ## Recommendation I try to recognize *data structures* and then break out any code related to that. For example, if I recognize a `Student` kind of data, I would break out code specifically related to that. First move the `Student` type into a `Student` module. Then maybe bring along relevant `view` code. If the resulting `Student.view` code needs additional information, just pass it in as arguments. When you call `Student.view` you can pass in that additional information. Now imagine there is specific logic related to students. **I would not organize it in terms of its relation to `update`.** I would have helper functions like `Student.isPassing` that can be *useful* in the `update` function. In other words, there is very rarely any reason to drag `update` and `Msg` code into the `Student` module. ## Notes 1. **I suspect the heart of a *great* module in Elm is a *data structure*.** A `type` or `type alias` that represents some important and coherent concept. From there, you have functions for working with that data structure. A good test for which functions to include might be to ask: does this function make sense if I only read this module? 2. **If you find yourself writing `get` and `set` functions in your module, I think something has gone badly wrong.** If you want outsiders to have unrestricted access to all your internal values, just use a record. If you want to hide your implementation, use a `type` and do not defeat the whole idea of hiding the implementation by providing `get` and `set` for every single implementation detail! 3. **Be skeptical if you have a module full of only functions.** Sometimes you will need a `Utils` file with no data structure at its heart, but it is rare. I think it is worth being skeptical when you see a module without any coherent relationship to a particular data structure, especially if you are just getting familiar with how to structure large projects in a functional language. Hopefully that is somewhat helpful. I am attempting to write this stuff up in a way that's generally helpful and constructive. It is hard to do, but there may be some progress.
Have you seen [RealWorld/Conduit](https://github.com/gothinkster/realworld)? I'm expecting a good Elm implementation to be 3-4 times larger than TodoMVC and could be a great showcase on how to do routing in Elm and how to structure a larger app. I've started an implementation structuring the code in the paradigm that makes most sense to me but it would be amazing to have a blessed implementation. 
Thank you so much for trying to help. * I'm using the browser back button * I'm using hash URLs. If I'm honest, I didn't think the `navigation` supported anything else. I can't see a clear indication from the docs that it does. I thought perhaps I'd need to do extra things in order to preserve the position, but perhaps I'm just using the current set up incorrectly? Any help would be much appreciated!
I'm using Elm to build a UI for webtorrent, which is a torrent downloading engine. The backend is NodeJS which communicates to Elm via websockets. The eventual goal is to download torrents remotely and be able to download the complete file or send them to remote storage backends e.g. Dropbox Check it out: https://github.com/kevgathuku/elm-torrent-dbx
Your solution still needs enough popularity to have an ecosystem.
Ah great, I didn't know about the gamedev channel, I'll get on it.
I think that the browsers don't automatically restore scroll positions on the hash routes, so you would need something to store/restore. You can definitely use non-hashed urls, though, which should allow the browser to do more of that for you. If you're doing things from scratch and using the url-parser package, you'll need to use the 'parsePath' function instead of 'parseHash'. See docs: http://package.elm-lang.org/packages/evancz/url-parser/2.0.1/UrlParser#parsePath You'll need to preventDefault your links, too. There's a good solution in the 1st post of this issue (linked from navigation package readme): https://github.com/elm-lang/html/issues/110
That's a very good point - you're right. It would be dumb of me to put the API key in the browser. I'll do it in Python instead.
Christmas came really early this year! :) I think that this is an historical Elm event. 
&gt; -- WARNING: this whole file will become unnecessary and go away in Elm 0.19, &gt; -- so avoid putting things in here unless there is no alternative! In Main.elm, what does this mean? What's going to change in 0.19 to make this unnecessary?
From looking at https://github.com/elm-lang/projects/blob/master/roadmap.md, it seems as though the routing layer is being redone. Relevant snippet: &gt; I recommend treating each “page” as a separate Elm module, and then having a “routing” module that uses elm-lang/navigation, evancz/url-parser, Cmd.map, and Sub.map to swap between pages. This will set you up well for 0.19 which will provide a much nicer alternative to that “routing” layer.
Question: you put your decoders together with your Data models, rather than in your Request modules, where they are used. But the _encoding_ of messages to the server is done in Request modules. Did you consider putting decoders also with the Request functions, and reject that approach? I can see arguments both ways. Decoders after all are constructors, so if you have internal models you'd want them to be defined in the same module as the models they construct. On the other hand it is nice not to have to wade through the serialization mechanics and have your Data modules be strictly about domain logic.
Sorry, I was looking at the code on my phone and had to scroll back and forth. I didn't realize there wasn't an existing list. One could of course create one with `List.range`. And this would be a better approach if you wanted to generalize the family size something like: produceFamily : Options -&gt; Organism -&gt; Organism -&gt; Seed -&gt; Int -&gt; ( List Organism, Seed ) produceFamily options parent1 parent2 seed size = let ( children, finalSeed ) = List.range 1 size |&gt; List.foldl (\_ ( children, seed ) -&gt; produceChild options parent1 parent2 seed |&gt; (\( child, seed ) -&gt; ( child :: children, seed ))) ( [], seed ) bestParent = if parent1.score &lt; parent2.score then parent1 else parent2 in ( bestParent :: children, finalSeed ) 
I am not OP but my rationale for this is: A decoder transforms from one *response* into potentially many different projections of data objects, e.g. One decoder decodes the pagination information in the response payload, to know to ask for more data, and the other decoder decodes the payload data into a particular model. So your decoders are tightly coupled to the form of your data models. An encoder transforms from one data interface into potentially many *requests*. Your encoders are tightly coupled to the form of your requests.
Awesome this should be a great resource
Great question! One reason is to avoid circular dependencies. Suppose I have a few requests that want to decode a `User`, and I have some more requests that want to decode an `Article`. Now suppose I have two requests that wants to decode both - say, "an article plus all the users who have commented on it" and "a user plus all the articles they've written." If I've put the `User` decoder in `Request.User` and the `Article` decoder in `Request.Article`, now I can't put one of these requests in the `Request.Article` module and the other in the `Request.User` module without creating a circular dependency. Another reason to decouple them is that HTTP requests aren't the only potential use for these serialization/deserializations. For example, we're using the `User` encoder/decoder to store session information about the currently signed-in user in `localStorage`. Hope that helps!
Generally speaking, I'd say it's good practice to have requests, data models, and decoders involved in communication with the backend API wrapped up together into a "Client" module (stored with the backend server source), and then imported into your SPA. Keep in mind that multiple elm SPA's may need to communicate with the same backend API, so you'll want to import the Client module wherever you need it.
This directory structure is something I would not have personally opted for. Instead of organising around the layer (Page, View, Data...), I would have organised around the entity (User, Article, Session...). Basically, the reason I lean towards the later is because it increases the cohesion of the packages, avoiding dependencies that cross the whole repository. Anyway, the point of the comment is to learn, what are the reasons that drive the kind of organisation you propose? I'm sure you have considered many organisation schemes, and have some very interesting reasons why you've chosen this one. 
ah this is exactly the architecture example i've been looking for! thank you!
Number 4 addressed with [https://github.com/ckoster22/elm-genetic/commit/77ed1e365972f9de5a3b2005a2913aab94bef050](https://github.com/ckoster22/elm-genetic/commit/77ed1e365972f9de5a3b2005a2913aab94bef050) Added and exposed a union type which determines if we're maximizing a score or minimizing a penalty. type Method = MaximizeScore | MinimizePenalty Renamed "score" to a more agnostic name, "points".
I'm working on my first package which is a genetic algorithm library. It's also forcing me to think harder about types (a good exercise) since others may consume this code. See my [other thread](https://www.reddit.com/r/elm/comments/69uxl1/seeking_feedback_on_a_genetic_algorithm_package/) for some much needed feedback!
Number 5 addressed here [https://github.com/ckoster22/elm-genetic/commit/21bfdd98214c9adc74cf645ce2da6c597729da89](https://github.com/ckoster22/elm-genetic/commit/21bfdd98214c9adc74cf645ce2da6c597729da89) by creating my own helper module and using `NonemptyList.fromElement` to create an initial nonempty list and using `NonemptyList.cons` to put the rest of the list together.
You are such a champion for making this. Thank you. 
This sounds like a [XYproblem](http://xyproblem.info/). What is the actual issue here? What are you trying to do with regular Elm and feel that you could do better with the help of some library? Can you give us a minimal use case to motivate the need for the said library? 
Some time ago I created a WebRTC chat. It was vanilla JS with a horrible callback hell :D Then I learnt to React, Redux, Redux-Saga and created such chat again using these libraries. Thanks to Redux-Saga, which is built on [JS generators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators), I avoided callback hell. I'm afraid that Elm is just like React+Redux, and I need some Redux-Saga equivalent to write such complex apps with clean code
Ok, I will try to implement that chat again. &gt; Elm is a declarative language and it might take a little bit to adjust your thinking I'm an Elixir programmer so functional programming is not a problem
How is this free if it asks me to sign up for a free trial? Am I missing something?