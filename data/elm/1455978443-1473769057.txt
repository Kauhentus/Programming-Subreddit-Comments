Looks good! :)
I love this, thank you!
Damn useful. There is one problem though. Say you have two fields: Int and any other field (e.g. string). In the first field you make a mistake and type 7z. This will stay in the HTML field when you tab out, but when you make a change to the other field, it will then revert back to the previous value. This would be expected because at that point a true action is sent off causing the entire view to update, and then because the model wasn't updated when 7z was typed in the previous value wins. This is something I would like to think about how to solve. Perhaps a new type the encapsulates both the value and the transient string would help e.g. `type alias Entering a = { value : a, current : String }` When I get some more time I will investigate this and put something up on github. 
kudos, this helped me a lot. It's just your standard `map` function, but designed to work on tasks, where a task is a wrapper for a single value. That's much clearer than the docs. 
Constructors exist in a totally separate namespace from types. When you do `type NewType = Maybe String | SomethingElse`, you are declaring a constructor for `NewType` named Maybe, which is *completely unrelated* to the type named `Maybe`. Your `MaybeString` option is, in fact, exactly how you should deal with this issue, although you could also "factor" out the Maybe into separate cases, like this: type NewType = NewNothing | SomeString String | SomethingElse Both approaches work. The advantage of your approach is that you can sometimes use the already-existing wealth of functions that operate on a Maybe, though you will still have to pattern match on your `NewType` to be able to use them.
That's what I am saying. When I originally tried learning elm for the first time a year ago that was a phrase that I heard passed around.
This is a tiny wrapper around window.crypto.getRandomValues. Wonder if it makes sense to include this into the standard library? Anyway, hope somebody finds this useful.
Let me know if you run into any issues with the tutorial.
This tutorial is amazing. If you want to take it further, you can add some instructions from [electron packager](https://github.com/maxogden/electron-packager) and create a full OS X App. You can use the [Mario Example](http://elm-lang.org/examples/mario) code for this. 
Thanks for the notes, Petre. So the ubiquitous [Max Ogden](/u/maxogden) strikes again. I'll have to check this out. 
I like to have private and public actions. Private are the actions that the child needs in order to do something and public are _do nothing just notify your parent_ actions. You can combine them as well but the basic principle is to just use nested _case of_ and provide some implementation for public actions while simply updating all the rest. case act of MessageBoxSubmit msg -&gt; case msg of MessageBox.MessageSent str -&gt; { model | posts = model.posts :: [Posts.update (Posts.Create str) model.posts] } _ -&gt; { model | currentMessage = MessageBox.update msg model.currentMessage }
packaging is such an unglamorous endeavor but you would be my hero if you would solve this for Elm. In the best case scenario, stuff like this ends up in elm-package and, with one of the next versions, elm-package.json gets few more options while elm-package could get a "standalone" option or something like this. :) 
Cool! Can it do more than just a Boolean value?
Just another note to let you know how great this is!! :)
Sure, it can do ints and floats too. Check out the Elm source.
If i'm understanding this right, I can leave the child implementation alone, but in the parent, nest a `case of`? I can think of ways to change the child implementation to pass-along another action, or expose some sort of decoder, or trigger another action update when one update flows through, but all of those sound like bad ideas. I want to avoid the child module having to know any details about the parents or changing its behavior to facilitate its reuse (if possible). Given your comment above, I would think something like this... update : Action -&gt; Model -&gt; Model update act model = case act of MessageBoxAction msg -&gt; case msg of MessageBox.Action.MessageSent -&gt; let updatedMessage = MessageBox.update msg model.currentMessage newPost = Post.init msg model.posts in { model | posts = model.posts :: [ newPost ] , currentMessage = updatedMessage } _ -&gt; { model | currentMessage = MessageBox.update nested model.currentMessage } But I'm not quite sure why this doesn't work. Given parent module actions of: type Action = MessageBoxAction MessageBox.Action How can I say `if type of MessageBoxAction -&gt; if type of MessageBoxAction is { particular child action } do something different; else let child update itself normally`?
`MessageBox.MessageSent` is one of `MessageBox` actions so you don't say case msg of MessageBox.Action.MessageSent -&gt; _ -&gt; but rather: case msg of MessageBox.MessageSent -&gt; _ -&gt; also `MessageSent` takes a string parameter so it's more like this: update : Action -&gt; Model -&gt; Model update act model = case act of MessageBoxAction msg -&gt; case msg of MessageBox.MessageSent text -&gt; let updatedMessage = MessageBox.update msg model.currentMessage newPost = Post.init text model.posts in { model | posts = model.posts :: [ newPost ] , currentMessage = updatedMessage } _ -&gt; { model | currentMessage = MessageBox.update msg model.currentMessage }
I was a little scared to open up the source file... but then I did and I understand everything!! :) This is just what I was looking for!
&gt; Install Node links to `s`
Thank you for creating the tutorial. I'm gonna have to read it a few more time to get everything! It covers a lot of ground.
How much experience are you looking for?
Ah, thank you. So `inputs` should be a `Signal` of the same actions that `update` is expecting? That makes a lot of sense. I also haven't really done much with arguments to `init` so I should definitely explore that further as well. Thanks again for taking the time.
&gt; Ah, thank you. So inputs should be a Signal of the same actions that update is expecting? That makes a lot of sense. Precisely! `inputs` is a List and as such you can feed a lot of sources into the same app mapping them to different Actions. &gt; Thanks again for taking the time. One is glad to be of service. \^_\^ 
Take a look at the `Graphics.Input.Field` module from the standard library: http://package.elm-lang.org/packages/elm-lang/core/3.0.0/Graphics-Input-Field
Rather than defining your own `Either`, you can use the core `Result` type. (Personally, I think `Either` is a better name for a library supplied type, but `Result` matches your use case.) Then you can use `Result.map` and `Result.andThen` in the same way that /u/jediknight suggests for `Maybe`.
You don't have to wholesale switch to `Graphics` from `elm-html` - you can create your inputs with `Graphics.Input.Field` and then convert them to `Html` with `Html.fromElement`. Ideally you would do everything in `elm-html`, but unfortunately I don't know of anyway to use the javascript `select()` API in Elm.
How about using ReactJS? You get to use JS, but you also get a reactive architecture.
React/Redux is somewhat close. You miss out on that sweet compiler, though!
You don't like writing JS but you want to write an Elm-like app in pure JS - that doesn't make a lot of sense. Maybe I've misunderstood something. Anyhow, to answer your question, I came across this article a couple of days ago - maybe it'll help: https://medium.com/javascript-inside/elm-architecture-with-jquery-152cb98a62f#.besjhfo3e You should also checkout Mercury (https://github.com/Raynos/mercury) (it partly inspired elm-html) as the concepts are kind of similar and that uses just javascript.
Great tutorial! Just started and hitting a problem. In this chapter: http://www.elm-tutorial.org/030_elm_arch/model.html i get an "elm-make: out of memory" error. It looks like it is because of this line: Signal.foldp (\_ state -&gt; { state | count = state.count + 1 }) initialModel Mouse.clicks change to: Signal.foldp (\_ state -&gt; { count = state.count + 1 }) initialModel Mouse.clicks and it works. Any help?
Now I think what I should try to this with ``Effects``. Especially this one looks promising: ``toTask : Address (List a) -&gt; Effects a -&gt; Task Never ()``. It seems like that a type ``a`` (a ``Dict`` of DOM-elements in my case) disappears and won't present in resulting ``Task``. Tasks like this "untyped" one *can* be runned with ``port``!
If you want field names as strings, try using Dict instead of a record : http://package.elm-lang.org/packages/elm-lang/core/3.0.0/Dict
&gt; Or what's the correct way to access an Elm record with the field name passed as a String? What should be the signature of this function: getByKey : String -&gt; {key1:Int, key2:String} -&gt; ??? getByKey k r = (magic k) r what should it return? If you answer this question, you can solve your issue. The way I view it, you want a function that will return either an Int or a String while receiving the same kind of input and I don't think that's possible. If all keys have the same type, the story is different. ;) 
I'll give Dict a try, thx!
Thanks for sharing! Based on your experience, would you recommend svg or collage for similar applications?
Thanks, that's perfect! Now that I know how to do this... it's incredibly useful! 
Elm discourages indexing `List`s, as they are linked lists under the hood: to retrieve the 1001th element, you have to first visit all 1000 previous elements. You could use an [`Array`](http://package.elm-lang.org/packages/elm-lang/core/3.0.0/Array), which has a `get : Int -&gt; Array a -&gt; Maybe a` function that’s really fast! Alternatively, if you don’t wanna rewrite all of your code, and your list is short enough that performance isn’t an issue, writing your own `getAt` function is quite easy: combine [`List.drop`](http://package.elm-lang.org/packages/elm-lang/core/3.0.0/List#drop) and [`List.head`](http://package.elm-lang.org/packages/elm-lang/core/3.0.0/List#head).
There are some things you can do with SVG that are not possible using collage. These include but are not limited to: mouse selection of displayed objects, display of external SVG objects ( for example, these cards : http://svg-cards.sourceforge.net/ ) and use of a wide variety of fonts. SVG would be the right choice if you know you will be needing any of those features. However, my takeaway lesson from this exercise was that it's pretty easy to switch from collage to SVG so there's probably not much harm in starting out using a collage. In my particular case, I was thinking of using a drag and drop to adjust the position of the fob ( the adjustable weight that determines the pendulum's rate). After converting my collage graphics to SVG I decided to use an HTML slider instead but left the two renderings in place. 
Why though? Aren't arrays usually faster in the real world except in very specific cases of inserts in the middle of huge arrays? Especially in JavaScript? Something I remember from comp sci anyway, especially in regards to C++ data structures.
Because array is buggy, you can just use a Dict for the time being! Just using numbers as keys!
Immutability and recursion. Functional languages typically use linked lists as the primary structure because they can be iterated over using recursion. You can't do a for loop when things are immutable so iterating an array would involve passing along accumulator values and checking that those values are valid every time. Then once a list is created, it's never mutated or added to. Instead of mutating or adding to a list you define a totally new list as "new list B = extant list A, with *these* additions or differences" -- and because A can never change, B doesn't need to make a copy of A (as it would in a mutable language), it can just save a pointer to it. Arrays are stored in adjacent memory locations which means you can't do this. B = A + something means B needs its own independent copy of A. So you're creating an entirely new array any time you add or modify a value, which is slow. &gt; faster in the real world except in very specific cases of inserts in the middle Arrays are faster to access randomly (if you know an array of float 64s starts at 0x186a0 and you want the 108th element you can just skip right to 0x1870c) but expensive to expand (if 100 elements were allocated and you try to write the 101st the entire thing has to be moved). Linked lists are slow to access randomly (you have to go 0 -&gt; 1 -&gt; 2 -&gt; 3) but always cheap to prepend to.
&gt; Aren't arrays usually faster in the real world except in very specific cases of inserts in the middle of huge arrays? Especially in JavaScript? Something I remember from comp sci anyway, especially in regards to **C++ data structures**. Well that's the thing, you're talking about "imperative" arrays here: a contiguous chunk of memory of size n*whatever you put in it, which you're going to mutate in place. But what happens in an immutable language? Now every time you want to change something you have to copy the whole array, which is *really* slow. While linked lists have issues, you can at least shift and unshift cheaply (create a new head element, or take the list's tail), hence their ubiquity in functional languages despite their locality issues (linked lists are giant games of pointer-chasing), and the fact that you can't just go and access the nth element, because while that's constant-time in a contiguous array (`read (addressof(array) + n)`) it's linear time on a linked list (skip n-1 items) That's been changing since the late 90s/early 00s and more extensive research in tree-based functional datastructures, but the tendency to use linked lists remains (doesn't help that linked lists are much easier to implement than more involved functional datastructures).
&gt; what should it return? `Either Int String` obviously ;)
Since you asked for the bare minimum :) import Graphics.Element exposing (show) import Http import Signal import Task exposing (Task, andThen) results = Signal.mailbox "" port tasks : Task Http.Error () port tasks = Http.getString "https://api.ipify.org" `andThen` Signal.send results.address main = Signal.map show results.signal 
Very nice introduction to Elm. 
This is the Html version. Also, technically, [you don't need to import Signal anymore](https://github.com/elm-lang/core#default-imports). import Html exposing (text) import Http import Task exposing (Task, andThen) results = Signal.mailbox "" port tasks : Task Http.Error () port tasks = Http.getString "https://api.ipify.org" `andThen` Signal.send results.address main = Signal.map text results.signal
I think it is overstating to say you won't get crashs in Elm code. You can easily get crashes in Elm code by explicitly raising errors (incomplete functions) or invadvtently using a function that does this. And then there is interop code which of course calls Javascript and can cause crashes in the code. It is better to say that Elm langauge avoids most crash causes at compile time with strict type checking. Crashes are very rare but still possible due to interop, explicit errors raised by programmers (which should ideally be none) and Elm ompiler or browser bugs.
yes, there are better ways. Here is how I would extract functionality (I've added another element to showcase some of the benefits and another way to approach things): view : Signal.Address Action -&gt; Model -&gt; Html view address model = let fwd toAction = Signal.forwardTo address toAction in div [] [ Button.view (fwd UpdateButton) model.button , OtherStuff.view (fwd OtherAction) model.other ] noFx m = (m, Effects.none) update : Action -&gt; Model -&gt; (Model, Effects Action) update action model = case action of UpdateButton act -&gt; noFx { model | button = Button.update act model.button } OtherAction act -&gt; let (other', fx) = OtherStuff.update act model.other in ({ model | other = other' }, Effects.map OtherAction fx) Please give the Elm Architecture a try. In the beginning it is a little bit uncomfortable but this is more because of the fact that it is new. After a couple of weeks, the genius in it begins to be apparent. If facilitates a clarity of implementation that eases the development. You pay a higher price upfront BUT, it starts producing dividends very very fast. :) 
Your code is the same, just slightly better factored.
Thank you, sir! Yes, I am using the Elm Architecture, and love it - as long as I don't have more than one nested child. However, my point of pain is updating a nested child that might be 3 or 4 levels deep. (See my reply to mcapodici's comment.)
How about this: anyFunction' a b c = ... anyFunction a = anyFunction' a "text" 32
I am experimenting with an idea at the moment that the actions be of type Model-&gt;Model directly making it easier to compose child ones into parent ones. I'll see how that plays out but it would mean ending up with a signal of functions which may be frowned upon by Evan :-)
I agree with your points, which vindicate my first point. "I think it is overstating to say you won't get crashs in Elm code." 
This is an optical illusion. If you have a N-depth hierarchy of components and you need to add something to the deepest one, you only need to change a single level. All the above levels say absolutely the same because they deal with the forwarding of the actions NOT the actions themselves. Here is a contrived example for some context: import Html exposing (..) import Html.Events exposing (onClick) import Http import Task exposing (Task, andThen) import StartApp.Simple import Effects type ActionA = ChildA ActionB type ActionB = ChildB ActionC type ActionC = ChildC ActionD type ActionD = Inc | Dec --| Inc10 | Dec10 type alias ModelA = { childB : ModelB } type alias ModelB = { childC : ModelC } type alias ModelC = { childD : ModelD } type alias ModelD = Int update actA model = case actA of ChildA actB -&gt; ModelA &lt;| updateB actB model.childB updateB actB model = case actB of ChildB actC -&gt; ModelB &lt;| updateC actC model.childC updateC actC model = case actC of ChildC actD -&gt; ModelC &lt;| updateD actD model.childD updateD actD model = case actD of Inc -&gt; model+1 Dec -&gt; model-1 --Inc10 -&gt; model+10 --Dec10 -&gt; model-10 view address model = viewB (Signal.forwardTo address ChildA) model.childB viewB address model = viewC (Signal.forwardTo address ChildB) model.childC viewC address model = viewD (Signal.forwardTo address ChildC) model.childD viewD address model = div [] [ button [onClick address Inc] [text "+"] , br [] [] , text &lt;| toString model , br [] [] , button [onClick address Dec] [text "-"] , br [] [] --, button [onClick address Inc10] [text "+10"] --, button [onClick address Dec10] [text "-10"] ] main = StartApp.Simple.start { model = {childB = {childC = { childD = 0}}} , update = update , view = view } If you want to modify the counter (childD of childC of childB of the main model) the only code that needs to change related to: ModelD, ActionD, updateD and viewD. All these things would normally be in a single file. Any action you add to ActionD will ONLY affect the code related to updateD and viewD. Any of the other actions stay the same. I have commented out a potential phase 2 modification of the counter. Please uncomment the code and see it work. As you can see, the commented code touches ONLY the counter code (ActionD, updateD, viewD). Nothing else changed. Another way to look at it is: once you put in place the skeleton of the application (the big components and how they fit) you will be able to easily change their behavior. 
&gt; Whats the best way to do this in Elm? my preferred way is to create other functions, just as /u/mister-metaphor suggested. There one difference. In Elm, you put the defaultable arguments first and the one that doesn't have a default last. anyFunction b c a = ... and then you can do: defaultText = anyFunction "text" defaultTextAndC = withText 32 
There's actually kind of an interesting question here. When Elm interacts with browser components, the browser is managing its own state for say an html5 date input (that the user has clicked on the calendar and has scrolled left a few months, etc). In Elm we can subscribe to a specific event on that date input component without having to pass its state, actions, effects, and inputs all the way up and down the chain. If you write your own datepicker in Elm, now you have to deal with passing all this stuff around and embedding its model in your parent model. What's the difference between a browser native component and one you happened to write in Elm? It would be nice to have some way of saying that this module is essentially a self-contained elm program that manages its own state. One of the things I'm doing in my app is effectively re-implementing select2 https://select2.github.io/ in Elm. I'm not sure this will ever actually get implemented as a published package in Elm because too much implementation detail has to be exposed to the end user. In particular, the end user has to capture the keyboard input and send it down into the module. I'm still relatively new to Elm. I've written about 1000 lines of Elm in about 15 modules and this has been the biggest nuisance so far. I'd love to publish my version of select2 and if you have suggestions on how that can be properly achieved in Elm, I'd be open to hearing them. 
&gt; What's the difference between a browser native component and one you happened to write in Elm? I know this pain. I've been there. This is also my main issue with Elm. &gt; I'd love to publish my version of select2 and if you have suggestions on how that can be properly achieved in Elm, I'd be open to hearing them. This kind of scenario can be accomplished with the help of Native. Unfortunately, use of Native can be a bit of a problem for the flexibility of development of Elm and as such it has been somewhat discouraged. Maybe in 0.17 things will be much better in this respect. 
But there is more to it than that in a real situation. If you want more than one "Datepicker" component on a page it is a LOT of work, you have to set up the wiring for each one, then you have to decide on a mechanism to pass its changes back up to the parent "Form" component. In the hack &amp; slash jQuery world I just do $('input.datepicker').datepicker(). Not saying this is better, but a real-world form needs lots of fancy widgets, autocompletes, datepickers, etc. Ideally you would want to re-use these in multiple apps, but what ends up happening in elm is they become intricately tied to the parent model data, and the parent widget has extra code to keeps its own state in sync with changes in the child widgets. Basically, it seems really hard to create a generic "Datepicker" that I can drop in any app, but I'm sure there must be a way.
Yes, that's what I would like too: modules as self-contained programs that manage their own state. ..oh yeah, we already have that... Java ;) But really, if Module A, could update a Module D, without having to thread redundant updates through B and C to get there, that would be awesome! 
What you describe are valid concerns and they regard the design of the DatePicker API. Beside the classical exports (Model, Action, init, update and view), it is useful to add an API that allows other things like, maybe conversion of the model to Date or maybe some parent Action that gets triggered on a valid date. These are all your choice and depend on how you envision the component being used. And yes, you need to document this for the people who would want to use your component. 
&gt; That is an INSANE amount of code generation. Is there anyway to shrink that down? When I've seen the elm.js size the first time it bothered me too. But there was the promise of dead code elimination and so I gave Elm a real try and then forgot about the size. After writing a larger app in Elm (few hundred lines) I was curious again to see how it behaves and put the app through on of those performance tests (GTMetrix). I've got into the top 10% without doing anything. I even got a grade F for not using the browser cache properly. Also, this way I discovered that if the server has gzip compression enabled, the size of the entire app drops dramatically and will most likely not be an issue. 
By the way, you might find this tutorial helpful: https://www.gitbook.com/book/sporto/elm-tutorial/details It's extremely well written and not yet linked to the official Elm docs.
&gt; so I figured that it would make sense for each to live in its own function. How about destructuring the value in `update` and making `handleClockUpdate` of type `Time -&gt; State -&gt; State`?
That's exactly what I ended up doing =)
Interesting... so what do you call the pattern exemplified by |: ?
I'd call it "map-andMap". There's two functions in a situation like this: map : (a -&gt; b) -&gt; Wrapper a -&gt; Wrapper b andMap : Wrapper (a -&gt; b) -&gt; Wrapper a -&gt; Wrapper b When you would normally write `f x1 x2 ... xn`, but you have arguments that are wrapped by `Wrapper`, and you want a result wrapped by `Wrapper`, then you use something like this: f `map` y1 `andMap` y2 `andMap` ... `andMap` yn. No fancy words, no category theory. Just a nice, easy to reproduce pattern.
Nice! I like that. And wrapper instead of functor. Much easier to intuit.
&gt; Also, is there any reason I might want to use a child's Effect in a parent module? The Effects are a reverse hierarchy where information flows from bottom up. You need to pass this information up otherwise it will not get to the execution port. update action model = case action of Child act -&gt; let (child', fx) = Child.update act model.child in ({ model | child = child' }, Effects.map Child fx) In the code above, calling `Child.update` with `act` is passing downstream the information embedded in an Action. `Effects.map Child fx` is passing upstream the side-effects requested by the child. If you do not pass upstream these side-effects, they will never get executed. So, no Http requests, no Ticks. It would be as if you have returned `Effects.none` from the child. 
I took a look and it looks OK. There are some stylistic code layout choices that are usually frown upon and some method extraction opportunities but other than that it looks OK. I'm curious why haven't you used StartApp? 
Yeah, if you're going back to basics that's important. I was mostly wanting to present this as an alternative to reading a Haskell book and learning about typeclasses and functors and trying to bring that back to Elm. 
The StartApp has an`inputs`field where you can Signal.map whatever inputs you have into a specific Action. Here is a a version of your Main.elm that shows this: https://github.com/pdamoc/SokobanElm/blob/master/Main.elm
[nevermind](http://package.elm-lang.org/packages/evancz/elm-http/3.0.0/Http#Data) I retract all previous statements. looks like they do not currently support blobs in elm-http
It works because of partially applied functions. A function with signature `f : a -&gt; b -&gt; c` is the same as `f : a -&gt; (b -&gt; c)` so by passing in `a` we get a function that takes a `b` and returns a `c`. Using `apply` or `|:` takes a `Decoder (a -&gt; b)` and a `Decoder a` to return `Decoder b` if type `b` happens to be the result of a partially applied function it can be a `Decoder (c -&gt; d)` and therefore can be chained with again. Hope this helps
I was going to write an explanation here, but then I figured it'd be better in the docs for |: themselves, so I opened a PR to elm-json-extra for that. Here's the explanation: https://github.com/circuithub/elm-json-extra/blob/more-docs/src/Json/Decode/Extra.elm#L90 If you have feedback on this, it would be awesome if you could leave it on the PR itself, so we can have them all in one place! https://github.com/circuithub/elm-json-extra/pull/8/files Hope it helps. :)
My main issue is I cannot read the code because I don't know the order of operations you get by chaining together a bunch of infix operators (something I would never do without parentheses normally to make it clear what is happening), and also whether the record type alias "Location" is equivalent to (a -&gt; b).
I try to avoid mixing these operators where possible, it's a lot easier to read when you only use one of them. So I'd do main = 4 |&gt; add 4 |&gt; add5 |&gt; times3 |&gt; show Which should do the same thing and, for me, is much easier to read as a single statement of data flow through a chain of functions.
&gt; or does it do some sort of a diff between the old model and the new Close. Elm always renders the entire UI using `view : Model -&gt; Html`, but then uses a diff between the new `Html` and the current `Html` in order to figure out what DOM updates to make. This is done by a library called `virtual-dom`. You can read more about this approach here: http://elm-lang.org/blog/blazing-fast-html
Excellent, thank you
The cheap equality checks with immutability are part of it as well.
Thanks! My favorite one is [this one](https://lucaschmid.net/elm#7) not sure if you saw, but you can click on the image and it does a neat little animation. :)
I think the easiest thing would be to send it as a string to an outbound port and have JavaScript insert it into the DOM. The proper elm thing to do would be to take the string, parse it, and encode it into elm-html I could be wrong though -- I'm still pretty new to elm. The best answer will come from /u/jediknight 
Very nice! That's good visualization for the process of updating of DOM using diffs :)
I think, there is a couple of possible solutions: 1. you can implement some native component, which will insert HTML without escaping 2. or you can try to play with [virtual-dom](http://package.elm-lang.org/packages/evancz/virtual-dom/2.1.0/VirtualDom) directly.
I'm very interested, but primarily in how it differs from the status quo, i.e. StartApp. Can you elaborate on that?
Actually, the best answer came from you. I can't think of anything more appropriate than parsing the string and converting it a virtualdom node if one wants safety. If safety is not an issue, the easiest way to do it is to send it to JS and have it processed there. Here is [a gist with a demo of the easy way](https://gist.github.com/pdamoc/004bbbfb76f695181f4a). :) Please note that this option might not play nice with the virtual-dom. I have not tested it beyond the simple use case. 
the Elm VirtualDom does not expose the `innerHtml` property and it does not seam to work when it is used with `property "innerHtml"` 
I'll want to write a post about this approach and about a comparison of this two ways. I hope to do this soon
If you aren't concerned about finding actual Markdown in your HTML, you can use `Markdown.toHtml` which defaults to not sanitizing it's output. So, you can pass raw HTML through it.
Here's what I went with (forgot to mention this is an Elixir/Phoenix/Elm app) The API I am using does not seem to have CORS set up correctly, so I have to go to the backend to snag the data. That being the case, I let app.js insert the data. This presents its own set of problems - specifically, there is no connection between the text the API delivers and the Elm model. This one I am still pondering.
I discovered this too - a wound up tasking app.js with cleaning up
My memory was not correct, but here's a SSCCE import Html exposing (..) import Json.Encode import VirtualDom innerHtml : String -&gt; Attribute innerHtml = VirtualDom.property "innerHTML" &lt;&lt; Json.Encode.string main : Html main = div [ innerHtml "&lt;b&gt;try this&lt;/b&gt;" ] [] I've been using this with success.
The problem with using such a middleware for logging is that you can't inspect and reinterpret the final representation the way you can the initial. So you have to add the log message individually to each action, either when it is created or when it is sent. In the initial representation you just define a custom interpreter that steps in between an action being sent and its being run and does whatever logging deemed appropriate, based on inspection of the action. Really this will come up any time you want to handle an action at a different place in the tree than where it was generated. As a toy example, if you had a list of counters where sometimes at random when you press a "+" button, it spawns a new counter. If your counters were written in this final representation, then there is no (good) way to reuse them here. Whereas in the initial representation, if you know enough implementation details of the counter, you can inspect the actions at the top level and look for increments. If someone has a use case for serializing actions, the initial representation would also be more suitable there.
I loved the way Evan firsts writes comments for structure (-- MODEL, -- UPDATE, -- VIEW ) and then moves to writing code. I currently keep the types together (Model and Action) but keeping Action closer to `update` makes more sense. 
Hash certainly will work (with some overhead). Another possible variant - timestamp.
&gt; If not how do i go about writing my own? Three.js has object model similar to html dom, so you could try to use virtual dom approach. Creating the three.js dom from virtual nodes and then patch it with diff.
Thanks, this was incredibly helpful! Your code above came to my aid this week when I was using elm-html-animation for an animated effect in a child component. I hadn't realized until now that effects have to be passed up through the hierarchy to work, but it makes perfect sense now :) 
This is really beautifully written and extremely helpful! By far the best I've read on this subject. There are just a few small things I didn't fully understand or which might need clarifications. Do the -&gt; arrows in this bit of code mean that these record items are functions? type alias Widget entry = { text : entry -&gt; Html , attributes : entry -&gt; Html , getState : entry -&gt; Bool } ... that's really cool, I didn't know that records could contain functions! :) You might want to consider adding a bit more detail to the indexedMap example. I've been using indexedMap a lot lately, so I understand how it works. But a beginner might not understand that it passes an extra first argument (the index) into the function, or understand how that index number is updated with each iteration, or understand how that number is used to produce the zebra striping. This is an amazingly useful skill to have in Elm that many beginners will find extremely helpful. (As a beginner, I've also fount the List.Extra's getAt method indispensable for referencing list values at specific index positions. It's so useful it should maybe be part of the core library.) Thanks again, I can't wait to read more!
I also love this style of commenting as it so clearly identifies the structure of the app. I've also been keeping my Actions as part of the Update, as I noticed Even doing this in earlier videos. I've realized that by implementing Evan's structure and commenting style, and keeping the structure of all my modules exactly the same, that I can clearly read even fairly complex modules at a glance without needing much additional documentation. I have one question for more experienced Elm users. Where is the best place to put a module's little helper functions? The kind of little conversion or convenience functions that might be used by all three sections, but don't need to part of the model's data. At the moment I'm listing them under the `init` function in the MODEL section.
There's an elm WebGL library that may provide you with enough abstraction.
1. Convert the task to a Result (Task.toResult) 2. Map the Result to a success Action if Ok, or a failure Action if Err 3. Do whatever you want with the failure Action (update the model, generate another Effect, or both) Here's an example: ActEnter -&gt; (model, makeRequest model) makeRequest model = Http.getString model.input |&gt; Task.toResult |&gt; Task.map resultToAction |&gt; Effects.task resultToAction result = case result of Ok data -&gt; ActReceived data Err error -&gt; HandleError error 
This thread contains instructions on how to test dependencies without publishing them. https://groups.google.com/forum/#!topic/elm-dev/nBKcxYZ5qGg You'll want to use the source-directories field of elm-package.json. However, you can't currently publish packages with Native code right now as far as I know. This is apparently going to be addressed with a new method of javascript FFI in the 0.17 release which I believe will be coming in the next 1-2 months.
Don't think you needed to respond this way. Quite an overreaction to an innocent post.
awesome! going to bookmark this - elm will make chrome plugins way more fun
Very interesting! I have a slightly unrelated question though; how did you get the pretty arrow and pipe symbols in the code in the Lighttable screenshot?
As someone else commented on your attitude, I'd like to apologize for making you feel this way but also remind you that my question is about Elm, not you. I've never myself participated in Elm conversations, so I wasn't aware of the etiquette you expect from us fans.
Yes I can do that. Thanks.
So I was able to fix it, and I've updated the code in GitHub. I noticed my URL was broken, among some of my type annotations being incorrect which I've sorted out in multiple commits since posting this. It seems to work properly now, except that it doesn't seem to make http.get requests when pressing the button anymore. If you have a chance to check out the most recent commit code, let me know if you can see why. If not I'll post any results in here later.
Also from the book [Programming Languages: Application and Interpretation](https://cs.brown.edu/~sk/Publications/Books/ProgLangs/2007-04-26/) there is a section that talks about [Reactive Application](http://cs.brown.edu/courses/cs173/2012/book/Alternate_Application_Semantics.html).
I really like this series, thank you for making it! Will there be any more updates? I'd love if you would add some kind of simple token auth or something. I've tried modifying it to restrict access to certain pages (redirect back to another page with no token) but I'm getting stuck on this.
[Chaining tasks](http://package.elm-lang.org/packages/elm-lang/core/3.0.0/Task#chaining) can be done with andThen : Task x a -&gt; (a -&gt; Task x b) -&gt; Task x b or sequence : List (Task x a) -&gt; Task x (List a) Your code will look something like this: (model, Effects.task &lt;| Task.succeed FirstAction `Task.andThen` \_ -&gt; Task.succeed SecondAction) There is a [good write-up](http://elm-lang.org/guide/reactivity#tasks) with further explanation provided on elm's website.
Features could include syntax highlighting, intellisense (with function documentation), a simple installer, source map support, Elm interactive window, debugging starts the reactor and error highlighting.
If these are things that need to update the model, why are they tasks and not `Action`s? Can you give more detail of what you're trying to accomplish? 
Elm before Haskell? That seems a bit odd. Though I guess VS does have an emphasis on html coding lately. 
If I'm understanding you correctly, I don't understand why these are `Task`s at all. You just need to chain a couple of functions that update your model, right? let (model', fx1) = UpdateInfoBox (...) (model'', fx2) = UpdateInfoBox (... model' ...) in (model'', Effects.batch [ Effects.map InfoBoxAction fx1 , Effects.map InfoBoxAction fx2 ] ) Also, if you don't need any Effects in those updates, it becomes a lot cleaner if you can change the signature of that UpdateInfoBox function -- suppose that -- updateBox : InfoBoxAction -&gt; Model -&gt; Model let model' = model |&gt; updateBox InfoBox.Updateinventory invQuantities |&gt; updateBox InfoBox.UpdateMeter storyLevel in (model', Effects.none) 
Elm's a lot smaller, so implementing the plug in will be a lot easier of a project. 
I spent a boatload of time reconfiguring my model for unrelated reasons and then tried rhitakorrr solution of using Markdown.toHtml and it worked perfectly! 
Worked perfectly! Thank you!
Thank you, Sir, that's very helpful! When I first started learning Elm a few months ago, I didn't know anything about functional programming and was having a hard time reading programs. With more imperative styles of programming, you can read a program from top to bottom, and follow the narrative through, much like a story. But with a bit more experience, it suddenly clicked: In functional programs you read from the general to the specific. You create little building blocks with your specific functions, and stack them together with your general functions. Now I find it really easy to read my Elm programs: Just dig down from the general to specific and it's easy :) I also love the consistent structure of StartApp modules because you can dig down in this same fractal-like way and don't have to re-learn each module's own internal logic to understand how it works. 
Elm for Atom is reasonable with syntax highlighting, intellesense and linting available. Although VS has free editions I feel Atom is more of an open choice, so would be a better platform to improve. I say that as someone who has used VS for 13 years.
I also tried double model approach but wasn't satisfied with the code I had. Essentially I ended up with one model inlined into another, so it gave around 2X multiplier for amount of code. It probably could be lower for less trivial model and view logic (I was experimenting with a fancy TODO :) ).
I had success doing this by using virtualdom widgets (which is actually what Markdown uses inside).
I have thought about this, I think it is doable to have a really powerful typesafe grid in elm. But I have never had the time to build it 
Cool. Thanks! I may be too new to understand all this but I will run it and see what it does.
Did you find any interesting examples in your research? For example, are there any data grids implemented for one of the haskell web frameworks? You should see /u/EffBott code below. It looks like a good start. https://www.reddit.com/r/elm/comments/4bcyrz/data_grid/d18dt1c
If I had to write a native app, I would LOVE to write it in elm, but that said I think native is evil and inferior to the web (with the exception of games)
You are using elm at work?
It isn't slow for me. (Old Lenovo laptop)
Nowhere near complete, but I started working on something like this during a meetup. Haven't had time to finish it but it might be useful as a starting point along with some of the other comments here. https://github.com/twitchard/elm-spreadsheet 
It was a one page application. I had two model records, one for view model like type ItemView = {id, name, completed, viewEditing} and one for ideal model type Item = {id, name, completed} Functions synchronize them: from : ItemView -&gt; Item patch : ItemView -&gt; Item -&gt; ItemView Update looked roughly like this: update : ItemView -&gt; Action -&gt; ItemView update iv a = case a of ModelAction(ma) -&gt; patch iv (updateModel (from iv) a) ViewAction(va) -&gt; handle view state Where updateModel was a pure model function, that didn't deal with view state. Of cause this scheme didn't play well with hierarchies. So the root update function was really ugly. 
You probably don't need to have the internal value on the JavaScript side - just have something like "lastID" inside your model?
I am still working on my first elm application (single page web app) too so I am not really experienced myself. So far separating the model, view and update into three files, like [elm-hedley](https://github.com/Gizra/elm-hedley) does, the update module containing the definition of the Action type, worked pretty well. My gut feeling says there has to be some code which knows of both, the labels the view attaches to addresses and the labels the update function knows about even if you use one of the methods you came up with. Probably there is clever solution but I don't really get what is wrong with referencing the action type defined in the update module in the view module. Sometimes I had circular dependencies but it was always with utility functions I added. I either moved those to a separate utility module or to the model module. The model module always only has dependencies to other model modules.
If I write the program `main = Signal.map show (Time.fps 1)` then `show` is a function from `Time` to `Element`. I can change `Time.fps 1` to get different granularity. If `show` was a more complicated animation function, I could use similar technique to speed up and slow the animation down. So I can write `show` to be a function from `Time -&gt; Element` as if time was continuous. This is why I am confused.
I'm afraid I'm still too much of a noob to really understand the distinction. In the same way that the Architecture tutorial does, I'm defining a type alias (record) in my submodule; instantiating that in the main module, using `Signal.forwardTo` to proxy the actions to the main module and then feeding it back to the submodule's view function. https://gist.github.com/ethagnawl/a09b8c9abc58495e1fc2
Note that none of this will compile and (especially the second) contain major mistakes (e.g. I just noticed that the Maybe in buttonModel isn't handled at all) I changed your gist to put everything into one (logical) module / level. No additional address needed. https://gist.github.com/akhener/153f38ff6572def168ef2198b4ffa8c0 Then I moved the button to it's own child module and discussed how to forward actions and (this is completely separate from the ChildActionButton/forwarding) communicating "up" that the button should be removed. For this "upwards" communication a additional address is needed The order is wrong. I suggest: main.elm, model.elm, update.elm, view.elm, button_model.elm, button_update.elm, button_view.elm https://gist.github.com/akhener/15f39cd8b9214a3e715e2f42eea985b2 
Whoah - you've really outdone yourself here. I'm looking forward to going through this tonight. Thanks for taking the time to put this together! :D
Your "ramblings" are great. My confusion is due to my being distracted by unfamiliar syntax and constructs, e.g. `always`. I also should have downloaded the zip and used Vim splits, as I normally would when acquainting myself with a program, instead of trying to read through the Gist. These resources look helpful, I will have a look through them this weekend. Thanks, again, for your help!
Could you give us an explanation of what we're looking at? 
I wrote this article out of wondering how to organize code that follows the Elm architecture. I wanted to divide the code for parts of a page (call them components, sections, blocks, etc., I'll call them features from here on out) into their own directories. I wanted each feature to be independent of the others, but find a way for them to communicate information with each other. Finally, I wanted to see if I could group some of these features together to assemble larger features, while still keeping the same pattern of inter-feature communication.
GitHub does not display the README on mobile when you link to a subfolder. Confused me as well.
I need the mailbox in order to send a message out to JS (using the aforementioned port) after a particular update happens. Creating a Dispatch/Utility module which wraps this up (as you've suggested) is probably the cleanest option. I actually hit upon that myself by way of [this tutorial](https://github.com/foxdonut/adventures-reactive-web-dev) last night. My hack was to bake the function which communicates with the port into my top-level update. portRequestNewGameObject = mailbox Model.initialGameObject port requestNewGameObject = portRequestNewGameObject.signal update = Action.update portRequestNewGameObject app = StartApp.start { update = update -- ... } I was concerned that creating the separate module just to wrap-up this mailbox was too heavy-handed, but I think you've swayed me. Thanks, again, for your feedback. :]
That article was incredibly helpful! I need to give the elm architecture another look as I now have a bit more experience/familiarity with the language -- it was pretty difficult to wrap my head around the first time. 
This looks great! For anyone who's looking for a way to do this through ports, it's actually pretty easy. Here's an example: https://github.com/fbonetti/great_lakes_data/blob/c89f61a974df15d93ee72ace93542d60fb54af67/app/assets/javascripts/readings.js Basically it subscribes to a signal of series and redraws the graph every time new data comes through.
Yes, definitely use StartApp and the Elm Architecture! It makes writing Elm programs extremely easy because it does all the tricky signal/mailbox wiring for you so that you never have to do any of that yourself.
Mailboxes require a default/initial value. By wrapping actions in a Maybe you can give Nothing as the default value. If you would remove the Maybe, then it would be required to supply a default value of the correct type to the start function. This way you don't need to implement a NoOp action and it reduces the amount of parameters needed.
Thanks for the reply and for putting this alternative example together - it was enlightening.
This is helpful, thanks!
This is a frequent issue and I suspect that the next version of Effects will get rid of it. Basically if your side-effect does not need to communicate back (you are not interested in the reply), you need to create some kind of bogus Action like `NoOp` that would do nothing but would provide a way of return from the one way messages. The way you do that is like this: submission : String -&gt; Effects Action submission email' = Signal.send email.address email' |&gt; Task.map (always NoOp) |&gt; Effects.task I read the above code like this: `send` does the sending and returns (), this is mapped to (always NoOp) which will always produce the NoOp action, and then, the resulting task is sent to Effects.task. However, you already have an action that can be reused: `RefreshField` so you can use that instead of adding an extra tag. submission : String -&gt; Effects Action submission email' = Signal.send email.address email' |&gt; Task.map (always (RefreshField "Thanks!")) |&gt; Effects.task 
Thank you so much! Yeah I had seen 'NoOp' in projects I studied. I had no idea thats what it was used for. Really, this clarifies quite a lot for me.
meh, pretty sure ive watched or skimmed all if these and none of them really go into depth of the language, more just "look at what elm can do". would be nice to have some vids on elm that actually go into practical usage instead of a list of counters or whatever
from http://elm-lang.org/docs/syntax here are four things that are equivalent: [1..4] [1,2,3,4] 1 :: [2,3,4] 1 :: 2 :: 3 :: 4 :: [] 
Looks very cool, unfortunately it isn't working for me on linux :(
Indeed! It uses a pattern I hadn't seen so far: computing model updates and effects in two separate functions. I guess in many cases it makes sense but I'm wondering whether it doesn't lead to duplication on the action matching logic sometimes.
Yup! The whole wack-a-mole game simply evaporated. Luckily with the kinds of games we build we don't have a monolithic infrastructure that we need to comply with, so we can use any new technologies we like, as long as they compile to JS/HTML5.
I made something like this, works great. It worked pretty much just like the elm architecture examples, but I needed a 2D array data type, so I made one: https://github.com/tortus/elm-array-2d I think there is work that could be done on the 2D array, but it worked great for me and the app has worked successfully for many months now. I couldn't possibly generalize the rest of the grid as a component though, the code was entirely unique to the problem domain. My big worry is there may be edge cases in which it is possible for a cell's row and column to change before an Effect (such as an XHR request to reload the cell's data) can be forwarded back to it. I think cells should probably be referenced by unique identifiers that never change to avoid this.
In a 1D list of components I made recently, I assigned every component a permanent number based on its position the list, like the Elm architecture example. One could also use the record's database ID, or a more complicated data structure. As I mentioned, I now believe indexedMap is not correct (although I see it used from time to time), because the index may change before an effect makes a round trip back to the component that caused it. I really dislike the inefficiency of mapping over the whole list and batching hundreds of Effects.none to change a single element though.
Thanks! those are for sure better names :)
If you **do** need effects in those updates, I wrote a :&gt; operator that you can use instead of the pipe which takes account of effects - [http://package.elm-lang.org/packages/ccapndave/elm-effects-extra/1.0.2/](http://package.elm-lang.org/packages/ccapndave/elm-effects-extra/1.0.2/)
My goal wasn't to go in-depth. It was to get a high level understanding before I began working with the language first hand.
Make it so!
To the author: Have you tried parsing json with Elm yet? It's a mess. You utilize Signals and Decoders (why?) and you get access to object[1-9] method to parse fields. That just seems incredibly silly. 
You don't need `Signal`s for parsing. I'm not sure why you object to `Decoder`s; you need a parser to parse. For objects, [circuithub/elm-json-extra](http://package.elm-lang.org/packages/circuithub/elm-json-extra/2.2.1/) has some helpful functions like `apply` and `(|:)` to make it a little smoother.
Exactly. Example taken out of elm-json-extra: locationDecoder : Decoder Location locationDecoder = succeed Location |: ("id" := int) |: ("name" := string) |: ("address" := string) |: ("city" := string) |: ("state" := string) 
Can you go into more detail about where the docs are insufficient? We'd love to improve them. 
&gt; Can you go into more detail about where the docs are insufficient? Sure, here are a few things off the top of my head. There is zero mention of constructor functions on the Elm site and there is almost zero info about creating new types in the docs that aren't unions. I think there was one reference but I can't find it now, and it's not even in the [syntax reference](http://elm-lang.org/docs/syntax)! I found [this doc on recursive type definitions](https://github.com/elm-lang/elm-compiler/blob/master/hints/recursive-alias.md) and it got me further, but I knew I didn't understand something when I got to "type Comment = Comment { ... }". Why is the second "Comment" there? I know now from learning about Haskell that when you define a new type, that definition includes the name of the constructor function, and it doesn't even need to have the same name. My Haskell book uses "data People = Person ..." which made it clearer what was going on. But, back to that document. There's a discussion of "unwrapping" that isn't explained anywhere. All of this syntax is just assumed and isn't explained anywhere. I'd like an explanation of how the event routing works somewhere. When going through the [architecture tutorial](https://github.com/evancz/elm-architecture-tutorial/) it starts talking about addresses that get sent to event handlers ("Every event handler in our view function reports to a particular address.") but doesn't explain what they are. I spent a little time trying to print them out in HTML to see what they actually look like :) Ultimately I came to terms with "it's just an opaque bit of wiring that needs to be passed around" and if I want to see how it really works I can read the generated JavaScript. There's inconsistencies in execution environment between the repl, the reactor, and what you can run with elm make. The repl doesn't allow type definitions, the reactor doesn't handle ports or something -- I got [this error](https://github.com/evancz/elm-todomvc/issues/8#issuecomment-158412705) when trying to run Todomvc in it, but the code worked when I ran it with elm make. All of this is very beginner hostile to run into these inconsistencies and not know whether it's because you made a mistake. Back to [recursive aliases](https://github.com/elm-lang/elm-compiler/blob/master/hints/recursive-alias.md): it shows how to define a Comment structure that takes a nested list of Responses, but never shows how to actually create one of those, or "modify" any data structure that's nested. I still can't figure out how to add a new "Response" once I've created the structure. You can't use ++ on it to add to Responses because it's a new type, even though it's just a List underneath. A couple other beginner things: the examples all show use of the Html module, but I don't remember if it even says anywhere that to use this you need to first 'elm package install evancz/elm-html'. Also, it's clear from examples what types of things are supposed to be capitalized, but this isn't explained anywhere. It's another thing that's clear if you know Haskell but is just assumed in Elm. Ok that's it for now! Thanks for listening.
It also shows what function returns. update : Action -&gt; Model -&gt; Model We can also write this like: update : Action -&gt; (Model -&gt; Model) What this means is that when we give `update` an `Action`, it returns `Model -&gt; Model`, a new function that accepts a `Model` and returns another `Model`.
When you see something like this: node : String -&gt; List Attribute -&gt; List Html -&gt; Html It can be helpful for beginners to think of it like this: node : (String, List Attribute, List Html) -&gt; Html Thinking that "everything is an argument until the last thing" is a fine mental model when you are just starting out. That said, I am working on some docs that explain exactly what's going on here in more depth! Tons of folks run into this, so I am trying to balance improving the language and improving the language and a bunch of other stuff. Point is, I take these kinds of things very seriously and improvements are on the way! About learning Haskell, it will help in the same way that learning Java will help you learn JavaScript. Lots of concepts overlap. Lots of concepts do not. Things are pretty similar overall though, so it won't hurt you. It will probably be a harder route though! **I'd say the best thing to do is talk with other folks on [the Elm slack channel](http://elmlang.herokuapp.com/).** A lot of these things are not too crazy, and talking it through with someone can make it from a week long struggle into a 5 minute question. Just know that folks on slack are super friendly and welcome all sorts of questions! The community is a great resource! :)
I'm also new to elm, but I think the multiple `-&gt;` syntax relates to "currying", which is a way of thinking about functions. The idea is that a function that takes several arguments like `foo(a,b,c) -&gt; r` could be thought of as a function that takes exactly one argument, but returns a function that takes the other two to complete the behavior, like `foo(a) -&gt; foo'(b,c) -&gt; r`, but then do the same for the returned function `foo(a) -&gt; foo'(b) -&gt; foo''(c) -&gt; r` until it's a chain of functions that all take exactly one argument. I've tried to use JS-like syntax for this example, but hopefully you can see how this might be something like `foo : a -&gt; b -&gt; c -&gt; r`. A cool thing about this is that it isn't just a weird mathstrubatory notation; in languages that support currying you can actually pass fewer arguments to get back a function that sort of has the first ones "locked in". For example, if `foo: a -&gt; b -&gt; c -&gt; r`, then `foo2 = foo 2` makes `foo2` a functions with the signature `foo2: b -&gt; c -&gt; r` that behaves the same as the original `foo` with `2` locked in as the first argument. I find this handy for reshaping interfaces* to make your life easier. Anyway, I'm also new to elm, so I don't know if it really is currying, or if it's just using that style for notation. --- ^(* "interface" in the sense of the signature of how you're supposed to call some library function or something, like when every call has the same first three arguments you have to keep carrying around.) 
Could have done without the click baity title and opening.
I love these kind of videos by Feldman. My other go to video about Elm is [**Make the Back-End Team Jealous: Elm in Production by Richard Feldman**](https://www.youtube.com/watch?v=FV0DXNB94NE)
Yeah, I'm still working out larger scale software architecture in Elm. Need to reread [Composing Features and Behaviours in the Elm Architecture](https://github.com/foxdonut/adventures-reactive-web-dev/tree/master/client-elm#composing-features-and-behaviours-in-the-elm-architecture). I'm also still deciding between ADTs and records for my app model. I've used ADTs extensively in other languages, because records were sort of the red-headed-step-child construct, but it seems like the model pattern in Elm seems to use records extensively. It would be nice if there were examples comparing the pros and cons of both.
Awesome, Haskell's `lens` in Elm, just what I was looking for! It looks like Evan also comments on what I'm grappling with re. larger architectures and possible harmful patterns as /u/wheatBread pointed out.
(Ps wheat bread and Evan are the same person)
I would not consider that repo you linked "standard" advice. I would try to learn the baseline of The Elm Architecture before looking into what people on the internet have to say about it.
At the very least, it gives something much nicer than the clunky record update syntax.
Cool! Is it open source? If so, I'd love to check it out.
Closed source - I wish I could share but I can't :( Elm was a marvellous choice for the project. 
You could do a straight port of [quantities](http://hackage.haskell.org/package/quantities), but that doesn't use the type system to record units. I'm pretty sure Elm is designed to prevent using the type system in this way, though.
Hey, Richard's compiler produces nice much error messages than mine! Is there anyway to upgrade to these better messages (I'm on 0.16)? 
Interesting, that strategy may be suited to Elm since it wouldn't require making general changes to the type system. OTOH, hard coding in a special type system feels sort of wrong to me.
Some other languages have features that are similar, but weaker and uglier (and are maybe meant for a different purpose anyway). For example Haxe lets you define a type that exists only at compile time as an [abstraction over a runtime type](http://haxe.org/manual/types-abstract.html). The problem with using that for things like units and conversions is it's not generalized, you end up writing [a _lot_ of boilerplate code](https://github.com/fponticelli/thx.unit), and you don't get to write "meters per second" as just m/s
This is the first thing I thought of. :)
I hacked out a type-safe dimensional number module and stuck it in a [gist](https://gist.github.com/altaic/b56e58eba0764aebd7f84c1287022a8f). It has a number of shortcomings, as is noted in the TODO comment at the top: * It doesn't use an arbitrary precision representation yet, so it underflows and overflows all over the place. Shouldn't be too hard to fix. * Only length and time units are currently supported. This was sort of a proof of concept, so I expect many more units to be added. It's not hard, but it's a little time consuming. * It should be split into separate modules, which is easy. * It needs arithmetical operations. I've got an AST and rewriter commented out that should do the trick when the glue code is written. It needs to be reworked, but that should be really easy. * Boilerplate. Without changes to Elm, that's unlikely to change much, though I'm sure there are tricks to use and improvements to be made. * It does not currently address the JS/CSS quantities that rely on various coordinate systems. This is hard for me because I am not a JS person-- part of the reason I'm learning Elm is because I loath JS. Different strokes for different folks, I guess. * It's verbose. The best way I've come up with is to have a function that parses, generates an AST, rewrites it, etc. This is the approach the Haskell lib `quantities` takes that /u/eruonna suggested. It's a bit more involved, but it's not rocket science. Anyway, using the module is pretty easy. If you remove the module declaration, you can paste it into [Try Elm](http://elm-lang.org/try) and at the top write something like: import Html exposing (span, text) import Html.Attributes exposing (class) -- 1000 cu mm == 1 cu cm example1 = toString &lt;| toPrecision 5 10 &lt;| canonicalize &lt;| normalize &lt;| LengthQuantity 1000 L_mm 3 -- 10 ms^-1 == 10 kHz example2 = toString &lt;| toPrecision 5 10 &lt;| convertTime F_kHz &lt;| TimeQuantity 10 T_ms -1 main = span [class "welcome-message"] [text example1] Oh, and I've verified the results against [WolframAlpha](https://www.wolframalpha.com), so (to my knowledge) there aren't any calculation sorts of bugs. Anywho, comments welcome. Enjoy. 
The answer that usually comes up for this is to use foldp' from the Signal.Extra package. http://package.elm-lang.org/packages/Apanatshka/elm-signal-extra/5.7.0/Signal-Extra#foldp' The init to foldp' is a function that maps the initial values of your signal to the initial value for the model. 
There's a fork for that, of start-app. Pull request is [here](https://github.com/evancz/start-app/pull/37). 
What if I wanted to reuse code for multiple features? I'm not sure how well that pan out with feature discrete directories. Also, would it not be better to have one file per external API rather than having to rewrite alot of code just to use an API in each Rest file?
This is some code organisation I do a lot. Here the biggest advantage is that your composant are composable. Of course, if Widget1 and Widget2 share a big part of code (typically lots of intelligence to cache and merge some HTTP calls), you add another directory containing all common libraries. And each Widget will depend on these libraries. And you could organize each library at will, so if many widgets uses the same API over and over again, just make a library to merge all common code. This kind of code organisation is something I do really often. In general, it is really good as a starting code organisation. If you find yourself duplicate code too often, then you make some library to factorise your code. I find this kind of organisation make it really easy to scale even when your application start to become very complex. It really minimize the surprise effect after some time. Finally: **"Yeah! Monoids!"**
Nice write up, great to see these kind of articles
I also just stumbled across the [elm-monocle](https://github.com/arturopala/elm-monocle/tree/1.2.0) package, inspired by Scala's Monocle library, inspired by Haskell's Lens library. There's also [elm-access](https://github.com/sgraf812/elm-access/tree/1.0.0), but it doesn't appear to be maintained. Figured I'd note them down here in case someone else is looking for something like that and comes across this thread.
Neat concept!
Curious. I played with it for a couple of minutes. Interesting.
We're doing one file per component, forcing components to be smaller. Am I missing out on some goodies?
Brilliant twist - nice!
 var container = document.getElementById("todoForm"); container.innerHTML = "&lt;div class='row'&gt;" +.... Wouldn't attaching html to this element be rather brittle; for example if there was a toggle which hid the todoForm by not rendering it, the element would be ripped out of the DOM and the HTML not put back when it was unhidden. Do you have any recommendation on dealing with that kind of thing? I feel like one may need/benefit from native code that can be used as an attribtue on an Elm Element, and attaches to some VirtualDom hook and sends a boolean to some Signal.Address when the element is created/destroyed
lol
Not even made in ELM.... (unless there's a ELM static site generator)
https://github.com/knewter/todo Sorry it took me a bit, I don't notice orangereds as quickly as i should
1. Elm doesn't have true typeclasses, but it has some built-in pseudo-typeclasses like `comparable` and `number`. The type for a `Dict` must be `Dict comparable v` (in other words, the key must be `comparable`). Records are not `comparable`, so they can't be used as keys. Only ints, floats, chars, strings, lists, and tuples are comparable.
I'm not super familiar with why this decision was made, but my best guess is that it's impossible to properly define the `(&gt;)` and `(&lt;)` functions for all records. If you evaluated the following, what would you expect it to return? { x = 1, y = 1 } &gt; { x = 2, y = 2 } If Elm had typeclasses, you could simply define your record as an instance of `comparable` and write the implementation for those functions, but unfortunately that's not the case. There have been some past discussions on how to fix this issue: **User-defined data types (and records) not comparable** #774 https://github.com/elm-lang/elm-compiler/issues/774 **"more flexibility for comparable types"** #1008 https://github.com/elm-lang/elm-compiler/issues/1008
I have a feeling you know what a WSO is
Put my code examples in a comment because the markdown isn't rendering properly in the post for some reason. #1 main = show "v" Signal.map show (Time.every Time.second) #2 (in C) int main() { show("v"); Signal.map(show(Time.every, Time.second)); }
What you are asking for doesn't work because the body of an Elm function is a single expression whose value is the return value of the function. But this is not the way you make effects happen in Elm anyway. The return type of `show` is `Graphics.Element.Element`, a representation of a graphical element that can be rendered to the screen. Calling `show` does not actually cause anything to be rendered, it just returns a value that can be rendered. To actually render it, you must return it from `main`. The type of `main` is restricted, but `Element` is one of the allowed types, so you can do this just by writing main = show "v" That will do what you expect: put the string '"v"' on the screen. Now suppose you want to render two things to the screen. For simplicity, let's say you want both `show "v"` and `show 7`. Somehow, you have to return both of these from `main`, but `main` has only one value. So how do you do it? In this case, you must in some way combine the two `Element`s into one. Fortunately, the `Graphics.Element` library provides some functions to do just that. For example, `above : Element -&gt; Element -&gt; Element`. Per the documentation, `above a b` is an `Element` that consists of the `Element` `a` stacked vertically above the `Element` `b`. So you could do main = above (show "v") (show 7) To get something that looks like "v" 7 On the other hand, you might not want to display two things together, you might want to display something that changes over time. Of course, Elm's raison d'etre is values that change over time. These are `Signal`s, and another possible type for `main` is `Signal Element`. So if you want to display something changing over time, create a `Signal` of the `Element`s you want and return that from `main`. Here you will likely want to use functions from the `Signal` library to help in building the `Signal`. You've already seen this, of course, since you wrote Signal.map show (Time.every Time.second) This takes every value that comes out of the `Signal` `(Time.every Time.second)` and applies the function `show` to it, creating a new `Signal` from the results. The result type of `show` is `Element`, so the result type of `Signal.map show` is `Signal Element`. So you could directly return this from `main`: main = Signal.map show (Time.every Time.second) This would show the current time, updating every second. Now the next question would be "how do we put together elements that vary in time and those that don't?" For your example, we would need a function with a type like `Element -&gt; Signal Element -&gt; Signal Element`. Unfortunately such a function doesn't exist in the standard library. But all the parts needed to build one do. These are the functions `Signal.map`, `Signal.map2`, (and `Signal.map3`, etc), and `Signal.constant`. You already know about `Signal.map`. `Signal.map2` is similar, but it applies a function with two arguments to two signals and produces a signal of the results. So you could combine two `Signal Element`s using `above`: Signal.map2 above (Signal.map show (Time.every Time.second)) (Signal.map show Mouse.position) That shows the current time on top, and the mouse coordinates below. (Note that we still need `Signal.map show` to turn these into `Element`s.) The function `Signal.constant` turns a value into a `Signal` whose value is constant. That is, `Signal.constant 12` is a `Signal` which always has the value `12`. Use this to turn the unchanging `Element`s into `Signal Element`s, and combine them with the other `Signal`s as above: main = Signal.map2 above (Signal.constant (show "v")) (Signal.map show (Time.every Time.second)) This will have the result I think you were looking for in your example. However, I would be remiss if I failed to point out that this is not the most idiomatic way of doing it. Especially if you are using the Elm architecture (and you probably should, unless you are sure of what you are doing), you would write a `view` function that is applied to varying data with `Signal.map` (or `map2` etc) to produce the `Element` you will display. You can pass in nonvarying parts to `view` before using `Signal.map`. It is easier to give an example than explain: view : String -&gt; Time -&gt; Element view str time = above (show str) (show time) main = Signal.map (view "v") (Time.every Time.second) Notice that the function we pass into `Signal.map` is not `view`, but `view "v"`. Because we pass this parameter as a simple value (not a `Signal`) before applying `Signal.map`, its value never changes. The changing value is `Time.every Time.second`, which is a `Signal` and which we do map over. The type system will prevent you from doing it any other way (you can't write either `view "v" (Time.every Time.second)` or `Signal.map2 view "v" (Time.every Time.second)`), and if you give `view` a type signature as I did, you will be able to see exactly where you went wrong.
I've hit upon a solution to this problem, though I have to admit that I don't fully understand how/why it works in the context of `StartApp`. Task.sleep 10000 `Task.andThen` (\_ -&gt; Task.succeed RoundOver) |&gt; Effects.task
Wow; just getting into Elm and I would like to think I could have come up with this in enough time, but this is an excellent and truly valuable exposition. 
Thanks, I had been using elm-reactor the whole time. I just realize that compiling the elm code would not spit that error. Now, using ports will have to recompile the projects every time, I loose the convenience of the elm-reactor though. 
Yes: http://package.elm-lang.org/packages/evancz/elm-http/3.0.0/Http#getString
Regarding your first question, these video tutorials seem quite good: https://www.dailydrip.com/topics/elm Another good tutorial is: https://www.gitbook.com/book/sporto/elm-tutorial/details And you might also find this useful: https://github.com/elm-guides/elm-for-js And this excellent introductory video: https://www.youtube.com/watch?v=3_M2G9U51GA
Thank you for the feedback. I'm guessing the decoration you've described is handled by [this](https://github.com/evancz/start-app/blob/master/src/StartApp.elm#L97) call to `Effects.batch` in StartApp?
Most Elm programs use a Virtual Dom, which means you'll see nothing without JS. Elm is meant for Web apps. You can use it for Web pages, but at its core, Elm is a full programming language,, and needs to compile to a full language like JS. If you're just generating static pages, maybe Hakyll or Jekyll is more what you want? 
From what I've seen with one of my starter projects, it'll compile the Elm source code to JS and bundle it with the necessary Elm core code in a &lt;script&gt; tag within the &lt;head&gt;. The only content inside of &lt;body&gt; is: &lt;script type="text/javascript"&gt;Elm.fullscreen(Elm.Module)&lt;/script&gt; 
Oh, I'm not trying to generate static pages, I'm just trying to wrap my head around Elm and figure out what it's actually outputting there. Thanks for the explanation!
Fair enough! Basically, I'd assume that any HTML it outputs is just a skeleton, the real application will all be in JS. 
That's what I figured. Thanks, again!
My understanding so far is that Elm will generate JavaScript wrapped in HTML, but that's only useful when you are testing stuff with the reactor. Eventually, you'll want to have elm spit out only a bundle .js file that you'll then include with your HTML. 
I'm concerned about SVG being slow but I'll give it a try. Currently I'm using Canvas and changing the colors of the hexagons at 15 fps no problem. Since posting this question I discovered this: http://psousa.net/demos/maps-and-boardgames-part-3/plain2.html which is very efficient and does exactly what I want. So questionnow is how to do this with elm.
**Elm compiles to javascript**. When you use `elm-reactor` (or `elm-make` without any options) it generates a skeleton for you, consisting of some basic HTML and CSS, with a script tag containing your Elm code compiled to javascript. This is convenient but you will probably never use the HTML skeleton in a serious app. The Elm compiler gives you two ways to compile your code: 1. `elm make Main.elm --output index.html` - outputs to `index.html`, and contains a basic HTML skeleton and your compiled elm code. 2. `elm make Main.elm --output elm.js` - outputs to `elm.js`, and only contains your compiled elm code.
Welp :p
You can map the mouse position within the canvas to the location of the grid.
Here's one way to do what you want ( or something similar ) using SVG: import Html as H import String exposing (join) import Html.Attributes as HA import Svg import List.Extra as LE exposing (andThen) import Signal import Svg.Events exposing (onClick, onMouseOver) import Svg.Attributes exposing (version, viewBox, width, height, fill, stroke, strokeWidth, style, points, transform) w = 1000 h = 600 rowCount = 20 colCount = 30 type alias Cell = (Int, Int) type alias Model = { rows : Int , cols : Int , selected : Maybe Cell , visited : Maybe Cell } init rc cc = { rows=rc , cols=cc , selected = Nothing , visited = Nothing } center = HA.style [ ( "text-align", "center") ] view address model = let radius = 0.5 halfRadius = radius / 2.0 halfWidth = radius * sqrt(3.0) / 2.0 radiusStr = toString radius halfRadiusStr = toString halfRadius halfWidthStr = toString halfWidth shift row = if row % 2 == 0 then 0 else 0.5 showCell row col = Svg.polygon [ points &lt;| " 0," ++ radiusStr ++ " " ++ halfWidthStr ++ "," ++ halfRadiusStr ++ " " ++ halfWidthStr ++ ",-" ++ halfRadiusStr ++ " 0,-" ++ radiusStr ++ " -" ++ halfWidthStr ++ ",-" ++ halfRadiusStr ++ " -" ++ halfWidthStr ++ "," ++ halfRadiusStr , transform &lt;| "translate(" ++ toString (toFloat col + shift row) ++ " " ++ toString row ++ ")" , fill &lt;| let jrc = Just (row, col) in if jrc == model.selected then "red" else if jrc == model.visited then "blue" else "grey" , stroke &lt;| "black" , strokeWidth &lt;| "0.07" , onClick &lt;| Signal.message address &lt;| SetSelected (row, col) , onMouseOver &lt;| Signal.message address &lt;| SetVisited (row, col) ] [] cells model = [0..model.rows-1] `LE.andThen` \r -&gt; [0..model.cols-1] `LE.andThen` \c -&gt; [showCell r c] in H.div [] [ H.h2 [center] [H.text &lt;| toString model.selected] , H.h2 [center] [H.text &lt;| toString model.visited] , H.div [center] [ Svg.svg [ version "1.1" , width (toString w) , height (toString h) , viewBox (join " " [ -1.0 |&gt; toString , -1.0 |&gt; toString , toFloat model.cols + 1.0 |&gt; toString , toFloat model.rows + 1.0 |&gt; toString ]) ] [ Svg.g [] &lt;| cells model ] ] ] update action model = case action of SetSelected cell -&gt; {model | selected = Just cell} SetVisited cell -&gt; {model | visited = Just cell} NoOp -&gt; model control = Signal.mailbox NoOp type Action = NoOp | SetSelected Cell | SetVisited Cell modelSignal = Signal.foldp update (init rowCount colCount) control.signal main = Signal.map (view control.address) modelSignal The hexagonal cells highlight in blue when the mouse passes over and in red when clicked. The code is available on github: https://github.com/dc25/elm-hex-tiling You can see the code in action here: http://dc25.github.io/elm-hex-tiling/ 
You're welcome! I happened to have an SVG checkerboard as part of another project that transformed easily into a hex tiling with a few changes.
Relevant: - https://vimeo.com/97408205 - https://github.com/elm-community/elm-webgl
Pretty simple stuff, but the dive into Elm was so pleasant I wanted to share the result. Click and use arrows to cycle through the maxims. Cycles also on its own every 30 seconds. Not much else. Source: https://github.com/makemeunsee/elm-maxims 
Ideally the 30 seconds timeout should reset when you cycle with the arrows yourself. Otherwise you're cycling and reading and suddenly it also changes by itself when you've only just switched. Otherwise, it's a nice little app :)
I gave auto-advance reset a shot at https://github.com/ianmackenzie/elm-maxims. It works, but it's not as elegant as I would like (and pretty verbose). I like to think it's reasonably clear though! I think if the app as a whole followed the Elm architecture there would be better solutions. I'm thinking of having an `autoAdvanceId` or similar in your model that would get incremented every time the current maxim is changed, firing off an `Effects.task (Task.sequence [Task.sleep (30 * Time.second), Task.succeed (AutoAdvance model.autoAdvanceId)])` whenever the current maxim is changed, then having the `update` function handle the `AutoAdvance autoAdvanceId` event by checking to see if `autoAdvanceId` was the same as `model.autoAdvanceId` (i.e. the user hadn't done anything in the meantime). This would avoid the hacky repeated polling in my current solution...
Immediately after posting this, I had an idea. It would make sense to choose one or the other if Signals were a push-style, rather than a pull-style system. Meaning that when an event happened, it pushed itself through the event chain. Then if two events happened at the same time, on separate threads or something, they pushed themselves through the merge, and the merge arbitrarily chose one event over the other. A pull style would mean that events would pile up into a queue, and wait there until the renderer "pulled" them through the chain. Sorry if this isn't familiar terminology. Still just an idea of why one is discarded.
I can't speak to why it was designed that way, but there are a couple functions that might help you: **Signal.Extra.fairMerge** This function comes from the Signal.Extra package (it's not in the standard library). It won't preserve both values in the case of a conflict, but it does let you use a function to determine which value to keep: &gt; fairMerge : (a -&gt; a -&gt; a) -&gt; Signal a -&gt; Signal a -&gt; Signal a &gt; &gt; A function that merges the events of two signals without bias (unlike Signal.merge). It takes a resolution function for the (usually rare) case that the signals update in the same "round". http://package.elm-lang.org/packages/Apanatshka/elm-signal-extra/5.7.0/Signal-Extra#fairMerge **Signal.map2** This function takes a combining function and two signals, and gives you a new signal as a result. Unlike merge, no values will ever be dropped, but you will have to handle both values as a unit rather than as discreet values. &gt; map2 : (a -&gt; b -&gt; result) -&gt; Signal a -&gt; Signal b -&gt; Signal result &gt; Apply a function to the current value of two signals. The function is reevaluated whenever either signal changes. In the following example, we figure out the aspectRatio of the window by combining the current width and height. http://package.elm-lang.org/packages/elm-lang/core/3.0.0/Signal#map2
I think the fairMerge is close to what I want. It seems like you could keep both values if you modified a to be a list of events by letting a=[Event] or something. looking at the difference between map2 and fairMerge: it seems map2 updates its arguments whenever either one changes, and calls the (a-&gt;b-&gt;result) function. With fairMerge, it calls (a-&gt;a-&gt;a) resolution only if both signals change. I think this reinforces my idea that the events are "pushing" their way through the system; i.e. the functions are called when a new event comes on the signal. anyway, thanks for the help! :)
Very cool!
this is actually super sick. looks visually stunning. nice job!
I'd have to go digging around in Elm's implementation. I did pull up Conal Elliot's "Simply efficient functional reactivity" though, and in that case, `merge` biases left but does not discard anything. The left bias just affects whose events come out first in the merged event stream when the times are the same, with the answer, "all the ones at that time from the left stream precede all the ones at that time from the right stream".
&gt; Elm is the most "hardcore typed language" of the list, meaning that you can't even call Javascript code from Elm and vice-versa - you have to communicate through message passing. On the other hand, Elm would be the language that would provide the most type safety benefits of the list I see what you're saying here, that elm's policy of only talking to js through the "ports" mechanism is the most safe out of the 5 languages you mentioned, but that doesn't have much to do with type safety in the way that strongly typed fp geeks usually mean. "Type safety" has more to do with the expressiveness of the type system, i.e. how well it allows you to encode invariants in your program so that incorrect programs don't compile. In this respect, you can make the argument that purescript is more type safe because its type system is much more advanced, but the added expressiveness introduces extra complexity. Elm hits somewhat of a sweet spot by being way more type safe than js, flow, or typescript, while still being simple enough to learn easily. 
It might be worth noting that the issue with `toString` returning a `Result` rather than a `Maybe` can be resolved with `Result.toMaybe : Result x a -&gt; Maybe a`. For the sake of composability and reusability, it might be nice to have something like require : (a -&gt; Bool) -&gt; a -&gt; Maybe a require p a = if p a then Just a else Nothing Then you could have parseNumValue v = (String.toInt v |&gt; Result.toMaybe) `Maybe.andThen` require (\n -&gt; n &gt;= 2 &amp;&amp; n &lt;= 10) |&gt; Maybe.map Num Alternately, you could have something like `filterMaybe : (a -&gt; Bool) -&gt; Maybe a -&gt; Maybe a`.
Yes, one could argue that the ports mechanism don't contribute to type safety, but to "side effects safety". Since safety is the main theme of the investigation, Elm appears to be still on the lead. Thinking strictly on type, then PureScript would be the most advanced of them. 
Nice! Thank you for the tip. Did not know `Result.toMaybe`, and it looks very useful.
I think I see. If all the instances of the term *safety* were replaced with the term *reliability*, I think I'd be totally on board. And I think that's what you are saying anyway. "Safety" has a cultural history with languages related to Elm and it often used to mean something much more specific (as you can see in one of the other comments here) and I don't think the jargon meaning of "safety" is the important thing.
Thanks for the input! I think you are correct, and the term *reliability* captures more what I was looking for. I'll review the text.
This one: http://ncase.me/sight-and-light/ Points to anyone who can tell me why Elm's `Text.link` isn't working.
Because it's drawn to a canvas element?
It appears to be the collage function...I somewhat recreated it here. http://share-elm.com/sprout/5723aefce4b070fd20dab6a4 Try the commented version of main and it breaks. Very weird! Edit: This reiterates the canvas comment :P I'm just slow today
Fixed it, you could do the link like so if you wanted it centered: linkText = [ fromString "A raycasting hack in Elm, based on " , Text.link "http://ncase.me/sight-and-light" (fromString "this excellent tutorial") , fromString "." ] |&gt; Text.concat |&gt; centered in flow down [ container w' 50 middle linkText , collage w' h' [ Edit: I see I was too slow and you commited 4 mins ago :P. Cheers!
Out of core into a separate package 
That tutorial was really enlightening, thanks!
i think his question was more about how that importing is implemented in javascript.
This is correct. There are also a number of different projects on github to use tools such as Webpack, gulp and grunt with Elm. 
http://package.elm-lang.org/packages/circuithub/elm-bootstrap-html/6.3.4/
Elm basically generates the JS code for each module, then glues them together in the proper order when it's done. You do NOT need to call Elm make for each file. Call it for your main and it will search for and compile any modules you've imported. Then, interact with the resulting js as is documented here: http://elm-lang.org/guide/interop
Nope, elm-make creates a ELM application with the Runtime included. You have to target an JS file instead of a HTML file when building, and then include that in your own HTML page (which can also include any CSS or other files you wish to use). This also means that the elm-reactor can't be used in a good way for testing. ~~(( At work currently so I can't give you an example ))~~ See other response for a short example
Native modules are intended for internal use primarily. What are you trying to do? Are you sure it can't be done with Ports or Tasks? 
very helpful...thank you! Given this approach...Do you basically then update your HTML and elm file compile and test? Is there a faster approach? 
Bootstrap is separated into CSS and JavaScript. The "JavaScript part" handles stuff like Modals, Menus, Animations. These aren't really going to work unless you implement them yourself, or add interops between ELM and Bootstrap JS. Not that easy to do. 
What have you tried? What's not working with those attempts?
This post describes quite well how I felt using Elm. I tinkered a little with Elm last year. I built a simple calculator in Elm and TypeScript at the same time just to get a feel of both languages (I only know Ruby and a little C) and I ended up abandoning the TypeScript version before finishing it since I was enjoying so much working in Elm. I have been testing a lot of compiled languages lately, but none have such a helpfull compiler as Elm does. It really makes things a lot easier to do, and most of the time if it compiles it works.
I realize your direct question has been answered, but you may be interested in these two UI packages written in Elm: * [gdotdesign/elm-ui](https://github.com/gdotdesign/elm-ui) * [debois/elm-mdl](https://github.com/debois/elm-mdl)
Anyone tried working with webcomponents like Polymer? I saw some comments on Github that someone tried forking elm-html to use incremental DOM and that seemed to work, but it's not something that's officially supported. Saw another github article https://github.com/quephird/polymer-with-elm that seems to just include the polymer HTML but doesn't mention DOM issues. 
(Caveat: Don't know Java, haven't used Elm in a few months, some syntax may be slightly off or weird-looking. If so, I'm probably mixing it up with the language's relative Haskell, but it should be clear still) If you look at your Java example, what are you really doing? You're turning it into a stream (unnecessary in Elm) and then mapping with `e -&gt; list.filter(y -&gt; y !=e)`, or, in Elm, `\ e -&gt; filter (/=e) list`. Hence, that snippet is just `map (\e-&gt; filter (/=e) list) list`.
Yes, this is definitely possible. You can write your logic in Elm and then export the resulting values via "ports". You can create a headless Elm app by using `Elm.worker()` instead of the usual `Elm.embed()`. In JS land, just subscribe to the ports and listen for changes. http://elm-lang.org/guide/interop Here's an example of a headless Elm app: https://gist.github.com/evancz/8521339 Edit: note that this example is slightly out of date, but the same concepts apply in the current version of Elm.
Thanks..i should have read the docs properly!
I ran into this when doing naive collision detection, where I had to compare every entity in the list to every other entity in the list. What I did was not pretty, nor efficient, so I'm all ears for someone else to come up with a better solution. First, I have a function to compute all other entities given an index and an entity. everyOther index arr = List.append (List.take index arr) (List.drop (index + 1) arr) Then I use that in my map with index function. List.indexedMap (\index elem -&gt; computeNewElem elem (everyOther index arr) ) arr It's O(N^2), and depending on what you do in computeNewElem, it would get more expensive. But this allowed me to get it done, and move on. I'll come back to it when I need it, as computers are fast. 
elm-ui looks promising!
I guess this example is from the docs? These examples are meant to be entered directly into `elm-repl`. If you want to output a website, you need to define `main`. In this example you probably just want: import Html exposing (text) (...) main = text (toString (goodName "Tom")) 
But what's new?
I'm not sure its possible, at present. The simplest thing I could think of was to simply construct html via elm in the test and compare it to the function output, but that didn't work, because e.g. `h1 [] [] == h1 [] []` is false. My next thought is to attempt writing a `toString` implementation for objects of type `Html`, then one could assert something like `"&lt;h1&gt;Hello World&lt;/h1&gt;" == toString &lt;| label "Hello World"` I'm looking into that now.
Will do. Yeah, I was reading the post on elm-dev about things changing soon. It will be interest to see how it changes. I welcome conventions that make building idiomatic apps better, which this sounds like it might be.
I just stumbled up http://tech.noredink.com/post/140291903568/static-site-generation-in-elm It talks about using the virtual-dom package and how it will generate the HTML in a string. Perhaps you could leverage something like that?
Thanks! I checked this out earlier but didn't find it super helpful in making me understand signals at a more fundamental level :/
No syntax is natural. We all get accustomed to a syntax. If you have trouble learning Elm's syntax rest assured, **you are not alone**. I've come to Elm from Python and, even if I felt a strong pull towards it, the syntax was alien to me. I've spent maybe a year looking from outside until I just decided to bite the bullet and just do a series of challenges in Elm. The challenges took me about a week and after that intense effort the syntax was no longer an issue. 
Maybe not what you want to hear, but Signals have been replaced by subscription in the newest version of Elm (released today). http://elm-lang.org/blog/farewell-to-frp
By making a function that operates on a pair/tuple, you *can* define a function that takes two arguments. You might reply by saying that this isn't *really* two arguments; it's just a single tuple argument. But then I'd follow up with the question: what then really is a function of two arguments? If it's not a function that takes a pair of arguments, and it's not a curried function of two arguments, then what exactly is it? Ultimately, I guess my point here is that I don't think the above poster is wrong once you consider more deeply the question of how one would actually define the notion of a function of two arguments. It's either a function that operates on a pair of arguments, which you can do in Elm, or it's a curried function, which you can also do in Elm. For practical purposes, I think it makes more sense to define "a function of two arguments" as a curried function. In other words, EffBot is simply using a semantics which *defines* a "function of two arguments" to be a curried function of one argument which returns another function of one argument. The details of that definition can be left for later, though.
Looks very good. I got stuck learning elm at about the point I wanted to integrate a call to a javascript function. Can't for the life of me remember if that involved signals or not. Will definitely try the tutorial(s) again when I get some more time because I really was enjoying everything else about the language and developing in it.
&gt;You might reply by saying that this isn't really two arguments; it's just a single tuple argument Yep. &gt; If it's not a function that takes a pair of arguments, and it's not a curried function of two arguments, then what exactly is it? You could say either one. But for drawing an analog to ruby, java, etc., the tuple definition is more correct. "Normal" elm functions (curried) are a whole different beast. My big problem is when people explain this: multiply : Int -&gt; Int -&gt; Int By saying that "Well, the last one is always the return value, and all the rest are arguments." That's not really what's going on, and it ends up making people think "why the heck does the type declaration look like that?!" The type declaration looks like that because that's literally what it's doing. It takes an `Int` and gives you back a function that takes an `Int` and returns an `Int`. Calling `multiply 5 3` is calling `multiply 5` *and then* calling the returned function with `3`. Understanding that is very important, and makes partial application and currying in general a lot more intuitive. When you see something like this, it ends up being easy to understand if you start with a correct understanding of how function application works: let numbers = [0, 1, 2, 3, 4, 5] numbersTimesFive = numbers |&gt; List.map (mult 5) Without that understanding, people think that mult takes two arguments and they write this kind of thing: let numbers = [0, 1, 2, 3, 4, 5] numbersTimesFive = numbers |&gt; List.map (\n -&gt; mult 5 n) 
I'm guessing we'll be "as far as ever" until there's a new release with only minor/trivial changes.
I'm excited to try out the new Websocket library. Hopefully now I'll be able to write a Phoenix Channel implementation that's pure Elm :)
It's the type of messages that are produced to notify the program of DOM events. The old way involved passing a function to the view that knew what to do to turn a message understood by the embedded component into a message understandable by the embedding component. With the new design you [map](http://package.elm-lang.org/packages/elm-lang/html/1.0.0/Html-App#map) over the HTML for the inner component instead.
I just saw this as well - I'll have to read more but I'm curious how Subscriptions differ from the mental model of Signals, Addresses, and Mailboxes...
So far, can't get this working (Windows) Empty directory, go to run `elm package install`. It creates the elm-package.json file, and then it says: Error: Unable to find a set of packages that will work with your constraints. Also it looks like someone changed the UpdateCode instead of the ProductCode in the MSI table. If you install this on a machine running 0.16, you'll end up with two different elm installs. EDIT: Temporary workarounds here: https://github.com/elm-lang/elm-platform/issues/141 
you just have to get used to it, there is a learning curve for any syntax. And there is especially a learning curve for more powerful types. I don't know what language you come from, but chances are you're not used to have a type system that's so precise. The hours that it takes to convince the compiler to accept your code can feel like banging your head against a wall. But it's like putting the time upfront that you'd spend on debugging later. Very few runtime errors escape Elm's type system, I've been working with it 6 months full-time and I think I had 3, total. It's an investment really :) Also if you're not used to currying that can be a block, written a bit about that http://www.lambdacat.com/road-to-elm-currying-the-unknown/
Thank you for the clarification; simplification can only go so far before it becomes obfuscation. Having the ability to apply arguments to a function across spans of time, rather then instantly, is completely new and mysterious for me. Could you suggest or point me to a resource that shows what role it plays in the evaluative style of computation? I'm finding that nearly all features unique to FP are aimed at reducing or eliminating the modification or adding-to program memory/state.
I installed bootstrap the old fashioned way and manually created the HTML elements in elm. When it got repetitive I made helper functions in elm to shorten the declaration of common bootstrap components. In short it is not a big deal.
It's not hard to do Dict with the comparison function as an explicit argument, it's just nobody has gotten around to writing the library for it yet. 
Huh, i though elm pushes proper way of semver but here it is with breaking changes updating only 'minor' version. even a seemingly small change of `module Something (..) where` to `module Something exposing (..)` is incompatible with 0.16.0 though semver clearly states that minor version upgrade should be backwards compatible. or am i missing something and this is okay? 
I bought both of the pragmaticstudio.com Elm video sets. I don't regret it, but if I had less money to spend and could only choose a single thing to get, I'd probably do the Elm track at dailydrip.com. It's $9/month, regularly has new videos added, and I think it covers the same stuff as the pragmatic studio videos, and then some. The pragmatic studio videos are a bit slower paced, so if that's important to you to consider. However, I really like the mix of text and video on dailydrip.com
All packages on are semver that starts with 1.0.0. Elm itself is on semver with a 0 in front. So it is 0.X.Y.Z. It would be cool to not be doing things this way, but it's not so simple because the world does not think of versions like Elm thinks of versions.
`Graphics` appears to be gone...temporarily?
From the Semantic Versioning Specification: &gt; Major version zero (0.y.z) is for initial development. Anything may change at any time. The public API should not be considered stable. http://semver.org/#spec-item-4
Thanks for the tip - didn't even know about dailydrip.com!
&gt; One thing I don't get yet is the type of view : Model -&gt; Html Msg. Why is Html parameterized over the message type? Because now instead of having the view post messages to an address, the view (and view elements) "return" messages to whatever called the view for rendering.
 import Html exposing (..) import Html.App as Html import Html.Attributes exposing (..) import Html.Events exposing (onInput) import String main = Html.beginnerProgram { model = model , view = view , update = update } -- MODEL type alias Model = { name : String , password : String , passwordAgain : String , validationErrors : List String } model : Model model = Model "" "" "" [] -- UPDATE type Msg = Name String | Password String | PasswordAgain String update : Msg -&gt; Model -&gt; Model update action model = case action of Name name -&gt; { model | name = name } Password password -&gt; let modelWithPassword = { model | password = password } validationErrors = detectValidationErrors modelWithPassword in { modelWithPassword | validationErrors = validationErrors } PasswordAgain password -&gt; let modelWithPasswordAgain = { model | passwordAgain = password } validationErrors = detectValidationErrors modelWithPasswordAgain in { modelWithPasswordAgain | validationErrors = validationErrors } -- VIEW view : Model -&gt; Html Msg view model = div [] [ input [ type' "text", placeholder "Name", onInput Name ] [] , input [ type' "password", placeholder "Password", onInput Password ] [] , input [ type' "password", placeholder "Re-enter Password", onInput PasswordAgain ] [] , viewValidation model ] viewValidation : Model -&gt; Html msg viewValidation model = let errorListItems = List.map (\errorMsg -&gt; li [ style [("color", "red")] ] [ text errorMsg ]) model.validationErrors in ul [] errorListItems type alias Validation = { condition : Bool , errorMessage : String } detectValidationErrors : Model -&gt; List String detectValidationErrors {password, passwordAgain} = let validations = [ Validation (String.length password &lt; 10) "password too short" , Validation (String.contains "!" password) "! is a forbidden character" , Validation (password /= passwordAgain) "Passwords do not match!" ] validationErrorMessages = validations |&gt; List.filter .condition |&gt; List.map .errorMessage in validationErrorMessages 
Thanks this was really helpful. I like the idea of storing it in the model - for some reason (imperative) I keep thinking of the model as global and try to avoid storing any state in it. I suppose it can be compared to the component's state in React. I like using the `type alias Validation`, I always forget to use types as a basic data structure and get stuck on tuples and lists. Too much C in my life has rotted my brain for higher order data structures. I like how you use it to then filter and map; I had gone down that path but ended up being confused with how to do it (I think I was stuck on tuples again). I did not know about the floating dot syntax for access, that's great to know. I can see pros to only calculating the validation when the particular field changes like you did for efficiency, so I wanted to try out a naive version where it's just calculated every time the view redraws. This is what I ended up with. import Html exposing (..) import Html.App as Html import Html.Attributes exposing (..) import Html.Events exposing (onInput) import String main = Html.beginnerProgram { model = model, view = view, update = update } -- MODEL type alias Model = { name : String , password : String , passwordAgain : String } model : Model model = Model "" "" "" -- UPDATE type Msg = Name String | Password String | PasswordAgain String update : Msg -&gt; Model -&gt; Model update action model = case action of Name name -&gt; { model | name = name } Password password -&gt; { model | password = password } PasswordAgain password -&gt; { model | passwordAgain = password } -- VIEW view : Model -&gt; Html Msg view model = div [] [ input [ type' "text", placeholder "Name", onInput Name ] [] , input [ type' "password", placeholder "Password", onInput Password ] [] , input [ type' "password", placeholder "Re-enter Password", onInput PasswordAgain ] [] , viewValidation model ] viewValidation : Model -&gt; Html Msg viewValidation model = let errorList = List.map (\msg -&gt; li [ style [("color", "red")] ] [ text msg ]) (detectValidationErrors model) in ul [ ] errorList type alias Validation = { condition: Bool , errorMessage: String } detectValidationErrors : Model -&gt; List String detectValidationErrors model = let validations = [ Validation (String.length model.password &lt; 10) "password too short" , Validation (String.length model.name &lt; 10) "name too short" , Validation (model.password /= model.passwordAgain) "password doesn't match!" ] in validations |&gt; List.filter .condition |&gt; List.map .errorMessage The one downside is that it runs immediately upon render, before anything is changed. So I'd likely end up putting the state into the model like you did.
Hmm. I must be thinking about what I'm doing wrongly. I'll have to consider carefully if there are better ways to approach problems like this.
Elm imports are qualified for a reason. Just don't put map in "exposing", and you can refer to List.map, Html.App.map etc 
I believe the Graphics package got moved to [here](https://github.com/evancz/elm-graphics/find/1.0.0?q=) 
&gt; (\someChildAction -&gt; ParentAction) Noob hard-to-search-for syntax question: What does `(\x -&gt; y)` do?
It is a function which takes a parameter `x` and returns `y` (which may be an expression involving `x`). You can also have multiple parameters: `\x y z -&gt; w` which is equivalent to `\x -&gt; \y -&gt; \z -&gt; w`. If you hear the term 'lambda' thrown around, that's what this is. (The '\' character is chosen to suggest the Greek letter lambda.)
Yeah, I saw that. That doesn't answer my question though. Don't really want to use Graphics if I can help it. Seems others may have answered though, so thanks for your help :) Edit: Apologies that this comes across as ungracious. It seems Graphics is becoming less "the condoned way to do graphics", and I'd prefer to not use it if possible. For this particular example I probably shouldn't even have mentioned it because it's not *entirely* relevant to what I'm talking about. I'm more interested in working out how to subscribe to info from the DOM context. All good though, https://www.reddit.com/user/janiczek has pointed me in the right direction.
Searching `\` in that page only shows distinction of function / anonymous function, without explanation.
Thanks. The problem that I'm struggling with is that I've been studying Elm for a while, went through tutorials and the Pragmatic videos. I can make complete sense out of any code I read, I fundamentally understand the language and how it works. Then I sit down and try to solve a problem, and it's like everything I've learned in the last 20 years is actually making it worse and not better. I'll just keep pushing through. :) I feel like one of those people that can understand English but can't speak it...
:)
You could store the current time in your `Model` and calculate the elapsed milliseconds every time you get a new `Time` value. For example, if you want 60 frames per second: Time.every (Time.second / 60) SetCurrentTime
Does that take into account the browser's 'natural refresh rate' as fps used to handle for you? Also, http://package.elm-lang.org/packages/elm-lang/animation-frame/1.0.0/AnimationFrame has a AnimationFrame.diffs method, would this be able to provide the same functionality but in a different way
Show us practical use cases. What code looks bad without them? How is improved when they're added? Change will not happen without concrete examples. 
Thanks for the suggestion. Unfortunately, I have text in each span... so I want them to stack. There actually already is a drag n drop thing implemented in 0.16.0 but 0.17.0 is such a new / different way of doing things and I wasn't really *that* familiar with the way 0.16.0 did complex things anyway. It's fine, it was just for an "implementation of concept" anyway.
`fps` was a Signal of diffs. The direct equivalent is indeed AnimationFrame.diffs which sends the provided Msg at 60 fps (tentative). If your code used 60 fps, most of it will remain unchanged. If you used a different number, you'll need to adjust the some of the numbers in order to compensate for the change in fps. Here is the [Mario example](https://gist.github.com/pdamoc/6f7aa2d3774e5af58ebeba369637c228) ported to 0.17. 
Here's my attempt (doesn't do any coloring but filters out non-errors in a pretty concise way): viewValidation : Model -&gt; Html msg viewValidation model = let matchError = if model.password /= model.passwordAgain then Just "Passwords do not match" else Nothing lengthError = if String.length model.password &lt; 5 then Just "Password is too short" else Nothing characterError = if not (Regex.contains (Regex.regex "[0-9]") model.password) then Just "Password must contain a digit" else Nothing errorMessages = List.filterMap identity [matchError, lengthError, characterError] in ul [] (List.map (\message -&gt; li [] [text message]) errorMessages)
Not sure if this is the best, but you could [reverse](http://package.elm-lang.org/packages/elm-lang/core/4.0.0/List#reverse) it and then take the [head](http://package.elm-lang.org/packages/elm-lang/core/4.0.0/List#head). But maybe a list is not the correct data type for your application. If you need to get the last element often, consider switching to some other data structure, maybe an array.
Is it possible to make it work on [elm try](http://elm-lang.org/try) by somehow importing it? On a side note, all `Graphics` examples seem to be gone from [examples page](http://elm-lang.org/examples), i was hoping to find an example there. Maybe they're moved somewhere else?
Thanks, pickten's answer got me in the right direction and came up with exactly what ludat wrote :)
 lastElem : List a -&gt; Maybe a lastElem = List.foldl (Just &gt;&gt; always) Nothing 
That's hot.
Okay, I figured out that evancz is deprecated, but wow that took a lot of work. I had to delete the evancz/elm-html line and run elm-package install elm-lang/html Why isn't there a better tutorial/reference about this JSON/dependencies task? 
How does this work!!
Here's another variant using function application. By writing a simple helper function you can make the validation code read a bit clearer (IMO) check : String -&gt; Bool -&gt; List String -&gt; List String check message condition validations = if condition then message :: validations else validations validateForm : Model -&gt; List String validateForm model = [] |&gt; check "password too short" (String.length model.password &lt; 10) |&gt; check "passwords do not match" (model.password /= model.passwordAgain) |&gt; check "name too short" (String.length model.name &lt; 5) 
Wow, that's a great idea, thanks!
Thank you for the link. Yea, I guess it might take a little while before the old examples, etc are updated. I would have been helped by a link early in the tutorials to a technical document describing this file and how to fix versions. Something like "If you are having trouble with steps X, Y or Z, check out this. . ." 
Thanks. I will play with that.
Check out these doc pages :) http://package.elm-lang.org/packages/elm-lang/core/4.0.0/List#foldl http://package.elm-lang.org/packages/elm-lang/core/4.0.0/Basics#&gt;&gt; http://package.elm-lang.org/packages/elm-lang/core/4.0.0/Basics#always 
Try composing a couple functions in the String library. I'd do the following. 1. `(String.join " " &lt;&lt; String.words) yourString` 2. `(String.join "." &lt;&lt; List.map String.trimRight &lt;&lt; String.split ".") yourString` I'll let you try to puzzle out what I did there, but let me know if you need an explanation.
Awesome, just the answer I need but... deleted.
I understand! Thanks! Jesus, that is elegant.
Thanks, this is sort of what I've been doing. Just going through the examples over and over. I'm really sad that they removed most of the Elm Architecture examples in 0.17, because now I'm confused how to do any of those things. The Counter examples don't work anymore, and Evan removed them from the repo. :( 
Interesting, I like this method too. I've done a lot of Elixir recently and learned a ton about list composition, but Elm is so foreign to me I'm still having a hard time thinking about *anything*. Seeing how similar this is to something I'd write in Elixir is super helpful. Thanks for taking the time to write it out.
The elm-make command fails for me with: elm-make: —-output: openFile: does not exist (No such file or directory) This is elm-package.json: { "version": "1.0.0", "summary": "helpful summary of your project, less than 80 characters", "repository": "https://github.com/user/project.git", "license": "BSD3", "source-directories": [ "." ], "exposed-modules": [], "dependencies": { "elm-lang/core": "4.0.0 &lt;= v &lt; 5.0.0", "elm-lang/html": "1.0.0 &lt;= v &lt; 2.0.0", "evancz/elm-http": "3.0.1 &lt;= v &lt; 4.0.0", "evancz/elm-markdown": "3.0.0 &lt;= v &lt; 4.0.0" }, "elm-version": "0.17.0 &lt;= v &lt; 0.18.0" } Is this 17.0 still a moving target? Any ideas how to fix? My os is the current linux mint. TIA 
Hi, that looks like a character error. The first dash was formatted into a long dash by the blog editor. Try again with this: elm make Main.elm --output app.js Thanks for reporting! I just fixed that in the post.
The nesting example was updated yesterday [here](https://github.com/evancz/elm-architecture-tutorial/tree/master/nesting) if you want to check it out. I think it answers your question: the [2-counter-list.elm](https://github.com/evancz/elm-architecture-tutorial/blob/master/nesting/2-counter-list.elm) file seems to import another module, and delegate to it for viewing the elements managed by this module using [Html.App.map](http://package.elm-lang.org/packages/elm-lang/html/1.0.0/Html-App#map).
You init with `Cmd.none`, maybe you can init with your resize action there? I'm guessing because I don't understand all of the new `Cmd` stuff yet. I think perhaps `Task.perform` with some combination of arguments that include your `WindowResize` action would work.
Lower case means variable. You can use any lower case name from the classical `a` and `b` to things that contain some more information for the reader like `msg`. Now, if your html code does not actually emit messages (i.e. it does not have any Html.Events attributes in it), you can leave that Html with a variable like it is done in `viewValidation: Model -&gt; Html msg` this means that the resulting Html will take whatever concrete type it is in the Html where it ends up (in the example case it is Msg). If you specialize it with `Msg` as in `viewValidation: Model -&gt; Html Msg` it also works because it end up together with other `Html Msg` If you specialize it with `Int` as in `viewValidation: Model -&gt; Html Int` it stops working because the rest of the list is of type `Htm Msg` however, if you map the Int to a Msg, it will work again. i.e. : view : Model -&gt; Html Msg view model = div [] [ input [ type' "text", placeholder "Name", onInput Name ] [] , input [ type' "password", placeholder "Password", onInput Password ] [] , input [ type' "password", placeholder "Re-enter Password", onInput PasswordAgain ] [] , Html.map (\_ -&gt; Name "") (viewValidation model) ] viewValidation : Model -&gt; Html Int viewValidation model = let (color, message) = if model.password == model.passwordAgain then ("green", "OK") else ("red", "Passwords do not match!") in div [ style [("color", color)] ] [ text message ] Of course the above code is super silly but I hope it give you an idea. 
Thank you for your reply! This makes sense to me somewhat. However, If lower case names in type annotations are type variables, why does this code not compile genericfunc : Int -&gt; {a: Int, b:typevariable} genericfunc x = {a = x, b= 2} in my mind, i'm defining a "generic" function which returns a record in which "b" is a generic variable can return any time. However the compiler complains that the inferred type does not match the type def.
Oo interesting. Reading your post made me realize that this sort of breaking-change major API upgrade is *possible* with strong static typing. So when Elm makes breaking changes, it creates a lot of work for developers of every project to upgrade, which is annoying. But when Python makes breaking changes, it creates just as much upgrade work, *and* you can't ever be 100% sure you've made every necessary change, making it annoying and *highly dangerous*. Which is why people have no plans to upgrade to Python 3.
Gulp example: https://gist.github.com/turboMaCk/e2e5bdaee255cd2d1488
You did a wonderful thing here documenting the upgrade process. I went through an upgrade of my own from an app written for 0.15 and only slightly updated for 0.16 (it was still using old paradigms). I ended up wishing I would have documented the process. In the end I would live you with one small stylistic choice I've picked up looking at official code produced by Evan: beside `({ model | ... }, Cmd.none)` you can also do `{model |... } ! []` It looks nicer and has the advantage that if you need to return a command you can just put it in the list. :) 
Could you explain what you suggest? I think you say to replace the argument of type Cmd by a list of Cmd (and thus, empty list is equivalent to one Cmd.none), but I don't understand the exclamation point!
Yes! This a big point I think. Just few days ago I went to a long argument about static vs dynamic typing and during that conversation I mentioned Elm. I was defending dynamic typing as powerful but unsafe thing. To be honest maybe all of this is some sort of reaction to that conversation. That conversation was reaction to uncle Bob's latest blog post. http://blog.cleancoder.com/uncle-bob/2016/05/01/TypeWars.html I kind of tried to explain what I mean by safety vs. power. This is that tweeter conversation: https://twitter.com/turbo_mack/status/727583733730136064
Oh thanks! Maybe you can post this comment under that blog post. I'll try to update it but I'm not sure when I'll find time to do so. I think it might be helpful for some folks to have it under that article until I do so. Thanks mate!
Ha ok, I think I got it (I tried to look at the implementation but it made things much more confusing than before): to "batch" means that the returned Cmd is a compound of all the Cmd in the list, is that it? Sorry I'm not familiar with the term "batch" here.
&gt; to "batch" means that the returned Cmd is a compound of all the Cmd in the list, is that it? yes. 
You mean, why not call the view function `view`? I have no idea. I also have two update functions with identical signatures one of which just calls straight through to the other. It's just a vestige of an earlier design that hasn't been cleaned up :)
Yeah, that's what I meant. I don't really have a problem with it. It just stood out to me. 
Also, Elm is in version "0" and likely will be for a long time to come. That means all us Elm developers are expecting major and frequent breaking changes to the API but have decided that the benefits of working with Elm are worth the risk and upgrade hassles.
Are you asking why someone would expect a stream of true values, why the system doesn't actually produce a stream of true values, or why the fact that the expected and actual behaviour differ is a problem?
Works for me now on linux, which is where I want to start. Somehow, Elm on Windows now has lots of problems for me now, but I don't think this has anything to do with your project. Thanks much for the fix,
He's just saying there's no guarantee that the two streams coming into `merge` are synchronized. Maybe one mapped stream updated slightly before the other one resulting in non-equal values. For example: numbers : Stream Float numbers = ... map1 = map sqrt numbers map2 = map sqrt numbers booleans = merge (==) map1 map2 In this scenario, what happens if `map1` is triggered to update slightly before `map2`? `map1` will suddenly have an output value based on the updated number value, while `map2` will still have an output based on the previous number value. The result is that `booleans` will be true most of the time, but may flicker to false for a moment every time `numbers` is updated.
If i understand what you want, you could do this by creating a custom type within your model to represent the state, and then custom update functions for each of those types. The most barebones example would look like this: type ModelState = State1 | State2 | ... type alias model = { ..., state : ModelState } type Msg = State1To ModelState | State2To ModelState | ... update : Msg -&gt; Model -&gt; (Model, Cmd Msg) update msg model = case msg of State1To newState = updateState1To newState model State2To newState = updateState2To newState model ... updateState1To : ModelState -&gt; Model -&gt; (Model, Cmd Msg) updateState1To newState model = case newState of State1 -&gt; (model, Cmd.none) State2 -&gt; ( { model | state = State2} }, Cmd.none) ... Then, if you wanted, you could even add more information to each state, ending up with something like `type ModelState = State1 String | State2 Int | ...` or whatever you need. Not sure if this is what you had in mind but it's how I might approach it!
`getRandomGif` does not run the http request. Instead, it prepares a command that can be sent to the runtime system (i.e. the elm js running in the browser) to perform the request. When the request completes, the runtime responds with a `Msg` that is fed back to the `update` function. Note that this is reflected in the types. `Http.get` does not return a result, it returns a `Task` which is a representation of an asynchronous effect. (In this case, the effect of making an http request.) In order to get the result, you have to tell the system to run the task and give it somewhere to put the result.
I thought this would be a linter, maybe call it something like `form-validate`?
Ok. So there's this thing called "communicating sequential processes" (CSP), first talked about by Tony Hoare. It's the idea of how to connect up communication within parts of a program - how to communicate between the pieces of your application in a nice, composable, good way that makes reuse possible and composability kinda fun. It's effectively core.async channels in clojure/script... if we model our app's communication in this way, it's very close to the original intention of objects (http://c2.com/cgi/wiki?AlanKayOnMessaging). Look into erlang's actor model, and the idea of having chunks of code "listening" to the things they care about. Perhaps OOP *should* have been called *Message-Oriented Programming*, but it wasn't and so we got stuck with confusion. We're only just now starting to come around to this realisation. Anyway, these are the basics. This (CSP) is "old magic" in terms of computer programming - leveraging papers from the past. Haskell has been doing this leveraging for a very long time (mostly from Math). Elm has had this kind of model, this CSP model that is very similar to Erlang's actor model, since the beginning with Signals and whatnot. These are of course now "gone" (at least from programmer visibility) in 0.17.0. What has replaced them? Well, nothing, because they're now baked in. The closest thing to Elm that I've seen is an architecture explained within a project called re/frame on clojurescript, which uses reagent (which is a nice functional wrapper on react's rendering layer), and describes a way to communicate and talk about state. https://github.com/Day8/re-frame . The major difference between Elm and any of these other types of things is that Elm manages all the connection stuff for you. You don't have to spend the pain to learn about all this stuff, and "the right way" is already set up for you. And, if you've ever had to do one of these before, you know how much work this saves an experienced programmer. This stuff is usually boilerplate, and it *should* be in the language or framework, so it's very nice that it is with Elm. The current version of Elm very much has a *nice* well-thought-out architecture built into it that hides all the wiring of connecting the pieces together. This is the application architecture you *would want* if you did it yourself nicely. Facebook people (reactjs) have been doing similar things (after they saw Elm's stuff, from what I understand) as can be seen at http://flowtype.org/docs/react.html whereby there is a way to connect up the state-dependencies of your programs so messages (which can contain state) just flow along from top to bottom and back up to the top again, causing changes to the model and therefore the view as they do so. The beauty of this architecture is that you can compose these items, build software in a reusable way, and you have the inter-app communication already designed for you. This is exactly what you need if you want to build *big* applications, and it turns out that it's also very good for building small ones, too. When you write an Elm app, you write pure (in the functional sense; functions only depending on their arguments, and not some other piece of changing state, and not functions that can do anything other than return a value) code that explains declaratively what the view should look like (and not a set of functions on how to mutate it). The view responds *ONLY* to the model. You declare what kind of thing your model is, its intitial state, and then an "update" section: a function for adjusting the model, based on recognising (pattern-matching on) Message values. You hook these "adjustment functions" into your view by making your view have Messages, which are implicitly functions that call back into the update functionality. This is so that everything is described "as it is" rather than "as how to modify" - that is, without having to reason about sets of mutated state functionality in your application. Everything is clearly and cleanly described. So, for example, you might have a button in your view. Maybe you have a text field that shows an Int value, too. The Int comes from the model, but you don't have to put it there, you just place its variable in the view, the button has something like "send message increment" in its js-browser `onClick` handler. Now, that is actually just a message in Elm, but it translates into functionality in JS. You don't have to write the actioning functionality yourself, because Elm's `onClick` implicitly has that functionality that calls update in it: it takes your message value, and passes it into the update function when the JS `onClick` is called. The important thing is you don't have to think about this. You can program as if everything is "now" without worrying about crazy messy states things can get into. When you run this application, the update function will have code that simply increments the model's Int value when it is passed an Increment message, the view is hooked up in such a way to know what it depends on and when that changes, that it needs to update its view if anything has changed. Everything is declarative, so it's easier to think about, nothing gets out of sync. Subscriptions are one part of the managed effects of Elm. This is very similar to how Elm has the "managed events" of the update chain described above, only it's about *effects*. That is, how you interact with the very necessary kinds of values that change over time like "the wall-clock time" or "mouse movements" or "keyboard presses" or "random numbers", not static or single values, but ones that are more like a stream of values that change over time due to all kinds of external "stimuli". These kinds of values are what make our programs interesting and give them life. They're "inputs" in our Input/Processing/Output cycle. If your app subscribes to, say, mouse movements, you then hook this into your update function by a function that makes it create messages that will be described in the update function about what changes to the model should be enacted when mouse movements happen. That is, this is the "pouring water in the top" part of the flow of the architecture: it's how the inputs get turned into Messages. This is how non-pure values (ie values whose identity stays the same but whose value is different depending on something else) get pulled into our pure application's model, and therefore how they drive the view, and step the application forward. Now, how are they different from Signals? Well, there's a lot of overlap. Because all of the effects in Elm were previously very much *NOT* managed, you'd have to program their co-ordination yourself, which was three things: 1. Very hard to learn about for new people (Evan has said this is one of the biggest stumbling blocks). 2. Tricky to reason about (even for non-beginners). and 3. Actually "incidental complexity" and therefore unnecessary if you look at what the programmer is trying to achieve with them. Subscriptions grabs everything that was in Mailboxes and Signals, and takes it away from programmer control, and instead asks the programmer "What kinds of inputs, or feeds of information do you care about knowing about in your program?" and "How do you want me to create messages out of these things?". So, yes, Subscriptions are a way to inject messages into your app from "effects" that happen outside-your-app's context. Take a look at this example: http://elm-lang.org/examples/drag ... and you'll see the subscriptions as: subscriptions : Model -&gt; Sub Msg subscriptions model = case model.drag of Nothing -&gt; Sub.none Just _ -&gt; Sub.batch [ Mouse.moves DragAt, Mouse.ups DragEnd ] If you look at the `Just _` part, you'll see the `Sub.batch` function which is being applied to two items, `Move.moves DragAt` creates `DragAt` messages with the particular co-ordinate data of the mouse, and `Mouse.ups` creates `DragEnd` messages. `Sub Msg` values are implicitly hooked into the execution model such that they *generate* messages when the effect(s) that they depend on change. Take a look at the update function to see how these play out into changes into the model. Then you can look at the view to see how these model states play out into the view. Hope this helps and answers some of the questions you had about why Subscriptions are a better way to go.
Thanks! That answers my question perfectly.
The second one. Sorry, my question was vague.
The Elm Architecture is already a state machine. Just create a `Model` for your widget and an `update : Msg -&gt; Model -&gt; Model` function to change it.
First of all, all `Cmd`s, because of the way `update` function works, work asynchronously. I mean, you return a `Cmd` from the update function, then some amount of time passes (let's say a long HTTP request) during which you could have provoked another `Msg` from inside your app, and then the result `Msg` from the `Cmd` comes and your `update` function fires again. As for custom `Cmd`, it all depends on what you want to do. Do you want a random number? `Random.generate` lets you specify the number range etc. and returns a `Cmd`. So you can do something like: type Msg = ... | RolledDice Int type alias Model = { ... , lastRolledDice : Int } randomDiceNumber : Generator Int randomDiceNumber = Random.int 1 6 rollDice : Cmd Msg rollDice = Random.generate RolledDice randomDiceNumber update msg model = case msg of ... -&gt; model ! [rollDice] RolledDice dice -&gt; {model | lastRolledDice = dice} ! [] So the answer is: you just use whatever "Cmd creators" the libraries give you (`Http` library, `Random`, `Websocket`, even `Task.perform` and others). More than that would probably need a custom **effect manager** which is an advanced concept which you very probably don't need and can work with what building blocks are already there. **EDIT:** feel free to come to [Elm Slack](http://elmlang.herokuapp.com/) and ask more in #help or #general :) I'm @janiczek there.
Perhaps I'm mistaken about R. Feldman's module (which looks great), but I was under the impression that it generated a .css file, which could then be added to your index.html file via a &lt;link&gt; tag. This module generates the stylesheet as a &lt;style&gt; tag so you can render it (and change it!) at runtime in your view function. There's no need to even have the index.html file, which means it can be used with elm-reactor.
That is indeed an important difference and a nice feature. It does seem however that this one does not offer the same compile time checking. Am I correct? Edit: I think I was mistaken, sorry. 
Ah, now I understand. Thanks so much for the elaborating this!
Here is a better example: I have a widget for selecting a person in the database. It can be in one of three states: 1. Blank text box. Shows suggestions as user types. 2. Loading the currently chosen person. 3. Person has been chosen or loaded. Just show their name with a button to clear the selection. Typically we will move between those three states. I felt like a genius when I cleaned this up by making a state type: type State = Loading | Blank | Selected Person Whereas in the past I might have had: type alias model = { isLoading : Bool, currentPerson : Maybe Person, ...} That is crap, and it is very easy to write update logic that leaves the app in a broken or weird state. The State type is a HUGE improvement, but I am still finding it hard to reason about what functions should be modifying what state in the Model, if I should have a separate state transition function instead of just update (because update handles all kinds of events, and not all of them may change the state).
Thanks, this is pretty cool! I will definitely be trying all of these things in my app. There are some stupid complicated widgets I need to write, and the Model can get very hard to reason about.
What prevents you from having your widget's update function only deal with messages that change its state and moving all the other stuff to a higher level of the app?
I believe you can use his library for inline styles as well. The bottom of the README has this example: styles = Css.asPairs &gt;&gt; Html.Attributes.style button [ styles [ position absolute, left (px 5) ] ] [ text "Whee!" ] Not sure if it can generate a `&lt;style&gt;` tag though. I mean, it can generate CSS so I guess you can just put that in the body of a `&lt;style&gt;` if you want. I'm not sure the performance tradeoffs there though.
&gt; import Window where is this module coming from? Cant find any reference to it in 0.17... likewise for Action edit: meh, it's in separate modules now, I guess they cant be used in the reactor, too bad.
Wow, that's so hilariously long :D (Great job!)
I didn't say it was, just not used to thinking functionally. :) Thanks, where this differs from what I am doing is it swaps out a submodule for each state. I find submodules a royal PITA with mapping their messages in the parent and view, but I will definitely give it a try, it looks like this pattern could actually solve the godawful complexity of my current project.
I would not store the configuration for HTTP in Main. I would create a separate module that isolates the app from HTTP completely and allow the creation of specific Cmd. In this module you can have a config for the HTTP. One caveat, I view configuration as being static. If I would have dynamic information, I would pass it to the children by extending the `update` signature. update : Context -&gt; Msg -&gt; Model -&gt; (Model, Cmd Msg) Do you view this as duplication? If yes, I'm curious why. 
Can you post the file and the command that cause this error? 
Would it be possible to provide an example where the command originates from a child but the config comes from the HTTP module? I asked a similar question [on stackoverflow](http://stackoverflow.com/questions/37355030/elm-update-a-command-coming-from-nested-module).
Are you getting any errors in the JS console? 
This is a really weird bug. The JS console reports that the native element module is undefined. In Elm 0.17, Graphics.Element was moved to its own module from core, and the new WebGL release from a few days ago merely updates the references of the original Native module to the new module by evancz (from the elm-graphics module). Unfortunately, the order in which the generated (or in case of packages, pre-generated) javascript code gets written to the output main.html seems to be determined by the alphabetical ordering of the repository fields in the respective modules' elm-package.json files. Since the default generated elm-package.json contains 'https://github.com/user/project.git', and webgl comes from the 'elm-community/elm-webgl' repo, and 'e' comes first in the alphabet, the webgl code gets there first, preceding the definition of the Element module it relies on. So if you change 'user' to 'auser' in your elm-package.json, the code will get generated correctly. This is an ugly hack though, I'm looking into fixing it proper
Your issue is that a button is an HTML element, but you wrap it inside `[]` to form a list. Try removing the square brackets around the button. As a side note, the "big" parens after `li` are completely redundant and may have been part of your confusion as it *looks* like you were going for a tuple.
That was in fact the problem. Thanks. Coming from JS and the little Clojurescript background I have, Elm's syntax is somewhat confusing.
Direct game link: http://yupferris.github.io/elmsteroids/
Thank you! 
Yes, I did have Elm installed previously! Thanks, I'll try that.
I read your answer again and finally understood it! Because my config is dynamic you're suggesting to pass an incoming context to my child update. Now is this a good solution (duplication wise)? I think it's okay because we are not polluting the child's model, the context remains available only in the update function. I think you should update your answer on stackoverflow so that other people can read it.
Looks very nice. Did you investigate options for sound effects?
&gt; Now is this a good solution (duplication wise)? The problems with duplication are two fold: - waste of memory when you have big structures (not the case with a small config structure) - synchronization when you have duplicated state in various points of your app (not the case here since you are not saving anything). &gt; I think you should update your answer on stackoverflow so that other people can read it. done.
Thanks! I hadn't look into it, no. Got any good suggestions?
Great job! I'm having problems scrolling the left panel, though. Is that something you already know?
Check out this elm webaudio implementation which is currently under development: https://github.com/trotha01/elm-webaudio Or this alternative version which uses ports instead of native calls and is even more currently under development: https://github.com/trotha01/webaudio I would say though that maybe it's worth waiting until these libraries are a little more mature as I believe they are not quite ready for doing the kind of fast paced audio you would want in a game.
This isn't mine. I just thought it was cool.
thanks for the tip! Yeah, even if I do sounds I'll probably want to synth them if possible haha. Might just save that for the next project :)
Hey thanks! Really glad you found that useful, and thanks a bunch for the kind words as well; it's very motivating to "hear" that :) Also, how can you be inadequate if you're actively learning and seeking new things? Isn't that the point of like... everything? :)
First of all, awesome work! &gt; ... and a huge void where helpful functions like liftA2 ought to be Not to be too much of a troll, but I feel the need to point out that `Maybe`, `List`, `Result`, `Random`, and `Task` all give you the equivalents of `liftA2` through `liftA5` out of the box :) They're just called `map2` and so on. That, and the `elm-community/*-extra` packages are battle tested and tend to have all the extra functionality one needs. As an example, [elm-list-extra](http://package.elm-lang.org/packages/elm-community/elm-list-extra/1.0.0/List-Extra#andThen) could have helped you with a nicer poor man's list comprehension. Unfortunately, I haven't seen an out of the box `State` equivalent.
This sub isn't the most active, so I don't think anyone will consider posting examples spamming! 
I personally don't mind the spam, but I wish your title here was better: - *"sorry for spamming"* - useless noise, would be better suited as a comment - *"much more organized"* - more organized than what? (Now I happen to know you mean your previous post with etaque's example, but that's very hard to find out, especially since you deleted it!) This makes this post hard to understand without context, and unnecessarily hard to find in the future. Post titles should have clear semantics on their own, let's keep this sub clean! *(The linked resource itself seems good, I'm just making meta-argument here!)*
I don't understand why this is spamming? Bogdan's routing example is great, but what we need is a simpler routing example *as well* that does *nothing* but route between two or three pages - basically like etaque's, but without the animation stuff. (The animation stuff doesn't seem to work on Safari). Also, it'd be quite cool if they actually used the hash instead of path, because reloading the page within a path causes the server to say the resource doesn't exist.
&gt; There are many posts about Channels already so the focus here will be on Elm Maybe link to some?
You've also inspired me to look into making `State` into a community package. Starting by switching to more Elm-like naming: https://github.com/yupferris/elmsteroids/commit/b0c311c70791fa13b7416cf1bc93b34e3092796f I'm a bit unsure what to call `return` though. Going to consult the slack channel methinks :) Any suggestions?
Makes sense given the slew of recent doping scandals in the functional programming community...
`finally` sounds good to me! I think publishing `State` with an elm'y api is a good idea in either case. My intuition tells me that there might be some reasoning behind omitting it from the `Random` API but idk, your use case here seems like it would be common enough to warrant it. 
Shit.... https://github.com/fbonetti/elm-phoenix-socket
I've found the [language guide](http://guide.elm-lang.org) to be a good starting point. 
I have thought about this, it would be very useful to have in a lot of places. Look at ERlang's gen_fsm Zach
After you finish the guide, best way to learn is to jump in and build something! And if you ever get stuck at any point, both the [mailing list](https://groups.google.com/forum/#!forum/elm-discuss) and the [slack channel](http://elmlang.herokuapp.com/) are full of people willing to help
I edited the OP with a sample of what I found to be the most useful from this thread. I found that trying to formalize things didn't really simplify anything, but I got huge wins over my previous way of doing things (booleans everywhere) just by creating a State union type and a helper function to handle the switching.
It's been updated. There are still some sections (like [this one](http://guide.elm-lang.org/effect_managers/batching.html)) that haven't been filled out yet.
This would be so amazing as a library. I might have to get to work on that.
http://package.elm-lang.org/packages/elm-lang/window/1.0.0/
Can you please add a LICENSE file to the repo?
Instead of sending the results of an HTTP request to a mailbox, use `Task.perform` to turn your task in a `Cmd Msg`. Unless I'm missing something about your app, that's essentially what you would have done with previous versions of Elm, albeit with Effects instead of Cmd.
Use upstream communication together with accessors into the components. update : Msg -&gt; Model -&gt; (Model, Cmd Msg, UpstreamMessage) and updateSomeInfo : SomeInfo -&gt; Model -&gt; Model -- or (Model, Cmd Msg) In the parent/grandparent/ancestor, check for the UpstreamMessage and if information needs to be passed to siblings, use the accessors to update them. 
This is something I haven't found an answer to yet. There's been a number of people in elm-discuss having similar questions. `Cmd` is overall a better architecture, but this use case for signals seems to have been forgotten.
The code is wonderfully simple and should be accessible for beginners. It also shows how to integrate with Electron. 
There are now two Elm libraries: https://github.com/fbonetti/elm-phoenix-socket and https://github.com/NoRedInk/elm-phoenix
Really nice work. This would be a great tutorial project for someone learning Elm. I also love the electron integration - you've inspired me to write a desktop Elm app!
You have [a link](http://stymiedcoder.com/) tot the complete app in action at the top of the github page. :) 
Awesome. I love the API.
Are you kidding me, this is the most awsome elm app I have ever seen!
why, thank you!
This is fantastic! Very well done!
Because it's not just a proof of concept, it got movement, interactions and a lot of bells and whistles (literally)! 
Well yeah, that's a browser security feature, if you can't do it with javascript you won't be able to with Elm.
Very cool. Well done. 
NOTE: The README is in Spanish, because I'm from Ecuador. I'm starting a new group in my University about Functional Programming, and I decided to do a lot of games with Elm. And this is my first game. :D What do you think? Well, of course I need to improve it. :P
Well, you *can* do it with JS just fine but you can't do it from Elm using JS interop (ports).
Last commit was two months ago. I'll gladly buy this book when it's finished. I love his presentations. So useful and informative. He has a great presentation style.
I do hope for an independent elm conf in the near future. I think strange loop is cool, but I'm primarily interested in Elm. Maybe next year or so. :D
I made some changes to add delay between the messages and to disable the buttons during the delay http://pastebin.com/FW496qrS
Strange Loop itself typically sells out in an hour or two (!) so it seems there is at least some possibility that the organizers might decide to sell standalone tickets to the Elm preconference, if the main conference sells out and there is still space available for Elmers?
Wish I could go, but TLV-&gt;STL is just too far for me 
There is apparently a twitter account: https://twitter.com/elm_in_action
Well it be possible to just buy tickets for elm-conf (and not Strange Loop)?
Very nice work! The API is nice and simple. Just out of curiosity, is there a reason you decided to return a 3-tuple with `Maybe Date`, instead of providing a way to query the date picker for the currently selected date? For example: update : Msg -&gt; DatePicker -&gt; (DatePicker, Cmd Msg) selectedDate : DatePicker -&gt; Maybe Date That way you could query your datepicker at any time to get the currently selected date. At the end of the day both approaches accomplish the same thing, but I'm curious if you think one way is more "correct" than the other.
This is really fantastic, we needed this! :)
It didn't work for me on the Safari [Version 9.1.2 (11601.7.1)] but it worked on Chrome. Very cool! 
what's wrong with: funct : Option -&gt; Option -&gt; String funct x y = case (x, y) of (Steal, Still) -&gt; "..." (Still, Steal) -&gt; "..." (Steal, Steal) -&gt; "..." (Still, Still) -&gt; "..." ?
Best place to start for elm: http://guide.elm-lang.org/ For FP in general, check out: http://haskellbook.com/. Great book. Better than Learn You a Haskell imo. I have found that a decent foundation in Haskell makes learning elm a breeze. It's kind of like haskell-lite in a lot of ways.
Thank you! I feel like I need to learn fp in general before I appreciate the beauty of elm.
Great and clean work! Thanks.
It seems it's full right now. I don't understand why there is limited capacity for an online event?
Relevant issue https://github.com/jdudek/elm-clipboard/issues/1
I was building this component for a project of mine and decided to generalize it and share!
This was a pleasure to read through. I learned a little elm from you and your implementation is clean. I like that your dependencies are minimal. 
An important feature in Elm is the use of [Union Types](http://guide.elm-lang.org/types/union_types.html), which help define data that doesn't fit into one of the default types. Normally union types are only a name, but they can also include other information, in the first case it is a boolean. From the guide, an example would be: type User = Anonymous | Named String So type *user* could be either *Anonymous* or *Named*, but *Named* also includes a string. When handling these types you could write: update name model = case name of Anonymous -&gt; { model | name = "Anonymous"} Named name -&gt; { model | name = name} -- 'name' is a local variable here, so it doesn't matter what it's called In the view block, you are right in thinking that the checkbox is sending a boolean value. Elm passes that value (of type ShowMeStuff) to the update function to process. The main function is of type [Program Never](http://package.elm-lang.org/packages/elm-lang/html/1.0.0/Html-App), which is another union type that can contain information needed by your program. More information can be found on the guide page, I hope that helped.
Yeah that helps a lot! So ShowMeStuff is a union type, that has a type of Msg and includes a Bool. If someone were to ask me what entities have a type of Msg, would I say: ShowMeStuff, which includes a Bool or would I say: ShowMeStuff Bool
This is a common stumbling block and it relates to understanding the idea of type variable. Please take a look at [Reading Types chapter of The Guide]( http://guide.elm-lang.org/types/reading_types.html). As you can see there, `List String`is a list filled with `String`, `List Float` is a list filled with `Float`. In the same way, `Program Never`is a program that is customized with the type `Never`. Never in this context is like saying "this program Never receive anything as initialization data" . In contrast `Program Size` is a program that receives `Size`as initialization data from JS. To understand the `ShowMeStuff` part take a look at [the chapter on Union Types](http://guide.elm-lang.org/types/union_types.html). In short. `ShowMeStuff Bool` is "a ShowMeStuff tag that contains a Bool". By itself, `ShowMeStuff` is a value constructor, think about it like a function that receives a Bool and produces a Msg **value**. The Msg **value** that it produces is this `ShowMeStuff Bool`. So, you are passing `ShowMeStuff` to `onCheck` and inside the handling of that event, `ShowMeStuff` will be evaluated with a `Bool`in order to produce the Msg that ends up in `update`. 
There's [Mostly Erlang with Evan](https://mostlyerlang.com/2014/03/24/032-elm-with-evan-czaplicki/), [JSJ 175 with Evan and Richard Feldman](https://www.podcastchart.com/podcasts/javascript-jabber/episodes/175-jsj-elm-with-evan-czaplicki-and-richard-feldman), [Functional Geekery 33](https://www.functionalgeekery.com/functional-geekery-episode-33-richard-feldman-and-tessa-kelly/) with Richard Feldman and Tessa Kelly, my [Functional Geekery 42](https://www.functionalgeekery.com/episode-42-claudia-doppioslash/), also [Changelog 191](https://changelog.com/191/) with Richard Feldman again, [Ruby Rogues](https://devchat.tv/ruby-rogues/212-rr-elm-with-richard-feldman-and-evan-czaplicki) with Evan and Richard. 
Many kudos to you for the architecture introduction! When I first saw Elm, my thoughts were "ahh but I have no idea how to structure apps with purely (well, almost) functional languages" ... and I was somewhat worried that I'd lose a lot of time that I currently don't have on my hand, while trying to build something simple, yet useful. Seeing many introductions such as yours, I feel like I have a lot more support and resources than I thought! Thanks a lot! :)
More details about what the meetup will be covering here: https://www.bigmarker.com/remote-meetup/1-Elm-Remote-Meetup-by-DailiDrip
Hey, is this website loading all this content from package.elm-lang.org every time someone visits the website? Or is the search done on your servers? Or the data is served from your servers?
Oh, thank you for sharing too! ... and for the author, well I hope he will see these comments :)
Hope you all enjoy it, I can't attend.
&gt; I thought Elm was a pure, functional language, but this is one hell of a side effect. \*groan*
I've had this kind of experience where I start some change... get a bunch of compiler errors and then continue the change and the compiler errors keep piling up to a point and then, little by little they are solved. Few hours later I have no compiler error and I haven't seen the app running for few hours. My mind goes "Ok, there are no more errors and the app should be running fine... but it can't just run fine from the first try, can't it?".... and the app runs fine from the first try. This is insanely great. :) 
Whenever I get an Elm program to run correctly on the first try, my first reaction is "Oh no, what's wrong with it!?" ... and then I remember I'm writing Elm :) 
Ya, I struggled with this too. If you look at the earlier `0.16` versions of the package, you'll see there was a concept of a dynamic list of items. I finally determined in `3.0` that there need not be a new API. If I provide an interface for you to set the list of items, any asynchronous behavior can be handled in your Elm program, and `Autocomplete.setItems` can be called with the result! See [here](https://github.com/thebritican/elm-autocomplete/blob/master/examples/src/RemoteExample.elm) for a remote example!
&gt; I listen to a lot of podcasts would you mind sharing a few? I don't know what to listen to
What are your interests?
frontend and functional things mostly
It's possible to screw this up in Elm too: ``` type alias Model = { things : List Thing , loading: Bool } ``` I made a lot of these types of "mistakes" when I first started using Elm. 
:-D In Elm, I'll bet you can fix it up again in an afternoon. ;-)
Ah yes, avoiding [the billion dollar mistake](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare) (i.e. allowing all types to be `null`). Not unique to Elm, but unfortunately not that common in widespread languages (yet), and any language that does not succumb to it at least has that going for it :)
To be honest, I usually still tend to store a loading flag in Elm instead of `Maybe (List Thing)`. The app isn't in a loading state very often in the code, so you're always unpacking that maybe even though it's usually the `Just` branch. More importantly, you often have a loading state that can be true even though you're, say, still showing the old data on screen. At which point your code might start checking if `things` is `Nothing` to see if the app is loading even though it doesn't actually care if there are any `things`. Nobody is wrong here, just thinking out loud. Sometimes turning something into a `Maybe` is all you need and most elegant.
I love your https://github.com/Bogdanp/elm-combine library. Learned a lot porting it to Swift, though I got lost in custom operator precedence. I'm curious how often that happens to people used to custom operators (Haskell) or if it's distinctly an issue for beginners.
Man, change the background its attacking the eyes! Bootstrap, nice tiles, whatever, but not those lines.
My preferred solution is to have a state type for the component itself, not the data, because it makes the data harder to work with. type State = Loading | ... type alias Model = { state : State } Most of my components are usually only loading once if they don't get their data from the parent. Background refreshes I don't show to the user at all.
You probably want to wrap it all up in a `let ... in ...` block.
Thanks,
Ahhh I see what you're saying. Thank you!
It's also worth mentioning that in Elm, we call these *tagged union* types.
Also useful inside `let` where you can just stack it tall with shit. let newModel = List.map ... model _ = Debug.log "x" x _ = Debug.log "y" y in ... I love me my console.log debugging.
When writing javascript, I always start with case and have to look up how to type the switch statement. I should switch to elm :D
Fair enough, and the article probably wasn't written with Elm in mind, which is fine! I just didn't want people here to wonder why their `data` declarations weren't working in Elm.
Yep, exactly. But jmite is right - it's unnecessarily confusing. Elm's ADTs are just as clear as Haskell's. I've updated it to just use Elm.
&gt; I should switch to elm I see what you did there
I wrote something similar as a learning project: https://github.com/crackofdusk/breakout
Nice! Thanks for having everything in one file, it makes it really easy to understand. I'm impressed - just over 300 lines of easy-to-read code for a breakout prototype. That's pretty close to what the same as JavaScript would be, so it really demonstrates how much better Elm has become for prototyping.
Why did you choose webpack instead of brunch? Is that because the prior video uses brunch?
I historically preferred brunch. For react apps, webpack was much nicer for hot loading reasons. I can eventually get to that with elm via webpack. Hot loading makes development so much faster.
Agreed. I was wondering, because phoenix+brunch+elm gave me hot reloading with basically no effort :)
Great job!! 
I'm new to elm and I found writing decoders vexing at first, but I've realized that it pays off big time to let the compiler make guarantees for you about incoming data. It's the tradeoff you make for never having the "oh man this value can be null?" moment... Also check out https://github.com/NoRedInk/elm-decode-pipeline , some helpers for writing decoders. I find it less verbose.
It is not done on servers. Github hosted web sites do not allow running your own code on servers.
the map signature is `(a -&gt; b) -&gt; List a -&gt; List b`. I'm not sure complex algorithms it implements. As for myself, I have no idea what you re talking about. This is not my project. I just posted the link. :)
https://crackofdusk.itch.io/breakout 404
yep, you can now!
Thanks, the page was private. I fixed that. The game itself is really boring, but I got to learn some basics about game physics and I tried elm-check.
If you want to it happen immediately I imagine you can just recursively call your `update` function from there. Gather any returned side-effects and return them as well. Otherwise you might be able to dispatch some kind of `Cmd` which just comes back around and calls `update` again but there is little point in that unless you have side effects. I might be missing something though! 
The keys seem to go in the opposite direction? I press left arrow expecting to go left, it goes right..?
You *can* actually have a Dict that contains Dicts: Dict k (Dict k' v) But that still wouldn't help with JSON decoding. The problem with representing a JSON object as a Dict is that a Dict needs to have the same type for all values. So if the JSON object only has strings for values, great, a Dict would work, but most JSON objects in the wild contain a mix of numbers, booleans, strings, null, and other objects.
See [elm-update-extra](http://package.elm-lang.org/packages/ccapndave/elm-update-extra/2.0.0/Update-Extra). `:&gt;` or `sequence` seem to be what you want.
Helper function: msgToCmd msg = Task.perform (always msg) (always msg) (Task.succeed ())
side note, can't thank you enough for letting me know about the figwheel update. the new error messages are...so much better.
I have a rule of thumb for this kind of thing: The longer people debate two options, the less important it is to choose between them. The reason we spend so much time talking about Static vs Dynamic typing is because neither choice is really much better than the other. If one really was much better then we would choose that one and move along. This also means that if at some point you decided "I think dynamic is the way to go" and you never considered static typing (because, well dynamic is clearly better, right?) you maybe be missing out on the benefits of static typing in the scenarios where it does actually give you more than dynamic. In other words, there are times when dynamic is better and static is better and it's wrong to think you need to pick one once and stick with it. See bike-shedding or the law of triviality: https://en.wikipedia.org/wiki/Law_of_triviality
Thanks for your suggestions, everyone! By "recursively call the update function" do you mean something like: ![ update NextThing model ] In my real application, I get an error message that looks like this: (!) is expecting the right argument to be a: List (Cmd a) But the right argument is: List ( ThisModule.Model, Cmd ThisModule.Msg ) It looks likes it the complier just needs the second part of that tuple. But, how do I extract it? 
[String.concat](http://package.elm-lang.org/packages/elm-lang/core/4.0.1/String#concat) and [String.join](http://package.elm-lang.org/packages/elm-lang/core/4.0.1/String#join) are what you're interested in.
I would have said "prototyping", for rapid development. But having tried Elm now I genuinely think that its typing forces me to make fewer silly runtime mistakes that end up being a time-sink - so I'm struggling to answer you.
 type alias Update msg model a = model -&gt; ((model, Cmd msg), a) map : (a -&gt; b) -&gt; Update msg model a -&gt; Update msg model b map f u model = let (r, a) = u model in (r, f a) noOp : a -&gt; Update msg model a noOp a model = ((model, Cmd.none), a) andThen : Update msg model a -&gt; (a -&gt; Update msg model b) -&gt; Update msg model b andThen u f model = let ((model', cmd), a) = u model ((model'', cmd'), b) = f a model' in ((model'', Cmd.batch [ cmd, cmd' ]), b) updateModel : (model -&gt; model) -&gt; Update msg model () updateModel f model = ((f model, Cmd.none), ()) runCmd : Cmd msg -&gt; Update msg model () runCmd cmd model = ((model, cmd), ()) type alias ChildFocus pmsg cmsg parent child = { extract : parent -&gt; child , insert : child -&gt; parent -&gt; parent , wrapMsg : cmsg -&gt; pmsg } updateChild : ChildFocus pmsg cmsg parent child -&gt; Update cmsg child a -&gt; Update pmsg parent a updateChild cFocus cUpdate parent = let ((child', cCmd), a) = cUpdate (cFocus.extract parent) in ((cFocus.insert child' parent, Cmd.map cFocus.wrapMsg), a) Now type alias Child = Int type Msg = AskConfirmation type OutMsg = ShowPopup | NoSignal type alias ChildUpdate a = Update Msg Child a update : Msg -&gt; ChildUpdate OutMsg update msg = case msg of AskConfirmation -&gt; noOp ShowPopup type alias Parent = { child : Child } type Msg = ChildComponentMsg Child.Msg cFocus : ChildFocus Msg Child.Msg Parent Child cFocus = { extract = child , insert c p = { p | child = c } , wrapMsg = ChildComponentMsg } type alias ParentUpdate a = Update Msg Parent a processSignal : Child.OutMsg -&gt; ParentUpdate () processSignal signal = case signal of NoSignal -&gt; noOp () ShowPopup -&gt; noOp () -- should have real implementation update : Msg -&gt; ParentUpdate () update msg = case msg of ChildComponentMsg childMsg -&gt; updateChild cFocus (Child.update childMsg) `andThen` processSignal And if you're willing to say the word "monad" it all goes smoothly.
I'm a big fan of the monad. I worry though that all the type-aliasing would take away from clarity. I'd have to try it out (I will), but most of the routing code (updating the parent with the child ect) only needs to be done once. Maybe this changes when you have multiple children exposing OutMsgs. food for thought/experimentation, thanks! 
I'm a big fan of the monad. I worry though that all the type-aliasing would take away from clarity. I'd have to try it out (I will), but most of the routing code (updating the parent with the child ect) only needs to be done once. Maybe this changes when you have multiple children exposing OutMsgs. food for thought/experimentation, thanks! 
Maybe someday soon we'll get type classes, though it might be overkill for elm. It is pretty annoying to need to map everything explicitly, I agree here.
/u/ChavXO You ever get anywhere with this?
What about https://github.com/joaomilho/act ?
`!` is a function that takes a model and a list of Cmds and returns a (Model, Cmd) where the Cmd is the composition of the list of Cmds provided: http://package.elm-lang.org/packages/elm-lang/core/4.0.0/Platform-Cmd#! edit: Apparently reddit eats the formatting on that link but it's at the bottom of the page.
Thats convenient! Thank you!
Thank you!
Wouldn't the code need to be `! model []`
`!` is an infixe notation so no, it must be inserted between the two arguments.
You can write it like `(!) model []` and it will work as expected. Functions declared between parentheses and made of valid symbols can be used inline. For example, you can define your own bitwise shifts like this: import Html exposing (..) import Bitwise exposing (shiftLeft, shiftRight) (&lt;&lt;&lt;) = shiftLeft (&gt;&gt;&gt;) = shiftRight main = text &lt;| toString &lt;| 2 &lt;&lt;&lt; 3 &gt;&gt;&gt; 3 
I like this solution but I'm unsure of how to implement this pattern if you pull update functionality into multiple files. Imagine you have a core update function in Update.elm that delegates more specific update logic to UpdateMenu.elm and UpdateCart.elm. So Update.elm's update function takes a Msg MenuMsg and, after importing the UpdateMenu.elm's update function, calls the imported update function with MenuMsg. How do you, then, call sub update functions from other sub update functions without running into circular dependency errors. If UpdateMenu wants to call UpdateNav AND UpdateNav wants to call UpdateMenu, you'll get a circular dependency issue. 
Is there any reason this can't be done with explicitly passing around the typeclass implementation? Why are typeclasses necessary, other than as a nicety over higher-order functions? Or is this one of the cases that requires higher-kinded polymorphism?
In my limited experience in programming in general, circular dependencies are generally bad. You should always try to straighten them out rather than find a language or infrastructure that attempts to support them. Generally speaking if you have two components that need to talk to each other you move all of the logic that concerns both up to a separate parent component that can oversee both sub components. Only the pure logic regarding each component is kept with that component. Circular dependencies often arise but are normally signs of poor architecture with mixed concerns (if I can be bold enough to say!) I'm sure exceptions exist but I've not encountered a convincing one. Plus in general for the Elm architecture you shouldn't think in terms of `Update.elm`, `UpdateMenu.elm` &amp; `UpdateNav.elm` files but rather `App.elm`, `Menu.elm` &amp; `Nav.elm` files each of which contain the relevant `model`, `update` &amp; `view` for each component.
Good question. Elm HTML API does feel alien if you're used to HTML and HTML-like template engines. Even Ruby's Slim templates are closer to HTML than Elm's HTML API. I wouldn't expect designers to break down their HTML markup into Elm components - that's a developer's job. Same case with React's JSX, or Ruby's HAML/SLIM/ERB. For small tweaks and such designers could use something like http://mbylstra.github.io/html-to-elm/ and then copy parts of the output into the real Elm code. This is by no means a solution, but it could help.
&gt; I wouldn't expect designers to break down their HTML markup into Elm components - that's a developer's job. Same case with React's JSX, or Ruby's HAML/SLIM/ERB. For small tweaks and such designers could use something like http://mbylstra.github.io/html-to-elm/ and then copy parts of the output into the real Elm code. Thanks for that cool/useful link! ~~Still, I don't think that's a solution that would catch on.~~ Sorry, somehow didn't see this: &gt; This is by no means a solution, but it could help. I'm guessing the innovative community behind Elm could figure out something. :)
There's [elmx](https://github.com/pzavolinsky/elmx), like JSX for Elm. I really like it a lot. It compiles the html in `.elmx` files into `Html` functions. Other than a few bugs that I reported that were quickly fixed by the owner (yay), I have been really enjoying it. It's changed how I use Elm, and I'm more likely now to use it in a production environment where most of the HTML and CSS are written by "non-coding" designers.
A nice tip I read yesterday (I'm new to FP!) is that if a function name is exclusively non-alphanumeric then it is infix by default, and referred to with parens on import or to use it as a normal function. e.g. to import the &lt;/&gt; "operator" from [UrlParser](http://package.elm-lang.org/packages/evancz/url-parser/1.0.0): import UrlParser exposing (Parser, (&lt;/&gt;), format, int, oneOf, s, string) Another example is comma being used as a function: (,) 1 2 -- same as (1, 2) (,,) 1 2 3 -- same as (1, 2, 3) I guess this is part of what makes Elm/Haskell nice for DSLs.
I second this!! Really, it's only going to take an experienced designer a few minutes to understand Elm's HTML. It's more logical, consistent and less verbose than HTML itself - or JSX for that matter, which is even worse. And, if your designers like CSS - they can just use ordinary CSS or SASS files. 
If you want to try it quickly, I have an elmx webpack hotloading starter kit: https://github.com/bbugh/elmx-hot-loader-starter Just clone and change `Main.elmx` to get started. Instructions are in the README.
You could desugar the haskell implementation (which passes around a record with the implementations), but that kind of defeats the purpose. It also wouldn't work right now because of lack of higher-kinded polymorphism. Even if it could, the goal is to remove boilerplate, not introduce it. 
Maybe you're looking for something like https://github.com/evancz/focus Anyway, with a good modular architecture, you shouldn't have to modify a deep field often in your model. `{ model | essay = { model.essay | markdown = newMarkdown } }`
All tough I would very much like to see Elm target something that runs somewhere else then the browser, a possibility for now is to create an normal Elm app and package with Cordova or something similar.
Oh, it works!!! Thanks for that :) 
Json.Encode is definitely what you want to use (in my opinion). I think there is a function in the module called object that will help you encode an object given you tell it how to encode each property. I'm on mobile so I won't write an example, but I hope this helps.
Thanks, this really helped. I was struggling to get it to trigger the `ShuffleDeck` message from another context, the compiler did not like me. Breaking the action out into the `shuffle` method like you did and then exporting that so that it was available in the main scope did the trick.
Thanks, yeah this is definitely the most I've dug into a functional language so I'm still getting used to thinking about things a little differently. 
You've picked the best language to get into functional programming. ;) Remember to be kind to yourself. You will get better soon enough. ;) 
Awesometastic, cheers buddy :)
No. I tried starting with WebGL but it wasn't very well documented and it was prior to the switch to 0.17 - so no on was sure on the state of the package or something.
I like that you used the word unambiguously. That's what tripped me up with Json.Encode. I was looking for a more ambiguous way of converting a record into JSON. I just wanted to toss an object into a function, regardless of its properties and get a JSON object. It's interesting how this whole process is a little more complicated since its a strongly typed language. I noticed JAVA has to do the same thing. Pros and Cons I guess. I think the pros outweigh cons like this though. 
Okay, here's some feedback. I think you've removed important parts without understanding what they do or why they're important. Your architecture's "strengths" you list are actually it's weaknesses. One of the great advantages of the Elm Architecture is that it allows any component to be reused as a child component of another component. That seems to be something this punts on. `onClick (MsgCart (AddItemToCart item))` from Cart's view: Cart's view is coupled to the event type for the whole app. This must be changed when the Cart is reused in another project. And what if you want to nest multiple Carts (or substitute a thing that would appear on a page more than once)? I guess the second cart would need to have something like `onClick (MsgCart2 (AddItemToCart item))`. What if Cart is only component? Then you need an event type with that `MsgCart` for no reason. The views are also coupled to the model type for the whole application, so you'll the same problems for that reason as well. The update functions for Cart and Menu both take a `Model` and update a field within that `Model`. This makes the update functions less reusable. Again, what if your page has more than one Cart or more than one Menu? Well, you'd need two copies of the file so one can `{ model | menu = ... }` and the other can ` { model | menu2 = ... }`. Or you come up with some scheme that means the component is aware it belongs to collection of components, which makes it silly if it's the only instance. As a rule of thumb, I think you're probably going the wrong way if you're trying to get rid of `map`. It's a very useful function that allows you to separate knowledge of a container from knowledge of what's inside the container and vice versa. The things I identified mainly fell out when I thought about what `map` is meant to accomplish. FYI: The demo seems to be down at the moment. `Model: { user = { name = "", money = 0 }, cart = { items = [], total = 0, isLoading = False, isLoaded = False, hasError = True }, menu = { items = [], storeId = 0, isLoading = False, isLoaded = False, hasError = True }, location = { path = ["menu"], query = Dict.fromList [] }, route = MenuRoute }` is what I get after it loads.
Neat library! However, I hope that native string interpolation is included in a future version of elm. 
Most of what you want is in fact possible in a statically typed language that supports type-driven metaprogramming. AFAICT, Elm tries to be as simple as possible and that obviously implies trying to avoid metaprogramming, but all the usual suspects (Haskell, OCaml, Scala) have such features. Here's an OCaml example using [ppx_deriving_yojson](https://github.com/whitequark/ppx_deriving_yojson) to autogenerate the `foobar_to_yojson` function: type foobar = { foo : string } [@@deriving yojson] let () = { foo = "bar" } |&gt; foobar_to_yojson |&gt; Yojson.Safe.to_string |&gt; print_endline Though I can't name a statically typed language that allows you to do this exactly as you asked, without an explicit type definition.
I found this super helpful! Thank you for writing! I did get confused by one thing: the backticks around `andThen`. I know it's a standard thing, but it took me a bit to figure out. The first place I found that described in detail was here: http://stackoverflow.com/questions/27441648/what-does-the-operator-mean-in-elm "Elm's Type System" (which also very helpful). In any case, thanks for writing and posting.
Are you talking 'hot reloading' or just 'reload the page on change'? Because I've not seen brunch + elm hot reloading at all
Here's an example of how I might do it: A root `Recv String` Msg that decodes the incoming payload strings and then dispatches the decoded result to dedicated handlers that are also defined in the update function. Haven't run it or anything, it's just an idea. import Json.Decode as JD exposing ((:=)) import Date import Debug -- TYPES type alias User = { id : Int , uname : String } type alias Message = { id : Int , user : User , text : String , createdAt : Date } -- UPDATE type Msg = NoOp -- This receives all messages | Recv String -- ...And route them to these | RecvUserJoined User | RecvUserLeft User | RecvNewMessage Message | UnexpectedPayload String update : Msg -&gt; Model -&gt; (Model, Cmd Msg) update msg model = case msg of NoOp -&gt; (model, Cmd.none) Recv payload -&gt; let nextModel = { model | payloads = payload :: model.payloads } nextMsg = decodePayload payload in update nextMsg nextModel RecvUserJoined user -&gt; let _ = Debug.log "user joined" user in (mode, Cmd.none) RecvUserLeft user -&gt; let _ = Debug.log "user left" user in (mode, Cmd.none) RecvNewMessage message -&gt; let _ = Debug.log "new message" message in (mode, Cmd.none) UnexpectedPayload error -&gt; let _ = Debug.log "unexpected payload" error in (mode, Cmd.none) -- DECODERS dateDecoder : JD.Decoder Date dateDecoder = JD.string `JD.andThen` &lt;| \string -&gt; case Date.fromString of Err _ -&gt; JD.fail "Invalid date" Ok date -&gt; JD.succeed date userDecoder : String -&gt; JD.Decoder User userDecoder = JD.object2 User ("id" := JD.int) ("uname" := JD.string) messageDecoder : String -&gt; JD.Decoder Message messageDecoder = JD.object4 Message ("id" := JD.int) ("user" := userDecoder) ("text" := JD.string) ("created_at" := dateDecoder) -- Here's our root decoder that should be able to decode all -- incoming payloads. -- -- Example of our expected payloads: -- -- { "kind": "user_joined", "user": { "id": 42, ... } } -- { "kind": "user_left", "user": { "id": 42, ... } } -- { "kind": "new_message", -- "message": { -- "id": 2 -- "user": { "id": 42, ... }, -- "text": "hello", -- "created_at": "2016-06-22T01:49:09.676Z" --- } -- } payloadDecoder : JD.Decoder Msg payloadDecoder = -- Use the "type" key to determine which decoder to use. ("kind" := JD.string) `JD.andThen` &lt;| \kind -&gt; case kind of "user_joined" -&gt; JD.map RecvUserJoined ("user" := userDecoder) "user_left" -&gt; JD.map RecvUserLeft ("user" := userDecoder) "new_message" -&gt; JD.map RecvNewMessage ("message" := messageDecoder) _ -&gt; JD.fail ("Unexpected kind " ++ kind) -- And here's the actual function that uses the decoder to turn incoming -- payload strings into a Msg. decodePayload : String -&gt; Msg decodePayload payload = case JD.decodeString payloadDecoder payload of Err err -&gt; UnexpectedPayload err Ok msg -&gt; msg 
curious if you found this: https://github.com/fbonetti/elm-phoenix-socket Also, I've got a branch where I'm implementing Presence support for the upcoming Phoenix release. https://github.com/knewter/elm-phoenix-socket/tree/feature/nested_records (the branch name is dumb, it'll be renamed before I open a PR)
Another important point is lack of side effects, which is not enforced.
Hello again, I'm not going to comment on the components that are not reusable. It's a valid point that not all components need to be reusable, but it doesn't really advance anything. We don't always want reusable ui components, but we do sometimes want reusable ui components and the Elm Architechture is a blueprint for that. I also don't want to discourage you. I'm just trying to give feedback on problems I see, and I think nice modular reusable ui components are a surprisingly thorny problem. Now, here is the problem with your reusable component strategy. Counter is a good example. You are providing Msg hooks for increment and decrement, which means we are free to provide an implementation for those Msgs. This isn't great. This means that every application has to implement their own add 1 and subtract 1, perhaps multiple times. And other components may have a lot more than just two Msgs to implement. You could provide library functions for that (let's pretend for something more complicated than counter), but then you have to match those messages and call that function. This starts to at least feel like the kind of boilerplate we're trying to avoid. I would also argue that we're more likely to reuse a component's logic and change how it's rendered; this is optimized to reuse rendering. Another criticism, this requires the parent view to know a lot about how the child component works. The cart also has hooks for Msgs, but it's not very reusable for many of the same reasons as last time. Its update function basically expects the model for the whole project to have a certain field, messages from commands are hard coded.
To make the intention of the communication from the child back to the parent more explicit, I would recommend using a separate type for the messages that the child passes back to the parent, e.g.: type Msg = Allowance Float | Candy type Effect = BorrowMoney Float update : Msg -&gt; Model -&gt; ( Model, List Effect ) update msg model = case msg of Allowance amount -&gt; ( { model | money = model.money + amount } , [] ) Candy -&gt; let money = model.money - 5 in ( { model | money = money } , [BorrowMoney (min money 0 |&gt; abs)] )
Thank you! This is totally right. I've gone ahead and updated the article to give that responsibility to the parent -- this allows for a much nicer summary of how the pattern works, too: &gt; Essentially, the parent tells the child how it would like to receive communication. The child returns a custom “translator” to the parent, which translates child messages into parent messages. Then, instead of *tagging* child-generated messages as they are created, the parent *translates* them using this translator. The translator acts as a “smart tag” — rather than tag every child-generated message as being just-for-the-child, the translator recognizes that some messages are meant for the parent, and routes them there directly. Thanks for reading and for the feedback!
Yeah, I find it's a tradeoff. Right now it feels like the most clear way of coding in Elm requires a ton of boilerplate code. However, I'm hoping that if we find strong patterns for handling most situations that just involve boilerplate, we might be able to create tools that simplify generating that code.
I figured that I was giving the counter view more flexibility by making its msgs implementable by the parent, but I see your point. That view in particular probably doesn't need to be flexible anyway. And its true that as a view gets more complex, the amount of stuff I'd be passing in could get out of control. Well I'm gonna port this over to the typical elm architecture and see what happens.
First off thank you, this is really well done. I really liked the comments guiding me to which file to look at next, I actually wish you kept going for a bit longer. I like the approach that you took at trying to build something more "real-world". As someone coming from the javascript world this is much needed. There are tons of proof of concepts out there, but it rarely translate into something that I could be using at work. If you are looking for suggestions, here is what I would love to see: * Pagination if there are more than 10 todos * A router that takes me to another page, with a completely different context (so nothing to do with todos). Maybe something like "my profile", where I can select an avatar, update my email, first name and last name, password etc. * A basic many-to-many scenario: On one screen I can create "modules", on another screen I can create "courses" and attach "modules" to it. I realize that some of the above features involve quite a bit of back-end work, but these are things that I get paid to build. The last time I got paid to build a little mario game or a rotating clock was... never. I know that I'm repeating myself but thank you for trying to build something more real world. I believe that it would help a lot of devs coming from other languages to not only feel more at home, but to also see the value in elm. On that note, if anyone else is interested in more "real world" elm, I think that this blog series is awesome: http://rundis.github.io/blog/tags/haskellelmspa.html
Thanks so much for the great feedback. I just added a nice roadmap for checking out the code to the readme. Having an edit profile is a good idea! I'll add that some time soon. I would really like to add routing...I'm just not sure if it will distract from the essential parts of the app (like Main and Update) by introducing harder-to-understand concepts (like Result and Navigation.Parser). Something to think about. This is my first elm app myself...I might just clone it and make something in the same vein but with everything you mentioned. Looking through builtwithelm.co there doesn't really seem to be a straighforward crud app with routing/pages like you mentioned.
Are you sure model.loading is False? It didn't work for me when model.load was True but then it worked when I made it false. Heres the full code: import Html exposing (..) import Html.App as App import Html.Events exposing (..) main = App.program { init = init , view = view , update = update , subscriptions = subscriptions } type alias Model = {loading: Bool } init = (Model False) ! [] subscriptions model = Sub.none type Msg = LoadNextPage | ScrollBottom view model = div [ ] [ button [onClick LoadNextPage] [text "Load Next Page"] , button [onClick ScrollBottom] [text "Scroll Bottom"] ] update msg model = case (Debug.log "Update" msg) of ScrollBottom -&gt; if not model.loading then update LoadNextPage model else (model, Cmd.none) LoadNextPage -&gt; (model, Cmd.none) 
I took the code from the url-parser example and split it across multiple files. I put the routing stuff in Router.elm, the `viewLink` and `words` widgets in Widgets.elm and I created 2 very simple pages with very basic, classical Elm Architecture code. https://gist.github.com/pdamoc/b383bdccf837dc2ad84955f75406cfbd 
I'm a little wary of generating code, actually. Most of what we need for this can be expressed in the type system. Once we're generating code, it doesn't seem a lot different from copying/pasting. OTOH we don't have a timeline for either macros or type classes, so code generation may be a useful intermediate step. I just think it's playing with fire.
Thanks again for the help guys. Here's the latest iteration. I rebuilt it from the ground up with the typical elm architecture src: https://github.com/pinksalmon/elm-online-store app: http://zachwilliamson.me/#/
How would the child handle messages that concern both the child and its parent? For example, i'm writing a login component. I'd like the parent to handle the effects (like POSTing the login request) while the component only renders its model. When I press login, I want the parent to make a request, and the component to show a loading animation. Would this be possible without using commands in the child?
You mentioned in the post that you tried having the child `update` create a `Cmd` to send the message, but what did you have the parent doing in that case? The parent needs to propagate that message back up. This should work; I have done things like this. On the other hand, if you are always going to communicate `LoadNextPage` events to the parent, it might be better to do something like [this recent post](https://www.reddit.com/r/elm/comments/4pja55/candy_and_allowances_parentchild_communication_in/). This way, the child explicitly tells the parent when it wants a page loaded, and the parent doesn't have to know anything about the internals of the child to do it. module Child (...) type Response = None | LoadNextPage type Msg = LoadButton | ScrollBottom update : Msg -&gt; Model -&gt; (Model, Cmd Msg, Response) update msg model = case msg of LoadButton -&gt; (model, Cmd.none, LoadNextPage) ScrollBottom -&gt; (model, Cmd.none, if not model.loading then LoadNextPage else None) And in the parent module Parent (...) type Msg = ChildUpdate Child.Msg | (...) update : Msg -&gt; Model -&gt; (Model, Cmd Msg) update msg model = case msg of UpdateChild childMsg -&gt; let (child', childCmd, response) = Child.update childMsg model.child (model', cmd) = handleChildResponse response { model | child = child' } in (model', Cmd.batch [ Cmd.map ChildUpdate childCmd, cmd ]) (...) handleChildResponse : Child.Response -&gt; Model -&gt; (Model, Cmd Msg) handleChildResponse response model = case response of Child.None -&gt; (model, Cmd.none) Child.LoadNextPage -&gt; -- Load next page logic goes here (`Response` may not be the best name to use.)
I am using Elm and Erlang (Webmachine) in http://squaretarget.rocks But in this case I had been using Erlang for several years, before I started with Elm. I find that they work really well together and I am very happy with the results. I have found Erlang + Dialyzer with tuple types provides at least some of the benefits of static typing in a language I already know. 
Our war is functional vs imperative- we called truce on the static/dynamic type squabble to fight the real enemy!
What makes you use Elm over Purescript?
Also, Elm 0.17 [had some inspiration](http://elm-lang.org/blog/farewell-to-frp) from Erlang and Elixir as well. &gt; That release also introduced a scheduler that was able to switch between work whenever it wanted. Elm 0.17 improves this scheduler quite significantly, taking some basic insights from the BEAM VM used by Erlang and Elixir.
I hope it does. I read a mailing list thread a while ago in which they claimed they would implement typeclasses or something to fill the same role. And I would like to have do notation. I like that Elm does not require you to understand monads to get started, but the fact is they do make some things a lot cleaner, and the \`Module.andThen\` \blah -&gt; pattern is clunky and tedious.
[**@dailydripcom**](https://twitter.com/dailydripcom): &gt;[2016-06-27 20:49:59 UTC](https://twitter.com/dailydripcom/status/747532452818718720) &gt;Our second Elm Remote Meetup is coming July 11 at 1800UTC! More here: [*dailydrip.com*](https://www.dailydrip.com/blog/elm-remote-meetup-2-is-coming) ---- [^[Mistake?]](/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/4qcc79%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/joealcorn/TweetPoster) [^[Issues]](https://github.com/joealcorn/TweetPoster/issues) 
&gt; Since the removal of record-field addition/deletion support, has there been any usable patterns to simulate ad-hoc overloading? I'm confused (and interested). How did that support enable ad-hoc overloading?
Well, you can do it [this way](http://www.haskellforall.com/2012/05/scrap-your-type-classes.html). But it isn't pretty. (This is written from a Haskell point of view, but works just as fine in elm) I wish there was something like function overloading by type or interfaces or both.
It's not truly ad-hoc; I mis-said that. Basically, there was [this](https://groups.google.com/forum/#!searchin/elm-discuss/record$20passing/elm-discuss/lUJG35HE6xg/ao1YpFRmySkJ), which I wasn't around to witness (only started using Elm a while ago and read that thread a week ago). Even with extensible records, Elm didn't fully support a 'Scrap Your Typeclasses' approach. I _want_ ad-hoc overloading; extensible records had provided something close but not quite.
I'm familiar with this only (https://groups.google.com/forum/#!searchin/elm-discuss/record$20passing/elm-discuss/lUJG35HE6xg/ao1YpFRmySkJ). Is the pattern actually implementable in current Elm?
Can you tell us what you want to do, other than "I want ad-hoc overloading". Why do you want it? What code is currently ugly without it? This will both help us find a solution currently possible in Elm (if one exists), and inform future decisions about type system changes. But features will never be added without concrete use-cases and examples.
Not to mention, it insists that its functions be total, so unless you have infinite recursion or explicitly call `Debug.crash` you won't get runtime errors.
I'm going to cheat* and use a [generic list-chunking function](http://package.elm-lang.org/packages/krisajenkins/elm-exts/25.7.0/Exts-List#chunk). Then it's just: import Exts.List exposing (chunk) import String formatCreditCard = toString &gt;&gt; String.toList &gt;&gt; chunk 4 &gt;&gt; List.map String.fromList &gt;&gt; List.intersperse "-" &gt;&gt; String.concat And at the REPL: &gt; formatCreditCard 1234123412 "1234-1234-12" : String &gt; formatCreditCard 123412341234 "1234-1234-1234" : String _* Disclaimer: It's not cheating, it's reuse!_
Useful do-notation requires some means of using different `andThen`s in different contexts. But not neccessarily type classes, yes. It has just occured to me that [local imports](https://github.com/elm-lang/elm-plans/issues/5) could be nicely combined with `do` for full explicitness and minimal verbosity: `Maybe.do`, `Task.do` etc.
Yeah this is my favorite method
I don't understand the fold functions yet but I had a hunch that they could be used to solve this problem. I should probably learn how they work.
I'm also a subscriber and it's excellent - the best place to currently learn Elm in a structured and comprehensive way. The only thing however is that it's not for true beginners. You'll need to already have some programming experience (in some other language) and need to have at least a basic grasp of Elm's [syntax](http://elm-lang.org/docs/syntax) and architecture. If you worked through most of the examples [The Elm Architecture Guide](http://guide.elm-lang.org/architecture/) and more-or-less get what's going on, you'll be in a good position to start with the Daily Drip's videos.
Thanks, I guess this kind of memoization can help. I wonder if with really big apps just the size of the structure returned by view can impact latency negatively (especially when there's need for frequent tiny changes).
I'm just guessing that maybe when arguments rarely repeat, with a lot of calls it can eat some memory.
Awesome! I was looking for some go board implementation, and now in Elm, and under MIT, thank you! For those looking for the elm source, [here](https://github.com/ajhyndman/go-react-redux-elm/tree/elm/src) is the elm branch.
I think there's a key insight that allows this approach to work so well, and has propelled it to popularity in React and its derivatives in the present day: The amount of time that browsers spend operating on pure data in memory is trivial, even for large sets, compared to the time it takes to read and write to the real DOM. Here are some benchmark numbers stressing the paradigm with interesting data sets. https://auth0.com/blog/2016/01/07/more-benchmarks-virtual-dom-vs-angular-12-vs-mithril-js-vs-the-rest/
I've also had same situation. I had to sink down the Msg coming from the port in my main module to the child module.
Yup, just came across Sub.map and that definitely solved the problem.
Click the timer for secret undo!
That's a bit late now...
Noob question: if you need referential cycles, what do you do?
This is great! Thank you for sharing, and writing up! Weirdly, clicks are not registering in Safari for me (though they work in Chrome) -- is that just my computer?
Well done, it's nice and polished. I agreed with all your insights as well.
Thanks!
Do you plan to continue to use Elm or was it just an experience?
Hey, thank you for the link. I'm really still getting the hang of live coding, so any feedback is greatly appreciated. I'm also not on a regular schedule -- if you'd like updates, I'd recommend following on http://twitch.tv/codetherapy or the YouTube channel at https://m.youtube.com/channel/UCDShi-SQdFVRnQrMla9G_kQ? -- I'm hoping to experiment with YouTube's live streaming feature soon. From my experience with other people's streams, it's definitely more fun to catch them live, although the recordings have the advantage of letting you fast forward the 40 minutes it took me to understand functors and Random.Generator...
Hmm, can't you just add the effects after the update? let (model'', fx'') = update UpdateMarkdown model' in model'' ! [Cmd.map UpdateQuestions questionsFx , fx'']
Thanks. Yeah I've wasted way too much time on this game so the secret undo was cathartic for me.
where are the multiple views in the TODO app?
1. Speak louder if you can, be more assertive when you talk, it'll make it less frustrating to watch. 2. State your purpose at the beginning of the video more clearly "Today I'm learning Elm by building $this" 3. Show a bit of emotion, you're not a robot, dont be scared to laugh at your own jokes. 4. Structure the video before hand, like an elm program.
https://github.com/MichaelCombs28/elm-journal Here's the git as I build it
Thanks! I agree with you on structure and purpose. I'm actually aiming to make this more laid back than most streams, though if my voice is too quiet to be heard, that's an issue.
EpochTalk, as in the forum software?
Thanks for the videos, one remark: the code font size is too small in the second video, and the blue text on top of it makes it quite unreadable when you type something in the bottom. 
Looks really good. nice job!
You're not being stupid at all, this is easy to get tripped up on when you're not used to thinking about the types. There's a couple things going on here so I'll try to break it down. Here's your first function, I've just renamed it to make things a bit clearer encodeModel : Model -&gt; Encode.Value encodeModel response = Encode.object [ ( "code", Encode.string response.code ) , ( "description", Encode.string response.description ) , ( "schemaType", Encode.string response.schemaType ) , ( "schemaItems", Encode.string response.schemaItems ) ] This function takes a `Model`, and returns a `Value`. Notice that this `Value` isn't a string of json text! Its just an abstract representation of a JSON value. To make a string out of it, you need the [`encode`](http://package.elm-lang.org/packages/elm-lang/core/4.0.1/Json-Encode#encode) function from `Json.Encode`. It needs an `Int` representing the indentation level, and the `Value` you got from your function. So to get a string of json we'd do something like the following fullyEncodedString : String fullyEncodedString = Json.Encode.encode 0 (encodeModel model) Now that you have this `String`, and you have your `Decoder String`, try to finish the test by decoding it. You'll definitely also need the [`decodeString` function from `Json.Decode`](http://package.elm-lang.org/packages/elm-lang/core/4.0.1/Json-Decode#decodeString) Edit: alternatively, skip the string encoding step and use [`decodeValue`](http://package.elm-lang.org/packages/elm-lang/core/4.0.1/Json-Decode#decodeValue) instead 
When you write `text decode encode model`, you are applying the `text` function to three arguments: `decode`, `encode`, and `model`. Since the `text` function takes only one argument, a `String`, you get the error you see. You can use parens to indicate the function application: `text (decode (encode model))`. That will also have an error, because `decode` is not a function. You need to use the library function `Json.decodeValue` to convert the `Decoder` into a function that does the decoding. So you want something like `text (Json.decodeValue decode (encode model))`. That will still have an error, because the result of `Json.decodeValue` is not just a `String`. The decoding can fail if the json value doesn't match what is expected. The type system requires that we record the possibility of failure in the type. So the type of `Json.decodeValue` is `Decoder a -&gt; Value -&gt; Result String a`. The type `Result String a` is a union that can be one of two cases, either an `Err` containing a `String`, or `Ok` containing a value of type `a`. The basic way to process a union type is to use a `case`. For `Result`, that would look like this: case myResult of Err e -&gt; {- Do something with the string e -} Ok a -&gt; {- Do something with the result of type a -} In your case, the type `a` will be `String`, and you would probably like to simply show the error message in place of the decoded string. So you can do something like this: handleDecodeResult : Result String String -&gt; String handleDecodeResult result = case result of Err e -&gt; "Decode error: " ++ e Ok str -&gt; str This returns the decoded string in the case of an `Ok` and the error message in the case of `Err`. Now you can use `text (handleDecodeResult (Json.decodeValue decode (encode model)))`.
You can listen for any browser event using the `on` function from `Html.Events`. http://package.elm-lang.org/packages/elm-lang/html/1.1.0/Html-Events#on Here's an example: import Json.Decode as Json onWheel : msg -&gt; Attribute msg onWheel message = on "wheel" (Json.succeed message)
Thanks! I used the documentation you linked to figure out how to read the deltaY value of the event. onWheel : (Int -&gt; msg) -&gt; Attribute msg onWheel message = on "wheel" (Json.map message (Json.at ["deltaY"] Json.int )) 
One approach would be to have `SettingNode` represented by an object with a `type` field and a `content` field, where the type field is 0 or 1 and the content is an object that can be decoded to either a `MenuNode` or a `Setting` as determined by `type`: menuNode : Json.Decoder MenuNode menuNode = Json.object2 MenuNode ("name" := Json.string) ("children" := Json.list settingNode) setting : Json.Decoder Setting setting = Json.object2 ("description" := Json.string) ("settingType" := settingType) settingNode : Json.Decoder SettingNode settingNode = let typeSwitch n = if n == 0 then Json.map MenuNode ("content" := menuNode) else Json.map SettingEntry ("content" := setting) in ("type" := Json.int) `Json.andThen` typeSwitch You can also do away with the explicit `type` and determine it just by the content of the json: settingNode : Json.Decoder SettingNode settingNode = Json.oneOf [ Json.map MenuNode menuNode , Json.map SettingEntry setting ]
Care to share what the code looks like? I want to change my current solution has well. I tried looking at Sub.map but I can't just wrap my head around it.
Oh I see now! It makes so much more sense! Thank you for your help I really appropriate it. Your answer combined with the answer below I think I've managed to crack the problem :)
Ahhh ok I see now, it makes a lot of sense that you're almost forced to handle any errors you may face. Thank you so much for the explanation and help it's invaluable :)
It is very difficult for me to reproduce the bug but I did manage to get it one time. I have no idea what's happening there. My bet is that the mouseUp is somehow lost. As for going about debugging this, I would first change the update's main case to `case Debug.log "msg:" msg of`.
If you select the text, then try to drag, the browser's drag-drop takes over (at least in Chrome). In that case, the problem happens 100% of the time. I would guess that is what is preventing the mouseUp event from firing.
I was able to reproduce the bug by RightDown+Drag+RightUp. There is no DragEnd event generated for the RightUp. 
I've only managed to reproduce it once and wasn't set up for debugging when I did it. Being stuck in drag state when the mouse button isn't down usually happens after a mouseup outside the browser window or over something that's cancelling all mouse events. Not sure if that's relevant here but that's where I'd start investigating. To debug using Chrome dev tools, flip over to the 'Sources' panel. One of the options on the right is 'Event Listener Breakpoints'. Toggle the mouse up and do a drag+drop. This will dump you into the first line of JS that executes as a response to the event. I get dropped into line 6048 in the `on` method of `_elm_lang$dom$Native_Dom`, which looks pretty good. Having execution pause prevents our testing but logging would help so add a breakpoint to line 6051 and right-click 'Edit Breakpoint...' to make a conditional breakpoint. For the condition I'm using: event.type === 'mouseup' &amp;&amp; console.log('mu', event.pageX, event.pageY) From there, toggle off the event listener breakpoint. I took the opportunity here to check the `event.target` and it turned out to be the documentElement so mouseup outside the window shouldn't be a problem (at least I'm remembering this as a safe pattern). I poked around at the page and I didn't see any `mouseup` handlers on the buttons so that shouldn't be a problem either. Hopefully that's somewhat helpful as a way to get started. I didn't reproduce it while typing this up even with eruonna's selection trick so I'm bowing out from here.
Here's an example for you: import Regex exposing (..) import String wordsThatFollowThe = caseInsensitive (regex "the (\\w+)") eg = replace All wordsThatFollowThe (\match -&gt; "a " ++ (String.concat (List.map (Maybe.withDefault "") match.submatches))) "The quick brown fox jumped over the lazy dog." &gt; eg "a quick brown fox jumped over a lazy dog." : String The point being, you don't use `$1/$2` etc., but the values are available to you under `.submatches`.
This happens immediately, 100% of the time on Windows - any browser version.
Sure, looks something like this: In the main module: type Msg = SubModuleMsg SubModule.Msg subs = Sub.map SubModuleMsg SubModule.subs update msg = case msg of SubModuleMsg msg -&gt; (SubModule.update msg model.subModuleModel) In the sub module: type Msg SubModuleMouseMsg Position subs = Mouse.ups SubModuleMouseMsg --- some update function that deals with SubModuleMouseMsg-- The way I understand it is thus: 1. Sub.map grabs the subscription from the sub-module and maps it to a Msg type within the main module. So, in this case, whenever that sub-module subscription fires, the main module's update function is called with a Msg type that lets us know where it came from (i.e. SubModuleMsg). 2. Then, in the main update function, you can just call the sub-module's update function and pass it the msg and its model. Please, someone let me know if I'm wrong!!
Thanks for this example but it's not a general solution and this approach is far more verbose than using $1 parameters. Looks like I'll have to write this myself. I'll post it here when it works. 
I had to write one. Here it is: [{-| Replace with $1, $2, ... $9 Parametric Replacements N.B. $$ is an escape for $, e.g. $$1 will be $1 in the output N.B. any $n that isn't specified in the regular expression is untouched in the output replaceParams All "(\\d)([a-z])" "-$1$2$$2$3" "6a7b8c" == "-6a$2$3-7b$2$3-8c$2$3" replaceParams (AtMost 2) "(\\d)([a-z])" "-$1$2$$2$3" "6a7b8c" == "-6a$2$3-7b$2$38c" -} replaceParams : HowMany -&gt; String -&gt; String -&gt; String -&gt; String replaceParams howMany r new old = let paramRegex index = "\\$\\$?" ++ (toString index) replaceParam match subMatch = if String.left 2 match == "$$" then String.dropLeft 1 match else subMatch replace index subMatch new = Regex.replace All (regex &lt;| paramRegex index) (\m -&gt; replaceParam m.match subMatch) new replaceSubmatchesInNew = L.foldl (\subMatch state -&gt; { state | new = replace state.index subMatch state.new, index = state.index + 1 }) { new = new, index = 1 } asStrings = L.map (Maybe.withDefault "") in Regex.replace howMany (regex r) (\m -&gt; .new &lt;| replaceSubmatchesInNew &lt;| asStrings m.submatches) old {-| Replace All with Parametric Replacement (See replaceParams) -} replaceParamsAll : String -&gt; String -&gt; String -&gt; String replaceParamsAll = replaceParams All 
I think you mean: type Action = ID String | Remarks (Maybe String) And... Remarks quoted -&gt; { model | remarks = quoted } 
Wow. The brackets fixed it!
Since for some reason this is not attracting any comments, let me just say that I am very, very excited about this! I am short on time currently, so I could not familiarize with what you did exactly. (I did not even have time to build it yet.) Could you possibly post a demo somewhere, ie. Github pages? Could you comment on any limitations or issues that would have to be worked out on the Elm side? Does it use Native? Does it require patches to elm-lang/virtual-dom or elm-lang/html?
Adding the brackets fixes the error, but the error happened because of a bug where the compiler doesn't check if you're looking for a type or a type Constructor, which is what maybe is. Ideally, when this is fixed, the compiler would have caught the bug in the definition of Action. Glad it's working for you now! 
This is a great walkthrough in general. I'll sheepishly admit I've never spent a moment to learn how to set a breakpoint with Chrome's dev tools much less how to sit on event listeners like that. Thanks for the write up.
I haven't heard of that, thanks for mentioning it.
I believe https://twitter.com/luke_dot_js worked through them a while ago. He may still have the answers / be willing to share them.
Cool! Where is the source code?
I did one "major" refactoring which was changing Friend from an UnionType to a record type.
Because the type signature is more accessible to the average user. At least in my mind it is. I think it's easier to see what's going on, and what's expected of you when you call it. I will expose the generalised one when I get chance to docstring it up properly. :-)
Thanks!
Just a little improvement, considering your source code is already neat: You could use `!` for your update function, e.g., instead of `({model | time = newTime}, Cmd.none)`, it could be `{model | time = newTime } ! []`
`msg` can be any type - the idea is that it is the type you use for messages in your application or component (as per the elm architecture). If you want to create html that doesn't produce any messages, you can just make it generic, so it'll work with anything. To do that, don't specific an explicit type, just return `Html msg` where `msg` is an unbound type. So your code might look like this: type Message = DoSomething | DoSomethingElse box : Html msg box = div [] [] button : Html Message button = button [ onclick DoSomething ] [] boxAndButton : Html Message boxAndButton = div [] [ box, button ] Note that `box` takes the generic type because it doesn't handle any messages, so it doesn't matter. `button`, on the other hand, emits the DoSomething method when the button is clicked, so it has to be `Html Message`. When you combine the two, it has to be `Html Message` to contain the button, and the generic type on the `box` method gets filled with `Message` so it can fit. In more complex applications, you might want to mix objects that provide different message types, and this can be done with `Html.App.map`.
&gt; view : AppModel -&gt; Html Msg But how does it fit into the syntax of Elm. Your boxAndButton returns the result of div which is supposed to be just Html. Shouldn't this cause a compilation error? 
I'm actually not sure this is always an anti-pattern. For example, when the data you're loading is nullable, Maybe, whatever you want to call it. Then Nothing can't just mean "it's loading" anymore. There's a lot of APIs designed like that - they return nullable data everywhere. Or is there a different solution to this?
To understand this, you need to understand the concept of a type variable. `Html msg` is the type constructor `Html` with the type variable `msg`. Here `msg` has no added meaning, you can replace it with `a` or `message` or whatever you deem appropriate. `Html Msg` is concrete type obtained from combining the type constructor `Html` with the concrete type `Msg`. You can read it as "Html that produces messages of type Msg" If you have some structure that does not include event handlers, you can leave the type of return with the variable as in `Html a` or `Html msg` and you will be able to use it everywhere. Another way to think about `Html a` is to make an analogy with `List a`. `List String` is a List that contains Strings, it is a specialized form of List. Similar, `Html TopMsg` is a specialized form of Html, one that produces messages of type `TopMsg`. 
Presumably that should be "that does *not* include event handlers"...
In the ELM runtime. This runs in the background, listening for events and (where appropriate) passing them off to #update. Once #update returns, it calls #view. This is what links the separate parts of your app together.
It seems that the only way to store intermediate state in Elm is via the `model`. The runtime stores the model and the Elm code is always stateless. It would be nice to have Elm mechanisms to keep intermediate state.
&gt; It would be nice to have Elm mechanisms to keep intermediate state. Absolutely not. Adding other ways to store state would allow new Elm programmers to re-use the stateful solutions they are familiar with from other languages, and rob them from the epiphany of discovering the simplicity of The Purely-Functional Way (tm)!
Store it in the model. Elm's type system is strong enough to let you accurately represent that kind of thing.
Not sarcastic, except for the way in which I wrote "The Purely-Functional Way (tm)", which is intentionally over-the-top in order to poke fun at my own over-enthusiasm for purely-functional programming.
Effectively the state gets mutated via input old state return new state and then that state gets stored for the next iteration. The state has to be stored. So my original question is where does it get stored. And it appears that it's stored in Elm runtime. I'm also investigating Effects Managers. They don't store state but the Elm runtime stores state on their behalf.
This is classic XY problem: http://xyproblem.info/ What are you trying to achieve? Are you just looking for a greater understanding of Elm? Have you read about the Elm Architecture? What are you actually stuck on? 
Purity is not something Elm will likely ever compromise on. Have you read the Elm Architecture tutorials on how to model your app? What are you really trying to do? 
You're not on the right track. Consider Effects Modules to be an off-limits, private API that let's intended for library authors only. You should strive to make your app as pure as possible. If you really need the full flexibility of javascript, use `ports`. &gt; Each call to the backend DB will create a new version of this structure (effectively adding to the old structure), but while my program waits for the next SQL call to complete, this structure needs to be stored somewhere. So why don't you store it in the model, which is the source of truth for your app's current state? Why do you need an "intermediate" representation of your model? Is it because you want every DB call to succeed before rendering anything? Do you need some info from the first query before you can execute the second query? If you tell us what problem you're actually trying to solve, we might be able to help you. Edit: Sorry, I just saw this in your post: &gt; I need to make multiple SQL calls to pull back the whole tree and **I need to inspect the results of the previous SQL call before I can form the next one properly.** Use `Task.andThen`: http://package.elm-lang.org/packages/elm-lang/core/4.0.3/Task#andThen
What do you mean by "work with?" You can certainly use both in your code. `andThen` does not only work for a static number of tasks. You can chain arbitrarily many tasks together with it. For example, you could do something like this: doSomething : List QueryInfo -&gt; Query -&gt; Task ErrType QueryInfo doSomething pastQueries query = foo doQueries : List Query -&gt; Task ErrType () doQueries inQueries = let helper pastQueries qList = case inQueries of [] -&gt; Task.succeed () query :: rest -&gt; doSomething pastQueries query `andThen` \pastQuery -&gt; helper (pastQuery :: pastQueries) rest in helper [] inQueries
I have no problem writing pure code (I ported my query parser to Elm without too many problems, which is a few hundred lines of Elm). I've come to the same conclusion you did. I need to understand the Elm Architecture better. Currently, I'm playing around with `Task`, `Cmd` and `Sub` to get a feel for them. Then on to `ports`. Thanks.
Might this be a case where not having andThen for cmds causes problems? Since they want to chain together several port actions? 
Will do. Thanks you.
Thank you. I thought it was a easy way to start and there are enough todo apps out there.
Did you have any functional programming experience before this? How hard was it getting into it?
Thanks!
Hey man, I think you are fundamentally misunderstanding elm. You're worried about state vs "intermediate" state. Drop that concept in your head, there is only state. Let's say you have some service which returns you a string for an image url. You need to call the service five times and only after five image urls can you do anything useful. In your terms, these urls would be "intermediate" state. But how can we model this problem? Let me put this in your terms type alias Model = { intermediate: List String, final: List String} update model msg = case List.length model.intermediate of 5 -&gt; { model | final = intermediate, intermediate = []} _ -&gt; { model | intermediate = (msg :: model.intermediate } Now I'm on my phone so I may have butchered the syntax, but basically you can just have a separate field for data that you want to hold onto but not use yet, it's that simple! Let me know if I can clear something else up 
Take a look at [html-to-elm](http://mbylstra.github.io/html-to-elm/) project. Maybe you can reuse something from there. :) 
Awesome! Looks like I could definitely leverage this :).
that was instructive, thanks!
A small bit. I did two Functional Programming courses in University. Functional Programming 1 and Functional Programming 2. In the first one we solved programming problems in Haskell. In the second one we reimplemented data structures and their operations in Haskell using algebraic data types. Sets, Lists, Binary Trees, Maps and Graphs. As a final project we implemented an interpreter for the factor programming language.
More details? We don't know what you're asking for. It would be helpful to know the problem you're trying to solve, and some context around what you mean by editable tree. Then we'll be happy to help!
If you're still confused, look up [parametric polymorphism](https://en.wikipedia.org/wiki/Parametric_polymorphism)
Something like files and folders where you can rename, add, and delete them or anything arranged into sections with items in each section. 
Can you give an example? What are you trying to use this for?
 Something like this Root Item Section Item Item Section Item Item Section Item Item Where you can add, edit, and rename the sections and items. I plan on using this for recipe ingredients and instructions organized into sections and for a file folder structure.
I've tried to learn elm a few times now and have had false starts. I hope this is the one. 
Another way: ``` let pos = ball.pos in {ball | pos = {pos | x = 1}} ```
Good news! :) https://www.manning.com/books/elm-in-action
That's the one I'd been using, but it seemed somewhat bulky. I think making a setter function is my preferred option.
This is exciting! I think it can fill a different niche than the Gitbook, more of an example based cookbook, going in to more detail, not meant to be read cover to cover. As has been pointed out on the mailing list, we should take advantage of the Versioning features, so we can track breaking changes in the docs. 
USA. The full book will probably be out about a year from now. :)
What substantial change are coming? 
(Also it's called sum-type, perhaps googling this will be more enlightening than my ramblings)
I didn't mean anything in specific, but by following elm-discuss mailing list I get the impression that the core developers are really open to feedback, critiques and discussion; they consider that Elm should not be worried about backwards compatibility right now, but should be focus on becoming a great language… Do I guess they are not _afraid of_ substantial changes — and that's what I meant ; ) 
&lt;3
I understand that. I am looking for an elm app containing a tree view were you can edit, add, and delete sections and items. I think I almost figured out how to do it myself.
It works!!! Thank you so much, Sir, I owe you a Cola the next time you're in Ontario :) Hmm... I suspect it's a bug in Elm's runtime...??? 
I just wanted to say that I really object to calling that thing "The Translator Pattern" like it's anything special. Functions can take arguments. You can give more arguments. You can give fewer arguments. Those arguments can be functions. They can be values. You can return a 2-tuple. You can return a 3-tuple. This is just normal functional programming, not some fancy pattern. That said, I appreciate that folks are pretty nervous about this kind of stuff. Part of the problem is that people are engaging in premature architecture optimization IMO. Another problem is that there is official guidance for some things, but it does not extend to explicitly cover *all* possibilities yet. I am currently focused on creating examples and docs that (1) reframe this whole topic as "API design" and (2) provide more guidance on *when* and *how* to participate in that kind of activity. A good library author chooses how to expose information depending on their domain. There is no single recipe for every library ever. Any time you start drawing lines with modules, you have stepped into the world of API design, so I am trying to write up some guidelines with nice examples that'll help people with this.
I think this is really important: &gt; So, if you think you need child-parent communication, reconsider. If you really need it, the elm community has patterns and libraries to make it pleasant. It's good that we're talking about these things to handle the case, but you're right that we need to have a conversation about whether or not we even need it.
this also ties into your comment about API design below pretty nicely. In my articles I tried to make clear: this is all a part of the API. We're adults here, we can change APIs if we need to in order to get a better result. So yes, refactoring helps *a lot*
If I'm ever in Ontario I'll take you up on that :) I have no idea if it's a bug or working as intended.
I'm pretty excited that this is a part of a university course!
The book looks pretty good already. If you don't get it today we'll hopefully be offering a discount to elm-conf attendees as well :fingers_crossed:
He may not be, but I am looking for a better understanding of Elm so I'd like to know how it is stored under the cover.
This has been my biggest stumbling block on my (short) journey into Elm so far. I always suspected it would seem simple when it finally clicked - and it did in the end. There is one type being defined here, and that type is Msg. The definition says that Msg comes in a number of different varieties, such as Edit, Score and Input. You can create an Edit or a Score and assign it to a variable of type Msg. You can't create a Msg - think of it as an abstract supertype. So you make a Save just by typing 'Save' - that's straightforward enough. However, if you want to make an Edit, it needs a parameter of type String - so you'd type Edit "Bob". Similarly you'd create a Score with Score "Alice" 5. Any of these will be understood by the compiler to be of type Msg. The thing which I wish someone would have said to me and saved me a 3 day low grade headache is this: The first word you see (Score) is a constructor for a particular type of message. The next two words you see (Player and Int) are the names of types which have already been defined, and they are the parameters to that constructor. Even though all three are capitalised words they not quite doing the same thing. Later on, when you're writing a case statement to decode the Msg you've just received, you'll use the names of the type contructors to specify what to do with different varieties of Msg: ... case myMsg of Edit aPlayer -&gt; do some stuff Save -&gt; do some other stuff Score aPlayer anInt -&gt; do yet more stuff The bit that surprised when I realised it is that Edit, which you have only ever mentioned when writing the definition of Msg, can be considered as a function which takes a Player as a parameter and produces a Msg as a return type. Its signature would be: Edit : Player -&gt; Msg Hope that helps and that my newbie level Elm knowledge hasn't led you astray.
Ordered.
To lift your confusion you need to understand the concept of [Tagged Union](https://en.wikipedia.org/wiki/Tagged_union) In you case, the type is `Msg` and wherever you use it you can pattern match on its cases. Each case has a tag and may have a list of additional types. If there are additional types, you have a cartesian product of all the types there. So, `Score Player Int` with get you elements from the cartesian product of `Player` and `Int` tagged with `Score`. Here `Score` is also a value constructor, a function that takes a `Player` and an `Int` and produces a `Msg`. So `Score somePlayer someInt` will produce a `Msg`. In closing, I must add that maybe 80% of what you do in Elm is playing with types so... once you understand these, the sky will part and you will achieve Elm enlightenment. 
What would be the tentative schedule for each chapter? A chapter a month?
This is so far my favourite elm tutorial. Instead of going the usual route of "here's a truckload of boilerplate called the Elm Architecture, trust me it'll pay off in the end" you give a minimal thing that works and slowly refactor it into the Elm Architecture, making the readers understand the benefits as they go. Great job, can't wait for the next chapter!
We already have elm-slack, elm-newsletter, awesome-elm, elm-reddit. 
Can a young programming language have too much support? Too many communities? Go look at Javascript. It dwarfs Elm. I've created this group because Elm's presence there is non-existent. There is a long road ahead for acceptance into the larger community of web developers. This is but a baby step in that direction. I hope you will join and help us move in that direction.
In Haskell you can create a smart constructor. See this [StackOverflow](http://stackoverflow.com/a/8510772). I tried to do this in Elm, but in Elm there doesn't seem to be a way to export the type or type alias without exporting the Constructors. I'm new to Elm so take my failings with a grain of salt. 
Right now any member can approve new joins. Not sure how to make it completely open. If anyone knows how please let me know. Thanks. 
This is a great introduction to routing in spas with elm! It really bridges the gap between the elm guide and actually building full applications.
You're coupling 2 different things here, matching passwords and validating passwords. I'd separate them. Then your code is: matches : Model -&gt; Bool matches model = model.password == model.passwordAgain validPassword : Model -&gt; Bool validPassword model = model.password /= "" Obviously, `validPassword` would be more extensive in production code.
&gt; I get the impression that they can be a little bit interchangeable Not at all! Algebraic data types can be *implemented* in terms of records, but the translation loses some guarantees. For example, suppose you have an app which loads a list of images from the server and displays them. In Javascript, I'd encode the model like this: initialModel = { loading: true, images: [] } and later on I would receive the images from the server and I would assign them to `images` and I would set `loading` to `false`. I would much prefer modelling this in a language like Elm which supports algebraic data types: type Model = Loading | Loaded (List Image) Now I can no longer accidentally access the list of images before they are loaded, as the type system forces me to consider the possibility that they might not have loaded yet. This [avoids the common bug](http://blog.jenkster.com/2016/06/how-elm-slays-a-ui-antipattern.html) in which an empty list of images is displayed for a second instead of displaying a more appropriate "loading..." message. It is of course possible to implement algebraic types using a record: type alias Model = { loading: Bool, images: List Image } but then we're back to the error-prone situation we had in JavaScript. So don't do that. Always use algebraic data types when you can, they'll force your code to consider all the possibilities and save you from countless bugs. The only case in which you should use records is when there really is only one case to deal with. In that case, type alias RGB = { red: Int, green: Int, blue: Int } type alias Image = { width: Int, height: Int, pixels: List (List RGB) } is much more readable than algebraic data types with only one constructor and a bunch of anonymous fields: type RGB = MkRGB Int Int Int type Image = MkImage Int Int (List (List RGB)) 
Have you read through the [guide](http://guide.elm-lang.org/) and the [elm-architecture-tutorial examples](https://github.com/evancz/elm-architecture-tutorial)? Also, Elm is recognized as a language by GitHub so you can [search all the repositories that have it as a language](https://github.com/search?utf8=%E2%9C%93&amp;q=language%3Aelm) 
Yes, I read them. I am more specifically in search for 0.17 projects, small or large. Link to Github Search helped, when I order by recently updated. Thanks! 
You need a little bit of experience with the Elm Architecture first. If you want to write a serious SPA, start with a regular navigation enabled Elm Architecture (like the example from [url-parser](https://github.com/evancz/url-parser/blob/master/examples/App.elm)) and grow from there. You can grow quite complex applications that still have only one model, one update and one view. They just pus the complexity into the types and into all kinds of helper functions. And after you get enough experience, you will be able to discern where it makes sense to draw component lines. Until then, component focus is a form of premature optimization. 
TIL it's possible to use elm-reactor with custom HTML files! I thought we had to use elm-make and some third-party run-a-shell-command-when-this-file-changes tooling.
Oh, I did not do this :) I subscribed to the conference's channel and found the video cool. I'm currently learning Elm; still trying to wrap my head around some things, mostly Types and what a good architecture for my pet project would look like. To get back to your remark, this particular use has some sort of the behavior of Tuples: pairs of states-places (I come from an OO background, I guess it shows). Then why not use Tuples, or Records? 
Here's my 0.17 todo: https://github.com/andrewsuzuki/elm-todo-rest-api
I recommend checking out [this project](http://package.elm-lang.org/packages/NoRedInk/elm-decode-pipeline/1.1.2/). That is a nice approach for when things get big. Your case sounds pretty special though, so it may be worth doing a bit of code gen if you are doing like 90 different SQL queries with crazy shapes. If it's only a few, that sort of thing wouldn't be worth it IMO. P.S. I just tried to search for "NoRedInk json" and did not find it, which makes me think the name or description needs to be updated!
Unfortunately, there is nothing special about the problem I am describing, at least not in the domain I am dealing with ( Task &amp; Asset Management for M&amp;E ). Did i mention that the results could be in the tens of thousands? I also have not seen any data grid implementation which would suite my needs. Looking at elm-sortable-table, I see that the author cautions against putting configuration of the table into the model. Given the fact that users typically chose the fields they want to display, this is probably not going to fly either. I am beginning to think that i will be returning to React for this one. ( or perhaps c++/qt )
yes. Backend is not an issue. We have RESTful services providing database access... We have used a number of strategies for the front end.. c++/qt, python/pyqt, and I have played with a number of web solutions as well ( react&amp;redux, polymer, backbone&amp;whatever)... 
Thanks for the tips!!! And i just grokked elm-decode-pipeline as well. seems even simpler...
It makes sense, Booleans form a lattice with True the greatest element and False the least.
It doesn't make sense to me either. It seems Python 2.7 compares boleans while Clojure doesn't: Python 2.7.10 (default, Oct 23 2015, 18:05:06) [GCC 4.2.1 Compatible Apple LLVM 7.0.0 (clang-700.0.59.5)] on darwin Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; True True &gt;&gt;&gt; False False &gt;&gt;&gt; False &lt; True True &gt;&gt;&gt; True &gt; False True &gt;&gt;&gt; True &lt; False False &gt;&gt;&gt; nREPL server started on port 50171 on host 127.0.0.1 - nrepl://127.0.0.1:50171 REPL-y 0.3.7, nREPL 0.2.12 Clojure 1.8.0 Java HotSpot(TM) 64-Bit Server VM 1.8.0_31-b13 Docs: (doc function-name-here) (find-doc "part-of-name-here") Source: (source function-name-here) Javadoc: (javadoc java-object-or-class-here) Exit: Control+D or (exit) or (quit) Results: Stored in vars *1, *2, *3, an exception in *e user=&gt; true true user=&gt; false false user=&gt; (&lt; true false) ClassCastException java.lang.Boolean cannot be cast to java.lang.Number clojure.lang.Numbers.lt (Numbers.java:221) user=&gt;
Maybe it's because, while mathematically sound and elegant and all that, it's not particularly intuitive and thus can be abused into "too clever" code for little practical gain, which (I think) would work against Elm's core design principles.
Python bools are ints under the hood, largely for historical reasons. It means you can still do somewhat-unhelpful things like `True + 1` and still get a relatively meaningful response.
The answer is: Because they aren't, yet. See this issue: https://github.com/elm-lang/elm-compiler/issues/1008 In general, if you miss something being appendable or comparable, well, it's because the core maintainers need to implement it. That's just how things are right now - I'd very much prefer to be able to write my own instances for those, but right now we can't.
They are comparable in Clojure. It's just that (&gt;) and (&lt;) are to compare _numbers_. Try `compare`, which returns -1 for LT, 0 for EQ, and 1 for GT. There is no real thought-through reason. It makes a lot of sense to be able to compare booleans, if just for sorting a table by a certain flag being set (checkboxes).
Oh and BTW, simple workaround for sorting lists: `List.sortBy` with a function that makes `True` a `1` and `False` a `0`.
Also, even if you don't use `compare` directly, `sort` and other sorting functions use `compare` by default. Sometimes, for complicated sorting, I'll `sort-by` a function that returns a vector. If I want to sort employees to the top and other people to the bottom, and then sort within those sections by name alphabetically, I would do something like: (sort-by (juxt employee? :name) people)
Chpfrk, that was my approach. But i am not sorting lists. I am sorting columns. Or rather the elm-sortable-table is. And that doesn't have any affordances for bool columns. Which surprised me, because the semantics for booleans are pretty clear, and Haskell allows you to compare bools. Anyway. I am not complaining. This is the most fun I have had with a new programming language in years. It all just fits together so well... 
And they form a dual lattice with True at the bottom and False at the top. You can compare them, but choosing that comparison is somewhat arbitrary, and I suspect comparing Bool might be a bad code smell. 
On the one hand, it's probably an oversight, and there's no reason they can't be comparable. On the other hand, comparing them for sorting is always going to give odd results, because there's only 2 values, so comparing Bool is probably a bad code smell. What are you actually trying to do? This seems like the X Y problem: http://xyproblem.info/
Given that all comparable types are currently special cases I don't think it'd be too bad, though.
Isn't that essentially the abstraction computing is built on? Binary? How exactly is it that you are determining that I am going to get "odd" results? I have a model with records representing assets returned from our database. Each of these records has a number of boolean properties which are domain specific, and which we sort on in other languages all the time without any issues. ( including Haskell, which Elm is authored in, not to mention SQL ). I dont see how this is any different than sorting a list Ints in the range of 0 through 1... 
&gt;Each of these records has a nIf you're wanting to sort by multiple boolean properties, you're probably best to just write your own comparison function.umber of boolean properties which are domain specific Sorting a list of collections of booleans is a whole different matter. I thought you were just sorting based on a list of single boolean values, which would just partition your list. If you're wanting to sort by multiple boolean properties, you're probably best to just write your own comparison function. Some day Elm may be able to derive more complicated comparison functions for things like this, but today is not that day. &gt; I dont see how this is any different than sorting a list Ints in the range of 0 through 1... It's not, but sorting is fundamentally the wrong operation for this Task, since it takes O(nlogn) time, and you could partition the list into 0s and 1s in linear time. That's what I mean by weird results. Sorting by bools is a degenerate case. It works, you can sort it, but it's not really a meaningful thing to do. It's kind of like multiplying by 1. You can do it, but you're doing something more complicated than you need. &gt; Isn't that essentially the abstraction computing is built on? Binary? Only if you're building hardware. Elm is focused on the abstractions of data types (Tagged unions, records, tuples), and functions. Programming isn't really about 0s and 1s unless you're working with really bare-metal stuff, and Elm seeks to be abstract, much like JS does.
&gt; Haskell allows you to compare bools. Haskell has a much more sophisticated, complex typeclass system for dealing with these things, with its own sets of tradeoffs.
In my life, I don't think I have ever seen a table with hideable columns. I'm not even sure what that would mean in terms of UI. Can you say concretely what you actually want to do? Do you have two views? One shows 4 columns and one shows 10 columns? If so, make two `Table.Config` values. Have a chunk of data in your `Model` that picks the correct one. Do you literally have a hide button on each column? How do you unhide?
I would suggest using an `Array` for a large number of identical fields. So your types look like type alias Model = Array Int type Message = Field Int Int You end up with some `Maybe`s when you access array elements, but if the `get`s are concentrated in one place, as in your `result`, I don't think that is too bad.
[Massive Decks](https://github.com/Lattyware/massivedecks) is a game, with the client being around 5K lines of Elm 0.17.
I think `Table.customColumn` and `Table.increasingOrDecreasingBy` together should be able to give you what you want: http://package.elm-lang.org/packages/evancz/elm-sortable-table/1.0.0/Table#customColumn
Thanks /u/mbilical /u/eruonna Maybe I should make my example more clear: --Model type alias Model { pies: Int apples: Int beer: Int } initModel: Model initModel: Model 0 0 0 -- UPDATE type Msg = PiesChange String | ApplesChange String | BeersChange String update :: Msg -&gt; Model -&gt; Model update msg model = case msg of PiesChange nPies -&gt; {model | pies = Result.withDefault 0 (String.toInt nPies)} ApplesChange nApples -&gt; {model | apples = Result.withDefault 0 (String.toInt nApples)} BeersChange nBeers -&gt; {model | beers = Result.withDefault 0 (String.toInt nBeers)} --View view : Model -&gt; Html Msg view model = div [] [ input [ type' "number", onInput PiesChange ] [] , input [ type' "number", onInput ApplesChange ] [] , input [ type' "number", onInput BeersChange ] [] , text (toString (result model) ] --Result result : Model -&gt; Int result model = (model.pies * piesPrice )+ (model.apples * applesPrice) + (model.beers * beersPrice) This is the standard way to do it?
At this size, it is probably fine. There are a number of things you could do, though. For example, if you were going to access the fields in a wider variety of ways, you could use focus to provide first-class getters and setters. You still have to write getters and setters, so this is probably only valuable if you use them in many places. Or more generally, you could have something like type Item = Pies | Apples | Beers getCount : Item -&gt; Model -&gt; Int setCount : Item -&gt; Int -&gt; Model -&gt; Model type Msg = CountChange Item String update : Msg -&gt; Model -&gt; Model update msg model = case msg of CountChange item count -&gt; setCount item (Result.withDefault 0 (String.toInt count)) model view : Model -&gt; Html Msg view model = div [] &lt;| List.map itemInput [Pies, Apples, Beers] ++ [ text (toString (result model)) ] itemInput : Item -&gt; Html Msg itemInput item = input [ type' "number", onInput (CountChange item) ] [] result : Model -&gt; Int result model = (getCount Pies model * piesPrice) + (getCount Apples model * applesPrice) + (getCount Beers model * beersPrice) So you just have to decide on the implementation of `getCount` and `setCount` (and `Model`). One approach is to just go with what you already have: type alias Model = { pies : Int , apples : Int , beers : Int } getCount item = case item of Pies -&gt; .pies Apples -&gt; .apples Beers -&gt; .beers setCount item count model = case item of Pies -&gt; { model | pies = count } Apples -&gt; { model | apples = count } Beers -&gt; { model | beers = count } This, at least, puts all the repetition in one place. You could do some tricks with functions: type alias Model = Item -&gt; Int getCount item model = model item setCount item count model item' = if item == item' then count else model item But I don't know enough about the underpinnings of Elm to guess about whether this leaks space when using `setCount`. Probably it does. You could do something with `Dict`, but there is an issue with using user-defined types as keys: type alias ItemIndex = Int type alias Model = Dict ItemIndex Int getIndex : Item -&gt; ItemIndex getIndex item = case item of Pies -&gt; 0 Apples -&gt; 1 Beers -&gt; 2 getCount item = Maybe.withDefault 0 &lt;&lt; Dict.get (getIndex item) setCount item = Dict.Insert (getIndex item) Using `Maybe.withDefault` could be bad; it hides errors from the type system. If you know that that case will never happen, or if a missing count always means 0, then it is probably okay. Otherwise, you might want to change the type of `getCount` to include `Maybe` and float the error handling farther out. (You could also write `result` in terms of `Dict` operations like `merge` and `fold`.)
Thank you!
"Configurable columns" is quite a common requirement in any asset/task management view I have ever used. It is very common to provide a visible column list executed as a popup menu wherein each column has a checkbox to trigger visibility. 
Cool, that helps a lot, thanks :) Hmm, I guess I'd say try it with the current implementation (breaking the rules) and see how it goes. I had an idea for a more complex version of the API that would let you have a view function like this: view : Config state data msg -&gt; state -&gt; List data -&gt; Html msg Such that you could derive more view stuff from that `state` argument and get all the `lazy` benefits. I thought it was kind of too complex for the initial release though, so I decided to wait and see if anyone would need it. Your case is a really nice example of something that'd benefit from this, so it may be worth having a `Table.Fancy` module with the more advanced API, and then define the `Table` module in terms of it (where `state` is `()`)
Nice! I'd been wanting to play with Electron as a platform for writing desktop Elm apps. This looks really cool. Thanks for sharing. :)
2 day course in person or online via Front End Masters. For $279 you get access to this 2 day as well as six months full access to FEM. I had been thinking about signing up for FEM anyways. What do y'all think about this course and price?
Yes, the progress bar and the audio play is made through JS interop, for the UI I used Semantic UI's CSS :)
Elm is a really awesome language, finally something good for the Frontend x)
What about the in browser repl mentioned here : https://github.com/elm-lang/projects ?
Thanks for clarifying!
Given that GHC can compile to LLVM, would it be doable to use the elm compiler itself in the browser?
I know people have tried to compile elm-compiler to JS using GHCJS and Haste. Both failed because certain packages were unsupported or because of stack overflows. I do not know of anyone compiling to LLVM and then piping it through emscripten to run in browser. It may be possible. Unclear!
Thank you for the suggestions!
If you look on NoRedInk/take-home, you'll find it (I don't know in what state). Or ask @eeue56 (Noah Hall) on Elm Slack team, he has probably the most experience with this.
Can anyone who has used this comment on how it compares to elm-webpack-starter?
Very minor thing, but if you give your file a .elm extension in Github Gist, you will get Syntax highlighting.
I discovered in http://faq.elm-community.org/#how-can-i-load-css-or-other-resources-in-elm-reactor I don't think it's news for ppl there.
I have updated the code on the following url [here] (https://github.com/kwaleko/ELM-POST/tree/master/ELM-POST ) ,thank you
ohh yeah I can see the repetition, I will adjust it , thank you 
Is there an error? Are you sure that your compiled Elm code is executed before the port is called?
In stepping through, I will get to the Message that is called which would call off the command to call the port. After stepping through that, nothing is called, no error is thrown, just get returned to the page with no action. Have tried this by Elm Reactor, elm-webpack, and just doing an Elm Make and opening the page created by Elm. There are several ports in the application, but this one with the alert was my original test to make sure the ports worked, and so has been compiled many times over. Of course, I have been working in Chrome while developing and have not had any problems. Just tried IE to make sure it worked there before handing it off to be used in the company. Here is the code from Update.elm, and the button that calls it off just has onClick (Hello "hi"). No errors or warnings in the Elm compiler for any code. port module Update exposing (..) import Messages exposing (..) import Models exposing (..) import Components.Reports.Update exposing (getReportMenuItems) import Components.Supply.Gauge.Update exposing (getGaugeData) import Components.Supply.Gauge.Models exposing (..) import Navigation import Hop exposing (makeUrl, matchUrl, makeUrlFromLocation) import Hop.Types exposing (Location, Query) import Routing.Config exposing (..) import Routing.Utils exposing (..) -- ROUTING navigationCmd : String -&gt; Cmd a navigationCmd path = Navigation.newUrl (makeUrl Routing.Config.getConfig path) urlParser : Navigation.Parser ( Route, Hop.Types.Location ) urlParser = Navigation.makeParser (.href &gt;&gt; matchUrl Routing.Config.getConfig) urlUpdate : ( Route, Hop.Types.Location ) -&gt; Model -&gt; ( Model, Cmd Msg ) urlUpdate ( route, location ) model = ({ model | route = route, routeLocation = location }, Cmd.none ) -- PORTS port isPageReady : String -&gt; Cmd msg port returnReportFromJS : (String -&gt; msg) -&gt; Sub msg port returnGaugeFromJS : (String -&gt; msg) -&gt; Sub msg port startup : String -&gt; Cmd msg port hi : String -&gt; Cmd msg port whatsupjs : Gauges -&gt; Cmd msg -- FUNCTIONS -- UPDATE update : Msg -&gt; Model -&gt; (Model, Cmd Msg) update msg model = case msg of SwitchView -&gt; (model, Cmd.none) CommitRow -&gt; (model, Cmd.none) LogIn -&gt; ({model | loggedIn = True}, Cmd.none) LogOut -&gt; ({model | loggedIn = False}, Cmd.none) Hello whatToSay -&gt; (model, hi whatToSay) RouteError -&gt; (model, Cmd.none) RouteTo route -&gt; let path = Routing.Utils.reverse (route) in case route of ReportRoute rpt -&gt; (model, Cmd.batch [ (navigationCmd path), getReportMenuItems ] ) SupplyDashRoute -&gt; (model, Cmd.batch [ (navigationCmd path), getGaugeData ] ) _ -&gt; ({model | slideMenuInit = False}, (navigationCmd path) ) LoadSlideMenu message -&gt; case model.route of ReportRoute rpt -&gt; case model.slideMenuInit of False -&gt; ({model | slideMenuInit = True }, startup message ) True -&gt; (model, Cmd.none) _ -&gt; (model, Cmd.none) LoadGauges message -&gt; case model.route of SupplyDashRoute -&gt; (model, whatsupjs model.supplyGauges ) _ -&gt; (model, Cmd.none) SlideMenuItemsSuccess menuData -&gt; ({model | slideMenuData = menuData}, (isPageReady "report") ) SlideMenuItemsFail _ -&gt; (model, Cmd.none) GaugeValuesSuccess gaugeData -&gt; ({model | supplyGauges = gaugeData }, (isPageReady "gauge")) GaugeValuesFail _ -&gt; (model, Cmd.none) 
how could I add URL parser to the parser embedded in the code, as the url in reddit &gt; [url] (name) &gt; the parser is in the line 177
Thanks for sharing! I entered. :)
Very noble of OP to not include the `/?lucky=214` in the url :-)
It doesn't exist in full yet, and where it does, there is still some experimentation going on. For instance, one part of the Elm community is excited about making it possible to compile Elm to the BEAM (Erlang) virtual machine, while others are interested in a NodeJS target.
Unfortunately the moarwick project (like most on GitHub) is not open source, so you can't use it as a starting point for an app that could be used in production.
We did realize for the next API dev session: a camera on the programmers would be nice when discussion happens. But otherwise Evan didn't want to have any ideas going in.
I had exactly this same problem a few weeks ago! Elm's port code relies on `Object.assign`, which IE doesn't understand. I needed to add my own `Object.assign` polyfill, which you can find here: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign ... I don't know if this is the same problem you've having, but this fixed all my IE port woes. 
I prefer the `always 2` style instead `\_ -&gt; 2`
I really like to use literal names. elm-compiler, elm-package, elm-css, etc. So it looks like that, and that's fun, but I think it's better to just call it an anonymous function :P
What?
Very true, especially in a strict language like Elm.
Totally get that. And that was a rough section, no doubt :). My plan after updating the API is to transcribe important parts of the video in a blog post (much like the "Let's Be Mainstream" talk). I'll also get time marker links to important sections.
Depends on if you how good you want your computer player to be. [Checkout the Wikipedia page on this topic](https://en.wikipedia.org/wiki/Computer_Othello). 8x8 board has a lot valid moves...
I'm so glad that helped! It was a real puzzle for me, I and couldn't figure out what was wrong till I turned on IE 10's compatibility mode and it pointed to `Object.assign` in Elm's runtime. I think this is should be built into Elm's runtime. Can anyone tell me where I can go to open this as an Issue?
Here is an example done in haskell that may be of help. https://github.com/reflex-frp/reflex-examples/tree/master/othello 
It's better to think about the whole application or website as one main function. You will triage the model or state into the parts required for each view.
I also like how `always 2` looks but I think I now prefer `\someArg -&gt; 2`; I think `\_ -&gt; 2` looks pretty weird but `\someArg -&gt; 2` is very explicit and I find usually the body is short enough that it's obvious the argument isn't being used. It is also sometimes helpful to remind the reader *what* exactly it is that's being ignored! Finally, I encountered one place where using `always` was error prone in a way that would not have been possible with the explicit lambda form: https://groups.google.com/forum/#!topic/elm-discuss/QUwwgTZGCa0 
I didn't import `Cmd`, as none of the example codes I have seen did so. I will try, though. Also, I was about to write *type constructor* instead of *type*, but I finally didn't as I'm relatively new to functional programming. I'm glad that I'm familiarizing with functional programming vocabulary :-) 
&gt; Did you import Cmd? Cmd and Sub are imported by default. 
Download the binary and just run it from there, I've found editor integration to be not so great with elm format
My bad 
Notes &amp; demos for a talk I'm presenting tomorrow in Denver, CO, USA. There's not a lot of intermediate-level articles to help propel people out of the learning valley…
I don't have specific knowledge of the migration path from Angular to Elm, but I'd recommend using [techniques like this](http://elm-lang.org/blog/how-to-use-elm-at-work). There are some notes [here](https://www.npmjs.com/package/react-elm-components#angular-ember-etc) about how to use the same general ideas for Angular and Ember, so hopefully that helps! Is that the kind of information you are looking for?
Holy jeez this is so helpful!
&gt; It already doesn't feel right for me, as the name of the type is repeated as the name of the constructor. This is a very common pattern, so don't worry about it not feeling right. If you really want to distinguish different `Int` types, this is the right thing to do. &gt; after writing out those types I started getting weird errors like "Type applications without concrete names should not get here" Your code looks fine at first glance, as long as you've updated your model type definition accordingly. Can you post the entire file that is causing the error (maybe as a Github Gist)? Also, `Type Applications without Concrete Names` sounds like a compiler bug, so it's probably a good idea to give us an example for future reference.
It is fair and ethical to post here the same example done with other alternatives, for example Transient/HPlay? 
Thanks for the reply! &gt; Also, Type Applications without Concrete Names sounds like a compiler bug, so it's probably a good idea to give us an example for future reference. I put things like `Count Int` instead of `Count` in the type annotations and that must have confused the compiler. I updated the post. Now I have what I was worried about – that the `update` function is going to get a lot more verbose.
ooh, more stuff for me to learn. Thanks!
I would be happy to see that.
Nicely written post. It's a challenge to write a technical piece in an engaging way but this piece pulls it off. 
For the shake of comparing different alternatives: {-# LANGUAGE NoMonomorphismRestriction #-} import GHCJS.HPlay.View import Transient.Base import Transient.Move import Data.IORef import Control.Monad.IO.Class import Data.String import Prelude hiding(div,id) main = keep . initNode $ onBrowser peekPoke peekPoke = do model &lt;- onAll . liftIO $ newIORef (0 :: Int) poke &lt;|&gt; peek model pokeMessages= fs "pokeMessages" -- send a message to the server each click poke :: Cloud () poke = do local $ render $ do rawHtml $ div ! id (fs "pokes") $ p "Pokes: 0" inputSubmit "Poke others" `fire` OnClick atRemote . local $ putMailbox pokeMessages "poke" &gt;&gt; stop -- update the mailbox in the server -- receive updates from the server peek :: IORef Int -&gt; Cloud () peek model = do msg &lt;- atRemote . local $ getMailbox pokeMessages :: Cloud String -- each update send a msg to each client local $ render $ do n &lt;- liftIO $ atomicModifyIORef model $ \n -&gt; (n +1,n+1) at (fs "#pokes") Insert . rawHtml $ p $ "Pokes: " ++ show n fs= fromString installation: install ghc and ghcjs cabal install ghcjs-hplay cabal install ghcjs-hplay --ghcjs Can be installed with stack too. compile: mkdir static ghcjs pokes.hs -o static/out ghc pokes.hs execute: pokes -p start/localhost/3000 Then just point the browser to http://3000 Some essential hints about how it works: The server program send the client program (stored in the static folder) to the browser. Once the client program starts, all further messages are sent trough a single websocket connection. Disconnection is automatic. messages and connections are not explicit. `onBrowser` makes all the code run in the browser except the code with `atRemote`. It is an abstraction that carries out the communication. It executes something in the server and return the result back to the browser. the clients communicate trough a mailbox in the server. Once a message arrives, it broadcast it to all the nodes since each node is subscribed to `pokeMessage` events. Mailboxes, buttons etc are reactive. There is no polling. All the client/server application is a single expression, made with monadic and alternative operators. It is composable: `peekPoke` can be combined with other widgets. This is a tutorial that explains what happens here with more details: rendering, communications etc: https://github.com/agocorona/transient/wiki/Transient-tutorial#transient-in-the-web-browser Edited, for more details
`Nothing : Maybe a` Means that `Nothing` is of the type `Maybe a`. But ofcourse it would be possible for multiple modules to define the same type. So `Maybe.Maybe a` lets you know it is the`Maybe a` type coming from the module `Maybe`.
Ah of course! Thanks so much for your help
I think there is not support for something like that. You can do it with opaque type from 'Internal' module you'd create that doesn't expose the contents of the type, and that only exposes getters for fields, not setters. 
Thank you!
You could also have your model build up like this: type alias ModelStatics = { playerName : String } type alias Model = { statics : ModelStatics , score : Int } This way you can keep all the fields you should not update grouped together.
Good idea!
You could also make them additional parameters to your `update` and `view` functions: update : ImmutablePart -&gt; Action -&gt; Model -&gt; Model view : ImmutablePart -&gt; Model -&gt; Html Action Now the type system guarantees that you don't change the `ImmutablePart`, not because you can't set those fields, but because you can't push those changes to the rest of the app.
It depends somewhat on when you know the immutable values. As soon as you know them, you know the child's `update` and `view` functions once and for all (i.e. `update' = update immutable` and `view' = view immutable`). At this point you have a standard Elm architecture component. You could wrap this up in an initialize function that returns the correct `update` and `view` functions.
You could put your type in its own module, and instead of using records, expose setters and getters. Don't expose setters for the super immutable fields. 
Thank you very much! I finally begin to understand all the type acrobatics I've seen in Haskell and why one needs them. I asked a friend and he also explained that in Haskell it would be a bit more succinct due to typeclasses. For the posterity: in Haskell we could make Count an instance of Functor: instance Functor Count where fmap f (Count c) = Count (f c) Then values of Count type would work with the `fmap` function which works like `mapCount` or `mapTimesClicked` /u/jmite posted: fmap updateCount model.count This pattern is so common in Haskell that there's an infix operator `&lt;$&gt;` which is an alias for `fmap`: updateCount &lt;$&gt; model.count This makes it look like a standard function application of `updateCount` (which may work on `Int -&gt; Int`) to model.count, but it makes the function lifted. There's [a page on lifting on HaskellWiki](https://wiki.haskell.org/Lifting) if somebody wants to read more on that.
Part 2 has just been published! https://auth0.com/blog/creating-your-first-elm-app-part-2/ 
I'd just do it a different way. Have two values in a module: 1. Type `A` is opaque. You can ask things about it, but that's it. 2. Type alias `B` is just a normal record. From outside this module, you will be able to refer to `A` but only access it with functions exposed by the module. You will also be able to use `B` and because it's a type alias, all the details are available to you. So there's not a way to do *exactly* the thing you want, but it is quite simple to get the kind of safety you are looking for. Just remember that **modules are for modularity**. You want to hide something? Modules. All the other things are not for modularity.
This is good, but it's better if `ModelStatics` is a `type` instead of a `type alias`. This way, you can choose not to export any implementation details, and from the outside, no one can know what's in there unless the module allows it.
If 1 blog post every couple years is spam, then sure. =D But yes, point taken; thanks.
I like when community members share their own writing on all of the subreddits I frequent, so I'd hope it is encouraged here as well.
I think this is common on subs like this, Haskell, Rust, etc. The more people writing about Elm, the better and here is an ideal place to announce the posts. 
&gt; Saving `Main.html` won't work [...] You need to save the *source* of `Main.html` I don't understand. To me "saving Main.html" and "saving the source of Main.html" mean the exact same thing: taking the HTML code which underlies the page and writing it to a file on my computer. What do those two expressions mean to you? *edit*: by any chance, are you referring to `Main.elm` as the source for `Main.html`? elm-reactor will of course update `Main.html` to display whatever `Main.elm` wants to display, but in this discussion we are talking about serving a custom version of `Main.html`, distinct from the one which elm-reactor generates from `Main.elm`.
&gt; I didn't have any issues loading the resulting HTML file in the browser though Good to hear! I assume your version of elm-reactor must be more recent than 0.17.0?
This is the first time I've actually understood the point of typeclasses like `Functor`. Thank you!
You're right, 0.17.1 - that must explain it!
Thanks everyone! Hope to "discover" something tonight... time will tell.
This is a slightly different version of `poke` and `peek` that also decrease the counter: data Msg= Increase | Decrease deriving (Read,Show, Typeable) poke = do msg &lt;- local $ render $ do rawHtml $ div ! id (fs "pokes") $ h1 "Pokes: 0" increaseButton &lt;|&gt; decreaseButton local $ render $ wprint msg atRemote . local $ putMailbox pokeMessages msg &gt;&gt; stop -- update the mailbox in the server where increaseButton = do inputSubmit "increase" `fire` OnClick ; return Increase decreaseButton = do inputSubmit "decrease" `fire` OnClick ; return Decrease peek model= do -- each update send a msg to each client msg &lt;- atRemote . local $ getMailbox pokeMessages :: Cloud Msg local $ render $ do n &lt;- liftIO $ atomicModifyIORef model $ \n -&gt; case msg of Increase -&gt; (n +1,n+1) Decrease -&gt; (n -1,n-1) at (fs "#pokes") Insert . rawHtml $ h1 $ "Pokes: " ++ show n And here they are combined with another widget that ask for the name and say hello: main = keep . initNode . onBrowser $ peekPoke &lt;|&gt; hello hello= local $ do render $ rawHtml $ br &gt;&gt; br name &lt;- render $ inputString Nothing ! placeholder (fs "your name") `fire` OnKeyUp render $ rawHtml $ h2 $ "hello " ++ name placeholder= atr (fs "placeholder")
I've upgraded the repository. I took the liberty to use an `update` function that is quite similar to the elm `update` function.
I know it does but its a little too basic. I would love to have the todomvc tutorial but with composition, the only good example I found its all in one file.
Looks like that’s exactly what I need, thanks!
The best way, in my opinion, is to use `never` from the [basics-extra](http://package.elm-lang.org/packages/elm-community/basics-extra/latest) package: import Basics.Extra exposing (never) Task.perform never TimeSuccess Time.now The type of `never` is funky (`Never -&gt; a`) but it's basically a way to say in these kinds of cases 'this can never happen' and actually have the compiler verify that.
Thanks for the help, everyone (upvotes all around). I'm going to retool the code and re-push. (As well as re-document.) This is a learning exercise for me and some lightbulbs actually went on as I was documenting so this is all valuable input. One of my downfalls is I've not internalized the libs; I just don't know what's out there or what it does, or what's good and what's crap, so the pointers to things like `basics-extra` is also good.
Thanks; this works for me (actually all of the suggestions have), but I'm still wondering... Since `Time.now` never fails, it will never try to call that constructor. But is there nothing anywhere that looks at the return type from `never`? Which is a polymorphic type, right? I guess I'm asking, what *IS* the return type of `never`, in the context I'm using it? Or does that not matter here; is the compiler saying "never going to call this, so I don't need to reify it with a concrete type" or something along those lines?
Thanks for this; will definitely give this a look and some thought.
Out of curiosity, how'd you wind up working with Elm without Node installed on your machine? I expected that most people graduate to Elm from other frameworks in the Node/JS ecosystem, not come to Elm directly. (It's cool that you did though.)
I studied Java and Python several years back but haven't really done much practical programming. But I live with a software and was wanting to get back into programming, and he recommended learning a functional programming language and had heard good things about Elm. Do you have any recommendations as far as developing a useful knowledge of the language outside the first party guide? 
Thank you so much for your comment. This is the type of feedback I wanted! I had struggled with how to not use a `let` in `nextItem`--I didn't know I could use a wildcard/variable in the pattern match. Thanks a ton! Updated the code with these suggestions and it is _much_ nicer.
Thank you so much for this feedback. Amazing! I implemented the first two bullet points and it's so much better. Thank you! I'm actually a bit conflicted about using `unfoldr`. It's great (and I updated the code to use it, and it's vastly cleaner) but sometimes I feel like using these "tricks" just obscures the code. Is it a commonly used function? Also, I'm now struggling to implement a feature where I update the UI as each number is calculated, instead of waiting for the whole list to compute. I think this is a drawback of unfoldr? Or is there a way to update the model each iteration? 
Not quite sure I understand the problem that well, but since you mentioned a SPA, I'd consider switching to [Hop](http://package.elm-lang.org/packages/sporto/hop/5.1.0/). You can then use a [`NavigateTo`](https://github.com/sporto/hop/blob/master/docs/navigating.md) as your command in [this line](https://github.com/ashishsc/simple-spa/blob/master/src/Players/Update.elm#L35) and let the routing handle that work. Intercepting `Msg`s on the parent level is something you'll want and need to do from time to time—it's not a bad practice, because you might need to do things to the main model outside your component or append some values before passing it back into your child. Most other parent-child communication is done via a lot of `map`ping from parent types to child types.
Thanks ! glad to know I'm not violating TEA
By the way, source is here: https://github.com/MrMovl/pokeGoProgressPrediction Some people already found problems, I think when inputting strings for the date.
Thank you so much for this detailed feedback! Those are great suggestions and I will definitely make those changes, I'm especially keen to make the config a separate argument to the view function!
On `unfoldr`, it is probably not widely used in Elm because it is not in the core library. There is a point of view I learned of in the Haskell community that prefers using folds and unfolds to general recursion wherever possible. People compare it to writing loops with for or while rather than using goto. You might lose a little generality, but you gain readability (for those familiar with the idiom) and you make it easier to reason about how the recursion behaves, which helps eliminate bugs. My feeling is that this is not a trick, and is good style in line with the philosophy of Elm, but others may disagree. In your particular case, `unfoldr` is a very good fit for what you are doing. It starts with a seed value and repeatedly applies a function that produces an output and a new seed. Then `unfoldr` builds a list of all the outputs, until the function returns `Nothing` indicating that it is finished. This is slightly more general than what you need, since you will always have the new seed value the same as the output. The list-extra package also provides `iterate` for exactly this case. You are right that `unfoldr` will probably not work if you want to get the results as they are available rather than waiting for the entire list. (To some extent, this is a drawback of Elm being a strict language rather than lazy.) But you will find that the domain-specific pieces you need for `unfoldr` are exactly what you need for the incremental version. The remaining bits are all control flow and communication.
Thanks for the (very) informative answer. Can you elaborate a bit on what you mean by: &gt; But you will find that the domain-specific pieces you need for unfoldr are exactly what you need for the incremental version. The remaining bits are all control flow and communication. You're exceedingly helpful. Thank you!
If you need keys that change at runtime, don't use a record, use a Dict: http://package.elm-lang.org/packages/elm-lang/core/4.0.5/Dict
You can't create a dynamic record. Use Dictionaries instead. http://package.elm-lang.org/packages/elm-lang/core/4.0.5/Dict#fromList
When you set up some kind of recursive/iterative computation, there are two parts. First, there is the domain-specific part that determines what you want to compute. In this case, the single-step `collatz` function, plus a test to determine when you are done. The other part is the recursive/iterative control flow and the communication of the results to where they are needed. This part is not specific to your computation, so it is a candidate for pulling out a general pattern or abstraction. `unfoldr` is an example of this, since that function just wires together the computation you give it. I would guess that the incremental version you are trying to build will not reduce to just a single function you could stick in a library, but you might discover a pattern that can be reused in other projects.
 import Html exposing (..) toTuple : List a -&gt; Maybe (a, a) toTuple xs = case xs of [a, b] -&gt; Just (a, b) _ -&gt; Nothing main = Html.text &lt;| toString &lt;| toTuple [1, 2] 
Thanks! Trying to get the hang of doing things the Elm way.
If you have any questions on how to implement these suggestions, hit me up (@greg.ziegan on Elm Slack). I'm wrapping up my new API for elm-autocomplete right now :) The branch is still sloppy but you can also look at https://github.com/thebritican/elm-autocomplete/pull/30 for example code
Ideally you'd never hold the pairs as a list though. That is a Python thing. In Elm it's better to put them in a tuple directly. If you are getting those values from JSON, you can use [`tuple2`](http://package.elm-lang.org/packages/elm-lang/core/4.0.5/Json-Decode#tuple2) to extract them to a tuple directly.
Seems neat, but there's a bunch of spelling errors that you might want to fix :) 
Great explanation, makes a lot of sense and should definitely be part of the Docs for Elm, thanks!
All I'm getting at here is that these terms create ways of thinking. To say "parent-child communication" implies that thinking about an Elm application in terms of "parent components" and "child components" is a useful and good thing to do. And *that* implies that "components" is a good way to think about Elm code. ### Components are Objects I think this whole line of thinking about components (from JS world) has been tripping people up with Elm. I was somewhat blind to it because I come from a different background, but I see it much more now. The concept of "component" is fundamentally an OO idea. It is just an object. I have private state. I have public accessors. If you make a `new` one of me, it is different than all the other ones. Etc. The only reason people don't see the direct connection is because the term "component" hides the equivalence. If someone came to Elm and said, "I want to make my whole program out of objects!" Everyone would know that's not a good idea. Elm is not *for* that. But when people come and say "I'm having a hard time making components!" no one really questions the underlying premise that's obviously misguided when you use other terminology. ### Overzealous Naming So my point here is not that any particular patterns here are bad. In fact, the elm-autocomplete video explores ways of configuring `update` functions [around here](https://youtu.be/KSuCYUqY058?t=1h14m50s) and you'll probably find it looks familiar. My point is more that overzealous naming and conceptualizing can very easily lead people to bad results. I'd rather teach the lesson of "look, you can add more arguments to your function" than "here is a particular way to add a particular argument to a particular function and it has this particular name". The beauty of functional programming is that the core language is so flexible that you can always find a way to do what you need *without* crazy stuff! Does it make more sense what I'm getting at though?
I'm fairly sure that you do *not* want `always &lt;| Debug.crash ""`. Instead you want `(\_ -&gt; Debug.crash "")`. The former will evaluate Debug.crash as soon as the `always` expression is evaluated. The former defers it until the lambda itself is evaluated.
Good point, I'm totally with you on this idea! Elm is not about stateful components at all. I can't think of a better name for a component, but I have tried to [improve](https://github.com/halfzebra/elm-examples/commit/eccba7b415884c869baec4a74a4d6c1e3f22517a) the documentation for the examples, to get away from the "parent-child" and "translator" as far as possible. Please have a look!
I don't think those changes fix the fundamental problem. I think we should drop the word "component" from any advice, unless we are mentioning it to warn people that thinking in that way will lead you to write silly Elm code. Read through Richard's messages in [this thread](https://groups.google.com/forum/?fromgroups#!topic/elm-discuss/_cfOu88oCx4). Our terms need to implicitly lead people to do what he is describing. In the end, it's not about terms, it's about mindset and framing. This means there is not a small cosmetic or terminology change that'll fix examples that are rooted in the concept of "components". Figuring out the better way is hard, which is why I took a break from guide to think about it more. ### Early Recommendation So my tentative plan is to never call anything "components". That term does not exist in Elm. Instead frame it as "refactoring" or "reusing functions" or "using modules". If you want to talk about "components" it should probably be something like this: - If you come from JS, you are used to creating "components" but that's not how things work in Elm! Instead follow [these rules](https://groups.google.com/d/msg/elm-discuss/_cfOu88oCx4/6tVXN2TGAgAJ). - You may be used to using *components*. In Elm we think in terms of *modules*. Instead of reusing *state* we reuse *functions*. When an app gets bigger, reach for [these three techniques](https://groups.google.com/d/msg/elm-discuss/_cfOu88oCx4/6tVXN2TGAgAJ). Things like this. Basically, make the connection but be explicit about how our alternative is different. ### Bigger Picture We can't settle with terminology. If I was okay with that, Elm would have monads and applicative functors. Instead, we thought about it for a few years until we came up with the name `andThen`. We avoided a whole boatload of pedagogical problems by choosing the *right* term and framing. People just "get it" and no one has to write a tutorial. So my early recommendation may not be perfect, but we can't settle on "component". If you have been reading elm-discuss for the past year, you can see the immense amount of time lost to people wrestling with the concept of "components". When we get the pedagogy right, that will stop happening and no one will feel the need to write another tutorial.
Given that translations are one of those things where you want to easily be able to let a community translators add new content, and where you want to be able to support partial states of translation, I'm not sure a closed union type like the one Elm provides is a great choice. Localization is complicated enough that it probably would be better just to depend on a library. Perhaps one approach better than the conventional one of keeping everything in markup to get looked up would be to provide "localizable" string literals as part of the language (since this needs some support for static transformations). Or just use a database...
While this is good for the top-level component in an app, I was personally trying to find a way to run some command or task as soon as a child component displays the first time; something directly analogous to `React.componentDidMount`. This is not as simple as when using `init` because the actions shouldn't fire at app-init, but rather at some point after the app has started but some new component comes into view. I believe that I have answered my own question, but I'm going to put the solution here for feedback and reference anyway… There must be some action which triggers showing a view, so when updating the model when handling that action, we will need to pass the new init-task along up the chain. update msg mode = case msg of ListUsers -&gt; ( { model | selectedView = Views.Users }, fetchUsers )
You don't necessarily have to *all* of the union's types accounted for. You could `_` wildcard out the `case` statement and return a `Maybe`/`Result` or `String.empty`, test for that, and fall back to another language. You're right though, that this may not scale to everyone's use case, but currently that library doesn't even exist for Elm.
Very cool! I think the type safety aspect could be worth emphasizing even more - it means you can fearlessly add new language options or new phrases, knowing that the compiler will let you know about any code that needs to be updated. I can also imagine creating reusable functions for little things like formatting dates or currency values in different styles, which could then be reused by different translators. Lots of possibilities...
I think there's a better way
Thank you for this! Definitely going to start using [elm-decode-pipeline](http://package.elm-lang.org/packages/NoRedInk/elm-decode-pipeline/2.0.0/)!
Might help to write a bit about yourself or link a twitter profile. And for selling products in Germany you might want to put some terms and conditions on your website.
Most definitely! The stdlib way was clunky. I am trying to introduce elm and this bit was the one I was dreading explaining. Now that feels very much like the Elm Way™.
There are a couple of ways you can achieve this. If you are comparing against the person's `id`, then you can simply provide the selected id into the `personOption` function and it will auto-curry with the value. personOption : Int -&gt; Person -&gt; Html Msg personOption selectedId person = let isSelectedPerson = selectedId == person.id in option [ … ] [ text person.name ] personSelect : List Person -&gt; String -&gt; Html Msg personSelect personList selectedId = div [] [ select [] &lt;| List map (personOption selectedId) personList ] Further, you can check out `List.indexedMap` which also provides the current index, which would help in the case that you want, say, the third option in the list to be selected. indexedMap : (Int -&gt; a -&gt; b) -&gt; List a -&gt; List b For example… personOption : Int -&gt; Int -&gt; Person -&gt; Html Msg personOption selectedIndex index person = let isSelectedPerson = selectedIndex == index in option [ … ] [ text person.name ] personSelect : List Person -&gt; Int -&gt; Html Msg personSelect personList selectedIndex = div [] [ select [] &lt;| List.indexedMap (personOption selectedIndex) personList ]
Brilliant. Worked like a charm! Thank you.
Yes, but the tricky question is: can this post make it in /r/programming ;)
This is really interesting! Starred so that I can checout the repo later. Now I really want to hookup a phoenix server to someones twitch chat and do some kind of analysis and display results in elm..
While working on this project, I ran into many other projects that interfaced Twitch IRC servers. The one that really stood out was https://twitchstats.io. It does all kinds of stat recording (in real time), might give you some inspiration!
I've wondered about this, too, because I think handling new component creation and message passing is difficult and annoyingly verbose as is, but it could be that I'm too noob to understand its beauty. Why is it that you want to make flat components?
This is absolutely neat, I've had intentions to rewrite myself a better twitch UI, your implementation of the chat, which is probably the biggest part, will help me greatly. Thanks!
That's awesome. Not everything has been implemented yet from the IRC protocol. Checkout `src/Twitch/Chat/Types.elm` to see what's been implemented.
Could you explain what is hard to read here?
I think it's just that I've written so many UI components and have been writing React/Flow for so long now, it's hard to know what the "best practices" are. It's a chicken and egg thing, because large companies aren't using Elm yet (read: Enterprise) and thus, the community isn't as big, so there isn't as much tutorial or best practice content. 🔄
Personally, I would move the inner case expression into a new function, but I don't have a huge problem with this nesting. I often think of each case branch as it's own function. If I was to complain, I'd say the let binding "res" is superfluous.
The Elm discuss mailing list is the place to be. The community is really supportive. Questions like yours are not at all uncommon. https://groups.google.com/forum/m/#!forum/elm-discuss
In the post that I linked to above (https://groups.google.com/forum/#!msg/elm-discuss/_cfOu88oCx4/6tVXN2TGAgAJ) The Esteemed Mr. Feldman (possibly the most experienced Elm developer alive) recommends using a nested parent-child architecture only as last resort. I find that a fascinating and refreshing perspective! The potential it has for simplifying our Elm code could be huge. My only question is... how? If you have UI components that need to maintain their internal states, how do you do that without updating them as child modules? I haven't found any examples that demonstrate this. I've tried (in my Gist example that I linked to) - and failed. ... This question is still open - anyone else care to comment or help provide a solution?
&gt; "The fundamental fact about learning: Anything is easy if you can assimilate it to your collection of models. If you can't, anything can be painfully difficult.” - Seymour Papert If you don't have a functional background, Elm can be quite different and it will take some time to get used to the new tools. Once you get the functional model of approaching a problem, with pure functions and immutability, things will get way way easier. [This video](https://www.youtube.com/watch?v=E8I19uA-wGY) is a gentle introduction to some of the functional tools you might find in Elm. (the video uses F# for the examples but the Elm versions are very similar) Also, Elm is quite practical so, if you challenge yourself to accomplish small tasks in it, you will have small wins that will motivate you to move forward. If you focus on practical things, people in the Slack channel or the mailing list will be able to assist you. 
I am no newbie to functional programming concepts, but Elm's syntax still manages to throw me for a loop and I do still both read and write Elm noticeably slower than Lisp, Elixir, etc. I'm hoping it goes away with more practice.
x-posted at [Elm-discuss](https://groups.google.com/forum/#!topic/elm-discuss/VsrB2_v6G08)
Seconded. Elm (Evan, really, I guess) tries very hard to gloss over any complexities in functional programming, and it seems to work for the most part. Without prior experience in Haskell, though, I'd probably find the lack of rationale for some things in the Elm docs maddening. Haskell both as a language and a community approaches FP in the *complete* opposite direction, but the resources are very high-quality and much more abundant.
Done the course and waiting for the next one ... I think it's really well done.
I think this book will be the best resource by far. It teaches you just enough to get started without being overwhelmed and refactor what you did earlier as it teaches you new concepts. I think it works better than the usual “bear with me this is going to pay off later”. Unfortunately, the book is barely started.
Totally. It's free, it's paced well, and gives enough instruction as it goes. I would recommend at least keeping up by typing what he's doing and making it work rather than just watching. This will require a lot of hitting the spacebar to pause, but worth the effort. If you're feeling saucy, as soon as he says what he's going to do, pause it and try to write it ahead of his, then see how you do compared to his solution. I don't have a JS background so my context is different than yours, but I found this class to be one of the best I've taken; I've already paid for #2, and am thinking about doing his React one.
One of the cool things about Elm is that it forces good/best practices. Are you struggling with how the pieces work together or do you feel like you're writing a jumbled mess of spaghetti?
I'm just learning Haskell at the moment, and I wondered why the signature you gave wasn't `m a -&gt; (a -&gt; b) -&gt; m b` - I'm in the process of forcing myself to read type signatures and infer the function. Obviously I've supplied a (edit: ~~monadic~~) functor map, have you supplied something that I should recognise? Thanks!
So, what you've supplied is what Haskell calls `fmap` from the Functor class, and what Elm calls `map`: it lets you apply an operation to a value wrapped in something. For List, you apply it to all the elements in the list. For Maybe, you apply the function if the value exists, or leave it as `Nothing` if it doesn't. You see this a lot in Elm with HTML: Html.map has this form, and lets you translate between different message types of Html. What I've described is used to chain the monadic actions together. It's called a bind, `&gt;&gt;=` in Haskell, or `andThen` in Elm. It says "take this value wrapped up in the monad, and a function that knows how to deal with an unwrapped value, and I'll apply it to the wrapped value". For example, you can use `andThen` in Elm to chain the results of expressions returning `Maybe`, building longer computations that might fail at some point. Or you can use it to chain Tasks together to make more complicated IO actions.
Ah, I think I understand, though I'm still not grokking monads - I'm reading the Haskell book and I'm nearly at that chapter so I hope that'll clear things up for me! Thank you for explaining the difference and noting that it was fmap I was describing, it's really helpful for me :-) 
I've had the hard time wrapping my head around elm at first too. I did try to clear my mind about imperative programming and try to find the pattern in elm by trying and playing around with the examples. Then try to write it again, and type all the codes you see, eventually I see the patterns. 
You're not the only one. Sometimes a new language (and more so if it offers a different paradigm) takes more than one try. Give it a try, and if it doesn't click, let it go for some time and try later :) Your brain will probably do some processing in the meantime. (I had a break of about two months before tackling Haskell again after my first, unsuccessful try, and it clicked.)
No I know, sorry. Was referring to the article I linked to. What I meant was more around questions like: "If Elm is statically typed, (which seems 'strict' if you're coming from JS), why do function signatures have enumerated parameters if they can be sidestepped/partially applied by way of currying?" 
Because you're not sidestepping at all. You're using the signature exactly as it's written. First to remember is the parentheses: when you have `f : Int -&gt; Bool -&gt; Float`, this is actually `f : Int -&gt; (Bool -&gt; Float)`. So in the "fully applied" case, you do something like `f 3 True` and you get a `Float` value as a result, just like a multi-parameter function in JS. But if you only give it one argument, the result you get is *exactly what the type signature says you'll get*. If I do `f 3`, then I get a result of type `Bool -&gt; Float`. I can save this for later on, giving it a `Bool` to get a `Float` result. Or I can pass it as an argument to some higher-order function. When you do multiple arguments, something like `f 3 True`, you're actually doing `(f 3) True`. First you give `f` the argument 3. This returns a function which takes a `Bool` and returns a `Float`. Then, we're giving that function the `True` value, finally getting a float. The point is, at no point are you breaking the type signature. Rather, the type signature has the currying built into it. 
&gt; Remember the struggle to find a little date picker widget in js ? Now you can code that in Elm easily. You don’t need to import all the dependencies of jQuery UI + jQuery or another bigger framework. What does Elm do to make it so you don't have to import dependencies? &gt; Forget about integration tests, used to test a “global state”. There aren’t any in Elm.... Isn't global state something all UI application need to implement one way or the other? &gt; If you are used to Capybara or PhantomJs, you can just … forget about all that. To test your Elm programs, you only have to write unit tests for your Elm functions. That’s it. When I say everything is pure functions, that also includes html tags. How can unit tests replace integration tests?
Are you using keyed elements?
Yeah I came accross this post in the elm google discussion group which really made me think about alternatives in elm: [Inter-Component Communication in 0.17](https://groups.google.com/d/msg/elm-discuss/i99LBvYSkpY/yQyk6WB0AAAJ)
As for the last question: it seems that this should be possible and retain some of the type safety by staying inside Elm. The ports variant has bigger chance of throwing that out of the window. As for the gist of the post - yeah, Elm makes you be explicit but the developer experience is not the same as in React-before-connect. The compiler errors really guide you a whole lot and it's way, way less painful. So: - React before connect: explicit but painful - Elm currently: explicit but pleasant (guides you) - React with connect: pleasant but magic - (maybe in the future?) Elm with connect Task or something: pleasant, kinda magic but guides you Edit: formatting bulletpoints
here: http://package.elm-lang.org/packages/elm-lang/html/1.1.0/Html-Keyed You probably should also look into [lazy](http://package.elm-lang.org/packages/elm-lang/html/1.1.0/Html-Lazy), if you aren't already using it. If you still have performance problems, then you might want to only render a small part of that whole list, e.g. look into how to display infinite lists
Here's my [gist](https://gist.github.com/MichaelCombs28/d1f96edab8b9085bfbe61231386f08a6)
Thanks so much, that's extremely interesting! I would *love* to abandon the parent-child paradigm... but my poor, tiny brain just can't conceive of how. For example, how could one re-factor the Counter Pair (http://guide.elm-lang.org/architecture/modularity/counter_pair.html) and Counter List (http://guide.elm-lang.org/architecture/modularity/counter_list.html) without updating nested children? 
There should be, but I haven't really found one yet. Besides fold and unfold, recursion schemes are quite obscure. Finding good names for this kind of general concept is really hard.
thanks! I couldn't quite get the hylomorphism to work in a nice way. I like the paramorphism because all the problem-specific logic is in one place. This is slightly more like the actual body of a while-loop. Out of curiosity, do you know of actual (somewhat common) use cases for para- and hylomorphisms? From what I've read they are mostly studied and seldomly used. 
I mostly see this in the Haskell world where there is no need to use an explicit hylomorphism. Haskell's evaluation strategy means that if you just compose a catamorphism onto an anamorphism, the intermediate structures are not created (at least for lists). There are also lots of ways to play with the type signature of hylomorphism. For example, the most direct translation of a while loop might be: while : (s -&gt; Bool) -&gt; (s -&gt; s) -&gt; s -&gt; s while p step s = let reducer = always expander a = if p s then let s' = step s in Just (s', s') else Nothing in hylo reducer expander s s Really, anywhere you have a loop, you essentially have a list hylomorphism, but I don't know if they are explicitly used. I think by the time you need paramorphisms, most people give up and use general recursion. (I probably would.) The problem I have with your `paralMut` is that it really doesn't look like a paramorphism. One of the key aspects of catamorphisms and paramorphisms is that the shape of the recursion is that same as the shape of the input. So when the input is a list of length n, you iterate n times through in a linear order. (If you define catamorphisms for trees, then you can have recursions that branch.) In particular, a catamorphism terminates if its reducer terminates for all input and its input is finite. But what you have doesn't act like that. In the example, it gets a list of length 4 but takes 12 steps of recursion. Depending on how you update the input list, you can easily create an infinite loop. (Anamorphisms (and hylomorphisms, which contain them), on the other hand, offer no such guarantee. That is an essential difference between initial and final (co)algebras. The promise you get there is that the shape of the recursion is the same as the shape of the result. Infinite recursion yields infinite list, though you could have a hylomorphism with a sufficiently lazy reducer that would let you have a finite loop.) In general, I also think separating the reducer and expander logic is a good thing. It let's you test them separately, for one thing. In this example, I know that `cata accum` should be the same as `String.concat &lt;&lt; List.reverse &lt;&lt; catMaybes` where `catMaybes : List (Maybe a) -&gt; List a` returns the list of all the `Just`s in its input. (Since `String.concat`, `List.reverse`, and `catMaybes` are catamorphisms, you might actually be able to prove that, not just test it.)
So this is a perfect use-case for nesting: https://youtu.be/OAgF2uUnKcg?t=4105 You build an entire game where each game instance has nothing to do with another. There's also nothing really interacting in a parent -&gt; child, child -&gt; parent fashion. If one could influence another... they probably shouldn't be nested bc it would be an entirely different game! You'll get a good sense of when to nest when you see it. Counters may be a bit contrived to show a simple, minimal code example of nesting. I suggest nesting nothing and ping the slack channel if you're even thinking about it in #help! Most times we'll arrive at a cleaner solution w/o parent-child.
Do you have this project on github? Looks pretty cool.
Yep, https://github.com/ivanceras/curtain and there is also a demo on free tier of heroku http://curtain-elm.herokuapp.com/ Just click on 'Connect to Server' with the default values, then you can play with the app.
awesome, thanks man!
What you describe does not sound like what I'm suggesting, because you are still threading things through places that don't need those things. To run with your example, if the CountrySelector needs an A from Main, and neither Sidebar or Configuration care about A, then what I'm saying is you need a function from A -&gt; CountrySelector and the resulting CountrySelector is the one you wire into your application. It's very basic functional DI. Is there a reason that this approach doesn't work in Elm?
I am making myself confused here trying to understand what you are saying. Perhaps I confused things with my syntax describing the nested components looking like a type (changed in my original post now). Here is what `CountrySelector.view` looks like (order can be changed if required): module CountrySelector exposing (..) view : (String -&gt; msg ) -&gt; List Country -&gt; Country -&gt; Html msg -- message constructor -&gt; selector elements -&gt; currently selected -&gt; html Here is `Main`: module Main exposing (..) view : Model -&gt; Html Msg view model = div [] [ Sidebar.view ] The currently selected country is potentially needed by other components, so `Main` needs to be able to understand how to extract it from the `Model` already, so it is best if it is the one that has the code for handling that. What does the type of `Sidebar.view` look like? How do we get the currently selected country into `CountrySelector.view` and get the results of that into `Configuration.view`? I don't see how partial application allows either `Sidebar.view` or `Configuration.view` to be completely ignorant of this data coupling.
&gt; What does Elm do to make it so you don't have to import dependencies? Nothing? You still have dependencies. They're managed by a kickass package manager that enforces semver but they are still dependencies. &gt; Isn't global state something all UI application need to implement one way or the other? Yes but since 100% of your functions are pure, you can entirely ignore the concept because none of your function be affected by anything else than its input. &gt; How can unit tests replace integration tests? It doesn't. At least not for NRI that employs Evan, they still use Capybara.
&gt; Mutating the global module state like this isn't allowed in Elm. I'm not sure where I suggested mutation. I'm talking about a closure over a read only function that produces essentially a readable lens over your monolithic state. &gt; ten to twenty minutes Not been my experience. Dependencies usually have dependencies. When you have to thread something through layers that don't care about it, coupling is contagious and the odds that you have to make unfortunate design choices get high pretty quickly. &gt; but monads are central to how Elm works Cool, is there somewhere I can learn more about that? I haven't seen the term used in any of the stuff I've read, mainly some google threads about whether to use the terminology. I realize there's a form of do-notation, but if I wanted to explicitly leverage a Reader or State, I'm not sure where I'd look for an existing implementation or example of how to implement my own. &gt; creating a pure functional ecosystem which is accessible is, perhaps, the most ambitious and frustrating part I can totally buy that. I've had a role in my last two companies which required me to ramp folks on these concepts, and worked with a publisher for some time on a book covering the same before realizing it was too much on top of regular workload, and the experience has led me to believe that the perceived inaccessibility is kind of an accurate reflection of the amount of information there is to learn, and not in fact a function of how the info is presented (though there's plenty of variance in quality.) In learning and teaching FP, I find I often have to remind myself that OOP was once a highly daunting and seemingly insurmountable source of confusion too, it's just that most folks have long since pushed through that and now take it for granted.
I've done a couple of prototypes, one of which was for a waverider buoy display. In the end, I switched to ghcjs and reflex-dom as the backend is in haskell and I was more comfortable with haskell. Looking back on my code, I used flot for timeseries plotting. What drove the change in the end was the need to use ports to communicate with flot and my lack of understanding of these and javascript. The other pain point was keeping my haskell and elm datastructures in sync. As the backend was also under active development, changes were frequent. There are tools to assist, but each time I made changes, it was a fairly manual process to to chase these through on each side. To my mind the biggest gap in elm for this type of application is the lack of native plotting and also the lack of map (google or otherwise) "widgets". edit: more details
You could use ImmutableJS and react/redux to get some of the way there. 
See if you can work on a side project to show them the wins. If the wins outweight the losses, you'll have their ears. This in no way guarantees you'll get their hearts.
Can you describe the pure JavaScript implementation that you are referring to?
So in a nutshell I guess it needs to be an abstraction over the concepts mentioned in http://guide.elm-lang.org/architecture/ I just read https://www.infoq.com/articles/no-more-mvc-frameworks and although I don't agree with the author, the article does contain some interesting concepts, especially TLA+. Comparing it to the Elm Architecture, I guess I'm looking for a lightweight "lib" that allows me to abstract Models, Updates (Messages/Actions) and Views.
I should've been more specific. I'm looking for a lib/framework that implements the Elm Architecture as described in http://guide.elm-lang.org/architecture/
I realize in your quote that I might have come across poorly, when I said "your monolithic state" I meant you as whoever the hypothetical developer is, not you personally. I'm actually not opposed to building a huge state object and passing it all over when it's immutable, and I tend to do it fairly often. Thanks for the insights, this was a really helpful exchange for me in my understanding of elm relative to my overall picture of FP.
It's an opaque type. Which basically means that you cannot look into how its made from the outside, so if you decide to change its details later, it won't cause a major version bump. Usually a good practice to expose only what you really need to expose.
Thanks for this. This looks good!
thanks, that makes sense.
Take a look at https://github.com/paldepind/functional-frontend-architecture (this collection of libraries helped me understand elm coming from js). Good for teaching but really you miss half the benefits without the elm compiler...
Also have a look at Redux loop - https://github.com/redux-loop/redux-loop
I'm actually going through the Egghead video's right now, looks great! Thanks!
Great video, thanks for the link! Does Elm have the Option.map thing he discusses around the 45 minute mark? I believe (if I understand correctly), that it sort of wraps a function's inputs and outputs as Maybes. It seems similar to andThen, but not exactly the same.
I really like these kinds of tools. In essence this is what bugs me about JS development, the lack of static typing. For small / quick projects its nice, but for larger projects I'd rather go for a language with a static type system like Rust or Go.
Can't you just monkey patch that panorama runtime to support the functions you need, e.g. just define var setTimeout = $.Schedule; var console = console || {}; console.log = $.Msg; etc.. before loading elm. Would that work?
Absolutely. That's what I tried and considered going with, but it just doesn't feel right, you know? Especially after those words in the latest elm blogpost about platforms, different backends and maybe even compiling into something that's not javascript.
I see, thanks for the insight!
For what it's worth, I think you should post this on the elm-discuss mailing list. It's good to get a data-point for where someone is using Elm, and it might inform future development/decisions.
cycle.js is close to Elm 0.16 (with Signals), probbaly not that close to Elm 0.17
Personally I think it's a good thing that a language not advertising itself as a v1.0 yet allows you to use JS through ports where it's lacking - that makes it seem way more practical to me.
This has been reported many times in the error-message-catalog, resulting in [this issue](https://github.com/elm-lang/error-message-catalog/issues/154). It is complicated to fix, but I'm excited to get this to folks!
you have [Maybe.map](http://package.elm-lang.org/packages/elm-lang/core/4.0.5/Maybe#map) and it behaves the same as the Option.map from the video. 
Must read till end - surprises throughout
Dart and TypeScript do not count?
I interpreted it as excitement on the part of OP.
&gt; Are my concerns irrational? Yes. :) Give it a try. Playing with it a couple of hours a day for a week will get you to a point where you understand enough of the language to make an informed decision about overhead and complexity. Elm constrains you to do things a certain way (immutability) and in doing so, liberates you from a host of troubles. 
As of about 2015, runtimes are were reliably fast enough that you could consider HTML5 just another compile target platform for any high level language. And, if you're already using modern JS frameworks, you're essentially just compiling down from new JS to old JS anyway.
I don't know why you think there would be overhead from a compile-to language. It shifts work from run-time to compile-time, so it has the capability to be faster.
&gt; Optimizing Elm cannot introduce sneaky bugs, unlike everyone else. Well that's not true. Trying to slap `lazy` on a view function broke the entire type system for me once and was nesting ADTs inside ADTs instead of changing the value it contained inside my Msg. My update function started doing weird things because `case` compiles down to a `switch` and the last thing in a case actually gets set to `default` in JS so I was constantly getting the last command. I spent an entire day hopping through compiled source to find out that it had to do with `lazy`.
That sounds crazy! Did you open an issue about it?
&gt; Naively, I am concerned about the overhead and complexity of using a compile-to language. I would argue that modern Javascript is a "compile-to" language, and a not especially safe one at that!
I tried to, but I had trouble making a simple way to reproduce the bug... after spending an hour not getting that to work, I had to get back to real work.
Well, if you ever get the time, please file a bug report. :)
Thanks for this! I've recently started drinking the elm koolaid... I think it's laced with something. Can't stop learning it.
Well, I am concerned about errors in the compiler, as well as the loss of control at the low level (high level really) core of the code. This isn't really conclusive, how about this. Is debugging easy?
It was about 1.5-2 months ago, so maybe it has been fixed up. I can tell you I did have to nest maps so… Since then, I've just ripped out all the `lazy` and plan to put it back later.
Okay, timeline seems about right. Sounds like `map` was the true culprit! Make sure folks know on elm-dev if you encounter this again with the latest `elm-lang/html` package. Even if you cannot get an SSCCE on your own, folks on Elm slack may be able to help figure it out!
&gt; errors in the compiler are equally likely to be in a JS interpreter. More-so, even, because an interpreter is much more complex than a a compiler taking a high-level language (Elm) to another high-level language (JS). &gt; loss of control at the low level This is definitely true, but it's a two edged sword. Elm is working on giving you more and more control over the web API and things like that. But not having this control makes your code safer, and in some cases, faster. You can avoid doing safety checks that are necessary in JS, because you've got a static guarantee that these things aren't allowed. For example, Elm lets you compile all your JS with the `use strict` flag, which increases speed. &gt; Is debugging easy? Fairly. The types and static nature of the code make it a lot more clear where values are coming from. Debugging code with `eval` can be a nightmare. The compiler also prevents a lot of debugging. There are entire classes of bugs that are simply impossible to happen at runtime in Elm unless you try really hard to make them happen. Array-bounds errors, null value errors, and of course, type errors, are all impossible in Elm, because the type system makes you account for these things. So the debugging you do is focused more on the correctness of the code, whether it does what you want it to do, and less about tracking down crashes and null values and "undefined is not a function" errors. And, when all else fails, there's a fairly nice 1:1 correspondence between Elm code and its generated JS, so stepping through it isn't that hard. 
This is a great honest answer, thank you.
If you want to see a well-done tutorial (video), check out knowthen.com. The first one is free, but can give you enough to write a real app. If you want to learn it, I'd suggest going through the exercises and pausing and trying to figure out what he's going to do before he does it. But, if you just want an overview, you can just watch the vids (at high speed, even), and follow along mentally. (disclaimer: I went through the free course and loved it. I have almost zero js experience and didn't feel like I was missing anything because of it.)
Would it be possible to get Aurelia into this benchmark? It's made by a guy who used to be the Angular2 team but quit over irreconcilable differences in what javascript frameworks ought to look like. From it's documentation it looks like Angular but sane. The team brags it's very fast.
So /u/wheatBread, how does it feel to compete alone with big engineering teams at Google and Facebook and be winning? :)
&gt; Haha, it is very energizing and exciting when you first see the results! It is also great evidence that the "but there are not 10 people working on Elm full time" concerns are misguided. (That concern is better addressed by knowing the history and timeline of languages like Python that are similar to Elm in organizational structure, but more evidence is always good!) I'll take all the evidence I can get, there's people I need to make give Elm a chance. :)
That's great! :) I'm working on something like Quviq's finite state machine testing (essentially fuzz-generating Msgs not blindly but in a way and order that makes sense, and checking for some properties)... But the Elm testing landscape still changes very rapidly. For example, Max Goldstein is revamping the Fuzz / Generator / Shrink API so that users won't have to write their own Shrinkers (and so that Fuzz.andThen will be possible, which isn't possible with Shrinkers right now). So ... maybe it's a good time to wait for a bit? :)
Why not PR the repo: https://github.com/evancz/react-angular-ember-elm-performance-comparison
First one was pretty good (and free). This seems worth it. 
Has been available for preorder for at least a few weeks. But yes, I pre-ordered based on the strength of the first one, which I loved.
[Must see] - Beautiful SPA resort. Phoenix oil for your back-pain.
thank you :)
Nice project! May I suggest that you update the text field for entering your age into a `tel` field? That way, people using your app on mobile will be presented with a keyboard with just numbers. Hope that you make more apps and share them with us. 
Thanks Sir! Great suggestion, I just added it and updated the "Try it" page. 
Instead of hiding the tab's content using CSS, how about not rendering the content in the first place? You'll have much fewer DOM elements on the page and the virtual DOM won't have to work as hard to produce a diff. Edit: Here's an example in a small app that I built. https://github.com/fbonetti/phoenix_tracker/blob/master/web/elm/src/App.elm#L244-L250
I practice a martial art/sport called jiu-jitsu and I wanted to try Elm by making a *very* simple web app It's very minimalistic, it should run on tablets and phones, and since I'm a programmer, the visuals suck big time. Any feedback is welcome! 
Annotations not supported in repl, need to use elm-reactor or online compiler (elm-lang.org/try ). It is stated in the FAQ http://faq.elm-community.org/#why-does-elm-repl-report-a-syntax-problem-for-any-type-annotation-such-as-for-fib--int---int 
Just so folks know, this is still a work in progress! I'm planing to add more examples that get into techniques for refactoring your `Model` and `update` as well. The main goal was to make the guide more clear that if you want "parent child communication" you are probably going in a bad direction and should think about it different.
Thanks. Questions like "how to scale an elm architecture" help people like me feel safer about choosing Elm as a go-to-production language. The community is growing quickly but a few KEY questions like this one remain and it's nice to see that they are a being addressed.
Yes, it's overwhELMing!
So how are you supposed to write files with pure functions? 
Basically head and tail return maybes because of the fact that the list could be empty. So you are forced to handle that. Check out the Maybe type more specifically map and withdefault. Also you could use pattern matching to get what you want done. On mobile but when I'm near my laptop I'll give a better explanation if needed
Can't you just use List.take to get the first 2 elements of each list and compare them? 
Not sure if you have read through [An Introduction to Elm](http://guide.elm-lang.org/) yet, but I think it may help out a lot! For your first question, check out this section on [union types](http://guide.elm-lang.org/types/union_types.html). It is similar to combining strings like you expect, except the language actually knows about it. The compiler knows exactly how many cases there are, so it can always detect if you forget one or misspell anything. It's actually quite a bit cooler than that though! For the second question, I'd check out [The Elm Architecture](http://guide.elm-lang.org/architecture/). The reason you do not call `update` yourself is because `Html.App.program` is managing all that for you. It hooks everything up. When the model changes, it generates a `view` and modifies the DOM. When an event is produced, it is piped through `update`, producing a new model, which is run through `view`, and on and on! Hopefully that helps! Also, it can be really helpful to ask questions on the Elm slack channel.
Ok, very interesting, but say I have a list [1 1 2 3 4 8 6 2] and I want to check that the first 2 elements are equal? So is this a code smell such that I should reorganize my program so I don't have to do that? If so, far out!
Elm discuss is probably where you'll get the best response for code review. https://groups.google.com/forum/m/#!forum/elm-discuss
Thanks
I've noticed that the counter, counter pair and counter list pages have been removed after this got added. I've been working on a little application where I followed the basic pattern described in those examples, is that now the wrong way to do things?
I had the same experience with a project I did; adding a feature I thought of after the fact was easy.
Here are two solutions. The first is an attempt to emulate what you were trying to do in order to show you how to handle `Maybe` results a bit better. This sort of thing is sometimes your best option, even if there are better ways of deconstructing lists. first2Equal : List a -&gt; Maybe Bool first2Equal xs = let a = List.head xs b = List.tail xs `Maybe.andThen` List.head in Maybe.map2 (==) a b The way that I would suggest is similar to /u/jediknight's solution, but it still wraps things in a `Maybe`. first2Equal : List a -&gt; Maybe Bool first2Equal xs = case xs of a :: b :: _ -&gt; Just ( a == b ) _ -&gt; Nothing In either case, you will get `Nothing` back when there aren't two items to compare. You can always toss this into `Maybe.withDefault False` to get the simpler behavior, but it is surprisingly common to suddenly realize you care about the corner cases.
I've noticed that occasionally, getting frustrated and wanting to build something quickly without Maybes. Then once I've hacked my way around them, I find I just need to put them back in. Hopefully, once I get used to elm, it won't be an issue.
Is it a good idea to put css styles in elm code or on separate css stylesheet for easy swapping for themes and templates.
Did you browse the Maybe module? What frustrates you is probably that you keep getting your data in and out of Maybe while that is not necessary. Let say I have this function: Int -&gt; Int inc n = n + 1 And I want to apply it to the head of a list and return the head incremented by one if the list has at least one member, otherwise a `Maybe`. You might think it requires using a `case` against the result and then wrapping it back in a `Maybe`? Not quite. It's just: Maybe.map inc (List.head myList) `Maybe.map`, `Maybe.withDefault`, and `Maybe.andThen` will help you by not forcing you to unwrap your Maybes until you actually need the content.
Yeah that's the feeling I was getting. Slightly annoying that I started looking at the modularity stuff about a day before this stuff changed on the tutorial website. I get it though, passing messages from a parent to a child more complicated. BTW: That second link is a duplicate of the first, but I think I found the right thread. TY.
Actually, just check everything in Core. It won't take too long and you'll struggle much less if you know those things are here even if you need to reread the documentation to know how they work.
I would just filter it in the render, see if that performs ok, If not look at the Html.lazy module 
If you only have 5000 movies Map.filter will do perfect. You could even do it real time. I would add a filter section to your model that holds the filter values and the filtered list and do the filtering in update.
I fully concur. Any time the lure of denormalizing the model got strong enough that I did it, it bit me in the ass later as I eventually ended up forgetting to update a subset of the model in a later change. Normalize/deduplicate the model, compute from that during render, use Html.lazy if (after benchmarking/profiling!) the on-the-fly computations turn out to be too slow (chances are high that they're not) 
&gt; Should I have a list of movies meeting the requirements stored in the model, and recalculate that list each time a filter changes? &gt; Or should I have a record that just stores which filters are active, and then a chain of functions that checks whether a movie passes through all active checks somehow? This is almost feeling like an X-Y problem and it makes me want to talk a bit more basically about how to manipulate collections in a functional language. The standard collection for displaying a list of zero or more items where only order possibly matters is a `List` and when you want to transform that list into something else (e.g. `Html` nodes), then `List.map` is the right tool. This gives us some pseudocode: List.map movieToListItem filteredMovies Presumably, we have a list of unfiltered movies laying around. Filtering a list on some filter function is straightforward using `List.filter`. List.filter (movieFilter activeFilters) movies Now the issue is what does `movieFilter` look like. Here is its type: movieFilter : List MovieFilter -&gt; Movie -&gt; Bool There can be several ways to construct `movieFilter`, but the most straightforward way is `List.any`. not &lt;| List.any (filterMovie movie) movieFilters The `filterMovie` function finally gets to the place where we are actually checking individual filters against individual movies. filterMovie :: Movie -&gt; MovieFilter -&gt; Bool This filtering doesn't have to live anywhere in particular and it lives in the grey area between business and view logic, so deciding where to put it is a combination of stylistic and pragmatic concerns. The general rule is don't optimize too early, so stick it where it makes the most sense to you, try it out under realistic conditions, then fix what is broken. Performance enhancements include using `Html.Lazy` (as previously mentioned), finding ways to pre-combine filters to reduce redundency, and pre-indexing the movies to allow for fast comparisons (e.g. `formats` as an integer instead of a list of strings).
They remain linked. If you need better performance, use an Elm array. The key is that pushing and popping is fast, and that's what's prioritized. Have you seen this? http://package.elm-lang.org/packages/elm-lang/core/latest/Array JS arrays really don't work with the functional approach. Some of the List functions will use an array internally, but that is likely to change as we get better code generation. As for performance, there's certainly work to be done, but I think you'd be surprised how good it is already. Things that seem slow, like using strings for Constructor tags, end up making Elm fast. And all its generated js has "use strict" enabled. One optimization that's missing is inlining, but I wouldn't expect that anytime soon. Though other tools, like Google closure, can achieve this on the resulting js. The biggest speed boost will come when webassembly is out and we can skip JS all together. Then, things like runtime type checks can be skipped, because Elm guarantees their safety at compile time. 
I have several chapters written, I want to do some more proofing and I was waiting for elm-test v 2.1.0 to ship (which it has) I hope to ship something end of next week
Regarding the 1.0 thing, I remember remarking a while back that I was surprised at the churn since elm-core had reached 1.0 and Evan responding that 1.0 is just a number and did not reflect on stability. It may be different for Elm overall though. 
They're unnecessary, but the problem is, the browser doesn't know we've given it Elm-generated code. It thinks it's run-of-the-mill JS (albeit with "use-strict" enabled). So there's no runtime checks in the generated JS, but the JS interpreter will do all sorts of runtime safety checks, so that it can throw `undefined is not a function` errors when JS does something bad, instead of writing to arbitrary memory locations or other terrible things. These won't be necessary when we can skip JS as a middleman.
Sure, whatever you need for your data. My point is more that folks new to ML family languages often do not have a habit of reaching for union types. They should! I might change the example you gave to be like this: type Availability = Netflix | Hulu | Stan | AmazonPrime type Format = BluRay | VHS | DVD type alias Filter = { availablity : Maybe Availability , format : Maybe Format , minRating : Maybe Int , newerThan : Maybe Int , olderThan : Maybe Int } And then you design some function that takes a `Filter` and your data and sorts it all out into a reduced list. Again, the point is to emphasize that union types will make any effort like this nicer.
Is there an ETA?
You can load compiled Elm in node and interface with it by using ports. I'm on my phone right now but there is a section on this in the Elm Guide if I recall correctly.
Oh cool, thanks!
I wish I could, but not in London these days, and I love that area!
For updating the first level of data you can sometimes use record pattern matching in the parameters of the function update msg ({roles} as model) = case msg of SomeMsg -&gt; {model | roles = {roles | seinfeld = "J. Peterman" }} 
Is https://github.com/evancz/focus something that would contempt you?
Read the whole page, it tells you to follow the link to elm-lang/html. According to this issue, Evan recently changed the url of the most recent version of a package's documentation to have a consistent url (i.e. /latest). This should mean you have fewer Google garden path documentation problems in the future: https://github.com/elm-lang/package.elm-lang.org/issues/193
To be fair this is pretty confusing if you are looking for the actual docs 
That's the answer I was afraid of
I have two projects meant to be run through node (though I'm not sure I'll ever finish them): 1. https://github.com/ahultgren/elm-server - a WiP POC for "universal" (both server and client side) elm 2. https://github.com/ahultgren/swagger-elm - generates types and decoders based on a swagger document. Run through a cli As well as one package for facilitating such modules: [node-elm-stdio](https://github.com/ahultgren/node-elm-stdio) (allows you to do stuff like `cat some-data | my-elm-processor | grep woot`). In short the answer is yes :)
&gt; JS arrays really don't work with the functional approach. Why not? It's not difficult to compile the pattern and lambda body variables to eliminate `::` and `[]` and replace them with real JS arrays, and this allows you to also use the builtin `map` and `reduce` operations. Anything defined in terms of these (which should be the vast majority of list operations) will get the benefit of using native ops. &gt; The biggest speed boost will come when webassembly is out and we can skip JS all together. WebAssembly will not (at least for a very long time) include a GC. Compiling a functional language to it will be significantly more challenging than compiling to JS. The results will almost certainly be better, sure, but it's a significant step up in difficulty from writing a JS backend.
http://package.elm-lang.org/packages/elm-lang/core/1.0.0/List#foldr
You should really open this up for a remote position if you want to attract top tier talent.
As others have said, folds answer the question you asked. But I'm not sure that is the right thing to do here. Why are you processing a list of `OutMsg`s? In what you have, the order doesn't matter, and the messages look idempotent. (`Close` certainly is; there is not enough here to say if `LoadNext` is, but not enough to rule it out either.) So why not: type alias OutMsg = { close : Bool , loadNext : Bool } handleOutMsg : Model -&gt; OutMsg -&gt; (Model, Maybe OutMsg') handleOutMsg model outMsg = ( { model | isClose = outMsg.close || model.isClose , loadingPage = outMsg.loadNext || model.loadingPage } , if outMsg.loadNext then Just LoadNext else Nothing )
Yep, I had just tried playing around with List.foldl and this is how I'm using it. import Html exposing (div, button, text) import Html.App exposing (beginnerProgram) import Html.Events exposing (onClick) type alias Model = { count: Int , loading: Bool , list: List Int } init = { count = 0 , loading = False , list = [1,2,3,4] } main = beginnerProgram { model = init, view = view, update = update } view model = div [] [ button [ onClick Decrement ] [ text "-" ] , div [] [ text (toString model) ] , button [ onClick Increment ] [ text "+" ] , button [ onClick Fold ] [ text "Fold" ] ] type Msg = Increment | Decrement | Fold update msg model = case msg of Increment -&gt; {model | count = model.count + 1} Decrement -&gt; {model | count = model.count - 1} Fold -&gt; let (model', numbers) = List.foldl ( \a (model,n) -&gt; let _ = Debug.log "a, model" ((toString a) ++" "++ (toString model)) in ({model | count = model.count + a}, n++[a]) ) (model,[0]) model.list _ = Debug.log "numbers" numbers in model'
&gt; When you append to a list in a functional language, you have two valid lists. The old version of the list is still valid. [That is precisely the semantics of the Array.concat function.](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/concat)
Also, there is the option to just use the web-based environment if you just want to play around a little and not put more on your computer. I know a lot of programmers that dont want to just keep adding to there local machine. www.elm-lang.org/try
Here is some general advice. Use [elm-format](https://github.com/avh4/elm-format) to help you format your code to community standards with a lot less thinking. There are plugins for most editors to run it automatically on save. If an anonymous function is more than a one-liner, pull it out into its own named function, either at the module level or in a let. While what you are doing works, it is generally a better idea to work with smaller data structures instead of updating large ones repeatedly. Don't combine logically unrelated tasks, it just makes it more complicated to understand what is going on. I have refactored the `Fold` section with these ideas in mind. This is a trivial example, so it can be further improved, but it should show some of the ideas. let countSum n a = let _ = Debug.log "n, sum" ( (toString n) ++ " " ++ (toString sum) ) in n + a newCount = List.foldl countSum 0 model.list numbers = List.foldr (::) [] model.list _ = Debug.log "numbers" numbers in { model | count = newCount } 
1. Elements can create bools with "onCheck" event in Html.Events, you can parse ints by toInt on the string and if it's not an int add it to the form errors which you should always include in your form model. 2. This is the imperative thought process that functional programming doesn't normally allow, you can use a port to do this, you can use a really fancy Json Decoder. eg. json.at ["target", "parentNode", "children"] Json.list &lt;| json.at ["target", "value"] This is actually pretty fun to tinker with, but a whole lot more complicated than the recommended way.
The view-based events are all tied to specific DOM elements. Other sources of events such as mouse movement or clock time are not well-connected to these elements and need to be wired in somehow. Events only get processed by the update function defined in `Html.App.program`. 'Child components' are just a bunch of pure functions which only get what is handed to them by this 'main' update function. They aren't even 'things' which could even begin to 'opt-in' to events. Perhaps when the process system gets built out we will see new patterns.
The components are a bit complex and flattening these into their containing components may not be very ergonomic to do.
I should elm to my colleagues, then browse to this subreddit. He was not impressed :( "Well, there goes the subreddit of a front-end platform"
This is true only for functions which you leave defined in recursive terms, and if you do as I suggest and use the builtin concat, map, and reduce operations, that means there is no primitive recursion in any of those cases or anything which is built by combining them! Add a primitive filter on to that, and I contend you have the vast majority of list operations ever encountered in real software. The goal is to avoid ever hitting the "real" inductive data type in the first place.
I'm not sure what you mean. Is there something I can read about this?
Some thoughts: * I am on board with this idea. * No way I personally could take on a new project atm - running dailydrip and spewing my opinions into the Elm slack and MLs is enough obligation on its own, and then there's (speaking at/attending) conferences and posting to reddit. * such a thing should obviously be built in elm-css^(paging feldman &amp; friends), as that makes it more like a thing people might be intrigued by. if someone wants to start it i'll contribute from time to time though (maybe a dailydrip episode on it to justify spending an hour or two?)
 { model | roles = updateRoles model.roles } What's wrong with this?
What is the advantage of elm-css over e.g scss? It looks like a clumsier markup for doing the same, the same model with different syntax basically. Is there anything to gain from it being in elm? (Don't take this the wrong way, I just looked at it briefly and I'm not getting it yet. I'm not trying to bash elm-css or anything).
&gt; Is there something I can read about this? A quick Google search comes up empty, so probably not, haha. Anyway, it's the same idea as when we define `data Nat = Zero | Suc Nat` and then tell the compiler "ok but don't actually do that because that's ridiculous; use this builtin Int64 instead" or whatever. A Google search for that also yields nothing, but I guess it's something everyone just sort of tacitly knows about, because both the Agda and Idris compilers do this. But really, when you're writing a compiler backend, it is something that sort of jumps out at you as an obvious thing to do. [The Elm AST internally has your inductive type stored as the constructor name and a list of expressions it's applied to](https://github.com/elm-lang/elm-compiler/blob/master/src/AST/Expression/Optimized.hs#L50), so for example `1 :: 2 :: []` is `Data "::" [Lit 1 , Data "::" [Lit 2, Data "[]" []]]` or something similar. As far as I can see, it renders this with relatively little transformation into JS (it may do some inlining, but the fundamental tree shape is still there, at least in the examples and output I tried). I'm contending that you can pattern match on `Data "::" args` and `Data "[]" _` and transform them into real JS lists at compile time. A pattern match on `x :: xs` becomes `expr.length &gt; 0` and the two variables it brings into scope are `expr[0]` (x) and `expr.slice(1)` (xs), and a pattern match on `[]` becomes `expr.length === 0` and brings no variables into scope. Now, functions defined on lists compiled with the above "optimization" are probably worse than the original. But! The key is we can also now have our optimizer match on `map`, `foldl`, etc. and knock them out at compile time with versions that act on real builtin JS arrays! So as long as our users are using something we have a builtin match for (where "builtin" isn't necessarily actually part of the JS standard library -- you can write "builtins" yourself and put it them the runtime), we're actually getting big performance wins. It's only if they start defining their own functions by recursing on `::` that we get a loss. Now there's one other big win we get: FFI harmony. Because our `List` is now actually a builtin list, we can easily call (or be called by!) other JS libraries totally seamlessly (well, provided the `a` in `List a` is also a type with sensible meaning in JS, like Float or String). To me this is the real winner, and the reason I usually compile lists this way when I do JS backends. If the above seems a bit obtuse, it's kind of like trying to explain swimming; it's not something you explain, it's something you *do*. If you're adventurous and curious, try writing a simple backend [for Elm expressions](https://github.com/elm-lang/elm-compiler/blob/master/src/AST/Expression/Optimized.hs#L50) by basically writing the function `myJSCompiler :: Expr -&gt; String`. It's easier than you might think, and you may even develop an unhealthy addiction for hacking on compilers in the process =)
I like this ugly design. It makes it look un-fun and workie, like Hacker News. It's scary to Facebookers, iPad users, and parents - which is cool. 
Where have I done anything that would affect referential transparency? Taking length, comparing for less/equal, slicing, map, reduce--none of these affect the original array. Now if you're referring to trying to figure out when the original array isn't needed so we can reuse its space without anyone noticing, that's a totally separate matter, and indeed quite a bit more difficult.
The problem is building arrays with concat is too slow and it's not going to be possible to build arrays at compile time most of the time. But I've just remembered a way you could build these arrays efficiently. Find a copy of Chris Okasaki's Purely Functional Data Structures book and read the section about binary random access lists. He describes a tree-like data structure for array use cases. You could so something like that except with native JS arrays underneath instead of a tree. I wonder if Elm's Array type is similar to this. The idea is that your array is a bunch of smaller native arrays. You take the length of the array and convert it to a binary number. The 1s in the binary number are JS arrays. So an array with 11 items would be 1011, JS arrays of 8, 2, and 1 items. To append, you concat with the 1 item JS array, then with the 2 item array and end up with 1100, arrays of 8 and 4 items. You'd be able to reuse most of the array slots from most appends. I think building an array with n items would be O(n log n), which isn't terrible but isn't ideal either. Interop might not be great either but probably better than Elm lists. To use just one JS array, you probably need uniqueness types or something. I don't know.
Well, I don't really agree. Not all data comes from somewhere else. I've used Elm for three small projects, two of which are completely client side, and they all append to lists at some point, as much as I try to avoid item-at-a-time code. However, I think you could implement this as a data structure along with a JSON decoder/encoder without messing with the compiler.
function add(a, b) { a + b } Just for correctness you should add the return here, good post though!
I don't think we need to create a new project if we just want to clean things up a bit. Googling 'subreddit theme' brings up this: /r/naut/ Aside from a few contrast issues, that looks like a nice theme that could be adopted here.
I think a dynamic functional language is a bit too wacky to catch on when we already have js. Excited to see Crystal gain momentum. Also excited for Ruby 3.
https://www.noredink.com/ certainly has a large app in production.
It is possible to use Elm with **React** (blogspot on Elm official blog) and with **Angular 1** (I have modified angular-elm repo for our mobile Angular app: https://github.com/Janiczek/angular-elm/). I don't know about **Angular 2** but I imagine it is possible :)
I just started to learn angular2 and I am a bit disappointed, because there so many tools that you need to build an application. What about elm?
Definitely Elm, Angular2 is a joke.
It depends on what you understand by production ready. If you want to use Elm in production by incorporating Elm components into bigger apps, the way [this blog post](http://elm-lang.org/blog/how-to-use-elm-at-work) documents, then yeah, Elm is ready for production. This is what NoRedInk and others did. If you want to use Elm as the sole language of the product, then most likely the answer is NO. If you use it to implement something very simple, you can get by but otherwise, you will most likely get into troubles. 
I used to think the same way as you. That was when I primarily did Java. Then I learned Python -&gt; Haskell -&gt; Smalltalk -&gt; Ruby After progressing into fp I came back to OOP with new eyes and a new appreciation.
Crystal looks really interesting! Since ruby is my strongest language, it's awesome to get compiled language performance from a ruby like syntax. Thinking of building my next side project with a Crystal back end and Elm font end.
You could also say const add = (a, b) =&gt; a+b;
&gt; If you want to use Elm as the sole language of the product, then most likely the answer is NO. If you use it to implement something very simple, you can get by but otherwise, you will most likely get into troubles. Why? Is Elm not for building large app? I want to use Elm as the main language for frontend stuff, why it is not advisable? For frontend, I want to use only Elm, it is advisable?