Man, I can't thank you enough for pointing me in this direction... Just opening the door to this world has leveled me up...it is like going to the world I never knew I wanted to go to. 
Though I do not know exactly how a stack machine works...I do know how a stack works, what RPN is, what opcodes are...and I also enjoy representing concepts in different fashions... I ran across this today...I haven't had a chance to read it, but it is about optimizing data structures...might be useful? [https://stratos.seas.harvard.edu/publications/design-continuums-and-path-toward-self-designing-key-value-stores-know-and](https://stratos.seas.harvard.edu/publications/design-continuums-and-path-toward-self-designing-key-value-stores-know-and)
You are welcome. Please have a look at this article I wrote: https://github.com/udexon/5CSM/tree/master/SMOCL (Closing paragraphs:) Where does this lead us? Stack machine is only the portal into the bigger world of graph theory, which some believe to be the very foundation of mathematics. The reverse Polish notation is simply the simplest notation to represent ANYTHING mathematically. Consider the distributive law described in this article. How many lines of code would you need to implement the distributive law in other programming languages? The solution in RPN is almost trivial. HOL Light, based on LISP, is another good point of entry to the abstract world of mathematics. However, I believe Forth and RPN, which are homoiconic as with LISP, are closer to hardware, and thus more appealing to some programmers like myself. In any case, when you understand the fundamentals of stack machine, which I think you can achieve in one week by following examples given here, the differences between LISP and RPN are trivial, as there are more interesting problems to pursue. (Additional references: SageMath, Python Sympy, Maxima.)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programminglanguages] [Proposal: RPN as "super macro" for C\/C++ code](https://www.reddit.com/r/ProgrammingLanguages/comments/aa759q/proposal_rpn_as_super_macro_for_cc_code/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Have a look at my new post: Proposal: RPN as "super macro" for C/C++ code https://groups.google.com/forum/#!topic/comp.lang.forth/cAZURahAnzg It talks about the same thing as the article -- but simpler and more practical.
It's a little late for me to dive into that right now, but tomorrow...a day of Forth planned...so I'll kick it off by reading your post then by moving into reading/executing and manipulating some code. Give me a bit to catch up ;)
*&gt; The reverse Polish notation is simply THE simplest notation to represent ANYTHING mathematically.* &amp;#x200B; I'm not arguing against this claim, but are there any official sources to back this up? What makes RPN simpler than original Polish notation? Obviously it's better for a computer processor, but what else does simple mean here?
Interesting point. The more interesting part is that, you may try to construct a proposition using RPN, and prove it using RPN. This requires plenty of theoretical and practical work. Also, the equivalence of PN and RPN needs proof too. Collaboration welcome. There are too many problems to solve.
On page 13, in Algorithm 1: the notation / language required to represent this algorithm can be represented in reverse polish notation in its simplest form, and be executed by a stack machine.
Man, I can't wait to see stack machines the way you do... Saw you write somewhere else that you feel that we are barely scratching the surface with stack machines...what did you mean by that?
Want power? [GForth](https://www.gnu.org/software/gforth/) Want support (and speed)? [VFX](https://www.mpeforth.com/software/pc-systems/) Want simplicity? [Retro](http://retroforth.org) Want to do embedded stuff? There's a Forth practically for every board
I made no claim, just asked you to substantiate yours.
Well, I find Forth extremely useful because it is interactive. And it works on devices that are too small for an OS. (But there are some really tiny chips that can't fit Forth. There you have to compile in Assembly or Basic of some sort. If I'm wondering if I just destroyed an i/o output on an Arduino Uno chip, Atmega328p it's simpler and faster to do so in Forth. I'm not really into desktop computer programming in Forth, except for study. I do occasionally use gForth in Windows or Linux. Forth can be really helpful to explore sensors and devices that you add on to a microcontroller. And via USB or wifi or bluetooth, you can remotely control things from your PC.
And it is only second to assembly language invl speed because it is so close to the hardware.
"All of this sounds impressive, yet it is really nothing but disguising, by pompous terminology, a triviality as a scientific theory." Dijkstra on simple-minded theories full of bloat... &amp;#x200B; Love this guy more than I thought I would ;)
"in short: the more elegant the better" -Dijstrka Well, Dijstrka, how about I just get something onto the page first... Going with Python for a quick stack machine implementation. First thing, I need a stack...fortunately, python's lists can work as a stack, quite easily. `In:` `s = []` `s.append(1)` `s.append(2)` `s.append(3)` `print s.pop()` `print s.pop()` `print s.pop()` `Out:` `3` `2` `1` Now, creating an RPN calculator with a stack does not seem too difficult...going to finish reading this paper, then going to write down a list of operators and how they will be implemented to finally check them against an RPN list of operators and how they work. Always best to try yourself first, or at least have some idea of what you are up to...become a master of chaos (in the psychoanalytic sense)... &amp;#x200B; &amp;#x200B;
Scaffolding: Figured I'd let anyone interested see what I do under the hood...I use Python almost every day, but I still write code like this...piece by piece, test-benching everything. `In:` `def rpn(s):` `ops = ['+','-','*','\\']` `for i in s:` `if i in ops:` `print "OP"` `print i` `print` `elif i.isdigit():` `print "NUM"` `print i` `print` `else:` `print "DISCARD"` `print i` `print` `In:` `rpn(["3","2","+","&amp;"])` `Out:` `NUM` `3` &amp;#x200B; `NUM` `2` &amp;#x200B; `OP` `+` &amp;#x200B; `DISCARD` `&amp;`
Last post for today...started late...and it's Friday... In: def useOp(x1,x2,op): st = x1 + " " + op + " " + x2 print st st = "print " + st exec(st) In: useOp("3","2","+") Out: 3 + 2 5 &amp;#x200B;
I should emphasize this is how WE need to construct the proof (to "substantiate" my claims): &gt;The more interesting part is that, you may try to construct a proposition using RPN, and prove it using RPN. &gt; &gt;This requires plenty of theoretical and practical work. Are you familiar with HOL Light and related theorem proving tools? 
Shouldn't your division operator be '//'?
I really want you to rename 'useOp' as 'apply' but maybe that's premature... Enjoying reading your updates.
Well, that or '/' ;) Would have caught it when I tested the remaining ops, but thanks for pointing it out! I will also have to make it a float division.
Well, I am doing this without looking at what is conventional, yet. I want to create a simple RPN calculator in python, then see how it compares to others in python...then I'll try php, repeat...then from there probably look at the theory of RPN and see how it all measured up to what I experienced. However, naming is my ultimate weakness, so any critique in that regard is highly welcome!
I think there's a ton of value in learning the conventions just for the improvement in your own comprehension when reading the literature. But I don't pretend to have more than a cursory knowledge. I was lead through this material in highschool in much the same order as you're progressing. Next step for us was to implement a rudimentary language, and then time share programs in that language on the same CPU. Really enjoyable and satisfying to implement and then execute something like this. Have fun!
I haven't found a Forth for the nRF52 (ARM Cortex M4), do you know of one?
In a digital design course back in undergrad, I was tasked with created a cpu with an alu etc...designed the language (in 1's and 0's) and then wrote a simple program. It was cool, really enjoyed the education I got...but, somehow, I felt I never got a deep education. Looking to get that out of Forth. As for learning the conventions, like I said, I do go back and look at conventions, but with a fresh view as to why the conventions may exist in the first place. 
Great work. Some pointers for you to make it a complete stack machine like Forth: (1) Colon definition (2) Conditional branch 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programminglanguages] [On the Design of Machine Independent Programming Languages by Dijkstra](https://www.reddit.com/r/ProgrammingLanguages/comments/aaheti/on_the_design_of_machine_independent_programming/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Ok, colon definition is fairly straightforward, but conditional branch in RPN? I'll have to think about that a bit, don't tell me ;) If I remember correctly, with an instruction register, a jump command would go to a specific location in memory.... Ok, so, maybe it is like a boolean check.... Let's try: if a == b: c else d So, I need to have a, b available, a conditional operator (probably '?') and an else (probably ":")...the usual comparison operators, ==,&lt;,&gt;,=&lt;,&gt;=,!=...and of course the colon ending. 3,4,?,=,1,:,0,; So, 3, 4 pop off...then the ?...then the =, it now checks if 3, 4 are equal, if they are, do up to : else do after : until ; Something along those lines? Not the answer, just 'warm/cold' ;)
Yea, that is what I am seeing, a way to do everything at once...
Yea, its an interpreted assembly language...puts it at the level of C, as far as I am concerned.
Awesome. I haven't done the full progression from simple adders to something programmable. Would love to at some point, just to satisfy my curiosity.
I have worked a small amount with microcontrollers, but enough to understand that I love them and need to use them more. Enter Forth...just so happen to be on the hunt for something like it and then it is suggested to me out of the blue...now that's service!
Look, you may be a language design genius, but if you walk around making claims that you can't actually back up, nobody's gonna listen to the other brilliant things you say. Perhaps I'm thick-headed and am not understanding your obvious statements, in which case forgive my rambling. But... If you are 99% sure you could prove something, but you don't actually have a proof at hand, then it's a Hypothesis, not a Truth. Which is totally cool! But you need to communicate that. "PHP is a dumb language" &lt;-- clearly opinion, because "dumb" is subjective. "PHP might be the world's least efficient language for Natural Language Processing" &lt;-- clearly a hypothesis, but disprovable (we could search for a less efficient language). "PHP is the simplest language to parse" &lt;-- disprovable claim. If I said the last one in a room full of impressionable minds, wouldn't you hope someone asked me for evidence?
There is a book out there, nand to tetris. If you are interested in stuff like that, it is a great resource. I'm really happy to have been introduced to this board. I think I have something to offer and I know I have a lot to learn from the rest of you. 
I think you are not getting my message. I was saying, the theorem proving tool itself needs to be rewritten in reverse Polish notation. Then we can go on to prove other things.
You need to define the word list first (Forth jargons). Then each WORD (function) has an index. Then branch to the index of the word (function).
Yea, I probably should look at a logical diagram of how Forth works...
Do you see how the thing that I quoted sounds like an assertion of truth, and not a hypothesis requiring exploration?
Of course I understand. Perhaps I should explain further my idea: -- Your assertion, whatever the content, is written in a natural human language called English, which is non rogourous and ambiguous. An assertion in a natural human language requires the listener (reader) to be equipped with similar competency, in order to comprehend the assertion, then express his or her opinion concerning the assertion. My assertion, ie. the Reverse Polish Notation is the simplest form of mathematical representation, although written in English, concerns a very specific domain, that is Mathematics and programming, which has its own methodologies for proofs. In fact, theorem proving is still an active research area which means there are still many open questions. However, in theorem proving, theorems are now usually proven computationally, aided by human verification. I am claiming that of the state of the art of theorem proving, the language used should be reverse Polish notation or any other language with RPN as basis. Just as any other theorem proving methodologies, we need to construct the computational algorithms to prove whatever assertions related to RPN. And this is a work in progress. 
I didn't ask for a proof. I asked you for a source. I was hopeful that by asking this, I would learn something. Why should I believe this statement? That's all I want to know. If you're saying I shouldn't until there is proof, then I agree, and I think you should write in such a way to reflect that, to prevent confusion like mine.
I am really curious, from where do you hear or learn about the phrase "prevent confusion"? Are you religious by any chance?
Oh yes. Twelve Tribes. You?
What is twelve tribes? Syiah? Iranian?
I was joking, that's an American cult. I felt like I had to joke at your inappropriate question. You should know that I haven't downvoted you once. That's other people reading what you've written. I really hope you figure out how to talk to humans, so you can share your intelligence, but I'm done.
I think you are lying. You are not a native English speaker. I have not heard anyone saying "prevent confusion". So why don't you tell us the truth? Everyone is watching you now.
I'm finding a few non-standard words 8n C H Ting's eForth, like AFT. It's used heavily in finite loops, such as.... FOR... AFT... THEN... NEXT... At first I was dismayed, but download and study "eForth Overview" section 5.3 to learn C. H. Ting's reason for this oddity. His reasons seem wise. The whole of "eForth Overview" is worth deep study.... leaving to think like a master.
[NEXT JOKE ORIGIN](https://www.reddit.com/r/ChoosingBeggars/comments/7kr5as/i_need_a_free_100mile_bus_trip_for_20_people_and/)
Maybe faster. Using printf for output can serious bog down CPU use. Not possible to use with small microcontrollers, but loves by beginners. Eliminate that.
ArmForth has a Yahoo group active, barely. Issues code.
C. H. Ting's eForth is likely a great beginning if tou can follow "eForth Overview" which is intended for writing a Forth in a DOS setting (has BIOS calls to start and for i/o). Only the first 31 commands are written in Assembly language. The rest demonstrates Forth can be written almost entirely in Forth. That should get you introduced to how little there really is to the inner interpreter, the outer interpreter, and the other core features. The rest is a linked list called the Forth dictionary. 
Python is huge. Requires an OS and file system.
One more think. The serial baud rate is documented at 19200 baud, bit in an Arduino Uno or Mini, the actual baud rate is 38400. C.H. Ting assumed an 8Mhz internal clock would be used, but these boards use a 16Mhz crystal. Don't mess with the code. Just connect with the faster baud rate.
SPI and I2C are not in C. H. Ting's documents. But I'm working on these via Atmel's reference material. Download and study "eForth Overview" as C.H. Ting fully explains eForth in that document, including some non-standard Forth words he frequently uses, like AFT. You find it in his Blink example.
Here are links to two good tutorials about Forth and microcontrollers. [http://flashforth.com/ff5-tutorial-guide.pdf](http://flashforth.com/ff5-tutorial-guide.pdf) [http://flashforth.com/ff5-elements.pdf](http://flashforth.com/ff5-elements.pdf)
&gt; you'll want to make your own implementation. I disagree with this kind of thinking. Not everyone needs to implement their own Forth from scratch. Sure, you learn how everything works in excruciating detail under the hood of *your* Forth. This is not, as you've stated, "in line with Chuck Moore's development philosophy". I can't immediately find the quote (I'll keep trying), but Chuck Moore makes an offhand comment about ANSI Forth and states something like: "If I'm an application programmer, I don't want to have to learn a new interface every time." He's pro-"modifying the Forth you're using to do what you want". He was anti-ANS because of the outcome that it standardised bad coding practices through overreach, not because it's a standard group of definitions. The reason very little ever seems to get done in Forth is because a ton of Forthers spend most time metaprogramming and never enough time application programming. The best way to write programs is use something that works. 
I recommend [Ciforth](http://home.hccnet.nl/a.w.m.van.der.horst/ciforth.html) (Lina, Wina, etc all towards the bottom of the page), because the documentation is incredible, it builds on a ton of systems, comes with useful string handling words in the base dictionary (gforth requires you `require` them), and has a reasonably-sized wordlist. It's also written in assembler so it's real fast. gforth is good I suppose, but overrated. Some of the things it does are weird, the definitions are quite large, the wordlist it comes with is massive (you'll be looking at the word index of the website a lot).
I posted this because people seem to recommend gforth a lot but using Lina I've found it preferable 
Python is huge, but that is a good thing ;) If you wanted to use python for microcontrollers, there is micropython, but, I mean, that is not ideal, which is why I was looking for something like Forth
I won't be using any print statements with a microcontroller...
[https://users.ece.cmu.edu/\~koopman/stack\_computers/sec3\_2.html](https://users.ece.cmu.edu/~koopman/stack_computers/sec3_2.html) How would Forth differ from that?
This is the hardware implementation of Forth. When Forth was created in 1968, the only stack machine hardware computer was from Burroughs, which is proprietary, and ran Algol. Forth was implemented on a variety of computer, none of them has a stack machine architecture. Eventually Charles Moore created and manufactured the Novix stack machine microprocessor in 1980s. We are not sure if it is still being produced or the old chip produced in 1980s are still running. 
Seems like a nice system. Is floating point available for it?
Hmmm, very interesting... It isn't wildly different from the architecture I was taught. RPN -&gt; stack machine -&gt; hardware implementation in verilog/vhdl -&gt; actual hardware implementation -&gt; load Forth onto my own hardware :) 
No, you'll have to use fixed point. http://home.hccnet.nl/a.w.m.van.der.horst/ci86.lina.html
Serial RS232 will need something.
Hmmm, I've heard of RS232 (comm protocol, right?), but I don't see why I would need a print statement...of course, I am not planning on interfacing with any common hardware, I am making an entirely custom system...so, I just need 0's, 1's to run out of the pins of the microcontroller... Now, I don't know what goes on under the hood necessarily when I compile some C for a microcontroller...maybe it is using print to get the data to the pin...but I don't see why that would have to be necessary. 
Somehow new learners want new languages when historically Forth and C could teach with great clarity. Everyone wants to reinvent.
Well, I am not against reinventing for educational purposes, but personally, I like going back into the past and rediscovering methods that were overlooked, possibly because the technology to implement it did not yet exist... Forth kind of feels like I stepped through a portal and am now able to look over the shoulders of the people that founded the modern world. 
My favorite quote of the paper: &gt; "We sometimes flatter ourselvesWith the idea of giving watertight proofs, but in fact we do nothing but make the correctness of our conclusions plausible. And let us be honest: even extremely plausible."
Yea, the guy had a strong grasp of reality...I wish more people could see that -_-
I use it extensively in my game engine. However the libraries I depend on to provide cross-platform high performance graphics require floating point, which I convert to at the last second.
Building a forth in another language is not FORTH.
Implementing my own Forth is, by definition, Forth, jackass. 
If you aren't building on the hardware level you aren't doing anything useful. 
1) Anything that I do that helps me learn, is fucking useful 2) Anything that will help me learn will help others learn and therefore useful 3) I can actually implement this on hardware, can you? 4) I know over 2 dozen programming/hardware/scripting languages. How about you? Getting real sick of the lames on reddit. You guys are a dime a trillion. 
10-20 languages been programming from 1979. &amp;#x200B;
10-20? That isn't a number of languages, that is a range, kid. How many languages do you know? How much hardware have you implemented? How often do you attack people that are smarter than yourself to make yourself feel better about being mediocre?
You should talk to Chuck he could use a good laugh. 
Yea, well, if he is worth his salt, he will side with reason not you. 
Just because you brought up Chuck... Think about it this way...everything you learn in hardware does not depend on the hardware. The theory of computers is independent of the medium. You can make a computer within a computer within...infinitely (resources allowing). Don't want to hear any more bullshit from you. Thanks. 
I remember you! You're getting interested in forth after the thread in /r/programming, right? Welcome to the forth community, keep up the good job!
I'm enjoying it. eForth is about 1000 lines of code. Today's Linux is about 5,000,000 lines or more. Add your project on top, and it gets even larger.
Nice. I just loaded gforth and messed around a little bit with the stack and creating a few simple functions. Fun stuff. Will see if I can find something simple/interesting to present to the board soon
GPIO i/o isn't exactly a feature in C on a microcontroller. It's quite direct and precise in Forth.
What is your opinion on 8th?
Updates: &amp;#x200B; [https://github.com/udexon/5CSM/blob/master/SMPG/README.md](https://github.com/udexon/5CSM/blob/master/SMPG/README.md) &amp;#x200B; Stack Machine Parser Generator &amp;#x200B; This example illustrate how Forth style colon definition can be used "rename" blocks of code of high level programming langauge (e.g. C/C++), thus making it more legible, structured and manageable. &amp;#x200B; The original post appeared on comp.lang.forth newsgroup. &amp;#x200B; The following is the output of cparse.php (will be uploaded after clean-up), a C parser written in PHP. It uses one simple rule: look for '{' and '}' as start and end markers, output block label as B\_startline\_startcol\_endline\_endcol. Each line starts with the line number, followed by the column number of either '{' or '}'. The number following IN\_IF is the nest level of the block. &amp;#x200B; The input example is taken from [https://github.com/supernovaremnant/bazel-android-opencl/blob/master/opencl-info/opencl-info.cc](https://github.com/supernovaremnant/bazel-android-opencl/blob/master/opencl-info/opencl-info.cc) &amp;#x200B; Even with such a simple example, it shows that the code can quickly grow intelligible, due to fundamental flaws in the design of high level programming languages. &amp;#x200B; The next step for cparser.php will be to provide the Forth style colon definition to "rename" the block labels B\_\* -- to give them a more legible name, to give it more meaning, structure and make in more manageable. &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B;
Too busy with C. H. Ting's minimalistic eForth to bother with 8th. I've heard too many repackaged claims with nifty Linux distros and Windows updates to get excited about a new name. I'm looking for pragmatic generic engineering principles applied and verify. C. H. Ting has been with Forth since the Apple II days and refine his coding of every detail along the way. 8th is yet another distraction from real learning.
Thanks for the heads up. "The hardware to support this Forth is minimal. An 8031 (or 8051) with an 11.0592Mhz crystal, a serial port, and an 8K EPROM at address 0x0000 and an 8K RAM at address 0x6000 are all that are necessary to run it. The RAM can be easily relocated by changing the constants in the source." Is that true about eForth?
Gforth is good for working through tutorials on a PC, but Forth on a microcontroller is more appealing to me as small autonomous gadgetry. 328eForth, Amforth, AVRforth, and Parallax's Forth on the Propeller chip are what I've been exploring. You might as well use Python on a desktop PC. It has floating point and pretty GUI.
Well, isn't a PC just a set of *really big* microcontrollers? ;) I see where you are coming from though, and certainly, lightweight is the key. However, I am hoping to get an all-in-one package. The ability to code up asics and run servers without the nonsense I find in other languages that can do that. Maybe not doable, but so far, Forth is seeming like it is the ticket
A PC is not a truly deterministic real time computer. A microcontroller can easily do that. The Beaglebone Black included two microcontrollers internally, just to resolve that challenge. But they program in their own Assembly language at this point. So if you want real time precision, you need either to attach a microcontroller ( via USB serial or parallel printer port ) to your PC. Or have an independent microcontroller. Or master a Beaglebone Black and its two PRU devices. Apparently USB3.0 support in BIOS has introduced so many interrupts that a Intel/AMD computer can no longer emulate real time processes. Too much jitter.
&gt; Apparently USB3.0 support in BIOS has introduced so many interrupts that a Intel/AMD computer can no longer emulate real time processes. Too much jitter. Wow, really? You have something I can read on that handy? If not, I'll look it up later. Pretty crazy And, how bad is the Black? What's the main difficulty compared to the payoff? 
EForth is ported to 8031/51 if there is enough RAM for the dictionary to evolve. Actual crystal can vary. The slower the Xtal, the longer battery life in real applications. eForth is as ported to a Lattice FPGA that I have with a custom created CPU and all in 16 and 32 bit versions. But you can have all my 8051 junk for free. (Send me a PM and pay parcel post from Taiwan). It's a historically complicated CPU that requires outboard chips to perform... like a USART, external RAM, external Eeprom, etc. Just a huge waste of time. The same or much better can be more simply achieved in an Arduino Uno at 16Mhz with thevAtmega328p. Parallax's Propeller chip has three versions of Forth (Tachyon Forth, pfth Forth, and Propeller Forth) And that is 8x 32 bit CPUs will 32Kbytes of RAM. One CPU provides a terminal interface, and the other 7 CPUs operate independently with a shared dictionary. I prefer 'pfth', but Tachyon is the race horse Forth on that platform Parallax's Propeller quite a whoopie that an 8031/51 will never have. Eight parallel 32 bit microcontrollers on one chip. But the Arduino Uno has at least 6 built in ADC pins and lots of shields. So its got a big whoopie factor too. Nothing to solder. 
Odd, they use `SEE` in an example in the PDF, but a Windows distro doesn't have `SEE` out of the box. Don't think I missed anything.
The BeagleBone Black is the solution, no bad involved. It's a fresh start. Texas Instruments provides it to U.S. industry for deterministic needs. Read their literature. BBB USB does not seem to be problematic about jitter. It may be because there isn't a proprietary BIOS involved. Booting Linux is done via Das Boot. Linux directly drives i/o. Unless one switches to a open source Libre BIOS, BIOS is all a black box that isn't optimizing for CNC. Libre BIOS is only proven on a handful of motherboards. Look at the Linux CNC community for reading. I don't believe Linux CNC and proprietary CNC have admitted the problems, but Linux CNC holds on to the fantasy that parallel ports are still a viable solution while trying to get people to buy 2nd old motherboards that are proven stable enough to work with their successful code. Proprietary CNC seems past it's prime as well, but still licensing what it has. They all seem to have given up on leading edge Intel/AMD. It's not evolving to the new motherboards or new CPUs. And almost everything in a 3D printer downloads the compiled CNC code (like Gerber files) to get a larger Arduino board to smoothly do the actual deterministic work independently. Your desktop does the 3D CAD, and a tedious compile run to create the Gerber files or other alternatives. But I'm interested in other determinstic projects. Forth seems optimal for home automation or an experimental ECU for automotive. It unlocks black boxes.
does your game engine using forth?
The ranges for floating point approximation are often static. In this case you can avoid convertion loss by choosing a different result format for fixed point arithemetic which allows more precise convertion. 
The first one is pretty small. It defines just a handful of words: + - * / max min negate abs = if . .s duo swap call compose curry : ; words sh A few more will be needed to make this actually useful. There is a test file, but this can't run it as it's missing numerous words in that file. It's also missing a license, so I won't look at it in any further detail than a cursory skim of the code. The second one is more interesting in scope, but is GPL licensed, so I won't look at the code for it. Just looking at the docs and the file listing don't show any Forth code in this one at all. Both also don't appear to be active projects and neither mention cryptocurrency as far I can see. 
It does - see https://twitter.com/RamenEngine and https://github.com/RogerLevy/ramen/
I have this tiny feeling that forth being so simple leads to regular / mathematical proof. And also, early processors were simple, I think M68k lineage started with A, B with reduce/fold binary operations. Much like FP/Haskell. Somewhere down the line that structure got lost in details.
I have this tiny feeling that forth being so simple leads to regular / mathematical proof. And also, early processors were simple, I think M68k lineage started with A, B with reduce/fold binary operations. Much like FP/Haskell. Somewhere down the line that structure got lost in details.
No problem at all. I might re-post to the 8th forum when time allows with some of those ideas. I find it interesting that there is a small community of folks which are flabbergasted by the rampant software bloat so pervasive in the wild. I wonder how much technical debt the world accumulates each day :). Maybe it isn't all that bad though. I'm still a novice compared to someone with your experience, but I've toyed with a few ideas that are good for storage (or at least workable), but I'm not sure how good they are for computation. Example: if you had to store a representation of each city in America as nodes and each interconnecting road as an edge, you could store that as an "Adjacency Matrix" which is a square matrix where each row represents a new city and the columns represent all the other cities. A "1" means there is a connection and a "0" means no connection. Any Adjacency Matrix of decent size will be mostly 0's, so you could just use a dictionary to store the non-zero connections and assume everything else is a zero. You run into issues though when there is information about the edges (roads in this example) that gets lost. I think 8th's native JSON format might actually work pretty well here. The resulting data structure shouldn't be too large. I'm not sure how you would do all the various calculations off of it though like inverse, determinant, transpose, LU factorization...etc.
Beat me to it! Thanks Charles :) I was gonna post this link, it's the upcoming "distro" repo, 2.0 is shaping up to be a big improvement https://github.com/RogerLevy/ramenengine
The projects are neat, but we could do without the cryptocurrency advertisement. Haskell is a popular language for plenty of reasons, not just this Cardano thing, which honestly I've never even heard of before.
Which license do you believe in? I am curious as I see you as a very good mix of expertise on forth as well as being the most reasonable leader in the community. Also please express why you believe in said license.
In actuality, I would prefer to use public domain (and did so, for many years), but that's legally questionable in some countries, and as I have contributors from many, it's better to use a standard license. Because of this, I now use ISC license for my projects. I'm good with most of the permissive licenses (e.g., MIT/X11, BSD 2 &amp; 3 clause variants). These make it clear what can or can not be done, and don't put any serious restrictions on how code can be used, while still giving credit back to the authors. GPL (and to a lesser degree LGPL) basically require that things incorporating parts of them be licensed as GPL. This is problematic to me in some ways. I try to avoid looking at GPL code as I don't want to risk inadvertently incorporating even small pieces into future projects of mine and reducing my options for how I can handle things in the future. This can be of some concern in a Forth, where code you write often gets compiled and intermixed into the system as a whole. (Especially when generating an image file, as I often do, or a turnkey application). If you use a host system thats's GPL, you are basically forced to license the source you write as GPL if you distribute a binary generated from the host. This may also apply to the LGPL, since a turnkey or image is more of an amalgamation than a properly separate linking. As a case in point, the author of IsForth [now called x4] uses LGPL, but includes a specific exemption when distributing that says you need to provide the IsForth sources, but not your own code. The need to deal with this is annoying. For me, only one project I have currently uses any GPL licensed bits. Specifically, the native version of Retro boots using GRUB. I deal with the license by just including the source code I used to build GRUB in the ISO image. This makes the download bigger than it needs to be, but it'd be more trouble for me to try to maintain compliance by hosting a separate download.
I approve of the choice to side with BSD style license and assume that ISC is something along the lines of ISC but that has some feature which you prefer or which differentiates it from BSD. I side with BSD license for a slightly different reason. I think GPL is designed to try to get every piece of code to be forced to be GPL which at first seems like a good idea if you like free software. But it actually does not work out because if everything in the world was "forced" to be open source then there would likely be lawsuits that caused reform in the law. I think BSD is better because it means people always at the least have the option to be open source but not forced to. This seems illogical to someone who advocates for open source but I think it works out. Over the course of human history project after project which was closed source has died out but we haven't even had enough time for us to create the branch of history called computer historian who would review these programs and realize this academically in a scholarly and peer reviewed way. So I think bsd license is a perfect opportunity to allow society to experiment with closed source and continually fail at it in history. This repeated failure would show as a good example to history why open source software tends to survive longer and get exponentially better exponentially faster over time.
I like open source as much as the next guy, but your post implies that closed-source somehow immediately makes it bad...just not true, not in the least. The best closed source programs outclass their opensource counterparts across the board. Furthermore, closed source isn't perma-closed and often get published to open source. At least you aren't a fascist trying to get everyone's software for free...but you can take open source off the religious pedestal you put it on. 
What words, in your opinion, is it missing?
Quite a bit. At a minimum, there's no words here for reading/writing memory, so no variables or data structures. There's a non-standard IF, but no word for less than or greater than. No remainder/modulus, no bitwise operators (and, or, xor, shift). No loops, ut this could be dealt with via recursion and conditional exits, depending on how IF works here. No analog to CREATE or DOES&gt; (though thia might be arranged via use of COMPOSE and CURRY). No DROP, no access to a return stack. This also lacks anything like IMMEDIATE, and FIND.
So here is my stance on that issue. I would say that there are serious advantages to open and closed source. First of all closed source is better for technologies for patented or which need to remain secret. For example if you were in communist china and trying to make software to rebel against the government then you would probably want to make it closed source. Closed source is also probably necessary for things like website frontends and videogames or application frontends. I however advocate for programmers tools to always be open source and for programming companies who make programmers tools (especially non graphical tools - no to be mistaken with non graphical tools for generating graphics) and here's why: open source code gets debugged by more people and anyone can make changes to the software meaning it is user oriented rather than company oriented. I also firmly believe that certain components of an operating system should be open source such as the desktop environment, file manager, browser, email client, etc. This gives the user control of their os and a company in control of the applications so that there is competitive and not anti competitive behavior. So I think games should rightfully be closed source but the tools for making or modifying a game should be open source. The same with any other kind of graphical application.
Why do I get the feeling that I am hearing a lot of other opinions through you? If you are making anti-government software in communist China, you absolutely would want to make it open source, because otherwise, the government needs only capture one person. Closed source is about proprietary software i.e. to make money. Employees don't show up to work because they want to, they do so for money. Therefore, no business can survive without making money. And, depending on donations is what the homeless do...not a viable business plan. Programmer tools? Not sure exactly what you mean by that, but if you mean functional components of software that do something that other software does not do, then, no, they should not be free unless the maker makes it free. Finally, maybe some open source projects with loads of user-edited content turns out well, but I'm going to guess you are busy looking at the small percentage of successes while ignoring the avalanche of failures. I like it when things are open source, but it comes down to entirely to the people that wrote the code/own the code to determine if it is free. 
I wish you a good new year 2019! My own experience with Forth started with a very nice implementation for the Commodore 128. I found it a quite better and easier programming environment than .. these structured Commodore Basic V7 or even assembly programming. This was an indirect-threading version of FIG Forth. Remarkably, it was way years later that I recognized the advantages which results from implementation exposition. A Forth environment before the ANSI standard exposes the implementation environment and threading strategy in established, de facto standardized ways to the programmer and gives them possibilities impossible with other programming languages. For example you can use indirect threading for redefinition of prior defined words. Better, you can write a word which does this dependent of it parameters. This lead to self modificated environments though generators which have global effect. Programming in such style require way larger effort with other programming languages beside possible Lisp and Scheme. With Forth before the ANSI standard this is possible in the way which fits your problem best because the underlying implementation can be used directly. So; In my opinion Forth shows advantage because of it holistic design, however this requires a complete different way of thinking.
C-style forth code sucks. http://forth.org/forth_style.html &gt; I have always said that the worst form of Forth abuse was to translate a 'C' program into Forth. - Jeff Fox
For me, the learning curve wasn't too steep; I guess because I didn't have to write any production code in it, and I was investigating Forth for some other project at the time. But yeah, some of the baggage around ANS Forth pushed me to come up with Reva Forth, at first, and now '8th'. That's not an unusual thing from what I see: there are a lot of Forths which just scratch the itch a particular programmer has.
Indeed! My users having the biggest issues are the ones doing direct translations of C code. 
I've been looking for a Forth for the C128 for years. Do you know what is is called or where I can get it? Thanks. 
I believe he was referring to the indentation rather than the mechanics, which is a rather agreeable position, if only for if-else-then and begin-while-repeat blocks. Although very very very rarely are these nested. Personally I've never had to indent more than twice when coding in Forth.
I believe you are mistaken - The full paragraph that quote was extracted from: &gt;I have always said that the worst form of Forth abuse was to translate a 'C' program into Forth. you lose 1. Use stacks and 2. good factoring. But perhaps even more important the concept in Forth was look at it and think it through and then write some good code, close to the metal based on your knowledge of the system. \- Jeff Fox
See, this is exactly the kind of rhetoric that holds us back. It's a broad statement, and you're basically parroting a paper that talked about how some programmers didn't "get" Forth 20 years ago. Sometimes you have to write code that resembles C because not all problems can be reduced to 7-10 word definitions. 
Thank you for that testimony. So standard Forth makes no provision for that kind of thing - in the pursuit of performance I assume - but Forth still is all about being able to get around the blockades that other languages put up. The challenges come when you are trying to do things at the level of what people do in other languages *today*, which for all their limitation is way more sophisticated than the metrics of the days of Commodore. It's uncharted territory, and Forth is so very behind the times. (And I don't mean just the standard.)
Not all programs have to (or even can) deal with the hardware much if at all. Sometimes you have to write some gnarly code (by Forth standards) and that's what I'm talking about when I say code that "resembles" C, in the sense that the definition is very long and arranged vertically. Maybe the name of the word is even a compound. It's not an entirely un-useful thing and I'm pretty sure I've seen code written by Chuck himself that fits the description. I like to think of it as "implementing virtual hardware" in the sense that you need something that isn't provided by hardware or an API and there's no point in spending the time factoring it out into something elegant and beautiful. This is how it is with desktop application programming at the level I'm doing, anyway.
So, take this snippet, a very rare definition from my game's source. It handles collisions for objects that are enabled to work with the common collision system. : interact ( - ) stage each&gt; as en @ -exit bitmask @ -exit stage each&gt; to you collide? if \ ." hit " bitmask @ you 's flags @ and 32 for dup #1 and if \ ." collide " i collide then 1 &gt;&gt; loop drop then ; Sure it can be written out as one big blob, but you lose a lot of clarity. : interact ( - ) stage each&gt; as en @ -exit bitmask @ -exit stage each&gt; to you collide? if bitmask @ you 's flags @ and 32 for dup #1 and if i collide then 1 &gt;&gt; loop drop then ; You can also factor out bits of it (which I've already done to the level that is useful) but then you have to think, when are you going to use these other words? : likewise ( - ) bitmask @ you 's flags @ and ; : ?hits ( - ) 32 for dup #1 and if i collide then 1 &gt;&gt; loop drop ; : interact ( - ) stage each&gt; as en @ -exit bitmask @ -exit stage each&gt; to you collide? if likewise ?hits then ; This is pretty everyday factoring of the kind I do almost by reflex. But I'd argue these definitions, while to some degree clever and clarifying, make the source more complicated than it has to be, when the definition I ended up with is perfectly readable and understandable. I even have a word, :SLANG , that creates words that can only be called once, for the very purpose of clarifying long definitions, but it just wasn't necessary here. Just an anecdote from the warfront.
It was Forth 128 for the Commodore 128. Required CP/M 3 (well, performance optimization is always possible by writing code words for the 8502 cpu instead of the Z80 if you know how).
Probably. Which things do you mean?
The problem of implementing sufficiently dynamic systems for string processing, list/collection processing, dealing with modern data containers like JSON and XML and formats based on those, dealing with modern libraries (especially ones based on C++). The computer needs to do more and you need to put it together faster - the bar is higher. Doesn't mean the application code needs to be more complex but the subsystems are essential on desktop if you're doing anything serious. What I mean is a lot of things are needed to make it possible/pleasant. Locals help, collections help. The idea of a Forth package manager is, happily, starting to sprout. We're still behind on FFI, and a stack-checking compiler would go miles (or editor, which I think would be both easier to create and better.) And if more people were writing applications, good practice could evolve, which would also go a long ways.
OK. I'm looking for a 6502 Forth.
i think the only reason is that there isnt a portable and high performance free forth. also many modern features need to be support. and to be honest today's enviroment is much more friendly to forth, for eg, i use a amazon lambda like service for my company, this service paid in 100ms, that's not that friendly to today's scripting language. also memory usage is relative to the costs. and the code size itself also affect the time costs, because they use docker to boot the function. and finally the function as service model it self is very suitable for forth i think 
Hey, jyf, just a quick heads-up: **enviroment** is actually spelled **environment**. You can remember it by **n before the m**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
hEy, JyF, jUsT A QuIcK HeAdS-Up: **EnViRoMeNt** iS AcTuAlLy sPeLlEd **eNvIrOnMeNt**. YoU CaN ReMeMbEr iT By **n bEfOrE ThE M**. hAvE A NiCe dAy! ^^^^tHe ^^^^pArEnT ^^^^CoMmEnTeR ^^^^CaN ^^^^RePlY ^^^^WiTh ^^^^'DeLeTe' ^^^^To ^^^^dElEtE ^^^^ThIs ^^^^cOmMeNt.
Don't even think about it.
I meant mcsleepy was referring to indentation. I think it's pretty clear to all of us that translating Forth code directly from C's register-style data management would look and function awful.
Oh, I see. I hope so. 
Yes, I don't advocate writing C-style code in Forth, but I guess what I meant is that one shouldn't go the extreme opposite end and try to do everything "the Forth way" just on principle or for aesthetics. It's something I struggled with. Didn't realize it may not apply to everyone.
The 6502 is such a fun processor.
Check out this post I made if you didn't catch it. https://www.reddit.com/r/Forth/comments/abgfqs/some_thoughts_on_forth_is_forth_easy_or_hard/ed0theh/
I see, so your disagreement wasn't simply syntactic. Then, no, writing code in a way that doesn't maximise the potential of Forth (stack usage, simplicity through conciseness through refactoring, solving only the problem that exists **and** needs to be solved) is in my opinion, is not a good use of Forth. Making the code "as tiny as possible" wouldn't be considered "forthy", making the code "as simple as possible" is a more accurate formulation - the Bell Labs guys also agreed that good code comes from simplicity and correctness. Simple Forth is different to simple C.
I see no problem with the neither first nor third syntax - code is for reading. Splitting definitions across even 10 lines isn't going to hurt anyone. Personally not using syntax highlighting I prefer the third, but I would write it more in a style more like Sam Falvo's anyhow. I appreciate this well-written response, though believe we've had some kind of a misunderstanding.
I'd argue that a lot of what makes a good Forth program makes a good program in any language. But perhaps what that is is too intangible to even discuss productively. Or maybe it's just the idea of simplicity. How that looks in C is quite different from Forth because it's based on the challenges that language presents and what ends up being the easiest thing. I'm just a pragmatist so I think the effort spent trying to make things ultra-clever is not always well spent and I think the way Forth lends itself to that - by the fact that it almost *requires* it if you don't want to end up questioning everything - makes it "hard" in that the balance is difficult to achieve.
It seems I triggered the C-hating reflex common among Forthers, so it's fine. I don't hate C as much as I used to.* *But I still don't code in it
I don't even hate C. I just think C and Forth are very different approaches and require very different thought patterns and, subsequently, very different program implementations
We just have different mindsets. I think all programming is essentially the same, everything else is just details.
RPN is awesome, I agree. It was fairly easy for me to implement it in Swift, so C/C++ should not be more difficult.
Nice. That was great, gentleman. We need more people like you on reddit. I am a noob and it really pisses me off at times. And is the point of forth making 'your own fucking forth'? 
Thank you for starting this interesting thread, there is something to Forth, something very different, something to do with the WORD and the stack and context. I have not done any forth but reading about it has change my style. Look and [Arthur Whitney](http://kparc.com/b/) and [Aplers](https://github.com/Co-dfns/Co-dfns/tree/master/rtm) c-style. How all the [best software patterns and anti-patterns](https://www.youtube.com/watch?v=9xCJ3BCIudI) in APL. I believe Forth to be similar to APL in this regard however opposite. I hope to help find out some day the best anti-patterns for Forth. It's good to see people thinking about this.
It's brilliant. 
Wow! This is amazing!
Forth is very close to the hardware. So if you like other people writing driver libraries and BIOS, it's indeed hard. If you want ultimate efficiency, minimalist use of resources; Forth is the only way to go. But you will have to actually learn what your CPU really does.
Ummn... Forth is really about Two Stack virtual machine in machine code primitives. This creates a very compact interpreter that is extensible. One stack is one stack. Yes Python might emulate, but at a huge waste of resources.... 
I could implement this in hardware, if you like ;)
I think this effort is of interest for you: [Forth128](http://forth128.blogspot.com/) Writing your own Forth would not very time consuming beside memory management. Its good that there exist an operating system which handles this for you: [Geos](https://github.com/mist64/geos)
For some features, standard libraries while principal good would be of less advantage practical within a Forth environment. List and string processing for example are by a wide scale application dependent. This means, that effective programming solutions in Forth would be problem oriented and as such not general factorable. What would be useful in my opinion is an approach like the Rebol community had chosen: Writing a performance optimized DSL for implementing specific string patterns or list operations. I think it would be the easiest way to write some kind of converter for there DSL libraries which should hopefully not so difficult. Another idea: Your game engine? (I hope to found the right word in English) seem to be a traditional library effort. Have you considered yet to write a game engine generator instead? I think such program would be unique and should have some advantages, like the possibility of ressource optimization which is a weak point of most game environments to my knowledge. For this kind of application, Forth can be of great benefit.
Thanks for the Forth128 link.
Ramen isn't exactly a library. It's a framework, and its various parts are very decoupled from each other. It does provide a very nice baseline for doing what you describe though, and I *think* that's what I do with it (generate engines) more or less. For instance the Zelda clone is really a framework for making Zelda-like games, and it uses an object specification framework that can be used in completely different engines/games. A certain degree of code compatibility across game projects is desired; therefore certain choices are made so that they can be common across all applications. But there is a large degree of customization.
Regarding application dependent libraries, I made my own collections framework [Venery](http://github.com/rogerlevy/venery) that is pretty much designed for the kind of work I do and I don't expect it to be applicable to every Forth application (for instance it's totally irrelevant to embedded and it doesn't use heap memory because games need performance). You don't need a DSL, Forth is the DSL.
I thought about what you said and you're right, I mean all languages impose their own constraints on what you can and can't do, even Forth. I think you're overstating the importance of a kind of incompatibility of how you need to think in C vs Forth, when I'm not really advocating bringing over anything from C besides definitions that are "inflated" by Forth standards. There is a ton they share in common, in my opinion, though. Mostly having to do with their bare-to-the-metal nature.
Me too. I think there is an imbalance of thought in the community. I don't even know half of the acronyms people are dropping. But I think I know a thing or two about what works in Forth and what doesn't.
I'm guilty. And some hypocritical in my critique. I think I've written 10 Forths of varying levels of completeness. The biggest one I ever did was for the Gamecube. I guess the difference is I had a specific purpose in mind besides just exercising a technical idea. But I don't want people to think there is anything wrong with that. Just we need more applications and standard Forth is an okay standard. Not great, just okay. I propose several solutions within my own code.
It's not that much closer than C, you could argue C is more close. I'd say Forth is close to *ideas*. If you want to have a commonality between embedded and desktop. My apps are really mountainous if you imagine how much nesting is probably going on on the CPU. It's not my code, though, it's the libraries I have to depend on.
Delete
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programminglanguages] [C++ parser in Forth?](https://www.reddit.com/r/ProgrammingLanguages/comments/actzza/c_parser_in_forth/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I'd prefer to say Forth runs on a real CPU with the twin stacks and a serial interface enhancing the existing hardware by providing an interpreter.
You could, but one stack still wouldn't be Forth.
Parsing C++ is notoriously hard. First of all, go read the C++ spec. It contains the full language grammar. For parsing in Forth, it might be useful to adapt parser combinators as used in functional languages. There was just [an article](http://theorangeduck.com/page/you-could-have-invented-parser-combinators) on this topic. The approach feels very natural for a forth programmer, just a bunch of `CREATE ... DOES&gt;` and you have your own set of combinators.
No sample code then?
I've never written a parser in Forth unfortunately.
totally serious question: can Visual Studio even fully parse C++17? C++ seems like it evolves too fast and ferociously for even industry compilers to keep up.
Why would it only have to be one stack? Not sure I am following you here. From what I understand, Forth needs two stacks and a dictionary. As far as making a Forth-like CPU, the architecture I was taught *is* Forth-like with items being pushed onto and popped off a stack. 
Forth isnt a CPU. It's an interpreter with an extensible language. Forth has been ported to many architectures with a variety of CPUs in 8 bit, 16 bit, 32 bit, and 64 bit schemes. Stacks maybe created in hardware or software, but without a dictionary it does really become Forth. One stack is for data inputs and results, the second stack is for return address pointers and interim results. In some cases, added stacks are useful. One such scheme is an independent stack for floating point calculations. Forth-like isn't Forth. There's a lot of Forth-like discussion here that is not Forth discussion. And it is simply distracting. Forth is an inner interpreter, and outer interpreter, and a communications interface. Which happened to use stacks.
It is distracting you from what? You don't have to read and participate in things you don't like. Fact is I can do whatever I want to with Forth even rename it HTROF if I want to. This is computer land i.e. the land of abstraction i.e. a place I can do anything I choose to. 
All programs run on a real CPU. Forth is unique in its approach, which is a halfway house between bytecode interpreters and conventional languages. 
gcc and g++ source code are always available as reference implementation. I just want a simplified version.
I think the important ideas here are: (1) C++ parsing (or any other high level programming languages) is an open ended problem. Only Forth colon definition allows such open ended problem be broken down and shared amongst programmers. (2) My Multitiered Stack Machine approach shares Forth code directly and execute them in other programming languages such as JavaScript and PHP, allowing such code to be shared via web based interface, which Forth is lacking.
Can you explain what you mean by multi-tiered stack machine?
Good luck with this. C++ templates were proven to be Turing Complete: https://en.wikipedia.org/wiki/Template_metaprogramming
Template metaprogramming (TMP) is a metaprogramming technique in which templates are used by a compiler to generate temporary source code, which is merged by the compiler with the rest of the source code and then compiled. The output of these templates include compile-time constants, data structures, and complete functions. The use of templates can be thought of as compile-time execution. The technique is used by a number of languages, the best-known being C++, but also Curl, D, and XL.
Several steps involved in translating any C-like language, which are roughly: 1. Check that the syntax is correct. 2. Transform the code into a syntax tree or similar structure. 3. Traverse the tree in such a way that code is generated for the target in an appropriate form. For Forth to do this would be fairly easy, I think, if you allowed the interpreter to not operate on whitespace delimitation and instead went with a character-based longest match is best.
[removed]
Well, you want to wander, so be it. And yet, It's all rather foolish to assert the topic is really Forth rather than grandstanding you own stack brainwaves. Charles Moore is a radical minimalist that created a language that leaner and faster than anything other than machine code. FILO is one feature among several. I'm merely suggesting that one really needs to learn the whole to comprehend. "eForth Overview" by C. H. Ting is an excellent introduction, available in .pdf for everyone to study.
It is neither foolish nor grandstanding to repurpose the concept of Forth. How do you know where it leads? What if it leads to a better understanding or to better written code? If a person has interest in something Forth-like, give them some room on their chain... Now, that said in defense of my ego, I am willing to drop my Forth-likeness for real Forth. I will read your suggested overview over the next few days and I will return. 
(1) Why, in your opinion, can only Forth colon definitions be used to break down an open ended problem? Other languages have named functions as well. Why can't they be used? (2) I still don't understand your 'multi tiered stack machine'. I assume, from reading your numerous posts, that you are trying to convert the Forth variant you use to these other languages. Or, perhaps, you are trying to write these other languages as if they were Forth. From one of your Usenet posts: [line 1] 1 i: u shv: estr: s shv: [line 2] array: d db1 array_push: t tab1 array_push: o space: ap: select_opt: [line 3] cx: dup: f1b l: &lt;tr&gt; s msv: 1 - 2dup: - 1 - 4 ixn: akx: cx: dup: [line 4] f2b l: 1 - 2dup: - 1 - 4 ixn: 5 ixn: td: s msv: f2b bnz: [line 5] &lt;/tr&gt; s msv: . . . . f1b bnz: [line 6] s rshv: table: body: html: ec: This feels messy and not very Forth-like to me. This is somewhat supported by one of your comments in that posing: For readability and ease of parsing, we have decided to use colon ( ‘:’ ) as suffix to function name, in contrast to the conventions of the Forth programming language. As a Forth user, I can't follow code bits like this. What are all of these words doing? You mention that `ec:` is the same as PHP's `echo()`, so I'm assuming that most of these are also poorly named wrappers for PHP functions. On the other part of (2), what prevents code sharing via a web based interface? Are you talking about pastebin type sharing? Email? Providing a Forth-as-a-web-service for remote executing of code? These have all been done.
Thank you for your interests and comments on my work. In the example above, there are actually function "wrappers" for PHP, MySQL as well as HTML. When using my PHP stack machine (which I call "5GL" -- Fifth Generation Graph Language, as a pun to Forth), I am able to use the existing functions and libraries in their existing platforms and programming languages, via the Inverse Shunting Yard Algorithm and Multitiered Stack Machine Interface. This means that, whatever the latest development of frameworks (node.js, typescript, Laravel, etc.), 5GL can be used as a unified interface script to any of these modules. In contrast to "pure Forth" implementation of web services, while commendable, they are restricted in their acceptance, usage and popularity. i.e. I suppose they don't even make up of 0.1% of the total number of newly, latest versions of frameworks and libraries, which 5GL can interface. On the other hand, 5GL is not designed to be a competitor of Forth, but rather a "trojan horse" for Forth, i.e. I use 5GL as modern easy to learn, practical examples for young programmers to learn a stack machine reverse polish notation programming language. After they learn 5GL, it will be trivial to learn Forth. You can see the source code of my 5GL JavaScript module using browser developer console. If you wish to have a copy of my PHP 5GL module, please direct message me for terms and conditions. I am fine with open source licensing. But I prefer "JAA" -- Just Ask the Author.
&gt; (1) Why, in your opinion, can only Forth colon definitions be used to break down an open ended problem? Other languages have named functions as well. Why can't they be used? Which particular programming languages do you have in mind? Please specify so that I may analyse them in particular. Thank you very much.
A colon definition is just a function, apart from esoteric languages and very early languages pretty much everything supports some form of named function. Most Forth systems don't have a rich vocabulary for working with textual data. Some of the newer dialects and offshoots will do better here, but languages like C (and C++) are difficult to parse. Factor (https://www.factorcode.org) may do better here, though it's been many years since I worked with it. Perl has GCC::TranslationUnit in CPAN, this may be useful since it uses GCC's parse tree. Common LISP has things like https://common-lisp.net/project/cparse/ that might also be a good starting point. MPE has a C to Forth compiler, see https://www.mpeforth.com/arena.htm . This one is written in C if I remember correctly, but is probably worth looking at.
I just finished my PHP stack machine C/C++ parser today. I will clean up the code and share the results soon. Please remind me if you wish to have a sneak peak. Thank you very much.
I think there'll be a big disconnect from Forth to your 5GL. Let's assume that you have a stack oriented means of writing JavaScript. I think the resulting language will be quite unlike Forth. There's a lot of questions. (1) how will you handle interaction with global and local variables? (2) Traditional Forth is typeless (in that values on the stack are typically just numbers, which may be values, pointers, etc). How do you deal with types in the host language? (3) how are functions from the host language exposed to the 5GL? (4) what about object properties? (5) how do you deal with operator overloading? Let's say that you are converting something like this in JavaScript: a = "hello, " + "world!"; console.log(a.length); How would this look in 5GL? It might work to do something like: "hello, " "world" + .length console log() (Assuming that a "." prefix is used to access an object property and a "()" suffix to call an object method). But: this assumes objects on the stack. So you now need to track the object types and use the appropriate class methods to access things. Do you have a way of exposing these properties and methods as words automatically? If not, all those frameworks won't do much good. Also: do you have a way of mixing the 5GL code into existing codebases? The other factor I see here is mixing languages. How interchangeable is 5GL over JavaScript with 5GL over PHP? Or potentially a 5GL over C? How do you plan to abstract things? Assuming that all of this is worked out, how would one then go from 5GL to a Forth? Apart from some superficial syntax similarities due to the use of a stack, is there a plan for this? Does 5GL have a return stack? Anything like `DOES&gt;`? Is there a plan for how Forth users could adapt their code for your all encompassing language? On the topic of licensing: a clear, up front license is vastly superior to "JAA". Without a license, I have to assume that I have no rights to look at, distribute, or use your code.
[removed]
&gt; I think there'll be a big disconnect from Forth to your 5GL. Let's assume that you have a stack oriented means of writing JavaScript. I think the resulting language will be quite unlike Forth. There's a lot of questions. I think I would like to address your questions and concerns from a bigger perspective. As you are aware, Forth is a wonderful programming language -- perhaps the most important programming language, but there has been no winning formulas in marketing it to younger programmers. The analogy is like the railways branching out from a train station. I pick this analogy as it is related to the "shunting yard algorithm" by Dijkstra, which gave rise to the stack machine, reverse polish notation and Forth. Programming languages today are like railways branching out from a train station. There is no way of making them converge. 5GL is perhaps the only workable solution. So I call it the "inverse shunting yard algorithm" -- to execute RPN within any given programming language. The goal is not to answer your questions myself. The goal is to train more younger programmers who can answer your questions, which I believe, there are now sufficient material which I produce for this purpose. 
what does power signify if it is different from support(and speed)?
From a 2007 era ColorForth snippet on comp.lang.forth: https://groups.google.com/forum/m/#!searchin/comp.lang.forth/PNG/comp.lang.forth/yLeh48XHFio ~~~ ( Print PNG to disk ) variable w 1024 w ! variable h 768 h ! variable d 1 d ! : frame 0x1E80000 ; \ the video frame buffer address ( DOS file ) ( create a File on a floppy disk - you won't need this ) : blks 256 * ; : w/c 18 blks ; : buffer 604 block ; : size ( -a ) buffer 0 1 reads buffer 0x98F + ; : set ( n ) ! buffer 0 1 writes ; : cyls ( n-nn ) 1 swap w/c -1 + + w/c / ; : put ( an ) dup 2* 2* size set cyls writes /flop ; : raw ( an- ) 15 swap 2* 2* w/c -1 + + w/c / writes /flop ; : get ( a ) size @ 3 + 2/ 2/ cyls reads /flop ; : .com 0 63 blocks put ; \ blks n-n size in blocks to words \ w/c -n words per cylinder \ buffer -a 1 cylinder required for floppy dma \ size -a locate size of 2nd file. Floppy has first FILLER then FILE allocated. \ FILLER is 2048 bytes, to fill out cylinder 0. Names at most 8 letters, all caps. \ Directory starts at buffer 980 + \ set n size. FILE must be larger than your file. \ cyls n-nn starting cylinder 1 and number of cylinders \ raw an write raw data to cyl 15 , block 270 \ put an write file from address \ get a read file to address ( Crc ) macro ( colorForth specific - will need to be changed ) : 2/s ?lit 0xE8C1 2, 1, ; ( I'm not sure what his is ) : 1@ 0x8A 2, ; ( I think this is c@ ) forth variable ad1 36054 ad1 ! variable ad2 54347 ad2 ! : array ( -a ) pop 2 2/s ; : bit ( n-n ) 1 ? if 1 2/s 0x-12477CE0 or ; then 1 2/s ; : fill ( nn ) for dup 8 for bit next , 1 + next drop ; : table ( -a ) align array 0 256 fill : crc ( an-n ) -1 swap for over 1@ over or 0xFF and table + @ swap 8 2/ s or 1 u+ next invert nip ; : +adl ( n ) 0xFF and ad1 @ + dup ad2 @ + : adl! ad2 ! ad1 ! ; : +mod ad1 @ 65521 mod ad2 @ 65521 mod adl! ; ( lz77 ) macro : @w 0x8B66 3, ; : *byte 0xC486 2, ; : !b a! 0x289 2, drop ; forth : *bys dup 16 2/s *byte swap 0xFFFF and *byte 0x10000 * + ; : . *bys , ; : +or over invert and or ; : 0/1 0x10 ? if 0x1E and 0x1E or drop if 7 ; then 0xF ; then 0 and ; : 4b dup 0/1 9 and over 6 2/s 0/1 0xA and +or swap 11 2/s 0/1 0xC and +or 0x8 or ; : pix dup @w d @ 2* u+ 4b ; : row 1, dup w @ 2/ dup 1 + dup 2, invert 2, 0 dup 1, +adl for pix 16 * push pix pop or dup 1, +adl next drop +mod d @ 1024 2 * * + ; : deflate 0x178 2, 1 0 adl! h @ -1 + for 0 row next 1 row drop ad2 @ *byte 2, ad 1 @ *byte 2, here over 4 + negate + *bys over -4 + !b ; : -crc ( a ) here over negate + crc . ; : crc -crc ; : wd ( -a ) here 3 and drop if 0 1, wd ; then here 2 2/s ; : bys ( n-a ) . here swap , ; : plte 0x45544C50 48 bys 0x0 3, 0xFF0000 3, 0xFF00 3, 0xFFFF00 3, 0xFF 3, 0xFF00 3, 0xFFFF 3, 0xFFFFFF 3, 0x0 3, 0xC00000 3, 0xC000 3, 0xC0C000 3, 0xC0 3, 0xC00 3, 0xC0C0 3, 0xC0C0C0 3, crc ; : png ( awh ) d @ / h ! d @ / w ! wd swap 0x474E5089 , 0xA1A0A0D , ( ihdr ) 0x52 13 bys w @ . h @ . 0x304 , 0x0 1, crc plte ( idat ) 0x54414449 0 bys swap deflate crc ( iend ) 0x444E4549 0 bys crc wd over negate + ; : at 1024 * + 2* frame + ; : full 4 d ! 0 dup at 1024 768 png ; : pad 1 d ! 46 -9 + 22 * nop 25 -4 + 30 * at 9 22 * nop 4 30 * png ; : go 1 d ! 1024 w ! 768 h ! 0 0 at 1024 768 png raw ; go ~~~ This would need a fair amount of work to run on an ANS Forth, but might be helpful as a starting point.
Thanks!
[https://groups.google.com/d/msg/comp.lang.forth/UO2E9xHOq\_g/NrzDaqf7DwAJ](https://groups.google.com/d/msg/comp.lang.forth/UO2E9xHOq_g/NrzDaqf7DwAJ) &amp;#x200B; &amp;#x200B; Thank you very much for your enlightening and interesting comments. &amp;#x200B; I am not sure if you wish to emphasize the idea that programming should be more pragmatic rather than theoretical? &amp;#x200B; I am a Chinese Malaysian. We believe in balance. Practice needs theory and vice versa. I think there have been too much practical work in the Forth world -- not enough theories like those of LISP. &amp;#x200B; Just an update to my original question: &amp;#x200B; \-- start -- Hypothesis SM1: All mathematical and programming structures can be constructed using graph. As such, they can be constructed using stack machine reverse polish notation. &amp;#x200B; We may attempt to prove the above by induction. &amp;#x200B; Firstly, we may prove the generation of natural number. Write an RPN program to generate natural numbers and verify them manually. This is trivial. &amp;#x200B; Next, write other RPN programs, which can be used to inductively prove other theorems. &amp;#x200B; Repeat the above until the collection of RPN programs can generate programs automatically, and prove all (observable) physical observations. \-- end -- &amp;#x200B; I think the above hypothesis SM1 is now self contained and well defined. &amp;#x200B; Comments welcome.
power is capability, ubiquity, interoperability (GNU, C) support is documentation, literal customer support. and speed is speed. 
One gotcha here to be careful of, since this is ColorForth: `or` is actually XOR, and `+or` is OR. Don't ask me why, you'd have to take that up with Chuck. `2/s` is arithmetic right shift (I guess it's named that because it's the "plural" of `2/`). It's not quite the same as standard `rshift` because that's logical right shift (doesn't sign-extend). The implementation here requires that calls to `2/s` are preceded by a literal. To help your understanding, I'll walk through the definition of `2/s` real quick: * First, this is a macro (defined after `macro` was called), which is ColorForth's equivalent to an immediate word. * If there's a preceding literal, `?lit` removes that literal, pushes it to the stack instead, and clears the zero flag, otherwise it sets it. (It seems `2/s` doesn't bother to check the flag with `if` here, it just assumes there is one.) * `0xE821 2,` compiles the bytes `21 e8` (reversed because of little-endianness). * `1,` compiles the least-significant byte of the literal. * So in short, compiling `5 2/s` will instead compile the bytes `21 e8 05`, which is x86 machine code for `shr eax, 5`. `1@` is indeed `c@` (compiles to `8a 00` which is `mov al, byte [eax]`), but it doesn't seem to mask out the high bytes. It looks like later code does the `0xFF and` manually instead.
&gt;2/s is arithmetic right shift (I guess it's named that because it's the "plural" of 2/) Most likely the `s` in `2/s` stands for "signed".
Thanks, and best wishes. C. H. Ting has gone to great effort to demonstrate Forth in its entirety. 
I load png,tga,bmp and jpg. the png lib is here https://github.com/phreda4/reda4/blob/master/r4/Lib/loadpng.txt I only save jpg images, The ColorForth save png don't compress and hace fix the dimensions. 
I wrote a sixel scribble drawing pad in forth with rle compression. https://hub.darcs.net/pointfree/forth-sixel
I don't think so for two reasons: * I actually completely screwed up; `2/s` is actually unsigned like `rshift`. * Even if I hadn't, `2/` is signed too, so it wouldn't make sense for the "s" to mean "signed" in `2/s`.
If it's actually unsigned, then the plural hypothesis makes perfect sense.
Latest updates: [https://github.com/udexon/5CSM/tree/master/SMPG/CSM\_5GL](https://github.com/udexon/5CSM/tree/master/SMPG/CSM_5GL)
&gt; This example illustrate how Forth style colon definition can be used "rename" &gt; blocks of code of high level programming langauge (e.g. C/C++), thus making &gt; it more legible, structured and manageable. An interesting goal, but I think the current results leave a lot to be desired. &gt; The following is the output of cparse.php (will be uploaded after clean-up), &gt; a C parser written in PHP. It uses one simple rule: look for '{' and '}' as &gt; start and end markers, output block label as B_startline_startcol_endline_endcol. &gt; Each line starts with the line number, followed by the column number of either &gt; '{' or '}'. The number following IN_IF is the nest level of the block. There's a lot more to parsing C than just identification of `{ }` blocks. &gt; Even with such a simple example, it shows that the code can quickly grow &gt; unintelligible, due to fundamental flaws in the design of high level programming &gt; languages. Sure. But I don't see why this example is necessarily unintelligible. From a quick skimming, I can follow along with much of the overall flow, even though I don't know the OpenCL functions. It's also C++, not C, and so may not be the best test of a "C parser". &gt; The next step for cparser.php will be to provide the Forth style colon definition to &gt; "rename" the block labels B_* -- to give a legible name, to give it more meaning, &gt; structure and make in more manageable. Ok, so then you end up with output like: S_193_39 S_194_19 S_195_62 S_198_18 S_199_42 S_200_29 S_202_21 C_203_3 if B_203_28_206_0 else B_206_7_296_0 S_300_30 S_301_17 S_302_23 S_303_14 S_305_20 S_307_48 S_310_42 S_313_40 S_314_15 S_316_15 C_339_6 do B_317_3_338_0 S_340_27 S_343_40 S_344_20 S_346_32 S_349_36 But: - I find this more incomprehensible than the original C++ code. Names should carry meaning and intent, these auto-generated names are useless without the original source to cross reference. - How will the code in these blocks be converted to Forth? (given the mention of colon definitions, I assume this is the goal) I think that going from something like this excerpt: if (ciErrNum != CL_SUCCESS) { printf(" Error %i in clGetPlatformIDs Call!\n\n", ciErrNum); bPassed = false; } To: : C_203_3 ciErrNum @ CL_SUCCESS != ; : B_203_28_206_0 ciErrNum @ z" Error %i in clGetPlatformIDs Call!\n\n" 2 printf false bPassed ! ; C_203_3 if B_203_28_206_0 else Seems rather messy and the names don't help me understand the intent of the program as opposed to the structure of the original. (This also makes me curious: how will your 5GL handle local variables across the various separate colon functions?) 
Sure your comments come quicker than I expected. I was going to add examples of colon definition names that are more meaningful. Thank you very much for your interests. I will update the notes soon.
 Let us continue with Forth style colon definition to give the statements and blocks more meaningful names: ``` : init_setup S_193_39 S_194_19 S_195_62 S_198_18 S_199_42 S_200_29 S_202_21 ; : get_platformid_fail C_203_3 ; : fail_message B_203_28_206_0 ; : get_platform_info B_206_7_296_0 ; : get_cpuinfo S_300_30 S_301_17 S_302_23 S_303_14 S_305_20 S_307_48 S_310_42 S_313_40 S_314_15 S_316_15 ; : eof_cpuinfo C_339_6 ; : cpu_stream B_317_3_338_0 ; : end_message ; ``` Now the 5GL code can be rewritten as: ``` init_setup get_platformid_fail if fail_message else get_platform_info get_cpuinfo eof_cpuinfo do cpu_stream end_message ``` 
I get a 404 on the gitlab link.
&gt; This example illustrate how Forth style colon definition can be used "rename" blocks of code of high level programming langauge (e.g. C/C++), thus making it more legible, structured and manageable. &gt; &gt; An interesting goal, but I think the current results leave a lot to be desired. This exercise aims to demonstrate a new paradigm in (meta)programming. It is by no means complete. We can transfer plenty of Forth knowledge to parse C++ and other high level programming languages. What I am aiming to do is to attract more programmers to Stack Machine Metaprogramming -- I am planning to start new Reddit sub, LInkedin and Facebook groups for this.
This works, but is both a time consuming (you'll need to cross reference the identified blocks in the C source, and choose suitable names) and fragile (since the block identifiers need to be updated when the C code is altered) manual process. Other than mapping to blocks of C code, how will this actually help in executing a specific section of code to test in isolation? Let's say I had something like: 0 int ngaValidatePackedOpcodes(CELL opcode) { 1 CELL raw = opcode; 2 CELL current; 3 int valid = -1; 4 int i; 5 for (i = 0; i &lt; 4; i++) { 6 current = raw &amp; 0xFF; 7 if (!(current &gt;= 0 &amp;&amp; current &lt;= 29)) 8 valid = 0; 9 raw = raw &gt;&gt; 8; 10 } 11 return valid; 12 } And we get identify a couple of blocks in this: LOOP_5_10 IF_7_8 How would these be tested interactively? They depend on local variables (`i`, `raw`, `current`), which wouldn't be in the extracted blocks. You could cast the variables as globals, but that makes testing recursive or reentrant functions substantially more difficult. In Forth, I'd probably do this as something like: :unpack-opcodes (n-nnnn) #3 [ dup #255 and swap #8 shift ] times ; :valid-opcode? (n-f) #0 swap unpack-opcodes #-1 swap #4 [ #0 #29 n:between? and swap ] times + ; In the Forth case, there are no variables, so passing in test data on the stack makes interactive testing easy.
The example I used merely serves as a proof of concept. In practice, Pareto principle would dictate what sort of applications and target programming languages 5GL or SMMP (stack machine metaprogramming) would be used. As such your question concerning local variables largely depends on the target applications and programming languages. As I mentioned in the GitHub post, there are 2 scenarios to apply SMMP: (A) As macro to modify source code before compiling it. (B) As a wrapper for interpreter execution. The Issue of local variables is resolved by the compiler in scenario (A). For scenario (B), it is most likely new programs would be written from scratch, as an interpreter would make it much easier. ie. The programmer would design the program in such a way to minimize issue of local variables. 
Just to recap, 2 important motivation of 5GL and SMMP (stack machine metaprogramming): (1) It would be impossible and counter productive for Forth programmers to rewrite existing function libraries in Forth. It is much easier to use 5GL SMMP to bridge the gaps between Forth and other programming languages. (2) There is not much incentive for programmers of other programming languages to learn Forth. 5GL SMMP allows programmers to use their preferred programming languages and learn a Forth-ish language to upgrade themselves.
Just to recap, 2 important motivations of 5GL and SMMP (stack machine metaprogramming): (1) It would be impossible and counter productive for Forth programmers to rewrite existing function libraries in Forth. It is much easier to use 5GL SMMP to bridge the gaps between Forth and other programming languages. (2) There is not much incentive for programmers of other programming languages to learn Forth. 5GL SMMP allows programmers to use their preferred programming languages and learn a Forth-ish language to upgrade themselves.
Just to recap, 2 important motivations of 5GL and SMMP (stack machine metaprogramming): (1) It would be impossible and counter productive for Forth programmers to rewrite existing function libraries in Forth. It is much easier to use 5GL SMMP to bridge the gaps between Forth and other programming languages. (2) There is not much incentive for programmers of other programming languages to learn Forth. 5GL SMMP allows programmers to use their preferred programming languages and learn a Forth-ish language to upgrade themselves. 
Hmm... I like `2,`... my compiler right now has commas for chars, words, dwords, and qwords. I'll have to think about number commas now. 
Congratulations Nice to read it! For my is a source of inspiration, I check the new IO system, I'm searching some like this.
Good work!
I love Mecrisp. On arm-cortex uCs, I get so frustrated with the C-based dev environments. None of them are very Linux-friendly, and the stacks of libraries that are so popular for configuring devices are impenetrable. After getting Mecrisp to work on a few STM32 dev boards, it was like heaven. Awesome to see more instruction sets supported. I also learned a ton about how to use a macro assembler by reading the Mecrisp source.
I didn't know "no compression" was an option in a PNG!
yes, see https://superuser.com/questions/454539/convert-image-to-uncompressed-png-from-the-command-line
You could write a game, for example ;-) I have found out that game development is a great way to learn about most of the features of a programming language.
Including all of the "helpful features" that end up being artificial limitations, sadly.
[removed]
Same here. In lisps I do this with fact/fib (it's fun to see unknown lisp implementation printing fact 10000 super fast) In other functional languages I write powerset or coin-change 
I also thought what the heck Forth would be useful for, after learning that STARS example for the first time when I read that book, but if you continue reading *Starting FORTH*, you will be able to do more than just print stars to the screen :). Forth is different, unusual and scary at first. But it's extremely powerful. Forth is extensible, you can define your own control structures, and standard constructs such as `IF`, `ELSE`, and `THEN`, among many others, are implemented in Forth itself. You can't do that in most languages, except maybe Lisps. With great power comes great responsibility, and to program well in Forth you need to adopt a completely different mindset you're used to, breaking problems down into its constituent parts and building it all up again. In the real world, Forth is often used in embedded systems where resources are scarce, where even an optimizing C compiler won't cut it. It's even been used in outer space; the Philae comet lander. It's also fun (and recommended) to write your own Forth implementation, such as [http://git.annexia.org/?p=jonesforth.git;a=summary](http://git.annexia.org/?p=jonesforth.git;a=summary) . I have been writing a Forth-based operating system for TI-84+ calculators. [https://github.com/siraben/zkeme80](https://github.com/siraben/zkeme80) Most of it is written in assembly, for speed, but it ultimately that layer serves to create the Forth layer with an interpreter and compiler. The source code for that GIF you see in that repo can be found at [https://github.com/siraben/zkeme80/blob/master/bootstrap-flash1.fs](https://github.com/siraben/zkeme80/blob/master/bootstrap-flash1.fs) , it's written entirely in Forth. Why Forth? Because it's much easier to debug than assembly, and so it lets you write more code more quickly, while still being fast. Stick with it. It's worth the journey.
Can you give an example of such a feature? I'm curious what you mean.
An easy one: Automatic garbage collection. In Java for a while when it was new, you couldn't adjust it without messing with the JVM which was a task and a half. Nowadays its better, but random slowdowns when running a larger Java app are unsurprising. The same could be said of C or C++ GC when a programmer tries to be too clever for their own good.
I've only ever used garbage-collected languages (including my favorite, which is Factor), so I don't even know what I'm missing in that regard. How does one collect one's garbage in Forth? Is it mostly just a matter of keeping an organized data stack?
Forth doesn't have GC unless you implement it. The closest it comes to any type of memory alloc/dealloc would be `allot` and `forget` but other than that, you're on your own. Although one of my favorite things to use Forth for is testing memory allocation algorithms.
&gt; With great power comes great responsibility, and to program well in Forth you need to adopt a completely different mindset you're used to, breaking problems down into its constituent parts and building it all up again. The freedom is wonderful, yes.
You like creating acronyms... &gt; SMMP (Stack Machine Metaprogramming) appears to be the first (as far as we are aware) theoretical and practical that can be used to integrate all know programming langauges and platforms, given the simplicify, flexibility and versatility of of the Reverse Polish Notation (RPN). I have yet to see you post anything dealing with the *practical* aspects of this. &gt; By extending the colon definition in the Forth programming language, we propose the Colon Definition Integrated Billing (CDIB), a mechanism for software authors (programmers) to claim ownership of a piece of code down to a single colon defition (coldef), thereby allowing the code owner to bill other parties who make use of the code. This is a bad idea IMO, and very much not in the spirit of Forth. Consider briefly: - colon definitions are just functions - why would someone want to pay to use a single function? - what about all the factors of a definition? - what if the definition changes, would a user need to pay again? and again, what about the dependencies? Given that colon definitions should ideally be short and well factored, you could be looking at dozens or hundreds of factors for a single high level definition. Going onto more practical concerns: - who pays? the developer using the function? the user of the finished product? - is the license a one time thing or a subscription model? - is the license for a single application, particular number of applications, or unlimited in scope? - is the license per developer? per end user? This also leaves out any details on how you propose to extend a functions to track licensing and collect payments. (As a side note, I'm not opposed to paying for, let's say, a commercial library that provides functionality I want and don't have time or domain knowledge to develop and support. Or donating to developers or offering commercial licenses. But paying on a per-function basis seems like a really bad idea to me.)
Please see this reply on comp.lang.forth that addresses some of your questions: https://groups.google.com/d/msg/comp.lang.forth/DjV79TGcpdE/qoNzytndGAAJ
I don't see any actual answers to my questions in that post. &gt;&gt; Why would &gt;&gt; anyone write forth when they can do it in Haskell and be free. &gt; &gt; The post below demonstrate how a C/C++ like program can be transformed into a "super macro" using Reverse Polish Notation: &gt; &gt; https://github.com/udexon/5CSM/tree/master/SMPG/CSM_5GL But this doesn't even attempt to answer the actual question of who pays who. &gt; The proof itself is going to be an interesting exercise, as I hypothesize that RPN can become the foundation of mathematical notations Ok, so show this. Contrast it with existing mathematical notation. Show why an RPN notation is superior. &gt; so the proof will be written in RPN, and the beauty of RPN is that the proof itself can be "executed". RPN is a *notation*. How will the proof be *executed*? &gt; This then leads to the next proposal that is perhaps not the priority of Forthers, but one which they can contribute significantly -- rewriting ALL function libraries in ANY programming language using SMSM. This will then be the main justification for CDIB (colon definition integrated billing). i.e. CDIB is not aimed at Forth words -- as I imagine they will comprise of less than 1% of all SMSM words (functions). Ok, so why are you primarily promoting a vague, incomplete specification to an audience that has very different priorities? I personally doubt that any Forth implementers are looking for a way to tie a billing and licensing system to individual words in their systems. If anything, most Forth users I've known don't seek to treat all languages as identical. Forth is a beautiful, flexible language in its own way. Code in other languages often takes forms that are very much antithetical to good Forth. Speaking for myself, I try to be pragmatic. If I need to use a particular language for a task, I do so. I can interact with things written in various languages through various existing, well understood means. Pipes, TCP/IP, and FFI all work well, and have for years. My Forth is quite non-standard, and has been influenced by numerous languages over the years. I'm interested in new languages and approaches. But I haven't seen anything concrete for your 5GL. I'd like to see an actual paper or implementation that goes into detail on how it will work. There are a *lot* of small details that need to be considered if you really intend to find a means of converting arbitrary languages to and from a stack based language. It's ok if you are intending to do just a theoretical model for this, but practical concerns still need to be considered. Set aside C/C++ for a minute. How will you convert APL? LISP? Piet? Malbolge? Smalltalk? Is there a representation of these that makes sense as a stack based language? Is there a way to know the various calling, type, and memory conventions and handle translating between them? What would this become in 5GL? (APL) PRIMES : (~R∈R○.×R)/R←1↓ιR Or this: (SmallTalk)? factorial | t | t &lt;- [:x | (x = 1) ifTrue: [ 1 ] ifFalse: [ x * (t value: x - 1) ] ]. ((t value: 5) = 5 factorial) ifFalse: [ smalltalk error: 'factorial failure']. 'factorial test passed' print Can a single 5GL code use a SmallTalk object, pass in a list from a LISP function, use a filter in APL, and then pass it the results to the C printf() function for display? What does this look like, both user, and one attempting to implement a 5GL system?
Please refer to this comment for proof using RPN: [https://groups.google.com/d/msg/comp.lang.forth/UO2E9xHOq\_g/NrzDaqf7DwAJ](https://groups.google.com/d/msg/comp.lang.forth/UO2E9xHOq_g/NrzDaqf7DwAJ) &amp;#x200B; &amp;#x200B; Thank you very much for your enlightening and interesting comments. &amp;#x200B; I am not sure if you wish to emphasize the idea that programming should be more pragmatic rather than theoretical? &amp;#x200B; I am a Chinese Malaysian. We believe in balance. Practice needs theory and vice versa. I think there have been too much practical work in the Forth world -- not enough theories like those of LISP. &amp;#x200B; Just an update to my original question: &amp;#x200B; \-- start -- Hypothesis SM1: All mathematical and programming structures can be constructed using graph. As such, they can be constructed using stack machine reverse polish notation. &amp;#x200B; We may attempt to prove the above by induction. &amp;#x200B; Firstly, we may prove the generation of natural number. Write an RPN program to generate natural numbers and verify them manually. This is trivial. &amp;#x200B; Next, write other RPN programs, which can be used to inductively prove other theorems. &amp;#x200B; Repeat the above until the collection of RPN programs can generate programs automatically, and prove all (observable) physical observations. \-- end -- &amp;#x200B; I think the above hypothesis SM1 is now self contained and well defined. &amp;#x200B; Comments welcome.
Thanks a lot for your very interesting comments and questions. Will address them by parts later.
[removed]
I will address your questions regarding fees and payment methods after we have discussed the technicalities of applying colon definition to non-Forth languages, as the fees / payment issues invariably depend on fundamental technical issues.
Try 328eForth on an Arduino Uno as you have shields and cheap sensors to explore. 
The only thing faster thanForth is Assembly language. So, to become the ultimate speed demon use Forth to learn how to optimize speed. Then learn to migrate code to Assembly language.
This is an interesting idea; although I know there are some things which are apparently very hard to do in Assembly. Then again, I've heard that that often depends on how well either the hardware or functions you're using are designed.
Read 'eForth Overview' by C. H. Ting, PhD. It's available in pdf for free. Also download 328eForth for the Arduino Uno. Deterministic programs on microcontrollers are quite easy in Forth. Working with a desktop PC muddles speed with many interrupt services. Forth replaces the OS to gain the best performance, even on a PC.
&gt; Also download 328eForth for the Arduino Uno created by C H Ting, PhD. Both are well explained. I think it's definitely a good idea to look at as many different FORTHs as possible; because the more implementations I read and become familiar with, the more clearly I'm going to identify what each universal element (like NEXT, for example) actually does. I haven't done much with the Arduino myself, but I've known someone else who was very enthusiastic about it.
C. H. Ting is an early academic follower of Forth and continues to attempt to teach the whole of Forth based on important work he did in many Forth easy to port to any hardware. So reading and using his versions are very worthwhile. I just downloaded the original 1990 code for 8086 eForth, and the upgraded version to 386 platforms. Once he has explained why it is coded the wayvit is, you'll be able to create your own optimum code based on specific goals.
Sometimes the only way to grow is by overcoming adversity. The new years demo looks pretty good. Something I couldn't imagine myself doing without putting in 10x the time and the work. Truly excellent! And you are right that Forth seems to taunt you into finding a "more elegant" way, especially with how easy it is to modify for either a major change or a minor one. I've never gotten that feeling using any other language.
Thanks. So, that took 2 days, about 6 hours. The idea of the engine was to make something you could roll off game or game-like ideas as quickly as you come up with them. Once you get a feel for how it works, it's like playing an instrument. You just tell your idea to the computer. Here's the kicker I've been dealing with. It's optimized for *that*. Other things are kind of a bear. You have to think too much.
Learn i/o yaour available options and Forth will be more useful. Open a file, store data, retrieve data. Open a port and communicate.
I know some people have their game engines segmented into different parts, like for showing text, another part for movement and collision, so on and so on. I'm not sure how you have yours put together, but breaking it up into smaller parts might help you see what you want the greater whole to become. But that's advice that applies everywhere.
It's a little hard for me to make the connection there but I think I see your reasoning. Ramen is fairly full featured and modular already though. What I meant was, certain programming tasks just kinda suck. If you want to use a c like struct for instance. The convention I set for field names is TYPE.FIELDNAME . So that inflates the code. The mechanism behind it was intended for minor problems so you have choices to make. It's just a consequence of how Forth is. There are alternative strategies but they all have tradeoffs. The easiest thing to do in any case is to make it a game object somehow. Because I optimized that.
I see. Sounds like you had started out with the benefit of a great deal of consideration. Do you do software engineering professionally?
Web developer. And actually ... the code has been in the making for almost 20 years. Trial and error, dead-ends, and hard lessons aplenty. It's strange, if I hadn't bought into the mythos of Forth so hard, I would have arrived at Ramen much sooner because it's actually quite humble in design. Apart from a couple fancy compiler extension thingies I'm doing. Whereas previous iterations (one notable one called Tengoku) were near-insane levels of complexity and essentially of no benefit since you could do the same thing easier in other languages. I've got some pretty pie-in-the-sky ideas that came out of it all, some of which I might still do ... *later*. Haha.
&gt; Read 'eForth Overview' by C. H. Ting, PhD. It's available in pdf for free. I want to thank you again for pointing me to this book. I tried reading Chuck Moore's "Problem Oriented Language," and while this book covers more or less the same ground, it does so in language which is much less abstract, and easier to understand. This will give me a much clearer understanding of the anatomy of a FORTH system.
i. TERMIO Check your TERMIO. Normally it is in "Cook" mode and the editing is done by the OS. If you are going to do the line editing you will need to be in "RAW" mode. i. figForth Look at a figForth source. It has a very simple line editing input only checking for returns and backspacing. Study it closely it does a little trick of changing the backspace character to a space when the input pointer is back at the beginning of the line. I don't know anything about gforth so have no idea of what problems you will be facing in adapting a simple fig routine to a much more complex forth. &amp;#x200B;
There really are too many "high minded" computer language books in general. C. H. Ting is all about how and why, though hr likes to mention Zen Buddhism and the Tao occasionally. Good luck.
In the back of Starting Forth is a small data base program.
Sorry, I just reread that and ... I was pretty high when I wrote that reply and I think I was a little incoherent. Basically ... let me explain Tengoku ... so it was OOP, very similar to C# in philosophy, everything an object, everything replaceable, everything black-boxed. It *looked* really nice and logical, but its fatal flaw was that every single piece of functionality went through many different degrees of separation before actually doing the work and this is what causes many modern code bases to become brittle and full of hard-to-trace errors. Try doing that in a language with no proper step-debugger or deep knowledge of the weird elaborate OOP extension you created. I was inventing a new language, and I was really ill-suited to the task. So I tossed it, and I think I went through 2 other iterations that were gradually closer and closer to the metal. Ramen embodies the don't-complexify rule. But also the don't-anticipate rule. So I'm discovering what works in Forth and slowly slowly trying out different things to make the process easier and easier. It hardly resembles C# though, which I sometimes fear makes it a tough sell. 
What does this have to do with Forth? &gt; As a coder who rather spend more time coding, one is constantly under pressure to produce academic publications. Some, working in academia, may feel this pressure. Most developers I know aren't under any pressure to produce academic papers. &gt; Instead of ending a colon definition with a semicolon ; , markdown colon definition (MDCD) includes one paragraph by default, or ends with double semicolon ;; at the beginning of a line for MDCD spanning multiple paragraphs. The examples in the article aren't Forth style colon definitions, just tags using a colon to identify them. Have you written any tooling to extract these blocks? &gt; MDCD therefore provides a handy facility to manipulate text which falls within a section, or subsection, or the smallest unit for markdown or equivalent text processing regimes. What is this facility? You show the use of a colon again, but how does the tooling or user know this is a subsection and not another section? &gt; Further, text within a paragraph can easily be manipulated using line numbers and character positions. The close ties to line numbers and character positions in these proposals bothers me. Code and documentation change. How will the tooling track this and keep the various generated functions up to date? &gt; Personally, I find MDCD tremendously useful for organizing my own thoughts when writing. I am sure many writers know the experience of unpublished drafts or notes scattered everywhere. In my case, I prefer using Gmail as my note pad. I think that using an email application for notes isn't the best idea, but k ow others who do similar things. (I prefer to use physical notebooks alongside a directory of version controlled text files for mine). &gt; With MDCD, by adding a label, one forces oneself to think of a label that makes sense. If there has been more than one label of the same, then one is forced to think of additional descriptions to make it unique. I still fail to see the benefit here. Markdown is for writing. Splitting the document into various named chunks seems like it would make it more difficult to keep things coherent. Can you provide an example showing how this is beneficial? 
I think both you and I are experienced enough to know that a good idea nowadays are rarer than code -- which lots of younger and less experienced coders can do. I do like your questions however. If you are a prolific writer, which I think you are, judging from the length of your questions, you should have plenty of unifnished drafts lying everywhere. If you are not, it is kind of difficult to relate to you the kind of mess we create for ourselves and a markdown colon definition will go a long way -- perhaps the last mile in the legendary text processing work started by Knuth. Having said that, I think you might have guessed that the implementation of markdown colon definition requires luatex -- the final excuse I need to implement my Forth extension 5GL in Lua. Do try out luatex markdown if you have not. My sample code would need luatex for testing.
I'm not sure I get it. Can you create markdown templates with stack "variable" substitutions?
Please seem my other reply: I think both you and I are experienced enough to ... https://www.reddit.com/r/Forth/comments/ah7xt1/markdown_colon_definiton_forth_colon_definition/eecjys3?utm_source=reddit-android
The motivation behind markdown colon definition -- perhaps the last mile in the legendary text processing work started by Knuth: The implementation of markdown colon definition requires luatex -- the final excuse I need to implement my Forth extension 5GL in Lua. Do try out luatex markdown if you have not. My sample code would need luatex for testing. I mean, can you imagine the fun of Forth killing Lua in TeX? I mean, TeX is one of Knuth's crowning achievements. I wondered why he hasn't embraced Forth. He might have been Charles Moore's classmate in MIT as they were born in the same year. Knuth implemented one of the most popular Algol compiler so he must know reverse Polish notation damn well. He could have been the mirror of Moore. 
By /u/DooFomDum, [who also submitted last month's top post](https://old.reddit.com/r/Forth/comments/a3ipn6/im_17_and_i_created_a_forth_interpreter_and/)
You could use forth with Glade: [Using Glade to create GTK+ Applications with FORTH [PDF]](www.complang.tuwien.ac.at/anton/euroforth/ef10/papers/mahlow.pdf) I hear [bigforth](http://bigforth.sourceforge.net/) also has gui support.
Thanks, without downloading that to my phone ATM which forth implementation is that based on?
MIN-FORTH
A couple more options: * Reva (earlier Forth from the author of 8th): http://dev.ronware.org/p/reva/home http://dev.ronware.org/p/revagui/home * GTK-server http://gtk-server.org/examples.html has an example in gforth and should be usable with others as well 
This will work with just about any desktop forth https://github.com/search?q=language%3Aforth+gtk+glade&amp;type=Code
Why don't your github posts include any code showing what you've done to implement the feature discussed?
[removed]
Code? What's that? Some kind of markdown syntax?
Surely it's self-evaluating!
A very enthusiastic post indeed, but most Forth programs are about as imperative as you get, with maximum side effects. I do think you can write Forth in a functional style, but it's not as idiomatic (or at least, as historically normal, anyway).
Having some experience from both languages, I can see where this is coming from. Forth words compose similarly to Haskell functions, both allow leaving things unsaid and implicit that are explicit in most languages. But the control you have over the parameter stack in Haskell is much more formalized. My own baby, Snigl (https://gitlab.com/sifoo/snigl); takes Forth several steps further in the general direction of Haskell.
Nice work. I have bee told about another similar project Kitten: https://groups.google.com/d/msg/comp.lang.forth/lpYwr5JtGbc/rapxAeHQDQAJ On an organizational level, I believe your project, Kitten and others could be group under Stack Machine Metaprogramming (SMMP) -- whose goal is to produce a Forth like reverse Polish notation that can "UNIFY" as many programming languages as possible (theoretically ALL of them -- as RPN is equivalent to abstract syntax tree). https://github.com/udexon/SMMP On the practical and technical level, I am inclined to produce a "shallow" "syntactic translator" as demonstrated in the following example for C/C++: https://github.com/udexon/5CSM/tree/master/SMPG/CSM_5GL I would leave the actual working of the target programming language (i.e. C/C++ or Haskell) to their respective interpreters or compilers. In this case, my RPN can be deployed regardless of the internal changes due to development of the target language, also, I do not need to maintain the resource to handle the equivalent of a monster in terms of software engineering. In the short term, I buy time to get more younger programmers interested in my 5GL (Fifth Generation Graph Language, a pun to Forth). When we have more followers, then they would be able to attack the modular work. 
Just made a "slipstream" [release 19.01a](https://8th-dev.com/forum/index.php/topic,1811.msg10335.html#msg10335), fixing a few issues.
I have it, and if I am honest I found it rather thin. Literally, and information-wise. Absolute fundamentals only.
[https://github.com/Lehs/ANS-Forth-libraries](https://github.com/Lehs/ANS-Forth-libraries) [https://forthmath.blogspot.com/2015/10/single-cell-computational-arithmetic-1.html](https://forthmath.blogspot.com/2015/10/single-cell-computational-arithmetic-1.html) If you're interested in mathematics **and** Forth.
It's thin, but originally it was meant to be used as a support to forth courses given at Forth Inc. I have it, and it helped me to learn the basics. I occasionally use it a a reference (although it doesn't contain an index -- It's small enough to find what you want). &amp;#x200B; From her and Edward Conklin, there is also 'Forth programmer's handbook'. An excellent boot to learn the internals of Ans Forth. Simple and quite complete. I bought it, but you can get it packed in PDF form when you download the Swift Forth free trial package from Forth Inc.
Thank you. :)
Have purchased the handbook as well from Abebooks. Nothing wrong with being a thin book that is well written.
Better than "Starting Forth" as it is more up-to-date. Generally, I enjoy getting initial overview from a thin text before having to conquer a thick tome. There are insights that may not seem obvious, like a clear mention of cells versus bytes and mention that a half- cell is an appropriate term on a 32 bit system.
what would be your books of choice ?
people doing concatenative programming do have fp in mind I believe
I prefer the book on MPE's site. It's beefier and free.
thanks 
 My own extension of Forth: The core JavaScript stack machine function F() is about 50 lines, not including repeated patterns and library code. It can do Ajax, with a PHP back end running an almost identical stack machine. I have also implementations in Python, C, C++. The 5GL core should be portable to any programming language. I am working on Haskell port now. Multitiered Stack Machine (nSM) https://www.linkedin.com/pulse/multitiered-stack-machine-nsm-using-5gl-fifth-graph-ng-ph-d-/ http://5gl.epizy.com/nsm/fgl.html https://github.com/udexon/SMMP nSM simply means "a stack machine within a stack machine .... (repeat up to N times)" . It is so named because the initial implementations of nSM are coded in PHP and JavaScript, whose interpreters are themselves stack machines. 
What kind of images? I've had some success with FFI-wrapping the parts of libcairo (https://www.cairographics.org/) I needed. Cairo exports to .SVG, .PNG and probably more by now. And if you hook it up to GTK+ you get a GUI canvas using the same API.
So you run a VM for a stack machine with enough opcodes to run an interpreter on top of, which runs your Forth code in the browser? Pretty cool
probably IMAGE:, it's fewer words. And if you had a bunch of IMAGE related words, they can be IMAGE:NEW, IMAGE:FILTER, IMAGE:OLDLADY etc
She was the first non-Chuck humanoid to grok Forth, I'd be surprised if her book wasn't good. Will check it out, thanks
What would you need IMAGE:OLDLADY for? Is AUDIO:OLDLADY not doing it anymore? ;)
Was a lot easier than I thought, I just added simple string support. It copies string to PAD area and places count and location on top of VM's stack. I am often amazed at forth's efficiency in execution and how readable the code can be.
[https://github.com/tehologist/ecma6-forth/blob/master/demo.fth](https://github.com/tehologist/ecma6-forth/blob/master/demo.fth) &amp;#x200B; Short demo program been working on past week, I am amazed at how little code forth requires. Demo uses only pixels and managed to create an entire text console with line and circle drawing and 16 colors. 
That is amazing, yes. Did you define "create" in another program, or assembly?
The interpreter and virtual machine are both in javascript. The interpreter looks up commands and compiles them into the vm as opcodes. Create just creates a dictionary entry with word type, name and pointer to where the code is in vm memory. It creates data words, when compiling it places a literal into code space that points to location. When called during run time it simply puts location on vm's data stack. Primitive word changes last entry in dictionary to type primitive, which during compilation places the memory value at current cell and increments code pointer. The implementation is pretty short, 540 lines total which includes interpreter, virtual machine and all the events and UI elements.
This does look very simple, yes. Thank you for that!
Awesome work, retro 11.0 was a huge inspiration to me. It kicked off my start into exploring what was possible with small virtual machines. I really like the forth functional words, I feel makes loops a lot easier to read and follow. 
I'd also pick IMAGE:. When I have a defining word which parses a name, I usually do suffix with a colon.
So I also posted this on Facebook and it was unanimous. I've already enacted it. Also END-CLASS and so on have become ;CLASS 
My other favorite is C. H. Ting and his eForth Overview. Forth attempts to be minimal, the tersest of computer languages. This how it gains excellent performance. Adding bells and whistles misses the whole concept.
Wait, what? You posted about Forth and got unanimity? Heretics!
I know! I was surprised too!
Very cool! I remember forking Reva from your assembly version of Retro, years (and years) ago...
I actually kept using Reva for some small tasks until I stopped using Linux about a year ago.
Cool. I still get people asking questions on it... but I don't actively maintain it anymore.
Writeups like this are very valuable to other budding language engineers - thank you very much
There's a Facebook Forth group?
Yup: https://www.facebook.com/groups/PROGRAMMINGFORTH/?ref=bookmarks 
:`) I forked it too when I made Glypher ... wonder if anyone remembers *that* XD 
I remember it. Still have a copy available as one of my fossil repos at http://forthworks.com:8080/glypher/dir?ci=tip and github at https://github.com/crcx/glypher Sadly it doesn't run anymore for me (Windows 7, 64-bit), but I enjoyed playing around with it back before I stopped using Windows on my personal systems.
Nice. None of that code survives in Ramen but I had an unreleased system called Test Pad based on Retro that served as a basis for some of Ramen's functionality, notably the Actor system.
&gt;There are insights that may not seem obvious For that I don't think you can beat Thinking Forth
I found "Thinking Forth" a bit difficult. Not site where it fits into learning Forth.
\&gt; Not site where it fits into learning Forth. When you've fully understood the basics and want mastery.
Up to [https://8th-dev.com/forum/index.php/topic,1811.msg10357.html#msg10357](19.01c) now...
Win32forth
I've just posted about my ForthMath if you're interested.
Very nice. How is the numerics performance on Forth in general? 
I'm afraid that Forth not at all can compare with the fastest language, if not compiled as in SP-Forth and others and coded by experts.
&gt; if not compiled as in SP-Forth Don't most modern Forths compile to binary by default?
Not GForth.
The only advantage with ForthMath compared to other math programs as GAP is that ForthMath is coded i Forth. For me the speed isn't critical. BAR\*\*MOD isn't fast enough for efficient decryption but for primary tests if you're patient .
The raw file [https://raw.githubusercontent.com/Lehs/ANS-Forth-libraries/master/forthmath.4th](https://raw.githubusercontent.com/Lehs/ANS-Forth-libraries/master/forthmath.4th) &amp;#x200B;
Thanks! Having a look now.
great answer! for now I'm stepping around the problem by using 'accept', which has consistent behaviour across the terminals I've tested.
Probably easier to start with one of the arduino based calculator projects than a dollar store calculator.
Calculators like that use chips that are not programmable. It's a specialty IC. A Raspberry Pi Zero is $5 or $10 for the one with built in wifi.
Even easier to loaf a free RPN calculator app to one's cell phone. Several mimic the classic HP calculators. Frankly, a Fourth caculator isn't as good as what HP did. They made theirs with very sophisticated floating point notation based on something like a 38 bit word. So the whole idea of a 16 bit or 32 bit Forth without full floating point is too simple. ~~~~~~ I'm very involved 328eForth on the Arduino Uno and it's great. But really great for robotics or other projects. HP calculators are the best, so try an emulator.
And 7 segment displays can't display all alpha characters to where you can differentiate between them, you need displays with more segments. So you'll probably need to replace the display and the main PCB. You'll probably need a bigger battery and probably want more keys. Something like http://hotwolf.github.io/AriCalculator/ is better.
Alternatively, you can get 328eForth up and running on an Arduino Uno with LCD display and 16 key keyboard. Then, emulate as much of an HP calculator as you can.
You wouldn't need a chip nearly as powerful as the one in the rasperry pi.
I am not saying to take a dollar store calculator and reprogram the chip that comes with it. I am saying to redesign it with a slightly more expensive chip. Something like a raspberry pi would be overkill for what I'm talking about.
I didn't bother looking beyond the IC because there was really no point. I'd look at [NumWorks](https://www.numworks.com/) if I wanted to implement something as the hardware and firmware are open source and it already runs python so it has plenty of processing power and memory for Forth.
Let's look at doing this: what resources will the Forth system need? * 8, 16, or 32 bit CPU? * How much RAM? * How much ROM/Flash? * How many I/O pins are needed? For the keyboard, you say 26 characters + a number row. So 36. Not including any shifting, whitespace, or punctuation. I'd add 4 (space, enter, backspace, and one extra for future use; maybe as a toggle to access symbols). So a simple 4x10 matrix would use 14 pins. (A more complex matrix arrangement could probably drop this a little). Assuming a segmented display, say something like this 6 character one: https://www.alliedelec.com/m/d/39c95422de72866c9adb651aa5a93105.pdf , you will need another 50 pins. So you'd need a processor with at least 64 I/O pins, or some use of I/O expanders. I'd consider using a character display like http://www.newhavendisplay.com/specs/NHD-0116AZ-RN-GBW.pdf which gives a 1x16 display using 16 pins. Other things: you'll need to make an enclosure and you'll need a battery, voltage regulator, and a charging controller (or holder if using disposable batteries). Your costs for anything approaching a useful system will very quickly exceed a dollar. So looking back to the Raspberry Pi. At $5 it's not very expensive and is more than capable of hosting a fully functional Forth. Couple with a cheap SD card and build the keyboard, display interface, and enclosure. You could probably achieve something usable for around $30-40 with some careful selections of parts.
Just to get a board made will cost more than the Raspberry Pi. Then you have something in the range of a few dollars for a microcontroller. A serial to usb chip will add another $5 or so. Then there's the display which will add more on top of that. It wouldn't be high volume so that adds significantly to the cost. It's cheaper to buy the Raspberry Pi even if it's overkill.
Pi is still overkill though there is a bare metal forthOS for it. I'm start with mecrisp or arduiforth or flashforth.
The Raspberry Pi is overkill and likely to lead you astray. The ATmega328p chip has several complete Forth solutions. 328eForth code comes with documents explaining Forth. All free.
The micro alone is ~$2 less than the Pi (or ~$7 for the W). This is also a handheld computing device. If it was for embedded control the AVR or other micros would be a better choice. It comes with storage, usb, communication, and a number of other things that makes the device more usable as a general purpose device. If you're trying to get the most functionality for the least amount of money a full computing device vs. a microcontroller is an easy choice.
If you understood anything about Forth, you don't require learning Linux and Python to create a Forth platform. Historically, Forth was created when 64K Ram computers were expensive, there was no GUI or Wifi. Bluetooth would be more appropriate than Wifi. The real question is which hardware will teach Forth the best fashion. IMHO, the Raspberry Pi Zero is a bad joke.
I do understand Forth. I use it to bootstrap custom instruction set architectures. I also use it on supervisor systems that are simple stack CPU IP on FPGAs It's great for resource constrained systems. In the context of a handheld device with the best value for the price. A Pi is an obvious choice. Yes, for learning. An isolated handheld device isn't going to be attractive. Why limit it to bluetooth when you can have both. If you're going to be learning programming keep the path open. I'm all for microcontrollers but even for a handheld device the cost of making one with a microcontroller is going to be just as expensive if not more. I historical computing quite well. Don't put blinders on when it comes to hardware. There are use cases for both. Everyone has their favorites. I rarely use Pi, but sometimes it fits. You get so much for the price and with the use case being able to plug in a real keyboard and put it up on a TV at that price point is a huge advantage.
Beaglebone or Banana Pi is better design and manufacturing than the Raspberry Pi if the desire for small Linux SOC devices is preferred. I have both. Why bother with Forth then? Python is the preferred kit. There's little reason to develop a Forth calculator in that device as you can have a complete Fortran or Cobol application. The topic is Forth and learning Forth. Not burdening the Learner with all the distractions a Linux SOC device can lead to. On a ATmega328p, one can stay focused on optimal Forth. Not a big muddle.
Portuguese sailors introduced bananas to the Americas, bringing them from West Africa in the 16th century. Bananas first became popular with the masses at the 1876 Philadelphia Centennial Celebration, where they were sold wrapped in foil for 10 cents each. *** ^^I'm&amp;#32;a&amp;#32;Bot&amp;#32;*bleep*&amp;#32;*bloop*&amp;#32;|&amp;#32;[&amp;#32;**Unsubscribe**](https://np.reddit.com/message/compose?to=BananaFactBot&amp;subject=I%20hate%20potassium&amp;message=If%20you%20would%20like%20to%20unsubscribe%20from%20banana%20facts%2C%20send%20this%20private%20message%20with%20the%20subject%20%27I%20hate%20potassium%27.%20)&amp;#32;|&amp;#32;[**🍌**](https://np.reddit.com/r/BananaFactBot/comments/8acmq6/banana/?st=jfof9k8d&amp;sh=acd80944)
Historically, yes. But: what are the use cases you see for Forth? Does an ATmega328p provide the resources you need? Should Forth be relegated to only systems that are constrained in terms of resources? Is there a place for Forth on larger systems? For something more capable than the ATmega328p at a similar price to your Arduino Nano, an ESP8266 based system could be used. It would provide a 32-bit processor and substantially more flash and RAM.
IF you're focusing on embedded control sure, but to go beyond that and deal with file system and larger processing tasks. To each their own though.
Parallax Propeller is an 8 cpu 32bit microcontroller that can use Forth in parallel on 7 cpus with the remainder providing full duplex serial i/o up into gigabaud rates. That's another alterative. Forth is complete in perhaps 500 lines of Assembly code, whereas Linux now has roughly 5000000 lines of C code. My feelings are that overwealming a new learner with elaborate resources doesn't build a real foundation in programing skills. ESP8266 is okay, but Arduino shields and senors offer economic first introduction to projects.
Sigh....
bad bot
I think the endpoint for this line of thought is just going to end up being a breadboard, a microcontroller that runs Mecrisp-Stellaris Forth, and some DIP switches for input and displays for output as seen [here.](https://www.youtube.com/playlist?list=PLowKtXNTBypGqImE405J2565dvjafglHU) Definitely more than a dollar, but the only good way I can see to have it upgradeable and fully programmable. 
I mean maybe. Here's an important part of history though: dollar stores used to be penny stores, then five cent stores. Then quarter stores and then seventy five cent stores and etcetera. Eventually as inflation goes up we will see two dollar-5 dollar stores. At that point this kind of thing may be possible.
Bluetooth seems an optional first solution. I've done in beforev with an HC-05 and Parallax Propeller 8x32. Have 328eforth installed on an Arduino Uno. Spent the afternoon configuring an HC-06 Bluetooth device. A lot of silly trouble as the RX and TX wants 3.3v ttl interface, so assumed the device was 3.3vdc power. This one has a voltage regulator. Nope, needs 3.6 to 6.0vdc to power adequately. Finally allowed me to reset the baud to the same at the USART. Haven't gotten in to work on the existing Rx and Tx pins. Possibly a conflict with the USB serial. So I'll have to try again with the io redirected. Wifi would be an even more challenging choice.
gforth uses the C `malloc` function to implement `heap-allocate`, which is then used to implement `allocate`: The primitive: heap-allocate ( u -- a_addr wior ) gforth heap_allocate ""Allocate @i{u} address units of contiguous data space. The initial contents of the data space is undefined. If the allocation is successful, @i{a-addr} is the start address of the allocated region and @i{wior} is 0. If the allocation fails, @i{a-addr} is undefined and @i{wior} is a non-zero I/O result code."" a_addr = (Cell *)malloc_l(u?u:1); wior = IOR(a_addr==NULL); And the wrapper: here ' heap-allocate a, ' heap-free a, ' heap-resize a, A, here Aconstant heap-words uval-o current-memory-words heap-words uto current-memory-words 0 0 umethod allocate ( u -- a_addr wior ) \ memory \G Allocate @i{u} address units of contiguous data space. The \G initial contents of the data space is undefined. If the \G allocation is successful, @i{a-addr} is the start address of \G the allocated region and @i{wior} is 0. If the allocation \G fails, @i{a-addr} is undefined and @i{wior} is a non-zero I/O \G result code. Beyond this I can't say as I'm not familiar with the inner workings of gforth. It might be worth asking this on the comp.lang.forth newsgroup as at least some of the gforth developers use that.
All is well, my Ardunio Uno with 328eForth installed is now working. I had a wrong resistor value in my voltage divider, megaohms instead of kiloohms. So now I easily reach it with my Android ASUS ZenFone5. Several free Bluetooth terminal apps. I using the HC05 Bluetooth app, works with the HC06 too.
You can on some systems have multiple additional dictionaries to append or remove. On the ATmega328p, 328eForth provides for one single dictionary, while Avrforth takes a more ambitious approach with multiple lexicons and multitasking. You can read each presentation.
Obviously, these Forth applications use microcontrollers without enough ran to manage file systems. And ALLOCATE in this context is a larger OS with vast resources. ALLOCATE is also an acceptable Forth word that simply allocates a contiguous data space in memory (RAM).
Comparing Forth against Assembly code for same task generally demonstrated that it outperforms write-compile-load languages. Of course assembly code is always the fastest if properly written.
VFX forth has a great compiler for producing optimizing code. Another one is mxforth which rivals C in producing efficient code. bigForth is also a native compile Forth which is quite fast. These 3 are the fastest as per this: [https://www.complang.tuwien.ac.at/forth/performance.html](https://www.complang.tuwien.ac.at/forth/performance.html)
Interesting efforts. A bit beyond my current Forth skills, but see how this might be worth doing.
Heh. "Egel" in Hebrew (עגל) is a calf; so it's funny (to me, anyway) that in Dutch it's another kind of animal. 
Try this: : test 22 s" foo" ['] constant execute-parsing ; See: * https://www.complang.tuwien.ac.at/forth/compat/execute-parsing.fs 
Thanks!
I took a couple of minutes to try it out. It works fine on my FreeBSD box after I installed `libtool`. The included example is really barebones though. I'd like to have seen a little more (perhaps as simple as some links to the various files being served from the default page). Out of curiosity, I checked to see if it was being used to host www.1-9-9-1.com and was disappointed to see that it was not. Does anyone know of any servers running on this?
It's a cute name, but perhaps not great when writing code. Numbers don't stand out very well and using a word named `1991` might get tiresome or confusing.
I just wanted to say that I appreciate the tongue-in-cheek postmodernist comment at the end
It is barebones, but that also means that there's lots of room for improvement.
The dot `.` command will output a number in the current base. Besides that, you can use `/mod` to produce a string onto the stack, stored as individual characters.
This should work: : to-string ( n -- addr c ) s&gt;d &lt;# #s #&gt; ; 123 to-string type 
I have (for now) the example running at http://forthworks.com:5050/ The default path is / and just shows "fff" Some other paths I've found: * http://forthworks.com:5050/hi * http://forthworks.com:5050/index * http://forthworks.com:5050/import * http://forthworks.com:5050/index.html * http://forthworks.com:5050/some.txt * http://forthworks.com:5050/crud.html I don't mind the actual example being lean. But having links to at least some of the supported paths would have been nice to have in the default / path. Or even a document or comment listing them as things to try could have been helpful. I ran into issues multiple times when testing the actions in '/crud.html': the server hangs and ceases responding when trying to use the POST functionality. I've had to kill it and manually restart after a couple of minutes (giving time for the socket to be released).
 s" 12 constant asdf" evaluate Is essentially how I always do it. It's all standard which imo gives it an advantage over the GForth specific way... 
It's crazy you mention the calculator OS - I've been considering a project for making a solar-powered calculator with ti-89ish capabilities, and even have the processor and solar cells open in tabs. Someone's already written a forth for the arm microcontroller I'm looking at, so it could even end up being easier than I thought. Have any for insights for such a project - even just down to feasibility? Thanks!
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [EuroForth 2019 is coming up! \[x-post from r\/forth\]](https://www.reddit.com/r/programming/comments/aqi4vb/euroforth_2019_is_coming_up_xpost_from_rforth/) - [/r/programminglanguages] [EuroForth 2019 is coming up!](https://www.reddit.com/r/ProgrammingLanguages/comments/aqg4kd/euroforth_2019_is_coming_up/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
23767! Really?
Read eForth Overview by C. H. Ting. He clearly explains that a mere 30 Forth primitives in machine code or Assembler, if available, will allow the activation of a Forth virtual machine that can then extend itself entirely in Forth. So if you can manage that relatively small challenge, the rest is inserting Forth definitions. Later, you may choose to optimize to gain better performance. You might install Forth in a very small footprint. Take a look at the 328eForth solution by C. H. Ting. Also, take a look at all the various othet small platforms he has ported eForth to. That may offer you a better grasp of building from scratch. I'm not familiar with Jonesforth, but know C.H. Ting has been an active contributor to the Silicon Valley F.I.G. since early on and has a Phd based on his efforts to teach Forth.
what's EDA stand for? Also this can't possibly be a complete tool chain for anything?
No. It's 32767
Electronic Design Automation &gt; anything Indeed Chuck's style is rather to write code only for the one thing he needs. Now, I have no idea what this code is used for ; but from what I've heard, he did all of the CAD software needed to design the GA144 chip.
I think it's the building blocks for simulating timings of really low level circuit components. AND gates a such. Pretty elegant and direct, I'd have done the same thing.
Guessing it's for randomization.
Warning- Presentation is a strong ERLANG bias. Misses key points of Forth.
It's worth mentioning it was published in 2009, to put things in context.
Looks like http://www.colorforth.com/ is not online anymore. That's sad if it is the case. 
Excellent, I can readily port all of this to 328eForth onvthe Arduino Uno and learn a lot along the way. Thanks.
Try this: https://hub.darcs.net/pointfree/forth-eda-cm-portable/browse/eda.4th
Yeah, it's been offline for a while now. There's a mirror at https://colorforth.github.io/ though.
1994. And yet hot reloading is still a rare feature in 2019. I’m curious how effective putting the browser centrally is alongside hyperlinking. I feel like jump-to-def and jump-to-callers makes me apathetic to how code is organized.
Interesting how the Holon browser is outside the system, rather than part and parcel of it the way the Smalltalk browser generally is. Sculpting rather than building programs seems to hinge on the straightforward compilation model. Forth’s directness shines here.
Holon is really neat blending of Forth with a Smalltalk-like browser environment. There are two aspects to the Holon model that have never sat well with me though. It's not written in itself (i.e. metacompilation support), and I want unfettered access to the Forth interpreter during compilation.
In my list of exotic stack operators I forgot to mention these two: * `pivot ( n1 n2 -- lo hi )` * `upivot ( u1 u2 -- lo hi )` For example: : umin ( u1 u2 -- u ) upivot drop ;inline : umax ( u1 u2 -- u ) upivot nip ;inline : min ( n1 n2 -- n ) pivot drop ;inline : max ( n1 n2 -- n ) pivot nip ;inline 
Could be fun to implement a bitonic sort with these words. Or e.g. a median 5 filter.
Looks like you updated More's 16 bit procedure to a polymorph cell procedure that will handle 32, 64 or whatever and it worked for you. The BIND is something that works if Forth's high level words vector to the body. Lina Forth does that and its common for them to do a bind manually; hadn't notice if they have a word called BIND. Don't hold me to this but I think they use PFA and not &gt;BODY; the latter may be the actual body address and not the pointer. Not sure how 'Hyperstatic Scope' applies to Forth. Googled it and it seems to be a fix for some Sheme issue that I wouldn't think would apply to Forth, but what do I know? I'm not in the hardware design world and it's too late for me to start now. But it looks like your're having fun and got something significant to work for you so I'm giving you a thumbs up.
Hyperstatic scope is basically the way the dictionary works, where words may refer to old versions of words instead of the new definitions.
While probably not seen in the wild for quite some time, I used to use computers (UNIVAC/Unisys 1100, and later 2200 series) with one's complement arithmetic. These (36 bit, word-addressable) systems had distinct encodings for +0 (all zero bits) and -0 (all one bits), and -1 had the bitwise value of 111111....1110. Normal arithmetic instructions would produce a +0 result. If you wonder why the checksum algorithm in the Internet protocols is funky, this is one reason -- originally implemented on 1's complement CPUs. If you want all 1 bits, then `0 NOT` is probably more portable and clear than `-1`. I wonder if there was a Forth for DEC 10/20 or UNIVAC 36 bit systems? That would have been fun to have had around..
Here's one --- When programming in Forth, consider where, when, and what.
So many blue links O_O
I'd like to say I found this using the yandex search engine.
thanks, but i noticed that some links were failed like that tiny open firmware's
TclForth includes the Tk GUI lib [https://github.com/wejgaard/TclForth](https://github.com/wejgaard/TclForth) Note the Wiki. &amp;#x200B; &amp;#x200B;
As the author: Thanks for your good words! - Please have a look at [https://www.holonforth.com/ef94.html](https://www.holonforth.com/ef94.html) . Holonforth actually is a metacompiler - with unfamiliar features: Holon loads the code directly into a living target system (umbilically via a monitor) and executes it \_in the target\_ during compilation where needed. The interpreter is available all the time. You can stop compilation, test a word and continue from this state. Holonforth can load selectively only the words that are needed (recursive descent method) for minimal code size. And you can debug stepwise through target code with the steps presented in the word's definition in the editor. It was fun to develop once Holonforth could recreate and work on itself this way. &amp;#x200B; 
"Nice" is charitable. Unfortunately, most of this is broken links.
&gt; The B compiler on the PDP-7 did not generate machine instructions, but instead _`threaded code'_ [Bell 72], an interpretive scheme in which the compiler's output consists of a sequence of addresses of code fragments that perform the elementary operations. The operations typically—in particular for B—act on a _simple stack machine_.
Unfortunately: &gt; only a few things were written in B except B itself, because the machine was too small and too slow to do more than experiment
Snigl (https://gitlab.com/sifoo/snigl#variables) uses prefixes and suffixes to simplify the parser and disambiguate user code. Not having to mentally keep track of which identifiers are types, variables, macros and functions makes the code significantly easier to read from my experience. Though I opted for `@` as variable prefix like Ruby rather than `$` which I find too visually disruptive.
Understand. PHP fan here. Just hoping to piss off some Javanese .... ;+)
why not use esp8266 and esp32 as the target? these chip has cheap board, huge ram(compare to ordinary arduino) and mega hz
Don't have them. And eForth hasn't been ported to them. His assembly code is presented ina way that's easy to study. And prior eForth documents allow one to port Forth to any cpu. I'm sure they are also good. I've a few Arduino shields that make driving motors and sensors handy as well. I might as well learn with what I have rather than jump around. Anything will do to program Forth in the abstract, but real project results are more rewarding. I've a stepper motor shield with 4 Pololu stepper drivers. 
Then why not post to r/java?
PHPfying java? You mean making it even worse?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/java] [PHPfying Java with $ variable prefix in Forth style Stack Machine](https://www.reddit.com/r/java/comments/b1x7oo/phpfying_java_with_variable_prefix_in_forth_style/) - [/r/php] [PHPfying Java with $ variable prefix in Forth style Stack Machine](https://www.reddit.com/r/PHP/comments/b1q3d4/phpfying_java_with_variable_prefix_in_forth_style/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
`$` is a valid prefix for a Java variable name, but for the love of God, do not, under any circumstances, use it. The Java style guide is more important than the JLS in this regard. Basically, just because you can doesn't mean you should.
I am thinking of developing reverse polish notation API for JDBC SQL functions: [https://www.tutorialspoint.com/jdbc/jdbc-select-records.htm](https://www.tutorialspoint.com/jdbc/jdbc-select-records.htm) Example: getConnection: &gt;$C createStatement: &gt;$S jdbc select: I need to access Connection and Statement objects to store the results of JDBC functions. \&gt; indicates push or store result in variable $C and $S. $ is used in RPN, not within Java code. 
Oh so you're not writing Java code with dollar signs? Then carry on.
No. I am developing programs in reverse Polish notation, run by Stack Machine in Java, calling Java functions and manipulating Java objects.
Try FlashForth. It has ready made hex images for Arduino UNO and for Arduino Mega2560. &amp;#x200B;
Well, I might. Then again, I'm actually interested in successful doing my own port. I might actually learn a bit more about the Arduino Mega2560 architecture. The bottom line is Forth isn't going to be handy without really understanding the microprocessor's features in depth.
FlashForth comes with the source code. Keep on studying.
I have a version based on eforth that runs on Arduino. It has pretty barebones hardware support, easy enough to add as the core is written in c. https://chiselapp.com/user/tehologist/repository/compc/dir?ci=6a69773d2c9083fd&amp;name=compc/arduino
&gt; The store that sells the calculator at the top of this page was rude to me and would not respond. &gt; The company that manufactures the calculators were also rude to me and would not respond. &gt; So I have made this page and decided to send the design to all of the designer's competitors. I'm sure this web page will put the store and the calculator company out of business! 
Probably not. But hopefully someone will want to try making them.
Ever notice that people are always being rude to you? Maybe it would be wise start asking yourself why?
I personally don't care what you think.
Awesome. Good luck with this project!
Somewhat the long way around as 328eforth is written in Assembly and well-explained. It's likely to be more compact and better optimized as it shares AMforth assembly routines. The Arduino bootloader is removed and replacef with Forth's inner and outer interpreter.
Perhaps you should learn Forth. Then you might quit thinking it's a stack based calculator. That's just an RPN calculator. Definitions of Forth words and using existing Forth words requires some alphabetical input and special characters. The Dollar Store isn't enough. It's a spoof. You are reinventing something than never existed . +++++ You could use a cellphone Bluetooth interface and Forth on an ESP8266 for a minimal cost. Or an ATmega328 chip with an HC-05 Bluetooth loaded with Forth.
If you really have something, please provide a detailed memory map of the calculator's microcontroller. Everyone would be awed.
I think you're getting a little off-track with the conductive ink stuff. A good place to start would be the STM32 ARM chips, where you can get a complete STM32F103 board for about the price of a coffee. I think you're completely fucking mad, I don't think this is going to be a significantly successful idea, but I don't see any reason not to at least attempt it and I wish you the best of luck.
this here sure is educational.
The STM32 would work nicely. After all, it can be programmed, has ample memory for a Forth dictionary, and can also manage the basic i/o services via RS232, SPI, or I2C. Perhaps an LCD. In fact, I'm all for anything that meets those requirements. Unfortunately, a Dollar Store calculator has a mystery CPU, which is likely to be unprogramable and lacking enough memory to fit the barest of minimal Forths. And, it isn't likely to be documented. Usually, these devices are optimized for minimal costs without any consideration for reprogramming and developed entirely for its original purpose. So you get a keypad, a 7 segment numeric display , and a battery holder in salvage. Buying a pair of Arduino Unos and using one as an ISP programmer to replace the Arduino bootloader with 328eforth in the other can be done for about $6USD. 328eforth is well documented for a noob. Then, one might figure what to do with the savaged bits to make that Forth calculator. Along the way, one might even that Forth does really depend on floating point maths. I think most of us would like to see a successful outcome.
Sure, if someone wants to fund it. Green Arrays was funded by Chuck Moore, but he's aged and there hasn't been much interest from others. Reality is the world had more good processors available that we actually have need for. So a dedicated Forth processor may not move forward. 
When you actually have a colon and semicolon displayed, you'll be much closer.
If you read the link I do have most of the ascii characters. I think what I may do is either define ( as : and ) as ; or else I may define def as ; and fin as )
You apparently didn't read what I wrote on my website very closely. I am proposing a full operating system with text and not a calculator. Maybe you should read\_harder.
Nowhere did I ever propose to use the microcontroller that comes with the calculator. I am proposing cheapening other components in order to get a better microcontroller. Now I am up to an arm cortex at 350 mips. Take a moment to look at my new design for the webapge. The entire thing is printable except for the battery. The case for the battery is 3d-printable and made out of 2 lego pieces.
Oopsie now my design on my site a printable arm cortex at 350 mips for less than 5 cents. Where is your god now? Muahahahah.
Yes for some reason people seem to be confused and think that I am trying to use the shitty calculator chip from the dollar store. Nope. Thats why I've been trying to cheapen out other parts of the calculator is to get a better chip. Now I have an arm cortex at 350 mips for less than 5 cents.
This really great! Just consider the cost reduction in manufacturing -- this puts chip production at a level that most companies can design there own chips. And a Forth chip like this of any particular design would be awesome, IMO.
I haven't been able to get very many solid specifications about what they can currently manufacture. It looks like they are still figuring out their manufacturing process. But what they report is that they are still at the phase where they see a doubling in transistor count every two years. The technology is sort of slowly catching up with silicon, though it might not ever reach the same level.
Do you have a link to a place one can buy this?
&gt; Printable logic gates can be used to reduce the number of pins necessary to just one. &gt; Because the design only uses 2 pins this frees up space for other attachments. Can you point to any examples of how this works? A means of using junt two pins for a keyboard and display would be interesting to examine.
This video shows how to drive a seven segment display with just 1 pin and a power line using xor gates: https://www.youtube.com/watch?v=ZP0KxZl5N2o.
They are still gearing up for mass manufacturing you can't buy them yet. Part of the reason is the transistor count is still doubling and unlike their silicon predecessors the transistor designs are already ready as soon as the transistor count meets the requirements of a given design. So they don't want to manufacture en mass until they've got the design down to a level they like. In their talk in 2018 they released a talk saying that they and finished designing the machines that were meant to manufacture them and were in the process of ordering them. The links to this talk and a video fo the processor are on the webpage I linked at the top of this thread.
He's only driving one segment in most of that video. At the end when he's showing multiple segments in use, there are clearly separate connections for each segment. https://i.imgur.com/0pIGY3i.jpg
I saw the talk, but until they're available to purchase, claiming a 0.05 cost is basically useless. If they were available, even at the current size, it'd be appealing as a something for prototype work. But without them being available it's just an interesting concept and not something I could plan to use in a project.
Well, your $1USD cost goal is confusing. Even the Raspberry Pi trying for under $25 for a Linux computer was something of a sham as one needed at least a USB keyboard and a monitor, or a fully operational computer with a USB port to act as a terminal. So.. The real cost of deployment was hundreds of dollars when you include the monitor, keyboard, etc. Building on the cheap often misses the boat. And often dead ends a project. Learning Forth on a small microcontroller teaches much about the beauty and usefulness of Forth, especially when the source code is available. The HC-05 Bluetooth and a Atmega328p is working well for me. Power is either a 5VDC wall wart or 3.3VDC Lithium cell. It's been running 24/7 for weeks without reset. Forth allows me to further explore the ATmega328p resources at near machine code. I'm happy. I'm not trying to prove much or seek fame. I don't need more MIPs or more RAM as much as I need more useful knowledge. 
Essentially, your project reduces down to build a dumb terminal suitable for Forth for under $1USD. Just building the keyboard for under $1USD is nearly impossible barrier. I've a complete VT100 terminal emulation that requires a conventional keyboard and a VGA monitor running on a $10USD Parallax Propeller chip. To me personally, It seems pure frustration to redesign keyboards and monitors
Just add more xor gates.
Here's a dollar, print me twenty.
The processor isn't for sale yet. Plus you can't just buy one as you should obviously know. You have to make an order of at least a couple thousand with these kinds of things.
But it's printable so you can just print one right?
If you have invested in the industrial chip printing technology too. This is not some kind of bestbuy printer producing these things it's new technology. But I don't believe you don't know this. Again you are just bullshitting. You know that this is new technology yet you don't want to acknowledge that fact. Your argument seems to be something like, "if i can't have it now it's impossible." Not true. My design is forwards thinking, yes. It will take a couple more years before it is possible to order these wafers. The technology is brand fucking new. I can assure you your bullshitting will not deter me from my goal of improving dollar store calculators. To me it's a noble goal: improve the resources of everyone by reducing the cost of calculators. A much more noble goal than bullshitting online.
I think the guys interviewed mentioned hopes of available chips by 2030. It appears what we are look at is a promotional prototype. I don't see how anyone outside of the industry can wire it to anything. I got a few GA144 chips soldered to Schmart boards, but I'd much rather have the $450USD demo board as I could actually learn something about Forth, not struggle with construction obstacles. There aren't any 5 cent microcontrollers available for Forth. These lowball cost numbers are an egotistical distraction. I can install eForth on a $2 ATmega chip run from 2 AA batteries. The ttl asynchronous serial can be boosted to RS-232 levels via a MAX232 chip or a few transistors and resistors. I know how to get a nice rock bottom cost Forth system running, but it's never going to be much below $10USD.
Still running tests and reading the 328eForth code. One way to this nibble swap is a destructive swap that may take two clocks. Since the LCD reads the high nibble first, after sending the high nibble; one could multiply the byte by hex 10, to relocate the lower nibble to the upper nibble. Then send it. It's twice as slow as a direct machine code nibble swap, but not noticeably slow to the LCD. And definition of one NOP very well may be foolish as a few clocks are involved in calling it. Coding the equivalent of eight clocks on an 8Mhz set up would provide a precise 1 micro-second delay. On a 16Mhz Arduino Uno, 16 clocks might do the same. This would be fabricated from calling the NOPs, doing a series of then, then the return. So calling a series of 14 NOPs might actually delay 16 clocks. LCDs might require a micro-second delay between reads or writes. They are slower devices. Also SPI and I2C are slower.
Its nice to hear
I can't find a viable Forth cpu IC for under $2USD. And frankly, that's good enough.
I don't know how tiny I'd call 1 meg, but, I am interested in the language and especially the shell aspect. A concatenative shell cancels out the need for pipes.
"A printable plastic forth cpu isn't for sale therefore I can't imagine it's possible." Maybe you should choose a different profession.
Well, an engineer that doesn't understand limitations, availability, and feasibility is just a dreamer building castles in the air. Forth is software, but you seem to ignore application to available hardware. I'm not waiting for a cpu, I'm working with one that's available.
BTW, if you're on Windows, you can try it *right now* grab it from [github](https://github.com/RogerLevy/RamenEngine), install SwiftForth and follow the instructions in the readme , and then click the button that says "mapedit"
Your argument again and again seems to be, "this hardware isn't the purchasable therefore your design is unfeasible." You only have the ability to design for the hardware that currently exists and not the hardware that will exists. I don't support you or your limited and narrow sighted way of thinking.
Some people sail boats, some people build boats, and some people dream of building and sailing a boat while never doing so. Remarkably, the three groups tend strongly to be mutually exclusive. You've mentioned little of real content about Forth. Whereas, I've tried to show you the least expensive way into Forth that I personally have achieved and am now studying. I don't pretend to be a visionary on the leading edge of computer design. You've a lot to learn from your first working Forth system if you merely begin at the beginning. And that is now feasible and available to you, bit you chase rainbows. Try it. Otherwise, you are tedious distraction to people that are really learning. Join the user community. It's humility versus humiliation. Humility comes with the maturity to let others show you your errors. I passed my Professional Engineers Exam in California over 30 years ago. You are caught up in the internet's illusions. 
If you really want a working hardware Forth CPU, try here. Github.com/howerj/forth-cpu It's a J1 similar Forth processor cloned on a Xilinux FPGA with VGA and PS2 keyboard support. But it isn't less than $1USD. But you'll learn Verlog and prototyping for eventually production.
The printable arm processor is not an illusion. I will not concede that it is an illusion, it is quite real. I will not concede that it can not run forth: not only can it run forth, but it can be custom printed as a forth-only processor. Your argument is that because you can't go buy one right now that it doesn't exist and that is chasing rainbows to imagine a design that uses a processor like that. You are welcome to that opinion. Whether you like it or not printable arm processors will exist over time.
Time and tide wait for no man. Perhaps your right, but you'll never buy one for 5 cents in single quality. They have to sell huge volumes to recapture the development costs. That may or may not ever happen. FYI, the Professional Engineer's exam requires everyone to pass a substantial section on Engineering Economics. You might enjoy studying the topic. Also, feasibility is interesting. Do whatever you want. I'm done.
Nice to see gamedev being done with Forth -- cool little engine you got going on :)
That is awesome.
Serious question, why would you bother making a better dollar store calculator when everyone carries a supercomputer in their pocket? Who would buy it?
I don't see any reason to waste the plastic shipped for old fashioned calculators on worse calculators. It seems logical to me to get the most out of the least amount of plastic.
Kudos for writing that in Forth! 
328eForth is both limited and not conforming entirely to ANS standard Forth. So in many ways it is better used as a case study, rather than a production tool. Do loops are called FOR loops, and there isn't an Assember. So, implementation of Assembly language is left to one's own solution. In my case of a Nibble swap and a NOP, insertion of merely one machine code could work, but requires the user to completly understand 328eForth's construction of an individual eForth word's format, including the Immediate and Compile flags and how Exit works. It's all there in the Source code, but not entirely explicitly explained. One has to review what Starting Forth presents and sort out exactly how 328eForth constructs it. To that end, I finally figured it out. So I can create a dictionary entry with CREATE and ALLOT and !then fill in the details with back and forth use of dumps and !. It's certainly a useful learning experience, but FlashForth for the ATmega328p has been recommended to me, provides source code, and offers more production friendly additions. I'll post my final Nibble swap and NOP solutions here after I've confirmed bug free operation. Hopefully very soon. After that, I may consider myself finished with eForth as I've learned nearly all I need to know from it. Nonetheless, it has been invaluable in revealing in depth, all the components of Forth and how they work together in a real and verifiable whole. One needs to understand the Inner Interpreter, the Outer Interpreter, and each and every bit of code that supports them. Otherwise, one never achieves a full appreciation of what actually is Forth. Above all, Forth isn't just a "stack machine".
Hey, gousey, just a quick heads-up: **completly** is actually spelled **completely**. You can remember it by **ends with -ely**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey /u/CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". And your fucking delete function doesn't work. You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
Hey BooCMB, just a quick heads up: I learnt quite a lot from the bot. Though it's mnemonics are useless, and 'one lot' is it's most useful one, it's just here to help. This is like screaming at someone for trying to rescue kittens, because they annoyed you while doing that. (But really CMB get some quiality mnemonics) I do agree with your idea of holding reddit for hostage by spambots though, while it might be a bit ineffective. Have a nice day!
Sigh.. not a damn thing to do with contributions to furthering the topic under discussion.... which is Learning Forth.
328eForth certainly isn't as useful as an application tool as either AMforth or FlashForth, but it's terrific for in depth learning of the minimal requirements of a true Forth that is resident on a microcontroller. In others, it's a great presentation for beginners. It does distract from issues central to Forth. I've made a lot of progress, so it may be the time for me to move on to FlashForth or AMforth. Both provide their source code and I suspect that will reveal pros and cons. Many thanks to C. H. Ting for his desire to teach the heart and soul of Forth, rather than dazzle with yet another clever rendition.
I've concluded that study of Forth code in native Assembly code as source is imperative to fully appreciating how close to hardware it is. Source code in C tends to produce a "Virtual Machine" Forth, which isn't as useful as a "true resident Forth". You may disagree we me, but I'm not likely to change my opinion. I fear virtual machines rob efficiency and create code bloat.
Hey /r/forth! Over the past couple of months I have been cobbling together a little Forth system bootstrapped from C with fairly straightforward C interop. My original intention was to use it as a scripting language for a game project, but it’s quickly come to be the tool I reach for to solve pretty much anything. I recently committed some code to interface with the AdLib sound card and it ended with me writing words to interactively livecode music and hooking timer ISRs to my interpreter to run the player logic. I read a couple of Forth books like 15 years ago, but I didn’t really “get” it until I wrote my own. It’s so much fun!
It's very easy to write a Forth, and especially so after you write one implementation. Implementing a Forth that covers large portions of the standard and is semantically correct is much easier than trying to write a Lisp or C compiler. jonesforth was a major source of inspiration for my implementation https://github.com/AlexandreAbreu/jonesforth/blob/master/jonesforth.S
Neat! The first forth computer I saw in a game was the old Red Power mod for Minecraft. You could program all kinds of automation with it and it was light on server resources. The Lua one won the popularity contest though even though they bogged down the server.
Adding more xor gates won't reduce the need for inputs to control those gates. If you want to drive this with a couple of I/O pins, you'll end up needing to use an I/O expander, which will increase your costs (in both monetary and resource use).
If I am not interpreting this video wrong you can indeed get it done with one pin and xor gates. https://www.youtube.com/watch?v=ZP0KxZl5N2o
Next perhaps, extend the Forth to provide an Assembler.
Like🎖️
Why 286?
I had an old 286 lying around and was really enjoying using it. (I am developing on actual hardware, not DOSBox. It's got a Sound Blaster, 500mb compact flash HD and an ethernet card plugged into a Raspberry Pi.) I decided it'd be fun to learn about it more deeply, and try to write the sort of programs that eluded my grasp when I was younger. I've found it really rewarding to discover how small, simple, and straightforward the code is to talk to the PC hardware, and to navigate its quirks. When I was a teenager I think I assumed talking to hardware was difficult because I couldn't get it to work, but it turns out the actual hard problem is debugging. 30 years later I still don't have a great track record of writing bug-free code the first time, but I'm MUCH better at zeroing in on the possible problems, performing experiments to narrow the scope, and building mental models of what is actually happening. I'm also finding the single-tasking environment to be a boon - there's enough friction to switching tasks that it's easy for me to stay focused on one thing at a time, but all my tools are small and fast enough that it's not really big a deal if my entire computer freezes up because of a bug and I need to reboot. 
Pretty awesome. Would you be interested in playing around with Ramen? Seeing as you have an interest in gamedev and deep knowledge of Forth I think you'd enjoy it. I'm still working on the manual so theres no hurry.
"Deep knowledge"? You flatter me! I'm just a guy who wanted to write as little code as possible. Sure, I'd probably be interested in kicking the tires a bit. I think I followed you on Twitter already :)
Relatively speaking! [Comment about the majority of Forth "enthusiasts" redacted.] I guess a better word is "experience". Nice! It's motivating just to hear that people are following and interested in it...it's a huge job.
Have you anything to indicate which compiles the swiftest code?
Yet another nothing to do with Forth thread.
I think the joke was that if only it were RPN then the blasted AI would have passed the test but I admit it's a bit of a stretch to say this has anything to do with Forth.
Which what? The code I present uses ultimately the normal "caseof" word, so it's not any faster than using that. Using multiple if...else...then might be faster, depending on how you arranged the tests and what was most likely.
There are a lot of versions of hardware that can run arduino. C is low level and can potentially run on all of them and you can use the c library’s available. Added bonus, can also test on platform testing on. Then can optimize and test for target platform. I took Dr. Tings eforth and wrote minimal interpreter to execute his higher level definitions directly to make most of the system written in forth and as portable as possible.
https://excamera.com/sphinx/docforth.html u/beckman101's docforth produces linked html documentation from forth source code. 
Wow, that looks super sweet. Unfortunately "the input program must be ANS Forth compatible in order for docforth to compile it", and I'm not anywhere near a standard forth. But this is will at least be a good read for inspiration. Thanks!
My point is that Forth is about effective efficiency, no "normal usage". I presume 8th too is attempting to optimize performance rather than just be semantics.
I disagree that Forth is about efficiency per se. In any case, yes: 8th tries to be performant, but it has other goals (security, ease of use, cross-platform development) which rate higher than performance.
I mean, you can somewhat do documentation with grep and sed.
Yeah, though worst case I'll write something that is sort of aware of colon definitions, stack effect notation, and maybe a little comment markup. 
You could redefine words such that defining a word with `create` would output &lt;a name=hello... and using a word with `does&gt;` would output &lt;a href=#hello... First load the redefinitions, then load the source code to document on top. So instead of laying down subroutine calls to word addresses lay down html. Another thing I like is integrated help systems, something like manpages for forth words. `help hello`
That's a neat way to do it. That sort of approach would be totally doable from within my current system.
Debatable of course, but really misses the niche that Forth serves, has served, and it's historical role. Welcome to the quagmire of computer programming.
Being dependent of C libraries versus being fully aware of all the features offered in a given microcontroller is the trade off. Those C libraries make assumptions, create inefficiencies. One isn't going to learn to optimize by being C dependent as they off load that responsibility to whomever created the compiler and libraries. Forth was created to work with an Assembler to deploy quickly and allow ease of optimization. Of course, I wouldn't write a Unix OS in Forth, but why bother with C in an ATmega328p?
This is an old thread, but no one mentioned the Hayes test suite. &amp;#x200B; [http://www.forth200x.org/documents/html/testsuite.html](http://www.forth200x.org/documents/html/testsuite.html)
Thanks a lot! It's totally comprehensive!
Although it's not Jonesforth and it is not for a processor that many people know, this repository creates a version of Brad's Camel Forth written in Forth Assembler and Forth for the TMS9900 processor. I had asked myself the same question and ended just doing it myself. (The Forth is in a cross-compiler dialect but should be understandable) &amp;#x200B; [https://github.com/bfox9900/CAMEL99-V2/tree/master/SRC](https://github.com/bfox9900/CAMEL99-V2/tree/master/SRC) It may give you some insight into what you want to do. It includes a lot of comments to help someone wade through it. &amp;#x200B; I have an unpublished/untested version for 16bit intel Dos in a folder that I have to get up there one day) &amp;#x200B; &amp;#x200B;
I do source files with mixed code and commentary, but don't generally extract the comments as a standalone document. I have a small program to generate an HTML file from the source, with each word in the code blocks syntax highlighted. This can be seen at [http://forth.works/322657e9dd111ef52a739db8bcf24ea1](http://forth.works/322657e9dd111ef52a739db8bcf24ea1) with the HTML export at [http://forth.works/examples/export-as-html.forth.html](http://forth.works/examples/export-as-html.forth.html). (Other examples are at [http://forth.works/examples/index.html](http://forth.works/examples/index.html)). The styling is all CSS, making it easy to adapt for non-colored displays or printing. I also have a shell script that can generate a glossary of the words used (for any words that are part of my implementation): [http://forth.works/c3e38d6893fe4d0a5483d4551789ded1](http://forth.works/c3e38d6893fe4d0a5483d4551789ded1) This will generate a file like [http://forth.works/322657e9dd111ef52a739db8bcf24ea1.glossary](http://forth.works/322657e9dd111ef52a739db8bcf24ea1.glossary) from the HTML export. Alt - Gopher Links: * export to html: gopher://forth.works/0/322657e9dd111ef52a739db8bcf24ea1 * `document` shell script gopher://forth.works/0/c3e38d6893fe4d0a5483d4551789ded1 
I tend to pursue ANS Forth or GForth as it is much easier to diverge from standard lexicon in Forth than with other languages and become heavily distracted with why. Historically, nested IF ... ELSE ... ENDIF seems to have done the job of CASE statements. 8th may even be such a non-standard situation. In the Forth Programer's Handbook by Forth, Inc. It's CASE ... OF ... ENDOF ... ENDCASE is available.
I guess it's got a 6809 (same as the Ensoniq Mirage) which is almost ridiculously suitable for running Forth on.
Quite a few of these I felt were pretty beefy applications of Forth. I suppose if it's a microcontroller, even for difficult-to-track satellites, Forth is king!
My pleasure.
6809 was particularly good at running direct threaded Forth. I believe NEXT can be coded in 1 instruction. This was a great effort by Phillip Eaton who muscled through on a machine with no prior Forth system. He can no longer claim to have "no low-level knowledge"
Sounds like you are just getting into Forth. Apologies if this is to simple. A NOP is pretty simple in Forth. And then wrapping that in a do loop gives you a delay. : NOP ; This will delay exactly as long as the NEXT routine in the Forth system. (It won't be very long. For indirect threaded Forths it will be about 3 to 6 instructions depending on the processor &amp;#x200B; : NOPS ( n -- ) 0 ?DO NOP LOOP ; \\ Usage: 100 NOPS Notice how we can pass the loop limit to NOPS on the stack, the loop index is provided inside the definition. &amp;#x200B; A better way to do this is to find a timer on the board and replace NOP with that timer. If is programmable so much the better.
This makes me ask "Why do you need to create a constant at run-time?" (just curious)
The problem isn't use of the NOP, but the fact that 328eForth does not provide an Assembler as some Forth's do. So I have to add the NOP word in the source cpde and recompile, or use available Forth lexicon to create a Forth word that's a single executible machine code that's b0000 0000 0000 0000. It looks easier that it is. The other word NIBSWAP requires x9582 machine code to swap a low byte in TOS while leaving the high byte (16 bit cells) unchanged.
The truth is neither your solution nor my imagined one would be a true NOP as both would take more than one clock cycle and thus lack any value for precise deterministic delays. A Five NOP code solution might be possible. Bit once you add in loops to extend the delay, the added code adds more time and greater inaccuracies. In other words, my mention of a single NOP was a bit of a trick question as a true single NOP can't be done in Forth. 328eforth might do 2 clocks at best presuming no time was involved in seeking through the Forth dictionary. Yes, using the existing timers is more sensible, and mastering the ISR might be useful as well.
BTW, 328eForth doesn't have Do loop structures.
The creator of RedPower, Eloraam, is making a standalone game with forth programmable computers
Super interesting video. Who would have thought..
https://wiki.forth-ev.de/doku.php/events:ef2018:synthesis [VIDEO] http://www.complang.tuwien.ac.at/anton/euroforth/ef18/papers/hoffmann-slides.pdf [SLIDES]
Looks promising. This could be implemented on top of an already-existing system as well!
&gt; The truth is neither your solution nor my imagined one would be a true NOP as both would take more than one clock cycle and thus lack any value for precise deterministic delays. Wrong. Precise deterministic delays are possible. That you don't know how long `: NOP ;` would take to execute doesn't mean that it isn't knowable. &gt; A precise Five NOP code solution might be possible. But once you add in loops to extend the delay, the added code adds more time and greater inaccuracies. Wrong. You have the same problem programming assembly language routines. To get a consistent delay you need to know and account for the overhead of the looping. &gt; In other words, my mention of a single NOP was a bit of a trick question as a true single NOP can't be done in Forth. Wrong. In a subroutine threaded Forth there's no reason that you couldn't define an immediate word that just emits a nop instruction to the code memory. &gt; Yes, using the existing timers is more sensible, and mastering the ISR might be useful as well. Different problems
Why not forget the NOP entirely, use a loop for delay and calibrate precisely with an oscilloscope. : NOP ; would likely need to be verified with an oscilloscope. I suspect it is two clocks. One to call the subroutine, one to return. The machine code NOP is one clock. Yes definitely, defining an immediate word is the key to both the NOP and the NIBSWAP. Much easier to do in the source code that afterwards in the Forth environment. But both ways can work. You are correct in suggesting that better understanding the available timers will offer more solutions. Perhaps better ones. A precise 5 NOP solutions would not be done with loops. Extending precise delays with loops creates a less precise delay.
Hi and thanks. So first off, 8th isn't an adaptation of Retro Forth, though it shares some ideas with the version of it which became Reva Forth. 'var,' is a variation on 'var'. Plain 'var' just creates a new named variable with an initial value of 0. The 'var,' variant takes TOS and initializes the named variable. Since they're both creating words, the name of the thing created follows the word as is typical. A syntax like 'var! foo 10' would have been more difficult to implement, and very non-Forthy as well.
Thanks for the clarification -- sorry if I misspoke with regard to the evolution of language. &amp;#x200B; With regard to \`var,\`, I mean, I can understand the RPN progression, but why a comma?
The decision was made so long ago, I can't honestly remember why. I think it was to parallel the use of , in regular Forth to store a value into 'here'... but that's the best I can do :/
&gt; Why not forget the NOP entirely, use a loop for delay and calibrate precisely with an oscilloscope? If that is how you want to solve your problem, go ahead. &gt; : NOP ; would likely need to be verified with an oscilloscope. I suspect it is two clocks. One to call the subroutine, one to return. The machine code NOP is one clock. The source for the compiler and the specs for the target are available, so you don't strictly need an oscilloscope. However, that requires learning more about the programming environment, so perhaps timing it with an oscilloscope or logic analyzer is easier. &gt; Yes definitely, defining an immediate word is the key to both the NOP and the NIBSWAP. Much easier to do in the source code than afterwards in the Forth environment. But both ways can work. Easier, maybe, but I wouldn't say that it's much easier. &gt; You are correct in suggesting that better understanding the available timers will offer more solutions. My point is that nop-timing solves a different problem than timers and interrupts. NOP timing is suitable for a class of problems that timers and timer interrupts are not. &gt; A precise 5 NOP solutions would not be done with loops. Extending precise delays with loops creates a less precise delay. There are numerous ways to perform a five *cycle* delay. Food for thought: an immediate word `CYCLES ( n -- )` that compiles an appropriate sequence of CPU instructions for an n cycle delay. The trivial implementation just dumps n NOPs. A smarter implementation may generate a loop once an accurate n cycle delay can be represented in less space by using a nop padded busy-loop. The first step is of course to implement your first assembler word: NOP. From what I understand of the Atmega 328p and its subroutine threaded eForth, this should just be : NOP ( -- ) 0 , ; IMMEDIATE The next step might be the simple CWAIT implementation: : CYCLES ( n -- ) 0 DO NOP LOOP ; IMMEDIATE
My own notation: LPA hStdOut mTerm .p 123 'two ¤ p; 3 &lt; |; 'bogus p :xyz
&gt;I was evaluating 8th, and I am impressed at all the work that has been done to turn Retro Forth into a professionally supported language. However, in looking over the code samples, there is one small syntax quark that irked me -- var,. e.g. &gt; &gt;10 var, foo 8th has some visual similarities with Retro Forth, and both have some shared history, but the two are quite distinct at this point. The `var,` naming goes back to at least 2005, where Reva had: `variable, ( n -- ) Create a variable with a value of n` The **,** in Ron's naming makes sense to me in relating to the `,` word.
I think that site is out of date. This is the current source for RETRO and documentation: http://forthworks.com/retro/ the variable syntax is currently `'name var` or `#22 'name var&lt;n&gt;`. In the last example, #22 could be anything (i.e an address on top of the stack).
I actually have an update for retroforth.org ready to go, just need to upload the files... Maybe in the morning. :)
Can you please explain the syntax? It's not obvious to me at first glance what should happen or why...
Well, nanosecond delays aren't really that much use. With a 16mhz crystal, 16 nops are needed to reach 1 microsecond. My original primary concern was coding the nibble swap. Approximate delays that are greater or equal to often are adequate. Yes, reading Atmel documents will answer all, but it's thousands of pages of flipping back and forth. EForth as just been a study project in how Forth is written in Assembly. FastForth offers q more feature rich support of the ATmega328p.
Thanks for your input as it did clarify the question of how to use Forth as an Assembler of machine code.
&gt; Well, nanosecond delays aren't really that much use. With a 16mhz crystal, 16 nops are needed to reach 1 microsecond. You're the one asking the question. &gt; My original primary concern was coding the nibble swap. 328eForth seems to store the top of stack in r24 (low byte) and r25 (high byte). The encoding of `SWAP` is `1001 010d dddd 0010`, where d is the target register. Thus, to nybble swap the low byte you just need to emit `1001 0101 1000 0010` (38274 decimal) to create a `SWAP r24` operation. So: : NIBSWAP ( $xyhl -- $xylh ) 38274 , ; IMMEDIATE &gt; Yes, reading Atmel documents will answer all, but it's thousands of pages of flipping back and forth. &gt; EForth as just been a study project in how Forth is written in Assembly. If eForth has been a study project in how Forth is written in assembly to you, you should have expected to be flipping through Atmel documents. That said, with no previous experience in low level AVR programming the only Atmel document I had to look at to answer your questions was an instruction reference.
You never did figure out that I posted the NOP as a red herring and I really wanted the nibble swap for LCD interface. I did read the manuals, the eForth documents, and source code. The post has been up for weeks. Now I can go back to determining how to repair the rack-snail strike mechanism in a cuckoo clock. Always something to learn. Nonetheless, you did help. Thanks.
&gt; You never did figure out that I posted the NOP as a red herring and I really wanted the nibble swap for LCD interface. You already made it clear that you didn't really want the question answered. I'm answering the question anyway, for the record, so that this discussion may serve as more than an amusement for you. It strikes me as a bit rude, however, to deliberately include red herrings in your questions. What is the point?
r/forth is so full of touts off the topic of genuine Forth programming that I thought it best. Besides the LCD does require delays of 1 millisecond and 70 milliseconds to initialize. So I began with a query of the smallest possible. Apparently I easily offend you. Perhaps your British sensibilities.
/u/8thdev can certainly speak officially, but I'll offer my thoughts on it too. In the forth world, a comma often means you're writing something to the dictionary. It'll take the top of the stack, write it at the here pointer, and advance that pointer to the next location. So to me, `var,` seems nicely idiomatic because it signals that an item on the stack will be consumed and stored in the dictionary. The `var` part connects it to named variables. So altogether it seems quite idiomatic and sensible to me.
Thanks :)
Well, your first solution of : NOP ; was simply wrong and a bit condescending. I'm not sure what's the point of belittling me. Many Reddit contributors just respond the first thing that comes to mind without full understanding of what has been said. And so, I put in a puzzle. As for my rudeness, I did say thanks twice. Excuse me for being thankful.
&gt; Well, your first solution of : NOP ; was simply wrong and a bit condescending. You're getting me mixed up with someone else.
Apologies, I did think I was just talking to one person. Your answer were especially good. Reddit can be confusing. Seeking a clear discussion on programming isn't easy in this format. I'd actually given up on getting helpful info as the topic was weeks old.
It also has two stacks.
I usually implement a stack in C as such: static TYPE stack[1 &lt;&lt; sizeof (uint8_t)]; static uint8_t stack_index; #define PUSH stack[stack_index++] = #define POP stack[--stack_index] Unless it's a stack of very large data structures, this is almost certainly more efficient than a linked list. If you need very large data structures it is better anyway to implement a stack of pointers to them. My example is a bit simplistic, but you can add under- and overrun checks easily. Using the POP/PUSH operations may also move the stack index around unnecessarily.
Retro -i no history? (Using Freebsd)
Retro's listener doesn't have any native line editing or history. I use \[rlwrap\]([https://www.freshports.org/devel/rlwrap/](https://www.freshports.org/devel/rlwrap/) ) for both of these on the occasions where I need that.
LPA is more a notation as a typical syntax (by the way, is these word not somewhat misleading for a concatenative language?). Anyhow it is easy implementable compared to APL. Each statement is a white-space separated string which is always compiled to a stream of machine code beside parsing. These tokens can include a prefix and postfix character or symbol. For example: _12.34h here '_' is a prefix character signaling negative numbers and 'h' is a postfix character signaling hexadecimal base. An example: 1 2 4.3 _2 3 4 ×.÷ Here the division operator is a postfix character. The token '×.÷' compute the compound of two arrays: [1 2 4.3 -2] and [3 4 0 0]. Each element of both arrays is at first multiplied and then divided. Implementation side, this result in machine code storing the resulting array which is virtual assigned as top of data-stack item. Please note the two white spaces for differentiating both arrays! The second white-space is of course a postfix character signaling an array end. compiled sequences can be assigned to an internal label: 'hello world' hStdOut mTerm 1000 O :greeting The array ['hello world ·cr' hStdOut mTerm] consists of three elements: A string and two machine code references. This is equivalent to a quotation, printing 'hello world'. 'O' is a primitive operator which evaluate the array and compile code for execution of this quotation 1000 times. The resulting machine code is then assigned to a label. This is signaled though the ':' prefix character. To the presented sequence: hStdOut mTerm :p print out any array. The resulting machine code for this functionality is assigned to the local label 'p'. 123 'two ¤ This sequence define the array [123 'two']. The ¤ primitive compiles code for for a specific element of this array. For example 1 2 3 4 5 ¤2 compiles code which loads the immediate value 2 into a free CPU register. This register is in addition marked as top of data-stack item. As operator the ¤ primitive can be both a prefix or postfix symbol, so the sequence: 123 'two ¤ is the same as 123 'two¤ This is equivalent in this case to your 'case' 'of' syntax. The rest just handles the case, if there exist no mapping value. That's it.
Thanks it helped. I"m just newbie in Forth. When I trying clock:day , I get "Word not found" and the same for all clock class. What I'm doing wrong? (Retro build from source)
Seems I got it ,its only for IOS....:)
Currently yes. I'll hopefully have the Unix implementation of these words done next week :)
Thanks a lot!! &amp;#x200B; Very interesting!!
Mixing a floating point and integer operation.
This isn't necessarily mixing integer and floating point. Wit a float on the stack, 8th will (IIRC) use the floating point version of 1+ and = instead of the integer versions.
I'm not understanding how that might be considered "true" .
Almost right. 8th will use the "biggest" math type when the operands are mixed. So a float plus an int results in a FP addition (as you stated). It does "automatic promotion of numeric types" so that the user doesn't have to do conversions (although that is also possible).
I think the requirement of already allocated strings is a weakness. A simple alternative to memory collection would be reference counting
DO has an immediate portion and stacks the return address until LOOP is compiled. Internally all DO does is say "remember you were here, for later".
\&gt; DO has an immediate portion and stacks the return address until LOOP is compiled. What is portion? Where is the return address stored, data or return stack or somewhere else? \&gt; Internally all DO does is say "remember you were here, for later". It also has to store the body as in "DO body LOOP" somewhere? Where?
DO only needs to store the current position in the dictionary so LOOP later knows what target address to put into the "jump" instruction. That data is usually stored on the regular stack. &amp;#x200B; In GForth: : bar \[ cr .s cr \] do \[ .s cr \] loop \[ .s cr \] ; &lt;4&gt; 0 140533557146928 140533557146952 0 &lt;7&gt; 0 140533557146928 140533557146952 0 0 140533557146976 4 &lt;4&gt; 0 140533557146928 140533557146952 0 &amp;#x200B; The first line after the definition shows the stack state directly after starting to compile a new word. The second line is the stack after compiling do, and it has some additional data. The third line is the stack after compiling loop, which consumed that additional data.
That depends on the Forth.
https://github.com/nornagon/jonesforth/blob/master/jonesforth.f#L160 If you look at this, it's compiling a (crude) BEGIN/UNTIL infinite loop which is conceptually similar. You'll notice that BEGIN is immediate, and simply stores the address of the top of the dictionary on the top of the stack. It doesn't put anything in the dictionary, because it's immediate, it runs straight away even in compile mode. Subsequent words will compile (incrementing HERE) but won't touch the stored value of HERE on the stack. Eventually we compile UNTIL which is also immediate. It runs in compile mode. The first word of line 169 ' is pronounced "TICK", and that finds the value of the following word 0BRANCH and stores it as the next word in the dictionary (COMMA). Now 0BRANCH requires a relative offset so we get hold of HERE, subtract it from the stored HERE that we left on the top of the stack, and COMMA compiles it into dictionary. Say we're in the middle of a word, and let's say HERE (which is where the next word will go) is $2100 in hex. The stack ought to be empty. The compiler sees the word DO so it runs it, fetches HERE and stacks it. The stack now contains the value $2100, and HERE is unchanged. Say we compile in a few words, let's say we read a value from a switch register on an IO port and wait until a bit is set to zero. It might look like "SWREG @ 128 AND" so it would look in memory like the value of SWREG at $2100, the address of @ at $2102, the value 128 at $2104 and the address of $LIT at 2106, and the address of AND at $2108. HERE is left pointing to $210A. When the compiler hits the word UNTIL, it goes "aha, this is immediate, I must run this code not compile its address" so it fetches the address of 0BRANCH, compiles that in, incrementing HERE - $210A contains the address of 0BRANCH, and HERE is now $210C. The next bit fetches that value, subtracts it from $2100 that we left on the top of the stack with DO, giving an offset of -$000C, and then finally compiles that value into the word as 0BRANCH's argument. So now our fragment of word starting at $2100 looks like SWREG @ 128 LIT AND 0BRANCH -$0C and that will do exactly what it looks like. Notice how DO didn't actually compile anything into the word, just left stuff for later. A practical realisation of DO/LOOP would stack the HERE value for the start of the loop in the same way and then in LOOP it would calculate the loop index from the number of repeats. There might also be another number put onto the stack to indicate what kind of loop it is so you don't try to terminate BEGIN with LOOP, or DO with UNTIL or whatever, but that's implementation dependent.
All MPE's Forth systems are documented using DocGen, which extracts formal comments from the source code. Output formats are HTML5, Markdown, Tex and Texinfo. The source code for DocGen is available with all editions of VFX Forth. DocGen was partially cloned in some versions of Win32Forth. We estimate that use of literate programming for all our sources reduces the initial bug level by at least 10%, less than the cost of writing it. VFX is not Open Source. Stephen
As someone who struggled with this until I buckled down and wrote my own Forth I feel your pain. Let me see if I can explain it to myself again. I am going to assume for the moment that we are talking about old fashioned indirect threaded code which is what most people new to Forth think of as "Forth". (This is not the "state of the art" today. You are hereby warned) &amp;#x200B; 1. There are typically a few runtime routines written in Assembler that do the real work. Mine are called &lt;DO&gt; , &lt;LOOP&gt; and &lt;UNLOOP&gt; 1. &lt;DO&gt; pops 2 args off the data stack. They are the loop LIMIT and the loop INDEX and puts them somewhere. Could be registers but in my case and other Forths they go onto the return stack. 2. &lt;LOOP&gt; increments the INDEX, checks if it exceeds the LIMIT. 1. If not it reads an offset value from program memory and branches backwards by that offset amount. (How the offset got there is in the next section) 2. If yes, it advances the Forth IP (interpreter pointer) register to the next CELL in memory and jumps to &lt;UNLOOP&gt; 3. &lt;UNLOOP pops the two arguments off the return stack and runs NEXT, the Forth inner interpreter. &amp;#x200B; At the language user level all the above is "behind the curtain". Here is what DO and LOOP do when you use them in a program. They are actually tiny "compilers". Here is a simplified definition of DO in Forth: (uses a deprecated word "COMPILE" but it serves this purpose) : DO ( -- addr ) COMPILE &lt;DO&gt; HERE ; IMMEDIATE It compiles the address of the &lt;DO&gt; routine into your "word" definition and... important part... it leaves the address HERE (the end of the Dictionary) on the stack. This address is where the loop will have to jump back to. &amp;#x200B; Here is a simplified LOOP definition: : LOOP ( -- ) COMPILE &lt;LOOP&gt; BACK ; IMMEDIATE &amp;#x200B; For education purposes I wrote the word BACK. BACK calculates the "offset" referred to earlier and compiles the offset into your word definition. &amp;#x200B; : BACK ( addr -- ) HERE - , ; \\ compile a backwards branch offset ( ADDR-HERE = OFFSET we jump "BACK" to ) &amp;#x200B; So BACK just subtracts the address on the stack left by DO with the new end of the dictionary HERE and uses comma to compile that number into the code. (HERE has moved because we have been compiling code into the dictionary all during this process) &amp;#x200B; Warning, there can be complications added to this process to deal with leaving a loop early and compile time error checks can be added to the process but this is the bare bones of how it works.
The misunderstanding you seem to have is that the body of the loop is some sort of separate block of code; I guess that someone coming from Smalltalk or Lisp could have this kind of *a priori*. But Forth is much closer to assembler. Both words have a compile-time part and a runtime part. Generally speaking the compile-time for DO leaves the an address on the stack, to be used by the compile-time of LOOP to compile a jump-back. The runtime-part of DO loads the loop parameters on the return stack. These parameters are used by the runtime part of LOOP to decide if it should jump back to DO (actually after, you don't want to execute again the runtime part of DO so it must be left outside of the actual loop) or discard the loop parameter and let the execution "thread" continue. Additional information: ANS Forth specification [DO](https://www.taygeta.com/forth/dpans6.htm#6.1.1240) [LOOP](https://www.taygeta.com/forth/dpans6.htm#6.1.1800)
I'm a big fan of literate programming. Totally agree. Forth has an unfortunate reputation for write-only programming, but it's really up to the programmer.
It is possible to make an arbitrary jump if there is any form of subroutine calls and the ability to modify the call stack.
Curious how? Can u plz give an example?
call your destination (which adds the current address plus maybe an offset = return address to the stack then runs destination), have the destination code (that I assume you control) pop the return address from the return stack.
On the website you've linked, it says it's intentionally not Turing complete hence why loops are not possible. So, provided it's designed/implemented correctly, this is not something you'll be able to do.
Without a true branch / jump instruction, I don't think you can implement a loop in bitcoin script. The control flow docs there suggest to me that you can conditionally jump to an address. Assuming the interpreter correctly implements it as documented, I don't think it's possible.
&gt; Fundamentally, loops need to be able to jump backwards. Conditionals like `if` only jump forward. Function definition is a way of jumping back, so if you can create your own functions in bitcoin script, perhaps that would work.
I don't think there is proper function definition. It looks like Bitcoint Scripts are all interpreted at the top level, and there doesn't seem to be a mechanism to define new words. Maybe I'm missing it though, as this is my first real exposure to Bitcoint Script...
` : goto ( D: JumpDest -- ) ( R: -- JumpDest) r&gt; drop &gt;r ; ` Simply changes the return address to whatever is TOS.
so that means people could make a infinite loop in bitcoin transaction?
No; there are no subroutine calls in the bitcoin script, and certainly no way to directly access memory.
Looks very nice. Light syntax, easy to read even when not knowing the language. Good choice of simple names: 'say' 'ask' 'recall'. Like 'use:' as it appears to load only selected words from a file.
There is no way to define new words.
Very cool! As 8th's author, I approve your use of the "a:" array namespace :)
May the Forth be with you too
Write your own forth or forth not, there is no try.
This is realistic; Yoda doesn't have teeth
 FORTH LOVE IF HONK THEN
Can you, please to write examples for unix:system commands? how to implement for example :ls |awk, find, cut etc... Can Retro replace bash/shell with em aliases? (I'm little bit confusing with pipes impementetions)
Doing shell things in RETRO is possible, but not as quick and easy as at an actual shell. E.g., &amp;#x200B; To get a date in YYMMDD format using the shell, you could do:: &amp;#x200B; date -u "+%Y%m%d" | sed s/20// &amp;#x200B; Wrapping in RETRO: &amp;#x200B; In RETRO, this would be: &amp;#x200B; 'date\_-u\_"+%Y%m%d"\_|\_sed\_s/20// file:R unix:popen \[ file:read-line \] \[ unix:pclose \] bi &amp;#x200B; It'd be feasible to write a series of combinators to wrap this more cleanly. E.g., &amp;#x200B; :pipe&gt; (s-s) file:R unix:popen \[ file:read-line \] \[ unix:pclose \] bi ; :&gt;pipe&gt; (ss-s) swap 'echo\_"%s"\_|\_%s s:format dup s:put nl pipe&gt; ; :&gt;pipe (ss-) &gt;pipe&gt; drop ; &amp;#x200B; And then: &amp;#x200B; 'date\_-u\_"+%Y%m%d" pipe&gt; 'sed\_s/20// &gt;pipe&gt; s:put nl &amp;#x200B; The \`unix:system\` just runs a process and doesn't allow capture of the results into RETRO. E.g., &amp;#x200B; 'ls\_-l unix:system &amp;#x200B; It'd be easy to use this to wrap simple things: &amp;#x200B; :cp (ss-) swap 'cp\_%s\_%s s:format unix:system ; :rm (s-) 'rm\_%s s:format unix:system ; &amp;#x200B; 'README 'NEW-README cp 'NEW-README rm
Thanks a lot. And is it possible to replace the xargs? For example something like : find ~/Pictures/ -name "*.png" -type f -print0 | xargs -0 tar -cvzf My_images.tar.gz
I don't have a direct replacement for xargs. The closest would be something like: '~/Pictures/ '*.png sh:find 'tar_-uf_My_images.tar_%s sh:args It's not quite the same, in that xargs constructs an argument list whereas my `sh:args` runs a command for each filename in an array. (The full code for this including the `sh:find` and `sh:args` is at [http://forth.works/b9222560bad0d402c17be7233b37b6a0.html](http://forth.works/b9222560bad0d402c17be7233b37b6a0.html)).
Thanks, _crc.. But now I get ERROR: Word Not Found , for the all a: namespace...( ERROR: Word Not Found `a:for-each`) What am I doing wrong? Current version (Using retro -i)
What do \`'a: d:words-beginning-with\` and \`@Version n:put\` display?
First just "OK" Second "201906"
Something isn't right; that implies that the array words are missing. I'm curious since I can't duplicate this with a fresh extraction of the source on my test machine. Can you try: `'array d:words-beginning-with` ? (If this shows anything then you're somehow using an older build of the system as these were renamed on 4/24).
Ok 'array d:words-beginning-with 'array d:words-beginning-with Ok array:make array:reduce array:nth array:reverse array:map array:contains-string? array:contains? array:filter array:dup array:for-each array:from-string array:counted-results array:length
Ok. Somehow you are running a copy with an image from between 4/10 (when `d:words-beginning-with` was added) and 4/23 (the day before the `array:` prefix was simplified to `a:`). You'll probably need to grab a fresh copy of the source (either the release at http://forthworks.com/retro/r/RETRO12-2019.6.tar.gz or the latest snapshot at http://forthworks.com/retro/r/latest.tar.gz ) and rebuild from that. A second option: use an external image: http://forth.works/latest.image and add a `-u latest.image` to the startup command line. A third option would be to change the uses of `a:` in the source to `array:`, though that would leave you using an older system (which I don't recommend). A fourth option: I could try to build a binary of either 2019.6 or the latest snapshot for you if you are using an x86-64 FreeBSD, OpenBSD, Linux, or macOS system. (This could take a few hours, until I get home from work I only have limited access to my test systems).
oh sh.. I forget to replace the old build with the new one on the PATH...just ran "make" sorry,sorry ...everything seems works now ...
No worries - I'm glad you have it working. Let me know if I can be of further help.
And with you as well.
Cool. I did similar "pseudoForth" implementations in JavaScript, PHP, Python, Java, Kotlin. Now focusing on creating "pseudoForth" interface in game engines: Blender, Armory, Godot.
 : d! 1+ 1+ cells sp@ + ! ; \ clearstack 2 3 4 5 9 2 d! .s &lt;4&gt; 2 9 4 5 ok 4 Although, you're probably better of passing parameters implicitly and using something like `create myarray 2 , 3 , 4 , 5 ,` when you need an array.
Don't. The stack is for passing parameters, and words shouldn't take more parameters than you can manage in the definition with few stack juggling words. As pointfree said put it in an array. Or use locals.
In 8th you can use "poke" (but you have to "needs stack/utils" first).
The entire purpose of the stack is to store data, while simultaneously minimising the need to count, because of how expensive and complex counting generally is, as you yourself observe when n is large. Counting only happens recursively, and a stack is simply a list of numbers. As a result, if you want to start manipulating multiple fields within the stack, then that requires you to make yet another recursive loop, which is external to the stack itself. Given that the entire substance of computer programming is recursive loops, we can not avoid some of them; but because they are fundamentally alien to the human way of thinking, the most reliable software is going to have the smallest possible number of them, because that will cause the least confusion and potential madness to the person writing it. It is not, however, fair to reprimand newcomers to FORTH for being unaware of this. Most operating systems have vast numbers of loops running which are beneath, and therefore completely outside of the end user's visible awareness, and as a result, said end user has no idea that they exist. The single most shocking revelation of Assembly or FORTH programming is the first one; namely, that at that level, context does not exist, and neither does anything else, other than an infinite sea of pure numbers with absolutely no fixed point of reference whatsoever. It's a great recipe for total, raving insanity if you are not careful. My point in mentioning this is to make you aware of it. Every time you have more than one of something, and you want to be able to read or otherwise manipulate a sequence of things, then you are going to have to write an additional loop (or index) in order to keep track of it. The way to avoid that, is to ideally use no more than two indices at once; i.e., index1 is EQUAL to index2, or index1 is NOT EQUAL to index2. FORTH, coincidentally, has two stacks; parameter and return, but you will find life infinitely easier if you only allow yourself to deal with one cell from each stack at a time, rather than wanting to juggle two or more. Do what is easiest to understand, and most straightforward; not what will allow you, because of its' excessive complexity, to superficially delude yourself that you have an eighteen inch long penis.
Your post said the same thing that mine did, except much more briefly. In my defense, I wanted to explain some things.
I almost cannot get past the tinfoil hat, and constant use of the meme words "based" and "redpilled". I cannot see this video as anything but a joke of some kind. Are you trolling us? Are you being serious but have some sort of personal issues?
"redpilled"? jesus fucking christ
My cat died.
I had to look up that term. Kids these days.
No no no, this has been an issue for all the posts from you that I've seen. Your posts are, at best, barely informative. At worst, you argue with others over basic terminology and knowledge. Why do you stick around here?
4k of memory or 4k of storage space?
Is there a difference?
Is there a difference between the size of a program on the disc in the file that holds it versus the amount of ram the program uses while the program in running? Does the ammount of ram a program uses always equal the file size necessary to run that program?
I once packed an interpreter and handful of words into 510 bytes so I could have a tiny Forth system in a boot sector. The compiler would have added a few hundred more bytes. Not comfortable to use by itself, but 1K would be enough to bootstrap a complete system on real mode x86. &amp;#x200B; On my current architecture it needs more due to the instruction set and packing requirements, but the kernel is still comfortably under 1k memory locations.
What is the minimum file size for a kernel that can bootstrap a full system, and what is the minimum file size of 'the full system' assuming 'the full system' means a repl with full programming and macros?
For which architecture and/or host? Real mode x86, I'd guess likely 1-1.5KB For 32 or 64 bit, I'd expect to be larger due to pointer sizes and drivers. If running under a host os, there'll be file headers and such that increase the size further. On my MISC architecture, I'd probably be about 1.2-1.5k cells (4 bytes per cell, so 4-6KB) for the minimum interactive system capable of handling my standard library.
Holy hell. Please tell me you still have that sector-sized Forth somewhere?
If a program has a narrow purpose, the memory it uses and the size of the containing file can certainly be one-to-one. Although the size of memory used by a functioning Forth shell can vary greatly during runtime, obviously.
Couple of reference numbers for your video. The primitives of Forth that let you begin writing in Forth are smaller than 10K on a 16 bit machine. Depending on where you want to stop writing assembler and begin writing in Forth it can be 1.5K to 2.5K "ish" Specific Example: I have a version of CAMEL Forth that fits in 8K and it is most of the ANS Forth "core" word set. The Assembler "primitives" use the first 2,356 bytes and they include an I/O driver for the screen and keyboard for the 1978 machine it runs on. The rest of the 8K, meaning, variables, constants, interpreter, compiler, and even a simple dynamic memory allocator takes the rest and is mostly Forth. It also has file support so that once it boots it can begin loading more source code to extend itself. (the disk card ROM (4K) is supporting the low level disk access and simple file system) &amp;#x200B; To add the assembler is another 2.6K (it's verbose) An editor would be 1K to 2.7K depending on your level of sophistication. A "meta-compiler" to let the system re-compile itself could take another 2 to 3K (not done yet) 32 bit machines make bigger images and 64 bit machines bigger again. &amp;#x200B; I think we had this discussion before about your use of the word MACROS. I think (tell me if I'm wrong) you believe that Forth's compiler (colon/semi-colon) is making macros. It is not. Macros expand when used. Forth's compiler creates something that is referenced with one token when it is used by the compiler later in the program. In some cases the reference is to native code in other cases it can be an address for thread interpreter . It can also be a byte code or a native sub-routine, but it is NOT a macro. If you want to use the correct term we call them WORDS or "colon definitions". &amp;#x200B; Forth can create macros for use with the Forth Assembler most typically where a single name expands to some assembly language in the program. Forth can also create "text macros", strings of text that can be evaluated by the text interpreter but these are seldom used these days.
LOL, if you want really in-efficient Fig-Forth sometimes had this definition (modified for ANS Forth) It's clever but not real fast. So you could ROLL the number to the top, modify it and ROLL it back down. :-) : ROLL ( \[n\]..\[0\] +n -- \[n-1\]..\[0\]\[n\] ) ?DUP IF 1- SWAP &gt;R RECURSE R&gt; SWAP THEN ;
I do... http://forth.works/r8086.zip From some old notes on it: &gt; It actually packs the RetroForth dictionary, stack, interpreter, I/O, and math words into just 512 bytes. I had to give in somewhere, so it only makes six words accessible from the interpreter at this point. &gt; So basically, you have + - * / reset . to play with. reset is used to restore the stack positions to the original settings (a good thing to use frequently since no over/underflow checking is done). The . word displays the top of the stack, and the math words are used like you'd expect from an RPN calculator.
Well, now that is beautiful. I had always thought that any functional Forth would be a little too big for a boot sector, but now you've solidly convinced me otherwise. I should give a sector-sized Forth a shot.
It's a worthwhile endeavor, I still frequently write code under artificial memory constraints to maintain an appreciation for the way things were (and often still are for embedded developers) and to remind myself that there's not a need for bloat. On my current architecture I need more space than a boot sector provides (memory on my system is cell addressable only, which leads to a lot of wasted space around strings), but even here I can have a functional system with interpreter, compiler, and a minimal listener loop into just over a thousand memory cells (32 bits per cell, so 4KB).
&gt;I once packed an interpreter and handful of words into 510 bytes so I could have a tiny Forth system in a boot sector. The compiler would have added a few hundred more bytes. Wow! That's awesome.
I think your definition is OK. The only problem is that SP@ isn't standard. Often array is better, but it's an advantage in Forth with flexible input and output. As long as we know what we are doing there are no problem. It's nice with words like: FACTORIZE ( N -- P1 ... Pn n ) that factorize N in its prime factors.
Most forths allow you to read one char from stdin thus allowing reader macros.
I don't understand this. I can't a see a connection to stdin ability and a "macro". Where and how was the macro created? Can you give us a one-liner to demonstrate this? Here is a Forth Assembler macro example: : @, \*TOS TOS MOV, ; &amp;#x200B; Here is a Forth text macro example: : DUP&gt;R S" DUP &gt;R" EVALUATE ; IMMEDIATE &amp;#x200B; Something like that would help me understand what you mean.
Not related to Forth. Downvoted.
Very funny. In a mediawiki system it's not possible to downvote but it's only possible to undo an action. And to the topic: Where exactly is Forth located if not in Academia? My understanding is, that Forth is the programming language of choice for computer scientists, so what does that mean that Linux is used in the top500 list? Don't they are using stackmachines for the calculations?
... You're incoherent. Here on Reddit we can downvote, which I did to your post. Forth is mentioned not once in the page you linked, so your post is off-topic. &gt; Forth is the programming language of choice for computer scientists False. I'd guess it's probably Python, since there are so many libraries that support it. I've seen it used anywhere from data analytics to web backends.
I have to correct myself, Forth is indeed seldom used by computer scientists, at least today. You're right. &gt; Quote: “Forth, on the other hand, is supposedly an arcane, non-mainstream, seldom-used programming language. Its role has been described: 'Hardware engineers love Forth. Traditional computer scientists hate it'.” Fifteen Years of Forth Publishing with ACM - Complang, Frenger, Paul
There is a rather active irc channel on freenode all about mecrisp forth. Terry Porter, author of this documentation is active in there. irc://irc.freenode.net/Mecrisp https://webchat.freenode.net/?channels=%23Mecrisp
Any particular reason for the user docs to use fossil's logo? (compare [https://fossil-scm.org/home/doc/trunk/www/index.wiki](https://fossil-scm.org/home/doc/trunk/www/index.wiki))
I love mecrisp. I learned so much by reading its source.
The minimum size to bootstrap a compiler is probably a minimal umbilical. An i/o loop that provides three capabilities: write a byte to memory, read a byte from memory, and call an address. I'd think this should be pretty small -- on the order of 100 bytes or less. You'd still have to build out a dictionary with it and plant a colon compiler, but it would be fundamentally minimal.
Your Use Case slide was already hitting a homerun for me. I paused and looked at it and thought "He's right, Forth is perfect for this." The talk is excellent .
Thanks! I've learned a lot on this subreddit, much of it from your posts, so thanks for the inspiration and education.
Always happy to help! I was shocked to see that you were doing this for Windows, since targeting Kernel32 is something that scares most assembly programmers away. I'm very happy to see that you made some extremely fruitful inroads on Windows.
I'm used to working with Win32 to some degree in shellcode. The parts that were the most difficult to work out were error handling (structured exception handling), and working out the FFI to safely run code from external DLLs. Probably the biggest surprise was that some bolt-on software in Windows (like security suites doing A/V or EDR work) will hook Win32 API calls, and sometimes will be compiled to use extensions like SSE, which adds constraints for \*some\* boxes. In one particular case, the code worked on all my test boxes but one (which was running a certain A/V service). I had to adjust all FFI calls to paragraph align the stack (on 16 bytes) because some of this API hooking code was pushing things through XMM\* registers, which get fussy that way. Some of it was, indeed, pretty bizarre!
this reminds me carrierIQ
Indeed, if the mobile world ever goes x86_64, I'm totally there!
Gory details indeed, but worthwhile.
Fascinating. I've never been much interested in infosec beyond obvious vectors of attack in an application, but I have great respect for you and the guys who do this kind of work. It is clearly a demanding field of work, requiring inventiveness and a wide breadth of knowledge. Kudos on making another cool Forth :)
Have been lurking outside hacking. Now this is a shortcut that is worth spending time on. Thanks a lot for sharing.
Proof that you're mentally ill?
This is arguably the best explanation of Forth for a conventional programmer that I have ever seen. Nicely done.
Thanks! I wish I could have spent more time on the language itself. But in a 45 minute talk, I had to make choices. I'm hoping to put together some more content along those lines.
See the "three instruction forth" &amp;#x200B; [http://pages.cs.wisc.edu/\~bolo/shipyard/3ins4th.html](http://pages.cs.wisc.edu/~bolo/shipyard/3ins4th.html)
Yeah, that's what I was half remembering. Thanks for the link!
Try this: : d&gt;$ ( d -- addr len) tuck dabs &lt;# #s rot sign #&gt; ; : n&gt;$ ( n -- addr len ) s&gt;d d&gt;$ ;
The way I talk online is weird and sometimes it pisses people off, and it especially seems to piss people off on reddit. But when you hear me say it out loud it's actually pretty reasonable sounding.
Your interim solution would be to use a chainloader. That is, a system-specific binary targeted to each system that loads the "true" program. Longer term? No idea.
Yeah, that's what I had considered; but it's not a viable solution in my case.
You could make a [FatELF](http://icculus.org/fatelf/).
Yeah, that's the only way to get a single executable which would work on both systems. But that doubles the deployable exe size, which isn't desirable. At the moment my preferred solution is to just say "use aarch64 systems" if you want to run 8th on them...
[http://brokestream.com/daf.txt](http://brokestream.com/daf.txt)
&gt; DSSP was not invented. It was found. That is why DSSP has not versions, but only extensions. Forth is created by practice. DSSP is created by theory. But they are similar and it is a fact of great importance. Ok, them's fighting words! But really, this makes me very interested in DSSP. I get that it's supposed to be designed so DSSP words clearly match the SETUN machine language, but it would be cool to hear from someone who's used it. I wonder how elegant it is in practice. Do I have to operate in a ternary context to appreciate its beauty?
Honestly, this sounds like your usual kind of madness. Are you sure you didn't stumble across your own comment and realize that it makes no sense, even to you?
Yes.
I have some free time, so let me give this a go: When you bootsrap Forth, you realize that the stack is sufficient to write words that emit code, and that every word that emits code is a compiler. Nothing too mysterious, once you get past the confusing terminology, and take a leaps of faith that the author isn't simply a babbling moron and might know something. Whether this is a profound realization, or not, I shall leave to your judgement.
As /u/dylund said, any word can lay down code, extending the compiler. I'd like to see more context for the quote though. The stack a means of passing data; it doesn't really have anything to do with macros, register allocation, or expansion apart from that. For an example, let's say I have an interpreter (in pseudocode): :not-found (-) 'WORD_NOT_FOUND s:put nl ; :process (a-) get-xt call ; :interpreter [ s:get lookup [ process ] [ drop not-found ] choose ] forever ; I could make this support general compilation by adding a variable to indicate the compiler status, changing `process`, and adding words to turn the compiler on and off: 'Compiler var :: Compiler on ; :; Compiler off ; immediate :not-found (-) 'WORD_NOT_FOUND s:put nl ; :process (a-) dup get-xt swap immediate? [ call ] [ compile-call ] choose ; :interpreter [ s:get lookup [ process ] [ drop not-found ] choose ] forever ; Alternately, any word could just lay down code (from RETRO): I have a `compile` namespace for some low level words that compile specific Nga bytecode. This is intended to aid in readability when constructing compiler extensions. ~~~ :compile:lit (a-) (li...... #1 , , ) ; :compile:jump (a-) (liju.... #1793 , , ) ; :compile:call (a-) (lica.... #2049 , , ) ; :compile:ret (-) (re...... #10 , ) ; ~~~ `does` is intended to be paired with `d:create` to attach an action to a newly created data structure. An example use might be something like: :constant (ns-) d:create , [ fetch ] does ; In a traditional Forth this is similar in spirit to DOES&gt;. ~~~ :curry (vp-p) here [ swap compile:lit compile:call compile:ret ] dip ; :does (q-) d:last&lt;xt&gt; swap curry d:last d:xt store &amp;class:word reclass ; ~~~ In this, `curry` is a word which compiles some code to construct an anonymous function that binds together a value and another function. There's nothing special about this; it's just taking advantage of Forth's flexible nature to let me operate at any level I desire. So how does it work? You just write words that lay down code for your system. You'll need to know the underlying architecture (instruction set, encodings, ABI, etc), and might need specific bits to call into the native code (depending on the threading model of your Forth), but there's nothing fundamentally different the normal process of writing words.
I think what he's getting at is that code is data and Forth doesn't bury that fact. :)
SaneFORTH documentation: http://www.greenarraychips.com/home/documents/greg/SFW32PR-190525.pdf Shame about the lack of colorForth. Without it, the arrayForth 3 software appears to lack a simulator.
In FORTH everything is data and everything can be code. You can write self modifying code and change the flow of a program on the fly.
Does anybody use this board for anything?
My take: if you were writing a traditional compiler, register allocation is one of the hairy code generation problems that slows you down. Extending your compiler isn't easy because it has to do so much. Forth's stack based execution model obviates this need. You can write immediate words that extend the compiler, and since runtime uses the stack, there's no register allocation headache. You get its equivalent for free. So forth as an extensible compiler is very liberating, productive, and bootstrapping the language uses this advantage to the hilt.
There are documented uses on the site, and apparently previously some military interest. At the moment, however, adoption appears to be incredibly limited.
I've seen people play around with them on you tube, what I wonder is if anyone has successfully made a product with it.
Does this `{ recv: ' onRecv }` syntax create a hash? I'm not up on all the 8th syntax, so I was curious if this is a hash or a quotation that gets passed to the server.
Yes, it's a hash ('map' in 8th's parlance). It's a dialect of JSON.
 http://www.greenarraychips.com/home/documents/g144apps.html
Ugly and narcissistic. What a combo
I assume it is very profound, that is why I was asking about it. I have only just now gotten my forth program small enough to where it won't get any smaller unless I write it in assembler. My current forth compiles to about 11 kilobytes and looks like assembler code the way it is written. It's just confusing to learns something like jonesforth and unlock the mysteries of forth when I don't know asm.
Well, you can run Forth in 32Kbytes. Linux might fit in 2Mb unless you are loading a router. Small is beautiful.
have you read *starting forth*?
FORTH words for a beginner to understand would be ANS CORE words.
If you don't mind a non-ANS Forth, [8th](https://8th-dev.com/) has a lot of samples, many of them short and simple. And it's got a good manual IMO.
A long-ish list.😎
Not clear to me how 8th fits in with classical FORTH. I guess best description it it's a FORTH inspired derivative with goal of providing a cross platform development environment. More or less.
Sam Falvo demonstrates writing a blog engine in forth: https://www.youtube.com/watch?v=mvrE2ZGe-rs Also, turtle graphics: https://stackoverflow.com/questions/12778187/examples-of-very-concise-forth-applications/
Yep, that's a fair description.
I have started watching. Looks helpful.
https://www.forth.com/starting-forth/1-forth-stacks-dictionary/ I have a couple comments... Forth isn't really conducive to Euler problems or code golf without a bit of experience. So the typical problems you'd find online for learning a language may not fit quite as well. And many of the examples you come across feel like child's play (eg Pascal's triangle). Where Forth shines is hardware and in the concepts it opens your eyes to. Forth is also much better at top down programming. Moreso than any other language I've worked with. Start high level and you can literally write what you want as a sentence and then - as you go - flesh out the code more and more. : run-traffic-light begin red 30 seconds wait green 30 seconds wait yellow 6 seconds wait again ; Okay, now it's time to flesh it out... : on ( pin -- ) lights off high ; : red red-pin on ; : yellow yellow-pin on ; : green green-pin on ; This may seem silly, but this is a lot of real life Forth code. If you're an experienced programmer and really just learning for fun, then I'd recommend reading Brad Rodriguez's Moving Forth for the eye opening it may provide: https://www.bradrodriguez.com/papers/moving1.htm Learning to use the stack to write code is neat, but at this point you could learn any stack VM and get the same experience. Eye opening Forth is about learning the inner interpreter, the code field, how the program is "compiled" and interacted with live.
It's not too bad. This page is both CORE and CORE EXTENSION. You don't need to pay close attention to the latter. &amp;#x200B; [http://lars.nocrew.org/dpans/dpans6.htm](http://lars.nocrew.org/dpans/dpans6.htm) &amp;#x200B; This could be whittled down further. E.g. it's not crucial to understand the pictured numeric output words in the first round.
Very helpful, thanks. There are (I am told) about 360 words in standard FORTH. The trick (I assume...) is learning the most useful 50 or 100. 😎
Certainly the CORE words are the basics. At a quick glance, these would be some of the most fundamental: ! @ C! C@ ( \\ \* + - / , . ." &lt; &gt; = DUP DROP SWAP : ; &gt;R R&gt; AND OR DO LOOP BEGIN REPEAT WHILE UNTIL CONSTANT VARIABLE IF ELSE THEN KEY EMIT TYPE. &amp;#x200B; Note, I left out some things on purpose. These could be second or third steps: HERE CREATE ALLOT , C, ' \['\] IMMEDIATE DOES&gt; &gt;BODY EXECUTE \[ \] EXIT RECURSE POSTPONE LITERAL UNLOOP LEAVE EVALUATE
sadly to expensive for me
your run-traffic-light example is missing an step: : run-traffic-light begin red 25 seconds wait red&amp;yellow 5 seconds wait green 30 seconds wait yellow 6 seconds wait again ; I have no idea why the red&amp;yellow step gets omitted so much.
[Egel Project - hardware control project tutorials using forth](http://home.hccnet.nl/willem.ouwerkerk/egel-for-msp430/egel%20for%20launchpad.html)
Maybe it is because most countries don't have a red &amp; yellow light step. As far as I know, it's only valid in the UK.
I migrated from gforth to Forth on Arduino (Uno) because it can actually be hardwired to something useful. Essentially Forth does more with less. So an Android device or desktop computer is unlikely to inspire real uses. Starting Forth by Brodie is pretty much a must read. eForth is my favorite author for explaining Forth in relationship to Assembler. Try considering these... A. AmForth - a bit complex for newbies B. FlashForth - Good, ready to fully support an Arduino Uno C. eForth328p - A beginners tutorial with complete source code for the Arduino Uno.
I'm uncertain you are going to find much. It looks like GSK/OOK demodulators may be created from scratch in a combination of analog and digital or normally done in Assembly for the sake of speed. It's easy to create digital modulation of FSK/OOP.
Honestly, if you want to understand what makes Forth programmers so find of their language you only need to focus on a few words in the core dictionary: Code Execute Word or parse Find Begin Again If Else Then Ahead Create Does&gt; Most likely, once you grok those (and I mean really understand what's going on), you grok Forth. ;)
Valid in Germany, Iceland, Denmark and Norway too. It eliminates the 'oh, it is suddenly green' notice delay when it has been so for a 'while' that many peeps suffer from. It also makes it unambigious where the light is in its cycle.
Now you know why this step gets "omitted so much".
eForth explains why they are classified CORE words. The inner interpreter The outer interpreter Interger math and binary math
I think it would be possible to convert the binary from AArch64 to GnuEabihf somehow.
Really? Have you any ideas how to do that?
Amazing how this pretend computer inside a game was leveraged to develop a FORTH. Reminds me if the computer inside Minecraft a few years ago. It was fascinating. Mojang abandoned that project.
I wonder how Green Arrays stays in business. Interesting chip, but very little adoption as best I can tell.
well, subjective experiences with AOT compilation lead to the conclusion that binary recompilation with code injection should be possible and straight forward to be implemented in view of the similarities shared though the same base ISA.
The built-in dictionary of GForth is a joke. There is a few core words in most Forth systems, less than 50, that can be used to define all Forth words. I learned Forth from Fig-Forth that wasn't optimal but very easy to understand from scratch. Today Forth is more efficient but less obvious to understand.
"...that moderately intelligent people might find it daunting to get started." I remember being in this position many years ago and you are correct. Learning Forth is more like learning a new human language. There are a large number of small words that have a big impact on the meaning of a statement. I would suggest studying some of the simple examples in Rosetta Code, although many of those have few comments. However at least you will know that they accomplish and you may even be able to load them on gForth. (can't promise that) &amp;#x200B; One approach that I took was to re-write something simple that I had written in another language, like a simple game. This does not get you acquainted with good form for Forth programs but I gets you started handling some of the warts in the language. And just to state it: Forth is harder than many other languages. It is low level, approaching the level of assembler but with a bunch of clever support routines. It takes time to learn the meaning of all the little routines much like it takes time to understand a big object library. So persevere and you will become productive.
If you have an example in assembler, re-writing it in Forth Assembler might let you experiment with it interactively which is quite fun. Typically this process lets one tease out parts of the code into Forth CODE words that take parameters from the stack and can be called separately. (where that makes sense) Note: the unstructured nature of Assembler code can make for some time consuming work to convert to structured Forth Assembler. (or you can add un-structured branching to the Forth assembler) Translating existing code will probably be the fastest way out the door in this case, based on Gousey's comment.
Just for grins I typed the command WORDS in Gforth. It displayed a long list in unusable format. Not a biggie
My main motivation is pure curiosity. Thanks to a LOT of help in this group I am reading more than one useful document and forming a plan. At some point I may do a post where I communicate what I think can work. There is an elegant minimalism in the Forth approach. I am starting to understand how it would be bootstrapped in a new unsupported computer. Next step is to make myself understand the minimum needed to start. I am not likely to ever build my own Forth but will understand the process. What are fewest routines one writes in say assembler (or some other language) which can then be used to build the test if the system obviously using a threaded code approach. In some ways my time might be better spent digging into Lisp. Later.
"What are fewest routines one writes in say assembler (or some other language) which can then be used to build the test if the system " This has been an age old discussion in the Forth arena but a safe answer (maybe) is to use Dr. Ting's E-Forth as an example of a minimalist system. I believe it has about 30 primitives written in Assembler. Another example is to look a Forth CPUs. They typically have about 30..35 or so instructions.
Does the server ever decrypt the blob? It doesn't seem like that's necessary; not sure based on your description.
The server doesn't decrypt the synchronized blob; that's just an opaque blob to it.
Would it be Charles Childers? [http://www.forthworks.com/](http://www.forthworks.com/) &amp;#x200B; If so, he's here: &amp;#x200B; [https://twitter.com/crcx](https://twitter.com/crcx) &amp;#x200B; By the way, he seems to be alive and working -- there was a release of Retro Forth in 2019.06: [http://www.retroforth.org/](http://www.retroforth.org/)
Greetings, I liked your talk, and watched when it was posted online. &amp;#x200B; Btw, new to forth, which brought me to this subreddit to learn more.
crc is at a lot of places. #Retro and #Forth on Freenode are two places he'll often be.
That would be me, what is the link?
Thanks! I'm trying to get things polished up and fill out the functionality in the system. Along with that, I'm hoping to do a blog post or video on youtube once a week. So if there's any Forth-related stuff you'd like content about, let me know.
I don't have anything specific that I can think of right now. I'm still in the learning phase of this venture.
Today this worked. But recently it returned an error, or so I claim😎 http://forth.works/book.html Not sure how that web site relates to retroforth.org I didn't realize that we also have a subreddit r/retro. I have followed you in Twitter. Your blog is evidently on hiatus. It happens. Thanks for your great work.
I’ll make sure the link remains fixed for future updates. /r/retro is unrelated to my forth... I have three servers. * retroforth.org is the oldest, there’s a lot of stuff on it not linked from the main page. It serves as a nice looking information page. * forthworks.com is my main server, accessible via gopher and http. * forth.works is my development server. It’s used for a bunch of things that I haven’t deployed on the main server yet. The blog (and much of my social presence) has been on break due to ongoing RSI problems. I spend most of my typing time working on projects. Hopefully I’ll be able to resume this in the future.
I chose the Fossil logo because I use Fossil for everything including my Doc site and Matthias Koch the creator of Mecrisp Forth also likes fossils. You raise a good point however, so I've changed it to a grasshopper and will see how that fits.
You can also get the STM32F401-RA and STM32F401CD-RA binaries from the official release tarball here: https://sourceforge.net/projects/mecrisp/files/mecrisp-stellaris-2.5.0.tar.gz
Thanks. Mecrisp-Stellaris Forth is quite wonderful. I am uncertain I have the most recent release. I just received the Nuceo-64 two days ago and did a first loaf to verify feasibility. I actually loaded from Debian Jessie Linux very easily. The Mecrisp-Stellaris Forth consumes a very small portion of Ram and Flash, leaving most available for projects. .
Got it! These seem to be the latest images. Have downloaded.
One of the problems I had when learning Forth was trying to use examples from one Forth in another Forth because they usually won't work. As they say "when you've learnt one Forth then ... you've learnt one Forth". My recommendation is if you can't find helpful examples online for Gforth is to switch to another Forth that does have examples that appeal to you. I find the Forths with the best examples are for embedded MCU's, be it Amforth, Flashforth, Mecrisp etc If you're into PC's then LISP may better suit as you mention in a later post.
Version 2.5.0 successfully loaded an running.
Version 2.5.0 is the latest release but doesn't have any bug fixes however 2.4.9 has one. Picocom works very well, easier than Minicom I think. I have some details at my sourceforge doc site:- [https://mecrisp-stellaris-folkdoc.sourceforge.io/serial-terminals.html?highlight=picocom#picocom](https://mecrisp-stellaris-folkdoc.sourceforge.io/serial-terminals.html?highlight=picocom#picocom) The Nucleos are handy, you may not even need to use OpenOCD, just drop the binary into the bulk usb storage directory that the Nucleo creates and wait a minute or so and it should flash by itself.
Perhaps you could help me with one question. I'm using the stm32f401-ra.bin as the stm32f401.bin failed proper operation after loading. I've no idea if this is the optimal binary and I see the stm32f410cd-ra.bin mentioned as well. Can you explain the alternatives?
Apparently, I'm running the best version for what I have. I received a reply in the Mescrisp SourceForge Discussions. The "...CD-RA" is intended for a device with less i/o.
Thanks for the messages so far. If this comment is here, we're still looking! Feel free to DM. Thanks!
You could announce it at the Silicon Valley Forth Interest group on Stanford campus this month. There are experienced (since 1970s), black-belt Forthers in that group that write clean, aesthetically-pleasing forth code: CH Ting, Sam Falvo, James Bowman, Brad Nelson just to name a few. &amp;#x200B; [https://www.meetup.com/SV-FIG/](https://www.meetup.com/SV-FIG/) &amp;#x200B; EDIT: If you're not anywhere nearby, I could pass on your message.
The Forth version for your chip would only differ in regard to memory (flash and ram) and you can change these yourself then recompile the kernel easily: https://mecrisp-stellaris-folkdoc.sourceforge.io/porting.html?highlight=build#changing-kernel-flash-and-ram-values &amp;#x200B; I always use the RA kernel, this page lists the differences between RA and Classic. [https://mecrisp-stellaris-folkdoc.sourceforge.io/ra-kernel.html?highlight=build](https://mecrisp-stellaris-folkdoc.sourceforge.io/ra-kernel.html?highlight=build) &amp;#x200B; Basically the version to suit your chip is only unique regarding the UART (so it can talk to the terminal) and possibly FLASH writing and INTERRUPT setup otherwise its either Cortex-M0 or above. No peripherals are defined in the actual Kernel and you need to do that in your user source. I've made a CMSIS-SVD parser that works for all MCU's with a SVD file to generate all the memory mapped Words and bitfields. See the link below for more information. [https://mecrisp-stellaris-folkdoc.sourceforge.io/register-generator.html#svd2forth](https://mecrisp-stellaris-folkdoc.sourceforge.io/register-generator.html#svd2forth) &amp;#x200B; For faster Mecrisp answers it's best to use the Mecrisp Sourceforge Discussion list as I only check here erratically. https://sourceforge.net/p/mecrisp/discussion/general/
Thanks. Makes it easier to move forward.
Just getting started. How about using one of the so-called "Blue Pill' STM boards that cost $2-3 from China? I can spend more if it makes sense or would be easier while I stumble through early Forth and associated MCU learning curve.
The "Blue Pill" is an STM32f103 that has a poor reputation for quality. Lots of complaints about defective boards. Buy one if you like to gamble. The Nucleo-64 board seems like a better option for me. There are Nucleo-32 boards. Both come with a variety of processors, including the STM32f103. Mecrisp-Stellaris Forth is available for the stm32f103. I wanted more speed, more RAM, more Flash, and advanced options.
Dr. Chen's "Understanding eForth"does an excellent job of presenting all the features that a minimum Forth requires. Primarily the author keeps the discussion short and focused on understanding the inner interpreter, the outer interpreter, and the serial communications link. Are you referring to WORD or WORDS? There is a big difference in purpose and response. WORD simply locates the address of a given word inside the dictionary. And puts its address on the stack. Look at how it is constructed in Forth or Assembly for your particular version. TIB is an Ascii input buffer entry that is parsed for immediate response to terminal entry of Forth words. PAD is a temporary storage area for processing strings.
Thanks. I'll take a look. I'm referring to "WORD". I just had a look at Jonesforth, and I see that WORD has a 32-byte buffer where it builds up the word, thereby eliminating the problem. I've tended to shy away from anything with assembler code. I'm actually wondering if it's possible/sensible to build a kind of "assembler translator" in m4, that translates a kind of "idealised assembly language" into a target assembly language. It could possibly use x86 assembly as a basis for the idealised language. I'm beginning to wonder if a TIB actually serves a useful purpose. After all, if WORD is built around the notion of an input stream, then it seems reasonable to suppose that terminal input needs no more special handling than a FILE*. The more I think about an implementation, the more I realise its potential flaws. No-one seems to implement their Forth's in some kind of "canonical way". I'll take a look at eForth. As it happens, in in the market for a Forth that works on mcus.
Well, I had looked up PAD in Forth Programmer's Handbook by Conklin and Rather at Forth, Inc. and they mentioned their definition above as the input buffer. Then I looked in eForth Overview and found it not mentioned at all. Just TIB and it can grow variably large. And I checked Brodie's Starting Forth where he claims it's an output buffer, but he exploits it as unused RAM in a way I find odd. These days, an output buffer isn't much needed. There's quite if bit of discussion that may be obsolete. If I needed a ram space for a scrach pad, I'd just allocate a space that would be dedicated to such. Three experts, three answers! I strongly suggest reading original open source code for a working Forth over focus on F79 or F83 standards. I know nothing about JonesForth. I prefer FlashForth, eForth328p, and Mescrip-Stellaris Forth.
The STM32F103 is a old ARM Cortex-M3 chip, first announced 11 Jun 2007 and the third ARM family by STMicroelectronics. Whilst this chip is still highly advanced and feature packed compared to all the ancient ATMEL MEGA stuff, later STM MCU’s have more modern peripherals. Warning: If you’re coming from a Arduino Atmel Mega series the STM32F103 will probably look like advanced alien tech from the future, but don’t be fooled, this is a old chip now. STM32F103 Limitations CAN Bus: Shares memory with the USB hardware, which means that USB and CAN cannot be enabled at the same time Serial Comms: No Autobaud The Blue Pill boards all use recycled STM32F103C8T6’s (in my opinion) and I’ve read about Blue Pills coming out with GigaDevices Cortex M3 “GD32F130xx” (64KB Flash MAX), STM32F103 clones which I think would also be recycled e-waste as that chip came out in 2014. Certainly one can still buy STM32F103C8T6’s brand new from reputable resellers such as AVENET, but they’re more expensive than the later and more capable STM models because the STM32F103C8T6’s are a old chip and I guess STM are just keeping the production line going for spare parts. My personal opinion is that the STM32F103C8T6 is not such a great choice for new projects. &amp;#x200B; Get a STM32F303 Nucleo for a more modern and capable Cortex-M3 Or if you're after low power, a STM32L073 Nucleo
In 1974 we paid $270 AUD just for a single National PACE 16 bit CPU, so I have trouble thinking a chip that costs $20 is anything other than cheap :) The problem with the Blue Pill is that you may waste hours/days of your time trying to get a new but faulty one from China working and that's no bargain ? If you buy something like a STM32F303 Nucleo you'll get a brand new and working unit straight from the STM factory in Cortex-M3. Or for low power, something like a STM32L073 Nucleo in Cortex-M0+ &amp;#x200B; Check [https://mecrisp-stellaris-folkdoc.sourceforge.io/supported-hardware.html?highlight=supported#supported-hardware](https://mecrisp-stellaris-folkdoc.sourceforge.io/supported-hardware.html?highlight=supported#supported-hardware) before purchasing a unit if you want Mecrisp-Stellaris to work 'out of the box'.
I am going to work backwards from WORD and then drill down a little. Here is a Forth definition of WORD in my Camel Forth implementation. : WORD ( char -- c-addr) PARSE-WORD HERE PLACE \ get some input, place it a HERE HERE BL OVER COUNT + C! ; \ append a space onto the string
CANbus needs a network of CANbus devices. Not sure users understand the added complexity.
My own opinion is to use Forth to learn Assembler code. It happens to be an excellent entry point. A lot of people use Forth compiled from C, but the true elegance of Forth is how it can be much faster than C. If Forth isn't fast enough, bottlenecks can be removed with Assembler. Fourth will debug speed issues easily. I'm not sure what you want to do is worth the effort. Allot can be done in software that avoids learning the lower levels and actual architecture. But that's just programming black boxes. I always want to eliminate the black boxes so I can appreciate the real engineering.
WORD searches the dictionary, which is an important task in Forth. But dictionary construction and the actual search method may vary in different deployments of Forth. Historically, some versions of Forth only matched the word length and first 3 characters as storage for the dictionary was tight. This also made searches faster than matching a long name on a chracter-by-character match. That's why I recommended reading the actual code versus a discussion of Forth standards. eForth may not be the best performance, but Dr. Ting presents a minimum of Assembly code to create a Forth kernel. He shows that about 30 primitive words defined in Assembly code are all that are necessary to create the rest of Forth in Forth. So I found it helpful. It may help some users get started with understanding the source code. Camel Forth is an early Forth intended for tight resources.
I have to agree. A friend bought five Blue Pills and not one worked, that's 5\*$3 or $15 and for that she could have bought a brand new STM32L072 Nucleo that's fast, low power, a much later Core and has the latest peripherals on chip. I can understand people hesitating over buying a new Intel I7 cpu for $800, but saving $12 (compared to the latest brand new Nucleo board) to buy some Chinese junk with a ancient STM32F103 MCU that was probably pulled from scrapped gear by a guy with a blowtorch in India ? It's no bargain, it's a waste of life and time in my view.
If only there was a source for a plug and play STM device loaded with a recent Mecrisp-Stellaris Forth and ready to use when connected over USB to a laptop or PC with the terminal emulator sorted out. More broadly, any combo of a reasonably priced Dev board plus the bits to follow a checklist and be playing with Forth within the first hour or so There are several candidate Forths including Eforth and Retro and Mecrisp. Sorry to mumble... LOL
Umm... WORD does not search the dictionary. It is a parsing routine. WORD is not popular with Forth 2012 proponents who prefer PARSE-NAME. This is why I factored out PARSE-WORD from the Camel Forth WORD definition so I could get at the c-addr and len in the TIB without copying it to HERE. &amp;#x200B; For clarity CAMEL Forth was an early "ANS 94 Standard Forth" for tight resources. EForth made no attempt to be Standard Forth. (ex: no DO LOOP only FOR NEXT) &amp;#x200B; From [http://forth-standard.org/standard/core/WORD](http://forth-standard.org/standard/core/WORD) WORD ( *char "&lt;chars&gt;ccc&lt;char&gt;"* \-- *c-addr* ) Skip leading delimiters. Parse characters *ccc* delimited by *char*. An ambiguous condition exists if the length of the parsed string is greater than the implementation-defined length of a counted string. *c-addr* is the address of a transient region containing the parsed word as a counted string. If the parse area was empty or contained no characters other than the delimiter, the resulting string has a zero length. A program may replace characters within the string.
Thanks. Reading the discussions of PAD and I see it is never an input buffer. I miss read. Conklin and Rather agree with Brodie is explanation. So it's not an obsolete feature. PAD is a CORE EXT item, so eForth doesn't cover it. I am aware of the lack of DO LOOP in eForth.
I struggle with the same. It's a common issue with open source. Lots of choices. I used eForth to gain a good idea of what's bare minimum Forth, but it lacks a lot of definitions I want when doing a real project. Recently started Mecrisp-Stellaris Forth because the ARM STM32 devices are really phenomenal in speed, RAM,and Flash. It will take time to grow into them. But for AVmega devices, I'm inclined to use FlashForth. That's a lot of jumping around to familiarize oneself with. Mecrisp-Stellaris Forth has ready-to-load binaries available at SourceForge and installation is relatively easy. But some source code is only in German. Everything is a work in progress. So it's up to you to choose what works for you. If the STM32 devices are too difficult, the AVmega are there to learn with less. I repeat, the eForth is more of a study model to help one comprehend Forth.
In traditional simple systems PAD is used by the programmer the way that the compiler uses HERE. It is a temporary buffer that might not be there the next time you use it. Both are in un-allocated dictionary space. &amp;#x200B; Typically HERE is defined: `: HERE ( -- addr) DP @ ;` And PAD is just some arbitrary offset above HERE so like this: `: PAD ( -- addr) HERE 80 + ;` Since simple Forths don't have dynamic memory, using the memory above the dictionary lets you have very "cheap" memory for short term use that does not require committing the memory to the final system image like a static buffer would do. (This was a common trick used by Assembly Language coders as well) &amp;#x200B; So to clarify how Forth handles text interpreting: 1. TIB is a static buffer somewhere. Sometimes at the upper end of memory 2. QUIT (the name of the text interpreter) uses ACCEPT to read keystrokes into TIB and it counts the chars input. (ACCEPT uses KEY in a loop) 3. The SOURCE word returns the TIB address and the length ( -- addr len) which is passed to INTERPRET 4. INTERPRET uses WORD to chop up the input string into individual tokens (words or numbers delimited by space) 5. INTERPRET passes each token to FIND to look them up in the dictionary. 6. INTERPRET will examine the STATE variable and compile if state = true or execute the word (interpret it) if state=false. If the word cannot be found it tries to convert it to a number and again does the right thing depending on STATE. 7. If all that fails INTERPRET runs ABORT with a "not recognized" error or some equivalent. Hope that helps lift a cloud here and there.
I've thought about making something but which STM32 device, Cortex-M0,3 or 4, which OS, Linux/bsd, OSX, windows ? My development system and IDE are awesome \*to me\*, but other people will want their own system, Forth users are a diverse lot with diverse needs. I think a Forth orientated board is a good idea as frankly the Discovery and Nucleos are made for C/Arduino and not really all that well suited for Forth.
Thanks. Your discussion helps. I've been trying to reverse engineer flowcharts on the inner interpreter, the text interpreter (aka outer interpreter), and haven't gotten as far as I hoped. Temporary use of available RAM space had never occurred to me.
Regarding OS, I'm using Debian 64 Linux, but Windows or OSX likely can provide a serial terminal application and text editor. Picocom seems prefer by the authors. But I use a different one. I do have a 64bit Windows 10 system to use if needed. But the beauty of Forth is that it's mostly depending on an ANSI terminal, not a cross-platform IDE and cross-compiler. I done loaded a binary from SourceForge. I used OpenOCD to load it, but there are alternative methods. I simply followed a tutorial that used OpenOCD and haven't investigated other possibilities. Using STM32 devices in C/C++ is an entirely different solution and KEIL would like you to license there $1600USD compiler at minimum for STM32 support.
Forth is simple but different so getting ones head around it takes a bit of study. Sounds like you are on it. Ya in high level languages we think of memory as this thing defined by our language of choice when in fact it's just a bunch a addressable pigeon holes. :-) &amp;#x200B; Not sure if this is helpful but here is the Camel Forth Interpreter compiler written in cross-compiled Forth &amp;#x200B; `TARGET-COMPILING: &lt;INTERPRET&gt; ( i*x c-addr u -- j*x ) 'SOURCE 2! &gt;IN OFF BEGIN BL WORD DUP C@ ( -- addr len) WHILE FIND ?DUP IF ( it's a word) 1+ STATE @ 0= OR IF EXECUTE ELSE COMPILE, THEN ELSE ( it's a number) ?NUMBER IF t[COMPILE] LITERAL ELSE TRUE SWAP COUNT ?ABORT THEN THEN ?STACK REPEAT DROP ;`
I downloaded a GA143 emulator in the last year and on and one of the Forths on it, either arrayForth or maybe another one (polyForth I presume) , I was happily surprised it was basically colorForth. To me it was, basically, colorForth. (And the emulator runs on PC, making it easy for a noob like me to tinker with. (I too share your admiration with colorForth))
Try www.99-bottles-of-beer.com for interesting Forth code.
The Alternative Functions section got my attention. Having muddled with these on smaller devices, this section is extremely useful.
slides: [http://www.complang.tuwien.ac.at/anton/euroforth/ef13/papers/hoffmann.pdf](http://www.complang.tuwien.ac.at/anton/euroforth/ef13/papers/hoffmann.pdf) &amp;#x200B; alternative that allows mixing python with forth: [https://github.com/hcchengithub/peforth](https://github.com/hcchengithub/peforth)
What changes did you have to make for Win10 to work?
I had to add stack-check code using "-fstack-protector-all", which sucks because it slows things down and I don't have any stack-smashing going on. I also had to lower optimizations from -O2 to -O1. Very disappointing.
Is this related to control flow guard?
I didn't investigate further to figure out exactly which of MS's hundreds of changes from the prior version caused this. I'm assuming it's due to their security mods.
it does look likely, though.
What serial terminal do you use with Forth ? My system uses GNUScreen and runs at 460800 baud with hardware handshaking. I have looked at all the common free C development systems For STM32 offered by STM (out of pure curiosity as I'm a dedicated Forth user), but they all seem huge slow, buggy, incredibly complex and no fun. I think the reason C is so popular is because the big compiler makers can ship it in a pretty shrink wrapped box for $1600 USD. I'm fairly sure they have no idea what Forth really is because every time they try and commercialise it, Forth morphs into something else ;-)
Well, a baud rate of 460800 is somewhat excessive. And typically Forth doesn't use RS232 handshaking. But both may be supported in required. I usually use Minicom or PuTTY, but Picocom is recommended by Mecrisp-Stellaris at 115200 baud. Forth, Inc. Has successful commercialized Forth since the 1960s. I believe Fedex is one of their successes. The popularity of C is primarily a cultural phenomenon created by academic culture providing it to everyone that sought a degree in computer programming. Elizabeth Rather of Forth, Inc. has made some very insightful comments about C versus Forth. And having been part of the whole era, she should know. My interest in Forth is that it is much closer to the architecture of what you ate using. Allows a more focused solution with better performance. But I suppose you argue that down. If you don't understand the utility of Forth, continue with what you use. I really don't care.
That would be arrayForth. PolyForth is a traditional Forth offering.
eForth is already a thing, it's the name of an old, old way of implementing a very simple, concise Forth designed by Dr C. H. Ting, which he has books on and implementations for multiple platforms. A cursory Google search reveals this. Perhaps a rename to elispForth is in order? Anyhow, I'd like to try this out but I'm not really an esliper, so without any example code I don't quite get it. Also your github link on the page is broken, it links to "githu.com".
There is an example program in the [docs](https://spensertruex.com/eforth), it opens a frame with eight panels in it. &amp;#x200B; Writing \`8pan\` in elisp took 37 lines of imperative garbage, so using the macro I was able to rebind the names and have it be three lines.
Nice! It's tricky to implement Forth in C, particularly the DOES&gt;. What license are you releasing this under? I might want to fork it and take a stab at cleaning it up.
Public Domain. I'll annotate the file accordingly. It's the way all Forth implementations seem to work. "DOES&gt;" is a tricky one. Many chickens were sacrificed in getting it to work! There seems to be a few ways of implementing "DOES&gt;". One is using "&lt;BUILDS ... DOES&gt;", which is the way I did it. That way of implementing it is very old, I think, and isn't even in the Forth-79 standard. John Walker's Atlast Forth (I like that Forth, it's compact) basically shifts some of the code to before the definition. Something like that. What seems more popular is a kind of anonymous function. A VM would be a good idea, I think. It would allow for things like recursion, and more importantly, a notion of where the Instruction Pointer is. The whole problem centres around DOCOL. It needs some kind of "context" as to where it is in the heap. So when you create a word, you store pointers to dictionary headers rather than pointers to functions. I tried to store just pointers to functions, but couldn't figure out how to make it work. Doing it my way requires an extra layer of indirection, but in the end I was undecided as to whether this would really slow things down. I was also thinking of storing the name of the word immediately before the dictionary header. This would have the advantage in that the header structure is more compatible with C structs. It would also mean that code pointers start at a fixed offset from the header. This should create a small speed improvement. Another implementation detail of mine is that I've with 0-terminated strings rather than other mechanisms like packed strings or strings which need both a location and a length. Using 0-termination turned out to be a good idea, as that's the way that C expects strings to be implemented. A lot of hassle is saved by doing it the C way, at least for an implementation that's written in C. Hope that helps a little.
What OS does your Forth assume it's running on?
It assumes 64-bit Intel. I've added a bit of code here: #if(__x86_64 ==1) typedef int64_t cell_t; #endif The __x86_64 is a gnu'ism. cell_t is, basically, the size of an address. Perhaps a test of sizeof(void*) would have been a better idea. That way it could be conditionally compiled for 32-bit systems, where I would expect everything then would Just Work. I can't see there being any problems running it under ARM, or anything like that. I don't imagine endianness would be an issue.
I am semi literate not a CS guy however. Do you run it here metal or can it be launched from say windows 10? It's probably not for me but I am curious. I agree that in future creating a light virtual machine is a great approachm I think Retro Forth does that?
Agree that the name eForth is something that exists and has quite a large community around it. Hope you change name of your clever hack right away.😎
I think you mean "bare metal" rather than "here metal". It runs under an OS. You just need a C compiler to compile it. You interact with it via the command line. So it should work from Windows 10, provided you have a C compiler. I actually created a Forth a couple of years ago that runs bare metal. It can also be compiled for command line usage. It was written in FreePascal, and was designed to be compiled for the Ultibo https://ultibo.org/wiki/Main_Page unikernel, which targets Raspberry Pi's and also works under QEMU. Kinda cool, actually. It could interact with the framebuffer, GPIO pins, and suchlike. It could, potentially, support anything that Ultibo supported. It just needed to hook into Ultibo's libraries. I kinda lost interest in it, though. The barebones Forth could potentially be compiled for MCUs (microcontrollers). Arduinos are the obvious choice. The Arduino IDE is very easy to use. You'd create hooks for the serial port, and you can program your microcontroller over the serial port. Actually, I'm adapting John Walker's atlast Forth for this purpose. Pretty cool. I've got DACs and GPIO pins working for the ESP32, and I'm working on the filesystem. I've found the Forth to be much faster than MicroPython. MicroPython is a mature project with a huge following. It certainly outshines my humble efforts. However, hooking stuff up in the Forth is very straighforward. I just write a shim function for the Arduino IDE. I haven't looked at the code for MicroPython, but I imagine its internals to be more intimidating. There are many excellent Forths out there, too many to evaluate. I had a quick look at libforth and pforth, and their code looks of high quality. Forth is a language that I only tinker with rarely. I look at it and think "that's amazing", but inevitably end up programming in C++, which basically gives me the results I need. I'm liking Forth for experimenting with microcontrollers, though. The whole "edit/compile/upload" cycle is too much of a chore, especially for the bigger mcus. Hope that helps.
Thanks. After I get some familiarity with Forth it would be a nice way to program an ESP8360.
Indirect-threaded is easiest to implement, although not quite the easiest to understand, in my opinion. And null-terminated strings are easy to use, but they can be a problem if you use the same tools when dealing with strings of arbitrary data, rather than human-readable text.
Thanks for sharing and keeping this fascinating gem of a language evolving. Forth was always intended to be barebones after all, according to guru Chuck. The quintessential programming language. I'm still relatively new to Forth, but it is the first time I've ever felt at all passionate about a programming language - perhaps because it coincides with an interest in philosophy. Will take a look.
On it boss! Go Forthe and ye shall find.
Clever solution.😎
😎
Yes it does, thank you. What do you mean by a VM? My last Forth interpreter in C started with a function pointer in the execution field of a word (which for colon words is DOCOL, and for DOES&gt; is DODOES), and pointers to those execution fields in the dictionary definitions of DOCOL words. The interpreter has its NEXT in the main interpreter loop which gets the next funcptr at *IP, setting a global/thread-local WP to the address of the parameter field, immediately following the execution field at *IP+sizeof(void*), increments IP, and then calls the function in the execution field directly. DOCOL then knows to RPUSH IP and set IP to WP. This worked, but it eventually evolved to a token-threaded forth to conserve dictionary space. Is that what you mean by VM?
What I meant by VM is a kind of abstract assembly machine with instructions like ADD, SUB, MUL, DIV, JUMP, CALL. The machine keeps track of the IP and shifts if up and down accordingly. What do I hope to gain, you might ask? The answer is ... the IP isn't actually used that much. In fact, it's only used within DOCOL. So it could be a local variable. The only thing required by DOCOL is the "WP". I reckon even that could be eliminated as a global. What would happen is that a word would have a flag signifying that it needs WP on the stack. EXECUTE would push the WP onto the stack if it sees that flag. The word then pulls WP off the stack. Almost no word will need that mechanism. DOCOL would, though. If DOCOL points at another user-defined word, it basically does recursion. Not that's there's anything particularly wrong, but it does mean you can't jump outside the word. Also, I haven't implemented an abort, which is effectively a jump. If I were to implement it, I'd use setjmp and longjmp. What implementing a VM gives me is the ability to jump, so you could jump out of a word, and maybe implement something like co-routines and jumping into the middle of word definitions. This would be useful for something like microcontrollers, which can have complicated state, where what you want to do is hop out of a word and into a different state. Although I find colorforth completely baffling, I think Chuck Moore has that kind of capability with his red words. I don't think there's anything fundamentally broken with my design, necessarily, I'm just thinking that a VM might be the way to go in future. My Forth also makes little use of the return stack. It's only DOCOL that uses it, and then only really because branching operations might want to adjust the IP. In fact, I haven't defined any words which give the user access to the return stack (there be dragons!). Instead, there's a "T" stack, or temporary stack. I envisioned it as a kind of shunting yard. In fact, because that stack is separate from the return stack, I reckon it ought to be possible to implement things like infix notation, maybe even with operator precedence. I imagine that it would be much slower than stragithforward reverse polish operators though, as the infix operators would have to shift and reduce stuff from the temporary stack. I'm just spitballing ideas here, of course.
Build vertically. Also this post would be more on-topic here: https://www.reddit.com/r/comparch/ Forth can run on it if it's turing complete, but it has to run first.
In general, Forth has historically needed 16Kbytes for dictionary space and about 2kb of RAM for stacks, buffers, etc That's on a 8 bit CPU. Building smaller is possible, but quick removes the useful features that make Forth a programming tool. I'm not too familiar with Minecraft, but I thought it requires an OS with GUI interface. A small OS image of Linux with GUI might require 512K of Ram.
16K on an 8 bitter would include the editor, block file I/O and the assembler. For this application you could make a workable kernel that allows text to be pasted into it. That could be 1/2 that size. (New Micros MaxForth comes to mind) I concur that building a simple CPU might be more practical and a Forth CPU is one of the smallest.
The strict definition of turing complete as defined by alan turing who discovered it is that a turing complete machine has infinite ram or storage. The computers we use today such as the ones we currently use to run forth are actually "pseudo-turing complete" but we call them turing complete for short. It's an oxymoron similar to, "it's cold as hell." It matters how much ram/storage a forth system has.
There's no way I will get anywhere near 1k. I was thinking about omitting my plus operator and having the only word available to me in the forth be a nor gate word and a word that strings nor gates together.
I've no idea what to do in Minecraft. Back in 1969 when I studied Fortran, the university insisted no gaming on the IBM360.
It's computationally the same, just very constrained.
My point is that Forth can run on any computational device that supports non-linear execution. Also my other point is that your post is off-topic.
The old Red Power mod had a FORTH computer which could be used within the game; I programmed a mining drill with it and Lua via ComputerCraft, half a decade or so ago. It is also true that, at least if you want straightforward layouts, redstone circuitry is prohibitively large. A basic inverter requires four blocks in length.
Is the question "how to do a forth in 256 bytes" off topic to /r/forth?
Then edit your post to "how to do a forth in 256 bytes". How do you know it can't?
Demonstrate me a forth that runs on a computer 1 with 1 bit of storage and 0 bits of memory Protip: you can't do it.
*"My own opinion is to use Forth to learn Assembler code. It happens to be an excellent entry point."* One of the little secrets that is not communicated much outside of the Forth community is how simple Assembly Language is to play (and learn) with Forth. You need a Forth system with an Assembler that can be loaded or is resident. (or you can write your own... really) But it is very hard for Assembly coders to imagine that it is possible to do interactive Assembly Language coding but Forth lets you do it. So for example in an old x86 Forth system that I use you can type: CODE 2* BX BX ADD, NEXT, END-CODE ( BX is top of stack cache register) Then type: 2 2* . 4 ok You just wrote a one instruction assembly language program, assembled it directly to memory and tested it. Be prepared to crash the system if you do anything complicated. :-) Also notice the syntax is Yoda style. :-) &amp;#x200B; Also the Forth colon compiler lets you build macros that can even take parameters from the source code. Example from 9900 Camel Forth below was created because the old 9900 CPU does not have a hardware stack. So I made some "pseudo-instructions". Notice the Forth stack can pass the src and dst arguments to the macro, after all they are just numbers. \ PUSH &amp; POP for DATA stack and Return Stack : PUSH, ( src -- ) SP DECT, ( src) *SP MOV, ; : POP, ( dst -- ) *SP+ ( dst) SWAP MOV, ; : RPUSH, ( src -- ) RP DECT, ( src) *RP MOV, ; : RPOP, ( dst -- ) *RP+ ( dst) SWAP MOV, ; And since I have complete source code for the Assembler I renamed the registers that I use for stack pointers. Complete control. :-)
FYI, migrated to FlashForth as easy to deploy.
Very fascinating. I've never really been into infosec before, but adding Forth to the equation really makes things interesting. How mature is this project? Do you use it for real work, as described in your talk? It looks fairly usable.
It requires a minimum of memory to actually have an appropriate and useful dictionary. That's reality. One can theoretically create a Forth CPU with much less, but that isn't going to be something useful. The whole desire to create Forth in Minecraft isn't going to do much other than create bragging rights.
Dictionary space needs to be large. Explain how to use Forth without a dictionary
ASCII requires a minimum of 7 bits for proper representation. So, how can 1 bit possibly represent an alphabet or a range of numbers beyond 1 or 2.
A dictionary can be built into the executing device, rendering the size of the attached memory irrelevant. Although the usefulness of such a setup is questionable, usefulness was also not an explicitly stated requirement.
I suspect bragging rights is the sole purpose of the post.
It is mature enough for me to use it, that's for sure. But then, I made it and know all the nooks and crannies. I have received a couple reports from people who've tried it out, and the response has been positive. Beyond that... well, most people in my industry are pretty skittish about programming languages, so I have no doe-eyed expectations of seeing it take over the pen-testing world by storm or anything. I do use it every day for something practical, which keeps me polishing it and rounding off the corners. It's as mature, or better, than a lot of tools I've used on assessments, so it's definitely part of my "production" toolbox. I've also found that Forth is the fastest way for me to experiment with the Win32 API and sketch things out. It's also the best way to play with assembly, since I can just throw some machine code in a definition and run it.
Fappy Horth!
What happened? I'm out of the loop.
Not really. My point is that there is a fully functional scheme for Forth. Creating something less than that is an academic pursuit, and quite well explored. Admittedly, I would rather see useful applications than something less.
And explain how that dictionary is going to be appended to Minecraft. One might as well shift to a hobby of building Ferris wheels out of matchsticks.
4th of July.
Well, it's good to know that at least you and others are using it in a significant capacity. Yeah, I imagine Forth is a little too out-there for most people in that realm of work, but that's really too bad because it has so much potential. The machine code access and Win32 API stuff you showed off in the video were very impressive. The floor is definitely very low, perfect for this sort of thing. The ceiling can also be quite high; Forth is not necessarily a low-level language as much as it is an extremely simple and basic language which can be built upon to the developer's contentment. I saw that's something you're working on. Forth is such an underappreciated language (IMO) and I can see so much influence and similarity to Lisp, in concept. I guess that's not super surprising since [Chuck Moore was taught by John McCarthy.](https://colorforth.github.io/bio.html)
I totally agree. I'm a long-time fan of Lisp, and when I'm writing immediate words it feels as powerful (or more) than non-hygienic macros. I hope to be a force for positive change, at least in my specific community, because language luddism isn't helping anybody.
Yes, you are exactly right. This power that you mention is so important in programming languages and facilitates much flexibility, such as what is in your project. I think a real key which allows a language to be so malleable and powerful is the concept of [data-structured languages.](https://web.archive.org/web/20170110000825/https://en.wikipedia.org/wiki/Data-structured_language) I think this would be so powerful for making visualized programming a viable paradigm. It's really the essence behind the works and teachings of geniuses like Chuck Moore, John McCarthy, Kenneth Iverson, Alan Kay, Yukihiro Matsumoto, and others. Programming languages which feature this kind of universal plasticity really ought to have been the norm from the beginning. I can see the practical advantages to more structured and disparate languages such as C, but really I think these should have been more of special-case languages rather than the widespread norm everywhere and the *de facto* measuring stick for other programming languages. Anyway, rant over, but it's very nice to see a kindred spirit in this regard :) If you can be a force for positive change, more power to you! :D
It worked for me, but I'm on: Gforth 0.7.9_20190103, Copyright (C) 1995-2017,2018 Free Software Foundation, Inc. Gforth has a lot of development but hasn't had a release in a long time. You might want to try `aur/gforth-git`
abandon hope, all ye who enter here ...
I'll try that thanks.
Wasn't Chuck Moore there in 2017 or 2018? Will he be recorded there again?
That bad ha?
I doubt it. My understanding about his last appearance was that it was a special even related to his "semi-retirement". When I was there prior to that, Chuck did not attend. It was a fun group, either way.
dead? ``` commit 0fdbf41d0484348316fbbb19a42a000ce043c265 (HEAD -&gt; master, tag: 0.7.9_20190711, origin/master, origin/HEAD) Author: Bernd Paysan &lt;bernd.paysan@gmx.de&gt; Date: Thu Jul 11 19:51:13 2019 +0200 Bump version number commit 2a0d5d9190b8f34c9f385efa6edf21045b99e3fd Author: Bernd Paysan &lt;bernd.paysan@gmx.de&gt; Date: Sat Jun 29 23:46:24 2019 +0200 Factor alias and synonym ```
I was just going by releases - there's a post further down that implied that it had died, so I was wondering. It's nice to see there's still things happening.
GForth is actively developed, but the website has not been updated to reflect any new development since 2014. the recommended strategy is to build from source, which you can find on Savannah or mirrored on Github.
And commits have been very frequent in the recent months. It's a very active project, as I see!
So, does this game engine have working code in something?
Twitter.com/ramenengine
[Here's the Github mirror](https://github.com/forthy42/gforth) which shows the latest commits. I do wish the developer would tag a release already and push it to the website, so people don't think it's dead anymore.
It does work with the latest snapshot.
I did something similar a while back, has a bit of a dumb name. [https://github.com/tehologist/forthkit](https://github.com/tehologist/forthkit) the implementation is less than 500 lines with only stdio.h as include and test program is mostly complete version of eforth including create does.
Hey, I just realized, are you the same Rick Carlino who made those tutorials for Opal and Volt? That was pretty cool stuff. I used Volt a lot and your tutorials helped me a bunch. Just wanted to thank you for that. It's too bad Volt never took off like it should have. It's pretty neat to see that you're interested in Forth as well.
 &gt; are you the same Rick Carlino who made those tutorials for Opal and Volt? I am! &gt; wanted to thank you for that I really appreciate it. It was really too bad that Volt didn't take off, though. I still stay in touch with Ryan Stout- he's working on a hardware startup currently (so am I, but not at the same place). We also went to Ruby Conf a few years back. &gt; you're interested in Forth as well I looooove Forth. I wish I had more chances to use it in the real world / work. Anyway, it really makes my day to bump into a Volt user here on /r/Forth. Thanks for the kind words.
&gt; I am! How cool! I actually was the author of a few Opal projects myself, one of which was opal-phaser. Unfortunately, life and work significantly diverted my attention from Opal for a good while, as it sounds like has happened with you also. &gt; I really appreciate it. It was really too bad that Volt didn't take off, though. I still stay in touch with Ryan Stout- he's working on a hardware startup currently (so am I, but not at the same place). We also went to Ruby Conf a few years back. Yes, I used Volt for several projects and had high hopes. It could have been a very serious Rails competitor. It's cool that you're still in touch with Ryan. Hope he's doing alright. He really did some monumental work on Volt for working on his own. Last I checked, he was working on Arsenal right? Is he doing well with that? I know the initial crowdfunding went really well. &gt; I looooove Forth. I wish I had more chances to use it in the real world / work. Ah yes, same here man. How much better computing could be if Forth was a mainstream language, maybe along with Lisp too. I love Ruby, but some other languages have serious advantages not found elsewhere, such as Forth. &gt; Anyway, it really makes my day to bump into a Volt user here on /r/Forth. Thanks for the kind words. I'm really glad to have made your day. I was pretty excited to see your name on here too, haha. Like I said, your tutorials were great and you did good evangelizing too. I think you even spoke at RubyConf once, no? I believe it was a lightning talk, IIRC. Fun times. Ah, that feeling of nostalgia for a time which was just a couple of years ago. Thanks for your kind words as well.
As others have mentioned, it is active. You can find snapshots here: [https://www.complang.tuwien.ac.at/forth/gforth/Snapshots/](https://www.complang.tuwien.ac.at/forth/gforth/Snapshots/) The main website doesn't update often, but I tend to install the 0.7.3 package, and then build the latest.
if you can alter arbitrary locations on the stack in this way, you have effectively implemented a register-based vm, where the registers are stack slots. i think including these instructions in your vm machine language is a great idea (as long as it's efficient), since it makes it easier to compile register-based languages/irs into your language.
Sure, except it's more pattern matching and replacing from the end of the stack than direct indexing. I find that makes more sense since it frees me from having to know anything about what comes before. The reason I ended up in this rabbit hole in the first place was performance, I was trying to improve part of a benchmark that replaced values by shuffling, dropping and pushing.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/concatenative] [Poking the stack](https://www.reddit.com/r/concatenative/comments/ceif36/poking_the_stack/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
&gt; But as to stack parameters, the stacks should be shallow. On the i21 we have an on-chip stack 18 deep. This size was chosen as a number effectively infinite. &gt; The words that manipulate that stack are DUP, DROP and OVER period. There's no ..., well SWAP is very convenient and you want it, but it isn't a machine instruction. But no PICK no ROLL, none of the complex operators to let you index down into the stack. This is the only part of the stack, these first two elements, that you have any business worrying about. Of course on a chip those are the two inputs to the ALU so those are what are relevant to the hardware. &gt; The others are on the stack because you put them there and you are going to use them later after the stack falls back to their position. They are not there because your using them now. You don't want too many of those things on the stack because you are going to forget what they are. *Chuck Moore* in [http://www.ultratechnology.com/1xforth.htm](1x Forth) The context is both similar and different from yours because he talks about a RM, a "Real Machine", and I always felt that there was a difference between what he does in his chips and what I do in my bytecode (*whadyamean "SWAP is convenient but it's not a machine instruction"?!*). But I think it gives a good idea about how to actually use stacks. With these directions in mind, I often eventually figured out how to remove unpleasant stack juggling by changing things around it. Even the little *swap over* which is usually named *tuck* is something I still hesitate to include in primitives because it tend to disappear when I reconsider the problem and "refactor".
Sure thing, I think most agree that excessive stack juggling is a bad idea. And as a consequence the general advice in Forth is shallow stacks. But the whole discussion starts with assumptions that are not universally true. In the context of dogmatic Forth, I fully agree with all of it. Given more syntactic flexibility, solutions like `poke` start making more sense to me. Another difference is that the assembler I'm writing is designed to be used as a compilation target as well, the end user language is free to expose whatever functionality it feels like.
This reminds me of [https://suhr.github.io/papers/calg.html](https://suhr.github.io/papers/calg.html) &amp; [https://suhr.github.io/wcpl/intro.html](https://suhr.github.io/wcpl/intro.html) If I'm reading your example and those posts correctly, I think push 1 2 3; poke {mul 21;} _; would be 1 2 3 21, mul, or, in CCF, 1,2,3 id,id,21,id id,mul,id as your `_` in the poke is like `,id`
IMHO, poking the stack entirely eliminates the very reason for it to exist.
I don't follow, it still exists to store state. If I take it out, the language is not going to work very well. There is no rule that says it's forbidden to modify items other than the top. There are several ways even in Forth to do just that, because reality doesn't fit into neatly labeled boxes.
Syntactic flexibility? It's called a stack for a reason, if you intend to blithely ignore the implicit locality of reference assumption on which the stack machine model is predicated and just go poking around the stack willy-nilly, you might as well just code directly for a register machine model, as you've already killed the goose and made it dead weight from the outset.
Right, good luck with that :)
No,there certainly isn't any rule, but FILO or even FIFO is a predictable mechanism. Each presumes an orderly behavior. Of course you can override this with knowing the memory address and a simple ! instruction. But predictable stack behaviors for both stacks is pretty much the heartbeat of Forth. Just because you can, doesn't really mean you should.
You're assuming Forth is the final answer to anything, which doesn't make sense to me. This is a superset, you may use it as a stack or update in place. Purity is a fools game. What is it about shuffle/update/shuffle that's more predictable than simply updating the value in place? I'll quote, "Just because you can,doesn't really mean you should.". It's strictly more powerful than what Forth offers, hardly different for different's sake.
This is r/Forth. Forgive me, but it isn't the presumption that Forth is the "final answer". The resumption is that your were discussing Forth.
&gt; It's strictly more powerful than what Forth offers "Strictly more powerful" in what sense? I'd conjecture that your construct could be compiled to straight Forth, using `&gt;R` and `R&gt;` as the critical ingredient. Which *would* show that most of the objections in this discussion are a bit strong, since `&gt;R` and `R&gt;` is cromulent Forth AFAIR. But it also shows that there's nothing revolutionary going on here. Now that I have your attention, why aren't you answering my question about the results of your benchmarking against Python (`bench` subdirectory of the repo)? After all, "the reason [you] ended up in this rabbit hole in the first place was performance", so isn't it natural to wonder how it worked out?
If your VM should be fast for COMMON out-of-order CPU's, there is no way around some kind of native-code generation because of different strategies for branch prediction and non-avoidable, principle higer latencies for indirect branches. So you will come to the point where a decision must be make between two aspects: Implementation effort and performance effect. Regarding both, most complexity for optimized JIT or AOT compilation can be minimized by designing the operation-code format and instruction set such, that multiple instructions are bundled to a single operation code as compilation is then reducable to efficient and simple to implement pattern matching on bit sets. Choosing a MISC style instruction-set allows is then the key feature because the efficiency of code generation depends on the number of instructions packed. This also solves another disadvantage of current processor designs, the machine-code depth. Stack based VM designs have the advantage to allow very compact operation-codes which also can have a larger impact on cache usage. Hope this helps.
Thank you. Not every interpreter needs to run that fast though, tight integration with the host language (C++ in this case) allows combining the strengths of both. I've been there, but the complexity quickly escalates to the point where its not doable for a single person and that takes away all the fun. The hunch I'm currently following is that embracing interpretation at a higher level rather than mimicking physical hardware will allow other ways of reclaiming some of the performance, while still keeping the implementation nimble. It's currently running benchmarks 1x-15x as fast as Python3, which I consider pretty good considering the difference in optimization effort and clarity, and fast enough for an embedded language.
1X-15X seems like a pretty big hit. I am not that familiar with Python but I have seen some benchmarks that run 100X slower than native code. (interpreted not PyPy compiled) Simple Indirect-threaded Forth is about 3X-5X off native code speed. And gForth's combination method, (black magic to me) written in C, is about 2X-3X slower.
I just about tore my hair out trying to make sense of it. In classic GNU fashion, no care was given for simplicity, instead it's about upholding the delusion of portability, much was sacrificed, and the source code sucks.