Yes, love my Ducky One with Cherry Reds.
[AVAST](http://www.valleyflorafarm.com/sites/default/files/images/pirate_keyboard_0.jpg) 
https://assets.logitech.com/assets/54252/wireless-touch-keyboard-k400-plus.png Best keyboard ever, plus, yellow button in top left corner is left mouse button, you are moving you hands minimaly
[Microsoft Curve Keyboard](http://www.ergo247.com/wp-content/uploads/2011/12/Microsoft-Comfort-Curve-Keyboard-2000-quarter-view.jpg) - although mines has the big return key. I use the same keyboard both at work and at home.
&gt; setting up authentication and authorization can be complex (security is complex and syfmony does support a lot) &gt; Yeah, it is. Even with all those layers you can set up. * Your own authentication method? You need to build a firewall listener * Only need to tweak how your login form is handled? `SimpleFormAuthenticator` is the answer * Something in between? There are `Guards` * You only need to fetch users from some custom store? `UserProvider` * Your authentication is done, but you need more fine granted authorization? `Voters` or some other stuff… Im fairly certain that there are no limits to what Symfony can accomplish, but it’s not the easiest piece of cake.
You can use [vfs](http://vfs.bovigo.org/) in your tests to create virtual filesystems which contain exactly what you want without having to really write those files.
Love my Ergodox EZ. I have been carrying it home and and to work, but my second one arrives today so I don't have to do that anymore. By far my favorite feature is the ability to change the layout to find the one perfect for how you use it. http://configure.ergodox-ez.com/keyboard_layouts/kdvdlp/edit This is my current one. I'm fond of the braces placement, no more pinky strain.
I've found a very simple and testable solution for this issue. It works in every IDE, without a plugin. It's a "factory helper function" (something like a laravel facade). There is one function for each specific service object. This function pulls only the desired service object from the dependency injection container. To make it IDE friendly (autocomplete, refactoring) I just add the correct annotation above the function. (@return Request).
I would disagree :) Did you even read the post? It's about what issues we faced in migration process and what effects it brings to us. Take into account that this migration was not done on some small one server application but on olx.pl (OLX Group is leading classifieds platform) which handle 4 bilion page views per month. Let me know what do you think about it.
WASD Keyboards V2 TKL at work, Ducky Premier CCnG at home, both with clicky switches. Planning on building a 60% keyboard this summer.
No it's not enough with Symfony unfortunately. I need to back-sync at least the cache to use the PHPStorm Symfony plugin, to have a better developer experience. I will try it anyway, I would like to see how much it's a problem to not have the cache..
&gt; ... enhance legacy PHP code with C#. Why not enhance legacy PHP code with just better PHP code? :)
Wow, you take your keyboards very seriously. Looks like a fantastic device.
My man. I use mine with a large iMac. The aesthetic clash delights me.
Microsoft Wired 600. Is cheap. Is good.
[Unicomp EnduraPro](http://www.pckeyboard.com/page/category/EnduraPro); new manufactured Model M style buckling spring USB keyboard with a Trackpoint mouse controller on the home row. It can be very convenient to not have to move away from the home row to use the mouse.
How the heck are you supposed to use this and emacs lol
At work: Cooler Master QuickFire Rapid-i with Cherry Browns Home: I switch between a regular QuickFire Rapid with Cherry Reds and a full size Rosewill RK-9000V2 with Cherry Browns depending if I'm doing lots of numbers or not.
[Amazon Basics](https://www.amazon.com/AmazonBasics-KU-0833-Wired-Keyboard/dp/B005EOWBHC) They're inexpensive, look good, feel good, sound good. The extra media buttons they chose to include are actually ones that I use (volume up, down, mute, calculator)
Great resource! Thanks!
I use evil mode...but its not easy to use the Ctrl Often, or is it
Control is to the left of "A", it's not that bad. I'm also on Mac, so CMD gets used more than CTRL.
I did wait a year for Clear switches to become available. Saw an email about them being in stock one morning (Swedish time). Ordered immediately. They were sold out a few hours later. 
I have the K60 that's now in my closet. I could never get use to the key spacing and the noise is way too much. I'm actually thinking about putting it on eBay because of these issues.
I don't see any ergonomic mechanical keyboards that aren't expensive, or is so odd, it would take a while to learn how to type on it.
Is your local server working? 
Steelseries 6Gv2 with black switches. Not the absolute best at typing to be fair, but since I'm already used to that keyboard from using a lot for games and other stuff before, I just use that for code too.
I actually realized I'd learned how to type a few keys incorrectly when I used an MS ergonomic keyboard with a gap in the middle. I'd been hitting "B" with my right index rather than my left. Took a week or two to get used to that. Sadly I eventually spilled something on it and half the kb stopped working and I reverted back to typing "B" wrong.
Colemak &lt;3
+1 for Apple. I have the bluetooth keyboard and trackpad. Can confirm, comfy as fuck.
Any stores where I can try those?
Don't know enough to comment on your first paragraph. As far as your second goes, however, I do need to point out that I'm aware of TDD, and that's the ultimate goal; I get the feeling, however, that going down that road before I can actually write proper tests might be a bad idea.
[Logitech K360](http://www.logitech.com/en-us/product/keyboard-k360)
The Microsoft 900 keyboard is a nice Windows alternative.
But.. arrow keys /s Totally would be fucked myself though, haven't gotten into the habbit of hjkl yet
I have a das ultimate, took me about 30 minutes to find the damn | character one day. Stopped using it after that.
Why not get one from Unicomp? Comes in USB and many layout options to choose from. They bought the patents for the model m buckling spring mechanism. 
I'm not concerned about PHP version support, this is about IDE tooltips. My IDE can't tell me what parameters the function accepts if you use variadics.
MS Comfort Curve 6000
The logitech K380. I like the low key's and I carry it with me to the office and I use it at home as well. I really like it
That's probably a database connection error. Check the PHP log file for more information.
[A wired Apple chicklet keyboard](http://www.apple.com/shop/product/MB110LL/B/apple-keyboard-with-numeric-keypad-us-english), very short short keypresses. &lt;3 
I use the arrows all the time. It's something you quickly get used to. It would be torture for gaming, but real-world work use is fine. The real problem is home/end/pgup/pgdn. They're on the function layer nearly in the middle of the keyboard, so it's easy to accidentally hit the wrong key.
Microsoft Natural Ergonomic. This one: https://www.microsoft.com/accessories/en-us/products/keyboards/natural-ergonomic-keyboard-4000/b2m-00012 Actually, now almost all the programmers at my work use this one.
It's not for sale, but we are giving it away on conferences/meetups in Poland. Feel invited ;)
On mac you generally need to use 127.0.0.1 instead of localhost for your db host
I'm very impressed that programmers don't use ergonomic keyboards. I use them for like 20 years. Currently Microsoft Natural Ergonomic 4000. I once wanted to build my own keyboard with additional row of keys - you know those keys we use most but we have to press shift () &lt;&gt;{} [] etc. I'm too lazy to press Shift. Wouldn't it be great to have all brace types directly accessible without shift key? 
This is like not voting because your vote doesn't count anyway. Till you hit the brick wall and you'd wish you'd have voted.
Because I was unaware. Thanks!
I think using pipes will introduce confusion. When i saw pipes used in rust for the first time i had no clue what they are. I am sure if i'd have seen `fn` i'd figured it right away. Also, maybe not posing issues when using bitwise operations, but def. will look awkward and even awkward when you pass an arrow function as a param to an arrow function, who knows why.
I switched from Black to Brown. They're both too loud.
I'm talking about the differences in key caps, keyboard body heights, etc. Of course the switches are the same (except for Razor and Logitech that decided to go with different ones)
One random person's unsubstantiated opinions.
A 10+ year old &lt; $20 Logitech Classic Keyboard 200
A third of the article is a generic (but potentially useful) upgrade guide, and the rest is specific to the author's product.
While complex, it's also very extendible indeed! Note that it's not 100% certain if the Simple variants will stay, guard pretty much replaces them.
Tried to find ZF3 docs when it was just released, nope. Saw the default page with Symfony integrated (for migration to Symfony blog post purposes), and the Symfony deprecation tool actually found a bunch deprecations triggered in a freshly released 3.0 version :(
[;\)](http://imgur.com/psFwHb8)
Well there are great people here that helped me out. Fuck you.
Can you echo something out in public/index.php?
&gt; low level I do not think that means what you think it means.
This ^
&gt; My first recommendation is to abstract the file loading from your class. In this particular case this wont add any profit. &gt; You end up mocking a lot of things in your tests, which leads to reducing the value of your tests. Basicly you will mock only things that cross boundaries of process. For example in this case you will just use stubs for filesystem. If you want to make your tests faster, you could use some in-memory filesystem for example. Something [like that](http://vfs.bovigo.org/).
Steelseries apex m500, very happy with it
This what I am currently doing. Test the public methods, nothing else. First write unit tests. Personally I am using SimpleTest for strange reasons that don't apply to other people, PHPUnit works fine for most people for writing unit tests. The purpose of unit tests is to test individual classes, methods, functions, and lines of code inside them in isolation. You should be able to run all of your unit tests for the entire project very quickly. You should do this frequently as you program, so you can get quick feedback on if you broke anything. Don't create any new objects inside your class directly using the new keyword, make sure to accept either those objects themselves, or factory objects that will create them from the public methods. Create a public static method called make() which only accepts the parameters that will be needed by your normal code and your integration tests (more explanation later). Your unit tests should not make use of the make() method, except perhaps once to test it. Instead of using the make() method, the unit tests will call the constructor directly. They will pass in the objects and factories that you would be inclined to new up inside the code being tested if it were not designed to be testable. The unit tests will mostly pass in mock objects instead of the real ones. You are largely verifying the code talks to and responds to those objects correctly. Then write integration tests. Integration tests are closer to a real world test in that they use as few mocks as possible. The integration tests will use the make() method instead of directly calling the constructor. The make() method is responsible for calling the constructor. The make() method will create and pass in the non-stubbed, non-test specific versions of objects. The make() methods creates a single place in the code where the "real" objects are created in preparation for calling the constructor instead of spreading that out to different parts of your code and integration tests. The make() method may also accept some parameters which it will pass along to the constructor. The only parameters the make() method should accept are the ones you would want to pass into the constructor even if you were not testing the class, stuff that will make that particular object instance do what you need it to do. The exception to this is objects that you still want to stub even in your integration tests because they would fowl up the test. This might be an object that collects output instead of echoing it, or an object that collects header redirect strings instead of actually sending them. Then move onto acceptance tests. Acceptance tests are the closest thing to a real world test you can have by doing automated testing. They test features instead of code by driving a real web browser to test the website from the perspective of a user, the same way a user would, by clicking on stuff and entering text and examining what they "see". They also serve to document the officially desired behavior of your website's features. By being the officially desired behavior of features, they serve as a good reference when discussing with the product owner how existing behavior should be altered, or what new behavior you might want to add. I use Codeception to write my acceptance tests along with Selenium and the Chrome driver. I make sure my acceptance tests test the error logging. I make sure my acceptance tests will fail if a PHP or JavaScript error occurred on a page they tested. I also run all the HTML that gets sent to the browser through an HTML validator. If a validation error occurs, the test fails. Acceptance tests are a good place to ensure you did not totally break the security of your website before doing a new release. They should make sure you cannot log in without a username or password. They should make sure you cannot login with the wrong username or password. They should make sure you cannot login with a valid username and someone else's password. All of your unit, integration, and acceptance tests should automatically run on a continuous integration server in response to a new commit in the main branch of your version control system. All team members should daily integrate all of their work into the centralized repository / version control system in such a way that the CI server runs all tests against it, so you know all the work people are doing is compatible compatible with the work of other team members.
Model M till the day I die.
&gt; After using the site to decrypt to encrypt I get a completely different value. Huh? You just told me no sites *could* "decrypt" them so...what exactly are you re-encrypting? Are these English words? All English words should be cracked by now, along with the top 10K or 100K passwords, but not every string in existence is reversible. Also, if you're using salts, that also breaks all the rainbow tables out there. md5 isn't great, but it's not quite as flawed as people make it out to be.
IMO Laravel is great for getting up-and-running quickly - this is especially nice for creating a quick MVP. But for maintaining large applications over the long term I personally prefer Symfony. Edit: neither framework is inherently "better" than the other, and both can be used for large projects. You just need to weigh the strengths/weaknesses to see which works best for your particular circumstances.
sorry i was writing this in the last min of class, i was rushed lol.
whoops lol, making chicken and waffles for dinner
That's fine. I'm just very interested in clarity and promoting public cryptography literacy.
Use "\n" instead of '\n'.
This loads the whole file in memory if I remember correctly. I've had major performance problems with large CSV with that (like 2GB+).
Desktop in PHP? Curious as to what toolkit you used.
I tried it both ways anyway and got the same value
Logitech K800, which has surprisingly outlasted better keyboards.
Can't tell you how many times I've screwed up code while making chicken and waffles...
1. Be wary of trailing new lines 2. Don't hash the base64 encoded value 3. If you pass \n through single quotes, it will literally be interpreted as the string '\n' and not a new line character. Use double quotes. I've amended your code at https://3v4l.org/ElXtk#output, passing the hashed values through hashkiller.co.uk you can see they all come out. 
Thanks! Ahh now i see what i did!
https://www.kinesis-ergo.com/shop/freestyle2-for-pc-us/ Having spent ~10 hrs a day on a computer for the past 20 years I've developed some wrist issues. This helps :) Along with https://evoluent.com/products/vm4rm/ Take my advise and please make posture a priority. I have lower and upper back problems as well. I now have to visit a chiropractor and massage therapist every month or else I'm in a large amount of pain.
I use this keyboard also and it has helped my wrists a ton. Along with https://evoluent.com/products/vm4rm/. I wish I would have taken my posture more seriously over the past 20 years.
Php isn't that bad really, it just has some quirks to it, but all languages do, none are perfect. But for alternates, there is pythons dyjango, ASP.NET (for windows). There are many more, I am just too lazy to search for them right now.
Python as well. 
In my opinion, going from Symfony to Laravel would be a downgrade. This is a very subjective question though, and I'm sure there's no "right" answer (the type of thing that'd be closed on stackoverflow). Additionally, if I was to move from Symfony/Silex to something else, I'd probably go Slim instead of Silex and give Zend Framework a try over Symfony.
I really believe all these major frameworks are pretty similar. I use Cake, but I am not an evangelist. Laravel may be better than Symphony or it might be the other way around. Ultimately I'd use what works and what you are comfortable with unless a compelling reason exists not to. "I heard a lot of people like Laravel" is a shit reason. Follow what the framework authors intended you to do, write clean, optimized code that can scale well and follow best practices with integration tests etc.. Thats more important than choosing between a major framework. If it were me, I'd use Cake ;-) But I wouldn't mind using another framework either.
Also this would be done on a Windows machine, not a Linux.
&gt; has exactly what you need. Good spacing, normal layout, all the basic buttons. It's amazing how many manufacturers get this wrong. key height also plays a big role for me. i don't like flat keys.
He's not wrong though.
Oops. Should be "high level". I'll leave it there as my scarlet letter. Thanks! 
PHP is great for beginners because there isn't such of a steep learning curve compared to other technologies such as node or ruby. I would suggest to learn PHP to familiarize yourself with how the backend works and such then move to a different technology. It will be a lot easier to use PHP as a *buffer* (sorry) for learning something else than if you were to learn node or ruby without prior backend knowledge. Also considering 80% of web servers use PHP these days, it is a good skill to have. 
&gt; There are a lot of differences between successful and unsuccessful programmers, but *one* of them is that successful programmers focus on getting stuff done, and unsuccessful programmers focus on arguing about tools I need to print that quote and put it up in my cubicle &gt; And if people try and convince you that's a terrible choice, ignore them; they're trying to have fun arguing which is great I wouldn't choose an orm such as Eloquent as a first exposure to dealing with a database though, if that's what your implying. Or a big fancy framework to do something super simple. OP need only look up php's documentation on PDO and how to 1. Connect 2. Query 3. Learn how to read the data from the query 4. Close the connection 5. Use prepared statements Op can learn to do what he wants to do with just the stuff php comes with, and no extra bloat or layers to learn. That stuff can come later, when one can properly appreciate what the abstractions those things provide. 
That's true, PDO is probably a better choice than an ORM. Depends what he's doing of course.
Python and Flask is an alternate. In my internship, I worked with PHP for a year and in school and another internship I've used Python for well over a year. Python is much nicer language, in my opinion, and Flask is great for building and deploying a server quickly for things like hackathons.
I've gone my entire life without using what is proposed, that's why I'm saying that it doesn't really matter. If I where to vote, I'd vote against because the pipes looks ugly (yeah, I'd base my vote on cosmetics in this case).
We're using it our new stuff and in one or two small production apps. It's awesome being able to get all the devs on the same version of different services.
I was more thinking about how you already have a browser window open when reading reddit comments, where as Node, Lua, Python etc. needs to be installed. It's not like OP made a usable website like https://time.is/ anyway...
&gt; where as Node, Lua, Python etc. needs to be installed. If you're using linux, `date +%s` approach doesn't need you to install anything.
I don't think anyone in this thread has mentioned the possibility of going with a serverless architecture. If you already know JavaScript (or a few other languages), you could go for a service like Firebase or AWS Lambda + AWS API Gateway. They're both quite cheap to run, both have the capability of storing information in a database, and both support JavaScript and client-side (in browser) implementation. A bonus is that if your website is static (HTML/CSS/JS) you can serve it out of Amazon S3 instead of hosting it on a web server.
&gt; 3rd party extensions I don't think third party packages are that bad as you make it to be. I had good success in integrating all sorts of functionality into my apps. If anything else you're always free to fork and maintain something yourself. Even if there are 100 and 1 packages doing the same thing then you'd have a choice in picking your package instead of being dependent on one particular package. &gt; frontend packages that integrate with the framework to ease development Can you elaborate? And do you have some examples of how other frameworks accomplish this? &gt;no good admin packages Have you even tried some? [Backpack](https://backpackforlaravel.com/) and [Laravel Generator](http://labs.infyom.com/laravelgenerator/) are pretty good. &gt;and may not even install cleanly Not sure how you install your packages, but almost all of the time it's doing `composer install $package`, adding a service provider to your `config/app.php`, optionally followed by publishing vendor configs/assets. &gt;Almost no docs for the bigger extensions Could you name a few? Not nitpicking, just interested. &gt;Expect to do 80% of the things yourself. Every man is for himself - it's fragmented as fuck. There is no real full-fledged community behind it - it's all driven by marketing. Sadly, I do somewhat agree with this. Between IRC, Slack and Laravel.io, community support is hard to find and people seem mainly interested in their own problems.
Along with what everyone else has said... Find a guide written in the last few years. Remember to sanitise your input and filter your output :)
You already have filesystem abstraction in php. There is no reason to build another abstraction on top of it.
I guess I am little late to the party. More than answering your question, I intend to comment on this "PHP is a poorly designed language" thing. I am a *traditional* programmer. When I say traditional, I mean that I have learnt programming through C, OOP through C++ (well not really) but mostly through Java. Then I have had extensive experience doing Haskell (because I like it) and real world stuff in Erlang &amp; Scala. To be precise, I used Scala for one of those Apache Spark thingies - you know, just your run of the mill big-data thingies, consuming some TB's of files. I have had professional experience at developing embedded systems (read robotics). I have also worked in the field of Machine learning. The programming languages that I **work** with, are: **OOP** - Java - PHP - C# - Python - JavaScript (doesn't belong here, but it **does**, if you know how to do it) **Functional** - Erlang - Scala - Haskell - Python - JavaScript (doesn't belong here, but it **does**, if you know how to do it) **Imperative** - C - Python - PHP - JavaScript (doesn't belong here, but it **does**, if you know how to do it) The programming languages that I **know** are: OCaml, a couple of Lisp dialects, Shell script (various flavors). So, I have had flings with a lot of languages. If you analyze any language, there would be flaws. The learning curves would be different and also the **primary** applications would be different. In a Turing complete language, you can express just about any idea. Our understanding of computing has generally improved with time. So, what we thought was great back in the 80's may be not so much great anymore. As generations progress, our understanding enhances. And, so does most of the tools, well, at least the relevant ones. And so has PHP. So, if you are a good programmer and you know PHP, you would be good in PHP. You can do anything in PHP. Yes. ANYTHING. But, then, as the saying goes, "just because you can do something, doesn't mean that you should do it". I can do PCIe drivers in PHP (actually, I have as a P-o-C), I can do TensorFlow API consumer libs in PHP and I can FUCK up using PHP too. So, does this mean that you should do *everything* in PHP? Yes and No. If PHP is the only language that you know, then go ahead and get the job done. If you have a better tool then use that or learn that. If I were to do Machine Learning, I would use Python. If I had some constraints on CPU/Memory/Power etc., I would possibly use C to acquire data, Erlang to parallelize the task and Java/PHP to expose ReST API's. So, PHP is a great language. Granted it does have some pitfalls, but, for every pitfall in PHP, I can show you one in your favorite language. **Points to ponder** PHP 7 has great performance. But isn't NodeJS better as it is non-blocking? Yes. But, in Node one unhandled exception can crash the process, PHP has great Exception handling. But, you could just run a multi-cpu Node? And so can you run a multi-threaded PHP thereby putting the expensive I/O read into Async... Python should be our choice. It has everything. Really? What about Public/Private Class variables? No. What about Interfaces? No. Wait! I know, the best is C. Fast, has everything, you can get it to do anything you want. Neat! Better still, learn Assembly. Do NOT learn Machine Language though... seriously, it [sucks!](http://softwareengineering.stackexchange.com/questions/126095/resources-on-learning-to-program-in-machine-code)! 
Nicely put!
You seem to be focusing on very specific things and missing the point?
PHP with a modern framework like Laravel or Symfony is a very good choice for web development. However it's been around a long time and some of the older tutorials you will online are shockingly bad, full of bad practice etc. I would say one big advantage of learning Node, Python or Go is you are likely to to learning from better quality, more recent tutorials. However, some of them may assume a higher level of knowledge - Go in particular is a great language to learn, but most of its audience are probably coming from extensive C or Java backgrounds. 
dont arguing about tools just focus on programming n become a successful 
Just as a point; when your learning, don't get to hung up on what to learn. You will find learning your first programming language difficult. Especially jumping from HTML &amp; CSS to a programming language. But don't give up - you will find learning your second programming language so much easier because a lot of the concepts you have learnt and skills you have gained are transferable. Learning your third one? Even easier still. When your picking your career options or working on a big real project later - that is the time to worry about what is the "right" language - for now, as a learner, just pick one and get stuck in. PHP is perfectly good for this - just make sure the tutorials you follow are fairly recent. Tho, &gt; I really want the ability to store user accounts into a database for an upcoming hacakthon If that's really all you want to do for now, have you looked at something like https://firebase.google.com/ and JavaScript ?
"Print" is the verb for displaying output on screen. Doesn't matter which function you use, it's still printing output. 
You're making the assumption that your bespoke solution on Slim will be flexible. You don't know that it will be because you don't know the future. Write the best code you can based on the current requirements and write *good* tests for it (not all tests are created equal). Laravel is not just designed for RAD. The DI container is very powerful and it has many enterprise level features such as built-in, multi-driver job queueing, real time socket stuff with event broadcasting, OAuth2, command bus, middleware, etc.
This site is inexhaustible source of lulz. The blunders of the current article are obvious, but look at the others: &gt; This is How Your Company Website Should Look Like in 2017: *GIFS are going mainstream*. No, really. In 2016 GIF started to pick up the wind and in 2017 finally came in full force. Right at its 30th anniversary, in the age of PNG, SVG and HTML5. 
FWIW, YMMV, etc., I would distinguish between Cake and Laravel by saying that while a very complex Laravel application *can* be built on top of a lot of heavy abstraction ("magic"?) and convention, it's very deliberately designed such that this doesn't have to be the case. You can do pretty much anything the "right way" in Laravel. On the other hand, in my experience it's considerably harder to go against the framework's conventions in Cake. You either do things the "Cake way" or you are almost certainly going to make a big fucking mess. This matters for a few reasons, but the one that's important to me is how easily understood a codebase is. A well-written Laravel (or Symfony, ZF, etc.) app is going to be easy to onboard someone onto or easier for an outsider to fire it up and fix a random Github issue, where as a newcomer to that Cake app needs to go hit the Cake docs (which really aren't that helpful unless you're solving the more common problems in the prescribed ways) before they can be effective. Cake is fine for the kinds of simple/medium complexity, ideally CRUD-based apps that agencies or (many) freelancers write. But please don't pick it for a brand new in-house business application that you are going to maintain for a long time. Nobody ever inherited a large, complex application and said "thank my lucky stars, it's Cake!". On a side note: Cake 3 is an order of magnitude better than 2 and it's getting even better as it incorporates middleware. But even so, if you want "RAD", it's hard to argue against Laravel. Source: do a lot of work with Symfony, Laravel, and Cake (3 and, sadly, 2). 
Yeah, K120 forever! Cheap, simple, just works. Once it fails, I think I'll buy at least 5 of them to stay stocked up for the rest of my life, but it's been like 4 years already since I bought this one and it's still working flawlessly like a new one (which is really quite surprising for such cheap keyboard, I type alot, play games alot, eat at PC, smoke at PC etc., you name it, I've done it...), so maybe I'll never actually get to making such purchase :-D I once tried some mechanical keyboard (with Cherry MX Black switches, without the loud sounds) and after few months it began failing, double or even triple-typing whatever button I pressed, and wasn't really that much more comfortable. Never again.
&gt; Cake is fine for the kinds of simple/medium complexity, ideally CRUD-based apps that agencies or (many) freelancers write. But please don't pick it for a brand new in-house business application that you are going to maintain for a long time. This is so true! +1
I'm in the minority, but I think dart is a great server-side alternative to php. Php is pretty great though, so don't write it off. 
We use it for anything non production. It's a great tool to make your CI more efficient (building/testing against 5.6/7.0/7.1)
It really depends on the size of your project..if you prefer conventions over configuration, you can start a lot faster and deliver ready made standard features easily..the downside is when your customer wants to change how a standard approach works..in this case you will most likely hit a huge bump..I used features from the framework which worked supposedly fine..but once I needed to change it..it took a lot more time than actually doing it myself from scratch..whilst if you use a framework like Symfony..you have a slower start, you will need to do a lot of configuration but for the long term you will be able to keep a certain pace and standard value delivered to the client..no matter the requirements or changes..so to sum up my experience..with framework like Yii or Laravel..you have a really good start, you can show very fast something to your client..but from a long term perspective you will really loose on the value delivered and even simple thing will be a pain once the system is robust..with frameworks like Zend or Symfony..you will have a really slow start but once you have everything properly set up you will be able to keep your pace and value delivered constantly over time..of course it also depends on your experience as a developer and with the framework..so it is not a rule 
Do you honestly believe anyone subscribed to this subreddit doesn't know how to define and print a variable in PHP?
I'm not the guy to say which one is better, but from experience, a framework you know will allow you to work more fluent than one you don't know already. Frameworks offer default-ways to solve issues. If your brain is in symphony, but you write in laravel, it's quite possible that your result won't be as good as it could be. Imho it's better to use the second best framework, if it is the one all your developers know. Unless you work alone, I'd ask the other coders for their opinion. If none of them ever worked with laravel, that's your argument for not using it. If you work alone... well, you got my sympathies, because it seems you got quite a workload ahead of you.. I'd also go with the framework you know best then. 
Use it only in development. And preferably on bare metal. It's amazing to 'docker-compose up' on any machine and have a dev environment up and running.
I think this would be a good move. To me a roadmap like this makes sense; PHP 7.2; (or whatever the next version is) Namespaced core, but existing globally scoped functions etc would map to their namespaced equivalents for backwards compatibility but would also be marked as deprecated and probably issue a warning or whatever it is deprecated features do. PHP8; Remove all core features from the global namespace.
I agree. Understanding how the service container for Symfony worked was difficult and it took a while to learn about all of the services it contained, but just about everything can be swapped for your own implementation. Inversion of control makes almost anything possible in Symfony.
If nothing else: It gives us a chance to clean up the standard library without breaking backwards compatibility. Argument order is funky? Fix it in the namespaced version.
Maybe they didnt start this in PHP7 due to fear of BC Breaks? I think there should be a way to achieve something like this without major BC Breaks, but it may take time to explore and discover how to make it happen. 
The only problem is that most of core is functions, and functions provide a very, well, shitty experience when `use`d from a namespace. We need to have a story for importing functions from a namespace. I'd propose static method imports, like in Java, as this can work in PHP, i.e. we refactor those functions as static methods, like this: class Arrays { public static array_map(...) { ... } } Then we use them similar to this: use Php\Arrays::*; array_map(...); 
What does this have to do with PHP?
&gt; PHP8; Remove all core features from the global namespace. that would probably a bigger PITA than the Python 3 changes and would seriously harm PHP 8 adoption as this would make *every single existing file* incompatible with the new language. And worse: It would be very tedious if you need to be compatible with both PHP 8 and PHP &lt; 8 as you would have to write namespaced wrappers for every single library function you use. Honestly I believe the train has long left the barn for a restructuring of this kind.
It does feel like it should have been two articles.
Then they could drop all of the old functions in version 9. That wouldn't be for a great number of years. People would have several years to make the switch.
If users want namespaces for new classes, fine give em. Changing existing shouldn't be rushed. Internals can learn for now and see how to migrate old stuff later.
I'm thinking that PHP 9 could drop it all. Then would be for many years and they could even creep in the deprecation notices over several releases in the 8 series. Also framework authors in the know would just start making the changes late in the 7 series. Then one day in like 6-7 years from now everything would be namespaced.
The entire core is unit tested, just glean the ways of doing it from them. It's not too bad, with factories you need to mock the create method and return a mock instance of the class you want to test. Sometimes is can get a bit messy but it's probably pointing to an issue with your code being too complex and integrated with the core or you are trying to test the core.
That is a good point. I guess if you stretched it out over more time and make the transition more gradual it might be more manageable; PHP7.2 = old-&gt;new mapping. deprecation + warnings PHP8 = can enable the mapping, deprecation warnings by .ini setting but its off by default PHP9 = remove the ini setting so its off for everyone I'd imagine that'd get most of the popular framework makers to get their code in order. For older code, say enterprise drivel that's still running php 4 era code in 2025 (or whatever timeframe we're talking here), I guess the PHP folks could backport security fixes and provide some kind of LTS support for PHP8. It's those enterprisey folks that have the money and lack of foresight to pay for that kind of support too - so could be a nice earner for the PHP folk - eg, Microsoft's extended support for Windows XP. 
This seems like a heavily mixed bag. On one hand, you clean up the standard library, but on the other hand you're creating a massive backwards incompatibility that is going to divide the community, and have a hindered adoption because they wouldn't care, and they don't want to have to do massive refactoring of there application. Something to consider with this, is that essentially EVERYTHING is going to need to be refactored, or depending on how old it is, rewritten. I can tell you for greenfield projects I would use the namespaced implementations, but theres no way I'm going to be able to go through everything I maintain and get it "up to snuff" if we eventually remove the non-namespaced aliases to quickly, and I love this idea. Just my two cents though.
Go
&gt; and actually the best out there for web backends In what way?
I can understand why people initially want this, but are you sure it would actually bring more value than pain and that the work-to-value conversion is high enough?
&gt; Having 2 different APIs of the very same thing will be maintenance horror for everyone. The old unnamespaced api just becomes a wrapper around the newer one, then when you drop the old functions in PHP 9 you release a php based wrapper to implement the old functions that also generates warnings for every call and at that point abandon the old api entirely.
This sums up my experience so far with Docker, too. Maybe I'd add that it also shines when building clean, ephemeral testing environments for CI.
maybe this is produced by random keystrokes of code-monkeys 
Lack of adoption says more about the community than anything. If devs of popular libraries and frameworks upgrade their code to be compatible instead of complaining about the changes like Python devs did, it's an easy upgrade.
Take it out back and kill it. It's the humane thing to do.
We at Forma-Pro use Docker extensively both for production and development. Here's a handy container image useful for PHP apps https://github.com/formapro/docker-nginx-php-fpm. Hope you also find it useful. It is kind of drop in container. Put your php\static files into it and it serves them. Also it does some extra things for you signal handling, php-fpm or nginx failure, logs forwarding to output. Also there is an app built and shipped by Docker. It is https://github.com/Payum/PayumServer. The build process is completely automated. The container with app is built by travis and pushed to docker hub. Than you can deploy it to prod with three commands docker pull payum/server docker-compose stop docker-compose up -d
there you go! function randomIndex($weights) { $r = rand(0, PHP_INT_MAX) / PHP_INT_MAX; // [0-1) foreach ($weights as $i =&gt; $val) { if( $r &lt; weights[$i]){ return $i; } $r -= weights[$i]; } return $i+1; } echo ['head', 'tails'][randomIndex([0.1, 0.9])];
This has nothing to do with PHP
PHP doesn't support sockets out of the box? But what about: http://php.net/manual/en/book.sockets.php I've built a small little WebSocket chat application with PHP on the backend and it worked perfectly fine. I never pushed it over about 50 concurrent connections so I don't know what its scaling limits are, but functionally speaking it worked as expected.
As a separate initiative, it would be nice to see some of the functions adhere to a style convention of sorts so that they are more intuitive and homgenous...
There are many big, forward-thinking changes and improvements I'd like to see discussed in time for 8.0, and this is very much one of them. Assuming it goes forward, I hope there's a good way to solicit community feedback^1 but at the same time let internals make the final call on a cohesive design that hopefully accounts for future needs. I also believe that most of the high-frustration areas (read: array and string functions) that people want to see "cleaned up" in a namespaced version aren't solved particularly well by just renaming some things, so let's not take the *all I have is a [hammer](https://www.flickr.com/photos/raindrift/7095238893/in/album-72157629492908038/)* approach. Might that also help? Sure. But we're engineers and can do better. I applaud you personally for your work on the libsodium RFC, especially since that brought this discussion back to the forefront. ^1 For example, `\php\SPL\Iterator\RecursiveIteratorIterator` is thrown out at one point in the thread. That name *completely* misses the point of namespaces, on several levels. I hope that they'd listen to feedback about that rather than trying to bucket existing functionality into new namespaces otherwise as-is.
Usual PHP behind Apache* won't help you here (unless you use long polling, which is something else). However, if you are willing to maintain a long-running PHP (which will be another server on it's own) then take a look at [Ratchet](http://socketo.me/), which is designed specially for this purpose. Alternatively you can use a service like Pusher or Ably (I prefer the latter for a better free plan) to host the realtime messaging infrastructure for you. *Most of web servers won't support it, but I read somewhere that someone got Ratchet working behind Nginx. If you use it and will to try going that route, message me and I'll try to find the article
You can try [Sylius](http://sylius.org) instead. It's a promising new e-commerce platform that's currently in beta.
Do not listen about web sockets. Web push notifications **are not web sockets at all**. https://www.w3.org/TR/push-api/#h-sequence-diagram I've done it in ruby, but there is same libraries for php and nodejs - interface, actually, almost similar. * PHP: https://github.com/web-push-libs/web-push-php * Nodejs: https://www.npmjs.com/package/web-push * Ruby: https://github.com/zaru/webpush Also, you could use something like onesignal.com, but I will tell about how to do by yourself. ----- **There is an brief example how it works:** Web push requires server part to encrypt and send messages (this is library for). You can do it via cron, daemon, jobs or like you whatever. When you want to send notification, you should send it to stored before endpoint url. This endpoint url is related to browser vendor. For now it's firefox and google chrome (android firefox works also). This endpoint url you will receive via JS-code when person will subscribe - you need simple js code for this. When browser starts, vendor will send notification to it. Browser will catch this with service-worker - it's js-script which works like a daemon but within browser. It does not require opened tab. So, you should write your own service worker which will handle push event to show it. ----- **It requires** HTTPS and manifest.json file. ----- I can give you an example of my app (it's on ruby, but simple). * Server side: https://github.com/violarium/ruby_moon/blob/master/app/services/notification_sender/webpush_sender.rb#L28-L32 * Client side (service worker): https://github.com/violarium/ruby_moon/blob/master/public/serviceworker.js#L48-L61 * Client side (subscription for web push): https://github.com/violarium/ruby_moon/blob/master/app/assets/javascripts/serviceworker-companion.js#L5-L12 * My manifest.json: https://github.com/violarium/ruby_moon/blob/master/public/manifest.json Materials which I've used and which could help you: * Google have good documentation for client: https://developers.google.com/web/fundamentals/engage-and-retain/push-notifications/ * About service workers: https://developers.google.com/web/fundamentals/getting-started/primers/service-workers * This is blog for full integration: https://rossta.net/blog/web-push-notifications-from-rails.html ----- Some tips, which I've discovered: * Google Chrome does not need gcm registration anymore * Web push can send only plain text, but you can send json and decode it on client (within service worker) * You can define how notifications will work in service worker right right away or you can make flexible notifications according to received data * You can debug service workers with google chrome * Do not digest service worker file with anything like service-worker-12387623487234.js - browser has own mechanism to update it, also it just could register 2 and more service workers for one site. * If you really can't do it on php, you could write simple script on ruby or nodejs to call them to send notifications. 
PGP.
I think that is a terrible idea. If you start changing the global functions around, you'll just end up having the same mess as Python has with it's 2-&gt;3 transition. The user base will be fragmented with adoption of the new major version hindered. I don't see that it's worth the pain. It feels a bit like https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/
I've been wanting to get off of running Apache and MySQL directly on Windows 10. A VM is a solution but a bit heavy, while dockerized applications are supposed to be simpler to set up, and re-set-up given a docker file. Been starting to use https://github.com/webdevops/php-docker-boilerplate to set up a per-project environment. Still figuring things out, but I really like the concept. Hope to get a couple of projects (one WordPress, one not) running within their own Docker envs this weekend.
 "This vulnerability allows an unauthenticated user to modify the content of any post or page within a WordPress site."
I think so. I still look up many string and array functions after 17 years of programming in PHP, because of: - Argument order (especially for string functions, like strpos) - Function changes variable vs. returning changed variable (especially for array functions, like sort) This pain never goes away for most developers, even if you can remember the most important functions you will still continue to look up many others which are less frequently used.
Ok, I clicked. To find out what the THREE earlier tutorials about.
I look up functions in C and C++ all the time (my most common other languages). Do people really not read the manuals (or in the case of C/C++ the source definition) routinely? Hmm... 
Thank you for all your work on this!
No it certainly isn't auto generated code, its hand written, I know the agency who did the work, they've been working on the code base over a 5 year period
Nope its all been hand written I know the agency who did the work, they've been working on the code base over a 5 year period
I see your point, it *is* down to the devloper at the end of the day, the problem is PHP *allows* this kind of stuff where statically typed languages its much harder to
How about scalar objects by Nikita Popov? I think it's 10x better than static methods.
Absolutely amazing, the stdlib is a hot mess of inconsistency.
They already are
No. Just no. Have a look at their Privacy. They gather an intense amount of user data. They sell that data. In the hand of your competitor(s), you sold yourself cheap.
I think that's a separate discussion. Some legacy functions might go there, but most cannot.
&gt; I don't believe people write 12,000 line long controllers. A different department from my last job (yes I am removing myself from this monstrosity as much as possible!) had an admin panel where the index controller was so big it would choke out any IDE. You had to open it in Sublime and it still struggled like crazy.
Unsure whether the complexity of an entire virtualization system is worth slightly less flexibility or slightly more time to test.
how would a statically typed language stop you from making a file with 400 lines in it for no reason? 
Doesn't your IDE cover all of that? When I type in a function call, not only does it popup a list of functions with that string in them, it also shows their expected args and return. Don't get me wrong, I still Google stuff from time to time. But certainly not things like arg order or return type. I usually don't even need to search function names, because of the suggested functions list that populats as you type. I'm more likely to Google flags such as those used in date formats, and to find out what versions of PHP contain a given function.
The RFC has been around for a while and doesn't really seem to have gained traction. Any time the issue is brought up people just say "we should have scalar objects instead". But that discussion has been going on for years with no progress on either side. 
It is the song of our people! 
&gt; PHP allows this kind of stuff where statically typed languages its much harder to That's not the case in my experience. A while back I inherited 2 vb.net apps and the code was atrocious, worse than your examples. So much copy paste you wouldn't believe it, SQL injection vulns, etc. I grant that, because it is easier to start with PHP, it's more popular so there are more examples of bad PHP code out there. But there's really nothing about the language that inherently makes anyone more likely to write shit code. 
It'd be extremely generous if I were to take credit for *even 0.1% of the work* that /u/jedisct1 has done here. He's the one that deserves everyone's thanks for taking NaCl and making it into libsodium.
Sounds about par for the course.
Damn thats nice. So something like a official Composer package that is dropped at version 10.
Someone above mentioned using a package to create the old functions in PHP9. So PHP could create an official Composer package as a fill in over the course of the entire 9 series and then drop it at version 10.
As long as current functions are preserved while new namespaces are added, I am fine
[This](https://github.com/wcgallego/pecl-gearman/) is now the official repo (which supports php 7). pecl just hasn't been updated so you will need to compile it yourself. 
I had a server admin badger me why I'm NOT using Wordpress, well, until I pointed out a 3 mile (exegerated) long list of current security issue's. Needless to say he started panicking, lol. 
Amazing! I'm really looking forward to this. I have noticed this sentence "We don't need crypto_aead_aes256gcm since that's provided by OpenSSL". Now i assume that libsodium is compatible with other bindings for other languages, is that correct? https://download.libsodium.org/doc/bindings_for_other_languages/ Wouldn't it then make sense to still include crypto_aead_aes256gcm in libsodium? For compatibility sakes? Even if the OpenSSL implementation is compatible with the libsodium implementation (Which i don't know if it is), wouldn't it still make sense to include it there? Could you give me your opinion about this? /u/sarciszewski 
One of the goals of the RFC was to slim down the API and only include what was necessary. Because OpenSSL provides aes-256-gcm, we can eschew that endpoint. In an earlier draft, we also eschewed chapoly. But [Noise](https://noiseprotocol.org/noise.html#introduction) requires one of the two, and ChaCha20-Poly1305 isn't provided by OpenSSL, so we included that. Noise support is necessary for e.g. integrating with encrypted chat applications like Signal or WhatsApp. The end goal is to make `sodium_crypto_aead_encrypt()` provide a CAESAR finalist (probably NORX).
hahahaha, touche! I disagree with js "there’s a stackoverflow question for anything you ever want or need to build" ... there's been times I've needed to implement something in js and cannot find anything other than SO answers that say: "just use *this* library" and then you go look at that library and it is the literal worst/naive implementation...
According http://stackoverflow.com/research/developer-survey-2016 it looks like JavaScript + Node.js are very popular and their popularity is growing. Maybe you were creating something totally awesome. I don't want to say, you're wrong, nor you are right. I think, your own experience is not enough statistically significant to represent whole web development community. In other words, it is subjective. But I certainly agree that we look at this world through our own eyes and each of us have own experience. 
Supervisor is great. 
Actually in almost every way..the language is mature, well proved over time, 84% of all websites are made in PHP starting from small to enterprise. OOP has evolved greatly since php 5.3..but mostly it is an intersection between quality, performance and price. You can develop a php backend almost 10 times faster than in Java or .net and it costs a lot lot less. You have a plenty of matured frameworks and thanks to packagest and composer you have 3 814 793 095 packges installed almost 200k of ready made solutions for you. So if you are thinking web PHP is the logical solution..and one of the biggest pros or cons is that you can develop a site after 1 day of reading tutorial :)
This is just a plain legacy code..no one hopefully will produce this nowadays :)
the most important difference: * runs on a browser also: * needs a transpiler (babel) to not suck completely * has 200MB hello world projects
Sorry, I wrote "version" instead of "branch" in the title, and I can't edit it, now. I see on php.net that you can download 5.6, 7.0, or 7.1. Aren't they developed and maintained as separate branches..?
How else would you manage to do further development of 7.0 and 7.1 paralelly? If there is a need for more 7.0.x releases, branch is the only reasonable way to manage its source code and e.g. backport 7.1.x fixes. Edit: to elaborate - 7.1 contains new features which are not and will not be present in 7.0 - in obvious way they don't share exactly the same feature set and thus codebase, which is why two separate branches are required. Let me know if you find my answer unclear, I'll try to come up different explanation
I'd suggest https://github.com/php-enqueue. Could be used as job queue out of the box. There is a job queue extension (https://github.com/php-enqueue/job-queue) which works over any Enqueue transport. It has some extra features like * Run unique job. Make sure there is only one such jobs is running at the same time. * Sub jobs and their status handling. * Job status and details storage. I am the author of the library. 
use Foo\\{Bar, Baz, Fez} but i cant for the life of me find a source right now...
That's still terrible...
Yup :D
I understand what you're saying, but I don't agree. You can manage to do further development like any other software in existence: you don't have to _release_ a branch in order to work on it. Did Microsoft release Windows Vista in order to work on it while Windows XP was the official version? I don't remember that happening. You can branch the repo, then merge the change. I don't see why one would have to release something in order to work on it.
Ah, got it. Is there a reason to always try to maintain 3 versions? If there are no breaking changes (which would cause a major bump in the release number), I don't see why they would need to do that. Weird.
&gt; Python3 is great, no python2 isn't dead, there is a lot of projects that are currently under development using python2, and it's not a problem, new projects will use python3. Python 3 is going to be a decade old next year. People are *still* arguing over it and some new projects rely on Python2 libraries which mean they end up writing Python2. Maybe it'll end up being resolved naturally after a while, but I'd rather not have that happen to PHP for a decade
&gt; async in PHP is easy Are you referring to pthreads?
I think if you already use Docker and/or Docker-Compose, also for PHP development, my solution with the Dev-Env help's a lot. If you don't your way is also okay.
There's always a way, I found this on the main site: http://php.net/manual/en/sockets.examples.php Otherwise you could check out Node.js, that's good for services that need to be on 24/7.
&gt; when do we... you know... stop cramming everything into the global space When there is a plan for what namespaces should be used, what old stuff should be migrated, how clashes with existing userland libraries should be minimised. For example (copying+pasting Nikic) The php-ast extension could reasonably be namespaced as php\ast, as it provides an AST for PHP specifically. Similarly the tokenizer extension could reasonably be namespaced as php\tokenizer. Extensions which are not of this type should not live in the PHP namespace, because they don't have anything specifically to do with php, apart from the circumstance that they happen to be bundled at the current point in time. &gt; when do **we** So you are going to help to craft that plan? 
Yes! Install GnuPG on your computer and create a key pair. Then encrypt the files with your public key, using the GnuPG PHP extension. http://php.net/manual/en/book.gnupg.php
Things you do if you really hate your job.
7.1 adds features 7.0 doesn't have. If people are using 7.0 and don't need those features of 7.1, but both have a security issue or bug that needs fixing you will see 7.0.x and 7.1.x get updated. PHP has always been a language that hasn't forced you to instantly upgrade to the next major version if you don't need or want to. If you're still confused, take a look at [this page](http://php.net/supported-versions.php) and call it a day. ps: your windows xp/vista comment doesn't work. they released vista, while still supporting xp at that time. didn't stop them from fixing bugs and security issues.
w0w
&gt; Did Microsoft release Windows Vista in order to work on it while Windows XP was the official version? I think we might just misunderstood here. No, Microsoft did not release Vista in order to work on it. They just released Vista as their new product and worked on two active versions at the same time, just like PHP here. Both PHP 7.0 and PHP 7.1 are supported branches (in terms of software releases and in terms of VCS as well) - because tell me, how else do you imagine workflow for more than one version? How would you make new commits to 7.0.x line while 7.1.x is your most recent release?
https://laravel.com/docs/5.4/queues
&gt;So you are going to help to craft that plan? Well, that sounded condescending. What are you implying? I'm/We're not to suggest anything without being a part of internals? ***We***, the developers, use the language. We're a part of the ecosystem. So yes - WE. Unless you want phpinternals to just shell in, plug their ears and go "lalalala"? Most of us already write our code in such a way that it's namespaced properly, and when we include a 3rd party package, it's usually a joy to work with. Using e.g. Guzzle vs poking our eyes out with curl_* is like... liberation. We need consistency in naming, and we need consistency in functionality. I still hate that we have curl_errno(), json_last_error() and the like. I mean, PHP is a mature language, and I really hate seeing it have such a mishmash of inconsistencies and weirdness. We still have a Procedural/OOP succotash with yada_yada_insert() on one hand, SPLYada::yadaInsert() on the other. It's a pain and everyone knows it. In a nutshell, if we can do json_* and curl_* and whatnot, then we can do json\\* and curl\\*. If we can have these new functions, then MAYBE we can set a rule in stone that says NEEDLE FIRST, HAYSTACK SECOND, for Pete's sake. We can have all current functions become deprecated as of the next major version, and then removed after that (which will take years), and by that time most people will have migrated. What most people agree on is that PHP doesn't have a clear agenda for the future. So, what better way to create such an agenda than by going to the people who use PHP and asking what's up, what's going on? I don't know exactly what would be the best decision for a nice PHP cleanup ( https://www.reddit.com/r/PHP/comments/5t7k2h/php_internals_discussing_an_idea_to_introduce/ ), so let's ask around and share some ideas freely without going "are you gonna do it?". But honestly, I'm just really excited that we're actually discussing this and that it's an actual topic. Most of the time I had to read these discussions under the "WHY PHP SUCKS" topic names.
I never claimed to be an authority. I'm just trying to understand something, I never said it should be done any other way than it is. Are you an authority? What have _you_ accomplished?
PHP 7.1 has breaking changes, mainly things that were deprecated in 7.0 have been removed in 7.1, and some things that weren't deprecated now ARE. They don't have to "release" 7.1 but it allows people to get a jump start on updating their code base to be compatible, while continuing to fix bugs/security fixes in 7.0.
I figured. Thanks :-)
https://3v4l.org/ZKOCI Fix: use \true and \false :) 
we are working on it a few days after I posted this rant about him I realized he has a degree in Electronic engineering, and that's why he has no idea about software development and the only experience he has is working with VisualBasic 6.0 on his last job. He told me he decided to find a job as a software developer because he likes it I've been trying to teach him since then, he is been learning PHP, HTML, CSS Javascript and SQL, but it's a lot to process so it's gonna take him a while.
Not redeclare, but shadow. As /u/boast03 showed, the originals are still there, just hidden by the `use` declaration. 
Just imagine the kinds of construction, electrical work, plumbing, and other such physical work gets done that's equivalent to this programming mess. Everyone is at varying skill levels, and from time to time, you'll see examples of work from those who have a lot to learn.
So let's say you have 7.0 installed and discover a bug. Somebody fixes the bug with a nice simple patch. In the current model, that fix can be applied and a new release called 7.0.1 can be cut which is identical to what you're running apart from the bugfix eing added. If PHP were simply a linear continuous development, then that fix would have to be applied to the current 7.1 state and you'd be forced to upgrade and pull in a LOT of new code that might potentially break your site for inexpected reasons. You're welcome for the clean and easy bugfix path.
Because there are [breaking changes between 7.0 and 7.1](https://php.net/migration71.incompatible). Every single time there are some breaking changes or syntax related new features, the minor version is incremented and a [migration page](https://php.net/migration71) is produced. The previous minor release is then maintained for security and bug patches based on the [support lifecycle](https://php.net/supported-versions). ie.: 7.0.x will be under active support till 3 Dec 2017 and under security support till 3 Dec 2018. &gt; Each release branch of PHP is fully supported for two years from its initial stable release. During this period, bugs and security issues that have been reported are fixed and are released in regular point releases. &gt; After this two year period of active support, each branch is then supported for an additional year for critical security issues only. Releases during this period are made on an as-needed basis: there may be multiple point releases, or none, depending on the number of reports. 
You can run gearman with PHP7 just fine, however don't use pecl but something like `apt` for installing. Beanstalk is typically my second pick.
ok
&gt; Are you referring to pthreads? &gt; No. &gt; lol. No. I just wrote the summary based on *that* article author's research. Comparing to golang - golang have way much easer async/non-blocking/concurrent mechanics. I don't want to start one more holly war, and the article doesn't look like all-round detailed research on async topic anyway, so I'll better just shut up now. 
I think that will be repeating the same mistake. If you don't have a plan from the beginning you will get the current situation once again, but with namespaces instead. Imagine putting a new class into \Foo\Bar and later realizing that lowercase should be used. You start add things as \foo\baz and have both \Foo and \foo. The current situation.
Thanks for sharing! You can additionally add a note to your README file how to use these containers as Bash/Zsh alias. That's my way to use the PHP tools everywhere from CLI.
This will depend on who is running/hosting your site. For a small volume of notification email sent to yourself, they may allow you to use [some built-in functions](http://php.net/manual/en/function.mail.php). For a massive email marketing campaign to a giant list of possible customers, you'll want to do something different.
Keep at it. When he picks on, you have a coder who produces compatible code. You'll know when you implement a helper he made and guess a method it uses and you guessed right, because he builds his code as you would've. That's a cool moment. 
You can use Amazon SES for sending emails like this.
You need a webserver and get all of this into your root. Depends all on wether you run Linux or Windows. For example if you run Windows you would need something like [XAMP](http://www.tutorialspoint.com/articles/run-a-php-program-in-xampp-server) and put it in htdocs. If you run linux put it in /var/www . 
Guard doesn't require a form implementation at all, you can decide how to fetch the details from the request and process them. If you want to make an re-usable login system, use the firewall config and create a factory etc.
For starters, never confuse null with empty with 0, they are different. For empty/0 you can just check if it equals ''/0.. for null you can use isset($var['field']). I'm no developer though, so there may be a more widely used/better option
Instead of moving the core functions out at a later version, move them to a PECL package so people that want the BC layer, can keep using it as they please.
Php has async? Or are you talking about ajax? 
It is really not easy to summarize all my experiences of recent years in a short reddit post. CakePHP 3 is far better then Version 2. I love the new CakePHP 3 QueryBuilder, it's great! My problem is not a directly a technical thing, it's more a question about the right MVC philosophy, ecpecialy the "Model". A separation of concerns (SoC) dilemma in Cake models. In Cake there is a 1:1 relation between a model class and a table. This is quite easy and simple for everybody. But if you have really complex buinsess logic (multiple data import/export interfaces, reports, statistics,...) then this philosophy can break youre neck. The world is not flat. In complex applications a model class (e.g. Customer) can become quickly large (after weeks, not only after years). I'm talking here about more then 10k lines of code per class and even more. Yes this is a so called "fat model", but thats also a very bad class from a maintaince perspective (please don't ask scrutinizer about it). Then you have these callbacks per model (afterFind etc). With the time there is a growing terrible mix of concerns. The code becomes unmaintainable. My wish is a new thinking about the model as a "layer" and not as a class. The model layer can be fat, but not the model class. Complex applications needs a Service layer (for the specific business logic). The Service layer is invoked directly by the Controller. Of course you could implement such a Service layer yourself, but this is far away from the Cake philosophy. https://www.bennadel.com/blog/2379-a-better-understanding-of-mvc-model-view-controller-thanks-to-steven-neiland.htm
Yes, with an internal counter.
Yes, it's compatible. https://gist.github.com/paragonie-scott/bb852d8f5462635f4a181f7843799a90 Run that code on PHP 7.1 with PECL libsodium 1.0.6 (and the underlying library v1.0.11) installed.
A minor version bump should not break your site, that's the thing. I see the point, though.
They really ought to do a full rewrite. That code looks like garbage. And they should do so using one of the many established frameworks like Laravel, Symphony, Cake, or even CodeIgniter3. They would probably get some more contributors to the code if it didn't look like trash.
Eh, I use it at my company. What's the alternative for getting a site out quickly at a low cost? Don't get me wrong, I think the code is garbage, but everything has security issues, not just wordpress. One of the bids we got for our site was from a guy who told us not use wordpress cause of security. When I asked him what his plan was he said he was going to roll his own. I stopped him and said "so you don't think your custom CMS will have any security issues?" yeah... everything is insecure.
Ill look into it in more depth shortly
ugly AF
I specifically mentioned that you have to look up functions in the manual much too ofter even for simple functions - because they have idiosyncrasies and therefore don't make much sense in terms of argument order and behavior. That is bad for every programming language, because it just reduces productivity and ease of use.
empty() var_dump(empty(NULL)); // true; var_dump(empty('0')); // true; var_dump(empty('')); // true;
[removed]
&gt; Is every post-audit commit going to receive an audit? After the audit, there will be no further releases until the subsequent changes are audited. Which means dev-master might change, but v1.0.1 won't be released until we get a +1 from security researchers. &gt; Are people who insist on having an audited version only going to be able to use versions that have been audited? With all likelihood, there will only be a v1.0.0 and that's what people are going to use. I don't foresee much changing post-audit. &gt; What about FIPS certification? I'm not even going to pursue FIPS. They only allow NIST ECC, AES, and SHA-2. &gt; Is libsodium even FIPS certified? No, libsodium uses cryptography that is actually constant-time when implemented in software and doesn't force implementors to avoid invalid curve attacks.
Click on the performance tab to see the real problem.
If the field is an on/off/unset switch consider using the inverse ``` WHERE field_name != 1 ```
you need to consult the php manual for both
and your self!
Performance time is perfectly normal. As in, there is no problem there.
Ok, let me give you a tip: You login to your youtube account, then you select this video and delete it. You have no idea what you are doing and your code looks like something you'd read in a PHP tutorial from 15 years ago. You are demonstrating terrible and insecure spaghetti code here for one of the most vital parts of your website: - You are passing POST data straight into the database, without any attempt of filtering or validating it. - [mysql_real_escape_string() does not protect against SQL injection attacks!](http://stackoverflow.com/questions/5741187/sql-injection-that-gets-around-mysql-real-escape-string) - You are not hashing any passwords - You are not using prepared statements - No concept of methods or classes in your code - You 'echo' out your login/account errors after the closing &lt;/html&gt;, instead of passing it into a message class and picking it up inside a formatted &lt;div class="alert alert-info" role="alert"&gt;...&lt;/div&gt; block or so that is already available in bootstrap - php logic and HTML all in the same file, no separation via templates - Typically the email is also the username - Inline styles attached to html tags like it's amateur hour - You are using the &lt;br&gt; to 'make some space' on your login form - my eyes are bleeding! - &lt;strong&gt; goes inside &lt;p&gt;, not the other way around. - Blindly including the full bootstrap stack with jQuery (and of course custom fonts!), even if you don't utilize any jQuery functionality on your pages. And what does your conn.php file and your db look like? What charset are you setting for your db-connection? What charset is declared in your DB table? Hoe do you deal with mandarin, japanese, greek or other non-english input? 
Same here. I think `Error` will fit.
This won't return null records.
Assuming you don't want any whitespace in there, just use: trim($word)
Nah man var_dump is way more useful for debugging than echo
Yes he did. &gt; Just "die" or "echo", at the right place, do a lot. And then because we're all humans that echo or die sometimes is not removed afterwards. I think I don't have to tell what are the consequences. And to give some more context, debugging is not only "displaying values of variables". Discovering the code by controlling it's execution is just as important. Especially when code was written by somebody else.
&gt; Another debugger I've used is the one that comes with Eclipse, configuring the php interpreter. You can also configure for debug the IDE that I'm currently using, phpStorm. So they do use a debugger, but they're not aware it's actually xdebug? 
 var_dump ($massiveObject); &gt; Firefox has stopped responding and will now be restarted.
We added a rule to our CI for that. :) There's no good reason for "die" and "var_dump()" to be inside source code.
Don't use "massive objects"?
With DI in use, which I assume your are not suggesting people don't do, objects are often nested many layers deep when you `var_dump()` them. My approach would veer towards not using var_dump().
was hoping I could avoid containers. I ended up slapping all my routes in index and it still doesn't want to work. Returns 404 for some reason :P 
🤔 Faster than PhalconPHP? https://github.com/leocavalcante/siler
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
First, I'm sure you're an smart and productive PHP developer, because I've been lucky enough to work with some great developers that love vim as an IDE, or other great ones that work from windows and are able to bring up linux VMs for what's needed, for example. 1. If we're talking about that var_dump(..) or massive printlining (output "all the info" at some point) **is enough** for most projects because that requires no setup for debugging tools, then we have a problem of setup that should be addressed -you, the community, the tools, I don't know-. And come on, it's 2017 (just joking) and I remember Borland Turbo Pascal 7 having an integrated, interactive debugger for a reason. 2. I don't want you to use a php debugger to understand what some code does because you assume it's a mess, but for productivity and well, to be able to control code execution that could have been written by the current team, or maybe is just a not very nice code looking legacy project. If you're OK your way, go ahead. But at some point I think you'll say "this code is a mess". You know-how, needed and used a php debugger for a code mess, not for all other projects. Ok. I care about productivity and the code that goes into the repositories, not the OS you prefer, tools, etc. but anyway as **diwipl** said at comments, we're humans and tend to leave by mistake some var_dump/echo over there**. You don't have to remove code that you didn't put in first place. 3. Nice code snippet for **printlining**, not for interactively controlling code execution using a **debugging tool**. Stuff like [Kint](http://raveren.github.io/kint/) is also nice. I insist, some people (I'm not saying you) have a problem with semantics in "debugging". Logging, printlining and using a debugging tool are different things, but all for "debugging". It's explained [in this book page](https://github.com/braydie/HowToBeAProgrammer/blob/master/en/1-Beginner/Personal-Skills/01-Learn%20To%20Debug.md) and that's what I wanted to put into debate besides the interview stuff. 
I'm going to disagree and say no, he didn't screw it and I wouldn't hold it against him if I was interviewing him for a position in my team. Don't get me wrong, debuggers are great (I loved my debugger when I was a Java dev), but I score the use of a debugger as low as it can be in the list of skills I want in my team (I consider not using an IDE a bigger red flag, but one of our best and most senior developers uses vim and nothing else... Personal preference I guess). I don't remember the last time I used a php debugger to be honest... The fact that php debuggers don't (or didn't?) work out of the box is definitely a factor, and they can be very tricky to configure (particularly if you are not using bare php and you have a vm, docker or something else in between your editor and your php interpreter). The other thing is that die, echo, var_dump, or other framework specific debug tools can get you a really long way, and they always work, no matter what the setup is. I personally replaced a good chunk on 2 in house ORMs with Doctrine 2 in a very large 10yo codebase with just the standard debug tools... And while a debugger would have been handy, I didn't feel it was a requirement. Are you sure you are not being a bit snobbish with this interviewee? It seems like a very harsh judgement. People have vastly different work flows and tools they like, and that's fine... As long as the code they produce is good, this shouldn't be held against them
If you think this is reason alone to not employ a decent developer, I wouldn't work for you, either. You said it yourself, not everyone is perfect and just because they haven't used the same debugging practises you have used in the past, doesn't necessarily mean they won't be productive. I honestly think your getting too held up on this, it certainty wouldn't be a deciding factor for me, assuming there were otherwise good things said by the developer that matched your expectations.
Nah, I get your point. The position was filled with someone that didn't use debuggers before, so perhaps I'm looking too picky on the issue being a requirement, but it wasn't, really.
Thank you for being the voice of reason, I feel the exact same way as you. 
1. The no-setup part is only an added bonus, the tooling is here and work pretty well, xdebug is a must and so is `error_reporting = -1`. PHP has come a looong way and so have the tools, I'm glad to know I can have an interactive debugger but in 99.9% of the time, it's not worth the hassle. 2. Humans tend to leave `var_dump` by mistake, proper CI, linting, and code reviews don't. It's a matter of productivity, I'm more efficient if I can rely of my understanding the code and having an instant result after typing `idlv &lt;ESC&gt;:w&lt;F5&gt;`. Debugging is overkill most of the time, it's more mental overhead, it breaks my flow of thoughts, it requires more tools, it's not worth the time. That's a matter of taste, if you like debugging, it's fine by me, I don't consider you're a lesser dev for doing it one way or the other. The point is that not using a debugger when working with PHP is not a red flag, not knowing the tools exist might be one, not having tried ^^^[1] to use them once is a concerning lack of curiosity. ^^^[1] ^^^Sketchy ^^^grammar, ^^^feel ^^^free ^^^to ^^^correct ^^^me ^^^on ^^^this ^^^one. 
I just worked through that, and it was way harder than it should be. If you want to have them in a separate file, but NOT in a class, make sure you namespace the file correctly (Slim). The easiest thing to do is create a new class that contains the routes for a certain function. In your index.php file, have $app-&gt;group('/pages', function () { $this-&gt;map(['GET'], '/{unit}', 'app\controllers\Pages:get_by_unit'); $this-&gt;map(['POST'], '', 'app\controllers\Pages:add_new'); }); Then I have a page called pages.php, first line is "namespace \app\controllers" and a class called Pages. In there, I have the functions for my routes, function: add_new(\Slim\Http\Request $request, \Slim\Http\Response $response){ *stuff* } 
1) Did you declare global $app; in Employees.php? 2) Including Employee.php must be done after $app is declared in index.php And if you are doing any of this, you are probably approaching the problem the wrong way. I used Slim on a project with tons of end points and I ran into the same issue. I ended up creating a wrapper class to build the $app and create all the routes. The route methods call other classes where the application logic is tucked away. I think slim encourages you to put the routes in the index for clarity. 
I occasionally write C#... and if you're using breakpoints and variable watching to debug your code, you're already in some deep shit.
I've done a ton of dev interviews from both sides of the table. I don't exclude people from hiring because they don't know a tool I'm familiar with. I make a note to teach that person about the tool and convince them why my way is better. Sometimes there's a legit reason they don't use a common tool, like a debugger. The best part about this approach is that you sometimes learn about some tool the other person uses that you haven't come across yet. I hate when I've been interviewed and get rejected for not knowing how to use a tool. You're not going to find someone who matches your requirements. I bring skills you don't have. Help me learn the skills I don't have. 
That is what I ended doing, filling the position with someone that didn't debug before, but wanted to learn. Also for the skills he has and I'm sure we can learn things from each other.
Thanks for the examples. I think it's not only enterprise stuff. A colleague at another company complains about he's the only able to debug in his team. They're not doing precisely "enterprise", nor sending mankind to the moon... But he's the one at the team who ends interactively debugging someone else shit when several hours are wasted trying to figuring out stuff. (Nonetheless to say that he debugs his own shit).
It *shouldn't* break your site, but it does introduce far more variables and more opportunity for *unexpected* breakage. We're only human, after all. :)
That's what I get for not caring about Doctrine until this year.
I'm the only person on my team that uses Xdebug. It did take a while to get set up the first time, but I don't understand how they get by without it. dd-ing just seems so inconvenient and clunky. A debugger is useful not just for fixing issues, but also monitoring correctness in every iteration of a loop, for example, or following program flow to ensure it's what you expect (especially useful in frameworks where you can end up with a huge callstack before you even arrive at code you've written yourself). Not to mention the amount of 'dd' calls I've found mistakenly left in production code on infrequently used code branches. 
HHVM its an independent language who don't need no implicit namespaces.
Implementing LTI in php is fairly simple (or, more accurately, can be :P) If you're looking for Moodle -&gt; Tool look at implementing csev's php lti implementation. I have a quick harness at https://github.com/kingmook/sup_sim_lti_php . This doesn't include things like checking nonces, but will get you started. If you're looking for Tool -&gt; Moodle check out the LTI moodle provider plug in at :https://moodle.org/plugins/local_ltiprovider Like previous posters have said, godspeed working with moodle. 
Oooh, as a newbie C# programmer I would love some elaboration on this 
&gt; What I use when a page is slow is Zend's debugger or a Firefox plugin to find bottlenecks. Zend's debugger is analogous to Xdebug, so basically he is using debuggers. Anyway, we have to be honest, there are different types of situations that call for different types of debugging. I always have xdebug working in my dev server and tooling, but I also have a "debug log" where I dump various environment information, including variable state (i.e. fancy var_dump, if you will), and I need both the log and the debugger, in order to debug most efficiently. This is not a heresy, and most platforms have both some form of interactive debugging supported, and also debug log supported. It's not a "choose one" question. Also some people have no idea how to set up Xdebug to run "just in time" which means they can't set up the proper environment for their debug sessions, and this is why they feel it wastes them time. This is correctable with one hour training (or less). If there's anything damning about the answer OP got is that the candidate sounds a bit dim in general. Or young and inexperienced. One of those. Depending on whether you're hiring a junior or nor, that may or may not be an issue. 
If you're using this, then you don't really have a clue what's going on in your code, or you've complicated it to the point where you're lost, or you're debugging somebody else's code. All stated scenarios mean you're in for a headache. Any time I've used these features means I've hit rock bottom and I've had nowhere else to turn to. If you can't decipher what's happening from the code by looking at it and diddling with unit tests, you're already neck deep and you can kiss your KISS principles goodbye. It's a perfectly fine and respectable way to debug your code, but I've mostly used it on other people's code and when writing an algorithm with tons of i,j,z,x variables I've lost track of. 2AM, complete darkness, and me pressing "step step step step" until maybe 20mins later I get an "AH HAH!"... yeah, that.
&gt; PHP is a server-side scripting language. It stands on **Personal Home Page Tools**. No. 
Nice idea. There may be a reason for it, but if it could be dealt with without using die() then it's advisable. 
I'm curious why you say a "full step through". That's how you feel when launching a debug session? That you need to "step through all the code"? I may have got it wrong. About "development through a debugger" taking more time than logging, I'm also curious what is taking so much time for you, since it doesn't seem to be the setup time of the debugger? 
That makes sense. If there's too much code to step through you use a debugging software. Thanks for the breakdown!
&gt; diddling with unit tests You say that as if you expect unit tests to be in every project you work on from the get go.
Do you have a github repo?
&gt; The fact that php debuggers don't (or didn't?) work out of the box What? I mean, sure, there is some configuration you need to do for remote debugging, but that's for a **specific type of debugging**. With most frameworks and such, sure, remote debugging is the only way you're going to do it, but xdebug also has the ability to run the script for you and debug as necessary. &gt; It seems like a very harsh judgement. I would say this depends the position you are interviewing for. If the candidate said he did something like Ruby's `pry` then that would make a little bit of sense - you'd get to get in to where the code is and poke around with a REPL. PsySH can do a lot of this, so I suppose that might be an acceptable answer, too.
If you want concurrency, performance, and scalability PHP is a terrible choice. So saying it is the best is just your opinion. With that said, I use PHP daily. But when it comes to critical high performance scaling web apps or APIs I wouldn't touch it with a 10' pole.
So you code everything directly on remote, staging servers, before going to production servers?
I switch between print_r and var dump. Print_r can be easier to read.
\Psy\sh() is a good friend to have.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
i use xdebug all the time, unless debugging simplexml objects. They always seem to segfault the php process. 
I agree with you and probably didn't mean it isn't used to "figure out what code does". But I probably wouldn't get my point across to OP if I said I've used it to find out what some complex logic does. They would have just responded that they didn't want to work with my company codebase. 
echo '&lt;pre&gt;'.print_r($o,true).'&lt;/pre&gt;';
Can you be more specific? If you run Windows, you can use a Linux virtual machine and run it locally. Does this solve your issue? If not, why not?
For a senior position, definitely but for a junior position, no. die or echo might be good enough when working in small scripts, but they sure as hell are not good enough when working on apps consisting of millions of lines of code (almost any app nowadays with its dependencies). The programmer should know how to properly debug things, how to properly profile things, and when each is needed. That's part of the definition of being senior. For junior positions, I'll be happy if they can write fizz buzz. 
A lot of people are also lucky enough to have one project to work on. At the moment my team maintains about 30 different projects for various clients. Good luck preparing a localhost development environment for each of the people on my team. It's far easier and less time consuming to give someone the SSH key to a working development environment. ^ you may have missed that part. I don't think that's a convoluted reason to develop remotely.
I'm not sure if you're serious. "Preparing" the virtual machine for 30 people in a team involves simply sending a file to 30 people, and telling them to run it. You also don't need a separate virtual machine for every project, as long as they run in the same environment, which seems to be the case here as you're using the same staging server.
I totally agree. I have been coding PHP/Hack for the last 15 years. I've used a debugger less than a handful of times.
There are definitely times when having an interactive debugger will save you a lot of time. And then having it available is a lot better than not having it. It is also almost always at least slightly easier than echo and die. So might as well use it instead. While I won't fail someone's interview because they don't use it, it could paint a picture of someone who doesn't spend the time to optimize his workflow, depending on other factors.
We don't have 30 people (I wish lol). Just over 30 projects. I'll just send you 30 x 2 - 140 GB VM files and you'll be in charge of keeping those up to date. Yes I'm being serious.
Can and should are two different things. 
What you're doing is definitely not a "should", so any improvement should be welcomed.
Obviously, this isn't secure encryption.
&gt; I score the use of a debugger as low as it can be in the list of skills I want in my team I can state, with a high degree of certainty, that both you are and your team are far less efficient then you should be.
Hi, I created a new theme for ApiGen, based on the website of ICanBoogie. Please have a look: https://github.com/olvlvl/apipgen-theme-icanboogie You can check it live https://icanboogie.org/api/http/3.0/index.html, although this version uses a different navigation to integrate with the rest of the website.
For parallel execution, maybe. But you're talking about async. The generators and socket support in core are sufficient for async IO and cooperative multitasking. 
If screwing things in fixes the problem, a debugger would be a power drill and echo would be a screwdriver. Sure the debugger is always faster and more powerful, but if you can't get the job done with a few echos, there are likely larger problems in complexity, readability and cohesion at play. I personally will generally opt to use echos for small things and a debugger for anything larger. Either way though, the end goal in a perfect world is someone who could read all code and understand it's issues instantaneously. Obviously that's never going to happen, but faulting someone on their preferred method of growing towards that end seems pedantic. Who cares how the problem gets solved as long as it gets solved in a timely fashion and with quality code?
Can you share your directory structure for me to make sense and learn? Always interested to learn how others structured their symfony application and why it is so. Thanks!
[removed]
I can vouch for this. Most of the time it's not because figuring out what the code does, but why it doesn't do what we want it to do. Eg. when a parameter to a function 'magically' changed its type or content making the function output different from what we expected, where is the optimal place to place the var dump/die/whatever. I much rather point and click (click breakpoint at where ever line i want and press the green play button) and step through it inspecting the relevant var/function (the act of knowing where to set breakpoints shows that you know your code, just that the code itself is misbehaving) rather than type and erase that line everytime, but maybe that just me.
I'm not saying it is wrong using a debugger. I know people that use a debugger all the time. I'm just saying that different people do different things. Just because you use a debugger all the time doesn't mean everyone has to use one to be good. 
Awesome! Looking forward to using this.
Honest question: why does it matter if it's in the standard library vs an add on? Seems awesome, keep getting better I like the direction php is heading.
Because everyone has the standard library available. There's no excuse not to use it. 
Lower barrier to entry, if only slightly. Crypto is one of those cases where you **really** want people to "do the right thing", so every bit of ease helps.
Please don't they have this intense hatred of php in that subreddit, most web languages actually.
Makes sense. In some of the other languages I've used they had multiple different crypto add-on libs depending on what you were doing. That's why I asked. I definitely agree in that the crypto is something you want done right.
Nice, didn't know you could do that, but I am disappointed: I tried doing `&lt;?php use const 2 as 1; echo 2 + 1;` but it didn't work
If i was interviewing this guy he wouldn't get any plus points for saying something like that, but i wouldn't see it as screwing up big time either.
In Symfony it's `dump($var)` - expected `die` at the end. Works in dev environment only (if you don't overwrite the settings).
It would be possible to make a PHP7-compat library that adds back all the old API's, so in practice it wouldn't be that big of a deal, except that you'd see that compat library floating around forever.
What is even the point in writing an "article" like this?
Let's say I will use crypto_secretbox to encrypt some data and store it. Then some day libsodium decides to change its default secret key encryption algorithm to something else. If I don't pay attention to libsodium changelogs will my application fail to decrypt that old data with crypto_secretbox_open? What will proper upgrade path look like in this situation?
It the installation of VM, Vagrant and the Image that takes the time. Composer, PHPUnit are fine once set up, but that initial setup and getting the fupping Networking to play nice with Windows 10 is what takes the time.
&gt; Then some day libsodium decides to change its default secret key encryption algorithm to something else. That's a breaking change, so unless you upgrade to a new major PHP version willy-nilly, you should be fine. Besides, I imagine that you'd be better off explicitly selecting which encryption algorithm you're using anyway.
&gt; you'd be better off explicitly selecting which encryption algorithm you're using anyway I think I can't do that with libsodium. Or can i? I think libsodium should include information about encryption algorithm along with encrypted data so it can be used in the decryption process. Or maybe it is doing that?
Yeah, separated things and both useful to "debug", but different than using a debugging tool like xdebug 
Simply put: That will not happen. It's compatible with NaCl which specified xsalsa20poly1305 and that ain't changing.
Its really nice, for the first time PHP actually is getting ahead of other programming languages, as opposed to the old time when PHP borrowed ideas or features already existed in other languages. It is a milestone, and hopefully PHP can continue to improve and shake off the bad reputation it has gotten over the past two decades. 
a true TDD developer (not myself) does not know how to use a debugger, because he doesn't need it... says uncle bob.. 
Going against namespacing for Sodium specifically, right now.
We haven't decided to add libsodium (the upstream library which the sodium extension wraps) as a build dependency for PHP, what we have decided to do is bundle the sodium extension. This does not mean that sodium is always going to be available: PHP doesn't decide what is going to be available, except for Windows, because package maintainers decide what default extensions will be in the base php72 (or whatever version you like) package, and what will be separate (ex. php72-curl). We won't know how widely available this will be until package maintainers make those decisions, or we have a follow up vote to have libsodium (the upstream library) as a build dependency of PHP and possibly turning the sodium extension into an "always enabled" extension (ex. date/core/SPL etc). It's great that this passed, but we should be clear on what we have actually done here ... it's not correct to call it part of the standard library at this time.
If you guys don't already do this, you should invest some time into getting a proper build process in place with Gulp/Grunt (I personally hate Webpack, though thats the latest thing in the JS world, and if you don't want to have to fudge around with node for your build process, theres https://github.com/reisraff/phulp which is a php alternative to gulp). Then I would take out jQuery and just start using plain JS. They have made a lot of strides with the language in ES6, and if you use babel, you can start writing classical JS instead of prototypical which is a boon if you have primarily PHP developers (This step also assumes that you have modern browser requirements and aren't still trying to support IE 9 and below). Another thing you could look into is breaking your application out into an API and then use something like Ember/Angular/Vue to build your front end and make it all ajax driven. Thats a huge shift though if you have minimal JS experience.
Okay, I was half-joking but the sarcasm was probably obfuscated by my confusion of terms here. Maybe it's not in the "compiled with absolutely nothing else" standard library, but if it's anything like OpenSSL since 5.3, it will be part of the de-facto standard library and that's good enough for most people.
What do you mean by "place all your variables"?
"I've never heard about libsodium before and so therefore it makes me scared to think about" - a conversation i've had with someone else professionally, believe it or not
I have made a build tool to help move towards new standards. Eg PSR2 or code covered by unit tests. It work by supplying both the output from the standards tool (phpcs, phpmd or phpunit) and the diff for the pull request / branch. Only if the code which has been changed fails the standards check will the build fail. For larger projects where the auto fix tools are not an option (too many non autofixable failures) or where test coverage is low, new code can be enforced to be a certain standard before merging, in the hope that over time this tool isn't needed and can just be enforced by the normal tools. The is a percentage option also so for example 80% of a pull request has to be covered by tests or 90% of the code submitted must conform to PSR-2. as this tool takes the output from existing tools, all of the normal options still work as they are expected in the original tool, for example turning code standards off or turning code coverage off for a certain method. https://github.com/exussum12/coverageChecker
Your [PHP SDK](https://github.com/tozny/sdk-php) could use some love by the looks of it. * Using old school namespacing in the class names. * All your methods are public and you're using an underscore prefix to signify private methods - you've required PHP &gt;= 5.3 @ composer level, so, why? * You don't support for systems with `allow_url_fopen` disabled as you're using `file_get_contents` with URLs. * You should be checking signatures in constant time via `hash_equals`. * You should provide and verify $crypto_strong when using OpenSSL. That's just from a cursory glance, I didn't go in-depth on your crypto usage.
It's a legacy SDK that is on the calendar for a refresh. Most of this is already on the docket, but I'll add the OpenSSL suggestion. Thanks!
I felt dirty and fooled after reloading the website. I kind of want longer discounts than 30 seconds. My timer was totally at 23h59m26s when i reloaded the website and got all the wonderful alerts. Where did my discount go? I was totally about to make a purchase.
&gt; Along with a thousand other 'get off the island' initiatives, the Drupal community has started to take dependency management more seriously, by integrating with the wider PHP ecosystem and maintaining a separate Drupal.org packagist for Drupal modules, themes, and other projects. Maintaining a Drupal-specific Packagist doesn't sound much like "getting off the island" ... ? 
I can't tell if this is a joke or the result of someone trying to flip a domain. Their design (and clients) looked a lot better a couple years ago: http://web.archive.org/web/20140517165658/http://niftycart.com/
It counts down
Yeah, I meant sometime in the future, obviously. Will take a while, there's still companies out there offering php 5.2.
You've failed to state a well defined problem. If you problem is "not enough buzzwords in my code" then it doesn't matter what you do. 
&gt; If we want a good parameter/command object we'd have to add a fluent method interface, or at least validating setters, and it quickly becomes a chore. Disagree. Fluent methods are a mixed blessing, and you still get a lot of benefits from the pattern without writing any validation code. Consider something like: class Product { public $name; public $price; public function __construct(string $name, Price $price) { $this-&gt;name = $name; $this-&gt;price = $price; } } You can now use type declarations to ensure your other functions are getting an actual `Product`, your IDE will helpfully remind you that a `Product` object has a name and a price, you know that the name and price exist and are non-null, you know the name is a string and the price is a `Price` object and that someone hasn't screwed up and passed you a float or the integer number of cents or a string containing "$5.00". Yes, you could add some validation to ensure that the name is an appropriate length or whatever, but that's icing on the cake; 95% of the benefits come without doing that. And if you use associative arrays, you get none of the benefits. And it's not actually any easier or faster.
&gt; You can now use type declarations to ensure your other functions are getting an actual Product Ahem... $x = new Product('Name', $price); $x-&gt;price = 'Nope, not really';
Try refreshing the page and see if you also break the discount script and get alerts().
Wack
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
... written in ASP.Net, posted it in /r/PHP... this guy is bold.
A reasonable amount I would say. We also have a lot of Integration tests and because I mostly touch core frameworks my code gets a lot of testing through other tests.
Have you considered writing some code? Or having an actual developer write some code for you in exchange for money and/or goods/services? Because that's how writing a program works.
sounds interesting. thanks
structs would be nice (rfc hint?)
I guess it depends on your platform of choice. I'm sure you can find some recommendations and tastes just googling a bit deep
because it also requires to install xampp and initialize the server 
Even if you just use classes with public properties, with no setters and no validation it's still better than arrays. Adding getters and setters should be handled by your IDE, it should take 2 seconds.
Outrageous. 
&gt; Even if you just use classes with public properties, with no setters and no validation it's still better than arrays. "Better" is subjective. If you just have naked objects with no getters/setters, you get property autocomplete in your IDE, that's better. It also causes useless empty classes to be loaded at runtime, that's worse. If you use objects with public fields, you save some RAM if you have plenty of instances of the same class (single hashmap), that's better. But you also have slower property access due to an extra indirection, and slower instantiation, that's worse. Can you see how engineering is about tradeoffs and not about making absolute statements :-)? &gt; Adding getters and setters should be handled by your IDE, it should take 2 seconds. I can confirm, all IDEs, including the one I use, generate getters/setters. Of course you also need to add the code which validates values in the setters. And again, if the object is well encapsulated (through said getters/setters, also fluent method chains) it can provide value, at the expense of all this extra code you have to write, and load at runtime. And again, some of it is generated yes, but a lot of it isn't. There are also other considerations once you start using objects merely for holding values. Things like mutability, which setters imply. These cause the dreaded "change from distance" bugs, due to the "by reference" nature of objects. This doesn't actually happen with arrays, which are "by copy" by default, including nested ones. And if you start designing your value objects to be immutable, then typically there's less support for that in IDEs, and you'll have to replace "setters" with "withers", i.e. instead of `$foo-&gt;setName($name)` you'd have `$foo = $foo-&gt;withName($name)`. This is not only even more code to write for the objects itself, but also more code to use it and mutate it (well, copies of it), and your solution is now even heaver than a getter/setter solution. Only to arrive at the level of stability that "copy" semantics provide, which arrays have by default. So, again, can you see how engineering is about tradeoffs? :-)
You hit the nail on the head. In a way we already have structs: arrays. We just need ability to type them, similar to Hack's shapes, and... maybe we can allow this syntax to work on arrays: $foo-&gt;bar = 123; // Same as... $foo['bar'] = 123; Which would be how JavaScript does it. The only thing which Hack's shapes are missing is optional properties (Hack doesn't have them AFAIK), which is a pretty common need. And it's not the same when you just set all those properties to null.
&gt; Personal Home Page Tools PHPT ? Did I miss anything?
This task is easily accomplished using: * an ORM (convert your database results into objects), for example [Doctrine](http://www.doctrine-project.org/) * and a serializer (convert your object into JSON representation), for example [JMSSerializer](http://jmsyst.com/libs/serializer) With those tools (there is a barrier of entry if you never used them) it’s a matter of a few config files and one method call.
Is `new ProductSearch` in an invalid state in your opinion? It represents `select * from product`. You may add more criteria to it using setters (or even pass a collection of some generic `SearchCriteria` using the constructor)
1. Download version 1.0.0 and its valid signature. 2. Vendor releases version 1.0.1 with a security fix. 3. You keep serving version 1.0.0 and its valid signature via MitM, then exploit the (now known) vulnerability. I call it a denial-of-upgrade. I was going to write a PoC that kept people vulnerable to Shellshock forever, but Linux's PGP signature dance prevented any straightforward exploitation.
Given that many Wordpress sites are maintained/used by non-experts the security of auto-updates should get more attention.
I'd naturally opt for HTTPS myself, but there are other solutions, right? Doesn't a timestamped signature accomplish almost the same thing (it doesn't prevent replay attacks, but does restrict the window of opportunity)? Or do I have that wrong?
&gt; If the "tradeoff" of a memory indirection is that important, you should consider using another language. You'll get much better gains from there. It's double indirection. Arrays are: `atom hashtable -&gt; value`. Objects are: `atom handle -&gt; object -&gt; shared hashtable -&gt; value`. It doesn't matter much by itself, but it adds up when you also throw in the slow-down of loading an extra file (for the class) and running the constructor. Now do this hundreds or thousands of times throughout the project, and suddenly it starts to affect your project's visible performance. &gt; Your point on mutability is good. In my opinion, objects solve a problem that's far more common than "spooky action at a distance": not having to grep through projects to try to find where things are set, used or to find possible values. You also don't have to play the guessing game of "is that set?" with objects. I'm not sure what exactly is that common problem you're referring to, but mutability is a very, very nasty and common problem, unless you specifically eliminate it through some of the techniques I mentioned. &gt; You can implement "with-ers" when you need them, only on the class you need them on, and you can refactor most of your code automatically. I'm not sure what you're trying to say here. If you'll be having immutable VOs, you have only two channels to configure an object: withers, and constructors. So you pretty much need them everywhere where VOs of some complexity are involved. Either this, or builders, which aren't any faster to implement. And refactor your code automatically... from what to what...? &gt; Using arrays everywhere just because you're afraid of spooky action at a distance is overkill, imho. I don't use arrays *everywhere*, but I use them. And if you aren't afraid of "spooky action at distance", then over the years you'll learn to fear it. Guess why PSR-7's HTTP message is immutable.
&gt; "Fluent" interfaces are a PITA to proxy/wrap though They absolutely are a PITA to proxy/wrap, although there are ways around this. But since here we're discussing using them for Value Objects, you typically don't proxy/wrap value objects. You only have one implementation which is good for most or all use cases. &gt; and you can't always validate just one setter when there are rules touching multiple properties. You can always accumulate rules that affect linked properties x, y, z in a method like `validateXYZ()` and then call it in all three setters, or you can have a combined setter `setXYZ($x, $y, $z)`. Plenty of ways to factor things to match your domain. &gt; I'd prefer a Builder pattern, where the last "generate" method pops out the data object -- or throws an exception if your choices are incompatible. Yup, I fancy builders as well, but now we have two extra classes and objects per method call in some third class. They multiply so fast, huh :-)? 
I just... love how everyone is keen to instantly start recommending exotic DB features, or heavy third party dependencies where you can read lots of pages of documentation, so you can then write plenty of classes, closures and YAML files, and maybe in a few days, you can have something working! Or how about this technique, I call it **A Basic Loop**: $out = []; foreach ($in as $row) { $id = $row['id']; if (!isset($out[$id])) $out[$id] = [ 'id' =&gt; $id, 'name' =&gt; $row['name'], 'posts' =&gt; [], ]; $out[$id]['posts'][] = [ 'id' =&gt; $row['post_id'], 'text' =&gt; $row['post_text'], ]; } echo json_encode(array_values($out)); 
If mitming the target is possible, wouldn’t blocking the update channel altogether have the same results? I guess there could be alerts if the security updates are not reachable, but in practice, are there?
I don't get what your problem is. You can simply create a class to handle the data and create tests with unit testing, then refractoring the code. I think I'm missing the point, maybe you are looking into something pre-built but again it depends on what are you using to show the charts and what type of charts you need to display...
Maybe one day we'll get something like https://wiki.php.net/rfc/propertygetsetsyntax-v1.2 into PHP. Didn't reach the 2/3 majority back then.
In that case, you can at least know that the updates are being blocked. Sure, not every server is capable of sending emails and big red notifications in an administrative panel can be ignored, but at least you *can* know that it's happening. This means that, if necessary, you can take manual action by uploading the files yourself by whatever means you manage your website. (even if it is FTP) 
1. /r/phphelp 2. [PDO::FETCH_GROUP](https://phpdelusions.net/pdo#group)
&gt; Uninstall WordPress everywhere. Migrate as much of the Internet towards a platform whose custodians care about security. If nothing else, we can limit the impact for when WordPress does go nuclear. Insanely unrealistic. Only option is #1. A slight #1b would be to lobby to WP developers and hosting providers of WP that they should raise pitchforks and contribute to option #1
This is an excellent approach if you have "large" amounts of data - using this approach with correlated subqueries or lateral joins (both do a similar job) you can create a nested structure multiple levels deep with 100s of thousands of leaf nodes in a hundred milliseconds or so. Though I expect suggestions like that to go down like a cup of cold sick in this sub.
&gt; Though I expect suggestions like that to go down like a cup of cold sick in this sub. In general when people ask about a problem, it's preferable to stay within the scope of the problem, which is: they have this schema, this query, and they need PHP code to convert one format to another. What PostgreSQL can do is very interesting, but it's naive to suggest to someone to change their database, their data schema and basically their entire architecture, to fix one of possibly tens of thousands of concerns (which we don't know) that the application has. 
I have no clue on how the WP internals work, but would a plugin be a viable option?
I would just implement controller strategy with mount method in slim.
So...is the pipe operator RFC dead? I've been tracking the internals mailing list lately, and it seems like some RFC get lots of discussion, then a quick vote, and others (like the pipe RFC) get a bunch of discussion....and then disappear. Is there a standard process in there?
I feel like I should be surprised, but I'm not. It's been pretty clear that Matt Mullenweg and his team are a bunch of people who are either too thick, or stubborn. This is why developers hate wordpress. It's such a terrible platform by an even worse company.
[See my comment here](https://www.reddit.com/r/php/comments/5tylhv/_/ddqbbad). tl;dr- doesn't matter, learning the exploitation and prevention of these vulnerabilities is language agnostic.
It's unfortunately true that a lot of devs have this attitude. I've gotten to the point that if your code sample has SQL injection vulnerabilities it's an immediate pass and I let the recruiter know that the candidate should not be interviewing for paid positions above junior. 
I appreciate your comment, especially since I see that i put this in the wrong sub. This is the obvious solution and one that I've implemented many times in the past. The main reason why I created the post was to explore those possible alternatives as well. Thank you
&gt; /r/PHPhelp You're right, I'm an idiot. Thank you for pointing that out. I don't normally post to coding subs and I neglected to check the side bar Thank you for PDO::FETCH_GROUP. It'll take a bit of time to look through the documentation for that, but I appreciate the point in a direction.
[VulnHub](https://www.vulnhub.com/) may interest some people as well. It's a collection of vulnerable VMs similar to this.
Really depends on the complexity of the project and the skill of the developer. As you can see, the comments below are already opposites.
Out of date - fails to cover exceptions and PHP 7's "thrown errors" (basically a form of exceptions)
Don't worry about what you're called so much. Concentrate on improving and learning at your own pace until you feel comfortable. Don't pressurize yourself. Titles like `Senior Developer` are always company-dependent and are relative to the view of the business. It simply means that you are fulfilling the requirements that your company has set for that given title. Your title does not say anything about your actual skill. A senior developer in one company, might not even get hired in another one. Try to do your best fulfilling your companies needs and learn the stuff you think you're lacking in your spare time (or work time if your company allows you to do so). You seem to have a great self-reflection and that alone proves that you're on a good way. Just identify the things you think you need to improve and set up a plan to actually improve.
None.
Pretty tough to claim to be a senior if you still grasping the core concepts of OOP, regardless of age/experience that still comes under the junior-dev for me. Quickest way to find out how you will do is to update your CV/Portfolio and send it off to see how employers react. Work out where the gaps in your knowledge are and go fill in the blanks. 
Im sorry great Sir. Show me the way.
I can build in OOP. I understand logic should go in the Model, the Controller will interact with the view/model to tweak things etc.
What kind of clients pay $60/hour for web work? I just can't imagine it'd be the typical "can you tweak my WordPress site" project. 
Maybe they hate PHP, because PHP is not suitable for implementing machine learning algorithms, which are very CPU intensive, and as of lately increasingly rely on GPU utilization. None of which are things which PHP does, really. Of course, if you'll be simply exposing an API written in something else (like Google's APIs), then it doesn't matter what language you call the API in.
a non free course promotion
There are various shortcuts one can implement and reuse, for example I'm using a data mapper library where the relationship can be described declaratively and then I can grab data from the database in the desired format directly. But it comes at a cost, and so it's more useful when the transform is much more complex, as a way to abstract it away and stop thinking about it. In this case, you'll achieve a similar effect by simply wrapping the loop in a function and calling it whenever you output this type of query.
my boss just wasted 180k on subcontracting shit out for 2 months. typical outsourcing result as well - scrap|rewrite.
Anyone have any good projects for getting more familiar with vanilla php? I'm pretty familiar with building out apps in laravel and WP but I feel like I'm missing out on job opportunities due to a lack of experience with vanilla php and writing apps from scratch. I'm looking at this [project right now](http://requiremind.com/a-most-simple-php-mvc-beginners-tutorial/) to just get something up on my github that shows I'm smart enough to figure out an app without a framework, but I'm open to suggestions. Thanks all.
What's the ballpark figure of the cost of the audit? Do you think that there is a way to give back some sort of public publicity to whom would like to chip in, to increase the likelihood of any company-backed contribution?
The estimates I got ranged from $30k to $50k. Anyone interested in this discussion should check out: * https://github.com/paragonie/sodium_compat/issues/8#issuecomment-273618277 * https://twitter.com/SniperSister/status/831514942968840192
It sounds like your problem isn't really the json_encode part, but normalizing your data and removing the duplicates. Once that is done you can json_encode it directly, implement JsonSerializable and encode that, write serializers, use fractal, etc. One solution is to do 2 different queries instead of a join. First do `select * from users`, then do `select * from posts where user_id in (?)`. It's probably going to be faster to match the posts up with the users than it is going to be to normalize the data. That is how active record ORMs like Laravel's Eloquent usually work. Another solution is to write code that normalizes the results. Doctrine is an example of an ORM that does this for you. You can get an idea of the performance challenges by reading [this excellent article](http://ocramius.github.io/blog/doctrine-orm-optimization-hydration/).
Mostly corporate clients and some mom and pop shops if they are desperate for some quality work. I typically don't fuss around with wordpress/drupal sites these days. I build/modify/support large sites with frameworks such as Symfony or Laravel. 
This is quite true. I have been in the industry for 15+ years and my clients show it. Usually gets you taken more seriously in interviews.
Vancouver here. I don't freelance much any more. I used to build crappy WP sites for $400 apiece... These days it's $50 an hour if I like the client and I've worked with them before, $100 an hour otherwise.
Sidenote and perhaps offtopic: &gt; Guess why PSR-7's HTTP message is immutable. It's not that immutable after all. ;-) http://paul-m-jones.com/archives/6510
Paul brings the tanks. 
I've only really done recursion in times of searching multidimensional arrays?
otherwise I would have to login to the webserver if I am hearing you correctly?
Cba with controllers really. Got it working now. All I need is basic skeleton. Most work is going into data processing. Building a prototype. So just sprinting for bare functionality.
Hmmmm... I was thinking about symfony/cake, haven't worked with laravel. Can you provide a symfony example of such js library? Also there are js validation libraries which do not require any PHP, eg. http://yaireo.github.io/validator/
Is it beneficial to me to code long complex queries in PHP (via PDO) versus a MYSQL stored proc. I know the data needs to be migrated with the PDO method... But there has to be value in OOP vs Transactional... Any input here? 
well it is indeed over complicating something for the sake of automation because the client said and i quote "they only know how to click a file and install it". I know i can just provide a .zip file and tell them where to unzip it, then ask them to get the ip with a command, i would do it but the client is asking full automatition
PDO
Learn what all these buzzwords mean an then ask again. In /r/phphelp
I'd say that being a senior dev is much less about technical knowledge, that _is_ important, but the real value is in your softer skills. e.g. The ability to work in a team, lead a project, evaluate the cost of technical decisions, mentor others, etc. Others have written more on this: http://mattbriggs.net/blog/2015/06/01/the-role-of-a-senior-developer/ Having said that, you're after technical knowledge and it sounds to me like you should look at a couple of frameworks (I'd recommend one being Symfony). Try to learn how they work and figure out the pros and cons of using each framework for different types of projects.
Thanks for the link. I know what the buzzwords mean I'm having trouble connecting them in terms of how they interact with each other. 
PDO will be more maintainable and gives you more visibility for your application's business rules.
Personally I prefer via code so that the queries can be versioned. I like to use the database as a dumb datastore, I don't put any business logic on it.
Yep, sure: https://github.com/formapro/JsFormValidatorBundle The main idea, is to have one set of rules that the server side and client side read from. If it's just a javascript library, I'm gonna have to write separate PHP validations
Thanks for the reply. I think I most of the soft skills covered, apart from leading projects, mainly because I just haven't had the opportunity. Would you say just get to know different frameworks, compared to learning how dependency injection works for example.
lol I really appreciate all the help I'm sorry I'm such a noob just trying to learn. Will adding a database abstraction layer like PDO effect the speed of the DB in performing other tasks? Will it improve my ability it pull data quicker than a normal stored proc? 
I'd say that if you learn more about different frameworks, that will help you to find things you need to learn (like DI/DIC) and if you take a analytical approach you will hopefully gain some knowledge of which frameworks are suitable for different types of projects.
you've been shown the link when laboriously typed your question here.
While we're at it, what's validation best practices and/or packages to use? 
&gt; facebook proves you wrong You realize that Facebook compiles their PHP to C++ and now they use Hack because PHP is shit, right?
If your backend is a JSON API, check out [JSON Schema](http://json-schema.org). You write your validation rules in JSON once and you can use them everywhere. For the server side you can use [league/json-guard](http://json-guard.thephpleague.com/) (disclaimer: I'm the maintainer) or [justinrainbow/json-schema](https://github.com/justinrainbow/json-schema). For the client side there are libraries to [generate forms](https://github.com/mozilla-services/react-jsonschema-form), [generate ember data models](https://github.com/thoughtbot/ember-json-schema), or [directly validate the JSON](https://github.com/epoberezkin/ajv) before sending it with $.ajax or whatever you are using. Another plus - Swagger uses a subset of JSON Schema, so you can generate docs and API clients from the same schemas.
Knowing the standard PHP is fairly good. In the real world, I would say that you will end up meeting custom frameworks and a good thing to know would be creating your own request router, error handler and in the end, an MVC system. I would start with a simple router and go from there, not necessarily looking at example code. As you get knowledge of additional functionality, it's a good idea to rewrite things better until you're happy. 
what would struct offer over typed properties with accessors to most people? EDIT: neither of which php has, but which are more likely to be gotten than structs 
Boston area, here. Based on my own experience / take with a grain of salt. At work, ~$50/hr Freelance, ~$100/hr
Indeed, with Symfony, once the penny drops, you can get stuff done really quickly in a very clean, structured way. Learning how to wire up services is arguably the most important thing to learn about Symfony. They provide with interfaces to everything, implementing your own stuff is really easy.
I wrote one... not sure if I can completely extract it from our project or not, but it's PHP-framework agnostic. It uses [jQuery validate](https://jqueryvalidation.org/) for the JS validations. You'll notice the rules and messages it uses are mostly JSON-serializable, so all you have to do is either write a PHP validator that will accept rules in the same format, and then serialize it and send it to the client, *or* you can do what I did and encode the PHP rules as an object tree, and then implement [`jsonSerialize`](http://php.net/manual/en/class.jsonserializable.php) which will then output a format accepted by jqvalidate.
$60 isn't that much for contract work. I charged $65-75 on my last gig, but I don't think I'll ever charge that low again. Look at it this way: if I charge $60/hr and it takes me 100 hours to build you a website, that's $9000. The last site I built is earning my client about $80K/year now. What he paid me is comparatively peanuts. Also, we do highly skilled work. We deserve decent pay.
For the past year I've worked with several startups to build out their MVPs. I charge $60, and they seem to think it's a fair price.
Why not link the PHP port available at https://github.com/OWASP/OWASPWebGoatPHP instead of the Java one since this is a PHP subreddit?
I worked as a contractor in London on rates averaging ~£400 a day for PHP.
My backend is basically a legacy spaghetti code, no clear separation of concerns type project.. Haven't really worked much with a JSON backend, but sounds interesting.
&gt; The point is to learn how to exploit the vulnerabilities - and what you'll learn from the lessons will carry over into any language. Terms and ideas such as prepared statement, escaping/sanitizing output, CSRF tokens are language agnostic. The PHP one is a port from 2014 which has very little activity from the authors (some documentation updates and a minor bugfix here and there), and since it's release it hasn't been porting over any of the updates from the original WebGoat.
You could theoretically use the [V8js PECL extension](http://php.net/manual/en/book.v8js.php) to run JS from your PHP code, and write your validation code in JS. But the V8js extension sucks, and at this point, you might as well go the whole way and write your entire app in node.js.
This thought actually crossed my mind, but was thinking of just running a node.js instance for validation..Had no idea about v8js. How come you say the v8js engine sucks? 
"I've used" != "use"
**SANTA MARIA**
second this. It's not a separate topic appSec and PHP, we MUST understand and build secure code, but this is in *java* so it don't belong here.
What I do is I expose everything on the server as an API, and I submit forms via the API, and get back either success, or failure with errors (including validation errors). For user submitted forms, I add a flag "validateOnly" which stops after validation. This means I can submit the form as many times as I want, as the user is typing and display errors interactively. It's not the same as having validation logic on the client, but the lag is honestly inconsequential to UX, and it allows you to validate not just with a restricted set of declarative schema rules, but any validation logic you have on the server (including things you can't check on the client, like username uniqueness and so on). I'd propose client-side validation only for forms of high value, high visibility and very frequent user. In which case you'd be likely crafting the UI manually and so you can also manually port the validation logic necessary, as well.
It does mean you can't have as-you-type validation though, which is what is considered the norm these days with client side validation.
No, this is why the "validateOnly" flag is there, so I can submit the form as you type. Even with client-side validation you usually don't want to literally show errors on every single character written and deleted, as this would present an obnoxious interface that flashes a dozen errors as you type. What's typically done is there is a "debounce" time (say half a second at least) before validation routines run, which makes it irrelevant whether you run validation locally or not, because server roundtrip is less than this. And some prefer to show validation errors as you *deselect* a field (i.e. when you focus on the next field for entry), which also makes the server roundtrip irrelevant. If you can show feedback to the user within 100-200 ms, it honestly becomes kind of excessive to have all this additional code and restrictions that allow you to run validations on the client. It doesn't matter much. If I was coding Twitter, which has like 5 forms and they all see enormous traffic, I'd optimize. But if you'll be getting under a million users a day, why bother.
It's a platform for teaching you about web security - a skill that is sorely lacking in the toolkit of a lot of PHP developers. Just about everything in each lesson has nothing to do with the language itself - you learn how xss, sqli, etc work by exploiting a vulnerable application. You can then use those lessons on your existing code. To put it another way, when you read an app sec article that talks about the importance of csrf prevention and it mentions Ruby, Java, Node, et al, do you disregard it as irrelevant because it doesn't mention PHP? If it tells you to use parameterized (prepared) statements, is that concept going to be completely lost on you because it's not within the context of PHP?
Since when the popularity of a package means it's better?! Does that mean that WordPress is of top-quality because it is the most popular PHP app? I don't think so. And not that I like JustRoute a lot, but FastRoute is a lot of code, files and classes (memory used, disks request, etc.) for something that is supposed to be "fast". Seems like a lot of Java crap applied to PHP.
I use this commonly in applications, in order to select the right "sub-application" from a set of a few apps, each of which internally uses a more conventional router. In my case, the URL comes parsed into various elements, including an array of path segments, so it's common to see this at the bootstrap: switch ($request-&gt;url()-&gt;path(0)) { case 'api': $app = new ApiHandler(...); break; case 'admin': $app = new AdminSite(...); break; default: $app = new PublicSite(...); } $app-&gt;run($request); So it's fine, if you have a few routes. If you have more routes, you can go for a conventional router, something like FastRoute (see on Packagist), but you can also use this intermediate variant, with maps: include $_SERVER['DOCUMENT_ROOT'].'/portal/config.php'; $map = [ 'newuser' =&gt; 'pages/admin/createnewuser.php', 'view_all_users' =&gt; 'pages/admin/view_users.php', ... ]; $file = $map[$_GET['action'] ?? 'default'] ?? null; if ($file) { include $fileroot . $file; } else { header("Location: ?action=home"); } This allows you to centralize your action logic and have a cleaner set of "routes" in an array, which will be easier to maintain and read. 
&gt; Since when the popularity of a package means it's better? Because more users have found, reported, and fixed bugs?
Yep, good point, that's a fine solution. The projectt at hand is a legacy spaghetti project, no Ajax or API backend or anything. But eventually as I modernise it I'll probably look at something like this. 
If you are targeting a single file with the assumption that loading fewer files is more performant, it is an unnecessary micro-optimization because of [OPCache](http://php.net/manual/en/book.opcache.php) (which has been bundled with PHP since version 5.5). To quote the manual: &gt; OPcache improves PHP performance by storing precompiled script bytecode in shared memory, thereby removing the need for PHP to load and parse scripts on each request.
If you're making a simple site with a few pages, it's harmless. If you're making a full-on web application with dozens or maybe even hundreds of different routes, yeah, you'll get some raised eyebrows. Routing with `include`s is more of a faux pas than the actual switching logic.
&gt; FastRoute is a lot of code, files and classes (memory used, disks request, etc.) for something that is supposed to be "fast". Why don't you benchmark it and see how it compares with a single God class with similar features? I'm betting the difference is going to be tiny, *especially* considering routing makes up a tiny % of overall performance.
I didn't assum that it will be more performant. I just wanted a tiny single file router that suffices my needs, I looked up and i didn't find one at that time so i wrote it then share it so maybe someone out there want something similar too.
All scripts are free, no hidden charges
In that case, cool! Implementing something like this is a great exercise in understanding how a component that seems "magical" to many people actually works. It also serves as an easy to use example to help others understand due to the small size.
Spamming other subs didn't give the traction you hoped for? 
For such small projects I wrote a simple router which checks existence of php file in a `/pages` folder, and includes that file if it exists. That router grew to my beloved hobby project I released at [GitHub](https://github.com/pinpie/pinpie). Maybe you'll find it pretty small and attractive to give it a try. If so - I'll help you to test it in action. Anyway, in my case I found convenient to allow file e.g. `/pages/users.php` to handle urls like `/users` and `/users/12`. Also I made possible to store some files in a folder like `/pages/users/` to attach some actions or pages like `/pages/users/banned.php` to handle url like `/users/banned` and to route url `/users` to `/pages/users/index.php`. Take a look at the [routing class](https://github.com/pinpie/pinpie/blob/stable/src/URL.php#L80), you may find there an example how to do that on your own.
This study compares a traditional HTML form (which reloads on submit, and shows error only after that), with real-time feedback (validate as you're filling in the form). And I'm talking about the fine nuances of implementing real-time feedback. We're talking about different things.
Debouncing UI events is also typically done in service of what users want.
Do you have data on that? 
You can do the same with a database, basically if you define your data as some sort of data dictionary you can create procedures in any language that will validate it.
Unfortunately common sense is often wrong. That's why usability testing is so valuable.
I'm not sure if this post is a troll. " 1.Open notepad and create a new file called "calculator.php" or any name as u like you can write 2. copy blow Code and Paste to your File" Like wtf? copy the code? No explanation or anything else? Cmon
Well, ok if you find one, let me know. Until then I'll consider the difference subjective and inconsequential. There's a big difference between real-time validation, and having to submit, reload the page, and only then see errors. But if it's real-time either way: will it happen immediately or in 1/5 of a second? Not that critical.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Like many have said it's fine for a small project. But in some of my larger older projects where I do exactly that you'll find a hell of a lot of unexpected placed where I threw in an `if ($_GET['action']...`. You might also find a few files here or there that read or update the database but are not actually related to any other accessible page anywhere on the site. They are just old files I forgot to delete. So there may be a file somewhere containing `if get action &gt; insert 17 placeholder news articles` for no useful reason. Or there might be a file in `/admin/includes/utilities/config/xtrash/backup-11-11-2006-3` that if visited would set all the session values necessary to be logged in as an administrator without providing a password. Having a single point of entry into your app where all of the possible accessible routes of the app are defined in one place helps to prevent forgetting about old/dangerous code and leaving it accssible. Using a routing library and a view template library will give you lots of convenient and useful features you'll probably quickly find a use for. Also the average user prefers `example.com/articles/daywatch-nightwatch-now-on-netflix/3306` over `example.com/index.php?action=articles&amp;subaction=view&amp;article_id=3306`
A struct is more a "fixed" type, while PHP class properties are not fixed. Example for a "wrong" struct. class Book { public $price; public $title; public $author; } $book = new Book(); $book-&gt;price = 39; $book-&gt;title = 'My book title'; $book-&gt;author = 'Me'; // Set a undefined property from "outside". // This is possible by default in PHP, but not allowed for a struct. // A struct would raise an Exception here, and this would be better // because this property is not defined in the Book class. $book-&gt;isbn = '1234567890'; print_r($book); 
ah, i never think about using properties that don't exist when it comes to php. :( definitely would be nice to error out there.
Totally depends on your location inside of those countries as well. Here in the UK as others have said £300-£500 per day (£40-£60 per hour) is about the going rate in London but outside of London this can change massively. Here in the North (especially in the Manchester) we're currently having a PHP boom and the lack of developers is really pushing the prices up, any where from £250-£400 (£30-£50) now seems very common here. Theses prices are based on working with a client for a 3/6month period, working on large scale business applications. You wont be getting these rates working directly with end users fixing their shitty Wordpress website with 400 plugins as they expect rates given by Indian/Asian developers of around $5 an hour.
I know what needs to be in the public dir, only with the 12 factor app (or docker containers) you usually store the credentials inside the OS env. This could be leaked with for example phpinfo() or perhaps leaving an error handler enabled by accident which dumps your server environment.
You have to edit app/config.yml to add new mappings for each module. You can skip that by registering your mappings from the Module Bundle. See [here](https://symfony.com/doc/current/doctrine/mapping_model_classes.html).
But this data would not be available if the credentials would be stored in a plain config.php file thus i feel it would be more secure in the case of some app exposing it or leaving some whoops handler enabled?
I'm currently deploying 3rd party products like sentry on docker, and working on automated deployments for it, then once we got that figured out, we'll probably move to put our applications in containers. The "trick" is to monitor the service endpoints, and ship any application logs out of the container, eg. to ELK or Sentry.
The WTF part in my mind is using `include` rather than [class autoloading](http://php.net/manual/en/language.oop5.autoload.php), which will allow you to do even more nuanced processing on requests rather than copy boilerplate among tons of individual files that directly handle requests. Of course, this is a very OOP way of thinking about program design, but it is the method that the PHP language has chosen and that its community strongly supports, so it is my recommendation. By using autoloading and having a controller class or two, you wind up with something closer to what /u/LtAramaki describes in this thread. There are an infinite number of ways to do this, so again, depending on the size of the application it either doesn't matter at all or it matters a lot. I recommend grabbing an off-the-shelf routing library like Flight or the popular Slim framework, or even one of the bigger routers from Symfony or Laravel. Libraries tend to give you a pattern to follow that has been "battle tested" to some degree so you can be more confident that you're not coding yourself into a corner. Do what feels right, and if you're not experienced enough to have a feeling about it, do what other people do. Eventually you will have a feeling about it and you'll be answering other people's questions here :)
I had a [similar problem](https://www.reddit.com/r/PHP/comments/5ru0m9/owasp_authentication_credentials_for_external/), answers there might give you some ideas.
Have my upvote for the ide one :)
I store application configuration, including credentials, in a config file, keyed by environment ( prod, uat, dev, etc ) Pull repo. Edit config file. Kick webserver. 
I do a similar thing for my projects, looking for a class in the Page namespace with the name of the page requested and calling Class::runPage() on it.
Hmm... I never thought about putting all the routes into a map... Interesting... This approach seems more dynamic than mine, I'll have to give it a shot later. Thanks! 
The `psr/container` package now has a stable release (1.0.0). Container-interop has been deprecated in favor of PSR-11 and now extends PSR-11. That means that all container-interop containers are now implementing PSR-11 automatically. Edit: also obligatory mention of the service locator thing: [Recommended usage: Container PSR and the Service Locator](https://github.com/container-interop/fig-standards/blob/master/proposed/container-meta.md#4-recommended-usage-container-psr-and-the-service-locator)
Nicely done! Not suitable for prod because of the lack of tests but thanks for sharing :3
You are worried that data will get exposed if you have an improperly configured web server. If you are already thinking that that might be the case, why would a plain config.php file be more secure?
In general you may not need client side validation at all. Just make the POST/PUT with Ajax/Web Sockets, and return errors as JSON if something doesn't validate. Then just use a few lines of generic Javascript code to update the view to reflect the errors. Advantage of this is that validation is always done in one place, and that place is server. You can validate more things on server (e.g. check for existing entities, rules based on the state of database etc.). You may add simple HTML5 validations, as well (e.g. required, etc.). Same logic of course works with non Ajax/Web Sockets traffic, but there you just re-render the page as a result of request.
The biggest problem with having secrets in the environment is that once they are in your environment, they are accessible everywhere. If you're using a exception logging system for example, all of the ENV vars might be getting shipped off to a third party etc. Same with spawning sub shells etc, they'll probably get all of the environment unless you sanitise it. 
Is there any specification changes or 11 and interop are pretty much the same? 
I think you raised a valid point. Obviously exposing error messages, or leaving Whoops enabled in production is a sign of worse problems, but up to this point (without using env vars) those secrets wouldn’t be exposed this easily. If you’re concerned about it, set up one place where you fetch data from env variables, and then unset them after they are passed to your application.
[Please don’t advocate security by configuration](https://paragonie.com/blog/2017/01/configuration-driven-php-security-advice-considered-harmful). There are other places that superglobal `$_ENV` can be leaked, not only by serving `app_dev.php` instead of `app.php`. For example, error handlers (Sentry, etc) will pass your context along with the error to an unknown location (often 3rd party). You can mitigate, but it would be better not to store secrets in global state, and as I stated in a different comment — use them early in the application flow and erase.
NIH Syndrome + Router is the new Hello World. I’m guilty too btw, I have my router buried somewhere in the depths of github. ;)
So bundle your files together for production use if this concerns you (Symfony does this, maybe it can be extended for additional app sources). Worrying about number of files in source code is ridiculous.
You'r a step away from RPC router like [zend json rpc server](https://framework.zend.com/manual/2.2/en/modules/zend.json.server.html) :D
Welcome to an open forum where discussion, including critique, takes place!
I am dealing with records in the millions. 
Uhm no 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
&gt; The 12-factor App, which you linked, was named so by Heroku, Not just named, but written by one of Heroku's co-founders, and yes it just so happens to be a convenient way of deploying applications to Heroku, rather than generally good advice.
Check out https://www.opulencephp.com/
This actually just close to correct. Tax rates can vary even within a certain zip code, and of course by the type of item being sold. 100% correct tax rates can really only be done by using something like Avalara.
What do you think is responsible for the PHP boom considering the growth trend of Node.js? I'm assuming the boom is largely Symfony and Laravel projects. Is that accurate?
I guess the point I'm trying to make is that frameworks remove security from the development process. On one hand this is great, it takes care of a lot of common security problems and saves development time. On the other hand, some pretty important security concepts are being overlooked because people aren't learning the languages anymore, they're just learning frameworks. I used injection as an example, it wasn't meant to be the focus and I apologize if that wasn't clear. What I meant to point out was that it has always been difficult to make security a priority during development and that the "benefits" of frameworks makes it even more difficult to focus on security.
Just start lookinf for big projects with PRs on them, comment on the PR if you can, do code reviews and then from there start coding away
Did you forget to run composer install?
https://bitbucket.org/ccmbenchmark/ting.git
You don't really need preg_replace, just use str_replace: str_replace('[b]', '&lt;b&gt;', $string);
Virtual Host error. Its all good now thx.
Out of curiosity, why do you want to "urgently" use another framework? To directly answer your question, I highly recommend using RabbitMQ, and it is quite easy to integrate with the rest of the php ecosystem.
A decent company should be giving you time to actually figure out how something works. A decent project manager will either give you a complete spec and ask for an estimate or give you a partial spec which you can request clarification on. A decent project manager also understands that the dude who wrote it originally will complete tasks twice as fast on the code base compared to someone completely new. If you are unsure I would ask the project manager what the expectations are and then strive to meet them. Every company is different with differing practices and expectations. I have always gone to my superior whenever I have been unsure. This way I do not spend a week working on the wrong thing or focusing on the project.
If we'd have `set` we might as well just cancel the whole spec and use an array. :-) I've already commented before that I find the whole notion of needing a shared standard for containers superfluous. It betrays the wrong architecture is being used for component/module configuration.
Is resque "compatibility" a necessity? Just from looking at the PHP resque clone I can tell you there are a few mistakes in it in terms of how to implement a queue using Redis. It's not very resilient against losing jobs in case of server failure, power failure, process gets terminated, etc. It really needs to be using Lua scripting to move the job onto a reserved queue during the same atomic operation as reserving it, which is the approach we took with Laravel's own Redis queue implementation. You can try giving it a shot outside of Laravel: https://github.com/illuminate/queue ... though I will admit, I don't particularly design the queue component for usage outside of the Laravel ecosystem, so it could be a little rough getting started. Need to improve in that area. :/
Probably because `null` is a valid value to store in the container, and having `get()` return `null` when the entry doesn't exists causes it to become ambiguous. Cache interfaces tend to have the same problem. Whether you *should* be storing `null` in your container is a separate question entirely (one which the answer is probably "no" in most cases), but that doesn't invalidate one's ability to do so.
Trying hard to understand what the point in this and why would a framework use it? It looks basic and [seemingly pointless](https://github.com/php-fig/container/tree/master/src) Having read http://mouf-php.com/psr-11-use-cases it now seems to me there is quite a divide in opinion in regards to if PSR-11 is a force for good or ultimately harmful, particularly when it comes to performance. [Larry Garfield](https://groups.google.com/forum/#!msg/php-fig/xC1CCjtyVnw/A3uZ-8HOaUIJ) has a pretty detailed explantation why. He concludes: &gt; In short, I believe this PSR is not unnecessary; it is actively counter-productive and harmful. What would be useful is, in fact, the exact opposite: Provide a common standard for putting stuff *into* the container. Having every library provide its own unoptimized mini-container is a terrible idea. But if it could provide a default configuration suggestion to any container? Ie, eliminate the need for a Symfony Bundle, Zend Module, or Drupal module whose sole purposes is to wire stuff up into the container? Now we're talking! That would be useful. That would allow for more experimentation and optimization without harming interoperability. That is something I would support. 
&gt; largely Symfony and Laravel projects No that doesn't seem to be the case, *most* are advertised as general PHP positions. It's hard for me to put my finger on it but the Manchester job market is booming at the moment which is great for me as I'm only 40mins away. Node is a fun toy (I did a gig 12months ago making a barcarole scanning/trade in site) but it certainly doesn't seem to be taking much ground in the e-commerce space. When it comes to e-commerce it seems PHP is the go to language mainly because of the amount of opensource e-commerce projects written in it compared to other languages 
Jesus, that puts you at around £720 ($900US) per day, I've not even seen those kind of rates in the London area never mind Scotland. Good on you for managing to attract that kind of money
I never do 'full' days to be fair. I'm a full time Software Engineer so I only like to pick up a few hours here and there as a little extra. usually I stick people on a retainer for security patches on whatever their software is (except wordpress) and it just becomes passive income with the odd bit of work here and there then maybe they want some additional work and you just add that on to the monthly fee. 
How do you find the clients?
By reputation or by another freelancer having overflow he defaults his clients on to me. I basically just done small tasks for people and they got more and more complex over time till I got a job out of it.
[curl_multi_info_read](https://secure.php.net/manual/en/function.curl-multi-info-read.php) 
&gt; There is a trend to store db credentials in the os env with .env files, only isn't this more insecure? Yes. Trends don't always go towards more secure and more mature, sometimes they're trends. Like fashion trends. &gt; How do you store your secrets? In files in my config folder. Now, I've also had high security applications, where logins are stored only in RAM, in a persistently running process. This is less practical in PHP, unless you have an extension that can store such data in-process without the risk of purging it (i.e. like the various auto-delete cache key-val stores do). It also means if the process crashes, or the server reboots, someone needs to log in and initialize the application by feeding it secrets from a remote machine. Here's an idea, just abstract it and inject it. Make your application just ask for the secrets in the form of an object, or assoc. array, or even better, as a client connection to the relevant service. Then you can defer and change your opinion on how to secure this data on a deployment by deployment basis, instead of having to make a Big Choice Up Front for your projects. Then go with the simplest solution (which for me remains... files in config folder), and change it only on a need-by-need basis, if someone requires it, or you stumble onto an objectively improved solution.
&gt; That said they can still be exposed obviously, but no more so than you storing config in a file somewhere. OP has a tendency of dropping phpinfo() and var_dump($_SESSION) in their code, which many of us do. And even if he wouldn't do it, someone deploying your app may do it, and it may be out of your control. So it *is* a risk. If this is the case, then putting things in your environment is less safe than a config file, because reading a config file implies file access to the server. And opening a phpinfo() implies opening one of a few phpinfo URLs which people tend to use for these files, with no privileged access to the server at all.
I'm a contributor to https://github.com/mjphaynes/php-resque, see https://github.com/mjphaynes/php-resque/pull/36, a ton of fixes are about to be added. I think what /u/utotwel is talking about is not using `RPOPLPUSH`? I plan on taking a look at that soon. My specific requirements were the ability to prevent duplicate jobs, and I can hack this in with php-resque but I couldn't do it with beanstalkd which I use for another project. If you're willing to help us out, you can contribute to this one, I'd definitely appreciate the help in improving it!
Basically this sub fluctuates between days where user-submitted libraries are all awesome, and anyone critiquing is instantly downvoted, and days where the actual user-submitted libraries are instantly downvoted and all the comments are negative. So the answer to your question is: you picked the wrong day. How do you pick the right day? Nobody knows. Like God's work, the ways of Reddit are mysterious.
What most people here don't really take into consideration is how much of the time the client books. Let's say a client books you for 5 hours... So you also spend at least 2 hours for consulting with the client about the project, writing an invoice, showing him the results, maybe minor changes, etc. This makes a total of 5+2 = 7 hours of work, but you only bill him 5. Moreover, you probably have to spend some money and time to find new clients. So a low rate for those 5 hours is definitely not possible. But let's say there's a bigger project. The client hires you for 3 months, 150 hours à month. Can / should you give him a better price? Yes, definitely. Some rates posted here seem to be so incredibly high, I doubt that any client will pay that if he takes more than just a few hours. Btw. I also hire freelancers in our company and the rates are sometimes really high, too. But then we book them usually just for a few days. We would never pay a freelancer USD 100++ / hour for long-contract work. :)
[removed]
Could you give an example or two of these small tasks?
What was your usual channel for finding contracts?
Hey, this is nice! It seems like a good first project, and you should pursue it further. But, sadly this is not object-oriented. You should try and refactor your code. Right now it's just procedural code put into a class. Instead, write a "Note" class which holds all the information about a Note. Then write a "NoteRepository" (or something else), which takes a Note and persists it to the database, and which can get Notes. Basically, split up your class. Still, really nice! :) Try to do some of the things you wrote about down below.
So you have a secret, similar to 80% of other programmers and IT folks - you're not actually as good as everyone thinks you are and certainly not as good as those guys on the internet who know how to do all the clever buzzword stuff. I mean, you can create programs, fix bugs, setup menus, produce reports and charts and graphs as needed by your employer/customers but so what, that does not make you a good programmer does it? To be senior you probably need a good 6 years of experience, but how to get that in only 4 years - its a conundrum of quite some proportion. I had a junior programmer once who claimed after 6 months he was ready to be a programmer with 2 years of experience because he worked long hours. I slowly explained to him that 2 years contained 24 months or 104 weeks of continuous development,bugs, learning, fuckups, shame, guilt, lightbulb moments, achievement, happiness, sadness, repetition and almost 700 nights of working late and dreaming/reading/fantasizing about technology. I think most senior Developer guys have a moment when it hits them, hey Im a senior developer. Its like a Dilbert moment. More often its just their boss who hits them and says, wake the f up, you're my senior developer, make this happen. Or maybe its when the 5 new snotty nose, fresh out of school, trainee know-it-all wet-behind-the-ears all academic and no street-smarts people turn up at work one day and you look and say "I hope Im not like that. Sometimes its because you left that dead-end not getting challenged job and just applied for one that said "wanted - senior developer". A senior developer who has spent all their career at one company is really not well rounded. A senior who moves all the time is rounded but not focussed. So look to move every 2-3 years to different types of companies and environments, read up continuously, watch laracasts and youtube tech videos and Codecademy, go to user meetings, talk and challenge other programmers. Keep honing your skills, read up and try to implement and follow best practices, dont get sucked into framework wars but have a rough overview of all of them. Focus on creating quality work you are proud of to your employer/customer. One day after 5-6 years, the senior developer tag will just slap you on the back, and you will be thereafter annointed to that role and have to wear that aura from that day forward. 
I used Learning PHP 7 by Antonio Lopez when starting out. Maybe you will find it as helpful as I did. Edit 1: I also used a PDF version of Tutorials Point PHP tutorials Link: http://tutorialspoint.com/php7/ Edit: Some people here recommend PHP The Right Way but since I have not used it, I cannot confidently recommend it. However, see for yourself. Link: http://www.phptherightway.com/
w3c school is one of the best source for learning php. Visit and see by yourself
Right indeed, I misleaded the term of "Object Oriented" in my code. Thanks for the explanation!
Great first project. A couple of suggestions for next steps: - Start using include and require to split your code up into different files, this will help you organize it. - Instead of using a POST request, try using a DELETE request. When you start thinking in terms of objects you will be able to tell the server many different things about an entity, just by giving it an id. For example: // http://notes.local/$entity/$entityId GET http://notes.local/note/1234 - Get the information for this note POST http://notes.local/note/1234 - Update the information for this note PUT http://notes.local/note/1234 - Put a new note with this information (create note) DELETE http://notes.local/note/1234 - Delete this note You could use a switch statement to check the $_SERVER['REQUEST_METHOD'] global variable function routeRequest() { // Get the entity and ID out of the URL // Will match /[entity]/[entityId] // For example /note/1234 if (!preg_match('/^\/([a-z]*)\/([0-9]*)$/', $_SERVER['REQUEST_URI'], $matches)) { // This is like our error message we send to some html // Try to make something that receives this data and displays an error page return [ 'loadThisView' =&gt; 'error', 'message' =&gt; 'Could not get entity ID from URI' ]; } // If we made it here, we now have some info on the entity requested // strtolower( makes sure it still works if some knucklehead requests http://notes.local/NoTe/1234 $entityType = strtolower($matches[1]); $entityId = $matches[2]; // Make sure we have this entity switch ($entityType) { case 'note'; $entity = Note::load($entityId); break; // TODO program screenshot model // case 'screenshot'; // $entity = Note::load($entityId); // break; default; // We haven't accounted for this entity type yet! return [ 'loadThisView' =&gt; 'error', 'message' =&gt; 'We haven\'t account for this entity yet!' ]; } // Now that we have the entity, we can route the request. switch ($_SERVER['REQUEST_METHOD']) { case 'GET'; return $this-&gt;handleGetRequest($entity); case 'POST'; // Maybe do some checking here for credentials, etc... return $this-&gt;handlePostRequest($entity); case 'PUT'; // Maybe do some checking here for credentials, etc... return $this-&gt;handlePutRequest($entity); case 'DELETE'; // Maybe do some checking here for credentials, etc... return $this-&gt;handleDeleteRequest($entity); } } // And then your "controller" function would interact with the model (the note) and return data to the html you have (your view). Give it a try! function handlePutRequest($entity) { // Now we update the model // First get the PUT variables from the request parse_str(file_get_contents("php://input"), $putVariables); $note = new Note($putVariables); if (!$note) { // Something went wrong while trying to save this note return [ 'loadThisView' =&gt; 'error', 'message' =&gt; 'Something went wrong while trying to save this note' ]; } return [ 'loadThisView' =&gt; 'success', 'message' =&gt; 'New note saved successfully', 'entity' =&gt; $note ]; } // Don't forget to put all of your model manipulation in the model class (Note) class Note { private $data; public function __construct($requestData) { // Build the query, this is a brand new note! $insert = 'INSERT INTO notes ('; $values = 'VALUES ('; // Loop through attributes this model has that can be saved, and look for update // Think of the attributes as columns in the DB // TODO Learn how advanced ORMs use multiple tables in the DB (look at Magento!) foreach ($entity-&gt;getUpdatableAttributes() as $attribute) { // Check if the request has this data if (isset(!$putVariables[$attribute])) { continue; } $value = $putVariables[$attribute]; // Since we have a value for this attribute, add it to the query $insert .= $attribute . ','; $values .= $value . ','; // Also add it to this model's data $this-&gt;data[$attribute] = $value; } // Comine our query $query = rtrim($insert, ',') . ') ' . rtrim($values, ',') . ');'; // Execute the query with your db class $results = $yourDBClass-&gt;query($query); // If there were no results, make sure we send along a false instead of a working model if (!$results) { // Or maybe we return an error message return false; } // Otherwise return this working model return $this; } } There are obviously a lot of improvements that could be made, but have your own adventure at it! Once you start to understand the basics of the request cycle, try to learn a framework that does all of these smaller, yet tedious tasks for you! Laravel is a great option for readability and has a pretty easy learning curve. Good luck, keep at it!
&gt; Out of curiosity, why do you want to "urgently" use another framework? It's CakePHP2 specifically and it's a burden to no end. Well of course, it's peak has passed and there's CakePHP3 already but when we faced to make a jump, we decided the Cake-philosophy is not a fit for us and new systems got implemented in stacks which fit more (e.g. Laravel on php, NodeJS for Websocket/soft-realtime-notifications, etc.). &gt; To directly answer your question, I highly recommend using RabbitMQ, and it is quite easy to integrate with the rest of the php ecosystem. I've come across RabbitMQ a few times, and of course the http://queues.io/ list contains it and others. Can you talk more about how you use it? Processed jobs, distribution, latencies, outages, resilience, overall experience?
Haha thanks(:
&gt; My specific requirements were the ability to prevent duplicate jobs, and I can hack this in with php-resque but I couldn't do it with beanstalkd which I use for another project. That's funny, we did exactly the same with php-resque-ex. De-duplication is essential with high concurrency with external factors where you can't guarantee that the same external event won't enter the system twice. I'm a big fan of contribution and did in small parts where time allowed. But to me, a queuing system needs to be rock solid proven to be a starter. I'm not implying on dissing your contribution or the project you refer to, but rather like to hear experience and hear success stories of a system to judge the next move.
About your ending lines I'd like to ask if it's not better for him keep trying to do this in pure php instead of rely on a fw ? 
This is all good, except that the PUT request shouldn't get an ID. The ID is not part of the application, but rather of the database layer, and it should be generated there.
Er, does this code just add the field values directly into the query without using parameter binding / prepared statements? It looks like there is no escaping at all happening there.
Did you look at the original port to PHP by chrisboulton? The main annoyance there is that changes haven't been pulled in for a while but they're in process of handing off the repo to other people. That one seems to be known to be rock solid, unless one of the issues are directly problematic for you. chrisboulton has said he uses it to process millions of jobs a day. All the other php-resque libs are really just based on this one. https://github.com/chrisboulton/php-resque
1. Mnapoli just wanted his name on a PSR. Now that PMJ is no longer functioning in a quality control capacity, getting PSRs through is easy. 2. Mnapoli just wanted PSR to stroke his ego by validating [his library's](http://php-di.org/) implementation as the One True Implementation that everyone else should follow.
This is a fantastic comment, really refreshing polite critical evaluation of a beginner's code. So nice to see after wading through pointless, snarky comments on StackOverflow. Well done : )
Could you give a little more detail on what kind of tests you're writing, and how the static method calls are making things difficult?
Uh... what is this? It looks mostly blank to me, I don't see much besides the directory layout. Was there more, but you forgot to push it to make it public? Where is the "architecture" that answers DDD problems such as: * What's your interface for Aggregate Roots and entities? * How are Domain Events collected and handled? * How are you defining your domain-repository interfaces, and injecting Doctrine-repository-backed implementations? * Does it use optimistic concurrency? * How are you ensuring that changes to child-entities cause the Aggregate Root entity's version to change? (A problem the Doctrine maintainers don't seem to care about.) 
Exceptions are objects, not stack traces. Please provide metrics that verify your spurious claim that exceptions are bad for performance.
lol whilst strictly true it's what they asked, I'm not sure that it matched the intention
Ah, that makes sense thanks!
&gt; Exceptions are objects, not stack traces. I'm not sure if you're serious. http://php.net/manual/en/exception.gettrace.php &gt; Please provide metrics that verify your spurious claim that exceptions are bad for performance. I'm not sure if you're serious, yet again. https://3v4l.org/EWJaZ BTW, your arrogance seems greater than your ability to do basic research, and I don't appreciate that, so I'm just going to say I've spent enough time giving you the 101 on exceptions. I was very gracious and very detailed. If you want to know more, you know where Google is.
You couldn't be further from the truth. 1. PMJ was actually the coordinator of this PSR before leaving PHP-FIG. PSR-11 when he left and PSR-11 as it was adopted are very similar. I dare to say PMJ is a proponent of PSR-11 2. This is plainly a troll and I'm not going to respond to that. Also, PSR-11 is a great way to write framework agnostic factories, which is the first step towards framework-agnostic service providers: https://github.com/container-interop/service-provider/
Looking for PHP 4.0 certification ?
What I got from the article was that laravel is great for fast-paced short-term projects, but due to some design-issues, it might cause extra costs for long-term projects when it comes to updates and bugfixing. Imho, that's a good piece of information to have for anyone looking into using laravel. I thought it was quite an unbiased view. 
Surely you mean [PHP 6](https://madeinproduction.com/products/php-6-certified)? =D Also note: The official Zend Certification has recently been updated to include PHP 7.1: https://devzone.zend.com/7526/zend-certified-engineer-2017-php/ - given that PHP 5.5 is no longer supported, and the amount of changes that went into 7, I wouldn't touch a 5.5 level certification.
I just hope I can use it in my Perl 6 project.
Laravel has the same sort of graceful restart. With regards to monitoring queues, keep an eye on Laracon in July. ;)
Indeed. We just use Lua for a few other operations so we use it for that too.
Exceptions providing a method to produce a stack trace is not the same as exceptions *being* a stack trace; exceptions do not produce or store a stack trace prior to one being requested. You shouldn't get so upset when one asks you to prove your claims about performance.
Here are some resources for a PHP beginner: https://gist.github.com/odan/a0dd66bf681fae46d0df14b103108f23
[removed]
Too bad I read the article first, didn't notice your comment since it was at the bottom. Would have saved me some time since it sums it up really well. 
Haha, I was thinking about that DHH tweet as I started reading the article, couldn't have asked for a better closing paragraph to quote next to it.
There is apparently a cheat sheet somewhere on the net, titled "How to promote your shitty homepage", with one of recommendations as "Write an XX-Things-One-Ought-To-Know article in the area you have no knowledge at all".
Don't think this sub is meant for support, but strstr with the 'before needle' arg may get you where you need to be: http://php.net/manual/en/function.strstr.php
Whenever you declare a $variable, you have to make its scope as small as possible. The same rule applies to variables with secrets. Environment variables are just like system wide "super globals". Some server background services are sending crash reports with all environment variables to other servers. People putting phpinfo.php into a public webroot folder and so on... Because of "Murphy's Law" I would never put secret data into environment variables. My advice: Put the secret data into a env.php file one folder above the project directory.
I'm not a master database guru so I'm not intimately familiar with every possible database it supports, but I'm going to go out on a limb and say I'm pretty sure all of them natively support positional prepared queries (eg `?`) so it would not be difficult to internally replace `:foo` with `?` then keep a mapping of the position-&gt;name (eg `[ 0=&gt;"foo", 1=&gt;"foo" ]`) then when the query is executed use the map to convert the parameter assoc array to the appropriate numeric array (`[ "bar", "bar" ]`). 
Laravel does not prevent you from writing your custom code for an "enterprise application". You are not forced to use the framework everywhere in your code. If you want to have something custom you can write it the way you want. 
That's practically true for ANY widely-used PHP framework, so it's not a pro/con point for anything..
I'd say that the issue is a little deeper. As far as I understand it's about binding by *reference*. So for the case in question there would be 2 references to a single variable. Dunno why it should be a problem though. that's what I want to know.
I forgot about that. I don't think I've used `bindParam()` since I quit using perl in the 90's (I haven't run into a situation where postgresql typecast something the wrong way without the hint.) Even so, if we're sticking to simple types, it could still make two copies of the variable and pass separate references to both copies if the driver can't handle two references to the same one.
Assigning positional logic can occasionally be a huge pain in the ass. 
Ahah, yes you are right! Of course I chose the one example that didn't need an ID! @dwixy, this man is correct. And actually, after doing a [quick google search](http://www.restapitutorial.com/lessons/httpmethods.html) it looks like the PUT request is actually for an update, whereas the POST request is for the creation. So it would look like this: // http://notes.local/$entity/$entityId GET http://notes.local/note/1234 // Get the information for this note POST http://notes.local/note // Put a new note with this information (create note) PUT http://notes.local/note/1234 // Update the note DELETE http://notes.local/note/1234 // Delete this note Keep in mind that the regular expression that is parsing the URL will need to be modified so that it works when there is no ID!
That is correct, this should not be done in a production environment, especially one handling user data! You should include some snippets that will help @dwixy query the database safely (bonus points if you explain specifically **what** the problem is, **why** its a problem, and **how** to fix the problem).
Probably obvious, but you need to access-protect the script. The delete link, for example, does not contain any token to validate, so someone can send you an email with some HTML link this: &lt;img src="http://example.com/index.php?del=1234" /&gt; Your browser will make the request, and the note will be gone without even you realizing it. 
It's just a facade.
Nope. `get()` can throw a NotFoundException because the requested entry is not found OR because one of the dependencies of the requested entry is not found (remember get is called recursively). "has" tells you if an entry exists or not. An entry could very well exist and still throw a NotFoundException (because one of its dependency does not exist). This happens when the container is misconfigured.
As with all languages and frameworks, it's only as good as the developer implementing it. I've worked on Zend projects that are a train wreck in every way possible. The Hello World example *doesn't fucking work" and the documentation is a utter disaster. I've worked on CodeIgniter (2MB zip file!) e-commerce projects that are just flawless for years on end. I've worked on websites that every single day made 1000EUR profit before I arrived at the office where php, queries, html, css and javascript were all shoved in to one file (viewprofile.php, sendmessage.php, etc.). That monstrosity, deployed with Filezilla, brought in over a million euros in 5 years. I have no experience with Laravel but I'm confident you can not, by definition say, that it has problems with updates and bugfixes for long term projects. Maybe *for that developer and his way of working* it was the case. No idea what kind of projects you guys work on but most PHP projects that I've seen are little more than CRUD and for that simpler is almost always better. Who the fuck uses an off the shelf PHP framework for truly mission critical projects anyway.
Because /r/lolphp
Eh, for personal and private use I doubt this would ever be a problem. Probably better safe than sorry, though, or if anything to follow good security practice.
this 100 times
Quick, someone tell the author what domain driven design means. All of his complains regarding ORM can be solved by isolating the domain layer from the infrastructure. But hey, it easier to bitch about a tool instead for reading some architecture books ;)
I heard the "If your application becomes successful, then you will need a complete rewrite" argument apply to PHP itself. PHP is great for prototyping but you have to use enterprisey shit like Java for mission critical app. /s.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
It's like you've never heard of services.
nice and elegant. cheers
just guessing here, but by reading the internals I think there was some controversy about how useful the pipe operator would be vs. how much confusing it would be for beginners. When a RFC gets negative feedback the author might choose to address the problem is a slightly different way, or abandon it altogether
&gt; bare in mind 
*Looks at Wordpress* Symfony or Laravel. I'm happy working with both! 
When we made the switch to Laravel, one of the best things about the framework is the very up to date docs on each version (5.1, 5.2 etc...) and laracasts for learning. It was also fairly easy to contribute code and edit the docs accordingly.
This post makes me really sad... This mentality is really not conducive to learning... 
This goes to show only clueless newbies, AKA self-proclaimed experts, think Laravel is a good idea.
There are a lot of options (October, in particular, is based on Laravel if that's your fancy), but one that might be of interest to many is [CMS Airship](https://paragonie.com/project/airship) (*edit*: which is published by my employer but we don't generate revenue from it), which is currently planning an overhaul for version 2.0.0 in order to be friendlier to extension developers and ship with better UI/UX out-of-the-box. CMS Airship uses an MVC architecture (and uses Twig for templates) and has a stated design goal of being more secure than the alternative CMSes on the market. I'm not sure exactly *how much* your employability will be impacted by being able to say "In addition to everything else, I've also contributed significantly to the most secure PHP CMS on the Internet", but it should be nonzero.
&gt; I've made various projects using Symfony and Laravel. However, I now fancy going down the cms rabbit hole. Maybe I'm do not understand the point, but for me it sounds like a step back.
Sure, but if you started with modern frameworks but a large chunk of the ecosystem uses CMSes, it's worth spending time with CMSes so you're at least *somewhat* familiar with them should such a project land in your lap.
sure. but the "good old days" where every developer was fluent in assembler and c++ and was studying CS, are long gone. Every developer knowing exactly what he's doing is a nice vision with a warm and fuzzy feel to it, but sadly nothing we can expect in reality to happen anytime soon... 
&gt; but if you started with modern frameworks &gt; it's worth spending time with CMSes why? 
Cool bro
It means seriously. /s
I'm not your bro mate
So true. I think he must be the only framework creator who constantly is defending his work :D
You didn't read the article? ;)
&gt; Maybe I'm do not understand the point, but for me it sounds like a step back. Some people like to learn by starting with the core (a small number of complex concepts) and then working upwards (a large number of simple concepts). Once you master the core, it becomes very easy to take on a higher-level abstraction, because you can appreciate the context.
[reddit silver](http://i.imgur.com/sy9lVl4.jpg)
If you've done Symfony you may want to try Drupal 8. Drupal 7 was kind of it's own thing but 8 was built on Symfony so you're probably already familiar with some of the concepts.
But seldom more than one correct way.
Like holy shit heaven forbid someone create something new!
&gt; Same complaints about Facades hiding dependencies and issues with testing. In fairness these are legit complaints. Facades make IDE use harder, the code harder to read for experienced PHP but new to Laravel developers, harder to test with non-standard tools, and basically don't really serve a purpose. Sure you can technically just use the (excellent) IOC container and build yourself a nice clean app, but it feels you are fighting every single piece of documentation, plugin, core component, every step of the way. &gt; If you are building a business critical system which will evolve with the business over the next five to ten years do NOT use Laravel. This bit is rubbish, loads of great reasons to use Laravel even if it's not your preference. 
Seriously as much crap as you get from the community, thanks for creating/developing laravel! Partially got me the job I have today.
think you just ruined Bad Santa for me.
It's true, but not entirely. Some things just more difficult with PHP: * PHP does not have threads. There are phpthreads extension, but it's not really convenient in usage. Also, when I've used it, I've been bumping in segfaults accidentally - so I just restarting my app by cron, but it's not nice. * PHP has a lack of some libraries like math libs for geometry, as well as a lot of other algorithmic libs. So, you should implement it by yourself. And to do it, you should spend a lot of time, learning advanced mathematics and so on. 
Came here to vote for October!
Yeah, they're teaching Laravel at my school and I see how everything starts to click with my classmates; having such a great documentation available is a huge plus for people that just finished with the basic programming course. This is the framework I've decided to invest in for a lot of reasons and I'm really glad it exists. Thank you very much Taylor!
Here is a list of CMSs written in PHP https://en.wikipedia.org/wiki/List_of_content_management_systems#PHP Wordpress and Drupal seem to be the dominant ones in play.
&gt; ~~The PHP~~ _Any_ community seems to be one huge circle jerk of meaningless arguments about nothing. FTFY. 
Yeah that's pretty spot on
Not that it matters, but isn't CMS Airship your project? Well, your company's project?
Since we have opcache in php why you even care if it's single file or even 1000 files?
very helpful video about php for beginners, you'll like it I promise 
I left PHP and went to the Node.js world, you cannot be any more correct in your fix.... Holy shit the bikeshedding there about semicolons or what build system to use is astounding.
Take Drupal for example, there is tons of functionality there that is built and maintained by someone else that covers maintaining and managing content on a website. Unfortunately Drupal (even though it is an "enterprise" CMS) doesn't really integrate well with other solutions. If you want customized applications built that integrate well with Drupal you usually end up having to build a Drupal module. If you are unable to see the value of this then it sounds like you have a bit of a not invented here bias. Basically most of the valid arguments one can make in support of using a framework can also be applied to support using a CMS.
Unless you're talking about Joomla, in which case up is down, left is right, and the only context to be appreciated involves blood sacrifice.
Well, with this approach your rendering useless the choice of any possible framework... 
Yep, that's correct. Just like the big three (WordPress, Drupal, Joomla), it's free software released under the GPL, so you can pick it up off Github and use it without having to ever deal with me or my employer.
Out of interest, how do you separate infrastructure from the core domain with active record systems?
Nobody is talking about making something new, I always recommend everyone to go and do their own framework, and experiment with many different frameworks. But it is a sad community where a framework like CodeIgniter is able to become one of the most used ones... It is a community that doesn't want to learn how to program, just to produce whatever garbage that seems to work... 
I love the 1) In plain words... 2) Wikipedia says... style explanation (and all the other work you've put in this!) Will nudge my interns into reading and learning from this. 
your whole "application" doesn't necessarily need to be all in one language.
Specifically, added typed class accessors and short closures. Thought it was interesting to be able to support the full functionality of an existing site, while shaving about 350 LOC off.
&gt; https://en.wikipedia.org/wiki/List_of_content_management_systems#PHP Pimcore is such a pain in the ass. You end up writing so much custom code to make it work that you may as well write your own CMS.
But is he your mate, blud? 
Good work!
&gt; Also, one day, the earth might be sucked into a black hole. Neither you or I can tell what lies ahead for the future, or for ANY framework out there, nor can you accurately predict where a project will be in 2, 5, or 10 years time. It might have been completely re-coded 5 times, could still be in the same framework because hey, it still works great, who knows. Ultimately, you should choose the right tool for the job now and not because in 10 years time you think it might not still be around or still "cool". Ok, this successfully describes the thought process of a person who doesn't know anything about anything, but most people don't fall into this group, me included. We're capable of analyzing facts, discovering patterns, making projections, and thus arriving at the approximate probabilities of different events happening, then acting upon these conclusions, and sharing them with each other, like OP did. But if you feared black holes an equal amount as web framework obsoletion, yes, it'd be quite terrifying, I give you that. I don't know if I'd be able to get out of bed in the morning, if it were the case. Great point. /s
This is full of typos, and still super good! I'll send some PRs shortly. :)
Adopting semver would just shift the version number that is changing to the left one.
If a service is missing something, then it is the service that will report it, not the container. The container has one responsibility - contain things. The only possible alternative is - not containing things. Even if we're talking about things like autowiring, which the container can't satisfy, then that's misconfiguration of the container, and it can throw *in this case*. But I don't feel that mere existence or non-existence of a service should be an exception. One benefit `has()` would have is that if the service is lazily instantiated, `has()` can respond without instantiating it. That's a reason to have `has()` but I don't feel it's a reason for `get()` to throw an exception on non-existence. ContainerInterface is very similar to a part of the Map interface in Java, which has a `containsValue()` that gives the simple "yes or no" interface, but also its `get()` method returns null on non-existence, rather than throwing. And that's handy. Compare defaults with both approaches: $foo = $container-&gt;get('FooService') ?? new DefaultService(); $foo = $container-&gt;has('FooService') ? $container-&gt;get('FooService') : new DefaultService(); I mean, it won't exactly make your project go over-budget for having to type a few extra keystrokes :-), but the former is more elegant, no? It'll also perform a thin hair better, as it's 1 lookup vs. 2 lookups.
&gt; This goes to show only clueless newbies, AKA self-proclaimed experts, think Laravel is a good idea. I'm guessing you're a non-self-proclaimed expert or a clued-in-newbie?
&gt; If you are unable to see the value OK, I see I have to explain my comment: I see the value. Drupal and ModX are my favorite CMS. They are different, that's why I can't choose the best. But it is not about size, functionality and quality. Both CMS and frameworks are huge markets. I would even say each framework or CMS - they are huge markets each one of them. I'm not saying there is no value in knowledge of some CMS. Both worlds of frameworks and of CMSs have their employers and employees. And top CMSs and frameworks - all of them have a big infrastructure. So. What is the reason to switch? If one have knowledge and is experienced in frameworks, have job/freelance work, and thanks to experience - good salary/wage - what is the reason to start the career from a scratch? Why?
Use PDO or ADOdb
how much lines are in that project?
Of course, but composer follows semver, just like npm and yarn do in the node world. It's good that Laravel also follows it, even though it's "just shifting the version number to the left one" because semver is not for us as humans to read, it's for computers to know how to act. For instance if I do `composer require laravel/framework:^5.4` that will tell composer to install any patch and minor releases that are `5.4` and newer, but not `6.0`... So if I don't follow along with development of Laravel, and I find out a new release is done, I should theoretically be able to just run `composer upgrade` and that will do all the necessary stuff to say "Hey, 5.5 of Laravel was released, this is a minor release, lets pull it in" whoops, it's not though, because in Laravel's world, 5.5 is a major release. Honestly, I love Laravel and this won't deter me on using it or talking badly about it, but I'd absolutely love from a maintenance standpoint to see the next major release (5.5) be branded as 6.0, and follow proper semver from then on. Don't be afraid to bump that major version number when introducing breaking changes.
And having logic, html, db calls in one file and procedural spaghetti code is very popular too. Doesn't mean it's a viable solution. 
A little over 1,000
Tell that to people like Drew Wilson (who wrote his own spaghetti framework that has a lot of `if` statements on `$_GET` requests) of Plasso.com, or Pieter Levels (who has even scarier code) of NomadList.com, or even better, Slack (who is using no framework, spaghetti code, and fucking JQUERY)
Interesting view, I can respect it. I get the message behind it... &gt; Don't blindly update dependencies on the whim of a number change. Like I said, I won't let that change my view of Laravel, I'll still build everything in it that I can, but I'm personally a strong believer of SemVer and personally will always publish everything I make to follow it. Keep on, keeping on, Taylor.
No. It's bad. It's fine for a quick POC, but it almost always has to be rewritten and adding others to the project just makes it worse. You can use a screwdriver to hammer in a nail, but there are much better, easier ways to do it.
Or use Bedrock with Roots if you're choosing WP since it has composer, grunt (I think for the 9.x release, but would prefer they use at the very least gulp), and they even use Laravel Blade. 
You can rewrite it from a scratch in one week. Just do it! :D
And features!
I was on mobile and made a typo. That code is spaghetti and I do want to separate the html and php and clean up the JavaScript. So that it's not so ugly it needs a paper bag over it's head :) so the question was, suggestions on best practices and approaches that have worked well for others. 
A fortune 500 company isn't interested in you building a site from scratch using laravel or symphony. They might be interested in a specific web app but even then if they are already using a large CMS (ektron, sitecore, drupal, etc...) they are going to want it built in to that. 
I can give you an opinion. Once upon a time Java programmers had a complete ecosystem, massive support from multiple vendors, an author with a mission and lets face it PHP was a scripting language. Since then PHP has been massively improved with version 5 having full OOP and version 7 filling in some missing stuff and having massive performance. Java may have also improved since I last used it (a while ago), but I think it is true and fair to say you can build large complex enterprise applications in both stacks as you can in .NET. All have their pros and cons, but all are competent, widely used and widely supported. So why might Java be imploding - since Oracle bought Sun the author with a mission hs changed a bit, or at least the mission has changed. Some supporting partners like HP and IBM are very wary of Oracle using Java as an entry point into their big clients and have cooled off a bit or at least turned equal attention to other stacks whereas a few years ago they were pushing Java hard. Some of the more recent Oracle releases have (as I understand) not completely kept to the founding principle and left some java programmers unhappy and maybe switching stacks. I think the biggest implosion apart from Oracle screwing their customers and their programmers is the change in attitude to Java just based on Oracle owning it. Of course all of this is just an opinion based on having been around 20-30 years (I started coding as a trainee in 87). 
Love it! 
This seems to be trending on github at the moment hs anyone tried this yet https://github.com/craftcms/cms
I don't think so. An [other comment](https://www.reddit.com/r/PHP/comments/5ue0gu/a_critical_analysis_of_laravel/ddu554l/) addresses this concern: &gt; Sure you can technically just use the (excellent) IOC container and build yourself a nice clean app, but it feels you are fighting every single piece of documentation, plugin, core component, every step of the way.
This is a good ebook in the subject: https://leanpub.com/mlaphp
If you'r familiar with Laravel and WP, you can explore how those frameworks implement the features you use every day. I think this will be educational. After all, they **are** "vanilla PHP" under the hood. Well I'd direct you at reading Laravel's code more than WP, because WP is using very outdated practices and its code might give you cancer. But yeah.
better write your own CMS, &lt;insert shitty prefixname&gt;CMS. Problem solved. Oh wait...
That would be fine, at least it'd be clear breaking changes are incoming. Longer maintenance of major versions also, at the very least security wise. I only use Laravel on command line, cron job type apps because I don't trust it enough to leave it exposed to the Internet. 
Awesome!
PDO is a must.
JMS Serializer is very slow and use lots of memory.
Statics and functions everywhere, files used as methods, directories used as classes. I guess if someone wanted to see what a REST API would look like in PHP4, that's the answer. Talking about REST, WTF is this: | GET | /beers/create | create.php | | GET | /beers/{id}/edit | edit.php | It appears as if Siler is mapping mutating functionality to GET... ? Is this about reading the *form* for editing and creation? Not sure what this has to do with an "API", but...
Using '?' is not a good idea with postgres. It is used for some [JSON operators](https://www.postgresql.org/docs/9.5/static/functions-json.html#FUNCTIONS-JSONB-OP-TABLE) which is a pain.
But facades and eloquent are turned off by default I think. Mitigates 2 of the points made by the article
You completely missed the point I was making if you genuinely think I literally meant the world is about to fall into a black hole - it's a stupid analogy, just as stupid as this article is in it's "Laravel is only good for prototyping, you *need* to throw it away for any of your projects to be successful" mentality. Try to predict where Symphony will be in 10 years time, or any framework and I can almost guarantee you'll be wrong. My point being - use the right tool for the job now, not because someone says it *maybe* bad or not "cool" in X years time. If Laravel isn't the right tool for the job now, then don't use it.
Who puts pepperoni on a burger?
 $tableName = (isset($_GET['TABLE_NAME']) &amp;&amp; isset($_GET['TABLE_NAME']) !== '') ? $_GET['TABLE_NAME'] : 'orders'; $dg = new C_DataGrid("SELECT * FROM $tableName",'orderNumber', "$tableName", array(...)); Unless I am mistaken, this is some pretty blatant SQL injection and should not be encouraged.
[For starter](https://twitter.com/ShrapnelCol/status/811554258927702016)
That's not a reason for "PDO is a must". I agree that PDO would be a better alternative than mysqli, but it's not a must.
don’t bother and report spam
&gt; By standardizing the way entries are fetched from a container, frameworks and libraries using the Container PSR could work with any compatible container. That would allow end users to choose their own container based on their own preferences. Read more in the [Why bother?](https://bungalo.com/property/170?d_from=26-08-2017&amp;d_to=02-09-2017) section
When I read this "discussion" I see "PHP vs. Java" in front of me. Me and many others think that Java is bullshit, but some protecting it and be like "Java is extremly powerful if the developer is coding correctly". Still till now I never saw a "good" Java product. - Blackberry Administration Panel - VMWare - NetBeans (Needs hours to start and when I used it, it was bugged es hell.. it might be powerful and one of the best IDEs, I don't want to discuss about it, just telling you that I made THIS experience) - OpenOffice Just a few that I remember that were (for ME and my experience that I made) horrible in overall performance. Just bad developers or coincidence? What ever, don't want to change the topic or start a discussion that has NO END or correct answer at all. Don't answer on this point, just read and accept. So this sounds similiar. I don't know about Dave, the Architect (he could be a known PHP Developer or just "someone"), but his Post sounds legit. Maybe I got manipulated and it's all biased or false experience.. or he is correct. It sounds like it's correct. I played around with Laravel before I used Symfony. Laravel was nice and made fun, but slowly became more or less irritating. Also a mate is like "oh no, don't use that shit. Fasaced,.. wtf is Eloquent for a name.. Illuminate.. yea, illuminate your code..". So we went to Symfony and damn.. Symfony is a hell of a strong environment! I don't know.. if you know how it works, you can build up pages pretty fast. How is Laravel doing this faster? By a shorter learning curve or more magic? In the end.. why we just can't saw that both are good and you should use which one is making you more comform like "oh, I like the term ORM and eloquent sounds like bullshit", well then use Doctrine as ORM.. in Laravel or Symfony, whatever you like. &gt; Symfony or Laravel. I'm happy working with both! - dsarchyuk
 PHP Fatal error: Call to a member function detectSarcasm() on null …
Well I'm not sure I agree with that comment either....
Well, not quite, not everything needs mocks, if that's what you imply, but I get your point :-)
A week? there isn't much going on in that script, could probably thrash that out in a few days but yeah for such a tiny project a rewrite is more than viable 
I can't help your own superstition heh 
Disagree. phpMyAdmin does the SAME way for both database and table names in URL query string. 
I tried that, it's not the problem. If I do a straight redirect with header('Location: foo.php') it works just fine. The problem must be with the Response object.
ha it is used for writing large apps, though.
Who puts a burger on a sub at Subway? So many questions.
Such a well-researched article. The author is as substantial as the content within it.
I guess "haters gonna hate". 
Headshot directly in my face. In a funny and stupid way I completly ignored the fact that these all products (that I use and love) are built on Java.
we have to give credit where it's due, now let's remind the java people what language facebook and wikipedia are written on :) 
Thanks, I didn't know about that. That does make it a bit harder to just wrap the PDO class in another class that handles the mapping, you'd have to reimplement the actual prepare function to use postgresql's `$` parameters instead of the usual `?` unless there's some internal flag in PDO to adjust the placeholder character, though I don't see anything in setAttribute or the pg driver to do that. (Based on [this post](http://stackoverflow.com/questions/30461558/jsonb-existential-operators-with-parameterised-queries) it looks like something needs to be done about this...)
Check whats being set with the following: \session_get_cookie_params() \session_id() \session_name() It could be down to the domain not being set correctly. framework: session: cookie_domain: .yoursite.com I would also check session.save_path
&gt; I know the mentality of many developers like you: just churn out a product, bill the client, and then away you go to the next one. But some of us think long term, because they're in it for the long term. We don't just think paycheck to paycheck, we need to make sure our platform and architectural decisions make sense in the long term. We commit to maintaining and evolving a solution, not just shipping version 1 and disappearing. You are suggesting all developers that use the right tool for the job now, for the project, are just out for money. Your also suggesting that Laravel is not a good choice because you won't be making as much money as say, Symphony. This is libelous and defamatory. Also using the right tool for the job "now" doesn't mean not looking into the future, or predicting trends, which you seem to think it does. It means weigh up all the choices, looking into the future and predicting business requirements, then use the right tool which matches that job *now*. If that means Laravel, or Symphony, great - but don't generalise (like this article does) that Laravel is only for prototyping or short lived projects in all cases, because that's simply not true. &gt; By that time we were 100% HTML5. So the code's not been adapted at all since 2007, because it was HTML5? Sure. Also, you decided HTML5 was the better tool for the job at the time because flash was phasing out - what's your point? That's the exact point I was making. &gt; Another reason Symfony is a better choice is because it's more componentized, so you can use aspects of Symfony through adapters and facades (not the Laravel ones, but the real pattern), which makes every component you use easily replaceable should the shit hit the fan You realise you don't need to use facades, right? Sounds like you have a fundamental misunderstanding of Laravel. 
Apart from WordPress, Drupal, Magento and Joomla what are these general PHP jobs based on if they're of significant scale and not based on either Symfony or Laravel? Are you saying there's a lot of bespoke PHP being developed without the use of major frameworks?
We have [no idea what you're talking about](http://www.cbsnews.com/pictures/burger-breakdown-best-and-worst/17/)
True, but they were all quite large by any standard when they began moving toward Hack.
You can create a big app in any language, what I'd like to highlight as some food for thought is the reasons those companies needed another language. What is PHP missing that HackLang offered, and I'm pretty serious when I say it is not only performance.
Haha its strange the things Americans put together in their food, unique combinations you don't really see anywhere else. I'm not saying its a bad thing its just very different 
You shouldn't do Reddit while drunk, this stuff is so hilarious...
I thought you are a newbie because you can't decide what to do with that not very long script. I agree with you. Rewriting usually takes much less time that creating. So, be brave, go and do it! :D 
Damn, i actually clicked the link. Can we get a [CLICKBAIT] tag on bait posts?
That's it!? You can blast this out in no time.
Could you please provide some proof of your postulate?
No headers sent previously, I'm testing this pretty much in a standalone script.
Insofar as is possible, I like to work bottom-up on things like this. Here's my process for dealing with legacy code: - Format the code and remove any dead code (including commented code), and any useless comments. The goal here is to make it possible to actually read the code that's doing anything. - Install Composer and set up a PSR-4 autoload space. All of your new code goes in there. - Install an ORM or database-abstraction layer of your choice. Start to extract all database access into these objects. The goal is to centralize all contacts with the database. This will support any database refactorings that you may do later and give your domain-specific code a place to live. You may end up with fat models, but a later round of refactoring can shuffle that logic into yet more appropriate places. - Find any repeated code that doesn't go into models and abstract that out into objects or migrate it to use a library. With this step and the one above, you're trimming down the size of your spaghetti, so it becomes a spaghetti of only controller code and presentation code. - For each remaining spaghetti file, put a big, loud, and obvious comment line at the very top. Presentation code does not go above this line. Start refactoring the file and moving as much code above that line as you can without violating the rule. You'll end up with controller code at the top and presentation code at the bottom. Delete your comment and move the controller code into a controller and the presentation code into a view. - Your presentation code should now just be a spaghetti of PHP templating and JS. Time to pull out the JS into a separate .js file. Keep on iterating until you have clean code.
I didn't manually use a "Cookie" header, the Request object passed it that way I guess. I know I shouldn't pass them like that, it's just something I tried. I shouldn't have to manually pass the session cookie everytime I use the RedirectResponse class too, right? There's no case of it being used like that. I tried looking at Laravel's and Silex's source code (both of which use HttpFoundation and RedirectResponse) but I can't figure what they do differently.
MY EYES!
Really good resource.
Depends on what the rest of your code is doing. Here is a working example: // flash.php use Symfony\Component\HttpFoundation\Session\Session; use Symfony\Component\HttpFoundation\Request; use Symfony\Component\HttpFoundation\Response; use Symfony\Component\HttpFoundation\RedirectResponse; require '../vendor/autoload.php'; $session = new Session(); $request = Request::createFromGlobals(); if ($request-&gt;isMethod('POST')) { $session-&gt;getFlashBag()-&gt;add('flash','The Flash Message'); $response = new RedirectResponse('flash.php'); $response-&gt;send(); exit(); } $html = ''; foreach ($session-&gt;getFlashBag()-&gt;all() as $type =&gt; $messages) { foreach ($messages as $message) { $html .= '&lt;div class="flash-'.$type.'"&gt;'.$message.'&lt;/div&gt;'; } } $html .= &lt;&lt;&lt;EOT &lt;form action="flash.php" method="POST"&gt; &lt;input type="submit" value="Flash Me"/&gt; &lt;/form&gt; EOT; $response = new Response($html); $response-&gt;send(); 
You have no idea how facades work under the hood, do you? They are testable, and can work exactly like services you describe - it's just their usage which varies. Take a look at the filesystem in laravel and the driver method.
**tl;dr** Just a spammy blog post again the opening line sets the tone and the low quality of the article: &gt; PHP (Hypertext Preprocessor) is used as a general programming language for web development. It’s a server site scripting language that powers roughly 240 million websites.
**I CAN'T FUCKING BELIEVE THIS.** This is pretty much the code I wrote... except the *exit* after the *$response-&gt;send()*. This is what was fucking everything up. I can't believe this. The old redirect function had the fucking *exit*. I'm sorry you had to write that whole thing just for this stupid thing, but THANK YOU SO MUCH. I was about to murder someone.
So you were caught out by your own arguments and now claim the other person is drunk, cool. 
Glad to help. I usually work inside of the Symfony framework which hides some of the details. But every so often it's nice to get back to basics. 
In "other discussions" I also found this: http://thecodelesscode.com/contents Fun stuff.
HttpFoundation is a godsend. It's amazing how much code you can clean up just by including it. Lots of shitty custom code for dealing with sessions (and flash messages), file uploads, and general request info. It's so nice to throw all that away and have a sane way of dealing with these things.
Ah right, well that was me out of ideas because this should just work without having to do anything fancy, then I saw your reply to the working example :) I'm so used to just returning my RedirectResponse objects in a Symfony controller that flow of execution didn't even cross my mind. Glad you got it working, I was beginning to question reality myself...
No dude, you're not even responding "to my arguments". Your response reads as if you saw *every third word* of what I said and tried to guess what the rest was, with spectacular results. Especially this bit: &gt; This is libelous and defamatory. Comedy gold. BTW, here's what facade I was talking about, **as I said**, not Laravel's, but the real pattern: https://en.wikipedia.org/wiki/Facade_pattern You provided a stock "you don't have to use Laravel's facades" response, which was completely irrelevant to what I was talking about, I guess out of ignorance, so I thought the link might be educational. 
Yeah, I guess I expected the RedirectResponse object would halt the execution after sending the response (what the hell would you do after sending it?). Maybe the RedirectResponse should have its own *send()* method that halts execution after it? It makes sense, I guess. Thanks for the help anyway!
&gt; except the *exit* after the *$response-&gt;send()*. Perhaps that was killing PHP while it still had unsent content in the output-buffer? 
I like the concept but I'm a little unsure of the results; Twitter does not seem 49% positive towards Trump. It seems a lot more than 20% negative as well. That probably says more about the source you used for analysis rather than your library.
Then maybe PHP is not the best language for your problem
&gt; And while you can simply not use facades, you can't so easily retrofit code which uses them into not using them You can, actually. Based on the responses you've given *your* the one quite clearly Laravel-bashing without giving an ounce of respect to the hard work put into the development of the framework. &gt; Even more weird: Laravel creator rushes in to defend Laravel by talking about how much money he made with it. I'm not going to waste my time explaining how disrespectful that is. 
That's right, but the core team is going to move to Zend3 or Symfony. Should happen within the next weeks.
This, and you never hear about a static site getting hacked. It's less maintenance overhead.
What we was saying was that he did NOT have the exit after the send basically resulting in two different responses being sent with unpredictable results.
It will only hog ram if you don't clean up after yourself. The other option for an infinate loop which means you can be a little messy without worrying is using the watch command. 
I haven't had a good chance to dig through the code. How are you determining sentiment? An outside source or another dependency or something else?
Sorry I am not very familiar with those frameworks; I meant like for example tinyMCE editor, and additional features like for example oEmbed, where you just drop youtube video, tweet or anything into the editor and it is automatically embedded. Simply, the editing of articles is already done and working. But if it can be achieved by bundles in those framework, then OK.
You could re invent the wheel as a learning exercise? Write a regex parsing router on your own, or create a DI Container. Something that shows you know the nuts and bolts of modern development, and you don't just consumer pre existing packages.
This is a good idea, I might take a look at how eloquent is handling things on the backend, could be really interesting. Thanks!
Yea if you are not careful about clearing memory then that is exactly what would happen. What is the reason you don't want to run a cron job? What if you set up a cron job that executed an infinite loop, but checks the run time very 100 iterations or so? If the run time is over 60 seconds, exit; Then, the cron job will start another one the next minute. Another option would be to set up a cron job that checks for a file lock. If the file lock is not there start the PHP script. While the PHP script is executing, periodically check it's memory usage, if the usage goes over XX MB, remove the file lock and exit; The next time the cron runs, it will see the file lock is not there, and start over again. I think a cron job will be your easiest bet. Alternatively, you can write the script and check it's memory usage through the loops and see if you can at least optimize it to use the least amount of memory.
Can't agree with you on this one. I started using it about 5 years ago and immediately liked it. I'm using it since then and do all kind of stuff with it. I also created several plugins, one of it is the biggest plugin for Pimcore there is. It's an eCommerce Plugin called CoreShop (https://github.com/coreshop/CoreShop). I do work as a freelancer and pimcore export for several agencies and many of them just started recently using it and they never experienced any problems in starting using it. 
Have a look at Pheanstalk, it's a php library for beanstalkd. Basically, you create "tubes" where your main app can put messages in and your worker script (the one that always runs) can get those messages that contain data and act accordingly. The worker script just waits for messages in the tube. As a heads up, be careful with long running scripts that connect to the database. If enough time has passed with no database actions , you may need to reconnect to the database. 
Just another anti-COBOL rant.
I've been running PHP processes in a long running daemon like manner for ages and haven't found them leaking memory for ages (not since PHP4/5.0). When they do it's because of something stupid I've done and is easy enough to fix/diagnose. Having said that, I do tend to make them self terminate after so many jobs (perhaps a few thousand) or a set time - with something like supervisor responsible for restarting them. I'd suggest you also have some sort of "you need to restart" signal/flag (perhaps a special job packet, or just checking some file/variable/database value on each 'loop') so you don't have problems with old code still running in a long running process after you think you've deployed an update. 
That's cron abuse, IMO. I mentioned supervisord in another reply. If you have a unruly process that hogs memory, you can appropriately use cron to `supervisorctl restart myservice` on some schedule. But in my experience even fairly heavy processes don't need to leak memory. I have queue workers juggling multiple Doctrine EntityManagers, and a little care in cleaning up at the end of the loop ensures they're memory-stable.
You should look into a producer/consumer messaging pattern, instead of constantly querying the database for new records. The process in charge of writing to the database can also produce a message (into a service bus) that a consumer picks up and performs the desired operation upon receipt. This will help with scalability. 
Be sure to check out https://laravel.com/docs/5.4/queues .
use mysqli, PDO is a slow bunch of shit
Planning on going to Iceland buddy?
&gt; My own solution is to create an infinite loop in PHP and run it as a background processes with nohup. You should manage this better. As long as you have the `pcntl` extension, you can do proper forking and daemonize things correctly. Should make things a bit more reliable. I made [a library](https://github.com/Firehed/ProcessManager) for this a while back, although the docs may be slightly out of date. &gt; However I have read that a PHP script running for ever is BAD. After a while it will hog gigabytes of RAM (and other terrible things). Only if you do dumb things. Anything that would be request-lifetime caching in a normal web script (singletons, most uses of `static`) will grow out of control. This won't be an issue if you discard data when you're done with it. I have scripts that have been running for probably two years uninterrupted. HOWEVER, polling a database directly is almost certainly the wrong way to do what you want. Get workers that talk to a message queue. Conceptually they're similar, but it avoids a lot of overhead and will handle implementation details correctly that you otherwise may miss (job failure and retrying, etc). My library above has an implementation for a Gearman worker, and making a new one for e.g. RabbitMQ shouldn't be terribly difficult since the model is about the same.
So would you consider my above approach to be one of a "clueless newbie"?
Also, we provide security fixes indefinitely.
Have you tried this option? use Symfony\Component\HttpFoundation\Request; use Symfony\Component\HttpFoundation\RedirectResponse; use Symfony\Component\HttpFoundation\Session\Session; use Symfony\Component\HttpFoundation\Session\Storage\Handler\NativeFileSessionHandler; use Symfony\Component\HttpFoundation\Session\Storage\NativeSessionStorage; // init and start session $config = array(); $config['session_name'] = 'webapp'; $storage = new NativeSessionStorage($config, new NativeFileSessionHandler()); $session = new Session($storage); $session-&gt;start(); $request = Request::createFromGlobals(); $request-&gt;setSession($session); // set flash message $request-&gt;getSession()-&gt;getFlashBag()-&gt;add('success', 'Success message.'); // save session if ($session-&gt;isStarted()) { $session-&gt;save(); } // send response $response = new RedirectResponse('foo.php'); $response-&gt;prepare($request); $response-&gt;send();
Wasn't so much the php side of things. I haven't written a ton of code in quite some time so I was just seeking opinions on best practices basically. I appreciate everyone's comments and ideas :)
&gt; I'm not really arguing it's a perfect solution or anything, but I am curious if this changes at least your concerns relative to extendability. I see many patterns where this code reinvents built-in functionality, like constructors and constructor arguments, and I still see coupling to a static payment configuration, which is now pushed to another class: the static Conf class, which provides a "default" payment service. I'll illustrate my examples with some source. I'm assuming your first code block runs in a controller. Currently we have this: public function controller_action(...) { $card_details = [ 'provider_class' =&gt; 'PaymentAuthorizeNet', //optional 'provider_payload' =&gt; ['merchant_id' =&gt; 'X', 'password' =&gt; 'X'], //optional 'card_number' =&gt; 'XXXX', 'exp_date' =&gt; 'XXXX', 'card_code' =&gt; 'XXXX' ]; Payment::chargeCard($card_details); } What I instantly notice is that we're using this array for two distinct purposes, construction details, and payment details: public function controller_action(...) { $card_details = [ // PROVIDER CONSTRUCTION DETAILS: 'provider_class' =&gt; 'PaymentAuthorizeNet', // SAME AS "new CLASSNAME" 'provider_payload' =&gt; ['merchant_id' =&gt; 'X', 'password' =&gt; 'X'], // SAME AS "new class(PARAMETERS)" // PAYMENT DETAILS: 'card_number' =&gt; 'XXXX', 'exp_date' =&gt; 'XXXX', 'card_code' =&gt; 'XXXX' ]; Payment::chargeCard($card_details); } So we can eliminate the extra class and the static call and use PHP's native conventions for what you're trying to express above: public function controller_action(...) { $provider = new PaymentAuthorizeNet(['merchant_id' =&gt; 'X', 'password' =&gt; 'X']); $provider-&gt;chargeCard([ 'card_number' =&gt; 'XXXX', 'exp_date' =&gt; 'XXXX', 'card_code' =&gt; 'XXXX' ]); } Notice that we have the same configurability options as earlier, but we eliminated the static call and the redundant "Payment" class which was only constructing and calling "Provider" objects. In fact we gained an extra ability: do multiple payments (and other operations) on the same provider, because we have the instance at our convenience. But now that we've refactored this a little, we see that we haven't solved our initial problem "controllers shouldn't care how is the payment made, they should just call into a payment provider". We can make those construction arguments optional, just like your first two $card_details are optional, but if we do this, we cause another problem for ourselves: we hit a set of "default globals" which can't be configured on a controller-by-controller basis, i.e. we've merely moved the issues of "global statics" to the provider constructor (which now aggregates the provider initialization logic that used to be in Payment::chargeCard): public static function __construct(array $config = []) { $this-&gt;provider_class = $config['provider_class'] ?? Conf::get('DEFAULT_PAYMENT_PROVIDER_CLASS'); $this-&gt;provider_payload = $config['provider_payload'] ?? Conf::get('DEFAULT_PAYMENT_PROVIDER_PAYLOAD'); } So how do we make sure controllers are individually configurable, so we can have, say, groups of controllers with one setting, and a group of other controllers with a different setting? Or how about multiple payment providers etc.? First we need to eliminate any global "defaults" and make configuration explicit: public static function __construct(array $config = []) { $this-&gt;provider_class = $config['provider_class']; $this-&gt;provider_payload = $config['provider_payload']; } Second, we go back to the controller, and we eliminate the provider construction and accept a provider from outside: public function __construct(PaymentProvider $provider) { $this-&gt;provider = $provider; } public function controller_action(...) { $this-&gt;provider-&gt;chargeCard([ 'card_number' =&gt; 'XXXX', 'exp_date' =&gt; 'XXXX', 'card_code' =&gt; 'XXXX' ]); } Now the $provider can be instantiated outside the controller, once, on demand, by whatever entity up the chain is instantiating and using this controller. And the controller, as you see in the last example truly doesn't have to know or care *which* payment provider it's using, and how this provider *is configured*. Of course, we can go way back to the original example, and inject the configuration instead of the provider: public function __construct(array $providerConfig) { $this-&gt;providerConfig= $providerConfig; } public function controller_action(...) { Payment::chargeCard([ 'provider_class' =&gt; $this-&gt;providerConfig['provider_class'], 'provider_payload' =&gt; $this-&gt;providerConfig['provider_payload'], 'card_number' =&gt; 'XXXX', 'exp_date' =&gt; 'XXXX', 'card_code' =&gt; 'XXXX' ]); } ... however as you can compare both, injecting the object is cleaner, doesn't require an extra static class "Payment", and is more flexible, as the configuration for the provider can *change completely* and nothing in the controller would have to change. 
I've been taking this for a test run recently: http://amphp.org/ "Amp is a non-blocking concurrency framework for PHP applications." It uses libevent, ev, or php-uv, and it's got a web server package that supports web sockets. So far, so good.
maybe look into supervisord
No.
Personally, I don't think its worth it. Imagine there is a locksmith certification. One day you need a locksmith, so you call a certified locksmith. He shows up, hits a hammer to your window, opens the door, and hands you your keys. Wow, what a class act, right? Will you ever trust a locksmith that says he's a certified locksmith now? No, you'll want to see their proven track record. You'll want to hear from their previous clients about their experience with them. You'll never trust that certification again. So what's the point of the certification? All it takes is one bad apple to ruin the bunch. Each company will have that "ah hah" moment when they realize that certification is not a consistent indicator of real-world applicable skills and abilities. At that point, it will be glossed over and not even considered during the hiring process, deemed useless.
I use Supervisor in conjunction with Laravel workers and SQS queues at Amazon. It's super robust.
My main concern would be the lack of garbage collection. Maybe it would be better to have a lighter wrapper (i.e. bash script) process that would repeatedly call your main php logic.
How does the consumer pick it up? Don't you need a process running to do that?
If there is ever a dissenting voice... it is always Garfield's. 
If you know someone from Hogwarts, just ask them to use Crapus Reparo on that code. Or you can hire someone with PHP knowledge. Or you can try to do it by your self.
You can use a message queue, which can be either push or pull. Push means that it will notify your code via webhook or some other method, and pull means your code is polling to look for new messages (much faster than querying the DB) every so many seconds.
Incorrect. Building tax profiles is something a lot of software and other engineers have done for a long time. It's not difficult. All the information is freely available online. Your post seems to indicate that you're connected to Avalara too. There are others that do the same function. 
Oh I'll learn and fix it :) I didn't write 99% of the code you see, I just took over making sure it didn't break about a decade ago
One thing to worry about, using the infinite loop process, is when the server reboots the process will not start again automatically.
You might want to try out [PictShare](http://www.pictshare.net/) it's open source (you can host it yourself if you want) and you can resize and rotate images just by changing the URL. You can also [upload images via PHP](https://github.com/chrisiaut/pictshare#upload-via-post) and get the URL for your image. ## It's demo time * Original Image: http://www.pictshare.net/b70bee91a4.jpg * Thumbnail 800x600 http://www.pictshare.net/800x600/b70bee91a4.jpg * Thumbnail 100:100 with fixed size http://www.pictshare.net/100x100/forcesize/b70bee91a4.jpg * Black/white http://www.pictshare.net/grayscale/b70bee91a4.jpg * [and much more](https://github.com/chrisiaut/pictshare#smart-query-system)
I think you are using the wrong google credentials for this job. You should be using Google Service Account instead of OAuth Client ID. Service Account is designed specifically for server - server communication, thus it wont require client authentication - consent screen. 
[removed]
The only way I know - reject using eloquent models in logic and use own objects which will be filled by eloquent in factories, like repositories. But it's terrible amount of work - better take the doctrine. But, honestly, in this case there are no need for laravel at all - there are a lot of packages for DI, routing, symfony packages - so we are able just to configure it all and work with simple "framework", or just use symfony.
Brilliant! Did not know about this
I would like to add, that facades are hidden dependencies. And it's really terrible within large apps.
But should I listen to you?
Same, but Symfony and RabbitMQ.
Please do share your very thorough survey results of "most" team leads. 
Actually, it is pointless, since the framework should use the container only. That's also why there is no "set". Framework is not application or library code. Therefore it must not be reusable. Interfaces are about reusability. What happens of course is, that the container is passed to the application or library code by the framework. Don't do it. Remember: If your application or library code has a dependency on a DI framework, you did it wrong. Only frameworks should access the DI container. It's called inversion of control. You'll love it.
Definitely Good. If you customize the original theme, and a new theme update comes out, it will overwrite your costumizations. If you modify the child theme, otherwise, your customisations are safe.
Thanks for your feedback, always appreciated. By the way, you **didn't argue with any** of the points I listed in my article to enforce why NULL is a bad idea. But, yet, just doing a Symposium by yourself, discussing a thing (the Burger use case) which **is not the purpose of the article**. When referring to &gt; strongly suggests that an associated object has to exist You **can't know** if this could happen or not, we didn't talk about the business case. It can be possible at all, it **depends from the use case**
Thanks for your feedback. *Shorthand*, isn't what I/many people want to achieve, but yet, what we want to achieve is low technical debt, high maintainability, less bugs, better codebase, less headaches. Returning `null` also means, that the method returns a mixed, which is a terrible idea IMO
... but you would write your parent-theme knowing that child-themes are a thing, so you would keep that in mind when making updates.
With authentication, like this library: https://oauth2.thephpleague.com/
The chain of responsibility seems like it looks for an object to handle a request. I am not sure that would work in my situation. So I have a command say DELETE, Before I can execute the command I have several validation steps that must pass and only then can the DELETE command be executed.
There are a couple of possibilities, depending on exactly what your setup is. 1. If your application is hosted/runs somewhere with a static IP, you can use `$_SERVER['REMOTE_ADDR']` to check the IP and deny access for anyone that isn't your IP address(es) 2. You can use API tokens, or another authentication method to check that the request is authenticated. 3. You could encrypt the response with a secret key embedded in your application
1. /r/phphelp 2. authentication is all you can do, if applicable
It's not possible to make it fully restricted like you want. What you can do is set the 'Access-Control-Allow-Origin' header. E.g. if your website is www.exampleA.com, you could add the following to your API nginx block add_header 'Access-Control-Allow-Origin' 'https://www.exampleA.com' always; While this doesn't prevent everyone from accessing your API, it will prevent access to end users using browsers, browsers honor the Access-Control-Allow-Origin header. If a user visits your site, https://www.exampleA.com and your JS code sends a request to your API, everything will go well because the browser will set the origin as https://www.exampleA.com and your server will accept the request. However, if some third party website, e.g. https://www.exampleB.com tries to use your API in their web page it will not work: User visits their site, their JS sends request to https://www.exampleA.com, the browser sets origin to https://www.exampleB.com, but your API will reject that request because www.exampleB.com is not an allowed origin. However, this doesn't really prevent access to your API, anyone who wishes can still access it, changing the origin is easy, e.g. all you have to do with curl is curl -H "Origin: http://www.exampleA.com" http://www.exampleA.com/api/endpoint
Consider this code: $event = new PreDelete($foo); $dispatcher-&gt;dispatch($event); // your validators, etc are hooked up and can prevent the deletion if ($event-&gt;isDefaultPrevented()) { return; } $entityManager-&gt;delete($foo); $dispatcher-&gt;dispatch(new PostDelete($foo));
That's a really really bad approach. Build your API assuming someone else *will* be using it. If someone wants to, they will. End of story. Your safest bet is to assume it will be used and make sure you take the proper security measures into consideration. Have a general public side of it, and a user-authenticated side. The API should be checking the credentials of the logged in user session and only allowing things that user is allowed to do. From your API's side, a browser is no different than a shell script I write to impersonate my session. 
While I agree you can't really block people from trying, [Security through obscurity is no security at all](http://stackoverflow.com/a/534006/4026897)
Right, so you have a chain of classes, all using the same interface, and the final one does the delete. If any class in the chain fails the request to delete, it never gets that far and you report the error.
Any kind of secret token would work. Auth header, same origin policy, oauth, etc.
Given he is talking of JS, none of your suggestions would be of any help
What makes you say that? OP was not specific about his setup. Certainly 1. will only work for a very specific set of circumstances, but why do you think 2. and 3. wouldn't work? EDIT: Just saw you even suggested 2. in [your post](https://www.reddit.com/r/PHP/comments/5usluj/how_would_i_make_it_so_my_api_is_only_accessible/ddwj9wm/) as a solution ...
excellent. Some, if not most patterns are quite similar. In which situation to use proxy vs mediator pattern by example?
If JavaScript has that secret token (and it needs to, otherwise how would it send it back to the server), so do the "malicious" API users.
The problem with new versions of PHP always is the upgrade issues. Too much afraid about upgrading. 
the list is long but i'll list a few * it's easy to scale large webs by using multiple servers for the load * have better security with half the code or complexity * it's truly OOP * Reusabiity * Objects There's a lot of info in the internet [like](https://www.conetix.com.au/blog/why-you-should-use-pdo-instead-mysqli) or [like](https://phpdelusions.net/pdo#why)
There *shouldn't* be any breaking changes in minor releases, but admittedly I have been caught out by one before. 
OMG THANKS ALLOT :D damn i was like 2+ hours with this error just to be a small thing :p
fuck sake man. Why.
You can't, generally. If the App is on a closed system (like iOS) you could use SSL pinning and all endpoints/data will be encrypted with MITM impossible. However, once the device is hacked that can all be undone. The best you can do is rate-limiting and monitor for abuse.
Right I should have clarified that secret token could not be available in the browser.
oh thanks ill check them out
So tell us about the dog first - breed, personality, traits? 
You are not describing your situation well enough for us to help you properly. 
T_PAAMAYIM_NEKUDOTAYIM
Ok and I fail to see your point. So what if someone uses code ignitor. Honestly this sub shits on anything not laravel or symfony. You want to learn PHP the best way forward is to create your own stuff. Plain and simple. This sub should be encouraging this not shitting on others. Seriously this attitude is not inclusive at all and just promotes potential users of the sub to not want to participate.
Ritchie
Good. For work we use a subtheme of bootstrap on drupal. Gives us a lot of flexibility and in built goodness. One major update for bootstrap messed with the breadcrumbs on a couple of sites for that, but that was because we had a custom function that was altering them. I think we just ended up removing that function and all was well! 
Zend's latest iteration of its money-making racket.
sudo
Nibble
Suggestions: JS calls to PHP, that PHP CURLS to API PHP. This is similar to using Stripe API, you have to pass keys from PHP to PHP. Alternative: Whatever data you are returning required POSTS and check they are from your local server. Otherwise any GET by nature is pretty much fair game. 
I've been fighting mcrypt deprecation warnings.
Ajax.
Running PHP as a service these days is pretty much okay. Been doing that for years now with no issues (basically, since PHP 5.3 days when they introduced Garbage Collector). You can go either via libraries that allow you do demons or just do it yourself - it's pretty much basic stuff if you run on Linux: http://lv.php.net/manual/ru/function.pcntl-signal-dispatch.php http://lv.php.net/manual/ru/function.pcntl-signal.php http://lv.php.net/manual/ru/function.pcntl-signal-dispatch.php http://lv.php.net/getmypid And a few more things - just google for info, there is no solid single article that covers everything, also you can look up those libraries for proper handling. The more challenging thing is actually error handling - and this you will have to figure out regardless what you are going to be using - you can't have your script just failing because by default library or extension X throws an uncatchable error - usually you need to look it up and figure out how to make it report errors and not just fail in regular PHP manner :) It's good that lately most things do throw exceptions or can be configured to do that. Exceptions and their handling are your friends. And DO MONITOR YOUR SERVICE! And make it send you notifications when it fails - you reaally reaaaaaaalllllyyy need that - speaking from experience. And look into Gearman/RabbitMQ/Insert your prefered queue server here to handle the queue jobs - it's quite a bit more scaleable and libraries for them usually provide an easy interface to handle multiple tasks and tasks in parallel.
You shouldn't be too afraid if you have good test coverage.
My condolences
Its Hebrew for "double colon". Not sure how to pronounce it though :) 
Havent chosen yet - I think it will be a French Buldog, so quite open to funky names :)
I wouldn't call that a problem with new versions. Thats a problem with old versions. Even software of today will have the same problem in 10 years.
Hax, DDoS, Tails
[removed]
&gt; You created just an entry point for an denial of service attack. That's premature optimization: The cost of throwing that one exception (rather than returning) is likely negligible compared to the cost of spinning everything up to handle that PHP request and querying the database. More importantly, changing `throw` to `return` in your architecture is **not** going to protect you. The DoS attacker only needs a *little* more power, and now the system is both slow *and* messy. If you want to protect yourself, you need to look at other strategies. &gt; so consider it from a real world point of view: That nomore exiting burger#10 could come from an old menu. In the "real world" that's an *exceptional* situation. Let's assume that your theory is right, and that OP *actually* meant `MenuItem` instead of a concrete `Burger`that goes to a particular customer: * Suppose `10` is literally printed on the menu visible to the end-user, then: * It's not a good primary key! `10` is actually a non-unique alternate identifier! * Companies seldom don't leave gaps in that sequence, they *redefine* what a `10` is over time, printing new menus. * So the tables/repo need to be redesigned. At a minimum, something like `getByCurrentMenuCode()` * If `10` was entered by a confused cashier after the client says "One Digital Double please", then: * You have an internal failure in your system! * You changed your menu, but not all components have updated data. Totally exception worthy. &gt; Returning null translates perfectly to a "Sorry we don't have this burger" answer from the clerk. I disagree, it's more like: "Here's your burger box", and hopefully the customer remembers to *check inside* to see if it's empty before they `takeABite()` or hand it to somebody else who doesn't know empty boxes can exist. &gt; Throwing an exception however translates to "I got kicked out of the restaurant and the moment later it shuts down its operation". ಠ_ಠ . . . Dude, do you even *use* exceptions? What you're supposed to do is *catch* them at an appropriate layer and trigger code to deal with the situation. Throwing one is *not* a fancy way of writing `die_with_stacktrace()`. 
; It's the perfect name, easy to spell, although it could be confusing if a neighbour has a dog called : because at a distance they look the same.
LtAramaki is right. Anyone that can authenticate will have access to the data you send. Send less data (access controls). Prevent responses to requests you can't detect as authenticated(authorization).
&gt; Then you have to check if the burger exists. In some cases — not always IMO a litmus test may be how far you can write good code without ever *testing* the object to see if it's the special case or not. Now, in the case of a kitchen where a `Burger` goes through a cooking lifecycle and then enters onto a `Tray` for a `CustomerOrder`... I suspect the customer will probably be unhappy that their tray contains a zero-mass, zero-calorie burger, even if they also paid zero-dollars for it. :P
ternary, depending upon conditions it'll work out one way or another
Can't believe FILO hasn't been suggested.
"Why do you call him semi-colon?" "He's kind of an ass."
Python 
NaN
Ada
How would your suggestion 2# or 3# help? As far as i understand, he is asking about securing his api endpoints for a public site using Javascript to communicate with his api. You suggest that "api tokens or another authentication method" would work, however if the client (javascript consumer) has that api token, then everyone using the site has access to it too, which means that everyone can make requests to the api. Encrypting the response is just as pointless. If the client (javascript) can decrypt the response, then everyone can. suggestion 1 doesn't help either by the way. 
It used to be an error reported by older versions of PHP. I think it was because the original developer of PHP spoke Hebrew. I'm not sure if it is still used. They might have replaced it with a different message. I remember seeing that error once and having to look it up.
Brainfuck
Still waiting on PECL maintainers to get off their asses. I need php_rar and someone has in fact fixed it, but the maintainers are not replying to him, so it's just stuck.
Bug
FooBar or FizzBuzz
[Wikipedia says](https://en.wikipedia.org/wiki/Scope_resolution_operator#PHP) it's [paʔaˈmajim nəkudaˈtajim], so people who can read IPA (like me) can have fun with that. EDIT: [Yandex Translate can pronounce it](https://translate.yandex.com/?ncrnd=9019&amp;lang=he-en&amp;text=%D7%A4%D7%A2%D7%9E%D7%99%D7%99%D7%9D%20%D7%A0%D7%A7%D7%95%D7%93%D7%AA%D7%99%D7%99%D7%9D) (click the speaker icon on the left)
&gt; &gt; OP didn't mention that his application was a 'public site' &gt; The question wouldn't make sense otherwise, would it? For example, if his application is running on an embedded server in a vending machine with a built in webserver/browser running PHP and js that is used for the interface and to get restocking data from a remote API. The API is public, but access needs to be restricted to the application. &gt; If JS can access the endpoint, then everyone can. This may just be about the semantics of "access". If site.com/api is a URL on the public net then of course anyone can go to the API, but if they have to provide a token, they won't be able to access the data unless they have the token. The token could be requested server side shortly before a js request and expire shortly afterwards. Without the server side component, you can't access the API. Similarly, with the encryption method, anyone can access the encrypted data, but only someone with the key (stored server side) could decrypt it. &gt; How would you tie javascript client code to an IP address or browser? This would be part of the token, such that if your token is stolen it would be rejected as it is coming from a different browser/IP. EDIT: &gt;&gt;a token could be used which is rotated via PHP &gt;If JS can request or "rotate" the token then everyone can. PHP would rotate the token, not JS.
In that specific case, I much have to agree with you, and that's why I will continue to attend to conferences, and that's why having a teacher when you study is fundamental. That was not really my point, for example, someone explaining a concept such as sockets has definitly won the right to produce a video, someone producing the related video that only shows you the code is so wrong, because he/her cannot possibly make you understand the implementation details in such short amount of time, you need to learn it.
This is not a "problem with new versions of PHP". It's a problem with people. The parts of PHP that break backwards compatibility are usually the parts that have to be dropped for security purposes (such as MySQL). People who don't upgrade are not avoiding it due to changes. They are just fine with their codebase being insecure
Please name him var_dump!
Boolean
I highly doubt its a "vending machine". If its a vending machine then no one would even know about the api being used in the backend.
Reading this an awful long time after it's being posted, but Option types are actual language constructs in many languages (Scala, Rust, many others) used along with pattern matching. It's actually one very nice way of doing error handling with very strictly typed languages that can't do exceptions. I'm sad PHP isn't strictly typed, has no compiler/static analyser, and doesn't bring such features.
It doesn't have to be for a request, chain of responsibility is just an idea. In its most basic form it needs a few elements: - Ability to be composed dynamically - Pass the "responsiblity" around - Ability to exit when needed (either at the end with success, or in the middle with an error) So if we were to do it **in the most basic form** with functions, you could do something like $has_x = function ($obj) { if (stripos($obj-&gt;text, 'x') === false) { throw new \Exception("X was not found in string"); } return $obj; }; $length_gt_5 = function ($obj) { if (strlen($obj-&gt;text) &lt; 5) { throw new \Exception("String must be at least 5 characters long"); } return $obj; }; // Pretend this is a function to delete from the database $delete = function ($obj) { unset($obj); }; try { $entry = (object)['id' =&gt; 50, 'text' =&gt; 'Hi there']; $delete($has_x($length_gt_5($entry))); }catch (\Exception $e){ print_r($e-&gt;getMessage()); } Running this would first pass on the length check, but fail on the X check, and then delete won't be executed because we threw an error, and it would be handled by your catch block. 
&gt; I will not ever learn any language by looking at a video whose rythm is just not the same as mine. I'm not you though.
Berners-Lee
Namespace Switch Split Explode Trim 
My dogs name is pNambic. Pay no attention to the man behind the curtain.
Go historical. You can name him Linus Torvalds. Animals actually prefer complicated names. They know when they are in trouble and when they they are being admired by the way you say their name.
Also, don't go with byte. You will have to explain it to everyone that he isn't going to bite them. And if he does bite someone, you will have to explain that you weren't commanding the dog to bite them.
Let me get this straight... you're saying my critique matches the critique of others, and that it reports the same problems over some period of time, during which period Otwell has done nothing to address them, so they remain. Thanks?
If it's not available to the browser, it's not available to JavaScript, so JavaScript won't be able to access the API, and OP's problem is how to make the API accessible to JavaScript, but not people's malicious "API scrapers".
[Business critical](http://lmgtfy.com/?q=business+critical) [Large sites built in Symfony](http://lmgtfy.com/?q=large+sites+built+in+Symfony)
&gt; Why do people continue posting videos showing code ? I mean, code is like a book, you need time to read it, understand it and appropriate it. You cannot just watch a 6 minutes video and understand it. If you mean the videos posted in this subreddit, people keep posting YouTube videos, because you can put YouTube ads on those videos... I wish there was a more romantic explanation. Other than this, videos can be a good media for a more abstract overview of a principle, and simple code examples demonstrating coding style, interactive debugging and so on. As you said it's bad for anything detailed and complicated.
&gt; This is because just acquiring some unique ID to pass in as a parameter strongly suggests that an associated object has to exist. It only strongly implies that if the object can't be deleted. If it can be deleted, it implies nothing at all. Furthermore just because a valid ID was produced for a given object, doesn't meant `getById()` will only receive back such valid ids. The id can be coming from a user playing with the numbers in their browser URL. Get/find/search/fetch type methods that retrieve items based on narrowing criteria shouldn't throw in general, that's the industry convention. Just like `strpos('foo', 'bar')` shouldn't throw if it doesn't find a match, or like `$pdo-&gt;query(...)-&gt;fetchAll()` doesn't throw on an empty result set. Looking for things and not finding them is business as usual.
What's the point of this? Yeah they can't "access your API", but they can still access the server that gets and sends data to the API, so they can basically use those calls to access it from anywhere.
Coda Loop Ruby 
The fact that performance more that doubles if they go to 7 should easily kill the argument that it costs money. In reality it'll save them money in lower resource requirements which translates to list hosting costs.
Have lots of things encrypted using mcrypt, need to re-crypt(?)
This is /r/php, so... $sigil! Or $array. If the dog's name doesn't start with a $, you're doing it wrong. If you like the double-equals but not the triple-equals, you can go for $truthy.
Echo
Then do it all in one go, then forevermore never use mcrypt again.
Millennials. The only text they can read at once is 140 characters long, with a lot of emoji preferably. So video sketches is their only resort. 
100% correct
This is another issue :)
I know there's a lot of interest in seeing this get audited so other projects can consider using it in good conscience, but this is just not something I have the time or energy to pursue. If anyone else does, please step forward. Please be advised that WordPress would still be waiting until 2018 even if I had an audited v1.0.0 and a patch delivered tomorrow. But as for me, I need a vacation. 
Unfortunately yes.
~high pitched voice~ Who's a good boy? Who's a good boy? Little Bobby Tables is a good boy, oh yeah, you're a good boy
I like a such kind of video. it helps you learn faster. If you can't understand something you can open textbook and find. these video help you understand logic of making of app. You can find long video. you can write a letter to author and he answer you
Thanks for the contributions you've made to the community-- completely disregarding the larger wordpress security issues I think it's great something like this even exists. 
Old code problems.
Thanks.
Let us throw in Node.js, PERL and Ruby in the line compiling...
&gt; Having to manually pause is asking your brain to move your fingers to click, while reading you don't need to context-switch to pause reading. If that's a problem for you, how the hell do you navigate an IDE/editor? Either way: Place your finger on the SPACEBAR. It will pause and unpause the video. You can navigate it with the arrow keys. I hope you'll never have to do code reviews or pair programming ...
I do, a lot, that was not the point. I do appreciate videos when they present something new I can then read about later. They are essential because they just given you the proper introduction to something deeper more complex, and invite you to search and learn by yourself, and I like that. What I don't like is a video tutorial that shows you, for example, how to create a chat in details with this or that techno. You cannot copy/paste, letters are not using typo you can choose unlike normal text in your browser, you cannot change how the text is displayed, the colors, and if the video is low quality, sometime you cannot even read it properly. It has very poor accessibility, it's not a good way to proceed with a tutorial into some techno. You cannot just slow the speaker voice either, no matter the quality (some are really good) it still cannot be "read" or heard at the rythm that suits your own brain. A video is not like having a teacher, when you don't understand a teacher, you can ask him to repeat or explain, a video is a one-way ticket. Text, whenever you don't understand, can be copy/pasted and searched for, voice cannot.
I agree. Observing that an object is deleted is to late. And observing requests to do something with the power to stop that something, while possible, is not observing. 
```throw new PetException("bad dog");```
It would be better to write code directly in C#.
[removed]
Do you have the slightest shred of support for any of your wild allegations? Especially bearing in mind that at least one of them (about not wanting other people to audit it) is utterly contradicted by the link we're discussing and in any case is nonsensical when discussing an open source package?
The funny part is that libsodium and sodium_compat are two disparate projects, and the person you're replying to got them mixed up. They also got a lot of other things mixed up. Getting libsodium into PHP for PHP 7.2 is a long-term security win. Sodium_compat was meant for projects to get up to speed *today*. The audit can still happen, I just need to take a break and then focus on other projects.
This is discussed in the linked issue. See https://github.com/paragonie/sodium_compat/issues/8#issuecomment-273618277 specifically
Explainer: https://medium.com/@ondrejmirtes/phpstan-2939cd0ad0e3 Alternatives: https://github.com/etsy/phan, https://github.com/vimeo/psalm (mine)
When I write code, I generally follow DDD. So my entities are generally value objects and things follow a slightly cleaner architecture. I see frameworks as glue; not as core domain. I guess it would be hard work :(
&gt; someone producing the related video that only shows you the code is so wrong Do you have any examples of code only videos? The ones I have seen typically have someone talking as well.
What the board is saying is correct, if you are going to make a JS call only, and want to see the API respond without making a user login, then it is technically "open" for any connection anywhere, wouldn't matter how many servers you have talking to each other. The only way is to lock down requests to your IP OR have a user/password combo to Auth. 
php 5.4 was end of life 1 year and 5 months ago (september 3rd 2015) any reason you're not making minimum support 5.6 in composer.json which is still receiving security updates? [phps offical supported versions](https://secure.php.net/supported-versions.php) for reference.
Have you actually tried to fetch and use the code? Seems like you have diff lines in there: https://github.com/ace411/Bingo-Framework/blob/master/App/Config.php Lines like &gt;&gt;&gt;&gt;&gt;&gt;&gt;
I guess the real question is... why do you attack **me** because **you** don't speak English?
looks good.
Every few months they post... Most of what is stated in materials posted or shared is misleading or nonsense. TLDR =&gt; { &gt; The project is a work in progress, so be aware that is not yet intended to run full applications. }
It's not just in Config.php, it's all over.
I don't see how the video format accomplishes this better than sitenotes, footnotes, google searches, etc..
Yeah, I was mostly thinking about Wordpress shops who churn out WP websites daily and don't care at all about who makes the product which makes it tick.
Someone rebased with reckless abandon. 
How does this compare with the built-in php linter (php -l), [Mess Detector](https://phpmd.org/) and [CodeSniffer](https://github.com/squizlabs/PHP_CodeSniffer)? Could you make a comparison matrix so that we can make an educated choice?
Let's be totally clear: he made that offer when I was asking why he wouldn't let anyone work on package signing and it was received as "if I pay you money will you go away" and I was consequently very offended. So, yes, he made an offer to help, but it was totally off topic when he made the offer and never addressed my questions directly. To be honest, I think he only made an offer because he wanted to be able to honestly say that he did; but only he can speak to his actual motivations.
Briefly, what is your tool doing under the hood? (Perhaps in comparison to the others?)
Why is there a lock file inside your framework?
Hold on. The actual question is: why are vendor packages committed in your repository? See the packages folder.
Companies who churn out WP sites are shit. 
What recent decision?
Well sarciszewski also gets upvotes too. Lots of people spam their own sites. There's the .NET / Peachpie guy but he doesn't get the upvotes that sarciszewski gets. There was PHP Pixie as well but not only did he not get the upvotes, as I recall - he was using multiple accounts (sockpuppets) to submit stories and maybe even to upvote stuff too. I don't think spamming your own product over and over again is really a problem on /r/php. If people don't like it they're free downvote. The problem is when people do it with sockpuppets. Like if sarciszewski used sockpuppets he'd still be spamming but we just wouldn't know, without mod intervention.
These two tools doesn't analyse PHPDoc.
"Companies that use philips head (cross headed) screwdrivers are shit." That is how weak that argument is
My dogs are cookie and bit, both chihuahuas. :)
Thanks for bringing this to my attention. I'm actually about to release my own wrapper, and there are some things in here that influence my work. I won't be using cURL, just sockets.
Design documents *should* be written in CouchDB as the difference between ad-hoc query speeds and an indexed view is enormous. I think the point about BSON was basically "CouchDB is better than Mongo" in nature, but can't be sure.
I don't understand what this library is doing. CouchDB has a super solid REST API, and it also has a GUI built on top of that API. And now this library exists to act as PHP wrapper around the GUI wrapper built around the actual API? ...why would you do that? And how does it even work? Does this actually have anything to do with fauxton (as the cryptic documentation implies) or is it actually a client for the actual Couch API, or...? Plus, there's no documentation, just a link to the official couch docs to the actual couch API, which apparently this library isn't even using, and a note to check the projects wiki, which doesn't actually exist? And as others have noted, the submission title mention BSON, which isn't even related to CouchDB. So uh... ...I'm honestly confused. Digging through the code it looks like it's just a simple curl-based client for the normal CouchDB API, which might be useful if any of it was documented, which it's not, so...eh. Finally, there's already a fairly popular and robust Couch library for PHP called [PHP on Couch](https://github.com/PHP-on-Couch/PHP-on-Couch). How does this one compare? (It doesn't need to be better; it's absolutely fine to implement your own solution to scratch an itch, learn more about PHP and/or couch, or just because you feel like it. But as a potential user, I'd like to know what I'm dealing with.)
Mods also do not know which accounts are sockpuppets; only admins have access to that information.
It's healthy to question one's motives. Why should I take for granted you're *not* affiliated with a government intelligence agency? Can you prove your motives are as good and wholesome as you want everyone to believe?
you have to get it from the client/frontend somehow. 2 overly simple solutions could be: 1. have JS send it's timezone to you in an AJAX call and store it in the users session 2. pass the date to some front-end templating and let it convert it from UTC ultimately it's going to be easiest to keep your server(s) in UTC, store everything as such.
Its recommended for app or framework, but not for library
Not sure why that'd be a false positive if it was an error though...
+1 on UTC. Even if you're good about keeping timezones attached to datetimes, you still need to deal with the "fold" that happens around DST transitions (losing/gaining an hour). Since UTC doesn't have this issue, you don't need to worry about it. 
Using it in my CI now: super-satisfied so far, and it analysed few very complex projects too. The only issue I have with this is that it loads the analysed files, which may be an issue if your code includes side-effects on inclusion. For libraries, please do start using it: it's amazing!
Why not? The composer documentation [gives a good reason] (https://getcomposer.org/doc/02-libraries.md) about why committing the lock file for your library is a good idea: &gt; This can help your team to always test against the same dependency versions.
Yup, hard to tell, nothing mentioned in the wordpress ticket, and their slack channel is not public. Edit: check out the slack archives and saw nothing more, so still hard to tell what happened.
There is a whole dedicated sub /r/phphelp where you are welcome to ask whatever questions you have, and get public answers from different people, which means that any rubbish told to you could be highlighted and ridiculed, while the proper solution offered instead.
It's a false negative, because no error was emitted. Psalm, OTOH, would notify you that code was incorrect. It would also warn you about this code: class A { /** @var string|null */ private $a; private function foo() { $this-&gt;a = "hello"; $this-&gt;bar(); } private function bar() { self::takesString($this-&gt;a); } public static function takesString(string $s) { echo $s; } } new A(); even though the code would not cause any issue for PHP (as `$this-&gt;a` is not null in this particular context). FWIW, Hack also complains about the code. Psalm can also be told to ignore `PossiblyNullVariable' errors (and many others).
So when it analyzes my bootstrap file it actually runs it?
As far as I know, yes. Ref: https://github.com/phpstan/phpstan/issues/67
You can prevent access to your application via ip filtering or vpn but not really the communication between your front and backend..you would need to issue some sort of authentication or password or whatever
The comment should really be "Companies who think using Wordpress for all sites regardless of size and complexity, are shit." Wordpress is fine in certain situations. People just abuse it and use it for totally the wrong types of sites.
&gt; As of Symfony 2.3, the Standard Edition comes with a new bundle that automates the tedious work. Whenever you run **composer install**, a script creates the **parameters.yml** file if it does not exist and allows you to customize all the values interactively. Moreover, if you use the **--no-interaction** flag, it will silently fallback to the default values. http://symfony.com/blog/new-in-symfony-2-3-interactive-management-of-the-parameters-yml-file &gt; There are two ways to know what keys you can configure: &gt; Use the Reference Section; &gt; Use the **config:dump-reference** command. &gt; For example, if you want to configure something in Twig, you can see an example dump of all available configuration options by running: &gt; php bin/console config:dump-reference twig http://symfony.com/doc/current/configuration.html
thanks , I will use it
A very good point against option types!
If you don't want to use JS, there may be a tricky but non-JS way: http://stackoverflow.com/a/891544
The Composer one is a nice default, but it's not exactly state of the art in autoloading. It's unnecessarily slow (which if you check the implementation is not surprising), and lacks advanced features, which are handy at dev time (preprocessors, auto-updating classmaps etc.).
Can you suggest something better, preferably who has benchmarked it? I use PSR-4, and auto updating classmap isn't an issue. Composer autoloader recently got apc caching, and works pretty much UpTo my expectations. I'd still like to see any options if available though. 
And apparently without any tests or CI checks. A no go not only for frameworks.
Note that Exception implements `__toString()`, so in weak-types mode this is not necessarily wrong -- though probably not what was intended.
I thought it sounds more like a dodgy acid strip from a 90s rave
What have I done to fight against crypto? Whatever you suspect it is, I'm sure it pails in comparison to documented evidence of pushing one specific cryptography library for over a year.
You can handle this on the server side as well. It is very easy using Carbon[1]: 1. Store *everything* in UTC on all records in your database. 2. Set a timezone for each user. You can do this in a few way; - As /u/tkdbb84 said - have JS send it to you via AJAX - Use the IP address and do it based upon their guessed location - Have the user pick their preferred timezone in the config of your application 3. When retrieving a record - you then have Carbon format it for the local timezone: - $timestamp_of_event = ???? // Get this from your database however you do it; $time = Carbon::createFromFormat('Y-m-d H:i:s', $timestamp_of_event); $time-&gt;timezone($user_timezone); echo $time-&gt;format('Y-m-d H:i:s'); // This will display the timestamp in the user local time echo $time-&gt;diffForHumans() // This will display "1 hour from now" or "32 seconds ago" You can take the concept further - and if you are display `Y-m-d` - make this a configurable variable for the user as well - so they can pick `d-m-Y`, `Y-d-m` etc - whatever suits them for their local preferences. [1] https://github.com/briannesbitt/Carbon
He's only comparing the 2 inputted passwords here to make sure what the user has inputted in the 2 fields match. Although he looks like a beginner and he probably doesn't know how to hash a password correctly its completely unrelated to what hes asking. On the other hand you shouldn't be recommending that he salts his own passwords, this can lead to vulnerabilities/weakness in the produced password. In fact it can cause the password to become so weak it was removed from PHP 7 all together: &gt; The salt option has been deprecated as of PHP 7.0.0. It is now preferred to simply use the salt that is generated by default. **To the OP:** **Do not** roll your own password hashing function and **do not** make your own salts. Simply call the password_hash() function and it will do the rest for you. Link here: http://php.net/manual/en/function.password-hash.php
Yes, both that site and https://janmarten.name are created with Preacher.
&gt; It's healthy to question one's motives. There's a difference between healthy skepticism and engaging in personal attacks rooted in nothing but skepticism without evidence of wrongdoing. &gt; Why should I take for granted you're *not* affiliated with a government intelligence agency? This is where your train of thought is derailing: One can be up to no good without being affiliated with a government intelligence agency. Similarly, one can be affiliated with a government intelligence agency and still only do good things (albeit, this is rare). &gt; Can you prove your motives are as good and wholesome as you want everyone to believe? No, nor should I need to. If the solution I'm recommending is secure, then it stands on its own merits **regardless of whatever I hope to gain out of it being used**. If you want to refute libsodium, might I suggest starting [here](https://github.com/paragonie/awesome-appsec) and [here](https://github.com/sobolevn/awesome-cryptography)?
&gt; Whatever you suspect it is, I'm sure it pails in comparison to documented evidence of pushing one specific cryptography library for over a year. Why don't you ask a cryptography expert if they can refute libsodium before you complain about it? If you don't know any, some of [the other names on this list](http://technosociology.org/?page_id=1687) might be a good place to start.
I think phonetically people will mix this up with FUBAR
The only subreddit hitting me like that since I've joined reddit is /r/PHP and don't have any clue !! All I've done is type a comment and it follows the rules.Yet I'm getting downvoted !! 
PHP got a lot of things wrong, but apparently it did at least get this part right when it added type hints, thank goodness.
&gt; The newest php MVC framework in the block Probably not now with the other 50 released in the last 10mins
You are right I get your point. Composer actually has an apcu-backed autoloader integration only came out recently. 
But is there any evidence that C# developers more happy or productive than PHP developers besides anecdotes and personal opinions? Are C# projects on Github more successful than PHP projects in any statistically significant way? C# projects are not cheaper because an IIS server certainly doesn't come for free. Neither does the SQL Server and the whole Microsoft ecosystem that you have to drag into the equation if you're planning on doing any kind of serious Windows based web hosting. You might think Wordpress is an abomination, and most seasoned PHP developers thinks the same way too. But have you ever tried Microsoft's poster child CMS Orchard using the latest ASP.NET MVC platform and Razer templates (http://www.orchardproject.net/)? I have, and I wanted to shoot myself afterwards. I get shit done in PHP. Maybe you don't, but I do. I can get shit done in C# too, just as soon as I figure out why this NuGet package keeps throwing Install-Package XML FormatExceptions at me.
Yeah, that's what I get for hastily writing this out on my phone. But nevertheless, Psalm tells you about that problem: Argument 1 of substr expects string, string|Exception provided with a __toString method (which can be fixed by explicitly casting the first arg of `substr` to a string). 
The real table flipping would be trying to work on a project that actually used this.
This brings a whole new meaning to `die-dump` https://3v4l.org/VKOHU
I really do think that there's enough interest from other developers in having secure tools to work with to justify this. Seriously, throw this up on Kickstarter so _we_ can vote for it. If enough of us are willing to throw down for it, who cares that the other projects are uninterested? Clearly, enough of the rest of us would value it enough to justify paying for the audit. Don't make that choice for us. It's going to be a long time until most of us can rely on having PHP 7.2+. Edit: I know that you're asking for someone else to step forward with setting up the crowd-funding, but who would know which companies to contact, what to ask for, and could be trusted by the community at large to actually follow through with the audit instead of finding some way to abscond with the money?
To expand on the PHPixie: /u/AndrewCarterUK did some nice exposing of /u/dracony [PHPixie using sockpuppets on /r/php](https://gist.github.com/AndrewCarterUK/96bf6fae02ef8b93f93b) [95% of PHPixie Installs on Packagist are Fraudulent](http://andrewcarteruk.github.io/programming/2016/05/09/phpixie-fraud.html) And then the whole shit show involving dracony's membership in FIG. My memory is fuzzy so I won't make any definite claims... but it's worth a mention if you feel like looking into it.
This problem is not specific to Scala but specific to any language that uses option types. Consider the following signature which corresponds to the one from the article: function f(int x): int; Now we want to make `x` optional like it was in the last part of the article: function f(Option&lt;int&gt; x): int; Since `x` is now required to be wrapped in an `Option` every caller is broken. Consider now how it is with nullable types: function f(?int x): int; Nothing breaks, no call needs to be checked. Obviously in PHP the problem would be less severe since we could simply remove the type constraint altogether and perform the necessary type checks within the routine’s body. However, we just lost all type constraints and need to add error handling to account for other, unwanted types that might get passed to us. Applying this to the returned value is always a breaking change, no matter if we use nullable types or option types.
https://www.youtube.com/watch?v=w-0TEJMJOhk
GitHub's excellent thinly-veiled pro-feminist agenda.
Thanks!
See A+ Certification.
Understood, so that should be part of the handler then, I appreciate the feedback! That actually makes a lot of sense having just said it "out loud".
Good article – a couple of typos (manor =&gt; manner, "Conclusio"). Also the `NaturalNumber` example you give provides a good example for why pass-by-reference is disallowed in Hack's strict mode – it messes with language semantics in hard-to-determine ways.
Many thanks for the compliment, glad you enjoyed it. Many thanks as well for the typo, but, what is it you don’t like about [*Conclusio*](https://en.wiktionary.org/wiki/conclusio)? References are frowned upon in internals too but BC, you know.
&gt; what is it you don’t like about Conclusio? [Latin is a dead tongue dead as dead can be first it killed the Romans now it's killing me](http://writersalmanac.publicradio.org/index.php?date=2001/06/26) 
That's a bogus response, and you know it. 'Oh no, we can't use GPG because it's slightly harder on Windows and it may not even be there!'. So... error if it's not there. This is *exactly the same problem* as the overly complex use of sodium_compat that **you're** trying to push. 
Oh well, I’m sure you’ll survive. 😁
You're advocating a solution that fails open ("error if it's not there" in WordPress land means "silently skip verification" because, hey, usability). &gt; This is exactly the same problem as the overly complex use of sodium_compat that you're trying to push. I don't understand this train of thought. Sodium_compat is implemented in pure PHP.
&gt; Sodium_compat is implemented in pure PHP. I *was* going to say that it was PHP 5.6+, but I checked, and it looks like you've made it a bit more portable. When I first saw this, it was modern php versions only. My issue is that this is a massive amount of work to solve something that's already been solved. &gt; "error if it's not there" in WordPress land means "silently skip verification" But that's not what I said. I mean ERROR IF IT'S NOT THERE. Sorry, you can't do updates, because they can't be validated. Install this package. You can't install this package? Drop the GPG binary HERE, and we'll do a file_hash on it so we know it's in the known good list. This is not rocket science. It just needs to *not* be overly, and unnecessarily complicated.
You're confused. I'm saying that *the entire implementation you're proposing* is overly complicated. Don't use libsodium at all. Use gpg. Gpg already implements a redundant web of trust, multiple signatures, distributed EVERYTHING and has been proven to work, and to be secure, for 20 years.
You're confused that libsodium is meant to only provide signatures. Its design goals include a hard-to-misuse secure-by-default API for: * Symmetric encryption * Asymmetric encryption * Symmetric authentication * Asymmetric authentication (signatures go here) In contrast, libgcrypt (which is what you'd use if you followed the "use GPG" recommendation for application-layer cryptography) gives you: * A cipher implementation which happily lets you use unauthenticated CBC or CFB mode * FIPS mode * Public-key cryptography standards which are constrained to RSA and ECDSA over [NIST or Brainpool curves](https://github.com/Chronic-Dev/libgcrypt/blob/e5a923dee8ad0539a53f5d16076ff326e4b49fa5/cipher/ecc.c#L94-L121) (which are [Weierstrass curves](http://web-in-security.blogspot.com/2015/09/practical-invalid-curve-attacks.html)) GPG isn't insecure, but it's easier to use insecurely than libsodium. Even if you view GPG as good enough for your needs, that doesn't imply that libsodium should be avoided.
No. To steal your code 8-) if (GPG::verify($fileName)) { // Proceed } else { // Scream loudly and log a validation error }
&gt; It's a simple wrapper around the binary. This is the issue. A large percentage of Wordpress installs are done in an environment where the person running the wordpress can't EVER install any binaries. Ergo your solution fails for them. Even 10% of wordpress's installs is literally MILLIONS of installs. From the library you linked: public function __construct() { if (file_exists('/usr/local/bin/gpg')) { $this-&gt;gpg = '/usr/local/bin/gpg'; } elseif (file_exists('/usr/bin/gpg')) { $this-&gt;gpg = '/usr/bin/gpg'; } else { throw new Exception(_("Could not find gpg command!")); } How is this code ever going to run on Windows? Remember, even a small percentage of wordpress installs is millions of installs. Ergo your solution is usuable for * Anyone who can't install binaries on their host * Anyone who is running Windows Granted, this is a Venn Diagram, so some of the first are also in the latter, but you're not providing a solution for literally MILLIONS of wordpress installs, ergo your solution fails at the start and never gets implemented in WP Core.
&gt; Using libsodium means that 95% of sites will use the polyfill. Using GPG means that - at most - 10% of sites will use it. Until PHP 7.2 is adopted, which comes with libsodium as part of core. Then only those running versions less than 7.2 will be using the polyfill. I don't see native GPG support anywhere near PHP's plans, ergo that 10% (or more) using the polyfill will always be using the polyfill. You're missing the overall point of sodium_compat: to provide a polyfill so widely supporting that wordpress would find no reason not to use it (yet they managed to find one, ho hum). Now who's making it complicated? You are. Your PGP 'solution' only works if pgp is installed. You complicate things further by wanting to include a 3rd party polyfill if PGP isn't there (does it work the same way as the PGP binary? If not, what differences are there? What exploits are there?). At no point would PHP itself implement PGP, ergo they're always relying on external support for it. I'm not sure why I'm bothering with this reply though, as this _isn't a solved problem_ no matter how much you stick your fingers in your ears and say "lalala, just use GPG" Edit: &gt; to sort it out later. Later == never. Just remember that.