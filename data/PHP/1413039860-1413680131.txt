Interesting. Symfony cookbook articles don't mention it, but it looks like you're right, there is indeed a filter shipped with it. Well then I blame Symfony docs. EDIT: The minifiers themselvess are not shipped with Assetic, only filters are, but the point stands.
Hey Jeff, elixir looks pretty cool. Good work! Any chance that you will cover some non-laravel node.js stuff on laracasts? Node.js looks like a tool that is useful for way way more than just gulp and now I am thinking about looking into it.
Throw exceptions. if ($program_is_not_happy) throw new Exception("Program isn't happy"); You can also make custom exceptions. class Error extends Exception {} throw new Error("An error occurred");
Cashier is not included with the framework. It's an optional package.
What do you honestly think you're contributing with this "point" you keep re-making?
Nice straw man argument.
It's a very cool add-in and I'm sure I'll use it because I'm already using gulp anyway.
&gt; If you read the entire article it talks about compiling PHP into C++ Just to note, this is what HipHop did. HHVM now compiles PHP into bytecode to be run in a VM (identical to the way PHP does it, hence why it has PHP support) and then when a script it requested enough compiles it further into machine code. There's no compilation into C++ any more. [There's this really awesome blog post on the HHVM site](http://hhvm.com/blog/6323/the-journey-of-a-thousand-bytecodes) that details how PHP and how HHVM compile things down. It's quite in-depth, but it's a great resource for those who want to understand what goes on behind the scenes and what really makes HHVM so stupidly fast.
Oh the "laugh at PHP" argument is so juvenile, typical noob talk... 
&gt; I would never install a plugin like that on any of my sites because it is an obvious security hazard. It's not a security hazard, it's your concept of security that is flawed. You have to prevent unwanted access to the admin area instead of deploying useless counter measures once an unwanted user is already inside the admin area. 
This is not even remotely a 30 hour project. The guy is not asking for a generalized sooper-scraper, he wants one specific page. If that page changes, he can change the script. This is a couple of hours, and that's probably too much.
I agree with these sentiments but it is more than just interoperability, it is about lifespan of the application beyond the person who just did the basic installation by following simple instructions that ultimately are encouraging bad practices and then having to wait for future releases to fix it. Which will most likely never happen because of BC and at which point would no longer be "Laravel". Being asked to fork it just to change directory paths is exactly what I meant for not to have to happen to begin with - this is what devs want and why I'd be pissed if I was Symfony developer.
Not to be confused with http://elixir-lang.org/
Reposted for visibility. This is based on catime's little one-liner. He did all the hard work of identifying the regex expression. I php-ized it, and used a slightly more reliable delimeter. If you know a little PHP, you can probably insert the data into the database. Should point out that this is a Linux solution. If you're on windows, it wouldn't be hard to convert this to grab the page, and then do preg_match and preg_replace. &lt;?php $tag = '2014020008'; $output = system("curl -s 'http://www.nhl.com/gamecenter/en/boxscore?id=$tag' | grep -E -o '&lt;tr class=\"statsValues\"&gt;.*?&lt;/tr&gt;' | sed -e 's/&lt;[^&gt;]*&gt;/~/g; '"); $vals = explode('~', $output); while (count($vals)) { $entry = array_splice($vals, 0, 38); # Validate and insert data here. Array of 38 values print implode('/', $entry) . "\n"; } Output: //2///M. Niskanen///D//0//0//0//-1//0//2//2//2//0//0//-//2:10//2:02//26:42/ //8///A. Ovechkin///R//0//0//0//-1//4//4//6//0//1//0//-//4:40//0:00//22:22/ //16///E. Fehr///R//0//0//0//-1//2//2//0//0//0//0//50%//2:14//0:36//21:07/ //19///N. Backstrom///C//0//0//0//-1//2//2//0//0//0//1//65%//4:23//0:36//22:53/ //20///T. Brouwer///R//0//1//1//1//0//2//1//1//0//2//60%//4:44//3:13//18:42/ //21///B. Laich///C//0//0//0//0//0//2//1//1//0//0//38%//0:15//2:25//17:14/ //25///J. Chimera///L//0//0//0//0//0//2//3//0//0//0//40%//0:07//3:45//16:51/ //27///K. Alzner///D//0//0//0//-1//0//1//0//5//1//0//-//0:00//1:40//22:57/ //38///J. Hillen///D//0//0//0//1//0//0//0//1//0//0//-//0:00//1:03//14:01/ //42///J. Ward///R//0//0//0//0//0//0//0//1//0//0//50%//2:10//3:17//19:52/ //44///B. Orpik///D//0//0//0//0//2//0//6//2//1//0//-//0:02//4:25//23:07/ //65///A. Burakovsky///L//1//0//1//1//0//2//1//0//0//1//21%//2:18//0:00//15:58/ //67///C. Brown///C//0//0//0//0//0//1//3//0//0//0//0%//0:02//0:00//3:42/ //74///J. Carlson///D//0//0//0//0//2//4//2//2//1//0//-//4:46//4:06//23:22/ //87///L. O'Brien///C//0//0//0//0//7//1//3//0//0//0//-//0:00//0:00//2:40/ //88///N. Schmidt///D//0//0//0//1//0//2//0//1//0//0//-//0:00//0:36//13:14/ //90///M. Johansson///C//0//0//0//1//0//3//1//0//0//0//-//4:23//0:00//16:39/ //92///E. Kuznetsov///C//0//0//0//0//0//0//1//0//0//0//50%//2:26//0:00//6:36/ /////Washington Capitals goaltenders//////No.//Player//EV//PP//SH//Saves - Shots//Sv%//PIM//TOI// 
Oh, what the hell. Here is a pure PHP version: &lt;?php $tag = '2014020008'; $page = file_get_contents("http://www.nhl.com/gamecenter/en/boxscore?id=$tag"); preg_match_all('/&lt;tr class="statsValues"&gt;.*?&lt;\/tr&gt;/', $page, $matches); $lines = $matches[0]; foreach ($lines as $line) { $vals = preg_split('/&lt;[^&gt;]*&gt;/', $line); # Validate and insert data here. Array of 38 values print implode('/', $vals) . "\n"; } Edit: Print boo-boo.
&gt;the objection is not to "sexy" per se, but that the wrong kind is being presented Honestly, I'd say *this part* is a valid observation. Where you go wrong is that you think this is somehow a problem for PHPixie's critics. Sexy can be either empowering *or* degrading. Strictly speaking, the problem with the logo isn't that it is sexy per se. The problem is that it is degrading. Sexiness is merely the conduit through which the degrading attitude towards women is conveyed. How can we tell this is degrading vs. being merely "sexy" or a positive and empowering variant of sexy? /u/mattaugamer already did a thorough analysis in [this post above](http://www.reddit.com/r/PHP/comments/2iwzzu/phpixie_logo_is_not_sexist_shocking_proof/cl6b009). 
A) it was a joke, buzz killington B) Php doesn't have pointers, so you basically can't have an NPE unless you find a bug in the interpreter, which was written in c.
A dictionary attack is really no different than a standard 'try every combination' brute force attack, except you're working with a list of words rather than a list of characters for each 'position'. To work quickly, they mostly rely on people choosing only 1 or 2 common words (months, sports teams, common names, etc), perhaps with a couple of numbers on the end. A quick google shows the OED contains ~180k words (the numbers given are higher, but there's a lot of words that are 'obsolete' or otherwise not in common use and many word lists exclude words less than a certain length, so I've lowered the figure slightly). Assuming we use the full dictionary and we always use lowercase, a 4 word generated passphrase has 180k^4 (~= 1 * 10^20 ) possible values. Generated passwords typically contain only the letters A-Z and numbers 0-9, giving us 36 characters per position. If we use lower and upper case, that's up to 62 characters. However, many systems will remove possible characters either to avoid generating rude words and/or to avoid ambiguous characters (eg. o/O/0, 1/L/l/i/I). Assuming we use the full 62 character set, an 8 character generated password has 62^8 (~= 2 * 10^13 ) possible values. As you can see from these numbers, it's going to be much faster to brute force the 8 character password than the 4 word passphrase. As a bonus, the four word passphrase is a lot easier to remember, so the user is less likely to immediately change it to their favourite football team and/or write it down in plain text and probably in plain sight too. If you want a stronger value, with a passphrase you can multiply the number of possible values by 180k simply by adding 1 more word. For the password, you need to add significantly more digits to get anywhere near that level of complexity. --- Dictionary attacks can also be easily mitigated on the application side using delays between login attempts and locking the account (I would send the account owner an email with a link to unlock the account and explaining what's happened - this gives them the option to leave their account locked if they don't intend to use it) and blocking the client after a given number of incorrect attempts. The only real problem that you can't mitigate is if the attacker has your username and password hash database (and I'm going to assume you're not doing something really dumb like using md5 hashes for passwords - hopefully you're using bcrypt (via password_hash())). And this same problem exists no matter how you generate your passwords. --- After typing this thing out, I remembered [XKCD Explained](http://www.explainxkcd.com/wiki/index.php/936:_Password_Strength) exists and probably covers this better than I can. It's also been covered on [Security StackExchange](http://security.stackexchange.com/questions/6095/xkcd-936-short-complex-password-or-long-dictionary-passphrase) 
One woman's "degrading" is another woman's "empowering." The point is that others want to police sexy according to *their own definitions* of sexy, instead of allowing for lots of variations.
It's not simply a matter of opinion. There are objective criteria by which we can evaluate empowering vs degrading forms of sexiness. If you are not aware of these criteria (despite /u/mattaugamer having clearly listed several above...), that is due to ignorance on your part. You should read some actual feminist literature if you want to engage intelligently in discussions pertinent to feminism. It's true that not all individual women will find PHPixie's logo problematic. But that's irrelevant to the question of whether objective standards can be employed in determining whether something is sexist.
"we are sorry for this bug"
Well that's encouraging and completely unnecessary. Support works both ways.
A) that it was a bad joke was part of the joke, and I don't feel bad at all. B) 1. If we apply your logic that Java-has-pointers-because-an-exception-has-the-word-pointer-in-it to php, then php does not have pointers because the similar error does not have the word pointer in it. In either case I think this simplification is wrong and neither language support pointers used explicitly by the developer. 2. C/C++ don't implicitly initialize pointers to anything, even for non object pointers. That causes problems for inexperienced devs, and if php did this and used pointers and kept the same base of developers it has now, this would cause tons of problems. 3. the bad joke is what I was really going for, and I am irritated that we are even discussing the merits of something this ridiculous. Edit: changed the Java argument summary to be hyphenated instead of quoted, per request.
When you put quotation marks around something you should really actually be, you know, quoting someone.
Fair enough. I changed it to be hyphenated so it is clearly the name I have the argument. I doubt anyone would be confused into thinking I thought I was quoting you exactly by the thread, but as you wish.
While I agree with the sentiment, using braces does not necessarily save you from this. In particular in the context of `for` loops I've seen people being confused about something like this a few times: for ($i = 0; $i &lt; $n; ++$i); { // ... } It's not very hard to add another semicolon after already writing two, even if you're going to use braces afterwards. The only way to completely avoid this, is by enforcing use of braces at the language level. This has the nice side-effect of allowing you to drop the parentheses on stuff like `if`, so effectively you write `if expr { stmts }` instead of `if (expr) stmt`. This is the way many of the more modern languages (like Go or Rust) are going.
/me nods That at least is easier to grep for across the codebase, something like `/\;\s*\{/` 
This is actually a rather hard question as it's pretty broad. Monitoring is a first step, have a look at monit (http://mmonit.com/monit/). Now, you should start thinking about your server configuration. For the webserver, you are using nginx, good choice. The two main configuration settings are worker_processes and worker_connections. The number of worker_processes best match the number of cores you have on your machine, so if you are using a DO 512, use 1 worker_process. Unsure about the number of cores? Set it to auto. The amount of worker_connections define how many concurrent requests you can handle. A single browser can open multiple connections at the same time, so you shouldn't set this too low. In your case 1024 should be fine. Have a look at cache headers for static assets as it avoids server hits: http://www.nginxtips.com/how-to-enable-browser-cache-static-files-on-nginx/ Next, you serve php via php-fpm. For a low traffic website you should set the pm (Process Manager) to ondemand. That way when you have no vistors, you won't have any php-fpm child processes running. Now, you have the max_children setting. This is very important. If php needs 20mb of ram to serve a request and you set max_children to 10, you will use 200mb of ram. If php needs 50, 10 children will give you 500mb of ram. The best way to calculate the number of max_children is to have a look at your php memory usage and your server idle memory usage but with all processes running. If idle you need 162mb for other processes, and your average php process is 50mb you get: (512 - 162) / 50 = 7. Lower it a bit and set it to 5 or 6. Next is your database. Unfortunately I have no real life experience with postgress, but I assume you should play with the buffer sizes. I found this tutorial: https://wiki.postgresql.org/wiki/Tuning_Your_PostgreSQL_Server Now, another important fact is: any request that will hit your webserver, php and/or your database is a request too much. You can avoid requests by merging js/css, use inline images in css if possible and using a cdn on the frontend side. Php requests can be avoided by a proxy like varnish or activating a built-in proxy in nginx. Now in a low traffic website it will almost always be overkill as the requests in the cache take up memory too and configuring those perfectly is very tricky. I would suggest you try experimenting with the other processes first and then if you feel you have a basic understanding, have a look at varnish. Remember, this is one of those things that come down to trying, probably failing, and trying again. Don't give up, only change one(!) setting at a time and always measure the changes. And enjoy!
This is so wrong.
No, this is why you should use an IDE with auto-formatting. 
It makes some Laravel-specific assumptions. If others want to use it, they can modify it to their needs. But, and again, it's a tool to make using Gulp with Laravel easier. Sorry if you think that's wrong.
and use braces on conditionals. I usually follow PSR-2 :)
The thing is the problem with this code has nothing to do with the lack of brackets.
Um, did you even look at nikic's example? The braces did nothing to reveal the mistake.
give import.io a try before you take anyone on. But tbh it really isn't that hard with Guzzle and DomCrawler, I use it to scrape Steam play times every min http://phunky.co.uk/playing.php
awesome. thanks again! 
Since he is arguing with code and you with insults, I'll just take this as proof that you know that you are wrong and just don't want to admit it. 
FINALLY! i've been waiting for this RFC
The biggest issue is that it doesn't support php extensions, but many of them have been built into it. You're going to have problems if you need something like IMAP support, for instance- and that's enough to keep most shared web hosts from using it. Compatibility with Zend PHP has improved quite a bit, but that has been a more current thing. You can track compatibility with current frameworks and libraries on the [HHVM Frameworks](http://hhvm.com/frameworks/) page. 
Everyone telling you to use exceptions is correct. You should throw and catch exceptions as your errors in your code. To get the php core to handle errors as exceptions, you can follow the examples here: http://php.net/manual/en/class.errorexception.php
I plead for better reusability and interoperability and your solution is "just fork it and change it for your own needs". That's what's wrong.
Same here, we often didn't use braces at my school.
Start a form on google you will get better results.
well, we did. We were encouraged to use them to be more verbose. They also told us to make the assumption that it will always eventually change to a two line if statement.
This is one advantage of [1TBS](http://en.wikipedia.org/wiki/Indent_style#Variant:_1TBS). Mistakes like that don't really happen: for ($i = 0; $i &lt; $n; ++$i) { // ... } Putting a semicolon at the end of a statement is natural, but with the brace on there, neither of these would look right: for ($i = 0; $i &lt; $n; ++$i); { // ... } // Edit: Actually, the below would work fine... for ($i = 0; $i &lt; $n; ++$i) {; // ... } I don't think I've ever accidentally terminated a statement like the above in 30 years of 1TBS.
Just did it, thx
That and the version jump would ensure it's not getting rolled out by the majority of hosting providers for another decade. Btw, what's the obsession with deprecating POSIX regexps anyway? It's a system library with a puny PHP wrapping. If the Onigurama engine stays (mb_ereg), why not the base implementation? And unlike PCRE it provides a memory/backtracking-safe runtime.
I would think so... Also, do we really have to cater to the (forgive the term) ma-an-pa hosting providers that don't want to upgrade because of BC breaks? That doesn't seem healthy for php...
Is it all plaintext passwords? You should add encoder support. Something like Symfony's Security component does with the Encoder Factory: http://symfony.com/doc/current/components/security/authentication.html#the-password-encoder-factory
The remaining [22% install base of 5.2](http://w3techs.com/technologies/details/pl-php/5/all) is even more concerning. You're right on the distros of course. I'd surmise however that entry-level providers hold on to outdated system setups *because* of PHP compatiblity anxieties. Now with PHP7 possibly introducing actual breaks, that's only going to be a more likely hold-up. Not all deprecated stuff is actually *unused*.
The point of the BC breaks, and the deprecations are to STOP people from using them, not patiently beg them to move on and not do anything innovative until they do.
Sure
The mysql extension needs to die in a fire. I'm glad to see this.
5.2 = 2006 (22%) 5.3 = 2009 (47%) Doesn't really look like anything you do will make people upgrade. So why not just ignore them and move the language forward? If their codebase is THAT critical and they want to keep jurassic tech (2006!) they can pay somebody to backport patches and bugfixes. And contribute back. I think this is a very hard thing to analyze. Keeping things stable and avoiding BC breaks is important, but so is making the language better. So why not just pull a Python 3 and make a saner API? That's another problem, it needs community effort to build something solid without risking making things even worse. But there's no real leadership on the project. My conclusion is, let's be thankful for the efforts that are already being put on PHP 7 and just, somehow, accept that PHP will never be good *as a language*. Userland will have to be good enough.
http://imgur.com/AmvIElz
Is this a dev environment tool? &gt; [If you want to require certain files explicitly on every request then you can use the 'files' autoloading mechanism](https://getcomposer.org/doc/04-schema.md#files) "autoload": { "files": [ "helpers.php" ] }, Shouldn't it be `autoload-dev` ? I would of expected it to be run via an artisan command for consistency. *Edi*t: Yes: `require-dev` 
What's the "Assignment of new by reference" one about?
Let's try to avoid another Perl 6 or Python 3 :) Some statistics about usage of every feature would be really useful
The startup time penalty is an artifact of HHVM's just in time compiler (and JIT systems in general). See https://en.wikipedia.org/wiki/Just-in-time_compilation#Startup_delay_and_optimizations
&gt; As of PHP 5, the new operator returns a reference automatically, so assigning the result of new by reference results in an E_DEPRECATED message in PHP 5.3 and later, and an E_STRICT message in earlier versions. See example at http://php.net/manual/en/language.operators.assignment.php.
Nice - removal of set_magic_quotes_runtime() - this is like the IE6 of removals for PHP7!! :) Will be following this vote closely, I have a sneaky feeling it might be a tough sell for some (esp. with removal of ext/mysql - thinking WordPress here). But would be great to see this happen - lowering LOC's in the codebase is always a good thing. **EDIT:** even on the ext/mysql thing - this could just be demoted to a PECL extension for those that (shudder) still use it.
I prefer to keep the procedural date functions so I can wrap them in my own Date, Time, and DateTime objects that have much less crappy API and name than DateTimeImmutable. PHP language developers should leave the OOP to framework developers and stop producing these f'd up classes that now have to be supported forever. 
&gt; Btw, what's the obsession with deprecating POSIX regexps anyway? Besides the fact that they're way slower than PCRE regexes, IIRC they were originally marked as deprecated because they're inherently incompatible with the not-happening Unicode stuff in old PHP 6. Apparently there was no way to make the two play along, so the plan was to remove them instead.
Sheesh. Have a look at Symfony components, you'll know the difference. And I'm talking about all Laravel components, not just this one.
&gt; why would you even do that when there's DateTime? Because it's terrible and already replaced by the slightly saner [DateTimeImmutable](http://php.net/manual/en/class.datetimeimmutable.php) in 5.5. But it's a fair point, one could inflict their own sanity by merely wrapping the existing DateTime class. But ultimately that class just calls the same underlying procedural C functions anyway. 
Personally I think the blog should have been "This is why you always unit test your code". Even with braces, this error would have been hard to spot, and it might easily have gone undetected for a long time.
I think the ease of deploying a virtual box on sites like DigitalOcean and Linode make this less of an issues. There is very little reason to be on a hosted solution that is not running a 'recent' PHP release (i.e. at least 5.5)
Are you asking about pagination (e.g. "show 5 posts per page, and then a 'next' link at the bottom")? If not, then I'm afraid your business rules are weird and confusing, and while it's normally bad manners to tell other people what their business rules should and shouldn't be, I've used enough shitty websites and enough shitty PHP frameworks/tools that I now firmly believe if someone is trying to do something weird, they shouldn't be trying to do it at all, and if their business rules are complicated, then their use-cases are wrong.
No, the helpers.php file contains the functions you can use in your template to reference the correct stylesheets/scripts. It is required in production.
http://www.tutorialspoint.com/php/mysql_paging_php.htm basic idea of pagination
Too many things use it. If they actually removed it no one would install the new version of PHP, it would be a disaster for the language. Maybe if they released a compatibility library or something. Most of the other things are easy to change if you use them, so removing them is no big deal, but ext/mysql is not.
Yeah... my million line project at work still depends on it. I think we'd be fucked by a dozen other backwards incompatible changes in PHP 7 anyway though, so it doesn't particularly matter.
&gt; But it's a fair point, one could inflict their own sanity by merely wrapping the existing DateTime class [Carbon](https://github.com/briannesbitt/Carbon) is pretty good.
We had at least 30 people ask for a downloadable PDF so we made one. LeanPub allows updates, so... you know, you can download updates. I can't see any possible issue with that.
We are not selling the book. We are allowing optional donations to go to the EFF. LeanPub don't take a penny/cent/dime. We don't take a penny/cent/dime. That makes it legitimately not a sale. It's like having a charitable collection jar on the desk at a book store. Only the book store lets you just take that book for free. You can put $5 in there if you like, or not, but none of that sounds like a sale, or a violation of the CC-NonCommercial license.
He doesn't need to. We aren't selling anything.
We use Laravel, so we define a handler to catch fatal exceptions and send it out to Raygun.io (which is a little pricey, but makes fixing those late night explosions much easier).
`ext/mysqli` became the recommended way to talk to MySQL back in PHP **5.0 in 2004**, and the better alternative of PDO became available by default starting in 5.1, in 2005. ### **It has *literally* been bad practice to use `ext/mysql` for ten years.** If you couldn't be bothered to fix your code in the past decade, nothing's ever going to make you do it, even for something as *amazingly brain-dead simple* as a blind port to mysqli via search and replace. Seriously, you can get it 99% of the way there replacing the spelling of the call and always making sure that the connection resource is the first parameter to the call. Even then, the plan (as of a few years ago when the official deprecation happened) was to turn `ext/mysql` into a PECL extension, so you can still get to it if you need it... but you shouldn't.
The reason this mattered, if nobody here used PHP 4.x, is that PHP4 objects were *not* automatically passed by reference like PHP5 objects. You *needed* to actually constantly pass objects around by ref, by hand. Objects being passed around by reference is an instant code smell. Either the code was developed during PHP4 (look for `var` to declare properties and no visibility declarations on methods for other hints) or the developer never moved on after learning PHP4.
&gt; this could just be demoted to a PECL extension for those that (shudder) still use it. That was the plan, last time this was talked about. It'd just no longer be shipped with PHP or enabled by default.
&gt; your code What, you think people only use code they themself wrote? And you think people have no active sites using code written 10 years ago? You are completely wrong on both counts. Just because the code is old doesn't mean it doesn't work, and just because the code is old doesn't mean the person doesn't want the latest security updates to PHP.
There is nothing good or worthwhile about anything in that article. The horrendous `ext/mysql` use, using *curlies* to index `$_GET` to the query-or-die antipattern, and the mixing of display logic, business logic and data logic all combine together to make it a horrible, horrible thing that should be nuked from orbit.
I don't care about any of that, I was just showing him the first google result for "php mysql pagination" that illustrated an algorithm to do it. Nitpick what you will, but that's exactly what it is and all that it was intended to be.
Nobody reading /r/php is in that audience, though. If *you*, the reader, are responsible for maintaining code that is locked into `ext/mysql`, and you didn't already know that you are totally screwed, well, guess what? You're totally screwed, your codebase sucks, and you are in for a life of pain. Everybody running PHP code that isn't a developer and hasn't had a developer look at it in a decade is also probably running on shared hosting still running 5.1, and will be until the day that the server dies. No shared hosting provider is also going to globally replace 5 with 7. Even today's horrible shared hosting automation system abominations can let end-users pick their PHP versions, even if it's 4 and 5. I mean, fucking 4. In 2014. Fuck everything about that. Also, &gt; And you think people have no active sites using code written 10 years ago? I still have code written 18 years ago running on my site. There are still a few hundred sites out there running code I wrote more than a dozen years ago. All perl scripts, all run by CGI, all surely on shared hosting, all surely vectors for shellshock by now. My former employer discontinued the product and told everyone to stop using it a long, long time ago. Bad things happen when you don't update your software.
The problem is that it's horrible bullshit like that site that continues to plague PHP. Please don't show newbies how to *do it wrong*. 
I don't think this is possible because it is using the HTTP Auth feature. This triggers an "Authentication Required" message to the client browser causing it to pop up a Username/Password input window. Once the user has filled in a username and a password, the URL containing the PHP script will be called again with the predefined variables PHP_AUTH_USER, PHP_AUTH_PW, and AUTH_TYPE set to the user name, password and authentication type respectively. To do this you would have to unset $_SERVER['PHP_AUTH_PW'], encode it and reset it.
And then you run "PHP_AUTH_PW" through the encoder, and see if it matches the already encoded, and defined password for the given user? Am i missing something?
Anything that will continue to need to use it, will be stuck on PHP 5... It's that simple I think. Even if they do release a Pecl package for it, It'd surprise me if the rest of the BC breaks don't mess up the project. All in all, PHP as a community, and as a language, should not cater to old projects that don't want to change. Its not healthy for anyone involved.
It'd sure give a reason for Wordpress to update their shit..... a DECADE later.
&gt; I would've thought everyone understood that deprecation would imply (almost certain) removal in the next major version. This is the most wishful thinking I have ever seen. Unfortunately this is never the case, ever.
In HTTP Basic the browser doesn't encode/hash the password, it is submitted in clear. So the PHP on server cannot do anything to change that. If you want more security, you can consider the HTTP digest method http://php.net/manual/en/features.http-auth.php (check example #2) 
Yup, fair enough. I'd failed to realise the ebook updates could be downloaded like that
Which is the recommendation of pretty much every publicly available PHP coding style guide made by teams.
The braces may not in hindsight or in hypotheticals, but likely would have during the creation of that code. That's the nice thing about recommendations, they don't have to be fool proof they just need to improve the likelihood of getting things right.
Ok got it :) I'm not storing anything with this lib. It takes an array of user =&gt; password as argument. If you have users with sha512, sha1, md5 etc encoded password you can implement the verification yourself https://github.com/devster/uauth#more-complex-usecase I think it is not of my buisiness how your passwords users are stored. This is a simple and easy to setup lib, I prefer avoid too many options
&gt; Too many things use it. This is why it has to be removed.
I wouldn't judge you based on using Dreamweaver. I would assume you had not pushed the limits of your abilities or had no internal drive to find and evaluate better tools. I would then judge your ability to make those same decisions for me going forward.
As much as we like to rag on Wordpress, since version 3.9 their DB layer will auto switch to mysqli if you run on PHP 5.5 or greater. Thus removing MySQL ext in PHP 7 won't affect it; Wordpress will just default to mysqli. 
You are right. I work in a company that uses a php system for the past 13 or 14 years. It uses the old mysql functions since then. Change the entire system to mysqli or pdo would be a nighmare.
&gt; Even then, the plan (as of a few years ago when the official deprecation happened) was to turn ext/mysql into a PECL extension, so you can still get to it if you need it... but you shouldn't. All ext/mysql functions should be replaced with a single function which burns down the developer's house.
i think i completely read over that piece.
You mean the time() function? If you're doing a lot of date math, DateTime can be god-awful slow compared to well-optimized code that uses the base calls. We have to normalize and calculate various boundaries on dates in datasets with millions of records, and the difference is between a quick walk to the drinking fountain, vs taking a long lunch and coming back to the office around 3pm to see if it's processed yet.
Maybe, but cause and effect works both ways. Break enough stuff and no distro is going to want to include the new version.
&gt; I think the ease of deploying a virtual box on sites like DigitalOcean and Linode make this less of an issue Probably not as much as you think. Most people still don't want to deal with sysadmin at any level, and having just finished an all-nighter manually backporting a fix to the linux kernel to deal with an obscure kernel bug that manifests on some of our hardware, I absolutely sympathize with them.
So actually there's no reason to deprecate them? If PHP removed everything that was slower than some alternative, this would be a very different language.
You mean, if you have two extensions providing similar functionality, with one supporting a lot less functionality, being slower, horridly implemented and unmaintained, that's not a reason to deprecate it?
That's not exactly what I'm saying. I will stand by "if you have two extensions providing similar functionality, with one supporting a lot less functionality, being slower, horridly implemented and unmaintained, then by all means deprecate the slow and horrid one, but since it is very widely used, don't remove it unless it is actively causing security or maintenance problems." I don't have skin in this game; I don't deal with any code that uses ereg. But I know an awful lot of people who do. Give them all the E_DEPRECATED warnings you want, but if you break their code purely out of high techno-moral principle, it'll hold that many more people back from using PHP 7. People are talking about "how can the language move forward if we keep all this cruft?" Well, ereg_ and mysql_ are not holding anything back from moving forward, any more than the installed base of horse carriages has been stifling the development of modern automobile technology.
Many of Laravel's components can be used anywhere. In the case of Elixir, specifically, I think folks might be confused as to what it really does. Gulp can be used anywhere. Elixir is just a thin configuration layer on top to help with some Laravel defaults. There's virtually no logic going on. The Gulp tasks can be used anywhere, assuming a configuration object is available.
You know, I thought this was an atypically neutral post, until I got to the last paragraph. Hey, did you know Laravel doesn't follow PSR-2? What a remarkable coincidence that the thing you felt would fix an odd and obscure syntax error happens to be something that Laravel doesn't do. Maybe I'm misjudging you here, but if it wasn't for the constant sniping at Laravel, you'd get the benefit of the doubt.
Aye. We have around 80 various crons. Most run on the minute. If we decide to adopt HHVM, I'll like build a job system using beanstalkd or something, that way the startup time does not matter. Our crons really should be distributable anyway. 
That's not at all what I'm implying. I'm sorry if it came off that way. I'm on my phone right now, but I'll try to reword it when I get home in a couple hours. I mean literate specifically in PHP, not in general. So I'm trying to figure out what it means to be literate in that sense *because* it's obviously untrue that professionals are necessarily more literate than hobbyists. 
For the people who don't understand why we are voting to remove things we've already deprecated: It's about timing. Everything that is deprecated should eventually be removed, but is now the right time? Personally, I wouldn't be surprised if ext/mysql was not removed for PHP 7. At the same time, this move is primarily symbolic because what matters to most of the PHP community is what the OS distributors do. If they keep bundling ext/mysql... well that isn't exactly removed, is it?
Not too much more.
Cynic! ;-)
It's not the memory of the VPS, it is the max memory setting in PHP. Just set it to, let's say 128m install your software and then back to a lower amount. 
I think the big difference is Python 2 and 3 are completely incompatible, whereas PHP 7 would just have some backwards incompatible changes and many deprecated features removed (if this RPC passes).
They should vote "no" `or die();`
But doesn't the box have Virtual Memory? Pagefile? Just configure the OS for it... It will be slow but will work. In linux it it is called the swap area...
This is def the case with AWS itty bitty instances -- they don't come with a swap for whatever reason.
I'm minded to agree with McGlockenshire - don't take the criticism personally. Over on Stack Overflow there is a strong bias against articles that are not updated to keep up with best practices, and in my view, rightfully so. The mysql library has been deprecated for some while, and the code narrowly avoids a SQL injection vulnerability by performing maths operations on potentially malicious input. [Elsewhere on the site](http://www.tutorialspoint.com/php/mysql_update_php.htm) the code is actually vulnerable. Here, a statement that is meant to update the salary of one employee can be misused to reset all of them.
IIRC AWS instances come without the machine's local disks configured, you have to enable them in the configuration of the instance...
If ext/mysql isn't removed, then the PHP developers will be doing a massive disservice to all those coming into PHP. Removing it completely will force newcomers to abandon horribly old tutorials and find more up-to-date ones, that are more likely to use prepared queries or at least teach about proper escaping (yes, there are still lots of horrible tutorials written against mysqli and PDO, but from my anecdotal experience the pool is a lot smaller - anything the core developers can do to help this is a good thing). Yes, there are many people running horribly old code bases, but to counter that argument I would say that they have already had and are getting plenty of warning. In many cases it could be that the developers will actually welcome this as it will force management in poorly run companies to give them the time to upgrade (and refactor while they do it). If developers really want to do a 'fast and dirty' upgrade, the mysqli functions are not really dissimilar enough to cause an issue in my opinion. And anyway, if developers are really really desperate to keep hold of horribly old code, then (even if the core developers don't) someone will more than likely put in the small amount of work that would be required to counter any internal API changes and make an external extension out of it. Who knows, the resulting fallout of people being forced to find more up-to-date tutorials that might actually teach them about prepared queries or at least proper escaping may even cause a long term improvement in PHP's (perceived) security track record.
The digital ocean boxes don't have a swap enabled by default. You can create it pretty easily, it's in the do docs. https://www.digitalocean.com/community/tutorials/how-to-add-swap-on-ubuntu-14-04
DigitalOcean instances do not have a swap file enabled by default. Enable it, and then maybe increase `memory_limit` for php-cli. I'm hoping this will fix your problem. https://www.digitalocean.com/community/tutorials/how-to-add-swap-on-ubuntu-14-04 https://www.digitalocean.com/community/tutorials/how-to-add-swap-on-ubuntu-12-04 At worst, you could simply `composer install` on your local box and then manually copy the `vendor` folder to your server.
Try increasing swap space. You could also try zram. 
The reporter's code *was* the test code. ;-) He was using that see if he was getting what he expected from the library; as it turned out, the reporter's test code was itself in error.
You can do what people have suggested and enable swap. My workflow typically has me run `composer update` on my local machine, and then scp the composer.lock file to the server. From there I can composer install without any memory concerns.
mysql_ functions will throw a deprecation warning every time you use them in PHP 5.5 and above, so that's likely what you were avoiding.
That seems a bit high. I don't think composer needs that much ram, does it?
As far as I figure, composer uses lots of memory when calculating dependencies, but not when just installing packages. So what I'm saying is that I think that you haven't copied your composer.lock over? If you copied that from your local box, then the dependencies would already have been calculated and doing a composer install would just literally be downloading/unpacking files and so wouldn't use a ton of memory?
In the 15 years I've been doing this, I've never once seen an error that would have been revealed by always using braces. The auto-formatter has always made it clear what was happening. I have seen one, as is literally one time, where there was a dangling semi-colon. Not having braces would have revealed this, but as it was only one instance that's not frequent enough to warrant establishing policy. Compared to what I lose in screen real-estate, worrying about braces is just not worth it.
That told them! 
Why not just use one of the three extant XML parsers?
It's going to depend on how much shit is in your composer.json and how broadly specified you have the versions specified. I've easily seen composer take up this much memory before.
Seeing more code at once helps with understanding, which reduces bugs far more than this.
and why in the world would you upgrade PHP on something you know is going to break, without fixing things&lt;?
P.S. I almost always type the braces first and then remove them during cleanup. So laziness isn't a valid charge.
Because i needed to parse The XML to an Array and then do some processing on Array. For example assume that i have a nested xml and want to get find the parent of a tag which contains value 'test': &lt;a&gt; &lt;b at='1'&gt; &lt;d&gt; &lt;e&gt; &lt;f&gt;test&lt;/f&gt; &lt;/e&gt; &lt;/d&gt; &lt;/b &gt; &lt;b at='2'&gt;&lt;x&gt;&lt;/x&gt;&lt;/b&gt; &lt;c&gt;&lt;/c&gt; &lt;/a&gt; Xml , stripTags, needle $array = x::seek('file.xml',1,'test'); This returns whole b with ' at=1 ' 
I have never heard of anyone who does that.
Well of course no one would *intentionally* upgrade, knowing that their site would break.
To learn Slim, I made a small img placehold service "a la" Placehold.it. Slim its a **really** nice framework, I wholeheartedly recommend it, specially with a small project like this one. Are there any other Slim projects arround you guys have made?
Not used it but I really like it. Earlier this year I was looking for a new framework to replace CI in a new project - didn't fancy any of the big ones and looked closely at Slim. Ended up making my own, but influenced by what I saw in Slim - showing that basic app stuff, routing, input/output etc, can be lightweight and not rocket science.
Pretttyy cool, I've tried using slim for a few projects and have really enjoyed it-it just feels right.
Thanks!, If people use it, I'll most definetly keep it alive :)
And the ORM library? What are you using?
Yii 2.0 is finally coming, after more than three years of intensive development with almost 10,000 commits by over 300 authors! Thank you for your support and patience! As you may have already known, Yii 2.0 is a complete rewrite over the previous version 1.1. We made this choice in order to build a state-of-the-art PHP framework by keeping the original simplicity and extensibility of Yii while adopting the latest technologies and features to make it even better. And today we are very glad to announce that we have achieved our goal.
Neat idea! Small bug I noticed: It seems any parameter can take the optional extension *except* the font name. This seem problematic, since you probably want the desired extension at the end of the URL. Ex: http://imgholdr.com/250/chewy vs http://imgholdr.com/250/chewy.png
If you don't say why, your argument is irrelevant ;)
... Are you serious? 
Aren't both the maintainability and performance woes entirely due to the ancient (20 years old) bundled regex.c implementation? Once you swap it out for `--with-regex=system` its speed scales down from 5µs to 1µs for common pattern matches. Same as with just using libpcreposix, which is just the ERE frontend onto PCRE. The ereg.c wrapper itself actually looks tolerable. I wouldn't mind avoiding code duplication by shadowing mb_ereg per default, of course. But just ripping a compatibility hole because of performance drawbacks from [historic PHP4 + Apache 2.0.x workarounds](https://github.com/php/php-src/commit/23a3cc71e3e321308fe6c28302a51a689dab1745) seems unreasoned.
First bug!, yey!, haha, thanks man, it's fixed now!
Yes, I'm not the only one to read this, and everybody hasn't your knowledge, so share a little more instead of assuming encoding/hasing/crypting/cryptogrpfucking/etc is the basics everyone should know.
Uses localhost:8080 for some reason?
dev environment :), fixed.
http://codahale.com/how-to-safely-store-a-password/ Just because he didn't link references does not make his ~~argument~~ fact irrelevant. This knowledge has been well defined and is even on PHP.net in the notes for popular hashing methods. * http://us2.php.net/md5 * http://us2.php.net/manual/en/function.sha1.php * http://us2.php.net/manual/en/faq.passwords.php#faq.passwords.fasthash
that's right I guess i use the wrong word, thx for the links
Nice!!!, good look with taming that beast!
`composer update` uses a lot, `composer install` not so much.
Install HHVM and run composer with it. I've had the same problem and hhvm helped... Also composer that way runs much faster. 
Took me a minute, here's my last slim project : http://downvot.es
This is pretty neat. Are you planning on releasing the source at all? Also, small typo: &gt;Just add some parameters to our URL, and **well** generate the image according to your requirements. Should be "we'll".
We made Assassin's Creed Initiates with Slim. 
I agree, but the PHP developers aren't in the business of destroying websites, even if the websites are owned/operated/coded by ignorant people. They're in the business of producing a usable language that helps people build websites.
It looks like Yii has come quite a long way. Glad to see other frameworks that aren't stuck in old principles. 
The feature list is very compelling, congrats on what looks like a good balance of low learning curve and modern software development practices.
Yep, but that doesn't mean it is wrong. 
Doesn't mean its right either.
I'm not against removing barely-used and deprecated stuff, but some of them (like creating a new object by reference) are present everywhere, even in the official manual http://php.net/manual/en/oop4.newref.php This page needs a big alert discouraging the use of PHP 4
What about this website? http://get-elephpant.com/ Seems to be the whole purpose of the thing, I want to order from there but I'm not sure if its phoney... Why would they put testimonials?
Yii2 is awesome! Thanks for the great work!
Here's a fun one. I've been beating my head over this for the last 5 days or so. I'm replacing mysql ext calls with PDO (really through Laravel 4.1's abstraction layer, but this happens when they execute PDO and when I use PDO manually) in a database-touching library. Everything's going great until I run into a simple query that runs *select count* query on a table, returning the total number of rows in the table. I have a unit test for it that creates a test database, a test table with a primary key id and single varchar column, then inserts two rows into the empty table and asserts that the row count is 2. This runs fine in my mysql command line and when using the mysql ext call. However it takes nearly 15 minutes to run in PDO and locks the table during the query. I've tried various combinations of prepared statements, fetch modes, query(), and execute() and still haven't been able to find out the problem. PDO will prepare the statement just fine but sits there when trying to run the query. This happens whether or not I'm using the SQL cache. All of my other PDO queries run fine. Google and stack exchange haven't been any help. Here's the original code: $query = "SELECT COUNT(1) AS count FROM `test_table`"; $result = mysql_query($query); Here's what takes 15 minutes: // Using Laravel to get to PDO. It does the same thing if I build a new PDO connection or run Capsule::table('test_table')-&gt;count(). $pdo = Capsule::connection()-&gt;getPdo(); $result = $pdo-&gt;prepare("select count(*) as aggregate from `test_table`")-&gt;execute()-&gt;fetchAll(); This query is slightly different, but isn't complex, and still runs fine using the mysql ext and on the mysql command line. My environment is PHP 5.6.1 and MariaDB 10.0.13 on OS X 10.9.5. Has anyone got any ideas? I've been tearing my hear out over this. 
no, but that accidental semicolon would be hard to spot when debugging.
Thank you very much!
His reasoning on the laravel.io podcast made a lot of sense tbh
Finally... Now let the Yii vs Laravel battle ensue.
&gt; This query is slightly different, but isn't complex The first query doesn't touch the table, what is the result of running this: $query = "SELECT COUNT(*) AS count FROM `test_table`"; $result = mysql_query($query);
And just as difficult without brackets.
As discussed earlier [here](https://www.reddit.com/r/PHP/comments/2ict7h/using_xmpp_as_a_logfile_debug_alert_system/), I now published the current progress to GitHub. Comments welcome. 
Love an peace man, love and peace ;)
Yeah, took a bit more time than we've planned but I like the result.
Sorry about that, that's my fault. I pulled the graphs from [here](https://grafana.wikimedia.org/#/dashboard/db/edit-performance), without bothering with the scales and things, just trying to get a screenshot that emphasized that HHVM is faster than Zend.
Is it different from, say, [dummyimage.com](http://dummyimage.com/)?
I used it for a small project - a few thousand lines - and the lack of ability to organize controllers into classes, basically having to pass the global $app variable around to every closure in order to have shared instances of classes, got really annoying. Most PHP developers are probably fine with this, though (doesn't make it good, however). If your project is truly tiny, like less than a thousand lines of code, I'd honestly just write it without any framework.
Congratulations Yii team for an outstanding framework. I have been following it closely since the beta and started working on a project recently with RC release. The learning curve has been very small so far. PHPStorm detects PSR-0 autoloading correctly and maps out source directories automatically. The framework code is so well structured and commented, I have not found myself going back to the class library / user guide that often. Also, thank you for supporting Yii 1.x until Dec 31 2015. Really puts me at ease knowing that this framework is in safe hands :) Overall, 10/10 from me. Great effort and well worth it.
Cheers! First yii2 release that has no code breaking changes since previous unstable release!
How it's not?
Further releases should not break code for quite a long time.
It's a cool project. However, I cannot find any link to the source, so posting it here seems to be against this subreddit's guidelines. For all we know you might have written this in Scala :)
The dumb comment was something like: How is all lower caps namespaces PSR compatible?
Try this: # /bin/dd if=/dev/zero of=/var/swap.1 bs=1M count=1024 # /sbin/mkswap /var/swap.1 # /sbin/swapon /var/swap.1 taken from [this composer issue](https://github.com/composer/composer/issues/945). It worked for me as a temporary solution.
I failed to mention in my other post that: //the ; after the query is a syntax error; the following produces a syntax error; $result = $pdo-&gt;prepare("select count(*) as aggregate from `test_table`";)-&gt;fetchAll(); //this does not $result = $pdo-&gt;prepare("select count(*) as aggregate from `test_table`")-&gt;fetchAll();
Hey neat project, generates pretty slick placeholders, and the custom font selection is a nice touch. Also a small typo, you should translate this bit of Spanish left behind: &gt;Color can be specified for the background and the foreground. Color use their respective HEX representation ***(#ffffff es blanco)***, and they always go after the SIZE parameter.
Totally agree with your point of view. I am all for standards, and have personally moved away from Wordpress related projects lately. But I will never bash or laugh at Wordpress. The divide between PHP Developers and Wordpress developers is real, and the way I see it (and I may be wrong), there is a strong push from vocal community members for taking PHP forward without much consideration for legacy code that is already out there. I think the PHP Core team is doing a great job balancing the requests from the community to move forward while keeping the legacy code bases secure and functional. Then there is the hostility towards Wordpress developers, which further pushes the two worlds apart. A developer will ask a question on here or stackoverflow about wordpress, genuinely looking for help. Instead, the white knights of PHP community will bash him/her about how bad Wordpress is. This creates an unhealthy space for open discussion among developers. That is why you will see Wordpress developers huddled together in Wordpress Forums, or a Wordpress subreddit, etc. No one wants to be bashed for doing their job. Wordpress may not be following PSR standards, but the fact is, PHP as a language allows for diversity to exist, like any other language. And I would not call Wordpress a complete mess. It has a learning curve, but once you get to grips with Wordpress way of doing things, it is like any other project. You set your goals and work your way to a solution. Also, one must remember that at the time when Wordpress' foundations were laid out, there was no composer, PSRs and standardization of PHP like today. Wordpress had carved it's own way of doing things, and it has worked rather well over the years. It is also important to realize that all the argument and fussing about WP being a mess holds weight when discussed among developers. I have worked with some successful businesses/agencies who have absolutely no interest in "How" and "Why" of a tool or software. They care about "What" it can do and more importantly "When" it can do. Tell a executive, non-tech project manager to invest significant amount of money and few months of time to develop a Symfony or Laravel based solution that will be extensible, following PSR standards, etc, etc vs. pick up Wordpress, purchase a premium theme from a selection of thousands and bolt on the missing functionality in 2-3 weeks. I am sure there will be many who will be sold on the first option but significantly more will opt for Wordpress. At least that has been my experience.
Well aren't we glad that phase is over? :) Let's welcome Yii2 and unshackle it from it's past choices.
I've used [CIUnit](https://github.com/fukata/CIUnit-for-CI2) in the past, and it worked fine for me - this should be enough for unit/integration tests. For functional testing, a regular [PHPUnit w/ Selenium stack](http://taiar.github.io/php/2014/04/21/acceptance-tests-on-codeigniter-with-phpunit-and-selenium.html) should work.
This thread has been linked to from elsewhere on reddit. - [/r/lolphp] [\[xpost r/PHP\] Can you convince me not to use DreamWeaver?](http://np.reddit.com/r/lolphp/comments/2j3tj0/xpost_rphp_can_you_convince_me_not_to_use/) *^If ^you ^follow ^any ^of ^the ^above ^links, ^respect ^the ^rules ^of ^reddit ^and ^don't ^vote ^or ^comment. ^Questions? ^Abuse? [^Message ^me ^here.](http://www.reddit.com/message/compose?to=%2Fr%2Fmeta_bot_mailbag)* 
Did you even read the comments on that bug? var_export doesn't generate anything, especially 'out of thin air'. That's the actual value of the float. Floats don't (generally) have nice round numbers like I suspect you think they do. See: http://en.wikipedia.org/wiki/Floating_point#Accuracy_problems
What I'd like to see on WordPress.org is *some* mention about "mainstream" PHP coding standards, like PSRs and use of composer. Eg if WP said something along the lines of this then I think it'd help "WP devs" become "PHP devs". &gt; We follow our own coding standards because it makes BC easier and changing all the code would be difficult to organise. However, there are widely accepted recommendations from the PHP community (called PSRs), which are sueful if you want to make interoperating with other code bases easier. Here's how you can do this if you want to... &gt; WP has its own plugin and theme system which is really easy to use. However, the rest of the PHP community have settled on using composer to manage dependencies. This can be difficult to get working with WordPress, and there are some pros and cons in using it. Here's how you can do this if you want to...
Codeception acceptance testing should/would probably work - since it just interacts with the site via curl/guzzle.
That would be worth to discuss. I'm a bit doubtful about how that would help WP (or be value for them) thought. I mean I think it is not WordPress' job to advocate folks from the WP community to take a look at the "PHP community". I'd think "WP developers" can become part of any other PHP community if they just want to (by their own choice, without WP especially advocating it). If the "other PHP community" a WP dev is joining is friendly and welcoming, I think everything will roll on it's own. That said, the most important part about communities is not technical details, but the people and the atmosphere.
He really did say that, accompanied with the kind of reasoning that should convince anyone of the obvious value in doing so. Hopefully #phpnw14 won't be too long getting the videos up, it's a great talk.
It does the same thing when I use `COUNT(*)`. `SELECT COUNT(1)` over `SELECT COUNT(*)` is an old optimization holdover that's stuck in muscle memory. `COUNT(*)` works just as well as `COUNT(1)` nowadays. 
Heh, that was me not double checking before I posted. The extra semicolon isn't in my original code. Good catch though. :)
I'm currently working on a multi threaded/process CLI application in PHP, it might not the best tool for the job but I'm already too deeply invested in PHP and migrating it to another language isn't going to happen right now. Before I continue, my question is, am I crazy or re-inventing a huge wheel? I'm using Redis ([phpredis extension](https://github.com/nicolasff/phpredis)), it's the backbone of this application. The application requires lots of separate processes doing jobs and all talking to each other through Redis, I'm making use of Pub/Sub to keep things ordered, for example 20 processes might do some work and share a single array on Redis, they publish commands such as add/remove to a channel that one "master" process subscribes to and completes the command as they are received. This is to counter what I believe is called a [Race condition](http://en.wikipedia.org/wiki/Race_condition). As I mentioned, this application requires many processes, they are managed through a similar method with an additional "watcher" process that ensures all critical components are running. Processes are run under the linux "screen" command and log to files. I know *about* [pthreads](http://php.net/manual/en/book.pthreads.php), but haven't actually used it. Should I stop what I'm doing and learn pthreads? Can threads "talk" to each other and share memory? What about race conditions? Is there something similar to Pub/Sub where a process waits till another process publishes something to work on? Is pthreads suitable for an application that should be running 24/7? I think I was put off by the fact that if the original process dies, all threads die with it.
That was a post snafu like my extra semicolon. I'm calling `execute()` before `fetchAll()`. The `execute()` call is what hangs. (Remind me to have a cup of coffee before I ask the Internet for help again. :))
WTF, why the downvotes?? I have a feeling there's a bot downvoting certain keywords on this sub. Really nasty. We need more Symfony around here.
Absolutely.no. You are asking for co-ownership (which isn't really an employment contract, but a partnership), and that means that you can't expect an employer-employee type of relationship. You are looking for an investor rather than an employee.
what about something like Gearman? http://gearman.org/
Explain to me multithreading like I'm 5
perhaps they are downvoting the content, rather than the submission. Anyway, it's an interesting, opinionated read. It's also got some interesting tweets about it. Part of problem is that a framework the size / scale / scope of Symfony cannot come with one-size-fits-all documentation. This best practices doc will - hopefully - eliminate some of the mess that people who are newer to the framework find themselves in. However, it's one extra document to read, requires you to have enough experience to understand wtf it's on about, and generally, in my experience, the ones who cause the most chaos don't read any documentation anyway. 
Thanks for feedback. I am basically looking for an employee that is willing to work for equity alone. The better route would be to find an investor and use that money on a programmer, I understand that.
I'll be there! Not only because I'm giving a tutorial and a talk, but since it's a conference run by the same people as php[tek] I'm sure it will be great. I've known the guys putting it on for a long time, before they started running php[tek] a few years ago so I'm highly confident the conference will be good. For anyone interested, it is a conference aimed more at CMS + Laravel, ZF, and Symfony developers than a general PHP conference, so I think that puts some people off. Most of the speakers do not live in their own little bubble though, so there will be lots of great people to talk to and interact with. 
I see that you updated your original post, and that you are calling execute on the $pdo object. You can not do that, you need to call execute on the statement ($result), in this case execute() returns true or false as seen [here](http://php.net/manual/en/pdostatement.execute.php), so you can not chain fetchAll() on $pdo who is now true or false. Hope this clears some stuff for you. Your code on my machine returns: Fatal error: Call to a member function fetchAll() on a non-object Try doing it the way I listed it in my example without the method chaining. 
Yes! This is almost exactly what I've built. I'm going to study this, they've probably solved some problems I'm going to run into and I might adopt some design. I'll also experiment with it and see if it gives me better performance than what I've done already. Some differences I've noticed are that I usually skip the "Job Server" and send commands straight to the "Worker", in some cases I use a Job server as job storage and a third process periodically gets all open jobs, processes and responds directly to the Client through Redis instead of back to the Job server. I think I like the idea of spawning additional Worker threads if the workload is too much for one process and multiple Job servers increasing redundancy. Thanks.
Didn't they changed the algo again? When I check new posts it never goes down below 60% upvoted unless there are a few real downvotes. I suspect /r/lolphp but whatever.
No sir, I would not. 
Let me check with the local grocery store, landlord, and utilities and see if they accept payment in the form of future equity. EDIT: Yeah they don't, so no.
Nice job! Definitely a tool that has a use.
Thanks! I'm still working out some of the kinks on it, but it's been handy so far :)
Thanks for the feedback.
If I was 20, didn't have a mortgage or any other financial obligations, was just looking to build some experience, and cool with taking a chance on something that could blow up? Yes.
I agree with most of the practices - not all of them, but it's definitely a good guide to determine how to set up a Symfony project.
Thanks, makes sense to focus more on people with those characteristics.
Wow, huge changes from yii. Looks really interesting, I might give it a try on some future projects.
And that's the spirit of the best practices. Pick which ones you agree with and use them, it's not a mandate. Personally, I found these really interesting. I had adopted the existing best practices guide which assumed you were building re-usable bundles, without really stopping to think about it. Having best practices that focus on reducing clutter and speeding up the work for those of us making business applications is a great idea.
Yes, some things make so much sense, like having one bundle or naming services, or keeping templates in one directory. I guess docs will be rewritten to include these practices. Because I followed the docs and cookbook and missed so many of these.
&gt; but I disagree with saying that only involved people take the best decisions. That's not the implication though. It's that those that do are going to have more impact than those who don't. Sure, it may not be the best decision, but it's a decision that was executed. The problem comes in that how do you gauge who to listen to? Pure meritocracies are not really good, because of a whole host of reasons (those that do the most aren't necessarily those who are best suited for leadership). But what PHP has today is a reasonable mix. It's part meritocracy in that doers have voice. But people who never do can be heard and listened to. The key is the balance in there. If you can make a better decision, but never get involved enough to actually come in and make it, then we all lose. But we don't lose because you were prevented from making it. We lose because you didn't make the effort to actually make it. The barrier is incredibly low. I encourage you to participate. &gt; It's more about the vision PHP has than anything technical. Now that's a far bigger problem...
Is it normal to end up with classes that only have one public method? An example would be that I have one class whose responsibility is to import data from a spreadsheet and load that into a formatted array. I then have another class who iterates that array and makes all of the necessary repository calls to persist the data. Both of these classes only have one public method to accomplish this. I don't know why but it just doesn't feel right? 
That does the same thing. The `execute()` call hangs. I'm seriously confused. I may try running this on another machine to see if I get the same results. $pdo = Capsule::connection()-&gt;getPdo(); $statement = $pdo-&gt;prepare("select count(*) as aggregate from `test_table`"); // Hangs here. $statement-&gt;execute(); $result = $statement-&gt;fetchAll();
Thanks for the clarification, I definitely agree with that.
Have you tried checking for errors like so: print_r($pdo-&gt;errorInfo()); Or like so? try { $statement = $pdo-&gt;prepare("select count(*) as aggregate from `test_table`"); $statement-&gt;execute(); $result = $statement-&gt;fetchAll(); } catch (PDOException $e) { die('Error Occured:' . $e-&gt;getMessage()); } Maybe without the die(). 
For context: http://world.phparch.com/ My company is organizing, so if anybody has questions I'm happy to answer them. I can also give 10% off coupons to anybody who DMs me and requests one.
I'm looking at someone elses code and I see things like: &gt; $i = round(0 + 0.25 + 0.25 + 0.25 + 0.25); &gt; $level = (int)$this-&gt;getSettings('levels'); &gt; if ($level &gt; round(0 + 1.6666666666667 + 1.6666666666667 + 1.6666666666667)) &gt; $level = round(0 + 1 + 1 + 1 + 1 + 1); &gt; while ($i &lt;= $level) Do I not know of a bug that was in older versions or does this person not know that **$i = 1;** would produce an int? Throughout pretty much the entire code ints are made from rounding even when it's just a 1 or 0 that never changes or to start. Ex: &gt; for ($i = round(0); $i &lt; count($payments); $i++) 
less likely to do it if you use brackets. Also, easier to spot using a regex search.
Looks like it's part of a DES implementation: http://trac.roundcube.net/browser/subversion/trunk/roundcubemail/program/lib/des.inc Also: 1. PHP has DES built-in, so there's no reason to be using this script. 2. DES is shyte and shouldn't be used anymore. 
I'd gone through with symfony a couple of times, and kept banging my head against the existing docs and 'best practices' I'd found, and kept thinking "this is not good". Seeing some of these 'rectified' in a 'best practices' guide... is interesting. 
How is sublime by far better than, for example, vim or emacs?
PHP7 skips 6, and would be best for breaking BC -- fix all the inconsistencies, remove previously deprecated functionalities, implement modern features. old code doesn't have to run on it, they'll always have 5.3~5.6 for those.
That sounds so horribly inefficient
My gosh, now that's documentation and features. No, it ceirtanly isn't, but man, it's just a couple of hour projects ! :D Dummyimage.com is really nice, I'll see what I can "emulate".
Thanks!, Ah, I shall then, I'll make a github repo when I get home, or just with a gist I guess, it's just a couple of lines anyway :)
Main language is Spanish, but I decided in a wimp to just deploy the app in English in the last minute. I'll fix it when I get home, thanks!
From what I've seen that's quite typical of "conversion" or "document" type classes (CSV creation, Markdown conversion etc). There is usually only one or two things the class does. Of course I'd assume you use multiple private methods to separate "sub-functionality", like quoting cells in a CSV creation class.
How does one become part of the PHP Internals? I know we can follow the news and all, but If I wanted to vote, propose a feature or write an RFC, what are the requirements? 
Dude,Could you please share the source code?
So of course the first comment on the article ended up being: &gt;just fix the function name and parameter order inconsistencies already.
This looks like insanity.
It looks like https://www.versioneye.com 2 years ago ;-) 
Correct. Each class has the one public method with multiple private methods (nothing that would warrant public exposure.) 
Gled to se HHVM moving up! Let's see how that works out. 
try /r/forhire 
What modern features do you think PHP is missing that should be added?
How do you guys feel about storing web assets in `/web`? I actually thought this was considered bad practise. I'm glad this book was released, it's a great help to assure you're doing things the right way.
I'm interested! Please pm me your e-mail.
I was looking over magic methods and was curious what are some unorthodox ways of using them? "Unorthodox" is a board term here, so go crazy.
Meh, I feel like a lot of these "best practices" are just some people's personal opinion and are not really universally applicable. &gt; Don't define parameters for the classes of your services. I've found it useful on multiple occasions to be able to determine via configuration which implementation of an internal service to use. Maybe on smaller projects this isn't necessary, but it is not exactly "cumbersome" to have a parameter. &gt; Use annotations to define the mapping information of the Doctrine entities. &gt; Annotations are by far the most convenient and agile way of setting up and looking for mapping information This is just my personal opinion, but I hate annotations with a passion. IMO, the purpose of using an ORM is to separate model logic from persistence logic. And having annotations for persistence inside the model class almost defeats that idea entirely. Yes, it's not *actually* a mixing of logic, but personally I don't like the way it feels, and using XML or YAML configuration works just as easily. I don't see how annotations are so much better that they are "by far the most convenient". &gt; Store all your application's templates in app/Resources/views/ directory. No thanks. If a view is used in a bundle, then it should be in that bundle. If you are not distributing your bundle as an independent library, then I guess it does not make a difference, but I still don't agree this is a "best practice". &gt; Store your assets in the web/ directory. Uh, what? Isn't the entire purpose of Assetic to gather your assets from their appropriate directories?
You can do many things like documentation stuff, extension writing/maintenance, bug fixing and maybe even contributing to core. Some more info [here](http://php.net/get-involved.php).
You've got an htmlspecialchars() error there friend - and a full stack trace visible in production.
Basically, [you need to have a VCS account](https://wiki.php.net/rfc/voting#who_can_vote) on php.net. For that, you need to apply for either a [PECL account](http://pecl.php.net/account-request.php) (for extensions) or a [PHP account](http://php.net/git-php.php) (for everything else). Both pages have useful info on what you need to do *before* applying. Good luck :) **EDIT:** You can of course write an RFC (and propose it on internals) *without* having a vote. If you choose to take this road you should ask an existing internals member for help with the RFC (both with writing *and* proposing).
Good read all together. My favorite part was they said "We've deliberately kept this guide short". In true Symfony fashion "short" is 50 pages.
FTP?? Ugh. Firstly, you shouldn't be using ftp for anything, and secondly, having it integrated into your IDE so it uploads when you save is a HORRIBLE idea. Seriously, it's 2014 - why are you using ftp?
That sounds beautifully disgusting. Why are you even using ftp, yet alone have it upload on every save? I hope you don't upload directly to production that way - if you do, you must be used to having a broken site many times a day.
https://ellislab.com/codeigniter/user-guide/libraries/unit_testing.html CodeIgniter has a built-in Unit testing class, you could start there.
Your computer can run more than one program at a time, right? Well, it does that by switching back and forth between them really fast. The OS pretends each program runs on a CPU all its own. That pretend CPU is a thread. Each program gets one. Multithreading is when a program has more than one pretend CPU. If you do it just right, both pretend CPUs can work at the same time(*), and if one has to wait on something (say, for the user to type something), the other can keep on going. (\* Sometimes, usually on older "single-core" computers, threads don't *actually* run at the same time. The computer just switches between threads really fast, like it does programs. If you actually *do* have more than one CPU, though, the computer can give each thread to one of the real CPUs, so both things actually can run at the same time.) The big difference between "multithreading" (having one process with a bunch of threads) and "multitasking" or "multiprocessing" (having a bunch of processes with one thread each) is how much data gets shared. Two processes each have their own copy of stuff, so whatever they change doesn't affect the others as much. Two threads in the same process, though, work on the same copy -- so whatever one changes, the other will *eventually* see. The catch with multithreading is that "eventually" part. When two threads can mess with the same data at the same time, they can mess it up (undoing each other's changes, sending each other off on wild goose chases, and all kinds of other wackiness). This is called a "race condition". It's a bug, and a really pesky one because it doesn't break all the time -- just at the worst possible time, in my experience. :) So it's really hard to track down. To avoid that, you need "synchronization" -- basically a way for a thread to tell others "i'm messing with this; if you need it, wait til i'm done". That's what "mutexes" and "semaphores" are often used for. 
While I can't say that we will use all of these recommendations I think its great to hear what the core devs consider to be the best way to structure things. I also appreciate that they provide a bit of explanation of why, not just 'do x'.
I *think* the email is just an alias that you can configure but yes, once you are approved for a PHP account you should get to choose an alias as well.
This is mainly an optimization sytem that sort of "bypasses" the PHP engine for parts of your code. It currently supports only a subset of PHP and I'd say it's a pretty advanced tool. If you are new to PHP, there is a long list of things to learn before getting to compilers like this :)
Does it appear that the code might be auto-generated or a copy/paste job? Either one could result in oddness like this -- the former from a code generator that doesn't try to clean up its output, and the latter from replacing formerly-variable parameters with hard-coded values (but somehow not making the jump to actually calculating the values or checking whether rounding was still needed).
I've been learning Symfony2 recently and this is very useful. No mention of defining Controllers as Services? I figure this is frowned upon then. Odd as there seems to be a great deal of varying opinions on this subject.
Not auto generated or copy-paste. It's a module from the developers website for a platform. Wasn't encoded or anything.
This is pretty neat actually.
I don't think its frowned upon, its just not common. There is a great deal of controversy on the subject though, and i'm sure thats why it wasn't included.
Sure man, I don't see why not, just let me make a simple gist when I'm at home ok? :)
Chapter 5 (Controllers) talks about Controllers. The guide recommends not creating them as services, but rather extending the base Controller provided by Symfony. &gt; Coupling the controllers to the underlying framework allows you to leverage all of its features and increases your productivity. And since your controllers should be thin and contain nothing more than a few lines of glue-code, spending hours trying to decouple them from your framework doesn't benefit you in the long run. The amount of time wasted isn't worth the benefit. 
Those don't have any effect. The call succeeds. It just takes 15 minutes or so to count two rows in a table, which works fine with the mysql ext. I tried it on a development system running Fedora 19, PHP 5.4.9 with MariaDB 5.5.39 and get the same delay. Thanks a lot for the help.
:)
I missed that, thanks.
Yea your totally right and I agree, but it's for a study of crypto techniques
Congrats on the release /u/michael_d! It'll take some time to migrate from Guzzle 4 to 5 due to request/response changes but I believe it'll be worth it :) Also thanks for removing functions.php! Composer has some weird behaviour with bare functions where, by manually including multiple autoloaders (think Laravel's workbench), you get "function already defined" fatal errors. It took a long time for Assetic to accept adding an "if-guard", glad that won't be necessary with Guzzle.
&gt;What is the benefit of removing ext/mysql? New programmers not using it. Seriously. When I started developing in PHP, ext/mysql was *already* bad practice. But those who taught me didn't know that, the tutorials and documentation I sought out didn't tell me that, and even today, nearly 8 years after I started using PHP, the vast majority of well-written tutorials for database interaction in PHP encourage the use of ext/mysql. People following tutorials aren't going to heed warnings, they're going to look for how to turn them off so the code they wrote works. Removing ext/mysql will stop the pollution of the newbie developer space with people using the wrong library. That being said, I'm all for just turning it into something that doesn't come with PHP but can be re-added for those that depend on it.
Here's the related blog post that describes the new features: http://mtdowling.com/blog/2014/10/13/guzzle-5/
Thanks!
If you haven't noticed by his post history, he's a troll. Knowledge is not what motivates his response. 
&gt; But I see WP is made for end users and it is doing amazing job at that. "End users" is quite broad. In reality, it's made for a specific *type* of end-user: the kind who structures their business rules and business model around Wordpress's limitations, not the end-user who wants exactly what they want. Wordpress, by its nature, is heavily opinionated. If your business rules don't match those opinions, and you aren't willing to bend your business rules to work with Wordpress, that's when you get into "development" territory, and that's where PHP developers start gnashing their teeth. So just a little tip for developers and free lancers out there, before you decide whether Wordpress (or Drupal) is going to be a good fit for your client, you need to determine which type of end-user your client is: the flexible kind, or the inflexible kind*. If your client is the inflexible kind, do yourself a huge favor and forget about using Wordpress or Drupal, and just go Laravel or Symfony - this choice will save you massive headaches down the line because at the end of the day, creating a basic CMS in either Laravel or Symfony is about 8 hours worth of work which will be recouped four-fold down the line. \*Also gauge how technical they are. If they want Wordpress because they know their way around plugins and configurations and themes, then Wordpress is probably fine. But it would be a strange situation for a technical client to pay you $50/hour to do what Wordpress was designed to let THEM do themselves. So really, if your client needs you to build a site and can't install/manage Wordpress on their own, then they will not benefit from Wordpress's theme/plugin ecosystem anyway, and instead YOU will be fighting all of that nasty technical debt. Never choose a tool that makes *your* life harder if it makes no real difference to the client.
Why not just use version control and do it properly?
We use subversion. That's how is all done. Using willbonds sftp plugin to upload our changes from sublime text to our own development area doesn't mean much. All checkins commits and pulls etc are doing through subversion
But if you have a shared development area, that means the dev area could have different versions of files on it to the ones you've been working on. Sounds like a nightmare. Why not use Git and have the devs work on virtual machines?
As a university we don't have access to git we have to use svn. Every morning all the devs do an update. It works for us and our needs.
I think we should have a separate sub for ircmaxell and krakjoe's blog posts.
It's an inferior workflow.
I'll be honest, I don't find it particularly difficult to differentiate between a troll and a conscientious objector. While I appreciate and agree with the fundamental perspective presented here, it just kind of feels strange to see such detail put into deciding whether any given opinion has merit or is just plain malicious. This reads like a call to arms to embrace the trolls. While I respect anyone willing to take the time and try to reason with a person who would rather descend into flame wars and name calling, for me personally, there is a line just over yonder and too often a person will sprint joyfully across it while I move on to doing something more productive. I don't really care how valid or brilliant your opinion is, if you're unwilling to strive for higher level discourse I'm out.
Although Versioneye's design is still where it was at 2 years ago.
&gt; we don't have access to git Git is distributed. If I `git init` a repo, I have a free-standing copy. You don't need any service whatsoever to host Git. Every user of Git is hosting Git. All you really need to do is to make the site you're SFTP'ing to be a Git repo. Then you can git push from your local machine, and then it'll SFTP the Git repo changes to the remote, and you'll instantly find conflicts.
Word
These are all valid points, but this is the best practices guide for people who are making business applications and do not plan on sharing their code. I think you are getting caught up on this being the definitive best practices guide. It's not. It's Fabien's Best Practices for creating pragmatic, non reusable business bundles. It makes tradeoffs for doing that, and it acknowledge's those tradeoffs. It's trading flexibility for speed of development and for fewer files needed. If you don't like these guidelines, then don't use them. They are just suggestions. The purpose is to teach people that there can be different ways of structuring your project files, based on whether you are sharing a bundle or making a business logic bundle. The majority of SF2 devs make bundles that are not going to be shared, but follow the best practices guide written for sharing. As an example, if you wanted to create a new feature bundle and add a page using the standard best practices, you'd need to: 1. Add your new bundle's routing.yml file to the app's routing.yml file. 2. Add your new controller's route to the bundle's routing.yml file. 3. Add your controller. 4. Add your controller (as a service) to the bundle's services.yml file. 5. Load your bundle's services.yml file through its DependencyInjection class. 6. Create a Twig template. Once you've done all that, you can finally start coding. But if you follow these guidelines, you can reduce a number of those steps. The steps then become: 1. Create your controller. 2. Create your twig file. That's it. Routing is done via annotations, and you have already imported controller annotations since you are just using one bundle. Your controller isn't a service, so you don't need to define a new service. Again, there are definite trade offs for doing it this way, but I think it's a nice counter point to the existing suggestions. It's not intended to be a one size fit all.
My advice has always been, listen to any complaints and feedback about your (or your companies) software/products/services. If its just a pure complaint, try to find out what the cause of the issue is. 1. If they _can_ justify their complaints, eventually you will get some constructive feedback which you can act on. More documentation on a specific subject, improve wording to restrict unrealistic expectations, make something quicker, etc. 2. If they _can't_ justify their complaints, then they're just having a little moan. Maybe you can prod some real information out of them by being polite and asking the right things, which has worked plenty of times for my benefit. 3. If they keep refusing to give constructive feedback, then ignore them. These are the rules I _try_ to follow, and when I do follow them I have a great day and usually end up with a satisfied customer. We followed these rules a lot for PyroCMS, PancakeApp, FuelPHP and a lot of FIG stuff, and turned some real haters into big fans, proponents and sometimes even evangelists. Somebody was freaking out about some trivial PancakeApp bug, but we fixed it super-quickly, and they ended up being one of our biggest source of refferals. Smiling and being nice to somebody who was being a massive dick about things equated to thousands of dollars over a few years. But, trolls are still out there. They're often just sad and bitter and twisted, or are just trying to get a rise out of you. You can't be nice to all of them. Some are just c**ts. It's hard to avoid feeding them when they're spreading patent lies about your software and potentially stopping other people from using it, but... try to stick to the three statements above and you should be ok.
In fact, if you're doing this stuff in PHP you're almost certainly just wrapping existing system calls anyway.
Honestly, and this could be my fault, but I had a hard time finding good examples and documentation on using Guzzle4. There was plenty for version 3. I should be able to find some better examples of what I was trying to do and what I couldn't find easily tomorrow.
A blog is a relatively simple application. I don't see anywhere where it says this guide was specifically written only for introductory Symfony applications.
I honestly don't see a reason not to use it. Not sure what /u/__constructor is talking about with exposing your system to the web... php and your web server don't both have to be installed. If you already know php and not bash why waste your time learning it when you need to get stuff done. Would i recommend php for this? no not at all but if you already know it and need to get something done no reason not to use it.
It was written with a blog as an example application, not specifically for making blogs. I'm in the "not for distribution" boat, and the idea of having a single bundle for everything is very enticing. What is the purpose of splitting the app up into BlogBundle, FooBundle, and BarBundle if those bundles are not likely to be used outside that one app? My current project was made using the "sharing" guidelines, because the current documentation strongly implies that it is the "Symfony Way," and while dealing with multiple discreet bundles isn't hugely problematic, it's still more trouble than its worth. The various bundles all depend on each other anyway, so it isn't as if there's some big decoupling issue. I'll probably be starting a restructuring branch in the near future, luckily my app is fairly small, so pulling it all into an AppBundle shouldn't be too hard. 
Promises in PHP. What is this magic?
I think doing stuff in PHP is fantastic. If you write tasks in PHP then it most likely is in your version control system. (vs something you setup and install into the server and then configure your cron to run). If you task is setup by a server admin, now you have lost all control over the file being run since it was installed in a special folder. You most likely are not alerted to the fact the task has succeeded or failed. To run tasks I use www.easycron.com which allows great control, it sends out alerts if a tasks fails or succeeds. Yes some of my PHP has system calls. eg $result=exec('mysqldump --all-databases ... I also like the fact, that if I need to re-deploy my code to a new machine, or server. All my tasks are in one repo. You can also use PHP pretty easily for file renaming, local image processing or what ever you can think of. I still use BASH for a lot of things, but sometimes it is a lot easier to do task in PHP (or ruby with threads, or python etc). 
If you could introduce more functional features so that I can show off to the Haskell / Erlang guy that sits 3 desks over, that would be nice. He's always on about how awesome partial application and curry is, for the longest time I thought he was discussing Indian Cuisine recipes but turns out he's just really smart. He does often say though, how much he needs "more nad". I don't know what "nad" is but maybe if PHP had "more nad" he might come around. If that's not possible, can you just make like Java Junior? Basically I'm looking for Java minus the build system and ridiculous package namespaces and horrible package managers. But I want the typing system and parameterized types and lambdas and generics and lists and hash maps and performance and method overloading. Also it needs to be 10x as fast, minimum, so that the Java guys stop giving me swirlies and stealing my lunch money. The C++ guy (there's only one of him, he's not good with people) says that PHP should also get rid of GOTO. I told him to GOTO hell. Get it? Also something about memory management, so if you could make that better too that would be good. These features aren't super important because I don't think Mortimer really gets out much and his opinions are basically shunned and dismissed by everyone in the company. We also have these JS bros that do all this Ember and Angular stuff, they say that PHP is kind of like that nerd who always wants to hang around but isn't buff enough to go to the gym with them, so if you could... I don't know, make a video of PHP shotgunning a tall boy at a frat party and then throwing a touch down at a football game and banging the prom queen that would probably help.
***SUBLIME TEXT'S KILLER FEATURES: Real-time multi-line editing AND thumbnail nav preview.*** Find the text you want to edit, CTRL+D to find the next occurrence(s) of it, or CTRL+click to select something else...and then start typing. Everything you selected will be updated in real-time, and if you press arrow keys, return, backspace, etc. that will all work as well. No more find/replace nonsense. Do it all in real-time. You will save so much time that you previously wasted doing repetitive stuff in coding you'll never want to go back to any other editor. As for the nav/preview mini-map thing on the right hand side, you'll quickly find yourself looking at the SHAPE and syntax-highlighted colors and navigating to exactly where in the file you want to go, vs. collapsing brackets or CTRL+F'ing your way around. It's amazing.
you should include an example page with photos / mock showing what the look and feel is like. i don't have a file to upload.
Doing something in PHP does not mean its exposed to the web, it's just a scripting language. If you are good at PHP and get things done with it faster, then just use that. I have written a lot of scripts in PHP (either just plain PHP files that do a specific task, or more complex group of tasks with Symfony's Console component).
I addressed that in my post. It was in parenthesis in the second point. There is no point in using PHP for any system administration task. You would have to use PHP to call outside scripts anyways, if you already know how to use them, which you would need to, to use them in PHP, then you don't need PHP for it. It's pointless abstraction. 
&gt; it just kind of feels strange to see such detail put into deciding whether any given opinion has merit or is just plain malicious. It's not really about that, if someone is truly being malicious then you don't interact with that person. But trolling isn't really malicious, it's sly and underhand, not "you're a dick head" in your face. So it's more about taking comments usually made to troll and turning it around to see what valid questions are asked, and answering them, rather than responding with anger or flames. Maybe they weren't trolling in the first place, maybe they were genuinely asking the questions you have found, when you assume they aren't trolling.
Completely not true. The password API supports single character passwords. You should be enforcing a minimum, simply for the user's sake (a 3 character password is trivially weak). But no, the underlying system works just fine with short passwords.
Also if you are actively refactoring the application you should consider pulling as much as sensible/possible out of the framework specific parts so that you aren't testing CodeIgniter PHP, you are just testing PHP.
Note thought that bcrypt has an upper length limit (72).
any chance of bringing up array-of (array typehints) rfc in php 7 ??
I would say, that 1 year is a very impressive time frame for PHP7. I Wish the internals best of luck, and thanks for coming this far.
Obviously depends on specifics, but as someone whos spent a decent time as a developer automating systems using PHP, I'm here to say you shouldn't do this. Use Ansible, Salt, Chef, or Puppet. These are the tools for the job, will be nicer to use, will also be much better for your career, and better for your company when they need to replace you. 
Discussion: [Gmane](http://news.gmane.org/find-root.php?message_id=32b8315ede38cd03ad4a7ab4497397e9%40mail.gmail.com) Zeev and Laruence seem to be trying to push through a really aggressive release schedule. While a release within a year looks impressive on paper, I think they're ending up putting the cart before the horse by trying to decide a release schedule without, as far as I can see, any real idea of what features they want to put into PHP 7. Laruence makes the point the features that miss 7.0 can go into 7.1, but this starts creating issues if those features that miss the 7.0 window are ones which cause BC issues. Personally I don't see any point in releasing a half-done 7.0 release if 7.1 then has to break BC purely because a couple of developers wanted to hit a specific, rushed release date. What the developers should be doing is drawing up a short list of features that they want to go into PHP 7, working out which ones are likely to cause compatibility issues and then working out an estimated schedule based upon that list. In my opinion a botched, rushed 7.0 release will cause more reputation damage and long term problems than one that's delayed and done right.
In the RFC it says: &gt; It's worth noting that the 3rd and 4th milestones will be quality dependent. If we have evidence that suggests that PHP 7 isn't sufficiently mature to go into the RC stage in June, or GA in October - we should of course adjust the timeline accordingly, and not push out a half-baked release. However, the goal would be to stick as much as possible to the deadline of new going-into-7.0 RFCs, and strive to follow the timelines for the 2nd and 3rd milestones as much as possible, to ensure an October 2015 release of PHP 7.0. So... erm...
Regardless of the content of the RFC, the process still seems backwards to me. Laying down time frames (and while this is an open source project rather than a company environment, estimates have a funny way of ending up as hard deadlines in my experience) before having a short list of PHP 7 targeted ideas just seems a completely broken way to decide a release schedule. What is the point of this RFC if there's no ability to stick to it once the list of items that the developers want to go into 7 is drawn up? They'll just end up having to have more RFCs for the altered timeframes which will likely end up wasting more time on pointless discussion.
Time to switch to Go. 
I'm pretty much sure 70% of the time, people use minimal components like mysqli, pdo, gd and other similar stuff. So, as long as those standard components won't have BC issues with PHP 7.0 I would say, it is good enough for me, if they take it from there.
This has to be a joke… One year.
I think Doctrine entities are something different from models. http://www.testically.org/2011/05/09/terminology-in-symfony2-and-doctrine2-record-vs-entity-vs-document-vs-model/
So do you think that 4 months isn't enough time to line up the RFCs for PHP 7.x? Because I think 4 months to come up with a list of remaining features that are needed for 7.x is plenty of time. As an outsider to the PHP core team, I'm pretty sure that the timeline will adjust itself if more features are required or if there are issues.
No, I'm saying how can you tell that the 3 months following that (or even 7 months if you include the first period, but that can really only apply to features which are already at least well into the RFC process) is enough time to properly implement the features they want to get into PHP 7 when they don't even have a shortlist of what those features might be yet.
I politely disagree. I think that setting a timeline motivates people to get on it with their rfcs and acts as a nice constraint to reference in determining what makes it in. Open ended IT projects tend to go on forever. This method is actually a military principle.
I can agree that an initial time frame to get RFCs in (or at least some initial description of the feature / change, as not all will necessarily require RFCs and some might merit a longer period of discussion) and discuss the short list would be a good idea, but I don't believe that would or should merit an RFC. What I don't think you can sensibly do is decide what the rest of the time frames should be without having that short list.
If it's going to be variable, what's the point of an RFC? Why not have an "informal" (as in, not defined in an RFC, which then requires it to be discussed for 2 weeks before a week being voted on) time frame for generating the initial short list, THEN define the remaining time frames (and if it is felt really necessary, spend 2 weeks discussing and another week voting on an RFC for that). This entire RFC is a pointless waste of time. The time would be far better spent discussing and drawing up the short list.
From their recent attitude, I'm not sure it's "move fast and break things", but it seems to me to be "move fast and as long as Zeev and Laruence's changes get in, who gives a damn about anything else"
In a conventional, compiled environment that may be true, but in PHP truly exceptional conditions already have their corresponding E_FATAL error triggers. You can't prevent a PHP script from terminating when it runs out of memory, so throwing an exception in that kind of situation is ultimately pointless. And while you can abuse exceptions just like any other facet of programming, there's nothing at all wrong with utilizing exceptions to report failure conditions that are recoverable.
don't forget to create the branch in the official repo. But I hope that you can't do it!
Those of you doubting the wisdom of pushing for an aggressove release schedule for 7.0 are forgetting how massively, heavily used PHP 5.0 was. Oh wait, it wasn't. 5.0 was basically a beta release for 5.1 and as it turns out, that worked out just fine. 7.0 will launch in a year with issues. Maybe a few issues, maybe a lot of issues. The bulk of adopters will spend the following year catching up to 5.6 while the early adopters will find out what's wrong with 7.0. We'll use those early adopters experience to build a better 7.1. And in three years 7.0 will be relegated to the same footnote as 5.0.
Well, I think the situation is slightly different. 5.0 broke a fair bit of BC, where as 7.0 isn't setting out to be nearly as severe. So 5.0 took quite a while to adopt as you needed hosts to support it, and libraries/applications/frameworks to support it. But 7.0 could be a lot easier. And if it is legitimately easier, it could drive adoption significantly faster than 5.0's was. I'm not saying it won't be the same, but I don't think the fundamental reasons for it would be... From a stability standpoint perhaps...
Sorry if this comes across as being purely comical - I'm not sure if this has been accepted by many as wisdom - but using x.0.0 releases is a pretty optimistic way to operate because there will _always_ be issues in new major versions. PHP 5.0, Android 4.0, Windows 8.0... etc ;) That being said, the PHP core team has improved a lot since PHP 5, IMHO.
I think you're gonna need to be more precise than that https://packagist.org/search/?q=statistics Or do you mean this? http://php.net/manual/en/book.stats.php
&gt; If you already know PHP and not bash why waste your time learning it when you need to get stuff done. What about Java? If I know Java, should I write all my system admin stuff in Java? Or Cobol? I know Cobol pretty well, also Basic and Pascal. I don't think that knowing PHP is a valid reason to ignore all of the other existing solutions out there for doing system administration, don't pigeon-hole yourself into a "PHP Developer" role. There's no reason to avoid learning something new. I am a little shocked that the general consensus in this thread seems to be "Sure! Use PHP!". I generally find the "right tool for the job" arguments a little pedantic but in this case I think it's fairly objective to say that PHP is the wrong tool for general *system administration tasks*.\* The other valid option is to simply accept that system administration is not your field of expertise and try to find a sysadmin mentor who can help you learn the generally accepted standard methods of doing things. Shell scripts are really, *really* not difficult to learn. Defaulting to PHP in this scenario is at best laziness and at worst negligent. Need to check disk space? - PHP! Need to monitor a process? - PHP! Need to provision a new server? - PHP! Need to install a package or change system configuration? - PHP! Need to iterate over a file system and find some big files? - PHP! Need to copy files from one place to another? - PHP! Need to backup a system? - PHP! In none of those scenarios is PHP a good answer. There isn't a sysadmin in the world who would advocate using PHP to accomplish any of those tasks. \* There are always exceptions for specific purposes but the question posted here seems to be more about general system administration.
Yes, your 2nd link http://php.net/manual/en/book.stats.php 
Except for the fact that it implicitly makes the project follow a waterfall model, which we know sucks
Yeah, not really sure how to handle the whole private package issue. I'm definitely open to suggestions but since it's a service on a public site, it couldn't do it on its own. I'd thought about showing how to set up a callback with GH or something to an endpoint so it could notify PT of the new release but I'm not 100% how all that works.
No one is proposing a Gantt chart with rigidity. Agile does follow a roadmap you know. We have a good idea about what needs to be done at a high level to remove the cruft that holds php back from becoming a great language. Address those things formally and then by all means go forward with incremental improvement on a sound foundation.
/end thread
Filled out the form, but the questions in the form are different from the premise here in your post: &gt; Essentially, what skills/characteristics make a good PHP developer good? You're implying here that being literate and being "good" are one in the same, which may be true for some, but not for me. I kept the scope of literacy narrow in my responses, and did not get into what I consider makes a developer "good". That scope is much larger and broader than functional literacy.
Missed your comment in parenthesis, my bad. My thinking was more inline with /u/manueljs, but /u/codenamegary makes some valid points above. When I was writing my comment, I was thinking of different kinds of tasks (moving a bunch of files, preparing for deployment, etc).
I don't have the bandwidth to try anything RFCish for a little while, just started a new job. krakjoe would know more, but the idea last time was to try again with Hack's generics syntax, but hold off adding actual generics until some later version. Full generics could be a 7.1 for example - if wanted.
Is there really a point to decoupling controllers? I was under the impression that controller are pretty heavily tied to your framework, and that all the decoupling should happen from services that your controllers use.
Moving a bunch of files is just as easily handled by coreutils. Of course if it's actually part of a ration script (like preparing for deployment) that's one thing. For general systems administration it's pretty pointless.
Yeah, that's not an excuse to use bad practices anyway. http://phptherightway.com will help you
It's not just security. It's pretty much everything. You're not using includes, so you have the database details in there twice... terrible idea. You're using mysql_ extension, which has been deprecated for years. Your code is a big block of mess, no separation of concerns. //grab another row. If we don't do this we'll get //stuck in an infinite loop and the page wont load. No you won't, this is completely wrong. Actually, no, it's not completely wrong, it's just not the way **anyone** does this. while ($row = mysql_fetch_array($result)) { That's more standard and far more readable. That said, you should actually be using mysql_fetch_assoc as it returns a much smaller array, and **that** said you should actually be using PDO. Finally, security. It's not enough to say "Oh, don't use this. There's no security." Put the security in it, or **do not write it**, even as a teaching example. Security is not optional. Everything about this code reads as someone who literally does not know what they're doing. I certainly don't think you're qualified to be teaching in this field. 
It's using **worst** practices. That's not good. Teach things properly, or don't teach them at all.
I guess I should have expected this from this sub. I'll delete this post soon but I wanted to tackle your points. &gt;You're not using includes, so you have the database details in there twice... terrible idea. Abstracting away code into a separate file is obviously the right way to do it, but for somebody who is trying to understand code from scratch, it's confusing and over complicating things. Why hide what's going on when it's not necessary? Includes are a whole other topic. &gt;You're using mysql_ extension, which has been deprecated for years. Yep, but again, it's WAY easier for a first timer to get their heads around. &gt; Your code is a big block of mess, no separation of concerns. True, feel free to suggest a better layout that explains things better. I'd love to accept pull requests to make it a better resource. &gt; No you won't, this is completely wrong. Actually, no, it's not completely wrong, it's just not the way anyone does this. Yes, I will and I've seen it done plenty of times. Also, it matches patterns that new students see quite often where you do something in a while loop and set yourself up for the next loop at the end. &gt;and that said you should actually be using PDO. Yeah, if this were a real application I would. &gt;Finally, security. It's not enough to say "Oh, don't use this. There's no security." Put the security in it, or do not write it, even as a teaching example. Security is not optional. Have you ever taught people anything? Seriously? If we brought security into things it would become far too difficult for a new student. &gt;Everything about this code reads as someone who literally does not know what they're doing. I certainly don't think you're qualified to be teaching in this field. That just seems like a personal jab. Thanks. 
5.1 was just fine, and 7.1 will be great. Just like surround sound.
http://symfony.com/doc/current/cookbook/controller/service.html
I see RFC and read Rugy Football Club. Being a dev who plays rugby can be so confusing.
damn. monstrous balls and shitty attention to detail
I'll be there
What the hell did he think he would do if he got offered the job?! P.s. Could you send me the test you gave him? I need a coding challenge. 
Someone's butthurt.
This sort of thing definitely doesn't help your membership request :/
Anthony references that talk here: http://blog.ircmaxell.com/2014/10/fud-and-flames-and-trolls-oh-my.html
I'd love to accept some of your points but your belittling and downright offensive attitude towards this is ridiculous. 
I was actually referring to Kaylas application. That is the thread Phil and Paul were quarreling in. It has 0 to do with my application. Sheesh, its like none can't take a joke. And I actually had to install a genesis emulator to get proper screenshot.
Sure, it was super simple: **Objectives (hidden from candidate, kept vague on pupose)**: * evaluate knowledge of dependency injection and coding to an interface * evaluate understanding of basic REST * evaluate code-quality * look for bonuses (composer usage, framework usage, any other libraries/time-saving tools) * evaluate attention to detail when documenting **Challenge** &gt; Write a simple API for showing a list of users, and creating a new user. The goal is to be able to swap out the data source for users without having to touch any of the code that uses the data source and returns the response. Provide documentation for consuming the API. Note that a client application that consumes the API is not necessary, this is only meant to test the building of the API itself to see how they would structure it. EDIT: added documentation request.
Seriously? Down-vote. Not cool dude, this stuff only makes the drama worse.
That's why I did that after the drama. Didn't expect this kind of response ((
http://devdocs.io
I can't for the life of me lie to appear more knowledgeable than I am. Infact, I always start by saying I am noob, and I would be willing to work for free as an intern. Some people bear a lifelong lesson, and eventual pain when told to do a simple things which they have no clue of. I can't deal with that shit.
I didn't expect people to have this response ((
Dude, you need to start listening to what people are saying to you. You seem to care a lot about PHP, which is cool. But you keep getting yourself in hot water. Consider how people might feel/react before saying something. I know this is just a fun joke, but it's inappropriately timed, and coming from the wrong person. If you keep getting the wrong response to your actions, try acting differently.
I see absolutely no reason to do this. Use the right tool for the job.
fantastic!
Whats this? $i=0; do { $this-&gt;_mysqli = new mysqli($host, $username, $password, $db); if (mysqli_connect_error()) { if (in_array(mysqli_connect_errno(), array(2002, 1049))) sleep(1); else { trigger_error('Error connecting to MySQL : ' . mysqli_connect_errno() . ' ' . mysqli_connect_error(), E_USER_ERROR); $i = 31; } } $i++; } while (in_array(mysqli_connect_errno(), array(2002, 1049)) &amp;&amp; $i&lt;30); - https://github.com/c-darwin/dcoin/blob/master/includes/MySQLidb.php#L24 Whats array(2002, 1049)? And is there no break statement in PHP ?
&gt; To date, No Hack or Exploit has been discovered because nobody uses it?
The difference between being literate and good is a great point, so thank you for pointing that out. Actually, people's different definitions of literacy are probably the most interesting part of the results I've gotten so far. While there's been some overlap, like understanding of syntax and basic ability to achieve a result, most of them are fairly unique. I'll try to share the results within a day or two.
Yeah I would even say: let's go fast so that the other devs don't get to put too many new fancy features.
If someone made a YouTube video going through how to do this. I'd watch it.
You also might check out PHP beyond the web by /u/RobAley 
Even the most experienced programmers have routine experiences of feeling like they are in uncharted waters and lacking certainty. A programmer should have a baseline of experience doing things, but the core talent is really knowing how to learn what is needed along the way to get things done. This stuff changes too fast for anyone to not feel unsure.
If I was the candidate, and I used Slim framework, would I pass or fail? Just asking as I can't imagine ever needing to write an api without a framework.
Off the top of my head * What do you use for version control? * What is your development practice (Agile, waterfall, whatever)? * Is there a coding standard and how heavily is it enforced? * What version of PHP are you using in production and/or what is your full stack (AWS? CentOS? Some laptop in a closet?) * Is the company involved in the local development community? * What is your deployment process? (Continuous integration? Have a jenkins machine? Print out the code and mail it?) * What is the typical workflow of a ticket from start to finish?
http://www.bbc.com/news/technology-21043693
Which framework you use is not a consideration here, that's totally up to you. Slim would be fine, Klein, plain old php, it doesn't really matter. The goal here is that you use some semblance of dependency injection with contracts to allow hot-swapping of data sources without touching the controllers or closures or endpoint handlers or whatever you end up doing. Using a light-weight tool like Slim would be considered a bonus though, as it shows you're willing to work with other people's code, know HOW to work with it, and can select an appropriate tool. But really, the thing under test here is that the data source be injected from the outside and typehinted to an interface so that I could inject a Redis data source, or a MySQL data source, or a CSV data source etc, and they all "just work".
Make a users table Use framework with scaffolding and rest functionality to auto gen crud code Done. 5 minutes of work. Framework most likely allows for DI around the data access. Ninja Edit: also docblock that shit
For fun, since I'm currently hiring a six man team. &gt;What do you use for version control? Github. &gt;What is your development practice (Agile, waterfall, whatever)? Until you have a launched product, you are de facto in a waterfall process. That said, we organize our project into sprints, we use daily standups, and we will be transitioning to an iterative, more agile process once the initial product is launched. &gt;Is there a coding standard and how heavily is it enforced? If you mean coding style guide, we adhere to PSR-2 (by my personal edict) &gt;What version of PHP are you using in production and/or what is your full stack (AWS? CentOS? Some laptop in a closet?) We will almost certainly be using HHVM LTS in production to enable the use of Hack where appropriate, but I tell my devs to work against PHP 5.5 for now. We also have a weekly 1 hour discussion about 'cool programming conversation' where I often talk about recent RFC's. The stack is somewhat complicated, but employs React on top of AWS. &gt;Is the company involved in the local development community? Yes, we have more than one local meetup we attend every month. &gt;What is your deployment process? (Continuous integration? Have a jenkins machine? Print out the code and mail it?) That's handled by our QA team and Infrastructure team after handoff from my team, but it uses actual deployment processes and heavily utilizes the ability to spin up and spin down AMIs seamlessly. &gt;What is the typical workflow of a ticket from start to finish? http://i.imgur.com/Q2V2IzB.jpg At the bottom you see our sprint schedule (rough). We use one week sprints that wrap up and kick off on wednesdays.
Never work for free
It's really useful, but it's also one of my favorite interview questions, because Objects are the only thing in PHP that are always passed by reference. function myFunc($obj) { $obj-&gt;test = "hello"; } $a = new StdClass(); myFunc($a); echo $a-&gt;test; What is the output of the above code? Then I follow it up with this: function myFunc($arr) { $arr['test'] = "hello"; } $a = array(); myFunc($a); echo $a['test']; What is the output of *that* code? I place them side-by-side, so that they answer both at the same time. It's one of the best interview questions I've ever asked. EDIT: If they are a VERY qualified candidate, I'll ask them to reverse the outputs without changing the content of the functions. EDIT2: BTW, the answer to the follow up is to change line 5 of the first example to `myFunc(clone $a);` and line 1 of the second example to `function myFunc(&amp;$arr) {`
Feels like SVN
Shit, you beat me!
5 minutes was probably too soon, but the requirements did not call for a client app. Using mamp or wamp to install Apache/mysql takes maybe 5 mins. Using composer to install a framework takes maybe 10-15 mins Creating a table takes 5 mins Auto gen code takes 5 mins. You are right - double the estimate just in case surprises happen and you are close to an hour. Solid estimating my good man/woman!
There is no excuse to advocate using MSWord, especially for an open-source programmer. You could have simply done a follow up with him and quized him about the code.
An in-house framework I used to use had database objects where every magic method call was a database lookup for that called string as a field.
&gt; Why would it be installed in a special folder unless you asked for it? Why wouldn't you be alerted to the output of the cron unless you asked not to be? EG. Simple Task. Lets backup mysql. (place task in /etc/cron.daily) cd /etc/cron.daily/; curl -O https://raw.github.com/gist/1670895/backup_mysql.sh chmod +x backup_mysql.sh files are output to /var/archives/mysql/ My solution. Hit the backup URL on my server from the correct IP (setup via EasyCron a web based cron service). This calls a PHP file that calls bash to do a mysqldump. File is then named and uploaded into dropbox. Now my backup files are NOT on the server should the machine die and sys-admin backups have failed (especially when clients are paying $$$ for the data). I can re-deploy pretty quickly if all hell backs loose. Just be clear. My solution is for a web application that I deploy onto a VM, nothing else is on this machine, other than my SAAS product. All my PHP code is in GIT and I deploy to the server via git. This means I can put system admin tasks in GIT written in PHP. Viola. Now everything lives in my repo, I can copy this to my dev machine, laptop and or server and I have a full-working testable deploy system (especially since I develop on mac deploy to linux) Yes maybe this is cheating, but I feel I am totally in-control when I see all my DBs sync into dropbox and I get the email saying success! (just got my email now and dropbox updated 8 mins ago, sweet, I know my backup has completed and I now have a versioned copy on my local machine (being backed up by time-machine). 
I like your approach and I'll help you refine your answers because you'd probably make me hesitant with how some are worded. You use git for version control and github as a hosting service. It might be a bit pedantic, but that's the kind of specifics we deal with daily in code. You could take your repository and move to your own gitolite or gitosis system if you wanted to down the road without losing anything and it's still using git. You're never de facto in a waterfall process. The waterfall model is a very specific process where all requirements are specified and finalized before anything else is done. Then everything is designed, reviewed, and finalized before writing any code. Then you write the implementation code. Then you test. Then you install. Then you maintain. It's an extremely rigid linear process where each step is required to be completely finished before the next begins. It is commonly used as an example of what not to do because you can't make adjustments downstream. If you are doing sprints, then at the end of each sprint is your product and you actually launching it isn't relevant to the process. A coding standard isn't just a style guide, but an entire system of conventions that may include a style guide like PSR-2. Standards may include restrictions like the Jet Propulsion Laboratory's requirement that no loop exceed 10 cycles and must hard coded that way. Others might even restrict file size, cyclomatic complexity, or naming conventions (camelCase, under_scored, szHungarianNotation). As part of your own standard, you could say you abide by the PSRs, but you'd still need to specify if you use PSR-0 or PSR-4 as part of your standard. Don't try to force a "cool" factor per se in your discussions about RFCs because it can give the wrong impression. It sounds like you're just wanting to discuss the changes coming for your environment, but it can easily be interpreted as contrived without enough context. Regardless of the complexity of your stack, please make sure it's documented for those joining you even though it's not worth detailing it here. Even if your QA team is the one responsible for deploying, your team's specific deployment is in handing off your product to them. Since your team isn't responsible for it, then you could actually treat it as a black box, but you still need to convey what happens in a macroscopic sense so your team can troubleshoot something in production if required. Again, I like your answers and what I wrote is pedantic and probably already known to you.
You just helped me figure out a major mental block in my life lately. Thank you. 
Ha, no that's fair. Since I wasn't even specifically asked, I wasn't going to be that precise with my answers, but I agree with and understand your points mostly. The only point I'd actually discuss further is the waterfall/agile discussion. Yes, waterfall is a specific process, as is agile. But they have characterizing features that lend themselves to a style of development and process. Agile is characterized as iterative and continuous. Waterfall is characterized as defined and release-based. Without a launched product, iteration is entirely internal. While we employ an agile process in our development and management cycles, there are aspects of agile that we won't implement until we have an initial release, and in some ways you can characterize that stage as being a waterfall *process* that is managed using agile *organization*. Agile is impossible to employ completely for us because we have component A that *must* be finished first, and component B that *must* be finished second. *After* those two components are finished, the entire rest of the application is agile and iterative, but those two are essentially the framework everything else exists within. And after an initial version of those two components is finished, they can both be iterated on as well.
If you're a developer and don't already have a stack setup, I would say you're not that into developing. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Impostor syndrome**](https://en.wikipedia.org/wiki/Impostor%20syndrome): [](#sfw) --- &gt;The __impostor syndrome__ (also spelled __imposter syndrome__), sometimes called __impostor phenomenon__ or __fraud syndrome__, is a psychological phenomenon in which people are unable to [internalize](https://en.wikipedia.org/wiki/Internalize) their accomplishments. Despite external evidence of their competence, those with the syndrome remain convinced that they are frauds and do not deserve the success they have achieved. Proof of success is dismissed as luck, timing, or as a result of deceiving others into thinking they are more [intelligent](https://en.wikipedia.org/wiki/Intelligent) and competent than they believe themselves to be. &gt; --- ^Interesting: [^Dunning–Kruger ^effect](https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect) ^| [^List ^of ^impostors](https://en.wikipedia.org/wiki/List_of_impostors) ^| [^Elizabeth ^Harrin](https://en.wikipedia.org/wiki/Elizabeth_Harrin) ^| [^Capgras ^delusion](https://en.wikipedia.org/wiki/Capgras_delusion) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cl9p7du) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cl9p7du)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I like it! Kinda like Laravel lite and I mean that in a good way. Starred.
Maybe you set up a vm from scratch?
Is your PDO connection pointed at localhost or 127.0.0.1? Possible weird DNS thing?
Among doing other things this vim plugin adds the php.net man pages in to vim https://github.com/spf13/PIV Hit shift+k when your cursor is on a function to see doc. Edit: I just reread your post about not liking existing vim plugins. I hope this wasn't it lol
Soooo you're hiring, eh? Want to pm me a link to apply? :)
their unit testing class is pretty lousy. I strongly recommend using CIUnit. You get all of the good stuff related to PHPUnit. 
Here is my presentation from AZPHP which shows how to get Selenium off the ground. http://www.slideshare.net/abfan1127/azphp-phpunitjenkins
man that is so weird. i heard about laravel for the very first time at work today.
it looks like someone who was attacked by floating point math errors...
YES.
&gt; Using composer to install a framework takes maybe 10-15 mins Hahahaha, so true. &gt; Updating dependencies. The bane of every PHP developer. I love you most of the time composer, but every now and then...
We did the same. Let someone do half the test at home and the other half in house. Take home is pretty much Wikipedia+stack overflow, in house is almost completely wrong. 
I would just use laravel and simply installed and wrap [this](https://cartalyst.com/manual/sentinel). Maybe even throw in a few unit tests...
&gt; Yes, waterfall is a specific process, as is agile. Just to layer on more pedantic - agile is not a "process". There are many process models which are considered "agile", but agile is a state of being, or a philosophy. Since you are organised into sprints and so forth (and specifically used that term) I would assume you are doing Scrum from an organisational process point of view... (sorry, I'll take my pedantic agile coach hat off now).... 
&gt;Some people have monstrous balls. Or a lack of common decency and common sense. What was that person expecting? I mean, a week from his first day, where did he see himself? "Herp dee durr i'm jus wingin' it!"?
Suddenly it occurs to me that one could probably outsource 100% of their work for like 20% of their income, and maybe 40% of their time (20 managing the outsources project, 20% reading / understanding / fixing submitted code) if the work were not done on site, or under particular scrutiny. Heck, the experience might qualify you jump into a management position for the next job. I wish I had read this post years ago.
&gt; I'm sure there were reasons (although I can't think of any) Allowing Guzzle 3.X and Guzzle 4.X to be installed at the same time. Meaning huge libraries like the [AWS PHP SDK](https://github.com/aws/aws-sdk-php/blob/8670f75a5b73dca8883a7faf18b2f81d144863bc/composer.json#L20) can keep using Guzzle 3.X while the project using the library can use the goodness of Guzzle 4 or 5 for their own HTTP needs.
(Dash)[http://kapeli.com/dash] (Mac only) is terrific. Loads fast, keyboard shortcut to popup the window. Has a lot of docs, including PHP, but also most other languages and even frameworks/libraries/CMSes too.
I'm curious, is this a senior level position? What salary range are you offering? 
Which would also have been out-sourced to India :P
sorry, i meant to say reconsider/implement RFCs that implement new features and break BC at the same time. optional return type declarations, optional scalar type hints, multiple return values -- if I remember there were several RFCs trying to work these in. would be nice to have them.
First thing you need to do is ask what *kind* of work they do. I interviewed for a PHP position and ended up being a Wordpress/Drupal/Magento/Joomla jockey. A well-paid jockey, but a jockey nonetheless. I have to fight hard to work with actual PHP, and now and again what I call a "free form" project opens up, which is cool. So that alone should pretty much answer your question about using modern PHP and good coding practices. Are you building PHP *applications* or brochureware? The former requires modern PHP and good coding practices to do well, the latter is likely approached more loosely by the company. Of course, ask all the direct questions like "do you use Composer? write unit tests? do code reviews? reserve time for refactoring?" and if their responses aren't very clear and straight-forward, they likely don't. Another thing you should be doing before an interview anyway, is looking through the company's portfolio (if they have one). Run the more recent client websites through http://buildwith.com to see what technology they're pushing out the door. If they are NOT a client agency, then you're probably off to a good start, but still ask those direct questions.
You'll probably hear about it quite a lot. :)
I have built a complete solution that lives in one code repository. GIT. It manages scheduled emails, scheduled backups, and other scheduled tasks all written in PHP using webcron. There is no need for me to create shell scripts that live in /etc/cron.daily that I would have to SSH into my server, find the files, modify them test them. It would be a pain for me to configure these scripts to talk to my application database outside my PHP application. I can edit modify any task in sublime by simply hitting command+t and going to this file. It's all there. It even leverages common configuration files like DB passwords and email logging. Fantastic. So pretty much anything shell can do, I can write it in PHP and keep it all in one language. These includes pushing my backup files into dropbox with 2 lines of code. Beautiful. My deploy script is shell. And I do heaps of shell scripting, love it. But I think keeping everything "together" makes a lot more sense. Including all my testing frameworks &amp; scripts. 
I tried using an outsourcer for some flash stuff once. They attempted to bill me to buy flash. I lost some faith in them at that point.
&gt; Make a users table create a migration
That's a Senior Dev position, right?
Sure, I sent you a PM with the necessary details.
Run. 
But this is my first job, and I've only been there a week. I'm worried about how that will look to other employers. I also don't want to be unemployed. 
Without a dotfiles-of-vm or using a service to generate the provisioning scripts; I would say you're not that into VM.
Symfony2 was unable to deliver? I'd be curious as to why. Or even what slim couldn't do for you.
Our architecture completely separates the client from the server (fairly common now) because we have genuine javascript *engineers*, which allows us to do some great stuff on the client. Obviously, this necessitates an API of some kind. So why not Slim? Well, our application has many, many parts. But here were the list of requirements that the API had to meet: 1. It must be built in WebSockets (and have optional REST fallback for individual requests). 2. It must know the current state of all clients and be able to push content to clients based on their state. 3. The API must be completely separated from the application code itself. 4. The application code must be separated into services (User Service, DB Service, Location Service, etc.) which are not interdependent on each other. 5. Each service must be able to run independently on its own server/environment. 6. Each service and the API must all be able to scale independently. I am very experienced with Symfony, and have a fair bit of experience with Slim. But these requirements (and they may sound crazy but with our application they make total sense) made me feel like both would get in the way more than they would help, particularly because we are not serving the application as a single stack/application, but instead invisibly in pieces. EDIT: We're planning/hoping to release our framework as an Open Source Project within the next year anyway, since there aren't really any open source projects that tackled our needs.
Well my first suggestions would be to 1) back it up 2) understand how it works 3) develop a process to work with it in its current state. 4) continue working on what is requested. 5) build list of features that need improvement 6) figure out how to improve a feature as a full rewrite or an upgrade to make it more functional. 7) Propose these ideas to your boss and explain how the new code vs the old code is better. 8) scheduled a monthly code review / update process to keep the working code in good shape and adjusted for any new updates to the site. 9) keep backups 
Do some research on current frameworks. You'll want something with an LTS or paid support available since this is a real project that needs to be ready for the long haul as other programmers join the team and you stretch it to its limits. To get started is the hardest part. Go in small steps. Work around the current database structure and application (abstract their crappy db structure so you can deal with it later). Begin by implementing one or two pages / URLs / methods / end-points a day. Once you have a process for implementing new features and replacing old features, document it and inform everyone else involved on the project that this is how future updates need to be done. When you look at the two options of recoding the whole thing or doing it this way.. The resolution will be complete by the same time either way. With piece by piece integration at least you are immediately phasing out bad code in favor of good code and spending some of your time working with good code. If you are comfortable with a modern framework and PHP best practices then you are likely capable of whatever you want to do. The question would be: do you want to do it. It would certainly hone your skills very quickly.
b+c :) I've had a similar experience, a total rewrite is a lot of work but if your company wants to survive it's totally necessary, in other way it will end badly Also, start a new site from scratch would be a good experience for you :) just use something modern like zend/symfony/aura/laravel, and write unit tests :)
This is very reasonable advice. #2 is the trickiest part since the code/database is such a scattered mess. But I think if I could maintain focus on #2 the rest of those steps will fall into place. Thank you.
Ok step 1. Don't stress, the company have got you in to do exactly this job, from a business point of view they've done the correct thing in realising there's a problem and that they need an in-house specialist to help them move forward. Step 2, don't fall into the trap of wanting to rewrite everything from scratch, and don't think that the quality of a codebase necessarily is important when trying to meet business objectives, the job of this app is to make money for the company as efficiently as possible. So one good idea is to spend half a day planning your strategy, what are the risks, how much is the business currently spending on different aspects of the site and how can that be improved. Which areas have security risks, which cost a lot because they continually have to be outsourced. When you do this don't use code quality when trying to get buy-in from management because while it matters to us, it doesn't matter to a business. Then try and split up the overall site into lots of small services, don't think of it as a massive website that does everything, try and split into very small component apps. For example and app that sends emails to customers after an order, an app that processes online payments, an app that sits in front of the store and handles the routing. Now you don't have a big massive mess to sort out, you have 20 small apps or services that can be tackled one at a time and you can focus on which one will make the most difference to the company first. Getting back on topic to PHP one thing that is really good for doing this kind of job is [Stack PHP](http://stackphp.com/) you can use the url map to mount separate self contained apps on each URL, then you can leave the other urls to carry on to the existing site.
 &gt;You are right - double the estimate just in case surprises happen and you are close to an hour. Solid estimating my good man/woman! I've personally found that multiplying how long a software related task should take by four gives good estimates. Hardware tasks only need to be doubled, since you're far less likely to discover massive underlying issues with hardware.
Phil, every time I read something you write here it seems to be mountains of awesome.
How about the Joel Test - http://www.joelonsoftware.com/articles/fog0000000043.html
Yes, my first instinct was to rewrite from scratch. You advice gives me some perspective. I guess from the business's POV they have a website that makes them money, and they want it to continue to make money. I'm going to start researching Stack PHP because breaking the mess into smaller apps seems manageable. 
&gt;there's nothing at all wrong with utilizing exceptions to report failure conditions that are recoverable. I didn't say you shouldn't do that. The whole point of exceptions is that you can recover from them. But they should be used for exceptional conditions. An unexpected error, such as an error loading a file, is exceptional. A key not being in an associative array is not an exceptional situation, it's a perfectly normal one. 
Complete rewrites from scratch are *never* the answer, no matter how tempting. You might *think* that multiple refactors are going to take longer, but you're completely forgetting to account for all the things that you don't know yet, especially about the obscure, bizarre business rules that the current code incorporates and that *everyone* has forgotten about. Personal experience here, though my inherited codebase isn't as bad as yours. At least my predecessors were just clueless, not *outsourced* and clueless. You need an attack plan, and it starts with being able to test old behavior and new behavior. If you don't already have a dev clone of the live environment, it's time to create one. Import the live environment every night. Don't rely *just* on a dev-only limited set of data. If you aren't able to work with a copy of the real data, that might mean you have to do testing on live, and that is bad. As a side effect, this nightly clone of live can also serve as a fine test of the nightly backups that are surely running. I mean, you have nightly backups of the database, right? *Right*? Next, look into various tools, like Selenium, that let you automate a browser. You can use this automated browser to poke and prod at the application in a repeatable way with expected results that you can test. This is going to be a more realistic approach to testing applications that weren't designed with actual *unit* testing in mind. **You're going to need to tackle it by going one page, one area of the site, one little corner of the universe at a time.** Little bites. Don't tear off more than you can chew. I can not overemphasize how important this is. Start by splitting out display logic from everything else. Use a template system here. If it's already using a template system, pick a *different* one. Twig is popular around here. This is a simple change that will have immediately browser-testable results. Next, if you haven't done it already, you need to crank `error_reporting` all the way up to `-1`. If the code is as horrible as you've described, you're going to get inundated with undefined array index and undefined variable notices. Fix as many as you can, and do it *now*. There are going to be horrible hidden bugs unveiled at this step, and you need to squish them while you can. While you're doing this, you need to make sure that the comments you're adding try to explain *why* the code operates how it does. This is the most important thing you can possibly leave for future developers. Now tackle the problem opposite of the templates: split out all of the database manipulation. Switch to PDO, as I have no doubt that a shitty codebase wouldn't already be using it. If you want to feel fancy, use Doctrine DBAL or another SQL builder (ZF has one, right?) instead. Don't use an ORM yet. Hell, don't even create entities yet, just segment out and segregate the database bits. Use global functions if you have to, just get the queries out of the rest of the logic This one will be harder to completely test using just a browser. So, now you have a template, some data access functions, and some spaghetti. It's time to reorganize the spaghetti. Try to separate out the things that deal with the request and response from the actual real business logic of the page, even if you have to do it just by drawing some ASCII art in comments. Congrats, you've almost achieved [separation of concerns](http://en.wikipedia.org/wiki/Separation_of_concerns), a central requirement for writing sane code. No framework or TLAs required. Repeat this same process for the entire rest of the site. Again, one page at a time, one area of responsibility at a time. **This is going to take a long, long time**, and to everyone outside of you and the people you work with, it's going to look like nothing is changing. Leave it to your bosses to figure out how to fight that perception problem. Eventually you'll reach a point where you've touched every page. You have a collection of templates, a whole bunch of shitty-ass logic (shitty ass-logic?), and a pile of database horrors. Make no mistake, the code is still going to be horrible in general, but it should now be *organized* horrible. Your next step is going to be fixing the database. No doubt, it's some horrible unnormalized abomination. Normalize it. Once normalized, you can probably sanely work with almost any database automation tool, like an ORM. Use these tools to help you build entities that represent records in your database. You don't *have* to use an ORM if you don't want to. Not all of your tables are going to translate well into entities. It's fine to only tackle tables that make sense as entities and leave the rest as manual poking and prodding. Now that you have your entities, it's time to begin collecting the code that twiddles those entities together. You'll find most of this logic in the spaghetti you shuffled around earlier, but no doubt some has leaked into the earlier database access functions. There was probably a lot of repeated code, right? You might have even already centralized it. That's good. Glob together related actions that modify entities into classes. You *don't* have to put all of the actions that touch one entity together in one class, and you *don't* have to keep it one class per entity. You *don't need to* put most of that logic in the same class as the entity either. Obey the [single responsibility principle](http://en.wikipedia.org/wiki/Single_responsibility_principle) Remember, your code is already shit, and it's fine to make an improvement that is still crappy as long as it's still an improvement. If you thought that doing primitive separation of concerns was slow, you haven't seen anything until you've finished splitting out your database entities and their related logic. Introduce testing here. Each of the methods that CRUDs an entity needs to be tested, multiple times, in multiple ways, triggering every possible failure. Don't bother mocking anything at this stage in the game. Just run it against your dev-copied-from-live database. You might need to restore the database after testing, or even during testing, but that's fine. As long as you have something that checks every bit of that logic and tells you when things change unexpectedly, you're better off than you were. Now, and *only* now, is when you want to look at introducing components from an "MVC" framework. You have primitive templates, basic controllers, and a layered model already. You'd probably be best off just wrapping your existing "controllers" in whatever request/response setup that the framework prefers, if you go that route. Add more testing here, at the controller level. By now you should have a healthy hatred for all of the work you've done, and you'll naturally want to throw it out. That's fine. It's even expected. **Refactoring a horrible codebase never ends.** Also, &gt; a professional framework like Zend, Yii or Cake Only one of those is "professional." If you must insist on using a framework, pick frameworks that are highly modular and are unopinionated. Trying to use a highly-integrated, opinionated framework with an existing codebase is a recipe for disaster. A framework with code generation is also a recipe for disaster. 
Kinda off topic, kinda not: Would actual contributions to lesser known projects benefit a resume in any way, other than personal experience in a multi-dev environment? I was looking into contributing too, and while it was originally selfless, adding a line to my resume wouldn't be the worst use of my time. 
There are no "defining" features. I consider it a PHP version of Flask (the Python framework), or a Silex with autowiring and less coupling to Symfony. I've taken ideas from various frameworks and combined them while keeping it as lightweight as possible, using third-party libraries and standards wherever applicable rather than writing my own way of doing things. I don't want the framework to interfere with anything beyond the routing and templating layer, so you're free to use whatever database, cache, authentication, mailer, queue, translation, and so on implementations you like without having to do dirty hacks or deviate from framework standards. There is a more or less complete list of features and design goals here: https://github.com/autarky/framework/wiki
Unless you're listed as a member of the project's "team" somehow, probably not.
Wow, thanks for the detail! Sounds like a lot of fun. &gt;It must be built in WebSockets Well there goes PHP right off the bat. Edit, did you go with a JS framework? If so, which one? I've been poking around angular and really like it for testability, but not used it to build anything yet.
It doesn't have a very good pull request/issue process, though, so contributing to it is not necessarily as fun.
Symfony is the best organized in my opinion - they label "easy" issues that you can try and fix, and Symfony + its components are extremely widely used in modern PHP projects. Other than that, I find it impossible to contribute to projects I don't actually use, so I'd recommend just looking at whatever libraries/frameworks you use.
If a company is profitable then a rewrite is possible. If a company is losing money it isn't at all. I have been a part of two rewrites. Both took a very long time. The first was because we had 40k lines of uncommented code which did weird stuff with xml. No one knew how it worked... Development was so slow because everything was procedural and fixing text on page a would somehow break text of page x... Different company. The second rewrite was because we out scaled our existing system. Took 8 developers 6 months to rewrite this because of the number of insane forgotten about business logic.. Everything is great now though. 4 million users and the service is scaling well. I would take my concerns to management. This is what I did with the first rewrite. I explained the situation. Explained why things sucked and why development was so slow. If a company can afford a rewrite it may be worth it but you need to make sure you are the right person to do it.. You don't want to leave the company with a whole set of similar but different problems. A rewrite halts current development and enhancement for a long time which is damaging to a business. It takes a while for the new system to be operational and be worthwhile. A cheaper solution is careful refactoring. Again this needs approval. I have worked in companies where a developer has decided to refactor and left so you have half the code base which is terrible and half which is partly refactored and nothing makes sense.
&gt; Our servers don't run Apache or Nginx or anything... we use PHP as our webserver and application layer. have things changed? http://www.reddit.com/r/PHP/comments/1b3hit/does_anybody_use_php_react_is_it_anything_like/c93zck7 
This would be such a huge red flag for me personally. Just asking for explanation is much more simple and accurate solution. 
I've had no experience with PHP frameworks but when you say swapping out a data source, I assume they'd all have to follow a fixed structure? Eg: your users table in MySQL would have to have the same structure as an equivalent CSV?
This is why we are looking at using HHVM and Hack as well. React + HHVM is blindingly fast. And with Hack + PHP 5.5/5.6 you can use a combination of pthreads and async functions very easily as well. EDIT: But the short answer is yes, many of the concerns in that post have been addressed to the point where we can build on top of it as a complete solution.
Like [this guy](http://www.bbc.co.uk/news/technology-21043693)? ;-)
Nothing wrong with being able to research a problem, the people that can't search and the ones that do but don't think about their found solution are problems. 
&gt; Surely it would be better to aim for a (near) perfect .0 release? An excellent suggestion with just two problems: First, getting anyone to try alpha/beta releases is worse than herding cats. While some folks are willing to put in the effort to test a .0 release, they'll balk at a -beta build of the same package. Without testing (and more importantly, reporting) it's hard to aim for that (near) perfect .0 release. Second, "Done is better than Perfect", and if that doesn't sum up PHP from every angle, I don't know what does.
I suppose it depends on what you reckon "a fair bit of BC" is 5 had the one big change we all know and love, but how many sites did it *really* break? I can tell you that Yahoo! Search didn't have any issues from the PHP-code side with upgrading to 5 (largely the issues were around "interesting" custom extensions). Meanwhile, we know 7 will require (minor, but non-zero) changes to private extensions, plus there are probably a couple surprises hiding in the change to how references are done. The migration might be harder for some, easier for others, or on par with the move to PHP5. We don't really know that answer yet, but I expect the 7.0 release will tell us.
Thanks, I might try this one in the future. The ones I tried made Vim unstable and slower when opening really large files.
Sound reasoning.
Yes there is. Download the chm. http://uk1.php.net/download-docs.php
Drupal 8 needs help, tons of little modules could use your help.
Since Guzzle 4 uses a different namespace and package name you can use Guzzle 3 and 4 or 5 in the same project.
Yep. Pretty sure LibreOffice would've worked just as well.
Having async support directly in the SDK, honestly, makes my day. Uploading a whole batch of small files to S3 (or a batch of AWS operations) will be so much faster then compared with with the old SDK. As they can now be executed asynchronously rather then one by one.
Ok, let's imagine then that I'm using Guzzle 4 and the AWS SDK is using Guzzle 5, or 6, 7, etc. Would that be a problem?
Yes. (Composer will warn you about it with suggestions though.)
&gt; Knowing how Composer limits to one version of a package, wouldn't it affect me if I were using Guzzle 3 for my own internal API calls? I guess this is true. The only solution would be to fork either Guzzle 3 (so you can upgrade AWS SDK) or fork AWS SDK (so you can keep your Guzzle 3).
I wish I'd known this in the past, and I'm sure I'll be using it in the future
And even then, there will probably a clash of namespaces (not between 3 and 4, as /u/WyriHaximus pointed out, but between 4 and up). Once the `GuzzleHttp\Client` class is loaded, either you or the AWS SDK is going to get the wrong version. The fork could rename the namespace, but that would be a hell of a change, and future commits would be a mess to import back into the fork.
Yeah, that's very true. I'm just thinking back to the object reference changes, which caused all sorts of issues in "frameworks" and "cms's" of the time. It wasn't massive, but it was there. And very true about the private extensions (and public ones). I guess my point was more that, as 7 stands today, I don't think the breaks would be as big as they were from 4-&gt;5, nor as painful... But yeah, only the future will tell for sure.
I would also add that it will be very frustrating but valuable experience. You should not quit this job.
Fair enough
Superb response. 
- Don't rewrite. Generally it is a mistake, and before making such a decision it would takes weeks or months of research. If you want to make yourself feel better -- consider all the fixes and improvements you are going to do "research for the rewrite". - Communicate. Make sure management understands your concerns, without being overly arrogant and self-serving. Explain that you have only been looking for a week, but you have concerns. Offer to actually show them the worst parts, ask them what they think about the codebase... mind the gap between how you view the code and how they do. - Slow down. If you try to do anything too quickly (like oust the other contractors) you will likely get serious pushback, you want to advise and go slow. You might be "their guy" -- but you are still the "new guy", you haven't done anything to prove yourself yet. - Add sanity. Add sanity not around the code, but around everything else. How backups are done, how version control is done, how documentation is done, how changes are deployed. Improving these parts will improve transparency and improve your reputation, as well as make any future changes far easier and less scary. - Data first. Take a step back from thinking about the code, and think about the data. All programming is DataA -&gt; Code -&gt; DataB, programmers overvalue the code part often, your job is move data from form A to form B. When you hit an 
/u/McGlockenshire 's answer is pretty thorough, I guess the following merely emphasizes a few of his points: * Stability is key. That means getting a dev environment up and running separate from the main site as the absolute number 1 priority. If you don't have this, you have nothing. * Stability again: make sure all the code is versioned. Git, SVN, doesn't matter. Get it into a repository so that you can revert and catastrophic changes you make. * Stability again: proceed with discipline. Adopt a process. Agile. Kanban. Whatever. Get a process, get a ticketing system. You cannot fix it and prove that you have fixed it until you have a ticket that says "refactor x in a,b,c places", and that ticket has been started, and you've committed to your code repo against that ticket, and you've moved the ticket to the closed state. If you do not do this you will never keep track of what has been done and what remains to be done. Get disciplined. Write tickets. * Refactoring stuff is time-consuming. Business is *never* going to give you the time simply to refactor page X. You wait until page X needs a feature adding or bug fixing, and you make small improvements as you do it -- pull all the HTML out into a template, and fill the template with variables. That's a small step towards MVC. Once you've done that enough times, maybe you can start thinking about adding a front controller and using an actual framework, but chances are once you're that far down the line it'll be tidy enough to maintain on an ongoing basis that the big step-change becomes unnecessary. * Use a ticketing system so that at the end of the month (or 3 months, or year) you can look back and show not only yourself but your manager the long, long list of things you've accomplished. * Don't complain about how shitty the existing system is. They know it's shitty. You know it's shitty. The shittiness is your challenge to solve so approach it with a positive attitude and everyone will thank you for it. 
You should just submit everything you wrote to your boss instead of Reddit.
Love it.
I look forward to Phil Sturgeon responding ;-)
It feels like FIG has confused the *process* with *progress*.
That's exactly the point that matters. Such large complexity levels are not an ideal point to start up. Instead targeting the ground level and as simple as possible cases (and thus lot less complexity), is what I'd like to see, too.
But the FIG is creating a standard for *frameworks* and most frameworks do actually implement all those advanced use cases. Their standard is not to be implemented in everybodies weekend project... Still a nice vantage point though.
Nail on head. Worse than those missguided standards are the people who complain on issue trackers that "we should adopt this spaces-over-tabs/logging/caching PSR because it was decided this way by the PHP community".
Could you please name a framework made by a voting-member of FIG, which implements all PSR standards? Name one. 
The structure in the actual storage mechanism doesn't matter as long as the php class that retrieves it maps it to a common structure. I think the idea is that if you call `$datasource-&gt;getUsers()`, then it should always come back the same, whereby $datasource can be any implementation of something like `DataSourceInterface` that has a `getUsers()` method.
&gt; But the FIG is creating a standard for frameworks and &gt; Their standard is not to be implemented in everybodies weekend project... Yes, frameworks which with people will use to make their code. So if a user uses code from a framework which uses a particular standard, they are therefore using that standard. So yes, it would be implemented in people's weekend projects... Sure, the user has the choice to use that framework or not, but most don't make that choice (and instead use one framework for everything). &gt; and most frameworks do actually implement all those advanced use cases. And I believe they shouldn't. They become Jack-Of-All-Trade platforms as well, with the same "Master Of None" syndrome that results. Look at Symfony's session manager. 26 classes and interfaces. To drive a session. Yes, there are definitely use-cases where you want that sort of complexity (and need it). But for the vast majority of Symfony users, it's overkill. And that's where simple interface can solve that problem. By relying on a simple interface, you can swap out a complex implementation for a simple one. And that sort of modularity is where FIG can make a HUGE impact. Hence the post. 
Can you please elaborate on that?
I think you misunderstood the FIG and its goals. Many frameworks/projects that are part of the FIG where created before any PSR was around. Asking them to change their codebase for the sake of implementing PSRs would be overkill for many of those frameworks/projects (like rewritting all the documentation.. and so on). **PSRs without conscience is but the ruin of the soul.**
I see standards like Mr.Crocksfort: http://highscalability.com/blog/2014/10/8/thats-not-my-problem-im-renting-them.html A way to not think about that problem cuz someone already thought on how to solve this and that. I can agree, as ircmaxell, that caching could be overkill in simple cases but, having a standard syntax is necessary and even in small codebase with few devs. 
Agree whole-heartedly.
Well I was thinking about madness like this: https://github.com/yiisoft/yii2/issues/2747 Yii 2 basically implemented PSR-2 with the exception of using tabs. Look at the comments. Most people want to switch to spaces not because it has any proper benefits, but for the sake of conforming to the standard.
I can proudly say I'm not that into VM
I understand, and can appreciate, the attitude that you want to see how people work with other people's code, but from an applicant's point of view, I want to show you how *I* code. So I'm curious to know if you get many applicants who submit challenges using frameworks or tools written by other people? 
ok, here is my learnings 1. Patience is needed. 1. If you are looking to contribute to big projects, big community it is not easy to get things merged. 1. When you start looking with small projects, then you can help with lots of testing, documentation, small typo fixes. In my case [I started with small](http://auraphp.com), that has helped me a lot to learn the good, bad the ugly. Good luck with the projects! It will really help you learn many things.
... but this all leads to one specific side-effect: every voting FIG member is attempting to make a standard based on what **their framework** already has, instead of trying to make a good standard. I am a bit afraid, that this can end up doing a lot of long-term harm, if they are not careful.
You seem genuinely concerned about how much the company is paying for all of this, but set aside this concern and don't presume that the business will fail because they paid for a development shop in India to write some bad code. The cost of the web site is likely a very small part of the total budget. Keep your focus on how to build a modern and professional system. I actually had a similar situation in my career. One part of an application was outsourced and the monolithic PHP file was something on the order of 30k lines of code. It was simply outrageous. The programmers had no concept of abstraction and the data was spread over six mysql tables because at the time there was a 255 column limit. They had no idea how to normalize a database. There was no validation on any inputs and large sections were copied in order to achieve minor variations on functionality. When asked to make some enhancement to it, I was faced with two problems: 1) Telling them that they paid for a turd. 2) Fixing the turd. I made some analogies to them that this was as if someone had taken a series of spreadsheets, printed them and scanned them as documents. I also explained how we could better innovate if we re-wrote this part but I took it in stages. I introduced loops, variables and sensible conditions and eliminated 2/3 of the code after a few weeks. This alone made things much more manageable. It took another couple of years after working on some other things to get buy-in to fully re-write it. Today it is under 2k lines of code and is much easier to manage. My advice is to make incremental improvement to parts of the application and share your success story with your employer. It is hard sale to get them buy into a big architectural change today. Your immediate task is to polish the turd you have been handed through sensible refactoring. Do this well and in time you will be able to swap out the architecture.
This kind of scenario is exactly why I wrote [Modernizing Legacy Applications in PHP](https://leanpub.com/mlaphp). It is a step-by-step guide to getting out of the situation you're in.
I agree, in particular with the comments about the caching proposal. I recently made my own [caching library](https://github.com/karptonite/geekcache), to handle some very specific needs on our website. I looked into using the PSR Caching proposal as a base interface, but it didn't make sense for us. In particular, despite the fact that our system needed some advanced features, I would have had to implement other methods ( exists(), isHit() ), and features (the ability to cache ANY value, including both false and null) that I didn't need, and which would have added substantial complexity to the system. If the PSR cache interface were something simpler, like the one proposed in the blog post, I could have made it work, extending it to support the other features I needed (tags, etc).
There isn't any real problem with adhering to the standard, either. And when you have a simple choice like that, adhering to the standard is always better, because it aids in interoperability and means people have one less thing to think about or configure in their editors when dealing with your code.
&gt; Look at Symfony's session manager. 26 classes and interfaces. T I pretty much agree with you. Not everything needs to be that 99%. And yes, Symfony's session class does implement some things that not everyone need (e.g. not every user may need/want flash bag or attribute bag). However, I'm don't agree with just looking at size/number of classes as an indicator of needs/complexity/bloat. The sheer size and number of classes in a library doesn't indicate usability/complexity. With modular libraries and applications, many of the classes are loaded on-demand (only when needed). If the number was truly important, the big libraries can be broken up into smaller ones. Architecturally, breaking up the packages may be better. However, the developer overhead increases with the number of packages (e.g, the average developer will have to install 3 packages instead of 1). By trying to make the library *appear* smaller, its usability has decreased (as its become more complex to use). There's also other things to consider (more complicated process for contributors, more complicated documentation, more complication following the codebase), but in general, breaking up the package does more harm than good. Is it worth it? Is it any faster? Is it any more efficient? Not really. Even in multiple packages, it'd still just load 3 interfaces and 3 classes for the average user. Was it worth the developer time to configure 3 packages vs 1? Probably not. We shouldn't just look at the number of classes/functions/methods/files-- that's just a number. Can we stop saying "look at how many [number] [project]" has. Its becoming a nearly-useless marketing number at this point. Can we evolve past this? I'm starting to get tired of looking at so called minimal projects that are more complicated/bloated than their competitors. tl;dr The number of files/classes/interfaces *used* may be marginally useful, but just looking at the number of used and unused classes isn't really an indicator of anything.
There's this talk called "[It Was Like That When I Got Here: Steps Toward Modernizing a Legacy Codebase](http://paul-m-jones.com/archives/2667)" by /u/pmjones himself (you can get the slides [here](http://www.slideshare.net/pmjones88/it-was-like-that-when-i-got-here)). Make sure to watch the talk and keep the slides as a reminder. Even if you don't like video, it's really worth it. It outlines a few **concrete** short term goals and goes a bit about the steps to be taken for each one. I see it as the low hanging fruit of turning a code mess into a code base worth that name. It focuses on keeping the app running the whole time: no big rewrite. The best part is: since you're starting from a pretty awful state, these first improvements will have a huge impact. It may look a bit old (2 years is a lot of time) but it's mostly pretty current. It even features the line "you just got a brand new job and..." so I think it will suit you fine. I think you're in for a lot of fun.
Well, arent there 26 classes just because they dont want a huge complicated interface? if you choose your implementation method (db, file, etc..) how many classes are used? and the userland interface is still pretty easy: get and set what you want... edit: as an example, look at how versatile those symfony components are, not *in spite* of but *because* they have default implementations for many scenarios; They are reused all over the place; https://www.acquia.com/blog/future-php-shared-power-tools they may be a bit more complex under the hood, but is that so bad if they're well written, easy to configure and well documented?
name a browser that completely implements all css standards correctly... does that make the standard useless? I dont think it does...
Are you even aware of how incomparable a 2 page PSR standard is to a complete CSS 1.0 spec?
php-activerecord does something kinda like that, except it uses static methods and names like `find_by_your_field_name`. It's kinda slick, really. If only the rest of it weren't as broken as it is...
The situation with PHP-FIG is very understandable once you've read the book [Systemantics](http://en.wikipedia.org/wiki/Systemantics#First_principles) The 'First principles' of Systemantics are: **New Systems mean new problems.** Once a system is set up to solve some problem, the system itself is a new entity which engenders new problems relating the development, operations, and maintenance of that system. The author points out that the additional energy required to support the system can consume the energy it was meant to save. This leads to the next principle. **The total amount of anergy in the universe is fixed.** The author defined anergy as the energy required to bring about a change. This as meant as a tongue-in-cheek analog of the law of conservation of energy. One of the problems that a system creates is that it becomes an entity onto itself that not only persists but expands and encroaches on areas that were beyond the original system's purview. **Systems tend to expand to fill the known universe.** The discussions about both the caching and message PSRs have taken far more effort or 'anergy' that it would have taken any of the big frameworks to just implement a very simple caching or message interface, start using it, and if other people start using it as well, then great - if not then not much effort has been wasted. Also relevant: **Elementary systems functions** * A complex system cannot be "made" to work. It either works or it doesn't. * A simple system, designed from scratch, sometimes works. * Some complex systems actually work. * A complex system that works is invariably found to have evolved from a simple system that works. * A complex system designed from scratch never works and cannot be patched up to make it work. You have to start over, beginning with a working simple system. I highly recommend the book - it's definitely as relevant today as it was when it was written 40 years ago. 
He [responded](https://groups.google.com/d/msg/php-fig/FzCFECFjF1o/AHJQpY0ds_QJ). And it's not far off from what I was suggesting... 
I've dealt with horrible PHP+SQL+HTML+CSS+JS spaghetti before when inheriting a project that was started in 2000 and hasn't evolved much since. The biggest initial win for me in order to think more clearly about how it all fits together is to go page by page and separate it into 2 files: mypage.php (which acts as a simple fat controller+model containing the PHP+SQL) and mypage.html.php (which acts as the template with HTML+CSS+JS and only deals with displaying data explicitly passed to it). You don't really need a fancy library for the template, something like this is fine in most cases: function renderTemplate($file, $vars) { extract($vars); require $file; }; renderTemplate('mypage.html.php', [ 'name' =&gt; $currentUser-&gt;fullName, 'title' =&gt; 'Home', 'items' =&gt; [1,2,3,4,5], ]); // In mypage.html.php, the vars will be available as: // &lt;?= $name ?&gt;, &lt;?= foreach ($items as $item): ?&gt;, etc... Now that you're working with PHP+SQL and HTML+CSS+JS separately, focus on the PHP side, extracting common logic in the same file into functions, move the SQL queries into functions that simply return PHP objects/arrays. You'll probably start to notice that several pages contain similar functions, combine and extract those out of the separate files and into a common file that you include at the top of the page. This is only the tip of the iceberg and still far from the end goal, but the main theme is to keep reducing the amount of complexity so that you can look at a page and easily understand how it all fits together, without needing to retain complex relationships and code jumps in your head. If you keep chipping away at it, you'll eventually be able to have a nice set of components that follow the single responsibility principle.
[Help yourself](http://oauth2.thephpleague.com/). If you got questions, ask the source, not a third-party that's not affiliated with the product. 
I love that analogy. I feel like my short-term task is to develop a strategy that makes sense from a business standpoint so that the owner of the company understands that it will be a slow process which will ultimately make him money. Then develop a long-term strategy to restructure the system. Your 30k -&gt; 2k story gives me inspiration.
Just to thank you guys for this amazing php framework. Got my organisations' staff management system developed from the ground up in a short while. Kudos! 
You nailed it... I don't think I'll be given the leeway to simply start refactoring when there are so many bugs that demand my immediate attention. I suspect I'll be working off the clock and at the coffee shop on a lot of this. Thankfully the position pays well enough to justify this.
You're right about communication. The first thing I noticed when I started was how the office manager (this poor girl who has taken the sad, sad defacto role of PM on top of her other duties) lit up like a thousand volts and said "it's so nice having somebody who communicates and can explain these things in human terms!" And you're also dead-on about keeping the contractors happy. They're very competent guys doing their best, and right now they're all I really have keeping the site afloat.
Thank you for this. I've only had one "trial by fire" experience thus far in my life where I was just sort of thrown onto a sailboat and expected to figure stuff out. It was overwhelming at first, but after 6 months I felt I was just as good as any of the other sailors. I intend to stick this out, and I'm hoping I'll be better for it.
Anthony has made some amazing suggestions that have quietly shaped multiple PSRs. His suggestion for a more PSR-0-like document was the basis of what Beau started writing, and this plea for more simplicity is no different. I can defend the choices made for a strong item approach, without necessarily demanding it go that way. If we can make a more easy standard then f**k-yeah I'll be all over it like a rash.
Haha, thanks chap!
The upgrade path from Guzzle 4 to 5 is really easy (nothing like 3 to 4). In fact, some library authors have set their composer dependency to 4 or 5 because they are only using a subset of the features and the subset they're using is unchanged. I don't expect there to be any more updates to Guzzle that will be as drastic as 3 to 4.
The "new" PHP has been there for the last 3 years, and the legacy cms systems (drupal, wordpress and joomla) is just now catching up. Other devs have been using "power tools" for a long time (composer) and im quite sure no one really wants to go back to a system lika drupal. Instead, start small, and use what you need, in 99% of the cases Drupal (and friends) are a major overkill, and in the end not flexible enough, leading to crappy, unmaintainable and untestable mess. When drupal 8 is released it will already be old from a php and community perspective. 
&gt; However, I'm don't agree with just looking at size/number of classes as an indicator of needs/complexity/bloat. In general, I completely agree with you. One large class is often worse than multiple smaller ones. However, in this case, I think it's a decent example because overall, there's a significant amount of complexity in those 26 classes/interfaces. It's not the number, but the overall complexity that's the problem...
I think it's less for the sake of it and more for consistency amongst codebases by different authors. I would however concede this is perhaps the tiniest of inconsistencies. Oh, and NEVER underestimate a community's ability to quibble over minutia. I mean, that's basically what we're doing right now, "No FIG, stop coding that absolutely for free and code this absolutely for free".
Well it doesn't have to be MS Word, but it does need to be something that can act as a honeypot. Also, we did follow up with the candidate and quiz them about their code, but they had reviewed it prior to the discussion so were able to answer questions about it and talk through it, thus quizzing them was not enough to raise any red flags.
this is the right answer
&gt;There is no need for me to create shell scripts that live in /etc/cron.daily that I would have to SSH into my server, find the files, modify them test them. There's no need for you to do that to run a cron job. Please, RTFM. &gt;It would be a pain for me to configure these scripts to talk to my application database outside my PHP application. If by a "pain" you mean saving 2, maybe 3 whole variables. &gt;So pretty much anything shell can do, I can write it in PHP and keep it all in one language. That's not a plus, that's called being too lazy to switch to the correct tool. &gt;But I think keeping everything "together" makes a lot more sense. Including all my testing frameworks &amp; scripts. System administration scripts do not belong with an application package. That doesn't make sense at all. 
Working on how this might be exploitable now, as I'd like to put a signature in our WAF. Pantheon, which hosts some of our sites, has already suggested they might be seeing exploitation attempts. The researcher who discovered this in a code audit says pretty clearly that there's a POC available in Section 1's pocket. Running some diagnostics (basically, dumping out all the arrays which come near the vulnerable bit of code) you see stuff like the stuff below. There apparently is a way to get the $args to have an array which contains arrays which has non-numeric (arbitrary) keys. I'm looking down the path of a deserialization which turns a string into an array - looking around in the source for all those now. Heading over to news.ycombinator to see what anyone has there. Array ( [:cids] =&gt; Array ( [0] =&gt; links:main-menu:page:node:en:1:0 ) ) Array ( [:cids] =&gt; Array ( [0] =&gt; links:main-menu:tree-data:en:9bd1605e2280833450478f9083b7f8714c2fa28f1012455e2744e5af1a13eec5 ) ) Array ( [:cids] =&gt; Array ( [0] =&gt; lookup_cache ) ) Array ( [:cids] =&gt; Array ( [0] =&gt; system_list ) ) Array ( [:cids] =&gt; Array ( [0] =&gt; module_implements ) ) Array ( [:fetch] =&gt; Array ( [0] =&gt; 1 ) ) Array ( [:ancestors] =&gt; Array ( [0] =&gt; node ) ) Array ( [:db_condition_placeholder_0] =&gt; 1 [:db_condition_placeholder_1] =&gt; 1 ) Array ( [:db_condition_placeholder_0] =&gt; 1 [:db_condition_placeholder_1] =&gt; 1 ) Array ( [:cids] =&gt; Array ( [0] =&gt; node_types:en ) ) Array ( [:db_condition_placeholder_0] =&gt; professional_theme [:db_condition_placeholder_1] =&gt; 1 ) Array ( ) Array ( ) Array ( [:cids] =&gt; Array ( [0] =&gt; menu_custom ) ) Array ( [:cids] =&gt; Array ( [0] =&gt; links:menu-secondary-menu:page:node:en:1:0 ) ) Array ( [:cids] =&gt; Array ( [0] =&gt; links:menu-secondary-menu:tree-data:en:9bd1605e2280833450478f9083b7f8714c2fa28f1012455e2744e5af1a13eec5 ) ) Array ( [:cids] =&gt; Array ( [0] =&gt; links:navigation:page:node:en:1:0 ) ) Array ( [:cids] =&gt; Array ( [0] =&gt; links:navigation:tree-data:en:9bd1605e2280833450478f9083b7f8714c2fa28f1012455e2744e5af1a13eec5 ) ) Array ( [:cids] =&gt; Array ( [0] =&gt; local_tasks:node ) ) Array ( [:cids] =&gt; Array ( [0] =&gt; theme_registry:runtime:professional_theme ) ) Array ( [:cids] =&gt; Array ( [0] =&gt; links:main-menu:page:node:en:1:1 ) ) Array ( [:cids] =&gt; Array ( [0] =&gt; links:main-menu:tree-data:en:9ec01ec58bf82a695e4acd636af283e0585fe8cd8a6e54eb140188a3e284ab1c ) ) Array ( [:cids] =&gt; Array ( [0] =&gt; links:user-menu:page:node:en:1:1 ) ) Array ( [:cids] =&gt; Array ( [0] =&gt; links:user-menu:tree-data:en:9ec01ec58bf82a695e4acd636af283e0585fe8cd8a6e54eb140188a3e284ab1c ) ) 
&gt; I can defend the choices made for a strong item approach For the record, I'm not that torn up over it. I was more using it as a tool to demonstrate complication where it *may* not be needed. If it's determined to be needed, great. But looking at the 50% case, it's a tricky sell to justify the complexity of it. If you can, definitely do it. 
Here's how the exploit works ([source](https://www.sektioneins.de/en/advisories/advisory-012014-drupal-pre-auth-sql-injection-vulnerability.html)): The function assumes that it is called with an array which has no keys. Example: db_query("SELECT * FROM {users} where name IN (:name)", array(':name'=&gt;array('user1','user2'))); Which results in this SQL Statement SELECT * from users where name IN (:name_0, :name_1) with the parameters name_0 = user1 and name_1 = user2. The Problem occurs, if the array has keys, which are not integers. Example: db_query("SELECT * FROM {users} where name IN (:name)", array(':name'=&gt;array('test -- ' =&gt; 'user1','test' =&gt; 'user2'))); this results in an exploitable SQL query: SELECT * FROM users WHERE name = :name_test -- , :name_test AND status = 1 with parameters :name_test = user2. Since Drupal uses PDO, multi-queries are allowed. So this SQL Injection can be used to insert arbitrary data in the database, dump or modify existing data or drop the whole database. With the possibility to INSERT arbitrary data into the database an attacker can execute any PHP code through Drupal features with callbacks.
Yes, trying to figure out how, in a pre-auth context, you can inject something (via URL/$_GET['q], get params, post params, whatever in Drupal's system) that will end up turning a numeric key into something "which are no integers".
Looks really good man keep it up. I may be using this shortly so I've been reading through it. Looks slick!
&gt;There's no need for you to do that to run a cron job. Please, RTFM. As recommend here. Thats good enough for me. https://support.servergrove.com/how-do-i-automate-backups-of-my-mysql-database/ &gt;If by a "pain" you mean saving 2, maybe 3 whole variables. Its far more than 2 variables. &gt;That's not a plus, that's called being too lazy to switch to the correct tool. Correct tool? Sorry. My administrative tasks are one line. Bash gives me no extra power that I requrie. &gt;System administration scripts do not belong with an application package. That doesn't make sense at all. Makes absolute sense. 
You should have a look at http://www.phptherightway.com
Could you recommend and ORM library?
Doctrine.
Don't listen to the other commenters telling you to quit. This is probably the best learning experience you will ever have, and will serve you well in all of your future employment. You will encounter this situation over and over again throughout your career, even if you end up at well-run software startups with very competent developers. Every codebase I've ever worked on, even relatively new code written by good developers, was somewhere between "hard" and "nightmare" to extend and maintain. The equilibrium state of software is broken, and fast-moving business requirements make it worse. The first instinct of any rational developer when encountering such a codebase is to want to do a full rewrite; experienced developers learn to ignore this impulse. Don't forget that your primary responsibility is to be a force multiplier for the business. In this case, their attempts at cutting corners have created a source of negative value; your job is now to expend just enough effort to reverse this situation, and not an iota more. In most scenarios, "bad" is good enough for the business, where technical challenges are usually smaller than the challenges of acquiring and retaining customers. Every time you sit down to write or refactor some code, ask yourself "will this make us more profitable?" Sometimes the answer is yes, sometimes it isn't. Good developers tend to be perfectionists with a healthy dose of OCD, so we can't stand working with an ugly codebase. Great developers know when the code is good enough, and when to move on to the next task. Often, an apologetic comment and an explanation of why the code is ugly is more effective than a thorough refactor. Your employers will love you if you have this attitude and demonstrate an understanding of the problems they are facing, not just a desire to craft perfect code. Good luck, and don't get discouraged. Remember that the mess was created by inexperienced managers, and don't take it personally if you start getting heat for software bugs. If nothing else, it will help you recognize a well-run company if you encounter one in the future.
What frameworks are you using in java? I'm a professional developer currently working in a java environment but I'll typically do small home web projects in php. If you're working with spring or really any of its components then symfony should be your only choice.
2008 was a hell of a year **edit:** *In response to:* CakePHP and Eclipse
Sorry if this is a dumb question but: Isn't that parameter binding by PDO? If so, doesn't it guarantees that no multi-querries will be generated from simple parameter binding? Or Drupal's db_query() does some SQL string processing to build the SQL query before sending to PDO?
This is awesome. Cloned it and running locally :)
Laravel comes with [eloquent ORM](http://laravel.com/docs/4.2/eloquent), but [Doctrine](http://doctrine-orm.readthedocs.org/en/latest/) is more full featured.
Yes, if you look at the bit of code in the foreach block above, it expands the number of bound parameters before PDO ever touches it. So, exactly as you suggest, BubuX, db_query does string processing in that it creates more bound params for PDO to bind. And it works fine... as long as all the keys of the sub-arrays are integers. The patch removes all passed-in keys. That said, one wonders what other string processing tricks might be hidden in Drupal Core.
Phil is "The Gordon Ramsey of PHP". I imagined him being nice and sweary about it, like the one about PSR0 and PHP7 
maybe u shoul take a look at Yii. That's quite fast framework. Also i recomend u to use phpstorm.
Implementing an OAuth2 provider is not for the faint hearted, even with the League library AND documentation. The error that seems to be thrown is: &gt;&gt; The requested scope is invalid, unknown, or malformed. Check the "ok" scope. So, I would start there. When you say: &gt;&gt; Now it is suggested to implement Storage interfaces. I don't wanna do this Well, I guess that's your problem right there. The library is storage independent and it requires you to implement this (and it supposed to be like this). 
Make it a Trait and make it available through Composer. Seriously, stop copying and pasting stuff. 
Thank you for this clarification. I can clearly see the problem now. And yes, it worries me also.
As others have mentioned, Symfony or Laravel are the ones to look at at the moment. Similarly, Doctrine is your go to ORM library. Just a heads up, Symfony includes Doctrine as part of it's framework A good thing to note is the dependancy manager [Composer](https://getcomposer.org/). It's pretty much your go to tool for including external libraries in your projects, and is quite possibly one of the best things to come out of the PHP community in a while. If you go down the route of Laravel, but see some features in Symfony that you like, you can just include those specific components into your Laravel project with composer, and it should just work. Good luck
I can't believe you linked to a random hosting company's support article. FFS you're trying to argue that your way is better when you haven't even taken the time to understand how to do it the right way. Open up your terminal, type man crontab and start reading.
Doctrine uses the repository pattern, and eloquent uses the active recort pattern
&gt; I actually posted it to discuss some improvemnts that might be added to it. Then say so, we don't read minds... 
That looks like it would be a great shirt.
The best framework is the one you prefer using. Aside from the others mentioned here, look at Zend (component based, you use what you want), Slim and Silex (both extremely lightweight). As well as Doctrine, another ORM to consider is Propel. Not used it since 1.6, but I really liked it - it's on 2.x now. Make sure you use an autocompleting IDE, otherwise working out what methods are available on what object can drive you mad. 
I have a client that runs a large portion of their PHP-based web application, their bread and butter, on iSeries using Zend Server. They also take advantage of Zend Server Job Queue to run async processes. In general it's fast, especially if you take advantage of DB2 on iSeries. DB2 is ridiculously fast. Zend Server is very stable and the support is great; they're always releasing updates. Alan Seiden is the industry expert on Zend Server running on iSeries. He has a lot of information about performance and everything on his website http://www.alanseiden.com/articles-and-publications/. I work with him and he's a pretty cool guy. Yes, you can run your entire intranet assuming it's PHP-powered. Many PHP-powered applications, including some intranets like Bitrix, run on MySQL, so you'd have to get that installed on iSeries to get it working: http://www.redbooks.ibm.com/redbooks/pdfs/sg247398.pdf. A couple of advantages of running PHP on iSeries, at least with Zend Server: - it's very fast, thanks to different kinds of caching that increase speed (page caching, opcode caching) - you can potentially move entirely from the Windows machine to the iSeries machine and perhaps even eliminate the Windows machine if the only thing it's hosting is the application you've mentioned - DB2 - You bring "almost" the PHP ecosystem to iSeries. I believe PECL extensions are a bit tricky to compile, but mosts times the default extension work. - Some of the Zend Server editions come with Job Scheduling system, where you could schedule single, delayed, and recurring async HTTP processes that run slow - iSeries is unix-like so things like git, svn, and ssh can be installed on it - Word is debugging is much easier with Z-Ray if you're using Zend Server 7 (haven't tried it myself... yet) - Remote debugging is possible with Zend Debugger - PHP runs behind nginx with FCGI processes (it's fast) - if you have a bunch of COBOL programs, thanks to Alan Seiden and IBM you can call them directly with the PHP Toolkit, comes pre-configured in Zend Server - Zend Server on IBM i rarely ever "gets in the way" and you could focus on just building your application just like you would on Linux, Mac, or Windows - PHP 5.3-5.5 - Some editions allows you do call Java code directly on your machine. Never had to do it myself, but this could definitely be an advantage if you have a lot of software already written in Java on iSeries. Disadvantages: - Zend Server is awesome, but it's not cheap. You just have to focus on the value it brings and see if it makes business sense. Zend Server definitely allows you to build modern systems much more easily. For instance, if you want to expose part of your system as a service behind a REST API, it's much easier to leverage PHP for that. - Doesn't happen very often, but sometimes cryptic bugs comes up you usually need a System Administrator that's familiar with iSeries and Zend Server to come in and help and sometimes Zend themselves. As long as you have someone (AKA Alan and I) in hand you should be good. - If you're not using Zend Studio, setting up your IDE to access the DB2 database is a little tricky (for me, PHPStorm). It's possible though. http://www.zend.com/en/solutions/modernize-ibm-i and http://ww2.zend.com/en/products/server/zend-server-ibm-i has a whole section on Zend Server for IBMi with a list of features and other benefits. If you need more help weighing whether or not to go with Zend Server, PM me and we could talk more. Assuming you have a technical budget for this, it might be a good move.
&gt; I can defend the choices made for a strong item approach [...] Can you tl;dr it? As someone who followed this proposal for a while and [made some suggestions](https://groups.google.com/d/msg/php-fig/UkSWS48eEgo/guux1B4L4ksJ) to try and address the growing complexity, I still don't understand the rationale for the strong item design.
Coming from Java to PHP you'll probably find yourself looking at a lot of implementations of language features and being tempted to say "Hmmm, it looks like this feature has only been half implemented, drastically reducing the usefulness of it, or implemented kind of mongily so it barely does what it was intended to do." and to that I have to say... YOU SHUT YOUR DAMNED WHORE MOUTH. If you want to use a framework (which is of course the right decision) you have two real options to choose from that are widely used and well supported. Symfony, and Laravel. Laravel is my choice, because I'm stupid and need my hand held by smarter people. Symfony is probably a better choice for you. It's less opinionated and probably a better fit if you understand the patterns, etc. Most of the time when recommending frameworks to people in PHP-land it's because they haven't used one before, so learning curve and availability of tutorials and training materials is are a major factor. Less so with you, though. ORMs are going to be largely framework based. Symfony most commonly uses Doctrine, an advanced Data Mapper based ORM that excels for complex logic. Laravel uses its own Eloquent ORM, an excellent and elegant Active Record ORM. Most PHP devs use PHPStorm as an IDE, but if you are a Java cat you're probably more familiar with Eclipse, which is also an excellent option so just use that. In conclusion, if you're just wanting to switch a simple frontend with minimal functionality, I'd recommend Laravel. With a weekend and the introductory [Laracasts](http://www.laracasts.com) tutorials you could smack together a solid victory pretty easily while still having a good basis to build from. If your requirements are more complex then you'll want to invest the time into Symfony. Good luck! I'd love to hear back from your experiences.
I must find an excuse to use this :-)
This is a true gem of a comment. Saved
You're using `$this` outside of an OOP context... o_o
A cryptographic library that choked on short entries (e.g. "0x00") would probably be very fragile :)
So you are saying I should write my own bash script to say backup my database, save it to a folder and upload it to dropbox via github "dropshell" ( https://github.com/andreafabrizi/Dropbox-Uploader ) then send an email from bash to say that the task is complete? 
I love redbeanphp its pretty awesome for rapid development. 
&gt; YOU SHUT YOUR DAMNED WHORE MOUTH. Roger! To funny LMFAO
Whatever your questions are the answer is Symfony... it is the PHP framework for Java developers.
All kinds of awesome - well done :)
I already said your case is a one-off that actually has a purpose using PHP, several comments ago. I'm saying you don't understand how to use cron, and your one exception (which I wont comment on the sanity/terrible practices of) is not a reason to think system administration should be done via PHP.
if you were a fan of hibernate in java, then you would mostly feel at home with Doctrine2.
/r/netsec has an example: https://www.reddit.com/r/netsec/comments/2jbu8g/sacore2014005_drupal_core_sql_injection/clagqhd
^ This is an answer
Right. Making a class for others to extend, vrs a much smaller single interface for potential composition. Two different approaches to the same thing. I think the Pool, deferred and multi-get is where this gets a bit shit, and that _could_ be done with more methods and more interfaces. Sadly, it seems like more interfaces just leads to a lot more similar methods. * getByTags * getMultipleByTagsWithOkTTL 
~~Regardless of what you fed it for $a and $b, it would return 1.~~ **Edit:** *I'm tired and wasn't thinking.* 
Well yes. I need access to the methods that are found in the PHPUnit_Framework_TestCase, which is the class you extend to write tests. Actually I use them by extending that class and adding those methods. Perhaps it is a more preferable way, I updated the post. Thanks.
Scratch that, it would indeed return 4 as it would have to decrement 4 times for 4 to be less than 2. Then each return of 0 would have 1 added for a final of 4.
The result will be 4. Though, i"m not sure why you're asking rather than running the function. $ php -a Interactive shell php &gt; function operation($a, $b){ php { if ($a &lt; $b) php { return 0; php { else php { return (operation($a-1, $b) + 1); php { } php &gt; echo operation(5, 2); 4 Function could be rewritten to be: function operation($a, $b) { return $a &lt; $b ? 0 : ($a - $b + 1); } 
I ran it, it returns 4. More specifically, it returns ($a - $b) + 1 if $a is more than or equal to $b. The reason for this is that op1: (5, 2) returns (op2 + 1) = 4 op2: (4, 2) returns (op3 + 1) = 3 op3: (3, 2) returns (op4 + 1) = 2 op4: (2, 2) returns (op5 + 1) = 1 op5: (1, 2) return (0) = 0 Also, is it really that hard just run the file yourself instead of asking reddit to do it for you?
thank you! 
thank you!
Items are a little more complex than simple wrappers, but they do solve the problems. A lot of it comes down to state. With a driver method you don't have a way to keep state outside of the cache backend itself. You can attempt to hold an index but it'll balloon up the memory usage. With the Pool/Item method you can store information about the current state of the system in the Item classes themselves, and when that Item is no longer around (the object moves out of scope and goes away) so does the metadata you were using. That metadata is what solves the rest of the problems- * Race conditions between when you check that something exists and when you retrieve it. The Item can save state, so it can have all it's information loaded into it at once. This means that the checks for it's existence and for what the item contains are one set of calls without a delay between them and there is no race condition. * No way to handle stampede protection. There are a lot of ways to solve the stampede protection problem, but most of them rely on the Item being able to have some sort of state with it. My favorite method is to precompute the value before it fails, but that involves a bit more complex code to do right- you have to add some locking mechanism (internal to your library) so you don't have a bunch of processes trying to precompute it leading to another stampede. * Very hacky attempts to add in group invalidation methods (namespaces, tags, stacks). This is more API specific, but the Pool/Item module is *a lot* more expandable. Without it, for instance, tags would require a duplication of all the set/clear functions (set, setWithTags)- with it you just add a setTags function to the Item. 
I lean more towards the `function array getData` syntax myself, as to me it reads quite a lot cleaner, but this is still useful.
&gt; I lean more towards the function array getData syntax myself, as to me it reads quite a lot cleaner, but this is still useful. ``static function static getInstanceOfCurrentStaticClass()`` Problem.
Excellent! Can you tag up a version? Even just 0.1.0 would make lazy installing easier. :)
`static function getInstanceOfCurrentStaticClass(): static {` still a problem 
This is an outstanding answer. I want to particularly draw attention to the highly Dependency-Injected style of this solution. When one object operates on another (such as FlockMigrator moving a flock from one customer to another), it assumes nothing about the underlying objects beyond the fact that there is a method "shipTo" defined in its Truck object. And it ensures that is the case by type-hinting that truck to only be an object conforming to the Truck interface. This makes it trivial to radically alter the shipTo command to change how the Truck actually moves the flock, without ever touching the FlockMigrator class. To elaborate on his DBAL point and your question about how to best organize your statistic generating code, it sounds like you already have the beginnings of a makeshift DBAL in the two database classes under the same interface. Hard-coded SQL would be hard to maintain between those two classes, so you should delegate the nitty-gritty work of SQL statement construction to each database class. Say you want to calculate which customer has produced the largest number of broilers in all their flocks. I would suggest doing something like this: class CustomerTotaler { protected $database; // Can accept either your MySQL or SQL Server adapter class public function __construct(DatabaseAdapter $database) { $this-&gt;database = $database } public function broilerTotal(Customer $customer) { $flockSchema = $this-&gt;database-&gt;getSchema('flock'); $farmSchema = $this-&gt;database-&gt;getSchema('farm'); $customerSchema = $this-&gt;database-&gt;getSchema('customer'); // This could be done a variety of ways. For explicitness, I'll use chained method calls $command = $this-&gt;database-&gt;createCommand(); // Returns a DatabaseAdaptorStatement $command-&gt;selectSum($flockSchema-&gt;getBroilerCountColumn()) -&gt;from($flockSchema) -&gt;join($farmSchema, $flockSchema) // Here, the join method would construct // the appropriate foreign key condition from the two // schemas, perhaps using another object that defines the relation -&gt;join($customerSchema, $farmSchema) -&gt;whereEquals($customerSchema-&gt;getIdColumn(), $customer-&gt;id); return $command-&gt;queryScalar(); } } So, no SQL is written directly, as that is delegated to each DatabaseAdaptorStatement's methods. Also, column names would not be hard coded, as those can be defined in schema objects, accessed via methods, and returned as Column objects that the database adaptor can then use to construct an appropriately formatted and escaped column name. This method doesn't even need to know how to join two tables together, as that can again be delegated to other objects better-suited to handle just that. This is just a suggestion, but I think this could be a very powerful, expressive, and maintainable pattern!
so we get prefixed names for type hinting parameters, but return types are suffixed? That's not very consistent. 
I'm not seeing it, the former looks ambiguous to me, and would look ambiguous to new users too ... This isn't the main reason for choosing this syntax anyway, I think the main reason is that it's compatible with Hack's return type syntax, which looking forward makes things easier for everyone. If hack didn't exist, I'd still prefer the way it is now I think ...
&gt;I'm saying you don't understand how to use cron, and your one exception (which I wont comment on the sanity/terrible practices of) is not a reason to think system administration should be done via PHP. Bah. I just web cron'ed the shizzel out of it and that way I didn't have to man crontab Which I think actually saved me huge amount of time. 
&gt; Well, I think it's a pretty contrived usage that is pretty unclear in either case, especially to someone not familiar with the syntax. Right, it's a knee jerk response ... I shouldn't assume what looks strange to me will look strange to you I guess. But I'm not really thinking about me, but the next generation ... maybe you're right about that too ... I dunno ... &gt; You're right about Hack, though. Using the same syntax as Hack has implemented is definitely better for everyone. Yeah that's better justification ... should probably have opened with that :)
Agree. These changes plus [Nullable Types](https://wiki.php.net/rfc/nullable_typehints) and [Array Of](https://wiki.php.net/rfc/arrayof) would remove most of the unnecessary docblocks we use today (the simpler ones that don't add documentation and just limit themselves to inform about what a method does).
I think the RFC covers the reasons why this decision was chosen. Personally it reads nicely to me. 
Just wait until you realize that by default, the mysql pdo driver uses emulated prepares (eg the variable substitution happens in the mysql pdo driver instead of the mysql server).
I'd love to see constructor promotion and generics, too. The former, especially, would replace a lot of boilerplate. 
&gt; Code which does not declare a return type continue to work exactly as it currently does. Then why do we have to wait for PHP7? :( It makes me sad to see all these cool, backwards-compatible features proposed for PHP7 that 5.x will never see.
Random point not related to the specific RFC, but how do I see internal discussion on an RFC? Is it linked anywhere?
It's not $result = ksort($myarray) because editing an array in place saves a lot of memory for large datasets.
This would introduce a new keyword, which I'd like to generally avoid. The colon is shorter and happens to be compatible with Hack, so I went with that.
Then why isn't it `array_unique($array)`? I'm not arguing that it should be, I'm just making the point that from a newbie point of view it's already confusing and inconsistent. This stuff can be hard to learn. 
(afaik) Drupal uses only utf-8, so emulated parameter binding is not a security issue though.
Presumably because array_unique is destructive. You'll come out with less data than you had before.
Consider this argument declaration: function foo(A $a) {} This says that the type of $a is A. Let's assume we did a prefixed return type: function A foo() {} Is this saying that the type of foo() is A? No, not really. The type of foo is a function which takes no parameters and returns type A. In my mind, this means there isn't actually an inconsistency. Furthermore, it is really strange for anonymous functions since the return type is not the name: $var = function A() {}; Sure, some whitespace could help: $var = function A () {} But it's not really any better in my opinion. Another reason that isn't listed in the RFC: compatibility with potential features like generics: function foo&lt;T&gt;(): T {} Here, function foo returns a type T. If we put the return type before the function name we couldn't put the &lt;T&gt; declaration there. We'd have to do something nasty like C++: template&lt;T&gt; function T foo() {} All in all, I really think the decision to put it after the parameter list is a good one.
Realistically there may not be another PHP 5 series release. If we do a 5.7 release it will most likely be a release to ease migration to 7, which would include more deprecation notices. It most likely would not contain any new features.
So? That's what you told it to do. Seems like an arbitrary decision to me. And sort could be argued as *kind of* destructive too, as it will re-order keys. 
You may be interested in another comment I made about this, which includes information not covered in the RFC: http://www.reddit.com/r/PHP/comments/2je507/return_type_rfc_moved_to_php_7/claxoxf
It's interesting. On the one hand, shorter keywords can be faster to read for the trained eye: pub func getSession(): Session { return $this-&gt;session; } On the other hand, using full keywords are more explicit in what they do: public function getSession() returns Session, null throws SessionException, \Exception { return $this-&gt;session; } The above code would easily tell a reader from another language that it returns either `Session` or `null`, and throws either `SessionException` or `Exception`. The benefit I see with your preference is that, if other features are added in the future (like `throws`), the use of `: return_value` could lead to pretty strange semantics. But, one could argue that things that `throws` should not be part of the method declaration, and instead make use of annotations or other methods, or just not be integrated in the language. I'm not really sure what I would decide in this case.
http://grokbase.com/t/php/php-internals/144r0jag37/rfc-return-type-declarations http://grokbase.com/t/php/php-internals/14ag7yb49a/rfc-return-types-update
As long as something like: // Int is not a valid type declaration function answer(): int { return 42; } answer(); is invalid, we're kicking wet shit up hill. You end up declaring half your functions with return types, and half without. Blimey, you can declare `array` as a return type but not string or int. It's silly. I understand why, but you can nevertheless see why it's frustrating.
Very uplifting post. I hope more people take this advice and learn how to set up a server from scratch using raw shell commands before trying to utilize high-level provisioning tools which, really, are aimed at experienced sysadmins who deploy and/or maintain multiple servers.
Create a getter method that you can override with a mock. class TheWonderfulClass { protected $objectWeNeed; public function getObjectWeNeed() { if (!$this-&gt;objectWeNeed) { $this-&gt;objectWeNeed = new ObjectWeNeed(); } return $this-&gt;objectWeNeed; } public function someGreatMethod($paramA, $paramB) { $objectWeNeed = $this-&gt;getObjectWeNeed(); } } And then to mock your desired object, mock/override the `getObjectWeNeed()` method to return your mocked object for testing. Depending on which testing suite you use, you might need to reflect the base class to override the method. If you instantiate a new object every time unlike the example I provided that creates only a single instance, then it's straight forward and you don't need to have the check like I provided. Also, if you're maintaining a single instance like in my example, you can set the protected value instead of overriding the getter method. Each option has its benefits and drawbacks depending on your needs so I won't categorically suggest one over the other. I'm only providing my specific single-instance example as an example that I typically use.
But how would you set parameter expectations for consecutive calls?
Assuming there are no more bugs in the emulation implementation.
Absolutely. I'm pretty sure that return types will be part of PHP 7. Scalar types are another matter. The last RFC on the topic was withdrawn, again :/ I hope we can come up with an alternative proposal, as this is a really important feature.
Tkx for your feedback. But in your example the $objectWeNeed is a class property, which in our case is not what we want, we don't need it to be a class property because we just use it in that specific method.
Yep... My WishList ---------------------------- Return Types, Scalar Types, Generics, Async IO, Getters/Setters, Threading (pthreads would do) Array Typehints, 
Use a codepad instead then - there's loads of these: http://codepad.org/X4TL7rAR
&gt; I hope we can come up with an alternative proposal, as this is a really important feature Do you yourself have such plans for a new RFC? We can only hope :)
That's a really good explanation, thanks!
It's not ideal by any means, but you can use the spl types instead of scalar types http://php.net/manual/en/book.spl-types.php
Shouldn't `__toString` be listed under *Methods which cannot declare return types* as it can only return strings?
Sorry, I forgot to add that the second example was implementing multiple return values, `null` being one of them. The method in question could have declared `returns Session, callable, string`, noting that any of those values could be returned.
This syntax (and a similar discussion in [another thread](https://www.reddit.com/r/PHP/comments/2je507/return_type_rfc_moved_to_php_7/clawld7) are fairly nice. They even match what some other languages do. I was happy to see it included array and callable. I was also happy to see it supported regular functions and proposed additions to the reflection API. A few concerns about this RFC, which is still far better than several RFCs I've read through: * The introduction of uncatchable fatal errors is a bit disappointing. (I'm not a fan of any fatal errors, but I guess CATCHABLE is better than anything) * It'd also be nice to see some sort of sane nullable, but we can live without it. * `ReflectionType` may be better as 3 classes `ReflectionTypeCallable`, `ReflectionTypeObject` and `ReflectionTypeArray`. Developers can then simply do instanceOf rather than a second method call. This removes the need for `getKind()` and allows `getName()` to be be named more clearly: `getClass()`, `getClassName()`, etc. However, return types may seem nice, but in a dynamic language like php: having some sort of [function overloading](http://en.wikipedia.org/wiki/Function_overloading) would be much more useful, on average. (even without return types, it'd be useful). I'm sure this isn't the first time its been mentioned, but lack of such a feature has me writing more workarounds than the lack of return types. Example without having return types: function find($id) {} function find(Criteria $criteria) {} function find(array $search) {} Example with return types: function find($id):User {} function find($id):Dog {} function find() { $type = \func_get_type(); } // calling code can determine what type it wants $user = $object-&gt;find():User; $user = $object-&gt;find():Dog; $user = $object-&gt;find():TheGreatBeyond; Maybe I'm dreaming too big here, but this should already affect how everyone is writing their code. tl;dr This RFC looks like its just about there, but would be much nicer with function overloading.
Sorry, didn't get it. I understand it now. I quite like your option. It does seem a bit of an overkill because ObjectWeNeed is only used in one method, but in the other hand, in the future it might be used in other methods and i like it better than instantiating the object directly in the method where we need it. I like it!
Good point.
&gt; Very uplifting post. Agreed. For me, this blog post is a metaphor for everything that is right about the Internet. There was a time when learning resources were limited to books, mentors and formal education. Now we have access to all these things at our fingertips, almost regardless of our situation. It's really kind of heart warming to read a story where somebody has embraced all of those things and is even going so far as to give back and publish their learnings for others to use. This put me in a very good mood this morning. :)
it's dumping what you told it to do
Tagged **1.0.0** composer require lastguest/pixeler:"*" Thanks for pointing out :)
Not really? I'm asking for "index" *foobar* on `null` and `0`. There is no such index. It fails with `""` (Illegal string offset 'foobar') and `[]` (Invalid offset: foobar), as I would expect it to.
Is it possible that `var_dump()` works the same way as `empty()` and `isset()`? For example, `empty($null['FOOBAR'])` would return true without triggering any errors.
With HHVM and PHP 7 you can also do: var_dump((0)['foobar']); var_dump((null)['foobar']); PHP 7 also lets you do: var_dump(null['foobar']); You can have a play with these here: http://3v4l.org/haTS3 Edit: HHVM lets you do: var_dump(''['foobar']); var_dump(''['']); 
File header pixelart generator?
Right, they just really aren't good reasons. The main reason is to help facilitate searching. But I guess people don't really know how to use grep properly, or use tools that index their code properly. Not really a great reason. Levi has added some more actual good reasons. But it all comes down to it's still inconsistent as heck. What it comes down to is that prefixing in parameter list was the wrong choice.
Not a fan of this syntax
You're assuming that our desire to know *why* that key is not in the associative array ends with merely the fact that it simply isn't there, where in the OP's example he explicitly desires more information about the failure condition than its mere non-existence (driver is offline, cache is not responding, etc.) We can either build a complex system of checks around the result of the function call that has to be reproduced everywhere that function is run, or we can throw an Exception and have the information we need included within the Exception object. Adhering to overly strict semantics in these circumstances merely makes your code more complex, harder to test, and less useful for no real benefit whatsoever.
Seeing how PHP has a function keyword, which differs from other languages like C/C++ and Java, I'm actually opposed to the ```function array getData``` syntax and am more partial to something like ```function getData() -&gt; array``` syntax. Ever since following the Rust project, I really like indicating the return type with the -&gt; because it's quick and easy for the eye to pick up the return type. It's also pretty easy to type. For example, at least to me, this is more readable: public function getData() -&gt; array { return []; } Than this: public function getData(): array { return []; }
I'm going with /u/Revisor007 here. Per Misko Hevery, your classes should *either* build and return objects, *or* use those objects to do things, but not both. The shorthand is "No use of `new` outside of factories." So if your class needs to create an object, pass it a Factory that creates that object, then invoke the factory to create it when needed. For example: class TheWonderfulClass { protected $objectWeNeedFactory; public function __construct(ObjectWeNeedFactory $objectWeNeedFactory) { $this-&gt;objectWeNeedFactory = $objectWeNeedFactory; } public function someGreatMethod($paramA, $paramB) { $objectWeNeed = $this-&gt;objectWeNeedFactory-&gt;newInstance(); // ... } } Yes, it seems like overkill, until you get to testing. You can then inject a different factory to change the object that gets created. Hope that helps.
the point still stands
You would instantiate the factory object together with the "theWonderfulClass", then? $wonderfulObject = new TheWonderfulClass(new ObjectWeNeedFactory); $wonderfulObject-&gt;someGreatMethod('foo', 'bar');
&gt; Accessing variables of other types (not including arrays or objects implementing the appropriate interfaces) using [] or {} silently returns NULL. From [PHP manual](http://php.net/manual/en/language.types.string.php). Long story short: You can access a character at a given position from a string using syntax similar to array: $zero = 'zero'; var_dump(gettype($zero)); // string var_dump($zero[2]); // r which is the same as: var_dump(substr($zero, -2, 1)); // r Because you set that string to NULL, *each part* of the string will be NULL.
&gt;&gt; Accessing variables of other types (not including arrays or objects implementing the appropriate interfaces) using [] or {} silently returns NULL. &gt; &gt; From PHP manual. Nice find! Regarding the rest: I fail to see how this is related to strings. I know that I can use `[]`/`{}` to access characters in a string. But I'm not doing anything on a string and `0` is not cast to `""` in `$zero = 0; $zero['foobar'];`. Otherwise I'd get the `Illegal string offset` warning.
That's pretty easy.
since PHP 7 is more than a year away, this is subject to change
Yes, I understand that the manual says so. But it doesn't make any sense to document that on the page about strings. Maybe it grew organically: First you could use `[]` to access array elements, then they added support to access characters in strings and while doing so, saw that they need to do something with other scalars. So they documented it on the page about strings. Still think this is not the expected behavior though and PHP should fail.
Somebody from internals should be able to explain this more eloquently but consider that NULL really means "unknown value", meaning WTF. If you perform any operation on an unknown value, the result is always unknown value. The only time $something['stuff'] will complain is if $something is an array and the key 'stuff' does not exist.
It should, if PHP was a strictly typed language.
I go with this! We actually have the TheWonderfulClass as a service. We can easily "construct" it like that in the DIC. Tkx Revisor007 &amp; pmjones.
I guess I'm old-school. We've got 300 clients on one monolithic dedicated server that we manage via the wonders of a collection of bash and perl scripts. How does deployment and hosting work for shops that use Chief or Puppet? I haven't really found a good online resource explaining a hosting plan or workflow for this. Do they deploy each client onto their own vps? Part of me just can't get over the idea that 300 small servers wouldn't be more work tuning, securing, and managing then one large server.
It's all about "high availability". For a larger application you'd use a load balancer and proxy requests off to several identical application servers located all over the place. You'd come up with a provisioning process to quickly bring up more application servers and add those to your load balancer if you needed to scale up. Your app not getting as much load? Kill some app servers and save some money. Also if your one server spontaneously combusted you'd be in a world of hurt. Although you'd could argue the same thing if your load balancer went down too. That's how I understand it at least.
You might have given your claim more credibility if you hadn't said "bestest".
Extra keystrokes to flip between a few files I want to edit at the same time? No thanks.
just felt wrong to keep what I've learned to myself after learning from everyone else! Glad you enjoyed the post :)
Well I find myself often editing 10-15 files at a time on a notebook. run out of tabs really fast. Brackets wasn't that bad since instead of tabs it has a list of open files at one side, but i like this much more. If you are editing only a few files it will be enough to Ctrl+e + down (once or twice) + enter 
Which makes a lot of sense and this is very much what I am finding lots of articles about this particular use case. I'm talking more about a use case where you have several hundred word press installs, odd collections of php4-era legacy sites and newer sites, none with any kind of load -- double digit visitation in a day with some of the more popular sites maybe breaking into three digits. Some built by us, some built by freelancers, some built by who knows who in some bygone era. Essentially a shared-hosting server where you would throw WHM/Cpanel on and feed out accounts to this or that person. I can see having lots of vpses useful in terms of having a massive mix of incompatible configurations. I think every year we shed a couple sites here or there spinning off onto their own cheap vpses because they don't work after a particular update and don't have any funding to be fixed. It would be interesting to replace handling shared-hosting with lots of VPses in a variety of configurations provided they could be managed efficiently but I don't know how -- or how web-dev shops who talk about making use of these tools are doing so...
Come back when it's got PHPStorm's refactoring tools, then I'll think about it. ;)
That's why I said it was a code editor, not an IDE =) It's a different category, apples and oranges thing =)
I'll just note here that vim has *both* tabs and a list of buffers.
Yes, sorry. Should have said current head of PHP 7 branch.
It is ok to do like you say but the code can be simplified: public function myMethod($param1, $param2, AwesomeInterface $interface = null) { $interface = $interface ?: new AwesomeInterfaceImplementation; }
&gt; For example, you created the FlockMigrator class. If I wanted to move a flock from one customer to the next, would it really be necessary to have a separate class to do this? That depends. I'd like to emphasize that most of what I'm going to say below (and have said above) are largely my *opinions* on SOLID. I've formed these types of opinions after having spent quite a lot of time trying to be as SOLID in PHP as possible. I've written code that is very loosely coupled and SOLID and also piles of spaghetti that work awesome and still run to this day. In my example, migrating a flock required a truck and doing some shipping. The premise of the SRP (Single Object Responsibility Principle) is that a class should be responsible for just one thing. This is also the reason there is a separate Flock and FlockRepository. A Flock is just a dumb object (entity or data object or model or whatever you might call it) and that should be its only purpose. Writing and reading to/from the database is outside the scope of what a Flock should do. The Repository has the responsibility of reading and writing to the database and loading Flock objects as a result. Loading and shipping a truck is outside the scope of what a Flock or Repository should do, hence you end up with a FlockMigrator that accepts the Truck and Repository and does what it does. It's necessary because it is performing logic that doesn't belong in any of the existing objects, it's beyond their responsibility. Generally, the Migrator would be considered a higher level service than the others. It incorporates low level objects and applies some logic on top of them. In the case you describe it's entirely possible that moving a flock just involves changing $flock-&gt;customer_id from X to Y and then persisting it somewhere, which is entirely within the scope of the Flock/Repository. In that scenario there is no need for a separate FlockMigrator and it would probably be a useless abstraction for most scenarios. There are other strategies like event driven programming whereby you would have a command that fires off an event every time the customer id for a flock is updated and you just handle that with whatever you need, but I digress... &gt; Or would it just be better suited in the Flock class? Or is this the whole point of SOLID? The whole point of SOLID is to make your code easy to isolate and test. As a side affect, it helps you think about your code in very useful ways. Paring things down to their individual parts in a SOLID fashion quite often increases the number of files (and some would argue complexity) of your application, although generally you end up with the same amount of code. It's just organized differently and in my experience, much easier to maintain and extend and reuse throughout your app. There is so much to discuss on this topic, so so much, that I've started drafting a blog post explaining a bunch of it but it's giant and I have no idea when it will be released. EDIT: Addendum. &gt; I think I understand SOLID now and how to implement it in the real world Google around for Domain Driven design and do a little research. I've mostly just been focused on SRP above, but Inversion of Control / Dependency Injection are also extremely important. After you create all these little objects, the question quickly becomes - how do you wire them together? Which part of your app is responsible for that? No time to delve into that right now but have a Google, there's a ton of resources out there.
I use it for command line stuff, but don't like programming in it.
&gt; rather than communicating with people like profession(al)s That phrase sucks. Whenever I hear it, I always interpret it as "Someone did something I didn't agree with, but I can't actually express a legitimate reason why they shouldn't do that." e.g. Programmer who never has any customer contact doesn't wear a suit to work - oh how unprofessional. Someone has their job outsourced, can't be arsed to fly out to Bumfuck Nowhere to train the new people how to do his job - oh how unprofessional. Somebody posted an open-letter in a place where other people could see it rather than posting it to the PHP-FIG google group, where it could be either ignored or shouted down - oh how unprofessional. If you have a legitimate reason to disapprove of someones actions you should be able to express it a lot more clearly than just calling them 'unprofessional'. 
Programmers all have Aspergers. Your humor is not welcome here.
I take exception to two things here. Firstly, you can't possibly say "You are simply wrong". We know there are multiple ways to achieve a goal. Secondly: &gt; taking the group hostage and dumping drama on us rather than communicating with people like professions I don't think he's done either. He's been communicating with me like a professional, but that wasn't enough. I had a really hard time explaining the benefits of the strong item for long as he was tearing my usual arguments apart. Pretty much every benefit you've listed could be taken care of with multiple smaller interfaces. That in itself means that your first comment of ircmaxell being "Simply wrong" because he has another approach is patently false in itself. They could both work, and one would be easier to standardise than the other. Where I disagree with Anthony's approach here was in providing a lack of technical details and examples, which hopefully he'll remedy shortly. It sounds like YetAnotherCacheProposal (of which we've suffered through many), but it's a little more thought out than any I have seen before. Let him explain himself a little better. 
Adding to what reinink said, it's also worth noting that period was only brought over a day ago. :)
TOTALLY. We only recently switched to using Jekyll for documentation, making this process a whole lot easier. This is on my to-do list, but to help remind myself, I've created an [issue](https://github.com/thephpleague/theme.thephpleague.com/issues/5) for this.
[PHP Super Best Friends Club](http://villains.wikia.com/wiki/Super_Adventure_Club) It's quite hard to take any of this seriously. No matter what is said once names with these types of adjectives are established, it becomes a problem to describe it as humble and is probably why it is looked at as egotistical.
Weird, so it's *people* who are joining the league? The state of my projects couldn't care any less about *who* these people are. Only the quality of their projects. Why aren't **projects** what are accepted into the league? Or maybe they are, and I'll just shut up. Man, I'm just feeding the standard PHP barkfest now aren't I?
Really? You read a name like that and think of it as anything but tongue-in-cheek and ridiculous?
Namespacing is easily solved as a layer sitting on *top* of the cache, rather than at the same level, though. They're just keys as far as the cache interface is concerned. Why complicate things by making it aware of namespacing? Nothing about stampede protection is unique to a strong item design. Locking mechanisms are easily handled in your application. After all, stampeding is an application problem - not a cache problem. Race conditions between existence checks and retrieval are easily avoidable, as well, by not using existence checks. Retrieve, and handle the miss if necessary. I've never seen a scenario where existence checks were necessary. That's not to say that there aren't any, mind you, but we're certainly talking about the 1% scenarios either way, no? I don't know what state/metadata we're talking about with respect to cache items, so I can't really opine on that point, but I will say that this seems like probably another 1% scenario. Generally speaking, I think all of these problems are valid, but /u/ircmaxell is right about trying to solve all the things. I think we need to take a more layered approach to designing these interfaces. Abstracting the drivers seems like a good first step, base layer to start with that everyone could probably agree on. Once that's out of the way, we could have separate proposals for interfaces to build upon that base layer and address some of the lesser-used or higher-level problems.
&gt; The semantics here is that they are both considered in PHP type hinting. the syntax is completely inconsistent between the two. You are right the difference is semantics between parameters and function return types, But those points are absolutely meaningless to syntax consistency. If the syntax was the same but means different things that would actually be *bad*, not more consistent.
*$this-&gt;interface 
Actually I guess the next survivor was me taking a raft off the island before getting banned =)
You might be interested at looking into this feature I [added to PHP-DI 4.2](http://php-di.org/news/10-php-di-4-2-released.html) a few months ago: `Container::call()`. With it, you could call your method like this: $callable = [$this, 'someGreatMethod']; $container-&gt;call($callable, [ 'param1' =&gt; $paramA, 'param2' =&gt; $paramB, ]); And the dependency not set in the parameters array would be resolved by the container. Now you don't want to inject your container inside your classes obviously, so instead you can inject the **`DI\InvokerInterface`**. In the container config, this interface is bound to the container so behind the scenes it's really the container that will be injected, but since you just use the interface then that's not a problem, you are decoupled. You can read the whole documentation here: [PHP-DI Container features](http://php-di.org/doc/container.html). Of course, I do not recommend making that a pattern you would do everywhere, but it can be helpful in some situations.
Very welcome, and good luck!
I agree with you. Certainly sounds like they're accepting *people* instead of projects.
Seriously, all the drama on Twitter between these people is a bit embarrassing.
What is giving you this impression? Because that is certainly not the intension. Our website even [states](http://thephpleague.com/#contribute): &gt; This group is about packages, and not about the people. To keep that clear - and to make sure people are joining for the right reasons - no members list will be posted, but we’ll let you know who is in charge of packages so you can poke them with feedback.
&gt; On the fly file saving. you don't need to Ctrl+S anymore Ugh - I could never work with an editor that did that...
It's totally projects. Did I say people in the article? As reinink points out, the website says quite the opposite.
Certainly not the case, take a look at the website. I found one ambiguous sentence in my blog which might have mislead a reader, so sorry about that.
Awesome! Good, I saw some other posts and an google group discussion where you "sponsored" another developer's application to the league. Perhaps all of that was tongue in cheek and I have become no less oblivious to all that surrounds me over the years. Thanks for doing what you do and encouraging folks to "just write code the best we can"
Sweet, got super confused when I found this [discussion](https://groups.google.com/forum/#!topic/php-fig/Toukmt2jkNk%5B1-25-false%5D) but now I get it. So awesome, I'm all about this. (though likely very very far from contributing)
Oh no no. I sponsored other peoples application to the **FIG**. Yeah, this is so much less about the ego of whos in the elite circle of something something, and more about providing a community where we just get on and build stuff as well as we can. The fact that any of that is contended by _anyone_ in the community boggles me mind.
It was more about [this thread](https://groups.google.com/forum/#!topic/php-fig/Toukmt2jkNk[1-25-false]) than your blog post.
Now for FIG it makes sense. How did I confuse that? Doesn't matter, very typical for me. That's SPECIFICALLY why I was initially worried that the league was accepting individuals, because people would never cease bitching about that. You can't bitch (as much) about a collection of solid projects. ^^^^Disclaimer: ^^^^I ^^^^realize ^^^^people ^^^^will ^^^^bitch ^^^^about ^^^^anything
I have to agree with 2upmedia, but I'm a bit biased, since I work for Zend. :-) Most of my customers over the last two years have been iSeries customers. 2upmedia mentioned MySQL. A supported MySQL is available on iSeries (called ZendDBi): http://files.zend.com/help/Zend-Server-IBMi/zend-server.htm#i5_zenddbi_installation.htm You can install it during the installation of Zend Server, or later. The "add-on" to run PHP on the iSeries is Zend Server itself. If you want to connect a Windows or Linux machine running PHP to DB2 on the iSeries without ODBC, and thus take full advantage of DB2 in your Windows/Linux-based application, you would get a product from IBM called "DB2 Connect" (not to be confused with the db2_connect() function). Naturally, that product would not be needed if you're running PHP on the IBM directly. You can get a free trial period of DB2 Connect and do some benchmarking with your own applications: http://www-03.ibm.com/software/products/en/db2connect-pe http://www-03.ibm.com/software/products/en/db2connect-ee Alan Seiden has a great presentation on DB2 best practices on his site. I, too, work with Alan, and can vouch for his integrity and knowledge. The XML Toolkit allows your PHP application to call RPG/COBOL on the iSeries, allowing you to leverage existing programs. You can always try out Zend Server Enterprise Edition for free for 30 days. It will not interfere with any existing instance of Apache (listens by default on a separate port). That way, you can see for yourself what works best for your organization. If you're currently pushing a LOT of data around the network, that would be an argument for running PHP on the iSeries. The degree to which your custom data must remain on your MSSQL server is a factor to consider. As you clearly understand, you have architectural decisions to make, and not just a product purchase decision. Many of our customers begin their modernization efforts by building intranet sites/applications with PHP, before building publicly-accessible sites. So, intranet app on the i is certainly viable! Hopefully, other iSeries users who run PHP apps will see your post and give you their perspectives. Best wishes!
Really what?
Why is it pathetic? And how is it any more pathetic than you coming over to /r/php to complain about a guy asking questions.
Also, the systemic down voting of anything i say is definitely not pathetic either.
Zed: "Hey, you know that build process that happens when a file changes? HAHAHAHAHAHA"
Sort of off topic but is there a popular sub reddit for discussions like this? 'Server managementy'?
It's easy to sound authoritative when one speaks in generalized statements. The fact that PHP can be found at every spectrum of the long tail, from massive sites like Facebook all the way to the untold millions of Wordpress SBS sites that "no one visits" would argue strongly against the idea that it is entirely missing from the startup and large application middle ground.
[citation needed]
No, I don't believe you have. First of all, in those years of development with PHP you've also gained years of general programming knowledge and experience that can be carried over to just about any other language. A wide range of experience is good (in fact, even if you intend to continue mainly developing PHP I would highly recommend you try other languages and learn about their particular ways of doing things - it will improve your (PHP) programming). Secondly, from my experience in the field I don't believe his statement. To take Facebook alone, if Facebook were only using PHP as a templating engine, why would they go so far as to write their own implementation to get speedups they needed and write a specification for the language, then go on to extend it with features they wanted or needed (in the form of Hack). Facebook developers have made a significant number of contributions both to the development of PHP and to its community over the years. You don't need to do all that for a templating engine. I don't believe the primary reason that web hosts don't upgrade their PHP versions is backwards compatibility issues or anything like that. It's lazyness and profit. A large number of these companies are out to make as much profit as possible as quickly as possible. You don't do that by employing enough sysops that they have enough time to do anything more than keep systems ticking over and throw in a replacement box when something dies. If you actually examined it, I be willing to bet you'd find that most of the large shared hosting providers keep themselves just ahead of the Wordpress minimum requirements (or at worst, slightly behind and start upgrades once the complaints start rolling in). To say that no one's using PHP, when I can go to pretty much any jobs site and find a new job in seconds is crazy. PHP is as strong today as it was 14 years ago when I first got into it, and I wouldn't bet on it losing significant share in the next 10 years either.
I've got the occasion to use 2 TLEP (CSV and URL), and they're pretty good and well documented. A pleasure to work with ! I always told myself that I would one day write an API that uses modern PHP standards and submit it to the league. If only I had an idea... !
Thank you for your thorough and well thought answer Sir
Puppet, chef, etc aren't provisioning systems, they are configuration managers.
PHP is a worse language than a lot of other languages like Python, Lua, Haskell, Clojure etc. But if there is one thing it does really well, it's generating web pages. There are some interesting projects in the PHP ecosystem, be it HHVM and HippyVM, Symfony, the Hoa libraries, ReactPHP, Guzzle with futures, Libphutil, Codeception etc. I don't think you have wasted something learning PHP, however it never hurts to look around and learn something new, of course.
Well I thought the same. But I tried it out and got used to it )
Why do people think python is better than PHP? Honest question
So this is vim + CtrlP, but without the wizard-level shit you can do in vim?
/r/sysadmin There's a lot of good stuff in there.
I'm starting to feel like Muhammad with all these down-votes. I must be a fudge packer. --edit-- I linked what I did because of the types of adjectives used. Both references make light of why I feel this type of name is not professional. The groups were made to be extravagant and ridiculous.
Didn't know this one existed. Thanks
the context makes the difference. parameter list vs on a functions. So the iconsistency still exists as they are both ways to enforce type, rather it's input or output. Look at most any other language out there, and you'll see the consistency between prefix and suffixed when specifying the type for any reason. 
I guess so. And you dont need to know C to write plugins ) 
I love Phinx. It's a great tool - very simple to configure, does one thing and does it very well. It's also incredibly fast. Highly recommended.
I think the term you're looking for is caching.
Why do some people prefer the color red over blue? Most languages these days are pretty similar in functionality. Sure, PHP's origins aren't as scientific as e.g. that of Python but in general 95% of what you can do with a Python or Ruby you can do with PHP just as well. For the most part it all comes down to a matter of taste. Most developers using a certain language don't even use the functionality that makes that language stand out from other languages. E.g. I wouldn't write a web server in PHP but I might use Python for that instead. It's only at such a specific level that one language can have a benefit over another language. If you're "gluing" stuff, it doesn't really matter. 
1 word: PornHub. It's running on PHP.
Python is a bit more sciency and has a vastly larger module ecosystem (just mentioning graphical toolkits for instance). There are more specific core and extensible complex data types. It has arguably the better object type system; contracts over constraints, functions are first class objects, so you can e.g. have unbound methods, which turns out to be more useful than OO coercion. (PHP is currently striving the opposite Java-esque direction). That being said, Python remains less useful for web apps. Strong typing is nice for a lot of things, but less for string and form processing as intended by PHPs dynamic typing. Many PHP frameworks got some questionable inspiration (pseudo MVC) from Python web frameworks (which there are a heap of). Still Python is largely hindered from gaining widespread use in this area because of the insistence on WSGI and the appserver model.
Eh, don't get confused by my question. I know some people prefer python over php. I get that. But why do people say that python is better, objectively?
Does not `$collection-&gt;find(['Names' =&gt; 'Joe'])` work?
I would consider two things in this case. I believe #1 answers your question, but #2 is valuable knowledge. Fair warning that this is quite lengthy. &amp;nbsp; 1. Create a function to display your links. This function will append an "active" class on the active page. 2. Output your nav using a recursive function. You write an array of links, it outputs HTML. Why? You're repeatedly producing the same markup. If you ever modify this markup, you now have to update it 30+ times. &amp;nbsp; ###1. Function Consider the following function. It takes link and displayText as parameters. The function produces the same markup for all links. function displaySiteLink($link, $displayText) { $output = '&lt;li class="%s"&gt;&lt;a href="%s"&gt;%s&lt;/a&gt;&lt;/li&gt;'; // NOTE: you may need to play with this logic to make it work the way you expect // If you're not familiar with the syntax below, this is a ternary operator. $class = ($_SERVER['PHP_SELF'] == $link) ? 'active' : ''; echo sprintf($output, $class, $link, $displayText); } Example: displaySiteLink('index.php', 'Home'); displaySiteLink('#', 'Home Users &lt;img src="images/darrow.png" width="10" height="6"/&gt; &lt;span&gt;&lt;img src="images/darrow-active.png" width="10" height="6" class="darrow-active-first-level"/&gt;&lt;/span&gt;'); I don't know about you, but I'm not a huge fan of the way this is presented. Having to pass HTML into function like that? Please, tell me there's a better way! &amp;nbsp; ###2. Recursive function Now, let's make it easier to update this HTML down the road. We're going to build two things - an array of all your nav items, and a recusrive function to loop through all of those items. There will appear to be more code overall, but the ease of use should make up for that. By analyzing your HTML, we know we will have to account for each of the following types of items: * Active class * URL * Link text * Multiple levels of nav * Some levels have a class on the &lt;ul /&gt; * Dropdown arrow image (darrow / rarrow) Let's create the array of your nav items to determine exactly what our new function will look like. $allNavItems = array( array( 'link' =&gt; 'index.php', 'text' =&gt; 'Home' ), array( 'link' =&gt; 'about.php', 'text' =&gt; 'About' ), array( 'link' =&gt; '#', 'text' =&gt; 'Home Users', 'arrow' =&gt; 'darrow', 'subs' =&gt; array( array( 'link' =&gt; '#', 'text' =&gt; 'About Home User Support' ), array( 'link' =&gt; '#', 'text' =&gt; 'Remote Support' ), array( 'link' =&gt; '#', 'text' =&gt; 'Pricing' ), array( 'link' =&gt; '#', 'text' =&gt; 'Hours and Location' ), array( 'link' =&gt; '#', 'text' =&gt; 'Promotions' ), array( 'link' =&gt; '#', 'text' =&gt; 'Protect Yourself', 'arrow' =&gt; 'rarrow', 'subs' =&gt; array( array( 'link' =&gt; '#', 'text' =&gt; 'Virus Removal Aftercare' ), array( 'link' =&gt; '#', 'text' =&gt; 'Downloads' ) ) ) ) ), array( 'link' =&gt; '#', 'text' =&gt; 'Business Users', 'arrow' =&gt; 'darrow', 'subs' =&gt; array( array( 'link' =&gt; '#', 'text' =&gt; 'About Net X Business' ), array( 'link' =&gt; '#', 'text' =&gt; 'Remote Support' ), array( 'link' =&gt; '#', 'text' =&gt; 'What We Support', 'arrow' =&gt; 'rarrow', 'subsClass' =&gt; 'third-level-support', 'subs' =&gt; array( array( 'link' =&gt; '#', 'text' =&gt; 'Hardware' ), array( 'link' =&gt; '#', 'text' =&gt; 'Software' ) ) ), array( 'link' =&gt; '#', 'text' =&gt; 'Services/Contracts', 'arrow' =&gt; 'rarrow', 'subsClass' =&gt; 'third-level-service', 'subs' =&gt; array( array( 'link' =&gt; '#', 'text' =&gt; 'Employee Benefits' ), array( 'link' =&gt; '#', 'text' =&gt; 'Consultations' ), array( 'link' =&gt; '#', 'text' =&gt; 'Client Acceptable Use Policy' ) ) ), array( 'link' =&gt; '#', 'text' =&gt; 'NetworkSecurity', 'arrow' =&gt; 'rarrow', 'subsClass' =&gt; 'third-level-network', 'subs' =&gt; array( array( 'link' =&gt; '#', 'text' =&gt; 'The Perfect Network' ), array( 'link' =&gt; '#', 'text' =&gt; 'Easy Fixes You Can Do' ) ) ), array( 'link' =&gt; '#', 'text' =&gt; 'RFP' ) ), ), array( 'link' =&gt; '#', 'text' =&gt; 'Web Users', 'arrow' =&gt; 'darrow', 'subs' =&gt; array( array( 'link' =&gt; '#', 'text' =&gt; 'About Net X Web' ), array( 'link' =&gt; '#', 'text' =&gt; 'Portfolio' ), array( 'link' =&gt; '#', 'text' =&gt; 'Social Media' ), array( 'link' =&gt; '#', 'text' =&gt; 'SEO' ) ) ), array( 'link' =&gt; '#', 'text' =&gt; 'Downloads' ), array( 'link' =&gt; '#', 'text' =&gt; 'Contact' ), ); Wow, that seems expansive, right? Take a second to review this array. Can you see the patterns? Now let's build the function. I've written comments throughout the function but if anything isn't clear, please ask! function displayAllSiteLinks($items, $defaultUlClass = '', $depth = 1) { // Convert numbers to verbose words. This stops at 9 levels. $mappedLevelNames = array(1 =&gt; 'first', 2 =&gt; 'second', 3 =&gt; 'third', 4 =&gt; 'fourth', 5 =&gt; 'fifth', 6 =&gt; 'sixth', 7 =&gt; 'seventh', 8 =&gt; 'eight', 9 =&gt; 'ninth'); $currentLevelClass = $mappedLevelNames[$depth].'-level'; // Create the class for the current level's UL if($defaultUlClass != '') $ulClass = $defaultUlClass; else $ulClass = $currentLevelClass; echo '&lt;ul class="'.$ulClass.'"&gt;'; // Loop through each item at the current level foreach($items as $item) { // Is it active? $activeClass = ($_SERVER['PHP_SELF'] == $item['link']) ? 'active' : ''; echo '&lt;li class="'.$activeClass.'"&gt;'; // display the link echo '&lt;a href="'.$item['link'].'"&gt;'.$item['text']; // Determine if there's an arrow and display it if so if(isset($item['arrow'])) { // darrow arrow size if($item['arrow'] == 'darrow') { $arrowWidth = 10; $arrowHeight = 6; } // rarrow arrow size elseif($item['arrow'] == 'rarrow') { $arrowWidth = 6; $arrowHeight = 9; } echo ' &lt;img src="images/'.$item['arrow'].'.png" width="'.$arrowWidth.'" height="'.$arrowHeight.'" class="'.$currentLevelClass.'-arrow-margin"/&gt;&lt;span&gt;&lt;img src="images/'.$item['arrow'].'-active.png" width="'.$arrowWidth.'" height="'.$arrowHeight.'" class="'.$item['arrow'].'-active-'.$currentLevelClass.'"/&gt;'; } // close link echo '&lt;/a&gt;'; // This is where the magic really happens. // If this item has sub-items, start this function all over! if(isset($item['subs'])) { // Now we want to parse the current item's subs ($items) // If the current item has a subsClass, it is $defaultUlClass // The depth should always be + 1 since we're going a level deeper displayAllSiteLinks($item['subs'], (isset($item['subsClass']) ? $item['subsClass'] : ''), $depth + 1); } echo '&lt;/li&gt;'; } echo '&lt;/ul&gt;'; } And that's it. Note that this function is not truly recursive becuase $mappedLevelNames only has support for nine levels. If you could replace "first" with "1" and so on, then this function could run for infinity and beyond! While there is more code involved, the maintenance factor is much lower! Hope this helps.
thanks, I'll try that! ps: damn semicolon!
I hit the 10k limit ([literally](https://i.imgur.com/jDae34t.png)) in my comment above - to display your nav bar you would simply write the following: &lt;nav&gt; &lt;?php displayAllSiteLinks($allNavItems); ?&gt; &lt;/nav&gt;
Thanks for posting this. Last night I was doing some planning for an app that I'm writing soon and migrations were a bit of a pain point in that process. (I'm avoiding Laravel for this project, but enjoy its migrations.) Haven't had a chance to research other tools yet, so this is a great help!
Uber made their first $25million on a PHP/CodeIgniter stack. #justsayin
Yeah what you are after is caching - either in PHP, or further upstream (e.g. Nginx cache, Varnish). Or, writing pages that render sub 200ms :) this doesn't have to be flat files :)
It's a really tough choice to make. On the one hand, it's incredibly easy to set up, and incredibly easy to customize with basic functionality. On the other hand, if you need to get down and dirty for those edge case scenarios in customization, it can be a *nightmare* to deal with. Once you start adding custom taxonomies to custom posts you lose all sense of an easily manageable relational database. Personally, I like to use WordPress for simple, WYSIWYG-managed CRUD projects - like a small online store, portfolio, etc. Beyond that, I would look elsewhere if it's something you will need to actively maintain.
Sorry, I should have said constructor *argument* promotion. Taken from the hack documentation on this feature, is this common boilerplate structure. You can see that these get really long, quite often. class Person { private string $name; private int $age; public function __construct(string $name, int $age) { $this-&gt;name = $name; $this-&gt;age = $age; } } The above can be replaced by this class Person { public function __construct(private string $name, private int $age) {} } It's a useful way to save a lot of cruft on objects. The list of object properties can get really long. It's only useful in specific cases - ie,they have to be called from something that constructs the object. 
Like everything worth its salt DB wise, phinx is built on PDO. Anything PDO can do, phinx can. So, you can easily write raw SQL that only does MySQL specific stuff and just run that. 
I've fought with Wordpress more times than I can count. It's fine when you're happy accepting its limitations, but when you want really custom stuff, it's a headache. Every time I start beating my head against the wall wondering why the URL structure is giving me 404s and unexpected matches/redirects, I think "Gee, I could have done this in 30 seconds in Laravel/Codeigniter/Cake/Symfony/Slim/Klein/Silex/FatFreeFramework...... IMO, Wordpress's biggest strength isn't the plugin ecosystem that will be an equal headache, it's the pre-built themes and theme frameworks you can buy for $30-40. Fancy front-end is more time consuming than most back-end modifications, so $30 can save you 20-30 hours of time. But again, you have to be willing to pick a theme and be happy with it. Once you want to customize it, good luck to you. At any rate, this has been my experience with Wordpress (either Wordpress itself, or all of the plugins you can use with it): http://i.imgur.com/RL1UjDr.png Notice how from my perspective, it looks like I can get there, but I'm unaware of the massive precipice that I'll run into just before I do get there. The relatively smooth 80% walk involves being able to leverage various configs and settings and plugins to get where I need to be, but then I (or the client) need something that the configs/settings CAN'T do, and now I have to wade through someone else's nasty, undocumented source code, which I probably can't extend (or if I can, it's a method 1,000 lines of out of control sadness).
But PHP would be so boring without it.
have you tried pagekit?
No I have not, but I like the look of it. Thanks for the heads up! Next project I have of this type I'll definitely give it a run.
I think this is the most important top level response if you're looking to use WP as a CMS. ACF and Custom Post Types let you add a lot of functionality without much effort to WordPress. Definitely look into these, they make WordPress life a lot easier.
Here's an unfortunate (and unfair) reality when it comes to PHP: All of the simple "brochure-ware" sites out there are often powered by Wordpress or Drupal or some CMS that takes all of the interest (and happiness) out of development, and those same CMSs are overused for more complex projects that they shouldn't be used for. PHP has a stigma that custom code is hard and expensive, and it's not. The more you get away from those brochure-ware sites and the bigger you go, the more you see PHP competing with Python/Java/Ruby and others. There's also this awkward painful zone where sites and applications are big enough and custom enough that they warrant a custom solution, but either the client or the development agency incorrectly chooses Wordpress or Drupal because they think "Oh you need to enter content? IT HAS TO BE WORDPRESS!". So you get the worst of both worlds: you have to use Wordpress, and you have to implement rather complex IA and business rules using it. At least with small brochure-ware sites you don't have to beat your head against a wall as much. Take this site for example: http://www.stylemepretty.com That site is built in Wordpress. If you take the time to click around, you start seeing all of the typical compromises that had to be made BECAUSE Wordpress was used: 1. Click on gallery, and the URI is /gallery. Ok, cool. That's simple and straight-forward 2. Now click on a gallery category (e.g. 'Bride'). The uri is now /gallery/subject/bride. Ok well now that's a bit awkward. "subject" is a superfluous slug, and it's there because it's likely a taxonomy term that HAS to be there because Wordpress dicks you over if you try and mess with its URI scheme. 3. Now click on a picture in that gallery, say the first one: http://www.stylemepretty.com/gallery/subject/bride/picture/2169636/ Ok, not bad I guess. 4. Now blow away the /subject/bride part of the URI: http://www.stylemepretty.com/gallery/picture/2169636/ Ok well it still works.... that's kind of strange. 5. Now replace what was /subject/bride with /subject/lkasdflkjasdkjlfalksf. Oh wait, it still works, and it even updates the bread crumb trail to the bogus taxonomy... 6. Click on the "View Full Gallery" link on the right, and you see http://www.stylemepretty.com/gallery/gallery/25662/. Why does "gallery" slug have to appear twice. 7. Click on Real Weddings in the navigation, and you'll see that the filtering isn't multi-faceted. You can't select Summer, Beach, Australia. 8. Click on Vendor Guide and you have to drill down - location and then category. But when you click on a category you're taken to /little-black-book and the header changes, so you're totally lost. So they likely tried to merge two separate sites and just failed... 9. All of the relationships between weddings, posts, galleries, and pictures I can promise you was way harder than it needed to be, and likely requires a lot of manual association entry in the backend, rather than automating it based on context. 10. They even have subdomain vendor spotlight pages: http://krista-a-jones-photography.stylemepretty.com/vendor-profile/ Is that even still wordpress at this point or are those manually created microsites? So that's a perfect example of a site that SHOULD have been built in a proper PHP framework, probably for an $80k-100k budget or so. But instead, some poor developers had to build it in Wordpress. This is all-too-common unfortunately. Decent-sized sites that require some proper architecture, UX, and IA planning, are shoehorned into Wordpress or Drupal because "Oh well you need a CMS". Because apparently complex IA, UX, and other business rules don't exist or don't matter... The REALITY is that building an authentication system and a simple CMS in say, Laravel, is 2-3 days worth of work, tops (less if you use a low-assumption package). It's negligible. And then you have a zero-assumption framework to build out the more complex business rules, IA, and UX that you often stumble over when you have to deal with Wordpress and Drupal. Sooooo, my point in all this, is that PHP is a misapplied tool. It's under-appreciated as a low-level tool for building custom mid-size sites, and CMSes built with PHP are overused and abused for scope they were never meant to be used for. "Oh yeah, just install some plugins and you'll be good".... You haven't wasted your time, but you may have to fight pretty hard to do actual PHP development :/
Totally true, that's why I haven't been a "sloppy" developer and I tried so hard to follow standards. For instance, Cakephp is a great tool. It forces you to follow conventions. Which is truly a pain in the ass in the beginning but man, is worth it. 
Cool, just the other day the boss was asking why we're still doing database migrations manually. I'm definitely going to look into this.
&gt; experience that can be carried over to just about any other language.. Cannot agree with this. The braindead way of doing things is unique to php and that experience wont do you much good in learning other languages. In fact, those things will make other languages look bad or less powerful to the novice user, and can prevent them from picking better practices. For eg, lack of some thing like php arrays can look like a missing feature in other language, and because the user is so used to doing things using php arrays, he will feel like having a hard time implementing stuff with lists or dictionaries. So the stuff you have been implementing with php arrays and references will be useless in other languages. Another example is code organization and namespacing. Again, the brain dead php way of doing this in unique to php so that your experience with organizing code in the PHP way wont help you in other languages. In fact, initially other options might look totally off to you, coming from php. You ll have to unlearn the stuff you learned when working with php, before you can really use what other better languages offer. So to OP, all is not lost. If you were working in php for a long, there is a good chance that you are very careful about the security issues with web applications, and with a bit of luck (depending on how you look at it), you ll have come across quite a few security issues and learned how to avoid them in the context of web applications. 
I've recently ditched Doctrine Migrations for Phinx and can say so far I'm not looking back. Doctrine Migrations dropped support for renaming columns, which forced me to Phinx as an alternative. Additionally, if you are using the php flunt schema interface provided, instead of writing up() and down() methods, you can simply write a change() method, and Phinx will do its best to produce a reversible alteration based on what is in the change(). So far, I have not had to hand write a down ... it just works.
I remember introducing database migrations for a project years ago. The other developers thought I was insane for even having the idea. Now database migrations are all the rage. Hrumph. I did it anyway. Major success.
I don't mind the arguing at all. I think it's good that they are all fighting for what they think is the best way to do something. What I hate is when it turns into name calling..
To be clear: anything that happens during 'runtime' (as in, when you call a method or function) can be caught. Inherent problems during 'compile time' such as return type declaration mismatches during inheritance are not catchable. This behavior exactly mimics parameter types. With that background, why is uncatchable fatal errors a bad thing?
An if/else chain of instanceof is worse than a switch statement on a type in my opinion. I am not sure why you feel that way is better; can you explain that? Perhaps I've missed some important concept in this regard.
I recently added Doctrine migrations to an existing project which I didn't need an ORM for. (To be honest, I might have tried Phinx if I'd heard of it then.) I posted a blog post about it here: http://jcfiala.net/blog/2014/08/21/using-doctrine-migrations-without-orm. 
&gt; It'd also be nice to see some sort of sane nullable, but we can live without it. The return type RFC actually links to a [Nullable Types RFC](https://wiki.php.net/rfc/nullable_typehints). If you are aware of that RFC and think it is insane, then please send me an email about it (it's off-topic here). The Nullable Types RFC is less complete than the return types RFC, which is why you have heard so little about it.
Ever since I shoved migrations into FuelPHP, then saw them turn up in Laravel, I've wished there was a quality framework agnostic package around. There were one or two others, but this looks drastically better than either. The hard part is: if you bundle a schema builder, then people complain they don't want that schema builder. If you _dont_ bundle one, then people complain about that too. I do much prefer the schema builder in Laravel to this one, but you can't install just their schema builder alone. If you could, these two would make a wonderful combination.
You realize you don't have to *actually* use doctrine to use its DBMigration component, right? You just have to have it in composer.
Very, but that's not really the point of the metaphor. In this case, "getting hit by a bus" can be no less severe than going on a two-week vacation, and more likely has to do with finding a new job. The point is that critical knowledge becomes unavailable for a period of time, or even disappears completely, and this severely hurts the employer -- often in ways they didn't realise.
Now if only the creator would at least provide input on Pull requests. The tool is really nice but far from mature. There are a lot of PRs waiting for any kind of response.
Sure, learn and use PHP, but also learn others. Learn a strongly typed language, and learn functional programming. Learn design patterns, learn how to make reusable code and learn a exotic and less familiar language. Dont do the cms-PHP thing, like start with Drupal and stick with it for the next 8 years. This will only damage you as a developer.
why? it depends on your needs.
I've been *trying* to introduce database migrations to my work for years now...still can't push it through. Nono, they would rather manage over 200 databases by hand, using PhpMyAdmin and no version control..yeaaaaahhh.
PhpStorm doesn't understand Laravel's schema builder for whatever reason..drives me mad.
Bad link
for the record, cakephp is an outdated, if not terrible, tool.
It has a test suite, that gets a save for later.
Throughout my career, I've found the best way to introduce new ideas is to lead by example. Sometimes you fail and learn from those mistakes, but when you're successful, you've demonstrated that you trust in your own engineering enough to implement it and ensure its success. From there, you can show the rest of your team how you accomplished a given task, and share the pros and cons. 200 databases by hand, though ... no thanks. I worked on a project where &gt; 7000 databases were managed through a custom database migration system, and it was really the only way to do it. What's your team afraid of?
It's useful cause it is a virtual machine. If you need multiple environments it is easy to take down or up the virtual machine you need. It is also super simple if you're in a team to share you Vagrant configs with your mates and all will use the same virtual environments with the same settings.
Sure, you can use Wordpress as your CMS, you can use it for whatever you want. As long as you are prepared to deal with constant brute force attacks, security vulnerabilities and so on. I'm working in major hosting company in Europe. I can not count how many automated attacks targeted for WP sites are performed daily. So sure, go for wordpress but get a pack of painkillers as it might give you a lot of headache later on.
Problem is for each project with same environment, i still need to redownload the same os..isnt that waste of time and hardisk space? is there any way to overcome such situation that i dont aware of?
Thanks everyone for your input. Your opinions are as mixed as my own! I shall try to weigh up the pros and cons you've offered, and will check out the plugins and alternatives you've suggested. Thank you all.
Vagrant is perfect for multiple projects. It doesn't download the entire OS again. There is one image. And that one is used multiple times (if you use the same settings). Try to setup Vagrant. The first time it downloads the entire OS based on your settings. Next environment is much faster to setup. It won't download it again, just re-use the image that is already downloaded. If you have multiple projects and you need to change just a tiny thing in your environment in one of them, Vagrant is great since you won't have to change the settings every time you switch between projects. Also, as stated earlier, if you collaborate over a project there's no need for thinking about how your environment is setup. Just give your friend your Vagrant conf. That's it :)
I like it because: 1. One server per project - project specific requirements don't cause spooky behaviour on other projects 2. I can develop on a machine which closely matches my production environment (not so much of a problem now that I use a mac for dev work, but I had been bitten while using windows to develop stuff that was ultimately deployed to a linux server) 3. Instructions/script for building my development server lives on git - so anyone else working on my project with me is guaranteed to have the same environment I have (cuts down on "works on my machine...")
Also, if you have the same environment, why not use the same box? Just use different folders
great to hear that..is there any tutorial on how to use vagrant with multiple project?
I wrote a shell script to do that some 20 years ago. It was originally for documentation "after the event" then realised that diff could be used against the output from two databases to see the differences summarised nicely. There may be a slightly more modern php script that can summarise a database in a normalised format that can be used to track changes. Edit: ADOdb library used to do this. You could give it instructions to say "make my database look like this" and it would work out and execute the statements to upgrade. It's a really old library, but there may be some ideas in it that could be used. 
im sorry, im such a new to vagrant thinggy..may i know how to do that?
nice insight..thx
You use it the same way as you use one Vagrant setup. Here's a simple tutorial. Just run $vagrant init+up in different folders if you need different virtual servers: https://docs.vagrantup.com/v2/getting-started/ Here is also on how Vagrant benefits you: https://docs.vagrantup.com/v2/why-vagrant/
You're worried about space? In the age of [$53 1tb drives](http://www.amazon.com/Seagate-Barracuda-3-5-Inch-Internal-ST1000DM003/dp/B005T3GRNW/ref=sr_1_2?s=pc&amp;ie=UTF8&amp;qid=1413533308&amp;sr=1-2&amp;keywords=1tb+hard+drive)?
a vagrant box is a virtual server. it can have its own ip, and you can set ssh and accounts up on it like any other linux box.
thanks you so much
Heh, in a similar situation. We connect to a dev database, which is basically a snapshot of the production database taken from time to time hosted on an AWS machine over a VPN connection. Slow as crap. Makes doing development slow as poop. On the flipside, ppl at my company do seem to be in favour of having a local, paired down database (which is a pre-requisite for db migrations), but the current database is in the order of hundreds of gigabytes in size and the schema is all over the place. It's more the case of that we know what we should be doing, but can't because previous bad decisions (done by ppl long gone).
So,it is not a headless browser like solution, am I correct? What is the point then? I would be happy to see a php implementation of one, like casperjs/phantomjs.
it promotes messy code and doesn't follow principles of good oop design. i've seen a couple of cakephp codebases and it was awful. it's just an old technology.
i realize is a for of caching, but, usually this is made in memory for page or bits of code. I'm intrested in this tehnique of creating a page snapshot, is there a distinct name of it or all call it "cache"? ps: dynamic content under 200ms? those pages should only be like hello &lt;user&gt; :) 
Yeah, it doesn't support JavaScript. But it is a browser in other respects: forwards/backwards, CSS selectors, redirection and cookie support. I've used it for a scraper project and it's pretty awesome. My only minor complaints is the docs are sparse, and you have to reach out to the Guzzle and/or Symfony Components docs to work out how to do something. Also using the Goutte.phar compressed version loses autocomplete in your IDE (at least in Netbeans anyway) which isn't great when you're stuck for which method to call. 
Hi, since I'm responsible for this ... inconsistency, I've added a cheat sheet page so help you with the package. Hope you'll like it http://period.thephpleague.com/api/
Is PHP a dynamic language? Is PHP typically built by a build system? By the time we've reached an unrecoverable/uncatchable error, PHP is already running bad code. There is no distinction of 'runnable version' or 'current source'. PHP pretty much gets the bad bits from being a non-compiled language, still having compile errors, and not having a good way for a developer to interact with them (even though they occur at runtime) A work-around is to write tests/unit tests/etc. Fortunately, fatal errors *usually* completely kill tests. Its a bit more annoying for a larger longer-running test suite: where the tests abrubtly end. (The short amount of debugging information, by default, doesn't help either). Thinking about how the unit tests should react to such errors may be a good start to how they should behave in general. tl;dr Should unit tests ever just abrubtly stop?
might be missing something - can this inspect a current database and give you a DSL-based starting point? Also, can it inspect domain models and build DSL changes based on that? These are what keep with me GORM so much, and would love to see those sorts of things in PHP, without all the heavyweight of Doctrine. FWIM, Doctrine doesn't generate DSL-based create/alter statements, just db-specific create/alter statements when you have it generate stuff.
One of the strengths and weaknesses of PHP is that is does a lot of magic under the hood, particularly with types and type casting. It's probably the greatest reason why I hate the language (I still use it daily at work). Unfortunately this means that you there are tons of edge cases where PHP silently fails. This is why you should never trust a variable to be a specific type and you should explicitly test rather than expect it to implicitly fail. Being implicit leads to bugs and security holes.
With PHP 5.5+, you may use http://php.net/manual/en/book.opcache.php instead since it's bundled with PHP (less headaches for versions and compatibility). However there isn't a local cache in OPCache, so you'll need an alternative (memcached or whatever).
I have really come to love [DBSteward](https://github.com/nkiraly/DBSteward) which allows you to spec your database in it's entirety and it can generate DDL updates from between versions. It solves many of the problems that seem to pop up when migrations happen piecemeal. Additionally, it makes much more sense to me to store the state of the schema at a given revision than all the changes that have ever happened to that shcema.
Downvote this and hope nobody sees it. "Well cause [apc is] an opcode cache that means it caches the compiled code, It is going to be included in PHP 6 and it is easy to configure." 
Whoever keeps posting Town Hall links has been getting them wrong for the last year. I'm sorry guys. http://phptownhall.com/blog/2014/10/16/episode-31-the-one-about-hot-dogs/
It's a bit shitty to complain that _massive_ projects with thousands of users don't move quite as quickly as a single developer smashing something together for a client in a few weeks. There will always be us on the bleeding edge, who've been using Composer/Whatever since it came out, and that trickle-down will always head to the larger products as and when they can. PyroCMS will have a stable release mostly switched to Composer components this November. Rejigging old CodeIgniter code and making it modern takes a damn lot of time. It's not like we didn't notice the updates in the community. :)
Totally outdated. Wrote more thant 4 years ago, when APC slated to integrate in PHP 6 (which is dead right now) ...
memcached ? Bad idea (50x slower) than shared memory system : XCache or shmop
Next time wait until Monday.
Perhaps you knew, but we have to realize that new folks are coming into programming (not just PHP) at an exponential rate. I have no problem with seeing a link to a quality package that I have already seen if it helps someone new! Maybe be a little more positively constructive next time? :(
Varnish is a page cache. Unlike opcode caches that work internally to make PHP faster by caching repeated bits of code, Varnish is an external cache that only sees whole pages (through a reverse proxy). It can greatly speed up performance for *anonymous* users (who all presumably see the same pages). However, there would be too much volatile, user-specific content to make the cache worth it for logged-in users.
That's a CSV no ? Unless I misunderstand what you're trying to do you can use league/csv for that http://csv.thephpleague.com/
It was expected ... 4 years ago :)
thx, is really useful for me 
Granted you hit that bottleneck yes, but in most cases memcached works just fine (you can even just use a local, non-clustered, memcached instance).
Why don't you use built-in functions to manipulate CSV files (it seems to be format of files you provided)? You can, of course, wrap it up in any class you want, but I don't see any profit in doing it just for an art.
No, named and positional parameters can't be mixed.
I added a smiley, how is that not positive ? I wasn't being rude or anything
please do
We'll be posting two more in this series over the next two weeks. Stay tuned to get your PHP + graph db learn on.
It's useful for replicating your production environment, or setting up development environments in your team. If you want something lighter, you can look into Docker -- lightweight linux containers.
As a followup: if one preaches reuse, but publishes duplication, then one has shown one's true colors. EDIT: See also "reuse" in [The Devil's Dictionary For Developers](http://paul-m-jones.com/archives/4724): &gt; **reuse:** Other people using my code. “I believe strongly in reuse; stop writing your own code and use mine.”
Everything you have done has helped immensely i really appreciate it. Very easy to follow with all of the comments and instructions. I just have one question. How does the active class work? for some reason the active class doesn't want to work in the view source code it has class="" for all of them but none are filled in with the class active when i go to that page.
For those of you on a Mac or linux box (or anything with bash): If you want to take vagrant for a spin (with an nginx + php-fpm install) on ubuntu 14.04 try my [simpleserversetup](https://github.com/Xeoncross/simpleserversetup) script. Just download (or git clone it) and then `$ vagrant up` in a terminal. 
Good point, I should just have done it the simple way. [Here is a gist](https://gist.github.com/Xeoncross/ef06d2e7f0ce65a88c6b) with an added strict/only mode.
Why not use the PHP version of array_key_exists ???
This is an insanely broad question. What are you really trying to ask? 
One: `array_key_exists` vs Many: `array_keys_exist`
Starting out as a freelancer with no experience you're only going to get small projects. Maybe your client has a small clothing business and they want a web store to sell out of, or maybe your client is a local restaurant that needs a website. They could be a band, local organization, etc that just need some sort of simple online presence. For these kinds of projects you client will not give you a requirement list like the ones you described. Your job is going to be to translate what the client says into a more technical set of requirements that you can work off of. Taking the web store example above, they'll probably need to be able to log in to an admin section to manage their products and check orders. They'll need to be able to send auto-emails to customers. You'll need to accept payments in some way. Customers will need to be able to log in the check on the status of their order. So you'll need a database obviously, you'll need to decide to use a framework/CMS or write everything from scratch, you'll need payment processing (which option to use? Paypal, Stripe, Authorize.net), you'll need some sort of user management and log ins, you'll need an admin dashboard. Lots of variables. Start working on your own small projects and then slowly move into freelance work. It's a long road. Good luck!
How about something simpler like: return count(array_intersect(array_keys($array), $req)) == count($req);
I would say the examples given are different than what I am describing. While it is very true that I regard Python and GNU as professional software (418 I'm a teapot has a serious purpose), the subtle difference between these and groups mentioned is where the joke lies. By appearance, Python, GNU, or the HTTP Specification do not come off as "extravagant or ridiculous". I would say this is because of the name not having adjectives in it that put a false sense (but a sense nonetheless) of immaturity. It also references that there's a club of PHP super best friends, which I feel describes how the developers view themselves rather than how the projects are defined. (Yes, I just said that I feel 'The League of Extraordinary Packages' is a better fit in this argument)
What everybody mentioned. + a few more things I would like to add: * Sandboxes your development environments. This is important especially when you are working on older projects that requires an older version of PHP or any other legacy services that could conflct with your other development environments. * You can simulate a multi-node architecture on your local machine easily. Just run each node as VMs, and let them talk to each other like they do in your production servers. Provisioning tools like Chef, Ansible, etc would come in really handy for this. 
Honestly, if you're new to development and requirements gathering then personally I'd advise you to first get experience with a competent team before going into freelancing. 90% of what you need isn't taught in the classroom and is instead taught by peers in real world development. If you begin freelancing now, you're only going to end up costing your clients more, as you're not going to ask the right questions and are going to end up doubling back too many times before you actually make the product they want.
It's the canonical link generated in the site that's to blame &lt;link rel="canonical" href="http://phptownhall.com//blog/2014/10/16/episode-31-the-one-about-hot-dogs/"&gt;
&gt;new folks are coming into programming (not just PHP) at an exponential rate. Exponential rate? I doubt it.
I'd just say it's not a black and white thing. Some developers build packages and release them on github / packagist just as a learning exercise for themselves. Want to build another router as a learning exercise? Go ahead! Want to put that up on packagist or github and let other people see it and critique it? Go ahead! Good job! Have fun! It's more of a problem when experienced developers who are already aware of pre-existing options decide to build, maintain and actively promote yet another router or what have you. Those efforts could likely be better spent contributing to pre-existing routers. And if pre-existing routers don't need improvement, something else probably does. What it comes down to is - if you're going to re-invent a wheel *and try to promote it or position it as a legit option for the community to rely on*, you should at least be able to make an argument as to why / how it is different, how it fills a previously unfilled niche, etc. "Lightweight" is probably not a compelling reason. Generally if someone is working on something that's truly "moving technology forward", they will be able to make such an argument. You allude to Laravel, but Laravel always strove for that terse / eloquent syntax, that focus on removing developer pain points. It was targeting (could even say *creating*) an entirely new niche within PHP. It had a legit motive. I think a lot of new-ish packages (not gonna name any names) fail to take this sort of thing into account, and that's where the general complaint against duplication comes from. EDIT: added that whole paragraph about laravel
Who are you talking about ?
There is no need for someone to have to justify handing over their hard work **for free**, or even promoting it. This kind of attitude is a disease.
Clients need full service... service. Not only do you have to build a full site from backend to frontend, you have to be able to find a hosting provider, set it up/configure it, deploy your site to it, set up a domain and/or change the DNS record to point to the server etc. If you want to freelance, you can't really be only front-end or only back-end. You need to do everything related to web development.
So meta.
i am trying to use if(isset($_GET['link']) &amp;&amp; $_GET['link'] == $item)
Eleventy seven people have joined PHP as new programmers since I started writing the beginning of this word itself.
You have to talk with the client to understand what he need(and not what he want) in order to setup a list like that.
I think we're in agreement. But for clarification, what can you get from Goutte? Well, some AJAX requests just use the response code to indicate something (200 = okay). Goutte can read that via the Guzzle client. Or, maybe a DELETE/PUT method is required. I've not done it, but I bet Guzzle can do that, and thus so can Goutte. Or JSON is returned, which as you say is rendered by JS (e.g. using string concatentation or a templating lib). That can be fed into `json_decode()` and then used in PHP. Goutte can fetch it. I agree that grabbing the _rendered result_ does require JS, but the point I'm making is that background fetches via AJAX do not necessarily need JS to fetch the data of interest.
Insightful and well-written article. Thanks in advance for making me save some of my time :)
I should really look at docker. Vagrant is nice but eats up a lot of disk space. 
I base the use of "exponential rate" on the following post by Robert Martin, not any primary research or primary statistical analysis. Excuse my possible mis-step! An interesting read nonetheless that brings up an important issue in educating new programmers as they enter the field! http://blog.cleancoder.com/uncle-bob/2014/06/20/MyLawn.html
Freelance here, doing only back-end. I sub-contract for web agencies. So yes, you can do only one thing. (and do it better than others btw) edit: ahah someone disagreed and downvoted all my posts. Lame.
&gt;How did other languages solved this problem? If it's even possible. I mean, you can go on npmjs.org and search for "ajax" or some other extremely common thing. There's a billion options there too, and you'd never sift through them all to decide what you were going to use. You'd google it, you'd look at github activity, you'd check out its website / documentation, you'd look for recommendations and peoples' experiences with various options on StackOverflow and the like. I'd say we should expect packagist to be the same way. Its greatest function is not its "search" feature but the fact that it lets you easily manage the dependencies you *do* choose to install. Which isn't to say that the search is useless - it often comes in handy for me. Just that it's not intended to be the end all be all of finding / choosing a package.
I don't follow you.
Millions of people tell me I exaggerate.
Sub-contracting is B2B, freelancing is B2C. Clients almost always need full service, when it's B2C, you must provide that full service. When it's B2B, the company you are being sub-contracted by is providing that full service. Not everyone is going to be able to get by exclusively B2B sub-contracting, you almost always have to supplement your sub-contracting income with real freelancing (finding and managing your own B2C relationships), which means you need to be able to offer full service. Bottom-line for the OP: don't get into freelancing if you don't have the chops to do full service B2C work, because you will need those when there's no sub-contracting work available.
Make sure that you're using `$_GET['link'] == $item['link']`, since $item is an array. If that doesn't fix your issue, let me know.
Bit dated (PHP7 adds an AST layer), but my blog post from 2008 should get you primed at least. http://blog.golemon.com/2008/01/understanding-opcodes.html
[Steve Corona](http://stevecorona.com/about-steve/) has a good write up about some of the different settings. You can find that [here](http://us1.campaign-archive2.com/?u=ba9c5a596f88fa86026dd89a2&amp;id=e828c52fd6&amp;e=7b6037540b)
It doesn't work that way. $array = ['one' =&gt; 1, 'two' =&gt; 2, 'three' =&gt; 3, 'four' =&gt; 4]; $yourArray = ['one', 'two']; var_dump(in_array($yourArray, array_keys($array))); // boolean false
Thanks, I'll definitely look over this.
+1 avatar
Doesn't seem to like it at all. It makes the navigation bar go away completely
Holy crap dude. I watched some of your videos on youtube a while ago. You're like a fucking legend in my eyes. I had no idea you browsed reddit. This is so cool xD
Huh...well look at that...never even noticed he was a mod. -.-
I'm not so sure he enjoys programming.
That should be on the wikiquote.org!
All the references on Wikiquotes have citations from officialish sources. Mine is just something I recall him saying when we worked at Yahoo a few years ago.
You know, I get the feeling he is a terrible programmer...
I understand your point but since when is freelancing only B2C? Moreover, I really think anyone doing mostly B2C as a freelance in web dev will have a very, very hard time. You need professionnal clients as much as you need professionnal colleagues and one person can't cover all the skills involved.
It's a shame such a gem is missing ;) Maybe someone can add it referencing to this thread.
You're making bad assumptions about what OS is all about. It *can* foster those kinds of things, and very often does, but it does not *have to*. And frowning upon contributions that don't is horrible. Open source software is a gift. If it helps, think of projects as Christmas presents. Are you going to yell at your grandmother for giving you the 3rd identical pair of knitted socks in as many Christmases? I would hope not. Is it redundant? Maybe. Is it useless? No. Is it rude and uncalled for to do anything but show utmost gratitude to her for dedicating her time and resources into making something that she thought might be helpful in some way? **Yep.**
Weird. Is Reddit parsing that out and using it as the link instead of the URL the poster is putting in? Fixed the source either way. It'll work for the next episode.
Clearly in response to my "You dont need to build yet another router thats exactly the same as every other router" conversations on Twitter, ignoring the nuance that if your product is actually at all different then you _should_ build it. If you are making something that is drastically different to the other options, in performance, API, functionality, or the _only_ version that you could work with has a license incompatible with your project/business then build away. If you are just releasing something that is completely identical then you are wasting time you could be spending building something the community actually needs. If you are building it to learn, then for the love of god do not release that to the outside world. It's probably going to fall apart under pressure. --I don't think I like somebody who is admittedly not a programmer, trying to tell programmers how things works in the world of programming.-- **Update:** Sorry, I thought I'd heard him saying he was more of a businessman than a programmer. This chap built all of HelpSpot apparently. Seems like I was wrong about that.
Could you post that code? (You may have to paste it into a third-party site like http://pastie.org/)
But he's probably still better than you. :) Edit:// [For you who are downvoting me.](https://twitter.com/rasmus/status/12481790397)
You're right. In example in the docs they search for another array that is an element of haystack. $a = array(array('p', 'h'), array('p', 'r'), 'o'); if (in_array(array('p', 'h'), $a)) { echo "'ph' was found\n"; }
Ha my fault - I think Feedly must muck up the links or something. It seems to happen EVERY time.
 // Loop through each item at the current level foreach($items as $item) { //Start of IF for active links not working. if(isset($_GET['link']) &amp;&amp; $_GET['link'] == $item['link']) { // Is it active? $activeClass = ($_SERVER['PHP_SELF'] == $item['link']) ? 'active' : ''; echo '&lt;li class="'.$activeClass.'"&gt;'; } else { // display the link echo '&lt;a href="'.$item['link'].'"&gt;'.$item['text']; } 
I think the point is not B2C or B2B because pretty much any high value work worth doing is for a business of some sort. The difference is simply working for a few agencies who give you a spec and will always pay vs selling to new clients, requirements gathering, resource scheduling and taking all the risk of sub contracting to other developers and having your dick stung when a client doesn't pay .
I've got one that has 15-20,000 databases in a multitenancy setup. Each one has a config table with a row that keeps track of the "version", and on every page load we run queries checking if the version in the database matches the version we want it to be. If not, we run migrations using a switch statement. I don't like it, but considering that code was put into play over a decade ago, it's fairly intelligent. This is what I'm referring to: // query that gets version here $currentVersion = 2.00; switch($currentVersion) { case 2.00: require_once 'migrate-2.01.php'; case 2.01: require_once 'migrate-2.02.php'; case 2.02: // ... etc. } I like to consider it old school cool. It's classic. It's vintage. It gets the job done. It annoyingly adds an extra query on _every_ page load. But... it's classic and vintage. (We're in the planning stages of rewriting this app.)
I think OS software is a lot different from a Christmas present, for a lot of reasons that I don't have time to articulate. Let's just say, OS devs aren't my grandma and I can always use a new pair of knitted socks. You can't clone or fork a knitted sock, and there are scant consequences to implementing the wrong knitted sock on the production environment that is your foot. So I can only really feel gratitude toward the open source projects that I and my clients actually benefit from. I can really only benefit from them if they offer something that wasn't already there. Even if I don't directly *use* a package, if it fills a new niche and improves the php ecosystem, I benefit indirectly from that and can feel gratitude for it as well. But if someone releases something completely redundant, it may offer nothing new except their personal vendor namespace. I don't see any reason to be grateful for that. I actually tend to see it more as an ego-stroking or self-promotional exercise on the developer's part. Resume padding. Either that, or they're unaware of all the pre-existing options, which tells me that they didn't do their homework or just aren't very experienced. In that case it means they aren't likely to be producing a high quality package on their own and they could have *greatly personally benefited* by joining an existing high quality project and learning from that team. Again, educational exercises are very different. Somebody once said that all PHP devs need to build a framework once, and I pretty much agree with the spirit of that.
Proofread, dude! :-/
Eep! Database changes while the database is being used AND done during request handling! How does the system handle concurrency? Please tell me the upgrade at least locks the operation.
Sure, it's two very different jobs and the later is more complicated, I don't deny that. What I'm trying to say is that you can be a freelance and have a niche, on contrary to what dadkab0ns was saying. It usually works out better than being the jack of all trades. The semantic argument on "what's a freelance" is a bit doubtful in my opinion.
Yeah, just setup your synced folders to be the same folder with your project files in it. (e.g., I have a Dev folder and inside there I have all of my project folders. Then I sync that Dev folder to /home/vagrant/Dev) I would highly recommend getting Vagrant up and running because it is a great resource for learning everything about Vagrant and how and why it does what it does.
option 2 did make the navigation go back to normal but the active class is still not showing up for the page i'm on. is it because my active class is named nav ul li.active a or could it be something else i am overlooking
&gt; Database changes while the database is being used Yep. &amp;nbsp; &gt; AND done during request handling! Yep... Imagine how awesomesauce load times can be. At a quick glance right now, I'm seeing some tenants (subdomains) that haven't been accessed in 5-6 years. &amp;nbsp; &gt; How does the system handle concurrency? Oh come on, you already knew the answer to this. Poorly! &amp;nbsp; &gt; Please tell me the upgrade at least locks the operation. Lol. &amp;nbsp; Keep in mind that this was originally written in 2004 as a PHP4/MySQL 4.1 app. Times were different then. :) It's been upgraded since but most of it is hacks on top of workarounds on top of patches. I have a branch for MySQL 5.6 compat right now. After that, I plan on tackling this whole migration issue!
Nah, that CSS selector will work. I did overlook something though. We're checking if `$_GET['link']` is equal to `$item['link']`, but I don't think this will ever happen. I'm guessing in your nav array, the link key is something like... "index.php?link=pricing", but the GET var is only going to be "pricing." They will never match! Ugh. You may have to play around with that logic a bit to make it function the way you want. One option is to parse the URL using `parse_url` and `parse_str`. You could also search the current url for a match using `stristr`, `strpos`, `preg_match`, etc.
Given that [this was you a month ago](http://www.reddit.com/r/learnprogramming/comments/2f1scm/learn_php_or_ruby_on_rails/) I wouldn't even be concerned with freelance right now. You're almost certainly not ready, and if you try to do anything but the most basic work you'll likely design a nightmare. Build projects for yourself first. Find groups that include experienced programmers but welcome novices. Get experienced programmers to critique things you do. keep learning.
Hear, hear.
Close! I would have been 11, and that's when I started using PHP too. :) I hated using ADODB, that was no fun at all. I remember that well. I remember hacking around with phpBB and Postnuke too. Crazy days. &gt; I think I'm allowed to at least state my opinion. Absolutely! But when you opinion is based around a misunderstanding of other peoples opinions, you have to expect them to try pointing out thats not at all what they meant. You helped support Laravel, and that was a lot of what got it from "YetAnotherFramework" to being something incredibly popular. Taylor's fresh approach to PHP using 5.3 features, without the brain legacy of how shit used to work in PHP 4-5.2 world meant it had a very fresh API. I'm sure his ASP.net background helped make it ever more unique. That is the sort of thing that helps innovation. But, again, that was not at all what I was talking about. Your blog suggests I am against innovation, which was very much either missing the point, or focusing on the wrong end of the conversation. I'm not sure how much time you spend working with Rails, Python, Node, etc but if you are familiar you'd know that there are _amazing_ components that solve amazing problems. Problems that we in the PHP community have to solve ourselves over and over, because people spent too much time rebuilding near-identical routers, DiC containers and god damn ORMs. When we get past these basics and move onto more interesting problems, PHP can move forward drastically. This is all coming from the same place as my love for framework agnostic code. Us all sitting around re-building codeigniter-oauth2, fuel-oauth2 and laravel-oauth2 was a massive waste of time. If I had just made oauth2 in the first place, Taylor would not have had to port that laravel-oauth2 bundle over to Laravel 3, and he could have spent more time making your software better. THAT is what I've been talking about. 
Lol, forgot to renew domain? Link is dead.
I use Node every day, I see loads of crap packages in there. Use Node for what it's good at, great. If anything like with what Laravel 5 is doing Node is getting pulled in and utilized rather than trying to build Node like stuff at all in PHP. Great. But saying people shouldn't build another X just because is silly. They should build whatever they want and some of it will rise up. Some of it will spur new things. When Taylor built Eloquent there were loads of other ORMs yet I remember you complaining to him that you wanted to use it outside of Laravel. So you found value in it right? If he had just said ah screw it this is just another ORM then we wouldn't have it. Very little code out there is a true clone. If you look at all the ORMs they'll all have slightly different API's etc. So let the market figure it out, no reason to worry about people building too much of that stuff and every once in a while something great pops up.
I can't speak for anyone else, but from all the languages I have used (Python, Ruby, JavaScript (Node.js), etc, I always come back to PHP. I love it, all it's quirks and everything. I enjoy PHP. If it wasn't for him, I wouldn't probably even be a programmer let alone the lead engineer of an up-and-coming company doing what I enjoy doing.
I suppose that depends on your definition of good code. I've personally worked with him (at WePay, pretty easily confirmed if you care with some googling), and his code is very much optimized for execution speed over pretty much anything else. Whether that's good or bad depends on what you're doing - often times, you'll care more about testability, extensibility, developer accessibility, or something else.
=) I agree re: 'better expressed' and I hope I didn't come off as "yell-y". The tone of many of his posts are **perceived** negative and I was just trying to be helpful in recognizing that his phrasing could be improved. I think he tries to be helpful in some cases, but he also comes across not in the best light. Especially when he posts things like: * http://i.imgur.com/Raq7cfB.jpg * http://www.reddit.com/r/PHP/comments/2iwzzu/phpixie_logo_is_not_sexist_shocking_proof/ * http://www.reddit.com/r/PHP/comments/2i95rx/warning_laravel_42_deletes_the_whole_friggin/cl070pe * http://www.reddit.com/user/dracony Text is a hard medium for communication in some cases. I think there's a lot of perceived negativity where none is intended as well. I'll try to be more recognizing of that or simply just keep myself from responding.
I just don't think that's the kind of thing that happens by telling people to make it happen. It happens when a lot of great devs spend a lot of time writing code in your language. When companies invest in that language and have devs working on hard problems that need new solutions in that language. That is finally happening with PHP again. So I think the fact that me (and many others) are "confused" by what you're saying means you should probably think about how you're saying it.
But to you - like Iain, I have to explain that I'm not currently - or hoping to - stifle anyone. What I've been talking about (and not had a chance to blog about yet) is more of a call for people to put aside ego, stop the constant NIH and collaborate. If you like a router but want to add some more features, send a pull request instead of just cloning it. If the author doesn't want your help then go ahead and fork it under a new name, but dont make that your go-to action. I'm not concerned about the internet being full of github repositories. I feel saddened that the potential manpower available in the PHP community, it's not being put to anywhere near its full potential. And it makes me even more sad that people can't understand that this is not me trying to tell people to stop coding things for fun, trying to learn or putting a choke-hold on innovation. I don't get how those things are the same. :-/
Okay I see what you're getting at and I agree. I had recently done the same thing. I had built a framework using outside packages and it was fun, learned frameworks a little better. But I have since archived it all and instead will be using others packages to build things instead.
But that's not why people build their own routers. You can't discover that new awesome API if you just send in a pull request on an existing router. That's the entire point. Certainly if you have more to add to an existing project send a pull request. But if you want to build your own thing that mixes in some of your own ideas you often don't have a choice but to rebuild. Hence, progress.
Lots of cs programs have one or two courses focused on just web development. Now its mostly python but I could see it being 10 years ago.
Do you have opcache.validate_timestamps = 0 On your windows system? If not, are the config files identical on the servers? If they are can you paste your config?
Right, if you think of something super awesome and new then build it out. The point is there isnt anything much so awesome and new that you can add to a router that the other 500+ routers haven't done. Nikita Poppov came up with something amazing and new and he built it. Good lad. Totally original. Not all of the 500 are. Can't you see im not proposing absolute rules, just suggesting that people think about if they really need to release a package which is so incredibly similar to loads of other existing packages?
Urgh, yeah. I'm new here, but Reddit appears sometimes to be as unreconstructed as YouTube comments. I may yet hot-foot it back to Stack Overflow... I miss being able to edit other people's posts `;=)`.
I'm saying you don't know until you build it.
Also, router is of course the very best example for your case. Pretty much any other PHP package out there dealing with just about anything else is much more open territory.
He's special because his approach is what made PHP what it is today, a language that gets the job done instead of the over-engineered crap that try to replace it from time to time. 
No, I have not set that option neither on Windows nor on Linux. So I guess its using the default. My configuration in windows is this. Note that opcache is currently disabled ;zend_extension = "php_opcache.dll" opcache.memory_consumption=32 opcache.interned_strings_buffer=8 opcache.max_accelerated_files=500 opcache.revalidate_freq=60 opcache.fast_shutdown=1 opcache.enable_cli=0 EDIT: I just noticed it... I'm an idiot. It's probably the revalidate_freq directive. I must have missed that it was set to "2" in the linux server
Ever seen how many currency packages there are?
You come up with some great API ideas by using components too.
Thanks! I never know what to do with praise, but I really appreciate your kind words. It **has** to be noted that /u/SaraMG (to whom you just responded) is one of *my* primary mentors on internals, HHVM/Hack, C, and PHP. Specifically, she helped me a *ton* to figure out exactly what the heck half the output of VLD meant (after Derick the author wasn't even able to recall :) So uhm, shoulders of giants and all that?
&gt; If you are building it to learn, then for the love of god do not release that to the outside world. It's probably going to fall apart under pressure. This please! Hosting it on GitHub is OK, it makes you learn with CI and stuff. But don't try to spread it through Reddit or whatever. Or at least don't get offended when people ask you "Why?".
[Burn it to the ground](https://www.youtube.com/watch?v=CfTsvWTtoiQ#t=52s). Thanks for sharing that war story!
I was one of the first dissenters in the [twitter spat](https://twitter.com/troypavlek/status/520398965326360576), and while I'll conceed that Phil et al made some decent points, I'm still unconvinced. I suspect that this is just one of those things where all parties end agreeing to disagree, but I feel that it's probably useful to put my thoughts out in longform and at least try. My chief argument, and what I still believe is the *learning* aspect. It's the reason that all first-year University students implement bubblesort, mergesort then quicksort, instead of just calling Collections.sort() or similar. I don't think anyone in their right mind would disagree that rebuilding a tool will help you more intracately understand it - and I know Phil agrees with that. Here's where the schools of thought diverge. I *absolutely* think the people rebuilding these clones should be releasing these clones on github, or sourceforge or whatever open source repository du jour is trendy at the moment. From my perspective there are a lot of pros to doing this: * Lets be honest, Github profiles are a lot like resumes with a lot of jobs. I think that's a good thing. If I'm a prospective employer and I look at your Github profile and see you built a router, then hell, that's better than *not* building a router, right? It means you more than likely understand how routers work. I don't think any reasonable hiring manager will go through and say "Oh, he built this router himself, but the other day I was thinking that it would be cool if PHP had a library to render images as UTF characters in the terminal. He didn't build that. I'm not going to hire this guy." * Open Source is hard. It's intimidating to make a pull request. I remember when I was making my first pull request on Github, I didn't actually know how to do it. I didn't know to create a branch on a fork and then a button would appear. I asked in IRC and got laughed at for being a nub (I really thought the internet had moved past that? Maybe it was just a bad day in IRC). Maybe a sole developer developing their own learning tool won't learn the full collaboration potential of git. But if we're encouraging them not to put it on Github, maybe they don't use source control at all? Or maybe they do, but they don't learn how to view diffs and commits on Github, how to use the issue tracker, etc. I think these are valuable skills to learn that will only help Open Source. * **It's not my damn business what someone else does**. And I think that's the kicker: if someone builds a router clone and it takes them 100 hours; well they're not going to spend 100 hours unless they're *enjoying* what they're doing. Maybe it doesn't help anyone. Maybe it's not what you would like to see developed, but *that doesn't actually matter*. They're doing what they *want* to be doing. I see no reason to ask them to do anything else. Perhaps the suggestion that people looking for a new project build something innovative or cool is valuable - but that's not what was happening. This was Phil aggressively saying "DON'T BUILD MORE ROUTERS - YOU'RE *HURTING* OPEN SOURCE". Now, to briefly consider the other side of the argument: * Many clones make it harder to find the good ones - I agree with this. I don't think it's relevant though. Searching is a problem of the provider hosting the packages. Github has stars for a reason. It's my understanding that packagist sorts by some algorithm, I believe it's number of downloads. There's groups like The PHP League, which exists to only host high-quality trusted packages. These are solutions to the problem, and they're all great solutions. If they need to be improved, so be it, but I don't believe the solution to the searching problem is to tell people to not make things that they want to make. * The code will break down in production, or be insecure, etc. Yep, this one is right too. I have personal experience with this - as a young developer I built a framework from scratch because I wanted to understand how to build them, how they worked. I had a vulnerability that allowed the user to display arbitrary files anywhere on the filesystem by passing a $_GET parameter. It was messy, and shouldn't have been in production. But it wasn't the fault of ME as the DEVELOPER OF THE FRAMEWORK that it was in production. It was the fault of me, the GUY WHO INSTALLED IN ON HIS SERVER. When I'm at work and getting a package to use in production, I evaluate it based on a few criteria before I even think about using it. How many downloads does it have? Are there any tests? What's the code coverage? Docs? Support on the issue tracker? Does it have any releases, or is it expecting me to require dev-master? All of these are things that should be considered by the CONSUMER before using the package. The way I see it, there are a lot of benefits and developer freedom associated with not getting your jimmies all rustled over the creation of clones. I really don't see a lot of weight behind the reasons against it. Just my 2¢.
Write what you want, share your code however you want, just have thick skin and market it responsibly. If you have no intention of maintaining some code you've written for the long term, just say so. If you receive criticism, accept it and embrace it. If you have no idea how to objectively quantify the quality of the thing you've made, just say so - people will *help you*. If you're pointed to a competing piece of code, study it and learn from it. And for the love of jeebus, be nice. You don't have to go around spreading pixie dust but it helps nobody to descend into personal attacks and bullshit dick measuring. These are my thoughts. EDIT: Also, if you're publishing *anything* online, check your ego and go have an Eskimo pie before you mouth off.
Why not? That seems like a great way to learn about all the other aspects of software. Why shouldn't this person learn how to properly document their code?
You should be using PDO and prepared statements like such: $statement = $conn-&gt;prepare("SELECT * FROM :table WHERE City = :city LIMIT :start , :limit"); $city = "Los Angeles"; $statement-&gt;bindvalue(':table', $tbl_name, PDO::PARAM_STR); $statement-&gt;bindValue(':city', $city, PDO::PARAM_STR); $statement-&gt;bindValue(':start', (int) $start, PDO::PARAM_INT); $statement-&gt;bindValue(':limit', (int) $limit, PDO::PARAM_INT); $statement-&gt;execute(); However, the problem with yours is the escaping of the quotes around the variable. $sql = "SELECT * FROM $tbl_name WHERE City = '{$formdata}' LIMIT $start, $limit"; If I were doing it this way, I would have a sanitization and quoting function for variables that needed cleansing and do a concatenation as such: $sql = "SELECT * FROM $tbl_name WHERE City = " . sQuote($formdata) . " LIMIT $start, $limit";
I believe the spirit of the comment was, don't market a fart as a windmill. Windmills are great and all, but farts have their place too.
Does the DB *need* to be hundreds of GB? Can't you wipe it and write some seed generators, which you'd want for new fields/tables anyway?
&gt; What's your team afraid of? Time and learning. We're swamped with work and they're not willing to allocate any time for anything that isn't necessary or will be a *huge* help, and they can't see what a big benefit it would be. That, and migration systems like phinx seem to be written with only 1 DB in mind. We would need to run out migrations selectively -- some would run on 80% of our DBs, some would run on 10%... we'd need to build a system on top to manage that.
Maybe. But if they buy a domain, make a logo, and write up documentation, they'll be getting better at it. And we all know documentation is really, really hard to get just perfect, so practice is always a good thing. I'd hate for the next project the guy works on to be really innovative and unique, and we all write it off because the docs are shit and the logo is made in mspaint.
Thanks for the tips, I will look into those prepared statements. The variable does seem to be passing correctly to my script as the data shows up on the page with the limits I set on it. (3 sets at a time) Attempting to paginate through the rest of the data set however does not work at all and nothing is displayed. Even hitting the previous link back to page one there is nothing at all. I think you are correct in that my variable is not getting called correctly throughout the pages but I'm not sure how to tackle that problem
If you are using javascript and ajax on the links you can easily pass that data through your POST or GET Otherwise if you're generating the links manually, you'll likely have to pass the page number and other data in the query string and do your offset calculations based off of the page number
&gt; He is nobody compared to Linus, Woz, Skeet, Dennis, Yukihiro He doesn't even claim to be. He's pretty humble, even though he created one of the most widely used scripting languages on the net. Did you even bother to read his quotes, or is this just a baseless rant?
Oh, I believe that without a doubt! I meant to say that I think he is not a very good "modern" PHP programmer. I won't say a word about his C code!
If you put it on your blog/website, that is 'verifiable' enough for Wikipedia you don't need to prove that it is true: http://en.wikipedia.org/wiki/Wikipedia:Verifiability,_not_truth The only limitation is that someone else will need to make the edit to the wiki. 
He basically gave us the language we use in /r/PHP
I mean, WorstDeveloperEver, why would we not at least hear what the progenitor of our livelihoods has to say, at least prior to dismissing it?
Sand blasted vagina itch
Yup. This one. When you find yourself needing to do anything exotic with arrays, it's often faster to just write a function to loop it than to do something clever with the array_* functions. 
And if he hadn't , maybe along the time some else could give us something better. Who knows?
Which as you may have guessed all means more money lost for you and a bad reputation.
Whether the code is good or not is not important. He built something that worked and got the community to help him out. Before php the alternative was either some shitty closed source crap or writing CGI scripts in perl (which is a pain to debug, and you have to write everything yourself). Sure, ruby and python are better designed, but they came later and don't have the community resources php has.
Fuck off
Thanks so much. I did as you, said already but was wondering if there were any "gotchas" that anyone had experienced. I've a feeling my new manager (asshole) is gauging my ability on delivering this project 
Like it was said before, you have to read migration guides, so you will know what to look for. Enable full error reporting and eliminate errors step by step. If you encounter particular problem, you can use this thread to ask and we will help you with replacing it. Obviously, simply removing dependencies on deprecated features won't make your code good, There are way more aspects, but this is definitely a first step. If you are going to migrate from PHP 5.3 to 5.6 later, I would strongly recommend you to use [PHPCompatibility](https://github.com/wimg/PHPCompatibility) - it is a set of check prepared for [PHP_CodeSniffer](https://github.com/squizlabs/PHP_CodeSniffer) that should help you save a lot of time.
I migrated several dozen sites from a 5.1 server to a 5.3 server. I think my only issue was a form which had over 1000 fields. PHP 5.3.9 introduced the max_input_vars option which I had to increase. I've migrated heaps of things from 5.3 to 5.4, and the biggest issue I've found is htmlspecialchars() and htmlentities() expecting UTF-8 content. If you're using non-UTF-8 strings (eg. ISO-8859-1) then those functions will return null unless you set the character set in one of the params. I don't have any experience with upgrades above 5.4.
&gt; I’ll just restart Apache every 10 requests. It's funny because it was essentially the way web servers were setup at (large internet company) for quite a while. ╔═════════════════ ೋღ☃ღೋ ════════════════╗ ~ ~ ~ ~ ~ ~ ~ ~ ~ Upvote this if ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ you are a beautiful strong code monkey ~ ~ ~ ~ ~ ~ ~ ~ ~ who don’t need no valgrind ~ ~ ~ ~ ~ ~ ╚═════════════════ ೋღ☃ღೋ ════════════════╝
This graphic: https://support.cloud.engineyard.com/attachments/token/9e2vlmtvjxpijbv/?name=PHPOpCodeLifeCycle.png That's somewhat misleading; it would be easy to get the impression that Zend is able to execute opcodes from shared memory, it can't do that. When opcache or apc has cached opcodes, it still has to copy them out to request memory (emalloc'd regions), it then has to do something similar to pass_two in order to set jump addresses and other boring things. I'd rather see a bit more detail, that is all ...
Looks like a couple of possible oversights, in that Zend Framework 2 was left out, and that both Zend and SF have businesses behind them that provide support and training to paying customers. Most businesses would like to know about the support option when choosing a framework, IMO.
I don't think it was rude ... a valid observation is what it was.
Are you sure the messy codebases were cakephp fault? Because I once saw a very messy Laravel codebase but then I discovered that the developers didn't even know what inheritance is, so I wouldn't say Laravel is to blame... AFAIK Cakephp it is very strict in its MVC implementation and convention-over-configuration. I would say it would take a lot of work to make a mess in cakephp. 
you can write bad or good code in every framework. it depends as always. doesn't change the fact that the framework is outdated 
Could you please elaborate on "outdated"? What do you think Cakephp is missing/not getting right? 
unfortunately i don't have enough knowledge of cakephp to make a true comparison, sorry.
There maybe one or two comments I've missed so not sure if this as been said but when I first saw the original comments in question from Phil I took it as meaning (I could be wrong here). If you are making something in production for a site / app and there's a package out there that does what you want it to then why reinvent the wheel just use one that's already out there and contribute to that, it will speed up development of your application. But in the mean time, if you want to learn how to make a router or similar there is nothing wrong with duplication, go for it if it means you're going to learn something new and if you carry on developing it and it turns out to be a game changing router then fair enough. No idea if that makes sense, it's kinda how I saw the original comments anyway, as usual a lot of s**t been blown out of proportion.
I finished a part-time foundation degree last summer and it had 2 modules on PHP.
Any config management is good, but I kinda prefer Salt these days -- in this case, specifically because I don't have to "pollute" my OS with Ansible. Salt will bootstrap itself from a www-&gt;sh script and then run in a local mode inside the VM. (Maybe Ansible can do that too? Dunno -- would rather do that to make the setup require one less host dependency.)
&gt; even though he created one of the most widely used scripting languages on the net. Not really. He didn't create the language we're using today. He was simply the first developer and still an internal. &gt; Did you even bother to read his quotes, or is this just a baseless rant? Yes, I did, and most of his quotes are always telling you to ignore good things and develop something working no matter what. Spaghetti code? Whocares? Just write it. - Comments? Ain't got no time for that. - Architecture? Just include config.php in 500 files. - Deployment? - Drag drop FTP works well, so what? One day you'll hop to another company (like most php devs including him does) and it is the next programmer's problem. This is wrong. All you do is saving the day. We've seen what this attitude caused. Billions of crappy, insecure, uncommented classes lying around the web. This is why every now and then people come to /r/php (almost daily) and blame about the crappy codebase at their work. This is why we need groups like PHP-FIG who tries to solve common problems. (albeit with loads of drama going on, that's another story) So what? He invented one of the most used scripting language and the most hated. It's not a rant, it is a criticism. If you enjoy being a toothbrush programmer forever, keep being one. I'm getting downvotes just because I'm doing a self-criticism in /r/php, so I really couldn't care less.
Your progenitor calls you as a toothbrush developer. You enjoy that?
Yes? You wouldn't. How many of you know Steve Jobs and Bill Gates, but have no idea who is Alan Kay or Larry Tesler? Oh wait, those guys are the first inventors of GUI systems that we're using nowadays and we're definitely in /r/entrepreneurs.
Yes, I realise installing Ansible kind of goes against the "keep your host OS clean" idea. But it is what I already had installed anyway because I use it for so many other tasks. Phansible actually already implements a way to provision on Windows machines by installing Ansible on the guest VM and run all the playbook in local mode. From http://phansible.com/docs/usage: "Phansible implements a workaround that runs the provisioning inside the Guest machine, with a local SSH connection. This is enabled by default, but you can also disable Windows compatibility in the "Advanced Options" of the VM settings, when creating your bundle." It might be worth it to revise my article to include that.
May I get more information on those over-engineered craps? What are they? Go? Dart? Node? Scala? Laravel is also over-engineered but majority of PHP devs use it. (or any other frameworks) Why? Because they move the exact opposite side of Rasmus' thoughts. People loves PHP, loves Rasmus's quotes about being a bad programming, but enjoys programming in a over-engineered Rails clone called Laravel. `throw new LogicNotFoundException;` His decisions made PHP what it is today, not implementations. This is why I don't consider anything he says about programming useful. PHP being extremely popular, getting things done, being easy to pick up relates to Rasmus's past decisions, which is proven to be correct. However, PHP having a crappy base, being inspired by too many languages (Perl, C, follows Java nowadays) at once, having no kind of standard is proven to be wrong.
You could make a bash script that will install ansible and execute the bundled playbook. It's how [Tower](http://www.ansible.com/tower) gets installed. I think it's a small price for a great tool. You already install vagrant, vmware, your OS is already "polluted". I also prefer Ansible because 1 machine gets "polluted", and has a lot less dependencies (Python which is pretty much everywhere). Salt depends on 0mq and has to be installed on master and minions, last time I checked. To conclude, I think you should use whatever you used in production, but if you're starting from scratch, my votes goes to Ansible. 
We tried it out for a while, didn't really see any great benefits. We have our DB2 data mirrored to a MySQL instance, so we don't often need to perform queries from linux/php to the Iseries. Meaning that we can get good performance from our web apps anyway. In the end we removed the php code from the Iseries, and we now use IceBreak (http://www.system-method.com/IceBreak) to create web-services on the Iseries which we can call from linux/php when we need integration between the 2 environments.
I quite like explicit `get` and `set`, but as you say it's a matter of taste. Are there any performance implications that result from adding this magic? 
https://puphpet.com/ is worth checking out as well. It's very tidy and has some really great extra options that it can manage. 
My personal opinion is that magic getters and setters in general just convolute an otherwise straightforward bunch of code. Yes, it's true they can eliminate boilerplate but I tend to favour explicitness over cleverness. There are places I find them useful, even necessary like presenters. I like the docs and your implementation seems good I just can't fathom ever being so religious about prefixed getters and setters.
Lovely. I was looking specifically for some thing like the php code compatibility module. Thanks!
&gt; PHP is rarely the bottleneck. It's so true. When PHP applications perform badly, in my experience it's either bad scripting or bad query/database design.
&gt; Salt [...] has to be installed on master and minions, last time I checked. You've haven't checked in quite some time -- since at least [2012](https://github.com/saltstack/salt/blob/1f02f680c3bc6f511533c1562bad5d1910f952a7/doc/topics/tutorials/quickstart.rst) it would appear. Possibly before even that. My overall point wasn't "_boo ansible_" -- I couldn't care less which provisioner people use, merely that the less stuff you have to put on the host, the more portable the vagrant setup becomes. The author already pointed out that Ansible can be run from within the VM in a local mode, so there ya go.
but he does seem to like solving problems.
You're judging him by your own standards, which is based purely on programming ability. But he admits he's not an engineer, not even a programmer really. For all your best practices, textbook OO, design patterns and all kinds of cool formal stuff, what have *you* actually achieved? Im a software engineer too. I try to use best practices, but I can safely say from all the millions of lines of code I've written, I haven't achieved even 1% of what Rasmus has in terms of contributing to the progression of internet Early PHP was a badly designed piece of crap, but it was still preferable to writing awful ASP or trying to secure 40000 lines of CGI script written in perl
It runs trunk with something like 250 plugins that modify the behavior in various ways and make it a unique product from the base open source project. So yeah, highly different maybe in that they modify behavior through WordPress' architecture of hooks and filters, but otherwise not really.
To save installing the VLD extension (not too difficult on Linux but a pain if you're trying to do it on a VPS from your phone), 3v4l.org shows both VLD output and HHVM bytecode. Eg http://3v4l.org/MTmlD/vld#tabs
&gt; But it's DEFINITELY a micro-optimization. FTFY
+1 for Salt It's insanely easy to use and setup
It's interesting. I too prefer the clarity of `get` / `set` prefixes. The less you have to explain to the developers who need to take your code over (or your future self) the better your current code is.
Huh?
They could learn to document something useful that they've just built, not yet another clone of something that exists 100 times over.
This.
Original point missed. Check. Misused a comment from me. Check
Ok, its pointless continuing this as you just seem to have a personal grudge against the guy. 
Please don't post links to pirated copyrighted materials.
Where and when is this?
 class test { public $array = 'bleh'; } function getData() { return new test; } echo getData() -&gt; array; &gt; bleh Not a good idea. 
26 - 29 Oct http://phpconference.com/2014/en
900 EUR per ticket. I could hire a freelancer for a month with that kind of cash!
This is one area where PHP-FIG are on my page - I'm a fan of get/set prefixes in method names.
https://twitter.com/3v4l_org says it's https://twitter.com/_sjon Saved me lots of hours testing stuff and helped me loose many an argument!
Yes! I will be there!
The circlejerk is real.