I guess that's what I get for skimming the RFC instead of reading through. In my defense, I don't recall being able to do this in the early stages of PHP5 - but I may have missed it.
Until you have to deal with drawing functions. It's not an absolute truth. As long as the task performed by the function is concise, it doesn't matter how many arguments you have.
Yes, that's been mentioned a few times now, so I'm reworking my pages to use pdo. I'll certainly post results either here or on /r/phphelp tomorrow to make sure I'm doing this right. I'm thinking my starting point was part of the issue. I picked up a copy of "php &amp; MySQL: the missing manual" and have been piecing this together based on what I'm reading there along with Google. Looking in the index, I'm not finding any references at all to "pdo" or "prepared statements". I'd blame it on being copyright 2012, but if you're saying 2005, then I'm wishing I'd chosen a different book in the first place...
I'm all for rooting out things that want to be special snowflakes but unsure if a descending sort is deserving of its own callable. If you were implementing a pure PHP sort, would you do this or have an if check than ran array_reverse? 
So if I have a function to draw a rectangle that takes (x1, y1, x2, y2, color, linethickness), you want me to break that up? How? With annoying elaborate state for color and linethickness? There are plenty of simple operations that still require plenty of characteristics to describe.
I guess so. I don't think there's much cost to it, though, and it can help with self-documentation. But if someone uses that variable's value again later in the calling context, I will personally come to their house and piss in their coffee.
Care to give an example? Because most drawing APIs suffer horribly from the latter problem (hidden objects).
I like the idea of appending `?` to boolean things, specifically to things like `is_empty` -- `is_empty?($someArray)`. However, I still think separating ascending and descending sort into two functions is unnecessary at best.
Developing new project and currently only testing against 7.x, we'll release on what ever version we've tested stable against at that point.
My company is running PHP 5.3. That said, the versions aren't that different. Successive versions introduce new language niceties but they're not /that/ different. I'd say focus on just learning PHP for the time being. Sounds like your a ways away from using version specific features so the version, atm, doesn't really matter.
&gt; is_empty?($someArray) In this case would be `empty?($arr)`. This just and idea of using a diacritic to clear ambiguity, which arguably would make things more consistent for variables, arguments, and functions which return or are booleans, IMHO. But then again, PHP wouldn't allow that specific convention, is just an example. &gt; However, I still think separating ascending and descending sort into two functions is unnecessary at best. Again, was just an example to project and idea to reduce complexity, not every function have duality in their semantics like sort, so don't take it too seriously, but I still find it feasible, IMHO.
I am pretty comfortable with older versions of php. One issue I run into though is through my learning stuff like pdo and then coming to our code base and being unable to use it. I Have to use things like mysql_fetch_array. Just trying to figure out what is realistic and a good way to make sure I'm not only getting stuff done for the current company, but keeping myself competitive as a lamp stack developer long term.
If you're looking to stay competitive, you'll definitely want to know all about 5.4+ and/or 7 *right now*. http://www.phptherightway.com
We just upgraded to 5.6 while it was still current. We're looking into upgrading to 7, though there's a lot of things that are broken for us.
Our website still runs 5.6 but that's because I've been busy getting a project launched that runs 7. :)
Fancy features? Because getting work done faster is a burden?
Thank you for this :)
&gt;That said, the versions aren't that different. Successive versions introduce new language niceties but they're not /that/ different. Biggest issue with this line of thinking is that security fixes aren't necessarily backported to older versions, and bug fixes usually definitely aren't.
5.5 or 5.6 on most of our servers. Some (much) older projects still require 5.2. We probably won't start using 7 until a framework we use requires it, so... a couple of years from now, probably.
He's wanting to learn the language - not become a sys admin. If you're a sys admin, yah, you want to stay up-to-date. But if you don't know anything about PHP and are just trying to get started I don't see it as really mattering that much. You ought not be writing live production websites at that stage anyway.
We've been running 5.6 on our custom applications, and will update to 7.0 as the packages and software become more finalized and released. For example, waiting for the apt repository to include more PHP 7 packages, more extensions to be finalized and bugs patched, etc.
Not that many. You may want to switch to node soon 
It is possible to start with a domain model if you understand the very business you are involved in, or that you work with a capable domain expert. If you cannot start with a proper domain model, it is most likely that you don't understand the problem domain. Even in this case, you can still build a DDD framework and evolve your code and business logic with it. 
&gt; This is circular logic. With positional parameters, even two arguments can be confusing (case in point, all the needle-haystack confusion). With named parameters this confusion is solved. But the claim is many named parameters would be a bad design, because... with positional arguments it'd be confusing? Doesn't follow, right? That's why we want named parameters. So that it's not confusing. Don't put words in my mouth. I'd respond to the rest of this properly but iOS is being weird and not letting me copy or paste. Suffice to say: simpler is better, and the more inputs you have, the more complex a function is. Named parameters only simplify this insofar as they mean you can avoid passing arguments you don't need to, and saving you having to remember the positions of parameters. But it doesn't solve the fundamental issue that a function with many parameters is too complex. Complexity makes functions harder to test, harder to reason about, harder to modify. It is poor design in both the abstract and concrete senses. It's for this reason that named parameters bother me. They make it less painful to use excessively complex functions and provide almost no benefit for well-designed functions.
Argh, I don't like this. This adds C++/Python-style free-for-all overloading which has led to such abominations as division-as-path-joining and bit-shift-as-stream-piping. I'd much rather see something akin to what Haskell has, where you can't implement just any operator on just any type. Rather, you must implement a set of operations together (e.g. those applicable to lists, or those applicable to whole numbers, or those applicable to fractional numbers) and make it satisfy some invariants. Then, your type is now considered to be, say, a number or a thing that can be mapped over, and satisfies type constraints asking for one. Something akin to Haskell's system would mean you could write your own number types, string types and so on, but discourage nonsensical operator abuse. I'd wanted to make an RFC for that. This RFC, though, isn't that. EDIT: See my response on the mailing list: http://news.php.net/php.internals/89991
Holy crap! This will be a great introductory tool for my juniors. Kudos. 
but whats the use case? where can it be used?
Quick and dirty list of anticipated questions (often mislabelled as "frequently asked"): * What does this do? * This library makes it a breeze to add a [Content-Security-Policy header](http://www.html5rocks.com/en/tutorials/security/content-security-policy/) to your PHP app. * Why might we want this? * CSP headers add a level of mitigation against XSS attacks, which you can read all about [here](https://paragonie.com/blog/2015/06/preventing-xss-vulnerabilities-in-php-everything-you-need-know). Our CSP-Builder project just makes them really easy to integrate. * How much does it cost? * Free, and MIT licensed. * What's the catch? Why release something like this? * XSS is actually a hard problem. Harder to defend against, if you're willing to believe us, than many cryptographic vulnerabilities. CSP headers add a level of protection so that, should your existing defenses fail your users, you still have another layer the exploit has to to punch through. We're releasing this in the hopes that the community will find it useful, and to reduce the rate of incidence of successful XSS exploits against any of your projects.
&gt; I've always preferred assoc arrays or parameter objects in key How do you even remember what the arguments are though? The method signature becomes totally opaque and you can only understand it by looking at the code to see what properties are being accessed. Surely you'd want the function to be easier to use than to change, if you're using it a lot?
I use PHPStorm for non-windows development, and VS 2010 for windows, .net etc. related things. I still use ~~Alliure~~, ~~Dreamweaver~~, Adobe Homesite even though it has been dead since 2003. It amazes me how few editors have multi-line find / replace (I know PHPStorm has one, I just hate waiting for startup times, or editing non-project files in my main window). I've also grown accustomed to the find/replace system so its what I use it for 99% of the time.
At the end of the day though, most applications are going to require routing, templates, auth, mail and a relational DB. You save a stack of time starting with a framework (nobody cares which one) that rolls all of this for you. 
When you have all those silly pop ups and key combinations to remember it can be. Who needs a command to create getters and setters when it takes a second to just write them
If anything, these should be interfaces instead of magic methods.
You're not wrong, I guess a use case would be to build desktop apps with PHP?
I strive to employ the Unix Principle in every facet of development, from my choice of operating system, desktop environment, development tools, and programming style. Fortunately as a hobbyist I can afford to practice a level of discipline which isn't necessarily the fastest way to develop, but produces elegant and easy to read code.
It's never normal for any company to update their codebase to the newest version of any coding language (unless for extreme exceptions). It takes time to properly test things. Nothing fucks up revenue more than upgrading PHP and finding that it no longer works with your applications due to some obscure reason. Usually, the downtime is testing. Clone the live environment and spin it up either in a VM or on a server somewhere, and upgrade PHP. If it works in test, then push it to live. If not, refactor code to comply with PHP 7 ruleset, test, then push.
&gt; How do you even remember what the arguments are though? In the case of objects, there's full autocomplete so I don't have to remember anything. I typically add a typed layer for data once an API becomes stable and stops evolving fast, so the value of types outweighs the cons of how types work in PHP (no generics, no type algebra like unions and intersections etc.), and I can produce types for client libraries in many languages that might want to use this API (not just PHP, but also TypeScript, Java, etc.). In the case of arrays, method/API documentation. I don't actually *enjoy* the fact arrays are untyped. We really need something like Hack's shapes in PHP, I think. Or even better, TypeScript's structural typing, that would be perfectly suited for the purpose. But I need to work with what I have. Engineering is about seeing what you have, and picking your poison. It's about trade-offs. Arrays are better than objects for generic data input/output for a myriad other reasons, like they are mutable *and* pass-by-value so they're a lot more convenient to work with compared to the clunky immutable value objects, or the bug-prone mutable value objects. You can easily pass generic arrays through reusable transform, validation, filtering stages, and while you can emulate that generic data access and transform for an object (either through reflection or a special-purpose interface), it's a lot more cumbersome and slower by an order of magnitude (and that's an understatement), while the value of over-complicating everything is unclear. There are other considerations but I'd need to speak with concrete code so we can be on the same page. Sometimes working with objects it the right paradigm. An object is the perfect paradigm for encapsulating *logic* that *contains* data. But sometimes, between distinct components, you want to just pass *data free of logic*. Free-form, generic, malleable, easy to transform data. And arrays + scalars are better at this. And arrays can be instantly produced out of various foreign inputs (JSON, XML, $_GET, $_POST, SQL queries, NoSQL quries to name a few) with no specialized knowledge, which is especially important as it materializes the role of PHP as a glue language. You need to be able to grab data from one place quickly and shove it some other place quickly, or your controller logic becomes unnecessarily bloated and redundant to your service layer logic. Types don't survive over the wire (not reliably and in a trustworthy manner, at least), so at some point in your app, the wire, everything is a soup of maps, lists and scalars, like it or not. If your API is wire-ready it means it should be ready to take an amorphous array and fully validate it before it uses it. There, not earlier. This means you can call that API remotely or locally, and it maintains its own integrity without making assumptions about its input. Modeling APIs this way saves a lot of boilerplate for exposing it over HTTP later on, for example. Phew, anyway **tl;dr**. There are right places for objects (explicit behavior, implicit state), and right places for arrays (explicit data, no behavior). And there are right places for positional parameters (lower level core APIs called locally), and named parameters (high-level domain APIs that may be called remotely). 
What does PHP-GTK have over updated projects like wxPHP? Are they different use-cases or is this internal functionality that other programs like wxPHP rely on?
&gt; Suffice to say: simpler is better, and the more inputs you have, the more complex a function is. There is no direct correlation between argument count and function complexity. It's indirect and circumstantial. Also, simpler is better, but as Einstein says, "make things as simple as possible, but not simpler". Chasing simplicity as an absolute, like, say, Up To Three Arguments, regardless of any more specific considerations, is I think a quite naive goal. A function with many inputs may be poorly designed, or it can be simply the function's nature. The count of arguments is already a very abstract notion, because you can have a single argument as a composite value (array) or an object which itself is so complex, you spent the entire application bootstrap on configuring it and creating it. Then that function will sit pretty with a short signature, but in reality it won't be simple. That complexity will be hidden. It's the same situation when you see in legacy code a function sitting pretty with no arguments at all, but it reads half the world from $GLOBALS. Having named parameters would allow us in many cases to be more explicit about what a function takes in and avoid a layer of indirection that we always need right now when we want named parameters (I'm talking about parameter objects and arrays here). Instead of abiding by artificial hard limits, and treating each other like idiots who apparently don't understand that *simplicity is a cool thing to have*, let's have an expressive language so we can choose the most natural and explicit, type-safe and efficient option for our APIs. 
I thought I clarified this point already. Again, if we're talking about verbosity of DSLs and APIs then I'd recommend the shorthand map notation over named parameters, again, because they don't screw with the testability of functions. My OOP point was about the auto-completion counterpoint only.
The use case is to provide GTK bindings to PHP for creating desktop GUI applications. 
&gt; Many parametered functions are bad design irrespective of named or positional parameters. Either your function is doing too much, or you have a hidden object in all those parameters. "Your function is doing too much" is not a specific drawback of an API design, it's a subjective opinion. So unless we define what "doing too much" is and why it's bad, it doesn't make sense to bring it up as an argument. For example, "more than three positional arguments become hard to read and follow" is a specific argument. We don't want APIs to be confusing and hard to read and follow. But a function "doing too much" might go either way. Maybe we should give that function a pay raise and a bonus for being such a hard worker. /s For an example of how things work with named parameters, in Objective-C and the new Swift, arguments always have a name, it's part of the function call syntax. There you can commonly see methods with 7-8 and more arguments. And yet it's very readable, very manageable, and Cocoa is considered one of the best designed APIs in our industry. Apparently named parameters change how input complexity is perceived.
&gt; all be it 
It's a shame this sets up to overload + = * / ** . instead of a Comparable interface. I can't see nice things I'd like to do with MyError * MyException, but MyError == MyException would be a different story. Also, at this point an interface seems better for the language than more magic methods: /** * Describes the ability to be compared against another value using the equality operators. */ interface Comparable { /** * Compares this object against another, and returns a relative position to allow for sorting, and comparison. * * @param mixed $value The object to compare this one against. * * @return int 0 if equal, 1 if greater than, -1 if less than. */ public function compare($value); } This would then provide an interface to overload the behaviour of ==, ===, &gt;, &lt;, &gt;=, &lt;=, !=, and &lt;=&gt; which I could see being very useful. I end up writing a lot of isEqual(self $b) methods, which while cool, would be nice if there was some syntatic sugar to back them up.
You don't necessarily need to use PDO, mysqli works too - albeit I wouldn't use it directly for anything but a very small application. I generally don't recommend books, solely based on the fact that they can't get updatet. Tutorials can. You should really learn to read the documentation; everything you need is said there and is always up to date. It is probably the best resource to learn new things in PHP.
What happens if I don't want to add these things? There is a point where the overhead of a different structure becomes worthwhile, but there's also plenty of room between that and insisting that functions should only have one or two arguments.
in short term it always look like an overkill but you will be thankful for the "overkill" a few months later. I don't now about you but I made several times the mistake to think "it does not need to be extendable" and my boss has proven me wrong when he came with new feature requests. But for sure if the projects is very very small etc then this all is probably an overkill =)
It's a valid question. No one really writes desktop applications in PHP, and for good reason. This project has been around for awhile and I don't think I've ever seen any real examples 
I didn't know GTK was a language.
It isn't, but javascript is. And claiming js is "built for the frontend" is an apple to oranges comparison.
What does `echo ini_get('error_reporting');` tell you? Try setting error_reporting to `-1` or `E_ALL` prior to running the json_decode. Also, in example given, `$output` is never declared prior to being passed in `json_decode($output, true)`;
The problem with too-many parameters isn't input complexity. That's merely another bad side effect of poor architecture. "Doing too much" is the architectural problem. You say it's subjective, but it isn't. A function should only do one thing. If your description of what the function does naturally includes the word "and", then it's doing too much. That's very objective and easy to measure. Input complexity is an after-thought, because well architected interfaces naturally lead to simple input.
Fair point. Though it does make me wonder if an object taking a long list of dependencies might have issues.
Well, PHP-GTK uses GTK whereas wxPHP uses wxWidgets. I imagine that would be the big difference.
I get it, I should have said the browser instead.
He'd have to learn how GIT works first. Or maybe OP considers it trivial 
Hi, The license is not specified anywhere. By default, code is not open source, even if public. Please look up how to apply a license on your code.
&gt; Is there a good case for php-gtk over something like electron? The use case is having a sizable PHP codebase and wanting to expose that existing logic via a native GUI. The alternative would be for PHP to provide an API another process can call, and then you can write your GUI client in any technology you want. But that alternative does come with limitations namely the lag and bandwidth limitations of IPC. If that's not a problem for a particular project, then it's a good way to go. If not, php-gtk is a better way to do. PHP also has reached a level of maturity where I think it's justified to call it a general purpose scripting platform. Indeed, a lot of its core API and execution model is focused on the web, but almost everything introduced in the last few years falls into the "general purpose scripting feature" department. The direction seems clear.
I downloaded Eclipse PDT. 
I am a professional PHP developer at my day job, I've been using PHP since version 2 (before OO stuff even existed in it), and I could be said to be a PHP enthusiast in the sense that I usually choose PHP for my personal web projects. PHP GTK is the worst fucking idea I've ever heard of. Seriously. Using PHP to write long-running applications because you're comfortable with the syntax or the duck typing is still a terrible decision. PHP is a web development language. It is steeped in features designed specifically to make webpages. Composer, PHP_CodeSniffer, and other such tools are successful in spite of, not due to, those features. Moreover, tools like Composer and PHP_CodeSniffer make sense because they are tools to aid in developing PHP web projects, so authors of said projects have PHP on hand and it is a natural choice, even though it's slightly perverse. Convenience here is the driving force. I just finished writing a couple GTK apps using PyGtk4, now that's a marriage of sensibility and reason. Python is well documented to run continuously without leaking memory like a sieve, and you can load only the libraries necessary for the task. You don't have `$_SERVER` and `$_POST` superglobal variables floating around in your desktop application because you're, for some strange reason, running it in a web application environment. I support the work of anyone who wants to make PHP better, but convincing people to write desktop applications in PHP is not the way I would go about it. Why don't we get the internals folks to strip out more of the meaningless shit, like that blasted `T_PAAMAYIM_NEKUDOTAYIM`, or add named arguments, or create first-class object wrappers around the standard library functions? I also recognize the desire to "stay within one's wheelhouse," but if you know PHP well enough to be dangerous, you're probably smart enough to pick up a language better suited to the task of writing a desktop application.
And this didn't work? http://wiki.eclipse.org/Debugging_using_XDebug Remember to restart the web server after every change to php.ini.
I've seen one, a control panel for apache (this was years ago). It should've been written in something else, anything else, but my impression was the authors didn't *know* anything else.
It's still built on electron, so it should probably be similar in speed.
You make some good points, mainly about PHP being specifically designed for web servers, but I think that PHP is evolving to suit more applications than the web (not that is incapable right now), it's improving in each new version, and I don't see it so different to Python (though Python is much more robust due to popularity and use as one of the main scripting languages, as you say). I am a little irritated with Python though because I am working with a RNN library done with a really ~~incompetent~~ bad design, allowed by dynamic typing and complete lack of static checks (not that PHP is any different in that sense, it is actually more permissive). Anyway, OP is not talking about convincing people to write desktop applications using PHP, he/she is talking about improving the tools to do so. Cheers.
Does the componen symfony crawler is better than default php dom implementation? 
In my opinion the symfony crawler is much easier to use for html content than the default dom implementation. 
Thanks for the reply. I've read GTD a couple of things (which I found has been good) and one of the things in their it mentions is if the next actions are not well defined then it can lead to procrastination. I've done pen and paper, white boards and to do list software. In most instances it's just moving stuff from one thing to another and I still end up looking at it and thinking, i'll do this later, and then later becomes tomorrow. Maybe I should go back to each thing I need to do and better define it and work out what needs doing...
Good idea tip, I might pay more attention to my food and exercise.... it's so easy to forget about yourself when your busy on things. I'll keep a basic log for a week or so and see how it goes!
Thank you for your contribution.
You should install xdebug with a package manager, not manually.
Please wait. Soon we will put cases of actual use php-gtk on the site. 
thank you!!
There's something satisfying about reading people make faster code using Blackfire. Nice work!
A comparable interface is not the same as operator overloading. You can do much more interesting things with operator overloading. For example imagine a couple Table column objets: $startTime = new Column('start_time'); $endTime = new Column('end_time'); Wit operator overloading we can implement a more expressive query builder: $query-&gt;where($endTime &gt; $startTime); With operator overloading, we can return objects of other types that can be used, like in this case, for generating conditions. Having this feature would make something like LINQ possible in PHP
I can't say I'm a big fan of using PHP for GUI applications, but there is absolutely no problem in using it for CLI applications, and little problem using it for daemonized code. PHP is a general purpose programming language, as such it's areas of applicability are primarily limited by available library bindings and performance. There are some things you can't do well in PHP because we have no good bindings (for example GUI applications or to a degree scientific computing) and some things you can't do because PHP is simply too slow for the task. CLI applications usually do not fall in either category. FYI, php-gtk has nothing to do with php-src, so this is no "either or" situation. Work on php-gtk does not interact in any way with work on internals.
I inherited a PHP-GTK2 app in a previous job, which I ended up having to maintain for a few years; to be honest it was an experience I'd rather forget! The guys in the IRC channel were a helpful bunch though, are any of the "old guard" still involved with the project, e.g. auroraeosrose?
Congratulations for doing this. I have used PHP-GTK2 for some personal projects in the past (almost 10 years ago :o), it was fun! An upgrade to GTK3 will do the project justice. Wishing you best luck!
Just going to chip in here: I use PhpStorm and XDebug was hard to set up to for me. First make, I had to make sure it was installed as php extension and was visible in `phpinfo()` Then, after trial and error I had to add some extra PHP configuration variables to `php` config. Enable debuggin listeners, profilers, keys (which I have saved somewhere :S). Then, I had to configure server, php runtime and debugger (port) in PhpStorm. Lastly, there is an extension for Chrome which toggles Xdebug cookies, which are sent to your dev server and toggle debugging/profiling. So in all, these are 3 (4?) things I had to set up. Now the debugging works really well inside PhpStorm, sometimes it's a lifesaver!
I think it just came down to the vote. Why individuals pick one style over another is anyone's guess.
Flow control is on the same line and declarative is on a new line. When parameters span and you new-line them like in example #2 the closing parenthesis makes sense to be on a new line - with the opening bracket. Its also just a style guideline, you can write anyway you like.
Thanks! that was an interesting read ☺
Thanks! That was a interesting read! :-)
&gt; Check Facebook's GraphQL. There are so many parameters per API call, they even had to make their own language for it, so they can specify nested structures of parameters. No, each field in a GraphQL query is not a function parameter. Queries in query languages don't directly (or even loosely) correlate to functions. &gt; Let's take the plus operator: it takes two operands and returns their sum. It's bad design, I suppose. Too many operands, and includes "and". The addition operator "adds two numbers". There is no "and" in its description.
You flow into a conditional (if, try, catch, finally etc.), whereas you don't with classes and functions (they are declared and called at another point). There was also a survey: https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md#appendix-a-survey
Did you installed PHP via homebrew? If not, you should have. Using homebrew it is also easy to install xdebug. 
My modification to this when I'm in a rut is I write the three things I need to do each day. Keep the list super simple, something you could probably accomplish in about 30% of the day. This easy list will entice you to get started and hopefully once it is complete you'll find your groove and keep going. If not, at least you did something. I do the same thing with cleaning. 
&gt; No, each field in a GraphQL query is not a function parameter. Queries in query languages don't directly (or even loosely) correlate to functions. Ok, what do they correlate to, genius? When you call, for example mysqli_query() or $pdo-&gt;query() is this a function/method, or what is it? Does it have arguments or doesn't it? Do they contain parametric data or don't they?
Can you please take your mental illness elsewhere gibranois.
Am I the only one who finds the Blackfire UI completely confusing? The fact you had to add a bunch of circles and arrows to every screenshot says a lot IMO.
The problem for me hasn't been ideas, but finding ways to motivate myself. I've got several projects I'd like to work on but I'm just awful at self-motivation. Been trying to work at it.
I am trying to call an adfs2 / ws-trust soap service where I receive saml back. I have a pfx file. What is the best way to handle this? Are there any good libraries out there? All of the libraries I see use a username/password instead of a pfx file.
Consider what happens if OpenGL were to decide to start defining rectangles as pairs of points, rather than a point and a set of dimensions. That's likely thousands of references to update, and one huge BC break. There is also nothing preventing inconsistency. One function may define a rectangle as x/y/width/height and another may define one as x1/y1/x2/y2. That can cause a lot of confusion and headaches. There's also parameter transposition. Consider what happens if an outlier function accidentally declares x/y/height/width instead of x/y/width/height. Extremely easy to miss, still compiles, very hard to debug. It also leads to a harder to test API, as now you have to replicate the standard rectangle unit tests for each function instead of just your object creation.
Got into it when I was in highschool because someone knew it and taught it to me, have stayed with it because it's paid the bills. I've diversified and learned other languages, but my go-to web language is still PHP.
To learn web dev. It made it very easy. So thanks php.
Got into it to build an online game. Stuck with it because infosec elitists tell me not to, and fuck those jerks.
&gt; infosec elitists Huh? &gt; Got into it to build an online game. What Game?
Infosec -&gt; Information security The game was one of my own design that never took off. In hindsight, it sucked anyway.
is it till around? in any form?
It hasn't existed in any form for nearly 13 years. Remember to back your stuff up!
I'm running OS X 10.7.5
That's quite outdated, but you should be using [Homebrew](http://brew.sh/). For example, to install xdebug for PHP 5.6: brew install php56-xdebug
idk if troll, but let's go on anywho. js (in it's life time - just the server side stuff): nodejs, io.js (yes, I know it's merged now), microsoft's fork php: hhvm, zend, quercus (no one uses this but I'm mentioning it just to be fair) Seems pretty even so far. The language has matured and become much better. 
I got into php because I hated Perl. I stuck with it because the jobs were always there. I keep coming back to it because I'm not competent enough with node and because the vast majority of people I work with are dealing with PHP.
That's the repo I'm watching. I'm waiting for more extensions and such to be finalized, not the PHP package itself which is good to go.
This need neat. I haven't seen RAML before. At first I thought it would be a second rate replacement for swagger but after looking over the site it's quite impressive. I used to call the process of using swagger "Documentation First API" Thanks again, this looks great. 
phpBB. A friend of mine ran a vBulletin message board that was decently popular and I decided I wanted in on the action so I installed phpBB and modded it up.
I just downloaded Homebrew and then entered the command you mentioned in the terminal and the output was this: macintosh-1:~ no$ brew install php56-xdebug Error: No available formula with the name "php56-xdebug" ==&gt; Searching for similarly named formulae... Error: No similarly named formulae found. ==&gt; Searching taps... This formula was found in a tap: homebrew/php/php56-xdebug To install it, run: brew install homebrew/php/php56-xdebug macintosh-1:~ no$ brew install homebrew/php/php56-xdebug ==&gt; Installing git Error: Git is unavailable Any idea why this happened?
&gt; you should all switch to nodejs What do we do in 2 years when its gone and not cool anymore?
Try running `brew doctor` and make sure it doesn't report any errors. Then run: brew tap homebrew/php brew install php56-xdebug 
The web should be scrapped, now!
.. geany on my laptop, pico on the servers.... 
Why not both? If I wrote a custom string class, I'd certainly want to satisfy the string-like interface that you're suggesting, but I might also want to overload `*` to give `str_repeat()` functionality [like some other languages](http://ruby-doc.org/core-1.9.3/String.html#method-i-2A). Also, how would this work with implicit type coercion? In `$foo + 123`, if `$foo` were a string-like object, PHP would want to coerce it into an `int`, but we don't have `__toInt()`.
Can someone make blackfire or similar that's not $80/mo :) I don't get why a (good) OSS alternative to Appdynamics, NewRelic or Blackfire doesn't exist yet.
You might want to take a look at [jsonform](https://github.com/joshfire/jsonform).
To make a website. Later I got back into it because I learned how to contribute to the language core. Why do I stick around? Because it's interesting. Also useful: when I make websites I usually use PHP for the backend, it's quick, I know it well, it works.
&gt; Why not both? Because having operators magically do completely different things when you give them different types is unintuitive and hurts readability.
Isn't xhprof OSS? Anyway, while not being OSS, most of blackfire features are free. The premium account only unlocks support, assertions and database + network transactions profiling. What's been used in the article comes for free.
Thank you.
https://www.phpbb.com/extensions/writing/
Auroraesoroseis away from the project now. My nickname in irc channel when I am there is Falsificado or Buhlerax. 
Thank you for your participation. 
PSR-2 was based on [a survey](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md#appendix-a-survey). The reasoning was: "let's standardize existing practices". On average the { was on the same line for blocks and on average it was on a new line for class and function declarations.
First tried it while in university studying computer science 15 years ago (PHP wasn't being taught I just used it cause I could get a simple side project hosted cheaply). After I finished my degree I put it on my CV among other languages and surprisingly the first job I landed was a PHP developer position. Now after several jobs and hundreds of projects it still pays the bills. I have experience in c# .net and android development in Java but PHP always feels like home.
I'd learned Java and C# through Minecraft and Terraria modding, and PHP was closer to either than Python. I probably would have stuck with Python had I not found out about Laravel.
I would nether suggest this but as crud there is thing called Sonata Admin Bundle
To a younger me, it seemed like The Language to learn for websites, because all the free webhosts I knew ran PHP + MySQL. So I went with it. I'm weeping all the time because of inconsistent function names and parameter order, but autocomplete helps.
You might look at [NV recent topics](https://www.phpbb.com/customise/db/mod/nv_recent_topics/). Starting from an existing plugin that touches most of the data you want, and has most of the presentation you want, will shortcut a lot of the development. "Trending" is usually a subject of time, so most of the work is coming up with a good query that breaks down comments/topics/etc by date and by volume/count. Then you would take the difference between each days, so things that are increasing in activity get higher scores than things that are decreasing in activity. You may also want to weight the scores so that new activity doesn't get considered "trending". You may also want to trim the last few events so everybody's score doesn't go to zero after midnight. This query is not possible in MySQL, however if you're doing PostgreSQL you can use [window functions](http://www.postgresql.org/docs/current/static/tutorial-window.html) which look something like: select ... , volume - lag(volume) over (order by year, month, ...) as delta If you're stuck with MySQL, you'll have to load the data by-day for at least the last few days, then rank them. I'd recommend caching the results (e.g. once an hour) since the query is expensive.
+1 for cakephp. Super easy to define your models and from there it generates everything you need.
For listing/filtering/search and inline edit you can take a look at http://datatables.yajrabox.com based on https://www.datatables.net/
Went into php trying to install php-nuke (like 10 years ago). Saw how easy was to modify code ( config.php ) and did some scripts after that. This was my introduction to programming. I later learnt other languages and made computer programming my career choice. After the upgrade to PHP 5, found it meets my requirements for most web projects I do. I've worked with nodejs (mainly because of socket.io) , but I think my most productive work is still done with php.
&gt; This query is not possible in MySQL You're talking about grouping by date and then having the difference of some quantity and the same quantity the day before. I am absolutely certain that this is possible in MySQL.
No wonder your queries are slow if you use dependent subqueries all over the place. Also, if there is an index on the `date` column like there ought to be, your queries don't have to be slow if you write them properly: SELECT t1.`date`, t.volume, t.volume-t_before.volume AS delta FROM t JOIN t AS t_before ON t_before.`date`=DATE_ADD(t.`date`, INTERVAL 1 DAY) But this requires having a table with the posting volume per day. Does that seem like a good idea to you? Because it doesn't to me. Here's the sort of thing I'd do: SELECT p.`date`, COUNT(p.*) AS volume, COUNT(p.*) - COUNT(q.*) AS delta FROM post AS p JOIN post AS q ON DATE_ADD(p.`date`, INTERVAL 1 DAY)=q.`date` GROUP BY p.`date` 
Check the output of EXPLAIN: Subqueries get optimised. All of those queries should produce the same query-plan.
You don't think a statement like "subqueries get optimised" is a bit of an oversimplification of the truth? Edit: hang on here. How can queries with different tables with different schemas produce the same query plan? That last one is completely different, the structure is nowhere near the same!
What about [LimeSurvey](https://www.limesurvey.org/en/)? It's PHP, but [built on an older version of Yii](https://github.com/LimeSurvey/LimeSurvey).
In the PSR case, it was result of voting as stated by /u/mnapoli - but it does not the underlying aspect on _why_ these projects have the style they have. Last time I asked myself this question, I found out that the inconsistency of curly braces placement under K&amp;R derived code styles is result of the original K&amp;R argument declaration for variables. In the original K&amp;R C, curly braces were always placed in end of the line of the block declaration. Except for functions declaration that were declared as this: int something(a,b) int a; int b; { if (a &lt; b) { /* let there be more light... */ } } When ANSI C got traction in the wild, these functions were rewritten, but their style kept intact: int something(int a, int b) { if (a &lt; b) { /* let there be more light... */ } } If you look at Java official style guidelines, they have fixed this issue, and function and class declarations are essentially consistent everywhere: int something(int a, int b) { if (a &lt; b) { /* let there be more light... */ } } 
Pay the bills.
Let me rephrase my second point: the two queries in my comment are completely different. You said that the query plans for the two are the same, and they simply cannot be, there is no way in which that can be true. Few things are a bigger pet peeve of mine than people changing the subject so they don't have to admit being wrong.
What you think I meant is wrong. Happy? `(SELECT a,COUNT(*) FROM t1 GROUP BY a)` and `(SELECT a,b FROM t2)` produce different query plans. However two subselects and a single-select with a join *will* get the same plan because one is converted into the other by the optimizer, and if `t2` contains `SELECT a,COUNT(*) from t1 GROUP BY a` then they will have similar performance characteristics. Perhaps PostgreSQL's tree-based EXPLAIN makes this a lot clearer/more obvious than MySQL's simple list.
Thanks for the link. I used apiary.io quite extensively before I switched to swagger about a year ago. While the documentation and mock interface was great, it was leaps and bounds behind the tooling for swagger. We were developing API's which need to be consumed by several different parties and we just had them generate the base connection libraries from our Swagger spec. We also used the same swagger spec to control our routes and validation. I wrote about it here: http://appirio.com/category/tech-blog/2014/10/writing-documentation-first-api/ This was all in node and was abandon by the company (new CTO didn't preferred java) so they switched it all to java. That was a fun transition... Now that I'm with running the tech for a start up, I'm looking to add the documentation first API component back to our stack (which is mostly php). These links are really great. Thanks again for all of your work.
Yes, PHP's operators have enough problematic overloads already, I don't see why we should encourage more. Sometimes-lexicographic-sometimes-numeric comparison has already caused enough security issues. JS's + seems great but it means that JS's weak typing is inconsistent, as it necessarily cannot apply to that operator. 
I'm the author of CrudKit. Thanks for the mention :) although it won't satisfy OP's requirement since it only does simple tables. 
Why not link to https://github.com/paragonie/csp-builder instead of v1.1.0 download zip files? And v1.2.0 is already tagged. 
If you're just starting you can always do with WAMP
A lot of the imagick/gd abstraction libraries I've seen are concerned with general image manipulation. Are there any imagick/gd libraries that deal with image creation (placing text, compositing images, etc.)?
&gt; While solid, Apache is fast becoming legacy tech, if it isn't already. Apache 2.4 can serve the same amount of php requests as nginx. It's just slower for static content. http://www.speedemy.com/apache-vs-nginx-2015/
How much would you charge? Obviously doing audits for free isn't any good but I don't think open source projects ought to be billed as much as closed source ones since they're likely not making any money. Like github.com hosts open source stuff for free exactly for that reason, Travis CI is available for use for free for open source stuff, etc. I think one thing that might help ya'll is trying to partner up with accounting agencies that do SSAE-16 / SOX / PCI / HIPPA audits or whatever. Often times those audits, which are primarily driven by regulatory requirements, are done by accounting agencies and they either recommend or subcontract for security audits, in my experience. And companies that work with accounting agencies typically have $$$.
Haskell does something akin to this with its typeclasses: http://news.php.net/php.internals/89991 I'd be a proponent of this with interfaces in PHP.
That inconsistency is why I love php
Once you discover we're all someone else's asshole, it'll get easier to deal with :-)
I've been stuck on a problem for more than 30 minutes and I feel it's bad form to spend another 60minutes being stuck when I can ask you and maybe have it cleared up in five. I hate to bother you but this is company money I'm burning. Can you help me please? - just a thought...
First realize that they, like you and me, are human and fallible. We make mistakes; it is in our nature. If you are simply being ignored I recommend sending questions in emails or other electronic communications which have logs. If they resolve it by talking to you I recommend writing a summary and sending it as confirmation (it's also helpful for other reasons). Over some period of time if they continue to ignore you then you can demonstrate the issue to someone higher up the chain. It's difficult to argue with data. Do you have a dedicated manager or boss? You should probably talk with them about it if you do. If they are also part of the issue this can be tricky, but I still recommend it. If it goes poorly then ask for an appointment with their supervisor. You don't want this to go unsolved. It will be a bad experience for you and them.
&gt; Here's the sort of thing I'd do: Please don't :) Your second example will cause both COUNT() to return volume1 multiplied by volume2, also causing delta to always be 0. You can only safely join the tables if the stats are aggregated per day and the dates are unique. Otherwise you need to do subselects to emulate it. It all comes down to what the table structure actually is.
This also sounds like a lack of documentation. If these are dependencies for starting up development on the project / deploying it should be documented. Don't have any documentation? Might be a good time to start some. 
why have you decided that scientific notation doesn't make sense for population numbers?
Easy, just add occasionally functional whitespace.
Check out SOLID principle. The S stands for Single responsibility. 
i've used wamp but its not updated enough for me to use the latest php 7 features
I'm not sure why you're being downvoted. Doing something "because I can" is second only to "because people told me it couldn't be done" on the best reason to do stuff list.
Have you discuss this with the "head" of all of you?
You shouldn't, there is a reason why their "seniors", at least they should respect you and answer questions concerned with the work of everyone. This kind of behavior is dysfunctional for the sake of the company and you should talk to the "head" about it.
Talk to your senior. Explain that you're having a tough time and are not sure how to proceed on a few things. When your boss inevitably asks if you've been seeking help from your co-workers, that's a great time to calmly and politely bring up the fact that they're being fuckheads. Don't be scared. You won't get fired for pointing out that you aren't being helped. 
By no means Apache is a "lesser" solution. You just have no idea what a learning curve is and what to answer to noobs. Apache is ok for learning and he will always get help from Stack Overflow rabble regarding it. He don't need no nginx. He need WAMP out of the box and familiar environment. Either way, it's deleted topic already. 
What does "so php 7 etc..." mean?
I actually just left a software house for this exact same reason. I would ask our Lead developer questions about the shitball of a code base that is 12 years old and would get flat out hostility. Because I'm sorry, I still have no fucking idea what if($JIMMY == False){$_SESSION['DROP_IT_LIKE_ITS_HOT']} means. I finally started calling people out on it, and the environment became very unstable. One of the seniors I don't think realized they were being that way, and calmed down. However our Lead became more crude, rude, and just flat out impossible to deal with. So i found a new job and jumped ship. I tried everything, from trying to take them to lunch, to being straight up aggressive back. None of it worked, so I let my CTO know what was going down on my exit interview. Some times you just have to know that its the people around you, not you. But also, you need to identify if you're the problem. Do you distract others? play your music too loud? are you smelly? There could be a reason they are being rude, but they could just be assholes. Lots of those in development.
well said. Seniors and leads are there to be examples of how to do well. They shouldn't be there to hinder you 
I have overlooked it somehow!
You get help for nginx on stackoverflow.com as well. And recommending a wamp setup in a world where the majority of runtime environments are Linux or Unix derivatives in my opinion is harmful. If windows is his desktop environment, and he wants to work on this, a link to a vagrant tutorial for the server is in order. 
Check out the official Slack desktop apps. The way they handle multiple organisations is really quite nice
I tend to use `/* reverse = */ true` instead: - it doesn't assign/overwrite a local - it makes it very clear that it's not actually understood by the language - someone who's more used to another language (or just hung-over) might add `sort($myArray, $stable = true, $reverse = true);` (if that were a valid option) tests would still pass, but then they'll get confused after sedding 'stable = true' to 'stable = false' in a file.
Just curious, I may come off as an asshole, especially when the dialog is like this; CW: I cannot get **X** to run. ME: Okay, (turning to look at them) what have you done so far to figure it out. IF CW says 'Nothing' and 'Tech is googlable': Me: Go google that a little bit and ask a more specific question. ELIF says 'Nothing' and exists(docs): Me: Here's the docs, read them, try and ask me again. ELSE: "Well.... blah blah (try to be helpful)" If there's docs and they claim to have read them I ask what do they not understand, if it's any flavor of 'all of it' I'm done with them usually. Edit: I personally (almost) always audit the process that lead them to me. I'm a co-worker not a career trainer. 
It was 1998 and I wanted to have a forum with some added functions, so I took phpBB 1.2 and improved it, cleaned it up because I was especially unsatisfied with the convoluted design. Wanted to make it simple in use while still maintain most of the functionality. Then, I learned about the many bad design decisions including SQL injection etc. - around 2003, I redid my system with security in mind and thus started to write my own simple CMS. In 2005, based on that work, I made a much more complex system (facturation tool.. room access system with booking calendar, room heating, MySQL replication etc. Both are in production since then (10 and 8 years). Only thing missing is PDO.. Since then, I've used Textpattern on several occasions because it's small and nice. In 2013 I got to know Joomla. And again, only 2 years later I'm stuck with non-maintained modules for Joomla so can't really upgrade from 2.5 to 3, textpattern has not even mysqli - so right now, I'm redoing my CMS and I think it fulfills my needs again and contains my knowledge of today.. I know we should not reinvent the wheel - OTOH there are a lot of different wheels. And there's some PHP code I wrote (with Oracle DB) that still runs in a major pharma company - which I'm surprised myself about. I even had the chance to add funtionality in November.
I've run a load of IRC channels in the past, people generally idle and it sucks. Many folks seem more happy to chat in Slack, especially new devs who've not used IRC in the past. I might enable the IRC gateway, but whatever. It kinda feels like my dad banging on about LPs and beta max whilst five year old kids are streaming music from spotify on their iPad. They're both ok or whatever.
I think the better way of doing this is to pass the credentials in the header using oauth2 authentication. Your Rest server should negotiate the credentials first. Once authorization is completed, you pass the auth token in the header for the subsequent requests. 
For all the occasional abrasiveness and heated discussions, PHP internals seems to have been generally civil. That said, I think a code of conduct is important, because sometimes assholes are going to stir shit, and having a process for dealing with that means people won't be scared off by it and will discourage people from doing it in future. Even if I don't seem to recall us having had big issues (to *my* knowledge - there's stuff I don't know... and now that I think about it, I think I'm looking too favourably on the past, especially w.r.t. reddit/Twitter EDIT: turns out there have been past problems on internals, at least, and people have been banned) up to now doesn't mean this is unnecessary. Never having had a fire doesn't mean you don't need a smoke alarm. And I get the unfortunate feeling that the response to this proposal might get nasty and end up justifying the proposal... Lewis's law. Also, it makes people a sense of security. If you've been burned by arseholes in another project, us having a CoC means you know there's a set of rules laid down and someone to turn to if something does indeed happen.
He's right. It's not going to be in 16.04. Sad face.
"Thoughtless use of pronouns" is a major problem in the PHP community? Really? *These* are the issues we face? It's already hard enough to be taken seriously as a developer when I'm asked my preferred language and I reply "PHP." This nonsense isn't going to help the perception of the language any. 
Many organizations get PHP as part of the distro. Most of the time only LTS distros are used. Even then, many companies will wait 6 months after an LTS distro is released. For example, 6 mo after Ubuntu 14.04 LTS came out, lots of people moved over. PHP7 came out too late for Ubuntu 16.04 LTS. Therefore, many people wont upgrade to PHP 7 until Ubuntu 18.04 LTS. That will be April 2018. Given a 6 month wait...that puts us at October-ish 2018. Wow, that's crazy, I know. Honestly, I'm not going to wait. 
&gt; I'll be voting no on this, passionately. This would effectively introduce a secretive tribunal by which political and ideological "opponents" can be silenced and punished. What makes you believe such powers would be abused? And it's not "secretive". It would report on its actions. Yes, it won't name the victim or reporter in certain cases - neither does a court in sensitive matters. If people want to silence "political and ideological opponents", they already can. There are several people who can, already, do such things as revoke commit rights, ban people from the mailing list, ban people from the wiki, redact commits, and so on. Yet they don't abuse those rights. &gt; It also gives sweeping powers within the project without any evident oversight or transparency. As previously mentioned, there are already people with these powers. There is oversight: the project leaders and, more importantly, the RFC process. There is transparency: decisions are public, permanent bans are publicly debated, the process for creating and managing the group is public – heck, **we are using the RFC process to create it**, the rules by which it functions are public, and **this RFC will be subject to a vote**. Furthermore, we're setting down *rules*! That's much better than shadowy unknown figures deciding things by personal whims. A CoC makes it clearer what is acceptable and what is not. &gt; That any CoC team member could effect "temporary" bans on people by their own discretion is a terrifying thought. No, it doesn't say that. The RFC says: &gt; **The CoC team** will vote internally on the recommended course-of-action (emphasis mine) And why the quotes? The RFC even says that: &gt; If the CoC team determines that a longer temporary ban or a permanent ban is necessary, they shall institute a temporary ban and raise an RFC to the general project to effect the desired ban. There's no fake temporary bans. And as the RFC mentions in another place, there is a hard 1-week tempban limit. &gt; I have to ask - can anyone point to a particular incident that's already occurred within the project that would have been prevented or better handled by having this sort of "code of conduct" in place? Yes. PHP internals has had to ban people in the past. And we had to do that in a non-transparent fashion, because we had no proper process, which obviously invites accusations of abuse of power, and makes it difficult for people to properly act. But this process creates a proper CoC team with actual specific rules, using the democratic RFC process. It is much better than Zeev Suraski having had to personally permaban someone by personal discretion with no oversight.
As a manager, I can't stress the importance of bringing up issues to as many people as can possibly help your situation (even coworkers who may not be able to change things directly, but can maybe help communicate to those who can). Very few people have the ability to read subtle clues we give off when things might be bothering us. This is especially so if there are layers of hierarchy that inhibit communication. Sometimes you might have even told one boss something, and that person simply forgot (we're human, it happens!). Bring it to someone's attention, and remind them if you don't feel like anything is happening, especially if it's important (and your happiness is important, or at least it should be). A problem can't be fixed if no one knows the problem exists.
Whitespace is always a clear delineator for tokens. I can't think of anything in any language where one token contains a space (besides the language 'whitespace' I guess).
The major difference between how things are now, and how this RFC would have things, is that right now there's no defining factor that gives someone such powers other than that they worked for them. This RFC would give powers specifically to people who have an axe to grind about conduct. Given the current political power balance in the community, I suspect most of the people on this CoC team would lean hard to the left in their personal politics. I've seen the operator teams for popular community IRC channels get stacked this way over the past couple of years. It's why I left #phpc and have no plans to go back. I don't want to drag open some drama that I'm hoping has already passed from memory, but I personally have been on the receiving end of abuse of power by people in powerful positions in our community. It was horrible, and it's practically impossible to prove. This also doesn't seem any more transparent or fair than our current lack of process. This creates a secret tribunal with an explicit mandate to hide the details of complaints from everyone but themselves, with sweeping powers to silence or banish project members. There's no mention of how due process will be maintained in these sorts of issues. Will the accused have the right to know the details of the incident, or "face their accuser"? I'm guessing not.
A set of rules as to what is acceptable and what is not, and a system for enforcing them? This way it's at least clear where the line is, and you have at least a way to deal with stepping over it, rather than an ad-hoc system. Codes of conduct are hardly a new or unusual thing. Lots of projects have them. The one that this RFC proposes to adopt, for example, is also used by Swift, Ruby, Eclipse and GitLab, among others: http://contributor-covenant.org/ If you've ever been to a tech conference, it's not unlikely it had a code of conduct. See PHPNW15's, for example: http://conference.phpnw.org.uk/phpnw15/extras/code-of-conduct/
It is mixed to piss off both parties equally. 
&gt; The major difference between how things are now, and how this RFC would have things, is that right now there's no defining factor that gives someone such powers other than that they worked for them. To some extent, yes. Though it's not like it's really completely fair. A lot of power comes simply from being the first person there. &gt; This RFC would give powers specifically to people who have an axe to grind about conduct. It would give powers to people who care about the community being an inviting place. If people have a massive "axe to grind" or conflict of interest, it is most likely obvious, and they won't be placed on the committee. &gt; Given the current political power balance in the community, I suspect most of the people on this CoC team would lean hard to the left in their personal politics. Why would political leanings matter? How you adjudicate should have nothing to do with your political leanings, unless they include a belief that certain people do not deserve fair treatment. &gt; I've seen the operator teams for popular community IRC channels get stacked this way over the past couple of years. It's why I left #phpc and have no plans to go back. Could you elaborate? &gt; I don't want to drag open some drama that I'm hoping has already passed from memory, but I personally have been on the receiving end of abuse of power by people in powerful positions in our community. It was horrible, and it's practically impossible to prove. &gt; This also doesn't seem any more transparent or fair than our current lack of process. Having an explicit process with actual rules means you know what constitutes unacceptable behaviour - you don't need to self-censor in fear, you don't get people thinking saying horrible things to people and harassing them is accepted. And having the people with power actually elected means, well, you know them, and you have at least some say in who they are. Why is that no improvement? &gt; This creates a secret tribunal with an explicit mandate to hide the details of complaints from everyone but themselves, with sweeping powers to silence or banish project members. There's no mention of how due process will be maintained in these sorts of issues. Will the accused have the right to know the details of the incident, or "face their accuser"? I'm guessing not. Unfortunately, you can't necessarily have a completely public process, due to the nature of certain things that might be reported (for example, if someone's personal information is publicised, or if outright libel is posted). I suppose due process may be an issue in some cases. I'm not sure what you could really do about that.
&gt;Don't start an RFC (or mail list discussion) about standardizing PHP function names and function argument orders. There are several historical reasons why the functions are what they are (including compatibility with underlying libraries), and many good reasons why the change would be counter-productive causing more end-user confusion, would lead to unmaintainable PHP engine code, and generally be a waste of everyone's time when they could be doing more interesting projects. This has been discussed ad infinitum. Review previous discussions and feel free to fork PHP on github. https://blogs.oracle.com/opal/entry/the_mysterious_php_rfc_process oh :/ 
&gt; For women in tech who are sick of being called men all the time, it can be a problem. While this is totally valid, part of the problem is just English lacking a singular, genderless pronoun. The trend seems to be appropriating "they", but I know all of my grade school English teachers die a bit each time it's done (and "one" just feels awkwardly formal even when it does work)
I'm not going to point out single tweets or go witch hunting. I've also just noticed that a specific tweet I had in mind (which was pretty mysoginistic) wasn't in reply directly to @ircmaxell but rather to someone retweeting him.
&gt; I don't feel particularly invited in a community when it has explicit rules stating that saying "offensive" things (by someone else's constantly-changing definition of offensive) is grounds for summary banishment You would surely be warned if you were found to break the rules. And realise that an awful lot of people do not want to be part of a community where people are *allowed* to say these things. &gt; I shouldn't have to be careful about what I say in private, or in unrelated public areas, for fear that I might have my career ended by someone a little too fervent in their ideology. Well, if you're not saying it in the context of PHP, you're okay. &gt; Under your idea of "conflict of interest", would you say that you yourself would qualify to be part of the CoC team? I'm of the opinion that someone who's in charge of policing conduct shouldn't have a strong political ideology about conduct. Having a "strong political ideology" doesn't mean much. Everyone has an ideology. There's nobody who's neutral. Somebody who hates CoCs has an ideology. Someone who loves CoCs has an ideology. Someone who things both stances are silly has, too, an ideology. &gt; I'd no more want a radical feminist (not that I'm saying you are - I don't know your political leaning) having that power than I'd want a vocal racist. Both are likely to discriminate against those they disagree with. Everyone has biases against others. The question is whether those biases are problematic. &gt; I'd rather not. I'm already getting uncomfortable having this discussion, for fear that being involved is going to result in my career being affected, as it has before when I've said anything. Stating specifics would probably result in the same. Fair enough. &gt; Rules are often bent to suit the narrative that people want to put forward. Sure, rules can be bent, but even then this is better than no rules at all. Currently you are dealing with the whims of moderators. Now they have to justify their actions against rules. &gt; Let's say that someone goes into my comment history on reddit and grabs one of the anti-feminist opinions I've certainly expressed, as evidence that I'm harassing/insulting/demeaning women. I would never do any of those things knowingly, but it's not uncommon for certain people to paint controversial statements as offensive ones. &gt; My personal politics shouldn't dictate whether I can be part of the PHP project, as long as my activity within the project is respectful. Well, again, if you're saying things under the PHP banner, that is a problem. But generally personal opinions are not a problem. &gt; If someone wishes to make a complaint, it should be public. Anything less is guaranteed to result in corruption. Anything that deals in private personal details should certainly not be in the scope of the PHP project in the first place. That's more likely to be a matter for the police, if it's worth pursuing at all. The police can do all sorts of things, but they can't deal with this quickly (and that's in the unlikely case that they deal with things at all), and they can't ban people from posting on the mailing list or committing to PHP. If someone is a determined harasser, you need quick action lest the target leave the project. Complaints being public may be an option in some cases, but it isn't in all. Again, inevitably you have to have some degree of trust. The courts do not make everything public for a reason. ---- One thing I should question: if you are so fearful of abuse of power, then why are you in the community now anyway? People already have this power. What makes you opposed to putting in rules and an accountability system so that power can be more fairly exercised?
&gt;Chances are the team will end up being made up of people who have commit access anyway. But I assume the reason to give them powers is so if someone abuses their powers to add, say, someone's personal information into PHP's permanent git record, it could actually be gotten rid of. In that case they should ask one of the project maintainers to do it. I can think of no reason for CoC members to have commit access beyond what they may already have earned through actual work. &gt;It does leave some room for abuse, but that's why you need to trust the team. And what if someone doesn't trust them, for good reason? Is there a process by which a CoC team member could be removed, that doesn't rely on popular opinion agreeing already? IMO, if more than a couple of project members object to a person being on the team, they shouldn't be allowed on. To allow otherwise would breed resentment. If this passes, I'd like to see every member of the team being *completely uncontroversial*. &gt;The problem here is that in certain cases, making the accuser's name public may set them up for abuse and harassment, especially if it is against a popular figure. What about the accused? They deserve just as much protection, if not more. The potential for false accusations *must* be considered.
+1 for the oversight/group/processes -1 for that ambiguous, self-evident code of conduct
&gt; In that case they should ask one of the project maintainers to do it. I can think of no reason for CoC members to have commit access beyond what they may already have earned through actual work. Can you justify why they shouldn't have it? It's not like there's no record of whether it has been used. If it's abused, the project maintainers can deal with the CoC team. &gt; And what if someone doesn't trust them, for good reason? Is there a process by which a CoC team member could be removed, that doesn't rely on popular opinion agreeing already? You could complain to someone, but no, there's probably not much you could do. But remember that this is **the current situation anyway with PHP administrators** - and this is generally true of any project. Nothing is new here. &gt; IMO, if more than a couple of project members object to a person being on the team, they shouldn't be allowed on. The PHP project has literally hundreds of contributors. No democracy can function adequately with absolute vetos. Now, if you have a serious, reasoned and evidenced objection to someone being on it, perhaps it might be listened to. But you're holding it to an impossible standard. Again, there is already this problem with power. &gt; To allow otherwise would breed resentment. If this passes, I'd like to see every member of the team being completely uncontroversial. Then we will get an ineffective CoC team, because anyone who suggests actually *enforcing* the CoC would be rejected, at the very least by you. &gt; What about the accused? They deserve just as much protection, if not more. The potential for false accusations must be considered. Sure.
&gt;And realise that an awful lot of people do not want to be part of a community where people are allowed to say these things. Then they should leave. They're apparently too immature to be part of a community of adult professionals. &gt;Well, if you're not saying it in the context of PHP, you're okay. History has shown otherwise, time and again. &gt;Sure, rules can be bent, but even then this is better than no rules at all. Currently you are dealing with the whims of moderators. Now they have to justify their actions against rules. Having rules is not better than having no rules. Those who would act irresponsibly will do so no matter whether or not there are rules in place. &gt;Well, again, if you're saying things under the PHP banner, that is a problem. But generally personal opinions are not a problem. Why is it a problem to say these things in the context of PHP? I'm doing so right now. I am expressly opposed to the modern radical feminist movement. Am I going to be banned, now? &gt;The police can do all sorts of things, but they can't deal with this quickly (and that's in the unlikely case that they deal with things at all), and they can't ban people from posting on the mailing list or committing to PHP. If someone is a determined harasser, you need quick action lest the target leave the project. So what you're saying is that you want to take a shortcut around due process, in the interest of punishing those who *might* have done something you consider wrong, regardless of whether or not it's illegal. &gt;if you are so fearful of abuse of power, then why are you in the community now anyway? People already have this power. What makes you opposed to putting in rules and an accountability system so that power can be more fairly exercised? Very recently I did nearly leave the PHP community. Instead, I chose to stick around in the parts of the community that haven't been brought under heavy political control by ideological zealots. That being said, those parts are becoming increasingly few. I'll fully admit that my days in the community are probably numbered, despite not having done anything wrong. Simply by disagreeing with this political ideology being put forward, I'm likely to be pushed out. This CoC doesn't create any more fairness in the process - it only codifies what many have privately feared. It expressly states that radical feminism is now the enforced ideology of the PHP project. And all those who disagree with this will be told to leave.
&gt;Can you justify why they shouldn't have it? Because they don't need it. They have no legitimate, prescribed reason to ever use it, therefore the only reason they'll ever use it is for bad reasons. &gt;But remember that this is the current situation anyway with PHP administrators - and this is generally true of any project. Nothing is new here. As I've said before, what's new here is a lack of ideological diversity. You're shifting the power to police conduct from those with qualifications, to those with popularity. &gt;Now, if you have a serious, reasoned and evidenced objection to someone being on it, perhaps it might be listened to. That presumes that those listening are reasonable, evidence-respecting people. What's more likely is that this will become a popularity contest, with serious real-world consequences for anyone on the outs. &gt;Then we will get an ineffective CoC team, because anyone who suggests actually enforcing the CoC would be rejected, at the very least by you. It'd be me, and at least a couple of other project members. If multiple project members oppose enforcing the CoC, then it's probably best the CoC isn't enforced. Since you're assuming that the CoC team will act rationally, you should also assume that other project team members will as well.
The problem with adding extra names is that now you have two sets of names to worry about. If you simply change the names and don't allow the old ones anymore, now all PHP code in existence is broken. Maybe scalar type methods will save us someday.
&gt; Because they don't need it. They have no legitimate, prescribed reason to ever use it, therefore the only reason they'll ever use it is for bad reasons. They do have a legitimate reason I have already mentioned: abuse of PHP commit rights to publish, for example, someone's personal information. &gt; As I've said before, what's new here is a lack of ideological diversity. You're shifting the power to police conduct from those with qualifications, to those with popularity. PHP is, for better or for worse, not actually a meritocracy at the moment. People with power don't have it because of, necessarily, qualifications, but simply because they were handed it. Now, usually that's because they played some important role. But still, the system is informal. There are people who have power literally because of popularity. Also, you're basically arguing against democracy itself with that. &gt; That presumes that those listening are reasonable, evidence-respecting people. What's more likely is that this will become a popularity contest, with serious real-world consequences for anyone on the outs. Can you justify this claim? The PHP group seem to be reasonable overall, no? &gt; It'd be me, and at least a couple of other project members. If multiple project members oppose enforcing the CoC, then it's probably best the CoC isn't enforced. Why is your voice more important than a hundred others'?
Because C# did not exist back then. And Ruby has never been popular where I live. And Python devs still can't decide between 2 and 3. So I'm stuck with PHP (and node) for now.
&gt;They do have a legitimate reason I have already mentioned: abuse of PHP commit rights to publish, for example, someone's personal information. That's not at all a legitimate reason. That's something that existing project contributors already have the right and reason to handle. Let them do so. &gt;PHP is, for better or for worse, not actually a meritocracy at the moment. People with power don't have it because of, necessarily, qualifications, but simply because they were handed it. Now, usually that's because they played some important role. But still, the system is informal. There are people who have power literally because of popularity. The people who have the power to revoke access are, so far as I know, in that position exclusively because they have qualifications, they've done the work, and they've earned the respect of other project members through hard work. Please point out the people "in charge" who are undeserving in your mind. &gt;Also, you're basically arguing against democracy itself with that. I'm arguing against electing people for the express purpose of silencing others, whether or not it's justified to do so. Someone whose role is to censor is more likely to censor than not. Leave that power to those who have better things to do than to censor people unfairly. &gt;Can you justify this claim? The PHP group seem to be reasonable overall, no? You can't have it both ways. Either project members can be trusted to behave reasonably, reliably, or they can't. If they can, then this code of conduct is unnecessary. If they can't, then you shouldn't give people unchecked power. &gt;Why is your voice more important than a hundred others'? Because the minority should be protected from the majority. I assume you agree with that sentiment.
sure, but what else could 1234 1234 be? I'm just saying it's not ambiguous, either it's a syntax error or it's one big number.
There's another good reason to *not* use this CoC. It's very ambiguous. When enforcing the code, are the CoC team members going to apply the word of the code, or what they perceive as the "spirit" of the code? Does something mentioned on the Contributor Covenant website define what's unacceptable? The code itself specifies "Other unethical or unprofessional conduct" as unacceptable. Who's to define what is unethical or unprofessional? In my professional workspaces, people often make jokes that might be considered unprofessional by others.
Yup, just what I was taught. Technically correct or not, I'd rather avoid specifying a gender unless speaking to or about a specific person. And it's not like I have people grading my writing anymore. 
&gt; The backlash against any hint of "PC Police" being introduced to a project is far greater than the PC police themselves. Yeah, theoretically we don't need it. In practice the fact that some people are responding to the suggestion of having an enforced "Don't be a dick" rule with this much outrage shows we probably do actually need an "Enforced don't be a dick rule".
Hey! So, anyone actively against the concept of having a CoC at all is essentially saying [what happened in the FreeBSD community sounds cool](http://blog.randi.io/2015/12/31/the-developer-formerly-known-as-freebsdgirl/). Read that article to see why such a thing is needed. Anyone with concerns about specific wording who wants to make this CoC better: cool, pitch in. Now, some folks seem a bit concerned about this: &gt; - Revert or edit existing commits Whilst it might at first seem completely unnecessary for a group - of what essential amount to moderators - to be given the power of code change and code reverting, this has a few reasons **1.) To combat "Nah it's fine"** I have in the past been involved in stupid dramas like the `foreach ($model as $babe)` thing in CodeIgniter. I - as somebody with commit access - refused to merge the PR at the time which would change `$babe` to `$model_class`, using two arguments. One being that it was funny, as I was younger and ignorant to a lot of things. The second reason being that CI had sod all unit tests, so changing that variable could easily have ripple effects. Trust me, CI used to use variables after a foreach to access the value of the last iteration and all sorts of nasty shit. Regardless of that reasoning, the code should absolutely have been changed, and one of these CoC members would have done that. In the end the company who owned CodeIgniter forced the change, but PHP doesn't have a "parent company" to enforce such things. **2.) Angry commits** Over at the PHP League we've avoided any controversy around code itself, which is nice. That's one benefit of the group mostly just being a big group of friends, but we have had one incident. We had one guy who was just being an asshole to everyone. Condescending beyond belief to new contributors sending their first PR, bullying people, etc. He was a real shit. We took a bit too long to merge his PR and he flipped the fuck out, tried asking for all of his changes to be reverted. If he'd had commit access he might have done something silly, which needed to be reverted. These CoC members could potentially need to revert a malicious act, or it could be that they do indeed want to revert this persons code to get them to shove off. &gt; - Reject pull requests Some people get super angry when their PRs aren't merged, and flame wars can pop up really quickly. Locking and stopping a PR is absolutely within the realm of a CoC groups remit. &gt; - Revoke commit karma If you're under investigation as a cop they take away your badge and gun. Seems like an active asshole (or suspected asshole) should probably not be making commits to a codebase. &gt; - Issue temporary ban (no more than 7 days) Seems fair too. This change makes sense, and those fighting against the CoC in general are the reason we need a CoC. Don't let people be pushed out of contributing just because some folks want the right to be bullies. 
&gt; I have to ask - can anyone point to a particular incident that's already occurred within the project that would have been prevented or better handled by having this sort of "code of conduct" in place? The heated language used in the conversation about scalar types went too far on list, and on Twitter some people were using more heated language that crossed over into threatening. &gt; Would comments made in private, in the community, or on social media potentially constitute a violation? Threats against people for "Destroying PHP" would probably be a violation. Let me turn your question around though; If you don't think there are (m)any places where a CoC needs to be enforced, what's the problem. And no, they aren't going to be acting like a secrete Gestapo - they are really unlikely to take strong action against anyone, unless someone is egregiously being an ass. Are you really saying that you reserve to be a much of an ass as you want, without any clear rules about what to do when you act like that?
&gt; I am expressly opposed to the modern radical feminist movement. Am I going to be banned, now? Huh? Why would it? The language in the code of conduct is pretty clear: * The use of sexualized language or imagery * Personal attacks * Trolling or insulting/derogatory comments * Public or private harassment * Publishing other's private information, such as physical or electronic addresses, without explicit permission * Other unethical or unprofessional conduct As long as you don't do those things, you're good. As long as you don't, say, reject a radical feminist's commit on the grounds that they're a radical feminist, you're ok. I believe you're having a strong emotional reaction to this proposal, which of course is valid; all emotions are. But claiming that having rules is not better than not having rules is, IMO, shortsighted and an emotional reaction rather than a rational one -- ironic because this process is trying to _remove_ emotion from the room. Instating a code of conduct means that everyone agrees to terms of behavior up front. And don't forget, the code of conduct protects you, too. Without a code of conduct, some maintainer could say "oh, frozenfire committed something? Weren't they the one that voted against the code of conduct? What kind of animal would vote no on that? I'm going to reject these pull requests because I don't want someone like that in the community". Without a code of conduct and a review process, that maintainer could _actually get away with doing that to you_ if they had enough clout in the community. _With_ a CoC, however, you'd submit a complaint, and a CoC volunteer would be honor-bound to investigate and do something about what's clearly "Unethical or unprofessional conduct"
I would typically setup an offline cron job to process and summarize the raw data, and then store the summarized data in its own set of database tables. You can design your summary tables to include whatever data you need to generate your trend lists easily and efficiently. My summary tables are usually denormalized so the queries for the reports/charts/trends tend to be simple select queries with little to no joins, and they tend to be very fast. The catch is your trend lists can only be as up-to-date as the last runtime of your cron job. If you want real-time stats, then this approach wouldn't work :( I'm a fan of optimizing for read performance, so whenever possible I try to do processing offline and then store the data in such a way that select queries return damn-near instantly.
You got a Job, just by sticking with it you will grow and be more valuable per default, that is great. But what are your goals? No matter what your goals are. It probably will not hurt to follow your passion and work on/try stuff that you think is interesting / fun. Doesnt matter if its a cool new html5 feature or a completely different language or framework or whatever. No matter what you will learn not only that specific feature/api/lang but you will as a side effect be exposed to new ideas, patterns, styles from that feature/api/lang. This translates to a broader toolbox for when you need to implement new stuff, understand other stuff, fix broken stuff etc. 
I wouldn't underestimate the human capacity for shittiness. 
I remember having a long argument with you once, where you would downvote every single one of my reply (despite having no objectionable content other than disagreeing with you) before responding. I am not sure something like this RFC is going to do good in the hands of people like you, who cannot even restrain themselves from doing such a moronic thing. I know that the rest of /r/php is not much better. But I did expect better from a core developer, (at that time, but not now). 
/u/the_alias_of_andrea it will be even better if you could write an rfc to remove *idle* members /ie: members who have contributed to php in the past but now visits the pages *only* to vote on things!!/ 
[Imagine](https://imagine.readthedocs.org/) might work for you.
what does that have to do with anything about the CoC and the committee(s) charged with enforcing it in projects that have already adopted such a code of conduct. Unless /u/magicpretzel has seen such things happen in projects that have adopted such codes, then they are just talking nonsense. It's not like these CoCs are new. Evidence of abuse should have occurred by now.
&gt; what if($JIMMY == False){$_SESSION['DROP_IT_LIKE_ITS_HOT']} means Easy: It means "unexpected }" 
It is a defensive maneuver.
In the 3rd section right now and this is just awesome! It's definitely beginner friendly but keeps the complete n00b stuff inside boxes that you can skip over. This is perfect for me where I have lots of experience coding but not in PHP yet I still want a solid beginner experience rather than the "best practices" feel of the PHP The Right Way guide. I love how you really delve into the mindset of coding, in terms of how to change the code, how to think about refactoring and even showing good documentation of functions! Truly a great guide so far! I'm gonna keep cranking away at this for the next couple of days. One thing I'll add before delving back in, I had an error (I'm typing this by hand rather than copying) and it took a couple of searches in google before I figured out where I needed to look for errors (`/var/log/apache2/error.log`). Might be a good box to add or even a purposeful error that you walkthrough how to find and resolve.
Because the code for it works just fine? I provided you a means to build your own unofficial instagram web app. 
Thank you for posting these. &gt; In which PMJones, loses his shit Even with his use of overly dramatic language, I wouldn't consider that "loses his shit". He does seem irritated though. 
you haven't yet proven that CoCs has caused any problems like that. ATM you're just talking out your ass. In any case, if a project decides allowing assholes is ok as long as they submit good code, then more power to them. However, for folks like me, who work on open source software all the time, we actually like knowing that such folks aren't tolerated. I'm way more inclined to work on projects that adopt CoCs than those that don't.
agreed.. Only currently active members (for some defintion of active) should be able to vote on RFCs
I replied, but then deleted the contents when i realized that your opening sentence left little doubt that you're not actually interested in hearing anything.
&gt; I replied, but then deleted the contents when i realized that your opening sentence left little doubt that you're not actually interested in hearing anything. Well that's constructive. Good job.
What about genderless he/him/his? 
Actually, from what I've seen in other projects and irl situations, people in these positions are typically not enthralled with the responsibility of enforcing these rules. Everyone knows from ample public examples what a colossal mess can result from not properly following the established process, or not having an established process at all. The group elected to handle the CoC process will have a thorny and uncomfortable job. If there is no process, then any dispute is handled either quietly by existing administrators (often unused to handling these kinds of issues) or publicly by application of brute mob force via social media and general disruption. When the first fails, the second takes over, and then you have a mess. The disturbing thing that will most likely follow is an influx of abuse and trolling from internet libertarians who wish to defend their right to heap abuse upon whomever they wish, in whatever form suits their whims. This has happened to a number of projects which have implemented a CoC. The cencorship and abuse of power they rail about never seems to materialize though. I was rather surprised to see /u/pmjones come out so strongly against this though. Kudos to /u/ircmaxell for tanking the aggros, as usual. Also to /u/the_alias_of_andrea for putting up with the /r/php boys club bullshit.
Link all you want, I'll write more. COCs have been on my mind for a long time. My description is completely accurate. I'm glad to see that I'm not alone in condemning this terrible RFC.
Yes, any time I see people volunteering to police the speech of others based on their political opinions, and being applauded for it, I get testy.
http://contributor-covenant.org/version/1/3/0/ The actual text of the "covenant" appears quite reasonable. What part of this text do you find unacceptable, or overly feminist-centric? Eliminating harassment, trolling, personal attacks, and doxing seems, well... like basic requirements for any professional setting. The covenant itself doesn't really appear to be dripping with feminist agenda.
&gt; their right to heap abuse upon whomever they wish Talk to /u/philsturgeon about that one; he's the one of the most abusive persons I've met when it comes to writing-on-the-internets, and he seems to get a free pass. Tosser, wanker, cunt, fuck-all, dick, douche; whatever he likes to say seems fine. But say "censorious fascism" and suddenly you're "hateful."
"Sure your code is good, but you called her a "him" so now your contributions are tainted and will be removed. Buh-bye"
Maybe an approach like the approaches done for middlware would be suitable. Chaining different middlewares and passing the request through each of them. I only have this example for you here https://laravel.com/docs/5.2/middleware
I don't want to get too involved in this discussion, but this part of your comment stood out: &gt; If you don't think there are (m)any places where a CoC needs to be enforced, what's the problem. To me that sounds dangerously close to the "If you have nothing to hide why are you concerned if the government/police/whomever reads your emails or searches your house or listens to your phone calls" argument. I'm always nervous about having a sword of Damocles hanging above my head even if I—and others—don't make many attempts to cut the horse hair. But don't take my comment the wrong way—I just wanted to mention that one little part.
I'm neither for or against this but I see there are a few problems with the chosen code of conduct as I see it. &gt;As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect All PEOPLE who contribute I think "people" should be removed as it's exclusionary. So it should read "... we pledge to respect all who contribute" &gt;through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities. This is extremely specific then oddly vague. It should probably just removed or reworded. &gt;We are committed to making participation in this project a HARASSMENT-free EXPERIENCE for everyone, Harassment needs to be defined. By reading this thread apparently people are be harassed everytime I use a pronoun. Experience should just be removed. &gt;regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality. While its nice to elaborate, I think this section needs to be removed or a "including but not limited to" kind of clause needs to be added. &gt;Examples of unacceptable behavior by participants include: &gt;-The use of sexualized language or imagery Everytime I see that one of you has written CoC, I'm not thinking code of conduct. Jokes might be made. Maybe the name should be changed. &gt;-Personal attacks Add "and harassment" &gt;-Trolling or insulting/derogatory comments &gt;-Public or private harassment This should be removed, "private" is too ambiguous. &gt;-Publishing other's private information, such as physical or ELECTRONIC ADDRESSES, without explicit permission Web addresses aka URIs might need to be exempted. &gt;-Other unethical or unprofessional conduct This needs to be better defined or removed as its too ambiguous. What I find unethical or unprofessional you may find ethical or professional. &gt;Project maintainers have the RIGHT AND RESPONSIBILITY I don't they should be forced to have the responsibility so this should be changed to something like "authority". &gt; to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not ALIGNED TO THIS Code of Conduct, "aligned with this" because the wording bothers me &gt;or to ban temporarily or permanently any contributor for other behaviors THAT THEY DEEM inappropriate, threatening, offensive, or harmful. This is too ambiguous, it needs a better description. People should not be punished for someone's preferences. I don't know quite how to word this. &gt;By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow OR ENFORCE the Code of Conduct may be permanently removed from the project team. They shouldn't be allowed to hinder the process, but I don't think forcing someone to do what they don't want to is unacceptable. &gt;This Code of Conduct applies both within project spaces and in public spaces WHEN AN INDIVIDUAL IS REPRESENTING THE PROJECT OR ITS COMMUNITY. This needs to be better defined as what exactly is "representing the community". &gt;INSTANCES OF ABUSIVE, HARASSING, OR OTHERWISE UNACCEPTABLE BEHAVIOR may be reported by contacting a project maintainer at [INSERT EMAIL ADDRESS]. I think this could be summarized as "Inappropriate behavior" or "Unacceptable behavior". I see no reason to repeat a partial list that was defined earlier in the document. &gt; All complaints will be reviewed and investigated and will result in a RESPONSE THAT IS DEEMED NECESSARY AND APPROPRIATE to the circumstances. Maybe this should be changed to "appropriate response" or something similar as it is oddly worded. &gt;Maintainers are obligated to maintain confidentiality with regard to the reporter of an incident. Confidentially but not secrecy I hope
Please realise that this is a draft and Anthony is looking for feedback. So don't swear that you will vote no if you have specifics to improve but let him know (he probably will read the comments here anyways).
I would vote no on any RFC which proposes a code of conduct anything like this one, and I've not seen any codes of conduct put forward in the recent years this has been a hot button issue which make significant improvement over *what we already intuitively agree on as a society*. I also would vote no on any RFC which puts together a cultural gestapo tasked with being the judge, jury, and executioner on matters of *good manners*.
I have also seen juniors that didnt even try and that pisses me off after the 3rd time of explaining it.
it also helps finding the solution by themselves =) which is a good thing even if you got downvoted. IDK why. People here like to get spoonfed I guess.
That clears it up. So it's not the details but the concept that you are againts. Fair enough, albeit personally I don't think that your fears have ground in this case(that we will somehow get some crazy people put them on the CoC team and allow them to misuse their power).
&gt; That's not at all a legitimate reason. That's something that existing project contributors already have the right and reason to handle. Let them do so. No? If your code breaks the CoC because of whatever then it's the CoC group's job to undo that. As in that's literally their job. Asking someone else to do that seems silly to me.
The existence of the CoC group shouldn't be taken as a granted point here. I will actively and vocally dispute such a group being handed the power to secretly and summarily dismiss project members, or reverse controversial changes, over personal conflicts, the only evidence they have for which is hearsay of the worst sort. And if such a group did exist, there is zero reason to give them commit access. They can simply submit a pull request with their desired changes, and one of the competent developers in charge of that project can click a button to merge it in. You don't need to give this cultural gestapo the ability to make unreviewed, undiscussed changes to our project's code. This is not even to mention the likelihood of this issue of code being unacceptable because of its content ever coming up with regularity.
You're putting on a great show, but who do you think you're fooling? Can you say, Trojan Horse?
https://pbs.twimg.com/media/CPMkTP0VAAAtUTG.jpg
Got into it because IPB/VB was expensive at the time. Learned what it was built with and thought "I'll make my own" never succeeded (well I guess it depends on what success means to some, I made a shitty forum that was fun to create, probably littered with security holes), but I've stuck with it since then. Edit: Just [found it](https://github.com/exts/nab145), so cringy
Still using Sublime. Want to switch to PHP Storm but I don't get given time to do anything other than code in my job, and havn't had the time to do it in my own time.
Posting such tiny "tool" (it's just a wrapper over symfony/process and pdftotext) here is IMHO an overkill. Anyway, the API seems bad, you create a new object of `Spatie\PdfToText\Pdf`, then set a PDF file ON IT, and call `text()` to extract it. Fluent interface is here is just wrong. It should work like this: $pdf = new Spatie\PdfToText\Pdf(); $text1 = $pdf-&gt;extractFrom('./pdf1.pdf'); $text2 = $pdf-&gt;extractFrom('./pdf2.pdf'); $text3 = $pdf-&gt;extractFrom('./pdf3.pdf'); // and so on so that you can use it as a service.
The definitions of "trolling" and "harassment" are very, very blurry. Some people consider disagreement "harassment" and there's even a new derogatory term for asking serious questions politely - "[sea lioning](http://knowyourmeme.com/memes/sea-lioning)" ("engage an unwilling debate opponent by *feigning civility* and [...] *requesting evidence*") So no, the language in the CoC is not clear, far from it. It's as vague as possible, with a door open to redefinitions in the form of the last point, "Other unethical or unprofessional conduct".
You should really look deeper into Randi Harper's claims if you believe her. She has a strong motivation to overstate her victim status.
My 2 cents: I think we can all agree that as a community we want to attract the best developers out there to contribute to and improve PHP for all of us. In furthering that goal, it makes sense that we are seen as a welcoming community to all those who may wish to contribute. Having a clear set of guidelines that are agreed upon by the community as to what will not be tolerated in our community (ie. things that make our community less welcoming, racism, homophobia etc) sends a clear message to all those who wish to contribute. If we have a set of guidelines, then there needs to be a process for when someone breaks those guidelines otherwise we're just paying lip-service to wanting to be a welcoming community. Of course it follows that we'd need to appoint someone, or better yet, a body of people, to enforce those guidelines. Now it seems to me, that those are all very reasonable steps for a community to take, and what we need to do now is hash out the details. What we should be debating is not whether we should have a policy and processes, but what those guidelines should look like and how the process should be handled.
&gt; So, anyone actively against the concept of having a CoC at all is essentially saying what happened in the FreeBSD community sounds cool Hey, why do you keep linking just to Harper's blog and don't link to the other side, Meixner? https://lists.freebsd.org/pipermail/freebsd-questions/2015-June/266479.html You can read what allegedly escalated it and judge for yourself: https://archive.is/9KGyX &gt; kindly go fuck yourself &gt; go. fuck. yourself. &gt; you're a fucking disservice to the project &gt; i wouldn't have even known who you were had you not decided to be a dumbshit &gt; you grow up, you piece of shit. &gt; another privileged dumbass &gt;A: Good night. B: good B: go fuck yourself.\ All in the span of 12 minutes.
Disagreement == outrage == need for stricter rules?
So what, someone is angry. You want to imply he would get banned if CoC was already in place?
Certainly sounds like a lack of documentation. According to Zend Coding Standards, every file, class and function should include inline docblock which basically explains the necessary details. Even if you are not using Zend explicitly, it is a good guideline to follow. In addition there should be some sort of documentation repository available. A Wiki is a good starting point to start looking into - MediaWiki is fairly easy to set up and use. Another way to generate documentation specific to source code is applications such as phpDocumentor which are able to generate docs straight from the code. I hope this helps.
Fascinating. Tell us more.
The entire CoC shtick itself is a hell of a hyperbole. A power grab over made up ambiguous BS. 
When dealing with so many people from different backgrounds/cultures having a Code of Conduct I would argue is almost essential. There has to be some form of appeal process though where power can be delegated if abused.
&gt; Let me turn your question around though; If you don't think there are (m)any places where a CoC needs to be enforced, what's the problem. Let's have it anyway since we don't need it! &gt; And no, they aren't going to be acting like a secrete Gestapo - they are really unlikely to take strong action against anyone, unless someone is egregiously being an ass. &gt; Make me dictator. I won't be acting like a dictator. I'm unlikely to take strong action against anyone, but do give me the powers to do so for sure; yeah, unlikely, unless they're being an ass, and I decide what that is. &gt; Are you really saying that you reserve to be a much of an ass as you want, without any clear rules about what to do when you act like that? Clear rules: power grab. Quit bullshitting. 
&gt; They make a recommendation to the rest of the CoC team based on their findings And of course the rest of the CoC team are of the same CoC/political persuasion. &gt; If you don't trust this system, you shouldn't trust any legal or court system Yup, power grab indeed. That's all it is. 
&gt; If you think PHP doesn't matter then quit pushing for this CoC crap and go busy yourself with better things. No, I think that PHP as a community should be more inclusive, but what power is there to be had over PHP? Seriously, it's an open source language that can be contributed to by anyone and forked for whatever reason you want. The CoC is just a way to lay down guidelines for what happens when one member starts abusing or harassing another. And when you have a community, you need that, regardless of what it is. &gt; It is precisely that. A Cultural Gestapo. The entire CoC document itself is a cultural bullshit document, and the attempt by cultural activists to grab powers to ban people over cultural bullshit is an attempt to put in place a cultural police that wants to operate in "confidentiality". I don't... what are you even trying to say here? I don't understand. You're just blabbering at some point. &gt; Maybe if you don't want to be called a Cultural Gestapo, don't propose becoming one. Three points 1) A CoC is not a cultural gestapo, it's just guidelines on how to handle things that need to be handled 2) If you don't like it then please give your input in how to solve the very real problem in tech. How do we solve the toxicity in the PHP internals? How do we deal with members being harassed? I'm not being facetious, come up with a solution. Propose it. Discuss it. 3) You seem to think I'm pushing for the CoC. I'm not. I'm not an internal, I only saw this RFC from this very post and I'm not invested in this solution. I'm just saying that there does need to be a solution. If not this, then another one. But come on. Even you must know how ridiculous it sounds to call it a gestapo. Surely you must know. I mean, really. Come on man
Haha. All you PHP devotees in this thread need to learn to take a joke. 
[removed]
[removed]
[**@philsturgeon**](https://twitter.com/philsturgeon/) &gt; [2016-01-05 04:16 UTC](https://twitter.com/philsturgeon/status/684226861447143426) &gt; Place your bets on how long it takes for somebody to say “Lol Phil supports CoC? He’s the biggest asshole out there!” Im guessing… 15:00 UTC ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Ah yes, but this is the nice thing about rules. The people who enact them and support them are just as subject to them as anyone else.
[removed]
[removed]
[removed]
&gt; To me that sounds dangerously close to the "If you have nothing to hide why are you concerned if the government/police/whomever reads your emails or searches your house or listens to your phone calls" argument. You've got a point but the tradeoffs are different. A government abusing their power, has the ability to completely ruin someone's life by sending them to prison and decisions are made by civil servants who are protected by all of the governments lawyers. A CoC for an OSS project has the power to, er, stop people from contributing to that OSS project....and doesn't have a massive bureaucracy to hide behind. I really find it hard to believe that anyone who was to be selected to be on the "Don't be a dick council" would actually want to do more work than they really had to, or that anyone thinks they would get away with abusing their power massively, i.e. completely inventing 'crimes' that someone has committed. About the only thing they could be likely to do is over-react a bit to people being dicks.....the worst outcome that would result from that is that people who be told to take a break for a few days....which is not the worst thing ever. 
My former line manager implemented a 15-minute rule for exactly this reason. If you haven't made any significant progress towards a goal in 15 minutes, I was to ask for help.
&gt; No they are not. You are actively saying it. It's not very inviting when you divide everyone in some emotional black and white appeal to enforce your ideology. Howdy! So, im not really setting up some false dichotomy here, you're either into the concept of helping people resolve complex intimidation problems or you're not. You think that people struggling to get help with stuff is not a problem, and that's basically ok. Those are the choices. Help people with this stuff (CoC), or don't (fuck those people). &gt; What does that have to do with PHP? Nothing. Open source projects have a lot in common. Not sure why social issues between developers would respect language barriers. &gt; I previously have read this article. One side of a story with no evidence means its just a nice story to any normal person. I'm not gonna play the "pretty sure they're lying" game, nor am I blindly believing every word. I do know personally of a few events in various communities that could have been helped, and I do know personally a lot of CoC's have made differences at conferences, both preemptively and after the fact. &gt; and those fighting against the CoC in general are the reason we need a CoC. Why is this a fight? That mentality is kinda the problem. This is just saying "Don't be a dick" and explaining a few of the ways in which one might accidentally be a dick, as that definition is different for many. &gt; You watch too much television. I nearly said Zat'nik'tel and IDC. &gt; Guilty until proven innocent is not very accepting and frankly extremely wrong. That's literally not what guilty until proven innocent is. People are taken in for questioning, and told to "not leave town for a while" during investigations. Teachers accused of indecent behavior towards students are put in temporary leave while investigations happen. If the worst thing to possibly happen here is that you are falsely accused and you cannot commit to master for 7 days... then, um, what is the problem? The greater RFC of it would throw this out as false and life continues just fine.
Um, no. She was allegedly the abused one and a lot of men are running about calling her a liar, even on this thread. Either way, the CoC group is there to solve the situation either way, so we don't just have a bunch of guys deciding for themselves. 
Makes perfect sense in hindsight, thanks :)
Yeah I'd get fairly sweary if I was dealing with that many harassers too. 
If you don't know what a gestapo is then just ask.
I know that the Gestapo was an abbreviation for the name of the Secret Police used by Nazi's in WW2 to silence, imprison and kill political enemies. To think that he could compare a CoC RFC to that is absolutely ridiculous.
Fucking hell. This is why people are skeptical of these things. It's never "just" a CoC, it always involves granting special powers to certain people, potentially people selected by criteria other than their technical expertise.
[removed]
That's again just a sermon, that sounds proper but misses context by a mile. Keep on.
&gt; This is a safe, non-judging environment WHY ARE YOU OPPRESSING MAH FREEDOMS!!!1! /s Seriously though, I get that some people might not be so keen on a CoC.....but some of those people, particularly those who work as consultants.....don't they realise that, y'know, people can see what they're writing, and that maybe, just maybe, making an argument against a CoC that doesn't make people think you're a tosser might be a good idea long term?
Look at Mozilla and what happened there. A worldwide community of coders built up a product and it got infiltrated and taken over by those cultural/political warriors. And now an open source project that brings in over $300 million dollars a year is funding their favored crowd and causes. This CoC bullshit is nothing but a hostile takeover. Don't waste your time over all the deceitful "don't be a dick" minutia. Don't waste your time haggling with them over what they can whip you for; just say no hell no to them grabbing the power to whip you. They don't give a damn about PHP itself. They don't give a damn about the people they claim to protect with this CoC bullshit. It's all a hustle and a hostile takeover. That's all it is. 
&gt;so we don't just have a bunch of guys deciding for themselves. And now you show your true colors
Which colours? 
Can you elaborate the Symfony part? 
&gt;If you are going to go through the trouble of using something like symfony components, then you better ditch php completely and use something better altogether. Except that ignores the rest of the PHP ecosystem and the fact that PHP has ridiculously widespread deployment as opposed to those other, better options. 
[removed]
To me, the wallpaper comes across as parody, I even thought I was in /r/programmerhumor at first.
Looks like Homework :P Read the examples in the man and you should be able to understand it. http://php.net/manual/en/book.pdo.php http://php.net/manual/en/language.exceptions.php 
&gt; and poop to any language Nazi ~~that~~ **who** disagrees. For persons, use "who", not "that". "That" is for things. Probably also a CoC violation, and could definitely be interpreted as hateful / disrespectful.
I personally choose PHP for its general pragmatism, one process per request no hassle memory handling, out-of-the-box web tools, great community. None of these conflicts with modern frameworks.
Thanks to Anthony for putting this RFC out there. There are, in fact, two items under discussion here: 1) the Code of Conduct itself, which will serve to establish the rules by which the community has *collectively* agreed they will behave when contributing to this open source project, and 2) the Committee that will provide oversight to those rules, and how they will address issue that might arise should conversations get a little *too* heated and discussions lead into territory that have very little to the ongoing work of the PHP project itself. It seems to me that the primary opposed reaction to this RFC has to do with the second part – the Committee, its selection, the terms of its members, and its process for addressing infractions – and less to do with the actual Code of Conduct itself. I think some valid points have been brought up on both sides of this discussion with regard to that Committee, and I'm hopeful that the conversation can continue to be productive in order to iron out some of those details. Who gets selected to the committee? How long do they serve? What is the actual process for infractions to the Code of Conduct (e.g., what happens leading up to an actual ban, whether temporary, or permanent? Are warnings issued? Is this a three-strikes-you're-out thing, or is it more quick than that)? I think these are fair questions, and I can understand how those who might feel they're being persecuted by the creation of this committee might feel that their own behavior will eventually exclude them from contributing work to PHP. In terms of the Code of Conduct itself, there are certainly some items that are up for interpretation, and I agree with the dissenting party that these items should be modified or excluded altogether if they can't be more clearly defined. That said, the *need* for the document, which is being debated by some, couldn't be more clear to me. At the end of the day, the committing members of the internals team have a responsibility to treat one other with respect, and to provide an inclusive environment where others can feel open to submitting their own ideas and contributions. Communities are grown and software quality is improved when others are made welcome, and knowing how to address negative issues when they come up will keep the environment welcoming for everyone. I'm not a voting member, but I would absolutely vote for an amended version of this RFC if I had the chance. I hope productive discussion continues to occur on this thread and elsewhere that helps make it as good as it can possibly be.
was that a trick test? it has to be.
Ugh, I'm not telling you what you think, replace that with "one thinks". Either one wants there to be a way to help people, or they don't. You just suggested people should be helped as and when problems arise, which I've already commented on elsewhere: &gt; Saying "We don't need a CoC until we have problems" is like saying "I don't need bear spray until I see a bear." It's a bit late then. There is no social contract other than "Don't be a dick", which needs to be elaborated on for those who are bad at knowing what dickish behavior entails. As for the fight thing, I think I was subconsciously responding to /u/pmjones who was the first to mention it. He said some Churchill style "We will fight them on the beaches, we will fight them on the shores..." somewhere which seemed wildly ridiculous to me. 
&gt; What power is there to be had over PHP? It's about power over one's political enemies, specifically anyone who objects to the COC as interpreted by its enforcers.
The answer is pretty silly, it's simple and straightforward. The link above is enough, even if you never used transactions before. But the code is written by someone who have no idea how it works. 
You know the answer?
pretty much that. Not always that easy to do, but in general, the only way to go. Companies that cannot treat their employees right, will not have a lot of employees to choose from. basic principle of capitalism. 
When using PHPStorm and using the quick function creation shortcut eg.: `pubf` + tab it'll auto create your public function. When you get to the parameters and setup a type for example: `public function someFunction(MyClassObj $class) {}` By default when you're adding the variable it gives you to the option for phpstorm to use the same name as the type hint you're adding if it's a custom class, but it's formatted using this format: `$myClassObj`, how can I change the auto complete creation format to use a different format of my choice like underscores which would automatically create the variable like: `$my_class_obj` ? (reason we're using underscore's is consistency, but if I could utilize phpstorm's auto variable names feature to use that format it would be a plus)
To get marks on the exam so I can get my degree...
that seems about the best you can go with, although it doesn't really make the program right. it is a problem with the code though. in the first try/catch block, if that throws an exception, everything after that block will fail since `$dbh` wasn't instantiated. this block should include everything that's below it. the placeholder for the `$dbh-&gt;commit()` should be right after the `foreach` block, meaning if all calls to `execute()` succeded, then we should commit. any exception thrown will still trigger the `rollback()` in the catch block.
&gt; Saying "We don't need a CoC until we have problems" is like saying "I don't need bear spray until I see a bear." It's a bit late then. I do agree that something could be done but not that it should. The chosen CoC is not the right CoC. I think it has many problems, see [this](https://www.reddit.com/r/PHP/comments/3zhapd/rfc_adopt_code_of_conduct/cymk1rs) which I wrote earlier. 
Its easy to follow, just look at the PHP Manual and you should be ok
[removed]
Just publish a "Code of Conduct" document that everyone has reviewed and agreed to. DON'T establish a council that deliberates and hands out punishment. If a case is raised, raise it in the mailing list, or just have a separate mailing list for it. Complete transparency, open deliberation. After all of it, everyone votes/decides on the sanction.
I am a sucker for punishment
ugh, I wish we all had excellent compensation
[removed]
&gt; It's quite alarming that you want to silence voices that you don't agree with. That's very scary behaviour. Yes, "I hate him for not putting one between it's confused eyes" seems like a voice that can contribute a lot to any discussion. You don't even need to know what "PHP" means in order to determine if this guy is trolling. BTW, I couldn't help but read your comment in C3PO's voice. Is that ok with you? Too late, anyway.
It has *additionally* to do with the attempt to bind the personal, the political, and the project all together. Cf. the phrase "This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community." Question: When is a PHP member in public *not* representative of the project or the community? Answer: they can *always* be seen as representative. It is textbook fascism.
&gt; The disturbing thing that will most likely follow is an influx of abuse and trolling from internet libertarians who wish to defend their right to heap abuse upon whomever they wish You said that people will come against this proposal because they want to abuse others. I just think it's a really dishonest tactic to paint all opposition with a dehumanising brush, having seen a lot of it in the last months.
To [quote](https://help.github.com/articles/open-source-licensing/): &gt;You're under no obligation to choose a license. It's your right not to include one with your code or project, but please be aware of the implications. Generally speaking, the absence of a license means that the default copyright laws apply. This means that you retain all rights to your source code and that nobody else may reproduce, distribute, or create derivative works from your work. This might not be what you intend. &gt;Even if this is what you intend, if you publish your source code in a public repository on GitHub, you have accepted the Terms of Service which do allow other GitHub users some rights. Specifically, you allow others to view and fork your repository within the GitHub site. &gt;If you want others to use, copy, modify, or contribute back to your project, we strongly encourage you to include an open source license.
i v iii iv ii And if you ask me I would think the $stmt-&gt;bindParam(":value", $value); should be down in the foreach block as well. I could be wrong, but the way it reads to me it seems like $value is always bound as null... Though to be fair, I typically use the "?" syntax when using PDO prepared statements, so I'm not _too_ familiar with the bindParam syntax. Still, I would want to see the bindParam() of $value be down in the foreach block so it's a little more explicit.
[removed]
&gt; I could be wrong Yes, you are &gt; it seems like $value is always bound as null It is not &gt; I typically use the "?" syntax which you can use with bindParam as well, it's irrelevant to placeholder type. &gt; Still, I would want to see the bindParam() of $value be down in the foreach block And be essentially wrong, confusing the very this function's purpose.
&gt; you are generally happy to defend misogyny Here we go with the calm, rational discussion without labeling your opponents...
Hey everyone, the MRA cavalry is here to save the day!
That you see it as an MRA issue proves my point that this is a political move designed to enforce a particular set of politics.
I think you need to learn what proof means. 
&gt; I think you're getting the wrong idea about frameworks here. The reason people push frameworks is to allow easier collaboration. Another way to allow for easier collaboration is setting up architectural boundaries in the codebase, and a proper separation of responsibilities between components. Modular applications. And... each can use a different framework, if the authors so desire, by the way. Collaboration doesn't require a framework in a well factored application. But a framework can be a way to make monolithic applications more bearable, at least at the beginning. But eventually it becomes a mess and you can't scale your developer force without them constantly stepping on each other's toes while committing to the same codebase. &gt; If you want to flesh out the entire application from scratch then that's your call, however suggesting that framework users lack skill its a typically immature statement. That's a false dichotomy, combined with a personal attack. A good way to shut down any opportunity for an intelligent conversation between engineers. Good job. I'll just mention that the alternative to using an "established framework" is not "flesh out an entire application from scratch". You still have components and modules to build upon. Nothing is done from scratch these days. Have you honestly never done anything that not based on a framework and it's not "from scratch"? Think about it, I'm sure you have, actually. I'm sure you use Composer and know how to integrate components that don't come from your framework. If not, here's to a new opportunity to learn.
PC colors, bro!
 &gt;A framework is simply a pre-canned application structure for people who either: Don't have the time [or] Don't have the skill Or they work in a professional environment with a project that requires multiple developers and will evolve over a significant period with a possibly-changing team. &gt; But you seem to push using a framework as *the ceiling* of someone's skill as a developer. To paraphrase a prayer: "Give me the skill to program the things I must, the humility to reuse the code I can, and the wisdom to know the difference." Sure, some people use frameworks as crutches, but on the other end there are also some people that are unwilling/unskilled at dealing with code that isn't their own.
&gt; Or they work in a professional environment with a project that requires multiple developers and will evolve over a significant period of time. Really. I wonder what happened with all those Symfony 1 apps "over a significant period of time". Their platform was abandoned. Or see the history of compatibility breaks in Laravel. They're at version 5 and and have only released one long-term support release in their history. All people using the other releases... they're screwed "over a significant period of time". Oh and by the way, a LTS is: - No long term new features. - 3 years of bug fixes. - 4 years of security fixes. So "4 years" is the ceiling of "a significant period of time" when you use an established framework. Then you need to refactor your application to a new version, or, as often happens, if your framework falls out of the hype train, you need to rewrite your entire application in another framework, or deal with more abandoned code where you'll be less and less able to find supported bundles and components for. Sounds like a professional way to go things. And you have little to no control over the high-level architecture if your app from the very start. &gt; To paraphrase a prayer: "Give me the skill to program the things I must, the humility to reuse the code I can, and the wisdom to know the difference." Indeed, that's my mantra (sort of) as well. I guess where we differ is in the wisdom to know the difference. I'm not against reuse. I just focus on reusing what's reusable, and the frame of your application, if you have eyes for architecture, is specific to your app and based on application requirements and design goals. But every component that is used in this frame, can be reused. Router, template engine, event bus, cache abstraction, SQL layer and so on, to name a few. The difference is subtle, and getting a feel for it requires some experience, or should I say... wisdom. &gt; Sure, some people use frameworks as crutches, but on the other end there are the people who are unwilling (or unable) to deal with code that isn't their own. I'm neither of those people, so I guess we're talking about some other people. I guess too bad for those people right? 
I like the idea of having a CoC, but I really don't understand why the ~~tribunal~~ "response team" is necessary. Is our community really not capable of calling out or ignoring the trolls and bad actors?
Let's face it, most people willing to be contributors can write decent code, and with a project the size of PHP, there's a lot of people who can write good code. The bottleneck for contribution to a project like this is rarely ability, instead it's much more dependent on the quality of community. In this situation, it's important to recognise that making a community seem hostile is far more damaging to a codebase than simply checking in a few pieces of mediocre-quality code. Now, of course there's discussion to be had on what "making a community seem hostile" means. Accidentally using "he" for a woman is not going to hurt anyone, especially if - as normally happens - apologies are made and everyone makes up. On the other hand, consistently refusing to use the correct term for someone out of spite is a very different matter. Having a CoC helps to make it clear that the PHP community values its members. Sure, there are still questions that need to be answered (it's in the draft stage after all), but that's why requests for comment request, well, comments... :P
The problem is that "being an ass" is going to be defined by a list of personal pet peeves a mile long, put forward by those with a very destructive and divisive political will.
Let's keep it civil, guys.
Thank you, I'm studying Spanish anyway. This will be good material to read. :)
&gt; It is textbook fascism. I don't know what textbook you're working from but no, this isn't fascism in any sense. &gt; Question: When is a PHP member in public not representative of the project or the community? Alternative question: when is it OK for a person who is representative of the PHP Open Source project to harass, threaten, or dox other people? The PHP project gets to choose who it associates with. Codifying how it will choose which people it will no longer associate with is a great idea, because it provides a set of understandable ground rules for everyone involved. 
I'd like to ask everyone to please remember, as you have this discussion, that /r/PHP has rules about decorum. Please keep your discussion civil, and don't resort to name-calling or personal attacks. Strong (even offensive) language is okay, but please don't let it devolve into trading jabs for political points. Please also be conscious of the effect that linking this thread from off-site might have on it. It is strictly against the site-wide reddit rules to "brigade" this thread by calling your friends and/or political associations to come give your own view more weight. And while it's a not something I think most will respect anyways, please don't use the downvote button to express "I disagree". It's there to indicate that a comment doesn't contribute to the discussion.
&gt; But then people will ask you to run Php-FPM, because you are duplicating a lot of work for every request which get thrown at it's end. So again, we are back at the same argument. Because the important part of "one process per request" is that there is *no shared state*, unless you explicitly share it. Whether a separate process is spawned for each request, or whether there are multiple reusable worker processes, or whether there is one process with multiple independent threads -- that's not relevant for the main concept. As such, citing php-fpm as going against the shared-nothing paradigm is pretty pointless.
I like Symfony2 because it allows you to use PHP's gigantic pool of developers, but with a much more reliable and robust system. I've also been to some PHP conferences where Rasmus has talked and I really appreciate the pragmatism in his approach. The PHP community frustrates me sometimes, so I get a little bit of satisfaction when he steps on people.
&gt; The PHP project gets to choose who it associates with. First, you are anthropomorphizing. It is people, not projects, who associate. Second, to "harass, threaten, or dox other people" is an offense suitable for reporting to the police. The code of conduct in that case is called "the law" and it already exists.
I read the link philsturgeon posted, but what's the other side of the story?
Edit: Removed my reply since it's a representation of my own views, and for some reason reddit has decided to green my name.
Yeah good catch :) Sorry about that.
Fair enough, then I guess what I'm _really_ trying to say, is I don't like the ambiguous execute() statement in the foreach block... I'd rather see the value passed in from the foreach block. Even if it leads to ever-so-slightly poorer performance, I think it's easier to read. Others may disagree, just my two cents.
Open the settings (Ctrl + Alt + S), search for `pubf` and you'll find the "Editor &gt; Live Templates" menu. There you can edit the variables and tell it to reformat according to your settings. I'm not sure if any of that will let you use snake_case here though. Edit: It seems like you can do this by editing the template variables and using the `snakeCase` function as seen here https://www.jetbrains.com/phpstorm/help/edit-template-variables-dialog.html
Thanks, must be some templates out there for snake_case.
&gt; I hate him for not [killing himself] This has nothing to do [on this subreddit](https://www.reddit.com/r/PHP/wiki/index) &gt; Trolling and abusive language are not permitted. We're easy-going, but such things are not conducive to good discussion. [Mandatory XKCD](https://xkcd.com/1357/)
It is actually possible to read the text only with PHP. pdftotext is encoding the pdf and just reads the literals from the encoded stream. The PDF specification is actually quiet comprehensive, you could read how to exract the text yourself without a external program.
I'll take one for the team and try it on my first and oldest Laravel app, to take it from L4 to L5.1, over the weekend probably 
Bias in a group of people assigned to uphold rules of conduct is very bad, you're right, but it is also extremely easy to call out and correct. If Phil Sturgeon calls you a dick, and that offends you, you should have the right to complain about it, and the group managing the CoC should tell him to stop being an asshole. http://i.imgur.com/Yj5ErOF.jpg
choose a different job, if you really need the help.
Really, stop putting words in my mouth. I'm not generalizing about the people with objections to this proposal. I'm talking about what has happened with a lot of projects who move to implement this. A bunch of outsiders with no prior connection tend to move in and start making drama. People with legitimate objections should voice them constructively.
&gt; Really. I wonder what happened with all those Symfony 1 apps "over a significant period of time". Their platform was abandoned. Well, so what? For each one of those projects, there are dozens of "your predecessor built this framework himself" ones, which are all effectively "abandoned" even more-quickly an even **shorter** timeframe and which leave behind no cohesive documentation or upgrade-path for you to continue from. &gt; Or see the history of compatibility breaks in Laravel. \*shrug\* That's an argument for comparison-shopping, not for "always roll your own framework". &gt; So "4 years" is the ceiling of "a significant period of time" when you use an established framework. Four? At my workplace for the last few years, a major application that still has blame-able PHP lines from around 2005. The fact that the earliest developers rolled-their-own-everything did not actually make it easier to manage over time, it just increased the "it'll break if you touch it so don't" factor.
I started it because I wanted to make a website, and PHP was similar to C, so I picked it up easily. I keep using it because Rails is hard. Or more specifically, Rails' documentation is hard to navigate. It's a lot easier for me to keep using Laravel, which has *amazing* documentation, than to get 80% through a Rails app just to get to the point where I can't find the thing I'm looking for in the documentation (true story). They accomplish the same thing and PHP is faster than Ruby anyway, so even though Ruby might have fancier syntax and isn't hated like PHP, I see no need to switch.
Haskell's too mainstream. Try Erlang.
No. Its just a placeholder indicating you want to replace :value with the content of $value.
I don't think he's hating Rasmus for not killing himself, but for not killing PHP. EDIT: Also this- http://shetterly.blogspot.com/2014/04/xkcd-doesnt-understand-free-speechor.html
He only started it. He doesn't do jack fucking shit these days. Nobody can argue with an infographic, though.
I think he means IP wise &gt; Laravel is a trademark of Taylor Otwell. Copyright © Taylor Otwell.
Abusive, personal attack. Banned.
For the sake of argument, let us assume that there exist consistency checks that PHP does not implement in order to reduce startup times, and which it would implement given no such constraint. As such we have a trade-off between consistency checks and shared nothing architecture (which requires fast startup times), granted. However, I do not see why this should be a lose-lose proposition, as I interpret you to be suggesting four comments up. Shared nothing architecture is considered by some to be valuable. Whether it is less valuable than the additional checks those implementation it purportedly prevents may be subject to argument (though I highly doubt it).
It's from /u/the_alias_of_andrea [here](https://www.reddit.com/r/PHP/comments/3zhapd/rfc_adopt_code_of_conduct/cym4eem) (credit where credit is due).
Here is the other side of that Randi story: https://archive.is/wH4Rg#selection-15923.63-15923.78 Textbook case of a code of conduct being used as weapon to abuse others - the very thing it set out to prevent in the first place. Malignant individuals exist and a CoC won't stop 'em.
!= PHP
Just as a follow-up. "How the shit did I not notice that", LOL, section 3.3 in "Build APIs You Won't Hate". Great book by the way. Down to earth, pragmatic, cool.
All this because PHP has a couple of contributors that are women or trannies.
That's Ubuntu's decision. We aren't bound to it. Not just because of what /u/ngony said, either.
&gt; People with legitimate objections should voice them constructively. Don't they, in this thread?
&gt; I guess that's why frameworks are so popular with juniors. They don't know how to do architecture. A lot of developers at this point don't have the time to write a framework just to wind up at where many established ones are already at. That's not just exclusive to PHP. Why reinvent the wheel? Many firms don't want to invest a lot of money for someone to code cowboy one together, when they can use a familiar system and be able to hire more people as they grow. I can't think of a time anyone I ever knew applied to work at a company on a proprietary system, outside of working at LinkedIn or Spotify. Even major companies use off the shelf tools, are you saying they're all stupid for that as well? People that roll their own thing carry that institutional knowledge out the door with them when they leave. It's a massive technical debt that not many companies want to stomach.
One of the benefits of having a smaller subset of participants review problems in a closed environment is to help protect the person making the accusation (because they'll get harassed just for complaining) and to help prevent public witch hunts (because they'll get harassed just for being accused of something).
&gt; I personally choose PHP for its general pragmatism Most people do. That philosophy made it so successful and is the reason it runs like 80% of the internet. I have never found a language and platform that lets me get so much done right away while still being flexible enough to use all of the latest design methods and architectures. 
This. Precisely This.
Yup. I guess reading page 1 of the PDO documentation and any basic example usage in those docs is beyond you. People will not always be around to hand you answers. I'm not griping about your lack of knowledge but your approach to acquiring knowledge and your impact on future co-workers. Yup, literally page 1: http://php.net/manual/en/book.pdo.php#50999
This question needs an update from someone who actually knows how to write PHP code. The correct answer would be: "this is all just wrong" 😄
Those other better options are not all that better. :)
I think that a lot of the issues brought up here are valid on both sides. But I think there is a simpler, more concise way of dealing with the issue. The problem as I see it is that the way this is written is that it carves up certain "protected" areas that a core group of people can decide upon. I think that a simpler approach would be to focus on the task at hand rather than enforcing behavior. For example, the RFC states that activities under protection are "contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches". Those are all code related, and honestly, sexual, derogatory, or private information doesn't belong in there. One way that this could look is that if someone posts something of a profane or derogatory nature the content is denied with a message that states "all content needs to be related to the current topic at hand. Please rewrite &lt;whatever&gt; with that in mind". This is software development and virtually all of the frowned on activities have no relation to software development. Something like this doesn't require a judgment of the individual (who may or may not truly be as bad as claimed) nor does it give power to anyone. All it says is "focus on the issue, not the person." There is the matter of private issues which this comment does not relate to. But for issues of public concern simply focusing on the individual issue and keeping it out of the personal realm would probably solve a good chunk of those problems without having to resort to bringing it before some kind of council or tribunal.
We actually see pretty few bogus complaints. I'm guessing that this is because we'll outright state that being *offended* isn't grounds to complain. Only direct personal attacks generally warrant a response. And in those cases, I simply remove the offending comment and go about my day. No controversy, because there's not much ambiguity in what constitutes a direct personal attack.
Using [m1/env](https://github.com/m1/env) because I needed only .env parsing, not all the automatic $_ENV loading and stuff like that, also it seemed like the most complete parser
This is true. The work and language improvement is done, albeit slowly, via community. It's all of us, and our opinions, that end up deciding, coupled with the chaos and drama of PHP internals, what new features get added. Fortunately, the community has to really really want something before it gets implemented (e.g. scaler type hints, aka effectively strict typing). 
I'm not sure if you're intending to express it this way or not, so let me bold some things for you. &gt; And the **political ideology** suggested by the Contributor Covenant website is **radical feminism** - a **destructive** and divisive **dogma**. Using words like these only serves to reinforce the division you're talking about, because it sets up ideological barriers in the discussion. If you're actually worried about solving this problem, a really constructive route would be creating an alternate to the Contributor Covenant that achieves the same goals - making sure contributors are treated as human beings - without using the specific words and phrases that make you uneasy.
tumblr in PHP
Okay, good. Now, I'm not a reddit mod, so I don't know the precise details, but IIRC there's a mechanism in the moderator tools that lets the mods talk directly with each other, right? Surely you and the other mods have had to use this functionality, right? I know there have been some pretty heated discussions lately. I've been managing internet communities for decades now (and damnit, now I feel *old*). Every time my users do something stupid en masse, I never make decisions on my own. Experience has taught me that I need to double check my opinions with my fellow admins and mods, and I never, ever do that in public. If we're going to talk about removing a bad contributor from the community, we don't need that dirty laundry hanging out. Now, *completely ignoring the actual rules that would be enforced* because I know you have problems with them, isn't the mechanism laid forth in the CoC policy effectively the same thing as private moderator chat? Wouldn't you, as a moderator, *need* a functional level of privacy in which to do your job?
I'm not interested in putting forth a code of conduct for PHP. I don't see the current state of things as something that can be improved by dictating what people can and cannot say. If they want to implement a mailing list rule saying that direct, personal attacks are unacceptable and will be removed, I'm cool with that. But everything indicates that they want to go much further - they're defining what is *offensive*, and setting themselves up as an authority that can apply this lengthy list of personal pet peeves to silence people on social media and the like. In effect, I don't respect or recognize extra-judicial moral authorities. I won't dignify one by helping to make it more palatable.
The biggest and main difference is that `Chronos` extends `DateTimeImmutable` instead of `Datetime`. Immutability for date values has proven to be a great way of avoiding bugs and reduce the amount of code, since developers don't have to manually copy the instance every time. Another important feature it offers is the `Date` class, which is used for representing dates without time (calendar dates). Any time method called in this type of object is basically a no-op. A minor but still noticeable difference is that Chronos has no external dependencies, on the other hand Carbon depends on symfony/translator which pulls a bit part of symfony itself, including a yaml parser. The ability to translate strings in Chornos is not lost, though. Finally, Chronos is faster than Carbon as it calls less functions internally. It is also HHVM compatible, when using the latest version of HHVM (3.11)
Both of those benefits go out the window the moment you make a decision to act, if you wish to remain in any way fair and honest. If you decide to ban someone, do you tell them what they did and who accused them? If so, are they somehow bound to secrecy about the details, or could they publicly complain that &lt;accuser&gt; got them banned? Do you publish who was banned and why? If not, then who's watching the watchers? When your extra-judicial police force is off investigating the complaint, are they allowed to talk to "witnesses" about it? Are the witnesses sworn to secrecy? What if the accuser decides that a complaint isn't enough? Maybe they take to Twitter to announce that they just submitted a code of conduct complaint against the accused. Can the accused submit a CoC complaint against the accuser, now? Who investigates which complaint? Can you vote on both? These are the problems you run into when you start trying to institute your own justice system. A better idea is to not.
[You're shadowbanned on reddit](http://nullprogram.com/am-i-shadowbanned/#kschrade76), just FYI. It wasn't likely related to /r/PHP. Reddit's anti-bot system probably triggered on your username, since most spambots on reddit have a first-initial-last-name-then-number username like you've chosen.
Man, I hope the PHP5/PHP7 diaspora is nothing at all like Python 2/Python 3 or Perl 5/Perl 6.
I'm cautiously optimistic on that one. It's much easier to write code that works on both PHP 5 and 7 than it is on Python 2 and 3 (and Perl 6 is a whole new language!), and that was (IMO) the single biggest thing that caused Python problems: if library and framework authors can't easily migrate their code to work on both the old and new versions, it's nigh-impossible for users to make the jump. We're a month past release, and already most major frameworks either support PHP 7 or have a plan to in their current stable versions. That's huge. By contrast, it took Django over four years to get Python 3 support, and Flask still says it's experimental more than six years after Python 3 was released.
Looks great on the surface. Something I would use.
The requirements to be on the CoC team are very telling. &gt; A team of 5 volunteers shall be assembled who will make up the code of conduct team. &gt; The team shall consist of: &gt; * At least one person with commit karma to php-src &gt; * At least one person with commit karma to php-documentation &gt; As long as the preceding two seats are filled, there is no karma requirement (wiki or otherwise) for the remaining three seats. 3 of the 5 members need not have any contributions whatsoever. This is perfect for outside ideologues looking for another project to take over. The RFC has been updated but I think they'd be better served by scrapping it and starting over from scratch. Ditch the radical feminist / tumlbr crap and much more narrowly define offenses. The whole spiel about pronouns and marginalized minorities makes the agenda of this CoC clear. Everyone has to walk on eggshells and toe the ideological line or risk expulsion and ostracism. Can you imagine if the linux community tried to hold something like this CoC against Linus Torvalds? This CoC crap is attempting to recreate events like Donglegate, Shirtgate, and Eich's ousting for donating in support of prop 8. It just makes the ousting much less public since it's internal and not external. Just quietly erasing you, removing your commits/karma, and banning you because someone was offended.
As per the RFC, 3 of the 5 CoC team members need not have any contributions/karma whatsoever. It's agenda pushing pure and simple.
it looks like some people like impressing their preferences rather than doing actual work that would really count as active.
Eh, my Flask projects' tests pass in Python 3. Then again I don't have large production apps fielding 10,000 requests per second. Haven't really touched Django tbh.
&gt; We apparently have very different moderating styles. Yes, that's abundantly clear. I understand your position more now, thank you.
&gt; A lot of developers at this point don't have the time to write a framework just to wind up at where many established ones are already at. That's not just exclusive to PHP. Why reinvent the wheel? Few hundred lines wiring existing components. How much time do you imagine it takes? And no, believe me you don't end up where "established" frameworks are. Established frameworks thrive on integrating their components tightly to the point none of them is individually replaceable. That's not the case when you wire yourself, and use interfaces correctly as a tool of design. &gt; People that roll their own thing carry that institutional knowledge out the door with them when they leave. It's a massive technical debt that not many companies want to stomach. I'm honestly somewhat sick of this straw man of "no framework? so you roll you own!". No, I don't roll my own. I *wire components* on my own. And it's not hard to write, it's not hard to read. The hard part is how exactly to wire things. And no general purpose framework solves this problem in a way that fits your app precisely. Apps aren't just a soup of models, controllers and views. This is no architecture, it's only the starting point of it. Those flat MVC layouts are monolithic designs that become impossible to reason about once their scale grows beyond few dozen controllers/models/views. It's quite significant then when frameworks are discussed, the juniors come out from their holes and start crying about people that "roll their own". The inability to even *imagine* that a strategy exists between "use a popular framework" and "roll your own" is quite telling about the lack of experience here. If you want to retire as yet-another WordPress code monkey, that's fine by me, but some of us simply have more interesting projects that require more interesting solutions. 
Can you provide a similar article from a more politically neutral site?
It won't be. PHP7 is almost a drop-in replacement. 
The query is contained inside the statement ($stmt). There is no seperate query to be done.
[**@randileeharper**](https://twitter.com/randileeharper/) &gt; [2015-01-03 08:02 UTC](https://twitter.com/randileeharper/status/551287459233812481) &gt; @OhNoes\_Zombies go set yourself on fire. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
I'm not going to pointlessly argue around your circular logic.
WE DID, LOOK BELOW (OR ABOVE, IDK WE'RE MAKING OUT EVERYWHERE AND ITS GROSS).
As a sysadmin I am quite sceptical of RedHat's, Canonical's,... ability to properly support an old release over years too. I mean it is one thing to have the LTS release support something 5 years that would otherwise be out of support after 4, this sounds more like it will be out of support by the time the LTS release is going to be adopted by anyone though. Adopting an approach that won't allow PHP 7.x+ to be used on Ubuntu 16.04 would amount to one of two things, either the whole PHP ecosystem gets stuck again, as it did and still is to some extent on PHP 5.3, or Ubuntu will be marginalized for webservers, both undesirable outcomes.
&gt; So by that logic you surely develop everything on WordPress Not at all. When I start a project, I look at the tools which can be a good fit, and decide what I want to build on my own and what I want to reuse. That doesn't at all mean I am unskilled in building everything: rather I am skilled at knowing when I _should_ build things on my own. And when I get that choice wrong, it's a good opportunity to learn. &gt; start from "scratch" and what that even means in 2016 - building your own router - building your own service locator/dependency injection container - building your own ORM These are all things I have done, sometimes to learn and other times because I wasn't wise enough to use good, open source implementations. Drawing the line between framework and reusable collection of components is an unenviably difficult task, but the point is that code reuse is nothing to scoff at. Modern frameworks are simply larger reusable collections of components. &gt; Do you fab your own integrated circuits with bare hands? As much as I love reasonable discussion on the internet, your tone in this thread makes me think you're more interested in a fight than a reasonable discussion. That's ok, but it's not what I'm in to. Perhaps you don't share or understand where I'm coming from, and that's also ok. I'm not keen on diving deeper into an argument, so forgive me for backing out at this point.
Thanks for the context, and I don't blame you for wanting vendor security. It was just unclear in this thread (and the repository readme) why a fork was needed. I meant no offence. :)
1. I don't see Ubuntu being marginalized. It just powers so much of the net and Canonical has had good stewardship. 2. We know that currently PHP7 will not be Ubuntu 16.04 LTS (April). 3. We know the next release after that will be Ubuntu 18.04 LTS in April 2018. 4. We know Ubuntu 16.04 LTS will have PHP5.6. 5. Most companies will not deploy a new LTS until 6 months after the release (~October 2018). So, that leaves us with 2 years (if not 2.5 yrs) of no PHP7 in an LTS version of Ubuntu. There are workarounds (e.g. PPA's). But, many companies have a policy against them. Given historical precedent, I figure that most of the internet will be stuck on 5.4-5.6 until late 2018 or early 2019. Interestingly, this situation is fairly normal for PHP.
Jesus. One of the cornerstone lessons on dealing with harassment on the internet is *do not engage*. That is what happens when you don't understand this lesson. It's chess with a pigeon / wrestling with a pig with that type of troll. They're *looking* for a response. They're *trying* to provoke you. With reactions like that, they *know* you're a target and they're going to get entertainment value out of harassing you. Now she's never going to be left alone. 
Whoa really? I was sure they'd use PHP7. Will 7 be available at all through official repos?
Ah I was looking for this the other day and couldn't find it. I remember saying at the time what an awful name it was...
Things like this is why I avoid twitter. 
Presumably by "yes" you mean "yes [to extending the 5.x lifetime]"?
http://news.arcustech.com/post/131972388936/php-7-and-ubuntu-1604lts
Are there some notable examples of people screwing up pronouns on purpose? Its really hard to believe there is an issue like that, and in general it feels like fighting windmills.
The way to support PHP7 in Ubuntu and other Debian based distributions is by having it in a PPA. That way I can have PHP5 in a server and PHP7 in another and I won't need to change anything else in the PHP7 server except adding a PPA. I simply don't see any approach where this is not possible, as anyone can create and maintain a PPA.
What have you written?
This is not good spanish, it looks like google translated english article. 
Code of conduct? I can't believe people take those things seriously. It's just childish rubbish with a political agenda. There's always been standards for propriety in the open source community. And our norms are far better than the whining babies who demand we enstate their padded wall policies.
You have no idea what I write. Just give up trying to insult me. It's not working.
The big reason to use PHP 7 for new stuff, from my perspective, is type declarations. They add more teeth to your interfaces, but you can't use them if you're supporting 5.6 and below.
Lol. Atleast read properly before getting onto your pitchforks and crying "Troll Troll"....
&gt; the greater group can call them out on that Maybe it can do that when it sees abuse? Seems like taking "yo dawg" to a new level here.
&gt; php (probably the C/C++ underbelly) uses short-circuiting which means it evaluates as little as possible. This is why it returns 'two', as that is the quickest answer. Wouldn't 'one' be the quickest answer? You check if n=1 first, and return 'one'. Done. The way PHP does it is: check if n=1, take 'one', then use that in the ternary for the second part. The string 'one' exists so it returns 'two'.
The short answer is that there's no real need. Major distros already have excellent, up to date repos available through the hard work of people like Remi Collet and Ondřej Surý. PHP would either have to duplicate that work or adopt it, which would then lead to problems around things like distro patches that are used to make the packages correspond to the distro norms (not to mention finding the resources), since I'm not sure anyone really wants a package that just dumps a bunch of binaries into /opt/php and doesn't integrate with distro web server packages. That then raises a bunch more questions: Do we integrate those? Do we maintain patch sets for different distro versions? If so, what distros and versions do we support? In summary, it's a giant tarpit, and I don't think it's something PHP should waste its resources on. I don't think I'm alone in that view. (Disclaimer: Part of my day job involves shipping binary PHP extensions, which includes figuring out how to package them. It's a nightmare, and it's actually easier to do a single extension than PHP as a whole.)
jesus... worse than I thought. 
I don't know your professor but I would recommend once you get done with this assignment to go to them and share your opinions about the question and possibly a better way to write the code (if you're able to determine one yourself). It may not do much for you now but I've found in my career it can be beneficial to make note of situations like this during code tests for job interviews etc. Making this a habit, at least in my experience, can help show additional knowledge that might not otherwise come across in your resume / code tests. You need to make sure to come across in more of a clarification / inquisitive way sometimes but optimization and overall code quality is a good skill to have.
It's worse... note the frequency of the dates. And of course be sceptical about these being purely tech in purpose. Suspect an ulterior motive of grassroot organizing and activist recruitment by those highly political agitators. &gt; Approved on December 1, 2015. &gt; RESOLVED, that the Python Software Foundation sponsor Honolulu's first annual Django Girls event in the amount of $550 USD. &gt; Approved on November 30, 2015. &gt; RESOLVED, that the Python Software Foundation sponsor Django Girls Windhoek workshop happening on January 25, 2016 in the amount of $750 USD. &gt; Approved on November 25, 2015. &gt; RESOLVED, that the Python Software Foundation sponsor Django Girls Rome on December 12, 2015, in the amount of $750 USD. &gt; Approved on November 19, 2015 &gt; RESOLVED, that the Python Software Foundation sponsor the Django Girls Cologne workshop, happening November 28 in the amount of $600 USD. &gt; Approved on November 18, 2015. &gt; RESOLVED, that the Python Software Foundation sponsor Django Girls Inland Empire workshop happening at UC Riverside on December 5, 2015, in the amount of $1000 USD. For 2015? https://pbs.twimg.com/media/CX8x7kOWEAAHFKC.png 
i'm also hoping to benefit from future optimizations PHP will get due to the type hints (no more type checking for some operations).
Will do. Thank you 
For those unaware, [she is literally making a living off her vague claims of victimization](https://www.patreon.com/freebsdgirl). And [as can been seen from her Github](https://github.com/oapi), she's definitely not earning it by writing good code.
There is no evidence that she was a victim of harassment before she herself initiated flame wars with strangers online. She is regularly an abusive troll to people on public forums and you are being had by a horrible person.
&gt; Democracy doesn't mean dictatorship of the majority. /by the people, of the people, for the people/ replace the *people* with *majority*.
I was actually hoping for that, and was my actual reference. Could you point out the reasons why it won't work, or might not be adopted for PHP?
`php -l` couldn't/wouldn't call them out, since throwing an undeclared exception isn't a syntax error. It would most likely throw a `TypeError`, and you'd have to rely on static analysis to catch it before runtime (just like return type violations). That said, it would definitely be nice to have.
Which is *weird* since German does and we have more in common with German than most other languages. All of the trans* folks and LGBT activists I've talked to were fine with "they". I'm not sure if selection bias is at play, since most of the folks in those realms I deal with are really laid back.
Yep. Not in PHP though. See some of the harassment directed at https://twitter.com/srhbutts
Subscribe to the PHP internals mailing list. Though that means you get the full discussions too, which might be a bit much for you. Or stay in /r/PHP I suppose, RFCs in voting usually get posted here by someone (sometimes me).
Same problem.
Maybe recently active. There's a lot of accounts on people.php.net, but the set that's been active in the last year is probably more reasonable.
At least action in your area of interest in a year.. whether that be bug wrangling, commits, docs, etc.. A real number would probably be north of that, but do you find 1 too onerous?
&gt; You would surely be warned if you were found to break the rules. And realise that an awful lot of people do not want to be part of a community where people are allowed to say these things. I guess you've never experienced a community where rules are mostly open-ended (like no comprehensive definition of what constitutes harassment) and interpreted to ban people the power owner don't like. If needed, rules are "clarified" or expanded and applied retroactively. I can tell you it sucks and soon all different voice about anything disappear. That's how you get a shitty monoculture which stiffles creativity.
&gt; For women in tech who are sick of being called men all the time, it can be a problem. There are no women on the internet. If everyone is considered a guy or everyone is considered a gal, it is equality. When you start removing anonymity you bring all the IRL shit some people want to escape. Also what some people may find offensive in their culture may be normal in another. And it's not because other projects decided to bow to some bullies that every other project should do the same.
I think they are referencing the latest South Park season.
 http://i.imgur.com/Kdrhmek.jpg 
&gt;replace the people with majority No, because that isn't the case. Minorities don't get to decide the political course of a democratic country, but they are still protected against mistreatment by the majority.
I subscribed to internals for a while and eventually the constant ignorance and trolling became too much to handle so I left. The problem with any completely open forum is that it's not the smartest, most dedicated, or most involved people who participate the most -- It's just the people who can type the most. These people are usually not the smartest, not the most dedicated (except in writing emails), or the most involved (except for writing emails). 
While I absolutely agree that PHP 7 is a really big improvement over 5.6, I am still slightly sad to see people jumping to making PHP 7 a hard requirement. It's one thing to use PHP 7 for your own projects, where you control where it is deployed. If, on the other hand, you're building a tool that's used by _others_, you simply don't have that luxury. Simply put: requiring PHP 7 will mean that a lot of Open Source projects will not be able to use your packages for a long time, regardless of how useful they look. And that's a shame. 
Hey that's me in the posting. Hope people also see it was a long time ago and since turned around from this very bad idea. Don't use request bodies in `GET` people!
Shopware is a really good e-commerce solution! The only problem is, you will have to pay much money for any additional plugin you want. Some plugins can cost you up to 500 euros...
Well, if its not in PHP it's not really relevant is it? I mean following this logic we should also have a PSR baning ISIS from PHP =)
I like the idea of moving often-used meta language features (like scalar type hinting for example) out of "annotations" and into the language. This particular thing seems like it would be burdensome if required by the parser...
I wonder about barely maintaned PECL extensions like `newt` for example. It could be a long ass time before many extensions on the list are maintained and some will just go away.
Nobody's code is going to get removed for accidentally calling someone by the wrong gender. You're fabricating an extreme scenario to further your point.
Well, the objects are normally destroyed at the end of the request -&gt; response -&gt; dead lifecycle of a typical php application. What specifically are you trying to gain, and what is "proper destruction"?
So you heard it was bad, but you don't know why and that won't stop you from echoing the conclusion.
I see, ok :)
*salute for Grace Hopper*
No, they're completely grammatically correct words to use, both in terms of historical definition (I mean, "they" has been a genderless, single pronoun since Shakespeare and Chaucer), and in terms of present-day colloquial usage (there are multiple studies that have shown that people these days use "they" as a genderless, single pronoun). The "plural-only" rule came about in the 1900s, dictated by a number of style guides that had come into vogue. I mean, if we're going solely on style guides, there's plenty of modern day ones that now say the opposite. The idea that "they/them/their" are grammatically incorrect is both incredibly recent, given the long history of the words, and also - already - fairly defunct, given the current usage trends.
We can't help you unless you post details of your problem, including the source code and any error messages. /r/phphelp is probably a better subreddit for your problem.
As long as we have something like this for reverse compatibility (like we do with types): declare( strict_exceptions = true );
Surely the point is that if you push users to upgrade they will in turn push hosts to upgrade and then the default column on this page: http://phpversions.info/shared-hosting/ might not be so embarassaing. 
Honest question. I'm very used to saving a password in db using a double md5 hashing, like Type in a terminal then copy the output of `echo randomtext | sha256sum` $b = key; $password=md5(md5($b.$user password)) Then to check login I just Select * from users where user name='$username' and password='$password' So I don't follow that first check user only then password. How insecure is this? Disclaimer: I'm not trying to obtain free guidance, it totally OK if you don't want to answer me. I'm just curious.
There's nothing wrong with forcing users to sigh while they look at your package, making them realize that they should put in some effort on their side as well (by upgrading). Free software is provided as-is, and if someone codes it for leisure, then that person should enjoy writing it. Coding against a newer version is always interesting and stimulating: fixing 5.3.3 bugs... not so much.
Cross-post from https://www.reddit.com/r/phpstorm/comments/3znise/how_to_fix_include_expression_is_not_resolved_for/.compact I'm trying to get PhpStorm to resolve define('APP_ROOT', dirname($_SERVER['SCRIPT_FILENAME'])); ... require APP_ROOT . '/file.php'; But I get the warning at the require line, "include expression is not resolved". How do I resolve it? I need the actual directory, ignoring symlinks, so `__DIR__` doesn't cut it. The only other suggestion I can find via Google is to set an include path, which I tried but that doesn't work.
BAD practice to save passwords as an md5 hash. It would be better to sha1 them with an additional secret like $my_super_secret_key = 'th1ZisS0m3SUPERKEXXX'; $hash = sha1($my_super_secret_key.$password_clear);
amen to that
Downvoting because your advice is still terrible and only marginally better than md5. PHP has built-in methods which /u/sarciszewski mentioned and if you're on an older version there is a library that is supposed to emulate the security of it: https://github.com/ircmaxell/password_compat
Double hashing isn't anymore secure than single hashing. Or at least I should say the security is "undefined" as it's not well researched last I heard, I'm on mobile so no sources, sorry D: But md5 isn't cryptographically secure anyways. If this is for some in home, toy thing then it's alright. But that's about all it's suited for. You'll want to use actual crypto tools to hash passwords.
Then I would argue that 80% of installs won't ever be upgraded because bare installs dont do anything useful enough to require or warrant upgrading (and that's even assuming the owner didn't abandon the blog 3 months after creating it).
Tx for the links! And you are right about $b. I edited and corrected. I'm on my phone right now What about saving wrong attempts by ip in a table and adding random milliseconds to each response. How would an attacker guess what is being done?
&gt;If the key gets leaked and if the DB gets compromised. Ok. Well then I guess bcrypt is better than everything else. 
The purpose of a salt is to prevent pregenerated attacks (rainbow tables.) It can be stored with the password. Infact that is what bcrypt does: `$2y$12$QjSH496pcT5CEbzjD/vtVeH03tfHKFy36d4J0Ltp3lRtee9HDxY3K` `$2y$` is method `12$` is a cost of 12 `QjSH496pcT5CEbzjD/vtVe` is the salt `H03tfHKFy36d4J0Ltp3lRtee9HDxY3K` is the hash
https://stackoverflow.com/questions/28395665/could-a-random-sleep-prevent-timing-attacks
Also posted today: https://www.youtube.com/watch?v=XJD9_Jh1iTQ Suffice to say, `str_shuffle()` is common and *very bad*.
&gt; any dev worth his salt would have looked at that code and raised an eyebrow. You'd be surprised how rare these people are. Also, valuable. &gt; 2) Always peer review the security code (invest in security experts or hire a contractor) Shameless plug: The company whose blog post we're discussing is usually looking for new clients. :)
&gt; You'd be surprised how rare these people are. I still have faith in the php culture to learn and grow. But more blog posts are needed. *hint hint*
https://www.airpair.com/
I think that the Wordpress devs, and their usage data, would probably disagree with you that their base product provides no value. Also, I'm excluding core "plugins" like Akismet from this.
&gt; For example - if an application is running on a machine, and someone disconnects the hard-drive every file access is going to start failing. There's no way to handle that This highlights the reason why I personally hate *exceptions*. I/O errors are **not** *exceptions* in the first place. They're to be expected, so the idea that you can't handle them is laughable at best.
But this would have solved the timing issue and the backdoor? ... password_verify($password, $this-&gt;dummy_pw); return false; ... edit: formatting
I agree, it's not obviously malicious. The initial issue would have set off my spidey sense. That combined with all the other bits would have made me very uneasy on average. In any case I would have bounced it after that initial issue. Then again, security is something important to me even as a someone who isn't a security specialist.
I'm dealing with a rabbitmq client, it actually did something in close method(and it do has a destructor and calls the close method), I don't know if you just let it die with php, without the proper destruction, what will it do to the server side.
Sure, you can use __destruct() { /** Code here **/ } that is automatically executed at the end of an object's lifecycle. You could use that method in a class to handle disconnections etc. You have to bear in mind... what if your application fatals for some reason, and the destructor isn't executed? You have to code for that edge case in a stacked error handler. [SEE EDIT] Or, just find out what happens when you cancel. I'm sure the server-side will handle this well. [EDIT]: Here's an interesting SO question for when the destructor isn't called: http://stackoverflow.com/questions/3434270/are-there-any-instances-when-the-destructor-in-php-is-not-called
&gt; Couldn't a compiler optimize the verification out if you just return false, and then you are back to the account enumeration attack. PHP isn't compiled. &gt; Also couldn't branch prediction leak enough information to enumerate accounts too. Yes.
I know exactly what T_PAAMAYIM_NEKUDOTAYIM means so I fail to see the problem. 
I think it's justified if you're making use of some of the new features in 7. I'll be pushing hard to get us to make the upgrade this year at work; the performance benefits are just too good. 
I need to start using this response
Laravel at it's finest /s. Sad day for them.
I don't like the response, but really, for something like this you *really* need an ironclad set of reproduction steps. If the OP can't reproduce the issue locally (especially if it's a specific driver for a specific external service) I wouldn't blame someone for closing it.
Thanks for the clarification :) 
Yes it does. Specific example: We audited a project for a client that used `str_shuffle()` to generate new passwords (14 characters, fixed alphabet). We estimated a maximum of about 2^80 possible permutations of the string they were shuffling (assuming a CSPRNG had powered the shuffling order), but the upper limit was really the approximately 2^32 possible states.
Given that the timing issue is not realistically solvable, what are your thoughts on the following matters: * Do you think it's still useful to make it harder to obtain the timing information by doing a dummy hash verification making it less trivial (in terms of number of requests required) to determine if the username exists or not? * If you don't think it is useful, wouldn't it be more use friendly to display "Invalid Username" or "Invalid Password" to the user depending on the inputted values given that "Invalid Username or Password" error does not provide additional secrecy?
See https://www.reddit.com/r/crypto/comments/3zpd2e/defcon_23_underhanded_crypto_contest_password/cynxowu You should eliminate these concerns in your threat model. Part of the social engineering at work is "Hey look at this academic concern on the blog of a cryptographer. Now let's pretend it's a practical consideration!" I discuss timing leaks [here](https://paragonie.com/blog/2015/04/secure-authentication-php-with-long-term-persistence#title.2.1), where leaking your "remember me" cookie could degrade security, and how I engineered a system to resist these attacks by separating the lookup and the verification. But seriously, if you username leaks out, big deal. You should assume they are public anyway!
Both ext/memcache and ext/memcached have been updated for PHP7, so they should work perfectly fine for you out of the box...
Great, keep me posted as to how you get on! Feedback is always welcome. If you need to delve into your logs to see issues, your PHP is probably configured with errors turned off. Add this code in `lib/common.php` before the functions (non-live only) to see errors on-screen: error_reporting(-1); ini_set('display_errors', true); In general it is a good idea to have a configuration system that detects the environment (e.g. live and dev) but I felt that was too much for the reader in this case - the material is copious enough already! 
&gt; why did you get into PHP what was the allure I was already a desktop app and Flash applet (yes, those were the days) developer. PHP gave me easy access to the server, and was widely available via cheap hosting services. &gt; What made you come back... I started serving clients who needed their own web app on cheap hosting services. :-) &gt; ... time and time again? I found PHP4 crude and primitive. I was looking for alternatives. But PHP5 was a breath of fresh air. With PHP 5.3 and closures, namespaces and so on, PHP has started on a new path of becoming a solid and credible scripting platform. So when it comes to web frontend development on the server, I stopped looking. PHP does the job. I use Python a lot as well, and I consider modern PHP7 to be on par, and in *specific* places surpassing Python purely as a language. I have no worries to use PHP where I'd use any other scripting platform. Of course, there are many situations I prefer a language with better tooling, performance and a more mature type system, like Java, C#. But PHP has its place and it fills it nicely. &gt; When was the first day you realized, I am a serious PHP developer? I don't consider myself a "PHP developer". PHP just happens to be in my toolbox, and I use it to solve people's problems and address their needs. &gt; When was the day you wept over using php and danced with joy over using it? I find the lack of generics and type algebra (unions, intersections) frustrating at times. It does force inferior designs in my projects *sometimes*. As for joy... I don't know honestly. I dance with joy when I write a great application, what it was written in really doesn't matter. PHP is, again, just a reliable tool. No one dances with joy for using a screwdriver. But they would probably dance with joy for having a screwdriver so they can fix their broken computer, for example. &gt; Whats the worst code you've seen and the most beautiful code? I don't think about code like that. I range it from incompetent to competent. There is a lot of incompetent code written in PHP, it's true, but it's coming from the fact the language is so accessible, and it's so easy for amateurs to build on top of popular platforms like WordPress and have a site. PHP lends itself to being written both incompetently and competently. It depends who you work with.
What about using the time to create a fixed wait? Look at the time when the login attempt comes in, do your login operation, then look at the time again and wait until time = starttime + 2 secs or something before returning.
Well, I don't know where you're getting your extensions from, but they show up in Remi's PHP7 repo for CentOS 7... I'd assume that if they weren't ready, they wouldn't pass the tests needed to compile and get stuck in a repo. Mind you, I haven't tried them yet... our codebase does horrible things with foreach() and list() that changed in 7.
It's absurd how much developers can dig in their heels over something that should never have existed in the first place. I started learning PHP about 10 years ago and in that time I got that error "unexpected T_PAAMAYIM_NEKUDOTAYIM" and my immediate response was "what the hell does that mean?" So I googled it and got my answer, but it led to another question: "Why did they give it that ridiculous name instead of something understandable?" It turns out that the answer to that question is just as ridiculous as the token name. How pathetic.
I was using an Ubuntu PPA that seemed very popular. 
How much of a concern is cost? php[tek] (and php[world] in November) are very good but also on the pricier end. Laracon is good if you want something cheaper, but it will be focused on Laravel--probably better for you if you're experienced with Laravel, the general PHP conferences usually have sessions that are more "intro to {framework x}". The regional conferences will likely be cheaper but also may not have as many options as far as topics during each time block. That being said, if your company is paying, you can't go wrong with php[tek] or php[world]. They're two of the biggest US PHP conferences every year and cover a wide variety of beginner and advanced level topics in and around PHP.
Is all of this really necessary? Why can't the CoC establish some basic guidelines which the community as a whole can interpret and enforce on their own? Is it even possible to come up with a list of well-defined examples? I'm reminded of this quote by Supreme Court Justice Potter Stewart regarding the definition of an observable yet subjective fact/event: &gt; I shall not today attempt further to define the kinds of material I understand to be embraced within that shorthand description, and perhaps I could never succeed in intelligibly doing so. But [I know it when I see it](https://en.wikipedia.org/wiki/I_know_it_when_I_see_it). Perhaps we don't need to come up with a strict, all-encompassing definition of what "bad conduct" is. I'm also curious as to why some folks are proposing that a CoC team/tribunal/panel/court/whatever be created. Is our community not capable of identifying and dealing with bad conduct "when we see it"? Perhaps there are examples I'm unaware of where the community failed to act, but I'd like to think that the onus is on **everyone** to deal with bad conduct instead of offloading that responsibility to some bureaucratic group. Furthermore, it seems like creating a CoC team is the reason some of these controversial issues are coming up: - The need to have well-defined rules - Determining who will enforce the rules - Requiring some sort of "due process" or appeal procedure Again I ask whether it would be better or easier to educate and empower the community to act and hold people accountable instead of empowering only a handful of individuals. --- **Disclaimer:** I'm not disagreeing or being confrontational, just trying to better understand the reasoning behind this approach and why it might be necessary or better than some alternative approach.
Yeah I understand there's no point doing it I was just wondering if that would work.
I listed a few popular framework conventions since they generally have quality talks. I've been programming professionally for about 8 years now, so I don't personally need an intro talk. =D As for cost, I don't want to rule out anything just because it's expensive. If php[tek] is great, then I'll try to make it work. The budget will be what it will be, and I can spread it around or blow it all on one. 
What? That we use `hash_equals()`? Why would I mention that? It's not part of the backdoor, just a regular coding practice.
Raises hand. Yep, can confirm.
User input is being compared to user input. This doesn't mitigate CSRF as I could easily set both values.
It's a lot of fun making a login manager, I find. Just not on any serious project. 
conferences are generally as good as you make them. larger ones have more to offer in terms of content and attendees, but the biggest value is almost always the connections you make at the meals, in the afterhours get togethers, and the hallways. You'll often see nice intros to concepts and tools and libraries in sessions, but typically, sessions are &lt; 1 hour - there's never enough time to get *huge* benefit from the session itself. Having access to a library author, though, is often much more beneficial in the long term.
Would bet all my money that less than a fraction of a percent of WP people even care. 
There is also performance improvements, return types and other nice things.
It is as you said, they are very similar. Location and timing will probably be the deciding factors if you choose between one of these two. php[world] was in Washington DC last year, although I'm not sure if it will be in the same location this year.
&gt; Is our community not capable of identifying and dealing with bad conduct "when we see it"? Maybe the "community" can, but can php-internals? Given the historic attitude of php-internals in general, I have *zero faith* that an internals-wide discussion on specific instances of a behavior problem would be constructive or productive. In fact, I imagine it'd soon devolve into the mass stupidity that happens any time internals discusses anything remotely controversial, and the "accuser" and "accused" would end up getting dragged through the mud, in public. Also, given the *disregard* for RFC rules and procedures that *some* core contributors have demonstrated in the near past, I have *zero faith* that internals itself could and would ever actually hold anyone accountable if a behavior problem was ever raised. These are just a few of the reasons why a smaller group to perform the initial handling of these problems can be a better approach, even if the creation of that smaller team raises a bunch of other problems. IMO, it will be easier to craft a ruleset that governs the smaller team than it will be to ever deal with a problem by having input from *everyone at once*.
Fair enough, thanks for the reply!
&gt; Is our community not capable of identifying and dealing with bad conduct "when we see it"? The point is they may not see it. And the victims of said bad conduct may be too ashamed or elsewise not willing to make it public, but would be willing to share in private, especially if there can be repercussions over it. Additionally, your point of rationality is exactly why there is no solid definition of discrimination or abuse. It's incredibly hard to define properly, but it's easier to "know it when you see it" which is why if you assume the response team is rational the entire thing has almost no downside. In fact, every argument against the team so far has assumed that the response team will be irrational (something that hasn't been proven so far).
&gt; In fact, every argument against the team so far has assumed that the response team will be irrational (something that hasn't been proven so far). The proposed CoC contains wording that some people view as politically charged, originating from a worldview that they do not share, or, worse, that they are opposed to. Experience has taught them that the wording they see is a sign of people that can not be trusted, because they identify people that use the wording as irrational. Once this opinion is formed, the discussion is done. There is no sane way to argue against the viewpoint, because now the people arguing for it are associating themselves with a worldview that is considered untenable and untrustable. A solution may be removing the proposed CoC from the proposal to create a conduct response team. There are other CoCs that cause less political divisiveness, like the one Debian uses. Collecting possible CoCs and putting them up to a vote as a separate RFC may make the entire process palatable enough to get both the CoC and the team ideas passed.
But there doesn't seem any reason to verify against the password the user entered when the username does not match a account anyway, so why not do: return password_verify('not_found', $this-&gt;dummy_pw); That would both bypass the timing attack and the noise function is incapable of generating a string with a _ (plus it returns a fixed size string) so it's not possible to have a accidental match.
See, the problem is, you're more clever than a lot of people. ;) Or maybe it helps that I'm going "attention this is a backdoor". Send the source code to `TimingSafeAuth` to other devs and see if they catch on.
The way CSRF tokens are pulled off in the real world, most of them would be mitigated even by this really dumb cookie check. (This is how Django does CSRF protection.) But yes, don't trust user input. :)
Why is everything on that page so large compared to the rest of the pages on this sub?
&gt; I was already a desktop app and Flash applet (yes, those were the days) developer. PHP gave me easy access to the server, and was widely available via cheap hosting services. Actionscript, next to php, is one of my favourite languages. &gt; PHP has started on a new path of becoming a solid and credible scripting platform. Doesn't these features actually make it more of an OO language, like java, then a scripting language , like ruby?
As has been stated before, "never having had a fire before, doesn't mean you don't need a smoke alarm".
&gt;Failing at step two will take measurably less time (from an attacker's perspective) than failing at step three. By doing so, an attacker can send a bunch of requests and figure out valid usernames, even if the rest of the application is secure. This is a good point, but if a developer is implementing login procedures and doesn't know this then they should not touch this. Always run the full operation set that may expose external credentials. Also, an [Erlang authentication](http://hexdocs.pm/comeonin/1.0.4/Comeonin.Bcrypt.html) library does a similar check to verify a dummy user hash check to circumvent this type of enumeration as well.
This timing difference is still present in the database lookup. There's really no way to mitigate it efficiently.
Wow, that changes things, a lot. So you can get banned from PHP because you're posting sex jokes on your personal Facebook page etc. Now that is definitely unheard of and the very worst of collectivism.
You don't need to work on someone else's code for your own public repo to be a great resource. Nor do you *have* to have it on github, as long as it's public and linked in your resume. I can't stand the UI of git, so I use hg and bitbucket, for example. Code samples - examples that you know what you're doing - are *incredibly valuable*. Experiment with a framework and put that experiment up, noting the goals and what did and didn't work in the README. Find an interesting library and build a trivial application around it. Put the experiment notes in the README. Build a trivial CMS, just because you can. Put the goals and anti-goals in the README.
PHPUnit 5.1.3 with PHP 7.0.1 using Xdebug 2.4.0RC3 seems to be working fine, coverage-wise
I got a free 1-year subscription for attending php[world]. It's nice but I don't know if I would go out of my way to pay for a subscription. Then again, I'm not a big magazine person and get most of my programming news from Reddit.
[The RFC lays out what the proposed team can and can't do](https://wiki.php.net/rfc/adopt-code-of-conduct). Go read it for yourself. Don't assume what it says based on what others are saying about it. The most they can do is turn off access for a week or rollback commits/edits. Anything stronger than that requires an internals-wide RFC vote with a 2/3rds majority requirement. Given how stupid internals can be about things, it'd take a *horrible* incident for them to actually unite behind a ban. The RFC clearly states that bans are the last possible resort and "should only be used in egregious cases where a pattern of disregard for the CoC is demonstrated." That said, the scope description is: &gt; This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. I see how you can assume that "you can get banned from PHP because you're posting sex jokes on your personal Facebook page" from that wording, but let's face it, given the *big* tasks required to actually *get banned*, that's not a realistic scenario. Perhaps that wording can be tweaked?
&gt; They are saying that $_COOKIE is user input, and so it's pointless to use it as a CSRF method, unless you are simply sending to cookie as the means to provide the token to the client. Tell that to Django. &gt; I imagine you already know this, but it is an oversight. Yes and no. Yes, it was an oversight in my original implementation (I literally threw this together in about an hour the day of the deadline). No, most CSRF attacks don't relinquish control over your HTTP cookies to the attacker. If you're thinking XSS + CSRF, then the attacker can just grep the correct token out of the HTML body. You want a CAPTCHA to stop those. I normally store CSRF tokens in `$_SESSION` because it puts less data in the HTTP request headers and means even less control the client has over the state of the application. The goal there is to minimize the surface area of attack and make auditing easier.
My team just shipped a horrible "subpar" software this Monday two days ago, and we already have 18 happy clients with credit cards signed up on it. Fifteen of those people were invited to and impressed by our private beta and became paying customers. I so regret using PHP, Java and Go for this, we had a party last night to cele... I mean, to regret our unfortunate choices. Thank you for your condolences and pointing out the obvious. We're already planning to ship an even more disappointing and subpar v2 by Q3 2016. By the way, what have you shipped recently, aside from your vitriolic Reddit comments? 
It's worth pointing out that, as with all things political, what is written down in the formal proposal is not the end of what's designed. Some of the conversations that have occurred in #phpmentoring and on Twitter have indicated that proponents of this have *big plans for it*. They see it as the tool they'll use to whip the PHP community back into shape, according to their definition of what's right and decent. If this was just a proposal to keep the mailing lists civil, I'd probably be ignoring it altogether. I don't deal with the mailing lists much, because the most interesting parts of it are simply the petty squabbling that goes on. Not harassment, not flagrant misogyny and racism, not the sorts of personal attacks that these moral panickers are making it out to be. It's simply fervent disagreement over technical matters, as can be expected when a bunch of programmers have different ideas about how their favourite programming language should work. The reason I'm so passionately opposed to this is simply because of how it's being portrayed by those proposing it. It is a political lever that will give them power to deal with those they don't like. That being said - I'll give you that bans aren't likely to be common. That's too open and direct an action for them to want to take. More likely, these "thought police", as ircmaxell suggested as a more palatable alternative to "cultural gestapo", is probably going to use their formal authority to enact whisper campaigns against people, under the guise of "investigation". The mere threat of being "under investigation" is all that will be required to silence dissenters. It's happened before in the PHP community, and it'll happen again.
If you reread my comment you should note that I acknowledge and support the use of salts. I don't support the use of a single salt for all passwords. 
&gt; Because checked exceptions are terrible. No they aren't: [&lt;lengthy discussion&gt;](https://www.reddit.com/r/programming/comments/2lea0u/whats_your_most_controversial_technical_opinion/clu0rvf) &gt; They make exceptions be part of the API [...] With checked exceptions, this is an API break. That's not a bug, that's the *feature*! [I'm serious.](http://imgur.com/iYE5nLA) The whole point is that your **exception** type(s) can get "checked", the same way **parameter** types are checked, the same way **return** types are checked. They are all coequal parts of your method-signature and the caller must be using them in a compatible way. &gt; Although they are great for small code base Automatic checking of *parameter/return* types helps you build *success*-paths for large systems. Similarly, automatic checking of *exception* types helps you build *failure*-paths for large systems. &gt; or you do the equally bad thing of catching specific exceptions at a lower level, and turn them into a generic "SomethingWentWrong" exception, which is of no use to man or beast. You forgot a third, better approach. 1. You **chain** exceptions, so that you have details to log or debug with. 1. You pick an appropriate exception *in the context of your own application or layer*. In a small top-level application, that might be `SomethingWentWrong`, but if you're building a module or library you need to [pick something suitable for the next layer up](https://www.reddit.com/r/programming/comments/2lea0u/whats_your_most_controversial_technical_opinion/clug55r). 
 &gt;Ok. Well then I guess bcrypt is better than everything else. Any salt stored alongside the password is vulnerable to a rainbow table if the attacker has access to the salt and the password hash. This is why I suggested storing the salt in a different database on a different server. It is well known that people are by nature lazy with their passwords. By lazy I am referring to password reuse. If your database holding the user's email, password hash, and salt are compromised then the attacker can go to all major financial institutions and log in as that user. If the user was lazy and reused their financial institution password then they are f***ed. Similarly to the Target attack, attackers used another system (HVAC) to eventually gain access to the card readers to get cc info. In other words, not all targets are primary targets. 
I wouldn't be surprised if checked-exceptions don't "fit" into PHP's unique situation, but in general [I think they can be extremely useful](https://www.reddit.com/r/programming/comments/2lea0u/whats_your_most_controversial_technical_opinion/clu0rvf).
&gt; Yup, bit of a shame it didn't become the next JavaScript (as was the plan). But... we have TypeScript now. So things are good again. :-) But ... Es6 ..... 
&gt; Any salt stored alongside the password is vulnerable to a rainbow table if the attacker has access to the salt and the password hash. Only if you're using a homebrew crypto method and have an application wide salt. A rainbow table has to be generated for it to be useful. To do that you must do the task of generating every combination so it's similar to bruteforcing but would be effective against all hashes retrieved. With a single use salt, generating a rainbow table is pointless. It takes up more IO writing to disk and takes up more space on the disk. It's also useless for every other user. Once you have a random salt for each user any type of rainbow table attack is nullified. The salts are for randomness.
&gt; I believe that the reaction to the RFC has demonstrated that there's significant disagreement on what "reasonable" means and what a "reasonable person" will believe. Judging by the way people talk about it, I don't think so. Most of the descent has been ideas that the CoC team will be comprised of "SJW"s and hence assume the worst possible interpretation of the result. Considering that anyone nominated for that team must be accepted with 2/3 majority (and can be removed with 50%+1), if a group of radical people are elected, then it's because the PHP community made it so. And it's in their power to remove them too... &gt; It will be a good idea to make the scope wording less vague. Maybe this can be done by providing explicit examples of non-project areas that are in scope and why. Yes, that's in my plan to make a bit more explicit...
You're not the only one proposing it. Your name is on it, but there are many supporters of your proposal who have specified how they expect to be able to use it, if passed. I'm shedding light on that fact. What you're seeking to create is a system which will be capable of serious abuse, regardless of how reasonable and rational *you are*.
&gt; What you're seeking to create is a system which will be capable of serious abuse, regardless of how reasonable and rational you are. I am seeking to solve a problem. If I was doing what you say, I wouldn't have changed my proposal significantly already, nor would I be willing to do so more (and am actively doing it). If I was doing as you say, I would have put it straight to a vote and put fingers in my ears when people yelled. 
No, I don't think anyone would ever say that in PHP $a == 'b' ===&gt; A equals "b" But $a = 'b' is always "a gets assigned the value of b" 
I didn't say you were intending for it to be capable of abuse. I'm saying that you're refusing to accept that it *will be abused*. You've given a weapon of censorship to anyone who's more concerned with the ends than the means.
Isn't every part (or most) of this RFC able to be changed by a majority of voters? So much rhetoric against this RFC seems to stem from the CoC team becoming a problem. Seems like an overreaction, since A) as Anthony already said, that assumption has not and cannot be proven until put in practice (and since the CoC is an elected body, shouldn't there be a very small chance of that happening?), and B) anything can be changed in the future if things don't seem to work out as expected. Come to an agreement on the basic necessities that are required for the CoC and any potential team that will handle poor behavior. Give it a shot. Change something (or everything) if it doesn't work. All this discussion is just going to stagnate adding something positive to the community. And as has been said by many people already, something is better than nothing.
&gt; I'm saying that you're refusing to accept that it will be abused. Correct. I will accept that it *can* be abused, meaning that a world in which it is abused exists. But I refuse to accept that it **will** be abused, because I refuse to accept that the team the **community** elects and oversees will be unreasonable to the extent that would be required to reach the level you're claiming. Is it possible to abuse? Yes. Is it likely? No. Because if a majority of people (50% + 1) think it's being abused, guess what: abuse stopped. 
Fairly? Any specific issues you've had with it in the past, or things you think might be better about it?
Supporting a bunch of services means you're in some ways limited to the lowest common denominator. IronIO's queue has some neat features (like extending an expiration on a long-running job via `touchMessage`), but they're unique (or at least rare) and thus not supported in Laravel's queue system. Laravel lets you dig down by doing `Queue::getIron()` but that obviously makes moving to another driver more difficult.
&gt; I am seeking to solve a problem. Man, you know I hold you high regard, but this will only cause more problems. It is a horrible idea.
The "reasonable person" will be the persons who want to enforce it; those who are against the Code of Conduct will be tarred as "unreasonable."
Thanks for the help.
This is correct, I was reading a memo earlier about fake proxies but that's more of a possible MitM or just a plain attack rather than a CSRF.
Can confirm that phpunit seems to not have any issues. Laravel seems to play nice with it and testing seems to work the same. A good way to test is adding php7.0 to travis or ci and let the ci tell you if the tests pass/fail as a matrix. Just a thought. 
&gt; I beg you, please take to heart the opinions of those who are against it. The outcry is not for invalid reasons. I have said time and time again, I will honor constructive feedback. What I will not honor is sensationalism and aggressive behavior or language. If you want to have an open, civil and calm discussion, I am all for it. I have already used feedback provided, so I think I have shown I am not trying to railroad something through. However, I will not respond to sensationalism. I will be proposing a COC and a conflict resolution policy. If you want your views to be taken into account then lets have the discussion civily and without blowing things out of proportion. I am 100% willing to compromise, but realize that I will not be persuaded by sensationalistic arguments such as the majority you have put forth. So I leave it to you Paul, do you want to have a calm discussion around this and see if we can come to a common understanding?
[removed]
There's a lot to be said for easy readability versus condensing everything into a bunch of one-liners.
I've made more than a few hiring decisions for developers. I'd take actual code on Github over any cert. But the only cert I'd give weight to is the ZCE. *disclaimer: i did tech editing on the ZCE 4 book by php|architect, and taught a prep course like 8 years ago*
That's just a slippery slope argument though. As far as I can tell this is a bog standard solution to a known issue, using a committee chosen by the community to deal with problems in a transparent manner. The only way I could understand all this fear is if contributors didn't trust their peers to elect fair minded people. But that would call PHP's entire RFC process into question.
&gt; That's just a slippery slope argument though. A slippery-slope argument is only a fallacy in logic. This is politics. &gt; The only way I could understand all this fear is if contributors didn't trust their peers to elect fair minded people. Fair is in the eyes of the beholder. &gt; But that would call PHP's entire RFC process into question. If it were a technical decision you might be right. But this is a political decision.
&gt;So if you want to keep these examples, fine, but you need to define hard boundaries. E.g. what is sexualized imagery and when does it become offensive? If your starting position is to define something that infamously [flummoxed the Supreme Court](https://en.wikipedia.org/wiki/I_know_it_when_I_see_it) you're in a lot of trouble. You'll probably waste a ton of time just to end up back at the same "reasonable person" standard.
Ya, I guess convention is a bit ambiguous and typically refers to naming or rules within programming. Though if you search "anime convention" you'll see that I'm not totally crazy. 
&gt;A slippery-slope argument is only a fallacy in logic. This is politics. What does that mean? &gt;Fair is in the eyes of the beholder. This isn't any single person though. It's a community deciding what their shared values are then selecting a trusted group to adjudicate for them in a transparent process. &gt;If it were a technical decision you might be right. But this is a political decision. I don't see how they're different. Everyone would vote the same if "technical" decisions weren't loaded with their own presuppositions and personal preferences.
Let's start here: &gt; What does that mean? It means what it says. What do you fail to comprehend about it?
Very nice article. I used it a little while back to implement remember me tokens with great success.
Have you seen what happens in communities where codes of conduct are adopted? They quickly become weapons for ideological warfare, not the promotion of civil discourse.
I wish I had your optimism.
So, nothing uncivil then, I take it. What *hyperbole* have I presented?
&gt; It will be a club with which to beat others, or worse, a poison gas to infuse into the community at large. It truly is horrifying. That is hyperbole. Pure and simple. It is an exaggeration on one extreme possibility to try to prove your point. And that's just in this thread. 
Also, this isn't the first CoC group ever. Many other projects have adopted them. If there have been problems with those, then they can be learned from.
wouldn't there just be another RFC to dissolve the CoC? Seems like it's easy to take power away from them if they are causing a problem.
Sooo... not PHP?
As a newcomer to Haskell (currently learning it), this looks very interesting. Although I think the article bangs too much on the `Vect` type, having the compiler check all the possible matchers upfront is quite interesting. Will surely check it out once I'm through my little pet `.hs` projects.
Read the title
I would call that "exagerration for effect", but ok, let's say that's hyperbolic. What else?
That's the definition of hyperbole, so yes. What else? Basically everything you have said in each of these threads is that way, even down to calling out MichaelC in the fig group for "being against free speech". You may have a valid point but the way you are presenting it isn't going to change anything. If you want to actually have an impact, drop the hyperbole, drop the sensationalism and lets discuss how to make the proposal better. 
Well, aren't you a sad picture. It's "cut TO the chase", BTW, genius. Not "cut the chase".
Literally every word has been "hyperbolic"? That seems a little ... extreme. Hyperbolic, even. Wouldn't you say that's hyperbolic?
This depends on the job. Is this contract work or full-time with benefits? Are you looking for remote workers? If you want them to be local, are you going to give assistance in moving to Utah? Are you sponsoring for visa's (foreign workers)? 
Adding "PHP" to a title doesn't magically make it PHP-related. Please post this to another sub.
&gt; I want to apply for a PHP certificate that I can use as reference e.g. for applying at companies in the future. ... [reputable] actually doesn't matter because I'm will not apply for any web developer job I... can't figure out what you want to achieve with this certificate. You want it to apply at companies but not for jobs??? &gt; I've thought about the W3 certificate that costs around $100 but I've read that it is not very reputable A certificate from the W3*Schools* (not to be confused with the W3C) is worse than not reputable. If someone cites a W3Schools certificate as proof they know what they're doing, it's a big red flag that they *don't* know what they're doing.
Watch out. Laravel removed IronMQ support in 5.2. If you're upgrading you'll have to install [LaravelCollective's IronMQ library](https://github.com/LaravelCollective/iron-queue) to get it back.
&gt;my own council I will keep I think this is a big part of the reason why people aren't okay with your proposal. Oh the hilarious irony
Can you guarantee this? Whatever horrible things a committee might do, it will do. 
Man, one of the reasons I became a professional nerd was to escape from politics. 
... Because she has a long well documented history of lying! Look, I believe that no one should be harassed, but if you seriously want to use Randi Harper as an example of how to act... You might want to reconsider. 
It must suck that your feelings get hurt so easily.
Worse, shadowbanned. 
Seems neat! One thing I've been struggling to conceptualize is how rabbitmq's `exchange/routing_key/queue` relationship might work in other "queuing" frameworks, such as redis or beanstalk. I'll definitely checkout out how you setup your routing system as inspiration :) (Hell, I may even drop my project in favor of writing backends for yours :P)
What I do (and promote in the CakePHP community) is checking for another environment variable [like so](https://github.com/josegonzalez/app/blob/master/config/env.php#L6): if (!env('APP_NAME')) { // load dotenv } This way we can short-circuit the env file loading if we assume a user will *also* set the `APP_NAME` as an environment variable in their webserver, process manager, or whatever runs cron tasks.
PHP UK Conference - London Feb 18-19 2016 http://phpconference.co.uk/
I wrote and use [Phive Queue](https://github.com/rybakit/phive-queue) and [Tarantool Queue](http://github.com/tarantool-php/queue). The first one is a time-based scheduling queue with multiple backend support. It’s a simple and robust scheduler and using it with [Phive Task Queue](https://github.com/rybakit/phive-task-queue) covers 90% of my use cases. But if I need more advanced queue with extra features, like priorities, tubes, fifo/lifo/whatever ordering, or when I use [Tarantool](http://tarantool.org) in my project, I prefer Taratool Queue. It supports [many queueing strategies](https://github.com/tarantool/queue) and the most cool thing about it is that you can even write your own app specific queue in Lua. For example, it took me few hours to implement retrying for failed jobs with different strategies (constant, linear, exponential, etc).
If you think you need a certificate to be a good PHP developer, you're in the wrong business. Get coding - that's how you become a good developer. Not with false certifications that only tell us you're good as passing exams. As others said, put code on github and let your prospective employer see it. They won't give a damn about a piece of paper which may as well be saying "yep, this guy codes".
Not sure if trolling...
Going to echo the other person that's replied to this comment just so you have some more proof that you're not being bullshitted here. Work on something open source. Think of an idea of something you want to build, use some new tech, or perfect the use of something you want to work with more. Whatever you do, get some work done on a real project. Honestly, if I were interviewing someone and they said to me "oh, I have this certification for PHP" the first thing I'd say is "okay cool, can you show me some examples of projects you've worked on?". I wouldn't even want to know the name of it, it's irrelevant. Showing you can do something with a real example is so important. Make something, give it an automated build, documentation, tests, the works. Just do something real - not some daft waste of money certificate. You don't have to code to make money, or to work on someone else's project. If you don't enjoy doing that, then you're probably in the wrong business.
If someone cites pretty much any certificate to do with PHP, I'd instantly assume they didn't know what they were doing.
I work for a sizeable startup. We are still using php 5.4.45 and have no intention of changing that in the nearby future due to the amount of other places that we'd rather invest our time in.
http://stackoverflow.com/a/28486617/2224584
I use PHPResque with Redis when I only have a couple of jobs, or RabbitMQ when I need something more powerful.
Good old Vi. Tried PHPStorm for a while ( got a student license ). But am too used to vi, that I do not want to start using arrow keys.( they suck on my MacBook and most other laptops I have seen ).
The advanced Zend and Symfony certification is worthwhile if you're going after enterprise or public sector contracts, but it still needs to be supported by a solid portfolio.
oh the irony.
Speed is one of the worst arguments to support PHP 7 only. You get the speed once you upgrade. The reason to _require_ PHP 7 should be its great features, but not speed.
You get the performance improvement by *using* PHP7. You don't have to require PHP7 in your packages to use it. The other points obviously still stand.
Although not finalized just yet, there looks to be another PHP conference in Sydney Australia in April of this year. http://www.phpconference.com.au/
As I understand you have diferent interfaces with similar bootstraping. So that you can have your services, libraries on the webserver side and terminal side. You can have a Servicemanager/ServiceLocator/IoCContainer bootstrap all your shared services like plugin bootstraping, database connections, configuratios... and share it between your interfaces.
A couple of options, depending on what you're trying to do: 1. Abstract the request so that you can create a fake request without needing the web server to inject a real one. So instead of accessing the superglobals (such as $_GET and $_POST) you access them through the request object. Make it a rule across your whole codebase that once you've created and populated the Request object, other classes only ever talk to that object. 2. Most of your classes should have no knowledge of whether they were called by a HTTP request or via the command line. They receive parameters, and don't need to understand where the values came from. You can make separate web controllers and terminal scripts that talk to the services. You can combine both techniques by injecting the Request object wherever a service needs access to the request context.
You're right, but in software architecture you could think of "HTTP context" and "CLI context", and then the underlying services which shouldn't care about how the request was initiated. For example, changing a value in the database is possible via a HTTP request and via a command line app.
I thought that maybe, if you took the "learn" away, it would tell a completely different story, but it's actually pretty similar... [Trends](https://www.google.com/trends/explore#q=PHP%2C%20Python%2C%20Ruby&amp;cmpt=q&amp;tz=Etc%2FGMT-5%3A30) Pretty interesting to say the least.
&gt; I maintain a system that is backwards compatible to 1990. And we all run on processors those instruction set architecture is backwards compatible to the 1980s :) [or :( maybe] 
Laravel does this a lot. Supported functions of the application can be run from the command line or via the front-end controller. What you have to watch out for, is which OS user each runs at, because it can play havoc with files written to the server (e.g. log files, compiled templates).
Look at "X Tutorial" what you will see going back to 2005 is that number of people ever interested in learning PHP is 100x or more the others. PHP isn't the new shiny, but it's market penetration in general is lent some credence by the graph.
 &gt;The salt is vulnerable to a rainbow table how? If you have the salt, why do you need a rainbow table? The point of a strong salt is that it pretty-well guarantees that the hash won't be in a rainbow table, as I understand it. You're right that a salted password shouldn't match an existing rainbow table. But nothing would stop an attacker from creating a new table that uses the salt. This is why using a single, application-wide salt is bad. &gt;Also, the point of hashing is that if an attacker does get ahold of the hash, the only way they can use it against the user is if they can crack the hash somehow. You don't crack the hash—hashes are one way. You generate new hashes based on every possible combination of password until you find a matching hash. This is why md5 and sha1 are insecure: it's easy to find a matching hash, even if the original strings wouldn't match (a collision). A good random salt makes this computationally improbable/impossible. 
So, what's your deal here /u/phpguy2? You just spend your day looking for stuff that makes php look bad and frame it in as much of a bad way as possible? You have been nothing but an annoyance to this subreddit.
&gt; you want it to apply at companies but not for jobs??? He wants to apply, but not for *developer* jobs. OP wants to apply for less technical jobs, but still show that he has at least some technical knowledge. So I think the situation is a little different from a typical developer where you just look at the candidate's github account.
Hey there Toast42 ... Chiming in here. I'm the conference chair for both php[tek] and php[world] ... They are 'similar' conferences because of the fact they are run by the same team :) However there is one very specific difference that we try to make between them: php[tek] -- It's (one of) the longest running PHP conferences, this will be our 11th year. And it's been described by people as the "PHP Community's Homecoming". So we started using that as a tagline as well. It started as a community conference, and continues to be run as such. The entire team here are PHP community members, running 3 meetup groups among us/etc. So it's really got a 'lets all get together and team-build' feeling to it during the conference, something that mgkismal refers to as well. As far as the sessions go. We tend to focus on 'core PHP' topics, with a good smattering of related technologies (MongoDB, databases in general, Javascript, etc). And then really try to get a number of advanced topics in there as well, so that the conference is wide enough/diverse enough to really have things for beginners and for advanced peeps. php[world] on the other hand -- Was specifically designed to try to bring together the fragmenting communities of PHP. Drupal, WordPress, Magento, Zend Framework, CakePHP, Symfony, Joomla!, and Laravel have all grown up with their own strong communities, and many people who do those frameworks/applications full-time as developers, grew to see themselves "as a drupal developer" or "a Laravel developer", and not as a PHP developer. Of course, in the end we all are dealing with the same problems, we all are PHP developers, and there is much that we can learn from each other. In fact, there was a movement within those communities to help merge things. Drupal has refactored itself using much of Symfony. Magento is now based upon Zend Framework, etc. There's a lot of 'don't re-invent the wheel' happening now. And we decided that a physical event would help with that, because it's something that we want to encourage. So hence why we created php[world]. It has 8 separate tracks of sessions for those different apps/frameworks. To be able to appeal to any of those developers, but with a big focus on the cross-over sessions that will encourage a Symfony Dev, WordPress Dev, and Joomla! dev to 'accidentally' sit next to each other, and learn from each other as the conversations break out. ... So, that's the difference between them - At least the difference that we try to create - I'd love to get any feedback that you (or others) have about how well we are doing that :)
Unless something crazy happens, yes, it will be in the same location next year. We've already signed the contract :) Eli -- Conference Chair php[world]
Anthony stop being naive. If there is literally one thing we have learned from human history and groups of humans in general it is that power **will** be abused. This is like the most recurring theme in human history. Stop having such chronological snobbery to think now we are so much more enlightened than in the past and will be perfect little angels in wielding power.
Here's the fix: http://git.php.net/?p=php-src.git;a=commitdiff;h=2871c70efaaaa0f102557a17c727fd4d5204dd4b So it's a theoretical buffer overflow, in case someone passes a string longer than 2^30 characters to escapeshellarg(). Very unlikely to be exploitable ;)
It does not look like this discussion (starting Dec 4th) had any response from a Canonical maintainer, so I doubt this is really still in flux.
[I like my tag for him more!](https://i.imgur.com/7gS9A2S.png) It's more fun if you imagine him as someone who REALLY loves PHP but can't seem to figure it out.
heh yeah
It's definitely a balance of how much stuff goes in the driver vs a "router" or whether you even need a router. Generally I tried to hide a bunch of stuff in the driver -- including useful things like time to run or delays in beanstalkd because I just found it too cumbersome to deal with in the consumer. Take a look at the [1.0 tag](https://github.com/AgencyPMG/Queue/tree/1.0.0) if you want to see where this thing started (it was ugly).
Engage Canonical on IRC.. Post in the discussions or tweet about it. Retweeting this could help: https://twitter.com/binwiederhier/status/684900968308289536
[**@binwiederhier**](https://twitter.com/binwiederhier/) &gt; [2016-01-07 00:54 UTC](https://twitter.com/binwiederhier/status/684900968308289536) &gt; Hey @Canonical @robiebasak Are there any plans to ship Ubuntu 16.04 with PHP 7? https://bugs.launchpad.net/ubuntu/+source/php5/+bug/1522422 ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Ubuntu LTS is intended to be very stable with very few new features. PHP 7 was only just released and has not been out for long enough to be considered stable enough for an LTS release. Heck, it was released 32 days ago. LTS releases rarely include new features, usually they just re-release the previous release ( in this case 15.10 ) with a shit load of bug fixes and an updated kernel. If you wanted PHP 7 in Ubuntu 16.04, you should have released it before the feature freeze date for ubuntu 15.10 ( may 2015 ). 
Just shadowban already.
&gt; Ubuntu LTS is intended to be very stable with very few new features. Why can't they make it be stable but with new features as well? /s
Yes, but the real question is, does that represent new projects providing more jobs for a particular language, or does that represent programmers abandoning the language, and so existing projects having difficultly in finding programmers through personal connections, and so needing to advertise the jobs online?
One could argue that Ubuntu LTS is like Debian Stable but with new features as well.
I believe you are indeed correct. ;)
If your friends have all done something apparently so terrible, at least consider whether you're wrong before condemning them.
We kissed! Here's [a link](https://github.com/josegonzalez/php-dotenv/pull/30)!
I liked this fix: Fixed bug #70831 (Compile fails on system with 160 CPUs). Big Iron Problems.
In fact, the voting requirements are stacked that way: 2/3 majority to get in, but only 50%+1 to be removed...
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [Interest in Php is going down down down... • \/r\/PHP](https://np.reddit.com/r/programming/comments/3zw5d0/interest_in_php_is_going_down_down_down_rphp/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Yes, yes, deceive subpar cheap subpar deceive cheap. How deceive subpar cheap subpar. What about your deceive subpar cheap deceive? How do you deal with it?
I have.
Or would it represent people looking for jobs? I think you don't google 'php jobs' if you are an employer.
In mathematics, zero has no sign, this is true. However, some representations of numbers in computers have signed zero, such as IEEE 754 floating point, which PHP uses for floats. On the other hand, two's complement, which PHP uses for integers, does not have signed zero. Why have signed zero? Among other things, it means you know which way underflow has gone (1 / +very_large_number = +0, 1 / -very_large_number = -0). It also helps with division by zero, because for 1 / 0, how do you know if you get positive or negative infinity if zero is unsigned? For signed zero the answer is clear: 1 / +0 = +INF, 1 / -0 = -INF. Further reading: https://en.wikipedia.org/wiki/Signed_zero
Apache web-server by default will treat pic.php.jpg as php. So it's better to either turn off php for that folder or recode images completely, i.e. using GD. 
I'm confused. Is this about having PHP7 as the default, or having 5.6 as default with alternate php7 packages? Half the arguments sound like they're for one side and half for the other.
As always there is more than one solution. My opinion is to just use whatever you feel comfortable with. :)
How can I actually check out the exact release version on git to build? I know going by the tag is not accurate in general but if I checkout the php-src at the 7.0.2 tag I get a build error? Works fine if I download the 7.0.2 release archive.
&gt; validator function making sure anything uploaded ends in an acceptable format (.jpg .gif .png etc.) File extensions have nothing to do with file types, anyone can name any file .jpg You need to check the mime type of the uploaded files. See fileinfo: http://php.net/manual/en/ref.fileinfo.php
Lots of conferences listed under php.net: http://www.php.net/conferences/
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/ubuntu] [PHP 7 needs to be in 16.04 LTS, lets make this happen!](https://np.reddit.com/r/Ubuntu/comments/3zwjcc/php_7_needs_to_be_in_1604_lts_lets_make_this/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
PHP7 should be the default. Ondrej Sury, the maintainer of PHP for Debian and Ubuntu actually has repositories with seperate installable PHP versions but that breaks so much stuff that he himself is advising against it.
I find this pretty reasonable. Will be curious to read objections.
PHP7 has been dead stable to me. And besides, PHP isnt system critical, so I can see no reason to not include it.
&gt; (although, I guess not impossible, but I personally like the idea of penalizing excessive number of bad logins with increased wait times or password resets sent by email) 
PHP 7 was added to Ubuntu 16.04 4 hours ago! - https://launchpad.net/ubuntu/+source/php7.0 - http://imgur.com/Ju1ctj1 - http://imgur.com/jdKygFv
Oh no, but we can do it, right? What happened to *we did it, Reddit*? Reddit can get everything it wants, right?
&gt; PHP isn't a special snowflake that requires a custom CoC. ( ͡° ͜ʖ ͡°)
&gt;If we must have a Code of Conduct, why not adopt one from a mature project? Because simple and concise is better then verbose and vague. Although I don't see the reason one is even needed.
Looks like they're sending the request as JSON, but in the `payload` urlencoded field. $payload = json_decode($_POST['payload']); $events = $payload-&gt;events; is_array($events) === true;
More and more, this is the only thing I care about when hiring. Are you out in the community? Are you working on modern stuff? Are you staying abreast to cool developments? Resumes with contributions to well respected and well reviewed projects go to the front of the line.
The main problem is that it leaves it possible for people to be a shit-weasel to someone else, but so long as they don't do it via PHP mailing lists the PHP project wouldn't be able to do anything about it. People should be able to open the PHP mailing list with having to see emails from someone is being a dick to them elsewhere. PMJones wrote: &gt; Once they have blocked/muted/junk-foldered the person-that-is-harassing, there will have been little for them to see in the first place. And github issues. And bug.php.net And the harassser can still go in and "help tidy up" any commits they make with sarky comments. And so on..... But the basic point is that the person who is getting harassed has to spend energy to avoid the problem. If they've got a legitimate complaint and have already received enough crap to justify a complaint, are they actually going to do that, or are they just going to say 'forget PHP' and go off to a work on something where they don't need to put up with crap? Putting it simply; if someone is being a massive arsehole, would we prefer to exclude them from the project rather than the people they are being an arse to? Oh and btw, the original RFC has been updated to concentrate more on mediation rather than punishment. 
But Paul's version specifically includes things in addition the mailing list: &gt; such as reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other project activities Directly from Paul's post. He seems to be encompassing any "official" channels used by the PHP project for its development and maintenance. ^
&gt; But Paul's version specifically includes things in addition the mailing list: So people can be shit-weasels on twitter, and so long as they don't say anything offensive in a PHP channel, nothing would be done. Let me give you a specific example: * Someone sends a rape threat to someone one twitter. * They send an email via PHP internals about a bug asking "Should I come round and help you out? ;-)" They haven't sent anything objectionable via PHP channel, so the project would be unable to act according to Paul's ideas. And for the record - people wouldn't be banned for occasionally using a wrong pronoun or a stepping on a cultural taboo. Removing people from the project would be an incredibly rare thing to happen, and would only be done when someone is being deliberately and continuously being an arse to someone else.
I believe he's already responded. &gt; If the activity in question rises to the level of filing a petition for *and being granted* a restraining order, *then and only then* might the project have some responsibility to help enforce that order, since the project itself may become subject to a lawsuit or other legal actions. i.e. any harassment that failed to meet a criminal criteria, wouldn't be acted upon. Any harassment where the person being harassed decides to just leave the project rather than seek a court order, wouldn't be acted upon. Fun-fact, if I came round to your house, took some photos of it, maybe some pictures of your family as well, and then sent you those pictures with the message "Hey utotwel, are you going to fix that bug that's important to me", none of that would reach a criminal matter. It would be creepy as fuck - but not anything the police or a court could do anything about. And he's suggesting that this is an acceptable situation.
I guess in your example I would ask: does banning a person that goes to that extreme from the PHP mailing list really accomplish anything? Don't you still have the problem of someone is willing to take pictures of your family? Just thinking out loud here. Does that person get banned from PHP Internals and then think "Man, I better cool it with the stalking stuff!"
That's extremely interesting! Thanks for the in-depth explanation.
I believe you're correct. Thanks for the link :)
The git repo does not contain a generated bison parser (unlike the source release). May that be the source of your build error?
Did you `./buildconf`before running configure? The tarballs include a bunch of pregenerated files, but you'll need to generate them yourself from Git (you'll also need re2c and bison).
I'm glad you liked it. Here's a side-note on why `-0.0` (and also `+-0.0` even when the former was fixed) behaved wrong in PHP. We were rewriting unary minus to `0 - ` and unary plus to `0 +`. However, it turns out that `+0 - -0` in IEEE 754 evaluates to `+0`, and similarly `+0 + -0` also evaluates to `+0`. This was fixed by rewriting unary minus to `-1 *` and unary plus to `1 *`. Very, very slightly slower, but produces the right result.
Thanks for sharing your perspective.
The [IUS EL6/EL7 packages for this release](https://github.com/iuscommunity-pkg/php70u/releases/tag/7.0.2-1.ius) are complete and will move to the [testing repositories](https://ius.io/Usage/#using-testing-repositories) during tonight's automation.
make -j4 seems to have done the trick, was not aware of that. Thank you
Ah, the `-j4` part is just parallelization, that part *shouldn't* have done the trick ...
&gt; It also helps with division by zero, because for 1 / 0, how do you know if you get positive or negative infinity if zero is unsigned? Division by zero is not a meaningful operation, inside or outside PHP. It is not the same as plus or minus infinity. 1 / 0 doesn't exist and you should not program like it does. Neither, before you bring it up, should the folks who design programming languages and calculators.
This isn't really a repository, as you've got no interfaces to create reusable contracts to a abstract/hide the data source, nor are the models decoupled from your DBMS make your eloquent leak and possible for other developers to interact with your DB directly. Purpose of repository is to be able to interchange your repository class transparently without your domain having any awareness of where the model was derived.
I was against type hints because without generics type hinting is stupid, basically there is no concept of types of higher kinds in PHP... but its 2016.. so you are limited to types of arity `*` where as `* -&gt; *` goes unsupported and creating wrapper types like a `List a`, `Vector a`, `Option a`, `Array a`, or `Dictionary a b` are useless in this system.. so why even bother at all with such a crippled system... I think PHP should focus on getting succinct lambda expressions instead the current lambda expressions are really terrible.
&gt; By restricting the CoC to project channels, we allow project members to engage in violent intimidation towards other project members without recourse. 1. Explain exactly how policing everything a member does whether it related to PHP or not is even remotely ethical? 2. Explain how not policing everything a member does whether it related to PHP or not turns that member into a violent abuser? &gt; It just seems like it extends the same protections to outright harassment and threats of physical harm. Please cite the relevant section that seems like it does this. &gt;Having an official code of conduct stating internals will turn a blind eye to any rape threats as long as they aren't on the internals mailing list sounds worse that not having a CoC at all. Please cite the relevant section that states this. 
I would imagine that `Chargify::customer()` is a Customer factory and the reference bit thereafter is to set and load the particular customer. It does look strange though.
You need to be able to correctly detect and handle situations when it occurs, even if it's not meaningful.
Honestly, the main reason I'm proposing this is what's in the second paragraph. I've been bitten by PHP using `.` and JS using `+` more than once.
Renaming the file upon save is smart, just for the chance of making programmatic access/use easier. ...maybe check mime type and look into 'sharding' Sharding, you may need to create a number of sub directories to ensure you don't end up with this system bogging directory with a billion images in it. I create PATH/year/month/epoch.ext path/file structure usually. You can set default file mode settings (I like 440 for read only on file, and 551 on directories). Saving the data of the uploaded file to a brand new image file not only adds a layer of protection, but it also helps reduce innocent edge case scenarios where the image is incompatible with your tools. Fun fact: you can create visually useless images that are actually encoded data packets that get around Content Security Policies as a similar AJAX payload would be rejected... Just because it is a technically valid image doesn't mean it can't have other purposes-- not even necessarily malicious. Just think of it as using a brick to pound in a nail, just another way of getting a job done if need be.
Well, it seems it will be done :D
IMHO the issue is that Linux devs don't pay attention to PHP. To anyone not working in the language PHP is some sort of anomaly. Distro maintainers have no qualms updating to latest versions of Perl, Python...
Having generics in PHP would be more than awesome. I wish this gets more attention!
[removed]
 $pass = mktime() % 2 ? 'apple' : 'banana'; There are some minor issues, but it has the bonus of making it only two guesses for people who lose their password, cutting down on help desk workload.
"non well formed"? Do you mean poorly formed? Cripes.
It should report an error. 
I'm with you in the sentiment that this sounds awkward, but other languages use "not well-formed" number errors, so I guess its a thing. To a native English speaker, that hyphen really makes a big difference. But calling it poorly formed is not the same as saying "not well-formed". You can't just put spaces after your "pre fixes" (typo intentional). Bla bla bla, english grammar, but there is something called coordinate adjectives and cumulative adjectives which you can chain adjectives to the noun. In this case, "well" does not stand as an adjectives to the noun "number", but rather a modifier to the adjective "formed" itself; thus we need the hyphen. For this reason we use the word not, and change the sentence structure because using "non" is less right due to avoiding chaining adjectives. also, i'm not a grammar Nazi, just wish to untangle this mess into a logical statement, so we can correctly state something before the RFC accepts.
I'm inclined to agree here - if I had to choose one, it would be typed arrays, hands down. Trying to make them with generics is...messy, and I don't look forward to seeing what would happen in the real world if we got generics before simple typed arrays. Tons of `Arr` classes, I'll bet. 
I have this mental image of you picketing outside PHP conferences holding a poorly-authored "God Hates PHP" sign.
7.0.0 shipped with multiple segfault issues. 7.0.1 fixed three of them: - https://bugs.php.net/bug.php?id=70970 - https://bugs.php.net/bug.php?id=70987 - https://bugs.php.net/bug.php?id=70977 7.0.2 fixed three more: - https://bugs.php.net/bug.php?id=71163 - https://bugs.php.net/bug.php?id=71092 - https://bugs.php.net/bug.php?id=71066 So yeah, I agree, distro maintainers do have a different definition of "stable". My intention isn't to beat up on the PHP developers; at some point you have to declare software stable to get it out there to get more exposure. But you have to understand that when Red Hat and Canonical select versions of software for their long term distros, they are committing to supporting it with security fixes for the *lifetime of the distro*. That means *5 years* for Ubuntu LTS and *10 years* for RHEL. The short support cycle of PHP doesn't line up with that very well, which is why Red Hat and Canonical pay lots of engineers lots of money to backport security fixes.
Again, thanks for the info! I'm learning more than I should be ;) Good to see it's fixed!
Absolutely, but that doesn't mean they do. (Why the pseudo-PHP?)
&gt; Python is having a comeback - it's the new hipster, the next Ruby, the next antiquated dynamic language getting dusted off for a short, pointless renaissance. Cut it out with this shit. Python is on an upswing not because of some secret hipster convention, but because there was a recent change in technology that is actually very well-suited to what Python has to offer: The [Raspberry Pi](https://en.wikipedia.org/wiki/Raspberry_Pi), for instance. Python is actually still very relevant as a language, just maybe not so much in the webspace anymore. That doesn't make it antiquated, it just means the applications it's best-suited towards has changed, much in the same way that Java moved away from web and towards Android application development.
Thanks for putting brief detail about my question. I already started reading evans domain driven design book and have read half of it, but i always think application is single unit where all web and domain part relies. So in case of web i was always getting confused that how can i separate application from web but your answer have very much concrete detail and provide good hint to start with commands.
Agreed. We don't need full blown generics. Just a way to define that this array is a list of `Foo`, or integers, etc.
"malformed" is a step in the right direction. I think it too strong. Akin to calling something "Not Perfect" "Flawed". Take for example $number = "1.0e3 apples" + 1000; echo($number); //2000 The number isn't malformed, or poorly formed, its formed in an adequate manner though type conversion and truncation at the first character not fitting in the scientific notion. But it could be formed more cleanly (without truncation of the text) so I can see why we call it "Not well-formed". tldr; change the non to not, and hyphenate
https://twitter.com/dshafik/status/685190123475046400
[**@dshafik**](https://twitter.com/dshafik/) &gt; [2016-01-07 20:03 UTC](https://twitter.com/dshafik/status/685190123475046400) &gt; Yay, the next Ubuntu LTS (16.04) will include PHP 7: https://launchpad.net/ubuntu/+source/php7.0 ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Please don't start making personal attacks based on divisive political lines. You've neither an indication that /u/G-_-D is associated with brigading behaviour, nor that they're here specifically to spread political rhetoric. Both of these accusations are serious, and you best have some evidence of this if you're going to lay them down here.
&gt; I compare a PHP certificate to other certificates like for languages (e.g. the Cambridge English certificates). I think it's much more reputable to show certificates supporting your knowledge about certain things instead of just saying "I can speak PHP well" If you show me your Cambridge English certificates, I have an educational institution's review of your English language capabilities and therefore I can with great probability assume that you know how to speak and write english. The level your education tells me what to expect of that specific skill. Showing me your certificate in your PHP knowledge shows me that you know PHP and the coverage of the certificate tests. But you'd might still be a crappy developer and not fit within the organisation if you don't have the experience or mindset that is expected or required. "Development" covers two things; the work with programming or scripting languages - and then developing. Developing is tough to measure - are you a good developer because you can remember all PHP functions available? No. But then I know you have a good memory - nothing else. I want to see that you are able to develop solutions to problems - not answer quiz tests. &gt; So instead of just saying that I've been active in web developing over the past years I could support this by showing the certificate. In my opinion, you're not supporting any claim of experience by flashing a quiz test result. Show me you can solve problems and I'll show you to your new desk. It's as simple as that.
I'm not sure if I'd classify it as a *personal attack*, but it is absolutely an accusation of misdeeds. Go head over to the main CoC thread and look at all the profiles of the posts that have large upvote counts. A few are **KiA moderators**. A bunch more have never posted in /r/PHP before, and have posted in KiA and related subs. A few have had not just no interaction with /r/PHP, but no interaction with any programming sub. The bizarre upvote and downvote patterns unlike I've seen in *years* in this sub, the sudden appearance of accounts that have never given a crap about anything in /r/PHP before, and the talking points continuously spouted are too much. It's a KiA brigade. I find it *funny* that this person chose to participate on this new account only starting with the CoC thread and *happens* to use the *same exact* talking points as the KiA people use. That's too coincidental with the established brigade to be anything but participation in it. I will trust that you will set aside any possible personal bias that might be sneaking in on the edges when reviewing this issue.
I do not feel you are being unfair, but I will not remove the accusation from my posts on a matter of principal. You may delete my posts if you feel that is the correct choice, and I will take no offense. I urge the moderator team to keep the sub updated on the brigade matter, but I don't think I've ever seen the admins respond to brigading before, so I'm not gonna keep my hopes up.
&gt; This is not good spanish, it looks like google translated english article. Soy de Argentina, mi idioma natural es español // I'm from Argentina my natural language is Spanish I made that article because im doing Spanish tutorials.
Whew! It's a good thing PHP7 was released before all this CoC bike shedding came along. Am I right white heterosexual guys or am I right? 
What is KiA?
Personally, since docker, I would care more about that than PHP, but if it can be in official repo's, I don't see that ubuntu offers anything substantive in PHP.
&gt; What if banning them from PHP related projects makes the physically violent against members of internals. Then it becomes a case for the police, and that person will likely be locked up
I usually inject paths like any other dependency. In my case the path is usually coming from a configuration file, so I inject it in the container binding. It makes the path dependency explicit, so you know the class needs it without reading all the code. 
Oh my god, I did everything wrong! There is tons of MIT open source upgrading tooling for free for CakePHP now. I could have just milked all the lost souls that have outdated apps on older API framework versions as well :P Refs https://github.com/cakephp/upgrade &amp; https://github.com/dereuromark/cakephp-upgrade etc
Big upvote from me for Matt Zandstra's book. It really took me from mid-level PHP, where I knew lots of syntax but tended to produce spaghetti code, to thinking about building proper software.
It's not stupid, as it's very useful as it is. Of course, you could add more options which might make it even better, but it's already very useful - and I'm especially happy with PHP7's scalar type hinting.
I can't say I support this idea. It makes things unnecessarily complicated because now I have to know about this class and its friends.
Love it. Well done.
It just a package to connect with Stormpath, an authentication SAAS company. If you don't use it it's probably useless.
Apps that are old and regularly add to add invalid numeric strings together also tend to already have error suppression on :P
(I think reddit removes the $ sign from code in comments)
A rape threat is a matter for law enforcement and not a group of untrained volunteers.
Exactly my point. I think strictly typed arrays would be a much better way to solve this problem than having full-blown generics in a dynamically typed language!
Try: PHP Beyond the web https://leanpub.com/php
This is a great article on why collection classes are a very good idea http://www.sitepoint.com/collection-classes-in-php/
How does an application's statefulness impact generics? Why are Java's generics "awesome" but wouldn't those same concept be useless in PHP?
Generics are not only about type-hinting, but also about template programming. There are also more examples than just collections, but collections seem to be the most obvious :) Consider that your typed collection would also contain a method, which then you could apply to elements of different types: class MyCollection&lt;T&gt; { private $elements; public function doSomething() { foreach ($this-&gt;elements as $element) { $element-&gt;doSomething(); } } Speaking of which, it'd be nice to also have something like [type constraints](https://docs.oracle.com/javase/tutorial/java/generics/bounded.html) to restrict a generic class to type parameters, implementing a certain interface or extending a certain class: class MyCollection&lt;T implements Countable&gt; { private $elements; public function getTotalCount() { return array_reduce($this-&gt;elements, function ($sum, $element) { return $sum + count($element); }); } } Without generics you'd have to create different collection classes for different element types (although the common method could be extracted into a Trait), if you want to use type hints and type suggestions by your IDE. Of course, we can still use the old "don't care about types" approach, but that's not only less error-prone, but also considerably less effective to read and to write using modern IDEs.
IMO, the article fails to describe why/how collections are a better approach. The complaints as presented are: 1. We’ve broken encapsulation – the array is exposed as a public member variable. 2. There is ambiguity in indexing and how to traverse the array to find a specific item. 3. ... This means that even if we want to print just the customer’s name, we must fetch all of the item information **Encapsulation**: The encapsulation is broken because the author chose to break it. A good way to implement this would be: class Customer{ protected $items = array(); public function getItems(){ return $this-&gt;items } } $c = new Customer(); foreach($c-&gt;getItems() as $item) {...} **CC**: You will always have an O(N) complexity unless your data-set is indexed and inserted/sorted in the right order which has nothing to do with it being a collection or an array. **Load**: Once again, collection or array, it all depends on how you chose to implement these things. A collection wouldn't change when/where the data is loaded. This is an implementation question and has nothing to do with collections. Lazy instantiation work on arrays just the same way it does on objects. I personally think that collections are a great thing to have. But we can have them within the existing array context instead of within the context of generics. It would be great if we could do something along the lines of: ```protected $items = Item[]``` which is essentially an array with a strict object type ```Item```. It basically is the same thing as generics but requires much less effort to implement and abstract
Before I hire you I need to know... Are you for or against the CoC?
Yeah totally. Repository should be like $userRepository-&gt;save($userModel); and also $userModel should be "dumb" (just a "data holder") In short form: You will regret it later if you implement it like the tutorial shows.
[**@atoum_org**](https://twitter.com/atoum_org): &gt;[2016-01-08 13:19:11 UTC](https://twitter.com/atoum_org/status/685450680279150592) &gt;atoum 2.5.0 released: [*atoum.org*](http://atoum.org/release/2016/01/08/release-2-5-0.html) \(yes, on our beta website!\). Nice new features! &gt; &gt;Thanks [@jubianchi](https://twitter.com/jubianchi), @mnt\_io, [@Grummfy](https://twitter.com/Grummfy) &amp;amp; kao98! ---- [^[Mistake?]](/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/40123r%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
lol 
There is a link mentioned at the top: First Published at: http://wiki.php.net/rfc/remove_name_mangling Which is a 404.
I'm new here. What is CoC?
Something that helped me a lot in understanding how I could put this into practice is a series of blog posts by Mathias Noback: http://php-and-symfony.matthiasnoback.nl/2015/01/a-wave-of-command-buses/ This definitely doesn't cover the whole of hexagonal architecture, let alone DDD, but it's a very practical and easy to understand tutorial on how (and why) to get started with using a command bus. I found it more easy to get started on the whole hexagonal architecture thing and more easy to use DDD after reading theses blog posts and putting them into practice.
&gt; Should the PHP team's resource really be spent on something like this? There is no PHP team with a set amount of resources. The person working on it is a new contributor, and doing so of their own free will, so it's not taking away from other development. &gt; This adds so much complexity for so little in return, and is usable in so few use cases. Yeah......I'm trying, and failing, to find a way to say politely "ah hell no". It's nice that they want to make PHP better...but class friendship is definitely not something I miss from my C++ days. 
its Code of Conduct or maybe Clash of Clans :D
Start off with [PHP: The Right Way](http://www.phptherightway.com/).
I believe the author of the RFC changed the name of the RFC while writing it :). Anyway that's a good move if this RFC passes as I hope it will also affect how `parse_str` and eventually `filter_input` work on variables mangling. 
doing it in PHP7.1 will be a major BC break. this is a first step into the right direction.
Just finished a raid..
You could play around with the Symfony console component. http://symfony.com/doc/current/components/console/introduction.html
Yeah, I understand your points, but Just looking at the 16.04 d/l I have (the main benefit for me right now is it works with less bugs on baytrail tablets); they have nothing I wouldn't rather get from the official github of the creator is all I'm saying. I trust the makers of the software tonnes more than the distro's that bundle them, and think distro makers can accidentally hurt PHP (as well as other software) with older versions of the PHP runtime, and associated SW, their take on webserver X, can be a particular bug-bear; but this is why I prefer docker, I am in charge of what I need, and the base can be extremely lean. Also helps that you can mix and match setups, in a much more component driven fashion.
&gt;The person working on it is a new contributor, and doing so of their own free will, so it's not taking away from other development. True, but I've heard the "we dont have enough dev resources for this" line many times. So maybe he could pitch in on other parts, where needed. Adding this will not only add complexity to userland PHP, but also php-src, and this complexity will spread wider than this feature alone, effectively adding more work in general 
still not relevant. e.g.: you could make a generic CRUD controller for your crud layer. your storage engine could make use of generic Repository classes, .... etc. How long the request lives is totally not relevant.
&gt; True, but I've heard the "we dont have enough dev resources for this" line many times. When you hear that, translate it into "No one wants to work on it", which is also a problem that could be solved, but a subtly different one.
+1
Yeah we really shouldn't be saying things like this. He contributed because there was an itch he had and he wanted to scratch it. We shouldn't feel entitled to his time now, and make "suggestions" about how he can more valuably spend it. Just my two cents
&gt;There's nothing wrong with respectfully expressing "ah hell no"! Direct and honest feedback is very valuable and will be respected are you sure? :D the Code of Conduct discussion is running pretty wild :P 
I was bitten by this issue recently, so it certainly should be fixed. However, I don't really understand the deprecation process being employed here. Shouldn't we instead have an *un*mangle function added in 7.1, so that if users are relying on this behaviour, they can correct it? That would minimise the BC break in 8.0. Also, "mangle" seems like unnecessarily negative verbiage to me. Having to call `(un)mangle_superglobals` is berating the programmer for not doing something the correct way.
Nonetheless embarrassing that they claimed PHP 7 support while they had that huge bug.
Ok so do it for PHP8, and release PHP 8 after PHP 7 without a 7.1 in the middle. :P... just joking.... BC break seems better than being surprised by this behavior... sorry if i'm eager to have a better PHP
How do you uncomment an HTML block with PHPStorm when editing twig template files? Currently it just ads the twig comment block or attempts to uncomment the one added :/
Hi, thanks for the feedback. Do you mean, that the URLs are too long to compare them directly and therefore you can't really see what the methods do? 
To unmangle it you'd have to manipulate the query string after the superglobals were populated. It would mean a small loss of performance, and would seem weird. While mangling it on 8.0 makes sense since you're relying on deprecated behavior so weird things are expected. The normal way should not be weird. 
Hi, thanks for all the +1! :) That's nice feedback In my first draft I was using variables for each option. But I then saved it into an array so I could iterate over it more easily. If I would've used variables I would have to check all of them if they are set, wouldn't I? What benefits would I have from saving each option into a variable? 
When I was watching Anthony Ferra's php[world] keynote he said, among other things, that PHP can be anything to anyone. If you want to do OOP programming you can. If you want to do procedural programming you can. If you want to use goto you can and implementing class friendship is in that same vein I think. If you don't like it don't use it. But if you want to use it... feel free. Just as is the case with goto. I support this RFC.
Well, I personally don't really like the idea as it kinda adds another way to create implicit dependencies. With a decent IDE it's trivial to add the necessary getters and setters. It might be useful to some people though, so I think go for it. Another thing is (in my opinion), that the term 'friendship classes' doesn't really sound very OOP. You might want to think about another term like 'accessor classes', 'scope classes' or 'linked classes', something that describes more what it does. 
I was thinking about this, but the problem is if you would like to call next before modifying something it will not work for you :)
yea sure but it would be cool to have that interaction. I mean things are fine without it. But just saying... :P
The basics being variables, control structures, and more which I'm sure your already know.
What? No new splash screen?
Not in PHP, but this helped a lot: http://hyperpolyglot.org/scripting It's actually remarkably similar to Python and Bash.
I agree about the use of the word "pruning". I think truncating would be a more accurate description.
Exactly. It would be easier if the URL was a lot shorter - perhaps a different URL for each example so you only focus on the specific use of that function. The documentation can use the longer URLs, but it would be helpful if the 'elevator pitch' sacrificed some detail in favour of clarity.
You, learn Ruby on Rails. RoR companies are more open mind than those PHP dinosaurs.
My issue is that the current proposal is **not forward-compatible**. In other words, there is no way to have `?a.b=dot` work on both 7.x and 8.0. You have to first upgrade and break your site/app, *then* add the `mangle_superglobals` function, which may not be a simple job if you need to add it to many files. One solution is to add `mangle_superglobals` to 7.x, then people relying on the behaviour can add that (where it would do nothing). The other is to add `unmangle_superglobals` like I said, so developers can implement "correct" behaviour in 7.x. Then they can simply remove that in 8.0. I actually think an INI setting *would* be a better option here. Have `mangle_names=1` the default in 7.1 and switch to off-by-default in 7.2 or a later version. Then remove it in 8.0. Now developers can update their code and turn it off manually 7.x, allowing an easy upgrade.
Coming from other languages Im allready used to see generics in &lt;&gt; brackets, and im used to seeing [] in php in connection with arrays. The meaning is imediately clear to me. What would be the problems for parsing?
From the [RFC](https://wiki.php.net/rfc/adopt-code-of-conduct) &gt;Examples of unacceptable behavior by participants include: &gt; &gt;Trolling or insulting/derogatory comments This is why I'm using a alternate account. If you don't like the truth, that is your concern not mine. I'm not a troll, I just disagree with you. This is one of many problems with the code of conduct. What would have happened if we had to abide by it, would my account have been banned thus protecting you from opinions you disagree with. 
I recall him pointing out that people cause severe performance problems with the way these frameworks are implemented and as such people who are interested in performance should avoid them. But I don't ever recall him saying frameworks are bad and you shouldn't use them. Can you link me to a resource?
I see, valid point.
It's indexing project files... seems to be common with any java based IDE. I only experience this on the first open/run of any project.
If only they fixed it so the software could update inline instead of downloading and overwriting the app in the Applications folder (osx).
Unfortunately this still doesn't solve the issue where it doesn't auto-complete ReactJS components imported ES6 style: https://blog.jetbrains.com/webstorm/2015/10/working-with-reactjs-in-webstorm-coding-assistance/#comment-247710 Although this is not PHP related.
&gt; I've been bitten by PHP using . and JS using + more than once. Happened to me a lot. I started using sprintf in PHP and String.format in Java whenever I needed to fuck around with strings. Sure it's verbose but it makes things a bit more clear.
Here's hoping "199USD" becomes a meme
The rfc proposes a mangle function that checks PHP version, your code would work on both 7.x and 8.x, you just would be using old behavior. The way you are saying i would have to check if the ini option is set before anything, it's not nice to be forced to do it, how many ini settings do you want to check? Short tags, open basedir, what else? Let's add millions of them...not
Hi maiorano84! Thank you for the great feedback! So a few things to note, We do understand that the built in Laravel Authentication is a great tool. The things with this to keep in mind is that it uses your own database still. Using Stormpath to handle your authentication allows you to prevent this and take the responsibility of the users security from you. We strive to make this a very simple process to install and set up. The only thing you have to do after requiring it in your project is gathering your API keys and application href. There is no configuration inside of the Stormpath UI that has to be done to get this working. As for the "web.register.form.fields" this can seem a little crazy at first why it is not in your view. The reason it is here is so you can easily turn off and on fields as you choose. In the future, you will also be able to include your own items in this list and have them automatically save as custom data for your accounts. We do use laravel's built in validation factory for fields listed in this. One of the nice things as well, you can use your own view if you choose. Let the configuration know which view to use and it will pull that in instead of the default one. I hope this answers your questions here and again, we appreciate your feedback!
 $urlPruner-&gt;anythingAfter('notfound')-&gt;prune('https://www.reddit.com/r/PHP/comments/4016ew'); returns "https://" expected "https://www.reddit.com/r/PHP/comments/4016ew"
Indeed, naming is important! Friend class sounds too Bob Rossy for me, but that might be personal. I didn't know about the c++ implementation. :) keep up the good work. 
 $urlPruner-&gt;regex('#anchor')-&gt;prune('http://hostname/something.html#anchor-5') returns PHP Warning: preg_replace(): Unknown modifier 'a' expected "http://hostname/something.html-5"
"Truncating" implies cutting off one end, but that's not what the library does.
You should add issues to the repo instead of posting them in here.
* "There's nothing wrong with having a tree as a friend." * "You too can do almighty object modeling." :) Have a good one /u/Hansaplast
Congratulations, this is possibly the worst video tutorial I've ever seen, and I've seen some bad ones.
A good UI would indicate that it was engaging in a processor heavy task, rather than leaving me to think the program is not cut out for the task.
My unspoken point was to show how someone can write all the classes with verbose comments and unit tests that they want, wrap it up pretty as a composer package, and still find 4 ways to screw up a glorified substring library.
[Release notes here](https://confluence.jetbrains.com/display/PhpStorm/PhpStorm+10.0.3+Release+Notes).
this is true, but what if you want to understand the under workings of an ORM. and ORM doesn't add any moire complexity then you make it add. Something for this would have been like active record. Much lighter in foot print then doctrine.
Why not just say that? Seems a lot better then being passive aggressive and spamming the thread. My point still stands, go add these comments to Github so /u/tzfrs can fix it.
You have some syntax errors in your JSON. Assuming you fix those, you would just need to do: $data = json_decode($yourJsonString); echo count($data-&gt;checks);
I'm entirely unsurprised by their response, but thank you anyway. I may followup again through mod mail.
I dunno, it's just really too much. If you're legitimate, I urge you to drop the sockpuppet account and post on your main, without copying the talking points from the KiA crowd. There are constructive ways to express your worries that won't get you labeled as a jerk. If you *are* from KiA, I hope that you realize that communication style alone pushed away a lot of people that might otherwise have been sympathetic to those concerns, and helped to create the toxic environment that you imply prevents you from posting on your main to begin with.
Preach it, brother, before the American Feminist movement wipes out the entire country. Actually, maybe that wouldn't be such a bad thing.
I'm so tired of complaints about paying for the best IDE out there. Submit feedback or something to them, not Reddit.
But you don't really need to rely on string concatenation in ether language either. Use interpolation in es6. In PHP use interpolation or one of the *printf methods. 
Hmm OK, maybe i'm misunderstanding the mangle function. Is that not provided by PHP? The RFC says (under "Proposal") that function would be added in version 8. But like I said it needs to be added to version 7.x code.
similar with /u/TheReverend403 said, just fork the library and backport their update if it necessary, and just define repository path in your composer.json to replace the original repo "repositories" : [ { "type" : "vcs", "url" : "https://github.com/yourname/your-forked-lib" } ] 
Is that a purely US thing? I mean, all that nonsense about "feeling safe" to participate in the project? WTF is this shit. I'm out of the loop here. Were there examples of "hostility" on the PHP mailing list? I don't think real devs care. Stop wasting their time. If you "feel unsafe" please seek professional help.
How about I atone with [issues](https://github.com/tzfrs/URLPruner/issues/created_by/erorus) and [PRs to fix them](https://github.com/tzfrs/URLPruner/pulls?utf8=✓&amp;q=author%3Aerorus)?
I also support the CoC. But! I'm allowed to have complex opinions about it that can take into account conflicting points of view to reach a consensus. Just like gender, the CoC is not a binary issue. Finally, being rude and ~~argumentative~~ disrespectful is not violence. It is bad conduct. Smash binary thinking. 
How would this sound: * Coc applies within the PHP mailing list, comments on the manual, social media put out by the project itself * Coc applies outside the PHP project if and only if you are directly harassing someone in the PHP team This keeps it mostly limited to the PHP project spaces (which is perfectly fine as far as jurisdiction issues go) but closes the loophole that if someone wanted to be a dick they just go pester people on facebook instead. This should satisfy both sides assuming someone with better wording skills writes it.
That's not the point I'm trying to say. I'm saying that if I say I work for Foo Corp and then follow it with "Kill all the black people" FooCorp are right to discipline me. If I say I'm a contributor to php and do the same then PHP has the same right. 
The test I'd use is "Is this person a known contributor to PHP?". I'm not /u/ircmaxwell though and it's a bit too late for me here to think about it fully.
&gt; Yay for MIT license, I suppose it's my code now. Heck yeah it is. If you needed to use this on PHP &lt; 7 then others likely do to. Publish it on GitHub and packagist as a "compat" library and try to keep with the upstream changes. 
Unfortunately, people aren't wrong in worrying that speaking frankly and honestly might have career consequences for them. That's my chief concern with this CoC. It has a chilling effect on frank and honest discussion. One has to fear that what they say online will be used against them, if it's controversial or could be considered offensive.
i wouldn't recommend doing that for what sounds like a permanent fork. 
It's funny, I just read that quote out of context, and for a minute I assumed the person was afraid of being witch-hunted *for insufficient sensitivity* if they disagreed.
For future promotion, it may help to name or describe the utility in the subject-line. That it was made and that it might be useful to someone is often implicit :p
You clearly need to read up on what "free speech" means, at least per US law.
The only issue there is defining "harassment" (and/or "abuse"). Do you think there's common agreement on even semi-objective measures there? I'll go further, and note that "harassment" and "abuse" have remedies under law, such as restraining orders, that can be applied, and do not necessarily require the project to be the primary enforcer (the project can of course take action as the result of a restraining order).
[**@drupliconissad**](https://twitter.com/drupliconissad/) &gt; [2016-01-08 15:53 UTC](https://twitter.com/drupliconissad/status/685489458934841344) &gt; @dshafik @ircmaxell Anyone who votes against this deserves to be shamed and hounded out of the community ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Not a great example, check out their other tweets. They're a troll, in the most base of senses, just trying to stir up shit.
Yeah, I actually do that and create permanent fork or sometimes private fork for unmaintained package or need to add feature to the package that unique to my case as long as the license allowed me to do so
Thinking like this is why no one uses Python 3, 8 years after release.
1. Extend the class with the feature I need and use that 2. Create a wrapper that implements the missing feature 3. Fork
You're the one who was accusing me and your still doing it, because you disagree with my opinion. There's the KIA group you don't like, I'm assuming they are generally considered bad, that's why you are trying your hardest to link me with them, because that means I'm bad and invalidates my opinion and protects your feelings. But if I completely change my opinion to one one you agree with, everything will be fine, right? Well, people have different opinions. You need to learn to accept that and to stop being so close minded. You don't like what im writing, so you turn the conversation towards me with the continued accusations, which is interesting considering what we're discussing. I learned alot a lot about the matter the last couple of days. I'm positive that people who act like you do will abuse the CoC for silencing opinions they don't like. Thanks for solidifying my position. 
Yes, it will be, but what other choice is there? If you can still keep up-to-date with other changes from the source repo, there is still a chance this old feature could be pulled back in, if they repent. Another choice could be to rewrite just some of the key classes, if that is possible. With PSR-4 loading you can load your customised classes first, falling back to the main package for the remaining classes.
You can always extend and override. Usually. 
&gt;I am therefore baffled by a minority of very vocal members of the community rebelling against the core idea, and every bit of content in the draft proposal. Maybe they don't agree with it. I don't see what is bewildering about that. These people aren't you. &gt;Even if it were true that it would never have been useful for anyone, that is not a good reason to argue that we don't need it. It's not a good reason for it either. &gt;Much of the world has laws not too dissimilar from those rules proposed, laws governing public and online decency and conduct. We all must agree to them, we have no choice, we can't back out because we think our freedom of expression is being encroached upon, or because we don't trust governance or policing. We can't not participate in society and so avoid being subject to such law. How is a government giving us no choice relevant to this, in which we do have a choice? I assume your not comparing government control to what the CoC would put in place. . EDIT: This made me think of a earlier [comment](https://www.reddit.com/r/lolphp/comments/3zikur/grap_your_popcorns_for_a_bit_of_phpdrama_and/cymv154) by /u/the_alias_of_andrea &gt;The problem is that, well, a CoC would only apply to stuff under the PHP Group's control. People who don't touch internals can't be dealt with. Having it enforced everywhere is some peoples preference it seems. . &gt;Maybe, that would have been a better starting place than the one we had ... Would you slightly elaborate on when and the venue you're referring to here. &gt;So, the wording needs tweaking and the process needs rational discussion ... On both sides. &gt;All the while we should remember that there are 5 year old children that understand why this is a good idea in principle. Using children like this is not rational.
I think the issue is they worry about speech in general being used against PHP contributors, not specifically PHP related speech.
Another no-good dev of Php core dev gang. This guy once came all guns blazing to me because I talked back to another core developer regarding some issue. I have witnessed every one of the people in support of this behaving quite childishly (to put mildly) on different occassions. I mean, from my experience, these guys already act like a gang without something like this...
I'm a bit 50/50 on the issue. I agree with the principal of the Coc but the wording is a bit vague. I compare it to a method in a third party library. This method is not well documented, it's vague on what side effects will be produced, and you aren't sure what will be returned. You NEED the functionality this method provides in your application, excluding it is not an option. But surely you'd be hesitant to invoke it without considering alternatives. That being said, I take issue to this: &gt; Much of the world has laws not too dissimilar from those rules proposed, laws governing public and online decency and conduct. We all must agree to them, we have no choice, we can't back out because we think our freedom of expression is being encroached upon, or because we don't trust governance or policing. We can't not participate in society and so avoid being subject to such law. Governments telling you what you can/can't say on the Internet is NOT A GOOD THING. And if you feel the government has passed laws violating your rights, you should do nothing? Bullshit!
"Mediation" sounds fine. Of course, both parties have to agree when in "mediation". If they don't, "mediation" has no further remedy. Again, which is fine with me. But "mediation" is not what's being proposed. What the COC provides for is more "judicial." The only people who need to agree are the judiciary, and their remedy is final.
Yes, often you can. Sometimes it is not that simple. If the issue is in a class that is embedded deep in a package, and it instantiated by other classes inside that class, then it becomes difficult to just override it, since other classes are still looking at the old one. With more service locators and DI being used these days though, the overriding method is getting easier as you can swap over classes to customer classes in different ways.
Who gives a shit what Shakespeare did? The English language looks very little like it did then. I've seen multiple university professors mark down students for using they/them to refer to single persons. People didn't get pc passes in classes like English 201 and Philosophy of Science. If someone really wanted to refer to a single person in a genderless manner, then said person could have just reorganized his or her sentences... Which I did many times.
Because it doesn't make sense to. What use case is there to send a simple response like that? If for status codes you better off sending it as JSON which there is a JsonResponse. 
Can't tell if you're being sarcastic or not. For the record, that's not "democracy" that's "a mob."
Yes. For example: "You have a member who loudly advocates against gun control. I don't feel safe with someone who likes to keep guns for themselves. I'm kind of afraid to have conversations with someone like that. Who knows what they might do if I disagree with them. Is that really the kind of person you want on your team?"
Sarcasm. They put something to a vote but then say "oh if you vote against, we will exile you". So... it's not a choice.
It sounds like you actually want to include the "process file" and call the functions from the 'index file'. If you using a get or post to call the process file you'll need to serialize them into url paramaters and then parse the url parameters in the process file. process.php function addNumbers($a, $b) { echo $a + $b } index.php: include process.php addNumbers(1,2) 'outputs 3
I am going to attach and format the code, please hold on a few. I am going to leave two comments.
How can I help (no crypto knowledge)?
 &lt;?php if (!empty($_POST['name'])) { $name = $_POST['name']; echo $name; }else{ $name = 'unnamed'; } if (isset($_POST['cell-color'])) { $color = $_POST['cell-color']; }else{ $color = 'color-0'; } if (isset($_POST['is-circle'])) { $isCircle = $_POST['is-circle']; }else{ $isCircle = false; } // create the cell object class singleCell{ //set default values static public $cellCount = 0; private $cellID = 0; private $name = 'unnamed'; private $color = 'color-0'; private $isCircle = false; //constructor containes two values one string one boolean public function __construct($name, $color, $isCircle){ $this-&gt;name = $name; $this-&gt;color = $color; $this-&gt;isCircle = $isCircle; $this-&gt;cellID = singleCell::$cellCount; singleCell::$cellCount ++; } //accessors public function getID(){ echo $this-&gt;cellID; } public function getName(){ echo $this-&gt;name; } public function getColor(){ echo $this-&gt;color; } public function getIsCircle(){ echo $this-&gt;isCircle; } //mutators public function setID($cellID){ $this-&gt;cellID = $cellID; } public function setName($name){ $this-&gt;name = $name; } public function setColor($color){ $this-&gt;color = $color; } public function setIsCircle($isCircle){ $this-&gt;isCircle = $isCircle; } } $cellArray[singleCell::$cellCount] = new singleCell($name, $color, $isCircle); $cellArray[singleCell::$cellCount] = new singleCell($name, $color, $isCircle); $cellArray[singleCell::$cellCount] = new singleCell($name, $color, $isCircle); $cellArray[singleCell::$cellCount] = new singleCell($name, $color, $isCircle); echo singleCell::$cellCount; $cellArray[3]-&gt;getID(); // header( 'Location:index.php' ) ; ?&gt;
Controllers need to return a HTTP response, and in Symfony a common response is a `Response` object. Returning just "HELLO" makes no sense in HTTP as you need to also return some metadata (headers). These could be defaulted / guesstimated (let's say, `HTTP 200 OK`, `Content-Type: text/html`), but having it be more explicit is a better choice as you need to decide upfront what the proper response is each and every time and not have this choice made for you (often without developers knowing there's a choice to be made to begin with).
So.. is anyone using this?
I am not sure what die does. I am going to have to look it up and implement it. Thank you. I am running xampp on a max if that matters or not IDK.
yes, otherwise there will no version 2.5
It is fairly prevalent in parts of the UK (mostly the academic community at the moment) though there is also a strong "brigading" effect outside that as well. Not sure where I stand on it tbh, on the one hand fundamentally saying "don't be an arsehole" isn't a bad sounding idea on the other things *do* get taken to extremes - like the whole dongle thing at that Python conference a few years ago which ended badly for everyone concerned. That said I self-select the parts of the communities I'm in towards the "not going to crucify you for a joke" side anyway - I don't get offended easily by what people say so I guess I should check my privilege or something. Who knows, I mostly want to talk about programming and related subjects, I'm not interested in desconstructing gender types in post-modern third wave feminist ideology or anything. My favorite wtf is still https://github.com/django/django/pull/2692 they replaced Master/Slave (which have specific meanings in computing) with Leader/Follower to the bafflement of a whole bunch of users.
It should be noted that you can also just return `new Response("hello")`, your example is unnecessary long for this simple use case. There are also ways to hook into controller events if you want to turn strings into Response objects. That's how template actions allow you to return just a data array, for instance.
There's the "don't be an asshole" side and then the side I don't like which is the public lynch mobbing and doxxing of people they don't like or feel offended by. It's a very very dangerous situation, but some groups think that's "okay" to do to someone.
/r/phphelp is &lt;-- that way. Jesus.
I am the same. Let's just write code. Actually I think 98% of us feel that way, but the minority is very vocal.
/u/pmjones asked me to respond to this on Twitter, so I will: I agree with him on this. It's why I limited the scope of outside activities to when you use your @php.net email address. Having said that, some people are inseparable from PHP, if Rasmus, for example, were to suddenly do something reprehensible, no matter the context, that would reflect on the project. We do not control outside perceptions, except through public actions that either prove or dispel them. Also, I see no issue with taking your outside conduct into consideration when applying the CoC. IIRC Paul, there was a conference where you were speaking where prior to the event another speaker threatened to kill you (maybe it wasn't you, not sure) — and they were banned from the event. Now in that case it was specifically involving the conference by saying that would be the venue for the action, but had they not said that, surely you would still agree their access to the event should be revoked... What this really means if that we do need to consider these incidents on a case by case basis, and reach consensus — while at the same time _ensuring the safety and privacy of **both** the accuser and the accused_.
Easier said than done in most cases. That core feature might have depended on a bunch of protected internal methods/functionality from its package that would require you to replicate a lot of its functionality to get access to. In many cases, it may be simpler just to fork and keep the feature contained within the package it was originally designed for.
If you're not a published expert on cryptography, you will do more harm than help.
not upgrade ... seems simple to me
&gt; IIRC Paul, there was a conference where you were speaking where prior to the event another speaker threatened to kill you (maybe it wasn't you, not sure) — and they were banned from the event. There was, she did, and she was. I also reported her to the police. Finally, I carry a weapon for self-defense (which should be no surprise to anyone here) because I hold myself primarily responsible for my own defense. If she had not been banned, I'd've been able to do something effective in response to any physical attack she wished to make. Further, I'll note "threats of killing at a particular location and time" have a different moral flavor than "I feel unsafe talking with someone on the Internet." &gt; I see no issue with taking your outside conduct into consideration when applying the CoC. Here's one problem: "I don't feel safe talking with someone who carries a gun. Guns are dangerous; who knows what a person like that might do if I disagree with them. Are you sure that's the kind of person you want in your project?" EDIT: FWIW I get that you have good intentions here, and I honor that. My position is that regardless of the good intent, the COC as presented will lead to bad ends, when those who intend "ill" use it for their own purposes later.
I'm sure you were a model citizen when this all happened too. 
This for sure. I'd say the majority of projects are hosted in a git repo, so forking and conditionally picking the authors fixes is the best bet
It's not his fault.
Which one are the modern PHP framework. 
Most OSS should, especially with the public source available in the fork.
I was speaking to you. This is /r/PHP, where we _discuss_ PHP, not /r/PHPhelp, where you _get help with PHP_.
starting a new project on packagist is easy enough, and marking it as abandoned is just as easy should the author decide to accept them later.
do you use Laravel?
The follow up RFC, if this passes, mentioned in the proposal section will probably address that.
Sorry, I should have put in an explicit sarcasm indicator. I thought the italics would have conveyed the tone there.
What steps do you think can be taken to mitigate the hypothetical abuse of the system like that?
&gt; It is at least indirectly (and I'll argue surreptitiously) about power over political enemies. Politics had (and still has) nothing to do with it. You brought it up, and you keep spewing it as a problem, yet nobody that's even remotely for a CoC has agreed with you that it's a political tool. The requirement for justification on why this will be a political tool is on you, and so far you have not backed up your claims to the slightest.
&gt; there is no list of "ciphers supported by mcrypt", because it silently choses what it will and won't support based on what version of OpenSSL it was compiled against I'm confused about what you possibly meant here.
&gt; A more serious response: If there is a cipher that exists in mcrypt or not openssl, then you should not use it. All I'm asking for is for this information to be available in the RFC. It's hard to do any sort of impact analysis if you don't even know which functionality is lost by removing this extension.
EDIT: Okay, the RFC has been updated.
I hope you're wrong ;)
&gt; nobody that's even remotely for a CoC has agreed with you that it's a political tool. And yet the majority of the anti-CoC feedback here (from /r/PHP regulars) keeps raising this as a hypothetical problem. Whether or not you think it is a problem, it's *perceived* as a problem. It's worth trying to address the perception directly.
&gt; Whether or not you think it is a problem, it's perceived as a problem. It's worth trying to address the perception directly. The problem is so far nobody has made the problem tangible enough to actually address. It's just a talking point "it will be a political tool". So far no hard evidence, nor even hypothetical evidence has been presented. Just "it will happen, because it always happens". It completely disregards the fact that there are voting provisions that if 50% of the project disagrees, they can remove a Conflict Resolution Team member. Heck, team members aren't appointed, they are elected by the entire project. If there was even a suspect that someone was being political, history has shown us that the PHP project would vote strongly. Yet the "it will become political" group continues to ignore that, and continues to parrot rhetoric. If they want to be constructive and talk about what provisions can be added that will "sooth" this potential issue, I'm all ears. I have been the entire time. But so far that's not what's been happening. So far the only "solution" I've seen is "Have no method of enforcement at all", which isn't on the table for me. Hence the frustration.
&gt; In short, one of the problems is that there is no list of "ciphers supported by mcrypt" http://php.net/manual/en/function.mcrypt-list-algorithms.php
...
This is probably more interesting to Laravel framework users, obviously, but the newsletter is a short (5min read), weekly look into undocumented features with occasional dips into the source code itself, so might be of interest to people who also like to study different MVC frameworks or see examples of php code "in the wild"
Then why did you say Jesus? It is not his fault.
&gt; I carry a weapon for self-defense (which should be no surprise to anyone here) because I hold myself primarily responsible for my own defense. If she had not been banned, I'd've been able to do something effective in response to any physical attack she wished to make. This is a very selfish point of view, yes, I have no doubt you can probably protect yourself, and yes, maybe you could be effective in protecting others if you're in the vicinity, but there are many others who would be put in danger — who likely wouldn't have the foresight to be wary — by saying "eh, I'll take care of it myself, that's all this needs". &gt; the COC as presented will lead to bad ends I absolutely agree that the CoC as presented (the Contributor Covenant) is _not_ a good CoC for the PHP community — I prefer to hope people wouldn't use it _cause_ abuse, but more that it wouldn't be effective; either way, it's not good enough. That doesn't mean we cannot come up with a better one. &gt; "I don't feel safe talking with someone who carries a gun. Guns are dangerous; who knows what a person like that might do if I disagree with them. Are you sure that's the kind of person you want in your project?" I don't feel safe around guns (due to my own ignorance, I plan to go to a range and familiarize myself with them at some point), but lets be _completely_ honest here, that's a false argument, it doesn't even come into play with the online aspect of the communities, and if it were to go offline that's a police matter. The point of a CoC is to help stop the stuff _between_ "decent person" and "illegal" that create an unwelcome, unfriendly, and less productive atmosphere.
&gt; It's not a good reason for it either. Just because you've never been burgled before, doesn't mean you leave your door unlocked at night. Just because no kids have been run over on this residential street, doesn't mean the speed limit should be 60mph.
Then the next version after 7.1 needs to be 8.0.
I'm cool with that. I rolled my own crypto library, so I'd never use PHP's.
You could use jekyll and import your static pages. Or you could create a subdomain (blog) and use jekyll to create blog entries and add links to your root web pages.
I really really like [Void.]( https://github.com/josephernest/void)
As much as I agree with the sentiment, if PHP is too bothered with backwards compatibility to even provide standardized function naming and parameterizing, they're not going to remove something deprecated with any kind of speed. Edit: Huh, I didn't expect downvotes for this. Not bashing the language here (I use it every day), just saying that backwards compatibility is too important to rush a major version with a sole intention of removing deprecated functionality.
You made a static site, but between a blog and "able to grab posts on other pages" you needed dynamic site, a simple CMS. As a temporary measure (that may actually work out for you for quite a while, maybe forever, depending on your needs) make a blog that you don't advertise on wordpress.com, and expose it's posts via a feed or other api, and on your static site put a bit of JS that yanks in the feed on the "blog" page and specific posts on the other pages.
The #1 compatibility issue will be that OpenSSL uses proper padding, vs mcrypt's NULL bytes. That wouldn't be too hard to shim, though I doubt you'd want to.
wordpress - just apply updates automatically via eg wp-cli, and only give it write access to wp-content/uploads (which you php_flag engine off in a .htaccess to stop code upload/execution from wordpress vulns). Make sure all other files are not owned by apache, and can't be modified by apache ... 
From the [internals announcement](http://news.php.net/php.internals/90445): &gt; Everyone is welcome to contribute, even if you're not a cryptography expert. Non-experts are the people I intend to be able to use it, so your feedback will be incredibly valuable.
It is possible... but with PHP you need some way to store data. Since PHP is designed to load, run and then exist, it doesn't normally preserve any information between sessions, so you need to store the chat information *somewhere*. Flat text files or JSON storage work. Those are just just regular files and not a proper database. Since you asked about other languages, node.js simply runs and all the chat information can be kept in-memory without any database or storage at all. The downside is that you lose that chat information when the program terminates. You can, of course, use the same techniques to save data with node too.
Back in the day -- 20+ years ago -- we'd do this by writing an HTML file. Top line for the HTML header and whatnot, one message per line, final line for closing the body. The header would include a meta refresh. When a new post was made, the script would open and lock the file for reading and writing (fopen `r+`), slurp the contents into an array, shift off the first line, pop off the end, then one more pop to nuke the last message, unshift the new message at the top, then rewind the file pointer to the top, truncate the file, write out a new header line, each message line, a new footer, and release the lock. It's brutal, it's horrible, the meta refresh causes white flashes other such fun, there are caching issues, there are file permission and ownership issues, there's no privacy, etc. But, it works. That said, if you're on shared hosting, check their terms of service. Again, back in the day, this was done and on the puny little shared hosting servers used at the time, it could cause performance issues. A huge majority of shared hosts put strict bans on *any* sort of live chat application in their terms of service, and they're often still there today. This isn't a problem if you're on a VPS or dedicated hardware.
my question is how volatile should be the message? if the answer is instant - you only need to open a connection between them (hi sockets!). Otherwise, choose where do you want to store it.
The idea is to have a server that a bunch of people can connect to. When this server receives a message from one of the people connected to it, the server sends that same message back to everyone else connected to it (broadcast). The connection needs to stay active for all connected clients and there needs to be two-way communication (full-duplex). Socket connections are usually used for this. Look for WebSocket tutorials out there if you want to try building something: https://en.wikipedia.org/wiki/WebSocket
well, you can always make one where the underlying data is a text file. in the most basic form, when somebody submits something, write a new line to the text file with a format like &lt;username&gt;: &lt;text&gt;
using ReactPHP you can build the backend to a socket service that keeps messages in memory in an array. then use socket.io or autobahn for javascript frontend to connect. 
NEXT! 
Agreed. Simple doesn't have to mean weak, just straightforward to use. It's perfectly possible to give someone easy tools to use encryption, while simultaneously providing an API that can be used for more complex designs if required.
&gt; And you should feel bad for choosing dangerous, less-well-studied cryptography primitives for your software. What's the weather like up there on that high horse? No one should feel bad about a software decision made in good faith at some unspecified point in the past. That's nonsense. We're all learning and improving every day. The only time to feel bad is if you realise something you've done in the past is dangerous and don't go back and fix it.
&gt; umm... well... Please don't write like you talk. It's a horrible practise. It reads very poorly.
You'll want to use websockets as mentioned here already. You can do the backend for this in php without a database (as long as you're only sending users messages made when they were connected, no "while you were away" messages). However you'll be using JavaScript on the client side (or you can make native apps in ios and android). You'll run a server script that'll manage the web socket connections and push messages around. Take a look at [ratchet](http://socketo.me). The library should help you get up and running and their documentation does a good job of explaining what web sockets are and how they work. Personally I'd pick node for this but with Ratchet you should be able to pull it off in php.
First, thanks for all the hard work, I didn't realize my own lack of knowledge in the area until I started reading what you posted. Regarding the proposal, I think following the example set forth by `password_hash` and having sane/safe default settings is a good thing - the developer may not want to worry or even know the difference between aes-256, salsa20, or threefish; they just want to implement a good encryption solution.
PHPFreechat is exactly this.
Also use variables more descriptive than "$a and $b". wamp &amp; notepad++ ???
That takes me back... http://www.ethereal-realms.org/
Come on. He don't need your opinion. He wants only hits from Reddit. It's just spam.
He aksed how it can't return, i see no return there
You could always use Firebase. Sure you could find a composer PHP Firebase chat package very easily. 
Better? public function helloAction() { return die("HELLO"); } ^/s
&gt; https://xkcd.com/1357/ Is calling people "asshole" via a comic strip a violation of the code of conduct as presented? Would we call that "demeaning" language, or a personal insult, or abusive? I look forward to your answer.
&gt; In a dynamically-typed environment generics don't make a lot of sense Yes, they do - and if you're documenting your code properly with php-doc, you're likely already describing your code in terms of generics. You've used php-doc type-hints like int[] or User[] right? You've used generics then. I think the strongest argument in favor of generics (any any dynamically-typed language) is that your code already has generic type relationships - you just don't have any way to declare them (except for arrays with php-doc) or check them. You likely have lots of other type-relationships in your code that can be described as generic - most codebases do. For example, PHP code is littered with php-doc blocks like these: @param $numbers int[] @return User[] These are generic (collection) types by any other name. In fact, the majority of type-relationships in PHP code in the wild can be described as generic type relationships. The problem is, you can only declare both the parameter and (in PHP 7) the return-type as array, which means the params and return-values are neither declared nor checked by the language. In other words, you get shallow type-checks only. And maybe with offline analysis tools, some deeper type-checking - but only statically, and only for arrays. At design-time, we can check these to some extent, using e.g. PHP Storm and (of late) tools like phan - but these perform static validations on the code only, there are no checks at run-time, which can easily lead to silent errors; code that works, but doesn't do what you were expecting it to do - the hardest type of bug to identify and fix. Because PHP is dynamic, type violations can easily occur, and can be hard to catch because actualt type-checks go only one level deep: arrays and other collection types, repository types, dependency injection contains, etc. typically only perform shallow type-checks, which leads to either bugs or endless unit-tests making assertions about return types, and redundant code at the top of every function to check input types using e.g. gettype() or instanceof etc. Generics in dynamic (or rather gradually-typed) languages like TypeScript and Dart, in my experience, are indispensable timesavers that help me write code that is safer, easier to write, easier to maintain, and more self-documenting without having to litter codebases with redundant doc-blocks. My position is, if we have to doc-block everything meticulously to be considered "a good PHP developer" - if we have to statically type-hint everything anyway, then let's expand PHP so that we can write "good PHP code" without having to go above the language. Doc-blocks should be for descriptions in english - it shouldn't have to be an extension of the programming language, one that isn't even understood by the programming language. When QA tools start to rely on doc-blocks as much as on the language itself for proper analysis, that tells me something is missing. IMO, PHP needs this feature worse than anything. 
It's not actually how I talk. It was a failed attempt at humor. You didn't deserve to be down-voted, but my questions were honest, and examples of why this stuff is hard. Are you going to answer them?
I love this going forward but holy crap the legacy stuff that is going to be hopelessly broken. I have a client with a complicated custom cart that uses mcrypt, and his host moved him to a new shared server (without telling him) and failed to replicate the existing package/extension environment (without telling him or me). "Can uh... can you guys add yada, bada, boom, bing... and uh... ^^^mcrypt ?" "What was that last one?" "cough cough ^^mcrypt" "One more time." "**MCRYPT**" "... are you serious? You're !#$@ing with me, right?"
&gt; The problem is so far nobody has made the problem tangible enough to actually address. One might say the same thing about the COC RFC itself.
Well, my point was that SOLID is more important than trying to cover all possible UX case scenarios in contradiction to Otwell's statement that UX &gt; SOLID.
Angle brackets because that's what most other mainstream languages use, including TypeScript and Dart, the only two gradually-typed languages I know of that support generics. Scala is less well-known. The aim was familiarity, and the concepts here are pretty close to how they work in Dart, TypeScript and C# etc. - I only know Scala superficially, so I can't say how similar the generic concepts are to it. (?) Angle brackets will figure in type expressions, which are used only in conjunction with the `new` and `instanceof` keywords, and in various declarations (implements/extends/use-clauses) so it shouldn't be ambiguous or impossible to parse. Also, PHP uses the angle brackets for short array literals and index operators, so I don't know why that would cause any less of a conflict? 
I get that, completely, but do you get the point I'm making? Having generics as a "compile-time" only feature (as per Hack) doesn't make any sense in a language that *isn't compiled*. A "compile-time" only feature, as in Hack, is inconsistent with the rest of the language - PHP is reflective and reified, so if we add generics, it has to be reflective and reified. PHP has enough inconsistencies.
Python is used a lot in the chemistry sphere, or so i was told.
At some point, you can generate a key. There will also be methods to persist them to disk or even export as a string (in a special serialized format with version/driver metadata), so you can have a long-term encryption key. Your example code is almost dead-on. Its usage *will* be that simple, and I intend to document it as well as I did [with libsodium](https://paragonie.com/book/pecl-libsodium).
You obviously haven't read my comments in the thread and have just latched on to this one. I think PHP should have a typechecker just like Hack does. That is where the biggest benefits come from as you are able to see type errors even before running your code, and you can see the type errors in less frequently run and tested code paths.
I imagine it's because SCRIPT_FILENAME is dynamic and dependant on the server configuration.
&gt; What about publicEncrypt() / privateDecrypt()? When I was at uni three different courses covered public key crypto. They never used the terms seal or unseal. * https://secure.php.net/openssl_seal * https://paragonie.com/book/pecl-libsodium/read/08-advanced.md#crypto-box-seal We're not truly encrypting with a public key. What we're doing is generating a disposable, one-time key pair, performing a key exchange (Elliptic Curve Diffie Hellman) with the recipient's public key, and then doing symmetric-key (authenticated) encryption and including our disposable public key in the message. Contrast that with RSA encryption, which limits your plaintext size, is slow, and [dangerous](http://framework.zend.com/security/advisory/ZF2015-10), but more like you learned in Uni.
I think the idea is to make it part of the core. By doing so it becomes the defacto way of handling encryption/decryption.
Even though this is not at all the right subreddit: you'll want to use shell scripts instead of batch scripts on Android, although you'll need a Terminal Emulator for that to work (it is shipped with CyanogenMod automatically).
[Have you looked at its codebase](https://github.com/josephernest/void/blob/master/index.php)? That's just its index file, and already it looks like one giant nope.
I have to chime in here: you ask for feedback and then simply ignore it. The naming of the functions is just not intuitive for anyone not very familiar with crypto. Also ``aeadEncrypt()`` and ``aeadDecrypt()`` are really bad names. Why is there a distinction of ``encrypt()`` and ``aeadEncrypt()``? I heard you calling "no unauthenticated crypto!". So why several modes? What does aead provide more? ``If encrypt()`` does not provide authentication, then rename ``aeadEncrypt()`` to ``encrypt()`` and ``encrypt()`` to ``encryptUnauthenticated()``. I also think the driver thing should be completely hidden from the user if this API should be dead simple. It does not matter to me if libsodium or openssl is used. The format should be the same and compatible regardless of the driver used to produce it. But nonetheless, thanks for working and pushing on this. I think trying to improve PHP if one is not a core inner circle developer is hard and (positive) feedback can be very sparse (especially on internals).
&gt; I have to chime in here: you ask for feedback and then simply ignore it. I didn't ignore it, I disagreed with it. I'm not doing this to cater to academics. &gt; The naming of the functions is just not intuitive for anyone not very familiar with crypto. Then I hope to establish a new vocabulary to go along with it: * `seal` means public key encryption where the sender can't open it * `asymmetric encryption` means public key encryption where the sender *can* open it That's far better than this klunky "encrypt with public key, encrypt with private key, encrypt with secret key" nonsense that OpenSSL allows. (`seal`, `sign`, and symmetric `encrypt` respectively) &gt; Also `aeadEncrypt()` and `aeadDecrypt()` are really bad names. Okay, what would you call an AEAD encryption method instead? The difference between `encrypt()` and `aeadEncrypt()` is the addition of additional data, not the authentication. All encryption must be authenticated encryption and that is not negotiable. But I'm open to better names for the AEAD modes. `encryptWithExtraPlaintext` perhaps? https://github.com/paragonie/php71_crypto/issues/3 - I opened this ticket to discuss the public API and naming. &gt; But nonetheless, thanks for working and pushing on this. I think trying to improve PHP if one is not a core inner circle developer is hard and (positive) feedback can be very sparse (especially on internals). Thanks. :)
Yeah, I have it implemented and I use it on a weekly basis. And I really like it. Why do you think it's a giant nope? 
It's also interesting that nobody mentions a PHP environment that already has generics: Phalanger. Coincidentally, it also doesn't use bare &lt;&gt; for type parameters, instead it uses &lt;: :&gt; construct. Probably because of the parsing issues you mention. Personally, I would like PHP drawing inspirations from a closer language, rather than looking at Scala, Dart and what not.
&gt; I forgot to include internals in one of my replies, but if this passes, I'll develop and maintain compatibility interfaces in other languages. Very cool (and ambitious). I'd suggest proposing the format as a broader (IETF?) RFC - it could lead to a lot more support, and good design feedback, from large companies as well. An open standard for encrypted data at rest (that doesn't begin `----- BEGIN PGP ENCRYPTED MESSAGE -----` ;) ) would be fantastic, even if not strictly necessary. Alternately, you might want to consider re-purposing something like JWT which, although a bit more verbose, already has some existing support in multiple programming languages. &gt; It depends what you want to do. &gt; ... Thanks - that makes more sense than the original example, which was just a "generate a key and toss it" type of thing. So, in practice, it's still standard public-key encryption, just without the trusted key database that e.g. GPG maintains? I imagine that, in practice, it would look more like this: // generate_keys.php $keypair = \Php\Crypto\KeyFactory::generateEncryptionKeyPair('openssl'); $secret = $keypair-&gt;getSecretKey(); // serialize and save this securely $public = $keypair-&gt;getPublicKey(); // distribute this // encrypt_message.php $fips = new \Php\Crypto\Asymmetric\Crypto(...); $pubkey = 'this was sent to me'; $msg = 'my secret for the sender'; $ciphertext = $fips-&gt;seal($msg, $pubkey); // decrypt_message.php $fips = new \Php\Crypto\Asymmetric\Crypto(...); $secret = 'I generated this earlier'; $cyphertext = 'something sent to me'; echo $fips-&gt;unseal($ciphertext, $secret); Which is not drastically different from the GPG extension, just *way* less clunky. Is this a reasonable assessment?
Yup! That's totally reasonable. :)
Let's start with the fact that error reporting is turned off immediately, regardless of whether or not you're in a development or production environment. Errors provide extremely valuable information, and should *not* be turned off in this fashion. Secondly, let's take a look at the fact that it's mixing business logic with all of its frontend logic. That's sloppy coding. Let's also consider the fact that the author has no code consistency. Looking at all of his if statements, he has some with opening and closing braces on one line, versus others on several. There are no separation of concerns here. There is no attempt at code organization. I'm sorry, but as petty as it sounds, that's kind of a dealbreaker for me. While I'm sure you're fine with using something built like this, I personally avoid using anything written so haphazardly.
I thought that they were since 5.5 or so, but maybe not. Still, like you said they try not to break anything besides edge cases. I don't think mcrypt fits that.
Yep, pretty sure that's why PHPStorm can't resolve it by default. My question is, how can I make it be resolved? Is there a setting somewhere? For example, a way to say "`SCRIPT_FILENAME` is always the full path to the file name" (which if I'm not mistaken is PHP's default behaviour). If `__FILE__`, which is also dynamic, can be resolved, why not `SCRIPT_FILENAME`?
So long as they're not implementing the underlying crypto algorithms what does it matter if they have a textbook level understanding or not? My knowledge of gzip as a format is pretty superficial but that doesn't mean I can't use the gzip CLI utility to compress and decompress files. As I said, so long as you're not implementing the underlying stuff I don't see how it matters if your knowledge is superficial. And, honestly, I always found the box analogy less intuitive than what it actually is. ie. symmetric ciphers suffer from the key exchange problem. How do you get the key from the sender to the receiver? Public key crypto solves it. You have a public key that anyone can see and a private key that only the recipient knows. You encrypt a message with the recipient's public key and then only they can decrypt it. How that works in practice is irrelevant. That RSA can be used to solve the key exchange problem is irrelevant and that RSA - as one of several solutions - uses modular exponentiation is irrelevant. You don't need to know that to get what public key crypto is and what it means and why you'd want to use it. That, in a real world RSA implementation, you'd use randomized padding and blinding is all irrelevant, since, if you're even considering using the API you've proposed, you're not implementing the underlying cryptographic primitives, anyway.
&gt; Except it does prevent some burglaries, just like a CoC will prevent some or most abuse. A locked door is a solid object impeding you from entering but not stopping you. A CoC is just words that no one ever has to see and doesn't impede abuse in any way. Abuse is already deemed illegal in written law yet it hasn't been prevented, or even hindered. Just because you feel like it will do something doesn't mean it will. &gt;Of course there is no silver bullet, that's impossible. I agree, but we shouldn't just accept anything. &gt;But having a clear policy on conduct can only be a good thing. The proposed policy is not clear, it is purposely vague. 
Hello, I have been working with a lot PHP stuff that was not made for the web, like daemons and services and sometimes wrote some async HTTP servers using of shell components which have been working without a single failure for a really long time. All this stuff made me think that PHP is not anymore only Web-oriented programming language. I think core developers of PHP should take on this then improving the engine that PHP could not only be single request living thing but long time running process too.
My another question would be about PHP Web Servers. Last week I was working on custom SAPI for embedding PHP into C++ application and I looked at the internals of other SAPI's like `cli` and `fpm`. They look really simple if you don't take on account the whole process management thing. I have done some tinkering too with `fpm` I managed to init the entire PHP before forking workers and run PHP a single script which would be available on all workers scripts it's like prepend but done once on `fpm` start up. This little hack allowed me to have preloaded PHP application before serving any request which lifted the whole performance of any application it was serving. So my question is could we fork PHP-FPM and create a server which would preload PHP application and would serve request by just calling a registered function (like register_shutdown_function)? We could have a PSR-7 ServerRequestInterface object as an argument and function should return ResponseInterface object as response. By having this type of architecture we could increase performance by 20 times. Of course, this kind of structure would require a lot of changes in applications, and changes to the server itself but I think it is worth to invest some time to have something better. I have spent time writing this type of server (https://github.com/ThrusterIO/http-server) but in plain PHP which I would not much trust for production as a server, but if we could have the same backend like PHP-FPM just modified to call function instead recreating PHP environment and reloading all resources.
This. wxPHP is a viable library for Desktop applications, too, just that it needs more contributors.
&gt; Just because you feel like it will do something doesn't mean it will. Just because you feel like it won't doesn't mean it won't. The vast majority of people obey the law. The threat of repercussions *does* prevent plenty of crimes (certainly more than the zero you're suggesting). &gt; The proposed policy is not clear, it is purposely vague. That's a completely different issue that I have never raised and have no particular opinion on. What I originally quoted was your opinion that there should not be a CoC at all.
Perhaps you'd want to list on your sign up page some examples of the tips your newsletter would include so people might be more inclined to sign up.
What you're describing sounds a lot like something [MailHog](https://github.com/mailhog/MailHog) can help with.
As opposed to passing the array values to the templating language? How do you decide which one to do?
We just use Mailcatcher
I use MailTrap.io it's great because you actually send out, but it intercepts the email and drops it in a sandboxed inbox. It also gives you some breakdowns on how other services view it's spam rating, this helps make sure you get delivered to inboxes.
Not really. It won't work with templates, it's helpful only when you return a JSON response rather than an HTML one. I personally prefer the short option, it makes so much more sense to only return an array when the Content-Type is so obvious. PS: I added an example in the previous post.
you're right - thought I had posted that but obviously not: This went out today, and you can see the link to Past Issues from the top menu http://us2.campaign-archive1.com/?u=5dd97d439d47ebaf407f869ad&amp;id=bc3e8a9b7b
Awesome thanks. I found this one also interesting. http://cologne2016.live.symfony.com/ 
OpenSSL doesn't offer AEAD in 7.0, but it was proposed for 7.1. So it wouldn't really be possible.
https://secure.php.net/conferences/
I've heard and read quite a lot of things about Laracon EU. I'm not a Laravel dev, is it still worth going?
We send all mails in staging to a mailing list with the testers in it.
&gt; long time running process I really want built-in language support for [Weak References](http://php.net/manual/en/book.weakref.php). They are an absolute must-have in a GC'ed language, and are especially awesome for avoiding memory-leaks\* when it comes to observer/listener objects. However, I'd draw the line when it comes to fancy multi-threading/concurrency constructs. That would open a huge can of angry worms for not a lot of benefit. \*Yes, they aren't "leaks" the way C has them, but it's the nearest equivalent in PHP-land.
I know many who does it in PHP but I mean real C/C++ written stuff which works with PHP sapi :)
Checkout Sunshine PHP it's near Cuba.
The thing with PHPNW is it sells out really quickly. By really quickly I mean before they even announce who's speaking.
OK make sense thanks
reading the src, kind of cool. thanks for the link
Are there any good examples on Service classes I can take a look at?
Another in the UK PHP South Coast - 11th June 2016 Southampton, UK http://2016.phpsouthcoast.co.uk/
You will need a separate VM with something mainstream like **Ubuntu** for this, but I assume that this is not a problem, since you want to be able to run your staging environment completely independent from your production environment: I use a custom tweak for postfix that does just this... so basically, on a fresh box: (all as root, "sudo -s" will suffice) apt-get install postfix Then run the setup, install it as a internet server with smart relay host, and set up your smtp relay. After installing postfix, run this on the commandline after you have adjusted it to your situation: (run as root too) echo "transport_maps = hash:/etc/postfix/transport" &gt;&gt; /etc/postfix/main.cf echo "mycompanydomain.com :" &gt;&gt; /etc/postfix/transport echo ".mycompanydomain.com :" &gt;&gt; /etc/postfix/transport echo "* :discard" &gt;&gt; /etc/postfix/transport echo "always_bcc = some.group.or.user@mycompanydomain.com" &gt;&gt; /etc/postfix/main.cf postmap /etc/postfix/transport service postfix restart I assume you know how to replace the values, but if not, feel free to PM me. Just tested this on a random box and it still works just fine.. I can send a mail from ANY program, and it ends up in that always_bcc mailbox, with the exception that you can still have it send mail directly to anyone @mycompanydomain.com. **Flabbergasted at how many people trust their testmails to third parties... this postfix 'hack' literally takes 3 minutes.. 2:30 to download and set up postfix on a slow connection &amp; slow VM and 30 seconds to adjust the example I gave and run it on the command line, and NO testmail will ever leave your corporate domain from that server..**
Sounds like you could be using some kind of configuration, and abstract away the actual email sending part of your system so you have a choice of different transport drivers. I've recently just made a system exactly like this, that can send via nothing, SMTP, SendGrid, and MailChimp, and has the ability to add more transport drivers whenever, and can be configured on a per-environment basis. Making this kind of thing into a micro-service on it's own is really fast too.
Despite our user base is not as large as PHPUnit, we still have users. Some of them are: * Pomm Project (https://github.com/pomm-project), * Pickle (https://github.com/FriendsOfPHP/pickle), * And many more: https://youtu.be/vR6ZvxUVa5M?t=7m57s (Mozilla, VLR, Mapado, ...)
http://mailcatcher.me/ is an amazing solution for that.
[DPC](http://www.phpconference.nl/), because, why wouldn't you want to go to Amsterdam? :)
Programs written in go are statically compiled to machine code. You don't need any additional software installed to run the program.
Have been making a lot of services that ask many different questions from a database and build a json object as a response. This is mostly MySQL queries into some internal logic into processing some content into spitting out json. Are there any third-party resources that I might want to use for this? 
I like to ensure that there's a `position:fixed;top:0;background-color:#FF0000;font-weight:bold;` header that displays for any environment that isn't production - in staging it says things like "You are testing on the live site. No destructive testing." Users aren't big on reading, of course, but the quickest way to teach them is to let them do what they're going to do anyway... none of this fool's business if the fools want to bother those other fools or muck up their production data.
But what kind of extra data and how does AEAD put that into the cipher text? Even wikipedia does not explain that, so I am not sure if anybody without proper crypto knowledge understands what it exactly does...
also [aerys](https://github.com/rdlowrey/Aerys)
&gt; Accusing the accuser prevents crimes? I'm not sure on your meaning of this as related to what we are discussing. Sorry I was tired, I meant repercussion.
Probably already too late to the party but here goes it anyway. Recently I found this tool here: http://www.toolheap.com/ It really works right out of the box and helped me to save some time.
I was not satisfied with pool-based approach of weakref (I like more how python's weak ref works) and need a PHP 7 support, so I made it. They have different interface, weakref if pool-based and weak\reference is notify based (but pooling also may be used). WeakMap from weakref now can be implemented in userland and it is done in https://github.com/pinepain/php-weak-lib as a Weak\SplObjectStorage class, so less C code to maintain, faster releas/fixes cycle. And weakref is PHP 5 only, while weak\reference is PHP 7. In addition there are few low-level functions provided by php-weak extension which allow to build any kind of userland weak data structures you need.
I think having different ciphersuites for openssl and libsodium is just... weird. Just make libsodium part of core (don't you have an RFC for that already?) and use it. You're providing the ability to select from different drivers to make it like PDO but I think PDO is different than this. With PDO you might chose a DBMS for any number of reasons. MySQL because it's free and because you're already using it. Oracle because you have a lot of money to spend and it's a better DBMS. MSSQL because you're on Windows and maybe it has features your DBA needs. But with crypto like this? If both libsodium and openssl are in PHP core why would you want to use openssl over libsodium? Whereas bigger companies have DBA's they don't typically have cryptography experts saying "we need to use this engine over that!". Cost isn't an issue either.
&gt; I talked about typed arrays, but not generics. I know, I'm pointing out that typed arrays *are* a form of generics: `int[]` === `array&lt;int&gt;` In other words, typed arrays are just one thing you can do with generics. Languages that start out with things like typed arrays and generic null-pointers rarely make it past that stage - for example, it's extremely unlikely that Go will ever move past that, because the type-system and syntax were designed specifically for those use-cases, rather than for generics in general. The problem is, by covering the most obvious use-cases with solutions that cover only those, you end up with something less generally useful. I would hate to see the same thing happen to PHP. 
If it's the latter then I would actually say that the function should tell you what is does e.g. isThisThingTrue() isEmpty() Sounds like they are making up for earlier bad naming decisions
Ha! Yeah in_array() returns bool, absolutely no need to strict compare it with true. IMO it's just adding unnecessary filler to your code, which can only hurt readability. Pro-tip: If they can't give you a good reason for it, then there isn't one :)
Keep the data in normal form for the database and use this for all business logic (option 3). From reading your post it looks like the concern with serialisation is efficiency? This can be dealt with using an application cache which is far easier to manage than having split logic between serialised and Db data. Serialising an object isn't a huge overhead - but creating it can be from a database whilst maintaining SOLID principles can be slow and painful. I tend to work on a 3 queries rule, if an API request takes more than 3 queries it needs re-factoring, with complicated Db relationships this happens quickly and you end up loading each entity with a query. You also assume you need a 1-to-1 with Db tables - you don't. If this happens just create new merged entities with SQL joins etc. Hope this helps
the functions, in gerneal, are named very well - and the php ones are, well, fairly well documented, that's why I'm asking - it also screws with my IDE in theis example: echo isset($obj-&gt;prop) ? $obj-&gt;prop : 'na'; is fine echo (isset($obj-&gt;prop) === true)? $obj-&gt;prop : 'na'; causes phpstorm to tell me that $obj-&gt;prop is not set
you mean a discard rule instead of just a whiterule, right?