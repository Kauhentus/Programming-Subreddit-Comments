indeed! seems like two people finally managed to agree on something in this subreddit XD cheers!
There's a upload file limit set by PHP (`upload_max_filesize` and `post_max_size` in `php.ini`). However usually you would want to resize the uploaded images to certain sizes used in different contexts (thumbnail, preview, large). In most cases storing images on disk as file and file path in database is the best option. This allows using the image with ease: simply `&lt;img src="$filepath"&gt;`. Also web servers are optimized for this and you get caching on server and client side for free.
php-fpm reload. Never had an issue with it and it is graceful (unlike php-fpm restart).
Nice! Thanks for this. That's roughly in line with when I last attempted an install of this type.
So, no more internal copying when a reference is used. One less reason to avoid references ;) 
All very good suggestions! @OP: You might want to also check out Zend Framework 2 as well. It's very complicated at first, but also very rewarding. You can find various skeleton applications for starting out, forked on GitHub and whatnot.
Yep. And also, feel free to ping me if you'd like feedback. :)
Can you please stop spamming this on /r/laravel/ /r/webdev and /r/PHP? Also you realize that with the MIT license they can already use it for commercial purposes without your consent or "developer license"...
Only if you heard of it before or watched any of the presentations about it :)
Life would be so much easier without them.
Oh come on, just stating my thoughts. Not like Im hating or rallying
Thank you!
Thanks @harikt for the [Gatekeeper](http://gatekeeperphp.com) recommendation (I'm the author). Gatekeeper was actually designed with an interface similar to what Sentry provides with more features added in. There's Remember Me functionality in there too. The way that it's set up, they can have multiple tokens with different expirations and it will verify the token and the user by the tracking ID of the token, not the session. That sounds like what you're after here...
 Arrays::setDeep($array, ['foo', 'bar', 'baz'], 123); // Sets $array['foo']['bar']['baz'] to 123. vs $array['foo']['bar']['baz'] = 123; (I know the array could come from user input, but just pointing it out)...
Sorry my friend, the libraries in CentOS 6 are just too outdated. You will either have to install more recent versions of jsoncpp and boost manually or you will have to use a container/virtualization solution like Docker. I will create an official Docker container for shadowd soon to make the installation as simple as possible.
Yes I know how array syntax works, but the function is obviously for runtime-defined paths ;)
Long story, but for one: try to implement it for arbitrary depth and you'll see.
I typically go for changing the app root, similar to OP, but I'd like to hint at another approach: phar. Phar is atomic (it's one file) and it's opcode cacheable. It's not something I've tried, but now I'm thinking.
I wouldn't take it offensively. I think /u/philsturgeon is simply trying to point out that if you have valuable feedback, that it should be posted to the official mailing list where people in charge of actually doing something about it will see it. Posting it here is most likely just going to get lost in the void or fall on deaf ears, at least compared to the official list that you're subscribed to.
Yeah I was going to say this. Never had a problem with doing that.
There are few big problems in events. 1. The observer pattern (which you don't implement) causes event wiring to happen entirely at runtime and you can't trace code from the event emitter to the event listeners statically, but only through an interactive debugger. Their order, count and kind, as well as their side-effects can cause deadlocks, livelocks, or just generally inexplicable application state. 2. Having multiple listeners means the event emitter can't definitively delegate a decision to the listener, because every one of them might change the event, with no clear authority who decides what gets done at the emitter. 3. "Global events" like anything global spell trouble. Your events lack details, which you can provide. But a big detail is locality itself. Not just "user-registered" somewhere, but *who* emitted it, and in what context. Global events are very good at causing a mess, because the entanglement of events and resulting state happens very easily and invisibly and it's hard to detect the creeping complexity until it's too late. At some point you realize the app is particularly fragile when you add or remove listeners, and you learn to fear messing with the event setup, not to break your app for some unclear voodoo reason. So preserving locality with clear contract between emitter and listener is crucial to keep the code modular, understandable and easy to refactor. The above can be mitigated by preferring the delegate pattern where possible. In most cases it's quite possible, actually. The delegate pattern is heavily used in OSX in place of event broadcasting (they have this too but it's not used as often) for communication between controllers and views, and controllers and models. Unlike a global "bus" of events, a delegate is given to a specific service instance, and the service specifically sends events only to this one delegate. No surprises, no actions from distance, and no "event fog". class RegistrationDelegate { function didRegisterUser($context, $details, $properties, $and, $so, $on) { if ($details['highRiskOfSpam']) $this-&gt;spamchecker-&gt;checkUser($user); if ($details['needsNotification']) $this-&gt;greeter-&gt;sendWelcomeEmail($user); $this-&gt;notifier-&gt;notifyAdmin($user); } } $reg = new Registration(new RegistrationDelegate); class Registration { protected $delegate; function registerUser() { $user = newUserEtc(); $this-&gt;delegate-&gt;didRegisterUser(...); } } Notice the goal here is that the Registration class calls a single delegate method and from that point on what the delegate does is none of its business. But because there's only one delegate at one time, you can do more than just listen to events with it, you can interact with your "delegator" and affect their behavior: class RegistrationDelegate { function shouldRegisterUser($details) { if (...checking...) return true; else return false; } } class Registration { function registerUser() { if ($this-&gt;delegate-&gt;shouldRegisterUser(...)) { $user = newUserEtc(); $this-&gt;delegate-&gt;didRegisterUser(...); } else { echo 'Well, looks like you\'re out of luck today.'; } } } Now you're free to keep your reusable logic in Registration, and your app-specific logic in delegates (BTW typically the delegate will be an interface or abstract class which the delegator library defines once, and then you implement ad-hoc for every given app).
writing makefiles for php projects can be fun, so I wouldn't say you're boring. :) This is a starting point for projects for us busy folk who don't have time to manually code our beloved makefiles. I used to love hand-coding my html, css and js but then I discovered html5boilerplate and I shaved minutes off of my kickoff time. Same idea. Again, its not for everyone and no one has to use it but I find that it helps me start a project quickly. I mentor a few PHP devs and I try to stress the importance of testing, documentation etc but the trending excuse was always "i can't set it up" or "it wont work on my machine" so this tool does a lot of the work for you. I'm horrible at writing so I think it will make more sense once I release the youtube video. If people find it useful then I'll probably add features to configure it all via the JSON file. Thanks for your feedback though I really appreciate it!
&gt; soon to make the installation as simple as possible Thank you. Anyway I was curious to test the WAF. Meanwhile I will try to fix the server CentOS 7.
In PHP world event--driven design is usually a code smell. We only have a single event that is possible: file being executed. This is the only real "event" in our workflows ever since its the only point of interaction. If you look at events in say browser/javascript or long running systems they are not only a good pattern but frankly a must have. Mysql server views your query as an "event" same as in browser your mouse click is an "event". The system cant know beforehand if the vent is going to come and who is going to send it. However in PHP events are mostly used in the same way as Wordpress hooks: to "trigger" different parts of the system. The question then arises why not "trigger" that functionality directly by calling a method? there are 2 possible answers: * The system you want to "trigger" is far awayy from the part where you need to trigger it from. Which means poor architecture * You are implementing a plugin system. In this case event can be refactores into a chain of responsibility pattern. Both of the above are problems with architecture. The reason for events being introduced in such cases is it being the only "band aid" that can hold the system together.
&gt; What happens to your "green" when you need to make a BC incompatible change? It's a sanity check, not the be all and end all. BC incompatible changes (if they are an issue) are picked up in automated acceptance tests (a change in behaviour *should* result in an earlier acceptance test failing), and QA. Of course it doesn't catch **everything**, mistakes still happen. But it does catch silly mistakes which would otherwise fall through the cracks if you were relying entirely on manual regression. &gt; A colleague or yourself committed a wrong test? It's red, but not for the reason you think it is. And so on. It's red, it gets investigated. Uncovering red for the wrong reasons becomes a process of tracing the problem back and determining that it was a *test related* problem..in much the same way as you would detect that it was a problem with the application code. &gt; But the biggest red herring here is that PHP is simply best suited for templates and controllers. Not for domain related back-end logic. So your most testable code shouldn't even be in PHP. That attitude is demonstrably bullshit. Just because PHP started off like that does not mean that's how it should be used, or even how it is **intended** to be used these days. And even if it wasn't bullshit.. CI over controllers is entirely a reasonable thing to do. &gt; Half the tests you write are just a compiler error by default in Java. Er no. But even if it wasn't the case, that would mean that the other half are valuable. In a suite of over 3000 tests, that probably means that there was some value to automating and performing them, if for *no other reason* than paying somebody to perform 1500 tests manually each day is cost prohibitive. 
I have been reading about event-sourcing and CQRS recently. In event-sourcing, we emit events for every single action that happens, store each event in an event store and then broadcast them out into some messaging bus so that listeners can act on them. The event store simply consists of a list of events in chronological order (you would need an event stream for each aggregate, but let's keep things simple). You then have read-models which receive those events and build the appropriate views for reading. If the view changes, you can simply replay the events to generate your new views. In your case, would it make sense to have 2 types of events by making them more fine-grained? Perhaps a "user-registered-himself" and a "user-created-by-admin" event. These events can contain different metadata appropriate to the context. This also simplifies auditing. For example, you would be able to list all users created by the administrator by looking at the event logs.
I know it was a contrived example, but... Why would you want to create a user in the first place if they are a spam bot? I'd think you'd want that behavior injected in another manner so you can simply not create that user or create it in a different way such that it's not actually able to interact with anything in a meaningful way. This feels more like validation, which shouldn't be handled by events. I don't know that I'd want to be notified by email of a user registering anyway, but assuming I did, I feel like I'd rather receive extra emails so I have the extra record of it happening and so if someone else were on the list of people that are notified they'd know it too. But even if that wasn't the case, it'd be simple enough to pass an extra flag to note that it was a manual admin creation and to skip sending it. I don't particularly care for that solution either, but it is an option, more fine grained events might be a better solution, event listener creation should generally be a fairly cheap operation. I always though of events such as those you mention as more of an opportunity for things like logging and cache warming. They're not critical to the process, there are no significant side effects, and they can't really interfere with anything, they are just things that are nice to have happen sometimes. For example, maybe you want to turn off the cache warming in your dev environment and turn off logging in your test environment. If you have another injected behavioral element to do those types of things, you have to be checking your environment in your "real" code rather than having it included as a part of the configuration process. Event sourcing is an entirely different ballpark I haven't thoroughly explored, so I won't really comment too much on that, but I know there are advocates. I will just say I suspect that that argument might not apply in this context as there would be a whole lot different about your application if it were being properly utilized, but I could be wrong, I've only barely started to read up on it.
Sure. There are multiple ways to solve the problem. The user registration example is probably *way* too simple an example to even consider using domain events... but i went with it because that's what OP went with.
&gt; What it does require is a UserHandler domain class. Then you would do $userHandler-&gt;handleRegistration($user); By extracting your logic into specific classes you always know where to add the new functionality and how to deal with it. Which still requires you to modify UserHandler any time new functionality is added. UserHandler could become incredibly complex very quickly. The user example is of course far too simplistic to advocate using an event approach - it is unlikely that user registration would ever get that complex. But imagine a case where you had to take dozens of actions after a user was registered? Events become incredibly useful in these cases. &gt; If you allow any part of the system "subscribe" to any event in the other part of the system you get the OOP equivalent of the spaghetti code. Er, typically you configure what handlers are associated with which events. I don't know that you would dynamically attach handlers to events at runtime. You should be able to look at some sort of config class and know exactly which handlers listen to which events. &gt; In your registration example imagine that the email handlers were subscribed dynamically in a whole different part. And one day the email is not sent, and then the event hell starts: you have to debug not only the code itself, but also the "meta" code that ddid the subscribing. You mean you look at the config and get a list of classes which could have sent the mail? or your logs which tell you what did (and by the absence of logs did not) run? Yes it is not quite as transparent as straight up method calls, and that is the tradeoff - but it's hardly the burden that you are making it out to be. &gt; And tthen the kicker: image a subscibtion happening inside some other event handler. Thats how you get coupled events, and then you're basically screwed If you did that, you're asking for trouble. *Clearly* approaches are open to abuse and you can do dumb shit with almost any approach you can imagine. It doesn't remove the fact that your statement that events are a code smell is patently false. You are applying an absolute (The use of events is a sign of bad architecture) to what can be a very complex problem. Yes, you can fuck things up using events...but you can likewise fuck things up with spaghettining method calls. 
&gt; So you break down into more classes you mean like a SendWelcomeEmail, and a NotifyAdmin.. hrmmm :) &gt; In that case you can easily do that without an event system. In this case ( unlike browser/js interaction ) you have all your comonents predefined. Just use any DI container to inject these depndencies and give them a common interface. Then instead of firing events you can iterate these handlers and call that specific interface defined method on them. Huh? that sounds precisely how event systems tend to work. You have a dispatcher which accepts an instance of an Event (the event being fired), which then looks at some config (your DIC, or a simple map of events to listeners) to get a list of handlers - The handlers are then resolved out of the container (or instantiated direclty, whatever), and a handle method is called with the event as it's parameter... so: 1. Define a map (somewhere, somehow... i suppose you could dynamically build it if you really wanted) of events to listeners. Note that the strings in this array represent classes. $events = [ 'UserWasRegistered' =&gt; [ 'SendWelcomeEmail', 'NotifyAdmin' ] ] class UserWasRegistered extends Event { public $user; public function __construct(UserModel $user) { $this-&gt;user = $user; } } class SendWelcomeEmail implements EventHandler { protected $mail; public function __construct(Mailer $mail) { $this-&gt;mailer = $mail; } public function handle(Event $event) { $this-&gt;mailer-&gt;send($event-&gt;user-&gt;email, 'Welcome To the Application'); } } 2. Raise an event via a dispatcher, passing whatever parameters the event has as constructor arguments $this-&gt;dispatcher-&gt;raise(new UserWasRegistered(UserModel $user)); 3. have the dispatcher read the map and iterate the listeners calling the handle method, passing the event as a parameter Sounds exactly like what you're describing? 
Half of the issue is how you deal with newly discovered issues. Its now only writing something that is safe but also keeping it safe for the long run. Overall that will take you much more time.
"Somewhere in /src" would be a good location.
You look to see if someone else has already done that shit, and then add an additional dependency ;)
It's a simplified example of some real business rules. The naming of spam bot check was poor - more like CheckIfUserIsSuspicious, which would reach out to a service like stopforumspam.com and validate the IP and email against their database. Often times banned users like to come back via proxies, and the proxies may have been flagged as toxic in the spam checker service. So when we detect a suspected banned user trying to re-register, we allow the registration to go through, but flag the account as suspicious and make them fill out an "appeal" form to prove that they are human, and also write something which helps us identify who they are (you can always tell people by the way they write - a forum troll has a certain "signature" to their writing style, so the appeal form helps us determine that). Regarding notifying an admin, that's more in line with a small business that might get one new customer signup a week or something, and the owner wants an immediate notification that a new customer/user has registered. Not so much for a high volume forum site, so I did mix some business rules, but either way, I feel like if you have to compromise otherwise sane business rules to accommodate architecture, you're doing something wrong.
and then you have PHP responding to &lt;?xml WHOOPS.
he was looking for: echo var_export($var, true);
So then that leads me to another question, is there some useful heuristic for determining when events are beneficial and when it's just overkill architecture for the problem you're trying to solve?
I make a folder called Component in my src folder, and name my component something relevant. For example if I had some sort of encoding calculator or converter, I'd make the file src/Component/Calculator/Encoding.php And stick the class Acme\Component\Calculator\Encoding in there. This matches how SF does things too. They'll usually have a Component folder for the raw PHP components, and a Bundle folder that plugs those components into the DIC, event system, and everything else.
This looks a lot like "command bus" pattern that has been popping up recently. Though, I think that command bus pattern is really just a hyper focused event.
The bus concept itself is harmless and it fulfills middleware role like ensuring transport and message semantics, say "receive at least once, at most once, encrypt, decrypt, negotiate protocol" etc. It's nice to have a unified command model you can pass easily through pipes and filters. I draw the line at: who's listening and what are they doing with it. If it's one specific listener to whom the command/query is directed, perfect. That's ideal. If anyone can subscribe as a listener, that's becoming slightly suspicious, but it's ok if they operate outside the domain of the event (example: listens for domain events, doesn't touch the domain, just generates separate reports based on it). If anyone can subscribe as a listener, and *they mutate the app/domain state that the event is related to*, then expect an explosion of complexity coming very soon. 
I like you.
&gt;Moreover, no logic needs to ever be duplicated. You're duplicating logic every time you have to attach the listener. You're also increasing touch points for where this happens. Want to add a new listener that implements some extra business requirement functionality -- go find the hundred places where you trigger the event and manually specify all the listeners and add it to the ever increasing list of context sensitive wiring. Also, try to maintain what contexts do and don't deserve some listeners while others don't and do. It get's mighty messy--and that's when the pattern starts seeming anti-pattern. But, I still say this is because the logic of when the behavior should fire is in the wrong place. &gt; That starts smelling like an open/closed principle problem whereby you need to keep modifying these listeners each time some new context is relevant to them and they need to account for it. I could argue that in the case of revisiting the listener to add additional exceptions to spam checking is a change of requirements. I.e, if your requirement for a color class is to return red, and you code it to do so--then later your requirement is to return blue you go back and change that class. In this case you can reduce the amount of modification by making the decision config based -- load a list of allowed contexts to check against (white-list) or the inverse (black-list) and make your decision then. &gt;Moreover, it would be better if they didn't even have the responsibility of deciding when they should execute and when they shouldn't. No, quite the contrary in fact. Here's the thing, no matter how you look at it you have conditional control flow requirements: If a then do A If b then do B .. etc You have to encapsulate that logic somewhere. Right now, your listeners are only encapsulating "then do A" and "then do B" and you are going to end up with dozens of repetitive and indefinite "if a" and "if b" logic strung out through your app via conditional wiring. Now, maybe the "if a" logic is complex enough to warrant it's own implementation to adhere to single responsibility principle, which will net you an additional class maybe "SpamBotContextDecider". Then that becomes the dependency for your listener. class VerifyUserIsNotASpamBot { protected $decider; public function getDecider() { return $this-&gt;decider; } public function setDecider($decider) { $this-&gt;decider = $decider; } public function onUserRegistered(Event $e) { if(!$this-&gt;getDecider()-&gt;shouldCheckForSpam()) { return; // no need to check for spambot } // check for spam bot } } class SpamBotContextDecider { protected $context; public function getContext() { return $this-&gt;context; } public function setContext($context) { $this-&gt;context = $context; } public function shouldCheckForSpam(Event $e) { if($this-&gt;getContext() == 'admin') { return true; } return false; } } This change follows single responsibility principle and perhaps it will also net you some relief on the open/closed principle as now SpamBotContextDecider closely mirrors the color class example I gave earlier. If the requirement changes, you change the one class dedicated to that requirement. The important thing here is that when you add, remove or change when a behavior should/shouldn't be triggered you are going to go to a single spot in your code base to make the change. 
maybe create a UtilitiesBundle and put the common functions in a Service
I'm honestly surprised, I thought GitHub would be a clear winner. Literally never had an interest in signing up for BitBucket. EDIT: Ah, BitBucket offer free private repos. Makes a lot more sense now.
I have an account for both, but I only ever choose to use github for my own stuff. If you're going to contribute to some project on bb then you need an account, but it's not an endorsement of bb.
Ya i use bitbucket more because of the private. There should probably be a poll on what you use the most not on if you have accounts.
I've used bit bucket for my private repos, but you're limited to 5 people having access, unless you pay. Lately, I've been using gitlab (free local install at work and hosted for personal). On their free hosted plans, you can have unlimited private repos with no limit on the number of users with access.
what a surprise, I like me too =D 
I have GitHub so that my office Boxen install will run. For my personal projects, I use GitLab. GH has a reputation for treating their women employees poorly, and Atlassian (of Bitbucket) have a track record of making tasteless homophobic jokes. I'd rather not reward that behaviour with my patronage.
&gt; and Atlassian (of Bitbucket) have a track record of making tasteless homophobic jokes. Source?
Their Twitter feed. Their "spooning" April Fool's Day video a few years back.
Services. Make a service for the stuff you need
When they're services I just add them in a "Services" folder, otherwise "Utils"
I'll grant you that video, but where in the Twitter feed?
Github for open source and Bitbucket for real work ;)
Good job Taylor!
Short tags have been a bit of an unofficial "no no" for years now. Whilst a TINY little bit more convenient, they're pretty pointless and don't let you quickly determine the language being used. For the sake of 3 characters it's not worth the mess.
Github for opensource stuff, Bitbucket for private stuff as Githubs private repo pricing is way overpriced for what you get.
"Utility" functions are a code smell since they usually result ina Util god class that can do wide range of different things, thus breaking SRP. Group your function ito appropriate classes and turn those into services
I think you've hit the nail on the head here in terms of requiring decision making part of the listeners. I'd just move the context in to the User though, make the user have some sort of referrer as part of it's attributes, that consumers of the Registration service are required to provide.
I thought most people would be using one or the other. Could have had an "Other" option I suppose, but too late now to change it.
Same as everyone, both. Bitbucket for private repos without having to pay. Also for our company. GitHub for projects you want to Open Source.
? Symfony have one of the best documentation. I dont think your problem is properly identified &gt;but when we dig a bit deeper it's just goes to Googling obscure problems. The cookbook and the docs are really unhelpful. what kind of obscure problems did you encounter ?
I pay for both for some reason.
I can see it's not worth making a fuss about, I was just a bit confused that I suddenly have to go through 10's of files replacing all the tags. I figured I can't be the first person to get caught out by this, and I think it's an interesting curiosity at the very least.
They have sort of opposite pricing, Bitbucket offers unlimited private repos but limited teams, whereas GitHub offers limited private repos but unlimited teams.
I think this is the correct way of doing it, a admin creating a user and a user self registering have different intent. And in them selfs are different events. If you were to look back over the life time of your system using the events been able to see the difference between two different intents are greatly useful. An example of this could be a user who changes there address, Do they totally change it to a different location or do them simply amend it. You decision in your application will be different depending on the intend of the user, Simply having one AddressChanged event does not tell you everything you need to know about that event.
FWIW, as someone with plenty of Symfony experience, I recently had to so some work in Zend Framework 2. In my opinion, the Symfony documentation is very much better than ZF2's. Not just the official docs but also the number of high quality blogs etc.
In my opinion Symfony has the best documentation of any of the PHP frameworks. Plus the documentation for all of the components are great if you don't want to use a full framework.
Github only. We use Gitlab in the office for private projects, I also have my own Gitlab install for my own private repos.
One of my criticisms of Laravel is that docs are a mile wide and an inch deep. They document very literally, but don't document interrelations very well or edge case uses. My cyncial opinion is that this is related to how they monetize. Laracasts has nice, deep documentation showing interrelations and edge cases. I understand this but they could be more honest about it or just come out and say it.
I use both, bitbucket for private, and github for opensource, same with others here :D
I'm not suggesting you use Codeigniter but I always felt their documentation has always been dead-easy to go through. I'm not sure if it's because of the frameworks simplicity or the documentation structure. But then again, it's Codeigniter, so just don't go that way.
For private, I'd rather use gitlab. Updates much more often. 
We are pretty much 100% WordPress now, but a few years ago I built an internal website for contest tracking and learned Code Igniter as I went. Definitely agree that it's easy to learn, and also agree not to use it, ever.
The command bus pattern is just a message that gets sent to one handler, it's more of a way of transform an action into a statement that is semantically in sync with business processes. However, within a command handler, you also often see an event firing, and then N number of downstream listeners acting on the event, which is where it starts to get hairy.
And Gitlab has the best of both, unlimited private repos with unlimited team size.
&gt; You're duplicating logic every time you have to attach the listener I wouldn't consider that logic, that's just configuration. In my example, you're literally just adding a string or a class to an array, that would be the most "logic" you'd ever duplicate, and I don't consider that logic as there are no conditions to fulfill or contexts to understand. &gt; If a then do A If b then do B .. etc &gt; You have to encapsulate that logic somewhere See, I would avoid that entirely. Maybe that's naive, but I wouldn't even structure event listeners such that they depended on a flow of conditional logic like that. I might have some logic inside of them with respect to the *subject* that gets passed to them (in the above examples, a User), but not logic regarding whether they should or shouldn't execute depending on things outside of that scope. Regarding maintenance, at the end of the day, the major bugs you'll have with events will boil down to: "Why did that listener trigger in that context? I didn't want it to" (at least, that's been my experience with events) With what I had proposed above, you simply need to go to where the context is, and see what local configuration of listeners has been set, then just remove the unnecessary declaration for it. I would much prefer that over "well fuck, gotta add a new condition to my listener to account for this unique context". Besides, if you have hundreds of contexts potentially triggering the same event as you've mentioned, that will *definitely* make the internalized execution logic of *each* listener enormously hairy. The more contexts they have to account for, the worse they'll get. Meanwhile if their only dependency is their *subject*, they remain maintainable. Maintenance does indeed have to occur somewhere, but I would prefer it as a simple local configuration (literally, an array of declared listeners) at the source of the context, rather than scattered throughout dozens or hundreds of listeners. But to your point, I guess it boils down to what you have more of: contexts, or listeners. If you have 3 different listeners and 100 different contexts, yes, my suggestion is definitely more work and more maintenance as you have to go into 100 different locations to make edits. But, you still have to account for those contexts in your listeners, so those 3 listeners are going to get nasty regardless. If you have 100 different listeners and just a few contexts, then I would much prefer the ability to configure the listeners at the context and then keep the listeners "dumb". 
&gt; Yea sure... because I will always remember what is in my code and it will be obvious to every other future developer what I was doing there. Yes, well if we find it hard not to accidentally open and close PHP tags all over our PHP source, I guess we'd be completely hopeless when it comes to escaping output for HTML, JS, CSS or avoiding SQL injections ;) &gt; It's trivial and this solution works great with IDEs/s That is a minor annoyance for me. And I don't think that solution is better at all than only using &lt;?php or &lt;?=. It's a matter of pain / gain. Gain: readability when you open very short PHP blocks dozens of times per template. Pain: Having to escape *one* "&lt;?xml" per template when you insist on using XML processing instructions like it's 1999 ;) I don't love the fact PHP team chose "&lt;?" as the start of the sequence, if it were me, I'd standardize on "&lt;%" like ASP did, but, well, that's gone from PHP7, so they're pretty much dictating the short open tag solution to the "short conscious". It's that or parsed custom syntax like Twig, which is a bit like shooting a fly with a tank (not that I mind that, if you're a fan). And then with something like Twig you'd be worrying that someone pasting a "{{" or "{:" or "{=" might open a Twig block accidentally, because it's always 1-2 chars to switch context with most template engines.
They hate us cause they ain't us.
They're jealous because we have the **real** /u/philsturgeon
I'll just leave this here: https://en.wikiquote.org/wiki/Rasmus_Lerdorf
That's like asking why that kid in school gets bullied. Maybe it's their hair, or the way they speak, or some funny gesture they do. It doesn't matter. But once you get a reputation for being a punching bag, and PHP has, then it stays like that, because everyone feels better having a bag to punch. The hate towards PHP has technical merit (most of it historical) but at its core it's emotional, so don't expect to win it with technical arguments. Technical arguments don't matter. Instead of arguing about whether PHP is good or bad, focus on results. Nobody argues with success. Do you see someone laughing at Facebook or Wikipedia for their use of PHP? Nope.
You just read a thing that had something derogatory to say about almost every language anyone should care about, plus a few more, and you saw someone hating on PHP ... I saw someone making a joke.
Of course it's a joke, but in OP's defense, PHP was the only language compared to suicide... that's pretty dark IMHO (and no, accidentally shooting yourself with C isn't the same thing). 
Couldn't agree more. If Symfony has too much advanced documentation, Laravel has far to little. Want to know how to stop using Facades? Google. Split your app into services? Google. It drives me nuts... every time I get near a Laravel app I have to spend an extra 25-50% of my time trying to figure out how it does its magic.
&gt;Yes, well if we find it hard not to accidentally open and close PHP tags all over our PHP source, I guess we'd be completely hopeless when it comes to escaping output for HTML, JS, CSS or avoiding SQL injections ;) I find it indeed hard to know if someone else on the project is doing something with XML when there are 6+ people working on one project. If someone did something with XML and I would implement your improvement then his XML template would not work anymore. Sure the unit test would expose this bug but it's unnecessary especially since I don't see any big advantage in visibility. &lt;?= is always okay and I have to use a normal open tag very rarely in templates. I mean: &lt;?php for($i = 0; $i &lt; 100; i++): ?&gt; vs &lt;? for($i = 0; $i &lt; 100; i++): ?&gt; Seriously?! &gt;with something like Twig you'd be worrying that someone pasting a "{{" or "{:" or "{=" might open a Twig block accidentally, because it's always 1-2 chars to switch context with most template engines. I would always enforce default escaping. Writing escaped content should be easy. Writing unescaped content should be hard so you can't forget to escape. But that's not how it is here where I work and we constantly have people forgetting escaping...
We use Gitlab at work and it's awesome.
Both.
PHP does get some flak for things that aren't really its fault. The old (and thankfully superseded) MySQL interface, for instance, gets a lot of criticism for "mysql_real_escape_string()", which I believe actually came from the C API. In retrospect, it probably would have been better to clean it up a bit than copy all of the cruft exactly, since it seems nowadays that people write a lot more database code in PHP than in C.
&gt; I find it indeed hard to know if someone else on the project is doing something with XML when there are 6+ people working on one project. So that "someone else" is just thrown into the middle of a project, and you have no team and company conventions, wiki, project documentation and no communication whatsoever, either in person, phone, email? Weird. I guess I'd indeed stick to the lowest common denominator in a dysfunctional team. But in such a scenario short tags are your least issue. Have fun maintaining *architectural constraints* on your project this way. 
I'm writing such phrases in a light-hearted mood, but I'll take your feedback that this is poorly conveyed over text. No offense meant to the author. It gets annoying over time to see one tutorial after another spreading misconceptions. It's not the singular fault of any one blog post or video, but together they change our culture. People who know a little bit better have a hard time fighting a tide of wrong terminology and misplaced practices when architecting their apps in a team environment. DI was around before containers and it'll stay around after containers. Focusing on the containers often comes with insufficient understanding of the practice of why we have DI in the first place (and it's enough to write a whole book about alone).
&gt; The fundamental difference between them is that in DI you pass a service to a dependent object as an abstraction.
Honestly, I have yet to see someone say "PHP is great". Are you sure it's not just the voices in your head saying this? PHP is perfectly serviceable, and has some unique strengths, but it has a long way to go still.
&gt; They're jealous because we have the real /u/philsturgeon I am affraid that phil will move to ruby and start hating php too
&gt; Want to know how to stop using Facades? Google Uh, No? * [Step 1: identify the Facade class via the reference section](http://laravel.com/docs/5.0/facades#facade-class-reference) * [Step 2: read the introduction to the container doc](http://laravel.com/docs/5.0/container#introduction) Those two sections are the only thing you need to read in order to know how to stop using facades. Want to inject the instance that lies behind the Cache facade? From step 1 we know it's `Illuminate\Cache\Repository` From step 2 we know we can just do this: &lt;?php use Illuminate\Cache\Repository as CacheRepository; class Whatever { protected $cache; public function __construct(CacheRepository $cache) { $this-&gt;cache = $cache; } } Done. You don't need Google, you just need to actually read the docs, and reading Laravel's docs is like an easy stroll along the beach on a warm summer day. 
Can you do me a favor and suggest an article that you think more clearly explains it?
That's the thing, it's kinda hard to find one which doesn't immediately turn south and start talking about containers. I've found the best way on balance to implement DI is via an "encapsulated context" (it's a pattern, you can look it up), which allows lazy instantiation of dependencies (unlike manual DI or container DI), without depending on a global container where services are fetched by "magic string constants" (service locators, registries). There's a very poor understanding of DI, which is why encapsulated context can be confused with a locator (it's not) and many containers implement aspects of locators (magic parameter names, not just types, annotations etc.) unknowingly and the debate becomes very hard to have about merits of each solution. Ideally from the perspective of the instantiated object, it just has access to its own dependencies, has no access to someone else's dependencies (a constraint violated by containers, as they'll serve you anything you typehint for and they know the type of), and you can freely change the instantiated object's PHPDoc and parameter *names* without fearing a container is reading them via reflection and making decisions based on such metadata (which is supposed to be a private detail of the object).
One complaint I have is that you can't link to sub-sections in your documentation. You have H2 anchors, but not anchors for anything below H2. Very often times I come across someone who has a question that is easily answered by a very specific section, but I'm forced to link to the H2 and then explain where to find the answer within that larger section. It would be really useful if there was more granular linkability in your docs - even down to H4. If you're planning on expanding your docs, more granular linkability will become all the more useful.
Those are all cases for making heavier use of traditional relational style and avoiding JSON as much as possible. You have to think about an abstract database schema that gives you the right amount of flexibility that you need.
I dunno, it was easy to follow for me. I first started using Symfony a few months ago. I was familiar with all of the concepts and design patterns it uses, though.
The objective of the post is to show DI in practice, using code, and invite people to play with. Try coding or changing this DI container, it's a good exercise.
Also, another thing you may want to consider is trouble shooting for installation. If we go through your installation process to create a project called `test`, and then create a virtual host for it called `test.local`, and add a reference to it in /etc/hosts, then browse to `http://test.local` in our browser, the very first thing we get is a white screen of death. I have maximum error checking on, and display errors on, but I get a white screen. If you don't know you then have to go through and chown/chmod the project directory appropriately, you'll have no idea why you have a white screen or what's causing it. I know that's not strictly in the purview of Laravel, but to a new developer just starting out (especially one that might be just getting started on a *nix system), they are going to be confused. The "Permissions" section in the intro doc doesn't really cover that in a way that a user might make the connection, and they could miss the section entirely because it's so small. So perhaps a dedicated "Troubleshooting" section for installation that walks the user through several potential scenarios and explains the solutions, could be useful.
&gt; JS could almost be called elegant The "everything is an object" approach is EXACTLY what I hate about it. I actually find that language to be really ugly. 
Great Answer! 
Old article is old (2012). Some of his points have been addressed in PHP 7.
Don't know how it compares to other frameworks, but Lithium is sorely lacking in docs, IMO. I still like it though.
&gt; Is there a good organizational structure for them? Yes, the one that's *consistent*. Since we have PSR-4 autoloading, where you place them is totally up to you. What matters is that you're consistent about it within a project, and from one project to the next. If you ever ask yourself "where did I put that thing again?", then you should take a minute to evaluate why you confused yourself. Where you place code is a lot like using bug tracking software or going on a diet - all of it works, as long as you actually do it consistently.
I feel like this poll isn't very meaningful. I work with lots of clients, so I likely do have a Bitbucket account for one who was using it... do I use it? Will I ever log into it again? Maybe when another client uses it. I answered GitHub only.
&gt; The entire language is centered around "everything is an object" and very strong primitive types. It's kinda funny to say that in the same sentence, because JS primitives are not objects. &gt; As compared to the huge pile of functions that exist in PHP, JS could almost be called elegant (if it weren't for the bad parts). JS has a bunch of functions too, and not just everything in Math.*, but also parseInt(), decodeURI(), decodeURIComponent(), eval(), isNaN(), encodeURI(), isFinite(), parseFloat(), unescape(), escape()... Functional languages are even entirely made of functions, yet everyone considers them very elegant. And C is also all functions. Maybe the existence of a huge pile of functions is not the problem here?
So, this might sound dumb. I rarely use source tree. I think it has a kinda high learning curve, and it makes me uncomfortable that all those buttons actually run git commands. What I want is a GUI tool that just gives me information on my repo. Git diffs and branching graphs and the like.
I'm sorry, but readability of code snippets http://screencloud.net/v/E8ZL And... Why did you decide there needs to be new framework?..
I think your question has been over-asked and I've not seen new points brought to the discussion. It would be more interesting if you asked "Why all the hate towards PHP7?" or "Why nobody uses HACK if it's so superior?" or "Why some people hate PSR?" or "Why is composer ruining my life?" or "How can I join the laravel circlejerk?" or "What's up with the apache hate in the past few years?". See, so many questions about hate that are related to PHP without attacking the language itself with tired arguments (bad function naming, because it's cool to be hipster and php is mainstream, because PHP looks like java, because PHP used to suck at objects, etc).
I think Fabien Potencier did a fantasmic job. http://fabien.potencier.org/article/11/what-is-dependency-injection
Really well written, though far from an introductory tutorial. I think everything up to http://tech.mybuilder.com/dependency-injection-tutorial/#let's-write-our-di-container covers as much as you need to know to get the basics of DI. If 99% of PHP devs just understood it to the point of your `interface Car {} class Ferrari implements Car {} class Driver { private $car; __construct(Car $car) { $this-&gt;car = $car; } }`, I'd have a much easier time working with other people's libs. All the repository/factory/container stuff after that is a nice way to apply DI, but to any newer devs reading this: don't think you need to implement this entire article just to use DI. 
I'd be curious what browser you're using. The pages are rendered from markdown and the whitespace should be pre (preserve whitespace) formatted although do go through hilightjs which could be affecting that. As for deciding there needs to be a new framework. 1) The framework is not new. This is version 3.0. I wrote the initial version back around 2009 or so when I was going freelance. 2) I have used various versions for personal projects, and it was designed originally for specific needs I had for client work at the time which were not fulfilled by other frameworks, at the time the two major options were CakePHP or Codeigniter. The latter was heavy with respect to bootstrapping and getting projects off the ground and the former didn't really offer enough with respect to rapid development. 3) I think writing and maintaining your own framework is really good practice, not only for keeping up with modern approaches, but also for understanding the fundamentals of other frameworks you might encounter. In short, it helps you become a better programmer in my experience.
Reminds me of similar critiques for every language I've worked in, including the brand new Swift. Swift is modern, safely typed and so on, it also has a "fractal of edge cases" that make it very odd to program in at times. But you see what gets built with it, and you see it's good. PHP is the same. It has issues, but it's getting better and it's useful. The rest is bikeshedding.
http://screencloud.net/v/uF0u
This appears to be related to this as far as I can tell: https://code.google.com/p/chromium/issues/detail?id=398274 Basically, Chrome is not rendering tabs in pre or pre-wrap. It appears untriaged and low priority on their list.
I don't want to use json or xml to specify class dependencies. Plain factories work well enough. 
I want to say I love DI. However, I hate containers. 
Agreed. Build your own. Then look at wordpress. 
We should totally hang out together! ;)
Are you the guy that wrote Former? 
I am yes, I don't maintain it anymore though, moved it to an org. Focusing on [Rocketeer](https://github.com/rocketeers/rocketeer)
Part of the pattern I often follow is to *completely detach* the nature of the input and the output from the controller. That is, the basic controller gets all of the input it wants in a specific format, and returns a data structure. It doesn't know or care whether the data came from a HTTP request or from a cron script or somewhere else. A layer on top of the controller is then responsible for accepting input, throwing it at the controller, then taking the data the controller emits and turning it into user output, be it HTML through a template or JSON for a web service or an email for a cron job. In addition to making it *very* easy to reuse controller code between request types, this also ends up making testing the controller more convenient by allowing it to always run in a vacuum. I've often been able to reuse multiple actions to compose other complex actions. Unfortunately this happens to be the exact opposite of your request.
Would you please be so kind and give a pointer to the manual. I'm really failing to find that feature.
FWIW, the word "controller" appears nowhere in the actual class names involved. I'm firmly of the opinion that trying to adapt "MVC" for most web applications is a bad idea, and was just using the word for the familiar context. That said, I'd kind of disagree on calling the innermost bits a "service" in this context. They're the bits that perform logic on data, which is closer to the definition of "business logic" than not. I'm a fan of things like the [anemic domain model](http://en.wikipedia.org/wiki/Anemic_domain_model), so my data objects are light on logic (though not horribly so, I easily see how some consider it an anti-pattern). A lot of the things I end up doing involve multiple data sources and types, so having the logic in the "controller" makes more sense for my use cases.
I've done this the hybrid way where depending on action and parameters a controller would use an HTML view or a JSON view to respond. However, there's a better way. Write your service layer ready to be exposed safely to the world from day 1, using AJAX compatible input and output (basically PHP arrays and scalars). Expose this as native objects and methods to your controllers. Then in a single controller dedicated to AJAX, expose that native interface to your client JS. Example: // In controllers. $domainEndpoint-&gt;users-&gt;create(['name' =&gt; 'John', 'email' =&gt; 'john@doe.com']); // returns ['id' =&gt; 123] // In Javascript. POST /api/domain/users/create {name: "John", email: "john@doe.com"} // returns: {id: 123} The entire mapping is automatic so you don't need to write routes or anything. If it's in the service, it's available both to controllers and AJAX. You can control security with authorization tokens. Every token has different permissions. I have a "system token" which services can use to call each other, which can't be produced from either AJAX or controllers. It's for special actions. Controllers/AJAX instead operate with the token of the currently logged in user, i.e. "client" or "admin" for ex.
Hmm. API Blueprint looks neat. It also looks hosted by Apiary. Not sure I want to do that (this is an internal API).. But the Polls demo they have looks great, so it's definitely something I'll look into. Thanks!
I've been using Ruby alongside PHP for years already and share about the same amount of love and hate for both of them. 
&gt; trying to adapt "MVC" You're using it whether you know it or not. &gt; I'm a fan of things like the anemic domain model, so my data objects are light on logic (though not horribly so, I easily see how some consider it an anti-pattern). A lot of the things I end up doing involve multiple data sources and types, so having the logic in the "controller" makes more sense for my use cases. Your anemic models are called "repositories". They are internal objects used in the model/service that handle persistence (say interaction with SQL etc.) and have little to no business logic in them. So to recap: 1. The layer above controllers are actually your "controllers" (mediating glue code, handles context, maps to neutral i/o for the domain services). 2. The layer you call controllers are actually your "models" or "domain services" (bulk of business logic is here). 3. The layer you call "anemic domain model" is actually your "repositories" (no business logic, mostly map from DB to objects etc.). Again, your architecture is very typical, and very reasonable, but if you use terms incorrectly people will misunderstand you. Case in point, "anemic model" is considered an antipattern as you said, while "repositories" are *not*. So, why make yourself look like you foolishly use antipatterns, instead of using the right terms which reveal your true architecture? This is one big reason why people have fights and grudges about if MVC is suitable and what not: because they don't understand the terms, and believe the architecture is inappropriate. Then they proceed to reinvent MVC with their own terms, and call it other names, like say Facebook's Flux. Terms of the trade are important ;)
What GUI are you using (if any)? The official "Git GUI" which is written in tcl/tk? Git-extensions? Smart Git? A web based one?
I don't generally use a GUI. I use source tree occasionally, when I want to look through commits more easily or something. I doubt that will ever really change. I tend to choose command-line tools over GUI stuff.
Cant really blame them though. JIRA isnt a bad platform but its also Atlassians cash cow.
If I recall properly, Symfony wants you to create an AppBundle for all the general things you may have: http://symfony.com/doc/current/best_practices/business-logic.html#storing-classes-outside-of-the-bundle
What happens to the data that is edited by the live systrm while the migration is running ? If there are no locks the scrnario when the row you alreafy migrated is being edited in the original table is possible. Thus you may lose data.
This is awesome! Haven't actually looked at the project as github is not accessible, but I'm really glad someone is making this available to the PHP community. I started work on a PHP library for this some time ago, only got as far as about 200 LOC. I called it [arctic tern](http://en.wikipedia.org/wiki/Arctic_tern) :)
Could you explain this part a little more: &gt; The objects should just see their objects, not that array where they came from. You have class 1,2,3,4 all in separate files. Class 4, requires 1,2,3. What's the best way to give access 1,2,3 within 4?
Thanks for sharing this! I hope to see this connected to doctrine schema update one day :)
I used PHPMailer's IsSMTP() and it worked out fine. Only took a few mins to implement. 
Exactly. This port of LHM to PHP has the exact same limitations as https://github.com/soundcloud/lhm in regard to remapping data. What might be easier in this case is to add the new columns then have a script remap the data once the table has been migrated. You would end up with a table like this: id integer PRIMARY KEY AUTO_INCREMENT json_data TEXT, some_integer INTEGER, some_string VARCHAR(255), etc. Then run your data mapping script to move json_data into some_integer and some_string. EDIT LHM was built by SoundCloud and is used by Shopify + many others. In high load production systems with multiple servers accessing the database dropping a column + mapping to new fields isn't really doable due to the distributed nature of the system. While your API / web front end / back end are being updated to the new version of your software dropping a column would have disastrous effect until all systems are synchronized.
For a small number of dependencies (typical for lower level components): class 4 {__constructor(1 $a, 2 $b, 3 $c) {}} For a large number of dependencies (aggregator components, modules, configurable apps): interface 4Context { get1(): 1; get2(): 2; get3(): 3; } class 4 {__constructor(4Context $ctx) {}} The latter you might notice is slightly like Pimple, in that you pass in a "container" and then 4 needs to call methods on it. But there are three crucial differences which change the whole dynamics of the solution: 1. Look, mom, no container libraries. We're using plain PHP interfaces and classes. It's fast. 2. Type safe. Your IDE can do autocomplete and show errors whenever you violate the interface. Less bugs and less checking of docs and endless YAML and XML configurations. 3. This is the biggie: interface 4Context is created and maintained together with 4, and contains EXACTLY what 4 needs. Nothing less, nothing more. While Pimple is global, and you can "steal" someone else's dependencies, only if you know their name. The problem with global containers, versus per-class contexts is that global containers make apps monolithic and it becomes hard to enforce architectural boundaries, because if someone is on a tight deadline they might quickly "steal" the PDO instance from Pimple in a component that's supposed to never run raw SQL queries on the database.
Containers are good for application-level code when you need to instantiate many high-level dependencies. For regular code "natural" DI is sufficient.
Thanks for your reply. BTW another approach could be a service-level write lock, where the service enters a "voluntary" read-only mode in which it services all queries, but commands are either queued for later, or denied. In this mode a single worker with the implicit "write lock" can migrate the table, using all the logic the service has access to. In the mean time users have full read access to the service, but can't change anything.
I had my first day at a company that uses JIRA today. Coming from a company that uses Bugzilla, I'm frankly impressed. I'm pretty far from well-versed yet, but it seems like it can be very powerful if you know what you're doing.
I was surprised to see there was no tools like LHM for PHP. Facebook released theirs but it seems overcomplicated. We had a LHM proof of concept in PHP + phinx in about 20 lines ( setup triggers, setup new table, rename tables, drop triggers ). Phinx ( https://github.com/robmorgan/phinx ) allowed a quick port of LHM
That would probably work if your service availability can support read-only for n minutes. This also means your application needs to learn how to cope with locked tables. 
&gt; the online API documentation had full source code rather than just method definitions You're right, it used to be like this but changed a few months ago. Jumping into the source method was really handy, and it's a shame that it's gone. 
Honestly if you know what you are doing it is awesome. Im not an admin but as a user its very enterprise ready.
Yeah I remember reading the source for the facebook tool, as I don't think they provided much in the way of docs. Phinx looks awesome, just haven't had a chance to use it for anything. I use a tool I wrote myself for the day job.
Submitted 2006: https://bugs.php.net/bug.php?id=39368 :(
You may have multiple containers in an application, at different levels. For example, a composer package could use Pimple to handle its own internal dependencies. The container wouldn't be "passed around", sure, but it does not have to be at the application root.
I wanted to stick to what was on the shirt but have it make sense.
BitBucket for pretty much all of my repo's. I use GitHub ONLY if I want something public facing for like a portfolio or something. And I only use GitHub for that, because it's so popular. I'd prefer BitBucker forever.
The article is ok, but one thing stood out: &gt; Because services are almost always unique from one another, it’s rare to see a service that extends an abstract service or implements in interface. Instead, services are “one off” objects. Well, that's hardly the case. There are services coded to a specific public API which is standardized, hence can be an interface. There are services implementing a specific internal interface as well (and we can use different implementations depending on the context). I'll just mention PSR-3, a Logger interface, and a logger is arguably a service. My services even have a dedicated interface about *which interfaces* the service supports. This and that protocol, this and that version of it. It may be rare due to logistical reasons to see most services coded to some pre-existing public API, but that doesn't mean we should define them explicitly as "one off" objects. There's no reason to. Especially as the number of services in a system grows, you want every service to support some common interfaces so you can learn more about a service, or use a "dumbed down" standard version of its API, even if you don't know the one-off one.
https://github.com/CakeDC/OAuth2
Another great tool that does something similar to scrutinizer (I think at least :S) is code climate. https://codeclimate.com/
Just out of curiosity - has there been an actual implementation of the "constant-time" or "not constant-time" exploit. I've seen the details but not an implementation.
No shit right? I'd like to slap that author with a rubber chicken. Over and over again. And again. Ok... done.
Both. Github for public stuff, bitbucket for my private shit (zsh, vim, etc)
CakePHP is still a thing?
Well, I think Laravel is awesome. It is the best of the frameworks I have used. I think their documentation is a touch weak though.
Yeah this should be part of your Nginx config when symlink switching. 
For a framework e.g. Symfony it makes perfect sense to be as vague as possible when defining what a service actually is, because it depends on your chosen architecture style. For example in terms of DDD; An infrastructure service e.g. "Emailer", "SmsSender" would talk to an external service e.g, SMTP, database etc so providing the plumbing. A domain service e.g "RefundProcessor" is a coordinator that would allow high level functionality within your domain. And an application services would translate messages from outside of your domain into processes inside your domain. What should hold true across these services is that a service operation should be stateless. So that you can stick it into a container and share it is just a side effect of being stateless. Hope it helped :)
Here is a image uploading site I made. The mvc part is wrong but you can learn from reading the stuff in php/models/ https://github.com/seth--/imgup Mime types and extensions are filtered, the file names are random and the images are saved in the uploads/ folder which is made inaccessible by a .htaccess file. I don't check file size or if it's a real image. Metadata is saved in an sqlite database and a cron job deletes old stuff. 
Thanks. Being stateless is an important point. 
&gt; I don't even know what the technical name for your logical fallacy is but with logical fallacies as deep as that you shouldn't be in the programming game. Don't you know? Programming is all about solving problems logically. Just because I suggested one program that does not mean it's the only one nor does it mean I am pushing it. Fine, let's apply some logic to this conversation. You said that people should use pcregrep instead of grep, and when I told you that I don't think most people use pcregrep or even grep for searching code for a string, you reacted by deliberately misquoting me as saying that my editor was shit and that this meant that I felt I could impose rules on everyone. I'd call that a bit of a logical fallacy, because I don't think I've said or even implied either of those things. Anyway, the fact that you did this in response to what I said, implies that you feel all IDEs and all text editors, including Sublime Text and Vim, are shitty, and that people should not be using them to search code for strings. I do believe I've seen you recommend pcregrep over grep, and maybe it's just my feeble, logically fallacious mind, but if I exclude all editors and all IDEs from the equation, grep/pcregrep is pretty much all that comes to mind in terms of tools a developer might use to search source code for an error string (edit: I guess you could do it with Git or some other VCS but I doubt if any of them have this feature).
"Wired up" is a good way to visualise it. The layers of injected objects behind the object you want to use, can go pretty deep, so it pays to not have to keep instantiating that stack over and over.
https://github.com/dmayer/time_trial
It's not hosted (or at least, doesn't have to be). I'm running it for internal APIs.
Useful write up, though I didn't know people didn't already understand this. Also, plenty of typos!
Did you check in the PMA options? I'm sure there is something in there.
I used it for a few sites, why the CI hate?
Will do.
[Makings the pull requestings](https://www.youtube.com/watch?v=zQSY98g1sA4): https://github.com/philsturgeon/philsturgeon.github.io
I've always said, especially in the case of PHP6 "Numbers are cheap. Don't be afraid to throw them away in the name of clarity"
While this is a nice library, and thanks for posting it, I can't help but feel PHP isn't a good place to manage your assets. All the good preprocessors for styles and scripts are either written in JS or Ruby and so piping them through semi-baked PHP compilers is a recipe for disaster. Of course it would be nicer if we could use PHP for everything in our projects and not have dependencies on other languages but I feel this is a war we're not going to win, and accept that asset management/optimisation is going to be done by a JS pipeline.
You can run command line utils written in JS or Ruby from PHP. Not that I'm so attached to processing assets in PHP either, but it really should be nothing more than a bit of overhead to make the shell call.
It's not necessarily a big deal in versioning but PSRs aren't all iterations of the same standard. They're differing standards from autoloading to code style to interfaces. And they're only going to get more crowded. Just imagine if variables were named like PSRs: $var0, $var1, $var2, $var3, $var4, $var7. It would drive most programmers mental. You'd be forced to memorize everything or regularly refer back to the source. Having a descriptive name is immensely more practical.
Security! Does it do only what it should? No exploitable vulnerabilities?
Something about how it still supports PHP 5.2, among other philosophies of years-old PHP. I don't quite understand it myself, built a couple perfectly serviceable not-quite-CMSes with it, but then I wasn't doing anything related to databases, or authentication, or anything else beyond "get a text file based on the url and template it".
Oh yes, it definitely is. You should check it out!
I feel like they should have used a form like PSR-000, PSR-001, etc. Maybe that would have stopped people interpreting the numbers as incremental.
There's a Symfony bundle that does this very well, provided you use symfony https://github.com/nelmio/NelmioApiDocBundle The design is inspired by swagger, so it might not be to your liking, but i find very efficient.
Cool!
When you select a file in a form, the uploads and stores into the server's temporary internet files by necessity. You may then read from that file and store it elsewhere. http://php.net/manual/en/features.file-upload.php http://php.net/manual/en/function.file-get-contents.php
I don't see how this is any worse than doing it in Ruby (which has even more overhead)...
You could use JS to read the file, and then do a AJAX upload with only the data needed
Actually this. Don't know why downvotes. Utils is the folder that is mentioned in best practices on official symfony site.
this
And then we can rename PSR2 to PSR-Shitstorm-Generator
I noticed yesterday that it already warns you when submitting, of packages that have the same name under other vendors. That's handy, just to check if someone has already submitted your package under their own name, to reap your package karma.
I noticed yesterday that it already warns you when submitting, of packages that have the same name under other vendors. That's handy, just to check if someone has already submitted your package under their own name, to reap your package karma.
I think of it more as a primary key. What it is doesn't matter, it just needs to be unique.
yup. you seem to miss the point. 1. you don't have to change your existing payload at all. you just add the context, which aliases your keys to the ones which have semantic values 2. you don't have to bundle context with the message. it can be a separate cacheable document 3. There are tons of existing RDF namespaces/ontologies out there and creating your own ones means reinventing the bicycle. just use what's already there
[**@SpotifyEng**](https://twitter.com/SpotifyEng): &gt;[2015-05-06 15:23:09 UTC](https://twitter.com/SpotifyEng/status/595972071609339905) &gt;[*spotify.com*](https://www.spotify.com/) is powered by the [@symfony](https://twitter.com/symfony) framework and many great packages from [*packagist.org*](https://packagist.org/) using Composer by [@seldaek](https://twitter.com/seldaek) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/35698v%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
[Reveal.js](http://lab.hakim.se/reveal-js) is a more popular, full featured alternative that also supports markdown slides. Why not just come out and say "hey guys, check out a summary of how great my framework is!"? You could have just linked to remarkjs.com and left it at that, but that would not conform to this sub's guidelines of posts having something remotely to do with PHP. Instead this comes across as an advertisement for your own content - 2 things that also go against this sub's [content guidelines](http://www.reddit.com/r/PHP/wiki/index).
CoffeeScript is on its way out replaced by things like TypeScript (Node.JS), so I guess that argument is no longer relevant. The best strategy is to be language neutral in your asset processing chain. Pick what's convenient to coordinate everything (PHP, Python, JS, whatever) and call the rest via CLI, pipes and sockets.
A no no? Then why are they now on regardless of the php.ini settings when before 5.4 they were off by default? Don't spread hyperbole and misinformation. Best practices recommends only using them in the context of an echo, but they are always available &gt; 5.4. Best use case is limiting this to templating variables, which is an ideal use, and why templating engines are superfluous in php. 
How did you concluded that they may open source some of their packages ?
https://twitter.com/SpotifyEng/status/596074150827024387
[**@SpotifyEng**](https://twitter.com/SpotifyEng/) &gt; [2015-05-06 22:08 UTC](https://twitter.com/SpotifyEng/status/596074150827024387) &gt; @pau1rw I think we have a couple things that would be fun to open source. They just need to be broken out to be an individual package ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
I've used SWAGGER in the past and I was really content with the results. https://github.com/zircote/swagger-php You can generate something similar to this: http://developer.wordnik.com/docs.html .
&gt;Instead this comes across as an advertisement for your own content At least he's consistent. 
What's the difference between a "custom test" and the kind you imagine? No testing library would actually write the tests for you.
I don't think he's going to re-add composer support. Even if he does, you should consider using a fork from a competent maintainer. Given his ignorance of composer, I seriously question his competence in maintaining a PHP package. &gt; I did not merge composer.json into this project. I have rejected requests to merge it into other projects I maintain in the past, for similar reasons to the reasons mentioned in this ticket (I do have a sufficient understanding of Composer to be confident that the support is correct) Not sure where this guy's been for the past 3 years.
The FUD was almost as good as php-internals.
The parser he implemented could be extended to compile PHP to raw JS, allowing developers to write client side in PHP (just like they do with DART/Typescript/Coffeescript). I don't see it happening though, because the lib required to support all PHP functions would be very intensive work to implement and having access to only native JS functions with the mild bonus of PHP syntax would be a frustration more than a tool. But realistically it's more a fun project, I think. Just like [this x86 computer emulator written in javascript](http://bellard.org/jslinux/).
There was nothing else at the time, and they're moving to some hhvm/hack thing they made themselves. If they started now, there would be a number of choices. An equally valid one might be starting with python or ruby and moving to java as they scaled up.
http://laravel.com/docs/5.0
Often reappearing bugs != code quality?
&gt; https://github.com/nelmio/NelmioApiDocBundle That looks helpful. Thanks!
Oh come on ... I can seriously strip everything pixie related from this and repost 
Let's implement that as a rule for all your future posts as well. 
Ty for your feedback. However, it seems like you missed the point behind the article :P 1. "don't have to change your existing" ... "just add the context". That was my entire point. We don't have to change the column names in JSON-LD. However, it was one of the suggested ways to implement the LD standard according to the spec. I even wrote that it is not necessary. I will make sure to edit that part and make clearer. However, we do need to add the @context object. Which is a huge bulky schema information object. That in itself is a change to the payload. 2. The problem then is that as a user of the API, I cant validate the integrity of the data at the same time as I get it. I would then instead need to grab that other document and compare the two. Besides, a cached schema document is a no-no for me. Especially with the type of APIs that I work with. 3. "There are tons of existing RDF namespaces/ontologies". That's actually the problem I was trying to get rid of. Centralize them all and have one std library for everything to derive from. That way, I can look up the std/event namespace and all of its children right on the official standard manager site. In addition, that would allow us to create validation tools/mechanisms that verifies the integrity of the data + schema.
I am ok with this example; he's using his content, yes, but showcasing it through the tool he's sharing. That said, this isn't PHP-related so I'm waffling on removing it for that reason. General webdev stuff should go in /r/webdev
So? It's consistent slop everywhere. And I'm pretty sure the Windows app is mostly just loading HTML into itself.
If a native app crashes while interacting with a PHP-based API, then it's a problem with the app, not the API, since it should have ways to handle bad/no api data.
I don't understand why you guys are over analyzing this. All their software seems to be coded like crap. All of their developers probably report to a head IT person. It was surprising to me that they did something right for a change. Why is this so hard to understand? Do you work for Spotify or something?
What if up until now two separate projects are using the same vendor ? 
Often reappearing bugs != code quality ? sometimes true : sometimes false teehee.. 
Well that's more to do with their Javascript development than their PHP development.
It's really rather simple: It's coded in PHP, therefore it's coded badly. /s
Indeed [Gentlemen, you had my curiosity… but now you have my attention](http://i.imgur.com/gQAXF5H.jpg)
Please do not write articles like this and post. This serves nothing. It's too short with vague statements. There isn't a single example.
&gt; So why not use something like a @namespace key/value pair that looks up the data-structure in real time from a centralized source regardless of what endpoint it came from. Couldn't you just look up the schema file every time you encounter a new schema? Is the only value the reliability of JSONPAC as opposed to other ontology providers?
http://www.reddit.com/r/PHP/comments/33x8w7/jphp_yes_its_what_you_think_it_is/cqphsev was this inspired by my comment?
Ofc you can. That part is mostly identical. However, you get a few more benefits by approaching it this way: 1. Documentation. If all API providers use JSONPAC, then we would have a centralized object documentation which works across all APIs. Each API can ofc have its own documentation like they currently do but it would be nice to have some sort of organized and reliable object documentation that is decoupled from the API service itself. 2. It would be rather easy to generate object inheritance maps for analytic purposes for the entirety of the network of APIs. 3. By encouraging everyone to use the same namespace provider (JSONPAC), we could build tools that extract data from APIs without having to write any logic. I gave an example of that in the article with the JSONPAC-TOOL extract function. We could later on take that extracted data and refactor it with something like Fractal. Imagine a use case where you want to extract every performer's name from an event API. Currently you have to do "for(...) response.data.events[i].artists[x].firstname"... Instead, you could standardize tools to extract the Alice/artist.firstname field. The tool will handle the logic of extraction and return a valid dataset the matches the field type by simply doing all the recursive looping for you via predefined schema. 4. Reliability as you mention 5. Most importantly, JSONPAC could help search engines understand APIs way better than they currently do. Schema.org/Person means nothing to Google. However Alice/event --&gt; Bob/event --&gt; std/event tells Google how all these services are linked together in a sense (--&gt; means extends here). + a few more things. 
The desktop apps are written in python aren't they?
Unit testing by definition means testing a unit of code (method/class) separately from all others. If by legacy you mean that it is a procedural mess, then unit testing is probably not the way to go. You could still use PHPunit + something like Guzzle to functionally test your application. Think about it this way: unit testing means testing each part of a car engine. Functional testing means testing the entire engine without knowing how its parts work. I do not know of any tools that can unit test something that is not divided into units. However, functional testing can be easily done on most (if not all) applications regardless of code base.
&gt; If by legacy you mean that it is a procedural mess I just wanted to remark OOP is just as prone to a mess as procedural, so let's not pile on good ol' procedural :P
Hey, I love procedural scripts. They have their special place in my tiny black heart! O.o
One of Python's strongest selling points is an even greater versioning rift than PHP7 is introducing. "Should I use Python 2 or Python 3?" is the great unanswered^* question of our time. ^(* Unless you count "Use Go or Node" as answers)
&gt; It still frees up the application to do other things so for I/O bound stuff I understand what you're effectively trying to say, but please don't confuse parallelism and concurrency. And don't conflate the two directly with threading or multiprocessing either. They're not the same thing. &gt; Python is duck typed, so it's classes kinda are the interface (although obviously unenforced at the language level). You can easily use duck typing in PHP too, as it doesn't require any sort of type-hinting. The beauty of PHP's OOP model is that you can make it as weak/dynamic or as strict as you want, supported by both the language and the engine.
This destroyed Perl too. Makes PHP7's lack of big BC breaks seem quite wise.
What you're looking for at this point are "characterization tests." The idea is that the units, such as they may be, are not testable in isolation. However, the *output of the system as a whole* is testable. For a characterization test, you: 1. Run the system with inputs/conditions of your choice and retain the output (e.g., the output of a page). 2. Make a change. 3. Run the system again with the same inputs/conditions and compare the new output to the old output. If they're they same, the test passes! You can do that kind of thing with PHPUnit and some imagination; I presume something like Behat or Codeception would work as well, though I have not tried them. If you're interested in modernizing the legacy mess, you might want to check out my book [Modernizing Legacy Applications in PHP](http://leanpub.com/mlaphp). Good luck!
&gt; essential That's debatable, I think it's more important that classes, functions, pretty much everything are first class citizens than making a attribute/method that can't be accessed outside of the class (which it's gonna end up getting all kinds of modified anyway, access modifiers are dated concepts with diminishing utility by the day.) &gt; In contrast PHP has a thread safe and non-thread safe builds, Well if we're gonna go that far for a counter I'll counter/counter with stackless Python. In vanilla Python It's not true multithreading, but it actually provides everything you want from it i.e. freeing up your application from heavy I/O blocking and for everything else there's multiprocessing. &gt; not "minor nice to haves". KWargs are great advantages. Slicing syntax is only one example from a literal list of things that Python does that makes working with strings and data structures easy. &gt; what can you do with a module you can't do in PHP? I can drive a car while doing a headstand too, just because you can arrive at the same result doesn't mean one way isn't entirely easier than another.
have you upgraded to the most recent version?
&gt; I think it's more important that classes, functions, pretty much everything are first class citizens than making a attribute/method that can't be accessed outside of the class OOP is a set of practices supported by a set of features. You can't just decide classes being first class citizens is more important than basics like encapsulation. Encapsulation is the very reason OOP came to be. And type safety *is* essential for large codebases where "code contracts by Skype chat and mailing list" is not a suitable approach to collaborating developers. Also without type hinting, IDE support for error detection &amp; autocomplete ends up very weak. &gt; It's not true multithreading, but it actually provides everything you want from it i.e. freeing up your application from heavy I/O blocking and for everything else there's multiprocessing. You can do the same in PHP with async I/O without wasting threads. Threads are a poor man's solution to I/O blocking and it doesn't scale (compare number of async sockets you can have versus number of threads). &gt; I can drive a car while doing a headstand too, just because you can arrive at the same result doesn't mean one way isn't entirely easier than another. Yes, so what is harder in PHP regarding modules? You're still dancing around it.
&gt; I ended up updating to the latest PHP7 nightly snapshot (mine was a month old) and restarting all the services. Still don't know why it decided to stop working. The fact you were using an unstable *alpha version* of PHP was a little detail you forgot to mention in your original post :P
I upgrade every time it asks me to, yes, on my mac, my pc, my iphone, and tablet.
Well, every time I mention that I'm using the PHP 7 Built In Web Server for a production site, I get an astonishingly negative response. However, I've got better performance using just the PHP built in webserver than any other web server on Server 2012. Also, it was working fine, then I updated a few wordpress plugins and started getting these damn errors. These are files that shouldn't be affected by a wordpress plugin.
I fear PHP7 introduced enough hurdles nonetheless. Looking at [the stats](http://w3techs.com/technologies/details/pl-php/5/all) and all but 5.3 hovering in the negligible area, we're likely facing 5 years for a significant rollout. Pulling a Python 2.7 here to emotionally ease the transition could still be necessary.
&gt; Not having to worry about global name collisions is one of the more important things. And many of the issues cascade from there. We have a namespace system and a standard PSR-suggested Vendor\Project\Component namespacing convention. I don't "worry" about name collisions. I never have, and I never had a collision. Do you? That'd be weird. Because even in the most unlikely scenario of running code from two identically named vendors with the same project and component name, it's very easy to change your namespace without breaking any of your code. &gt; Of course Python OOP has encapsulation. It's not enforced at the code level so it does rely on everyone playing nice; The thing is though every language requires everyone to play nice. How do you implement private members in Python? __mangling? Well that doesn't take in fact modules, so it still collides. Now you have to worry about name collisions in Python. Irony. &gt; Yuck, flashbacks to Node.js. Event loops are nice in theory but make buggy, hard to grok code once you add any kind of complexity to it. At this point we're moving to discussing personal limitations and that's not the point of the debate. Countless people are writing async IO every day and have no problem with it. In Python I'd choose async as well if I want concurrency.
The culture around Python is more accepting of installing modules/libraries/extensions that are written in C. This is pretty important for taking advantages of good C libraries out there.
&gt; Well, every time I mention that I'm using the PHP 7 Built In Web Server for a production site, I get an astonishingly negative response. Yeah. I'll bite and assume you're not just trolling. It's not intelligent to be told why you have issues, and react by continuing to post about issues while hiding the reason for your issues. It won't solve your issues. BTW your benchmark is off. The built-in server is single threaded. So its performance is an order of magnitude slower than production-ready servers like nginx and apache.
&gt; Smalltalk doesn't have those features either. It's a bit hard to claim a feature is "essential" to object-oriented programming when the language developed by Alan Kay doesn't have it. The man literally invented the term. You're confused about the terminology. Yes, Alan Kay invented a style of programming he called "object oriented", but it has since evolved into what we know today as OOP, and Alan Kay's original more general style has been given a new name called "actor model", coined by Carl Hewitt and the spiritual successor to Alan Kay's philosophy. Actors are often implemented functionally or OOP inside, but Like Alan Kay's objects the focus is on the message passing semantics and not on the nature of the object itself. Still they do enforce encapsulation by responding only to messages they want to respond to in the public and not to message calling their guts. See, everything has a name and there's no confusion. BTW1, Alan Kay's objects are also *asynchronous* (and so are actors). BTW2, Smalltalk uses a convention to put all its private methods under name "private". For the first ever language with objects, that's a reasonable approach. They were still discovering things, and SmallTalk has remained mostly an experimental language. In 2015 for a production level language it's not. At least not if it wants to claim it's OOP. &gt; Pass a module into a function. hello($module); &gt; Return a module from a function. function hello() { return new Module(); } &gt; Import a module within a scope without polluting the namespace outside that scope. Well I prefer dependency injection so I don't import modules at all! I just "ask" for modules $module and that's scoped to the method argument where I ask for it. Very much scoped. That said when you "use Foo;" you don't pollute the namespace, it's *file scoped*, which is also *a scope*. It feels like you don't use PHP much. &gt; Write a file that executes code when named directly to the interpreter, but not when imported as a module. I'm totally missing the use case here. It's more of a quirk Python supports because it uses "modules" where classes would suffice. What is the use case? &gt; Introspect on module contents. $reflClass = new ReflectionClass(Module::class); &gt; Write a module in native code and dynamically load it without fucking with php.ini. Sure! http://php.net/manual/en/function.dl.php Of course you realize why dl() is not a great idea when running thousands of requests a second in a web server. That would be stupid in any language, including Python. But running in CLI? Have at it! 
You're right, but the latest docs are not so good as Ellislab's docs used to be in previous versions
I visited their careers site, nowhere does it say they use php at all. I think they're a python / java shop.
&gt; I fear PHP7 introduced enough hurdles nonetheless. Like what?
Make a browser-automated acceptance test first, refactor your legacy code, make a unit test for the new code. If the original acceptance test still works then you've done it right and didn't break your site with your changes. We use [Codeception](http://codeception.com/) at work for functional, unit, acceptance, and 3rd party integration testing. I can't recommend it enough. Codeception is built on top of PHPUnit, so you can still use the unit test syntax that you're used to, though they do add a few extras into the mix.
&gt; You might think that, but nginx and apache run like crap with PHP-FPM. Incredibly slow. The problem is your configuration. Not the servers. You should fix your config, or ask someone to fix it for you, because what you do is reckless. It's like taking painkillers to treat a massive heart attack. &gt; Except saying "HURR DURR IZ CUZ UR USIN DA BUILT IN WEB SERVER" isn't "being told why (I) have issues" Is that what I said? Dunno maybe change your glasses? You don't have to identify so closely with your choice. Be open-minded, learn a little. People, me included, are telling you what you do is a bad choice, because the built-in server is both unsuitable for production for security reasons (it has NOT been vetted for security!) and for performance reasons, because as I said it's *single-threaded*. Which has a massive effect on both CPU bound apps and IO bound apps. Those are facts. And running alpha bits should be obvious why it's bad. I mean you're looking at undefined behaviors, random crashes and in this case random characters at the end of your includes. I follow PHP7's development and there's an astounding number of problems left to resolve before it's production ready. This issue you were having would have NOT happened if you would simply fix your server config and stick to a stable release of PHP 5.6. Oh also, HURR DURR TA DERP? DERP. Have fun.
I know, it's weird that php is no where to be found on their career site. 
I am accepting pull requests on my project Atlas. http://github.com/alexbowers/atlas It is a framework agnostic way to deal with Courier services (UPS, FedEx etc)
Can you guys relax? All I said was with the consistent flow out crap that comes from Spotify that I am impressed they did something right. [There are definitely thousands and thousands of users experiencing the same issues that I do.](https://www.google.com/search?newwindow=1&amp;safe=off&amp;espv=2&amp;q=spotify+freezing&amp;spell=1&amp;sa=X&amp;ei=W_9LVbySL4LjoATM64GoDg&amp;ved=0CBsQvwUoAA&amp;biw=1559&amp;bih=826)
&gt; We have a namespace system and a standard PSR-suggested Vendor\Project\Component namespacing convention. Yes you do. But that doesn't mean it has to be used (also it's really ugly). With modules this is the default. It's a big deal with larger teams especially, and oh god wordpress, back in the day anyway. &gt; How do you implement private members in Python? __mangling? You don't. Even with \_'s every member can be fucked with with enough effort. But this is, in general a really bad idea so it really doesn't happen (double underscores are usually reserved for python internal stuff, anyway). No language construct necessary. Again, it would be *very* nice to have, but in the end it's a very small problem that modern Pythonic coding practices have kinda eliminated anyway. Non-constant, immutable attributes are kinda a strange thing to see in a modern Python class. If you really really really don't want someone fucking with a method you can just override __call__ to double check where it's coming from, but again honestly like strings of private methods probably means you have an over complicated design and if you make your API obvious enough (via documentation and good naming) people are naturally gonna flow to the point of least resistance anyway (We don't *want* to fuck with your plumbing methods unless we have to). The world has moved on, there's literally an entire internet's worth of information for you to digest and form a more informed opinion. The argument "Well we can do that too" rarely amounts to much.
 mt_rand(1,10) === 4;
In what sense? An inefficient system can still be perfectly usable, after all. It's why the US system of weights and measures keeps trucking on. I'd argue PHP's named RFC system it much more relevant to the issue. When you see something like [rfc:scalar_type_hints_v5](https://wiki.php.net/rfc/scalar_type_hints_v5) it's not only clear what it's about, but also which iteration it is. RFC-273 wouldn't have been nearly as useful.
Online courses/tests
😀
Who pissed in your cereal this morning?
&gt; How do you implement private members in Python? Why do you need private members? Why is it so important? If you really think about it, you will find that it does not hold much value other than to differentiate from an objects public methods. A way for a programmer to say that, 'these are the methods you are supposed to call, these are for my own use'. So python, instead having private members, decided to use convention and denote them prefixing with an _. The point is that, I don't want to enforce this rule. I just want a way to convey this info and convention will do a good enough job at that. Your problem is that you are trying to write PHP in Python. EDIT: For clarity.
&gt; Why do you need private members? Why is it so important? If you really think about it, you will find that it does not hold much value other than to differentiate from an objects public methods. Name collision. You can't prevent name collisions in child classes by convention. The private properties in a superclass may change in a patch version or a minor version and all child classes MUST work in a backwards compatible way. Except if you go by convention like "_property" you risk collision with an already existing "_property" in a child class, resulting in very subtle but potentially really bad bugs. Actually I said you can't prevent it by convention, that was a lie, you can do what I suggested up there: 1. Use double underscore to use Python mangling (internal mangling prevents same-property name collisions). 2. Include the vendor name (prevents same-class name collisions). 3. Include the module name (prevents same-vendor name collisions in different modules). So, sure, it's not absolutely necessary, if you don't mind typing __vendor_module_property for every private property. How many people do that? In the PHP community we do religiously include Vendor\Project\Foo in our namespace. Do you do that for private properties as the norm? I've NEVER SEEN THAT. BTW internally private properties in most languages are implemented precisely in the above way. We type "private foo" but internally it's mangled to "private.namespace.classname.foo" ensuring it remains unique when it gets compiled away as a tuple offset in the object at a lower level. When the compiler can assume the prefix for you, it's kind of dumb, I think, to do it manually.
&gt; I've yet to see a meaningful, or logical, argument as to why Python (or Ruby) are objectively better than PHP. 1. Less (an understatement) weird behavior and sensible, helpful use of types. In php ['0e46' == '0e83'](http://3v4l.org/3ILmt). This should be enough for any self respecting programmer to keep away from this language. You can use strict comparison but then 1.0 !== 1, so you see, you cannot just do the right thing with PHP. 2. Pleasant readable syntax. 3. Helpful standard library. (Try using the Python os.path functions vs what php has to offer natively) 4. Modules as opposed to primitive auto loading build on top of laughable include functionality. (Yes let use just pretend that this file is inserted in the middle of the current one) 4. A great community that actually works together. EDIT: Decorators (setter and getter decorators are great), Descriptors (reusable automatic type check every time when a property is set without having to write explicit setters) 
Maybe, but let's take Javascript, which supposedly has a better standard library than PHP does. I can NEVER remember whether I call array.length or array.length(). Sometimes things are properties, sometimes they're functions. Python has `len()` which is no better than `size()` or `count()` (abbreviations are stupid no matter what language they're in).
So what happens when Post in one module extends Post in another module and they both have "__foo"? Try it.
While your comment is clearly a personal opinion I'd like to let you know about some inaccuracies in what you are saying. Composer autoloading is quickly becoming the standard for any modern php development. Composer has had an [optimize option](https://getcomposer.org/doc/03-cli.md#dump-autoload) on its autoloader for quite a while now and is one of Symfony's [Performance Recommendations](http://symfony.com/doc/current/book/performance.html) As of php 5.5 there is a [built-in Byte Code Cache](https://php.net/manual/en/intro.opcache.php) which also helps with autoloading and performance in general. When you say it is slow I'd ask compared to what benchmark? How fast does python load its classes? The argument that php class loading is slow doesn't have a context and there are many ways to load efficiently. php will not let you know that you've made a typo. This is correct however if you try to use a class and mistype the namespace or mistyped it in your declaration you **will** get an error that the class you are trying to use does not exist. If you are not seeing this error you might want to checkout your [error display settings](https://php.net/manual/en/function.error-reporting.php). The one class per file does not make splitting code out more difficult if anything it makes things easier to read and use. Though it you don't really like it the 'one class per file' rule is more a [guideline than actual rule](https://www.youtube.com/watch?v=jl0hMfqNQ-g) [PHPUnit](https://phpunit.de/) and/or [PHPSpec](http://www.phpspec.net/en/latest/) make mocking and unit testing extremely easy (I'm not sure what your point about a DI container has anything to do with testing). Personally I think the misunderstanding comes from the fact that you are equating namespaces and python modules. They are not the same thing. Namespaces main purpose is to avoid class name collisions (and with the PSR autoloading standards they help with autoloading files as well). The fact that people have used the same namespace to hold code that is similar is just good code organization. You can only 'use' (read as import) single classes not entire namespaces which is a key distinction between namespacing and loading modules. PHP is not as bad as you think and certainly not worse than [every language out there](http://compsoc.dur.ac.uk/whitespace/)
You are going to extend Post and call the subclass 'Post' itself?
You're right, the cognitive load does add up, but I feel in comparison to the logic needed to implement complicated business rules in a maintainable, flexible, change-friendly way is so much more cognitive load that the standard library weirdness is barely noticeable - the light of a planet lost in the host star's glare.
One thing python (and Perl too) has that we greatly miss, IMNSHO, is that a lot of linux packages use it, so python is way more mainstream than PHP. That's one of the key points we should focus in the near future, invest in making PHP a ubiquitous language, simply present because it's needed to run useful and resourceful applications on specific operating systems. It might play a difference in the long term future of the language itself. As of the next major, I strongly believe PHP7 will be the greatest major that ever happened to the language since PHP5. * jsond should make the "license loudmouths" quieter. * STH + Return Types + Engine Exceptions should make the "type loudmouths" quieter. * The performance boost should do the trick to everyone else. I might be wrong, but I'm hopeful.
&gt; Then why do you have one class per file convention? I *want* one class per file so that I know what's in a file when I see it in my file system browser, or so that I know where to find the file when I need to open the class. I think I would lose my mind if a file could contain any arbitrary set of classes, where it's name doesn't accurately reflect what's inside of it. The fact that autoloading requires PHP's classes and file names to be identical creates structural consistency, which is a HUGE asset. &gt; And why you do you need to put everything inside a class and put that class inside a namespace (Manually no less) Don't you have to do this in Java and C# too (and even if you don't, every example I've seen from these languages does it this way)? Do they get a pass while PHP doesn't? I know this issue is about PHP vs Python, but you can't rip on PHP for these things without ripping on other well-praised languages that do the same thing. &gt; don't you think that not having to trace the curly braces will improve readability? I think tracing indent levels is worse, as you need line guides to know what nesting level you're in. Of course, it really depends on how defensively you're programming. If you've got [arrow code](http://blog.codinghorror.com/flattening-arrow-code/) in either Python or PHP, you're gonna have a bad time tracing where you are regardless. If you flatten it, indents vs curly braces are a non-issue. &gt; PHP the has the PATH_SEPARATOR constant, by Python has dedicated function for joining paths. I think the latter is the better solution. You can use '/' in any OS except for very old versions of Mac and Windows. Arguably that makes PHP better at handling paths since you can just native OS directory path symbols instead of a function. DIRECTORY_SEPARATOR is antiquated and unnecessary.
&gt; the opposite way on purpose for the lols:.. The point simply is that you has to THINK which is the right way for something as simple as an equality check. And you have no way of knowing the right way until you know all the possible values of the operands before hand. Do I want to use type coercion here, do I expect string values that can be interpreted as a number here etc etc. &gt;And you can implement Descriptors trivially in a trait and then just do stuff like:.. I don't see how that trait can work because $foo is public and wont trigger a set or get magic call (which proves that it is not trivial at all). Anyway the point is that it is not built in and hence does not have standardization that is a must for things like this. 
&gt; I don't see how that trait can work because $foo is public and wont trigger a set or get magic call (which proves that it is not trivial at all). Wow you give up so easily: unset($this-&gt;foo). I can tell you why I declare it (even if I don't have to) - it's a chance to provide autocompletion and PHPDoc documentation which the IDE and users will see, and that's very nice for libraries. There are also more advanced reasons for this technique, but I don't want to confuse you, so let's stick to basic usage. The above code sample is something I have and use in my own library. It's not a theory, it's real. &gt; Anyway the point is that it is not built in and hence does not have standardization that is a must for things like this. Yeah, why is it a must for things like this? As you see, it's doing just fine like it is. 
Sure you can, if the "features" they demand are well supported by the existing code base. That isn't to say that the back end is sacrosanct, but if the demands of the marketing group aren't feasible given the existing back end codebase, then the new features should be phased in more slowly, not rammed through and damn the consequences. 
&gt; I want one class per file so that I know what's in a file when I see it in my file system browser, A unit of functionality != one class. When you see a file, you should know what part of the app is present in that file. It does not necessary mean one class. Because a piece of functionality can be split as a combination of modules classes and functions etc etc. And sometimes it makes sense to split them further into separate files and sometimes it doesn't. With php you don't have the option to not split it into separate files. Need a new exception, yea that is right. Make a new file with all the namespace baggage and all...And one typo, and good luck catching that exception. &gt;You can use '/' in any OS except for very old versions of Mac and Windows.DIRECTORY_SEPARATOR is antiquated and unnecessary You still need to worry about that when you deal with functions that return paths. Also Linux file names can have backslashes in them...
So, you want to replace decentralized self-bootstrapped system with a centralized one? Also, did you see schema.org?
It's not a direct answer to your question but we have a bunch of ["easy-pick" issues at Couscous](https://github.com/CouscousPHP/Couscous/issues?q=is%3Aopen+is%3Aissue+label%3Aeasy-pick). That's a good way to get started to contribute to a project. There are also people hanging in the Gitter channel so you can get help easily and slowly move to contributing more seriously.
&gt;The problems you listed either weren't there, or you weren't aware how PHP solves them. Oh they were. Those are real problems for me. It may not be for you. That is quite fine and I understand. Let us move on.
&gt; Yes, I am. What's the problem... Nah man. No problem. You win.
wait waaat?
I think you're overlooking the fact of simple diversity of opinion. PHP was really early to the web dev scene, other languages didn't get there until someone took the time to write a framework, then that framework became the dominant "method." For example, in Ruby, you don't need a site to go over this, because Rails IS how you do things, and there is a "rails way." This just doesn't exist in PHP, and IMO, thankfully so. We have a lot more diversity and people trying different things than other languages. This pushes us forward and keeps the community relevant. With respect to simple best practices and general knowledge, I fail to see how the numerous tutorials, webcasts, etc, don't achieve this.
Well that's just sad.
I disagree with this article. It's not the PHP community that sucks. The complaints around W3Schools and the high availability of poor tutorials (mysql_* and others) is a hard problem to solve. There are some really great resources out there, but unfortunately they get drowned out by the sheer number of copy-paste blogs that exist (blogs where people who frequently have no idea what they're talking about simply copy-paste articles from elsewhere). Because of the way the Internet works, there's unfortunately no way to label these sites in such a way that the poor newbies finding them will know how terrible they are (when these get posted to this reddit, I do post comments on the blog articles, but I highly suspect they never make it to the public comments due to the fact that the blog owners will simply delete / filter negative comments). There are already a number of resources such as [PHP The Right Way](http://www.phptherightway.com/) and [Awesome PHP](https://github.com/ziadoz/awesome-php) that provide curated lists of resources.
Facebook actually...and then http://phacility.com/.
But is it as fast as [FastRoute](https://github.com/nikic/FastRoute)?
Yes, it is slightly faster. When routes are cached is much faster. See benchmark results in github readme.
as i said hard to explain but i'll try let's say my database table has id, product_id, product_name, product_price, order_id The edit order page has a div with products listed, with product name and product_price as textboxes so they can be edited. something like this: &gt; &lt;td&gt;&lt;input type="text" name="product_name[]" value="Product name 1" product_id="product_name_id_1" /&gt;&lt;/td&gt;&lt;td&gt;&lt;input type="text" name="product_price[]" value="100" product_id="product_name_id_1"&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="product_name[]" value="Product name 2" product_id="product_name_id_2" /&gt;&lt;/td&gt;&lt;td&gt;&lt;input type="text" name="product_price[]" value="100" product_id="product_name_id_2"&lt;/td&gt; This list can go on and on depending on how many products are in the open order... What's an efficient way to save this back to the database when Submitting the form? 
&gt; What's an efficient way to save this back to the database when Submitting the form? You open a transaction, run a bunch of UPDATE queries (one per row) and commit the transaction. If you use an API which allows multiquery you can also send it all in one go (still as one update per row, but one exec() call).
That's interesting! Please would you blog about why it is faster?
When this table is submitted the table will obviously not be a table anymore. It'll be a bunch of fields. I recommend you structure it like this: &lt;?php foreach ($products as $i =&gt; $product): ?&gt; &lt;tr&gt; &lt;td&gt; &lt;input type="text" name="products[&lt;?= esc($i) ?&gt;][name]" value="&lt;?= esc($product['name']) ?&gt;"&gt; &lt;/td&gt; &lt;td&gt; &lt;input type="text" name="products[&lt;?= esc($i) ?&gt;][price]" value="&lt;?= esc($product['price']) ?&gt;"&gt; &lt;input type="hidden" name="products[&lt;?= esc($i) ?&gt;][id]" value="&lt;?= esc($product['id']) ?&gt;"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;?php endforeach ?&gt; This way you'll have a list of products submitted to the server, exactly the way you get them from the DB. Notice the hidden field that gives you back the product id. It doesn't matter where you stuff it, in fact it doesn't even have to be inside the table, but anywhere is fine (it's hidden after all) Also notice the esc() function (which you can implement with htmlentities() internally), although I'm sure you escape HTML content, but just in case ;) And then, sure, one update per product.
&gt; It is described in github readme but in general reason is that all routes are "converted" in tree like structure. Aw man, I thought I'm so smart to do that myself :P Kudos for thinking outside the box. In my case I went all the way and had the router *defined* as a tree so I don't have to convert it at all. It might be worth splitting your router in two: 1) Defining the tree as a tree 2) A builder who gets "standard" routes and defines the tree using the previous API This way you'll have less need for caching if you skip the "classic" routes step.
I agree with you completely, code was written for couple of hours just to prove the concept, make real benchmarks and to see what other people think about this realisation. 
W3Schools is still around because it's easier to read for people that haven't RTFM the FM. The php.net pages are very informative *once you've learned to decipher them*. The path of competence tends to be close to as follows: W3Schools type readable -&gt; StackOverflow Answers -&gt; able to grok PHP.net -&gt; Reading PHP Source The author is basically complaining about people at step 1 not being at step 3 when step three requires knowledge of not always straight forward language constructs. Now that isn't to say W3Schools isn't bad, it's to say that there's certain points where knowing the exact right way to do something isn't conducive to understanding it, the reason W3Schools gets traffic and keeps coming up is because it's built around being easy to understand as opposed to a technical manual. IMHO more languages would benefit from more things like W3Schools and less 'we already built it for you' force the newbies into packages approach (Ruby, Python, Node), the latter isn't beneficial to climbing the ladder of knowledge though it is more efficient. Also, I'm not aware of *any* language with a good set of tutorials on how to build frameworks for that language, the answer in *most* other languages is just *don't do it* and use Django, Rails, Scala, etc. Any semblance of consistent practices in that area in those languages doesn't come from standards or community it comes from mono-culture. At least PHP has a set of community standards and basic guidelines (most recently PSRs, though they're not the first) for some common practices, the only language that I can think of off the top of my head with a similar community infrastructure for developing frameworks is Javascript and iirc they don't have any sort of general guided practices. Am I really just completely unaware of something going on in this space in other languages? edit: Speaking of Security /u/TravenWest, you might want to look a your site's security, the SSL cert is compromised. 
Dear ahugesb! They can only use the trial version where is the code obfuscated. They can also use the self hosted version (blogbook.hu/auction) freely. Now I am developing the wordpess widget. This is news and not spam. 
&gt; STH + Return Types + Engine Exceptions should make the "type loudmouths" quieter. Nope
I was confused by the benchmark in the readme. Was this cached or not cached? 
I'm glad different approaches to routing are being explored. FastRoute supports caching, so I'm not sure why you aren't including that in your benchmarks. Furthermore, FastRoute has more features (constraining parameters with regexes), something I think you ought to include in your description if you're advertising with benchmarks. Also, the fact this library doesn't consider PATCH, DELETE or HEAD valid HTTP methods is weird. Lack of tests doesn't help either.
As I mention in comment above this code was written just for couple of hours to prove the concept and get some real benchmarks data. Library is far from ready and a lot of functionality is missing. Comparison to FastRoute is made to have some values to compare with, not to show that FastRoute is slow or bad. Actually FastRoute is a very good library and is used in Lumen. I do not include caching benchmarks for FastRoute, because I was not able to turn on caching and there was no clear documentation how to use it. And I was lazy :) With couple of words - FastRoute is production ready, battle tested library with very good results. PGF/Router is a prove of concept. 
/ is reserved HTTP character because it separates URL parts, and in REST world this is very important. I don't know major framework that allow using custom URL patterns with / For more information [Wikipedia](http://en.wikipedia.org/wiki/Percent-encoding#Types_of_URI_characters) and [rfc3986](http://tools.ietf.org/html/rfc3986) The nested part and subdomain routing are very tricky, I have no idea how can be implemented in current structure, but I think it's be possible.
For the record, FastRoute is not actually fast if you don't use caching. The setup work it does is more expensive than just using a naive loop-through-regexes approach. The non-cached variant exists only for testing and for use in high-performance servers that run on the CLI SAPI. You can find an example for how to use caching at the end of the https://github.com/nikic/FastRoute#defining-routes section.
You could try http://up-for-grabs.net
It being a reserved character has nothing to do with this, and a use case for capturing '/' is very simple: Assume you have a nested category scenario and your posts end up under categories/programming/my-post or categories/programming/php/5.4/my-post. Using such an approach to identify your post you need to capture the entire url after categories/ . With regexp its rather simple
I understand you wrong. I have not thought how this can be implemented. It is a very good point. Thank you!
&gt;&gt; Why is W3Schools still around? &gt; I don't know. Because nobody has `rm -rf --no-preserve-root /`d them yet.
I ment my own code. And yes I consider Symfony2 architecture to not be very good. Hence why it is slow as hell. I dislike Doctrine2 entirely. I wrote both a framework and an ORM without events, and can definitely say events are a code smell. Btw it's faster than Doctrine, support Mongo out of the box and build performent queries, and both have 100% test coverage. Here is a quickstart guide for the ORM: https://github.com/PHPixie/ORM/blob/master/examples/quickstart.php Which ORM have you written ?
&gt; I am all back end, and I can validate a form in PHP after it's submitted and put up error messages, so what if Javascript can do that in real time before it's submitted, "big fucking deal", right? But you'd never want to rely on Javascript validation. You HAVE to validate on the back end after form submit, and to save yourself from inconsistency problems, you ought to do AJAX requests back to the server on each field change if you really insist on front-end real time validation, but then you still need to do a final validation check of the whole form on submit anyway. &gt; Just because YOU don't need it does not mean it's an insignificant feature. And the flip side of that of course is, just because it's there doesn't automatically make Python better than PHP, or PHP a shit language.
Hey, now! I'm interested in a library that can do some cashing for me! :)
OP mentioned his aversion to trending repos in his post.
The only issue I see is with your use of semicolons. I noticed it in the very first sentence I encountered in your blog: &gt; An annoying feature of Magento in my opinion is when you visit the website; add things to your cart whilst logged in, but for some reason don’t checkout. I wasn't clear on what you were trying to say here, but I decided just to keep reading. Then the next sentence: &gt; If you were to visit the website again as a guest, add items to your cart and then login to checkout; you will notice all the items you previously added to the cart are all of a sudden re-added alongside your current items. In this case, you seem to be using the semicolon as a comma, although that still doesn't explain the first sentence. To clarify though: semicolons are not commas; they're more like less decisive periods. If you have two independent clauses that you want to connect, but you don't want to use a conjunction, and just using a comma would result in a comma splice, a semicolon would be appropriate there. Alternatively, they can be used instead of commas to separate items in a list, especially when some items contain commas. There are a few other minor grammatical issues, but nothing too glaring. Overall, it's probably above average for this type of blog.
Your code blocks aren't rendering correctly: http://i.imgur.com/UIkQuqs.png As for the writing, it's pretty good but you could go into more detail. I read through the Basic ACL Tutorial For Zend post and don't think you should skimp the details for the sake of brevity. Also, commenting your code would help out people who are unfamiliar with the system you're writing the tutorial for. Nice work so far, keep at it! edit: Looked into the code block rendering, it looks like it's being caused by the twentyfifteen theme's css. Line 404 in style.css these three attributes are causing it. margin: 0 0 1.6em; table-layout: fixed; width: 100%; http://i.imgur.com/ifsOaHX.png
Depends on what you're writing. If you're doing heavy math calculations or text processing or distributed processing, Python is going to be a better choice. But it's a better choice not necessarily because of anything intrinsic to the language (as much of a PITA UTF8 is in Python2 it is better than PHP's handling) but due to the ecosystem of developers. The packages for the above tasks in the Python ecosystem are _incredible_, well supported, and fully fleshed out due to Python's prevalence in the scientific and statistical communities. Not so say PHP can't do any of the above, it can, you'll just have to do the leg work as there probably aren't a lot of packages available to you. Similarly PHP isn't necessarily better than Python at web stuff intrinsically (use Flask+Jinja2 and uwsgi and you'll realize PHP's web edge isn't as large as you think it is) but because of its community it has a significantly better ecosystem around web related tasks. There is no _real_ hierarchy or ranking to programming languages in the same way you can't tell me Spanish is intrinsically superior to Norwegian. You're probably better off learning Spanish if you live in Texas sure but that "superior choice" is situational, not intrinsic. 
I have. Spotify would lock up playing songs a lot on Android. Never happens to me when I'm streaming from home using Plex.
It's confusing what your service is, and why it exists. Beyond the trendy blurry background with a giant headline, some some explanation would help. "The current status quo sucks because 1, 2, 3." "We do private plugin and theme updates, and now you no longer have to 4, 5, 6 instead you can 7, 8, 9." 
Cheers! Thanks for the hard work on phinx.
Thanks for taking a look and you make a very good point. I think adding a sub-heading similar to your second idea would fit nicely right below the giant headline. "We do updates for your commercial plugin and themes so you can stay focused on your product", or something along those lines.
In the other places on the page you've used semicolons, you also capitalised the next word which is incorrect.
I would say that the major advantage of python over php is in the interfaces it has with gui toolkits. You *could* write a desktop app in PHP, but it's going to suck compared to writing it in python. In the desktop app space, PHP is not really an option. Python is a pretty good option there.
If there are no tests right now then I would not recommend unit tests. Instead, I would advocate doing functional testing. I have used [Behat](http://docs.behat.org/en/v3.0/) for this and I think it does a great job testing the important parts of the system. Writing these tests first gives you some faith that the entire system is working as expected. Then, you can start refactoring and writing unit tests for the new code.
Seemed more like an observation than a negative statement. 
I agree with you on both points, but the question wasn't which is better, it's what advantages does Python have over PHP. Among the major languages there's not an objectively "best" language, there are only trade offs (and opinions). The "best" language is the one that best helps solve your problem, and even then there's often enough good options that it comes down to preference.
Um, OK. The search results issue is easy to fix. We just need to go to Google and ask them to manually reorder any page with the "PHP" keyword to our liking. That's a totally fair way of organizing search results (sarcasm). But seriously now, I agree that there are a lot of bad PHP tutorials, examples, and blogs out there. That's not a fault of any of the PHP communities, from how I see it. Even if we were to make the most amazing, information-packed huge wiki with good practices and constant up-to-date information, it wouldn't be the top page on Google overnight. This article claims that the PHP community sucks, but all it talks about is bad misinformation out there not authored by the community. *Doesn't that sound like an unfair claim?* And we know about W3Schools. It's more than just a problem for PHP; it's a problem for the JS community, the HTML community, etc., because its filled with bad practices in its examples.
View the [docs](https://developers.openshift.com/en/managing-environment-variables.html#database-variables).
Great :) BTW I kinda jumped directly to critique but please don't be discouraged. All successful businesses go through countless adjustments like that until they hit jackpot ;)
If what I mentioned above is the issue, trying localhost won't work. I'm thinking he moved the script to a different machine, but not the database. So he's successfully asking for a connection... to the wrong database.
My sense is that most routers are geared toward RESTfulness rather than implementing support for the full breadth of HTTP verbs. In practice, I think you can satisfy 99.9% of most routing needs without PATCH/OPTIONS/TRACE/... And, at any rate, this router is clearly not purporting to be ready for enterprise-level production use. I am curious why the lack of PATCH would "kill it" for you? I gotta be honest, those lesser-known verbs aren't really things I'd ever call deal-breakers. Maybe I'm a buffoon though.
To be fair, I'd rather write TypeScript, which compiles to JS which compiles to PHP, instead of writing PHP that compiles to JS. Oh my god what am I saying! I must be on drugs. But yes, I would.
I think you guys (and maybe more people, I volunteer) should team up and combine these techniques for an UltraFastRouter. I remember you split the route "rounds" when you have many routes, but if you generate per path-level regexes (maybe not each segment but say two segments at a time depending on the routes) it can become even more efficient. I also have flashes of ideas for involving bloom filters and tries :P
This is not a final production ready code, it is prove of concept to see what yo are thinking about this solution. 
&gt; I've been watching some Laracasts tutorials and they seem to frown upon using a stack like WAMP or MAMP but I can't seem to find any good resources as what my development environment should look like, and how to install it before installing Composer and then Laravel. I've even read suggestions that I should be using Linux, which I'm also unfamiliar with. Ignore the snobbery and just set it up whatever way you find. If WAMP works right now on your computer, don't touch it. Keep using it. In general, you only need to install MySQL (standard community install) on your Mac and download the Mac build of PHP. You can use the built-in PHP server for development and testing. Deployment is best on Linux and BSD simply because they're free and simple and only have the bits you need for a server, but that's a concern about your *production server*, not your *development setup*. Your dev setup doesn't matter as long as it works and has the right components. Go check: http://php.net/manual/en/install.macosx.packages.php
I think you're doing a spot of conflating and confusing an architectural decision (how to map classes to files, or vice versa) with a language that doesn't actually give a damn. The mapping stuff is userland autoloading code... You can rewrite the typical public autoloader any way you want. Not necessarily recommended (for interoperability), but you can indeed do it.
Sure, Python is better at building GUI's… because it has better culture around extensions for good GUI libraries written in C :) I'm being a bit facetious as there are GUI toolkits in Python that don't use C libraries, but it does show the importance of having a good Foreign Function Interface.
Are you sure you mean Spotify? Maybe Shopify.
It's not faster when you actually put fast route in "production" mode. And it doesn't remotely have the same features. I hate when people make premature and wholly misleading statements like this ....
I see it now, it's the last one in the list. They asked for familiarity with php. https://www.spotify.com/us/jobs/opportunities/technology/ 
Thank you. My concern is that I want to be able to follow the Laracasts tutorials exactly and want to set up my development environment in the same fashion, yet I can't find any information on Laracasts that explains their setup.
The Wikipedia article does a pretty good job describing OOP: http://en.wikipedia.org/wiki/Object-oriented_programming The introductory paragraph describes what OOP is: &gt; Object-oriented programming (OOP) is a programming paradigm based on the concept of "objects", which are data structures that contain data, in the form of fields, often known as attributes; and code, in the form of procedures, often known as methods. A distinguishing feature of objects is that an object's procedures can access and often modify the data fields of the object with which they are associated (objects have a notion of "this"). In OO programming, computer programs are designed by making them out of objects that interact with one another. It then mentions the classical-inheritance model, and is very careful with its words: &gt; There is significant diversity in object-oriented programming, but most popular languages are class-based, meaning that objects are instances of classes, which typically also determines their type. Some examples of OOP languages that don't employ the classical inheritance model are: ECMAScript (JavaScript), Lua, Julia, Rust. In fact, ECMAScript and Lua actually employ a rather interesting alternative to the classical inheritance model: [prototypical inheritance](http://en.wikipedia.org/wiki/Prototype-based_programming). ECMAScript 6, however, will be employing a classical inheritance model (or something similar).
You can create a virtual machine with Vagrant and Laravel Homestead. The nice thing about this is if you screw up your environment, you can just make a new virtual machine. [Homestead](http://laravel.com/docs/5.0/homestead) [Laracast on homestead](https://laracasts.com/lessons/say-hello-to-laravel-homestead-two)
php is dirty but gets the job done python is clean and gets the job done pick your poison and remeber that both need time and effort if you want to master them
&gt; OOP that doesn't suck Why does OOP in PHP suck?
Pick a bunch, find issues marked as improvements/enhancements. A lot of issues out there go unresolved around new features or improvements because maintainers have priorities and limited time. If you find one to work on, you can fork and code, and then open a PR. You may need to make a call on whether the maintainer actually wants that new feature implemented to start with first though.
What /u/pee-ayche-pee said ;) I didn't mean it negatively one bit, and would in fact welcome everybody to share their experiments.
^This^ Since you mentioned developing on two different environments, Vagrant (especially with a configurator like PUPHPET) will help you stay consistent and you can check it into your version control
I'd definitely recommend Vagrant, it's easy to setup, just follow their Getting Started guide at http://docs.vagrantup.com/v2/getting-started/index.html You mention you're watching Laracasts too, so this is where Vagrant comes in handy, as Jeffery (the author of Laracasts videos), has published his Vagrant setup file, see https://github.com/JeffreyWay/Vagrant-Setup So once you're familiar with the basics of Vagrant, use Jefferys file and you should have a near-identical setup to him as you're following his video tutorials.
I work with php on my job, and python for fun, so I don't have deep knowledge of python. I would say that python has a more ordered structure because of it's syntax nature, it's an object oriented language and not added as an afterthought which makes it easier to find stuff internally, string. something will bring you everything you need, while if you don't have good memory for instr using PHP you have to google it... Also python has great libraries made for it from the C ones. I would never start a linux / windows desktop project with PHP, python has a really big advantage there.
I think some of the content needs tweaking as it's a bit hard to follow. I've included an example below, along with a quick re-write, as I thought it may be helpful. "An annoying feature of Magento in my opinion is when you visit the website; add things to your cart whilst logged in, but for some reason don’t checkout." How I might have worded it: One of the more annoying features of Magento is cart persistence, which works as follows. When you visit a Magento store (as a logged-in user), add products to your cart and then leave without completing the order, your cart is persisted. This means that your cart is saved &amp; will be regenerated next time you login. It's not difficult to envisage problems with this methodology. For example, imagine you visit the store as an authenticated user, add some products to your cart and then leave. Later you decide to come back to the store, this time as a guest. You add some items to your cart, browse to checkout and then login etc etc etc.... 
The short echo tag and "short tags" are two separate things, only the echo tags are enabled by default.
[Hemingway](http://hemingwayapp.com/) is a good app to use to help check your grammar.
I don't think anyone noticed that OP posted the response header as saying the PHP version is 5.2. Seriously dude 5.2? Who out here is using 5.2 for anything? 5.2 has been deprecated for eons. PHP 7 is right around the horizon, and is just fast as fuck and pretty freaking awesome! I would never take advice from an academic, perhaps a better way to learn programming is to look at what is going on in the world today. The fact is that PHP powers more than 80% of all websites on planet earth and almost every, if not every hosting provider has PHP installed on their shitty shared servers! That is a huuuuuuuuuuge fucking number man!
Concerns which, as the article notes, Laravel [addressed rapidly](http://taylorotwell.com/response-dont-use-facades/) (and further improved in L5).
I thought that's what I'd described, I was speaking more to bringthetanks comment. 
It's just that people are interested in what HHVM is doing and working on. This just says that they've moved into performance lockdown. Some people want to know that.
That's totally fine, but, IMO, the title should say "planned HHVM performance lockdown" or "HHVM performance lockdown next week"... it is worded in a way that makes the average person, IMO, interpret that it's not simply a blog announcement of something occurring in the future.
Eh, consider it a status update then. A tweet in blog post form :P
&gt;both need time and effort if you want to master them.. The difference is that mastering PHP involves learning to step around stupid gotchas. While the latter lets you learn useful stuff.
Both. Whether you send HTML to the page or JSON is a matter of your view layer. It should be trivial to send the same data structures on both channels. So I simply have this in my HTML page: &lt;script&gt; var app = new SomeAppForThePage(&lt;?=json_encode($data) ?&gt;); &lt;/script&gt; This gives my JS app everything it needs to get started without waiting. If the volume is not much you can dump the full start state at once, otherwise the needed subset. It depends on the volume of your data. Then, for subsequent updates over AJAX I can re-send the same data structure (or more typically subsets of it) by responding with full JSON responses: &lt;?php header('Content-Type: application/json'); echo json_encode($data); ?&gt; Also it doesn't have to be "on page load, or on demand". As the app works, if you see opportunities to prefetch parts of your data few seconds BEFORE it might get requested, but AFTER page load, that'd be ideal. You need to try to be smart about it (if the app budget allows, all this does add complexity).
Perfect, thank you!
 http://www.slimframework.com/ (first hit on google for minimal php framework) http://codecondo.com/minimal-web-frameworks-for-php/ (2nd hit) 1 (any) of them should fit your need. Pick something you like the style of or something you think that could grow with you (either on this site or a future project). Or since it is a small uninvolved site pick something you want to try out and dont mind throwing away in the future. I have used Slim and Silex, both nice. Lumen is another very new one that might be fun to try
Their remember me tokens are a bit funky. https://github.com/panique/huge/blob/f978a88e8b6198d8df834f8d8e0ca28352ea75bd/application/model/LoginModel.php#L229-L248 https://github.com/panique/huge/blob/f978a88e8b6198d8df834f8d8e0ca28352ea75bd/application/model/LoginModel.php#L100-L136 I'm not sure what the purpose of the hash is in this construct. They're using `password_hash()` and `password_verify()` so kudos to them for that one.
&gt; they seem to frown upon using a stack like WAMP or MAMP The problem with W/MAMP isn't that it's bad, the issue is that it isn't the same environment as a real server. That means that occasionally your code will work you your dev environment and not work when you upload it to a real server. Using vagrant to setup a virtual machine and chef/puppet scripts to configure it, allows you to have a dev environment that is almost identical to the production environment, which just eliminates that whole class of issues. Setting up a whole environment at once can be a bit too much to learn at the same time; the website https://puphpet.com/ generates a Vagrant environment and set of Puppet scripts to get you up and going quickly. 
\#1 applies anytime you're comparing hexadecimal, like for hashes in a logon system--a common thing to have in most PHP applications.
Whatever generates the hash is obviously going to generate it as a string, and whatever is going to retrieve the hash from a cookie or a database is also going to return it as a string. You would deliberately would have to go out of your way to make whatever functions are pulling or creating the hash, cast them to a numeric. So as I said, this is yet another theoretical example of a problem with PHP, rather than a real example. Literally, someone just made it up to illustrate that it *could* be a problem.
Some of the nice ones are already mentioned. Would like to add a few more . Some are in development also * https://github.com/auraphp/Aura.Framework_Project * https://github.com/distillphp * https://github.com/radarphp
Don't use 'admin' as your Wordpress username, dude.
I can't tell what situation you're thinking about, but I'm pretty sure it is not the same thing that fishburne was trying to highlight. Here, let's tackle it from the opposite direction... Consider this function: function checkAuth($savedHash,$userInput){ $h1 = $savedHash; $h2 = md5($userInput); // Yes, they are both 32 characters of hex. assert(preg_match('/^[a-f0-9]{32}/i', $h2); assert(preg_match('/^[a-f0-9]{32}/i', $h2); if($h1 == $h2){ return true; }else{ return false; } } Would you agree that this is pretty normal for PHP code? Nothing too exotic? OK, so 99.99% of the time this function works flawlessly... but *very rarely* it breaks, and returns `true` when it ought to have returned `false`. The one thing we know for sure is that it isn't an MD5 hash collision. Can you guess what's going on? &gt; You would deliberately would have to go out of your way to make whatever functions are pulling or creating the hash, cast them to a numeric. Well, look at the example. There are no casts, everything is a string... But the bug still happens. &gt; So as I said, this is yet another theoretical example of a problem with PHP, rather than a real example. Literally, someone just made it up to illustrate that it could be a problem. I have been programming PHP professionally for 7 years now, and I *did* encounter it... Only once, but the sense of WTF has stayed with me.
You do not have to add the @context object into the JSON payload. You can put it in the header of the HTTP response as a Link header, see [section 6.8](http://www.w3.org/TR/json-ld/#interpreting-json-as-json-ld) of the spec for more info. I think this is a powerful and often overlooked feature that gives you the benefits of explicitly specifying your grammar/vocabulary in a known standard format (JSON-LD), while allowing you to use your existing responses as-is if you really need to.
Composer is not necessary with PHP but if advise installing it since lot of PHP packages use it. It's very simple and completely different from Vagrant. Composer will install the dependencies. (See composer.json in your project folder. That lists all required packages) Vagrant will create a VM and run the PHP code. 
Try sudo mv composer.phar /usr/local/bin/ 
Still getting the "No such file or directory" error.
What are the perms/ownership of the folder? What flavor are you using?
http://askubuntu.com/questions/473742/installing-composer-globally-permission-denied
really can't agree on that one. python has its fair share of gotchas too although they are mostly there by design. (same can be said for php, but there seams to be a huge amount of designers with different approaches there) 
&gt; python has its fair share of gotchas In Python 3? I am not claiming that it does not, although I would appreciate if you could list some of them or point me to somewhere where I can read more about it. So again, the point was not that Python or (any other langauge) does not have gotchas. The point was that large body of the knowledge of a PHP programmer comes from learning to sidestep these gotchas in the language. You see, people tell that PHP is easy to learn. Yes, but what people miss is the fact that what ever useful concepts other language require one to learn before hand, PHP replaces with a requirement to learn these endless (often obscure) gotchas a new user has to learn before he can even hope to make a non trivial application... Actually I think php.net need to have one page dedicated to warning new php users of every gotcha the language has. Something like, "1001 php gotchas you should know and keep in mind before/while writing PHP application". If it is not possible to add to php.net then may be you guys can add it to your new testament, phptherightway.com... 
It's announcing an open effort which you can participate in. It's enough of a news I think. We don't have THAT many big PHP engines out there. Just two, in fact. If not here, where should they post :P
Cool kids don't care what cool kids use.
would you suggest any better framework like this one?
Here is a decent [quickstart guide](http://www.sitepoint.com/quick-tip-get-homestead-vagrant-vm-running/), a godsend for Laravel (or any other) development on any OS.
PHP is a moving target. Like every other popular language, it's spec keeps being revised, it's interpreter performance is improved and new tooling is created to make using it more productive and pleasurable. Cool kids often have no idea what makes them cool. IMO it has very little to do with the tools they use and more to do with how they use them and what they are able to do with those tools.
To be fair, LAMP can also refer to Perl or Python, but I'm guessing that's not what they mean here. I'd be really fucking impressed if they built Slack in Perl, and if it was built in Python they would have just said Django. And not only that, they use Java too! PHP + Java, the horrifying duo.
Cal Henderson built Flickr in PHP, loves PHP, no surprise they'd write Slack in PHP too.
Nginx is ridiculously easy to learn, and my feeling is people who rely on Apache modules for functionality necessary to their application are designing their application wrong. That said, you CAN make Apache almost as fast and efficient as nginx, it's just easier to install nginx and get that speed and efficiency out of the box. I'm sure it is 100% a case of the people in charge of the decision at Slack know Apache and don't know nginx, as you said. But I think learning nginx takes no time at all. I made the switch for our internal servers a few years ago and it was really painless.
&gt; PHP + Java, the horrifying duo. Wait. [Wat](https://www.reddit.com/r/PHP/comments/34d6g2/why_dont_we_care_more_about_securing_our_php/cqtke4x)?
The "cool kids" arguing about curly braces and dollar signs are rarely the ones who actually build useful stuff.
It's also a case of YMMV. There are good reasons to delay or not make a switch that may not have been true for you. I'll elaborate with some examples later when I'm not typing from a trail on my phone. I'm open to being wrong, fwiw, but I've made the same decision in a couple cases.
Imagine that, using a great and reliable stack no matter what the script kiddies think. You go Slack!
No, the college graduates that just discovered Rails last weekend don't use PHP anymore. People that want to get shit done may still, in fact, choose PHP.
Nothing wrong with using PHP, it's a powerful language, and just as others it has it's downside, problem is the community can't keep up, and are mocking a PHP that existed in the time of functions.php, we're long past that...
Some beginner web frameworks like laravel would be a more extensible solution but I've used the same project when I was a beginner and it's pretty solid in terms of being easy to hack away at.
I guess people hate whatever they use the most ;)
Yeah you're right, I didn't see the "may". And the chip is due to the attitude among some PHP folks that Rails was some sort of fad, despite the influence of Rails (and the libraries that grew up around it) being a major contributor to the PHP ecosystem no longer being a land of total wtf.
For me, I don't really like PHP in comparison to other languages that exist today in terms of syntax, structure and functionality. Given that it was one of the first languages I learned growing up, it's unlikely that I am going to trade it for anything else when it comes to web-development.
[Silex](http://silex.sensiolabs.org/) is another popular microframework.
Cool kids use Ruby on Rails :P
I think PHP is hated because it is used often times for the wrong applications and it's easy to be sloppy. At least that's what I get from people that are far more advanced than me.
Have a look at http://php.net/manual/en/function.ob-get-contents.php
It used to be that, but as you can see from the post it has evolved into more.
I am not that good with PHP to understand the manuals yet, otherwise I would have gone there. :( Would you mind making an example? Simple example. 
Basically: &lt;?php //start of file ob_start(); ... Page generation stuff here ... \$result = ob_get_contents(); ob_end_clean(); \$handle = fopen("filename.html", "w"); fwrite(\$handle, \$result); fclose(\$handle); The ob_* functions are output buffers, so anything that would normally get output to the screen (or, in a web context, to the http response) gets saved in a buffer to be retrieved when necessary. Depending on how your page generation is built, it may be best to have the file saving code in a separate file and then use include to call the generation code. Otherwise you'll end up with an old school mess of open and close &lt;?php ?&gt; mess that's difficult to understand. Edit: fixed Reddit mangling dollar signs in variables. 
Ahem http://www.commitstrip.com/en/2015/01/12/the-right-tool-for-the-right-job/
what happens if you don't round() x and y?
I started in C++, then Visual Basic, J++, Java, C#, and only then did I learn PHP. Still prefer PHP.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Aereo**](https://en.wikipedia.org/wiki/Aereo): [](#sfw) --- &gt; &gt;__Aereo__ was a technology company based in [New York City](https://en.wikipedia.org/wiki/New_York_City) that allowed subscribers to view live and [time-shifted](https://en.wikipedia.org/wiki/Time_shifting) [streams](https://en.wikipedia.org/wiki/Streaming_media) of [over-the-air television](https://en.wikipedia.org/wiki/Terrestrial_television) on [Internet](https://en.wikipedia.org/wiki/Internet)-connected devices. The service opened to customers in March 2012, and was backed by Barry Diller's [IAC](https://en.wikipedia.org/wiki/IAC_(company\)). &gt;On June 25, 2014, the [Supreme Court of the United States](https://en.wikipedia.org/wiki/Supreme_Court_of_the_United_States) ruled against Aereo in a case brought by several broadcast networks. The Court found that Aereo infringed upon the rights of copyright holders. The point of contention was whether Aereo's business model constituted a "public performance", which would legally require it to obtain permission from the copyright owners of any programs it transmits. The court ruled in a 6-3 decision that Aereo's business model was no different than that of a cable television provider, despite the differences in technology. As a result of that decision, their case was returned to the lower Court, and the company announced on June 28 that it would immediately suspend its services while consulting with the Court on how to proceed. Aereo's services were suspended on June 28 at 11:30 a.m. EDT and the company filed for [Chapter 11 bankruptcy](https://en.wikipedia.org/wiki/Chapter_11_bankruptcy) on November 21, and was later purchased by [DVR](https://en.wikipedia.org/wiki/Digital_video_recorder) company [TiVo](https://en.wikipedia.org/wiki/TiVo) for $1 million in March 2015. &gt;==== &gt;[**Image**](https://i.imgur.com/Cwxdpjm.png) [^(i)](https://en.wikipedia.org/wiki/File:Aereo_logo.png) --- ^Interesting: [^Global ^Táxi ^Aéreo](https://en.wikipedia.org/wiki/Global_T%C3%A1xi_A%C3%A9reo) ^| [^Aéreo ^Servicio ^Guerrero](https://en.wikipedia.org/wiki/A%C3%A9reo_Servicio_Guerrero) ^| [^ETA ^– ^Empresa ^de ^Transporte ^Aéreo](https://en.wikipedia.org/wiki/ETA_%E2%80%93_Empresa_de_Transporte_A%C3%A9reo) ^| [^SonAir](https://en.wikipedia.org/wiki/SonAir) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cr3r7ri) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cr3r7ri)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Can you echo the SQL statement after binding all parameters to see how dose it look like?
Not a problem. &gt; Are your ORM entities that hard to instantiate at runtime? You can "create" an entity just by doing "new Entity()", so that's not the problem. The problem is getting an entity with _valid_ data in it, e.g. a valid name/age/phone/datetime/other data that's private/related entities. Or getting an entity with purposefully _invalid_ data so you can ensure the error handling works correctly. This issue gets more pronounced when you begin to deal with inter-entity relationships. Entity "Y" has a 1TM relationship with entity "Z", which has a MT1 relationship with "W", and if those relationships and values spread across the entities do NOT match, then stuff fails. You can have additional problems enter the scope if you're dealing with external systems (which we are) and have to seriously concentrate on load testing (which we do). Unfortunately, none of the normal "class mock" libraries out there (Mockery, Prophecy, PHPUnit's) did what we needed them to do without a LOT of extra overhead. The only solution I could find that worked was to create a "mock/fake" of the entity the service/whatever was supposed to work on and inject it with the data I needed to test. &gt; And if you can mock them via a library, they probably behave like like simple DTOs, so why not stick to simple arrays (which are simple to create)? This library isn't really setting them up as a "mock" as you would think of something say coming out of Mockery/Prophecy. What it does is set up a pseudo-mocking/stubbing class where you instantiate a new entity with whatever data you want, regardless of the visibility scope of the property (public/private/protected). You pass in an array of data to the "mocking class", and out comes a valid instance of the entity you want with the data you passed in. Any validation/processes that might be in the entity class (say a setter that takes data and formats it or sets another value in addition to the one you passed in) are bypassed. This gets more important, again, with the relationships of ORM and how the entities relate to each other. In addition, the Entities are pretty much core to the software. There's a lot of "if not instance of" checks to ensure data validity because if the entity doesn't exist in the database, there's nothing for the software to do. &gt; I get this feeling that the problem you solve is caused by the way the ORM library is used. Entirely possible. One of my main jobs now is to help with a re-factor/overhaul/re-architecture of the software. Unfortunately, the demands being placed upon it now are outside of it's original scope and the growing pains are tremendous. Also unfortunately, there is zero allowance for breaking backwards compatibility, so any future work we do MUST take into account the current implementation so as to not blow the whole thing up. If the inner workings change that's fine, but the 3rd party access cannot alter at all. I had a feeling that this library might just be applicable to our situation, but considering how much time it's saved me already I figured I might save someone else the time too XD.
i still dont understand why we dont all still use IRC ... i mean slack is cool in ... replicating IRC behavior in a browser :) god i miss the good old irc times ... i think i am getting old 
I was confused for a second, I thought you meant they were sued out of existence due to LAMP being copyrighted, haha.
I meant to delete the damn .lock file. Thanks for the catch. I was more worried about getting the versioning working right for packagist/composer to work with so I brainfarted on a few bits. I left the commented code in there since that's the next bit of functionality that I was working on. But I agree on the clutter thing.
haha, Again, you don't NEED to delete it, it just won't get used. 
I think you've got your logic mixed up there. Just because he might think nginx is bother better and newer than Apache, he doesn't necessarily think it's better *because* it's newer.
Meh. Already did it XD
No, he's commenting on a thread where we're basically saying that PHP is still very relevant and large websites use it to great advantage all the time. He says that's PHP is fine for lots of big projects, but Apache, which is older than PHP, and just as useful and popular, is somehow **not** up to the task. Basically, he's making the same argument about Apache as everyone else makes towards PHP.
Haha. My bad. For what it's worth, those are basically my thoughts exactly whenever someone actually brings up PHP's early beginnings.
Nope. Ngnix still has to initiate PHP handling, and there is no real advantsge over Apache. Well, maybe in terms of memory consumption. 
I'm learning Rails because "Richard, new project just came in. Learn Rails." I've heard a lot of people talking about the beauty of Ruby but honestly... it's just kind of obtuse. PHP might not be beautiful but it's straightforward and follows a very standard sort of syntax that makes it very clear as to what you are doing. I don't know if that's why I like it or if it's simply what I'm most used to but, agreed.
Lol no worries, as I said, I am like Sheldon from big bang theory, I simply don't get when someone is being sarcastic, much less when you're reading it lol. And yeah absolutely, it's a really cynical behaviour 
Wait hold on I am a noob so I may be totally wrong, but isn't styling 100% html+css? 
The responsive design is going to be based around your theme and not your backend code.
Okay, I understand. My question is- do I have to re-create my theme from scratch using responsive design techniques, or can I make changes to my existing theme in order to make it responsive? 
You just add media queries to your css file, restyling elements according to device width. Is this your first time?
You're not wrong; this has nothing to do with PHP.
So in that case, all OP has to do is add some CSS rules and possibly some functions to make dropdown hover menus work onclick for mobile and such?
You can keep your current CSS rules. Now you go and research @media for CSS and use that to create new CSS rules for mobile. 
You certainly can do it now. It would have helped a lot if you had designed your app with that in mind, sure, but it's not too late. If it's a main feature of your app, you should do it now, you don't have to re-create anything from scratch, you can use media queries (even if you had started with mobile-first in mind you would have use them anyway) It's got nothing to do with PHP, that's a frontend problem. Are you freelance? Or is it a corporate projet and you're realising you made a mistake?
Are mods not going to take this down??
Yes, it'd be my first time. Right now, my app looks terrible on a mobile device. The site isn't optimized / responsive for mobile devices. I guess I'll look into adding css media queries. That should solve it, I'm assuming. 
Apache with mod_php is *not OK*. It's very slow compared to Apache with mpm_event and php-fpm. In fact, this is why people say Apache is slow in Apache/nginx comparisons: they are always comparing Apache2 with mpm_prefork and mod_php against nginx, which is not fair since nginx uses php-fpm by default.
i could do most of the stuff you mentioned in irc. especially by nature irc can do all that it being just a server, leaving most of the stuff like img display up to the client. drag and dropping img to display was as easy as it is in slack though pasting omages from clipboard was not supported by most oses during prine of irc. - service integration always was a key asset of irc. server side archives is actually one of the view things that slack has, that irc hasnt (thoughh its a joke to implement this in unreal ircd)
I like C++ the best. So much power and such an interesting language. To me, it's biggest strength is its complexity (which is a weakness to others). I like PHP too, but I stay away from scripting languages unless they're well-suited for the application at hand. That being said, I like compiled languages more than interpreted ones with non-web stuff.
Probably because Objective-C's joke needs no introduction. It's funny, the two top mobile platforms run two of the most hated languages (Android [Java] &amp; iOS [Objective-C]). Java can carry over to so many more applications and is so well adopted compared to OC, which makes it all the more to hate on. Swift is something Apple is pushing for this reason, though it can be integrated into Objective-C applications.
I would have to disagree with you, a PHP application is not going to be able to scale as well as some other languages. For what it does, it does well. Wordpress and Drupal rule the roost on the web, because most of the web can operate in that framework and within the LAMP/WAMP stack (though PHP can live outside of those stacks.) I think PHP gets undue hate, but just like any language it has its limits and purposes. If you're building an enterprise grade web application, PHP is probably not the tool. Each language is a tool, and each one has its own applicability.
Is it necessary to create separate UIs for a responsive version of the site (and then using them as a guiding point for the CSS media queries)? Or is there different process? How do developers typically determine what the site would look as a responsive mobile theme? 
Is it necessary to create separate UIs for a responsive version of the site (and then using them as a guiding point for the CSS media queries)? Or is there different process? How do developers typically determine what the site would look as a responsive mobile theme? 
Didn't Slack also get hacked?
You should have a design made up that you will follow to modify the style of the site (not seperate, same site) based on device width, of which the responsive media queries respond to.
Now I'm wondering what the heck Monkey Scroll is.
I think you don't understand nginx. And PHP for that matter. Unless you server your apps with built in PHP server.
If plenty = 2 then ok :p
Rails?
Over-engineered for sure. But that's what makes it fun! As posted by another, the "next" button moving is annoying. If you could autoload the next image in memory and change it in JavaScript then the transition would be smoother PLUS when I spend 4 hours browsing pics I don't have to press the back button 600 times before getting to my previous page (that's my special use-case I know there are ways around it okay). I assume getting a "gw" version is as easy as change one single variable? I mean... just making sure you're following best practices. 
Thanks for the post too. I feel like I should be asking for a more detailed version but I can already learn a lot from what's there.
My boss won't be able to use IRC. But he is able to use Slack, so the number of interruptions is _way_ lower.
IRC is still alive and kicking. It's still the best way to get in touch with developers of FOSS projects.
I added the previous button functionality too now! =)
Yes, it is definitely over-engineered but that makes it part of the fun! ;)
+1 for Source, I'm learning Laravel myself and would love to dig in and OP's set up.
Sure, I'll message here as soon as I move a bunch of keys to environment variables.
http://dracony.org/stop-using-php-fpm-to-argue-using-nginx-vs-apache/ http://blog.bitnami.com/2014/06/performance-enhacements-for-apache-and.html
Awesome, thanks for delivering! This is gonna be a good weekend.
You are welcome!
I agree with you, that I missed a point here. I have fixed the code. :)
Thanks for the feedback. I didn't notice this on a Mac and an iPhone 5S but most likely this happens on an Android or Windows device? I'll try to deploy a fix ASAP!
Cool, I didn't know that. I've added a PR.
No mention of the PSR-3? Use of private? I wouldn't want to find this being used in production.
1.) /r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on 2.) Look into jQuery AJAX.
I see, I'm mostly developing in JAVA, but in PHP it seems that private is kinda forbidden. I have changed my code. Thanks for the heads up! The next time I will come with much better examples
It looks like a fun learning exercise. You should do a better job of sourcing your material.
1, 2, 3, 4... feels incremental to me, in the sense that one depends on the previous (like version numbers). 001, 002, 003... feels like separate, independent "ID" numbers rather than incremental ones. Just my 2¢.
It's not really forbidden, I don't know why the folks are jumping on you. It's a matter of design. For a base implementation that others extend, you may want to change the implementation without BC breaks - then you use private for internals. And protected is for, effectively, the "public API" for *child classes*, so they can access &amp; override. So nothing is broken either way, it just depends on the intent.
It's not forbidden at all, choose private or protected for the same reasons as in Java: Depending on how you expect the code to be used.
THIS. SO much this. I did 3+ years of Ruby/Rails dev, and I was attempting to add a new type of Hypermedia representer the [roar gem](https://github.com/apotonick/roar). Holy hell. There are no typehints or interfaces in Ruby, and I found myself desperately wishing the project was written in PHP so I would have a concrete interface to code to, or at the very least a base class to extend with clear method definitions. NOPE. Instead it's got `instance_eval` everywhere, meta-programming, and nested modules galore. I spent a few days on it, before finally giving up and using hand-rolled JSON erb templates.
In your Sitemap Command, why do you use App::make rather than using dependency injection in the constructor? 
So how much actual code did you wrote by your self? 
I totally could do that, I guess I was being lazy there! =) I'll fix it.
I'd say keep the ads. You have the source, just have the ability for users to remove their image from the site. (DMCA shit), and make sure you aren't showing private aimages.
You need to load a php page with your data attached in some way. Either simply load your page again, with added URL parameters ?variable=value, or, if you don't want to reload the page, post it to a page you don't display, via eg. jQuery. Again the easiest way is to use url parameters. 
Yep, I added the source links to the original imgur posts too at the bottom (above the social media sharing links). No private images are being used and in case someone has a problem, there is always DMCA.
 $log = new Log($logpath, $timezone); $log-&gt;error(...); $log-&gt;info(...);
I use nginx and PHP every day for many production and development servers at work. So, yeah, I understand them just fine.
Alas, you can use many thing constantly without zero understanding how they work.
You raise a good point with libraries, call me CMV'd.
&gt; Less (an understatement) weird behavior and sensible, helpful use of types. In php '0e46' == '0e83'. This should be enough for any self respecting programmer to keep away from this language. You can use strict comparison but then 1.0 !== 1, so you see, you cannot just do the right thing with PHP. In php you could express everything as strict as you want. You get early taught not to use == in most situations. So you easly do things this way: '0e46' === '0e83' // string === string 0.1 === (float) 1 // float === float (float) $a === (float) $b // (float) ? === (float) ? I like being explicit over being beautiful. &gt; Pleasant readable syntax. That's a matter of taste. I like the explicit usage of punctuation and curly brackets. I like them in every language. If I ever design my own language, it also will have explicit elements for showing borders of code-blocks or statements. But I got your point and there is nothing wrong with a readable syntax. &gt; Helpful standard library. (Try using the Python os.path functions vs what php has to offer natively) Right. &gt; Modules as opposed to primitive auto loading build on top of laughable include functionality. (Yes let use just pretend that this file is inserted in the middle of the current one) Right. If I remember correctly, PHP has some sort of autoloading and has those include, include_once, require and require_once-Functions. Didn't met them for years. Today, I use Composer for that. In the end, it magically works just the same way, Python works - but with more flexibility... &gt; A great community that actually works together. Same applies to PHP. Or can you clarify this point? &gt; Decorators (setter and getter decorators are great) For libraries/packages that is some sort of a bad design-driver. In PHP, you should not use protected properties as your program may fail silently when you access a non-existing property. This is likely the case when you rename or remove a property. When you publish a package, the interface of your classes gets also published. If, at some time you feel you need to change the way your components store things internally, your methods mostly stay fine, but your (protected) properties change. And then you have no chance to see who has already used those properties in deriving classes or foreign packages. As PHP just create a new dynamic property when you set a value to a non-existing one, that could raise hard-to-track bugs. And you should not use public properties, as they can't be a part of an interface. Just keep it simple and use private properties at any time. You can use methods (... and yes, there are some valid uses for public properties). &gt; Descriptors (reusable automatic type check every time when a property is set without having to write explicit setters) PHP has this [phpdoc](http://en.wikipedia.org/wiki/PHPDoc) which enables IDEs like PHPStorm to apply static code analysis on my code and give me some sort of report where variables with a wrong type are in use. I know of no single IDE that does that job equally good for python. PHP supports optional typehinting for interfaces and arrays. Python (and ruby) does not (python may get it with 3.5?). I could stop here, because this is a perfect showstopper for me. So I can use autowiring. So my [DependencyInjectionContainer](http://php-di.org/) builds 80% of my environment for me. Even if I randomly change the parameter-signature of my constructors. And: PHP has Interfaces. Real Interfaces. So I can build components that depend of those interfaces and force other components to implement just this interface to be compatible to my component. I can refactor that interface and get a notice (at compile-time, but you need a proper IDE currently) when my component is not compatible anymore. Ducktyping is nice, but... no, it's not. **I *really* don't want to say that PHP is better than python, but also not that worse on it's own.**
The point I was trying to get at was a non-descriptive name requires developers to either look up the RFC or memorize them. I'm not quite sure what your counter-argument is here since I have no idea what those RFCs are without looking them up nor which RFC superseded which. The big problem, though, is you don't explain why the current system is *preferable*. The whole blog post feels like a half-hearted "that's just how the system works".
Well, for anyone curious, it turns out my two databases were NOT identical. The tables were all identical, but at the database level, the collation of the database on the live server was set to latin1 and the collation on the test server was utf8. Changed the live server to utf8 to match the tables, and everything works fine. 
Lots of transsexual dating ads on your site, FYI. I hope to god their not suited to me. Edit how long did this take you?
Some posters here haven't realized that this is a throwaway site to demo some stuff. Good work my friend
A lot of things Freepbx has being doing in the last year or two have been quite the opposite of what the opensource philosophy is all about. Such as this. https://www.dslreports.com/forum/r29959964-FreePBX-and-the-unsigned-module And this. http://www.dslreports.com/forum/r29786067-Ward-Mundy-s-open-letter-to-Sangoma ...and no it is not about Ward Mundy. He is just one of the more vocal people about it. Just because you have a bunch of individual GPL modules on github with no straight forward opensource way of installing them does not mean the project is being designed in a way that fits with the GPL philosophy. In fact that is not even a bug...that is a feature. If freepbx was still interested in being a truly open source project they would not have the signed modules and non-opensource module admin software distribution system. I am aware of the legit excuse for using signed modules. Doesn't explain all the other things being done basically forcing people to use them and the non-opensource module admin distribution system. 
Definitely useful for solving code puzzles. Actually its a pity sites like codility don't provide any debugging tools if you are solving puzzles there.
if mysql_* works for me, and I don't plan on porting my code to other systems, why is it bad to use?
Actually my article was about id's being incremented in Draft instead of ID's incrementing on Acceptance. If you just don't like IDs at all then this is nothing to do with you. PSRs have names though so we're fine. PSR-3: Logger. That's the one about loggers.
Sure. Can I list them off the top of my head? No, because I simply don't punch myself in the face by using any of those functions so I don't have problems ready to list. I have this vague thought in my head that there's ways you can set up your db encoding such that it's still possible for real_escape etc to be defeated. I may be imagining that, so take it for what it's worth. Bottom line is nobody should be writing any new code that starts with mysql_ . Period. It only remains because so much code relies on it, but the same can be said of asbestos. It hurts to learn PDO at first, but once you get over the small initial learning hump it's gravy after that. Once it's done it's done and it'll make things clearer and more deliberate. If you can go from this point onwards with using PDO then it should only take a day or two to get used to it and you'll be sorted.
Even if they're for your personal use, it's best to get in the habit of using PDO so that when you are building something public facing, you're experienced with how to use that system. In general, mysql_* is no longer indicative of modern app and database access design. Getting ahead of this and using PDO in your projects gives you familiarity with how to handle these within best practices guidelines. 
&gt; I know I have found several bugs but no longer post bug reports specifically because of the way freepbx has been acting. So, who fixes these bugs then if you don't report them? Is there a secret git repo somewhere that I don't know about? Or do you hold onto the bug and wait until someone ELSE reports it and it gets fixed? That's pretty mean, and THAT goes against the ethos (if not the word) of the GPL. That's also one of the reasons I've been agitating for us to move to the AGPL, so there isn't that loophole. (Go read up on the AGPL if you don't know what it is) &gt; Wards open letter was about a LOT more. I went back and re-read Ward's letter, and I have to disagree. it's all about some commercial arrangement he had with Schmooze. As had been pointed out several times, I'm not a lawyer, but when the entire post is copying and pasting contracts and commercial agreements, then I kinda think it's about contracts and commercial agreements, of which I happily wash my hands. That has nothing to do with the Open Source FreePBX project. &gt; This is a systemic attempt to abuse the GPL license, trademark law, and copyright law. There are three totally different and separate things there. The GPL is pretty simple, it says you can have the source code to GPL products if you ask for it, and if you redistribute that source code, you can't alter the licence. I am **the** GPL nazi, and if there was an issue with our GPL compliance, I'd love to know about it. With Copyrights and Trademarks, I'm not a lawyer, so I abide by the common sense 'Don't remove anyone's copyright' and 'Don't use people's trademarks' (at all, unless express permission has been granted). Trademark law is scary and complex, and I steer well clear of it. 
Is it possible to use a number (eg of games and goals) from wikipedia on my site, that will be updated automatically? 
So, is /u/phpgeek just /u/dracony?
Digging through your source, one thing caught my attention that bothers me a bit: https://github.com/ukjadoon/topcuteanimals/blob/master/app/Commands/CreateSitemap.php In `handle()`, you're doing service location to get the sitemap by calling `\App::make('sitemap')`. Not only is this service location, it's the *worst kind* of service location: aliased service location. And not only is it the worst kind of service location, it's the worst *laravel* kind of service location - the kind where it's a global alias that gets bound in a vendor's service provider, making it extra hard to find without opening up config/app.php Alias binding is shitty and I kind of which Taylor would remove it from Laravel. Anyway, since this is a for fun project to learn from, this is a great place to add some abstraction and create an application boundary. 1. Create a generic sitemap service interface that your application wants to use. 2. Create your own SitemapServiceProvider that binds an implementation to that interface, and replace the one for `Roumen\Sitemap` in `config\app.php`. 3. Create an adapter for Roumen\Sitemap that implements your own sitemap interface, and bind that adapter to the interface in your SitemapServiceProvider. Use Roumen\Sitemap source files directly here, don't use his service provider binding crap. 4. Modify https://github.com/ukjadoon/topcuteanimals/blob/master/app/Commands/CreateSitemap.php to type hint to your interface so that it will auto resolve your adapter for the `Roumen\Sitemap` library 5. Update the `handle()` method of the CreateSitemap command to remove the service location, and then replace `$sitemap-&gt;store(...)` with `$this-&gt;sitemap-&gt;store(...)` to use your injected sitemap service. 6. Bask in the glory of knowing that you over-engineered a way to change out that sitemap service for a different one without ever having to touch the `CreateSitemap` command :D
Are you adding session_start() to your results page? 
That's my impression, as well. I mean PHP today (5.x branch) is already outdoing Python and Ruby, but it was slower around the ~5.2 days.
It'll have to be on all 3 for it work 
Yes.
`mysql_real_escape_string()` still leaves you vulnerable to injection; search the Internet for details. Also, the `mysql_*` functions are deprecated and will be removed in the future.
&gt; if mysql_* works for me, and I don't plan on porting my code to other systems, why is it bad to use? You might fully understand the implications of it all, and so your mysql_ solution *could* still be secure (people will tell you its absolutely not possible to have a secure mysql_ site, but its not true. It IS however pretty crappy practice and makes it much easier to introduce vulnerabilities. If you don't understand what I mean, chances are your site is vulnerable already). This is the situation I'm in, but am belatedly porting to PDO. Not because I plan on using anything other than MySQL, but because I want to be able to upgrade PHP without major headaches. I've already left it really late to be doing this, but better late than never The problem you have if you stick with mysql_, is that its not only deprecated in 5.5, but will soon be removed altogether. There *will* come a point where you need to upgrade your current PHP installation, for whatever reason, and if it happens to be an urgent requirement, you are basically screwed. This is the sort of thing that can kill your web-based business, so you simply have to attend to it, assuming you hope to be around in a few years. 
Im converting a site to pure https, however my forums allow arbitrary images to be embedded in bbcodes (which now also need to be served via https) Ive come up with a solution to solve this (which involves proxying image requests through a server of my own, and then caching and serving them under my own ssl certificate). But I'd love to hear from anyone who has already solved this problem, particularly if theres a third party cloud service which makes it less painful. Ive looked into imgur API (poorly documented) and IBM/Softlayer's cloud solution, aswell as Amazon, but all of it seems much more work than just spinning up a virtual server and doing it myself. Its strange, this must be a common problem which people have been solved a thousands times before ?
You mean football? ;) A quick google finds [this](http://api.football-data.org/index) which I think would do what you want. If you're looking for a more formidable/reliable source and you're looking at paying, as such look into ESPN or Opta. If you have no luck finding an good API don't resort to scraping Wikipedia, look into reading something like a [bbc news rss feed](http://feeds.bbci.co.uk/sport/0/football/rss.xml?edition=int) or something.
Scott here. **I want to make the Internet safer from crackers.** I spent a lot of time finding and disclosing security vulnerabilities in all of your favorite open source frameworks the past couple of years. After a while, though, I started to sound like a broken record to myself, so I'm currently re-evaluating my strategy. For my first experiment, I thought I'd identify the bad security advice that developers are most likely to encounter after typing a query (e.g. "php encryption") into their search engine and clicking the first Stack Overflow result. Despite finding an abundance of vulnerable code snippets ripe for the amending, **I immediately hit a proverbial brick wall.** My edits (which usually appended a warning or two and linked to reliable symmetric cryptography libraries) were all rejected, including one that only [patched a timing attack vulnerability](http://stackoverflow.com/review/suggested-edits/8016470). As it stands, someone seeking to learn how to implement secure symmetric-key cryptography in PHP is much more likely to be given bad advice than good advice, thanks to StackOverflow (particularly: the way they handle "closed" threads and the fact that they have non-experts in cryptography rejecting amendments to accepted answers to encourage safer practices). From the StackOverflow community's perspective, perhaps changing the accepted answers is unacceptable. But from the perspective of someone who wants to make everyone's applications more secure (and preferably, by default), the answers, accepted or not, should be considered **harmful**. I'm at a loss for how to proceed. P.S. If anyone is interested in assistance with securing *your* application, [shoot me an email](https://paragonie.com/contact/) (I'm the `security@` for Paragon Initiative if you'd rather not use the form). If your project is free as in beer **AND** free as in freedom, I'll personally review it for free.
http://fabien.potencier.org/article/47/pragmatism-over-theory-protected-vs-private Composition over inheritance ... every single time. I consider overuse of protected as a code smell. Yes, sometimes you should use a protected method, and that's usually where you have a designated extension point, and that's usually an abstract class/function that's meant to be extended. There are far better ways to offer extensibility - such as the middleware pattern.
This is pure speculation, but they're probably not. Their real-time services are written in other languages, and they have a javascript app running in the user's browser connecting to those services. LAMP is just the stack responding to the initial HTTP request and returning HTML.
&gt; Ive looked into imgur API (poorly documented) Maybe it's changed since I last looked at it, but I found the Imgur API pretty straightforward, and unlike when I last looked, there are now existing libraries. It'll be far more time effective letting someone else do the hosting. Just take note of the Imgur terms of service and their retention policy.
I understand your frustration, but the brick wall is made from two layers: 1. Not all reviewers have at least a decent amount of knowledge in security field. In review process I tend to skip over edits with a subject that I don't know enough, but not many people do that. 2. SO rules says that you should not edit a question/answer in such manner that could be interpreted as changing the original poster intention. In 99% of the cases, such edits will be rejected on review process. Although I have edit privilege and none of my edits go to the review queue, I would not edit a wrong answer or an answer with deprecated code. Instead I would add a new answer and comment (_in bold_) to the wrong answer with something like: &gt; This is now deprecated. See this answer for more up to date information: &lt;link&gt; or &gt; This is bad practice and is NOT secure. See this answer for the proper way to solve the problem: &lt;link&gt; With time and patience, your answer will get enough votes in order to stand out. Which brings me to a common mistake most people do when they search something on SO: &amp;nbsp; **It is not a rule that the accepted answer is the more accurate one. Take your time to scroll people and read other answers, because you could find more up to date information AFTER the accepted answer.** &amp;nbsp; I don't like insecure code either and I think that developers should learn more about security best practices, especially in PHP ecosystem. But in the same time I also understand why those SO rules exists, so I'm somewhere in the middle in this case. &amp;nbsp; You know security and on SO are a handful of security people, so you could profit from this. Try to concentrate on giving good answers on security related questions and with time you will gain enough reputation that could get you an expert status on SO for security. This will help the community and will help you to become more known and respected voice in the security field. &amp;nbsp; I hope you would not interpret my comment the wrong way. I had similar problems as you not long ago and I wanted to give you a few hints which I learned since then regarding SO.
&gt; I would not edit a wrong answer or an answer with deprecated code. Instead I would add a new answer ... This is what I would do too, if the questions weren't closed (but also top hits in Google).
I personally think you're going about writing your CV in the wrong way. Yes it's important to know "advanced concepts" but they should be demonstrated in your CV through experience in applying these concepts by writing software. Then in the job interview when you're asked to discuss through some of this software you've written you can talk about the approach you've taken. As an employer I'm not looking for someone who has memorised hundreds of functions, I'm looking for someone who understands how to apply their previous experience in new contexts as well as learn new concepts which together will produce the best outcome.
Ok thanks, Ill perhaps revisit the imgur idea, as this was kinda my preferred choice to begin with &gt; It'll be far more time effective letting someone else do the hosting I agree, if possible. The problem is, I had some a few technical questions, and despite emailing imgur support aswell as chatting with the devteam via their official IRC channel, I still didn't get any concrete answer and the docs didnt explain it either This was even though I made it clear I'd be using their highest paid tier, not just some freebie offering So even though I love imgur and use it lots as an end user, I was left feeling that partnering commercially with them would end up being a bad idea 
Agreed 100%. One of the biggest time savings I've been able to offer my current dayjob is an intuitive understanding of PHP's arrays and `array_*()` functions. This enabled me to fix a lot of bugs and to help talk my teammates through issues they were experiencing in their own code. Arrays are considered basic. A mastery of the fundamentals is usually more valuable than a surface familiarity with the complex.
http://www.derailingfordummies.com/derail-using-anger/
I know basic PHP, been tinkering around with it for a couple years. I have never had the need to use a database, and was always intimidated to learn. Recently I have jumped in and realized it's not so hard, so basically my skills will only improve from here. Am I hireable? 
Its just Google ads and they are context sensitive to your browsing history so perhaps...or maybe they are just really shitty at showing relevant ads. I am getting a lot of World of Warcraft ads here though.
Thank you, sir!
But hes right.
? We're talking about encryption (ie. making a secret unreadable), not authentication (making sure the secret isn't modified). That's what `openssl_sign()` is for. Also, what's so cool about GCM? How does it relate to public key crypto?
&gt; We're talking about encryption (ie. making a secret unreadable), not authentication (making sure the secret isn't modified). That's what 'openssl_sign()' is for. Read the article I linked. If you don't authenticated ciphertexts, attackers can do all sorts of evil things to your encrypted message. This is all symmetric key crypto. `openssl_encrypt()` is also an interface for symmetric key cryptography.
LOL
It seems like this method isn't working for you so well though. Whether or not you have the right information is irrelevant if noone wants to listen to you, and at the moment it seems like noone on that site wants to because you are not going about things the right way. If you don't want to play by their rules, go somewhere else- write up your solutions on a blog or something.
Languages don't scale, architectures do.
Look into a router or micro framework, for example [slim](http://www.slimframework.com/).
Just an idea, looking you are using reflection to set the values for the entities. Have you thought on using a symfony component called PropertyAccess ? http://symfony.com/doc/current/components/property_access/index.html I currently use it to populate objects with arrays (test days)
Is there any discussion around how you arrived at the constants present in the code (and strongly recommend not changing)? It's 3am so I was only able to briefly skim the library, but it seems to use only 128-bit encryption, rather than the (usually unnecessarily) stronger 256-bit. That doesn't seem to fit with the "security above all else" mantra. 
https://github.com/defuse/php-encryption/issues/35 We actually summoned a lot of experts and /u/codesinchaos actually chimed in :P
Interesting. Sounds like the conclusion was sort of "128 is strong enough for now but we can revisit". I imagine the context of data access and usage also plays a part; my background specifically relates to CC storage (PCIDSS level 1) where the vast majority of the data is at rest most of the time, and when in-flight its either secured by a TLS connection or GPG. 
Personally, I'd love to be able to use Salsa20-Poly1305 here instead. But that requires developers to be able to install the libsodium extension.
Good luck explaining that to your QSA. Or your security page that customers see for that matter ;) Either way, thanks for working on making crypto a bit safer. The world needs it. There aren't many places where I'm in favor of using a highly-opinionated library, but this is definitely one of them. 
Thank you for looking into this. You are right, and I ended up using Laravel's Str library. use Illuminate\Support\Str; The previous code was replaced with, $this-&gt;message = Str::limit($post-&gt;headline, 80, '...'); and if you look into the source of the Str::limit function it does use mb_strlen. Ajax loading isn't hard to implement but I was worried about search engine crawlers not being able to crawl the site easily if there is too much Javascript involved. Until I come up with a fallback solution, I will keep the current functionality.
So interested... Shame I live 3308 miles away from NY!
Yes, I mean football, thought you are American :) Big Thanks, Im gonna read about it.
Thanks, still no have idea what I am looking at but thanks.
Fair enough too, but I understand real sport :P When you inevitably need to write this API give "guzzle" a google. Will save you a lot of drama.
give "guzzle" a google. What?
Probably because the two "main guys" behind Composer and Packagist only have limited time and budget. They are doing amazing work, basically changing the entire PHP ecosystem, but there's only limited amounts of cash flowing in, and they are only human. You can support them by using [Toran Proxy](https://toranproxy.com/).
http://apidocjs.com/ works pretty well
Thanks for the feedback. The 12 months is on top of the 6 months, and we'll prolong this period for as long as it's necessary. If there are still a significant number of sites running on Bolt 2.2 around, 18 months _after_ the release of Bolt 2.3, we will keep on supporting that version. When 2.2 is released we'll make this a bit clearer, that it's _at least_ 18 months. &gt; I'd expect AT LEAST 12 months of security fixes with a non-LTS release. This might be feasible for huge projects, but we have limited resources. Drupal officially supports 2 versions (latest and next-to-latest), as does WP, I believe. 
I am more of a `foreach` guy as opposed to an `array_walk` one. 
It is the answer to "And how to find those API's?". it is a *large* list of public APIs. That is where you can start your little project. Once you have found an API that has the data you need, as mentioned by /u/flyingkiwi9 , have a look at guzzle: http://codesamplez.com/programming/php-http-request-guzzle 
Note: &gt; By downloading a file or other content from the Imgur site, you agree that you will not use such file or other content except for personal, non-commercial purposes, and you may not claim any rights to such file or other content, except to the extent otherwise specifically provided in writing. http://imgur.com/tos
It's not in PHP7, for one.
It's a similar concept, but unless I'm mistaken that bundle doesn't let you mess with private/protected/static values? That's always part of the problem when you're trying to get a mocked instance of an entity; you never know what visibility is set on a property, and not all public/private properties have proper (get|set)ters for them. (E.g. Doctrine entities and the bloody mandatory id property.) Basically once the mocker/faker class is set up it becomes a uni-directional construct where you just say "Here are the values I want in it. Make it happen, and don't give me any shit about private or protected, just DO IT." and you get an instance of the entity to toss around. Also I'm trying to avoid having additional dependencies in my library if at all possible. I might have to change my mind when I get around to setting up the ORM aware section because holy hell there are a lot of ORM libraries out there and I really don't want to have to hand roll a bunch of crap to parse annotations/yml/xml files, but I'm working out ways around that. /shrugs.
I haven't seen a single unbiased benchmark that has pegged PHP7 as faster than PHP on HHVM. Do you have any good resources I could look at?
Certainly: https://github.com/bolt/bolt 
Ah, didn't realize you put the beta version on master.
Understanding what all of these are, and when to use them: https://github.com/domnikl/DesignPatternsPHP
&gt; For PHP, I can't really think of anything advanced If you're looking for stuff truly unique to PHP, rather than just advanced concepts that are found in other languages, off the top of my head: * Streams (how everything is a stream, even files - so knowing how to use stream in PHP is different from other languages) * OPcache configuration and generally knowing how to tune PHP via php.ini * Profiling with Xdebug * Knowledge of what the PSRs are and mean * Composer (obviously other languages have package managers, but being *good* at Composer is an advanced skill in PHP) Then of course there are plenty of things in PHP that are in other languages, but still need an understanding of in PHP: * CURL usage * output buffering * Exceptions * etc...
Is that "resumes and programming interviews are terrible" link correct? If so, can you explain?
At a glance, using mt_rand() is not entirely random (esp. if leaked earlier by same process). Also using setcookie() without scope for setting domain, secure &amp; httponly flags. More relevantly, the cookie parameter omissions are already reported in an issue and weren't fixed in a current release. They seem to be scheduled as fixes in a future stable version, however, in a comment from March. I do get worried when security fixes are put off to future versions for too long.
The specific functions were `array_values()` and `uasort()` in the most recent issue. Nothing too complex.
Lol /r/php forensics , you must really hate /u/dracony, but I am pretty sure I'm a different person
Was it [µ](https://github.com/jeremeamia/mu)?
Guzzle is a library. Great for handling/consuming APIs. You should definitely check it out.
&gt; You are sounding more and more like the kind of person I avoid. Which is a common occurrence in this sub-reddit. A lot of the people who post frequently give an appearance of being massive twats, who I would hate to have to deal with in real-life. I have no suggestions on how to deal with this problem, other than to call them out on it. 
If you are just getting started, use MySQL. It is not inherently more or less secure than other database systems, the security part is up to you. If you are using it with PHP, use [PDO](http://php.net/manual/en/book.pdo.php) to connect to it, that will get you a long way toward preventing SQL injection attacks (your #1 security concern when connecting PHP to a database). Become familiar with the [OWASP Top 10](https://www.owasp.org/index.php/Top_10_2013-Top_10), several of them relate to databases but all are important if you are just getting started.
&gt; you must really hate /u/dracony, What makes you say that? I have not downvoted /u/dracony or /u/phpgeek nor did I describe my views on /u/dracony or /u/phpgeek. I simply pointed out that both users have unique things in their writing that stand out. Since we're making assumptions here, you must be declaring that the /u/phpgeek account is worth hating and that by saying /u/dracony is likely also /u/phpgeek is an insult to /u/dracony.
I've always wanted to try Yii. Anything in particular that sets it apart from other frameworks like Silex and Laravel? The code generator looks pretty neat. One thing that I can't get past, though - and this is going to sound petty - is its lowercase namespacing. I know that the Studly Case convention applies only to class names, but I'm seeing it applied to namespaces as well in most other frameworks. Personally, I just think it's more consistent that way.
At one time I made lists of different webdev stuff for all 3 levels ( Junior, Intermediate and Senior) : * http://phpixie.com/blog/things-every-web-developer-should-know-part-1/ * http://phpixie.com/blog/things-a-web-developer-should-be-able-to-grasp-part-2/ * http://phpixie.com/blog/things-a-senior-php-web-developer-should-know-part-3/ Now watch me get downvoted for linking to one of my blogs even though this is a direct and extensive answer to your question.
Avoid JSON ? I was hoping JSON will make it easy for configuration. So we use JSON to define the types of attributes expected and then store all data in that format. Only problem would be searching/indexing but I thought jsonb from postgres would help me out with that
&gt; A mastery of the fundamentals is usually more valuable than a surface familiarity with the complex. Hear, hear.
http://php.net/manual/en/function.strtotime.php &gt; Note: Dates in the m/d/y or d-m-y formats are disambiguated by looking at the separator between the various components: if the separator is a slash (/), then the American m/d/y is assumed; whereas if the separator is a dash (-) or a dot (.), then the European d-m-y format is assumed.
That was my first thought when I went there too, I think it's the correct link though. I mostly skimmed it, but the idea is basically making a game out of coding and as you progress your solutions are saved, so an employer can go look at your solutions without having to maintain and update coding tests themselves, and it gives coders a set of problems to work on to make a resume of sorts without having to come up with projects to work on so you can share them from your personal Github account.
I think you mean the first code will return ```false``` faster than the second.
Yes.
&gt; This is patently false. That's like someone asking "Does PHP have a package manager? What is it?". It's not broad at all. Considering that most big projects closed their PEAR channels or are in process of doing so, there is only one good answer to that question. Can you guess it ? &amp;nbsp; &gt; Secondly, if 10 people give me 10 different options. AWESOME. I just need to be pointed in a direction and go from there You have been pointed to 10 directions actually, not one. Testing 10 wordpress plugins could be easy, but testing 10 implementations ideas, 10 refactoring ideas, [...], could be more challenging. &amp;nbsp; &gt; Meanwhile SO is perfectly fine allowing questions like "how do I set the default timezone in PHP", which a 10 seconds google search would turn up. Actually no. Those kind of questions are answered already in the wiki and are usually closed. When you find such questions you should flag them as duplicate with a link to the wiki entry. &amp;nbsp; &gt; I've been in charge of moderated community sites for ~12 years. Gaming community sites - the kind full of trolls and flamers. Did you just compared SO with a gaming community ? Wow! 
Yep. https://github.com/dmayer/time_trial
Normally I'd just downvote, post something vaguely snarky, and move on, but you appear to be an actual human being with a legitimate interest in learning instead of another bot submitting tutorials for some low-quality code blog aggregator. So, your tutorial has some invalid PHP code. Depending on server settings, it will either accept any value or always throw a fatal error. This line is the culprit: if ($response . success == false) { It looks like you're trying to access the `success` property of the `$response` variable. It's guaranteed to fail for two reasons: 1. The `.` symbol is used for concatenation in PHP, so it will be interpreted as trying to add the contents of a constant called `success` to the end of the $response string. PHP will try and interpret this as the string "success" since the constant doesn't exist. The response will have "success" appended to it, so it'll never be falsy. Any code entered will be considered successful. 2. The `file_get_contents()` function returns a string, not an object of any kind, so there's no circumstance under which `$response` will ever have a property called success . Maybe you're expecting a JSON response and missing `json_decode()`? I'd be happy to change my downvote to an upvote once you've corrected those issues.
I had a chance to play with it, and I found it to be really clean and simple. For anyone who is concerned about modern coding standards, Bolt definitely provides a great alternative to WordPress. 
I wanted to make a little note programme that saves what I type in, in a .txt file. I tried everything, but I couldn't get it to write UTF-8 Characters correctly (ä,ö etc). Used utf8_encode(), mb_convert_encoding("Hällo", 'UTF-8', 'auto') and file_put_contents("test.txt", "\xEF\xBB\xBF" . "Hällo").
I find a lot of developers on the internet are like this, having the appearance of self inflating their own egos.
The fact that you're asking this.. might be considered that you don't know much of "advance techniques" in PHP. This is a brainless question for one who does. Not to be mean, but come on.
Out of interest - what are the best methods nowadays?
lol why so much hate for phppixie and its creator? Everytime I see a post about this framework, everyone is downvoting it :D
I usually make the log filename include the year and month at the end. That way the file rolls to a new file every month. On some of the more aggressive logging where I needed to log a message bus I was breaking it up as fine as by year-month-day-hour. Its not too much work from there to delete old logs (assuming everyone can agree how old of logs to delete). Plus once they get too big working with them can be a pain. 
Sorry :'(
That is a fair assessment of the situation. There aren't easy answers here.
Always great to see a new release of bolt! I really love it's easiness for clients and developers. 
I've been working on it for some time and now I'm using it with my vim all the time. It doesn't support some really important parts(like static call via ::), but I'm working on it and it wouldn't be hard to implement this features. Watch video and try it :)
I believe that StudlyCase for namespaces is part of the PSR-2 standard. It really bugs me too, actually.
At a high level, it's correct. However, to improve it, you should break these up into three separate tests, each handling a specific assertion. Doing so is beneficial because one of your tests failing won't impact the other tests. In your example, if your implementation mucks up the strlen check, you lose information about the character range check's implementation until that is fixed. As another poster mentions, you *could* also use a `@dataProvider`. They lend themselves *extremely well* to predefined test vectors provided by a specification ([example](https://tools.ietf.org/html/rfc6238#appendix-B)), and are basically a different name for the same thing. When I use them, I prefer to break valid and invalid values into two separate sets that power my positive and negative tests respectively. I'd also strongly recommend adding a failure message into your assertions; e.g. `$this-&gt;assertFalse(isMD5(''), "An empty string should return false");` As a result, my test for the same code may look like this: &lt;?php class isMD5Test extends \PHPUnit_Framework_TestCase { public function validValues() { return [ ['74fd269c4bbd9cc0300f99a34234c40b'], ['74FD269C4BBD9CC0300F99A34234C40B'], ]; } public function invalidValues() { return [ ['abc123', "Too few characters"], [[], "Wrong data type"], ['abc123abc123abc123abc123abc123abc123', "Too many characters"], ['Xbcd1234abcd1234abcd1234abcd1234', "Invalid characters, but correct length"], ]; } /** @dataProvider validValues */ public function testValidValues($value_to_check) { $this-&gt;assertTrue(isMD5($value_to_check), "Valid value was considered invalid"); } /** @dataProvider invalidValues */ public function testInvalidValues($value_to_check, $reason_it_is_invalid) { $this-&gt;assertFalse(isMD5($value_to_check), "Invalid value was treated as value, should have failed from $reason_it_is_invalid"); } } 
I use Yii, very happy with it. I haven't found a decent Yii v Laravel comparison to date, however so I'm not sure you'll get the feedback you're looking for.
It's not.
Had to look it up before posting the original comment. From the [PSR-1 coding standards](http://www.php-fig.org/psr/psr-1/): &gt; Class names MUST be declared in StudlyCaps. The only reference to Namespace standards is this: &gt; Namespaces and classes MUST follow an "autoloading" PSR: \[[PSR-0](http://www.php-fig.org/psr/psr-0/), [PSR-4](http://www.php-fig.org/psr/psr-4/)\] Still bugs me, but Studly Case namespaces are not required.
Check out... * [Test Driven Development by Kent Beck](http://www.amazon.com/Test-Driven-Development-Kent-Beck/dp/0321146530/ref=sr_1_1?ie=UTF8&amp;qid=1431385900&amp;sr=8-1&amp;keywords=kent+beck+test+driven+development) * [The Art of Unit Testing](http://www.amazon.com/Art-Unit-Testing-examples/dp/1617290890/ref=sr_1_1?ie=UTF8&amp;qid=1431385988&amp;sr=8-1&amp;keywords=the+art+of+unit+testing) Neither book is PHP but the principles are the same. Also, Kent Beck's book walks you through step by step with examples that may prove useful to learning.
I do know html/css. And I could make that sql query after looking up how to do that query. I can't do it by heart just yet 
http://stackoverflow.com/questions/11115533/php-file-put-contents-and-utf-8
We've all been there, glad you've got it resolved. 
Sorry for the late response. I don't have whitepaper or video links discussing this exact topic in mind. I think searching for "intranet security" should give helpful, informative links though. I encourage you to explore this topic more yourself. But yes, once a threat source gains control of a system which has intranet access (employee downloading random file they found on the internet, DMZ'd server hosting an application not properly secured, etc), that threat can then use that infected system as a vector to attack your internal network. Those attacks relaunched from the infected system may include simple xss or sql injection techniques against websites and hostnames found in an infected system's bookmarks, web history, logs, etc among several other ways to discover other machines on an infected system's network. Internal website or application developers seem to have a false sense of security behind their firewall, so common attacks like these could be very successful. [Sony comes to mind](https://en.wikipedia.org/wiki/Sony_Pictures_Entertainment_hack). The exact attack vector there seems suspiciously omitted, but it's pretty obvious what happened. Just like any public facing web service, you're going to have to protect against sql injection or xss attacks from employees' infected PC's, curious employees trying out internally accessible "http://mycompany.com/hr/username/delete" GET requests, clients changing any "USERID" cookie string value to that of any internal IT member's username which gains them elevated privileges, etc. Common sense when developing a public website; common sense when developing a private website.
I see your point here, but I have tested the code and, if the captcha is wrong, then it returns false. I know about the warning you mentioned and for some reason I never fixed it(I will), but I ensure you that is not always returning "success". 
I almost never write functions myself, I stick to classes and methods. But now for a template system I'm authoring, I need to write a dozen or so plain functions. And I'm not sure if I have to stick to camelCase() or under_score() for those. Both styles make me feel a tad uneasy, camelCase for being inconsistent with the rest of the PHP functions, and under_score for being inconsistent with 99% of the code I write. So which one should it be, reddit? echoRaw(); echoHtml(); echoJs(); Or echo_html(); echo_raw(); echo_js();
why build another?
Hey Scott, I just wanna say thank you for all your efforts. Here you are trying to make PHP security better and people on reddit label you as egotistical twat. Ugh. If only people could put more of their time into making something useful instead of hating other people... Anyways, I can see some questions on SO are now open! Keep up the good work.
If your .php file is UTF-8 you don't need to convert anything. If your .php file isn't UTF-8, you should convert it to UTF-8 :) If for some reason you can't, you should do `mb_convert_encoding($string, 'UTF-8', $encoding_of_file)`.
I'm not sure an LTS release is the way to go for CMSes, especially when it's not really long (I'd consider 3-5 years long). Either go full backwards compatibility always (like Wordpress), allowing users to upgrade whenever they want without having to worry about breaking things, or fix security critical bugs in all minor versions so that people don't have to upgrade to potentially backwards incompatible versions to be secure. In any case, good work!
Thank you for the useful suggestions. I got a little ill yesterday so I am in bed now trying to recover but as soon as I am back up I'll work on implementing that. Cheers!
I will thanks 
Easy, don't use ZF2 to build your application! :) But seriously, get something like Xcache, perhaps put some caching in place for your queries, such as REDIS. For the frontend you could also use Pagespeed to help sort it out; ZF2 is relatively bulky right out the box, there is only so much you can do for it's performance. There are plenty of faster frameworks out there...
Does this have any benefit for a PhpStorm user?
why is that every stuff added with composer end up with stupid path names like /vendor/mystuff/MyStuff/mystuff/library/mystuff.php and ugly namespaces like \Joe\MyStuff\MyStuff\ThisTool ? (not entirely sure it's a question or a "wtf bleh ugly" rant, probably both)
You can but you shouldn't) Just use those PSRs =)
Sorry, I didn't mean "you" personally. I just refer to /u/dracony being downvoted here in general. Sorry for the misstatement
Yep. If high performance is an important part of your application, you should probably stay away from most of the popular php frameworks out there. But if you're stuck with ZF2, you might as well make the best of it.
Better than being stuck with Laravel. ;)
What don't you like about laravel?
I..... didn't even know you could do this....... I need to revise my tests.
In order to conserve space the authors have thrown security out the window. Take a look at the source for Twitto: require __DIR__.'/c.php'; if (!is_callable($c = @$_GET['c'] ?: function() { echo 'Woah!'; })) throw new Exception('Error'); $c(); It blindly (without an verification) executes any function with the name passed in as the "c" parameter. That's a huge security flaw. Twittee could conceivably be used as a DI container, and I don't know about any security issues with mu, but these types of projects are not tested, not actively developed or supported (no bug fixes) and are written for brevity, not clarity. I have seen some very small (5-6 line) libraries that are useful, tested, well written, supported and actively developed, but these aren't that. These were one off jokes/programming exercises.
&gt; I'm diving into testing (probably a few years too late) Also, have you tried PHPspec? Might be personal opinion but I found it way more 'accesible' than PHPunit, Jeffrey Way have some good tutorials on testing with PHPspec under his laracasts site. I also started too late with testing, but never looked back ;)
What would you tell to a developer that doesn't want face Magento right now knowing that during this year Magento2 will be deployed and for sure will change lots of stuff? 
Most of the time I copy from a already existing controller.
I'll add: 3. Removing the need to write tedious code to generate fields of radio/check buttons or lists of options for select elements and checking the individual elements for whether or not they're selected. It's a real PITA. As for frameworks, I wouldn't target support for things like Laravel or other full frameworks that have their own templating engines and HTML helpers. The real value of this project is as a component that can be pulled in on code that is without a framework or has been cobbled something together on top of a micro-framework. The only way this would make sense with a big framework is if they were to drop their own implementations to out-source the work to your code. (A real possibility if this thing catches on.) For example, one project that I'm working on is the maintenance and extension of a 90s era PHP application. I've been slowing dragging it into the modern world with Slim and Twig. However, I've had to write my own helpers as I've found them necessary along the way. Having a solid library to do this that I could simply pull in and rely on would be fantastic. If this thing makes it to a good and stable 1.0, I'll probably end up writing the Twig bindings to it.
So is it safe to say: * The model contains the code necessary for retrieving the various data sets you will need, and is instantiated and/or its methods called by the controller so it (the controller) can process the data * The view handles the entire layout, including instantiating a controller and calling its methods where necessary to achieve the actual html * The controller is essentially the engine that uses indicators from the view to produce everything else by utilizing the model for data and spitting that data out in a way the view can make use of it (in so much as the view just basically allows it to do its thing). The controller is like the gun that is aimed by the view and fires ammo supplied by the model? Am I understanding this? An excellent explanation, by the way - this is the first time I have seen an explanation of the concept that showed actual code while making the implementation clear. Converting from non-MVC to MVC really helps in that.
I may have missed something above. What is it that the model and controller are actually doing? It seemed like the controller was driving the operation of the model classes, because it was calling the static methods and processing the returned data. Is there something that the model classes are doing besides providing methods that access data?
Yeah, totally agree about the whole just as much typing thing, I remember some posts / comments a while back about it and people saying the same thing. I guess from my experience at my job with CakePHP, the real value has come more from the Form Helper section of it and the "assets", being able to load them in and cache them and still out put with just `-&gt;image('logo.png')` for example makes life a lot easier. Just seemed as I was doing it, I may as well include some of the other common stuff like lists, we've had a few sites where clients have had the ability to create lists via "Add new item" button rather then WYSIWYG. So having list method to just drop the array results from database into makes life so much easier when doing the templates! As for your points, the basic setup of it *should* check for post data and pre fill automatically, if not there may be a bug. And with validation, I kinda assumed that would be handled by something completely separate, but I guess it could be useful to have some way of adding it if you are wanting to add "error" classes to show error states on certain fields.
Hopefully it will do that for you! The radio type and select boxes just accept an array, which should generate it all for you. I know CakePHP and Laravels Eloquent both have a "list" type method which returns data in the id =&gt; name format which is perfect for dropping straight into the selects options. I guess my plan for it wasn't to target specifically every framework or even attempt to, as like you say a lot of them have all this stuff built in but more provide the ability to. It would have been easier enough to just check for post data within the methods, but for the slightly more effort of creating the interface and abstracting it out, i've instantly made it portable (same with the assets and routes) so that it *could* be attached to any framework if required.
`&lt;form method="post"&gt;` is perfectly fine. Your browser will submit the request to the current URI without a second thought. No `action=""` necessary.
I love you!
Ooh, nice. I'll have to dig into that soon. Starred for now. Thanks!
For self-submitting forms you can just have action="", however, and this may be a heresy, I don't know, but I stopped submitting forms directly through HTML some time ago. I use this: http://malsup.com/jquery/form/ My forms are always submitted to an API which responds in JSON and then I fill-in any validation errors via JS if I have to. Works great, and no more "Are you sure you want to re-submit" messages, or POST/GET redirect gymnastics. With AJAX forms, then, action simply points to the URL the API is at: action="/api/domain/users/create/"
Assuming you have an incoming request, somebody loading the page `mysite.com/blog/post/14`, a router will match the URL to a controller and action. The controller will retrieve the post from the model and select a view to render. The view doesn't talk to the controller, it's the other way around. A controller could render different views from the same action. Somebody could add a query string parameter for response format(not the correct way to do this). mysite.com/blog/post/14 would render an HTML page but mysite.com/blog/post/14?format=json would return a json representation of the object. This is called content negotiation. The controller would render different views based on the request. 
Nice article, but... &gt; class SomeOtherServiceAdapter implements **iStatusUpdate** Please don't name your interfaces with a lowercase "i" prefix, unless your revolutionary interfaces are meticulously engineered by Sir Jony Ive. Just call it "StatusUpdate", or if you insist on following the PSR, go for the redundant "interface StatusUpdateInterface".
Going to have to disagree with you on that one. We've been very successful with Laravel so far. It's very well thought out and has some great functionality out of the box.
How would you envisage that working? Do you mean something like a list of valid attributes and some kind of check against them to prevent them being added if they're not in our list?
Fully appreciate what you mean, I even mentioned it in a comment but as I said in the original description this was purely something for a learning some new stuff and your post hasn't helped at all other then trying to start the debate again on whether Html Helper are useful or not.
I didn't focus on that bit much but thanks for the suggestion, noted :)
Let's break it down, using the real world example of `vendor/filp/whoops/src/Whoops/Run.php` * `vendor` is the directory composer places all dependencies in by default. You can configure this using the [config-&gt;vendor-dir](https://getcomposer.org/doc/04-schema.md#config) option in your composer.json file if you'd like to change where these dependencies are placed. * `filp/whoops` represents the [package name](https://getcomposer.org/doc/04-schema.md#name), and is used to ensure each package has a unique directory to operate within. If all dependencies were placed into `vendor` with no separate directory per package, there'd be no way to prevent filename and directory name collisions. * `src/Whoops/Run.php` is the path to the `Whoops\Run` class, relative to the package root. Navigating to the package's [repository](https://github.com/filp/whoops), we can navigate to see that file. Each one of these directories serves a purpose. Even though it's verbose, it's structured to be easy to navigate and understand.
It's not too bad really, when it comes right down to it, most businesses have very little *difficult* business logic (e.g. Amazon's recommendation system and Google's search algorithms), much more common is complex business logic, which can be difficult to work with, but if you can effectively break down problems and know OOP patterns to implement your solutions, it becomes much easier. I'm not trying to say that most coding jobs are easy, just that you'd probably more intimidated by your first programming job than you'd need to be (I know I was). Also to keep in mind, in my experience at least, it's much better working with someone who has the fundamentals and are eager to learn and grow and work with the team than it is working with someone who is effective but a PITA to work with.
&gt; $_SERVER["PHP_SELF"] Yep. As an example: if your form is www.example.com/submit.php an attacker can do something like this: www.example.com/submit.php/&lt;script&gt;alert(document.cookie)&lt;/script&gt; And many other nasty things such as pulling in a remote image with your cookie sent along with the request.
Technically, not part of a PSR. Just a bylaw of PHPFIG: https://github.com/php-fig/fig-standards/blob/master/bylaws/002-psr-naming-conventions.md But its not totally redundant :p
According to the [HTML5 specification for form action](http://www.w3.org/TR/html5/forms.html#attr-fs-action): &gt; The action and formaction content attributes, if specified, must have a value that is a [valid non-empty URL potentially surrounded by spaces](http://www.w3.org/TR/html5/infrastructure.html#valid-non-empty-url-potentially-surrounded-by-spaces). This means any posts recommending `action=""` are recommending invalid HTML5. Either omit the action attribute or make it a valid non-empty URL. I also recommend `$_SERVER["REQUEST_METHOD"] == "POST"` to see if the HTML method is equal to some value. You are checking that the request method is equal to some value; what does `$_SERVER["PHP_SELF"]` mean? It's just not as descriptive.
Sweet, may be fun to have a play with
[This post could/should help](http://www.sitepoint.com/php-tips-resources-best-practices-2015/).
Laravel is definitely the better framework, but if most of codecanyon's customers are the types that think $5/month DigitalOcean VPS is too expensive, you may have to settle for CI. That said, if someone thinks that $5/month server is too expensive, then so is just about any software you plan on selling them...
I was talking about the simplicity of deploying the app on the server.CI is just zip and upload.How is Laravel ? Every tutorial I read has so many steps which are "hard" for an average customer.Is there any service/package for this kind of a problem? 
In Laravel 4.2 I just just .zip all code (vendor folder) included, and then I changed "public" to "Public_html" or whatever the root on shared hosts is and had the code above web root.
OWASP isn't exactly a standard specification that a piece of software can comply with (it's not like ACID in that sense). What's more is, the majority of technical vulnerabilities are either solved, or created by, the end user. Frameworks can certainly expose vulnerabilities, but you can take an otherwise "secure" framework and use it an insecure way if you don't use it correctly.
Just wondering if I was missing something. Thanks for the reply.
[http://www.phptherightway.com/](http://www.phptherightway.com/)
I think with CI, webroot and application root are one in the same, but I can't remember - it's been a long time since I've worked with CI. You could technically put index.php and all your public assets inside of the webroot, and put everything else outside of it, but then I don't know if that will screw up directory structure assumptions CI makes in the bootstrapping process.
I always have something like `&lt;input type="hidden" name="mode" value="saverecords"&gt;` on my forms. I like for things to be explicit, and I avoid things that look ugly. I find the construct `if ($_SERVER["REQUEST_METHOD"] == "POST")` too ugly to be allowed to exist. Anyway sarciszewski reply is perfectly fine.
You may want to educate the client that OWASP isn't really a specification that can be fulfilled. It's a series of guidelines for best practices, and tips/techniques for penetration testing, but as far as I know (could be wrong about this), it isn't a compliance checklist of items you can say yes or no to. Thus the client is making an orthogonal request analogous to asking you to describe the smell of the color blue or why gravity feels wet. That said, I get the position you're in. I *think* you'd be safe telling the client "Yes, a fresh install of Yii does not contain vulnerabilities as outlined by OWASP, within the scope of its responsibilities.", but someone who knows more about its cookies, sessions, authentication, and encryption libraries would have to verify that. Certainly the client can't expect Yii to be responsible for not leaking information about how your webserver or server folder permissions are set, or how you go about building forms, since it doesn't have control over that sort of thing.
I have to say, this article does come across as if WhiteHatSec is trying to claim they found a new vulnerability here, what with the long table of colliding hashes printed as "found by WhiteHatSec" on right. It's trivial to obtain an endless collection of such hashes. I see nothing new that we didn't know [over a week ago](http://cryptologie.net/article/268/how-to-compare-password-hashes-in-php/). Actually [a year ago](http://pen-testing.sans.org/blog/2014/12/18/php-weak-typing-woes-with-some-pontification-about-code-and-pen-testing). In fact [make it two years ago](http://turbochaos.blogspot.com/2013/08/exploiting-exotic-bugs-php-type-juggling.html). This is a very, very long article that can be summed up as "use === for comparing strings", something many of us PHP veterans knew for years, because PHP has always compared numeric strings like numbers, and not just "0e...", case in point: echo "0000000001" == "1.0e0" // True And hashes forming properly formatted numbers are not an exception in any way.
&gt; Have you ever thought "if only my interface name had Interface in it" No, because i have `Interface` in my interface names. When I `ls` a directory, I don't want to open a file to see if its a class, an abstract class, or an interface. I just want to know. &gt; having both AbstractFoo and FooInterface is kind of cargo-cultish. And no, its not, if they do/provide different things. Sometimes your abstract class provides things that your interface shouldnt have. Sometimes you have multiple abstract classes that implement an interface. I know exactly why i have `Interface` and `Abstract`. I don't need to ask why.
Your code symbol names shouldn't be designed to optimize for "ls". I also want to see what's an interface, so I use an editor that shows me that, and a lot more. I also have an autoloader allowing me to put interfaces in a directory without making a namespace out of it. So several wrongs (lack of proper tooling, lack of proper organization and fixing it with souped up naming) don't make one right.
The model should represent your business logic, the model can be made up of many different classes, some of which will likely have nothing to do with the database. In this example you're dealing with a Post and a User class, these are really entities (although, confusingly, they are often referred to as models). They are part of the the model and for very simple CRUD apps, you may just need these entity classes. For anything more complex you are going to need a whole lot of different classes (see [The Single Responsibility Principle](http://en.wikipedia.org/wiki/Single_responsibility_principle)). Let's say you take Payments, your Payment model may be composed of classes like this: * ProcessesPayments - This is what you would call from the Controller, you give it a PaymentMethod and it perform the necessary actions to process a payment. * PayPal implements PaymentMethod - This is a class that provides the specific details about how to take payments for a specific payment method, in this case Paypal. * Payment - This is an entity, representing a payment from your database. All of these classes make up your model. So, the controller fits in because it's tells the Model what to do based on what the User has provided. You might have something like this: class ProcessesPayments() { public function takePayment(User $userID, $amount) { //take a payment return new Payment(); } } Then your controller: class PaymentController() { public function pay() { $user = getUser($_POST['user_id']); $processesPayment-&gt;takePayment($user, $_POST['amount']); } } The point I'm trying to illustrate here is that the model has no idea what the User wants to do, all ProcessesPayment knows how to do is process a payment, it has no clue how to retrieve a user or get data from the POST request or anything like that. This is where your controller fits in. Similarly your controller should have no clue at all how to take a payment aside from knowing that it needs to call a takePayment() method and provide it with a User and an amount. This is called separation of concerns and is the principle that MVC is based on. So, yes, to answer your question in the example you were responding to, that model was literally just a database layer. In anything more complex than very, very simple CRUD apps you do not want to be putting any sort of business logic in your controller methods and that means you will need to be putting it into the model.
But "Magic Hashes"! It has a name so it must be a real vulnerability! Oh wait...no logo, nevermind.
The language itself should be pretty easy to pick up. Learn bad practices. Learn about the vulnerabilities of PHP. Learning how their code base is laid out will be a bigger hurdle but companies don't expect you to come in knowing (because how could you). Learn what third-party frameworks, packages, and services they use and familiarize yourself with what they do; then move on to learning how they work. I would learn what stuff does by name before trying to master using it. At least that way you can add to conversations in planning and talk the talk.
Ok that clears it up. Thanks!
the assumption was regarding the organization
If you want to know your interfaces are interfaces on the file system, move them to a folder saying so (without this changing their name or namespace). PHP is not Java, so there's no need to tie file organization tightly with namespacing.
oh yea!! tandem, baby!! LOL!!!
I don't want to have to change my directory structure, and thus my organization, just to see if a file is an interface (or even an abstract class). I want things to be where they are organizationally fitting, not just by namespace. Again, you are assuming to know what my workflow/organization looks like...
First, we're discussing hashes in general, not password hashes. Chances are there's one comparison to be made and no second attempt which renders a timing attack impossible. Over the web, the timing jitter from the transport layer is another reason timing attacks from comparing strings are impossible. You pretty much need to be next to the server and have enough internal information to do a timing attack. Timing attacks need tens of thousands of attempts over LAN on an idle server to start revealing the first few characters of a *plain text password comparison*. From there if we add hashing, it becomes a different problem. Add salting, another level of difficulty again. And, of course, a timing attack is particularly impossible **if you block the users** from trying to login after several bad attempts (by user OR ip) that start looking like brute forcing / dictionary attack, which is a **far more likely vector** that we already should block. I've nothing against the password_*() functions, of course, but let's not distort things out of proportion. [Relevant slides](http://www.security-assessment.com/files/documents/presentations/TimingAttackPresentation2012.pdf).
I only know that it's apparently causing you to use your PHP symbol names as a side channel for type information. And that's enough.
&gt;Over the web, the timing jitter from the transport layer is another reason timing attacks from comparing strings are impossible. You pretty much need to be next to the server and have enough internal information to do a timing attack. Which is why you perform thousands of runs from a botnet across multiple users.
Using SELF will work fine, but with 2 drawbacks : * it will make your page code more complex because you'll have to deal with the case when $_POST is submitted * on that page, pressing F5 (reloading the page) will cause the form to resubmit, after it has been processed. I for one always prefer to have forms handled in another file, then redirect to original form with a status message. Edit: "better validation" is absolutely a non valid point. You can completely validate things in a separate handler.php
&gt; is there a better way where there's no php inserted into view code but instead have a way to allow for dynamic page content creation but still only allow for front end tech. You might want to reword your question, because I have no idea what this sentence above means :) If you don't want PHP in your templates, use a template engine, say Twig. But you're just replacing PHP code for Twig code. You still need template code in your template code. And I see no issue with that unless you can hint at it, and then we can discuss it. A view is well decoupled if it only relies on a set of data that the controller (or someone else) gave to it. That set of data can be an object called a "viewmodel" or it can be a simple array of variables (which is more common) which also acts as a make-shift viewmodel for the view.
Hi, I slapped this together this afternoon for a project I'm working - hopefully this will be useful to others! If the unlikely event that spec needs to be pulled back into draft I'll update the library but following the mailing lists this seems very unlikely at this juncture. Any feedback will be welcomed.
That doesn't strike me as a sane rule, just a rule of convenience. The "service" generating a form might be invoked in any number of circumstances. There is no guarantee that the current route maps to a controller which can handle the form submission. It is only a "safe bet" if your conventions tend toward that. The safest rule would be to always specify an action on the form. It's just not "convenient".
Forgive me for my ignorance if you will, but what the heck is a content negotiator? 
The PRG pattern exists because it avoids a lot of issues with browsers, back buttons, refresh etc... These end up being issues when PRG is not used because the HTTP protocol is specified a specific way (i.e. stateless) and the browser is assuming this is the case. When you try and carry state between requests the user agent rightly doesn't correctly handle things, because that's not how HTTP is meant to work. While it does make things like wizards or multi-step forms a little more cumbersome to implement, it is ultimately the best option to use PRG and store progress, partial data and state in a database or another store such as the user's session.
All I have to say is, phpfmt in Sublime &lt;3.
I remember the OWASP site saying *"We now have marketing people saying their products integrate the OWASP Top Ten, which I think is the opposite of what they mean"*
Ok, so modify the "rule" as appropriate for each situation. About 95% of my &lt;form&gt; tags go to the current URL, so there's no need for an action. Sometime I need a form to post data to a different route other than the current page, and it in those cases I'll use an action. 
Are there any other reasons (other than that it takes up extra bytes) not to supply an action if the current and action URLs match, if the URL is programmatically generated?
&gt; pressing F5 (reloading the page) will cause the form to resubmit, after it has been processed. I've heard of some people using a redirect to the original form with a status message, but I don't really see why that's better. First, doesn't that cause the back button to not work correctly if the user wants to go back to a previous page? (I'm not sure if current browsers still have that issue, but I remember when sites that use redirects would cause an issue where you couldn't easily navigate back to a previous page after a redirect.) It also seems like a lot of effort to avoid the theoretical issue of someone pressing reload, but I can't think of a situation where that's actually been a problem on sites I've worked on. If the user clicks reload, the browser actually asks them if they are sure they want to re-submit the form. So if that's what they want to do, then it's clearly intentional. 
Shouldn't the user token part be broken out separately?, this is making an assumption that a future service will require/use a token, and that its a single token and not something more complex. 
But some frameworks do promote bad abstractions for security, for example Code Igniter which doesn't have a template engine that escapes HTML by default, among many other bad practices...
Omitting the action is mainly used when writing the markup manually. If the markup is generated, via a form builder or something similar, and like ties into a routing system, then programmatically is also ok.
Can someone ELI5 what a hash timing attack is? hash_equals() says "Compares two strings using the same time whether they're equal or not." which doesn't make any sense to me. Either two strings are identical (===) or they're not right?
Looks like /r/php still doesn't quite get that "convenience vs sanity" business. 
I would add that submitting back to itself makes the form a bit more complicated to track with things like Google Analytics, since pages are generally identified by the URL. Having the same URL makes GA think you've hit the same page twice, which is technically correct, but for the purposes of tracking, incorrect. For those who care or need to know, the fix is to overwrite the URL recorded by providing a new one with your pageview command ga('send', 'pageview', { page: 'form-complete.php' }); With GTM the solution is to define a dataLayer property name and incorporate it into the More Settings &gt; Basic Configuration &gt; Document Path setting.
True but this is just an example to understand the concept under the hood :)
Here's the brutal truth. It's a legacy feature of the HTTP standard that we're stuck with, intended for times when there were only about a dozen MIME types, so the client would send to the server all MIME types it accepts (in order of preference) and the server would respond in one it supports. Today browsers just tell servers "look here's a kitchen sink of things I accept, but really.. give me ANYTHING, ANYTHING AT ALL, I beg you". Literally, look at the [Accept headers they send to servers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation). Content negotiation has become a joke. There are only two types of real-world HTTP clients: 1. Clients who want EVERYTHING (i.e. browsers). 2. Clients that connect to APIs that provide exactly one thing and the clients only support one thing (HTTP APIs). So although negotiation does satisfy my nerd instinct for theoretical neatness, in practice it's kind of pointless. The only people who take it seriously do take it to a religious extreme, because they think they're implementing the will of "REST" by using the more obscure parts of the HTTP specification. The irony is of course then they use it to implement APIs that only ever respond in one MIME type (JSON) or tops 2 (JSON, XML). But they *had it negotiated*, damn it! They had it negotiated.
Sorry if this doesn't directly answer your question, but just a few thoughts. It sounds like you already got the job, which means your skill set was sufficient enough to get you through the door - congrats, btw :) The best advice I can offer is to simply go in with an open mind, don't be overly critical of the warts in their code, try your best to adhere to their coding standards, and do your best to ramp up on their code base as quickly as possible. Every company (hell, team) has their own way of doing things. Rest up, and be prepared to hit the ground running when you start :)
&gt; Don't take a fucking job that requires something you don't know Right, so teach yourself php first, without a mentor, cause that's gonna work out a whole lot better ...
A Controller in Symfony is just an object; I make them the same way I do the others (normally in my IDE).
Do you know any of the technologies the new company uses? Any frameworks or cms systems etc. If so getting a start on those would be ideal.
&gt; Over the web, the timing jitter from the transport layer is another reason timing attacks from comparing strings are impossible. There are plenty of facts out there to refute this. Never mind that if you're on a common hosting provider (AWS, Rackspace, etc) there's a very good chance that someone determined to do so could actually make requests to your LAN interface and drastically speed up the attack. Yes, you should also be employing rate limiting, and it's *hard* (but not impossible) to execute a timing attack over a medium with unstable latency. That is **not a good reason** to be employing best practices and using timing-attack-resistant password comparison methods. There's literally no downside to following best practices. 
Dude, you're telling people that it's pointless to follow best practices. That's simply incorrect. Please stop. Just because an attack is complicated doesn't mean you're not vulnerable to it. Just because it's hard to do doesn't mean it can't be done, or that a determined attacker won't do it. There are plenty of attacks I don't fully grasp and as a result can't imagine anyone pulling them off. But I'd be reckless (and in my past position, possibly criminally liable) to ignore known solutions to those issues. 
Technically correct, but in practice you'll almost always see either the URL or an HTTP header value change. 
Content negotiation is done with HTTP headers :)
Further reading: - http://blog.ircmaxell.com/2014/11/its-all-about-time.html - discussion on reddit: [1](http://www.reddit.com/r/PHP/comments/2np1uh/remote_timing_attacks_in_php/), [2](http://www.reddit.com/r/netsec/comments/2noudj/its_all_about_time_remote_timing_attacks_in_php/) - [discussion on Hacker News](https://news.ycombinator.com/item?id=8671287) - http://blog.astrumfutura.com/2010/10/nanosecond-scale-remote-timing-attacks-on-php-applications-time-to-take-them-seriously/
This was actually the initial motivation for writing the underlying [content negotiation library](https://github.com/ptlis/conneg) some that this uses (some 8 years ago).
&gt; It's a legacy feature of the HTTP standard that we're stuck with This is only really true for web browsers - there's a whole world of other web clients that **do** care about receiving the correct types.
for something which might keep users of my site, the documentation is terrible. It doesnt clearly tell me when and why it blocks users, whether or how you can train it, how you can whitelist, etc.
Check out the function number_format() number_format($yourNum,6)
If you remove the well thought out part then I agree with you.
It is easier to ask what I like about it. Uh, Symfony component reuse?
Tutorial [here](http://www.sitepoint.com/social-logins-php-hybridauth/).
There is probably already ppa with it for Ubuntu. So it doesn't really matter
Imagine how much more innovative they could be if they used these newfangled technologies like "Composer", "autoloading", "unit tests" and "not appending .class to your class files like it's f*#king 2005"!
This say November this year. But it seems quite optimistic. https://wiki.php.net/rfc/php7timeline
It's fine. Whatever works for the work you need to do. I use a higher level of abstraction because my projects tend to have a lot of stuff tacked on over time, and they're probably going to grow into something much bigger. In my own situation, it would be reckless for me to apply less consideration. But some people just need to hammer out a new website every week. I've been there.
I'd add SuSE to that list. Waiting for something to come up on [OBS](https://build.opensuse.org).
the writing is clunky, but this is the most interesting php article i've read all month!
Socialite is good if you're using Laravel, but if not the League has you covered with two packages, one for [oauth1](https://github.com/thephpleague/oauth1-client) and another for [oauth2](https://github.com/thephpleague/oauth2-client). Socialite actually uses this under the hood and wraps them up with the user authentication stuff, which you could do yourself rather easily. These can integrate with literally any user system and most of the code is in the README.
"Single responsibility" is not objective criteria to judge code by, it's defined by the code itself just as much as by team mechanics, workflows, and business goals. Heck, [the company lawyer may tell you something tomorrow and suddenly you need to refactor your code](http://linuxmafia.com/faq/Kernel/proprietary-kernel-modules.html) differently to account for SRP. So when some bystander says "that's a violation of the single responsibility principle" gently remind them they don't know the responsibilities of your code in order to make that call. And this is also why it's hard to figure out a generic rule for when to create objects locally. "They have no dependencies" is very unlikely. The given example with DateTime is demonstrating this: a class which acts as a window for, and depends on the *global system clock* is not free of dependencies. So if you run tests like "user shouldn't be able to sign in for 1 hour after 10 bad login attempts" you don't want to actually wait 1 physical hour for the test to be done. So then you'd want to inject the clock. But should you always inject it? I don't think so. It's more like: don't try to come up with a simple rule. Accept the subtlety of these decisions for what they are. We can only judge a choice as good or bad in the moment, and even if we have rules, a good choice today easily becomes bad tomorrow. We should feel ok to rely on our gut, embrace refactoring &amp; imperfect design.
(for Ubuntu)
If I'm not mistaken that's when php7 is released, not what OP is asking.
Interesting article, except how he promotes mysqli over PDO. He gets the reason people use PDO wrong. The main reason why PDO gets used more than mysqli is that mysqli is *ugly* hard to use API in comparison. PDO is just easier.
Man, I have such a hard time with Form validation lol
Personally, I find mysqli easier than PDO - but that's because I went from mysql to mysqli, and only looked at PDO later. Often, what you're familiar with seems easier than what you're not.
&gt; The main reason why PDO gets used more than mysqli is that mysqli is ugly hard to use API in comparison. PDO is just easier. How so? The object-oriented version of mysqli is pretty much the same as PDO.
Yeah, that would make me really nervous, I've worked on a site where for a while we were getting loads of requests from a botnet or something, it was hundreds of different IPs, they were trying to send spam emails through one of the forms. The other prevention methods we had in place kept it from sending anything and it was a really light page so it was not having much of an affect on the site, but holding them all up for several seconds each would have destroyed it and the other sites running on our servers. It wouldn't have a huge impact if it was only ever a max of a few at a time and they were tracking how long it took to optimize their spam rate so it would stop doing it after a few attempts, but in the right scenario that could bring your site to a complete halt...
And what about when something goes wrong with your throttling system? Or when your manager makes you disable it because an attacker is trying to brute-force a targeted account and is resultantly DOSing it. It happens. I'm talking about using *all* of the tools available to you, not picking the one that you think suits you best. Having one mitigating factor in place doesn't mean you shouldn't have others. The system is known as [defense in depth](http://en.wikipedia.org/wiki/Defense_in_depth_%28computing%29), and it's widely considered a best practice in the industry.
*ahem* dedicated, custom headers. You know what I meant!
But is the keyword there 'were'? After a brief look at their database examples now I don't see injections, and they show examples both mysqli and pdo. They do seem to skip giving dynamic parameters to the query though...and if left alone the guy learning this stuff might think of a solution by himself... but looking further they do warn about SQL injections on their prepared statements section. Still looks pretty decent for newbies? I wonder if that contact approach would be better? Instead of putting up a site like w3fools.com and hoping that newbie will find it before they find the other one that is left to rot, peope should contact the w3schools and try to improve it. I'm not sure it will be going away soon, so it might be better to make sure it doesn't stink?
I should have known that. Thank you for the info. :)
&gt; And what about when something goes wrong with your throttling system? When a key service is down, other services depending on it also go down. So we'd notice. &gt; Or when your manager makes you disable it because an attacker is trying to brute-force a targeted account and is resultantly DOSing it. It happens. Yes that's a good strategy. When under attack, disable your key defense layers. I have so much to learn. 
I promise you, conversations like that happen. Customers freak the hell out when they start getting SMS messages from your MFA login system when someone is trying to break into their account and ask for it to be disabled. It's your job as the engineer to shut them down as being entirely counterproductive, and indicate that what they're seeing is the system working as it's supposed to.
&gt; I promise you, conversations like that happen. Customers freak the hell out when they start getting SMS messages from your MFA login system when someone is trying to break into their account Good! That's precisely the point of it. BTW it's typically one message. And it says "your account is blocked, but safe, call us to resolve this". &gt; and ask for it to be disabled. It's your job as the engineer to shut them down as being entirely counterproductive, and indicate that what they're seeing is the system working as it's supposed to. I'd actually disable the login for the affected user(s) and give them a special key that enables it, before I start removing layers of my security, but I do find it humorous that a supposedly security-conscious person like you suggests it's perfectly ok to instantly open the kimono once we're under attack and let the attacker attack the system. Getting an SMS or an email is annoying, but it pales in comparison to letting the attack succeed and the hacker getting into people's accounts. You really need to sort out your security priorities.
Where did I say I'd remove layers of security? I'd never do something that stupid. What I actually said was that customers or non-technical folks will ask me to do so. Please go re-read my post.
Would you mind helping me with this? I'm not that good at it; I just know the basics of sanitizing it.
Can you link me to the broken site?
Can you tell me one or a few things you don't like and why? I ask because I use it daily and honestly, quite like it...I am curious why someones experience is different (I am not looking for an argument, I just want to know your perspective)...
Yeah, and Padriac didn't make that claim. Read the first paragraph of the blog post. :P
[Link](http://lp.busbank.com/motorcoach/get-a-quote.php) I'm using a php file to store all my POST data and then it will send an email the client. The problem since Safari doesn't allow "required" in its input fields, anyone can submit even though all fields were mandatory. I'm using this so if there are empty fields, this would come up, but when I test it and actually try to submit a form, it doesn't send. if (!empty($name) || empty($email) || empty($phone) || empty($departure_city) || empty($date) || empty($start) || empty($arrival_city) || empty($end) || empty($busamount)) { http_response_code(404); echo 'Fields cannot be empty!'; } // Send mail
Make sure each of the values ($name, $email) is correctly being populated. Double check that you're using `http_response_code` correctly. Sorry I can't be of more help!
Kinda disappointed /u/philsturgeon wasn't nominated...
You should really try PDO, or an ORM, they're both pretty easy to use. Of course, you'll have to learn a bit, but honestly, it's not that much (basics should take you a couple of hours).
Pay $$$ to Google and get access to their (antiquated) SERP XML feed. That's what several of our clients do and it's the only reliable way to get the results.
This is very true, even Debian LTS is 5.3.3
but it only "seems" easier, often you have to look at objectivity that if you took 2 mins to get used to it, it'll actually end up with tighter code.
It's a very subjective issue. For many people, this is literally a vulnerability within PHP. I don't necessarily agree, but I do look sideways at it suspiciously ;). It's fine for PHP programmers to deny it and point out that it's a very deliberate feature, but we also need to recognise that we must deliberately take steps to prevent it from ever happening while at the same time still calling it a "feature". There is something of a conflict there though we can all find examples showing that being a security weakness and a feature can co-exist (the obvious being that all integers/floats from POST/GET are represented as strings, so there!). The fact is that because of this (and other type juggling examples), we absolutely must use === at a minimum to disable type juggling quite a bit as a security measure. Type juggling in PHP is a security weakness, quite a common one. We're also seeing the release of PHP 7 with scalar type hints designed to eliminate even more of this uncertainty. If you do read the article, you'd discover it's actually a simple expansion of the whole "magic hash" issue's overly narrow focus on 0eN exponents to clarify that this issue was always obvious, quite a bit more broad than just improbable hash values, and has a very simple but critical solution. One, I add, that continues to elude PHP applications even to this day making it well worth repeating regardless of how many times it has been "re-discovered". I also mention timing attacks which are crucial given the growth in cloud computing (many of us are near neighbours now, physical location wise) and the risks of MITM attacks on internal networks (e.g. installed monitors) which reduce network lag, statistically, to a level that *may* be exploitable. So advice about using === alone is outdated and also worth reiterating.
One important point to clarify: Bootstrap or no bootstrap, that doesn't impact on the PHP part, since PHP runs on the backend. It's impossible to guide you through all the bits and pieces (there are some vital things to consider, like security), but here's a few links: Processing external data: http://php.net/manual/en/language.variables.external.php Filter extension for filtering (duh!) and validation: http://php.net/manual/en/book.filter.php Have a good one!
Those are some pretty impressive numbers. I guess a little healthy competition from HHVM really kicked the PHP team in to high gear! That said, with those numbers posted is there going to be any real reason to run HHVM now? If I had the choice between vanilla PHP, and HHVM with all it's caveats, warm up periods, and unfinished modules the choice seems pretty clear. I hope the HHVM team sticks around just to keep PHP honest.
Honestly, until they get their pgsql shit straightened out, HHVM is off the table for us anyway. We're back to php56 and eagerly awaiting php7
If they wanted it to apply to functions, they'd say so. You can refer to a method as "a function", but absolutely no one would call a standalone function "a method".
I've heard the same thing about the memcached library.
I'm just saying I can't use PSR for functions because it deliberately says nothing about functions. PHP uses underscores in its entire library. So we have one hard fact (what PHP does) and one speculation (that PSR suggests method-like naming for functions, which it doesn't).
&gt; But is the keyword there 'were'? It's more that they had to be *given* code in order to update the page. Just because those particular tutorials are free of that particular vulnerability, doesn't mean all their tutorials are suddenly good. Like I said, from the way they run the site it seems like they don't know their stuff. Which does not give me confidence that any tutorial is safe and correct.
I would have used HHVM (and hack) for my newest project if it had proper pgsql support. There is an extension out there for it... but it didn't seem too reliable. I had to edit the C code for the extension just to get it to compile.
Yea, they've had a nice back and forth, sometimes it compiles, sometimes not. Last dozen times I tried it was "not," and I frankly don't have time to fuck with it. I get that it's free and oss, but I can't believe that facebook doesn't use pgsql *anywhere*.
Very possible, but at this point I'd prefer php7 anyway, unless we're talking an order of magnitude better performance. 
I have an issue with that last chart. PHP was faster than Python at rendering a mandelbrot fractal. Yes, because I know that's how *I* judge my web languages. By TTM. (time to mandelbrot) No mention of django, rails, serving pages, rendering views, db overhead, nothing that's actually relevant. 
Some exciting numbers - but we really shouldn't give Magento developers any more reasons/excuses to bloat their framework. 
That's different. Using AJAX implies restful communication with the web backend, meaning that the client JS is actually part of the application layer and therefore OK managing state on its own. What I meant was serving a response to a POST request, that is dependant on the data submitted with that POST request, is an anti-pattern and should be avoided due to the way that HTTP works. EDIT: good reference is how django handles multi-step forms https://docs.djangoproject.com/en/1.7/ref/contrib/formtools/form-wizard/
&gt; If you don't want PHP in your templates, use a template engine, say Twig. But you're just replacing PHP code for Twig code. +1 I couldn't agree more. "Taking PHP code off the templates" never sounded like a good reason to use Template Systems. It's nonsensical, since you just replace one code with the other.
&gt; I know thats just one part of the graphic but: What the fuck did they do with Drupal 8? They moved their entire codebase to Symfony and Twig.
What the hell happened to Drupal? &amp;#3232;_&amp;#3232; ... Or was 7 test not uncached?
Good! I hope they come up with some big returns. 
No but there's about [1.3 million users](https://www.youtube.com/watch?v=0ktiTRwd-pg) for him to choose from, so it's fair enough.
Default php in Ubuntu and Debian is still labeled as php5, not php. Honestly, I'd be surprised if it was in Ubuntu 16.04. I reckon the timing will be too tight.
mobile.dispatcher.class.php
&gt; How so? Try passing an array of bound parameters to prepare() and execute() in each and returning all resulting rows in an associative array. Not exactly a rare use-case. In PDO, easy. In mysqli, awful.
Oh so you're the guy behind http://mandelbrotasaservice.com/ ? /s
It's not about caching fully generated static pages. The core caching in Twig &amp; Symfony are more akin to compiling a program in advance. Twig templates are compiled into pure PHP which removes a huge overhead. Symfony's dependency injector runs a whole bunch of checks when not cached to make sure the whole thing is wired up correctly. Files are combined to reduce disk I/O. All kinds of stuff.
Ah I see, Twig's compiler is horribly slow so if it's running every time no wonder (but are you sure it means that too?). Well I'd be curious to see benchmarks with that "caching" then.
Your example actually demonstrates that SRP is not that simple. The first interface may be just an endpoint facade or an adapter, it doesn't necessarily have to implement the details of its functionality. As an adapter, it's perfectly "single responsibility" in that context. As for your more cohesive classes, I do find it very odd to see Login and Logout broken into separate classes, while it's clear that both refer to the same underlying piece of state "being logged in, or not". It's not very cohesive to me. Can you imagine, say, login running on one set of servers and logout running on another set, with no shared state? Makes no sense, right. So they are one in everything but API. Other suspicious elements include things like Login::viaID() and ::viaUser()... That authentication is not authentication *at all* and I foresee confused programmers crossing architectural boundaries they shouldn't here, possibly introducing security problems in your app. If you'll make an Authentication service, encapsulate it well so it can't be used incorrectly. Your interfaces look like the Command object pattern, but a Command would obviously not have "method commands", it'd be just a DTO with setters and getters, so the way it's factored is kind of confusing. An object is not a verb, and a method is not an adjective. And yet despite the command segregation, you didn't decouple the authentication operation from session management, because your Logout class has the very suspicious "currentUser" method (current to whom? The PHP session... beep). Of course to realize why those are "two responsibilities" you have to know that you'll have, say, API clients which do authenticate, but they don't have a session, they use a bearer token or a similar mechanism. In my apps I factor this in three services: 1. Identity (create user, read public user details, edit user, delete user, authenticate user by returning token). 2. Authorization (accepts token, action, returns if this token can perform this action). 3. Client session (sign in = save the token in the session; sign out = delete token from the session). The last one is more part of the client, a component, not a service, but there you go. Notice Identity &amp; Authorization have no clue whatsoever about a session, which is how it should be as they're typically not even on the same server as PHP and its session files. Long story short, I maintain that SRP is highly subjective and sensitive to context outside code.
As a WordPress dude, I am fucking ecstatic for PHP 7. Who doesn't love twice the speed for free?
&gt; I had to edit the C code for the extension just to get it to compile. Yeahhhh, that's not going to happen, I don't have time for that :P
Too late
Hehehe, [beta blocker.](https://en.wikipedia.org/wiki/Beta_blocker)
&gt; Those are some pretty impressive numbers. I guess a little healthy competition from HHVM really kicked the PHP team in to high gear! Same effect as with competing JS browser engines. I find it very interesting to see competition really bring solid results after years of stagnation. The phrase "competition increases efficiency" doesn't ring as hollow to me anymore.
Will give it a look, maybe find a youtube video or 2 about it :) - thank you!
I do hope HHVM 3.8 flies past PHP 7.0, because this means PHP 7.1 will fly past HHVM 3.8 ;) Repeat until both match the speed of a C application... ;)
I believe laravel, i have no experience with that - but i will give it a look anyway!
Well, Tech Empower benchmarks are quite a bit more realistic: https://www.techempower.com/benchmarks/ Spoiler: Python doesn't fair that well compared to PHP. I actually wrote about how impressive PHP *as a language* is on these benchmarks: http://www.reddit.com/r/PHP/comments/33evlz/techempower_web_framework_benchmarks_round_10/cql8rmh Sure, you can say PHP is just C wrappers for these things… but if that's so why on earth are Python and Ruby scoring so slow? Surely they use C wrappers for many of these things too?
&gt; Other suspicious elements include things like Login::viaID() and ::viaUser()... That authentication is not authentication at all Sure it is. One of your business rules is to login a user after they register. So you have a user or an id, so you can authenticate them with that. There are plenty of reasons to have functionality to authenticate a user on their behalf rather than requiring credentials. &gt; Long story short, I maintain that SRP is highly subjective and sensitive to context outside code. And I maintain there are plenty of indicators within the scope of just a single class to point to problems with its responsibilities. If a class is a facade, the code will clearly show you that. My example is for brevity which is why I showed only the signature, but its intent was to illustrate an actual class that was responsible for doing all of those things.
I don't, but people keep asking me so who knows. I might one day.
What kind of improvements did they make to the VM to achieve such impressive numbers?
New major. Expect BC breaks
Fair enough. This is a very large corporation however, so I'm not unfamiliar with lots of change over time. Coming up on 15 years here, so I doubt I'll be moving anywhere anytime soon. 
Yes and no. I use MySql today, but since I have PDO and (RedBean) I can switch to Postgress or Maria DB. At the rate we are going, if MySql is not performing as well as I want it to I have 2 more options (supposedly better, but I am not going to start that discussion). 
Can I get a citation for the last chart?
Hashtags are #cool.
That would be nice. But HHVM right now has a better chance of that happening. What I would love tho. Is a transpiler from Hacklang to C++. To then be compiled. That would be awesome.
A list of backwards incompatible changes can be found [here](https://github.com/php/php-src/blob/master/UPGRADING). There's a fair number of them, but they're mostly small changes. Most codebases will only be affected be a few of them. Certainly not a Python 2 &gt; 3 situation.
probably, I need a user friendly, database / user driven treeview system. Got a few scripts I could use but need someone able to customize it for the site's needs. I'm a designer so I'm pretty good with creative works and graphics but HTML and CSS are as far as my coding abilities go. 
I believe you can turn the error level up and it will warn you that certain commands are depreciated as well. Should be relatively easy going from once you've identified the problem code.
&gt; Twig's compiler is horribly slow I believe their C extension helps a lot
I'm afraid it's not that simple. Java outperforms all languages you list and it's JIT. It's an interplay of the language's semantics and its engine. JIT allows the code to be profiled as it runs and as it finds hot spots it compiles "traces" with simpler data types than can be discovered ahead of time. I'm basically saying you lose a ton of possibilities to optimize dynamic code if you compile ahead of time. It's not a good idea. It's a good idea for C/C++ because they're not dynamic.
Yeah, it'd be nice if they published their code for those benchmarks too. Often times, benchmarks are inaccurate because they fail to use idiomatic code in the language that they're testing against. A true benchmark on language performance would involve writing the most idiomatic and best optimized code for each language.
It is simple. I don't have to rely on PHP to get my use case of more speed. I already outlined I have more than one option to achieve my goal. Oh and now that golang is now very stable. The community is now focusing on optimisation. I would wager in a couple of years, golang will approach raw c/c++ performance and eclipse java in the process. Java on the other hand, well that has plateaued.
A lot of the python standard library is written in python. This could be the major difference.
I'm able to get the pgsql extension to compile just fine for versions 3.5, 3.6.x and 3.7.
Sadly it crashes very often
You check $_FILES, and if not empty you move the uploaded files and put their names in MySQL with a simple insert query... I know I'm missing the thing you're asking for, but honestly I don't know what it is. Which part specifically are you confused about in the sequence above?
The name confused me with the https://github.com/psecio/gatekeeper by Chris.
I have used https://github.com/Lusitanian/PHPoAuthLib and I like it.
There is no such thing as "at once", the operations are executed in sequence: first process the upload, then save something to database. You can control the flow of the operations (eg: if the upload failed or is not valid, don't save anything to the database) but that's something you have to solve this by yourself. 
&gt; Yes! Joomla has a very nice MVC structure No.... no it doesn't. Joomla's "MVC" structure is about as MVC as Ronald McDonald is Batman. Also, I'm not sure why the reviewer failed to mention you can't develop a Joomla site with xdebug scream enabled because it's cache engine makes liberal use of @ instead of first doing the (faster) `file_exists()` check. Plus the logic is totally backwards, it attempts to write to cache files that don't exist yet, and only when the write fails does it attempt to create it, and then rewrite to it... And really, any sort of strict error checking won't work, since Joomla fills your screen with warnings and notices. K2 (which isn't Joomla core, but is supposedly one of the top content extensions for joomla) is riddled with undefined index notices. As far as the Joomla community goes? Their response to the problems of loose error checking is that "warnings and notices aren't errors, therefore they're not an issue". It's like... "no fuckers, they mean your code is shit and you should fix it". Plus Joomla's extensions and plugin ecosystem is vultureware. They aren't technically allowed to sell access to the code as per Joomla guidelines, but many sell "support", which includes documentation. Or how about one of Joomla's best quirks: you have to hit close or cancel in your current menu context before you can navigate away from something you have open. Or how about another one of Joomla's best quirks: content can't just exist on its own - it has to be added to a menu first. Don't want to display the menu anywhere? Create a hidden menu just so your content can be attached to a menu so it can be accessed. What kind of hacky shit is that? Or how about another one of Joomla's best quirks: an individual post/article has dozens of display settings, that are overridden by the menu item's display settings. But an individual post/article can't exist outside of a menu, *so why does it have its own display settings at all?* Or how about another one of Joomla's best quirks: it's impossible to work on Joomla in a team environment because extensions aren't version-control friendly. Say developer A is working locally and installs an extension. They commit the source code. Then they go to the staging server, and pull down the source, and of course the code is there but the extension isn't installed in the database. That's problem #1, it's not a plugin if the database needs to know about it. Wordpress plugins merely need to be "activated" by pressing a button. WP is smart enough to see source code, and then let you merely activate the plugin if it hasn't been activated in the database yet. Anyway, no problem right? Just have to install the extension zip on staging and the expected behavior is "Oh, source is already here - I'll skip that and just update the database". NOPE. Gives you a big fat error. So now you have to delete the source from staging and then re-upload. Oh but wait, it gets more fun. Some extensions use the extension ID in their CSS classes. So if you unknowingly referenced those classes in your CSS, you've now broken things because when you install the extension, it may be a different ID depending on which order you reinstalled other extensions in...... And that list is just a *short* list of the fun adventures I've had with that train wreck. FTA: &gt; Who is Joomla for? &gt; 60% for the Developer, 20% for the Designer, 20% for the End-User. Joomla still needs a lot of work to really catch up. False. It's for 100% Asshole.
whitelisting ore exceptions would be important for me. whitelisting based on ip and useragents
Most if not all major Linux distros are absolutely terrible about keeping packages up to date. PHP's no exception. I'd expect RHEL (and by extension CentOS and Fedora) to get it before Debian thats for sure. I don't tend to follow Ubuntu so no idea about them.
The fastest PHP Fortunes entry is a [flat standalone PHP file](https://github.com/TechEmpower/FrameworkBenchmarks/blob/master/frameworks/PHP/php/fortune.php) that just calls out to PDO to get an array of Int =&gt; String from the database and spams out HTML directly. The fastest Ruby entry is [part of a Sinatra application](https://github.com/TechEmpower/FrameworkBenchmarks/blob/master/frameworks/Ruby/sinatra/hello_world.rb), using two slim templates (layout and fortune table) for rendering and ActiveRecord for database access. Start layering on similar levels of abstraction to PHP and you find yourself moving down the list extremely rapidly. Similarly with Ruby, when you look at the other benchmarks and see the results with a plain Rack handler and simple database API you rapidly find yourself moving up the list. There just isn't one for Fortunes yet.
Really love the idea and the implementation, nice work! Too bad I switched to UUIDs: wouldn't go back :-) I definitely see the business use-case for this tool tho, useful!
It looks like a really simple to follow interface, I like it. Will stick it on my list of things to play with :) But why use PDO and then not test anything other than MySQL, wouldn't it be better to just support MySQLi? This isn't a dig, I just see PDO being touted as the go-to just incase you ever want to switch DBs but i've never ever done that on a launch product in my life. Also I wasn't aware until recently that PDO doesn't support all MySQL 5.1 functionality.
Those are two very well-designed classes. 
Any reason to not just add a particular number to the id? Or even just initialize the database tables with some random auto increment offset ? Im sure you have a reason to do all this ptime number stuff, but you never explain it in the post
Thanks for the kind words. &gt; why use PDO and then not test anything other than MySQL Because I hope that future versions will add support for more DBMSs.
Thanks :)
Great work mate! Thanks!
Ah. Actually personally I have long stopped using numbers to represent stuff. Whenever possible I like to use the slug, name or some other string field as identifier.
To be fare, showing how fast django is is irrelevant when comparing to php projects, as it will have more to do with, say django vs. Laravel then python vs php.
I have done that a couple of times as well. But if you want to change the slug, then you have to set up a system to redirect the old slug to the new one so that old links don't break. I used hashids a couple of times, but I ended up liking this integer style hashing a lot more :)
http://s3.amazonaws.com/rapgenius/drugs-are-bad-mmkay.jpg (unless you can share)
Thanks, these are interesting suggestions.
So it is a theoretical issue but not a practical issue and if I was really worried I can fix it by the tiniest random usleep (microtime sleep rather then full seconds). The original article would have been a lot better if it went "use === for comparing strings and here is why".
Hi Ocramius, since you're a ZF2 and Doctrine developer, I guess you're using UUIDs with MySQL. I'm struggling about primary key representation with UUIDs (I guess BINARY(16) with UNHEX() inserts and HEX() selects), but I wonder about DB performance. What about your experience?
&gt; and step 3 is raptor attack. agreed, but that's why I'd instead design around duplicate events in transaction managers instead. My point is that so much stuff can go wrong before that, that it's not worth fixing that first. That said, using hierarchical IDs depending on host + hardware info/ + pid + time + rng is a good idea, so I'll look into that for sure.
Came here to say the same. This is how it's done!
Ah, a fellow object variable name capitalizer I see. I too like naming variables after the capitalization of the object class they reference. Helps me know when I'm working with an object vs other primitive types.
Right? I'm glad to know that more people see the benefits. Perhaps, we should form an alliance or something :)
I'm in :)
I'm a big fan of WordPress- very popular and very powerful. It's drawback is the code feels outdated- but that's because it's married to backwards compatibility so nothing breaks when you update. That trade off is fine with me. That being said- I have used and like Drupal 7. It's a solid CMS and just because it confuses OP shouldn't have kept it out of a review of different CMS's. Maybe he shouldn't have reviewed / compared any without having a good amount of experience with each one.
I am in a relatively similar situation, working at a mid-sized enterprise on an internal PHP app, backed by a SQL Server database and hosted on Windows/IIS. Originally the app used ODBC for database queries, but this performed poorly and made debugging difficult (error messages were frequently generic and we'd have to manually run queries in SQL Server Mgmt. Studio to find the *actual* error). Our database related issues have largely disappeared since we switched to Microsoft's SQLSRV driver. Also, I wrote a lightweight wrapper for SQLSRV and MySQLi so I wouldn't have to copy/paste the same boilerplate for every prepared statement and insert query. Check it out at https://github.com/theodorejb/peachy-sql/ - you may find it helpful.
Fucking Joomla. You hit the nail on the head. What the fuck were those retards thinking when they sat down and decided to build that fucking piece of shit. &gt;ou have to hit close or cancel in your current menu context before you can navigate away from something you have open. THAT IS NOT HOW THE INTERNET WORKS, FOR FUCKS SAKE JOOMLA. WHAT IS WRONG WITH YOU Also, the fucking name. Joomla. Sounds like the exclamation of a multi-handicapped kid going on an amusement park ride or some shit. JOOMLARRRH!!! i hate joomla
HHVM still isn't compatible with Zend's generators. This is a major point against HHVM for me. I pinged some people on #hhvm about it yesterday and it's still a low-priority issue. Essentially Facebook has code that doesn't work if the semantics change to match Zend Engine and it's more work than they originally expected. They also don't support double unpacks (ie `$fn(...$bound_args, ...$args)`), which is not as big of a deal but still sucks for anyone doing partial function application. Which means that personally HHVM isn't even an option. I have no idea what its performance is like on my code because I've never been able to use it.
Other than the one fractal test this was PHP, PHP and PHP. The test was the engines running the language, not the language. 
&gt; Yes... which I already said And it deserved reiterating :) &gt; By "simple database API" in Ruby do you mean something like PDO or something like mysqli? Do you mean some level of abstraction to work with multiple DB vendors with the same API, or did you mean to use a vendor-specific API? In terms of their examples, their "raw database access" is just using the Mysql2 library directly. But I'd expect you'd see similar performance out of something like plain [Sequel](http://sequel.jeremyevans.net/), where the ORM layer is optional. Maybe worth some benchmarking.
It's funny, I almost *always* start out like the second line does it, but with a return statement, and then without fail I always need to change something and wish I had just assigned it to a variable in the first place. I really need to start disciplining myself to just do assignment first unless there's an important performance reason not to.
PHPloy now has SSH support. I hope you give it a try.
But tis so offensive to mine eyes!
I see the documentation mentions SFTP. That is FTP over SSL , but it is not SSH. SFTP will not let me issue a remote command on the server such as "ps aux". Further, while ssh is useful, what would be even more helpful is the ability to rsync over ssh. In fact rsync almost pre-obsoletes this tool as it will delete/replace files on the target that are older than files from the source, as well as uploading files that exist in the source, but not the target. That being said, the ability to rsync over ssh, then issue post deploy commands via SSH would be ideal, and make this utility a hell of a lot more useful in real-world scenarios. Another useful feature would be the ability to rollback unsuccessful deploys. What happens if this deploy breaks things? Capistrano has support for this. I would advice looking into it. 
The code looks great, but what happens if the tables' primary key fields aren't named "id"?
I've worked with mcrypt extensively before and my experience with it was pretty horrendous. I probably won't write any cryptographic code any time soon, but it's nice to know there's a cleaner and safer alternative.
I feel that with IDE's and PHP's loose typing, capitalizing variable names has as much potential to be misleading as it does to be helpful. For example, what if a method accepts a string or an object implementing `__toString()`? For example, a Framework's response object that can accept either a raw body string or some kind of renderable view or JSON-transformable collection.
The name of an input variable doesn't have anything to do with the name of the argument, so I don't see how that would be an issue. $StringableObject = new StringableObject; $this-&gt;render($StringableObject); $this-&gt;render('whatever'); public function render($string) { // lower case since used as a string here, even though it came in as an object. }
It won't work. Perhaps, this could be a setter.
Definitely, that would be a good layer to add on top of this. I could see this being a "provider" for something like that. I've sort of made something like that layer with a library I wrote: [Modler](https://github.com/enygma/modler).
Thank you for reading. It's not okay at all, the "not that bad" part is about how Magento 2 is at least attempting to become framework agnostic and making it possible to switch the underlying framework in the future. The "isn't going away anytime soon" line was signalling that though progress is on the right track, it isn't anywhere near finished and ZF1 will be staying with Magento for a while. That Magento is maintaining their own fork is also very typical of how bad the technical debt is that it is even necessary to have such a fork. In terms of updates and feasibility of switching/updating frameworks for Magento 1; not realistic and beyond saving. Magento 1 is basically code frozen and Magento 2 was intended to be a refactor of the former. However, due to massive delays in paying off that technical debt (getting Magento 2 out there), the compound interest is only growing.
&gt; it was effectively obsolete when ZF2 was released in 2012 I think many would argue it was effectively obsolete well before that, regardless of when it was actually officially replaced. &gt; None of these things particularly endear me to Magento. Agreed, but then again having at one time inherited a major(ly botched) project, I'd say nothing will convince you Magento is terrible like working with it. They should have just thrown out the whole stinking pile and used that sweet, sweet eBay money to rewrite ground-up in a modern and performant way instead of putting on conferences and retreats.
Not intended, sure. But the way things are intended isn't always how they're used. My point was that it should be clear that it's not doing anything to protect from injections outside the areas covered by prepared statements and bound parameters. I get that you (and most PHP developers) understand that using it like you stated is a bad thing, but remember that not all developers are at the same level. Some that are starting out may think what you posted is perfectly reasonable...
Hah! `*insert snarky joke about StackOverflow readers here*` But seriously, if you don't have the time and energy to do it right, you're better off using one that has been reviewed by people who know cryptography.
Well since Safari doesn't use the "Required" tag, people can submit the form easily. 
That is 99% of people.
I've been using Laravel for about 4 months, coming off a load of Codeigniter and vanilla PHP legacy projects (or, as I like to call them, Unmaintainable Shitcode). You are a lucky guy. PHP for the web without a framework as elegant as Laravel is like ASP without .Net - a dead end. You're lucky. Very!! Put together a simple Laravel project from a short tutorial. It may seem complex at first but when it clicks, you'll be ok. It still makes me smile on a regular basis - I barely ever have to hand-roll some janky solution to a common problem, because it is either covered already, or I can pull in a Composer package to do it. This just takes the standard of your end product through the roof. 
Even picking the right tools written by other people seem extremely hard. How do we know which way to go? I actually need to do some encryption in a project. What do I use? Should I read up on SSL? Is AES good? Is there some guide I can just follow and know that I've done the best I can?
Find out who the experts are. * [ircmaxell](https://twitter.com/ircmaxell/status/588770036162015232) is a good start; he's generally respected by the community and is responsible for a lot of the PHP features we rely on for building secure apps (including the password_* API) * [padraicb](https://twitter.com/padraicb) has been publishing blog posts about appsec for years; he's a pretty well-known Zend Framework expert to boot * [enygma](https://twitter.com/enygma) publishes a weekly newsletter called [Securing PHP](https://securingphp.com) and has literally written the book about application security in PHP ;) Find someone with a high reputation. Read what they have to say. Find out what they recommend, or who they recommend asking instead. Eventually, you will find someone who is both: 1. Knowledgeable about the subject matter you are asking about, and most importantly 2. Someone who you personally can trust. Then ask them what they recommend. If you want an easy answer, just use libsodium. You're probably not going to find a more secure implementation that works with PHP; and if you do, please tell me.
[**@ircmaxell**](https://twitter.com/ircmaxell/) &gt; [2015-04-16 18:24 UTC](https://twitter.com/ircmaxell/status/588770036162015232) &gt; I make this offer to any open source project. If you have a security issue that you're unsure of, contact me and I'll do my best to help. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
&gt; Why should mcrypt be limited to supporting *only* AES versions of Rijndael? The specific example was the weak key scheduling 256-bit key version of standard AES actually reducing security below the threshold of 128-bit AES. What sorts problems will be found in Rijndael-256? I don't know. As [Taylor Hornby wrote](http://www.cryptofails.com/post/75204435608/write-crypto-code-dont-publish-it): &gt; That’s why you shouldn’t release your crypto code. You don’t know what you don’t know. A cryptographer is a person whose set of unknown unknowns (about cryptography) is a lot smaller than yours or mine. An unknown unknown is a lot less likely to create a vulnerability in a protocol they design, or some code they write (but sometimes it still happens). If Rijndael-256 were a well-studied cipher like the standardized 128-bit variant, I wouldn't have made this claim. &gt; The only real drawback to using mcrypt that the article mentions is that "mcrypt's been collecting dust for 7 years". You're ignoring the performance, the ability to be impervious to cache-timing attacks via AES-NI that OpenSSL offers, and the fact that you have to write *less* code (less code generally reduces the probability of introducing bugs) to get a working implementation working. These are all benefits of OpenSSL over Mcrypt. Given that mcrypt is abandonware, I believe it is a mistake for any developer to build their frameworks or libraries on top of it in 2015.
Have fun with it. I just pushed it onto php-src a few minutes ago :-)
&gt; The only possibly real drawback to using mcrypt that the article mentions is that "mcrypt's been collecting dust for 7 years". &gt; Yet, I don't know of it having any unfixed vulnerabilities so I guess this doesn't matter much, though, does it? Cryptography is not a trendy web framework, it doesn't have to be reinvented every year. Reinvented? No. Updated and patched when necessary? Yes. And that's not going to happen with mcrypt, because it's abandoned.
\o/ Bob just finished this for us ... It'll be in PHP7. Here's the relevant commit: https://github.com/php/php-src/commit/dd17e18f41439ecf04eda48420771e1753ee77cd The dictionary functionality is only available using the new incremental deflate/inflate APIs we added for PHP7. You can see how to use them with dictionaries in this .phpt test case: https://github.com/php/php-src/blob/dd17e18f41439ecf04eda48420771e1753ee77cd/ext/zlib/tests/dictionary_usage.phpt Note that currently if the dictionary used to deflate your strings is stored as a `char*` with `\0` bytes separating individual words you'll need to explode it into an array for use with these functions e.g.: var_dump(explode("\0", $str)); I think we may need to accept *either* a string or an array to support the string dictionary use-case. Let me know if you have input on this.
Thanks :)
I would love to see the OpenSSL extension revisited in PHP7; totally agree there. I don't hold out high hopes though. I didn't know about the libsodium extension, but since I don't use PEAR/PECL, it's not really an option until it's ubiquitously available via Macports, apt-get etc. Same goes for this [openssl-incremental](https://github.com/zingaburga/php-openssl-incremental) extension I found on GitHub.
&gt; I don't hold out high hopes though. If there's enough community demand, I'll write the RFC and send the pull request myself. (After talking it through with, e.g. /u/ircmaxell, first of course.)
Facebook disable dysfunctionality in late 2014
https://github.com/sarciszewski/php-future If I can, it will also go here.
I haven't looked very much, but my first impression is that it seems fairly odd that a "futuristic framework" uses some rather old conventions. Notably the use of "fake" namespaces and including ZF1 directly in the repository versus leveraging composer. My 2¢.
You should add 'off-by-one' errors to that list.
What every one else already said, just one thing that might help, you can set the "name" attributes of your inputs like this: &lt;input type="text" name="contact[name]" ... &gt; When you POST your form, PHP will now receive something like this in the $_POST variable: $_POST =&gt; array( 'contact' =&gt; array( 'name' =&gt; "Bob", 'email' =&gt; "bob@bigcorp.com", ) ) Because of the structure it might be easier to handle the input. Hope this helps.. 
I came in here to drop the same link, but instead, I'll drop this one, which adds PHP autocomple support to ycmd: https://github.com/Valloric/ycmd/pull/120
I started writing https://github.com/cweagans/theforce, but abandoned it in favor of this approach: https://github.com/Valloric/ycmd/pull/120 There's also https://github.com/mkusher/padawan.php, which is similar to my first code completion project. I don't think writing it in PHP is a viable thing - PHP is just too slow to make it happen in a timely manner.
Your goals are commendable, but I think you should start with [what's new in PHP 5.3](http://php.net/manual/en/migration53.new-features.php) and go from there. Also, never develop in isolation - always learn from [the community](http://www.phptherightway.com/) and [competing frameworks](https://symfony.com/), because everyone wants to be futuristic after all... 
Don't. Just don't.
It would. When yours is ready? ;)
Can you put up a sample copy of your .env file?
Please note that this blog post is more like a proof of concept. My target is to help beginners to understand how a webserver on a really simple base works.
&gt; A webserver is a long running process which PHP is not made for. Also PHP does not natively support threading (pthreads), which will make developing a good performing webserver a really hard task. But this might change. I know why you had to write the above - so the zealots don't come with their pitchforks saying the same to you ;) That said PHP not being suitable for long-running processes is a bit of a historical thing, because few versions ago we got a garbage collector which resolves the main point behind "don't run PHP for a long time" (reference loops). Also regarding threads, aside from pthreads, another alternative is a pool of processes (via forking or simply spawning more fresh worker processes). I still wouldn't write a server in PHP probably, but if I had to pick, say, between scripts like Python and PHP... I'd probably have to think about "why not" these days. BTW: &gt; The server responds to client the. Your $blogWriter has a race condition ;)
Im sorry I thought this is the correct subreddit :( Where should I have posted this?
And then I set the value of one of the checkboxes to "1 OR 1=1; -- " and the entire table is deleted. Using user input without validation is an extremely dangerous thing. Please make sure that you always sanitize the input.
Personally, I see there nothing but plenty of bad practicies. First sentence: "Delete records one by one is very time consuming". And then: foreach($idArr as $id) { mysqli_query($conn,"DELETE FROM users WHERE id=".$id); } It is exactly what person who wrote that tried to avoid, isnt it? (;
Another rehashing of the same basic PHP security advice you can see all over the web.
I do validate them in my php file, but my issues are making sure the fields are required. I'm not sure I understand; I don't use the php.ini when I build out my page.
&gt; To clarify: the two to three substantial events we have each you are marketing endeavors, which help close deals, which provide funding. You know what else helps close deals? Having a modern and performant platform. As I point out, it's obvious where Varien / eBay's priorities lie, and it's not on engineering or architecture. That's a fine business decision (obviously all resources are finite, you can't do everything), but don't be surprised or offended when someone points it out.
Sigh... still a typo on his surname. It should be Gutiérrez. Not deleting and reposting. I could get temp banned from posting. :$
I mean, IMHO the elephant in the room is pretty obviously EAV and how shitty it is.
If the goal is to check if the fields are required, you could do something like: $requiredFields = array('field1', 'field2'); function validate($input = array(), $required = array()) { foreach ( $required AS $field ) { if ( isset($input[$field]) &amp;&amp; $input[$field] !== '' ) { continue; } else { return false; } } return true; } if ( validate($_POST, $requiredFields) ) { // required fields are set! } else { // missing required fields! } Edit: Thanks sudocs!
Prefix the code by 4 spaces, and make sure there's a new line before the start indented by 4 spaces
Neat post, but two things stood out: &gt; Imagine being able to put a variable in a JavaScript string in your template, and have the engine transparently encode it correctly for you. Awesome, right? After writing and using an engine like this few years ago, I went back to simple string templates with a configurable global HTML autoencoder (no context). I've realized that not everything that's awesome in theory has value in practice that outweighs its cost and limitations. &gt; Implementing [trie for lexing] in PHP is quite straight forward: I'm a bit puzzled about going this way. Instead of building a slow PHP trie, you can use a regex lexer instead (the regex engine does make use of a trie among other things internally, at C speed).
From the article: &gt; An application service has an important and distinguishing role - it provides a hosting environment for the execution of domain logic. As such, it is a convenient point to inject various gateways such as a repository or wrappers for external services. ... &gt; &gt; In addition to being a host, the purpose of an application service is to expose the functionality of the domain to other application layers as an API. This attributes an encapsulating role to the service - the service is an instance of the facade pattern. Exposing objects directly can be cumbersome and lead to leaky abstractions especially if interactions are distributed in nature. In this way, an application service also fulfills a translation role - that of translating between external commands and the underlying domain object model. The importance of this translation must not be neglected. For example, a human requested command can be something like “transfer $5 from account A to account B”. There are a number of steps required for a computer to fulfill that command and we would never expect a human to issue a more specific command such as “load an account entity with id A from account repository, load an account entity with id B from account repository, call the debit method on the account A entity…”. This is a job best suited for an application service.
I do use the basic santization as well, (trim, !preg_match etc) Here is a snippet of my code. session_start(); $recipient = MAILER; $errors = array(); if ($_SERVER["REQUEST_METHOD"] == "POST") { if (!preg_match("/^[a-zA-Z ]*$/",$name)) { $errors['name'] = "Name is required."; } else { $name = strip_tags(trim($_POST['name'])); } //$name = str_replace(array("\r","\n"),array(" ","\r\n"),$name); if (empty($_POST['email'])) { $errors['email'] = 'Email is required.'; } else { $email = filter_var(trim($_POST["email"]), FILTER_SANITIZE_EMAIL); } if ((preg_match("/[^0-9]/", '', $str)) &amp;&amp; strlen($str) == 10) { $errors['phone'] = "Phone is required"; } else { $phone = strip_tags(trim($_POST['phone'])); } if (empty($_POST['date'])) { $errors['date'] = "Date is required."; } else { $date = $_POST['date']; } // response if there are errors if ( ! empty($errors)) { // if there are items in our errors array, return those errors http_response_code(400); return $errors; } else { // Set the email subject. $subject = "Incoming email from $name"; // Build the email headers. $email_headers = "From: $name &lt;$email&gt;\r\n"; $email_headers .= "Reply-To: $name &lt;$email&gt;\r\n"; $email_headers .= "Return-Path: $name &lt;$email&gt;\r\n"; $email_headers .= "MIME-Version: 1.0\r\n"; $email_headers .= "Content-Type: text/html; charset=ISO-8859-1\r\n"; // Build the email content. $email_content = "&lt;html&gt;&lt;body&gt;"; $email_content .= "Name: $name&lt;br&gt;\r\n"; $email_content .= "Email: $email&lt;br&gt;\r\n"; $email_content .= "Phone: $phone&lt;br&gt;\r\n"; $email_content .= "Date: $date&lt;br&gt;\r\n"; mail($recipient, $subject, $email_content, $email_headers); } }
I would like to state for the record that PHP *is in fact* capable of supporting non-blocking HTTP/websocket servers. It does so with shockingly good performance if you do it correctly. You don't need threads; you need non-blocking socket streams and this something the language provides out of the box with no additional extension requirements. I understand that this is not the thrust of the article -- just want to point this out for the sake of correctness.
&gt; I'm a bit puzzled about going this way. Instead of building a slow PHP trie, you can use a regex lexer instead (the regex engine does make use of a trie among other things internally, at C speed). The regex lexer creates the Trie (well, more specifically a [DAFSA](https://en.wikipedia.org/wiki/Deterministic_acyclic_finite_state_automaton)) at runtime, on every request. Yes, C is doing it, but that's not free. And the more complicated the REGEX, the more complicated the compiling will be. Generating the Trie is expensive, but executing it is *fast*. So I used that as a starting point, and have worked towards a very good outcome (the end product which I'll blog about next week is between 20% and 80% faster than a single call to preg_match for the equivalent list). The Trie was just the first step in that journey...
&gt; The regex lexer creates the Trie (well, more specifically a DAFSA) at runtime, on every request. Yes, C is doing it, but that's not free. And the more complicated the REGEX, the more complicated the compiling will be. PHP has a shared per-thread cache of 4096 (last I checked) compiled regular expressions, so it's not on every request, only the first one. &gt; Generating the Trie is expensive, but executing it is fast. So I used that as a starting point, and have worked towards a very good outcome (the end product which I'll blog about next week is between 20% and 80% faster than a single call to preg_match for the equivalent list). Everything is possible but I just strongly doubt that without seeing both side to side.
password hashing? PHP 5.5 native functions or password_compat. To use anything else is basically irresponsible. Authentication, I just use Laravel's built-in auth library.
As far as I know there's not one specific to Laravel. There *is* one that encompasses all of PHP-land, which Laravel and many other systems use, called [Composer](https://getcomposer.org).
Yeah, I've recently learned Drupal and used it for a few projects. Other than being slow and confusing it is really great. The search in Drupal is pretty easy too, it doesn't have one. Well it does but it works so poorly no one suggests that you use it. Everyone implements Solr or something like that when a real search need exists. But I would choose Drupal over MS Access any day. I guess I am not selling Drupal very well. I actually like it though. I kind of have to since I dedicated a few WEEKS learning it. 
 $ sudo php server 8008 Why sudo? You can bind to port 8008 as a normal user (and any other port &gt; 1024), there's no need to run as root!
not yet
I would have liked to have seen his face the first time he hit the 63 table join limit on a MySQL query. Hell, I'd like to see *my* face the first time I saw that one, talk about wtf... 
Yep. No question that you *can* write a server in PHP, and actually have it work pretty well ([example](https://github.com/Firehed/PHP-MUD/blob/master/app/SocketServer.php) from a project I was hacking at a couple years back) - you should really be questioning whether it's the right tool for the job, though. Then again, people are running servers written in pure JS, where an uncaught exception will crash the whole damn thing (there's no equivalent to `set_exception_handler`), so it's maybe less insane than it would have been considered a few years ago. The performance isn't a huge issue compared to C, you tend to get slightly safer code, and there's a lot to be said in having everything written in the same language. But chances are that if you're debugging your actual server and not just the code running on it, something else has gone deeply wrong - which is why you should almost certainly be using server software that's already out there if you're not just doing a learning exercise.
And a place you can look up packages that are available through composer would be packagist.org (among potentially others, this is just where I always look).
Open Management Infrastructure is exactly what it means. I'd much rather have it return JSON as well, but unfortunately I only have the option between CSV and XML.
Though I'm hardly a fan of XML, I'd go with that. I'm not aware of any major APIs returning data as CSV and it would get really inefficient for any kind of hierarchical data structure.
To be fair, the entire first paragraph is about the history of this problem, mentioning 5 years ago, a year ago, etc. Can you quote from the article where he claims undue credit?
No need to get all shirty. These comments aren't private messages, they're for the benefit of everyone's use.
just use namespaces to avoid collision
&gt; Also as an added bonus question, what do you feel is better to return data in from this API? CSV or XML? Why not both? Use XML by default, and choose CSV for edge cases with lots of table-like data if it's faster. XML is preferable by default because there's one XML format, and most people use compliant parsers and generators, while everyone and their dog has their own subtle take on what the CSV format is, so it should be used with extra caution.
By the looks of it, /u/sarfraznawaz2005 is some kind of RSS aggregator bot.
Would I be able to access the windows username of a user visiting my site with this?
Unfortunately not (or fortunately). If you could, that would be a mighty big security risk, harkening back to the dark ages of insecure Internet Explorer versions &lt;= 6. All this can do is access the Registry on the server that PHP is running on, so you *could* get the Windows username (or profile name, or login info, or IE homepage, etc.) of the user the server is logged in as.
Ironically, I rarely use Windows these days, but I used to run PHP sites behind IIS 6 a lot back in those days, and PHP and IIS didn't play all that nicely together back then. IIS stored a number of useful information in the Registry, so my site would access that info to determine how to serve content-types, since it had some strange bug on how it overrided Content-Type depending the server environment. I can't remember the details, but it led me to start this library, and I've added to it since then.
Something made an impression on me on a second glance: &gt;The problem that I ran into was that JavaScript has a non-trivial amount of tokens. But the real problem is the regular expressions. For example, Numbers can be defined in a lot of ways: &gt; &gt;/0[xX][0-9a-fA-F]+/ &gt;/\.[0-9]+/ &gt;/\.[0-9]+[eE][0-9]+/ &gt;/\.[0-9]+[eE][+-][0-9]+/ &gt;/0/ &gt;/[1-9][0-9]*/ &gt;/0[eE][0-9]+/ &gt;/[1-9][0-9]*[eE][0-9]+/ &gt;/0[eE][+-][0-9]+/ &gt;/[1-9][0-9]*[eE][+-][0-9]+/ &gt;/0\.[0-9]+/ &gt;/[1-9][0-9]*\.[0-9]+/ &gt;/0\.[0-9]+[eE][0-9]+/ &gt;/[1-9][0-9]*\.[0-9]+[eE][0-9]+/ &gt;/0\.[0-9]+[eE][+-][0-9]+/ &gt;/[1-9][0-9]*\.[0-9]+[eE][+-][0-9]+/ Why list all those? You need one for hex, and one for decimal. A quick take: &gt;/0[xX][0-9a-fA-F]+/ &gt;/([0-9]+|[0-9]*\.[0-9]+)([eE][+-]?[0-9]+)?/ P.S.: Reddit eats backslashes.
Thanks Andres, you're a great talent doing all kind of stuff that would be quite hard for most of us. You've done an amazing work developing and leading the community to create Phalcon &amp; Zephir. We have used Phalcon in our company for more than two years and we really respect and appreciate your work. Keep up the good work.
OMI? Only company I know that uses that phrase is a company called Zonar.
Also, thanks! Positive feedback helps too!
&gt; I thought the same thing. I wonder if it's because your 2nd regex requires backtracking and none of the ones on the long list do? Notice how none of the expressions in his list contains a | or ?. I think there's less backtracking to do in the short version. For example imagine on the long list version a naive implementation scanning 0.5971 on the "with e" regex, only to find no "e" follows. It'll need to forget the "0.5971" part and scan it again with the other variations. In my version it's the same regex with an optional subpattern, so it keeps moving forward. If "e" is there, fine. If not, also fine. &gt; Also, your second one allows patterns that aren't included in any of the above list. Like 00008, although my console happily evaluates that, so maybe it's valid after all... Hmm. Yeah it seems it's accepted by engines. The regex can be edited to accommodate the rule, **however**, see the issue is just implementing the standard is not enough to create a safe context-sensitive escape engine precisely due to little loopholes like these. Unless one parses the entire source and *regenerate it* so any abnormality goes away, there's no saying how a browser might interpret a given edge case. This is in part why I gave up on template engines that fully parse the source. It's a ton of work and you still can't cover edge cases, unless you go all the way with runtime DOM generating the final code (at least there's value in that: you have full control, yet you can't produce invalid code in your templates).
As far as I can tell this is the correct subreddit. Thanks for posting this. 
&gt; $cart-&gt;flash(); You surely didn't mean flush, did you?
I'd suggest 'empty' as that's what it does, it empties the cart.
https://github.com/snipe/snipe-it, perhaps?
Thank you for your feedback. I have used `illuminate/support` package as it comes with a lot of flexibility and it does not required Laravel. Taylor already made this package framework agnostic. In addition, `illuminate\support\collection` will allow users to use a lot of goodies: - Sorting cart products - Chunk - count - slice .... Thank you for the suggestions about shipping, discounts and taxes. I have added them in my check list. I will soon write the unit tests for this package. Thanks again for this feedback, it will help me a lot.
&gt; it's obvious where Varien / eBay's priorities lie, and it's not on engineering or architecture. There are a couple hundred people in the product &amp; engineering teams who'd disagree with you. Magento 2 doesn't suck - there's a performance benchmarking kit for all to use to verify this. Guess we'll see more in Q4 when it is released. Varien hasn't been a thing in years BTW. They became "Magento" several years back, before the acquisition. Not sure where we headed with the eBay Enterprise spin out. Hope I didn't/don't seem offended. I'm keenly interested in opinions and ideas about Magento and like to point facts out when and where I can. 
How would you solve those design challenges? Canonical values with translations, arbitrarily configurable attribute sets, facet configuration... These are really tough problems. Flat index tables have been around since 2009 to reduce overhead. 
My philosophy is that there is a time and a place for everything, even Singletons. I liken Singletons as if it were table salt: if you use just a dash here or there it can make your application better. If you use it too much then it'll make your application "sick to its stomach" and other bad problems - mostly in code maintenance and testing. As for testing any private method, PHP helps to overcome that feature through the use of Reflection: $s1 = MySingleton::instance(); $s2 = ( new ReflectionClass($s1) ) -&gt;getConstructor(); $s2-&gt;setAccessible(true); // If you need to pass arguments, // use ReflectionMethod::invokeArgs() $s2 = $s2-&gt;invoke($s1); assert('$s1 === $s2'); // rest of code... http://php.net/manual/en/reflectionclass.php http://php.net/manual/en/reflectionclass.getconstructor.php http://php.net/manual/en/reflectionmethod.setaccessible.php http://php.net/manual/en/reflectionmethod.invoke.php http://php.net/manual/en/reflectionmethod.invokeargs.php Now, in my opinion there is very little good reasons to use Reflection is this manner. The main one is testing. My testing philosophy is "if it contains logic, test it" and "if it cannot be tested, refactor it so that it can be tested". If there ever comes a need to have a second instance of a Singleton outside of testing, then it might be time to consider a different design pattern. For instance there is Registry, Service Locator, and Dependency Injection. Use the right tool for the right job, and make sure you make your code testable. Even if you don't test your code, you'll thank yourself later when that one rare edge case happens and you need to change something that would've been impossible otherwise. Edit: fixed links 
Sometimes a task doesn't need the overhead of a full blown abstraction layer, but the use of a Singleton might be sufficient to get the job done. If you're your own boss, or the lead architect of your project and can lay down absolutes like this, good on you. For the rest of us, sometimes we have to balance what is socially cool and socially uncool with getting our jobs done in a timely and efficient manner. Whether people consider Singleton to be an anti-pattern or not - which the author conceded to in their article - there is room in everybody's toolbox for things like this; if for nothing more than a real understanding of how it works, and not just the parroted "Singletons are bad" dogma from someone on the Internet. 
Bcrypt
I don't see how this prevents the package from being framework agnostic, it's just a standalone component, it isn't tied to Laravel in any way, it's the same as using a Symfony component.
&gt; There are a couple hundred people in the product &amp; engineering teams who'd disagree with you. Don't get me wrong, I'm sure all the technical people working there including yourself are fully competent and probably damn good at your jobs. Do all of them agree that a continuing dependency on decade old code was a good idea for v2? I doubt it, but I also understand how companies (and these sorts of decisions) work. &gt; Magento 2 doesn't suck Awesome, it's good to see you stand up for your product, and maybe you're right. I bailed after the 1.4-1.5 days, so I haven't really messed with it too much beyond poking at the source. I probably won't return for a serious look until it undergoes a complete rebuild. &gt; Hope I didn't/don't seem offended. Arguing with other developers about opinions on technology is pretty much our second job (or should be). I'm sure we'll both sleep fine tonight... 
Naah, just make your small package and use it if you want. No need of C to implement stuff like this.
You're right, none of these are particularly trivial problems. That said, IMHO the necessity of the (at times pretty flakey) indexing system to apply EAV to the problems indicates to me that EAV isn't an appropriate solution. It may have been the best feasible choice at one time, but that's no longer true, which is why I think it's unfortunate that the Magento architecture is still coupled with it. 
Hi Anthony, in your blog post, the tokenization result of ``result = 5 + 13;`` misses the tokens for `` =`` (and a single space which will not show up before or after the equal sign, grrr). 
Oh no don't get me wrong they're not all decoupled but at least illuminate/support is, it doesn't get any more low-level than that, it's really just string and array helpers.
It also depends on [illuminate/contracts](https://github.com/illuminate/support/blob/master/composer.json#L19-L20), which brings in a pile of interfaces that are specific to Laravel. 
Can you elaborate on how you use Phalcon and the benefits it has been giving you?
Can you ask the host to update it? Or would they generally not do it? Depends on the host? 
`empty` is a reserved word, so you can't have that. http://3v4l.org/9jdqb
`array_pluck` already exists as `array_column`, while `starts_with` and `ends_with` probably has quite a few collisions with existing implementations (but would be useful in the core, sure - but will cause quite a bit of BC in non-namespaced code).
Good solid constructive feedback. 
I use xdebug daily... But how do you inspect the return value within the function without assigning to a variable? 
Good point, bring on the context sensitive lexer.
&gt; As for testing any private method, PHP helps to overcome that feature through the use of Reflection If you're trying to test private methods, you're doing it wrong: your tests are coupled to the class's implementation details instead of its public API. This makes refactoring much more difficult because you can't change the class's internals without potentially rewriting tests. &gt; If there ever comes a need to have a second instance of a Singleton outside of testing, then it might be time to consider a different design pattern Given the potential difficulty of converting singleton usage to proper DI, I think the relatively small cost of injecting an instance is far outweighed by the benefits.
Here is a good place to start. http://www.phptherightway.com/
singleton / multiton pattern can be an outside service, the behavior doesn't need to be inside the class itself. See Containers.
Learning OOP in PHP. A collection of resources to learn object-oriented programming and related concepts for PHP developers. https://github.com/marcelgsantos/learning-oop-in-php
We will likely use the minimum version bump to decide what the framework version bump will look like. `Zend\Foo` and `Zend\Bar` will be independent, but package `zendframework/zendframework` will be bumped according to the versions of all the minor packages that it includes. Given an `x.y.z` naming: - if packages were only updated in the `z` part, then `zendframework/zendframework` will be bumped in the `z` part - if at least one package was bumped in the `y` part, then `zendframework/zendframework` will be bumped in the `y` part - if at least one package was bumped in the `x` part, then `zendframework/zendframework` will be bumped in the `x` part (once ready) So yes, a lot of moving parts, but much better maintainability as well. There are also a lot of considerations about integration testing, but we'll get there :-)
&gt; For the rest of us, sometimes we have to balance what is socially cool and socially uncool with getting our jobs done in a timely and efficient manner. Woah, there. I know it's a hot button topic, but don't ignore the real reasons behind avoiding Singletons. And all you need to do is cut that "getInstance()" method from class Foo and paste it in your application (context/factory/config/container, pick one) class and rename it "getFoo()". Simple. It's neither "inefficient" nor done only to be "cool". Get burned a few times, you'll come around. The problem is, as a developer of component Foo, you do NOT know AppBar needs one instance of Foo, until you write app AppBar. More importantly, you do NOT know the app itself is a singleton. What if you need AppBar and AppBaz running together with different Foo? That's the kind of situation that becomes the norm when you factor your code into app modules (vs. a giant monolith). Multiton is a touch better, but you're now maintaining a global (for that class) table of string aliases for configurations, which means all users share that table and need to go through your multiton configuration process, be aware of the strings in the table, and avoid collisions. tl;dr Libraries that think they know apps better than the app developers end up producing code which is harder to reuse. The goal here is no dead ends in reusable code. Leave factory's job to factories. P.S.: There are rare-as-a-unicorn cases where *tons can be useful. For example if you model Boolean as a class, you might want to have the true/false object instances as singletons.
Thank you for the feedback. However, `$cart` is not a Singleton. See the below example: $guestCart = new Cart('guest'); $guestCart-&gt;add([ 'id' =&gt; 1001, 'name' =&gt; 'Skinny Jeans', 'quantity' =&gt; 1, 'price' =&gt; 90 ]); $userCart = new Cart(Session::get('username')); $userCart-&gt;copy($guestCart); var_dump($guestCart-&gt;items()); var_dump($userCart-&gt;items());
&gt; I just can't trust the code of someone who can't write properly. Really? It's a long tutorial, typos happen. Relax. No computers will be harmed in the execution of this code.
Use four spaces at the beginning of the line, it will leave what you typed alone.
I knew it. I knew someone would link to this as if it's a good place for a beginner to go. It's not. It's where a seasoned PHP developer who is looking for best practices and modern PHP development should go, it's not where a beginner should go.
Thank you for the feedback. This will help me a lot.
[Oh, hi there!](http://cdn.meme.am/instances/500x/62267058.jpg) Yes, I do. I watched their presentation and I've inspected several implementation of Flow in the wild. It's MVC combined with the command pattern. Facebook's interpretation of what they called "MVC" (as seen in diagrams during the presentation) was incorrect which was pointed out by dozens of programmers (look for comments below the videos), and their Flux diagram much more closely resembled the MVC pattern (albeit with components named differently). BTW, I never miss the opportunity to educate those in need, but I won't respond if you insist on going through my comments, being rude :) If you want to ask, ask *nicely*.
Unit tests will be added soon. Thanks.
So I guess my question isn't how to structure the response, but more of the directory structure and Web server config that allows you to serve the API as well as the js. Let's assume any popular mvc is in use with the standard webroot/public folder (cake, laravel, etc.) Thanks for the help so far!
If you use any popular MVC, all requests likely get redirected to the same file, let's say start.php. From that point you can pass it to the router, which finds a controller, which renders a template (view). Unfortunately the routers in many popular MVC frameworks are a bit limited, but you can get around it. Go in that start file, and check if the URL begins with /api/. If it does, call your custom service router, otherwise pass along control to your standard MVC framework router (for controllers showing HTML pages). For your service router, files and directories don't matter. Only objects and their properties and methods do. And objects are of a given class, so class organization I feel is best done the way you usually do it (in a PSR-4 style tree, like in Java). I organize services in "endpoints". An endpoint is a simple object, with simple methods, where a method receives and returns only PHP scalars and arrays (so it can be serialized as form fields, JSON etc.), and not complex objects. So if you have an object like $domain, -&gt;users is a sub-endpoint in it (a public property) and -&gt;create() is a method on $users, nothing abnormal here. Your service router has to use [reflection](http://php.net/manual/en/book.reflection.php) in order to map your URL from this: "/api/domain/users/create/" to this: $domain-&gt;users-&gt;create() in a for() loop. Then you can call the method with (in the simple case) $_POST and echo the result encoded with json_encode(). And that's the whole thing. The use of reflection means you don't write manual routes for your services and when you change your service endpoint objects/methods, your URLs automatically are in sync with that. Your controllers will use the object endpoint directly ($domain-&gt;...) and send and get back arrays; while your AJAX code will use "/api/domain/..." and send forms (or JSON) and get back JSON. P.S.: Regarding your static files, you can just organize them any way you want in a folder like /assets (or even off the domain). I don't think there are any special considerations here. **EDIT**: I have the feeling I'm still not answering *quite* what you need answered ;) Ask more specific questions?
Well I'm just specing out the project now. How would you go about doing it? I def. Want an api separate from the front end for ability to use the same backend with the Web, mobile apps, etc. 
Make something like api.mycoolapp.com your backend service. PHP, Node, Java, whatever. The important thing is no public folder allowed. The web client can live at www.mycoolapp.com. No server-side code allowed. I like Amazon Cloudfront for this but it can be simply S3 or whatever else you like. Then you set up nginx or whatever you use on your api to allow CORS requests from www (you just have to add some HTTP headers and respond to OPTIONS requests so it shouldn't be difficult), so that you can just use jQuery.ajax calls to it (for example) and stay completely restful. The strict decoupling makes a lot of things much easier later on. Caching is much simpler when you can use one policy for all your frontend assets and it doesn't affect your API. Consuming your API from your web client will also make your usage that much clearer when you develop other clients.