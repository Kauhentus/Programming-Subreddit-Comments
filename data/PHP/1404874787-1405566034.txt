Which quickstart are you looking at? The quickstart on laravel.com shows: 1) running composer install to get the framework 2) configuring homestead (which gives you a virtual machine to run so you don't have to gin about with configuration, xampp etc) 3) setting up routes 4) creating a migration 5) executing the migration 6) way more stuff... And it isn't just copypasta of a terminal output into an ad infested website to boot... 
I'm not sure where to begin. You're pretending to compare Javascript and PHP, but you're really comparing async versus sync IO. No surprises—they perform differently. &gt; drastically improvising performance by leveraging the benefits of functional programming Non–blocking IO and an event loop is what makes Node quick with high–concurrency, low computation workloads, not functional programming (incidentally, despite having functions–as–values, Javascript is still a crap language for functional programming).
Are they just IUS or remi packages?
I have this same issue - always have in fact. For a while I was worried I had some weird variation of bipolar disorder where I would have these almost manic productive streaks that would last 2 or 3 weeks or so, followed by complete detachment from coding what-so-ever. What bothers me the most is that I have close network affiliation with a number of companies in my area that are literally throwing work at me. I could easily make $150,000 this year between my full time job, and all the freelance stuff being thrown my way. And the freelance stuff I would get to do would be fun - a solid mix of staying in my comfort zone where I will be most productive, but also learning new ways to apply what I know and gently expanding that comfort zone in the process. But I feel like I'm burned out, and just can't bring myself to do it, even thinking about all the toys I really want. I really wish I were as hungry for success as I was when I was younger.
lol, i was more looking for what would happen if you pass something that doesn't match the typehint.
Michel Bartz steals the show. 
Great post. I just discovered the box app a week or so ago and it made my life a lot easier, so I'm happy to run into another of your projects.
The same thing /u/reinink said. The *whole* purpose of having a separate model, controller, and view layer is being able switch out any one of those components without changing the others. In other words, the *same* controller (and method) is used to render HTML, XML, or JSON, and each of those formats has different escaping needs. You can't run your data through `htmlspecialchars()` within the controller, because the controller doesn't know whether HTML is being rendered. This is the entire fundamental point of MVC, and it's the reason so many of us like it. With MVC I only have to write one controller method to render my site as HTML and as an RSS feed and as a JSON document. I'll demonstrate what I mean. Here is The Micro-Reddit PHP Framework™. Holidays.php &lt;?php namespace RedditFramework\Model; class Holidays { /** * Returns an array of all important holidays * * @return array */ public function findAll() { return ["New Year", "Easter", "Halloween", "Christmas"]; } } HolidaysController.php &lt;?php namespace RedditFramework\Controller; class HolidaysController { /** * @return array */ public function holidaysAction() { $holidays = new Holidays(); $rows = $holidays-&gt;findAll(); return ["holidays" =&gt; $rows]; } } holidays.html.twig &lt;ol&gt; {% for holiday in holidays %} &lt;li&gt;{{ holiday|escape }}&lt;/li&gt; {% endfor %} &lt;/ol&gt; ViewInterface.php &lt;?php namespace RedditFramework\View; interface ViewInterface { /** * Renders the controller results * * @param array $data The controller results * * @return string */ public function render(array $data); } HtmlView.php &lt;?php namespace RedditFramework\View; /** * Renders an HTML client response. */ class HtmlView implements ViewInterface { /** * {@inheritdoc} */ public function render(array $data) { Twig_Autoloader::register(); $loader = new Twig_Loader_Filesystem('/path/to/templates'); $twig = new Twig_Environment($loader, array( 'cache' =&gt; '/path/to/compilation_cache', )); $template = $twig-&gt;loadTemplate('holidays.html.twig'); return $template-&gt;render($data); } } JsonView.php &lt;?php namespace RedditFramework\View; /** * Renders a JSON client response. */ class JsonView implements ViewInterface { /** * {@inheritdoc} */ public function render(array $data) { return json_encode($data); } } index.php &lt;?php namespace RedditFramework; // Dispatch the request. The HolidaysController will handle requests // for the path "/holidays". Any other path is a 404, which is handled // by the ErrorController. if ($_SERVER["REQUEST_URI"] == "/holidays") { $controller = new HolidaysController(); $result = $controller-&gt;holidaysAction(); } else { $controller = new ErrorController(); $result = $controller-&gt;error404Action(); } // The "Accept" request header tells us whether the client is requesting // an HTML document or a JSON document. Base on their choice we will // render the data returned by the controller using either the HtmlView // or the JsonView rendering engines. if (empty($_SERVER["HTTP_ACCEPT"]) || $_SERVER["HTTP_ACCEPT"] == "text/html") { header("Content-Type: text/html"); $view = new HtmlView(); echo $view-&gt;render($result); } else if ($_SERVER["HTTP_ACCEPT"] == "application/json") { header("Content-Type: application/json"); $view = new JsonView(); echo $view-&gt;render($result); } else { header("Content-Type: text/plain"); http_response_code(400); echo "Unable to handle request"; } MVC was designed to work just like my little example. Same model, same controller, but different views depending on the client request. Values *can't* be escape in the controller because the controller doesn't know which view is being used, and it certainly doesn't know how that view wants it's data to be escaped.
oops. I should have realized not to post this in the PHP subreddit! The PHP guys, will obviously not like it when something gives better performance than PHP ;-)
Type hinting enforces expectations about a parameter. It's how you make sure that the thing that is passed to your function/method is a specific kind of thing that you know how to work with. Imagine we have the following code to define ways to send alerts from our application. // this interface unifies how we send alerts interface AlertInterface { /** * We can't specify type hints for primitives in PHP but we can in phpdoc blocks. * Smart editors will help you out in code completion. * @param string $message */ public function alert($message); } // this class lets us send alerts via email class EmailAlert implements AlertInterface { public function alert($message) { // we have to deal with edge case that something that wasn't a string was provided to this method if(!is_string($message)) { throw new \RuntimeException("You didn't pass a string to alert! It only accepts strings."); } mail("admin@example.com", "Alert!", "$message"); } } // this class lets us send alerts via text message class TextAlert implements AlertInterface { public function alert($message) { // we have to deal with edge case that something that wasn't a string was provided to this method if(!is_string($message)) { throw new \RuntimeException("You didn't pass a string to alert! It only accepts strings."); } $sms = new SMSService(); $sms-&gt;setTo('555-5555'); $sms-&gt;setMessage($message); $sms-&gt;send(); } } Then, imagine you want to add the ability for some code to issue an alert. For instance, a job that runs in the background. (Note most of the job code is omitted, only the important parts are kept). class Job { protected $alertMechanism; /** * We've used a type hint (both in the phpdoc block, and in PHP code to enforce what we expect to be provided) * @param AlertInterface $alertMechanism */ public function __construct(AlertInterface $alertMechanism) { $this-&gt;alertMechanism = $alertMechanism; } public function execute() { // omitted // .. // $error = true; if an error occurred if($error) { $this-&gt;raiseAlert(); } } protected function raiseAlert() { // notice we don't check if alertMechanism has an "alert" method? Or that its even an object? // we can safely assume because we used a type hint. It's impossible for alertMechanism to be // anything other than something that satisfies AlertInterface $this-&gt;alertMechanism-&gt;alert("Job failed to execute!"); } } 
You are the Nancy Grace of engineers. Instead of clinging to your unfounded conclusions, perhaps take a moment to learn from all the people that are willing to participate in your forum. 
Setup a satis server so you don't have to rely on packaging everything you install. 
isnt like there were migrations before that... 
hi privateclick i have posted the question in other category. But no response so though asking this question. Also you have mentioned some framework in above post, see different framework have different feature. So people who are creating new framework will have different feature in it. In your post you have mentioned you have to rebuild after they left. that means from begins its self wrong.
Rather than rewriting I will say to refactor the code with using different components available in the PHP. Probably the video http://paul-m-jones.com/archives/2667 by /u/pmjones and the book http://mlaphp.com/ may help you how to convert to a better system.
I feel like I'm missing something here. What you've done is taken what would be dynamically built by your controller/model ("// Send the response!") and hard-coded it... somewhere? I just don't see how this is extensible. What's being gained here?
Could you explain this process a little or link me to some good (preferably AWS) docs about this? Very interested. 
Because it knows the output type it's sending? I don't understand what I'm missing. If it's sending HTML escape for HTML. If it's sending JSON escape for JSON. If it's sending XML escape for XML. Am I totally crazy here?
I already answered that question. &gt; With MVC I only have to write one controller method to render my site as HTML and as an RSS feed and as a JSON document. I don't know what you mean by hard coding. Perhaps you misunderstood the purpose of my example. 
&gt; I've only had to update a schema because of changing enum values a few times, and updating a table with 50 million rows only takes 10 minutes It's not about the machine time it takes, it's about the time it takes to a human to write the code to do it and deploy it on each machine. And all enums are not finite : I have many projects where enum change often, like a list of jobs people can have inside an adminstration, or a list of center type. And even if gender do not change, I witnessed a change in salutations lately, from Miss, Mr, Mrs to just Mr and Mrs. As per the storage problem, I don't deal with big data, and I feel this is micro-optimization. Thanls for the index trick though, it's interesting. And also : I'm not using Mysql anymore, I know postgresql has something similar, but I haven't looked into it that much.
I am forced to use MySql Workbench all day, every day. It's a piece of shit. Crashed on me once already today, I expect more by the end of the day.
Someone on IRC suggested that I could signup for a micro AWS instance and host a demo on there. I will take a look in a few days!!
Yeah, I realize this is kind of a lousy example. I could express myself better if I knew which frameworks you use on a regular basis. I've edited my example to make things more clear. My example is a pseudo-code representation of an entire MVC framework. The Holidays and HolidaysController classes shouldn't need any explanation. `ViewInterface`, `HtmlView`, and `JsonView` are tiny pseudo-code representations of a much larger view enguine. For example [Zend\View](http://framework.zend.com/manual/2.0/en/modules/zend.view.quick-start.html). Pay particular attention to this part: &gt; Renderers take View Models and provide a representation of them to return. Zend Framework 2 ships with three renderers by default: a PhpRenderer which utilizes PHP templates in order to generate markup, a JsonRenderer, and a FeedRenderer for generating RSS and Atom feeds. [Source Code](https://github.com/zendframework/zf2/tree/master/library/Zend/View) Also note the return values from the Zend controller examples. (A simple unescaped array) Everything after "// Handle the request!" represents the [front controller](http://en.wikipedia.org/wiki/Front_Controller_pattern). In Symfony the front controller is web/app.php and in Zend Framework the front controller is index.php. This is where the app initializes the appropriate controller to handle the request, calls the controller action, and renders a response to the client.
Hi, I'm one of the Skipper developers. Yes, Skipper is basically ORM Designer 3, and I'm glad you like the improvements. Regarding the price. If you spend more than 20 hours a month on the ORM, Skipper can pay for itself in the first month. It may not be profitable to invest in a complex tool if you spend little time on the ORM, and it's better to continue to write code manually. But because you will get lifetime license for the initial price, it's a good choice also for less dedicated ORM programmers. It's up to you how much money you save when you can get your definitions ready in one quarter of the normal time. Skipper is pretty useful in all phases of the project. It helps you to maintain your definitions together with documentations and allows you to quickly extend your model at any time in the development process.
&gt; it's about the time it takes to a human to write the code to do it and deploy it on each machine. Write what code? `ALTER TABLE users MODIFY salutations enum('MR','MRS');` That code that took me 15 seconds to write? What exactly are you deploying? I assume PostgreSQL has replication support similar to MySQL replication. You only have to send the above SQL to a master server, and the rest should be taken care of for you. Instead of asking what's wrong with enums, you should be asking what's wrong with your deployment system. &gt; like a list of jobs people can have inside an adminstration Then use a string to represent jobs. Every conceivable list of values is not meant to be an enum. An array should be used to store a constantly growing list of job titles. You should have a `jobs` table which is referenced by other tables using foreign keys. You're doing something terribly wrong if a job title like "secretary" is being repeated hundreds of times in some table. [Data Normalization](http://en.wikipedia.org/wiki/Data_normalization). This isn't micro-optimization. These are good programming practices you should consider adopting.
Ah, I sort of took you as the "I don't need a bloated full stack, I can roll my own" type of developer, but obviously wrong there :). That Silex tutorial should help a lot, have a good look at the pimple service container too. Not sure if these have been mentioned, but in a nut shell modern web frameworks (including .net and rails) are: * request/response paradigm * front controller/router sends requests to a thin controller * controller gets model to do heavy lifting and renders a template using result * "model" is very loosely defined - it's just whatever you need to get things done * service container is used extensively to manage dependencies * orm for db abstraction * automated tests for everything Both Symfony2 and Zend2 are good MVC frameworks in PHP, I'd recommend Symfony only because it's more mature and more popular. Stay away from Laravel or any of the older frameworks like Cake. I don't have much experience with the micros (Silex, Fuel, etc) but from what little I do I wouldn't bother. The full stacks are flexible enough while providing sensible defaults so there isn't much reason to go bare bones. Hope that helps, and good luck!
Ha, can totally relate. I managed just 6 months at an agency pushing out Drupal builds. You never get better as a developer because no one wants to pay for anything that can't be achieved by cobbling together a bunch of godforsaken modules. Instead you sit there clicking through admin screens (which makes your eyes bleed) wondering why in the hell Features is even a thing (worse use of the word 'revert' ever), and also what future can this bug ridden clusterfuck actually have. Hardest thing is turning down the extremely lucrative contract jobs which I'm well qualified for. At the same time I wonder why these companies with so much money want to spend it on fucking Drupal! For the money they're paying they could actually buy programming talent and produce much more resilient and maintainable builds using MVC where there actually is a logical path from url to page template. Trying to maintain Drupal is like defending a sand castle from the incoming tide. It's at once depressing and terrifyingly sad.
My preference is Mac OS X + virtual machine running by [Vagrant](http://www.vagrantup.com/) with shared project folder using NFS, which gives almost the same performance. Also there's a very good web GUI called [PuPHPet](https://puphpet.com/) which will help you to build everything you need for start.
&gt; Are there any better solutions? Yes: [Vagrant](http://www.vagrantup.com). Now, to answer your earlier question: OS X is a perfectly fine development platform (I use it myself) but for a proper good experience without having to fuck around with Apache and the likes I use Vagrant. I have my own provisioning for Symfony (which can be found [here](https://github.com/kleiram/vagrant-symfony)) so I only have to run `vagrant up` once and I have a fresh development environment without any leftovers from other projects.
I run osx + vagrant, but could just as easily run linux + vagrant or windows + vagrant. My vagrant/puppet scripts are versioned and I can also deploy the exact same environment to production when the dev cycle is over. MAMP/WAMP really isn't a good solution if you are building to deploy to a VM of any sort. Match your environments!
This get covers fairly often in this sub-reddit, but I'll bite. Most people move away from installing PHP/Mysql/Apache on their daily driver. The cleanest (and arguably) simplest setup is to spin up your own virtual machine that contains all of those aforementioned items. If you want to drink from the fire hose, you can head on over to www.puphpet.com where you can use a Web front end to configure all of the items you *most likely* use within your PHP application. Ultimately, this gives you the freedom to create/destroy/create virtual machines freely without cluttering up your machine. Send some donations /u/jtreminio 's way for his continued efforts on that project. It might be confusing up front if you're not familiar with it at all, but I can assure you that it will be time well spent once you figure it out. EDIT: Crap... I walked away before hitting submit and 5 other people said the same thing. Whoops.
Passing anything that fails to match the type hint results in a catchable fatal error. You can either let the application fail, or you can handle that bullshit like a ninja using a try-catch block: $fuzzi = new Bitch(); $fuzzi-&gt;setName('Marsellus Wallace'); try{ $fuzzi-&gt;setId($user-&gt;create($fuzzi)); } catch(Exception $e){ exit('Does Marsellus Wallace look like a bitch?'); //Subtle as fuck }
Use Vagrant. Create a virtual machine per project using Vagrant and keep your actual operating system light and clean. You're welcome.
Reiterating this snippet's simplicity $stockedFish = $ponds-&gt;getTotalStockNumber(); relative to something like foreach ($ponds as $pond) { if (isset($pond["fishBreeds"])) { foreach ($pond["fishBreeds"] as $breed) { if (isset($breed["number"])) { $stockedFish += $breed["number"]; } } } } seems, well, disingenous. `getTotalStockNumber()` won't just magically work without being implemented somewhere, and its implementation is almost certainly going to involve `foreach` loops much like those in the second sample. By the same token, you could as easily make a comparison like this: &gt; With OO design, you often end up with dozens of extraneous classes to &gt; implement something that would be straightforward in procedural code. Here's &gt; what would be a simple calculation, implemented in classes: &gt; &gt; class PondsCollection implements IteratorAggregate { &gt; private $collection = array(); &gt; &gt; public function getIterator() { &gt; return new ArrayIterator($this-&gt;collection); &gt; } &gt; &gt; public function add($pond) { &gt; $this-&gt;collection[] = $pond; &gt; } &gt; &gt; public function getTotalStockNumber() { &gt; $sum = 0; &gt; foreach($collection as $pond) { &gt; $sum += $pond-&gt;getTotalStockNumber(); &gt; } &gt; return $sum; &gt; } &gt; } &gt; &gt; class StockDataCollection implements IteratorAggregate { &gt; private $collection = array(); &gt; &gt; public function getIterator() { &gt; return new ArrayIterator($this-&gt;collection); &gt; } &gt; &gt; public function add($stockdata) { &gt; $this-&gt;collection[] = $stockdata; &gt; } &gt; &gt; public function getTotalStockNumber() { &gt; $sum = 0; &gt; foreach($collection as $fish) { &gt; $sum += $fish-&gt;number; &gt; } &gt; return $sum; &gt; } &gt; } &gt; &gt; class Pond { &gt; public $name; &gt; public $size; &gt; public $pegs; &gt; public $amenities; &gt; public $fishBreeds; &gt; &gt; public function getTotalStockNumber() { &gt; return $fishBreeds-&gt;getTotalStockNumber(); &gt; } &gt; } &gt; &gt; class StockData { &gt; public $name; &gt; public $number; &gt; public $date; &gt; } &gt; &gt; Wouldn't it be a lot simpler to do this? &gt; &gt; $stockedFish = getTotalStockNumber($ponds); Of course, both comparisons are equally misleading, and in fact neither actual implementation is significantly more complex. The same fundamental techniques of functional abstraction are applicable regardless of paradigm here. 
Thank you for your comment. I will consider that in my future tutorial. 
Completely agree!
Case sensitivity is an option, when partitioning your drive on osx. 
Better get them a new husband
Didn't Rails invent TCP/IP?
I often compare this feeling to the novel, flowers for algernon. I go from savant to idiot and back. Sometimes I'll review the savants code, and say how did I write this ? Other times I'll look at the idiots code and say the same thing, but with a different emotional emphasis. While its nice to know I'm not alone in the feeling, the stress it can produce when on the down swing is significant. 
You typically wouldn't want to run the schema tool directly as your db migrator. Doctrine Migrations is quite relevant. The talk of the new version (a rewrite) is exciting, too.
I'm going to disagree with you here; but if you can find that information publicly somewhere I'll gladly be wrong. :)
http://isdownforeveryoneorjustmedownforeveryoneorjustme.com/
Finally a Symfony Live on the East Coast!
I moved to MacOS a few years ago purely because I needed a smaller laptop when travelling. I ended up with a Macbook Air, and was surprised by how much easier a lot of things were. In Windows there are a number of hoops to jump through that are just needlessly hard. As web development has moved to a paradigm involving a lot of tools and especially command line tools it has become increasingly difficult to work well on Windows. Things like implementing SASS... install Node, npm install gulp, install ruby, etc. All of those things would be a pain in the ass in Windows. It's not that they're impossible... just... harder than you want them to be. And it's the sort of thing that makes it easy to put it in the "too hard" basket. Point is I recommend OSX for dev, highly. I also use MAMP myself. But I don't recommend it. There are better/easier/cheaper options. I would recommend using Vagrant. If you don't know Vagrant (I literally learned it a few weeks ago) I would recommend Homestead. It's the environment set up built by Taylor Otwell, and while it's recommended for Laravel it's not by any means unique to it. Symfony would be entirely happy. The reason I recommend it is more that it's a little more [clearly documented](http://laravel.com/docs/homestead) than more generic Vagrant setups, helpful for newbies like us.
Short Answer: No Long Answer: Yes, you could use PHP in some way in your back-end. But PHP is a server language... its not built to 'stream video' really I suggest you google things first. Googling "php live video streaming" - first result was a Stack Overflow page with lots of helpful info.. Also, /r/PHP is not really for help. Try /r/PHPhelp 
The reason I downvoted this is that it the entire article essentially boils down to a single regular expressions. It's not in any way specific to PHP or any language.
I think you're fine, /r/phphelp is for noobs to get help figuring out how to write a loop, or why their autoloader isn't working, etc. On the other hand, your question is fairly advanced, and there isn't going to be any single right or wrong answer. It's not a matter of _"oh you forgot a `;` on line 5"_, it's a larger design question which I think this sub _is_ a good fit for.
Are you serious? Is this article for real? Am I back in 2002? I'm getting so fucking tired of this shit...
Hmm, so would you still use PHP to connect the two users together and then flash to stream the cam? &gt; I've been looking online for guidance and I'm sure I overlooked something but I can't find much on this topic. I checked out that stack overflow page and found a handful of expired links that don't actually contain the guides mentioned anymore. Let me also mention that the question on stack overflow was posted in 2008 - that's 6 years ago. Let's just say technology changes. As for /r/PHPhelp, thanks for the reference I didn't know it existed. Honestly a lot of help taking place on /r/PHP though for a non support subreddit. Possibly because it has 12x more subscribers. Wish I could move the post!
Thanks for the reply, I will have to look into WebRTC and Flash for sure.
That's why we need to keep the bounce rate as high as we can ;)
I develop stuff in PHP and Python that goes onto a production CentOS Linux Server using a combination of apache, memcached, and MariaDB. 100% of the code that I have written in the last year went onto the Linux server without modification. Also the command line for Mac is nearly identical to command line linux so skills in one are close to 100% transferable to the other. Whereas when I was doing the WAMP thing I was always having to write code that needed to know if it were on Windows or Linux. To me the only question is do you use HomeBrew or MacPorts to install the stuff you will need. A VM can give you the ability to build a perfect staging server but I am not keen on developing on "remote" servers when I can develop right on my desktop. Obviously this would have to change if I were on a large team. PS About the only thing that can burn you is case sensitivity between Mac(doesn't care) and Linux(does care). Not only is it the file names that can burn you but select * from USERS; is different than select * from users; in many databases. So my solution is that 100% of files that are programatically accessed are all lower case.
How to run PHP Scripts on your computer ( without server ) Step 1: [Install a shitty server](http://i1.kym-cdn.com/photos/images/original/000/626/292/06f.gif)
Damn right. And the mods should be deleting this shit. I don't know who is a modderer, but I'd like their view. I've actually reported a few of these, but I'm not sure if that's the right approach.
[Hmm](http://i.imgur.com/R782OcY.png)
I made the switch from MySQL Workbench to SequelPro and won't look back. Go from table to table through foreign keys. Fantastic copy and pasting of tables quickly to excel or open office, even copy with column headers. Nice SQL completion. Actually able to view tables and sort/quick query them.
Doesn't have anything more than SequelPro offers me and that's free. Also imo has a much worse interface. Only thing I like is the dark theme.
I was going to recommend mamp. I use it for all my dev work. I had a few issues getting MySQL set up but that might have been an upgrade vs fresh install issue. 
yeah, HTTP and HTMl too
You just described most linux distros, and they have the benefit of not being overpriced garbage. Running out and buying a mac just to write PHP is stupid when your existing hardware can be easily adapted to a friendlier dev environment.
What are you using inheritance for in test classes?
&gt; overpriced garbage [...] buying a mac just to write PHP is stupid No need for that here. "Overpriced" and "stupid" are subjective and "garbage" is just insulting osx users for no reason. Try to be civil.
Wow the javascript on that site is terrible, froze my entire browser. 
Yeah, with Vagrant, the case sensitivity isn't an issue really...
Exactly what issue did you run into with case insensitivity? I'm having a hard time thinking of situations where you'd notice this in everyday use. Are you habitually creating test, Test, and TEST files and relying on them to be different? This is a very artificial edge case: $ mkdir expertsExchange $ mkdir expertSexChange mkdir: expertSexChange: File exists
You have got to be one of the MOST negative people on reddit today. 
Yeah, that code and not forget to run it on - your development machine - all the environments (demo, staging, production, you name it) And you have to tell your team to do the same, and sometimes they're not as good as you, they forget to use migrations and end up having different enums on different hosts. &gt; you should be asking what's wrong with your deployment system. It's not good enough clearly, and we're turning ourselves toward jenkins and [gunnery](https://eyjafjallajokull.github.io/gunnery/) to change this, but in the meantime, we'd like to have "enums" (pay attention to the quotes) that we can change by changing one file only. &gt; Then use a string to represent jobs. Every conceivable list of values is not meant to be an enum. An array should be used to store a constantly growing list of job titles. You should have a jobs table which is referenced by other tables using foreign keys. You're doing something terribly wrong if a job title like "secretary" is being repeated hundreds of times in some table. What you're describing here is exactly what I'm doing on old projects, and I know what data normalization is, I learnt the theory 8 years ago, and I have been putting it in practice since then. Now, lately, I've been looking at this approach and I feel that data normalization is having a bad influence on the code design : the reference system your speaking about forces me to have a separate table, which means having a separate entity just for that. An entity that contains only two fields : `id` and `code`. Not very easy to deal with, and we're not really database-first guys, but code-first guys. Me and my boss are being less and less obsessed with this kind of optimization, and starting to use denormalized fields. After all, what difference does it make if every user has a string field instead of an enum field ? What if I have good indexes on that column ? That may cause a perfomance problem, but we're planning on hitting the database not so much, and fetching most of the data from a search engine (elastic search) sitting before it. That's where we're headed : focusing on indexes, whether inside the database or outside. 
use a `RecursiveIteratorIterator` and `RecursiveArrayIterator`, then use something based on `FilterIterator` – either `RegexIterator`, the newer (5.4+) `CallbackFilterIterator` (better), or implement your own (better than Regex, same as Callback IMO :)
testing classes that innherit from other classes
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to [##php on Freenode IRC](http://webchat.freenode.net/?channels=%23php).
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to [##php on Freenode IRC](http://webchat.freenode.net/?channels=%23php).
I suspect we're all looking to become better programmers, and I'm often considering questions like yours too. I am one of the organizers of the GTA PHP Meetup Group in Toronto so I get a lot of exposure to people who are trying to sort out things like this. I primarily use Slim or Symfony when I'm building PHP projects. So I feel well suited to responding. WRT your specific questions: 1) For me the #1 benefit of using Twig is that it forces me to separate frontend and backend concerns, which leads to cleaner and easier to maintain code. On top of that, I don't write unit tests for my Twig templates, so there is less code to write. Also, Twig is relatively easy for non-programmers who know HTML to deal with. I'm sure there are many more benefits, but those are the ones that matter to me. 2) Slim + an ORM can be a great fit for small to medium sized projects. I find that when projects are of a higher complexity they start to benefit from the extra organization and abstraction found in a larger framework like Symfony. I've also heard many great things about Laravel. See [The MicroPHP Manifesto](http://microphp.org/#!/) for some good reasons to prefer something like Slim over Symfony. I also gave [a talk on the subject](http://blog.vicmetcalfe.com/2013/12/04/slim-redbeanphp-and-knockout/) at one of our Meetups. I really do like either approach, depending on the problem I'm solving.
If you use --dump-sql and store the output on a file, then you only have to run the schema diff once (on your dev box), and simply use the generated SQL on the rest of your environments.
Ive been using Twig for the last few months as the templating system for a large symfony project, and have mixed opinions about it. Whilst i like that it deals with all of the caching, escaping and safety aspects of dealing with outputting to the user, but it can be a hindrance when i just want to be lazy and loop through an array with a foreach. It has other advantages too, like automatically checking for getters, array keys, object properties with the same syntax, so {{ my_var.my_key }} checks for $my_var-&gt;getMyKey(), $my_var-&gt;myKey and $my_var[‘myKey’]. Ive never used Slim, but it does look like a nice micro framework. Its not really the same as Laravel though (which is a throw back to the monolithic / rails ideologies), as is Symfony to a certain extent. A closer match would be Silex, which is symfony with no shits given about structure, but as its built on symfony components means you have the stability and quality that they bring. After a few months using Symfony, that is now my go to framework, but for anyting smaller i would use Silex. 
I have been using Vagrant since i first heard about it at PHP UK a couple of years ago and i pretty much love 90% of it. I have had some issues, but the developers are amazing at answering questions and getting stuff working again. The best thing about Vagrant is mimicing the environment you will be putting production code onto, so no suprises when it goes live. If you do use Vagrant I would advise using Ansible as a provisioning language, its YAML, but super easy to read compared to Puppet which might as well be fucking hyrogyths. 
&gt; I hope to stay somewhat a generalist in IT I would say the time has passed for this. Being a generalist in IT generally means jack of all trades, master of none. Get specialized and learn something really deeply, it will help you be better at other 'general' tasks
I'm looking forward to it. I've been to 2 (Portland and Berlin), and they are always a good time with great speakers and great attendees...
Joe is a brilliant developer with an impressively bad luck. He totally deserves our support!
Without explaining, and preferably showing, the projects you've been a part of, how could anyone possible judge you? You've listed technologies but what have you actually built? Portfolio is vital. If your expertise is at junior level, you will earn less than if you're able to operate completely independently, or write complex, bespoke applications. There are other factors, too, such as your communication skills, people skills, knowledge on UI and UX, design skills, marketing skills, the list goes on. If it's your first job, lower your salary expectations to something that will be sufficient enough to pay your way. If not, you can use your previous pay as a guideline.
Glad we finally worked out why I'm so reluctant to use enums. I thank you because it gave me the occasion to clarify things to me by clarifying them to you. I guess when you're using an ORM, you must be ready to make some sacrifices on database beauty if you want to get code beauty. &gt; I'd be interested in hearing how things go with jenkins/gunnery I'll mp you if we come up with something good. For the moment, we're not using gunnery yet, but there's a workflow that looks like git-flow that's coming to maturation and that we should start using next week on our projects.
I totally agree with you.
If you are making a simple REST API, you should look at Silex. It will be easier than learning a full-stack framework and will help familiarize yourself with the Symfony components.
1) It leads to more secure code (auto-escaping, sandbox etc..). It also provide template inheritance which raw php cannot do. It's a simpler language than PHP so easier for designers to learn. 2) It depends on the size of the application.
This helped me quite a bit: http://marco-pivetta.com/doctrine-orm-zf2-tutorial/#/
I often refer to Mac OSX as if "Linux and Windows had a baby" It has the reliability, vendor support and modern UI of Windows, mixed with the command line and general awesomeness of a Unix based system. For me this means the perfect development machine - even though I still use VM's to keep my OS light.
Also a vibrant member here on reddit: /u/krakjoe
Cake 2.* was still just as backwards as Cake 1.* and Cake 1.* was backwards since PHP 4. I don't think I'll ever take a programmer seriously who advocates for CakePHP.
I feel this way too, for the record. :/ My main issue is sometimes programming [especially maintenance] bores me to tears and its only the paycheck that keeps me from neglecting it entirely.
 {% for item in array %} {{ item.name }} (runs item-&gt;getName(), item-&gt;name, and item['name'], like you said) {% endfor %} How is this a hinderance?
Because that is best case senario. If you need to do something more complicated, the TWIG (not sure if thats actually an acronym) syntax gets super verbose when raw PHP would be simpler to read and immpliment. 
It insults the people who would buy it.
http://www.ultrabookreview.com/177-ultrabooks-macbook-air-good-great/ &gt; All these lead to a very important aspect: how much do these laptops cost? &gt; The latest 13.3 inch Macbook Air starts at $999, for a Haswell Core i5 processor with Intel HD 5000 graphics, 4 GB of RAM and a 128 GB SSD. And you can actually find it discounted online. The 11 inch MacBook Air starts at $899 for a similar configuration, and once again some webstores actually list it cheaper. &gt; Premium Haswell ultrabooks on the other hand start at around $1100 to $1400 these days, for a pretty much similar configuration (somewhat slower CPUs and graphics though are bundled on most base ultrabooks), but in most cases that includes a high-resolution touchscreen as well. Some of the best such machines are detailed in this other post. As for the 11.6 inch ultrabooks, well, you can read all about them in this post. &gt; Of course, you ca find ultrabooks that sell for between $500 and $1000 in stores as well, but those are not exactly direct competitors for the MBA, or they are older generation versions, with Intel Ivy Bridge hardware. &gt; Bottom point, it’s actually funny that these days, high-end ultrabooks are actually more expensive than similarly configured Macbook Airs. In fact, the Airs have gotten more affordable in these last years, while premium ultrabooks have gotten pricier. http://www.pcmag.com/article2/0,2817,2397811,00.asp Definitely not extremely, and I wouldn't even say marginally. The small extra cash you are spending on the air is for a quality product, as you may disagree, but I really don't care. More often than not, people who complain about the quality of macs are heavily biased. The days of this argument are over, guys need to stop using it.
it pains me to think about myself and my children being put out like that. Support all around!
Just create a different VM for each project you work on. http://puphpet.com helps a lot
Uh.... Ruby COMES installed on OS X. So, thats definitely easier... nodejs: brew install node or brew install npm grunt: npm install grunt, just as easy, but more likely to work on a mac. Last few times i tried installing anything node related on windows, shit just didnt work sass: again, ruby already on OS x, little easier to install... Nothing over complicated at all. Also, dont (as he said he doesn't recommend) install a *amp stack.... Vagrant, boom. it works.
https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project
HAHA, that made me laugh… you gotta love getting called out… :) ok, so I had a little look in my project twig files. {% set photo_list = '' %} {% for photo in property._source.photos %} {# loop through the photos and get their urls, but skip the first one as thats preloaded elsewhere #} {% if loop.index != 1 %} {% set photo_list = photo_list ~ ',' ~ photo|image_size('lg') %} {% endif %} {% set photo_list = photo_list ~ ',' ~ photo %} {% endfor %} Some of this might obviously be due to the code its self or a poor understanding etc, but you cannot deny that is verbose and i can certainly see where it would be much quicker, simpler and more easy to read raw PHP {% macro navigation(items, strict = false) %} &lt;ul&gt; {% for route_name, label in items %} &lt;li{% if (strict and app.request.get('_route') == route_name) or (not strict and app.request.get('_route') starts with route_name) %} class="selected"{% endif %}&gt;&lt;a href="{{ path(route_name) }}"&gt;{{ label }}&lt;/a&gt;&lt;/li&gt; {% endfor %} &lt;/ul&gt; {% endmacro %}
I don't think so. http://aws.amazon.com/amazon-linux-ami/2014.03-release-notes/
That doesn't seem too complex to me... But, i guess its kinda subjective. Some of this could be cleaned up with simple Twig_SimpleFunction's and what not.... But, i'll upvote for civility!
Not gonna completely reply to this cause im over this argument. Always goes no where, but a quick search on amazon.co.uk shows several ultrabooks in the same price range as the air. eh. 
I admit that i was looking for the most complicated stuff and obviously its not even that complicated when you know what youre looking for, but when you take the speed of templating with PHP and then add several layors of complexity on top of that, it must have downsides. I like twig, i would like for it to be just a little less verbose though. :)
Again, ruby doesn't need to be installed on osx, thats inherently easier. Node, like i said, the last three times for me, simply didnt install, which makes grunt difficult. Sass has one step cut out, dont need to install ruby, already there. Vagrant wont break a mac. I wouldn't agree that its HARD to install dev tools on windows... but i would say things dont always work. Shit, i couldnt get cygwin or git working on my last windows machine (8.1 may have caused issues)
http://php.net/releases/5_3_20.php "Please note that the PHP 5.3 series will enter an end of life cycle and receive only critical fixes as of March 2013" http://php.net/archive/2013.php#id2013-07-11-1 "Please Note: This will be the last regular release of the PHP 5.3 series. All users of PHP are encouraged to upgrade to PHP 5.4 or PHP 5.5. The PHP 5.3 series will receive only security fixes for the next year." https://wiki.php.net/rfc/php53eol "One year with security fixes only, announce with 5.5 final release" 5.5 was released 20th of June. PHP 5.3 either goes EOL on 11th of July to coincide with the statements in http://php.net/archive/2013.php#id2013-07-11-1 or it has already gone EOL on the 20th of June. Either way it is essentially EOL as tomorrow is the 11th of July. http://php.net/archive/2013.php#id2013-06-20-1
**EDIT**: As /u/just3ws pointed out, Mr. Watkins is being asked for **SIX** months of rent **PLUS** a deposit, which completely justifies the extremely high number. I apologize if it seems like I insinuated that his intentions were anything but noble, I assure you that is absolutely *not* the case. I am in no way trying to troll or be an asshole to such a fantastic developer, and I plan on donating Friday morning when I get paid. I am just curious as to where the £6,500 figure comes from (upwards of $9,000USD). It's far more than would be required for an apartment down payment and far, far less than would be required for the down payment on a house. I am sincerely curious, and I swear to god I am not trying to be an asshole :-/
1) The rental market where he is might be more expensive than yours 2) He probably doesn't want to rent a shithole for a family. That can fly when you're solo and getting your start, but once you have kids you need a place that's safe, clean, and peaceful. Additionally, he's probably at a place in his career where, current situation aside, he expects to live like a human, and so needs a decent flat.
From the site. &gt; The only way to get a tenancy is to have *6 months rent* **and** *a deposit in advance*, and we just do not have it. - Emphasis is mine. Those requirements are crazy.
&gt; 2) Is it bad to build in Slim + an ORM? Would learning Laravel or Symfony really be a big benefit. I used Slim at an old job. It did its job well until I found myself having to write scaffolding around it to take care of things it couldn't do. I ended up migrating the site to Laravel and had a much easier time of things. Slim is pretty great as far as micro-frameworks go. Use it where it makes the most sense to use a micro-framework instead of a big, featurey framework.
PHP 5.3.28, the last stable 5.3 release, went out [December of last year](http://php.net/archive/2013.php#id2013-12-12-2). I wonder if they'll make one last update or let it fade out. Perhaps it's already de facto EOL'd.
Why are you editing dependencies? Are they your own repos?
I had to do 6 months rent and two months security deposit in Brooklyn, NY and my credit rating is high. This is apparently bc it is near impossible for a landlord to kick out a tenant in NYC (quickly) and I was traveling for ~6 months w/o an income so they wanted to ensure I could pay. Though, I've heard of this happening in situations where people have a steady income as well. I don't know the reason for Joes requirement. I only mean to make the point that it isn't just about credit rating.
You shouldn't be editing your dependencies. Do a pull request upstream, extend their classes and use yours, etc.
shut up and take my money! no seriously, let's help him out with the deposit! this guy is one of the many people that make PHP work with C code that we don't understand, but make (big) money out of. we got your back joe!
Food, water, electricity.. drugs.. Seriously, $9000 might seem like a lot to you or I -- but not when you need to support more than just your own pizza pocket addiction, booze, and *Chivalry: Medieval Warfare* on Steam.
Well I hope it's the end of 5.3 support!
depends greatly on geographical location, the rarity of your skills in that location, and the type of company. I recently hired on at 30 an hour doing PHP/JavaScript and XML backend work.
I think that I need to clarify that many of the dependencies are mine and are either private or public. For example, all the Flight stuff is in a repo and all the Hotel stuff in another, but you can have a project that uses both.
Hurrah!
&gt; far less than would be required for the down payment on a house. What sort of house are you looking at, and where? Conventional wisdom (and many banks) like to see 20% down. That would be a down payment on a $45k (USD) house - that doesn't get you much house in most markets, at least here in the US. EDIT: ACK - duh - completely misread that... 
all of this feedback is great, thank you!
This is so true. I just have always felt a passion for so many fields of IT from end user support to php dev to building HA servers in the cloud. I just struggle at the idea of becoming hyper specialized. The job I am leaving basically had me inside of IIS for 2 years and not much else. I fear falling back into something like that again.
My understanding is that he's just recovering from another big bad stroke of luck that bled him dry. He's one unlucky fellow.
Your first two "vulnerabilities" aren't for all but the most absurdly retarded code.
Link to your dependencies' autoloader in your autoloader, don't worry about making them a composer dependency until they're in the state you want them to be.
To be honest most of the vulnerabilities I've found is due to old or poor quality code. * Reliance on mysql_escape_string and injecting it right into the query. * Not validating the data properly before using it. * Not validating or escaping the data as it leaves the server. 
Maybe if it was made a Symfony library it would work?
This. My netbook runs Ubuntu's gnome web remix and it is a fine machine for writing code on. for anything else it is a piece of crap... My desktop used to be a windows machine, which was "ok" for doing most things but a nightmare for writing code on. OSX provides the best of both worlds. An operating system I can use every day without wanting to claw my eyes out and a solid development machine when I want to go to work.
Check the documentation [here](https://getcomposer.org/doc/03-cli.md#install) about using the *--prefer-source* flag with *composer install*. It creates a repo of your dependency in the vendor folder and you can commit and push upstream.
thanks :) At least i don't feel guilty now.. hahaha
I am using Laravel. From what you said, I need to inject it into a form library and controller does not need to know the dependencies required by the form. So is this okay if I do it this way: In a form file, let's say registration, I will load the department dropdown list by using facade: Department::getDropdownList(). So to generate a dropdown list using Laravel Form API, it should be: echo Form::select('department', Department::getDropdownList()); Is this acceptable? 
You pretty much answered this yourself :) Just make this script a separate file, run it once and then remove/rename/block it Or am I missing something? 
My question is where do I run it? I am doing all of this on a web server, and I'm not sure where to individually run the file without putting it in some code which will be published.
Yes, it is very common to do so in any app/site that's larger than a single page. This is called "Seperating logic from presentation", and can be handled by a templating language in just about any CMS or framework. See here for a nice intro: http://symfony.com/doc/current/book/from_flat_php_to_symfony2.html (This example uses Symfony 2, but the principle is the same for any framework)
So when creating a multi page nav page, what's the best way to do it in PHP? Do most just have everything in one php file and just hide/show the pages internally when necessary?
Yeah, you frequently won't have any entirely static pages. You should consider using a template engine like [Twig](http://twig.sensiolabs.org/), though. At very least, it can give you automatic protection from XSS attacks, and it'll also make it easier for a designer to tweak your pages.
Alright thanks. Just a side note, why haven't PHP compilers already been modified to try and safeguard from XSS?
Ops! Sorry! I will delete it!
http://twig.sensiolabs.org/ http://www.phptherightway.com/
Because that is not a task of language, but a task for library. And most sane libraries do that
It's recommended to create a separate partition for work files in OSX, too. The same way as in Windows or Linux you should keep your stuff separated from the operating system partition. Keeps things clean.
Isn't xliff the way to go these days?
I agree. 100%. But developing on an environment that is different from the production environment is asking for trouble. Macs are a good first step and allow you other tools like Vagrant etc. 
It would break backwards compatibility for echo() to do HTML escaping. You could certainly define a shorthand like h() for htmlspecialchars(), though, and safely do &lt;span&gt;&lt;?= t($foo) ?&gt;&lt;/span&gt;. I'd suggest that you at least put it in a separate file from your business logic, though. It's really tough to read a mix of HTML, PHP, and SQL.
Place I work at is still running PHP 5.2! I cringe everyday!
Neither, did I. 
Totally, and to be clear I run my development code on a vagrant VM. I don't actually consider myself to be developing on the vagrant machine though - I use mapped folders so I "work" in the host OS and I "serve" from the vagrant box. When it comes to a development machine I'm not simply referring to what runs the code - it's the entire ecosystem of tools that a unix-like operating system affords a developer combined with some thoroughly well thought out mac desktop applications that make it a joy to work this way.
In fact, you are a little bit wrong ;) It actually should, according to RFC, end its life on 11th of July. However, the community is planning to release the last version containing the security fixes developed since the last 5.3 version released in December 2013. You can read more here: http://www.serverphorums.com/read.php?7,957660
There's two workflows here, and which one you choose depends on how actively you are making changes to your project dependencies. Firstly, if you are actively working on libraries that will become dependencies then just symlink the dependency folder into your /vendor directory. For example you work inside ~/projects/dep1/ but symlink ~/projects/main/vendor/dep1 to ~/projects/dep1/ This allows you to change your code in dep1 and instantly have the effects in your main project. After a while, your dependencies may become a bit more stable but you still don't want to be pulling from packagist every time you make an update. Workflow 2: ~/projects/dep1/ is setup as a proper composer package with working composer.json file. Now back in your main project you can add this to your composer.json. "repositories": [ { "type": "vcs","url": "/Users/you/projects/dep1"} ], Check the path is correct for the dep1 project. Now when you run composer update on your main project it will pull from your local folder and be almost instant. 
How does it work with php?
I have to plead ignorance as well. Anyone used it for anything mildly serious? Would be curious about the experience!
If only everybody had savings set aside...I certainly don't. And I would hate to be stuck in this kind of situation with my wife and kids!
Not anymore he doesn't. &gt; Raised: £8,395.00.
&gt; Do most just have everything in one php file and just hide/show the pages internally when necessary? No, you should read the article I've linked, because it describes perfectly well that you shouldn't do that. 
Because '&amp;&amp;' has higher precedence (see http://www.php.net/manual/en/language.operators.precedence.php) than '='. So in the second if condition, it evaluates the count before the assignment. In doing so, $foo does not exist at the point that count($foo) is executed. Try: if (($foo = $bar) &amp;&amp; count($foo) &gt; 0) 
 if ($foo = $bar &amp;&amp; count($foo) &gt; 0) : means if ($foo = ($bar &amp;&amp; (count($foo) &gt; 0))) : The condition is evaluated the same as if the "`$foo = `" part wasn't there.
Not sure if this is still work in recent versions of php, but the path normalization oddities + path truncation to do LFI attacks in PHP is pretty cool. http://security.stackexchange.com/questions/17407/how-can-i-use-this-path-bypass-exploit-local-file-inclusion/17807#17807
Thanks, I'm already using the workflow 2, but was looking for a solution like workflow 1.
I don't have an autoloader as I use composer's. Also, I wouldn't know the location of the dependency's autoloader because my team may not clone it at the same location as I would.
It's one of those things I hear talked about a lot, but usually without any clear word of what it actually is or how it works in concrete terms. I have enough trouble learning shit I actually sort of pretty much kind of understand. 
personally, I think it's not that great code when you put a declaration into an if statement. I'd write it as: $foo = $bar; if($foo==$bar&amp;&amp;...) if($foo=$bar) should always return 1 unless something goes terribly wrong. When something is always 1, no need to do an if-statement here. 
I may have posted before realizing that you need to add 'array' in there 
Agreed. You would either have to be pretty negligent to get kicked out of rented property or have some serious bad luck... UK law requires landlords to provide notice period (under most circumstances) when evicting tenants
What's with the comma after the closing paren after MCRYPT_DEV_URANDOM on the first line? Seems out-of-place.
Spam. Needs to be removed.
Do you have the mcrypt extension enabled in your php.ini? extension=mcrypt.so Then restart your server.
No way to know without seeing the whole script. Are you using a framework of any kind, or did you write this code yourself? Can you upload the file to pastebin or Github gist?
&gt; This is the announcement for wxPHP v3.0.0.2 which mostly fixes Mac OSX related stuff as other issues described on the changes list. This is a patch release, not really interesting…
Head over to /r/PHPhelp for support.
When this happens the biggest webhosting provider in brazil will officially supports only two EOLed versions.
Okay cool, so a basic user login script. If all you're doing is hashing, and this doesn't have to be a super-secure application, I recommend using SHA-1 hashing because it's pretty good and doesn't require any extra extensions to work. In PHP: $password = sha1('mypassword'); In MySQL: SELECT * FROM users WHERE password = SHA1(mypassword); Let me know if you need more help.
When nothing is entered into the boxes? You mean the form fields? So you're saying when someone enters their credentials in the username/password fields, it works, but when they leave them blank, it doesn't work?
The point of the code is to evaluate if $foo (which is being assigned the value of $bar) is a "truthy" value, not if $foo is equal to $bar.
it looks like an old version of PHP indeed. you use new "short" array syntax and old php doesn't know how to deal with it
Don't know about the purpose, only about what it does. = declare == equal === identical if ($a = $b) will assign the value of $b to $a and return true on success. http://www.php.net/manual/en/language.operators.comparison.php edit: so with ($a === $b) it should work, as === has a higher priority than =
I dont remember what the problem was, but it didnt install properly. It happens, and its not as infrequent as you may think
Makes two of us!
Is there a "compiler" for it?
Had you not added your emphasis, I would have absentmindedly missed that part. That **completely** explains the exorbitant number, and I feel like a double asshole for that particular egg-on-the-face moment. I will be editing my post to ensure that nobody like me gets the wrong idea like I did. Side note: 6 months *plus* deposit is absolutely CRAZY. 6 months *alone* is crazy. IMO, anything more than first and last month down is crazy. 
This sort of stuff really belongs on /r/phphelp
Dangling comma? Version of PHP that requires "array()" declaration? Do a phpinfo();, figure out your version and the installed libraries, and go from there. If you don't have mcrypt, use something else. That said, there are actual code errors that need to the fixed before how you're encrypting your stored passwords matters.
TL;DR use a framework, probably laravel You are missing out on lots of stuff by not using a framework, specifically you're writing things that someone else already wrote, and you're probably not doing as good of a job as they did, since theirs got popular. That said, you're getting to write everything, which means that you're getting to learn how everything works without their being any "magic". Then again how good of a result that makes depends on how good your code is. Symfony and zend have really steep learning curves. I've read that laraval is more approachable.
Thought I sent you a reply message, but I guess it didn't get through. You're missing a close paren after the call to empty(). You gotta close the if() statement too. Should be: if(empty($_POST['password'])) { $login_ok = false; }
Actually $a = $b will return the value of $b... so if $b is a falsy value it will fail.
I always had the urge to see how things work under the hood. But that doesnt necessarily make me a better PHP dev. From this perspective, not only you should use Laravel, but also give other frameworks like Symfony or Slim a try. The only case I am aware for not using a framework are performance/scalability scenarios. Other than that, you should totally do it. If you, like me, want to try without a framework just for the fun, I always recommend Fabien Potencier's series of articles on how to build your own framework. http://fabien.potencier.org/article/50/create-your-own-framework-on-top-of-the-symfony2-components-part-1
I didn't think you were an asshole for asking. It was a legitimate question given how many dubious fundraisers there are. :)
Symfony doesn't have a "really steep" curve, it's a bit more complicated than "laraval". 
Thank you for your experience! I can try to clarify what is it. AOP is a technique for solving only cross-cutting tasks. It works on top of OOP and allows to install aditional hooks everywhere. For example, hooks in the Drupal is a typical AOP advices, because we can define a concrete point in the code (hook or a joinpoint in the terms of AOP) and then dynamically apply additional handlers. That's it. AOP = ability to wrap any existing method into closure and perform additional logic when an original method is executed. In 90% of cases AOP can be easily replaced with traditional OOP patterns such as decorators or proxies, but this require a lot of boilerplate code, for example for logging or caching. I like DRY principle very much, so I can extract this scattered code into one single class, called an aspect, and apply it in the concrete points in the code without writing a lot of code. You can have a look into this article http://go.aopphp.com/blog/2013/07/21/implementing-logging-aspect-with-doctrine-annotations/ to understand how it works. However, AOP is special tool for special tasks. Here is the list where AOP **COULD** be used in production: Logging, Caching, Transaction Control, Authorization, Exception handling, Dependency Injection. Anything else **SHOULD** be restricted from usage. For dev mode AOP can help a lot with testing by mocking methods on-the-fly (static or final too) or by verifying arguments and contracts for the methods and classes (behaviour checks, BDD).
PHP-based desktop applications? That sounds pretty cool to be honest.
I don't know how many people own VISA or MASTERCARD. But, I only have Paypal. How can I donate ?
Thank you!
It definitely has a login system. I'll start looking into Laravel tonight. I hope porting won't be too much of a pain if I do decide to do it. Thanks!
Edit: had a mistake in my previous comment, so rewritten: When the Value of $b can be translated into 0 or false, it will output false, but any other case, would always return true. So if your values are 0/1, '0'/'1', true/false, etc. You might get true/false statements, but if it was a String or any other more complex object, you'd get "true" for success. You can test that with this code: $a=0; $b=1; if($c=$a){echo "0 ";}; if($c=$b){echo "1 ";}; $a="some"; $b="other"; if($c=$a){echo "some ";}; if($c=$b){echo "other ";}; Please disregard the original message, if you got it before I could edit it. 
I used the sample questions by Lorna Jane Mitchell (See: http://www.lornajane.net/posts/2014/zend-certified-php-developer-5-5), which helped me a lot.
Depends on the growth of the project, I'd say. I wrote a simple web page two years ago, now it's huge and it's a pain the ass updating it. It uses plain PHP barely without any architecture, because Hey, it would just be a simple web site right? I could refactor but the site works and I don't have the time to do it, however I wish I would have built it on a solid base.
I don't expect a large user base, but the code base itself is going to be fairly large judging by my plans for the simulation. I'll take a look at the Laravel docs in more detail tonight and maybe get started with a port...porting will no doubt be my least favorite part -.- Thanks!
Thanks. I specifically mentioned CakePHP because in my research there was a lot of people saying not to use it. But yes, I kind of discounted Symfony2 because it seemed too bloated. However, the fine folks here have convinced me to take the plunge and go Symfony2. I'm working with some stuff from Lynda.com now (http://www.lynda.com/CakePHP-tutorials/MVC-Frameworks-Building-PHP-Web-Applications/92562-2.html) and I'm starting to see the power everyone else understands. Thanks 
Mr. Watkins gives his paypal email in his comment, just follow the link in the topic. Good luck.
&gt; if ($a = $b) will assign the value of $b to $a and return true on success. No, it will return the value of $a. PHP doesn't return true or false based on the success of an assignment, as those never fail unless something catastrophic happens.
Thanks, this is awesome
He's a good developer, he should be able to land a well paying job. Then again it looks like he's fully supporting his kids and partner so that would explain it. 
Even with the good rating letting agencies often check your latest bank statements for consistent income. And this is something you might not have if you've been freelancing.
Test the code then... but IF-statements can only handle true or false requests and can only return true or false. So if your Value is a string, it can't return that string, as it is not boolean true/false. It's rather that php automatically converts types if it makes sense, so 0 and 1 become true and false if that makes more sense than just reporting success. But never the less, it's bad practice to use it inside an If-statement and should not be done in the first place. Independent of the details of how it behaves strangely. 
Looks great. Really well written. I should have some use for this soon. 
I've used that bundle also. I have entities that are ready to be used as part of a package, so my goal is to allow a dev to copy an entity from my bundle into their custom bundle, and change a simple config value. I know Doctrine has decent inheritance handling. I think you can create a new bundle and extend an Entity from another Bundle, but I haven't tested. The question is whether my entity should be abstract in that case
Security is one of the things I'm aware of the most with my project. I've just started converting all of my mysqli queries to use prepared statements and I used a tutorial solution for password hashing and user registration. Session management I haven't even properly looked into yet! I've always been prepared to put in the time to do the security right before making the project publicly available. The other stuff - dev speed and such - I'm not bothered by with native PHP. Anyway, I'm going to check it out and at least consider it. The thing I'm dreading most is spending tons of time on basically reimplementing everything I already have, as I'm quite far along in the feature list. Thanks for the advice!
If you really want to be a "better" PHP programmer, make your own framework. I did this. And, I can safely say I learned way more than learning a ready-made framework. It's the best learning experience I've done. You will face coding problems you've never faced before. You will frequent Stack Exchange more. Caveat: Only do this if you have a lot of free time, otherwise Laravel or any other framework is fine for most projects you will do because there's a good chance no one else will use your framework but yourself.
&gt; I used a tutorial solution for password hashing Sounds like a red flag to me 
I dunno, I actually had a ton of fun porting to Laravel. The common use cases are executed and documented so well it made me smile.
He's obviously not that intelligent if he can't handle basic personal finance. Glorified begging.
Makes three of us. I feel your pain. 
Asking for help when you find yourself in a bad situation is just about the most intelligent thing you can do. We should be encouraging people to ask for help. Not making them feel worse than they already do...
Yeah sorry again for not explaining properly but I just meant on a Web host like 000webhost, where can I run the script only once to create the table
Assignment in condition is valid, but it's best to evaluate the expression as not simply truthy or falsey. Example: if( false !== ($file = readdir($dh)) &amp;&amp; 0 !== strpos($file,'.')){ // do something with non-hidden $file } Yes, this could be written as: $file = readdir( $dh ); if( $file &amp;&amp; 0 !== strpos($file,'.')){ // do something with non-hidden $file } But it's arguably more readable in while loop, while( false !== ($file = readdir($dh))){ if( 0 !== strpos($file,'.') ){ // do something with non-hidden $file } } Or if you wanted to write a do...while do{ if( false !== ($file = readdir($dh)) &amp;&amp; 0 !== strpos($file,'.')){ // do something with non-hidden $file } }while( false !== $file);
And once you build your own framework (because the learning aspect is indeed extremely worth it)... throw it away and use something like Laravel. The PHP community has enough fragmentation without yet another release of some half-baked framework.
like others have said, you would probably need flash for capturing the user's webcam/displaying the video stream. You COULD use php to capture/output the streams by making a simple socket server, and ajax/php for the chat portion. I would do more research, but this would be my "instincts" on getting started
&gt; not that great code I'd argue that it's almost universally bad code. You shouldn't mix conditionals and assignments.
XAMPP. ew. sudo apt-get install apache2 mysql-server php5 libapache2-mod-php5 php5-mysql add php libraries as needed.
Is there any reason you would move away from Drupal 7? If it meets your needs and you have no problems with it, I would suggest sticking with it. I would also stay away from Cake. It's slow and improperly written in regards to OOP.
Why would you do manual testing? What kind of manual testing are you talking about? What about Nightwatch ( http://nightwatchjs.org/ )
Yeah, it's something I was going to review and likely redo before public release.
I was in this boat for a while. It's a bit like driving vs walking. I never have any problems walking, but now I can drive - holy crap, there is a lot more I can do!
As with any option, that's pretty much a given.
Someday you'll probably realize that we don't live in some kind of utopian meritocracy where only intelligent people have money. When that day comes, I want you to know that I'd still help you out if you needed it, even though it will be pretty embarrassing to ask. Best of luck.
That's encouraging, thanks.
Serious question here.... Why would you EVER install xampp on linux?
Now payum supports stripe too, both checkout and js http://payum.forma-dev.com/documentation/0.10#Stripe, with a good integration to symfony
I came here to say exactly this! Metapackages like this make a lot of sense on Windows/OSX but zero sense on Linux (to me). You're sacrificing free &amp; automagic updates, the ability to manage services independantly (it's not clear if it's easy with this package but the linked article describes only how to start/stop the lot) as well as the ability to get community support from your distro. I guess there could be some non-obvious benefit to make up for this but I can't imagine what it could be.
It's that various things that you currently waste time doing become very easy, either via Laravel, or via the huge ecosystem of stuff via composer (which you probably aren't already using). A good example is generating an Excel file from a database table, normally that's really hard, if not impossible, with a small amount of work in Laravel + a composer package that can be 2-3 lines of code.
Stuff like this is starting to make less sense on windows and OSX with virtual machines, and stuff like vagrant too....
Hey, thanks for your comments! The redesign is at this point is more of a re-skin, with some added interlinking etc. Mostly just design changes though. In the future we will add functionality however. I'm assuming that it would be better to wait until that time before re-coding from scratch? 
Well, FWIW those are the options that he put in the title, and I never said "use a framework or don't use any other 3pd code" I suppose that while you *can*, it doesn't really make sense. I mean, if you want to roll your own and you have the time and ability then yeah, do your thing it will be the perfect custom tool. However, if what you want is to leverage as much working, tested, and well written code as possible and time is a concern, use a framework. Personally, I'd say if you want some sort of middle ground, go get a framework and branch it so you can add all your custom stuff on top. That said, I can't really imagine that anyone ever really means "write it all yourself", even when they talk about I always assume that's a little hyperbole. I mean, are you going to not copy code from php.net? I'd just assume that everyone is using *some* 3rd party code and then you can sleep at night!
Hmm, I feel like I'm already doing this to an extent, though not really thinking of it as building a framework - more as structuring the project in a practical and efficient way. 
I think he/she quoted "laraval" because you accidentally called it that at the end of your original comment. Thank you for the advice, anyway! I just branched off my main project, went through the homestead and Laravel setup, got phpmyadmin installed on the VM, and migrated my db from my MAMP MySQL installation to the new one. So far everything has been pain-free.
&gt; I suppose that while you can, it doesn't really make sense. I mean, if you want to roll your own and you have the time and ability then yeah, do your thing it will be the perfect custom tool. It makes perfect sense. This is how I, and many other developers that I know have worked for years. A framework provides architecture. Your code is servient to the framework. The framework calls your code. Which means if there's a problem with that architecture, or a precondition that it gives you winds up to not fit your needs, you're stuck either migrating off the framework (just as hard as from legacy code), or hacking together weird workarounds (or living with the problems). Instead, if I use all the same libraries, all the same components, but wire them together myself (which really isn't much work), I'm now very loosely coupled to those libraries. If *any* of them isn't up to snuff, I can swap it out. If the router isn't working, I can swap or work around it. I'm in control, rather than the framework. Frameworks work, because they assume architecture for you. That's the difference between a framework and a collection of libraries. The relationship between your code and the 3pd code changes between the two. Frameworks buy you startup costs. Which aren't really that expensive overall. And if you buy the 60/60 rule (60% of cost come post-deployment, and 60% of those costs are from changing requirements), optimizing startup costs is the less important thing to do. Instead, I'll take an extra day or two wiring the application, but have the longer term flexibility. I'll write very little extra code than yours that runs the framework (100's of lines at most), but I'll have tons more freedom. The libraries become an implementation detail rather than a fundamental component of the architecture. That's where you want to be. So yes, it does completely make sense. And it's not "roll your own". It's architecture at its very core. You never get something for nothing...
Sorry, but this statement makes no sense. In cake 2 you can autoload basically any class following the PSR-0 standard, you can include your own autoloader or jus tuse composer's or if you will you can just use 'require'. I don't see how you are limited to loading classes from only a few directories.
I can answer some of those questions and hopefully write a blog post about it later: &gt; does it use composer by default? Definitely &gt; does it follow PSR-1 and PSR-2? CakePHP follows PSR-1 since version 2.x and most of PSR-2 (tabs, for example) &gt; does it use Synfony's HttpKernelInterface, so it's compatible with all the Stack middlewares? No, CakePHP has a very solid and proven HTTP layer library that has been cleaned and improved for 3.x. It does have a middleware layer, that *could* be made into Stack, we will make a choice if we see more projects adopting it or if it becomes another PSR. &gt; does it have a logging interface that I can add handlers to (compatible with Monolog or the PSR logger? Using monolog is on the roadmap for the next beta release. &gt; does it have and event dispatcher that allows me to listen for Event objects? Yes, it actually has that feature since version 2.1. We have streamlined it and improved prerformance for 3.0 &gt; are tests run against PHP 5.6 and HHVM? They are, HHVM tests pass in 96%. We have opened tickets for the broken stuff in in the hvvm project on github and some of them have been happily resolved :) &gt; does it use semantic versioning and not break BC by adding methods to interfaces not marked as internal? This is the case since 2010, our official documentation states our versioning and deprecation policy.
Something no one else mentioned. When you work on your own, the architecture of your project is necessarily intuitive to you. But let's say you get bigger and you need to bring other people into the project; now they will have a learning curve. If you use a popular framework like Laravel you will be able to find people who will already be comfortable in your project. That's worth a lot right there.
I haven't tested it, but in FacebookSession class there's a [getLongLivedSession](https://developers.facebook.com/docs/php/FacebookSession/4.0.0#getlonglivedsession) method. Could it be that? Edit: In the [source](https://github.com/facebook/facebook-php-sdk-v4/blob/master/src/Facebook/FacebookSession.php#L157) there's a comment saying that the method will be removed. 
Good point
Cake is oddly written. It doesn't follow PSRs, doesn't utilize Composer, doesn't have a built-in autoloader, forces conventions over configurations, doesn't offer any real kind of class abstraction, relies a lot on magic functionality, all of which make it really slow. Cake 3 has changed a few things but all the bad parts of Cake 1/2 still exist. Use Symfony or Laravel if you're looking to use a framework. Use Bolt if you want a CMS.
I have never heard of a good gastropod simulation that didn't use some sort of framework.
I sense you're making fun of me. I'll show you when my snails take over the world.
Hey, thanks for this response. In your opinion, what would be a good framework to use if not Cake?
Laravel or Symphony are the resounding favorites of this community. 
FWIW, if you're looking to "progress", I'd recommend getting rid of phpmyadmin and writing your sql in the CLI.
Well "roll your own" is what I call it when I've done it in the past. But the point is: no one is writing *everything* from scratch, so you can stop worrying about it.
&gt; why did you quote laravel? And for that matter, why did you call it "laraval". I was mocking you. Sorry about that. 
You wouldn't unless you didn't know better. Honestly, I think every person who uses php should have at least a minimum basic understanding of how php and apache are configured. it's really not hard, and it makes it infinitely easier to manage the two once you have a handle on it.
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to [##php on Freenode IRC](http://webchat.freenode.net/?channels=%23php).
Should check out Behat, mixed with SauceLabs https://github.com/Behat/Behat
It's sad that it bothers me that the disclosure controls are rendered so poorly. At least try to center the - sign vertically within the box. So much effort, so little UI to execute and to fall down on such a detail. :(
Thank you; I think I'll begin doing this after I port everything over.
I like that they brought up their preference to move to CakePHP. It shows that they are thinking things through. I don't know Cake very well, but I know about frameworks in general, and I would much prefer to have code delivered in app framework form than Drupal "framework" (I guess some think of it that way) form. Drupal is very enterprise-ish and such software tends to be full of stuff that your website will not use. Even the modules tend to add two extra features for every one feature you do need them for. Code that's coming from somebody working with Cake will probably be easier to understand to a PHP generalist, will probably drive a GUI that's easier to use, and if it's somehow not fast enough, there are like a million things you can do outside of your framework choice to make sure your website runs extremely fast. Finally I would just mention that you are hiring somebody to build and maintain code, rather than hiring a framework. At some point in 2016 they will probably come to you and say, "gosh we found framework X and it's brand new and we think we could deliver these new features and even more speed and stability with it." What you want to be able to say at that point is, "you guys did a fantastic job on our website, we didn't know if Cake was going to be good but it worked out just fine, and I'm really glad to hear about the new technology. I have had some feature ideas of my own in the meantime so maybe we can include them with the framework switcharoo." In other words, you are hiring them for their professionalism and responsiveness first, and then maybe worrying about tools if/when they become an issue. If you really want to cover your bases, ask them for references, call those people and find out what they've experienced. As much as I'd love to harmonize with everyone else here, this is an online discussion forum and they tend to be biased toward process purity. Whenever I hire process purists, it seems like there is a 90% chance that they make all this great talk up front, then take my money and deliver sub-standard code or just try to disappear out of procrastinatory frustration with themselves. When I hire people who are capable but still a bit process-deaf, they at least seem to deliver quality work (the definition of quality work being "meets requirements"). Good luck with your project!
In your post, you mention: &gt; Note that the library is purposely limited in scope. It does not do roles, groups, access control, or account management. You give it some credentials, it tells you if the credentials are valid or not, and starts/stops sessions. That's where a lot of developers get confused. They think that "Auth" means both authentication and authorization and try to make their code do too much. Perhaps the package should be called Aura.Authentication or Aura.Authenticate to be more clear about its domain?
Why the hell do you need an entire framework for password hashing? Scrypt?
&gt; I was mocking you. Sorry about that. Assuming you're not doing it again, no worries :)
Absolutely.
Seems pretty useless. Relying on a framework is great, but hashing sensitive data correctly really needs to be, IMO, a staple that each and every programmer learns from the getgo. If not, then they'll come to call themselves a programmer, get a job, laravel isn't an option and look like a scrub. I've been using this [library](https://github.com/cosenary/Bcrypt-PHP-Class) for a while now and have since converted it to use scrypt instead, as bcrypt and scrypt are relatively similar programmatically, but not entropy wise.
This has been touched upon above, but it's worth repeating for your sake. Is it a re-skin or a functional re-design? A re-skin would not necessitate moving to CakePHP. That could easily end up costing a lot of money and for what?
Even easier: sudo apt-get install tasksel sudo tasksel install lamp-server Will even walk you through installation like it's a package, but installs everything separately.
It's cute that you think /r/PHP would take this seriously.
Weirder still, though, is why it's a lexer special case. Perhaps it's to work around an issue in the parser.
Learning it right now. Just started seriously yesterday. I'm coming from CakePHP. It's got some really interesting features and it seems much easier to learn than when I started learning Cake. There are a few sub components that I'm reading up on right now so learning Laravel seems to me means learning: Blade for php templating - Eloquent ORM - and while not required, i'm diving into node and grunt while I'm leaning to configure my first dev environment. I'm liking it so far.
*bah dum bah dum* -- PHP, ladies and gentlemen.
For $9 try https://laracasts.com for one month... its a great resource for learning Laravel the right way
Why are you adverse to the official documentation? I recently started picking up Laravel as an additional framework and find the docs are incredibly friendly.
Typing --force into anything on a production server makes my insides queasy. I think it's a healthy fear for every developer to have.
I spotted this parsing special case today when I was trying to revive Anthony Ferrara's scalar type hinting RFC. I really can't fathom why this could be a good idea.
Laravel's official docs are actually really good. EXTREMELY easy to skim, and just play around with the examples. You can learn 90% of what you need to in terms of the framework from the docs, and then use something like Laracasts for guidance on architecture. I personally love Laravel and strongly recommend it. It manages to be incredibly expressive with very concise syntax, requires almost ZERO configuration, doesn't have a crazy convention that you have to follow, doesn't make too many assumptions, and isn't infested with too much of its own pseudo languages. It's arguably the most pure-PHP-friendly framework available right now - that is, just know PHP and learn the framework's API, and you're all set. You don't need to learn a crazy configuration structure, or an annotation pseudo-language, or a string-based pseudo-language, or anything else: just its API. Can't speak highly enough about Laravel.
Yes. If your changes are mostly cosmetic, then absolutely stick with Drupal. The overwhelming majority of your changes should be via new artwork, CSS, HTML, and JS - none of which have much to do with the framework or CMS. As such, rebuilding the site in a different platform is a complete waste of money at this point, as none of that platform code needs to be touched.
Combine the official docs with the [cheat sheet](http://cheats.jesse-obrien.ca/) that was up here a few months back and everything is pretty easy to nut out. 
Best resource for beginners - [Code Bright](http://daylerees.com/codebright/codebright). It's the free online version of Dayle Rees' popular book on Leanpub.
`int` isn't a reserved word, but `(int)` is a token. This isn't to reserve anything, the PHP grammar just sucks. You can work around this by typing `var_dump(/**/int)`.
&gt; int isn't a reserved word, but (int) is a token. I know. That's what the OP demonstrates and mentions. &gt; You can work around this by typing var_dump(/**/int). Or any number of other ways.
my main issue with the docs is that they're so incomplete. I understand that there is the API reference, but for someone trying to learn the various methods available to Eloquent models, etc, it's not very friendly.
I've found that the docs and examples they give are complete enough that you can do most things with them. I've only ever had to dig through the API reference a couple times to find out how the API actually works, or what situations I might be able to apply to it. They are definitely incomplete, but they get you most of the way there (at least for starting out).
yeah they definitely get you a long way.
I made this library for fast prototyping or making small applications for my clients. Here are some usage example with Codeigniter. https://github.com/howtomakeaturn/Outlaw-Example-With-Codeigniter
Thank you for the opinions. I names the APIs because I don't want to make inexperienced developers confused with what exactly 'insert', 'update', 'delete' means since this library implements these features in a really dirty way. I rather they feel these APIs and usages weird since it's indeed uncommon.
i agree with this..i make alot mistake when im coding my own framework..i also getting better at using git cause i had to constantly reset/revert/checkout/merge and etc..and like u said, i need to think carefully about my application architecture, how to autoload class etc..indeed precious experience
Like I mentioned, you would handle doing all of this within the context of a route. When you're in the context of a route you know exactly what page is being requested.
Sounds like you might want Request::url() 
I'm a beginning Web Developer taking classes in school still. I've taken a two month course on PHP and MySQL. How experienced do you think someone should be with PHP to get the most out of learning laravel or another framework? I know it's always good to know the language before learning the framework. 
Seriously. The Java documentation is structured like someone barfed all the comments out of the source code and smeared it all over a page (which is essentially what auto-compiled Javadocs are). The Laravel documentation is one of the best I've seen of any language. Period.
Laravel is great. I did a few projects on 4.1 and just moved the one I still work on to 4.2. It is elegant, flexible, and has great design which will help you learn good PHP habits. Jumping back into old nasty PHP code hurts even more after using a framework as clean and elegant as Laravel. There is only one real concern I have with Laravel and that's the lack of a defined support roadmap. Because of this I moved to Symfony for enterprise-y projects because The Suits want to know something more than "as long as the community supports it". Symfony 2.3 was a long term release that came out in 2013 and is supported until 2016. And when that comes out there will be a new long term release available. So if the support matters to you I'd recommend Symfony. It is also very well designed and will help you learn great PHP habits. It's even more flexible than Laravel (sometimes a little too flexible which adds to the complexity!). It also has really detailed docs, lots of community and paid support, and bundles (feature plugins). The downside is that it's not as easy to pick up as Laravel is. Both are great and you won't go wrong with either. Also,check out: Vagrant (and puphpet) which lets you create, copy, and destroy VMs for development really fast and easy. And for an editor, if you don't already have a good PHP one, try PHPStorm (full-featured IDE, integrates all the things!) and SublimeText (fast and more of a text editor but has fantastic packages to add functionality).
As php is a server side programming so to test any website in your local system using Linux you need to install any server which i chose to be XAMPP.
This is so pointless though. It is so easy to install a lamp stack on any *nix OS... And i would hope you aren't using this for production servers
I only signed up a few days ago but I love these things. Z Jeffrey Way has a pleasant voice.
Using a virtual machine is cool and all, but it doesn't eliminate the need to be able to set up the environment.
Isn't int?
Agreed, but it should remove this particular need....
Well i din't say that you can't install lamp this is one which i preferred to install it and i am not using it for production server just on one system.
That seems like great advice. Thanks for taking the time to answer. Just from your hashing example I can already see how Laravel could make it easier and more efficient to develop with. I guess in the end it wouldn't hurt to start playing around with Laravel but still continue to learn more about PHP at the same time. Thanks again. 
Alright, yeah that's what I had been doing, but it seemed improper for some reason. Thanks for your help!
Do you have a public GitHub repo where people can look how you code/work/organize your projects?
That's a fair point - it has been many years since I did any dev on windows &amp; when I did it was as a host for Linux in VMware. On the other hand, if you're new to the *amp stack I can see how xampp would be cognitively easier/less intimidating than vagrant.
If you ask me NO - java time is passed. So much cool things happening arround java - groovy, scala, jruby ... For me, the most logical way is to start with FB HACKlang. At the end of summer they plan to release FBIDE - ide for hack. Check on youtube - it is like phpstorm for php. With hack you'll feel like writing statically typed PHP - in fact hack it is :-) All you need from java you have in hack ;-) P.S. that is decision I made for myself. 
When it comes to stuff like payments handling, PHP is, admittedly, not the best choice. Auto-promotion of integers to floats, lack of arbitrary precision arithmetics in the stdlib, lack of static typing and loose comparison are all detrimental to a fool-proof payments system. At best, they make you write tons of boilerplate. At worst, they introduce sneaky, very-hard-to-detect bugs. MtGox.'s leaked code should serve as a huge warning sign for this. Java, on the other hand, has static typing, type-safe comparison and things like [BigInteger](http://docs.oracle.com/javase/7/docs/api/java/math/BigInteger.html) providing arbitrary-precision immutable integers so it is better suited for this work.
It would be best, if possible, to queue each log event and let a background process deal with updating the database. 
I have _just_ started learning this last night. Laravel installation and homestead setup took all of 30 mins to an hour. The official documentation has been perfect for getting started, why are you against it?
Good luck getting your first few jobs... You might have to underbid the competitors to get your foot in the door and build your feedback rating.
Actually he/she just sounds like english isn't their first language. Nothing they've said isn't really that far from the truth, just worded clumsily.
The Java platform is certainly powerful. From time to time I use the Spring framework with Groovy as my language of choice. If you're familiar with Symfony then Spring should be relatively easy to pick up, in fact, I'm pretty sure Symfony borrows a lot from Spring framework in terms of design. However, having said that, there a things I miss when I work with Spring, e.g. the ease with which you can create Symfony command line commands and Doctrine with all the command line tooling that comes with it (fixtures, migrations, etc.). 
Really? &gt; java time is passed. Utter shite. And Hack/HHVM as a drop in replacement for Java? Nope.
It's not a crazy opinion if controversial. I don't agree with it, but... I'm not sure they're advocating hack as a Java replacement, merely saying that a lot of the *reasons stated* for going from PHP to Java may be covered by Hack. 
I was thikning that was my eyes. 
I think by "time has passed" he was referring to innovation in the java space - there's very, very little going on compared of the excitement an innovation in the java world was happening at the groovy/scala/jruby level. Basically 'java's time has passed' much in the way C++'s time has passed - Its used by a *lot* of people, and that will continue to be the case, but is anybody doing anything exciting in it? That being said, the OP wasnt talking about exciting things, he was talking about financials. So, yeah, you want a stable, static, predictable in that space. You *do not* want bleeding edge where people haven't already discovered the vast majority of mistakes that are possible. Ecommerce/financials in go/rust/swift/Hack ? yeah, why not wait a little bit on that... But will Hack squeeze out all the bugs someday and be a good thing for that type of app? perhaps. Is it a *drop in replacement* ? hell no. Nothing is a superior drop in replacement for anything other than earlier versions of the same language.
You definitely can use your own autoloader, actually most people using cakephp now just use composer. For example, you can use `composer create-project` and get this app template https://github.com/FriendsOfCake/app-template which comes pre-configured to use the composer's autoloader. No conflicts whatsoever. ClassRegistry::init() is a model factory (admitedly very badly named) but ithas no other purpose than creating Model instances. Were you actually trying to autoload classes with that? Anyway, CakePHP 3.0 finally uses namespaces and uses the composer autoloader by default. So this argument can be put to rest now :)
No problem! I can see how this misconception can exist, as there is plenty of FUD around CakePHP. It turns out that it is a very decent framework and hopefully with version 3.0 people will start to look at it differently while enjoying easier ways of doing the same repetitive tasks :)
I always recommend using a microframework like [Slim](http://slimframework.com/) before diving into a full-stack framework as a beginner. Microframeworks let you write pure PHP but give you a gentle introduction to routers, controllers, the request/response workflow, templating, session management etc. Furthermore, you can jam an entire Slim application in a single index.php, whereas with something like Laravel there are like 50 files in a starter project and a lot of things going on behind the scenes.
Why java and not [Go](http://golang.org/)? Statically typed: check, non-verbose: check, speed: check and I think it is easier to learn than java.
I tend to sway people away from Java due to it's resource overhead that many overlook. The language you use doesn't matter as much as knowing the language thoroughly. Knowing the caveats in what a language does in certain situations like automatically casting between number types therefore affecting precision is of more benefit than typing or execution speed. It may be beneficial to migrate to Java in your situation, but it could just as well not be worth the effort. For what I do, I don't rely on language primitives for things like currencies and I try to do everything as stupid simple as possible for the most crucial aspects which could effectively be translated into any language without any sort of struggle. Like nearly every language, both php and Java operate in two realms, compile-time and run-time. Java obviously compiles to bytecode so you get compilation errors, but php also compiles to opcode prior to running even in JIT environments so both can easily be analyzed via static analysis of the code for compilation errors. For php, running `php -l` does such a static analysis, or lint, for you and I have this run from vim each time I save a php file. As for run-time errors, both php and Java require that you actually run the programs to detect them. I've been known to describe php as akin to Java without a JRE, but with the emotional history of a sex-change operation. Php now is very similar to Java and very different from the time it was lampooned a decade or so ago, but it still has a lot of its old histrionics weaved throughout. You might very well be falling prey to the grass being greener. Every language is horrible if you've worked with enough of them. If you break out items such as your payments to a processing queue, then it really doesn't matter what you use and I'd actually advise something more along the lines of python to process them because I find it easier to maintain than Java installations for my systems. You should be writing a lot of tests with whatever you do so choose what you feel most comfortable with, not necessarily with what language you think is right for the job. Java could be best for you, but it also could be worse for you; only you will know in the end. Just don't choose something on a gut feeling and do your homework. Perhaps working on a couple small packages in Java might give you the proper information you need to choose your path.
I learnt Laravel using a combo of Philip Browns excellent step by step tutorials: [Culttt!](http://culttt.com/2014/07/07/doctrine-2-different-eloquent/) - the index of all the tutorials are about 3/4 down the page. Code Bright already mentioned in another thread and the official docs.
easier than the above command?, or the two commands by /u/__constructor
What an awkward method to intercept a form submission. Just hook a function on the submit event of the form and push the "click" to Google Analytics. &lt;form id="ex" ....&gt; &lt;input type="submit"&gt; &lt;/form&gt; &lt;script&gt; var form = document.getElementById('ex'); form.onsubmit = function () { _gaq.push(['_trackPageview',track]); } &lt;/script&gt; Moreover, _trackPageview is not really appropriate to track a form submission, perhaps a custom metric is more fitting. 
That seems a bit of a stretch. They really don't seem any better than most documentation in the PHP world, let alone ANY language.
Are you kidding, why wouldn't you? As far as I'm aware this doesn't go against any PSRs or coding standards, and it's just a convention that's developed within the team. If anything, it's more concise and readable than separating it?
Why not use repos, fuck? 
Feel good, everyone. We helped Joe!
&gt; You might have to underbid the competitors to get your foot in the door Kind of exactly the problem with this type of work these days. Too many young developers trying to get in, underbidding and with that pushing down the average price customers are willing to pay... Last project I applied, the customer suddenly wanted 160% of the work for 60% of the time paid, on an already very low calculated offer... You can't underbid forever... Sometimes not taking the job is the better thing to do.. 
Networking networking networking!!! hand out your business card to everyone, get your site up and running, if you live in a large-ish city, you might also want to SEO your way to the top for "cityname web developer" and such. Other than that you could try some of the tips on this page: https://helgesverre.com/blog/how-to-find-work-freelance-web-developer/
In the first snippet, sqrt() is invoked on every iteration of the loop. In the second, its only called once at the beginning to calculate the initial value of $i.
Add to that developers who live in the Phillipines or India, where their overheads are very low as compared to Europeans or Americans. Still, it is good for the digital nomad, who might move to asia and find the 'low' wages on oDesk considerable.
Just a heads up: Some of the lessons are free, and I recommend newcomers to Laravel start with the [Laravel From Scratch](https://laracasts.com/series/laravel-from-scratch) lessons. They are fantastic. Jeffrey Way is fantastic. Laracasts are well worth the price. 
Java is more established, Go is interesting but not a safe bet as Java is. It's also the language used in Android, which makes for a big excuse to start learning it.
&gt; For php, running php -l does such a static analysis, or lint, for you and I have this run from vim each time I save a php file. As for run-time errors, both php and Java require that you actually run the programs to detect them. As far as I know, `php -l` just checks that the code is valid PHP, but doesn't check that objects exist, methods receive valid params, etc., which Java does without actually running the program, right?
Try this: for($i = 1, $j = ceil(sqrt($num)); $i &lt;= $j; $i++) {}
They've probably used it. I have too, and yuck. Super inflexible basically. That was my impression. 
He *really* wants you to install XAMPP in Ubuntu.
Int ain't
Please avoid Learning Laravel. They are shady as shit and have ripped off the work of other Laravel resources. Rather go with laracasts or code bright.
I've run through those lessons. They're really good. Some of the clearest video tuts i've ever done
I can't help but feel he sounds just a tiny bit like Tobias from arrested development though. And now I can't unhear it
sudo apt-get install apache2 mysql-server php5 ... I don't understand why anybody would install XAMPP on Ubuntu.
You could always use the [Zephir](http://zephir-lang.com/) language and start easily writing modules with it. They've done a great job of removing atrocious C boiler plate and they've given it the best of PHP and C structure. Its going to be quicker than Java and it supports very nice static typing. You mostly need to compile it to PHP modules but it also now has a WIP JIT compiler. The developers are crazy intelligent. Zephir might be right up your alley if your customers can be made to install a PHP module.
Realistically you write the product in the language most suited for the task. For the use case you've outlined it's absolutely the more prudent option to choose something thats statically typed.
Craigslist is honestly your best bet. You're going to have to sift through 90% of the shit to find the good jobs, but after a few months you'll be able to start turning work away if you live in any reasonably sized city/town. You can drop bad clients like a rock but good clients will keep coming back with more and more if you can deliver.
This. I was very new to PHP and started with Laravel and Jeffrey's way of teaching is incredibly good! Unfortunately for me i ended up getting a job at a Python/Django place and there is no place like Laracasts for Django which is a shame.
Thanks for the detailed answer I probably can work with this. Thanks a lot!
IMO its much **less** readable and invites confusion because you have to figure out if you really mean `$foo = $bar` and not `'$foo == $bar`.
Murder, pollute? Are you serieus lol? Everyone understands CRUD terms.
&gt; providing arbitrary-precision immutable integers so it is better suited for this work. Especially if you want to round off and send the remainder to a bank account.
Like in superman?
I agree with /u/mattaugamer, the terms you used are definitely **more** confusing than basic CRUD terms like insert/create, read/get, update/edit, and delete. Your current API terminology makes no sense.
This is /r/PHP 
Does your space key break after every period and comma?
Thank you so much for this!!!
Love the concept! Great documentation too. 
Jetty, tomcat, jboss, glashfish ... java is fine, the ecosystem is crap...
I think your thought process is sound and I've done similar in the past. For instance, I delegated real time event handling to Node even when my application was in PHP etc. Some things are simpler to do with other languages/technologies and this is something that can be objectively observed. This single language mindset that plagued the Ruby community (and is now appearing in the Laravel community) is a dangerous one and it will eventually lead to trouble. 
I can't believe int.
Also, Go's API is stable-ish right now but the official tools (esp. for packaging) are *definitely* not stable and they *will* break BC in the immediate future so I'd rather wait for ~a year to let it stabilize a bit.
Is this a karma train? php 5.2.8 here.. nut soon ill upgrade everything.. i said that 3 years ago.
Heh, those are two of my least favorite parts of Laravel...
Hey Spectrael, check out channel 9!
Oh this would be excellent. Without a doubt my biggest obstacle in becoming a better developer is the fact I've never had a conversation (in person) with someone who's even made a hello world program. Also, maybe try posting it in /r/VirginiaTech? That sub is far more active and lots of CS majors show up there.
Using primitives to represent money instead of a well-tested [money class](http://martinfowler.com/eaaCatalog/money.html) is pretty shady in *any* language, though, so I'd argue that PHP's shortcomings are only real problems if you're doing things the wrong way. Monetary amounts should, of course, be internally represented as integers, and auto-promotion can be dealt with by using `gmp`, if you need arbitrary precision. I believe several good money libraries already exist, but it's not hard to roll your own.
I have no idea what the rules are, but I'm glad to have the link :D I didn't realize that you were just getting into PHP, not just getting into programming. I feel a little silly now. Anyway, good luck and if you have any php questions, that's primarily what I do and I'd be happy to help. If you're ever in Denver, CO I'll buy you a beer :) (I did get very confused when I got to "go" [which is one of my favorite games], and not a language I know)
Not a problem! I'll be the first to admit that, especially being self taught, I continuously learn new things about the languages I use at home _and_ at work. Even though I code pretty much all day every day I still feel like an amateur.
I like his videos, but I would happily pay extra to have someone else dub them.
A lot of people love node here, myself included. You just made a terrible apples to oranges comparison while barely understanding the technologies you were comparing. No one is downvoting this because it's Node.js, they're downvoting it because it's a bad article.
Embedding user-supplied variables directly into SQL statements is probably the biggest one I see.
Thanks and done.
Sure, there is gmp but one; it's not in the stdlib and requires third party libs, and two; it's not very efficient, e.g adding 2 N-bit numbers is O(N) and multiplying them is O(N\^2). But that's not even my main point. Why do money stuff in PHP where it is painful, non-standard and boilerplate-y when you can do it in a language that *natively* supports it? Every tool has its uses, including PHP. Arbitrary precision arithmetics in a language where integers are platform dependent and capped at 64bits is just not a good idea.
Aww the PDF version looks nowhere near as good as that page.
This feels like you're insulting my intelligence, when I said I was a beginner, and couldn't find any answers via google/stackoverflow/here. Sorry I've apparently lowered your faith in up and coming web developers every where.
Ok, so at the moment you're just hard-coding the username and password which is a terrible idea. You really want to hook into a database to add users, you want to be able to then change the details affecting each page, etc. Authentication is something basically every web app needs, and as a result there are lots and lots of frameworks that make this VERY simple to get setup. The current flavour of the month is Laravel and with it, you should find it very quick and easy to set up a database that your app will hook into so that you can require they be logged in before accessing any number of pages you want restricted. You're just starting out so a lot of it may go over your head at first but as it's time sensitive just look at Laravel, follow the free video series on Laracasts and you should know enough (or be able to copy and paste enough) to get basic authentication set up. 
The can't figure it out either. I suspect something has been lost in translation. 
There are a couple good ways to store and use users and passwords. The easiest is to setup a Database so that you can create a user table that will store usernames and hashed passwords, as well as permissions. For that you should look into http://www.mysql.com/ and http://wiki.hashphp.org/PDO_Tutorial_for_MySQL_Developers . Once you have the database setup you can create a login page, as well as a user creation page. The user creation page will allow you to setup a Username, and password as well as assign permissions to the user created. When storing the password you need to hash the password in order to keep it secret. To do that you should look into this: http://php.net/manual/en/function.password-hash.php. The username password and permissions would then be stored in the database for the login page to retrieve and use. Now when a user logs in you will create a session that will hold their username, and the permissions that they hold. Session information can be found here: http://us1.php.net/manual/en/session.examples.basic.php. Then that session will persist till it dies, or they logout. For each page they visit you can compare the permission stored in the session to the permissions required to view the page. That is a very basic overview of a way to store and use logins. Let me know if you want or need more information.
Thank you very much. My workday is pretty much over, but I will look into this either over the weekend or first thing monday. 
you're probably right, sorry for being an asshat. To answer why it doesn't work, you're comparing a string to an array. in theory you could use a function like in_array() to check if the string is ANYWHERE in the array, which would work - but of course it would allow user names and passwords which don't pair up with each other to also work.. which.. if you're hardcoding plaintext passwords in a config to begin with, you probably don't care. tldr: in_array() would work, but don't do it.
Yeah, I know what I'm doing isn't a good solution. I'm the first hired web developer at the company I work for, and I'm often given tasks that I haven't encountered before, even in school. And often they have deadlines, need it done as quick as possible. Building a web page is easy, but sometimes I balk at tackling something brand new under a deadline. So I found a quick fix while I learn how to make a proper database to store usernames and passwords.
Possibly not what the OP is going for, but what if there was only one admin and you (the programmer) were the only one with that admin access? Would hard-coding the credentials, and hashing them, still be a terrible idea as far as security is concerned (from a completely black box approach)? Please explain if so!
Yes, it is designed for the web. Looking forward to other responses as far as security is concerned, however.
Ah, sorry. Let's say that any website that is more than just static pages with a little complexity like user login and uploads is a 'web app'. Most web apps are data driven and thus utilise a database. There are lots of options, but if you're starting out use MySQL. You will need to install it on your web server or look for a web host that offers it. There are GUI's that will then allow you to, for example, create a table called 'users' that has the fields username, password, email address. Your 'app' will be coded to check the username provided in the form against the users stored in the database. If it matches, on they progress. Hard-coding isn't bad because server side code doesn't show up BUT say you have 3 people who need access. Create $person1, $person2, $person3, check that on every page... fine. But then person 2 leaves, and now you have to go through each page and delete them. 2 pages? Fine. Creating a new user? They'll have to ask you, you have to log in to your server, update each page with said new user... it's just so messy it's a nightmare. Never do this.
Eff that guy. When you say "sensitive", how sensitive are we talking? I generally give each user a "level", call session_start() at the top of each page (so you can check the session variable), set a session variable ($_SESSION['whatever_you_want']) after they authenticate, and session_destroy() when they log out. Otherwise it times out after an hour of no activity (whatever session length is on your server). Then I can do: $groups_who_have_access = array('boss','peon'); if(in_array($_SESSION['whatever_you_want'], $groups_who_have_access)) echo $content_of_page; else die('You don't have access'); These pages aren't housing anything that any staff can't see though, because sessions can be spoofed. If you want fast, cheap, and good at the same time, you're going to have a bad time. Pick 2 of 3. I wouldn't store the password in a session variable, I would store the (hashed + salted) password in a database and only check that once per session. And one more time, eff that guy. Welcome to the dork side, all I ask is that you be curious and never stop learning. EDIT: Found this tutorial for pretty much what I'm talking about: http://www.phpeasystep.com/phptu/6.html
Someone mentioned hashing a database once I get that set up, so I'll be looking into both of these things this weekend or Monday.
&gt; Eff that guy. It's okay, he apologized. &gt;If you want fast, cheap, and good at the same time, you're going to have a bad time. This I know. I chose a simple and not great solution because of a deadline, but only to be able to come back and fix it properly later. As far as sensitive, not incredibly, just documents available for General Contractors for the specific jobs they're apart of. Not like, personal data, or something of the sort. 
If the only person who is going to need admin access is you then you can just use .htaccess to restrict access to the webpage via the web server. You can limit access to entire directories this way but it's not an ideal solution. Personal blog with a yourblog.com/addnew that only you will ever need to access? .htaccess works fine for this, but this obviously won't scale well when you want to add new users and is a pain in the ass to maintain when you want to change credentials etc.
Zephir is a terrible recommendation based on this post; I almost wanted to go as far as asking you to not make any recommendations in this subreddit based on this single recommendation post. The question being presented has nothing to do with Zephir but instead Java; If you feel that Zephir trumps Java in terms of choice in this decision I'd ask that you please include them in your post and or explain them such as your statement: &gt; Its going to be quicker than Java I could be very wrong making this assumption but I'm under the assumption you're not a core developer of Zephir or someone who uses it on a daily bases? Assuming that my assumption is correct I don't understand why you're recommending something you're lacking in experience with. Even if my assumption is correct or incorrect doesn't matter because I'd have to question a recommendation that suggests to use something that isn't even at a major stable v1 release. Zephir is extremely young to be making these sorts of recommendation; Hell, I can go further just by pointing out the issues page. TL;DR Zephir is less than one year old &amp; you're recommending it for payment processing o_o
I don't mean to take up too much of your time but, what would be the benefit of a .htaccess file over hard coding the username and password. We can go ahead and assume 0 scaling &amp; 1 user only - ever.
As you set all of this up, I recommend you look into SQL injection and prevention methods: white listing, black listing, and prepared statements are a good stating point.
You do realize Java is still widely used all over the place, right? For example, android apps are mostly written in Java.
Thank you, I will absolutely check these things out.
No, he's flat out wrong. Listing a bunch of alternatives doesn't mean something is dead, or even dying.
I type slow, so I didn't see his reply before submitting, but that kind of attitude turns people away from this sub. The FAQ says "Please be professional. This is a technical subreddit, so the level of decorum is higher." If you have the attitude of a teacher, questions have answers, not comebacks.
Well, thankfully, years on the internet have given me a thick skin, and I know sometimes people say things in moments of stress/anger. It's not an excuse, but it is human nature. After he apologized he was helpful, and everyone else has been incredibly helpful with several different (definitely better) methods of going about this, for which I'm thankful. I'll get it figured out.
I'd say it's a) with .htaccess you don't need to write the front-facing form or the individual page logic as the browser takes care of that. And b) it's also possible to protect an entire 'back end' with .htaccess by limiting access to a directory, let's say blog/admin so now you can protect blog/admin/addnew and blog/admin/manageposts. Of course a blog would likely be hooked up to a database, but you get the point.
Right you are. It's just a syntax check.
Something like this is what you're asking for. No framework, no database. This is just how you can do it in plain php. $logins = array( 'admin' =&gt; 'mcmillan', 'ian' =&gt; 'password', ); $login_username = $_POST['username']; // do some validation next line // validateOrDie($login_username); if(isset($login[$login_username]){ $login_password = $_POST['password']; // do some validation next line // validateOrDie($login_password); if($logins[$login_username] != $login_password){ // handle login failure } } P.S. People injecting their own concerns in a discussion about how to approach an engineering problem is part of what makes /r/php such a miserable place. Hard coded logins being a terrible idea? WTF. Suggesting massive dependencies for a beginner. WTF. Just answer the question. Sheesh.
It also says it's not a support subreddit.
Wow, good luck with this. It's really needed. I lived in Red Bank for a while and hated having to stay late to go to the NYC PHP Meetups.
What about Hack? Seems like a good middle-ground.
&gt; Sure, there is gmp but one; it's not in the stdlib and requires third party libs, How is this a disadvantage? Installing an extension is a 30-second inconvenience, at worst. Not bundling everything under the sun into core PHP stdlib is a *good thing*. &gt; and two; it's not very efficient, e.g adding 2 N-bit numbers is O(N) and multiplying them is O(N^2). I'll just assume you're right about the complexities, because I've never inspected the gmp source and don't really care to, but I will say that we're talking about money-handling here, not modeling the Big Bang. The performance of your arbitrary precision math is virtually guaranteed not to be a bottleneck. And gmp is a C extension, in any case. It's more than performant enough to calculate your bank transfers, TPS reports, late fees, and shopping cart checkout totals without bringing your app to its knees. &gt; Why do money stuff in PHP where it is painful, non-standard and boilerplate-y when you can do it in a language that natively supports it? Because it's not those things. You're artificially inflating the situation to be something it's not. Other, non-dynamic languages have some nice-to-haves (we all know this), but none of them are specific to money-handling. The class of problems that they can prevent is not specific to money-handling, and they're just as severe in real estate, warehousing, or medical apps. If you properly unit test your code (which you should be doing *anyway*), lack of these nice-to-haves can be mitigated. Besides, the most common problems in money-handling apps come from things that static typing, type-safe comparisons, and native arbitrary precision math can't prevent anyway. Things like rounding errors from splitting monetary amounts, for example.
Good luck!
Good luck! 
GtlPHP PHPGrenade 
Use Composer to handle dependencies.
Hi everyone! I wanna say thank you to all of you! I think you guys are right! I change all the API names in the version 1.2 now they are classical 'CRUD'! nobody need to murder or pollute their data anymore! and I also fix the typo 'dns' to 'dsn' https://github.com/howtomakeaturn/Outlaw For backward compatibility, I remain the following code function inject($table_name=null){ return $this-&gt;create($table_name); } function take($table_name=null, $id=null){ return $this-&gt;read($table_name, $id); } function pollute($table_name=null, $id){ return $this-&gt;update($table_name, $id); } function murder($table_name, $id){ return $this-&gt;delete($table_name, $id); } function gather($table_name=null){ return $this-&gt;readAll($table_name); } Thank you all again for make the library and the PHP world better. Love u all :DDDD
Hello, I'm already using composer, I'm not talking about managing dependencies, but how to keep up with one's project ecosystem including dependencies
How about a [wiki](https://www.mediawiki.org/wiki/MediaWiki)?
You can take a look at [Carbon](https://github.com/briannesbitt/Carbon), it extends DateTime and has many useful methods. Very easy to convert from unix timestamp to DateTime or Carbon and back again.
for security advisories of your dependencies: https://security.sensiolabs.org/
I understand that you're just a random internet stranger, but I honestly feel much better that you said that. I felt awful asking for clarification, because Mr. Watkins is such a prominent member of the community, but you are absolutely correct in pointing out that there are a huge number of shady fundraisers out there. I just wasn't sure about how the numbers added up and it seemed shady, but after your clarification it became perfectly clear. Thank you, /u/just3ws :)
I've got a pretty good job and income myself but three kids, medical expenses, every day things that just come up can really take a toll on the savings account. I don't think I could easily come up with six months plus in a short time without help. I don't know about the UK but I also have credit problems because of past medical expenses with my kids (last child was in NICU for nearly a month) and that didn't help my credit. It doesn't take a lot to get put in a really tight spot.
&gt; Even if we were to agree on all your other points, isn't this one reason enough to use the best (i.e a non-dynamic language) tool for the job? No, because there is nothing about static languages that make them implicitly better for working with money than dynamic languages. As I pointed out, the biggest pitfalls when working with money can't even be prevented with the perks of a static language. The fact that static languages have some perks is irrelevant to this conversation unless they aid in money-handling (which they do not, any more so than they aid with any other domain). So what are you left with? Syntactic sugar? I won't deny that `a = b + c` is nicer and more natural than `$a = $b-&gt;plus($c)`, but one would be flat crazy to choose Java over PHP just for this sugar.
Just finished up a Craigslist project - For me, Craigslist has been the best site to find work off of (when you do find a client, and make it to the contract stage), 8/10 everything goes smoothly. But as you stated 90% of the postings are spam, low budget, or very unorganized projects that would only lead to headaches.
&gt; No, because there is nothing about static languages that make them implicitly better for working with money than dynamic languages. If you honestly believe that, then I think we just have to agree to disagree and leave it at that :)
Reminds me of [this](http://www.doxdesk.com/img/updates/20091116-so-large.gif).
A wiki will help facilitate communication and organization within your company but will not automatically alert you of security vulnerabilities in your project dependencies.
Personally, I simply *don't*. Keep your number of dependencies as low as possible and try to get a good handle on what each one of them is actually doing. Is there going to be a security vulnerability in your math library, or collection class, or cli argument parser? Probably not. Might have some bugs, but it's unlikely to expose an avenue for hacking. The biggest vulnerability is the framework you use. Your passwords/authetnication and ACL. Keep an eye on those projects and don't worry about the smaller dependencies so much. Maybe update them to the latest stable release when business is slow.
Only gotcha I can think of are timezones. Make sure your timezone settings are correct.
Post this over at /r/PHPHelp! You'll get some good help over there. This isnt the support subreddit :)
Yea. Don't do this. Use a database. If the website is company based located on a secure server, I'd even say use flat files for storing the username and pre-encrypted password/salt before using hard coded usernames and passwords.
Love it. I really hated those old names, but I love the idea. 
If you get it going, feel free to pm me, as I run a group in DC and can point you to the discussion list for admins and other resources.
Why not python?
And daylight savings.
This is the license: http://opensource.org/licenses/MIT In other words, you can do almost anything with it as long as you include the license file.
Laravel itself is licenced under [MIT](http://opensource.org/licenses/MIT) which means you can, but some components/dependencies you used in your CMS may not be able to be used in commercial packages. You will need to make sure any components have the right licence.
You want to do what with php?
Hasn't CI been forgotten about?
He says that he is thinking about leaving PHP and migrating huge amounts of code. That will take quite a lot of time and depending on his timeline (it could be a year even) then Zephir could be quite relevant for him. So big fucking deal if I sent him a link to a technology that he likely wasn't familiar with. I don't need to apologize for Zephir being at v0.4.2 and if he isn't capable of looking for a version number than he shouldn't be programming anyways. As far as Zephir I would definitely consider it if I wasn't sure about a change and it was some time out. The nice thing about it is that he wouldn't need to rewrite everything but only a few core modules.
I've not used any framework, for now i want to code with clean and pure php before i move to frameworks. I don't need some super advanced books, it's just that i don't want a book to explain loops on 5 pages and classes on 20 pages. Edit: grammar
Oh, ok :)
all are MIT, ofc he can. 
Was just making a point that you should check licenses first.
References are quite easy to understand actually, but you need to know when and why it should be used. Example $a = 1; function add($foo) { $foo++; } add($a); echo $a; // 1 Now this would do nothing to $a But if we changed it to $a = 1; function add(&amp;$foo) { // See the &amp;-reference sign here $foo++; } add($a); echo $a; // 2 And just for your info $a = 1; function add($foo) { $foo++; } foo(&amp;$a); // Here we moved the &amp;-reference sign to the call instead, but this is deprecated since PHP 5.0 I think it was // (not sure if its removed in the newest PHP yet, but will properly be gone in PHP6) For books, well if you come from a C++ world, and you are quite good at it, I wouldnt find any books that describe the PHP language, just use PHP and find the good stuff (and the quirks) in PHP. I really mean just learn the difference in the syntax between C++ and PHP and you are a big step. After that, use a framework, and now it would be a good time to find books that describes the framework of your choice to really get into it. When you are good at that framework, you can pretty easy learn other frameworks.
The thing that I'm not seeing is an explanation as to why it's needed. Having more package managers/installers just fragments the community. NodeJS got it right - they have npm and that's it, and it works great. Edit: thanks all for your explanations, I now see the value in it. I wasn't too knowledgeable about PHP package management before so I get it now!
Well i understand references quite well, but double $ singes bugs me, i can google that out, but i believe that there is a lot of these things that i don't know that even exist so because of that i asked for some advanced books or tutorials, but i tend to avoid tutorials. Thanks for help anyways :)
Pickle is for installing binary extensions and it doesn't depend on the ages old pear installer which the php devs like to get rid of
And yes, references can also be used with arrays. $a = ['foo' =&gt; 'foosy', 'bar' =&gt; 'barsy']; function add(array &amp;$array) { // Here we both use the &amp;-reference sign and a type strong - meaning the input into our add function needs to be a array $array['baz'] = 'bazsy']; } add($a); print_r($a); // ['foo' =&gt; 'foosy', 'bar' =&gt; 'barsy', 'baz' =&gt; 'bazsy'] And classes can also be referenced
.. and the plan is to integrate it with composer, so that composer can handle both extensions and libraries.
I assume you're talking about the command line tool pear (which, when invoked as pecl, is what's being replaced by Pickle), as PEAR itself is for libraries written in PHP, and not for lower level extensions for PHP. This aims to replace the 'pecl' command with something more flexible.
I still use CI for some projects just to switch it up a bit. 
Thanks for the comment, guys
People do seem unhappy with pear / pecl. I've never had too much trouble.
[This book]( http://www.amazon.com/gp/aw/d/1430227273?pc_redir=1404751285&amp;robot_redir=1) helped me boost my PHP programming to a whole new level, hope it helps you as well. Also look into frameworks like Symfony or Laravel, they're definitely worth learning if you want to be serious about PHP
Not only have I reaped huge gains with memcached but the key value system has made for more interesting data structures. Basically I use mariadb as a physical backup and my systems use memcached as the data store. Quite simply I don't have any datastore that even comes close to the amount of memory easily allocated to memcached and servers can remain on for months at a time (basically kernel updates cause reboots). 
It handles dependencies better, follows PSR-X for autoloading, easily allows project local installations, has a usable dependency file that can included with the project, supports installations directly from VCS if the project has a composer.json file (directly from github, etc.), lockable versions, packagist.org as a repository of projects works a lot better than the pear website, etc. :-)
You should not explicitly reference classess or class attributes, classes are passed by reference as default. The parser should warn you of this if you have error reporting configured to display warnings. 
Holy shit I hope this is hyperbole. Or sarcasm. No one could possibly hold this opinion with a straight face or a real job. 
Php is a Turing complete language with only esoteric variances in style, and a notably large inbuilt library of helper functions. Learn the appropriate operators and their usage, the coding style best practices suggested by the community at large and you can stop looking for php books and instead focus your effort finding books about programmatic concepts rather than language bound constructs. Advanced programming begins when youve left the language specific issues behind and venture into areas of thought that are language agnostic. 
If you meant about algorithms, design patterns etc. it should not be a problem since i'm computer science student and as one i have strong background i such areas. PHP is Turing complete language, but so is Turing machine, URM and Lambda calculus (not sure about the traslation, English is not my native) and i don't see many web sites built with those :) Only problem that i encounter are those that are language spececific, i need to learn all about PHP and it's language construct in order to advane to frameworks and other helpful tools. &gt; Advanced programming begins when youve left the language specific issues behind. That is why i need good PHP book, with advanced language specs :)
Why not Redis? (Serious)
yes, pretty much. http://ellislab.com/blog/entry/ellislab-seeking-new-owner-for-codeigniter
I would highly recommend looking into Redis. I used to be a memcached fan myself (and still am), but Redis' versatility and ease of use is just amazing
&gt; they have npm and that's it, and it works great. When it does work, yes, it works great. But that's ignoring all the horrifying warnings and errors during compiling and what not.
I had been using memcached for years, then switched to redis. The difference is _huge_, quite the revelation in terms of features and stability.
What do you mean? No one should ever be seeing the JSON. Your JSON requests should be under some URL like /api/users.json?id=5. No one on your desktop app should be hitting that URL unless they're deliberately trying to access the API.
Same here. We are currently moving everything from memcache to redis
Classes are not passed at all, objects are. In PHP, objects are *not* passed by reference by default. Object identifiers are passed by value. The difference is quite subtle but it's important to understand to avoid confusion: $obj = new stdClass; $obj-&gt;name = 'foo'; function bar(stdClass $arg) { $arg-&gt;name = 'bar'; } bar($obj); echo $obj-&gt;name; // bar As you can see here, this appears to be passing by reference, but it isn't. $obj contains an identifier which points to the data held by the object we created. This identifier is what we pass to the function, so when PHP finds the instance whose name property should be set, it finds the same instance again. However consider this case: $obj = new stdClass; $obj-&gt;name = 'foo'; function bar (stdClass $arg) { $arg = new stdClass; $arg-&gt;name = 'bar'; } bar($obj); echo $obj-&gt;name; // foo If we truly had a reference here, this situation would not arise. What we've done here is simply put a new object identifier into $arg, replacing the old one. The identifer held by $obj is still the original object. If instead we *do* pass the object (identifier) by reference: $obj = new stdClass; $obj-&gt;name = 'foo'; function bar (stdClass &amp;$arg) { $arg = new stdClass; $arg-&gt;name = 'bar'; } bar($obj); echo $obj-&gt;name; // bar
I've been using [Couchbase's](http://www.couchbase.com/) memcached server with much success. It's super easy to configure and extend capacity by adding nodes. If you aren't using Redis, you should be using Memcached via Couchbase.
The reviews on Amazon are decidedly negative about the readability of the book due to very poor English and editing. Was your experience different?
I thought that we are speaking about web development. Yep java is used for android but groovy and scala as well. Android development will become more enjoable soon. Learning of java is worth only if you plan to work as dev in enterprises. P.S. Java is boring lang - nothing exciting.
I used Mongo for a while and threw it into the trash and then spit on it and threw a dirty diaper open side down on top of it; out of pure frustration. I found that MongoDB is cool from one end to the other; but for some reason everything that is easy is great but everything that is hard is a brutal battle where I needed a Ouija board so that I could get tactical advice from Napoleon. Whereas with things like MariaDB and so far with my redis tests everything is about the same difficulty; which isn't too bad. 
Came here to say this. Not only does it do what memcached does better, but it does a load more too. It's available on AWS Elasticache too now.
If you're a reasonably advanced developer and you understand concepts like MVC and IOC and all that, and you don't want to read through basic docs or sit through hours of screencasts that explain what a controller or a view is, here's my suggestion: Go to Github and type "Laravel" in the search. Clone some of the more popular and recent projects, and go through the code and see how they implemented their controllers and models and views etc.. Definitely check out more than one though (I think I've reviewed about 6?), since there are different ways to go about things and I've seen some questionable practices alongside good ones. ;-) Then reference back to the official docs (which are quite good) when you want to dig into something further after you see it being used in the codebase.. This is how I did it.. I started about 2 weeks ago and I'm deep into development on my own Laravel app already with a good understanding of the framework. Once you get up and running it's a pleasure to work in. 
Or, /r/PHPhelp 
Holy shit that's an interesting book! One day, when I consider myself good enough, I'll get me a copy. Thanks for putting it on my radar!
most people will only be using composer to interact with pickle
Add an authentication layer?
Just started a blog and figured I'd get some feedback on how I write stuff and if the article itself is informative and helpful!
Little late to the party on this one.
Two issues: 1. People recommend rsync/deployment services because hosting a clone of your code on your production server is a) a security issue and b) entirely overkill for a server that needs exactly one version of your code (the one marked stable). The latter point is particularly something to watch with large repos with a lot of history. 2. You don't explicitly state that's what you're recommending (but it seems heavily implied), but never, ever, ever, ever, never run `composer update` on a production server. Ever. You have no idea what changes have been made upstream and how it affects your code. You run `composer update` on your dev server, test the changes, then commit your updated `composer.lock` file. On the production server (or really ideally, on your build server), you run `composer install --optimize-autoloader --no-dev --prefer-dist` which will install the versions of dependencies you know work. With those two issues in mind, these are perfectly suitable instructions for deploying to a *staging* or a *dev* server, not production.
Why is he being downvoted? This IS the correct approach.
Redis is a persistent data store, you can use it for your mem cache and backup.
Yeah sure, would be cool :)
Not the solution you're looking for, but you can run `composer dump-autoload` for a quicker classmap generation.
I ended up installing Apache, PHP, MySQL and Composer myself :) Wish I had done this ages ago. Was a great learning experience.
Laravel comes with an MIT license, so as long as you include the license with the software you're fine in that regard. The issue here, is whether or not the client is okay with you reselling the work you've already done. Since you've already sold the work, it's no longer yours. If they're not okay with the client they can take you to court for it. You should simply remake the CMS that you previously made with a few added features and bug fixes, then release that as your product so even if they take you to court you could argue it's not the same product.
I know, I am testing it on some under development code; I just have never put it into production so I can't say that it doesn't turn into a huge pain in the ass. I deployed MongoDB for some code and I couldn't have regretted it much more. When I typed "yum remove mongo-10gen mongo-10gen-server" I breathed a huge sigh of relief. So while redis is looking really good, I don't want to make the mongo mistake again. 
For website URLs I like your method, but for APIs it's much easier to *not* put half the variables in the path and the other half in the query params. It's also nice to have the type (.json) in there somewhere too in case more than one is available.
The standard library. Everyone can make some gripe about the language itself – unexpected/unintuitive handling of references in `foreach` loops, truthiness/strict comparisons, etc. – but most of the really high-profile complaints (and rightly so) are inconsistencies in the standard library. Needle/haystack vs. haystack/needle argument ordering, returning `false` vs. returning `null` vs. doing nothing on failure, not taking advantage of class namespacing, the list goes on. At this point, my wishlist for PHP6 contains only one item: a ground-up redesign of the standard library which properly takes into consideration features that have been added to the language in the last decade. I know it's impractical in so many ways, but this is my wishlist, not reality!
There isn't a better solution. This command does exactly what you were asking for.
I think populating the database full of tickets first with information columns is a good idea rather than trying to insert as you go. That way, you don't have the cost of an insert, just an update. My line of thinking here is that an update based on ticket ID number would probably be faster - sure, it still has to do a search for the record, but less data is being created and dealt with compared to a full new insert. Make sure you use InnoDB tables for your MySQL database because they support row-level locking on write operations. This means that many updates can be made to the table rows, or tickets at once. Otherwise, if you aren't using InnoDB, and a bunch of users get tickets all at once, it could cause an avalanche of stuck requests since each update has to wait for the prior one to finish and the whole entire table remains locked. That can get ugly fast. I can't see why this would be a problem though as long as the server itself has enough memory and everything else is optimized to handle such requests. Your biggest bottlenecks aren't going to have anything to do with PHP at all - it's really the database and webserver. Another option is to try creating a queue. Back in the day, a site called fileplanet used to do that for downloads. You'd get in line and had to wait until it was time to grab your download ticket. 
The Needle and Haystack issue.
Gah, I did say Classes, didn't I? You're right, I meant objects. I think the use of the word 'reference' was a poor choice as well, what you actually have is a pointer to that object in memory, not a reference. The difference being, what is passed is mutable via assignment, BUT, if the object is assigned to a new variable instance, that variable is a COPY of the passed object. Heck, does PHP even have 'references' per se? I think they're actually called 'aliases' due to this subtle behavioral difference. In any case, you almost never want to pass an object by explicit reference (MyClass &amp;$foo), as the behavior of the pointer to the object as a parameter behaves much like a property passed by reference, hence the confusion.
&gt; The client sells events throughout the year, but has a select few that are very high demand, and to date has always crashed their system when they go on sale. I need to not crash. Fun! Get the client to be more specific about the requirements. How many users will try to buy tickets at the same time? Translate that into requests per minute or per second. Have the client sign off on that. Once everyone agrees on the load the system should be able to handle, you can start looking into specific technologies (Laravel, MySQL vs Memcache vs Redis) and stress test the system and prove to your client that you are meeting the specifications.
I can second PHP Objects, Patterns, and Practice, a great book, but by now probably a little behind the current syntax and functions. I would also recommend many/any articles by Alejandro Gervasio, from the old phpmaster site. http://www.sitepoint.com/author/agervasio/. He does a lot of great exploratory writing on new PHP constructs as they're added, with very useful examples..
For the noob that just traveled down this path like me: pay attention to the memcache vs memcache*d* as they are similar but completely different. 
An easy, memory-friendly way to re-index a multi-dimensional array by the values of one of the child elements (e.g. a unique ID). A zero-indexed array of items is useless compared to an array indexed by a unique identifier. I run into this all the time, on every app I work on, and there is no single function way of re-indexing a zero-indexed array of objects or array without looping over it and eating a bunch of memory.
Both Memcached and Redis atomic "increment" functions return the new value after the increment has taken place and would be a good fit for determining if the event has "sold out", etc.
1) Method Overloading 2) LINQ
Here you go: http://timetoogo.github.io/Pinq/
Just comply with naming standards and you don't have these problems. Multiple classes in a single file is a bad idea anyway, composer has problems with it, your IDE has problems with it, coworkers have to search classes, ...
Lisp-style macros. Rip out the internal token parser, replace it with a parser that generates and AST and add a macro function that can modify the AST during bytecode/opcode compilation. If you did this then 95% of the PHP RFC's and most of the stuff in this thread could efficiently be implemented in pure PHP without having to change PHP at all. Someone already did this in PHPPHP, a PHP parser written in PHP. Of course, that's slow as hell but it proves the concept is sound.
Uh, *what?* What the hell does a wiki have to do with handling dependencies? 
I love this idea. Its a great challenge to how do you build a system like this. I think I can see more than 1 challenge here. If you system shows any sign of it working well. Then 1. Who ever you build it for, will want to push the limits of what it can do (eg sell 10,000 in 3 mins). 2. Sell it to another company that wants to sell 100,000 tickets etc. And you end up with a system that breaks and most likely is like all the other ticketing system out there. Some thoughts off the top of my head. 1. The way ticket sales work today are **stupid** and **frustrating** 2. You wait until 9:55 am and refresh your browser 200x to see if the tickets are on sale. 3. *Crux* if you do get through by chance. Then you can *try* to buy you ticket hoping the system wont crash. 4. So you manage to get a ticket and it takes 3 - 30 minutes (30 minutes once for me to buy basketball tickets). Everyone is going to hate your system because it is slow (even though it just processed 1000 tickets in 20 minutes). I would love to suggest some ideas. 1. Pre register all buyers for the event so when tickets go on sale, they only need to login and pay. (optional) 2. Create a queue server, which puts people into a queue holding them there for 5, 10, 20 or 30 minutes, a queue server would display a rough time or place in the queue that a person needs to wait before buying a ticket. 3. Monitor the ticket server and when there is a "spare" slot eg load is not too high, pass a person from the queue into the main ticket system. So they can be processed quickly and efficiently. 4. I suspect that the database is going to the biggest problem and I love you idea of generating the tickets prior. If this system was super smart, you could also allocate tickets to different servers so this way, your primary queue server would check each of your ticket servers to see who has capacity to serve a customer in the queue. 5. This way you have a system with near unlimited capacity and awesome user experience. 6. For bonus points - a feature for future dates, the queue server could push emails, sms or just play a loud sound to say, to say "you are at the front of the queue". Make sure the user presses a button before they go to the ticket server, this way you know you have a "live" user and not someone that has left for the bathroom. I think what I have described is like a real ticketing system. Paper tickets are printed, sent to different locations, people queue on the day at the venue, and are even handed of to different tellers when they get to the front of the queue. This system works great. 
Have you measured the memory overhead? As I recall, PHP uses copy-on-write, so a second array of the same items should not consume all that much memory until you start modifying it. And an array of objects doesn't make copies of its contents at all. Personally, I try to work with (arrays of) objects wherever possible, to avoid that copying and to have code completion. And when I need to key an array by a unique identifier, `array_reduce` feels more idiomatic than a `foreach`. It's still a loop under the covers, of course, you cannot reindex an array without iterating over its contents to get the keys...
Wouldn't this be a good use-case for generators? Genuinely curious.
Why don't you want them to be namespaced?
OP mentions documentation, change logs and stuff like that which a wiki would be good for.
Politically? Appoint a competent BDFL ( /u/nikic ? /u/ircmaxell ? ) to keep the self-important circlejerk out of the way. Technically? Add a type system similar to TypeScript - it would be optional, support primitives and *generics*, and have full IDE integration.
Can I do it with a single function call, ubiquitously in every project I work on without having to include additional dependencies or libraries? I'll I want for christmas is: $newarray = array_indexby('id'); :( Sure, I can write my own generator function that does this, but then that's a library I have to use in every project I work on. I want a language-level construct that uses generators internally, rather than forcing me to do a userland implementation. Internally, it should be much more performance-friendly and memory-friendly than a userland implementation of the same thing.
To go one step further, I'd like the standard library to be built in PHP itself, rather than in C. That way, not only are performance problems more visible (and more likely to be tackled), but if I don't like the standard library, *I don't have to use it*.
While I can certainly sympathize with the sentiment, I'm not sure I'd go that far. It strikes me that there's some benefit to having some of the lower-level stuff that's heavily relied on by other components, especially string-handling routines, implemented in C. Perhaps a reasonable compromise would be to move more parts of the standard library, without changing the APIs at all, into more and smaller extensions? That way, environment-specific selective elimination of less-desired parts of the standard library would be possible.
Sure, an API like that would come in handy. But how should it handle failures (e.g. the off-chance of duplicate keys)? And it would ideally need to handle `['id']`, `-&gt;id`, `-&gt;id()` as well as a callback/closure... I'm not saying that is too complex, just that it'd have to be thought through. If you are on 5.5 already, you can try `array_combine(array_column($items, 'id'), $items)` .
You mean the haystack and needle issue. 
If I were you I would use cloud based Queues for easy management. Put all your tickets of one kind in a Queue and when someone buys a ticket take one message out of that queue. There can be a cron that will count the number of messages in that queue and as the quantity goes below a threshold replenish the queue. 
Remove everyone currently involved politically.
Stack Overflow is *not* a forum or a support center. It's a Q&amp;A site to get answers to precise problems you are encountering. If the answer to your question is in the documentation, is a matter of opinion, or requires a full chapter of a book, SO is *not* the place for it. The "canihazcodez plox" brigade thinks it is, but it's not.
PSR-4 requires a namespace. Or at least, composer's definition does.
Forgive the self-promotion, but this is exactly what I'm writing about: https://leanpub.com/typedphp This kind of stuff is possible today, and greatly aided by the use of things like SPLTypes or Nikic's Scalar Objects extension. 
Cool. A domain I've worked in professionally! If you can make a decision to align the business with a computationally efficient workflow like sponnonz mentioned, go for it. Otherwise this is my advice. My setup was a 4-node webserver cluster running behind an F5 on top of mssqlserver, but the general principles are the same. We regularly sold out stadiums in minutes. Hit the database as few times as possible. There are most likely going to be cases where you need to begin a transaction, get some rows, and then insert/update some rows. If this requires multiple round trips to the database, you are hosed. Aim low like one db call for retrieving seats, one to add seats to the basket, and one to purchase everything in the basket. Of course you'll want to verify this is what's slowing you down before optimising for it, but this is the number one reasons for slowdowns. Run explain or whatever your equivalent is for analyzing your query plan. Scans are evil and index appropriately. Its entirely possible to over index and slow down your write times. Consider strategic denormalization. Jcink's idea is interesting. I'd prototype it.out. I feel like you would certainly want to clean out unsold tickets after the event. Depending on your performance target, you'll want to explore more exotic solutions. My personal threshold for this would be 50k seats in &lt;20 mins. You could scale mysql past this but it might take some work. As always get real data by running simulations against your targets and collecting data.
After generics, shorthand syntax for closures / lambdas. The current closure syntax it terribly verbose and much of the time closures are simple one-liners. If PHP were to adopt something like [Hack's lamda expressions](http://docs.hhvm.com/manual/en/hack.lambda.php), this would allow far more expressive and cleaner code when using functional elements of the language. //Current syntax: array_map($values, function ($val) { return $val * 10; }); //Hack's lambda expressions array_map($values, $val ==&gt; $val * 10);
No. Needle, replace, haystack and something totally different issue. =)
1. While it would be nice in the sense that you can do it in other languages, there's ways around it. Might not look as nice, but it works. 2. LINQ is a non issue. 
Then no one will be involved. People are political.
well, you'd obviously have to elect new people EDIT: how does this get downvoted?
This would be a fairly easy solution that would maintain backwards compatibility between versions. I am all for this. Function calls will be a few characters longer (array::search instead of array_search) but would save me headaches of checking the docs when I am about to use a function.
There a difference between elected and forced. =) 
im not forcing anyone lol
So, if you have people running against each other, which have to be voted in, then it's political. If you put people in charge by a random selection, then many things can happen: Nothing, something or anything in-between. 
I think you misread me from the start... &gt; Remove everyone **currently** involved politically Im not saying keep remove them. I also think they should serve terms, with max number of terms...
This is so cool, because I'm building exactly the same for a client. Hit me up, so we can exchange ideas.
Technically, this could be done before PHP6 then
I actually think it looks nicer haha
By reindexing, do you mean make the numeric index contiguous? You can use array_values() for that. 
A type system would really improve PHP. Even an optional one.
What, like Rasmus? &gt;:-)
Well it's a recursive issue that. You remove the people you think are corrupt, you put in people that seem like they will do a great job, but unfortunately they are human and have thoughts. Those thoughts may or may not align with the mass and they might vote for what they think is right and not what the majority thing, which may or may not be a really horrible thing. Personally I think that the next major revision shouldn't be backwards compatible. Get standards in a place and and enforce them.Of course that will take a whole new group of people to even get the ball rolling. 
But change still happens. You aren't stuck with the same non-moving SHIT. How well did that work for Python 3.
Well, to some extent, it already exists: you can use [type hints](http://us.php.net/manual/en/language.oop5.typehinting.php) to specify that a function argument has to be of a specific class type. There are limitations, but it's a start.
That's likely true for slapping together basic applications. Frameworks help you glue things together and help you reduce repetitive tasks, but if your app does anything of reasonable complexity and or uniqueness you will write plenty of PHP code.
Frameworks don't remove the need to write PHP or the need to ever write PHP that requires a mastery of the underlying language unless what you are creating is very very basic.
The one thing I would currently like to see (but this changes monthly!) - change all function errors to exceptions across the board - much nicer being able to try/catch all the things. Much like this examples wraps up here: http://php.net/manual/en/class.errorexception.php And a close second - something I posted the other day which I see as a worthy addition to generators (if at all possible). http://www.reddit.com/r/PHP/comments/2a498n/generators_yielding_from_within_a_closure/ 
Yeah, but not being able to type hint and try/catch on int and string is more limiting than it sounds in my experience.
Needle, haystack, egg and chicken?
At the risk of being flamed to hell.... what is stopping you moving to another language that doesn't have these problems? I'm forced to use PHP at work, so I'm kinda stuck (but my IDE auto-complete hides a lot of the needle/haystack issues)....
I just updated lib and docs!
There is some logic to the haystack needle order, string functions use it one way and array functions the other. I remember watching a keynote by Rasmus Lerdorf mentioning it's something to do with the underlying C code. I still have to look it up every time though.
But the OP obviously isn't legacy code.
It's worth noting that you can register more than one autoloader. So you could use a different, non-composer autoloader that specifically looks in your /controllers folder for a matching class.
I moved to Python in a previous job (all those arguments about where to put { and } and tabs vs spaces (2 or 4?) .... gone.
Write a PHP pre-processor? Write your own syntax ;)
I'm sure there's a reason for asking for one thing ... however, it doesn't seem to be a super useful thing to think about. The best of the isolated ideas here are just impractical ... * Type hinting needs finishing; users should be able to hint for everything that the engine supports, so should internal functions. * Namespaces need promotion; right now they are a feature of the compiler, they are much less useful than they could be from an engine perspective because of this. For example should we want nested (or anonymous) classes, access control is more or less completely terrible without proper support for namespaces at execution time. * Traits need finishing; the original draft for traits (in scala) includes support for ```$var = new ConcreteClass() with SomeTrait;``` Where a trait can impement an interface, the above line is extremely powerful. * Objects should be castable to every type supported by the engine, this compliments and completes a better type system for PHP. At this point we can really entertain ideas like method overloading properly, we can have full support for generic programming, nested/anonymous classes (they are one in the same thing) ... So I'd do that ... in that order ... it's more than one thing, depending on perspective, I could describe all of the above as "bring the engine to place where much more is possible".
This. If you allow passing "1foobar" as an integer, PHP will be getting *yet another retarded and ever-so-slightly broken* "feature". I mean just *look* at that allowed/disallowed matrix. Soo many retarded things in there. * bool(true) is a valid string. * "123sfdsf" is a valid integer. * *Any* primitive is a valid boolean, but not arrays/stdClass because fuck you. * `null` can be passed for primitives, but not for resources/arrays/objects *completely* defeating its purpose. I could go on...
&gt; Should I then have a cron running every few minutes to re-release tickets that have not completed checkout? Assuming you pre-populate the ticket database (a good idea) a ticket will be "available" to fetch if... 1.) It has not been claimed 2.) It's 'last touched' value is past the 15 minute lockdown window. Thus - when said ticket is first fetched put a timestamp on it - for each step of the checkout process, optionally add some more time to this value (to allow the user to go back/forward through checkout without dropping the ticket). If any tickets timestamp blows this cap/timeout it's back up for grabbing. Don't underestimate the power MySQL/Postgres can wield without resorting to other solutions (Redis/NoSQL/etc.) - having something transactional is well worth it being e-commerce related. It might even be the case if you still need some database storage for the site itself outside of purchasing you run a separate DB instance for solely the ticket management side since that's going to get slammed. Or maybe use Redis as the "first hit" looking for a free ticket and then if that succeeds the client request can then move onto the database and claim the ticket in the DB. That way your Redis instance of "1000 tickets" can get slammed by everyone hitting "F5" to denial of service levels - and then at most 1000 users will be accessing/updating the DB at any one time. At least on the MySQL side, correct tuning of InnoDB (things like innodb_buffer_pool_size) is going to be your your friend. 
It's consistent with the existing zend_parse_parameters (i.e. internal functions) and casting behaviour. Also, it does throw a notice. EDIT: I'm also not quite sure on this one, though. It might yet change.
http://www.phptherightway.com/ is always a good read. I work with PHP since 2004 and since 2008 the professional way. I'm still learning.
&gt;bool(true) is a valid string. Right, that's PHP's current behaviour for internal functions, and I don't see what's wrong with that. &gt;"123sfdsf" is a valid integer. ~~Not *quite*, that gives a notice.~~ EDIT: It isn't any more, the RFC and patch have been changed. &gt;Any primitive is a valid boolean, but not arrays/stdClass because fuck you. The patch, as written, allows stdClass as boolean. Since that is how it is just now, it might make sense to allow array() as boolean. EDIT: I added a section to consider that: https://wiki.php.net/rfc/scalar_type_hinting_with_cast#booleans &gt;null can be passed for primitives, but not for resources/arrays/objects completely defeating its purpose. What are you saying? Do you want primitives to have to be explicitly nullable? Or are you complaining that resource, array and object aren't nullable by default? You can always do `function (resource $a = NULL) {}`, and if the nullable types RFC is implemented and passes, you'll be able to do `function (?resource $a) {}`.
Which is, itself, the correct decision to make. :)
I am the current maintainer and am willing to answer any questions.
So you'd opt for change and breaking backwards compatibility?
"Typing … anything on a production server makes my insides queasy" FTFY ;-)
Thanks for your thorough answer and encouragement. Unit testing has been on my todo list for a long time, I'll prioritize it now. About Phalcon. In 2012 I decided to learn a framework and chose symfony2 after a survey of available frameworks. I studied it and built a few applications, I liked it a lot, the feel, the logic, the community, the documentation. Then two months ago I took a look at Phalcon. I spend a couple of weeks getting the feel of it, then another week systematically reading through the API documentation, occasionally referring to the c-code. Of course, studying Symfony has helped me understand the MVC magic built into Phalcon. What I've found is that Phalcon is exceedingly easy to work with. It's functionality seems so straight forward and transparent, the "magic" makes for very few lines of code, and advanced features for free. The caveat: I haven't built anything yet, I'm still reading up on it. I will build my first Phalcon based project in a few weeks time. Then I'll see if my first impressions last.
Thanks
This is the key to end your frustration. Array functions have needle first. Remember that and you're golden. 
Dumb article.
Easier to use the backtick. In 18 years of PHP I've never once needed to use that within a regular expression.
No, it isn't. Strict typing here would not go well with PHP (type juggling is inherent), and it's not what internal functions do. http://nikic.github.io/2012/03/06/Scalar-type-hinting-is-harder-than-you-think.html
I know Nikita's blog post very well. As evidenced by the comments there and anywhere scalar hints are discussed the community overwhelmingly wants it to be strict. So far, the majority of the resistance seems to be coming from internals folks which is very telling, since it suggests internals is very out of touch with the community.
What about using the [error control operator](http://php.net/manual/en/language.operators.errorcontrol.php) for that method if you don't want to replace it? This also gives you the benefit of not suppressing other errors
As has been pointed out before function foo(int $a) {}; should be strict, and function foo((int) $a) {}; could be used for casting. This way it would be much more useful, and it would be consistent with PHP's casting syntax.
Generics Method overloading Scalar typehints Return type hinting
Most likely Business decisions. I have a site almost exactly like this guys and EventBrite and I make almost 10% on top instead of paying them. That is about 20%. In just about 3 months I paid for my site and staffing needed for 1 year.
Just for the record, any time you try and put words in someone's mouth they're usually wrong. I said nothing of the kind. There are plenty of options for improvement that don't break backward compatibility, most particularly by moving contentious areas (such as string or array) to a new and more OOP approach while leaving the global functions in place. Another option is to simply alias "old" function names to a consistent name scheme and deprecate the old versions. That wouldn't fix argument order, but it would still be an improvement. Besides, you're misconstruing my argument. My statement above was not a reason for wanting the change, it was a reason for not wanting to go to a whole other language. The above is a whole other unrelated issue.
The second would be kind of confusing, no? To me it looks like a way to automatically cast a parameter. If scalar type hinting is to be done, it should be done a single way, for the sake of simplicity and consistency with non-scalar type hinting.
or use `mb_ereg_*` functions which don't require any delimiter (and are as fast as `preg_*` functions)
&gt; It's not, however, consistent with existing userland type-hinting behavior. That's correct, but that's not reasonable. Strict type hinting for scalars is going against the fundamental weakly-typed, type-juggling nature of PHP
ereg supports a limited subset of preg features.
Jeeeeze, I didn't mean to put words in your mouth. Just interested in how people would fix the issue. New OOP sounds like a good idea. We use a library similar to https://github.com/jsebrech/php-o ... but once the language has this the syntax is so similar to ruby that making the switch is effortless. It also kills the 'feel' of PHP. I'm sure Rasmus wrote a whole load of stuff about how fixing all these things by going pure OOP was against what PHP was all about. [edit] blimy, getting downvoted to hell again :( it may be time for me to stop posting. It's a shame because it was these sort of threads that got me interested in learning Python and Ruby and JS to learn more about why people moaned so much about PHP
&gt;I know Nikita's blog post very well. As evidenced by the comments there and anywhere scalar hints are discussed the community overwhelmingly wants it to be strict. Strict hinting isn't the PHP way, and would be inconsistent with the rest of PHP. It would make PHP's userland functions diverge further from internal functions. Anyway, the RFC as proposed is strict with a few exceptions (bool, ~~"123a"~~ EDIT: RFC no longer permits "123a"). &gt;I know Nikita's blog post very well. As evidenced by the comments there and anywhere scalar hints are discussed the community overwhelmingly wants it to be strict. Do they? An awful lot of PHP developers don't participate in the "community".
&gt; [...]the fundamental weakly-typed, type-juggling nature of PHP Look, I'm very, truly sorry you want to reverse time and go back to PHP 4, but the cat's already out of the bag. This is how PHP's hinting works works *now*. It's going to be a total WTF that some hints throw E_RECOVERABLE_ERRORs whereas some just throw E_NOTICEs. As nikic said on internals: &gt; I haven't yet closely reviewed the details of what is and isn't allowed, but one things I would strongly recommend against is introducing any "accept but throw a notice" cases. Either a value is allowed or it isn't. "12foo" to an int/float argument should throw a recoverable fatal error, like everything else. (I'd change that in zpp as well, but that's a different discussion).
The console application for Composer is built on top of the [Symfony Console Component](http://symfony.com/doc/current/components/console/introduction.html). The point of implementing the actual completion in PHP is that it allows completion based on commands/arguments/options that are already defined in PHP code ([example](https://github.com/composer/composer/blob/master/src/Composer/Command/UpdateCommand.php#L29)), without writing completions for them in whatever shell you're using. The package currently only has a hook for using in BASH shells, which I agree is a bit limiting and could be improved, but it would be straight forward to add a hook to use with another shell.
I don't think having two different kinds of scalar type hint will really be a good idea. We should do it one way and do it right, not allow several ways because nobody agrees.
"Python", "it's a breath of fresh air." &lt;-- No
What about using try...catch? It's more elegant than the error control operator "@", since it gives you the opportunity to react to the error/exception. However, error_reporting(0); should disable all errors and warnings, I'd suspect something is amiss....
Needle, then haystack.
ereg != mb_ereg
Honestly, I take what Rasmus says as a comprehensive list of dumb shit. I pretty much universally disagree with what he says and wants for PHP. I think if there's anything holding back PHP it's Rasmus and his voting block. As for "feel". That's something I really think can and should change. The "feel" can evolve with time and there's nothing wrong with that. Would you rather use `array_search($users, 'jeff')` or `$array.search('jeff')`? Pretty much an arbitrary choice, but the second is nicer largely because it's obvious what's being done. In fact my first version wouldn't work, because the needle and haystack are round the wrong way. This was not a "trick" on my part. I genuinely fucked it up and had to google the correct usage. I've been doing PHP since 3-point-something. Keeping a "feel" is a lovely abstract notion and all, but if the feel is fucking stupid, why do so? There are a large number of obstructionists in PHP using "backward compatibility" as a club to prevent any improvement in the language, and using some arbitrary definition of "PHPness" to prevent anything that they can't point at BC breaks as a valid issue in. Wanting the tools we use to improve doesn't necessarily mean we should have to jump to other tools.
Two points: [1] when your ideal changes to PHP make it feel identical to GO or PERL or PYTHON or whatever, and [2] these changes will almost certainly never happen (Rasmus), isn't it time to at least take a look at another tool?
&gt; I was unaware PHP 5 removed type juggling. Are you aware that PHP's userland type hinting does not type juggle at all? Because your proposal and your responses here seem to indicate that you either don't know how PHP 5's type hinting works, or you know how it works and want to ignore it because you want it to work a different way than it does now. This is how it currently works: &lt;?php function bar(array $bar) {} $foo = 1; print_r((array) $foo); // Array( [0] =&gt; 1 ) bar($foo); // E_RECOVERABLE_ERROR $foo = 1.5; print_r((array) $foo); // Array( [0] =&gt; 1.5 ) bar($foo); // E_RECOVERABLE_ERROR $foo = 999999999999999999999999999999999999; print_r((array) $foo); // Array( [0] =&gt; 1.0E+36 ) bar($foo); // E_RECOVERABLE_ERROR $foo = true; print_r((array) $foo); // Array( [0] =&gt; 1 ) bar($foo); // E_RECOVERABLE_ERROR $foo = 'bar'; print_r((array) $foo); // Array( [0] =&gt; 'bar' ) bar($foo); // E_RECOVERABLE_ERROR $foo = new stdClass; print_r((array) $foo); // Array( ) bar($foo); // E_RECOVERABLE_ERROR Scalar type hinting should follow the exact same pattern. This RFC is, at best, a non-starter until it does.
&gt; If we can diverge from zend_parse_parameters() by making the int type hint more strict (fatal on passing 12.5 to an int type hinting param because of loss of data, instead of truncation), then I think we can also diverge from it by making '123abc' throw a fatal for both int and float type hints. When it is casted, does that not also constitute a loss of data ('123abc' -&gt; '123')? A notice defeats the purpose, and is a outlier in that table of accepted values. It needs to be a fatal. ~~Yeah, I'm starting to agree on this point. I'm going to look into implementing it.~~ EDIT: RFC now handles this strictly. '123abc' is not a valid integer value. &gt;I still think the whole thing is far too complicated though. For example, the 'bool' column accepts nearly everything under the sun. How exactly is this useful? Bools are a bit of a mess. We could allow just `TRUE` and `FALSE`, but supporting the integer values 0 and 1 would also make sense. If we do that, we need to support floats and ints too. Since StdClass's behaviour is weird, we might as well just make anything truthy cast to true and anything falsey cast to false.
&gt; Are you aware that PHP's userland type hinting does not type juggle at all? I am well aware, yes. &gt; Scalar type hinting should follow the exact same pattern. Scalars are fundamentally different from the other types. PHP doesn't really juggle the non-scalar types, so it makes sense their type hints are strict. On the other hand, scalar juggling is routine and expected, so making their type hints also juggle would make sense (and be consistent with what internal functions do here).
&gt; Strict hinting isn't the PHP way Yes, it is not compatible with the *old* PHP way (think PHP4). &gt; Anyway, the RFC as proposed is strict with a few exceptions (bool, "123a"). Please don't take this personally, but the fact that you are defending `"123a" == 123` suggests either you have no formal CS education at all and/or no knowledge of CS fundamentals. This "feature" is *atrocious*. It is laughably stupid. I wouldn't hire the author of it as an unpaid intern. It has absolutely no defendable qualities. Even non-programmers would never consider "123a" to be the same as 123. &gt; It would make PHP's userland functions diverge further from internal functions Why would they be related at all? The whole point of a high level language is to abstract away the low level implementation details. &gt; Do they? An awful lot of PHP developers don't participate in the "community". Obviously this is all anectodal, but whenever this has been discussed, almost everyone agreed that strict is the way to go. Those who don't participate, as you say, should voice their opinion if they are so against strict hints.
Wow, thanks for that insightful, detailed and definitely-not-anecdotal post.
Because half of internals has historically been against stricter type-hinting. This solution seems to please them (from the first reactions on internals), and that's a great thing. All previous RFCs on that topic had been rejected. So if we want them, maybe that's the only way that we can get them. I agree with you though, but I'd rather have that than have to wait for another 10 years. Also, have a look at this **[amazing article from Nikita](https://nikic.github.io/2012/03/06/Scalar-type-hinting-is-harder-than-you-think.html)** which explains all the problems related to adding scalar type-hinting in PHP. His take about "strict type-hinting": &gt; I think it is evident that this is not an option. One of PHP’s greatest strengths is being a weakly typed language and this proposal would turn it into a strictly typed one. This goes against the PHP philosophy and also differs from how pretty much everything else works in PHP.
Thank you! Sorry that's not a question :)
That would be awesome (and much easier to install) as a Oh My Zsh plugin: https://github.com/robbyrussell/oh-my-zsh There's already a `composer` plugin by the way, but it doesn't autocomplete packages IIRC (just commands and options).
And to be clear, strings are the other way around.
I agree, I'd usually be in favour of EventBrite, but this project necessitates it to be in-house.
don't use the the error control operator. First, try to fix the error (by using [preg_replace_callback](http://php.net/preg_replace_callback) instead of the /e-modifier, like the error message even says) And add a custom error handler with [set_error_handler](http://php.net/set_error_handler) instead of suppress them. Error messages are there for a reason. Just because you don't want any user see them doesn't mean there is something for you to look after
You have to realize that PHP always has a horde of "Fuck PHP I hate it" types in the subreddit, its difficult to differentiate between those, trolls, and genuine questions. For example, your question has been answered many times. PHP is ubiquitous, that's the main reason. Cheap low end no configuration hosts, an immense amount of open source software (Joomla, Drupal, Wordpress etc.), plenty of jobs. Any language is going to have its issues IMO, and if our main complaint is haystack / needle and needle / haystack, how bad do we really have it? Thats a classic /r/firstworldproblem for programmers. I'm not *against* learning other languages, I just tend to hate the troll brigade that answers every PHP question with "derp don't use PHP". As an example of other programming languages having issues and breaking backwards compatibility, you need look no further than python, aka the language that for most PHP haters can do no wrong. Python 2 vs Python 3. Why? Its not because python is a bad language. Its because as languages become more popular it becomes harder to make this type of change. I wouldn't even know about this if it wasn't at least popular enough for people to be pissed about it. Its all like the linux folks who answer every windows question with "Don't use windows!" I use linux for some things and windows for others depending on what I need. I don't try to shoehorn everything into one or the other because they tend to be very bad at different things respectively.
See my previous points, but this only looks at one piece of the puzzle.
Python ended up in the same issue and broke backwards compatibility. I wonder if when that happened you were making this argument in favor of moving away from python.
I don't think so. `(int)NULL`, `(float)NULL`, `(string)NULL` and `(bool)NULL` all give you meaningful, nearly equivalent and useful values, but you cannot cast a null to an array or an object. That being said, I might change the behaviour for nulls. 
Really not sure what the confusion is about (other comments to this post). One is declaring 'this must be an int' - we say type 'hint', but it's really a 'demand'. The other says "change the type of the incoming value to an int". Now... what would happen if it couldn't be changed to an int? Null? 0? PHP's current casting behavior would kick in, although it might not be apparent to everyone at first blush, but... the () are pretty clear PHP syntax to indicate casting (and active change) vs just 'int' which would be a runtime check. (and possibly a compiler-type check at some point, I'd guess). But it's not going to be all that useful (other than a documentation-level thing) at a float/int/string level unless we can actually type the values themselves directly.
The thing is I, and evidently tons of people on the comments of that blog post, would rather have no scalar hinting at all than this half-assed RFC.
I'd rename it to HPP.
&gt; hon ended up in the same issue and broke backwards compatibility. Python's BC break had nothing to do with "fixing" the language. &gt; I wonder if when that happened you were making this argument in favor of moving away from python. No. When the Py3 break happened, I advocated staying with Py2 because nobody asked for the Py3 changes and they weren't that important. It seems like the core team agrees since they *still* maintain and update Py2 after all these years. 
Eh, don't thank me, thank Anthony (ircmaxell). He did the bulk of the work, I'm just trying to get this through.
I actually didn't know this, thanks for the info.
I didn't know that the Composer console was built on the Symfony component, thanks for setting me straight.
There's an interesting tech talk with the people who (of all things) run PornHub, and pretty much none of what they talk about is porn. It's all about how they make such a high volume site scale effectively while using a framework (Symfony - not known for being lightweight) to run it. The conclusion is basically "varnish all the things". It's well worth looking at for this. I also have to say, much as I like Laravel, and I really do, there's probably a case for "bits" of this to be broken back out into non-framework components that are much lighter weight. 
Official support for annotations. There's nothing I can't stand more in a codebase than annotations in comments. Comments should never modify the runtime behavior of code!
Yeah, the first one is consistent with non-scalar type hinting syntax, and the second one is consistent with type casting syntax. If you're aware of PHP's regular type casting why would it be confusing? 
&gt;Python's BC break had nothing to do with "fixing" the language. The point was there were improvements that were made to the language that broke BC. Splitting hairs over why the changes were made is pointless. Its obvious the creator felt that the changes were needed, and that's the only argument I need to make. &gt;No. When the Py3 break happened, I advocated staying with Py2 because nobody asked for the Py3 changes and they weren't that important. So when the core team no longer maintains Py2, are you going to move to a different language because you didn't like the changes made to Py3? Or do we just see Py2 as being forever in limbo with no new features etc. It also appears that you have a benevolent dictator more than willing to fork the community, which from your point of view seems like it should be troubling since you argue against breaking BC.
I'm against `null` being valid int/float/string/bool (it's an error waiting to happen), but how is `null` not equivalent to "empty array", just like "empty string"?
I don't think so. The only meaningful and equivalent typecast of NULL is (string)NULL, because an empty string really is equivalent to NULL conceptually. 0, 0.0, and false are nowhere near NULL equivalents, and PHP's behavior in these cases is a major blunder. Personally, I'd prefer incompatible typecasts just be reported as such with errors, but... BC.
Yes, but "Nikita's blog" is not representative sampling, nor is "anywhere".
The problem is that PHP's current definitions of "truthy" and "falsey" are pretty much shit.
In what way?
&gt; So when the core team no longer maintains Py2, are you going to move to a different language because you didn't like the changes made to Py3? That's just the thing. I *will* move to Py3. Because I was never *against* the changes in Py3 in the first place, I simply saw *no need* to move to it, *especially* since Py2 was going to be kept active for the foreseeable future. &gt; It also appears that you have a benevolent dictator more than willing to fork the community, which from your point of view seems like it should be troubling since you argue against breaking BC. I'm actually not against breaking BC in this particular case because if the *entire stdlib* breaks BC, why would anyone stay with PHP? At the very least, it does nothing better than anything else. Honestly? If it were up to me, I would design (with collaboration from people with *proper* CS backgrounds) a new, cleaner stdlib and deprecate - ***but not remove*** - the old one. This way, all the PHP5 code out there would still work and people can migrate in their own pace over the years. I would only drop the old libs in PHP7, which would be many, many years away.
&gt; NULL is equivalent to an empty array, but it's not desirable to allow it for params marked as being for arrays, unless they're nullable. Why? It's an empty value, just like an empty string or an int value of `0`. It's very easy to cast, and even follows the PHP way.
Well, for starters, the non-scalar typehints don't cast, so they must reject anything not fitting the type specified.
That would be ideal, except that "right" is not clear-cut. I would only support non-strict scalar typehinting if the implicit casting rules used were "fixed" first, because PHP's current casting rules have a lot of WTFs.
Then `(array) null === []` shouldn't be valid?
I'm talking about typehints, not PHP's casting operator. The two do not *necessarily* need to align.
/r/php is a decent enough sampling to get a feel for it. Everytime it comes up (which is practically once or twice a month it seems) the opinions are overwhelmingly in favor of strict typehinting over this implementation. And, I actually would prefer this implementation (with some tweaks to casting rules), so I'm not biased here. Just pointing out the obvious.
Sorry, I fail to see how is that is different from other types. I also fail to see how passing `true` as a `int` parameter and it being transformed into `1` is a-ok. Maybe I don't get it. Maybe the approach proposed is inconsistent.
I have no doubt that some ticketing companies are expensive, but in case it actually matters to the OP, EventBrite only charges 2.5% + 99c for handling the sale. To that you need to add Paypal or payment gateway costs, or EventBrite themselves will handle the payments, too, for an additional 3%. So unless the tickets are super cheap then EventBrite isn't anywhere near 20% (assuming the tickets aren't free as in that case, EventBrite charges nothing). We were looking to do our own coding for this, too, but went with EventBrite instead. Seeing as we were going to have to pay Paypal either way, their take is only a few dollars and well worth the additional stuff that comes with them: eg. metrics and attendee emailing but way more importantly, a mobile app that lets you quickly check the attendees in on the day!
I don't really see how using brackets make it any easier to avoid escaping. All the following are valid patterns. If I had used the same bracket as the delimiter, I would have had to escape the closing bracket in the pattern. var_dump(preg_match('/[)]/', ')')); var_dump(preg_match('/]/', ']')); var_dump(preg_match('/}/', '}')); In my opinion, the brackets just make it much more complex to escape the pattern properly. The delimiter parser is not very context aware. Better idea in general is just to use some unused character as the delimiters in hard coded regular expressions (I default to '/' but switch to '#' when required). If user input needs to be inserted into the regular expression, then the proper approach is to use 'preg_quote()' function.
Mostly due to the implicit type-casting WTFs. The direct boolean conversions are okay for the most part (minus all objects being truthy, instead of discriminating based on contained data like what's done for arrays, but I'll let that one slide). A falsey value cast to any other type should remain falsey. And ditto for truthy values. Unfortunately, PHP's badly broken type conversion rules screw this up royally: php &gt; echo @array() ? "truthy\n" : "falsey\n"; falsey php &gt; echo @(int)array() ? "truthy\n" : "falsey\n"; falsey php &gt; echo @(float)array() ? "truthy\n" : "falsey\n"; falsey php &gt; echo @(string)array() ? "truthy\n" : "falsey\n"; truthy php &gt; echo @(object)array() ? "truthy\n" : "falsey\n"; truthy
&gt; A falsey value cast to any other type should remain falsey. And ditto for truthy values. Why? You can't do a lossless, meaningful conversion for all types, and certain types are deliberately always truthy because it's the most useful behaviour in conditionals. This isn't even PHP-specific; in JavaScript and Python, for example, objects are truthy.
That's good and bad news. Good in that (hopefully) these differences are moving towards saner implicit type-casting rules, but bad in that without updating the PHP internal rules to match, we're making the language *that much more* inconsistent. Maybe this RFC ought to take a back seat to another one aimed at fixing the broken type-casting internally first...
I think scalar type hinting can be implemented using the idea of boxing. [PHPScalars](https://github.com/joefallon/phpscalars) is a great library for just this purpose. Additionally, no changes to the language are needed. Sweet!
&gt; Why? Because, logic, that's why. A falsey value should not gain truthiness just by being type-casted. That's *insane*. &gt; You can't do a lossless, meaningful conversion for all types 100% agreed, but there's nothing that says all types have to be convertable to all other types, either. If a conversion can't happen without fundamental changing of the meaning of the value (esp. if it involves crossing the truthy/falsey boundary), then it should throw an error. &gt; and certain types are deliberately always truthy because it's the most useful behaviour in conditionals. This isn't even PHP-specific; in JavaScript and Python, for example, objects are truthy. That's completely fine, as long as you're *consistent* in applying that concept. JavaScript is consistent. Objects *and* arrays are always truthy. In PHP and Python, objects are always truthy, but arrays can vary. That sucks.
I see all these comments saying "Why not just switch languages?" and it makes me think of a house. . You love your house, but you wish you had a nicer master bathroom or maybe a media room. You have the option to buy a new house that has all these things you want, but you love your house. You love your community and the thought of moving away just doesn't seem like a realistic option. This is the way most of us PHP developers feel. We love the language. We know it inside and out. Yeah there are certain aspects about it that we wish were different, but we keep on using our favorite language until these changes are made or until someone in the community offers us a solution. For me the one thing to add would be primitive type hinting. EDIT: Spelling
You make an excellent point with your examples. However, while you are correct that `preg_quote()` should be used to quote input, the article refers to injecting patterns rather than data.
Have you tried echo-ing out your SQL variable to see exactly what your built SQL query is?
Not quite, here's an example. Say I have the following array: array ( [0] =&gt; array ( 'id' =&gt; 312, 'name' =&gt; John ), [1] =&gt; array ( 'id' =&gt; 154, 'name' =&gt; Bob ) ) I want to be able to quickly make it like this (and by quickly, I mean one line, one function call.) array ( [312] =&gt; array ( 'id' =&gt; 312, 'name' =&gt; John ), [154] =&gt; array ( 'id' =&gt; 154, 'name' =&gt; Bob ) ) 
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to [##php on Freenode IRC](http://webchat.freenode.net/?channels=%23php).
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to [##php on Freenode IRC](http://webchat.freenode.net/?channels=%23php).
I like the idea of casting any possible input, and maybe issuing an E_WARNING on significant data loss. I've always felt that strict type hints don't really make sense in a language like PHP, and more of an auto-casting approach feels more natural. As before, it's always the responsibility of the caller to provide appropriate inputs. This feature would effectively be a nicer-syntax equivalent to doing something like "$foo = (int) $foo" for each of the parameters. It gives the function the confidence of knowing what types it's dealing with, while giving the caller the accommodations one expects in a loosely-typed language.
Yes. The query doesn't like php variable in FROM . I tried: $f="201406"; $a_temp="zzz_reservationservicedocumentgenerateddocs_"; echo $a_temp.=$f; And i put {$a_temp} in SQL {$a_temp} and working... but it's not what i want... 
&gt; Currently if I specify a type hint, it is strictly applied. PHP does not follow its casting rules in this situation, and nor should it. Well... that's not entirely true in some sense. While we don't *cast*, sure, typehints allow derived classes.
So now I have to do `foo(new Integer(3), new String("foo"), new Float(7.5));`? Ew.
A derived class *is* the same type as its parent.
I understand that many jump at once on the architect train, as that's where you usually start, but if you already have a system running what holds you from actually doing some benchmarks, monitorings and profiling to actually find out where the bottleneck is? PHP/FPM, Nginx and MySQL/InnoDB all are proofed to be working well under high load if used correctly. Also they can scale either vertically or horizontally.
Sorry. No it does not support CLI invocation.
I don't know of a better solution at the moment.
&gt; When you cast a scalar type to a non-scalar type, and vice-versa, you lose information. This often includes the truthiness or falsiness. Losing information during type conversion is fine (often necessary); losing truthiness/falsiness is *not* fine, as it's fundamentally changing the meaning of the value (e.g. `(string)[] === 'Array'`, in which all information is lost, and the truthiness has also flip-flopped, so the new value is completely arbitrary and in no way related to the previous one). Type conversion between scalar/non-scalar doesn't really even make sense conceptually, and should almost always throw an error, in my opinion. The exception to this rule would be non-scalar -&gt; string, which (frustratingly), PHP gets wrong in the case of arrays, but right in the case of objects. Going from scalar -&gt; non-scalar isn't problematic on the surface, until you consider the edge-case consequences (e.g. `(array)0`, `(object)false`, and so on). &gt; Well, if we do that, then you can't have truthiness/falsiness as you'd have to eliminate casting too bool. Loss of information is fine. But fundamentally changing the meaning of the value is not. For example, `(bool)0` doesn't change the meaning of the value, as both `0` and `false` are falsey (it also happens to be one of the cases where you don't even lose information, since the reverse conversion is the reciprocal; e.g. `(int)(bool)0 === 0`). What I'm talking about are things like `(string)[] === 'Array'`, where you've completely lost the meaning of the original value. &gt; much like how empty strings are false and non-empty strings are true. Well, if by "empty strings" you mean literal `''`, then you're wrong, as `(bool)'0' === false`. However, if you're referring to "empty strings" as defined by whatever `empty()` considers "empty", then that's a pretty big mess that even veteran PHP devs can't remember the ins and outs of often times, and we'll have to agree to disagree.
Object wrapped literals, ala JavaScript. If a variable containing a string, integer, float or array is addressed as if it were an object, the runtime automatically wraps it in an object for that type (String, Integer, Float, Array). Those object contain OOP versions of all the functions we currently use for those types. This creates a parity with the functional versions of the Mysqli and DateTime functions. $foo = 'my text'; echo $foo-&gt;ucwords(); // My Text
Ability to write desktop apps or server apps with it. Multithreading. Objects with key value pairs should be interchangable with arrays. Callbacks for operations. Hmm, I should be a node developer...
&gt; Hit the database as few times as possible I'd even go so far as to say that mysql writes should be deferred to a message queue. Use a memory store to keep track of available seats (OP is using memcache but I'd probably go redis).
Varnish is awesome for consumption sites like portals, blogs and tube sites where the majority of traffic isn't personalized, but it's not helpful for the kind of site OP is building. You can't cache a checkout.
A consistent needle/haystack order.
Despite what seem people say here, there is no "perfect" language. Nothing is one size fits all, but that doesn't stop me from wishing more languages would adapt themselves to include features from other languages. I use both PHP and C# at work, and both languages have things I'd love to see incorporated into the other. I'm dying for C# style properties with their own getters/setters, rather than being forced to rely on the magic __get and __set functions. I thought we might get them, but then the RFC got voted down. A proper string and array class would be nice. LINQ would be nice.
Nice, completes packages! That's the feature I want.
 for($get_months=date("Ym");$get_months&gt;=201401;$get_months--) {} before this i tried with array foreach($getmonts as $getmonth ){} In second case, $getmonth contains strings - for example: 201406
Why? It's interesting and informative.
String methods: haystack, then needle. Array methods: needle, then haystack. This has to do with PHP being a thing layer over C, and how those C methods are prototyped.
What is the error you're getting?
I'm not sure it's possible to have method overloading in a weakly typed language. We would need to add scalar type hinting before we could add overloading, but I'm all for both! [Guards](http://en.wikipedia.org/wiki/Guard_\(computer_science\)) would give the same benefits of method overloading while getting around the problems associated with weak types. Less has a [clean guard system](http://lesscss.org/features/#mixin-guards-feature) that could be adopted by PHP. Example: class MyClass { public function setNumber($number) when ($number &lt; 50) { } public function setNumber($number) when ($number &gt;= 50) { } public function setNumber($number) when (gettype($number) == "string") { } }
https://wiki.php.net/rfc/propertygetsetsyntax-v1.2 I am hugely disappointed at the internals for the bickering over this feature, and the nay voters.
Reminds me of HTML++, or Haskel++, or something.
+1 for a Composer PR.
Yes, that's basically it.
`()` are the best delimiters, as since they are asymmetric, you never need to escape them. Simple as that. And they logically represent the `0` group: (foo(bar)baz) matches "foobarbaz" as [ 0 =&gt; "foobarbaz" 1 =&gt; "bar" ] It's conceptually cleaner, and never requires escaping you wouldn't already need need anyway. 
[Generators are in PHP &gt;= 5.5.0:](http://php.net/manual/en/language.generators.overview.php) &lt;?php function array_indexby($data = [], $col = ''){ foreach($data as $row){ yield $row[$col] =&gt; $row; } } //-------------------------------------------- $people = [ ['id'=&gt;143,'name'=&gt;'bob', 'age'=&gt; 37], ['id'=&gt;144,'name'=&gt;'tina', 'age'=&gt; 8], ['id'=&gt;145,'name'=&gt;'joe', 'age'=&gt; 22], ['id'=&gt;146,'name'=&gt;'sarah', 'age'=&gt; 52], ]; foreach(array_indexby($people, 'id') as $id =&gt; $person){ echo $id . ': ' . $person['name'] . "\n"; } Output: 143: bob 144: tina 145: joe 146: sarah 
Oh I see, the complete opposite of my suggestion. Yeah, would be great as a native function.
that's the entire point of this RFC...
&gt; If I type hint a parameter with int, I want an int That ignores the fact that in PHP `"12"` **is** an int. Consider: 12 + 1 // int(13) "12" + 1 // int(13) So the casting rules, where there is a **lossless** cast, makes sense given how PHP treats types. Given that there is literally no way for a type to be declared, all types are dynamic. And that's the point. That's what this RFC realizes. Since there's no way to declare proporties or variables as `int`, directly, having hints be purely strict would result in people simply calling everything with an explicit cast: `foo((int) $bar)`, which ignores data loss entirely (which is a bad thing). Especially since `PHP_INT_MAX+1` is a float. &gt; I have told it the type I want, and that is what I should get, or else an error. And with the current RFC, that's what you will always get. function foo(int $a) { is_int($a); // **always** true } The point being that what goes into the function call will be cast to an integer **if it can be done so losslessly**. That's the fundamental theorm here...
This is beautiful.
I've found that using the hash symbol (#) works well.
Makes it more difficult to use in a CI environment IMHO.
I found a plugin for Symfony `console` commands...forgot the name of it tho...
This is exactly correct and the same point riimu made [before](http://www.reddit.com/r/PHP/comments/2akpdz/ideal_regex_delimiters/ciw8fu6). This finding actually invalidates the article's claim. I wish riimu could proof read my articles before publication :) The crux of the problem is that the list of metacharacters changes within a character class - suddenly all braces are no longer special. Even the closing square brace is not treated as a metacharacter (and does not require escaping) if it's the first character in the set, i.e. `[]]` matches a literal *]*. Therefore there is no magic bullet to this problem after all. Square brackets are probably the best bet now since many people are not aware you can get away without escaping square brackets within a character class.
read books, write code, set a goal, practise a lot. same as sport 
Precedence for the ternary operator. So I can do: $foo ? $bar : $baz ? 1 : 2 Instead of: $foo ? $bar : ($baz ? 1 : 2) Because the first actually means: ($foo ? $bar : $baz) ? 1 : 2 Which is not very useful. I would also like the `.` operator to have a lower precedence than mathematical operators. echo 'a' . 1 + 2 . 'b' Will not output `a3b` as you would expect but rather `2b`.
one word, i want 'consistency' and move every core function to appropriate namespace
&gt; The explicit cast operator does exactly what it should IMO. So, you have no problem with `(string)[1,2,3] === 'Array'` or `(string)[] === 'Array'`? Because I can't stand that blunder, personally. I also very much dislike that `(string)true === '1'` while `(string)false === ''` (as opposed to `'0'`). And `(int)(array)0 === 1` is mildly annoying, as well.
I hear you. Does any other language offer exactly that, as part of their standard library?
I think the approach here is pragmatic and valuable considering PHP's type system, but I think what causes confusion/backlash is that we call this a type hint. This seems more like a "cast hint" or "cast directive". Its main job is giving you pre-casted arguments rather than making demands on input type. Downside is it means another obscure list of rules, but they seem pretty intuitive.
This solution will not handle the large input. You'll need to basically implement an arbitrary precision integer system and hand optimize the conversion process to get through it in a reasonable amount of time. Here's [my solution](https://code.google.com/p/mrclay/source/browse/trunk/php/codejams/2010_practice/alien_numbers/) which does the large set in 2s. Read after you do yours :)
What I'm wondering is why I was able to pick up AngularJS easily but am finding a lot of other frameworks Matterhorn-steep in learning curve.
I've never really found a need to inject arbitrary regex bits into another regex pattern, personally, but wouldn't something like this (untested.. mobile) solve the problem? abstract class Regex { public static function compile($pattern, $modifiers = null) { return sprintf( '#%s#%s', addcslashes($pattern, '#'), $modifiers ); } }
&gt; it makes me think of a house Yes! It makes me think of a house too! Quoted from somewhere else: If PHP were a house, the master bedroom would have 4 extra doors leading off it. One would be labeled "womenstoilet" and have a regular porcelain potty, the second would be labeled "washroom_mens" and just have a urinal ($DEITY help you if you're a man and need to go #2, because womenstoilet($male) is not permitted). The third would be "bathroom" and would contain a bath. Which is filled with kitty litter, because someone remembered that the family living there might have a cat which needs a toilet too. This is despite there being a perfectly good litter box in the back hallway, which the person who filled the bathtub was not aware of. The fourth door is a tiny unlabeled hatchway hidden behind a bookcase. When you open it there's a small shrine dedicated to the builders of the house, set in the middle of an otherwise unusable 1000sq.ft. room.
The Angular documentation has improved a lot recently, so that helps. The only other javascript framework I've used is backbone.js, which is stretching the term "framework" a bit. What else have you tried to learn?
This approach already comes pretty close: $person = (object)[ 'name' =&gt; 'Joe', 'age' =&gt; 21, ];
Not sure if you caught this, but the inventor of Laravel responded to your question [here.](http://www.reddit.com/r/PHP/comments/2ai1ex/can_i_resell_an_app_built_on_laravel/civyoka)
&gt; how to keep up with one's project ecosystem no, he's not
I know that this RFC is labelled scalar type hinting but it still feels incomplete. To be consistent with the 'types' of php variables, should there not also be an 'object' type hint to define that an instance of any class is required. I understand why the 'resource' hint was removed but I believe that an 'object' type hint would have valid use cases.
Could you explain, Why are you using an old version of Zend? -or- Why is this not composer compatible?
I have used this solution for 2 years or more This app is worked with php 5.x (Earlier my wp site was spammed regularly, my host admin didn't like wp sites on his server.) I can rebuild in ZF2. I've done it in Symfony 2: http://blogbook.hu/symblog/web/blogwpshow/2885 But these are not completed. Honestly I would like to earn with these projects but I realized that it is only interedted with some developer.
&gt; NodeJS got it right - they have npm and that's it, and it works great. NodeJS is a Javascript library. You cannot compare that with a language such as PHP. Now, if we compare it to the JS world, it has npm, bower, and many more package managers.
It would be better if you would analyze what are your needs for your blog then make them in the framework you're comfortable with. As much as I hate *I'm sorry for the language* the clusterfuck of Wordpress. It's so dumb'd down that we just don't necessary take to note the bloated effect of the app.
Had no idea this existed. Thanks.
This is *way* more interesting and useful than I first thought... My first thought is this should integrated into some kind of parameter validation for routing or input cleaning on a web framework.. 
&gt; slumming it in Ubuntu. Fuck you.
That's not "logic", that's just "a reason". It's not logical to be inconsistent, just because the underlying platform is inconsistent.
Uhm, like it's not easy to use 'em on win or any other nix..
What about those characters? Remove them? Replace them? With what?
Adding composer as a central feature for Wordpress (not in each individual plugin, like some people do, creating clashes between plugins) is an awsome way to develop custom plugins for specific client needs. Been doing that for several years now, and composer slips in remarkably easily.
Mac + PHP? Mac has nothing to do with it.
Now that's funny. Great way to start off a Monday morning.
Your “equation” says using Mac somehow adds “ghetto types” to PHP. Mac has nothing to do with it.
It's a PECL package, why would someone call it Mac+PHP when Mac is nothing to do here?
Really this is more like: pecl install SPL_Types You didn't really give any useful information on the page, and the steps are otherwise useless for anyone running PHP on Mac already. I expected a more thorough run down on what SPL_Types are, and more information on subclassing these (as you yourself said they were useless unless you subclass them). Also, the [original post is here](http://www.reddit.com/r/PHP/comments/2anovz/mac_php_ghetto_types/) if anyone was interested. **Edit:** Mate, if you don't like my feedback, don't post it in a public forum. The post quality is quite low, and frankly, this is borderline blog-spam.
Note that in the Ubuntu slum the SPLTypes are installed by default `^_^`
Thanks! If you know anyone still in the area, please pass it along.
I'm confused. Notwithstanding that this is a mostly contentless blog post that seems to merely serve as an ad for your upcoming book, you close with: &gt; I found all this out because I’m busy writing a book about it. What exactly were you writing before you found out about SPL_Types, which is at the very basic level of typed PHP?
Named parameters.
You base your opinion of the post on the premise that "steps are otherwise useless for anyone running PHP on Mac already". That discounts everybody running Vagrant and/or MAMP. Those folks may find it useful to know how to get PHP running. And then to get SPL Types running. Because even when using MAMP, installing PECL libraries can be a pain. It's not expert-level stuff. Some people (like you) know how to do it already, and that's great. It's not written for you. :)
I have updated the post to include the following disclaimer: &gt; This is an intentionally short post aimed solely at teaching those (who do not know) how to install SPL Types in OSX. &gt; &gt; If you already know how to run PHP (via Homebrew) and further know how to install PECL extensions then this post is not meant for you. If you don’t want to hear about related work in the field, then don’t read all the way to the end.
&gt; Do you even have a CS degree ?? Yes I do. &gt; what makes you think that the current devs(internal) dont have a CS degree!! You can just ask them. &gt; Oh, sweet.. after 10-15 years. So? PHP tries *very hard* not the break BC, ever. This is exactly inline with the policies of internals. I'm not sure what you are objecting to? &gt; Then I can safely assume that you are a procedural php programmer. On the contrary, I mostly do OO with Python where it is *miles* better than PHP. *Everything* in Python is an object. Even functions. Are you sure you know what Python is? &gt; And for the record, The only thing good about python is it does have a big library. lol. 
Most everyone calls what OP is saying "assets", to most everyone a dependency is a software dependency.
&gt; It is. If you do 1 + "123sfdsf" you get 124. But it also will raise a notice that data-loss occurred (which is consistent with internal functions). Again, this is *atrocious*. Even CS 101 students wouldn't find this acceptable. *"Let's fuck it up here, because it's already fucked up internally"* is not a justification. &gt; * Any primitive is a valid boolean, but not arrays/stdClass because fuck you. &gt; Not anymore. Because this stuff is hard, and there are lots of tradeoffs. It's easy to Monday morning quarterback it, but it's a completely different thing to constructively discuss tradeoffs... That's good to hear, hopefully that discussion results in a sane implementation. &gt; That's not what's happening. Null can be **cast** to primitives. So? It can be cast to array/stdclass as well: php &gt; var_dump((array)null); array(0) { } php &gt; var_dump((object)null); object(stdClass)#1 (0) { } &gt; Passing "12sfdsf" isn't fine, but there's already precedent for it (zend_parse_parameters internally will raise a notice). But there's still open discussion around that (should that be fine, or should that be an E_RECOVERABLE_ERROR (or perhaps a new E_INVALID_CAST error). And yet, the usual people (hello zeev!) are *already* defending "12sdfsf" as acceptable. Those who think this is acceptable should not touch ***any code***, not even as an unpaid underfed intern... &gt; And yes, these shouldn't be errors but exceptions, but until something like Engine Exceptions[1] gets accepted, not going to happen... I agree, hopefully something like that gets accepted eventually, but PHP 6 is still years away so it is of no practical use to anyone.
&gt; Again, this is atrocious. Even CS 101 students wouldn't find this acceptable. "Let's fuck it up here, because it's already fucked up internally" is not a justification. In theory, theory and practice are identical. In practice, they are quite different. Let's face it: If you're looking for a robust type system, PHP is the wrong place to look. It isn't, nor will it ever be. Instead, it's a useful type system. The abstractions that are present, while not perfect and leaky, are incredibly useful and powerful. So let's be realistic for a minute. If you care about type sanity, you should't be using PHP in the first place. Not because it make it hard, but because it makes it impossible. Sure, we can pretend to ignore the edges, and say "Well, if I pass an int, it will be an int!". And 95% of the time you may be fine. But 5% of the time it won't remain an int (thanks to mutable types). If we don't try to ignore that, but instead embrace that, we get to the point that `"12"` **is** `12`. They are 2 representations of the same value, since `(int) (string) 12 === 12`... If you get to that point, and accept that **lossless** casting is not only acceptable, but a good thing. As far as `"123sfdsf"` being `123`, that was there simply for consistency (erring on the side of working). There's a lot to be said for "best effort" in these cases where if there's a reasonable answer that keeps things working use it instead of borking everywhere. Not that I said *was*, because it's not there anymore. &gt; So? It can be cast to array/stdclass as well: That's a point that you seem to be missing (and indeed a lot are missing): there's a big difference between an implicit cast and an explicit cast. Implicit casts happen when you pass variables to internal functions expecting a particular type (or do certain expressions). Explicit casts are `(array)`, etc. **Implicitly** null is not allowed for complex types, but it is allowed for scalars. [Zend_parse_parameters](http://lxr.php.net/xref/PHP_TRUNK/Zend/zend_API.c#305). Example: var_dump(array_sum(null)); // Warning, expected array, null given var_dump(abs(null)); // perfectly valid. **Explicit** will never fail. That's the point of an explicit cast. The difference between the two is the intent. When you write `(array) $foo`, you're explicitly telling the language that you want the result to be an array, so make it one. But when you pass a variable implicitly to something wanting an array, it's not clear if that was a mistake or if you wanted to convert it. Which is why implicitly it fails. But explicitly it works fine. &gt; And yet, the usual people are already defending "12sdfsf" as acceptable. So? &gt; Those who think this is acceptable should not touch any code, not even as an unpaid underfed intern... And many of those that think it is acceptable are also significant authors and maintainers of the engine behind PHP as it sits today. And while you could argue that explains some of its inconsistencies and bad parts, it also make it **incredibly useful** and powerful. If you're looking for an academic language, go somewhere else. If you're looking for a useful one, that's the point...
Can anyone explain to me why this "Ain't nobody got time for that" video is here promoting a unit testing framework? This is why tech has a diversity problem. The video basically makes a joke out of this woman because of her race / sex / socioeconomic status. EDIT: The video has been removed! Thank you Mr. Fallon!
[**@cowburn**](https://twitter.com/cowburn): &gt;[2014-07-14 13:15:51 UTC](https://twitter.com/cowburn/status/488673227775160322) &gt;Dear [#phpcommunity](https://twitter.com/search?q=%23phpcommunity), if we removed PHP 4 from the manual, would you mind? Lots? A little? ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/2aoaph%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
&gt; Let's face it: If you're looking for a robust type system, PHP is the wrong place to look. It isn't, nor will it ever be. Yes, I made my peace with PHPs retarded type system a long time ago. That doesn't stop me from *encouraging and advocating* a better one. What's wrong with wanting to improve PHP? &gt; That's a point that you seem to be missing (and indeed a lot are missing): there's a big difference between an implicit cast and an explicit cast. True. My mistake. &gt; And many of those that think it is acceptable are also significant authors and maintainers of the engine behind PHP as it sits today. And while **you could argue that explains some of its inconsistencies and bad parts**, (emphasis mine) It explains so, so much really. When I search for the code behind a wtf in PHP, it almost always turns out to be authored by the same few people (hello zeev!). &gt; it also make it incredibly useful and powerful No. There is nothing useful or powerful about `"123asdf" == 123`. None, not a single one. There is not a single non-PHP programmer in the world that would defend it. &gt; If you're looking for an academic language, go somewhere else. If you're looking for a useful one, that's the point... That's a strawman. There are many, many useful non-academic languages. Ruby, Python, .NET and Go (yes Go) are just a few examples of useful, powerful, well-designed and sane languages... The fact that PHP is retarded in many ways **should not** stop people from fixing it. Yet a lot of the internals seem to be stuck in the PHP4 days and **accepted defeat** that it will never get fixed. Some are even seem to be suffering from Stockholm Syndrome (hello again zeev!), thinking what they are defending is the *right* way... It seems like a CS 101 course for everyone with commit access would go a looong way to start fixing things. And that, is just sad...
Good god a horizontal scroll bar.
As someone who was just brought on to maintain a PHP4 project (in 2014 :/ ), I'd prefer a copy of the documentation with PHP4 annotations be available somewhere easily accessible if it were to be removed from the official manual. I can't count the number of fatal errors I've experienced in development from using functions that don't exist (memory_get_peak_usage, how I miss thee). The documentation helps to clarify when support was added, and what I can still count on in PHP4.
v4 manual should be archived somewhere. Even in 20 years, when we've reached version 5.30.0, someone will stumble across some old PHP 4 code still running something and have to deal with it..
I went back to `/` because sublime text switches into regexp syntax mode.
Do you have much experience with OROCRM? I'm starting a project soon based on it.
No. Definitely remove it from the main manual and have an archived version for PHP 4 only, like Java and other languages do.
People make a huge deal of it *because it's a problem*, not the other way around. There is no problem that will ever go away by ignoring it. "People making a big deal out of it" may *seem* like the root of the problem to you, but I'd be willing to bet that that's because you don't directly experience racism or sexism or discrimination except in the context of someone else making a big deal out of it. Maybe to you, discrimination is just a phenomenon of "other people complaining about discrimination." Have some compassion from the people who do experience it, listen to their stories and maybe your perspective will change. &gt;Soon as the diversity becomes a normal thing, it would be a problem. That simple Yeah, when it's not a problem anymore, it won't be a problem anymore. But you speak as if you think that is just going to happen magically. The video isn't satirical, it's an actual woman on an actual news broadcast. *To you* it seems like a casual joke, but that casual-ness just goes to show how deeply engrained sexism and racism are in this community. It's really easy to be blinded to it when you're not on the receiving end. Yes, things like this do serve to make women and minorities feel unwelcome. If we want to improve the diversity situation then we at least need to be sensitive to things like this. The author of the blog should remove it. EDIT: The video has been removed! Thank you Mr. Fallon!
Some problems you should work on: - Your SQL query is very long, and it makes it very difficult to read. - Your first CASE should be replaced by a LEFT JOIN to a separate table (where you have 1|AT, 2|VF and so on). - For your second CASE would probably be better having one customer table with a "corporate" boolean, then using LEFT JOIN to get relevant data. - Most importantly, you shouldn't put variables into queries, even if you're escaping them. Use parameterised queries, which are available in mysqli and PDO. - Your table names are ridiculous. - Why separate tables for each month? Unless you have millions of documents each month there is no need - just have a month or date field.
&gt; I still have to look it up every time though. Fucking use an IDE already. I'm tired of these pointless complaints. You don't need to memorize a single damn native function. You could say this same problem about every single function you don't use often enough.
It kinda bugs me that they are asking twitter for what they think rather than just looking at web traffic to gauge how many people are still using the documentation...
A more readable font in the UML wouldn't hurt either. Edit: thanks for updating it!
This is fantastic news, really glad it got accepted!
Looks great. Would love to see it implemented.
The video has been removed. There are some things in life that I just don't time for. One of them is waiting for tests to complete because the testing framework is super heavy and uses allot of reflection, injection, and eval that totally kills test performance. On the other hand, I always have time for testing. Unit testing and TDD are an amazing invention. I run my tests over and over again all through the day as I work. This is probably why I am so sensitive to their execution speed. The only reflection my unit test framework uses is to get a list of method names in the UnitTest subclasses. Everything else is iterating through arrays, etc. Very non-fancy PHP. Also, very fast PHP. Base overhead test execution speed is less than 0.01 millisec per test-case on PHP 5.3. Actually, I am not exactly sure as I can't measure that low. PHP 5.5 and HHVM run much faster giving a smaller overhead per test. Of course, once you start getting into the time-span between interrupts it's hard to get accurate measures. Mock/stub execution overhead includes one array insertion and one function call. So, that overhead is pretty much zero too. That's why I say my mocks are as fast as the stubs and don't require separate concepts nor separate objects. 
Awesome!
even better, no UML at all 
edit: disregard, I can't read. What do you mean an actual RFC?
Isn't it just the symfony plugin? That's what I use and it doesn't autocomplete the Symfony console.
Is that why we still answer questions with code like: $conn = mysql_connect(); ?
&gt; Pickle &gt; Pecl &gt; Pear [Hm](http://theonceandfuturecoffeeaddict.files.wordpress.com/2012/05/286380-that-really-rustled-my-jimmies.jpeg)
I do use an IDE (PHPStorm), however, I couldn't recite the order of the needle haystack without looking it up. Hence I still need to look it up every time if I need to know the order without using PHPStorm. 
&gt; if I need to know the order without using PHPStorm. Why would you need to know the order outside of your IDE? &gt; I couldn't recite the order of the needle haystack without looking it up I could list a thousand functions that you wouldn't know the arguments and their orders without looking them up.
Yes, you could. The point is that the ordering is used on a vast amount of array/string functions which I know the names of and the parameters they take, but stumble at the ordering. It's not often that I have to code outside of PHPStorm, but on the odd occasion I'm hacking something together in VIM, or supporting other developers who may not be using an IDE (their choice). I'm not advocating development without an IDE, because your right, since I have moved across to PHPStorm from sublime I have never looked back. I was merely saying that I cannot remember the order off of the top of my head, which is more my problem rather than PHP, so I am not attacking PHP. 
I think you might not be understanding how PHP is used. &gt; how can I create a php where I insert the following data From this question, it sounds like you need some kind of script that allows you to insert the information? I don't see how this will save you much time since you are basically typing the same information either way. Edit: After re-reading, are you saying you type the SAME information multiple times? If that's the case, then using a include on each page is what you need. http://php.net/manual/en/function.include.php This way, each page will contain the include and you only have to update the one file being included. 
Are these your videos? 
This is going to be great for using partial function application and currying. E.g.: $foo(1)(2)(3)
We can have nice things? Really? OMGWTFBBQ!!!
This is fantastic news! Thanks to /u/nikic for making this a reality. This patch fixes one of the major wtfs in PHP and it is a *huge* step forward. Congrats!
This seems very sensible, good to see it accepted.
I wouldn't miss PHP if it were removed, let alone the manual.
Keep getting webpage not available on mobile. Can someone summarize what this means exactly?
PHP6? Is there an official language roadmap?
Er, you might, but I generally don't. If someone asks a question and is already using mysql_* I'll work with them to fix their code, but I've been actively recommending users switch to mysqli or PDO for years.
I have a couple of scripts that need to work on 4. Just a couple.
"Some time after Perl 6 is finished"
Yes
Then why are you in /r/php?
You should not be editing anything in the vendor directory. Do you customizations inside of adapter classes. Read up on the Adapter Design Pattern.
Nice work
Thank
I tried to Learn Me a Haskell For Great Good and I still don't quite get the whole currying thing. Wanna try to explain it to me in the context of PHP?
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to [##php on Freenode IRC](http://webchat.freenode.net/?channels=%23php).
http://www.phptherightway.com/
Remember when we got dereferencing of arrays returned by a function call or array literals? That times 100.
Seconded - well done /u/nikic 
I'm confused ??? A lot of DB's don't support transactions on a schema change.
*blows party favour*
In haskell instead of "foo(1, 2, 3)" you can write "foo 1 2 3". This also allows your "foo 1 2" which returns a closure with only the last parameter for the arguments.
Ahh, I think I get it. So the result of foo(1) returns a function, which then gets called with (2), and returns another function that gets called with (3), yeah?
Derick's the man. Don't know why he objected, maybe the knock on work he'd have to put in to xDebug :)
I'm pretty sure it's optimized for greedy parameterizing (so foo(1,2,3) instead of foo(1)(2)(3)) but otherwise yes. [((foo(1))(2))(3) would work that way.]
Shits &amp; Giggles
@shawncplus - you forgot to add "Drops the Mic and walks away" to your post 
True. I should've write reading instead of answering
Again, you're splitting your query. Now part of it is in the path, part of it is in the query params, part of it is in the header. Next you're going to tell me that part of it should be in the POST params. An API shouldn't be that difficult to consume. Most people don't manually set their Accept header.
Why hasn't your app been updated? There can't possibly be that much backwards incompatible code could there? 
that would've rhymed.
I dont get why you would do this, instead of having conditionals in your method...
please give autoloading of namespaced functions another try.
I actually ran into the very first example there $foo()['bar']() ... don't ask, it was bad and I do feel bad for it.
Avoid reading anything that is more then a couples years old. And Do what /u/shawncplus says.
No arguing here.
you are caching wrong. 
maybe to explain this better this is a business rule not a package. caching should be granular. you are making a lot of assumptions, and stil ultimately deleting by key, which should be at the users discretion. 
gross. if you are using php 4 you don't deserve support. for reals. come on. fucking dumb. upgrade. what are you supporting? a school for ants?
&gt; any backwards compatibility break is a MUST in a *major* version update
I would definitely go with a database storage, though you technically could use file storage for that as well. Personally I would simply create a table user_playlists where you store all the playlists the user has: id | user_id | title ... all the info you need. And a second table user_playlists_songs which would store song - playlist associations: id | playlist_id | song_id | added_on The last column would be useful if you want to preserve order in which songs are added, so later you can order then by date_added and get them in the order in which the user added them. Hope it helps.
I've just rechecked the examples of what will break. I really really really hope I'm not relying on any code using those patterns.
&gt; OO with Python where it is miles better than PHP. Well I did laugh to that!! and just because you can create *class* doesn't mean that the code is extendable/,maintainable.. Now.. moving on!! &gt; Are you sure you know what Python is? had to do a job on django once. I do admit i did hate (but not anymore) php back then, but after working with django, i did realize that python/django is a *crap*. PS: To others, If you are looking for a language better than PHP Go for Java,C#. Rest sucks in one way or other!!.
But can we please get rid of backslashes s in namespaces? 
As an author of "Removing PHP 4 references from the manual" proposal, I'd like to note one thing. If community accepts it, downloadable snapshot of manual containing references to PHP4 will be provided. It means that anyone who might need it for any reason will be able to download ready docs and use it. I hope this approach will satisfy everyone. BTW: It's good to see, that you like and support this move, thanks :)
You are right. However, many references were already removed and I think it's possible to remove most of remaining in relatively short time. I'm just waiting for consensus in the phpdoc community now :)
I'm totally with you - would be a good move forward, having to scan over paragraphs/examples in docs that are irrelevant in 2014 for 99.99% of cases would be a great time saver. If this did get the okay I would happily start cutting/moving content as I find it - have made a few small PHP doc updates in the past - the process is really quite easy.
The explicit cast operator lets you convert between almost any two types and will never fail, so while some results are weird, I have no problem with them.
http://www.oodesign.com/ has a nice overview of design patterns http://overapi.com/php/ has a nice cheat-sheet for php and as was suggested: http://www.phptherightway.com/ has a great collection of right ways to do it. those should help you out I hope. 
&gt; ... don't ask, it was bad and I do feel bad for it. You shouldn't. Any decent language should support it and PHP finally will :)
I'd save it into database and retrieve a js-readable list via AJAX-Request that i buffered in local storage for quick access. Adding or changing playlists also via AJAX-Request in the background. 
I know I'm late to the discussion but I've always wanted to do this: new Response('Hello World')-&gt;send(); instead of having to wrap the constructor with brackets: (new Response('Hello World'))-&gt;send();
&gt;version 5.30.0 iswydt
You might think that f x y = x + y is equivalent to, function f($x, $y) { return $x + $y; } But it isnt! In haskell all functions are effectively defined as: function f($x) { return function ($y) use ($x) { return $x + $y; }; } So that in haskell f 1 2 //3 is f(1)(2) //3 and f 1 // increment function is f(1) // increment function 
If you want people to share playlists (or even keep them at all) then a database is your best option. If they are more ephemeral, you could use [HTML5 LocalStorage](http://www.w3schools.com/html/html5_webstorage.asp) or just a $_SESSION variable. Then just load them via json.
If you cant figure out php, you should probably pursue a different profession. The world doesnt need anymore shitty software.
So are you telling me without ever being taught or reading about or looking at a single solitary line of PHP, you sat down one day and knew everything? Because we aren't born with knowledge, we learn it. 
I am completely self taught, from the age of 11 until I received formal education in college. I replaced my highschool programming teacher and taught the classes. By the time I ever touched php, I had probably 10 languages under my belt, starting with c++, basic, c, vb, then x86 asm. My point is, with php, one needs not really know anything about the intricacies computers...it is simple scripting. If you cant manage that level of complexity, how do you expect to deal when you actually have to concern yourself with the hard stuff?
Are you trolling? Self-taught is a form of learning... So you admit to not being born with the knowledge of how to use PHP, you did in fact learn it from some source. I'm not talking about level of complexity. Everybody has to start somewhere. You realize you weren't even born with the ability to write the word "PHP," right? I'm serious, I can't tell if you think that anymore. 
For the pcntl side of things, I like Spork ( http://github.com/kriswallsmith/spork ). It seems to be one of the more easier packages for process management. *EDIT* After looking in to ReactPHP .. Totally use that. I'm impressed ... As for key-value management, you could look in to Redis, but an SQL solution works as well. SQLite is nice, IMHO, but I don't know, personally, how it would handle multiple bot connections.
Please don't cross-link to other reddit posts, link to the article instead.
As for handling the bot service, look in to something like supervisord ... It handles all the processes and makes sure the main daemon is still running.
As you only just posted this, it's easier to delete + post again. Don't know whether mods can change links.
Nothing you said makes any sort of sense in the context of this project. With respect to caching, application users have no discretion. They should not be aware that caching is even occurring. Package users still have full discretion. Cache invalidation is a traditionally difficult problem. This package makes it almost trivial. It gets even easier if all the possible tags are kept in one location (e.g. constants in a class you create called "CacheTags"). Deleting by tag is not the same as deleting by key. A key can belong to one cache entry. However, a tag can belong to many cache entries. Some cache entries can be dependent on other cache entries. Using tags just makes the process of managing cache invalidation due to changes in the data store easier. In fact it gets nearly trivial.
does PHP actively follow semver?
You must be dense. Read my original comment. I made no comment about being "born with knowledge to write php", but that people who need help with such an easy language are going to fail in the profession (most likely.) Edit: further clarity: I didnt learn from ridiculous tutorials, I learned straight from the documentation. 
Do you remember mambo? 
[Link for the lazy](http://ckon.wordpress.com/2014/07/14/php-5-7-twice-as-fast/)
To be fair, it's entertaining to read the PHP hate from unqualified fuckwits who give away their own inexperience when their primary complaint is all of PHP's "gotchas"...
Is the really long process one function call, or is your application scraping (for example) 1000 unique pages and that's what takes so long? If it takes a long time because you're performing a lot of unique actions, look into a task queue. You write an application that adds tasks to the queue (it can be as simple as a mysql table with id, url, done, or an actual queue server), and another application that takes the top 5 items in the queue, processes them, and terminates. Them you just set up a cron job to run that task runner application every 30 seconds or minute or so that checks how many runners are active, and if it's less than the max, run a couple more. If you look up PHP task queues you'll probably find some pretty good resources. Also, if you're comfortable with Javascript, your CRON job can just be a web page. Set the page up to make 5 ajax queries to your task running script, and on success, update some status info on the page and start up another ajax request (to the same URL), on fail do nothing. (And set your task running script to return a failing http error code when there are no jobs left or something fails)
Uh, weird. Your way works! But now I'm curious about why mine doesn't. Look, this is how the editor is interpreting the strings. My way in the first line, yours (correctly highlighted) in the second line: http://i.imgur.com/syFRC57.png Edit: don't mind that it says 'usuario' instead of 'user'. I translated the code I posted for clarity.
How would strict handle foo("10")?
Thanks for those links, oodesign in particular looks like it'll help me improve my OOP.
You could use a queueing system with AJAX, you could just call it for each individual page, then update a progress bar on your page and make another AJAX call for the next page. As long as you didn't have a single page that took more than the 4 or 5 minutes it takes for a browser to time out you would be okay. You could also have multiple AJAX requests going at the same time if you wanted.
Your code should work fine. There is no real problem here; in fact, this is probably a feature of your text editor. Note that the first occurence of the word "usuario" is surrounded by slashes. When people use [regular expressions](http://en.wikipedia.org/wiki/Regular_expression) in PHP, say with the [`preg_match`](http://php.net/manual/en/function.preg-match.php) function, they often tend to use forward slashes as [delimiters](http://php.net/manual/en/regexp.reference.delimiters.php). This stems from early Perl days, I believe. It looks like your editor has a feature built-in that tries to discover regular expressions as they appear in string literals. Edit: I use Sublime Text, and [it does the same thing your editor does](http://i.imgur.com/hOIQDnm.png). It's just a syntax coloring thing, nothing more.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Regular expression**](https://en.wikipedia.org/wiki/Regular%20expression): [](#sfw) --- &gt;In [theoretical computer science](https://en.wikipedia.org/wiki/Theoretical_computer_science) and [formal language theory](https://en.wikipedia.org/wiki/Formal_language_theory), a __regular expression__ (abbreviated __regex__ or __regexp__) is a sequence of [characters](https://en.wikipedia.org/wiki/Character_(computing\)) that forms a search pattern, mainly for use in [pattern matching](https://en.wikipedia.org/wiki/Pattern_matching) with [strings](https://en.wikipedia.org/wiki/String_(computer_science\)), or [string matching](https://en.wikipedia.org/wiki/String_matching), i.e. "find and replace"-like operations. The concept arose in the 1950s, when the American mathematician [Stephen Kleene](https://en.wikipedia.org/wiki/Stephen_Cole_Kleene) formalized the description of a *[regular language](https://en.wikipedia.org/wiki/Regular_language)*, and came into common use with the [Unix](https://en.wikipedia.org/wiki/Unix) text processing utilities [ed](https://en.wikipedia.org/wiki/Ed_(text_editor\)), an editor, and [grep](https://en.wikipedia.org/wiki/Grep) (global regular expression print), a [filter](https://en.wikipedia.org/wiki/Filter_(computer_science\)). &gt;==== &gt;[**Image**](https://i.imgur.com/rVnR1le.jpg) [^(i)](https://commons.wikimedia.org/wiki/File:The_river_effect_in_justified_text.jpg) - *The regular expression \(?&lt;=\.\) {2,}\(?=[A-Z]\) matches at least two spaces occurring after period \(.\) and before an upper case letter as highlighted in the text above.* --- ^Interesting: [^Perl ^Compatible ^Regular ^Expressions](https://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions) ^| [^Comparison ^of ^regular ^expression ^engines](https://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines) ^| [^Grep](https://en.wikipedia.org/wiki/Grep) ^| [^List ^of ^regular ^expression ^software](https://en.wikipedia.org/wiki/List_of_regular_expression_software) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ciy7yc3) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ciy7yc3)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Oh yes! The original Lucifer who gave birth to the dark prince, Joomla.
Ah, ok. Thanks for the explanation! Yeah I was using sublime text too, with a different color scheme.
&gt; I feel like the example code you gave would be clearer at first glance. Yes. Using it like `$foo(1)(2)(3)` is just an example, and I think as an example it works - in real world scenario I would find that VERY hard to read and debug. I think that it could be mostly used in things like ORM etc. 
Running from command line is probably the easiest/best but you have to be aware that your environment variables (and how you add request variables) is going to be much different. I don't think it's necessary to write it as a native executable (#!/etc/php) as opposed to running it via the php command line executable. Having it run as a cron is only problematic if you call it too frequently, since it will stack (2 min process running every minute will eventually end up being 50 prcoesses slowing each other down). But you can add a locking mechanism with a flat file or something similar. [getopt](http://php.net/manual/en/function.getopt.php) is nice for creating bash like arguments `php ~/myscript.php --debug -r=14`.
I'm a huge fan of Laravel 4, but you definitely have encouraged me to check out Yii 2.
Sublime has more of those. Check this out, for instance: $var3 = "SELECT * FROM table WHERE id=1";
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to [##php on Freenode IRC](http://webchat.freenode.net/?channels=%23php).
It's quite a basic library. Too basic to be called a library even. Ask yourself what your repo has to add when there are gems like Carbon around. The code is not bad, it's just only about 30 lines of real code. But keep it up and it might grow into something nice. 
IMHO, Yii1 is pretty obsolete for current php development, so let's discuss Yii2 and Laravel Yii2 pros: * Has better Active Record, especially for [joining relations](http://www.yiiframework.com/doc-2.0/guide-active-record.html#joining-with-relations) * Has more core developer * UI widget, the Grid widget is great &gt; What are the advantages of using Laravel over Yii2? * Laravel follow more PSR standard than Yii2, Yii2 uses lowercase for namespace and not following PSR-3 for their logger component * Laravel seems more flexible and less opinionated than Yii2 * Laravel consist of independent components, Yii2 is more like monolithic framework * Yii's development is too slow compared to Laravel &gt; And finally, for the folks who have used both frameworks, Which one do you prefer? and Why? Laravel, because Yii2 is too opinionated for me *Sorry for my english*
&gt; Laravel follow more PSR standard than Yii2, Yii2 uses lowercase for namespace and not following PSR-3 for their logger component How is that contradict with PSR? Also, does Laravel codestyle follow PSR-2 ? Btw, samdark from Yii is a member of PHP-FIG.
https://github.com/Hywan/Marvirc
&gt; You don't define routes, just add controllers. [Isn't this kind of an anti-pattern?](http://philsturgeon.uk/blog/2013/07/beware-the-route-to-evil)
There are even BC break and added features in revisions. They seem to try to follow the idea of idea, but they are far from strict about it.
I know this has been said, but I would like to see versioned archives for each major release. They don't even have to be online, a compressed tar of the directory tree would be fine. All too often, I am faced with situations where I have to maintain someone elses ancient code, I saw production php3 code not very long ago. 
I don't know if we should listen to this guy...
The editor seems to think it's a regular expression. 
How dare you speak against our lord and savior, Jeffrey Way!
Give [phergie-irc-bot-react](https://github.com/phergie/phergie-irc-bot-react) a look as far as structure. It has at least the separation you're looking for (bot/client/events/plugins). The plugin interface also has getSubscribedEvents(), which does as your envisioned start() method would.
Heheh - yeah my thoughts exactly when this flashed up on my Reddit home page. It's like another world of comment fudd compared to here. :)
Certainly sounds like a good contender for a CLI script. Remember you no longer need set_time_limit messing either - CLI scripts are hard coded with unlimited execution time.
PHP 7 seems like the best option to me. 
Interesting approach to storage. I can't help but wonder if a json file with all the info wouldn't be simpler. Or for that matter, just a file with an array. Edit: Oh jeez, it's just looking at the domain extension? I initially saw the structure of the 'domains' folder in the project and assumed it used that directory as a sort of database for legitimate schools.
As far as I can tell this entire project simply returns a boolean data value based on the URI of the email address. As stated in the example on the original ruby project page `america.edu` is not an educational domain, because it was registered prior to 2001 when anyone could purchase an `.edu` TLD. However: &lt;?php require('vendor/autoload.php'); use SwotPHP\Facades\Native\Swot; echo Swot::isAcademic('america.edu'); Returns `1` for `True`. This is __not__ correct, therefore this entire project is useless as it would take someone far less time to simply look at the domain name and testify that it's `.edu` or any other of the 350 TLDs used for global learning institutions and be accurate, rather than rely on this project and be incorrect.
Maybe you don't mean to offend, but please consider the fact that this port only exists because I thought the Ruby project solved a neat problem and after investigating our community for a similar project and not finding anything, I decided to try and be helpful. You may not mean to come across as badly as it seems, but please understand that the type of feedback you've given causes newer developers to NOT engage in open source. Typically and ironically, this tone also comes from individuals that complain about the state of FOSS. The package was ported for fun. I am not paid to validate educational domains. I simply did a one to one port of a ruby gem the best I knew how. I likely made a mistake. That said; an example of a productive and perhaps more useful response: "Hey! I installed the package and played around a bit and found that there is a bug regarding the isAcademic method call on X domain. I'll write a test reproducing it and if I have time propose a fix for this bug. Thanks for the work, is there anything else I can do to help?" That's the community I want to be a part of. You're better than this. 
It's doing a few things. First, the storage implementation is indeed interesting! Haha. It matches the ruby gem implementation and what's nice about that is we can easily pull updates to that list. That said, a build script that did code generation to build an array instead is a great idea and still solves the update problem! An example: NCSU.EDU is a valid domain. As is aif.ncsu.edu or fourth/fifth level subdomains on top. This package uses the public suffix registry in combination with custom additions of institutions to report legitimate public suffixes. 
Naw, sure I don't want to offend. But this isn't a port. A port would suggest that it contains the same functionality as the original--which it clearly doesn't. &gt; the type of feedback you've given causes newer developers to NOT engage in open source. I do not represent open source, I'm simply a developer. As much as you hate to admit it, when you release things for public viewing someone, somewhere is going to have something shitty to say about it. That has nothing to do with open source, more with human nature. &gt; I likely made a mistake. Actually, looking over your code you did quite well. However, it simply doesn't have the functionality of the original. Without it you've simple created a Rube Goldberg machine to complete a mundane task. &gt; "Hey! I installed the package and played around a bit and found that there is a bug regarding the isAcademic method call on X domain. I'll write a test reproducing it and if I have time propose a fix for this bug. Thanks for the work, is there anything else I can do to help?" That really has no bearing here as there really are no bugs. The software works as you intended it to, but it's simply not useful because of its decreased accuracy. &gt; You're better than this. I'd like to think so too, but I'm really not (at least not from your perspective). When I give feedback I like to be objective, not subjective. If instead of what I originally posted I celebrated the mediocrity of your attempt I wouldn't be doing you a service or your project, you would never want to get any better because you would be under the impression that you were doing fine. Instead, I give my view in an objective manner so you can take a second look at your project with my thoughts in mind and really think critically about what went wrong. Something you should consider in the future is maybe [__SCRUM__](http://en.wikipedia.org/wiki/Scrum_(software_development\)) development, which would enable you to see the project as a whole and in parts so you don't miss anything. Like I said before, I don't mean to be a dick, but there's nothing wrong with me saying a software is bad when it's clearly bad and doesn't function as a port as originally stated...
What can you do with this that is not already available on date time object? 
To be fair, even though the original project uses that domain as an example it also has a bug that considers it valid.
[How so?](http://i.imgur.com/ZX2wYex.png)
Yeah I just checked the same to be sure. I think I'll be contributing to both projects tonight haha. 
It's in the readme but they're strangely not testing for it. I cloned the repo, added a test for it, and it fails.
+1 bad point for how true of a port we have here... :) I really appreciate the attention you've given this Xanza and I also appreciate the brutal honesty and feedback you've provided. I would have accepted a passing identical test-suite otherwise and missed the opportunity to improve. Thanks! :)
It should fail. foo(123) -&gt; pass (int) foo(0xff) -&gt; pass (hex int) foo(0123) -&gt; pass (octal int) anything else, fails. foo(1.0) -&gt; fail (float) foo("1") -&gt; fail (string) foo(5.0E+19) -&gt; fail (float)
Thank you. 
Something like https://github.com/swoole/swoole-src could be good for the networking layer. Been following along with this project - looks rather promising.
As I was reading this article the entire time I couldn't wrap my head around how ZF was performing so well in these benchmarks until I came across the end of the article. "Zend CTO &amp; Co-founder" Please release github repo to reproduce all of these benchmarks.
[Head First PHP](http://shop.oreilly.com/product/9780596006303.do). No comparison.
If all that's there is an include, yes I'd make use of a framework, since you've essentially got a blank slate. Particularly if you're not familiar with the quirks of PHP. Also I'm not sure, since you're not asking for help with a specific problem, but /r/phphelp might be the place for this.
So it's your base controller? In all honesty I've never seen full output logic put that high level before. What happens when someone requests your RSS feed in JSON?
So, first things first.... give http://www.phptherightway.com a good read. You will find that the use of mysql_* functions are not recommended (actually depreciated in current version of PHP). I would highly recommend using PDO for database connectivity: http://wiki.hashphp.org/PDO_Tutorial_for_MySQL_Developers Also look into separating the view (html) from the logic (php code). To make the code a little bit more modern you can do something like this: **logic.php** &lt;?php $host=”localhost”; // Host name $username=””; // Mysql username $password=””; // Mysql password $db_name=”test”; // Database name // Connect to server and select database $db = new PDO('mysql:host=" . $host . ";dbname=" . $db_name . ";charset=utf8', '" . $username . "', '" . $password . "'); $sql = $db-&gt;query('SELECT * FROM test_mysql'); $result = $sql-&gt;fetch(PDO::FETCH_ASSOC); $color = 0; include("view.php"); **view.php** &lt;table&gt; &lt;? foreach($result as $row) : ?&gt; &lt;tr style="background-color: '&lt;?=($color &gt; 0) : "red" : "green"?&gt;'"&gt; &lt;td&gt;&lt;?=$row["id"]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$row["name"]?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$row["email"]?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;? $color = ($color &gt; 0) ? 0 : 1; ?&gt; &lt;? endforeach; ?&gt; &lt;/table&gt; **OR** you could use css: tr:nth-child(odd) { background-color:red; } tr:nth-child(even) { background-color:green; }
The title is quite misleading IMO.
So “Use a Webcam to take pictures in Javascript and Flash”…?
Try some php template than include like https://github.com/auraphp/Aura.View/ or http://platesphp.com/ .
Yes
The nice way would be to extend the template-system so it also offers an option to exclude the header and navbar. A quick-fix, even though ugly, would be using CSS to hide those boxes. They'd still be loaded, but invisible. Might work if you only need it for 1 or 2 pages. 
This article is written too defensively and tries to showcase PHPNG instead of benchmarking them objectively. &gt; On Wordpress, hhvm is WAAAY faster than PHP 5.6 - *but only 27% faster than PHPNG*. ... so, still faster, right? I don't care what implementation brings the largest speed improvement as long as it's stable and plays well with legacy code.
&gt; Really? Then the solution is to fix the benchmark, not just benchmark the login page. Use different sessions, and test real applications and real pages. A fixed benchmark is mentioned, but not included because it requires custom modifications: &gt; Once I benchmarked hhvm and PHPNG on equal terms, PHPNG was significantly faster than hhvm on the SugarCRM logged-in page view, even more so than the login page. I haven't included this benchmark here as it cannot be run using http_load as it requires custom headers. If &amp; when I have some free time to conduct it reliably - I'll publish it separately.
Are we interested in this kind of thing ?? I'm not sure how useful it really is, since webcams are at the client and php at the host. A couple of weeks ago, we needed reliable face detection in php, so I interfaced with the industry standard library (OpenCV) and made a quick extension for that purpose http://github.com/DatingVIP/Facial. OpenCV can capture from webcams ... holla if you're interested and I'll extend it to cover the webcam/video stuff ...
On a Spanish language keyboard it's important not to mix up the ' with the `. That is mixing quote mark with grave accent. I just guess this is your problem from when I program using Spanish keyboards...
I think you are quite right and opened an issue in the website repository to fix this: https://github.com/phpDocumentor/phpdoc.org/issues/5
It is splitting the **request** logically and *not* the query (a part of the request) as you posit. The query (?id=5) remains unchanged. HTTP has a very simple and easy method for requesting a certain response format and that is in the Accept header. Placing this responsibility elsewhere is duplication and non-standard. &gt; Next you're going to tell me that part of it should be in the POST params Eh? It is a GET request...
HHVM doesn't do the latter and isn't *quite* Zend-compatible.
Nice work - just a quick skim you have a small typo in the "ClassLoader" README.md. The line: &gt; Unlike PSR-0, the PSR-0 class autoloading Should be &gt; Unlike PSR-0, the PSR-4 class autoloading Would do a pull request - but it's a 1 byte change :) 
Also consider Python for tasks like these.
I know, but that's not what the article is about. It talks about performance and adds "but only X% faster" after each unfavourable result.
I really like the redis client. The MONITOR command is super handy for debugging.
Well... the article is almost 2yo so maybe the author had yet to jump on the Redis train :)
The "but" part is legitimate IMO, we are talking about a prototype/pre alpha of PHPNG, whereas HHVM has been actively developped by Facebook for quite some time now.
Fixed, thanks :)
That's good to know. I had guessed that would probably be the case, but didn't know for sure.
&gt; * Wordpress Wordpress is a widely-used real-world app, no? &gt; * SugarCRM login page &gt; * Drupal homepage &gt; * Symfony ACME app home page (i.e. the empty demo app) &gt; * ZF Skeleton App Sure, you have no "main app", but isn't the bulk of performance issues with big frameworks caused by all the boilerplate and setup time each framework needs on each request?
So I'm meant to use this instead of PuPHPet? What am I supposed to do regarding the staging and production servers? This project only seems to be about local VMs.
&gt; However, we should also delete by tag every cache entry with the tag posts_table. Not really. Instead, the post should be removed from that level of cache. This would require application awareness of cache, which is fine. A blunt force removal means cache invalidation all the time at the merest hint of a change. Cache invalidation is already a difficult problem, but blindly removing data from cache is equally troublesome and defeats the point of cache.
Really nice work overall. A few notes about SecureRandom (with a quick look): I'd try to make the SecureRandom class more simple by removing the $buffer (there is no need for it, just read straight from the randomness generator when bytes are needed). With security critical code it is especially important to avoid greater surface for bugs (every line of code is suspectiple to contain a possibly critical security bug). The more simple, the more better. The generators should make absolutely sure a requested amount of bytes is actually fetched (i.e. check that 16 bytes is present if 16 bytes were requested, exit with an error). Those generators could throw a specific exception on error condition (now they can return boolean false or GeneratorException -&gt; make them always throw GeneratorException on error). I'd consider carefully if OpenSSL should be used to gather random bytes (it has a poor security record, and who knows what happens to pour from it tomorrow). Good to see it is last in the line of the available methods. And I'd drop the support for /dev/random, as it is not suitable for online use and there is no security difference between the two (about urandom, see http://sockpuppet.org/blog/2014/02/25/safely-generate-random-numbers/). The getBufferedInt looks to use the "trial and error" approach to make sure the number distribution will be uniform, this is really good. However, if I'm not mistaken, it allows to generate ranges greater than PHP_INT_MAX, which could lead to errors (I didn't take a good zoom on this, just bringing it up as it is something which must be "absolutely sure to work"). You should include some kind of tests to try to catch possible biases on the output. Also, I'd remove the documentation about: &gt; By extending the Gererator\Generator interface, you can easily also create your own randomness sources... As security related high-level library should never give the end user a change to shoot themselves in the head (the only situation you would need to use a different randomness generator is when running tests, as you would use a test implementation which gives predefined random results i.e. when testing random int generation). While version requirements are on composer.json, maybe add them in the README too. Btw, is there anything else than [] which drops the support for PHP 5.3 ;) About libraries in general, my take on it is that a library should do "just one thing" and "do it really good". The library author should have a good understanding of the underlying problem the library is solving and thus making it high quality in terms of the "underlying problem" and also on general things related to libraries (i.e. sane API and so on).
You are such a tease! :D Thanks for pointing me to this - I had heard of it but hadn't connected it to you. Checking it out now...
The easiest way would be to go with wordpress if you're not very good with php. It is very simple to create a template and manage users.
Personally, I never learned all that well from books. @Blitz79's suggestion of Head First is a great one if you're going to take the book route though. Another online resource for you is [PHP The Right Way](http://www.phptherightway.com/)
I love symfony (that's why I read through the documentation) but I find this design decision rather silly.
I've talked to a bunch of people who swear by this book (in a good way): http://www.larryullman.com/books/php-for-the-web-visual-quickstart-guide-4th-edition 
the first rev of this book was one of the ones that got me into PHP. Can't recommend it enough for those starting into PHP!
I'm well aware of the silly requirements large bureaucratic organizations have, none of that changes the fact that software that hasn't received any security updates in over 4 years is inherently insecure. though i now get what you meant by "security". 
That is brilliant. Now I want to do the same thing.
Serving stale data is orders of magnitude worse than deleting cache entries due to a possible data dependency. However, it is not that difficult to minimize cache thrashing. Also, as long as the application is more read heavy than write heavy, the issue is minimized. Lastly, partitioning the cache based on a user id, organization id, or some other reliable method will further reduce unnecessary cache entry removals. Are there other methods of easy and reliable cache invalidation? Time-based doesn't work for database results caching. Russian-doll or some sort of nested caching gets too difficult to manage because of the high level of granularity and the possibility of missing a dependency as the application is modified.
The usefulness of a library should not be based solely on bulk. Also, using Carbon for MySQL datetime still requires me to remember the MySQL datetime format string (i.e. "Y-m-d H:m:s"). Carbon does not provide a simple chronograph to measure time between two events. Carbon does not provide a set of constants to represent months. My library is a great lightweight and simple supplement to Carbon, not a replacement.
As someone who is unfortunately stuck supporting PHP 4 applications, I would be very happy to see PHP 4 documentation preserved. As long as I can find it somewhere easily I'm a happy camper.
When reading websites on my phone, I like to turn it sideways. However, I can't stand when navigation bars and other random bars are cluttering up the viewing area. Any bars that follow the view around as I navigate the page is total rubbish. Screen real-estate is already constrained. I don't want your dumb bar taking up even more. This leads me to another point. Responsive design is great and all. However, I see really bad artifacts all over the internet when viewing pages. I don't think web developers are able to fully account for every screen size possibility no matter how much they would like too. I have a hard enough time getting my devs to test every popular browser as it is. Testing every device and orientation seems hard to maintain. Devices with small screens seem to be getting bigger screens as time goes on (e.g. iPhone 6). Maybe going back to a simple fixed width 960px layout is a good idea as the small screens get bigger. I have no issues with pinch and double-tap. On the larger phone screens, its not even needed to view 960px pages. What does everyone think?
You can also just use simpler designs, which work really well responsively.
We've tried to keep it down in recent times. Usually we don't break BC in minors unless there's a *very* good reason, such as security. Minors do have BC breaks, but usually minor ones.
If you have any questions, I normally idle in #phpc (and #phpphp for this specifically) on Freenode (among other places). Feel free to pop in and ask away :-)
I love how inconsistent people are with up/down voting these types of posts. I posted this once and got downvoted to hell, but I've seen /u/phpsupport get nothing but upvotes, too. Welcome to Reddit, I guess.
For staging and production servers you use Forge. So Homestead is a local VM that is easy to get up and running. Forge deploys the same setup to DigitalOcean etc.
I mention this at the very end of the article. I haven't used Forge yet (hoping/waiting for GitLab support), but this is what you would do. A full blown custom server with custom provisioning isn't really necessary for small to medium size applications IMO - especially since the Homestead stack is feature packed. Most people and apps can just let the Laravel brand get them up and running from development to production (I think that was their idea at least). 
If you use sublime as a daily driver, and especially if you're going to make videos with it, you should toss those guys some funds and get a license. Not trying to be condescending so I'm sorry if this comes off that way...but as a fellow coder, I would really appreciate people who use my tools on a daily basis supporting me in the development of those tools.
It's not semantic versioning, it's plain logic. Major === many big changes. There can't be any big changes without BC breaks.
&gt; Wordpress is a widely-used real-world app, no? Yes, that's exactly why the next sentence is "The only realistic benchmark here is Wordpress." I don't see your point. &gt; Sure, you have no "main app", but isn't the bulk of performance issues with big frameworks caused by all the boilerplate and setup time each framework needs on each request? The blog post wasn't about "framework performances". It clearly mentioned "real world applications" (that's why I put it in bold). So that's what my comment is about. Sure framework performance is interesting, the numbers are interesting. But we need to keep in mind that we are not talking about real world applications here. That's just what I'm saying.
Thank you for pointing that out, I misread the "logged-in page view" as "the login page view" ;) I'm eager for something more concrete than just "PHPNG was significantly faster than hhvm" but that's still interesting to know.
Thanks for the feedback!
&gt; You can also just use simpler designs I don't know if Symfony or sensiolab would let me redesign their site. Maybe I should ask?
I'd say PHP The Right Way won't teach you PHP, but it *will* teach you how to do PHP right.
&gt; What does everyone think? This is a topic I'm very passionate about. Here's some completely unnecessary back story. Years and years and years before the iPhone came out and mobile was even a thing, I was a front-end guy: Photoshop, designs, UX, CSS, HTML, JS. Life as a front-end developer was great. 980px wide and fuck you if you tried viewing my sites on anything other than a PC monitor with a maximized viewport - ***I*** decided the layout, not you. I had to deal with browser compatibility issues, but that wasn't the worst thing in the world. I got into back-end development a few years ago, and back-end is what I currently do at work. But every once in a while, a project comes in where I have to do both front and back-end, and front-end went from being awesome, to a *an apocalyptic wasteland of teeth gnashing and suffering* ***Steve Jobs and his motherfucking iPhone ruined the internet.*** Suddenly, sites had to be mobile-friendly. They had to look different on this screen than they do on that screen. To be clear, this is exactly the same shit game developers have to go through when making their game work on Xbox, PS3, or PC. **Websites (at least, their presentation) became platform-dependent**. Ok, well, targeting certain browsers with @media and serving up a different style sheet isn't *so bad*, right? Well mobile-friendly led to the concept of responsive, where it wasn't just targeting different platforms or resolutions, but somehow fluidly adapting to an infinite range of viewport sizes, with some key break points, AND different platforms where resolution and physical size aren't the same good old 72ppi anymore.. So what happens? The designers we work with are still largely stuck in desktop-first mentality. "Here's our design for 1280px. Have fun". Zero direction for how it should break. Zero direction for how it should shrink. Zero direction for what it should look like on different designs. So here I am, left flapping in the breeze trying to invent new variations of the design I was giving to not look like ass on various devices and viewport sizes, many of which I don't even own or have access to. The worst part is the fucking workflow. Before? 1. Edit some CSS in the browser 2. see that it's good, save it to style sheet. 3. Done. Now? 1. Edit some CSS in the browser 2. Drag the browser window around to adjust the viewport width, check the results, adjust 3. Switch the user agent in the browser and simulate its viewport width, check the results, adjust 4. Save what you THINK are the correct values in your CSS 5. Find a target device, load the page in the actual device, see that it looks NOTHING like the simulated viewport/useragent in your browser 6. Take a wild guess what the fix should be (no way to really preview it) 7. Save and check again in the device 8. See that the change that fixed the device, fucked up the desktop 9. Tear out the change and place it in a targeted media query 10. "Done" (never done, client has device you don't have, sees a bug, puts in a ticket) 11. Cry So god damn glad I'm more back-end than I am front-end these days.
I know, and I will, it is just that I already did so for sublime text 2 and sublime 3 is still buggy. But I will :), it is the best tool ever.
Amen! 70$ is nothing!
&gt;Objects should be castable to every type supported by the engine, this compliments and completes a better type system for PHP. You mean with something like __toBoolean(), __toInt(), etc.?
&gt; Are there other methods of easy and reliable cache invalidation? Yes. It depends on the application. Caching isn't something you should just throw on at the end. It's something that needs to be thought out. And that's the general problem with pretty much every single library I've seen that promises to handle all the caching for you. It takes a hammer to caching. This tag-based caching package would fall over at scale (especially when you consider the cost to actually delete all the other tags associated with it inline).
Can you speak more about using JS to replicate CRON job functionality? How would you get the JavaScript on the web page to execute on a schedule without having to manually visit it?
Only when abused in ways that make baby jesus cry (so of course, what every PHP app ever does). And once again as I said, it makes performance problems *more visible* and *more likely to be fixed*.
Wow, how are you in that situation? Have those apps really been going for 10 years?
So you're saying something like this: $string = "my really long string that has..."; //a long string $string = str_replace(" ", "-", $string); I'm highly skeptical that string functions would not suffer enormous performance penalties if implemented in PHP instead of C.
FYI you can do {% if loop.first %} rather than looking at the index, loop.last is another similar boolean. 
I stumbled upon this on Twitter: https://twitter.com/daniel_sloof/status/489500387200999424
"Head First PHP &amp; MySQL" is one of the best ones out there. Rather than being a PHP reference book (for which there is always php.net), the book assumes zero programming knowledge. It then gets you interested into developing an Alien abduction site using PHP &amp; MySQL. As your task progresses, you will learn some important PHP lessons that are helpful for a lifetime of PHP programming.
I have bad news: the pattern name "Model-View-Presenter" has been retired in favor of "Passive View" and "Supervising Controller". &lt;http://www.martinfowler.com/eaaDev/ModelViewPresenter.html&gt; I myself only discovered this a few months ago when researching [Action-Domain-Responder](https://github.com/pmjones/mvc-refinement).
I'm working for a company that has a PHP 4 server running at a hosting firm, dedicated to a client that can't be persuaded to upgrade to PHP 5. I think most applications running on that server are about four years old (go figure).
www.dotdeb.org
Have you browsed http://news.php.net/group.php?group=php.internals ? [edit] I just googled "php internals propertygetsetsyntax" and got a lot of info.
There's been a long back and forth between Daniel and Zeev on Twitter, but it looks like they still haven't figured out where the difference comes from. Benchmarks are hard...
&gt; Status: Declined, Vote Failed &gt; Voting ends not before Wednesday, January 23rd 2013. The PHP language is expanded, so a 2/3 majority is required. &gt; Yes: 34 &gt; No: 22 A 3:2 majority was required, and was achieved. I too would like to know why it was declined. **edit** I apologise, mental arithmetic was never my strong point. Ill stick to calculators :(
I think the core issue is that the RFC tried to do altogether too much at once. It tried introducing a complete accessors system covering all possible and impossible use cases, which made it rather complex (not for simple usage, but in its entirety).
A 2/3 majority would be 66.6% of the vote, whereas the RFC only received 60.7% of the vote.
How's that math work? 34/56=0.60 which is less than 0.66 E: math
That's such a crap excuse. :/ Why block a system that's good but complex, just because it's complex? (Not directed at you really.)
Thank you for your many comments! Let me address some of the issues. &gt; I'd try to make the SecureRandom class more simple by removing the $buffer The buffer existed mostly because reading from /dev/urandom byte by byte is not exactly a good practice. However, the way I implemented the buffer was unnecessarily complex. I've simplified some of the functions and instead of implementing my own buffer, it just now takes advantage of buffered reads via fread(). &gt; The generators should make absolutely sure a requested amount of bytes is actually fetched This is a good point. I hadn't accounted for the fact that any of the random generators could return false on unexpected errors. They now all throw GeneratorException on error instead. &gt; I'd consider carefully if OpenSSL should be used to gather random bytes Yeah, I made a decision to use it as the last fallback despite knowing that it is not well trusted. I added a small note about it to end of the documentation but I personally consider the better compatibility more important right now than possible concerns that may pop up later. &gt; And I'd drop the support for /dev/random, as it is not suitable for online use and there is no security difference between the two I actually originally implemented it due to discussion with a someone very experienced in security. After further discussions, it did become clear, however, that the relevant cases for /dev/random do not really apply to PHP. I do not consider the optional switch to be harmful, however, so I'll avoid changing the API for now. I did change the documentation about it, though. &gt; However, if I'm not mistaken, it allows to generate ranges greater than PHP_INT_MAX The method didn't verify it, but none of the callers could provide it with greater number. However, due to the change in buffering the function has been removed and integrated with getInteger() (which verifies the arguments). &gt; You should include some kind of tests to try to catch possible biases on the output. Yeah, but how? Most common test suites are for byte generators. Testing getBytes() does not provide any additional information, as it simply relies on the system random generators. At least the image generated by example/distribution_image.php indicates there is no simple pattern. &gt; As security related high-level library should never give the end user a change to shoot themselves in the head Agreed. I removed it from the documentation. &gt; While version requirements are on composer.json, maybe add them in the README too. Done. &gt; Btw, is there anything else than [] which drops the support for PHP 5.3 ;) There are some little things. For example the stream_set_chunk_size() that is required for the buffered reads requires 5.4.0. I also make use of (new object)-&gt;method() structure in tests. Personally, I've moved to PHP 5.4 on pretty much all of my projects. Because of this, I've also set the minimum compatibility level for those libraries at 5.4.0. It's hard for me to pinpoint the exact requirements, since I only make mental notes about things that require versions later than 5.4.0. Given that PHP 5.3 is just about to reach its end of life, I'd rather not concern myself with it anymore. (Even though there are too many hosts still running it)
That's from 2008 and suggests using SHA() for passwords. Is that really a good idea? OOP is a mere *appendix*! Out of curiosity, does it use mysql_ or MySQLi?
It doesn't matter if you refer to it as one pattern or two, the actual implementation would be the same. We all know what OP means when he speaks of MVP, and the name's probably a lot more prevalent than Passive View and Supervising Controller. Going around pointing this out everywhere just because Martin Fowler decided that it would be more clean to split the pattern just isn't constructive. 
Really nice article covering concepts not often seen in PHP applications. I like that you mentioned the persistent state for events and aggregates don't have to be the same. This was one of the most liberating concepts for me to understand when it came to event processing, especially in a distributed application. Being able to dump events to some arbitrary channel, and vice versa, being able to integrate events from any data source abstractly starts to become a core feature when working with large sets of data requiring a lot of aggregation or processing. Nice work!
If memory serves correct it uses MySQL, although I've been using MS SQL (I know...off fucking combo)
As you already know, I'm big on calling things by their proper names as much as possible. Since Fowler created the name in the first place, he's the one in the best position to retire and/or rename it. UPDATE: I went back to check my facts, and it appears Fowler is not the originator of the term; cf. &lt;http://lostechies.com/derekgreer/2007/08/25/interactive-application-architecture/&gt;: &gt;it wasn’t until after Taligent, Inc. was purchased by IBM in 1995 that Mike Potel first suggested the name “Model-View-Presenter” to describe the architecture found within the Taligent programming model. So, my bad on the originator of the term. However, as to your claim that "We all know what OP means when he speaks of MVP", there are at least two variations listed in the Los Techies article. I'll grant that one might be more common than the other, but the term is not without its own varied meanings. The article further goes on to talk about Fowler's refinement of the pattern to the terms I mentioned. As such, I'm happy to stick with Fowler as the authoritative source here.
&gt;Since Fowler created the name in the first place He *what*? Last I checked Mike Potel was the first to formally describe the pattern. 
Yes, I have updated and corrected my post above.
Numbers moving in the right direction are fine by me. Clearly PHPNG is giving some sizeable improvements in the PHP runtime - assuming it can maintain compatibility with everything vs. mainline/unit tests PHP right now then it can't be a bad thing. And Magento is probably the biggest pig-dog you could test against :)
Would running Mage in production HHVM be a terrible thing right now? I haven't seen much to say otherwise...
Unique use cases and exploring the limits of what is possible is interesting. Unfortunately, the site seems to have exceeded its bandwidth, but yes, some of us like this sort of thing.
It doesn't delete other tags. It only deletes the cache entries that have that tag. In fact, it's a O(1) array look up to get the cache keys for the tag and then it iterates through the keys and deletes them.