learn 3 more languages, that'll probably teach you better than anything how to be a better php programmer. 
Well, there are groups (as [http://groups.google.com/group/cake-php](http://groups.google.com/group/cake-php)), mailing-lists, irc-channels, and lots of other sources. I started by reading the online [book](http://book.cakephp.org/view/875/x1-3-Collection). Then all you need is the [API-doc](http://api13.cakephp.org/). This is the very best source for proper information out there. If you have questions utilize the groups, irc-channels or mailing-lists. But try to figure it out by yourself by reading the API-docs/Source-Code. That's what the people do that know enough to help you. 
Zend is just a bunch of loosly coupled components no? How is that bloated versus the do-it-all frameworks? I dont use them either since PHP was worthless until 5.x's object model and when 5.x was released there wasnt much taking advantage of it, Also it gives me the ability to leverage newer PHP builds 5.3 (late static bind/ FPM) since i dont have issues regarding backwards compatability
Thanks everyone for the many comments. I'm glad to see that a few other people are in the same situation I'm in, hopefully they've found some good advice in this thread aswell. I think I'll start with the following: 1. Find a PHP framework and take the tutorials on the site to find out how they work. Probably Yii. 2. Get a good, modern PHP book that focusses on PHP5 and OO. I'm thinking this one, once it comes out [link](http://www.amazon.com/Advanced-Php-Programming-Large-scale-Applications/dp/0672329239/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1287471954&amp;sr=1-1) 3. Find a general OO, pattern programming book 4. Learn Python, it's something I've been wanting to do for a while now but never made time for. 
Within spitting distance of the PHP ecosystem, Python, Perl, and Ruby are all probably worth your time. Though I've largely made my peace with PHP, I'd probably be doing web development in Perl or Ruby if not for legacy considerations. And people sure seem to be getting [decent mileage](http://code.reddit.com/) out of Python on the web, though it's not much to my tastes. I'd also hasten to add that I think you can learn plenty while writing PHP, but I feel like for myself a great deal of what is fundamental to programming didn't come clear until I'd spent serious time in more than one language. 
I have considered trying to do a masters in cs in evening classes or something like that, but with the amount of overtime I put in at work it's not really viable right now.
Zend appears to have [Not Invented Here syndrome](http://en.wikipedia.org/wiki/Not_Invented_Here) IMHO, as they implement almost everything you can think of, but do it Their Way. The components are also interconnected (fuck `Zend_Exception`), meaning that if you want to use a class outside of Zend, you need to strip that out.
I love Python. I'll often whip up quick scripts in it (desktop use), simply because it's quick to develop with. I don't use it for web dev as much, since it's not designed explicitly for the web (ala PHP), meaning that you sometimes need frameworks/libraries to do things PHP has built in.
It still uses no PHP5 features. Progress, GG.
&gt;CodeIgniter is beautifully flexible but allows you to do things that you really shouldn't. Hi there jasongill, I'm in the same situation as OP, except I've learn to program PHP using Codeigniter and I'm addicted to it, I use for every project even the simple ones, I know this is not right, but my boss usualy wants things working yesterday, and CI provides really good shortcuts to get the job done in less time. Care to explain your statement so I know if I'm doing something wrong? Tks. 
While that is an object that doesn't explain why objects are good. The parent is struggling to understand the point of objects, and that is a much bigger topic.
&gt; PHP 4 support is deprecated. Features new to 2.0.0 may not support PHP 4, and all legacy features will no longer support PHP 4 as of 2.1.0. From changelog
Deprecating PHP4 support while not adopting new functionality of 5 is either laziness or stupidity.
You're right, I'll elaborate. If you have two procedures that deal with products, like a listing page and a modification page in your admin area, you load up the product with something like this: $prod = new product($prod_id); And bam, theres your product. Rather than having to build the product by hand each time, you just hand the code the data it needs and it build the product. This allows you to use the product wherever you want in your script without it getting messy, and if you need to change something about it, the code is all in one place.
DCI? Well, I can't see how these two things could be related. Would you care to elaborate? Patchwork is meant to aid in testing, by letting you catch calls to user-defined functions (or methods) and forwarding them to another function (a filter). And since it does all that dirty and rather slow preprocessing stuff, using it in production is not exactly a good idea.
That's still not showing the power of OOP. After all, I can do this: $prod = product($prod_id); sell_product($prod); vs. $prod = new Product($prod_id); $prod-&gt;sell(); or $user = new_user($username,$password); email_user($user,$message); vs $user = User::create($username, $password); $user-&gt;email($message); I'm not suggesting your wrong. =) Just pointing out that OOP is much more than the little you present. The parent doesn't see the point of objects. And with the above examples, is he really wrong? Objects aren't useful for being objects. Polymorphism, inheritance, and all those other big fancy words are where objects start to become really valuable. Sure, encapsulation helps, but I don't think to the same degree (or at least it's not as apparent). I hope you don't take this the wrong way. I just remember my early days of first learning OOP and wondering what the point was, when the examples showed things I could already do in C. OOP isn't about using objects. It's a way of programming and objects happen to be a great tool that lets you use this way of thinking. Hopefully I didn't confuse anyone. Maybe someone has said this, or can say this, better than I've tried here. 
Unrelated, but this is my favorite PHP wtf: $a = '0'; $b = new stdClass; $b-&gt;$a = 'foo'; $b = (array)$b; $b[] = 'bar'; print_r($b); Result: Array ( [0] =&gt; foo [0] =&gt; bar ) 
You can use several of them as standalone units. For instance, Zend\_DB and Zend\_Form can be used without the rest of the framework. Also, in addition to the full version, they have a minimal version without a lot of the extra stuff.
Sorry that was stupid: So I have a form that when submitted sends to this page: &lt;?PHP session_start(); include_once 'connect.php'; $date= date("Y-m-d-H-i-s"); if($_REQUEST['submit']!=''){ $q="INSERT INTO notes (note_maker, campaignUser_id, note, date_created) VALUES ('".$_SESSION['userid']."', '".$_REQUEST['campaignUserID']."', '".$_REQUEST['note']."', '".$date."')"; $r=mysql_query($q); echo mysql_error(); } ?&gt; The error is with the $_request['note'] because there is an apostrophe in it. Error is: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 's note', '2010-10-19-08-17-16')' at line 1 And inside of connect.php I have: //This stops SQL Injection in POST vars foreach ($_POST as $key =&gt; $value) { $_POST[$key] = mysql_real_escape_string(trim($value)); } //This stops SQL Injection in GET vars foreach ($_GET as $key =&gt; $value) { $_GET[$key] = mysql_real_escape_string(trim($value)); } 
You should look into moving towards something like PDO. If I recall correctly, mysql real escape string is going to be affected by php.ini settings regarding magic quotes. Make sure magic quotes is off. I highly recommend moving to a more robust mysql handler. I made the shift to PDO and have had no problems getting things running properly. Your mileage may vary, but my experience with PDO has been great compared to mysql stuff. edited: underscores causing unwanted italics or bolding. edit #2: Be cautioned that turning off magic quotes if it is indeed on may have unwanted effects regarding existing code using escaping functions.
Yea this is the echoed query: INSERT INTO notes (note_maker, campaignUser_id, note, date_created) VALUES ('', '', 'eric cartman's nnote', '2010-10-19-08-34-33') 
Thank you that was an obvious mistake. Can you explain why PDO is a lot better?
&gt; At the time of writing there are 93 issues in the Issue Tracker on BitBucket. The vast majority of those are invalid, irrelivant, ridiculous or badly described and non-repeatable. Yeah, that's going to encourage people to submit more bug reports in the future.
Bug: Your product sucks. Steps taken: I opened product and it didn't work.
The bloat in PHP frameworks is not so much from the components as they are often lazily loaded. Most of the time it makes more sense to measure the time it takes before the application is bootstrapped and reaches user code, before that it's all framework code taking up time. I can't say about Zend 2.0 but Zend 1 is not very fast at bootstrapping and does a lot of things which most people don't need. Don't get me wrong, though, it's not a bad thing, every open source framework is going to make itself useful for as many people as possible so sometimes you just have to add code which is only used by a subset of users.
Whoa! Your SQL Injection method is bunk. Modifications to $\_POST and $\_GET *are not* reflected in $\_REQUEST. Change your connect.php to a single foreach against $\_REQUEST - but even that might not be the best idea. Consider writing your escaped data to a new array, so that way you aren't escaping apostrophes when you go do more work with the data (say, echoing out some of it.) Example: $sqlData = array(); foreach($\_REQUEST as $key =&gt; $value){ $sqlData[$key] = mysql\_real\_escape\_string(trim($value)); } Then use $sqlData['keyName'] in your SQL query. 
PHP *is* a template language. All the other stuff is just stuck on as an afterthought, like a weed that evolves sharp teeth and starts eating people's limbs.
Some dude that wants to be a teacher and therefore spams? A kind of White Spammer?
I understand it better now you put it that way. It would serve well as an improved exception handler for frameworks and/or other userland abstractions in various stages of testing.
&gt; Am I alone in my frustration with this? why are you frustrated about this? &gt; Are the other frameworks doing this too? indeed.
This is one of the best features of PHP. I've used it a number of times to make truly dynamic code which uses previously defined conditions to decide which function to execute. It's a bit like a choose-your-path book. You define various methods and let the programming decide. The trick it not how to create dynamic variables, it's identifying when they'll be necessary and when they will save you time.
Yea thats completely unnecessary.
I'm not sure if it can do anything about exception handling. That's because the filters only kick in at the beginning of a call, and if none of them asks to "short-circuit" it, the call will continue as usual, meaning that if the called function is supposed to throw something, it will. However, what's for sure now is that the readme really needs some serious work.
In this case 'QueryStringAsArray' wouldn't be called as method, it's a property: $obj-&gt;QueryStringAsArray; // not $obj-&gt;QueryStringAsArray(); Not sure why you would do this instead of defining the method in this case. 
Or a transition phase.
Are anonymous functions really closures if they don't close off any variables? Maybe I'm wrong, but I've always had the impression that the PHP documentation incorrectly uses the two terms interchangeably.
Our UofR [class](http://ureddit.com/class/167) is ready, and we also have our own [subreddit](http://www.reddit.com/r/UofRIntro2PHP/). Join and let's start discussing format &amp; syllabus.
I must admit I am interested in that, just that my time schedule is actually really really horrible. I wouldn't want to let anybody down in group work, so would it be a problem if I just am lurking and work on my own time schedule?
Ah good, I was hoping someone would say Python because I've had this strange desire to learn for a while now because I've seen some excellent uses for it off-line as well as on.
No problem at all. 
So I just follow the class subbreddit or is there something else I need to monitor?
&gt; Not sure why you would do this instead of defining the method in this case. ya me neither. thanks
 $anonFunc = function() { echo 'this is just a function'; }; $closure = function() use ($var) { echo $var; echo 'now this is a closure'; };
I make extensive use of anonymous functions wherever they make sense when developing in PHP, but one thing I do find annoying is the fact I have to type out "function" every time, which looks pretty ugly compared to other languages (having "lambda" even, or "fn", or "def" for example). It seems like anonymous functions at least could benefit from a little syntactical sugar to make code a little more pretty
Anonymous functions rock. In Javascript I use them everywhere. In PHP, well, we're not on 5.3 yet :) However, I do think that functions should be defined with the "function" declaration everywhere - regardless of whether they are anonymous or named.
I have clauses in my contracts that if they are going to give me props or spread my name, that they must refer to me as the "functionality developer", and must distinguish the "website design and layout" with the actual designer.
1. It is extremely hard to document how this would work functionally outside of a huge docblock that includes all the possibilities and their expected return type / value. 2. Its far to difficult to extend this functionality without a copy pasta of the entire method (huge no no) 3. Just don't freaking do it, ever. I would say just move it into a function and do a grep/replace.
Thanks for clarifying, that's what I thought. In this case, TFA is also wrongly interchanging "closure" with "anonymous function" but that doesn't make these examples any less practical. It's not a big deal, but it would be nice if PHP's documentation would get the wording right, so everyone else who follows their lead can as well. 
Have you checked the job ads and seen many that require PHP? Also consider MySQL and Apache. I like PHP and think it's great, but recently have gotten into IIS/ASP.NET/C#/SQL Server and enjoyed the tools Microsoft has very much. A lot of job ads seem to require those. I would generally go by what you see in the local want ads, though PHP in general is a solid choice if you want to start learning. Have you worked with JavaScript frameworks such as jQuery, along with Ajax and XML? I've seen those are in demand lately as well. 
I would absolutely consider PHP a good starting point. It's free to scale up to infinity and its job trend is increasing at a far faster clip than C# or Java, and it's already ubiquitous, for very good reasons. The trick is finding a mentor. I'll mentor you for free, if you want. From absolute beginning to your first $40/hr gig, assuming you have what it takes to be a programmer.
Do you get paid, or not?
Genius.
I get this a lot. Some of the best code I've written looks like garbage from the front end. I usually show off the code in interviews and don't show the actual live site.
SQL Server (my favorite Microsoft product) works fairly well with PHP too.
With regard to 2), whatever you learn, you'll still have to deal with clients who make you want to jump off a bridge. A different bridge maybe, but more or less the same deal. BTW, if you know JavaScript, PHP shouldn't be too hard.
no, go with Python or Ruby.
Not that craigslist is the best place to find programming jobs but php returns 3.5 times the amount of job postings in Seattle as python and ruby combined, and 1.5 times as many as .net Don't get me wrong I like python, but I also like getting paid.
doesn't matter, it's a horrible starting point for a programmer so if it can be avoided it must. also Python/Ruby jobs are better quality in overall and in detail.
I guess we'll have to agree to disagree.
Fair enough, I agree that consistancy is a strong point, but sometimes "function" just seems a little verbose. But I suppose in a way that is what makes PHP a good language (syntactically consistent, not so much with the std library..)
The argument against those stats is that it doesn't matter how many jobs are available, it only matters how many good jobs are available and how many candidates are qualified for those jobs. E.g. I'd rather be the only Python programmer for 10 good jobs than one of 1000 PHP programmers for 100 good jobs. I'm not saying this is the case, but obviously there are fewer Python and Ruby programmers than PHP programmers so simply looking at the number of available jobs isn't a full picture of the situation. For what it's worth, Ruby on Rails programmers in my area make a lot more than most PHP programmers. ASP.NET programmers seem to be a dime a dozen, although at the high end they are well-paid I'd hate to be a junior.
I've found that this is an issue with designers that want to offer "the whole package". They mainly do print and have no idea as to how the web works. They'll also hand you crap that is insanely hard to implement without Flash. Best solution is to avoid these guys.
This works: call_user_func(function(){ echo "Hello World!\n"; }); But if it's a one-off function, why make it a function in the first place?
To create a scope to work with that won't pollute any other space. Create some variables, use them to do work and then forget about it. Edit: I forgot to say thanks. Thanks!
Why not just use unset() on them afterwards? I have no idea of performance impact of closures, but I can't imagine they'd be anything but slower than plain vanilla PHP in this case.
So many stories I could share...
Unfortunately you can't. This is one of the things that php does wrong. For instance, the following code, which is even simpler than your example, is also not supported by php: new Whatever()-&gt;DoSomething() The whole concept is called 'dereferencing'. There seems to be some improvement in the next version (6.0 ?): http://schlueters.de/blog/archives/138-Features-in-PHP-trunk-Array-dereferencing.html http://fabien.potencier.org/article/18/what-for-php6 
I just had to give up on one because he was sending me things at the last minute then accusing me of not having "time management". This client has single handedly burnt me out of contract work. I wish I could tell more devs to steer clear of this stuff.
Yes! I vote for PHP because the tools to use it are simple, and you can start learning the basics with very little setup. Also because you already know what it is, and it was the thing you thought of first. You can learn others later, get started on one you know. Go download [XAMPP](http://www.apachefriends.org/en/xampp.html) to run a server locally, and write a [Hello World](http://en.wikipedia.org/wiki/Hello_world_program) page. Then make it write the current date to the screen. Then break it horribly and learn the error checking tools. After you've got some basic stuff going, find a popular open-source project and learn that. Wordpress is PHP, and easy to start digging into. There's a lot of people out there using it, and a lot of different tutorials to get you going. But whatever you decide to start learning with, go into it with the understanding that it should be one tool in a toolbox. No language is perfect for every situation, and with some experience you'll learn how to determine what to use for what purposes. But yes, learn PHP! It's a great start.
It's not limited to outside designers. One of the problems (at least for us) is that our clients are cheapskates. The code has to work, so the design time is where it gets cut. No one wants to pay for the amount of time it really takes to make a site look good, but it's the first thing they'll complain about (ignoring all the functionality). I've "designed" and coded plenty of sites that I can't show to people.
Contract work can be the devil's paycheck.
All they had to do was drag a few things around in Photoshop - it can't be THAT hard?! Ugh. Even if you get consultation time with the designer, you'll spend inordinate amount of time explaining why you can't use some random commercial Mac font or that users can resize the width of their screen. Don't even start with SEO or why it looks the way it does in IE5. My stomach is getting upset just thinking about it.
This, this, a thousand times this. PHP, as much as I love it, has a pretty 'noob' community and really nothing inherent in the language that pushes you towards making 'beautiful' or 'elegant' code. Go learn a more structured language (Java, Python, C#) - and learn it well. When you come back to PHP and bring all that knowledge with you, you'll write much better code. Once you've done that, spend a bunch of time on Wikipedia reading software engineering articles. For example, the [singleton pattern](http://en.wikipedia.org/wiki/Singleton_pattern) is probably one that you will end up using at some point. The [Model-View-Controller Architecture](http://en.wikipedia.org/wiki/Model–View–Controller) is pretty big on the web. You've got internet access - you don't need to memorize all of the stuff on there. Just read them, know they're there, and pick up a bit here and there. I honestly don't believe you'll ever learn to write 'elegant' or 'clean' code without some background in another language. Get on it! Edit: Oh, and despite what people say - don't pick up a framework right now. You likely don't know enough for that framework to really be any more than a black box. You won't be learning to program properly, you'll be learning a framework. Learn the concepts (infinitely more important than languages, really, just easier to learn in another language), write your own code until you're comfortable with all of the concepts, **then** go pick up a framework.
Transparencies, EVERYWHERE! Also it needs to work in IE6. RAAAAGGGEEE!!!!!!
Please provide evidence that Python/Ruby jobs are better quality. Seems like you are just a fan boy.
You're asking in the wrong subreddit.
Good Ruby and Python developers are like gold dust, in Berlin, where I live, Ruby developers earn around €500 a day, PHP developers €300. Same situation in London too.
I do both Ruby and PHP development professionally. Ruby work is generally of a higher quality, better spec'ed, worked on by people with more intelligence and better paid.
And they'll look at you as if pointing out technological limitations is somehow your fault. You obviously came up with the HTML specifications, wrote IE, and are the reason their clients don't have the same 30" Apple Cinema display they do.
"Computer Science is as much about computers as Astronomy is about telescopes." Computer Science will show you how to use math to 'prove' your program correct and other 'science-y' things. If you wanted to go to school, you'd want Software Engineering or something a little more grounded in reality. Oh, and I think you'll find as you start getting better at writing clean code, code re-use will become a lot easier and more realistic - and that overtime may just no longer be necessary. We two programmers here - one working 16+ hour days, another working 8. The one working the overtime sounded like you as far as skill level goes. When they both left and they hired me, I took over the workload in comfortably slack 8 hour days (it was a bit rough at first cleaning up a lot of the garbage, but once I got over the brunt of it it was smooth sailing). Once you hit that point, you may find you have time for some school :)
Even worse - their 16 year old nephew who took a class on html in highschool and has a blogger account. 
Personal experience isn't concrete evidence. He made a pretty large claim that I am pretty sure he pulled from his ass. As a redditor that has been here for over 1 year I think you would expect someone to provide evidence or facts on how it the jobs are "better quality overall and in detail". Overall there are a lot more PHP positions out there ("http://regulargeek.com/2010/08/18/web-scripting-programming-language-job-trends-august-2010/"). Sure some of those jobs are going to suck. But many are going to be great jobs as well.
User-defined function calls have traditionally been very expensive in PHP. However, I haven't done any benchmarking on this in years, so please apply a proper amount of salt.
I recently had to get on our designer's case because he kept giving me transparent gradients in content boxes that have to resize dynamically to the content. It's not that I can't do it, but it's really fucking hard.
Any advertisement is good advertisement right? The key to not let you hit you in the face is to have a list of what you do on certain sites upfront. Tell people that you didn't do the design.
I don't doubt it, but there aren't as many jobs for ruby/python devs here in the States. There are jobs, but not as many. Remember this guy is just starting out, he's not likely to get a job right away doing that kind of work.
I agree. The entire structure should have been rethought to adopt the new methodologies made available by the language shift. The ZF guys got this right for their upcoming 2.0. Codeigniter's calling itself 2.0, yet performing the cut-off for PHP4 at 2.1. Do they not understand the meaning behind release numbers? They're _kinda_ breaking backwards compatibility at 2.0 and completely breaking it at 2.1.
Well, PHP won't allow you to call "new Whatever()-&gt;DoSomething()" but it will certainly let you chain method calls together. Check this out: &gt;class foo{ public $text = ''; function bar(){ $this-&gt;text = 'bar'; return $this; } function getText(){ return $this-&gt;text; } } $foo = new foo(); echo $foo-&gt;bar()-&gt;getText(); 
Well, that's a lot of unset()'ing depending on how much work I have to do. Sometimes, like when using auto\_prepend\_script's, it's just nice to do some work (preparing $_SESSION or whatever) without leaving any mess behind. Edit: Escaped underscores. Why can't Reddit use magic\_quotes\_gpc? 
1. I would have liked an example of the output (to see exactly what you mean). 2. How hard was getting that .in vanity URL?
Because reddit uses markdown syntax, which uses underscore pairs to mean _italic_ font. :) And it's particularly strange/funny with reddit URLs.
A lot more positions doesn't say anything about the ratio of developers to work. I don't doubt that there is less Ruby work out there, but there are even less Ruby developers.
You could just make a Factory function. Construct("Whatever")-&gt;doSomething(); function Construct($className){ if(class_exists($className)){ return new $className(); }else{ throw new Exception("UR BAD"); } }
&gt; It's free to scale up to infinity What in the hell are you talking about.
30 seconds of googling yields a couple of salary estimates for [PHP](http://www.payscale.com/research/US/Job=PHP_Developer/Salary) as opposed to [Ruby]( http://www.payscale.com/research/US/Job=Ruby_Software_Developer_%2f_Programmer/Salary) developers that jive with personal experience and anecdotal evidence, but even given that we're sitting on r/PHP, this part can't really be terribly controversial.
try to think how designers feel. we get handed the same old story about how they wish they could do more for us but there just isn't enough money or time in the budget for our work. i know you guys must get it too... you are probably getting the people who accepted the paltry pathetic budgets and you got the design to prove it. also those designers who are inconsiderate to you guys are usually inconsiderate to other designers. when we do get their live files, its utter crap. you have to spend 15 minutes putting things in proper folders in photoshop, naming layers and fixing clipping masks. and most of the time their work is so ugly you don't even want to try to *fix it*
the reason is simple: the quality of the code, which is directly proportional to the quality of the community as a whole. the reason there's so many jobs postings for php is because its community is the largest, not the other way around. employers prefer languages where they have many choices to hire from (so they can hire the cheapest and don't worry if they leave) they don't like languages where people is scarce and knows its worth, they don't care or even know about the code but you as a developer know them very well. even being the largest community the average skill of the php programmer is pretty low (and if you argue on this I'll call you a troll), the reason for that is the low entry barrier everyone knows and that's exactly the reason php is a bad starting point, there's too many pitfalls so in order to be a Good php programmer you better learn about good coding practices and proper style and *then* you can go into php otherwise you'll learn the wrong way and sunk even more the level of the community.
it's ok, it's just my opinon. if you're interested [here](http://www.reddit.com/r/PHP/comments/dthao/i_want_move_away_from_design_and_into_development/c12t5f5)'s a bit more of explanation about it.
As a Designer that actually knows AJAX and C#, amen dude.
That's exactly what I was thinking. Now php isn't worthless, in fact, I think it fits perfectly in many of it's applications. I thought it would be a good suggestion for him to learn first, because he'll make his stupid mistakes where it's expected and it will help him realize how much better a language like python is when he gets to it. Plus python seems to be used for more higher end projects which he is unlikely to get off the bat.
I wish there were more of you out there.
Yet oddly enough, `__toString()` is the only class function that will work straight off the assembly line. I don't get why that's the only one. Edit: With that said, I think I just found a way to prove you wrong. class Test { function do_something() { echo "you're doing something"; } function __toString() { return "a"; } } ${(string) $a = new Test}-&gt;do_something(); Gives "you're doing something". Doing something very wrong and unnatural. More wandering down the rabbit hole.
It's not that hard. Just hang the gradient on top of a solid background which matches the bottom of the gradient. Set the gradient to no-repeat, then when/if the need to stretch occurs, only the solid background will show. This is multi-column and ie6 friendy.
1. I'll update the post tomorrow. 2. $8 at godaddy.com
This is why I learned to program on my own after I finished design school. As a designer, I didn't want my work associated with shitty programming. I wanted total control of my sites, especially if they were going to end up in my portfolio. Plus, employers are looking more and more for designers who can also code. I can build a site from design to HTML, CSS, jQuery and some limited PHP. It's a hell of a lot of work to do it all, but it does feel good when the project is complete to know that the entirety of the site is your own creation. Now, if I could just convince my boss that since I'm doing the work of two people, he should pay me the salary of two people.
*Everyone* has a client.
IMHO, PHP is a complete mix between procedural and OO, all depending on author's preference. And a class's methods are all procedural once you get down to defining them. So PHP really isn't the best for proving OO theory, but still it lets you do some nifty OO concepts.
**Yes:** 1. Easy to find work 2. Knowledge / answers are easily and freely available. 3. Extremely low barrier of entry. **No:** 1. PHP work, by and large, pays less than any other language. 2. The vast majority of free resources, tutorials, guides, etc. for PHP are either hilariously incorrect, full of bad practice or just plain wrong. 3. There's a precious lack of standards, usage of good practice, or other normalizing factors from project to project; most FOSS projects are terrible code. 3. The PHP community is disjointed and disorganized. 3. You *will* get mocked by other developers for using PHP. 3. Lack of any good resource for learning short of trial and error (e.g. there are great Python/Java/C books, but nothing quite worth investing time and gambling your career for). 3. A marked lack of sophisticated tools (IDEs, build managers, etc.) that other languages enjoy I'm sure there's more for both columns, but this is what comes off the top of my head. I used PHP as an entry point because it is easy to find a job writing PHP, but jumped out of it as soon as I could because of the pay difference and the mind-numbing stupidity that so often defines popular opinion in the PHP world (e.g. abstraction is bad).
Closures just become an instance of a special private internal class (Callable, I believe), so there's no more overhead than defining a class with a single method and then calling it (e.g. negligible amount).
While that's a valid workaround, having to create a factory and pollute the cleanliness and readability of your code to compensate for a deficiency of the parser is still a net loss.
Probably that you could have a million servers running it and its still free.
All the time! I would rather buy designs and graphics online for $5 a graphic and say $30 for a template than wait 2-3 weeks for a crappy design (that i know is going to be bad) come in and have to work with it.
We'll start with the subreddit and go from there... Anything you'll need to know will be first posted on the subreddit.
Something about PHP just brings out the trolls in droves, even if mentioning it in passing. I can't quite put a finger on why.
Were you implying I was trolling? I wasn't, these are my experiences with both contract and full time work.
Mediawiki is also PHP. For certain tricks and hacks to improve the user interface (ie blacklisting/whitelisting certain html tags in articles, using ldap or a different mysql source for user authentication), you'll need to know at least a little bit of PHP.
I suppose that is a valid point, although I would have phrased it rather differently. The million servers and the people smart enough to deal with them, after all, do not come gratis.
In your mysql query, you would want to do an inner join on id. So select a.whatever, b.whatever from users a inner join orders b on a.Id=b.id where conditions.
No, not at all. I agree with your points. Sorry, I was referring to this: &gt; You will get mocked by other developers for using PHP. &gt; The PHP community is disjointed and disorganized. And how even the slightest mention of PHP anywhere, including Reddit, and even by sharing simple code for public scrutiny, brings heated argument. Some people just seem to get rabid or superior about PHP, either by hating it or loving it just a bit too much.
[Here is a simply explanation on how Relational Database work](http://computer.howstuffworks.com/question599.htm)
You missed the transparent part. You can't overlap like that when you're dealing with translucency because you'll double the opacity of the box anywhere the two images cross. It also doesn't allow for the gradient to fill the entire space. There's three ways to do it. The easiest is to use the CSS3 background-size attribute, but that doesn't work in IE so it's pretty much out. The second is to use one or more absolutely positioned images that stretch to fill the box accordingly, with a relatively positioned content layer z-indexed above it. The third, and the one I used last time, was to have the designer recreate his gradient as two separate images of lower opacity that would blend together to create the correctly appearance. The lower one was repeatable to fill the entire space and the upper one was a stationary image.
Yeah, cool, but first thought looking at it is "why doesn't he explain what he means by 'making it a tree'?" Looks like it makes a hierarchical associative array. But yeah, the description of the article reminds me of one of those comments like, "// make $i bigger by 1" before the line: "$i++" ;)
Ah yeah, I see what you mean. My personal opinion is that it's a combination of the programmer superiority complex, the fact that PHP is actually quite a bad language by most standards, the fact that it enjoys so much success when other languages might seem more deserving to some people and the public front of PHP (those terrible guides, blog posts, etc.). When I was big in PHP (I still do 20+ hours of it a week but do Java full time and I get just as much flack for that - some from the PHP people who you'd think would learn), I just tolerated it knowing that PHP was the only language I could assimilate into (let alone be successful) and launch a career being almost entirely auto-didactic. There is some quality code out there and quality developers writing it, it's just hard to find because the torrential amounts of idiocy surrounding PHP that defines most peoples' perception of the language and its community.
There's a huge demand lately for Drupal developers, specifically. Drupal's a "content management framework" written in PHP, called that because while it has tons of great CMS features it's built in a way that makes it a pleasure to use as a web application framework -- indeed that's what I do for a living every day at the company I work for. If you learn to build sites in Drupal and enough PHP in order to be able to implement some hooks and do theming work that requires altering markup structure and such, you should be able to find a good job at a Drupal agency. The local Drupal Users Group here (Portland, OR) is *always* full of people looking for Drupal talent. There just aren't enough skilled Drupal developers out there at the moment.
&gt; Sockets Oh god, here we go. Yes, you can make a complete and versatile server of just about any kind using nothing but PHP. Just remember to parse the difference between GET and POST requests, and to learn what headers are supposed to look live vs what some malicious a-hole client gives you. I'm beginning to like this guy.
nice
So this seems to be working. It was easier than I thought SELECT faq_id, company, question, answer, date, status FROM `faq`, `users` WHERE faq.author = users.id
It's a companion to MySql and HTML. I treat it as the new BASIC. It's easy to learn the basics, fun to learn the more advanced, does all sorts of neat crap, and allows folks to do very unnatural and powerful things. And, probably not the best overall solution, but it's a quick Google or PHP doc keyword search away from getting any job done in minutes. Bottom line: although you can make a reliable heart monitor or proper unit conversion class capable of safely landing a machine on Mars in PHP, it's catered and marketed actively, by both PHP devs and the entire user base, to folks who just want to print HTML. Has anyone ever heard of an "HTML Developer"? Yeah, well, that's the class of people PHP caters to. It's sad, because PHP does so much more than that. I know a lot of PHP users eventually realize this, but this is the niche they're stuck in.
&gt; Bottom line: although you can make a reliable heart monitor or proper unit conversion class capable of safely landing a machine on Mars in PHP, it's catered and marketed actively, by both PHP devs and the entire user base, to folks who just want to print HTML. Just nit-picking, but as far as I know, PHP has no realtime facilities. Joking aside, I do disagree with PHP outside of the server side scripts because of performance (I have seen several benchmarks placing it an order of magnitude behind python/ruby and two (in one case, three) orders of magnitude behind Java/C), the memory consumption (with properly configured GC, Java is even lower, because of the overhead memory usage of arrays and object) and the lack of any sort of threading capacity or any other asynchronicity. I'm also not of the opinion that PHP is a great first language to learn because of the culture of half-assedness that surrounds it and the difficulty in separating the good from the bad as far as other code, tutorials and the like is considered. I'm a bit jaded, though, because everything I hated about PHP is gone for the most part from Java and everything I liked is much better implemented (that's not to say that Java doesn't have its own set of problems, they're just more manageable than PHP's).
So, I created a benchmark. The following code is run: $GLOBALS['loop_times']--; if( $GLOBALS['loop_times'] % 1000 == 0) { print "."; flush(); } First, it's run inside of a while loop alone. Second, it's put into a function, and the function is called from a while loop. Third, it's put into an object method, the object is created, and called from a while loop. Fourth, it's put into a closure. Counting down from 1,000,000, the bare while loop takes 0.68-0.69 seconds. The function call takes 2.0-2.1 seconds. The method call takes 2.2 to 2.3 seconds. The closure also takes 2.2 to 2.3 seconds. So, one million function calls, on my local machine, introduces an overhead of 1.4 seconds. An interesting thing happened with the closure. Here's the original form: $anon = function () { $GLOBALS['anon_times']--; if( $GLOBALS['anon_times'] % 1000 == 0) { print "."; flush(); } }; When I modify it from a plain old anonymous function to a real closure and get rid of the globals reference like this: $anon = function () use(&amp;$anon_times) { $anon_times--; if( $anon_times % 1000 == 0) { print "."; flush(); } }; then average execution time drops to 1.8-1.9 seconds. Clearly the globals hash lookup has some expense to it. I wouldn't expect otherwise, it's being called a million times. Conclusion: Function calls have an overhead, but unless you are quite literally performing one million of them, you're probably not going to notice. Method calls and anonymous functions are very slightly slower. Referencing globals may also impose a minor penalty.
I can't decide if I like this stuff or not. On the one hand, it's a nice concise example. On the other hand, it's such a trivial example that there's practically no utility to it. It's perhaps marginally better than reading the [docs](http://us3.php.net/manual/en/sockets.examples.php), but not by much. But I'll up-vote it because there are a pair of earlier posts on the site about doing process-control stuff, which you'll generally need if you want to create any kind of actually useful socket server.
That's more of an HTTP discussion than a Sockets discussion.
That helped a lot. Thanks.
You should link to tests to allow for second opinions. But otherwise, yeah, that's why I called it the "new BASIC". Which is why I'd actually personally recommend it for a first or second language.
Gawd yes. I need to write up a one-pager to warn clients about doing up-front design. 90% of the time, you're better off doing something with a developer, in "black and white" until it all works. Then you go find a developer who can grok what's going on, and have them pretty it up. The results are almost always better than trying to do "specification by photoshop"
I've recommended [SQL Clearly Explained](http://www.amazon.com/SQL-Clearly-Explained-Jan-Harrington/dp/012326426X) to several people, and they've all thanked me. It's a clear, fairly concise, explanation of the fundamental concepts behind relational databases. It aims to provide a nice foundation, and doesn't distract with product-specific info, nifty tricks, etc.
Hrmph. My problem at work is not being allowed to automate their processes and write/clean up code as appropriate. Somehow I just don't understand how having someone copy and paste things from one excel spreadsheet to another is a good use of anyone's time.
It's a server discussion, really. I'm just mentioning port 80 in particular. After doing some socket stuff like in the link, you might find that HTTP is often nothing more than a recommended standard of organized text. Making an HTTP server in PHP, you have to parse request headers and bodies yourself. But yes, one should study up on the [HTTP standard](http://www.w3.org/Protocols/rfc2616/rfc2616.html) to know exactly what needs to be done to handle normal requests. On a side note: at least with straight PHP, unlike Apache, you get to set the "Server" header to whatever you feel like. Hell, lie and say you're using the same "'; DROP TABLE servertypes; --" server software that Reddit is using.
Slight rant here, this is my big problem with a lot of other developers I have met. DB design is absolutely crucial. Data needs to be clean, easy to access and normalised. Good SQL can reduce the amount you need to code by a lot. Please note, I'm not ranting at the OP. He/She saw a hole in their knowledge and sought out further info. That's awesome. 
Did someone say *r/trees*?
PHP is simple, with lots of documentation and a really large community. So it is a great language for beginners. However, beginners should realise the bigger picture - PHP's lack of structure (unless using a framework of some kind) and general looseness means that it is a good idea to learn other languages soon afterwards.
There's actually a HTTP 1.1 compliant web server written entirely in PHP: [Nanoweb](http://nanoweb.si.kz/). Of course, no important website uses it in production. Just because it's possible it doesn't mean that you should do it... Clients are a different story though. Socket clients are not difficult to write, and they're a great way to understand how certain protocols work under the hood. Try writing a Memcached or Redis client in PHP, it's fun. Anyway, I also think I'm starting to like this "dark arts" series somewhat. These things are usually not written about in any detail.
Interesting numbers there. Have you tried using $anon = function() { global $anon_times; $anon_times--; if( $anon_times % 1000 == 0) { print "."; flush(); } }; instead of forcing a hash lookup? (I guess the performance will be about the same as the `use(&amp;$anon_times)` version, but who knows?) Also, you can eliminate the global entirely by using a static variable inside the function: $anon = function() { static $anon_times = 1000000; $anon_times--; if( $anon_times % 1000 == 0) { print "."; flush(); } };
[Github's version of Markdown](http://github.github.com/github-flavored-markdown/) ignores underscores inside words. It's probably better suited to programming, so non-programming subreddits might not appreciate it.
Yeah, MySQL will actually rewrite that internally as: SELECT faq.faq_id, faq.company, faq.question, faq.answer, faq.date, faq.status FROM faq INNER JOIN users ON faq.author = users.id (if there are multiple tables involved in your query, you should make sure your field names explicitly identify which table they belong to. alternatively, you can use faq.* to select all fields in faq) This query will return all faq rows with author fields matching any user id. You should learn the JOIN syntax since not all RDBMSs will support your syntax.
You can do that in Apache as well, just add `ServerTokens MyFancyWebServer` to httpd.conf or your vhost. Edit: You can also do it via a simple `header('Server: MyFancyWebServer');` in PHP.
You would be amazed how many ridiculous issues are in there. People have not read the modern classic: http://www.chiark.greenend.org.uk/~sgtatham/bugs.html
As I said, they have commercial products running on this framework so a total "PHP 5 rewrite" would set them back in the stability of their products. What would that achieve anyway? I have autoloaded classes, static libraries, PHP 5 syntax throughout and there is a PHP 5 base class that is used instead of the PHP 4 base class. I don't give a shit about namespaces and we can add in things like validation calbacks using closures as we go. 2.0 is a massive change yes, but not a pointless change. PHP 4 support is basically gone (they aren't checking anything, they dont give a damn about it now) and they have all those PHP 4 support features marked with a #php4 comment tag. That means in 2.1 they will run around finding those tags and deleting the functionality. If people are still using PHP 4 by then? Well they were warned! :)
A couple of tips: - Write quotes with double quotes, because you use single quotes in SQL statements more often. - I always use prefix column names with the table name eg. customer\_id, customer\_name, customer\_company\_id, company\_id. This is so if you join customers to companies and put the results into an array you don't have two conflicting columns named "id". It also makes it clear what table the variable came from eg. $row['company\_id'] vs $row['id']. Others will disagree with this, and there are workarounds (eg using "AS" in the SQL) but it makes life so much easier and clearer longterm.
Yes, and there should be an [RFC](http://wiki.php.net/rfc) for something like: new Whatever-&gt;doSomthing(); (new Whatever())-&gt;doSomething(); The parentheses is to avoid ambiguity with: new (Whatever()-&gt;doSomething());
I was pretty torn when writing the article about how complicated to make the example. I had thought it would be fun to make some sort of token-ring, where I can pass a value around the ring until is gets to X, then dismantle the ring. The problem is that any FUN example with sockets it going to be sufficiently complex enough to alienate a lot of people. I decided to go with the super-simple example so that people can get exposed to it and not get scared off. 
do both?
No, tree. Close though
I've updated the post with an example of the input and output.
&gt;So, one million function calls, on my local machine, introduces an overhead of 1.4 seconds. I think I can live with 1.5 millionth of a second overhead :) PHP is *fast*. Interesting stuff though, especially re: $_GLOBALS vs closing the variable. Thanks.
Both would be nice. I would like to learn more without reading dull and tedious documentation.
Does anyone have any experience with both this and Wordpress that can do a compare/contrast?
Thanks, so I guess I will follow that subreddit.
&gt; honestly, lots of people spend a entire semester (or more) of university on this topic. This is very true. Before college I'd been programming before but never touched a RDBMS (yay for storing stuff in CSV). Ended up having two semesters dedicated to learning SQL and I was halfway through the second before it just clicked in my head and made sense. I struggled with it a long time and now I look back and have a hard time remembering why that was. You can expect to learn it over night, just start with the basics and keep working at it and eventually it will start to make sense for you. Then again, I know many programmers who never really seemed to figure it out.
I'm sure I'll get some flak for this but I'd recommend playing around with MS Access and either designing your own DB or going with their standard northwinds database example. They have a relationship viewer (well, they used to so I'd assume they still do) that was really good at laying it out in a way that made sense. I think SQL Server does it too but there's so much extra stuff in SQL Server to distract you that I'd stick with the basics until you figure it out. Access is an extremely shitty DBMS but it's also very simplified and made the learning process much simpler. I would not recommend using their query designer though. One may think they can learn something by visually creating a query then looking at the code it generated, but I can assure you it will do it in the most confusing and obscure way possible. 
I just use "/src/ClassName.php" for all of my classes and leave the rest of my procedural on the root.
I had never heard of this one either, thanks my little bottle of advil.
I made a complete IRC client out of PHP. http://sf.net/projects/phpegg That was **way** back in the fucking 90s. Project largely stopped by 2003.
Strangely enough the first thing I ever built with PHP was a program that used sockets. Hell of a confusing thing to start with.
Any useful/practical applications for this? There seem to be way better tools at handling sockets than PHP.
You're over-engineering. What advantage does creating all these objects give you over just loading your data with a single query and formatting for display?
 $sth = $this-&gt;pdo-&gt;prepare('SELECT ip FROM kills'); $this-&gt;kills = $sth-&gt;fetchAll(PDO::FETCH_CLASS, 'kill'); im kinda rusty, but would that work? 
oh. i totally misread the question. ignore me.
It seems to me that a `file_put_contents()` and `file_get_contents()` communication between HTTP hosts might be a better way to do socket communication than this technique. Another couple routes are XML-RPC API in PHP and SOAP API in PHP because then you just interact with objects directly between servers, rather than having to handle the communication layer API logistics.
The only place where I get mocked online for using PHP is, well, on Reddit. I don't have that issue on StackOverflow, Devnet Forums, WordPress forums, and so on. Facebook runs their company on PHP, and get a ginormous amount of traffic, although it's a compiled form of PHP now. WordPress, an immensely popular product based on the stats, as well as WordPress.com traffic which is also very high on Alex stats -- these things run on PHP too.
PHP 5 has a new set of [Stream functions](http://www.php.net/manual/en/book.stream.php) which are IMO easier to use than the old socket functions. Using streams might have made your examples more familiar to those who already know how to use fopen/fread/fwrite/fclose. I know that stream\_socket\_client works very well. I'm not sure about the server functions though; there's an old comment that suggests some sort of buffer problems.
Switching from $GLOBALS to the global keyword makes the run take 2.0-2.1 seconds on average, slightly faster than using the hash lookup method. The benchmark script worked by having the function modify a global. Declaring the time counter as a static variable inside the closure prevented any outside reference to it. I added a return statement to the static closure. After doing so, it also takes 2.0-2.1 seconds to run, on average about 0.05 seconds faster than the global keyword version.
Why don't you use the `$class_name` parameter of fetchObject() to load data directly into your Kill object? That would be a lot more efficient than creating an object, creating anothe object, and loading the data from the first object into the second object. But by all means, just do a join.
Yes, this kind of problem is exactly what oo struggles with sometimes. I just like to return arrays and not use that kind of oo.
There are two common patterns here that you can use. The first would be changing how Kill::load() works. Split it into three methods: public function load($id) { $sth = $this-&gt;pdo-&gt;prepare(...); $sth-&gt;execute(array( ':id' =&gt; $id )); $this-&gt;loadFromArray($sth-&gt;fetch(PDO::FETCH_ASSOC)); } public function loadFromArray($data) { foreach($data as $k =&gt; $v) if(property_exists($this, $k)) $this-&gt;$k = $v; $this-&gt;init(); } public function init() { if(isset($this-&gt;data-&gt;attacker)) { // Load the Player object here. } } This method doesn't translate well into your current use of your objects. Normally, fields from the database are simply placed into properties, while you are sticking them all into a single properly that is itself a stdClass. This is weird, and you should consider changing it. What this will let you do is fetch the complete record for the Kill inside Killboard and instantiate each object without it doing it's own query. This may save you a bit of load time. A second thing you can do is look at caching. Make your constructors protected and add a static method to each class that is responsible for creating new instances. This static method can check one or more caching methods before creating a new instance. You can cache for just that one script call by referencing a global. There's also APC's shared memory caching and larger solutions like memcached. A critical part of adding caching is knowing when to invalidate cache entries. If all of your objects are also responsible for saving themselves to the database (in the same way they're responsible for loading themselves), and *nothing else* would ever modify that object's table, you can easily add cache invalidation in the save method. Now, all of this being said, you don't need to change a thing. Are you encountering a performance issue right now? If not, don't change a thing, your design isn't incorrect. If you are encountering performance issues, use a real profiling tool like [xcache](http://xcache.lighttpd.net/) or [xhprof](http://pecl.php.net/package/xhprof), and then act on what it points out as the worst problems.
I've been mocked here, on other forums, on IRC, on a phone interview, and in person at a convention. Maybe my experiences are little less typical than I thought?
I'm guessing using the kill list in another context, for example, simply showing the id of the kills without fetching any other data. Of course, that's also simple: just a query, but he'll be creating lots of methods into the killboard class to fetch the data in different ways, and on each he'd had to wrap each item into an object, to maintain whatever OO functionality he wants.
[Yes](http://ibra.us/).
Separate database operation and object creation from the domain object. Real roughly, it's like this: class Killboard{ function loadKills(){ return Kill::Mapper()-&gt;findAll(); } } class Kill{ protected $attacker, $victim, $weapon, $timestamp; public function __construct(Attacker $attacker, Victim $victim, Weapon $weapon, $timestamp){} public static function Mapper(){ return new KillMapper() } } class KillMapper extends Mapper{ //1 sql stmt with victim,attacker,weapon joins private $_select = "SELECT ... JOIN ...."; private $_joins = ""; function findAll(){ $kills = array(); $sth= $this-&gt;pdo-&gt;prepare( $this-&gt;_select . " " . $this-&gt;_joins ); while ($data = $sth-&gt;fetchObejct() ){ $kills[]=$this-&gt;createObject($data); } return $kills; } function findById($id){ $sth= $this-&gt;pdo-&gt;prepare( $this-&gt;_select . "WHERE id = :id " . $this-&gt;_joins ); $data = $sth-&gt;fetchObject(); return $this-&gt;createObject( $data ); } //Separating object creation from data retrieval //lets you build objects from multiple sources (including previously executed queries) function createObject( $data ){ // we call "createObject()" on attacker's mapper with all needed data , which // doesn't do another query. $attacker = Attacker::Mapper()-&gt;createObject( (Object) array( "id" =&gt; $data-&gt;attacker_id, "name" =&gt; $data-&gt;attacker_name, ... )); // repeat for $victim, $weapon,: $victim = Victim::Mapper()-&gt;createObject(...); $weapon = Weapon::Mapper()-&gt;createObject(...); //then: return new Kill($attacker, $victim, $weapon, $data-&gt;timestamp ); #### passing the mappers as parameters might be more sane, eg: //function createObject($data, Mapper $attacker_mapper, Mapper $victim_mapper, Mapper $weapon_mapper) } } //Repeat same pattern for Attacker,Victim, &amp; Weapon. Class Attacker{} Class AttackerMapper{} //must have createObject() method Class Victim{} Class VictimMapper{} //must have createObject() method Class Weapon{} Class WeaponMapper{} //must have createObject() method //Then: $kill = Kill::Mapper()-&gt;findById(4); Check out the book, [PHP Objects, Patterns, and Practices](http://www.amazon.com/PHP-5-Objects-Patterns-Practice/dp/1590593804).
Apache will always override your custom PHP header, and `ServerTokens` only accepts [these info levels](http://httpd.apache.org/docs/current/mod/core.html#servertokens). Maybe there's something in [mod_headers](http://httpd.apache.org/docs/2.0/mod/mod_headers.html) or [ModSecurity](http://www.modsecurity.org/).
I came in here to say this. Coupling your database logic with your domain model classes is always a bad idea, as your objects should be able to initialize with just any data that conforms with an interface. Pull the database code out of the object and you'll be more decoupled and it will be easier to swap data sources, modify objects, etc.
Yep, and I can guarantee all the images are going to be chopped up in the least practical way possible, despite the directions I gave on where I wanted the images sliced :(
Aye, I want to wrap stuff as much as possible and minimise dependency, as this aides unit testing. For instance, my killboard class does nothing except load other classes and then combine their output - why would it need a database? If I just had the Killboard start spitting queries, it would need the db. I think that is unnecessary.
That does seem interesting though.
What?
&gt; they have commercial products running on this framework so a total "PHP 5 rewrite" would set them back in the stability of their products. Which is exactly why CodeIgniter is not the framework of choice if you're development large web applications. For small websites, it's not a big deal. You can use just about anything for those and it'll be ok. Design patterns are there for a reason. Namespaces have been added for a reason. When you're working with a huge codebase (or have to develop one), these kind of things **matter**. 
Sure, you want separation of concerns, but I still don't think it warrants this massive object graph you're heading towards. It's unnecessary complexity and overhead.
This is why I built "conditerators" into Tierra Templates (http://tierra-templates.com). The code above becomes: {@ array ? "&lt;ul&gt;" `&lt;li&gt;&lt;a href="{link}"&gt;{text}&lt;/a&gt;&lt;/li&gt;` "&lt;/ul&gt;" @} Much cleaner and the ul tags are only generated if the array variable has at least one element. 
The objects are not important in this problem, but the high amount of queries when only one does suffice. An example with the same problem: foreach ( get_id() as $id ) echo get_name($id); with get_id and get_name doing one query on each call.
I'd agree that making good, maintainable code is about getting the balance between abstraction and simplicity.
I like this idea. Essentially then I could have one query that is then pulled into objects once it is already retrieved from the database. Currently I'm using containers to make instances of more complex objects, so this might work well with it.
You're right, `ServerTokens` will at "best" give you a `Server: Apache` header. I stand corrected. According to http://httpd.apache.org/docs/1.3/misc/FAQ.html#serverheader you'll have to modify the source code in order to truly customize the server header, I'm assuming that's the case for 2.x as well. Thanks for the correction.
yeah really? here's the top three google links: http://www.tizag.com/phpT/fileupload.php http://www.w3schools.com/PHP/php_file_upload.asp http://www.quackit.com/php/tutorial/php_upload_file.cfm and the 5th, the php manual http://php.net/manual/en/features.file-upload.php if you seriously still can't figure it out, then i don't think you're going to.
For each class I have that basically holds database values, I gave it a method where data can just be pushed into it. That way I can get all the rows with one database select, and push each row of values into a separate objects, all with one query. The class can also be told to get its values from the database. 
A pretty simple case. i.e. http://www.quackit.com/php/tutorial/php_upload_file.cfm Other than handling the form and writing the logic for handling the posted file, the only thing you really need to worry about is naming and moving the file uploaded from your tmp directory (http://php.net/manual/en/function.sys-get-temp-dir.php) to a permanent directory. 
What I meant is there is some discussion about the general scripts not having much security features, which is of concern to me. I've seen those links before, just looking for something a bit more secure. Thanks for your reply.
I did that, and I've seen the links from cephyn. I was looking to make those general scripts more secure. Perhaps a captcha or member registration should be added. Hmmm. It's not that I can't find how to do it in general, just looking for some thing more security conscious. Perhaps my description was not very well worded. Thanks for taking the time to reply. 
The best place to start is probably the [official documentation](http://us.php.net/manual/en/features.file-upload.php) - it covers the subject quite well. 
That makes sense. I will do that from now on.
1. I dont understand it, I would have to learn the language you created 2. This adds overhead So i would have to spend time to learn your template language just to add overhead, all the while php can do this just fine. Not to mention i think the php version looks better.
Use `is_uploaded_file()` and `move_uploaded_file()`. Sanitize the filename using `basename()`, and also use a ctype function or some regex to remove anything other than a-z, 0-9, hyphen, underscore, dot, and a handful of other safe characters. Never save uploaded files in a location that is accessible directly from the web. (If somebody uploads a PHP script, it could be executed on the server when accessed!) Use a DB to manage uploaded files, and force users to go through your script to access them. Always use `readfile()` to send files to users, unless you have x_sendfile or something fancy like that. Make sure image files actually contain images. If possible, check for viruses using something like ClamAV. 
filter by mime type/ extension, convert image files (gd2, imagick) and save the converted file, then unlink() the original. For other instances, there are some AV you can use on the server. If it's a text file, you could filter it against css and save the filtered version. There's not one answer. You take different measures for the files you are expecting.
Are you looking to make public uploads? Otherwise definitely your first step is to create a members only upload page. There are a few ways to make it more secure. Using s database to store what fields have actually been uploaded is a nice step. This way your programs knows what and where all the files can access them from.
Thanks! I'll look into it.
Thanks for the constructive feedback.
thanks!
Interesting. Thanks a bunch.
Try looking into [Zend Framework's File Transfer class](http://framework.zend.com/manual/en/zend.file.transfer.introduction.html). It has built in validation which can help with your security concerns. I don't use it that often as I don't make file upload forms, but it is pretty useful.
I've implemented your solution, seems to work pretty damn well: http://github.com/radiosilence/trouble/blob/master/trouble/kill.php http://github.com/radiosilence/core/blob/master/core/superclass/mapping.php Any tips?
excellent, thanks!
Another question. How would you adapt this mapper to saving?
Aye but how do you handle joins? I propose something like this (drunkenly hacked up): &lt;?php class Join { private $parent; private $child; private $child_alias; private $child_fields; public function __construct($parent,$child, $child_fields, $child_alias=False){ if(!$child_alias) { $child_alias = $child; } $this-&gt;parent = $parent; $this-&gt;child = $child; $this-&gt;child_fields = $child_fields; $this-&gt;child_alias = $child_alias; } public function get_left_join() { return sprintf('LEFT JOIN %2$s %3$s ON %1$s.id = %2$s.id', $this-&gt;parent, $this-&gt;child, $this-&gt;child_alias); } public function get_fields() { $fields = array(); foreach($this-&gt;child_fields as $field) { $fields[] = sprintf('%1$s.%2$s as %1$s.%2$s', $this-&gt;child_alias, $field); } return $fields; } } class Car { public function get_dragster() { $joins = array( new Join('cars','wheels', array('diameter', 'manufacturer'), 'rear'), new Join('cars','wheels', array('diameter', 'manufacturer'),'front') ); $q = new Query('cars', array('make', 'model'), $joins); return $q-&gt;output; } } class Query { public $output; public function __construct($parent, $parent_fields, $joins) { $left_joins = array(); $fields = array(); foreach($parent_fields as $field) { $fields[] = sprintf('%1$s.%2$s as %1$s.%2$s', $parent, $field); } foreach($joins as $join) { $left_joins[] = $join-&gt;get_left_join(); $fields = array_merge($fields, $join-&gt;get_fields()); } $this-&gt;output = sprintf("SELECT %s FROM %s\n%s", implode(",\n", $fields), $parent, implode(",\n", $left_joins) ); } } class Wheels { } $car = new Car(); echo $car-&gt;get_dragster(); ?&gt; Going to sober up before I decide to implement it into stuff.
Unfortunately, he presented his point after the discussion had ended, so he doesn't get any points for it.
Is it likely to be used a lot and actually require some sort of high performance?
Where exactly might you recommend finding GOOD code to read? I'm in the same boat as Soylent...
EAV is a hack, and it more or less violates relational algebra.
What would you propose instead? 
sqlzoo.net - Go there! Live, interactive tutorials. They will teach you the concepts one spoonful at a time before combining them together. The best part is that each section has a quiz. The quiz lets you write real queries against a real database server. You pass or fail each answer based on whether or not you pulled back the proper result set. I can't emphasize this site enough!
I'd like to add that sometimes organizations will let their DBAs design the data storage to ensure consistency. It's not a bad idea, especially if you haven't been around this block a few times yourself.
He's saying he's a noob and doesn't understand the code.
Interesting. I never knew the name for it, but I've had to do this in a number of places where I need to assign an arbitrary number of attributes to some record in SQL. Beware: It can make for some "interesting" reporting. MySQL has a "group\_concat" function that works here, and Postgres has a number of options with its array datatype or their new function similar to MySQL's group\_concat. On SQL Server it was a bit more complicated because there was no built-in function for using data like this, but there are a couple of good options for getting your data. Edit: Forgot to slash my \_'s
It may be somewhat of a hack, but it's the proper solution for certain business problems. I'm not going back to modify this table, the application and its reporting every time you decide you have a new attribute you wish to store. Especially when the problem at hand concerns storing an arbitrary and yet-unknown amount of attributes. Fully normalized databases are not always the best solution.
&gt; have any of you experienced similar difficulties trying to use PDO -&gt; SQL Server Yes &gt; Has anyone else had better luck? No &gt; What types of solutions did you use to work around these problems? Switched to MySQL 
Thanks for your input. &gt;Switched to MySQL That's not gonna cut it here, even though open source (Postgres) sounds really tempting.
Yea PostgreSQL is great, perhaps better than MySQL. We just already had dedicated MySQL boxes so it was an easier sell. We've had no issues with any apps that were on Oracle, DB2 or MSSQL that are now on MySQL. 
&gt; Fully normalized databases are not always the best solution. Even more to this point, fully normalized databases don't scale as well as *de*-normalized databases.
Not the OP and don't believe EAV is really a 'hack', however if you have the ability to implement and support it: a non-relational (nosql) object/document oriented database will be a cleaner solution. However if your EAV models are only a small portion of your architecture it may not be worth it.
About 5 years ago, TDS was buggy. Ultimately I had to create a primitive message queue between an Apache web server (PHP) on Linux and Microsoft IIS (Active Sever Pages) on Windows. On the Linux server I used PostgreSQL. On the Windows server I used MS SQL Server. The data would move in batches every 30 minutes, with a recovery makeup job every 15 minutes if the data didn't move properly. It had error handling and recovery that I continued tweaking over that year. If a job didn't run after the recovery interval, all jobs would halt on the Linux server, data would collect in the PostgreSQL, I would receive an SMS message, and I would jump on the server to see what was up. Eventually it just ran without my intervention. We did this until we were ready to completely transition away from MS SQL Server and into PostgreSQL entirely.
Well, many of the apps we run only support Oracle, DB2 or MSSQL - often it's "pick one of two" and so MSSQL has worked out to be the best choice for us. It also happens to be a really nice database. We're putting in a lot of effort to consolidate our DB2 / 400 database into MSSQL as well. Trying to add a third database platform when we are trying really hard to use just one doesn't make a lot of business sense. But oh, how I long for decent Linux support.
But you're hosting the site on Linux? Why not switch to Windows and use their drivers, I'm develop on a Windows machine, and the newer mssql driver seems to be pretty stable so far. Again, I use it 1% of the time, so your mileage may vary. 
Out of morbid curiosity, why are you using Linux machines to speak to MSSQL? Microsoft has done a pretty good job working with the PHP folks to get the IIS+FastCGI+PHP (5.3) stack up to production quality. If you're already a MS shop, it might make more sense for you.
i have not switched to PDO yet because I use some "magic" code to make sql statements and forms from meta data. the getColumnMeta() method is still experimental and subject to change. http://www.php.net/manual/en/pdostatement.getcolumnmeta.php 
We've got a pretty good mix of technologies, so we're not what you would call a Microsoft shop. Linux, Apache and PHP are all very top notch software, and I personally am a bit of an open source zealot - why pay for bug ridden propriety crap where "free" does it better?
I do a bit of that as well, although I wouldn't call it magic. I also cache the metadata into a sub-class so I don't need to keep hitting the db for each instance I use. It's probably my favorite piece of code and makes form work a breeze.
You could try using jTDS and JNI so you can call the java functions through PHP.... personally though, I stay away form SQL Server unless I'm already using .NET or some crap.
Few random-ish thoughts: * Start looking at the code for open projects you like. GitHub and its relatives are great for this - if you hear about something neat, you can very often just clone the repository and fire up a text editor. Don't be afraid to dive into the code of big, mature projects. You might not know what the hell's going on, but trying to figure it out could teach you a lot. * Books like _[Higher-Order Perl](http://hop.perl.plover.com/)_, _[The Perl Cookbook](http://oreilly.com/catalog/9781565922433)_, and _[Perl Best Practices](http://oreilly.com/catalog/9780596001735)_ made a big difference for me a few years back when I was just starting out on programming as a full-time gig, because they're chock-full of concrete examples. * I did a few [Project Euler](http://projecteuler.net/) exercises the other night, and it seems like you could learn quite a bit by solving problems and then checking out other folks' solutions.
Looks great! I am pretty decent at SQL, but I never quite understood the whole views thing. Thanks!
We've considered that. Microsoft themselves offer a pretty good "official" JDBC driver as well. I'd be interested to know if you've tried it, and to what success. Ultimately, if this problem were big enough to force us into such a concoction, we would probably switch to running Windows rather than run a Java instance just to handle our database connection.
Nope, sorry. We use Geronimo/jTDS at work so it's all Java. My own web stuff I only use things that run on linux ;)
A view is simply a SELECT statement that's presented like a table. They're great for reporting or giving someone limited visibility to a larger set of data. They can selectively filter out columns and use JOINs and WHEREs, and can also contain a bunch of expressions that might be ugly to work with. So you could setup a handful of complicated views, then use them as a starting point for building reports since you can select against a bunch of filtered and pre-defined logic.
Cool. Phing still needs a lot more work. I've been using it as the delivery "engine" for our deployments, but still a lot of exec calls. It needs an rsync task, and the ability to work through gateways. In hindsight, I should have extended Phing, but I had limited time and was porting our older, script-based build/delivery systems. Hopefully I'll get a chunk of time soon to write a Phing task which calls rsync, though
I use Windows 7, WAMP, e text editor and Photoshop. I also use the convention of [http://sitename.local](http://sitename.local) in hosts file for any website and setup VirtualHosts in the Apache configs within WAMP. I do some development on a Macbook Pro with Textmate. I use the built in Apache and PHP versions there, with the same support for VirtualHosts. I also use the [ghost ruby gem](http://github.com/bjeanes/ghost) to manage hosts.
Makes sense. So basically instead of having to do a complicated WHERE/JOINS, etc. each time, I would just do a SELECT from a view? If so, I can't believe it took me so long to figure that useful tip out...
Yes! And they're so easy to create: CREATE VIEW myNewView AS SELECT itemId, itemName, price * taxRate as finalPrice FROM myItems You then can "see" this view as a table. It will only have three columns: itemId, itemName and finalPrice. Depending on your database, you can sometimes write to a view as well but that can get confusing quick and will often lead to unexpected results. 
You don't work for blinds.com, do you?
Put your stuff in a separate file and then do this: function runFile($file) { include($file); } runFile('yourfile.php'); Any variables in yourfile.php will be entirely their own scope and won't pollute any other space. For classes, functions, and constants use a namespace. 
There are no good solution in RDBMS to support schema less data. One hack is to use EAV. Another one is to store data in blobs (XML field, BLOB field, JSON serialized strings, or something similar). Yet another solution is to have a "huge table" where you have columns like (int1, int2, int3, text1, text2, text3, float1, float2, float3...) or to alter schema based on user input, and then there are solutions like this: http://www.simple-talk.com/sql/t-sql-programming/avoiding-the-eav-of-destruction/. Outside RDBMS you can use another solutions, like doc db.
[The book](http://www.amazon.com/PHP-5-Objects-Patterns-Practice/dp/1590593804) I mentioned in my parent post is a must and easy read; it goes into way more detail than I could here. Basically, you'd update/save through the mapper class (or mapper helper classes). class Mapper{ public function find(){} public function findAll(){} public function createObject(){} public function insert(){} public function update(){} } Saving then occurs either manually or automatically when object properties change.
Jack9, if you've done PHP for 12 years (a year less than me), and don't get hiii's point, then **you are indicative of the reason people think PHP coders suck!!**
StoneCypher, you're one of the reasons people think PHP coders are idiots.
Bull-fucking-shit. I code on top-1000 alexa ranking websites.
SQL Server has pivot that I think can be used here.
Mah, that's what's what ob\_start() is for. Are you retarded or a noob?
&gt; why pay for bug ridden propriety crap where "free" does it better? Counter-example: this thread exists.
I'm certainly aware of the difference between free and libre software. I also understand the significant differences between the very liberal BSD, MIT and Apache licenses and the much more restrictive GPL and certain variations of creative commons. But back to open source in general. From the perspective of our business, we get most of our value out of the free-as-in-beer aspect. But we also get a bit of value by avoiding propriety vendor lock in as well. One is obviously a bit easier to measure than the other.
That's what I thought as well - It's not as useful as I'd hoped. Especially when you want to show a comma-separated "list" of attributes presented in a single cell.
We're on PHP 5.2 for now, so class definitions would be a problem with your solution which also pollutes the function name "runFile". Namespaces are a nice solution to the class definition problem. I'm looking forward to using them.
Sure don't. I just checked out their source and it's full of \_\_VIEWSTATE.. Smells like a .NET shop to me.
If you're wanting assoc array values to have defaults then this method is a million times better: $myArray += array('myArrayKey' =&gt; $defaultValue); I used to have `ifsetor` all over my code. Not any more.
 $ul = Tag::ul(); echo $ul-&gt;open(); foreach ( $array as $item ) { $li = Tag::li(); $a = Tag::a(array('href' =&gt; $item['link'])); echo $li-&gt;wrap($a-&gt;wrap($item['text'])); } echo $ul-&gt;close(); To each his own, I guess.
 "&lt;li&gt;&lt;a href=\"$item[link]\"&gt;&lt;/li&gt;"; There, I've just saved you four keystrokes per array echo and your code will still run under `E_STRICT`.
Without namespaces, definitions of classes, functions, and constants are always global -- even inside of (anonymous or otherwise) functions. The only solution is unique naming. Name all your classes uniquely. Don't use bare functions, always make them static members of a class. Don't use bare constants, always make them const members of a class. My solution will work for simply running code in another scope which is the problem you describe: "Create some variables, use them to do work and then forget about it." You only need to declare runFile() once. If you call that same method with different files, each file will get a unique variable scope. Why do you need this? I rarely have a problem with scope conflicts (I'm still on PHP 5.2 as well) -- perhaps you're wanting to do something that has another solution. 
I'm confused. What's wrong with MySQLi?
Fair enough, but who here is responsible for the lack of a decent driver? Depending on your view, this can become an even greater reason to use open source. How many open source databases don't have drivers for Windows?
Heres the deal, I've done extensive PHP and MSSQL work: switch to Windows and use the Microsoft-developed SQLSRV extension (which now provides a PDO plugin) or suffer Microsoft's petty wrath. You will never see a good driver for Linux because no Linux dev cares enough (FreeTDS hasn't been maintained or updated in years), and Microsoft certainly doesn't care.
"SQL Server" refers to the Microsoft SQL product. So Mysqli functions aren't very helpful in this situation.
But there are two things happening here: 1. You've already paid for the proprietary crap (MSSQL) 2. Attempting to add FOSS has made it worse, not better Go with one or the other.
It certainly hasn't made things worse. There are a few non-text bytes that piss off any SQL queries they are in. This has never been a problem for us, but the perception of it bugs me.
Actually, what I did was make child objects that are the same -- can be marshaled or populated -- and the parent object builds an array of these child objects. I don't know if that's exactly what you need but that's what worked in my situation anyways.
I did it and i never went back since.
Have you at least tried it on the IIS stack to see if it works there?
All the best websites have shoutboxes.
Oh I see. I've never worked in that type of environment. Thanks for clearing that up.
Skip PDO and go directly for the ms_* functions. Save yourself some headaches. http://github.com/jawngee/HeavyMetal/blob/master/sys/data/database/mssql/mssql.php
Anyone who disagrees must suck. Not unexpected. There was no point. There was a declaration. I guess it's a matter of what is there versus what you, specifically, see.
Excellent!
They used PHP for 10+ years. Then one day after the CIO had been there for 4 months or so, he was all like "PHP is teh suck; ASP.NET is teh bomb." Two 1/2 years and unholy expenses later, they're just partially a PHP ASP.NET hybrid. http://www.blinds.ca/ is more or less what it looks like and I did both it and http://sears.blinds.net/ (the blinds Network platform) in PHP.
Aye, having worked with PDO, MySQL, MSSQL, and PostgreSQL, I'd avoid MSSQL like the *plague*. It's fucking horrible IMO. LIMIT &gt; TOP. I favour PostgreSQL now.
you know what i hate, when they dont have a demo, or at least a clearly stated demo.
Agreed. Just one note: Even if you don't have time to implement sth, describing it in a ticket requires way less time - and probably someone else, with more free time at the moment, will implement your request. So, please, if you think that sth is missing, just add a ticket, and this feature will have better chances to land in next Phing release.
I don't often use a TabBuilder style library (as most of my work is one off reports), but I think the greatest benefit is having a tree that can be modified / traversed, more so than just being neater than embedded HTML inside PHP (or vice versa). Little off topic, but DomBuilder for Javascript is pretty sweet too: HTML(HEAD(TITLE('Hello World!')), BODY(H1('Heading!'))); *At least if you don't mind polluting your namespace, otherwise it's not quite a nice looking*
http://www.google.com/search?sourceid=chrome&amp;ie=UTF-8&amp;q=php+file+upload+security
Thanks, I'll keep that in mind. I got to work with Phing quite a bit, and it's a good system, especially running it inside of an Expect script for completely automated with running exec commands. I wrote a tutorial on it a while ago, which was posted on the Zend blog, which was pretty cool. I'll have to poke through and see what I came up with
My interest is in being correct, not passing weak warning structures. If you value keystroke count more than strictness, then I think we have incompatible belief structures.
If you valued being correct, you wouldn't be interpolating vars directly there at all, you'd be using sprintf and htmlspecialchars.
I really wish I could use the built in XML library stuff for this purpose, but to date I haven't found any straightforward way to get a document (or fragment) out without it sticking its `&lt;?xml?&gt;` crap at the top. According to their bug tracker, the flag that turns that off was never implemented (despite being documented... go figure).
1) [That's not what downvote is for](http://www.reddit.com/help/reddiquette). 2) Your downvote does not instruct young developers. 3) It's unfortunate that you have confused opinion with fact. 4) My -7 comes from people like you, who are neither able to judge quality in code nor know what downvote is for. 5) &gt; "A view littered with echo 'ul', echo '&lt;div id=""&gt;' . $var . '&lt;/div&gt;'; is definitely not easier to read." It is when your script is more than about two screen pages. Vertical density is radically more important than horizontal density, which RAND studies show, and nearly all experienced developers know. 6) Most developers make poor choices, which is why most developers find most code ugly. As a result, being downvoted is equally strong a predictor of having it right as of having it wrong. The worst case is actually mild agreement, characterized by a bunch of personal agreement and no actual claim basis. 7) Much of the reason the average development history of proggitors is so low is that young programmers tend to attempt to justify their choices with herd behavior, instead of reasoning based on experience, which leads to herd voting lowest common denominator strategies, thereby punishing any redditor whose choices, no matter how politely stated, are uncommon. Since old developers frequently make uncommon choices, which is the bulk of the reason their productivity is so radically higher, this tends to cause frustration among older programmers, who are suddenly robbed of their ability to post, because a bunch of juniors forgot what the downvote button is for, and decided to rage so that they could feel correct. Note that not one criticism here is in any way defended or justified with anything beyond opinion. 8) May I see some of your large code, so that we may have a productive discussion of who's actually in a position to take which tone with whom? I'd like to know on what basis you take this tone of authority. 9) The comment was actually upvoted for quite a while, until a vague "this is awful" reply came in with no justification, at which point the sheep steered towards the river. 10) I note that you remain a case example of nearly all of these items.
You don't rely on IDEs? You do realize their whole existence is to make your life easier, right? 
Tell me that again after you've successfully completed a large project used by other people. I'm not really interested in random insults from random people.
1. Do not use globals; if you need it pass it in 2. Do not use variable variables. It may be a neat trick but will make your life hell and further erodes any help an IDE may be able to give you with php. 3. Write things in such a way they are unit testable (see point 1). Oh and write the tests. I prefer PHPUnit. One good rule of thumb here is if you use the word "new" in your constructor, you're doing it wrong. 4. If you're not freelancing, have someone code read what you're about to check in. It's just like having a second pair of eyes proofread your paper before you turn it in. Of course you're so awesome your code will never have a bug, in which case it helps others stay in the loop of what's going on. 5. Use version control. 
Agreed, but my function was for reading array values. I suppose something like: extract($values + array('something' =&gt; 'default')); would work, but then you have to worry about user-defined values.
I do value being correct. However, you're making presumptions that this is user supplied data. Input scrubbing belongs in input acceptance; if you're scrubbing during output, you're making assumptions that the data inside isn't intended to be markup active. That isn't the correct place for such measures. sprintf() is not a useful security tool, for what it's worth. It performs no appreciable defense of any kind. Interpolating means "finding a value inbetween two other values." For example, if you have five photographs of a ball in motion, and you want to find its location between two, you would interpolate. htmlspecialchars() is not a sufficient defense strategy, and prevents one from making perfectly legitimate useful code in places like that. In the meantime, your code does not run correctly in several well known circumstances, including older parsing cachers like APC. It also fails lint tools, and will not work correctly in php earlier than php 4.3/php5, representing nearly 1/3 of current deploys which are out of users' control, as that will be interpreted as a define constant, rather than a string key. That behavior returns in PHP6. Such is the danger of relying on interpretation of undefined code. To do so for the sake of saving keystrokes is untenable in a professional environment. Being wrong to type a trivial amount less is absurd. Please don't preach to me about what it takes to be correct, after having taken the position you have, especially when your pulpit is not actually generally correct - only in the case of presenting third party content, at which point your defenses are not adequate or correctly placed. Please consider being less condescending, sir. 
&gt; htmlspecialchars() is not a sufficient defense strategy Okay, you're flat out advocating writing XSS-vulnerable code. I can no longer take anything you say seriously.
And verbose bullshit is still bullshit.
1) Because using single quotes is incorrect. Try it, and see if you can spot the giant glaring incorrect behavior. 2) Actually, double quotes are faster, even though they shouldn't be. Try benchmarking it. The double quoted path has had a whole lot more effort applied to it. Consider not believing that what should be the case actually is the case; it frequently is not. Similarly, believing what you read on StackOverflow, proggit and (yes, really) in the PHP manual is often a poor choice, as the information is as often extremely outdated as it is flat-out wrong. Benchmarking before making speed claims is a sign of skepticism, which usually indicates experience. 3) Who cares about the speed of echoing quoted strings? If you care about speed, you shouldn't be using PHP in the first place. 4) Because my personal convention is "single quotes for string literals, double quotes for mutable strings." I have tweaked my editor's color scheme to reflect that. I don't expect anyone to choose to agree, but it's the reason I chose this notation.
&gt; Okay, you're flat out advocating writing XSS-vulnerable code. I certainly am not. Saying one thing isn't sufficient doesn't mean I advocate less, it means I advocate more. Please be more careful when reading. Cherry picking the one criticism you incorrectly think you've found a flaw in is just how you display that you are the sort of person who cannot admit having been wrong. It is unfortunate that, presented with several concrete cases of your own advice making literal bugs, you are unwilling to be honest, and must invent criticisms to feel correct. There is no described XSS vulnerability. I simply said what you were advocating 1) wasn't enough, and 2) was in the wrong place. Calm down. Yet again, [you are abusing the downvote button](http://www.reddit.com/help/reddiquette). That is not what that is for. (That you're going on to other threads and doing the same thing makes me laugh.)
Primary keys are the main key for a table. They aren't much different than other keys, though in many databases they must be slightly stricter, such as eschewing the possibility of identical values. Unique keys just can't have matches. Non-unique keys can. No, don't do multiple queries. The round trips are expensive and data can change inbetween, plus a lot of other more subtle stuff you don't want to think about yet. Generally you use joins, like so: create table users( id integer primary key not null auto_increment, name varchar(255) ); create table pages( ownerid integer, url varchar(255), foreign key(ownerid) references people(id) ); insert into users(name) values('john'); set @last = last_insert_id(); insert into pages(ownerid, url) values (@last, 'http://johnsite/'), (@last, 'http://other.johnsite'); insert into users(name) values('bob'); set @last = last_insert_id(); insert into pages(ownerid,url) values(@last, 'http://bobville/'); select users.name, pages.url from users join pages on users.id = pages.ownerid where users='john'; Do they need to be set up a certain way when they're created? Well, planning's good, but you can change things later. I mean, always plan where you can, no matter what you're doing. But SQL's for the real world. Things change, people are wrong, etc. alter table pages add column(rating float default 3); The MySQL manual is pretty readable, as is Joe Celko's "SQL for Smarties." Bill Karwin is also worth listening to.
Thank you!
I do use IDEs kind of. I currently use coda if you want to call that an IDE. Ive just never found and IDE that i agreed with, so ive stuck with advanced text editors.
While I do not have any experience about the MSSQL/PDO-combo, do you supply the type of the argument to the bindValue/bindParam-methods (such as PDO::PARAM_INT - $statement-&gt;bindValue(123, PDO::PARAM_INT)? This also require that you actually cast the value supplied to int (no idea why). If you're working with values above 2^31, this will not work. PDO also supports emulating prepared statements, but be aware that it works on the client side by simply building the SQL-statements from the supplied information and sending the generated statement to the server.
You are just arguing semantics and not even being clear about your own definitions. 
I'm not sure that makes sense. If you are working with a large scale web application surely you want a stable framework that doesn't reinvent itself with each new minor version? I understand that namespaces have their uses, but I have built some MASSIVE content management systems, applications, REST API's and plenty more in CodeIgniter and NEVER had any problems. The fact that CI is so simple and so stable means I can build massive applications without ever worrying about some change screwing with my code too much, a'la Symphony or Kohana - which dont get me wrong, are both great fun to work with too.
cool project, i will upvote ps... i am not a fan of monkey patching/testing, but i realize that some projects may just need it. 
should be fine unless you are using specific 'mysql sql'... two things that come to mind are multiple inserts in one query and full text indexes. also, try using an orm/dbal (like doctrine). it makes these types of database moves painless.
There's a lot of tiny differences in syntax. MySQL tends to deviate a bit from standard SQL. String concatination is different, and difference between (aggregate) functions. Test all your queries basically, and assume it will be slower.
The queries are all VERY basic, I'm terrible with SQL I prefer to just extract the stuff I want and use php to do the work I need. I'm talking standard SELECT, INSERT and UPDATE at the level of the first day of PHP 101
Test anyway, seriously.. It's not that crazy of a suggestion
Oh I will, I'm just not expecting any real issues as I would with a complex query. Thanks
The free in free software can be either. Anyway, you have assumed that he meant one meaning for "free" when in his sentence it was far from clear, apparently just so that you could pick a fight. He might just as well have meant "why pay for bug-ridden proprietary software when I can instead pay for bug-free open-source software?"
&gt;While I do not have any experience about the MSSQL/PDO-combo, do you supply the type of the argument to the bindValue/bindParam-methods (such as PDO::PARAMINT - $statement-&gt;bindValue(123, PDO::PARAMINT)? This also require that you actually cast the value supplied to int (no idea why). Surprisingly, that doesn't work either. From what I've gathered, the FreeTDS driver doesn't support the API call "SQLDescribeParam" which is used by PDO/ODBC. PDO/ODBC hears that the method isn't supported, and makes the wrong decision to treat everything as a LONGVARCHAR. At this point PDO/ODBC sends everything as LONGVARCHAR even to int fields, regardless of PDO::PARAM\_INT. I took a look at the FreeTDS source the other day and was surprised at how clean and relatively simple it looks. I might make it a weekend project to try and jack some of the functionality from the dblib driver over to ODBC and see what I get.
http://framework.zend.com/manual/en/coding-standard.html Surprisingly a lot of PHP developers get the general impression that they should following something like this guide (despite having never heard of or having never read it).
Yeah, I usually start talking in the shoutbox right after I sign their guestbook. 
&gt;1) Because using single quotes is incorrect. Try it, and see if you can spot the giant glaring incorrect behavior. Well I know you can't interpolate variables with single quoted strings. &gt;2) Actually, double quotes are faster, even though they shouldn't be. Try benchmarking it. The double quoted path has had a whole lot more effort applied to it. Well, we've paid a lot of money for Zend engineers who actually develop the PHP core tell us quite the opposite. That's not your average StackOverflow or Proggit poster. To tickle your fancy, I made a loop that ran 1 million times. I build an HREF link two ways - using variable interpolation on a double-quoted string (0.4 seconds) and then switched it to a single-quoted string with concatenation (0.3 seconds) - that's a full 25% faster. &gt;3) Who cares about the speed of echoing quoted strings? I agree with you completely. When I read back on my comment, it made me feel a bit like a douche ;) &gt;4) Because my personal convention is "single quotes for string literals, double quotes for mutable strings." Hey, personal preference counts. To me, I prefer not having to escape my double-quoted HTML attributes. Most of the time I'm running a function call as well, which can't be interpolated anyways. Sure would be nice if PHP allowed you to use echo "{expression()}";
&gt;No I don't think you are Is that how you begin every single post? I can't believe how hard you try to make everyone else sound wrong, even when they're not. I bet you are a blast at parties. I know exactly what I'm talking about here, but you insist that I'm wrong with a religious fervor. You argue that free software is libre software, but that's obviously not true - it's the entire reason we ever started using the term libre to begin with. You contradict yourself a second time when you say that a closed source application can be given away for free. So what is it? Is that software free, or is it libre? You are preaching to the choir on this one pal, but you keep insisting the choir is wrong.
You generated a lot of discussion but after 5 days, no one pointed out that your example of "Do not" is **wrong**? &gt;echo "&lt;li&gt;&lt;a href=\"&lt;?php echo $item['link'] ?&gt;\"&gt;&lt;?php echo $item['text'] ?&gt;&lt;/a&gt;&lt;/li&gt;"; should be &gt;echo "&lt;li&gt;&lt;a href='".$item['link']."'&gt;".$item['text']."&lt;/a&gt;&lt;/li&gt;"; It is much shorter and more readable if you alternate the quotes and you don't include those excessive open and close tags (that would also throw an error). I code both ways... the second if the code block is more than a line or two.
MSSQL is certainly not horrible. T-SQL is incredibly powerful and as a bonus it's really easy to use. Common Table Expressions are very kick ass as well. I certainly agree with you on the usefulness of LIMIT over TOP. However, some make the argument that database paging should be accomplished with your driver and not within the SQL statement itself. I'm not sure how I feel on the matter. On one hand, why *not* provide the functionality? On the other hand, I've run into trouble trying to apply LIMITs on top of queries that already contain one before. FYI, we page data successfully with MSSQL by using mssql_data_seek() - I bet a similar function exists for both mysqli and postgres drivers as well.
On http://flourishlib.com/docs/UTF-8#MSSQL I have the two most important settings for TDS: the version must be set to 8.0 and the client charset should be set to what your app is expecting. For Flourish I actually recommend setting the client charset to be the same as the server since I do encoding conversion in PHP for cross-OS compatibility.
We've tried it on IIS - but this was before the days of the SQLSRV extension. The old Microsoft supplied (and PHP bundled) dblib driver was laughably bad. Null values came back as empty strings :( These days, we're pushing Apache to do things that I'm pretty sure IIS doesn't do, but I can't say that for a fact. We use its reverse proxy features with mod_rewrite and mod\_headers to provide for trusted authentication to other HTTP servers. We also use rewrite maps to a stand-alone PHP process that does URL access authorization on the request level - we can protect access to non-PHP URLs withing invoking PHP for every request. If we switched to Java tomorrow, our URL authorization would continue working without a hitch. Finally, our management (agreeably) believes in minimizing the number of platforms we maintain. Apache is one we want to keep, IIS is one we would like to minimize (but I think we use it for stuff like Outlook Web Access).
Yikes! We just hired our first IT Director ("Duh, duh, duh!") but he was interviewed pretty thoroughly before we made the selection. He's a really nice guy for one, but one of the things I really like about him is the belief that "I don't pick technologies, that's your job. My job is to make sure that you use them to provide what the business needs." A PHP / ASP hybrid sounds awful. I can't imagine any easy method of invoking PHP methods from ASP or vica-versa, without some god awful mechanisms. I see some JQuery on blinds.ca, what an awesome tool.
Peculiar: flussence just made this exact same language error. &gt; Well I know you can't interpolate variables with single quoted strings. To interpolate means to take the value between two other values. For example, interpolating between 3 and 7 gets 5. &gt; To tickle your fancy, I made a loop that ran 1 million times. Yeah, funny thing about benchmarking: one test rarely tells the whole story, and simple defects can cause radically wrong results. When benchmarking it's appreciated if you provide the benchmark. &lt;?php $in = 'inset'; ob_flush(); flush(); ob_end_flush(); $first = microtime(); for ($i=0; $i&lt;10000; ++$i) { echo "d $in d"; } $second = microtime(); for ($i=0; $i&lt;10000; ++$i) { echo 's ' . $in . ' s'; } $third = microtime(); for ($i=0; $i&lt;10000; ++$i) { echo "n ", $in, " n"; } $fourth = microtime(); $fifth = microtime(); for ($i=0; $i&lt;10000; ++$i) { echo "double double $in double double"; } $sixth = microtime(); for ($i=0; $i&lt;10000; ++$i) { echo 'single single ' . $in . ' single single'; } $seventh = microtime(); for ($i=0; $i&lt;10000; ++$i) { echo "no-cat no-cat ", $in, " no-cat no-cat"; } $eighth = microtime(); echo "\n\n&lt;br/&gt;Short:&lt;br/&gt;Double: ", ($second-first), "\n&lt;br/&gt;Single: ", ($third-$second), "\n&lt;br/&gt;No-Cat: ", ($fourth-$third), "\n\n&lt;br/&gt;&lt;br/&gt;Long:&lt;br/&gt;Double: ", ($sixth-fifth), "\n&lt;br/&gt;Single: ", ($seventh-$sixth), "\n&lt;br/&gt;No-Cat: ", ($eighth-$seventh), "\n\n"; ?&gt; The results? Short: Double: 0.802888 Single: 0.056241 No-Cat: 0.04942 Long: Double: 0.070779 Single: 0.207002 No-Cat: 0.146845 What you might be forgetting are several things. For one, the size of the string affects how PHP attempts this, and has a pretty big impact on speed due to copy thrash. For two, output buffering can have a pretty serious impact on this sort of performance, favoring whichever one gets done first. For three, microtime() is complete bullshit - if you use my script often enough, you'll occasionally get a *negative* timestamp. Get this in a profiler and you'll get real numbers which roughly match the set above. Practically speaking, the Long set matches what almost all real world scripts will experience. &gt; To me, I prefer not having to escape my double-quoted HTML attributes. I've been writing HTML for a long time, since long before PHP existed, so I'm already used to it from other languages. However, I understand and respect your preference. &gt; Sure would be nice if PHP allowed you to use echo "{expression()}"; echo "but ", it_sorta_does(), ", man";
(protip: "mod\\_rewrite") Sucks if you're not allowed to change it, I guess. Oh well.
Hey safety, I think you're onto something good here. But I also think you're missing a couple of things. Maybe I'll take a few minutes to contribute a few changes this afternoon, but here's a design suggestion as well: Make your class more stateful. Keep things like tablename and a list of primary keys as part of each instance. It makes for less parameters for many of your method calls. I'll tell you what, if GitHub will let me send you a file (I've never used it before..) I'll send you a couple of classes that we use for MSSQL. I think you'll like them.
Woops. I've gotten better about escaping my underscores, but I forgot on that one. I had a lot of replies to process this morning and my coffee hasn't kicked in yet.
I'm going to have to check out Flourish, thanks for the link! But FYI: &gt;MSSQL does not support UTF-8 natively like the other database engines, and requires that all databases on a server use the same character encoding. This is no longer true. I'm not sure when SQL Server ever required a server-wide character set, but on 2008 I just now created a table with multiple character sets on a per-column basis.
Yeah. I wish markdown was a bit more intelligent about underscores between words, considering it's written with programmers in mind (backticks).
I didn't say that SQL Server doesn't support different collations, but that there is no UTF-8 collation. I can't find any UTF-8 collations on either my SQL Server 2005 or 2008 installation, and I can't find any info online that says UTF-8 is supported. Instead, everything references the national data types.
So, I took a look at your class and I've made a few suggested changes. How in the heck can I send it back to you?
I've learned everything I know about html, CSS, JavaScript, SQL, C#, and PHP from reading the Head First book series. Here's a link to their PHP book http://www.headfirstlabs.com/books/hfphp They're a really good series for beginners, as I've only been learning about html for a year and I only started reading their PHP book a week ago. But I can say I've learned a hell of a lot from them.
jon@interfacelab.com
Awesome! You can also send it to me at jon@interfacelab.com
you are correct sir, i wanted to use string concatenation like i see too many people doing. I fixed it thanks =). As for alternating quotes if you do it the right way there's no need for it.
When I came to work at my college campus for the research department doing web development we were using MSSQL and ASP on a horrible windows server. I fought for a year to get PHP installed on the thing and I was a little more comfortable though I did have to reinvent the wheel numerous times because there's simply nothing written for a php/mssql environment. Coming from a background of LAMP servers I fought tooth and nail to get 2 LAMP servers for our exclusive use and I couldn't be happier. I have not seen anything that convinces me to move to Python or Ruby over PHP. It seems like I'd be taking a step backwards into a world where there's simply not enough stuff to work with. 
The way I see it, Reddit's programming boards are visited **mostly** by programming enthusiasts. And I'm sure we can **all** agree, PHP as a language is nothing to get _enthusiastic_ about. Sure, if you're just some guy who programs as a job, and not for fun, PHP will **usually** pay your bills. But those people **usually** don't frequent r/programming or r/php because they do not care about programming outside of work (and **in most cases**, they are a bad programmer because of it). EDIT: Bolded some quantifiers to make it clear that there are exceptions and outliers.
just the phrase "specification by photoshop" conjured up startling nightmares from three wasted months of my life I will never get back..
I use PHP because that's what I picked up on. I started using it maybe 6 years ago just as a hobby, and only up until recently the work I have done has been used on a professional level. For me, it's easy to create a specific internally used application within a week and ready to be rolled out to the client. Sure I could use python/perl/etc which might speed up the website, but I don't know those languages and at this point in time I have no interest learning them. In the future I will, but I don't have the money, resources or time at the moment.
I usually avoid getting religious about languages. It's just not useful. PHP has had its pitfalls (register\_globals, magic\_quotes\_gpc) but every other language does too. But I will say it is *very* flexible, very fast and very easy to deploy. It's hard to knock on from a business perspective. 
PHP is very useful. I'm now getting into Ruby, but I certainly wouldn't turn around and entirley dismiss something as dependable and accessible as php just because it has a few problems here and there.
Every language has strengths and weaknesses. The problem with php is that it is selected by people (usually non-technical) for the wrong reasons (usually the cost). The same goes for Python: it is selected by people (usually technical) for the wrong reason (usually the coding style)... Every project has its own requirements. There are projects where PHP is a better choice than C# or Java or Ruby or &lt;put-any-language-here&gt;. Not all projects, however! The selection of the language should be a topic of a serious discussion between the project manager and the software architect in the beginning of the project. The developers should not have a vote: a good developer can code in any language. 
The cool thing to do is hate on PHP. Encyclopedia Dramatica on Reddit: &gt;/r/programming/, Where neckbeards post links to programming articles and berate others for their choice of programming language because it fills that dark hole left open by being a sexless 25 year old.
&gt; I usually avoid getting religious about languages It is like watching a construction crew build houses using just screwdrivers, all the while screaming "I HATE HAMMERS!!!" 
Imagine if you knew PHP and Perl, Python, or Ruby, you could make money from multiple pools instead of just one and just pick the work you might be excited about instead of the work that's available. EDIT: I'm being downvoted for suggesting people learn more than one language? Is that... is that what's going on here? 
Oh, on the other hand, I hate Python because it is like Chinese text, what I see is like a Chinese text.
I think the reason most of us bash PHP is because we use it for job and money. It's the language most of us are close to, and thus a constant source of irritation. I know I personally rely on PHP for all my professional programming experience, though i'm actively trying to learn python and java. I'd be willing to bet if Java or Python had the reach PHP does, we would all find something to complain about in those languages as well.
yeah.. PHP does make money and if you're using it to make websites it really makes your job easier .. i am an avid Perl supporter.. hated the fact that i had to write my regular expressions inside quotes, or couldn't indent my heredocs or that all the fucking functions are in the main namespace or i can't use strict, etc.. but with time i've gotten used to it, actually started loving it.. now i can't think of making a website without php
It depends on the app, but my (everyone's?) #1 class that I need in 98% of my scripts is my sql class. Connect, query, escape data, return various structures, I always need it. #2 A data model. That is, do form reading, CRUD and data sanitation (SQL escape on saving, HTML escape before display) for me. #3 would be a cheap little "html" class I made. Draw lists of selects, checkboxes and radios. Here's a name, a data structure and the default value to select. This makes web form work (an overwhelming amount of my job) brutally efficient while forcing no restrictions. On the client side, there isn't a project I've made without jQuery since I was introduced.
Maybe I missed it but all of a sudden there seems to be all this PHP hate and I don't really understand why...
Article links to an article that we've already read.
I disagree that the developer should not have a vote because this isn't a perfect world and a decision made in a vacuum is fallible. Get other input to eliminate the risks up front. 
This is point for point exactly what I was going to post. [My Database](http://github.com/ChiperSoft/phPit/blob/master/objects/Database.php) class, [my data model](http://github.com/ChiperSoft/phPit/blob/master/objects/DBRecord.php) class, and [my HTML Page wrapper](http://github.com/ChiperSoft/phPit/blob/master/templates/Page.php). Swap Prototype for jQuery
Why do I code in PHP? Because PHP works everywhere. If my client wants to be cheap and put the site on some $2/mo web hosting, it still comes with PHP. If my client wants to buy hosting in a country where Rails/Django isn't well supported (e.g. lots of places in Asia), it still comes with PHP. If I download some library for a job, I can be reasonably sure that it would work wherever PHP 5 is installed, and it usually doesn't matter whether it's PHP 5.1, 5.2, or 5.3. Many of them even work in PHP 4, though I don't care about that anymore. No need to worry about "This is incompatible with Ruby 1.8 vs 1.9" or "You need Python 2.4 vs 2.5" bullshit. In other words, a lot of backwards compatibility. It makes PHP ugly, but it works. 
I really like Zend\_Db and Zend\_Form
I've used Prototype on WebOS before. I think it's alright. One part of me likes the way they extend native DOM elements to have more functionality, other parts of me don't. My biggest gripe with Prototype is that I think it over-emphasizes the "id" attribute with the $() selector. It has the fantastic Sizzle engine but treats it as second class with the $$() selector and just doesn't seem to get the attention it deserves.
If you knew all of them, you wouldn't know any of them good enough to make the *real* money...
Well the $() existed long before using CSS selectors to get elements existed, so $$ had to be added separately to keep from breaking functionality. They also return different things. $ gives you an element, $$ gives you an enumerable. Personally, I love the way $() is implemented in Prototype. If I'm loading a dedicated named element, Sizzle is just unnecessary overhead.
I can't come up with a reply that isn't mean. Have a nice day, good luck with the one language you know (whatever it is). 
Yea I really wish that php would of inherited some of the great assets that perl has
I think part of it is Ruby, Python, and some other programmers are really into programming, and see it as a culture, not just a job/career. They are really interested in this stuff, and honestly, PHP isn't all that elegant comparatively. Many PHP developers (myself included) use it because it works, and they're able to get the job at hand done with it. We see programming as a tool, not so much an art.
I agree, for web programming, it's really hard to argue that php is a bad choice. I don't even really like the language but damn it gets the job done. 
stdClass, 'cause it rocks.
You know what's a lot more frustrating than dealing with PHP? CSS. I like my development job, but I hate the web design aspects of it.
&gt;around here lately. lately? you must be new to reddit.
the best way to get better at programming - learn a different language than the one you are working in. if all you have ever used is PHP, then you have no idea of the concepts you are missing out on in other languages.
yeah? it also pretty much sucks to use, especially once you start getting into other languages. i used to really enjoy coding php, then i discovered ruby and python, now i really, really dislike coding php.
I have seen PHP hate for at least 6 years now... usually from people not having an income from programming. My favorite was a guy who worked at Spencers criticizing it.
The benefits of PHP completely outweigh most other languages. The ease of PHP syntactically, the ease of deployment, and the fact that it's free to run should be all the reasons programmers need to choose PHP. Start throwing indexing engines, alongside a memcache engine, onto PHP servers, and one quickly sees why PHP is the best choice. There is no hidden magic that happens, like with ASP. There's not much overhead like with Java. Hating on PHP has become a trend. That's all. Despite the fact that major companies run on it, people still hate it. Yahoo uses it. Facebook uses it. That should be enough proof that PHP is your best choice for development with websites. Now, a poorly configured server, with poorly written code will slow, and a untuned MySQL server (or whatever you choose to run for data) can be a good reason as to why people hate PHP. It is easy to do all those things, especially if you haven't worked much with the combination of the three. But if all of those things are properly calibrated (which is a relatively easy thing to do), then there's no reason PHP shouldn't be chosen. Any programming language can be slow and painful. It depends on how well you know PHP. If you just throw an install out onto a server without tuning it in PHP, Python, ASP, or whatever, you'll run into the same issues. PHP's just easier for this. There's more reference. And it's just more friendly to work with.
I agree with the OP. Before I learned PHP I cringed because I had predispositioned myself to hate it and every time I looked at job postings they all wanted experience in PHP. Eventually I learned it, and I haven't had trouble finding work since...
It is not a decision made in a vacuum. It's the job of the software architect to know the risks as well as to train his team of developers. He should not be separated from the developers; he should lead them. It's like soccer: every player has an opinion on the playing system. However, it's the coach who should take this decision. And yet, he will have to train the payers to follow his strategy. 
Good programmers can make a good living working in Python, Perl, Ruby, Java, or just about any other mainstream programming language. PHP is not unique in this regard.
Huh?
Why not? It takes a long time to master a language. I've been programming php for more than 10 years and I still haven't learned all that there is to learn. If I would spread my efforts I wouldn't get good enough in any language. Having said this: I took a short look into python and ruby. And have to admit that they are superior, I really like their concepts, but I just don't have the time to learn them (I mean *really* master them). edit: BTW: When I say "you", I don't mean "you" personally, I mean it figuratively.
&gt;a good developer can code in any language. That's a bit idealistic. It doesn't take long to pick up a new language once you understand the concepts, but it takes a long time to learn its eccentricities and how to get best out of it.
I did not deny that. My point is there are more opportunities (at least in my nape) for PHP programmers. 
In a perfect world, but there are too many incompetent people in business. All it takes is for the software architect, who could even be great as his job, to NOT know that there is a framework on a different language that would be better suited to push the application through in less time with less development. I'm not advocating a bunch of middle-managers sitting in a room pushing bullshit around like dung beetles, I'm just saying that in a tight development team that can be a worthwhile discussion to have as a group even if it's ultimately the software architect who makes the decision.
It doesn't take 10 years to "master" PHP. You might have to pick up a new library every now and then, but the concepts and syntax do not change drastically version to version. PHP 5.3 introduced some great new things, if you were not focused on just one language you would already understand several of them. You don't have to MASTER every language to be proficient, and the skills required to be a good developer are not language specific. I find your opinion frustrating, I am seeing via the down-votes that many other PHPers might agree with you, I am guessing that is because this is /r/PHP. I love PHP, I have been using it since 4.0.something when I first loaded it up on my Slackware box. (2000, so 10 years) but I also like Perl, Python, and JavaScript. I'd like to know what you think you know about PHP that I would not. 
Living in Europe, most of the projects I am involved require a multilingual interface. So I always have the class "Lemma", that is responsible for translating a dictionary entry to the current language.
I've found it works best to ignore IE6 (or even 7 and 8). A lot of stuff actually works in more recent versions of IE that make for a LOT less headaches (like having to class and ID every little fucking thing).
I really don't know why you feel so offended. I'm just giving you my personal opinion. I cannot say if I know anything about php that you don't know, because I don't know you. But I know that it took me a long time to get where I am now. And I wouldn't be there if I also tried to learn many other languages at the same time. Just my personal experience. I know that there are some people out there who are more gifted than I am, maybe you are one of them.
I'm not offended, just frustrated, it's not the same. You're the first person that's told me this opinion, but when I started replying the top of the chain had -3 for votes, so I am guessing this opinion is shared by more than a few people. 
Hey man, I'll have you know I make money _despite_ PHP.
Listen. I don't say that php-people shouldn't look out to the world and get a grasp of the concepts that are out there. I had a look into Java, Ruby, Python, Perl. It gives me perspective of what I expect a good language to be. php falls short in many aspects, but also showed that it's capable of catching up. but yes, my time is limited. I'm a professional developer for many years now and I also have a private life, so I choose to be good at one thing instead of being mediocre at many... edit: and I really couldn't care less about down-votes... I'm just being honest...
hey we're just talking here, no biggie &gt; mediocre at many I guess that's what is *offensive*, you're insinuating that a PHP developer that also does Python work is less of a PHP developer than someone that does just PHP, since you're good and this other developer that uses both is mediocre at best? 
no, I'm just talking about *myself*
Ah, you're just saying if you picked up another language your PHP skillset would start to evaporate. 
No, I'm saying, that I wouldn't have the time to pick up another language if I also want to pay my bills and have enough leisure time...
I've discovered that "a lot of stuff" still leaves a lot of stuff to be desired, even from IE8. Their CSS support is still really bad, even though "really bad" is better than it used to be.
What's leisure time? (*now I've got it*)
wrong word? sorry, english is not my first language. i meant free time.
Javascript was the first place I used Regex outside of PHP, and you are damn right about writing expressions inside of quotes. It sucks! I also love the fact that regex (along with everything else in JS) is treated as a first class object.
I read a long blog post written in 2008 by Larry Wall who said that PHP is making the same mistakes Perl did in its day, just in a much slower fashion. :)
No, no, right word. What I meant was, **what is leisure time?** as in "I don't have any", finally understanding your opinion. I work way too much, but I figure, I might as well now while the wife is in college and we don't have any kids. 
Javascript really taught me a thing or two about object oriented programming. It sat right under my nose for years getting nothing but hatred and neglect from me because I could never differentiate between Javascript as a language and Javascript as it's used to manipulate the DOM. Then I was introduced to jQuery, forgave the DOM for its sins, and my eyes were opened. Functions, regex and arrays as first-class objects? What's this closure concept you speak of? Holy shit! This is an awesome language! JS is a work of art, a true beauty that makes the "object oriented" claims of PHP look a bit dubious.
so now we are full circle. have a look at the topic that started it all.
I hate PHP but it accounts for 60% of my income, so it almost suggests that I hate my job :)
Well, I'm trying to figure out where you're coming from, because I think it's possible to take 10 years to truly master a language. But you mention concepts and syntax and the fact they don't change much. Then you go further and mention proficiency, and I think that goes hand-in-hand with concepts and syntax. I think you are spot on those ideas, but those aren't what I consider "mastery". Further more, I don't think having "mastered" skills would be something you could really fit into a couple of paragraphs on Reddit, or anywhere else short of a highly academic environment. It's certainly not going to be covered over a pissing match of "what do you think you know that I don't?" BTW, I think using Slackware in 2000 earns you some serious geek cred. You were into Linux way before being into Linux was "cool"
*a good developer can code in any language.* True since the dawn of coding. But please, explain that to hiring managers and HR departments. The ONLY constant in hiring of programmers and admins is that they want people who are expert at the platform in use at the company. Whether you're good or not is irrelevant. A few months ago I was not considered for an admin job because they were using Oracle Unbreakable and I've mostly worked with RHEL and Centos. They are all identical! This is like -- I'm an expert Ford transmission mechanic but the Mercury dealership doesn't trust me to do oil changes! 
I like PHP, it is a pragmatic language that gets the job done (and I am beginning to feel the urge to punch anyone mentioning closures).
Master is not the right word, which is why I put it in quotes. I think I should have said *it doesn't take 10 years to be sufficiently skilled with PHP to make decent money with it*, especially if you have development experience with Perl and/or C as a background. The only languages I don't bother looking at are from Microsoft, mainly because I'm assuming it takes money or piracy to use them at home. I don't have time or desire to try them even though I believe C# would be a fine choice. 
i've discovered css reset ... and headache was away. 
&gt; Then I was introduced to jQuery, forgave the DOM for its sins, Easy to forgive when someone else works to abstract it away.
[Indeed](http://oppugn.us/posts/1287608776.html).
What's your point? We're in a PHP subreddit. Someone else worked to abstract all of C code (or worse) away from me. Sizzle is a kick-ass selector engine, and jQuery is built to make the best of working with collections. If you're not writing your webapps in assembly, you're just using someone else's work to abstract it away from you.
Well, say what you want about C# but here are my thoughts on it: &gt;if(a = b) Does not mean what it appears to mean in C#. "C Sharp" is anything but, they've remove the sharp edges for you and they will interpret the expressions and assignments you write however they wish.
Unfortunately for your upvotes, most Redditors don't have the same problem. But I'll check into Lemma and give you a positive tick for letting me know about it. Thanks!
Why fight tooth and nail for a year when you can just install it on a VM and show them what it can do?
&gt; But I know that it took me a long time to get where I am now. And I wouldn't be there if I also tried to learn many other languages at the same time. I really kind of disagree with you there. Learning python made me a better programmer, and a better php programmer. Learning a bunch of languages might be too much time, but learning another good language will help you with your php as well.
So you tell your clients to ignore 10% to 70% of their audience and not care what the site looks like to them?
Only people who make money off something are qualified to have an opinion about it?
Imagine this conversion... **Me:** Welp, time to hit the surf, my sponsors just bought me this awesome board which I love. **Guy:** Psssh, *that* board. That board sucks. I heard someone on reddit it has problems that I never encountered because I live in Nebraska. **Me:** Maybe you should try surfing... with any board... before you talk shit. Special Note: I don't surf.
Since I levelled up, I've only got 5 programming points to spend, do I put two in python, two in php and one in ruby? Or should I minmax and put it all in php?
My experience with JavaScript completely changed when I learned about jQuery. If you ask me, JavaScript would be greatly improved if it had the ease of use of jQuery built in.
I'm not sure what your point is. I'm not arguing against abstraction per se. My point was, you forgive X for being terrible because someone hid it from you, is not exactly eye opening. It's the opposite.
In an institution such as a community college it's not about what "works best" it's about what costs the least and requires the least amount of change. If it requires someone to do *anything* outside their normal duties it's automatically too expensive.
It may take some time to really learn the best practices of a language, but I think in essence linepogl's statement is more or less accurate. Using the best practices and learning eccentricities, popular libraries, etc. does require a bit of experience and quite some googling as you code but really I don't think it should take more than a day or two to be able to code decently in most high level languages if you're generally a good programmer.
Register_globals and magic_quotes are deprecated now, thankfully. However, there are still a bunch of web hosts running PHP4 on their shared hosting packages. Which means a lot of big PHP projects, like WordPress, have been stuck accommodating them longer than necessary.
Hell, Facebook (one of the biggest sites on the internet) is PHP and a mix of lower-level languages (e.g. C) for the heavy lifting.
I know PHP and a bit of C/Objective-C, and I've been casually skimming through a Python book occasionally. Not making much money yet, as I'm more interested in my own projects than working for someone else. :)
It mainly gets a bad rap because of how easy it is to get started with. You end up with a lot more newbies writing bad procedural code. That and the stupid namespace character...
Sure but how do you know that guy isn't a surfer living in Nebraska, or a programmer working retail? Note: I used to work retail while doing web consulting on the side.
I really think the haters are just playing the system. If you tell everyone the language you love really sucks and you hate it, then there's less competition for you. Hey everyone, go Delphi! It rules!
I think I infer that what you're really looking for is *why* use OOP, rather than *how* to do it in PHP. For me, it's about abstraction. I don't need to know anything about a class except it's public stuff, nor any of the private object connections it makes to do its bidding. If I did it all in procedural code, there is no public/private stuff going on. The other thing is about namespace. When you see a function being called from the global namespace, you keep wondering if that was some new function in PHP you might not have heard about yet, or if it was something that someone coded. But with a class and an object, it's a little easier to see. This works best with large projects and teams. However, even on small projects it's a good idea because you never know when that clever concept used in a small project might be easily dropped into a large project. By making it a class file, or a dir of classes, it's easier to carry that into a large project.
Why not use Kohana? It's a fork of CI where the devs brought it into the realm of PHP5, rather than PHP4. Kohana is a little leaner, yes, but that's what I like about it. I just use it for MVC. For other stuff, I just use PDO and straight PHP in classes. That way, new guys joining the team only need to learn Kohana for the MVC, and can hit the ground running because most already know PDO and straight PHP.
Learning OOP is like a curve, and as soon as you get a grasp of the *objects* part, you're in baby. The best way to conceptualize objects is that an object is fucking *anything*. *Anything*. If you're used to PHP, you've probably worked with databases. In most cases, a database table maps a particular object. Let's take, for example, a shopping cart program. A product is an object, a product category is an object, a user account is an object, a cart is an object, a transaction is an object, and so on an on. Now, right now you're thinking, OK, I've got objects, what about the relation between those objects? A person (account) *has a* cart, which *has many* products. Once the person checks out they *have a* transaction (eventually they will *have many* transactions). Programming languages (including PHP) allow you to define these relationships in the programming language the same way you do with a database. A `Person` object might have a reference to a `Cart` object, which might have references to many `Product` objects. Are you with me so far?
i guess that's part of what doesn't click for me, i've made the association in my db, how does making it again my code help? i tried using cakephp before but i just found it confusing. i've written oop c++ code before and i found writing it oop helped organize my ideas of how things should work, but it doesnt click the same way for php :/
i think your interpretation of my question is pretty accurate, do you have any sample code which shows oop code to be easier/simpler than procedural? maybe with db interactions if at all possible. also ty for taking the time to answer my question.
So, Ruby?
If you've used cakePHP then you're familiar with *Object Relation Mapping* (similar to Ruby on Rails ActiveRecord). That basically means that, in my application, if I have access to one object, I can retrieve its related objects without having to load them through some other means. Let me give you an example, using my previous example: If I have the `Cart` that you're adding a `Product` to, I automatically have access to the `Customer` who owns that cart. I also have access to all the other products in that cart. If I have a `Customer` object, I have access to their current `Cart` (if they have one), as well as all their previous `Transaction`s (if they have any). OOP in PHP can totally organize your ideas the same way it does in C++ or Java. 
&gt;but yes, my time is limited. I'm a professional developer for many years now and I also have a private life, so I choose to be good at one thing instead of being mediocre at many... You're missing the point. Different programming languages make you approach tasks in a different way, which in turn makes you a better programmer. You can bring the knowledge back to php. The same is true for programming topics you may not think apply- I read a couple of books on compilers last year and then did a few projects related to it, and it made me better at doing a lot of things I've done in php. Be mediocre at things, it's okay. Just picking up the different ideas and patterns will make you a better developer, regardless of language.
ಠ_ಠ
yea, i'm already thinking of ways that it can simplify code i've previously written. i've read before that some people have custom written sql classes to simplify queries, i need to find some of those examples and see if there is a way i can use the two to remove a lot of redundant code. i also want to learn how to properly use error handling in php (maybe with some kind of error reporting feature so i can track bugs more easily) and transactions for my queries.
Right... these don't really have anything to do with objects. Are you gaining a clearer understanding of objects? I promise to persist with this until either you understand objects or I get tired, whichever comes first.
All we all writing the same classes over and over? I have my DB class with SQL generation/sanitation, etc., DB Model class, HTML builder. . although I also have a UI framework class that creates jQuery UI elements and bindings automatically.
i think it's a matter of seeing how it can be useful in php applications, but i'm starting to see how it can be utilized in this kind of environment to make better code. maybe after i write some oop apps i can go back to using cakephp without getting a headache. lol edit: i understand those don't have anything to do with oop php, just vocalizing my goals :)
I code PHP and Ruby for a living, the fact is that Python and Ruby developers command larger salaries, I'm speaking from experience within Berlin and London, where I work. PHP developers 250-300 Euros a day, Python/Ruby 300-500 Euros a day. There are less Ruby/Python projects, but far less developers to do those projects, PHP projects and developers are a dime a dozen. In general Python/Ruby projects are better spec'ed, planned, worked on by a better class of developer and managed by someone who is going to pay you more money. Again I'm speaking from a European perspective here, but a good Rails developer in Berlin is like gold dust, you will earn double what you will as a PHP developer. You could make far, far more from developing in a different language to PHP, it's just if you suck at writing code and architecting projects and sticking to conventions (which PHP doesn't lend itself to), you'll have to stick to PHP, it's only easier to make more from PHP if you're a below average developer, you have to be at the top of your game in better languages because you'll get called out. I don't have any problem with PHP, t's portable and easy to learn and it scales well. People say it isn't languages that scale and there is a little truth in that, but PHP is a faster language than other comparable languages. The main problem is, I just think most PHP developers have far less experience, because the good ones usually leave, PHP suffers from severe brain drain. 90% of the PHP projects I've taken over, have been truly, deeply retarded, PHP developers usually fit within a demographic of web developers with around 2 years experience who never learned how to write code, and they don't need to, you can get shit working with PHP and it probably won't break, but it won't be a well thought out project. The other problem with PHP itself is the development team isn't forward thinking, brave or ambitious enough, I feel they're scared to change their old broken paradigms in case developers faced with learning the new PHP paradigm or the paradigm of a new language, they will jump ship. **tl;dr:** good developers will make more money in Python/Ruby, there's less work but even less developers. PHP suffers from a [brain drain](http://en.wikipedia.org/wiki/Brain_drain) effect. PHP needs to look forward and fix a lot of the stuff that is broken with the language itself.
Uhm, SASS translates to your stylesheets and has nothing to do with the language you are writing your backend in. Unless you edit your code on the production server.
&gt;like having to class and ID every little fucking thing Really?
Whoever is downvoting you, has never worked for a serious design agency or big clients.
&gt;The ease of PHP syntactically PHP's syntax is an abortion. Read my other post above, I don't hate PHP but the syntax is not one of its good aspects. It's a frankenstein, designed-by-committee mess. The namespacing syntax..jesus christ. Anonymous function: terrible. Can you do this in PHP? echo some_function()[0]; no, you have to do this $some_array=some_function(); echo $some_array[0]; end(array('x','y','z'); //PHP: ugly [ "w", "x", "y",].last // ruby: sexy some_function(null,null,null,0,'y',null,null,null,$something) // o rly? some_function(length:0, letter:'y', object:something) // ruby 
Dereferencing is in trunk now: http://schlueters.de/blog/archives/138-Features-in-PHP-trunk-Array-dereferencing.html I mean it was a mess but things are getting a lot better. Plus there's nothing stopping you abstracting the parts you hate. For instance, I hate the way arrays are not objects, so I use my own Arr class that has many things on it, so I can do. $my_arr-&gt;map(function($element){ echo $element-&gt;key; }); Or whatever.
I think it' more like they're all using DeWalts while they scream "We hate black and decker". The reason is with one brand you'd get better drills and with the other you'd get better hammers
Yeah, I saw that. Taken long enough hasn't it? PHP isn't ambitious or forward thinking enough.
Again I have to rant I completely agree with you, it's so frustrating. There are so many "developers" out there today who just don't have a good enough grounding in CS and programming to understand what the fucking language does. a for loop is a for loop in any language, the semantics and syntax may change but the *logic* is the same. The concept is the crucial thing after that, picking up a language is about learning syntax. 
It isn't easier to *start* writing PHP in OO, it is easier to maintain and expand it once you're done the base. Setting up three files in OO instead of one procedural file to serve a web page doesn't seem simpler, but once you start replicating class functionality in multiple pages, and extending that class to subclasses, you've got a much better foundation to build on with OO. For database connections, I use PDO in a singleton instance so no matter how many times you use it, it is only created once. I think you'd do well to download a modern CMS and pick apart the code structure. Something like SilverStripe maybe?
10%? The large travel site I work for gets 4% and dropping. 70%? Is this an IE6 fan site you're talking about? But regardless, this number is not enough on its own to make a decision. What if it's a 4% visit rate but also a below average conversion rate?
He said consider not supporting up to IE8, which is why I said 70% (inclusive all IE8 and below). And yes, there are industry and regional differences in IE6 usage. I wish it would die just as much as anyone here, but I still have clients that insist on supporting it because even 4% is too much to ignore. BTW, W3 browser statistics show IE6 at almost 6% and Statcounter puts it at 7.42%. I apologize for my quick estimating of the current browser penetrations, but the point stands.
I think it's important to have a variety of languages down. Sure, you're not going to be proficient in all of them but you'll gain perspective. You'll see why the language is built the way it is. You'll learn programming concepts that translate into any domain. More knowledge is never a bad thing. Take a day and learn python. The language is trivial to learn.
Hey, it was surprisingly fun. At least more fun than any job I've had except lifeguarding.
$POST should be $_POST and you should sanitize it with [mysql\_real\_escape\_string()](http://php.net/manual/en/function.mysql-real-escape-string.php).
i do have $_POST , for some reason it isn't showing up that way here. when you say "sanitize it" what do you mean? thanks for your help, i'm a big php/sql newb. my php renders fine, i'm just not getting my inputs placed into my database. thanks
If you don't sanitize the input it could contain bad code!
ok i understand now, this may sound really stupid, but how would i adapt that to my script.... i'm not lazy, just absolutely clueless :) thanks would it be ( string $unescaped_string [, resource $_POST ] ) ? 
$Users = mysql_real_escape_string($_POST['users']); etc
You have a stray comma in your SQL, just after `Email`. Also, wrap your values in quotes: VALUES ('$Users','$Product','$Email')"
thanks for your reply. when i plug that in, it takes away my form inputs. i suck.
Well, reddit strips my underlines $users = mysql_real_escape_string($_POST['user']);
jQuery didn't open my eyes regarding the DOM. It just took the pain away from having to use that piece of shit. The eye opener for me was getting to look past the painful parts of programming in a web browser to see the true beauty that is Javascript as a language.
Well, jQuery is mostly useful for working with DOM objects, aka "stuff in a web browser." Javascript as a language doesn't really need jQuery because there are places where it wouldn't make sense (node.js for example)
Well it's been organically created with no direction other than enabling people to do stuff easier, as opposed to other languages that have clear coordination in how they've grown.
&gt;All we all writing the same classes over and over? Hehe, that one made me laugh a bit. I've considered releasing my stuff as a lightweight framework but it's all MSSQL-centric. I would only ever release it if I could extend it to other DBs while keeping the polish.
Use prepared queries. The security benefit is worth the tiny peformance decrease in some cases. Also you should not have the database code and the template code in the same file. And when the database connection fails, throw an exception and handle it someplaces else.
When typing into Reddit, please put a backslash before your underscores (like this: \\_) or otherwise nobody can tell whether the problem is with the code or with your typing.
Is it ironic that in trying to talk about escaping strings, you didn't escape your string?
upvote for thruth serum
You need to escape underscores on reddit with a backslash. (put a backslash \\ right before any underscores that you want to show up)
Brilliant talk, thanks for sharing.
wat
http://fabien.potencier.org/article/46/twitter-and-emails-are-good-postcards-are-better Not sure why this was posted in r/php, though.
This: [http://fabien.potencier.org/article/46/twitter-and-emails-are-good-postcards-are-better](http://fabien.potencier.org/article/46/twitter-and-emails-are-good-postcards-are-better)
You're right, jQuery itself is really almost exclusively useful for DOM/CSS manipulation, event handling, and some AJAX -- all web stuff really, but I think stylistically it's got a very simple and clean approach which avoids verbosity and simply works the way you'd expect it to because there's kind of a parallel approach to all things. I don't know, but personally I think without libraries JavaScript lacks elegance and even if it's more robust than people recognize, it looks a bit clunky.
&gt; &lt;form method="$_POST" action="contact.php"&gt; &lt;form method="POST" action="contact.php"&gt;
Umm, since you're using mysql**i** not mysql, the correct function call would be $Users = $mysqli-&gt;real_escape_string($_POST['Users']); And you'd have to do this _after_ you do the `new mysqli` thing.
Get a IDE and setup debugging. Anything else is just wating time for the most part. Alot of PHP developers tend to completly ignore debugging methods and stick to echo, no good! if your really worried about security of user input i would advise using preparred statements as well as PDO. Beyind that youve already been awered i beleive
I think it would be most helpful to learn in a "real world" context. Specifically, using an ORM. Go download and try out some stuff with [Propel](http://www.propelorm.org/) and give that a whirl. It's good OO (uses getters and setters, object passing, even some advanced stuff like autoloading) and is probably something you should use anyways (it's fast and encourages a good data modeling process).
I would forget relational ideas when trying to understand OOP. There's commonly held ideas that relational and OO logic don't match up well; one name for this is [object relational impedence mismatch](/http://en.wikipedia.org/wiki/Object-relational_impedance_mismatch)
One of the reasons why it's better is code reuse. One definition that might help you is that a class is a bundle of related variables and functions, neatly tied together in a little carrying kit. If you have procedural code in multiple places that's more or less the same, stuffing it all into a class makes maintenance and deployment of that code much easier. When you update the class, the changes are autmatically propagated everywhere the class is used.
[bballbackus](http://www.reddit.com/r/PHP/comments/dvce6/sending_form_inputs_to_mysql_database_ultra_newb/c137hep) is right. May i suggest to use firefox+firebug? You can easily see what's your POST values.
Not if you do $Users = $mysqli_real_escape_string($dbc, $_POST['Users']); where $dbc is your database connection.
This is bullshit. Use PDO with prepared statements instead of mysql\_real\_escape\_string().
I would have said switch to PDO, but it looks like he's new at website development and I didn't want to give him something more complex than simple mysql/i querying.
&gt; $Users = $mysqli\_real\_escape\_string($dbc, $_POST['Users']); You have an extra `$` in there. Besides, you'd still need to call this _after_ you instantiate the MySQLi object, since that's what your `$dbc` is. Anyway, I was just pointing out benjick's mistake of recommending *mysql*\_real\_escape\_string() when the OP is clearly using MySQLi.
Your suggestion was fine, I was only pointing out an alternate way of doing it if he hadn't made a mysqli object, but rather just opened a DB connection.
Anyone who knows what they're doing should have already moved onto Kohana: http://kohanaframework.org
OOP and Autoload are my two favorite organizational crutches.
If you want my opinion, this sounds like a waste for a database. All you're doing is checking if a key exists. Just setup a config file and add values as you need. Also~ I hope you've sanitized input. This screams XSS. Edit: I'm hoping no-one helps you here, this is the most basic simple entry level stuff you need to learn by Googling and/or getting a book. Instead, here is advice on best practices. * Sanitize user input, both in the url key you've mentioned and the form field(s). If PHP 5.2.x or newer, make use of the filter functions, otherwise Google about sanitizing user input. * Use PDO * Use Prepared statements to help combat injection vulnerabilities. 
So you have a paywall that consists of an ID that anyone can append to the url and might show up in Google eventually? Also, if it's just a number or some type of code, people WILL most definitely try to append IDs that are not their own, either manually or automated. Why did you decide to go with this instead of the more standard username / password combination?
You'd want to do some learning and figure out how to utilize the PDO abstraction. At minimum you want prepared statements. -- your sql drop table if exists affiliates; create table if not exists affiliates( id int unsigned not null auto_increment primary key, affiliate_id int unsigned not null unique ) engine = InnoDB; // add affiliate $mysqli = new mysqli($host, $username, $password, $dbname /**, $port, $socket**/); $stmt = $mysqli-&gt;stmt_init(); $stmt-&gt;prepare('insert into affiliates values(null, ?)'); $stmt-&gt;bind_param('i', $affiliateId); $stmt-&gt;execute(); $stmt-&gt;close(); $mysqli-&gt;close(); // select affiliate $mysqli = new mysqli($host, $username, $password, $dbname /**, $port, $socket**/); $stmt = $mysqli-&gt;stmt_init(); $stmt-&gt;prepare('select * from affliates where affiliate_id = ?'); $stmt-&gt;bind_param("i",$affiliateId); $stmt-&gt;bind_result($id, $result); $stmt-&gt;execute(); if(!$stmt-&gt;fetch()) { // failure, the ID does not exist. throw an error } You mentioned you know your way around php, so I shouldn't need to mention that the $host, $username, $password, $dbname, and $affiliateId are undelcared and need to be in order for this to work. I didn't test it, so there may be other things in there that don't work. Should get you started, though. 
Yup. This is seriously the kind of stuff you're likely to keep doing. Best to learn it now. 
Thanks man! I'll try this!
Well the whole point is people appending the code manually. But only the people who paid for it. Because with a standard username/password combination, a user would be able to use his ID, but since he will be promoting that website with his own ID, other visitors must be able to access it too. 
&gt; I'm hoping no-one helps you here Wow.
i tend to follow several guiding principles, 1) No code duplication - encapsulation generally helps reduce redundancy across the board. 2) Simple, clean code - take advantage of syntax shortcuts where not prohibitively expensive, abstract out functionality that exceeds four or five nested conditions and/or loops, and refactor often. 3) NO global classes(i.e. singletons), or global functionality in general. Yes, there are very specific cases where this is appropriate - but unless you know them, don't do it. Prior to PHP 5 this often was not a choice and so many legacy developers may disagree. Before said developers excoriate me for my blasphemy, understand that the paradigm has shifted away from that procedural non-sense which has unfortunately defined so many great, albeit flawed, web applications. On a final note as a core developer, MVC may be a great platform to develop small to medium sized web applications. But not so for large applications which easily become unwieldy and bloated. 
There are literally [16 million examples out there](http://www.google.com/search?q=php+mysql+example). Part of being a good developer is making proper use of Google and finding the answer, not asking on for yet another example here. It may sound harsh but I'm trying to help not start you off expecting hand holding on day one. 
And off he goes with his copy/paste code he knows nothing about. Nice work guy. 
Not everyone learns the same way. Some people need a direct link between their problem and the code in front of them to begin to understand the solution. In any case, what do I care if he doesn't know anything about the code? He'll learn it the easy way, he'll learn it the hard way, or he'll stop trying to make websites. I couldn't care less.
I am not a developer nor I want to be. I am simply an entrepreneur. My worker is on holiday and I needed this done quickly because the idea changed (long story).
I see. This is called "security through obscurity". unless you're okay with giving most of your content away for free, I would suggest looking at other access models. Here's a scenario that will happen: * Bob signs up through an affiliate; accesses the content on your site and bookmarks the url * Bob cancels his subscription and realises he still has FREE access to the content * Bob sends the link to 5 of his buddies. * ... * Loss?
You have a developer? Wait for him to come back from holiday. I'm serious. You are not in as much of a hurry as you think you are.
It's not a subscription, it's a one-time payment thing. Also, Bob will get deleted from the user list if he requests a refund. Thus, his affiliate code will no longer work.
You security solution is completely pointless and trivial, the holes in your pay wall would possibly brush the mirrors of the 20 18-wheelers driving side by side as they pass through it. If you aren't a developer, pay a developer $500 to implement something and give you training (since you are obviously interested in learning how this works) or buy a $50 book for beginners. I'd recommend Welling and Thompson PHP &amp; MySQL Development as a great item to have on your bookshelf - just get the most current revision.
Thanks for the concern, but I haven't explained the whole story. This is NOT how users will authenticate. There is a much more sophisticated system in place for user authentication (a paid script). Thank you all for your opinions but all I wanted to know was how to get that thing done that I mentioned in the OP.
I'd say learn another language or two, different languages offer new skills and challenges. I felt the same way about my code, that it was just kind of haphazardly organized in whatever way I thought was best and for me it never seemed to quite fit. MVC Frameworks are nice, they give you a place to put things and a way to organize concepts. They also handle a lot of the sticky and/or ugly details with user facing systems, so they can be a huge boon. But when you need to write a back-end system you're stuck with the same problem. I think a MVC solves an instance of your problem, but doesn't actually answer your overall question. My thoughts on project structure and organization only really started to mature after writing systems that were much more complex. The main thing that got me there were my use of two languages that have fairly strong name spacing, Java and Flex(ActionScript). With Java you use a lot of libraries which are name spaced the same as your source files, and thus you don't have to think much about your project structure. That's my two cents, let the down votes begin. tl;dr: Learn a new language, it's good for you.
good luck :p
This. An additional suggestion which I haven't seen mentioned is make your functions smaller and name them better! Aim for around 20 lines at the maximum and if it exceeds that then ask yourself if you can refactor part of it into it's own function. This makes it very easy, given a function overview, to see which part of the code you need to edit, it also means that you can change the code however you want so long as the intput and output stays the same and it's guaranteed to not affect any other code.
Autoloaders with Zend's directory structure (or rather, pretty much every framework's structure) are a good idea for sure. One very basic example is: function autoloader($class) { $location = str_replace("_", "/", strtolower($class)); $location = BASEDIR . "classes/". $location . ".php"; return (file_exists($location) and include($location)); } spl_autoload_register("autoloader"); new Not_Included_Class(); // Will load classes/not/included/class.php class some_other_class extends another_not_included_class { } `spl_autoload_register()` allows you to add one or more functions or class methods to a stack of functions that are executed when you try to call a nonexistent class. To add a class method to the stack: spl_autoload_register(array("myclass", "myfunction")); spl_autoload_register(array($myclass, "myfunction")); This shouldn't incur too much overhead. You could always make some system that caches file locations or something but you probably won't need that unless you're Facebook. An autoloader like the example above only has two 'heavy' function calls: `file_exists()` and `include()`, which is not that much worse than `include\_once()`. For me, personally, the file structure is easily read as well: classes/ model.php # class model{} model/ mysql.php # class model_mysql {} page.php # class model_page {} controller.php # class controller {} controller/ default.php page.php user.php admin.php admin/ user.php cms.php # class controller_admin_cms {} The only downside I can see is when you're using an editor that doesn't show full file paths in tabs. If you have a `controller_page` and `model_page` class, then it would show "page.php" in both of them.
I don't really like the implicity of autoload, as I don't like one class per file much. It is useful. I personally use a pythonic "import" method. Yes, it's weird as hell, but I see it more as an aesthetic difference, and I use the lowercase.module.name standard to differentiate between modules and classes. So I might have a session handler module that has the classes `\Core\Session\Handler`, `\Core\Session\HandlerContainer` in it, that I'd then import with `import('core.session.handler');`, at the top of a file that needs it. Explicit and consistent. Example: http://github.com/radiosilence/trouble/blob/master/trouble/kill.php
Doing some work on the vanilla forums recently, and that seems to have sub-divided parts of the code into separate "applications". One MVC engine runs the lot, but there is an application for the front end, another for the admin screens, another for some shared functionality etc. I think this prevents it becoming too unwieldy by grouping related functionality.
Be careful the login code from this guy(login tutorial) can be hacked easily by injecting SQL. These tutorials may be good to get to know PHP but please don't try to develop web apps after this. There is really a lot more to it.
MVC Framework is really the only way to go if you want truly organized code and rapid applications development.
OOP and Autoload is the way to go. Especially if you're using newer PHP and use namespaces. But OOP and Autoload are only tools to HELP you better organize your code. The single greatest thing you can do to keep your code clean, organized and maintainable is Test Driven Development. [These](http://www.slideshare.net/avalanche123/clean-code-5281847) are some great slides a co-worker of mine put together. If you mock out your API and make sure it's fully unit testable the quality of your code will improve dramatically. A good IDE will help with this too (which one is a whole other discussion) as good intellisense and built-in testing support make it much easier to to keep things organized and under control. In a multi-developer environment a CI (Continuous Integration) server is priceless as well.
Autoload is slow and may disable some of your opcode caching.
Mine is semi-Object Oriented style. I have objects for: database, user management, business logic for the site, templating(Smarty) and many more objects like data models. The main things I emphasize is: - making the code readable and simple - decoupling areas like business logic and presentation - don't repeat code I don't think echoing HTML is a good thing, for one the IDE can't help you with that, it becomes harder to stop mistakes. I recommend you get a template engine(like Smarty) and separate the HTML from the PHP.
This is the only way. And I've been there with multiple model.php files open (still love textmate though)
Wordpress
We're all just trying to help you avoid a big gaping hole in your (otherwise secure?) setup. A system is only as secure as its weakest link.
.... I follow pep 8
php is opne source :) and you can make money..it is very easy to learn
Some people hate it. Some like it. But what I do is use a lot of spaces and tabs, IMO, its nice to read and clean looking. if ( $model-&gt;saved ( ) == true &amp;&amp; in_model ( 'user_id', $user_id, $model ) ) { $category_finder = $this-&gt;factory-&gt;create ( '__finders__category' ); $categories = ( $this-&gt;input-&gt;get-&gt;game_id &gt; 0 ) ? $category_finder-&gt;find_all_by_game ( $game_id ) : $category_finder-&gt;find_all ( ); ...etc ... }
Personally, I don't like spaces directly inside parentheses. But I like to put a space directly after if/for/foreach/while, so it becomes: if ($x == $y) Just a different preference I guess.
make the code into modules and into separate files..dont mess the code of others
i've settled on trying to space everything out as much as possible, like this: # comment if ($x == $y) { while ($something &gt; $x) { $x += some_function( $y ); } } # maybe another comment else { die(); } # # define a function # @argument: argument description # returns result as a string function some_function( $argument ) { # do something... return $string; }
I prefer to use as much whitespace as possible, because that makes things easier to read, and I have a large screen! I use the [Allman style](http://en.wikipedia.org/wiki/Indent_style#Allman_style_.28bsd_in_Emacs.29) for curly braces, and usually have an empty line before and after any full-line comment.
I code like this... if (!$context) { $context = ($this-&gt;scope() == "cms" ? "cms" : "website"); $locale = $this-&gt;locale-&gt;values($context, $name, true); // If no website locale, fallback onto cms locale if (!$locale &amp;&amp; $context == "website") { $locale = $this-&gt;locale-&gt;values("cms", $name, true); } } else if (is_array($context)) { foreach ($context as $value) { $locale = $this-&gt;locale-&gt;values($value, $name, $strict); if ($locale !== false) { break; } } } else { $locale = $this-&gt;locale-&gt;values($context, $name, $strict); } It's spaced out enough to be readable, but still compact enough to show a lot of code on screen at one. In function I tend to not use the global keyword and instead opt to use $GLOBALS to make it clear which variables are global.
If we're talking "written" style, I generally follow [K&amp;R](http://en.wikipedia.org/wiki/Indent_style#K.26R_style), with elements of the [Python Style Guide](http://www.python.org/dev/peps/pep-0008/) and the [Java one](http://www.oracle.com/technetwork/java/codeconvtoc-136057.html). I also hate newlines, so most of my open-brackets are on the same line. Following English rules helps too, I think; I'd rather see "if (foo)" than "if ( foo )". The latter looks unnatural to me. In terms of architecture, I'm OOP all the way unless it's something seriously throwaway (or a "runner" file that instantiates objects and starts them working). I use MVC a lot too. 
Except you know, that none of the PHP frameworks implements MVC. It's usually some variation of PMVC or MVP. So even though real MVC cannot be used for web apps, it's a good orientation pattern for code and flow structure.
Interesting. What exactly does your `import()` function do? Replace dots with slashes and then require\_once? Do you keep a list of modules that have already been imported? Does it have an impact on performance over autoloading, especially with an opcode cache?
Never, ever mix PHP, SQL, and HTML. They each belong in different places. As long as you remember this, it doesn't matter what organizational structure you use!
I put almost everything in PHP-tags and echo stuff.
I'm the same way. I go for: if(case1 != case2) { dothis(); } It just looks cleaner to me.
You want to use a "design framework" or MVC like [zend](http://framework.zend.com/), [symphony](http://www.symfony-project.org/) (my favorite), [cakeMVC](http://cakephp.org/)... THis allows for easy and logical separation of your project into three main components: Model (the db code), View (the html/presentation code), Controller (the bit in the middle that sticks them together; sort of like the page specific php in that anything that doesn't have to be in the controller should't [but that's just from an OO/code reusability standpoint])
Half-assed MVC style. Main script dumps everything into an array and does no output, then tells a renderer object to go off and do something, which includes a bunch of files that contain all the `echo` and `?&gt;` stuff. I don't bother with frameworks because it's simple enough already. *Edit: ooh, silent downvotes for advocating MVC. Cute.*
I guess I'm on the hate it side. IMO spacing out the parens make things much more difficult to read. To each his or her own.
My code is formatted very similarly. I also have a little MVC framework I put together a while back that I use. 
http://github.com/radiosilence/core/blob/master/importer.php It's called with import_module.
why not? if (!$context) { $context = ($this-&gt;scope() == "cms" ? "cms" : "website"); $locale = $this-&gt;locale-&gt;values($context, $name, true); if (!$locale &amp;&amp; $context == "website") $locale = $this-&gt;locale-&gt;values("cms", $name, true); } else if (is_array($context)) foreach ($context as $value) if ($this-&gt;locale-&gt;values($value, $name, $strict) !== false) break; else $locale = $this-&gt;locale-&gt;values($context, $name, $strict);
You're much better off following an existing standard. In the PHP world the most common one is [Zend](http://framework.zend.com/manual/en/coding-standard.coding-style.html). This is especially important when writing open source code you plan to release. By using a standard many people can work on the code without having conflicting styles involved.
The one thing I do that is different from most other people is writing my code in what I like to think of as paragraphs. That is, when I start a new idea I put a couple of new lines between it. (Assuming that it's not a new function, etc...)
Yes. Take a look at [Zend Framework Coding Standard for PHP](http://framework.zend.com/manual/en/coding-standard.html).
Holy shit, that's Pythonic. `import` throwing `ImportError` and all. Now all you need to do is get rid of all those stupid dollar signs and curly braces...
I like the brackets, I find it to be more readable and easier to navigate code blocks. (One of the main reason I could never get into python) Edit: I should point out the change of the local function call being in the if statement before the "break" would break my code since $locale is no longer set which gets used further down. It would need to be if (($locale = $this-&gt;locale-&gt;values($value, $name, $strict)) !== false) which I tend to not like to do
[[citation needed]]
I'll sometimes still compress stuff, but only in certain instances. Like if I need to do something stupid like this (really contrived example, but you should get the idea): if ($x &gt; 1) $x++;
I follow C whitespace guidelines from K&amp;R, Linus Torvalds and a bit from jwz. OO all the way except for prototyping.
If you end up doing PHP at a work place, you'll want to follow a standard. It's good to get yourself acclimated to changing your coding style based on the development team your working with. When reading code, you shouldn't be able to tell if it's yours or the people you're working with. If your code stands out, you're doing it wrong. [Zend](http://framework.zend.com/manual/en/coding-standard.html) has a coding standard that the company I work for follows. As far as echoing HTML inside your PHP - it can easily get hard to follow. It's much easier to read code that follows the MVC pattern. Even simply separating the business and presentation logic into independent files, makes a world of difference. 
I imagine the downvotes are for saying you don't use frameworks. It took me a long time to move from rolling my own everything, to just using what's already there. A few other people are advocating MVC as well.
pep 8
Yes oh god yes! Lined up curly braces = easy definition of scope - no hunting at the end of lines for the opening brace.
CakePHP does a pretty damn good job of implementing MVC.
thanks. do you know why my database is showing empty rows everytime i try a test input? the rows increase with each submit, but they are blank.
thanks. do you know why my database is showing empty rows everytime i try a test input? the rows increase with each submit, but they are blank.
thanks. do you know why my database is showing empty rows everytime i try a test input? the rows increase with each submit, but they are blank.
If you're still using the query $sql = "INSERT INTO Customers (Users,Product,Email) VALUES ($Users,$Product,$Email)"; try $sql = "INSERT INTO Customers (Users,Product,Email) VALUES ('$Users','$Product','$Email')"; instead.
no luck. rows inserted to set on sumbit but it's all blank when i check to see if they were there. mysql&gt; select* from Customers; +-------+---------+-------+ | Users | Product | Email | +-------+---------+-------+ | name | product | email | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | +-------+---------+-------+ 13 rows in set (0.00 sec) a lil empty up in there
I agree with everything but I've found myself using template engines less and less. It's easier for me to just use PHP and keep logic out of the file instead of remembering the Smarty/Twig/Dwoo syntax.
Not sure who downvoted you, but I do that as well. Helpful if it's something like if ($x == 1) $y++ else { //do stuff }
I change those in code that I edit, I hate them so much. [1TBS or die](http://en.wikipedia.org/wiki/Indent_style#Variant:_1TBS)
Read a book?
If you can do that that's fine too.The main thing is not to mix things that aren't supposed to be mixed. I am rather conformable with the Smarty syntax, but I know that there is no one-size-fits all solution for decoupling the presentation from everything else.
Have you tried any of the MVC frameworks? They do almost exactly what you described. I know that CodeIgniter has plugins for template engines.
A man can but dream :) And what's the points of looking like all the other frameworks, you got to have something special. Conforming to PEP8 quite a bit is kinda fun. Also curly braces can be made less obvious in one's IDE.
I didn't really feel the need to do that, I just create Data Access Objects that manage the database operations(with my database object), and provide an API for managing the data, I have Smarty templates and I have my business logic scripts which most of the time are just switch and case statements. I am working on replacing the later one(business logic) with objects that contain methods, that map to actions. I have done a lot of experimentation, I have wrote a lot of data model frameworks and stuff like that but then I realized that this is not what I should be doing because I don't spend most of my time on the server side, I work more on the client side. TL;DR: I did not feel the need to use any MVC frameworks because my simplistic approach worked so far.
i made a small page for another redditor a few weeks ago - this page was viewed *only* by redditors. [This](http://i.imgur.com/T8LNg.jpg) is a screenshot of the browser breakdown. I'm proud of reddit.
That might be so. It's arguably one with more a understandable API and nice docs. But anyway, if Model===Database, then it's called PMVC (Passive-MVC).
Understood. I know there's this MVC craze going on in PHP right now, was just curious if you've found it worked for you. Certainly if your current arrangement gets the job done and you're comfortable, I wouldn't advocate switching gears.
Is the code the same as in your post?
I have to say, that's a pretty selfish way to code. I have a preferred style but I *adopt* that of whatever code base I'm working on. Consistency within a single code base much more important than my personal preferences.
http://zend-framework-community.634137.n4.nabble.com/ZF-and-Autoloading-td640085i20.html http://forum.lighttpd.net/topic/17500 http://forum.kohanaframework.org/discussion/1435/web-site-optimization-maximum-website-performance-using-kohana/p1 As far as it being slower from the start (ignoring the debate over opcode) you can see for yourself using MICROTIME(TRUE). I work in a high-traffic environment and the small bit of convenience of not having to specifically include class files isn't worth the trade-off.
That extra line takes up too much vertical space, and I find it much harder to follow. If I'm working on something that someone wrote years ago and I'm the only one currently working on it, then I don't see the problem altering it to my tastes.
That happened, then it hit me again: Braces are utterly meaningless and redundant in properly indented code. 1tbs ftw.
[FTW!](http://github.com/radiosilence/core/blob/master/core/session/handler.php)
What if you need to add a line?
orgasmic
VIM
everything is the same seriously, javascript is actionscript 5 or more years ago, everytime I see a new canvas 'experiment' it makes me wonder why we have to recreate the same shit over and over and over again.
I'd say XML / JSON in a database is much worse than EAV. Generic columns and dynamically changing the table schema violate the relational model too. I'd have to admit that programmers jump to EAV a bit too quickly following the desire to build a "general" solution. However, sometimes it is the right solution using the tools we've been given.
Well there's already flourish and Zend libraries if you so chose. What would you be library-izing, and what don't you like that you've encountered so far?
HTML helper, like.. take an array, a "selected" value and create a dropdown from it. Some other things: - PHP integration with jQuery or any other JavaScript Library, so you can dynamically create dynamic client-side scripts ;) - Image manipulation, resize, watermark etc.. - User authentication class 
if($x=$y){ while($a=$b){function();} }else{ die(); }
I agree only I dislike } else { and prefer } else {
please dont do this. if you are going to follow up with an else statement.
Leave notes. Lots of Notes.
It's mostly just for quick stuff, I don't throw huge blocks of logic after the `else` statement. Do you have a suggestion for something better?
yeah just include the {} tags for the first statement. if ($x == 1){ $y++ }else{ //do stuff }
The Facebook devs have stated publicly that they consider PHP to be a technical liability and if they were to do the whole thing again they wouldn't be using it. I'm not going to go railing against PHP, but let's stick to the facts.
Oh, I thought you meant some other type of logic, not just a personal preference.
You can master PHP or Python in a few months of intense work, but I have never really seen anyone with a mastery of C++ or Lisp who hasn't spent at least 5 years with the language.
aye, yeah its more preference. 
If it's abandoned, why not pick it up? Sounds like a perfect opportunity if you're excited about it.
I'm not 100% clear on the legalities of this. I know it's open source ... but if it's abandoned, is it still ok to pick up and claim as my own with credit to original? Also, I don't really want to work on a project by myself. I'm looking for something that make my team experience stronger... and also teach my the best practices for source control.
Well if this is all on the same page, then it is grabbing the (empty) post fields, then executing the SQL, *then* rendering the HTML. The SQL insert has to be on the page it is posting too.
Is there supposed to be a link attached to this?
That is the worst thing I've ever seen.
Invest some time learning Zend Framework. It's worth it.
PHP 5.3
You should check out [ProjectPier](http://www.projectpier.org). Development has slowed down lately, but it has a solid code base, and they are looking for new developers.
The fact is that it works. It may not be the most technically efficient way to go about things, but development is mainly about getting things done in the first place.
Check out LemonStand: http://lemonstandapp.com
($x == 1)?$do_stuff:$other_stuff;
Yes, that's the entire point of open source. Git is designed around the act of forking code. Look at Ubuntu (forked from Debian), xorg (forked from XFree86), or Webkit/Safari/Google Chrome (forked from KHTML). It happens all the time. Hell, you can do it with an active project if you're not happy with the development pace or focus (look at Joomla and Mambo). I'd say find something interesting to fork and take over. Do some initial work and use that effort to attract a team. You can really build your resume that way. 
Is there a good listing site or some good methods of finding abandoned Open Source projects? I'm learning Python and know a decent bit of PHP and would like to do the same to improve my resume .. thanks.
Same here. My C, Perl, and PHP are nearly identical and all K&amp;R formatted. As for style, I tend to use a php file that contains all my functions and db calls. My html files then just call it like &lt;?php dofunc();?&gt;. Keeps my stuff easier to manage, in my opinion.
I think the real challenge with a project like this is to convince programmers that there is value in programming their backends in this library instead of raw PHP, or a full-fledged framework. I took a quick glance around the code. For things like string processing, I would recommend trying to use built-in PHP functionality to accomplish what you want whenever possible, since extensions are written in C. For instance, the Ik_Util_String::isUTF8() method could be replaced with this one line: return iconv('UTF-8', 'UTF-8//IGNORE', $string) == $string; Not only is the code much shorter, but it runs about 20x faster. The iconv and pcre extensions are invaluable standard extensions, leverage them whenever possible. Performance is going to matter a lot if you are going to replace low-level functionality, or provide convenience methods. The other recommendation I have is to specify what open source license this will all be released under.
This is the purpose of the Fork button on every github project. It copies the entire project to your account and allows you to make changes under your own name, while still keeping it linked to the original code. If the original project does finally get updated, you can merge the updates into your own code, and can also submit suggested changes back to the original author in the form of a Pull Request.
If you're interested in maybe working on a WordPress plugin, could you take a look at [Virtual Pages](http://wordpress.org/extend/plugins/virtual-pages/) and maybe figure out why it works great for some people and is completely broken for others? I can't find a culprit plugin or anything that the people with issues have in common.
I'd say every project would love help. All of my projects need help, but if you're really keen, I'd love some help with [SimplePie](http://simplepie.org/). It's one of the most used feed parsing plugins for PHP (used by WordPress, so you'd also be benefiting them), but all of us developers have little time to work on things. We have [a lot of issues](http://github.com/rmccue/SimplePie/issues) which need some time (even to just triage), and I'd love some help with that. If you'd like to help, email simplepie[at]ryanmccue.info and I can help you get started. :) Edit: fixed formatting. That's what I get for typing fast.
Why do you have the brace on its own line after the if and else, but not after the function declaration?
This is perfect. It needs to be the #1 comment, it is dead on. Also, I am a developer living in the US who does php/ruby/python and the numbers you mentioned for Berlin/London are pretty similar to what is happening over here. I will say this though, in the last six months I have been getting a lot more requests for Rails based projects. Maybe like 45% php, 45% rails, 5% python.
The only thing I would have done differently is how I approach the logical flow of your conditional statements. It's hard for me to explain but I approach all code blocks with a "most true" conditions come first. I could define what I mean by "most true" but it would probably take less time to demonstrate. Your code has three conditions: 1) !$context 2) is_array($context) 3) $context &amp;&amp; !is_array($context) Among those I would say #2 is your "most true" statement because it is highly specific and it's making a positive assertion. If you also had "$context instanceof Something", that would come before the is_array statement. The #1 condition would end up being the "else" statement because it is actually the "least true" of the three. This would end us up with: 1) is_array($context) 2) $context 3) !$context You can see the example is already simplified because in your example by the third condition it is possible for $context to exist but not if it's an array whereas in my example by the third condition it is only possible for $context to not exist and no other stipulations are needed. If $context does not exist the 1st condition will fail and so will the 2nd. By adhering to this method of approaching conditionals, developers who are familiar with my style can scan my code even quicker because they know what *kind* of statements to expect towards the beginning or end of conditional statements. It also makes it easier to insert new conditions and highlight assumptions. If you look at the new series of conditions you'll notice that statement #2 will pass for any value that equates to true. We may want to replace that with "is_string($context)" or "is_numeric($context)". Scanning several conditionals all marked this way line up better. Just a thought. Everyone has a preference and the more important thing is to be consistent. EDIT-formatting
If you were receiving downvotes it was probably because your response to "what's your preferred style [...]" started with "Half-assed" :P
If I put: $model-&gt;saved = 'oh noes'; $this-&gt;factory-&gt;create = true; In front of your code, everything becomes nightmarishly confusing to me. To each his own but I wouldn't rely on a coding style where two innocuous, albeit strangely named, variable assignments can wreak havoc on readability. EDIT-reading my comment maybe "wreak havoc" was exaggerating.
if you do fork something I'd be totally up for joining you, I was thinking of posting something like this a while ago.
a) every time you load that page you have $Users, $Product, etc. empty. and the query will put in the db your empty values. b) put an isset($\_POST['Users']) before your mysql query, if you have not $_POST it will not execute the query. c) check with firebug if you are actually passing those POST variables.
One cool free software project you could contribute to is libre.fm, a replacement for last.fm. Libre.fm is based on GNU FM, which you could also work on. Another option is GNU social, a free replacement for Facebook. I'm going to be contributing to social very soon, I'm excited. As for the legality of taking a free software project and making it your own, timdorr already answered but I wanted to clarify. For a program to qualify as free software, it must--at the very least--be released under a license that will grant you the four freedoms. You can fork actively developed projects, you can resurrect abandoned projects, you can do anything as long as you release your modifications under a compatible license. On a personal note, I think it's wonderful when developers fork code or take over an abandoned project; that's a fundamental freedom we all deserve with software. Good luck finding a good project to work on. I'd like an update when you finally wget going on one. :)
I'm curious to know what's inside that foreach loop. Perhaps another foreach would be a good guess.
There was just some display code in there.
I do that too, only sometimes I take into account possible values, like in this case $context could be an empty array which to structure it your way, I would have to do this: if ($context &amp;&amp; is_array($context)) { ... } else if ($context) { ... } else { ... } or if ($context) { if (is_array($context)) { ... } else { ... } } else { ... } I don't like using the same condition "if ($context) {" twice in the if/else blocks and I would rather opt for the choice with the least amount of nesting. In this case $context also by default has no value so it also makes sense in that regard to come first. Edit: come to think about it, I do tend to put the absolute falsest value first then from truest to falsest. This is because often times I can do: if (!$value) { return false; } And get that out of the way right away to prevent having to check all these other logic statements first that may not even except false values.
Or spaces after the parameter brackets in functions but not if and while statements.
Watching this makes me feel a lot better about the material I'm creating ;-)
No, you just gave a PHP noob enough code to hang their business! If anyone loses a job because the guy rushed this to production and all their crap gets stolen ... man, i wouldn't want your potential karmic debt!
Did you know that you just basically recreated __autoload() only in a less "catch-all" way?
&gt; Zend Framework, for example, checks everything when running in production all the time Hey, what's the alternative? I'd *love* to know!
What's going on here? What's "pep 8"? 
I've used Ubercart for a similar system. It's not the simplest setup, but I believe there are modules that will get this set up for you. If you decide to try it, go post on their forums, there are helpful people there that know the Ubercart system much better than I do.
 class MyClass { public static function getFoos($isVisible) { if ($isVisible === true) { $db = MyDB::loadDB(); $db-&gt;query('Select foo FROM bar WHERE isVisible=true'); $foos = $db-&gt;fetchAll('Foo'); foreach ($foos as /** @var Foo **/ $foo) { echo $foo-&gt;bar . "\n"; } } } }
RosettaBlog. Aiming to support Drupal, Wordpress, and Joomla backend Databases, themes (and hopefully plugins) in a BSD Licensed project. rosetta@phppro.phpexperts.pro I hang out in #phpexperts on freenode, and I also provide one-on-one PHP mentorship for those just starting out or wanting to get better. EDIT: RosettaBlog is a joint effort by myself and students of the phppro course. It's a great place to learn how to code professionally, without repeating all the noob mistakes that all the books/tutorials/most other php devs promulgate (like XSS flaws, SQL injection bugs, etc.) plus you learn design patterns, proper encapsulation, etc., etc.
and since OP is trying to learn, check out this link: http://www.cs.tut.fi/~jkorpela/forms/methods.html
I hang out on #phpexperts @ FreeNode (IRC) and give one-on-one php mentoring to anyone who wants it. One of my services for the PHP community.
[wouldn't something like this be easier](http://php.net/manual/en/function.eval.php)?
If eval is the answer, the question is wrong.
I'm confused about the difference between your two examples. Neither one is checking for an empty array. You raise a good point though, I do consider the "Is X missing a value?" to be my first condition in cases like this (I still try to phrase it as a positive assertion): if (empty($context)) { ... } elseif (is_array($context) { ... } else { ... } Empty will return true if $context is an array with no values (also integer 0, string "0", string "", null, and false which you might not want it to do).
This is why people write unit tests. Come up with a few scenarios to test and what the output should be. Then code the tests to pass in and verify the output. You don't need a full testing framework like PHPUnit (although it's awesome) to do this, just write a little bit of code that hooks into your functions.
I have to admit, the thought did cross my mind. It didn't stay in there very long, though :-P Too much of the input is coming from a user. I'd rather not risk opening a potential attack vector.
Oh, don't worry. Whatever code I end up using will be unit tested. Heavily :-)
If I have: $list = array(); if (!$list) { echo "Empty array"; } That would echo "Empty array" I tend to not bother using empty, since !$value generally does the same thing.
I think there's and error in your logic. This part: foreach($c as $k=&gt;$v) When used on an array like this: $conditional = array( false, false, 'and' =&gt; array(...) ); Will give you those results: #1st run $k = 0, $v = false #2nd run $k = 1, $v = false #3rd run $k = 'and', $v = Array Thus you will get a true as a result, but from what I gather a false and false while using the OR comparision should return false, thus the whole condition should be false.
I know that this doesn't address your actual question, but I feel like descriptive variable names make for much more readable code. What exactly is $c? What is $v? If you describe these variables with their names, then it may make returning to your code easier.
$v is getting overwritten with a recursive call to evaluate(), so the variable will never contain an array past the loop.
I have just checked this and I think you are mistaken, sir :-) I have tried the following array as an input: $conditional = array( false, false, 'and' =&gt; array(true,true) ); And, while the result is false, the operator defaults to AND: so it **should** return false. Because you mentioned the OR operator, I assume you may have meant this: $conditional = array( 'or' =&gt; array( false, false, 'and' =&gt; array(true,true) ) ); This actually results in true, as it should. Your assertion that "a false and a false while using the OR comparison should return false", doesn't apply because more than two things are being ORed together. An OR on an arbitrary number of expressions will always result in true if at least one of those expressions evaluates to be true. Thanks anyway :-)
$c is a conditional, $k is the key and $v is the value. I completely understand your concern, but "$k =&gt; $v" is pretty common shorthand for "$key =&gt; $value". As for $c, I do agree: I should have spent the time to write the extra few characters, and will do when the code is taken outside the context of a quick test file :-)
Yeah, the main variable that I was referring to was $c. I write $key and $value in my foreach loops if it makes sense.
Just because $k =&gt; $v is common doesn't mean you should use it. In your case $k is what in your array? An "operator"? And the $v looks like it is always a boolean. So wouldn't something like this be easier to read? foreach ($conditional as $operator =&gt; $option) { ...
I can't check *every* possible condition in unit tests. I just wanted to see if anyone could spot any subtle mistakes that I might miss in unit testing, or if anyone had any suggestions for improvement. 
$k is *sometimes* an operator, other times it's just a numeric key. $v is *sometimes* a boolean and other time it's an array. &gt; Just because $k =&gt; $v is common doesn't mean you should use it I am aware of this particular nugget of wisdom, and I realise my code could have been more readable, but it's just a test I hacked together in 10 minutes. It will be re-written in a more understandable form if and when it makes it into the rest of the code-base. Also, you wouldn't use $iterator instead of $i in a for loop, would you?... Or would you? :-P
We don't need another one that does it wrong. There are many more possibly valid characters in the local part than there are in that horrid little regex. Smarter people with more time on their hands have [already done a pretty darn good job](http://www.dominicsayers.com/isemail/) building email validation routines. And even then, there's no better way to validate an email address than to actually send it mail.
as far as open source licenses go some require you to distribute the source code, some do not, though it doesn't change your ability to charge for the product either way if you decide in the future. basically BSD licenses let you do just about anything provided you keep the license in tact. GPL license has what's called "copy left" this means your code must also be under GPL and must also be open source.
It sounds like you're looking to improve your own abilities, volunteer with an open source framework, new frameworks pop up constantly and you can learn a lot from working with one. also frameworks are centered around following best practices and efficiency, it sounds like it would be right up your alley.
I am eagerly awaiting the release of the RAD framework [Lithium](http://lithify.me/). Their development (or at least the release) is stalled, but I'm too busy to help out.
Oh, sorry, my bad - I thought that it only took the first two arguments into consideration (so "false OR false").
A quick hand count puts the cyclomatic complexity at 9, so it seems like you could get really good coverage fairly easily.
Can you please explain why? I understand the security implications if you're eval()'ing anything that's come from user input, but if everything is properly sanitized, or picked from a whitelist (as in this case), then what's the problem?
I'm afraid I fail to see your point. Just because a set of unit tests pass doesn't mean the piece of code being tested is "correct". There may be a situation I hadn't considered when writing them, that someone smarter that me might spot, that I could then write a unit test for. The XML is irrelevant to any unit tests covering this function. Testing both the XML parser and the evaluate function at the same time would not be a *unit* test.
That, kind sir, is genuinely useful information :-)
An easy mistake to make, sir :-)
Np. I just figured if user input was restricted to a tightly controlled whitelist you might be OK, and save yourself a lot of headache! I've actually tackled this problem before (also for a reporting system), but it was in Pascal.. a long time ago.. :)
The trick is to write the tests first. Really, if you write the tests after the application you're only testing what you already know will work.
I think you would be much better off modeling this with classes instead of arrays. Something like this: interface Expression { function evaluate(); } class TrueExpression implements Expression { function evaluate() { return true; } } class FalseExpression implements Expression { function evaluate() { return false; } } class AndExpression implements Expression { function __construct(Expression $cond1, Expression $cond2) { $this-&gt;cond1 = $cond1; $this-&gt;cond2 = $cond2; } function evaluate() { return $this-&gt;cond1-&gt;evaluate() &amp;&amp; $this-&gt;cond2-&gt;evaluate(); } } A Or-Expression can be implemented analogously and also expanding it to work with multiple conditions should not be too difficult. This way you will end up with a type-safe logic system.
&gt; Also, you wouldn't use $iterator instead of $i in a for loop, would you? That's a horrible example. With an iterator you have a value that is isolated to one line in the for loop definition and maybe used in loop, but you never actually manipulate it. But okay, lets say $k and $v is accepted as $key and $value. Then what are they keys and values of? It's easy enough to tell *what* the code is doing it, but not *why*, which is the part you're going to forget in 3 months.
Ok, I get it. $k and $v, or even $key and $value are a bad choice of variable name. It's a tiny function in a a throwaway test file. Should I add docblocks to the function too? 
That does seem a little over the top, but is worth considering none the less. Thank you.
Very true. Had I not been in a rush to get my ideas into code, I would have done this.
Speed would be the most obvious answer. eval() is slow and risky to use. Also, handling errors would be a lot harder.
it may seem over the top but I found it far easier to understand his code than yours
this isn't necessarily true, i've found a perfect use case for eval(). the 2.x version of the Kohana Framework uses it for transparent class extensions. they have a cascading file system, so application/libraries/class.php is found over system/libraries/class.php. you can extend the class.php file with out having to copy and paste it. this is because libraries have a suffix called _Core(aka Database_Core) even though the user only calls "new Database();". this means if someone transparently extended database they create a class in application/libraries/ and do "class Database extends Database_Core" what eval did is create that empty class if the extension didnt exist, this functionality is super effective and not possible with out creating an extra file for each class in place of using a simple eval statement
Well, it wasn't possible until PHP5.3. You can use [class_alias](http://php.net/class_alias) to do that now :-)
Yes but because it is called explicitly it means you control what you are loading.
I don't think speed would be a legitimate issue in context, but fair enough, I can see how error handling could quickly become a pain. Also, I well understand the risks, I have developed in a lot of languages before coming to PHP, which I think helps build a much more solid foundation of good habits! Cheers though.
I'll bet that Java's your first language too.
Always add doc blocks before you write the actual function. ;)
IMO, it's simple: If you're *building a string of code* to execute, there is something critically wrong with the flow of your program. If you can write the logic to write the code that you need to execute, you can probably also just write the code to begin with. Now, there are use cases, and it can be used safely by whitelisting, but it's still a horrible, horrible practice.
I'd actually argue that this isn't a valid use case for eval. It's only needed because PHP's OO mechanism is less flexible than more "modern" languages. That being said, that's kind of clever. 
I applied to help with this project sometime last year, the guy running it emailed me back saying "yeah sure, I'll get back to you". That was the last I heard of it. Oh well...
no, php is
wow good find didn't know that existed
Windows 7, XAMPP, Dreamweaver CS5, Photoshop and FireBug in Firefox. Develop PHP/HTML/CSS perfectly. Used to use Notepad++ but opening and saving files when using Codeigniter got a bit tedious. 
It will return true with an empty array, is this a problem?
Well, I used to have another developer, but he disappeared. I have been working on a CMS for awhile, still quite small (I am in the process of redoing some aspects) compared to some, but I am always in need of help. It's called [SnowCMS](http://snowcms.googlecode.com/)
thanks for clarifying. if only my professor could. he is all like you do this, this, this, and this. the first time i heard him say "copy the code" i knew it was going to be a long semester. we are trudging our way through php with no reasoning, rules, or explanation. you are a life saver. i learned more from your comment than i did in lecture last week. doh! any books or resources you would recommend? 
Well yeah, I see your point. I guess it all depends on how people interpret reading it. Its like trim(implode('++',$some_array))... some people may read literal as "trim, implode by '++' for some_array" others may read it as PHP would "explode some_array by '++', then trim the result". PHP syntax just sucks completely in general.
There is no need to increment the variable name :) $actualpost = str_replace('[b]', '&lt;b&gt;', $replacmentquotes); $actualpost = str_ireplace("[/b]","&lt;/b&gt;",$actualpost); $actualpost = str_ireplace("[img]",$imgvariable,$actualpost); Will work fine. Alternatively, put the result of one str_replace as the last argument in another str_replace, this will result in really long lines though.
Did you know that `str_ireplace` supports arrays? $actualpost = str_ireplace( array( '[b]', '[/b]', '[img]', ), array( '&lt;b&gt;', '&lt;/b&gt;', $imgvariable, ), $replacequotes ); 
You can actually pass str_replace and str_ireplace arrays as parameters and do find/replace on all of them at once. [PHP Manual](http://us3.php.net/manual/en/function.str-ireplace.php) Aside from that, it's sort of poor form but perfectly valid to reuse variable names. I find it considerably less terrible in your use case, since they would all be blocked together so it's obvious. But go with the arrays as arguments.
I generally use the counter in a for loop to describe the purpose of the loop.. 
Oh I'm not very helpful. But there was indeed a website specifically for that. It listed various FLOSS projects looking for contributors. (Damn bookmarks creep.)
this deserve many upvotes
This goes to my post [here](http://www.reddit.com/r/PHP/comments/dw4x3/a_quick_logic_check_please_rphp/c13dhzy?context=3) but it seems like you are continually proving that posting this snippet on Reddit was a waste of time. You already know it works. You have unit tests for it. And apparently it's also going to be re-written.
You might want to [take a peek at this excellent article on character encoding and PHP](http://kore-nordmann.de/blog/php_charset_encoding_FAQ.html). By "take a peek at," I mean read from top to bottom.
Sizzle isn't invoked if you use jQuery on an id; ie. $('#myElm') does not use the sizzle engine, it uses document.getElementById. You can read this: http://www.neeraj.name/2010/02/15/how-jquery-selects-elements-using-sizzle.html for a more indepth look at when sizzle is and isn't used.
I think the point of that blog post was to enlighten devs on how punycode domains influence whatever email (or URL) validation method they use, not actually provide a bullet proof method of validating one.
PHPMailer. Many sites I work on (most?) require sending email at some point, and PHPMailer takes all the pain out of sending email via PHP.
Not at all. It's the desired behaviour if anything :-) Thank you.
I can see what you mean, it definitely does *feel* wrong, but I was hoping to nail it down to something more specific! Admittedly, I've never once used it, but I can imagine in the right situation it could be very useful?.. Coming from other languages, PHP certainly does seem to be very amenable to bad practice though..
TBH I'd recommend using PHPMarkdown over coding your own probably buggy BBCode implementation.
[You're doing it wrong.](http://php.net/bbcode)
bbcode is so *yeasterday*. It was created for people that understand HTML yet think that other people would prefer square brackets and it suddenly does not look messy, technical and complicated. Yes, go with markdown. It also does not look bad if displayed without formatting. And you mention "buggy". It is already obvious that "[b][b]hi!" is immediately going to generate invalid markup that the browser needs to cope with.
exactly this
Not a Joomla! issue - most probably an encoding problem. 
Mmmmm, XSS-ilicious!
Yes
Thank you for this. It's discussion of [UTF-8](http://www.utf8-chartable.de/) inspired me to find the [answer for Joomla](http://docs.joomla.org/Language_Guidelines_for_3rd_Party_Extensions). Now I need to try to implement it.
&gt; The alternative is to actually test the software before putting it in production. That's what unit tests are for. &gt; Write tests that ensure protected and private methods works and are called as expected The _public_ methods are the ones that need testing. They specify the contract of your library. &gt; instead of filtering and validating the parameters and return values in production. So how do you handle incorrect parameters? &gt; For example lets say there is no need for a setAction method in a request class to be called by anything other than a router. This means even though the method must be public there's no point in filter or validate the input parameters, it's enough to test the router. Now you've taken away validation and introduced a cross-cutting concern and broken encapsulation. The request doesn't do validation, but the router does it _for_ the request, because it's gotta happen at some point. Not to mention you've introduced an invisible dependency between classes. "It's okay to call this public method as long as the caller is a router." &gt; My main concern is not the performance overhead. It's that you end up with a large codebase where you never know if a method will be called with the wrong parameters or not, or who is calling it. If there is no checks and instead you have complete tests maintenance and refactoring is so much simpler. I think you just contradicted everything you said previously.
All translations files should be saved as UTF-8 with no Byte Order Mark (Notepad++ or PSPad can do that for you). Databases should also be be UTF-8. The character encoding of the actual .php files can be in ANSI, usually without any problems. Also, make sure you have the correct &lt;META&gt; tag in your template if applicable to ensure the output is encoded as UTF-8.
wait wiat wait. What is Tonido?
Having this same exact issue with Flash. I can't display foreign text. Does anyone know if you can send data without html entities? 
Can you encode the HTML into a JSON array, and decode it in Flash?
I'm not sure, I will be looking this up though!
I'd leave them as entities. I've found PHP often fucks up encoding especially with UTF-8. Have you seen the amount of sites that have weird, broken characters for the £ sign?
True, but right now my Flash displays things like &amp; reg; for registration marks. There isn't a way to convert it in Flash without running through a giant array. (Sidenote: I made this array in Flash and it actually slowed the IDE down considerably, that's how big it was!) 
I'm not sure, in that case. Perhaps have PHP strip the characters/replace them with equivalents, instead? Or explore the route of having his PHP specifically use the utf8_encode() function. PHP can definitely send the unencoded things, and if you're pulling things in for flash you should have a separate (perhaps XML or JSON) API for doing that, not pulling in HTML. Perhaps something like this: http://php.net/manual/en/function.html-entity-decode.php Then something like this: http://uk2.php.net/utf8_encode Then, for kicks: http://michelf.com/projects/php-smartypants/
My God! Noobs, learn about mbstring.
Thank you. This is exactly what I was looking for!
I am on a shared host and can't use extensions or I would be all over that
Wouldn't get anywhere with that. Not only do I have safeguards in place to prevent it, but the forum (where you would have to post) would not allow any kind of scripting either.
I am going to give this a go, thanks for the suggestion. You are right my BBcode implementation is buggy but I spent hours when I first developed the site looking for a decent parser and could not find one.
OMG!! OK! Going back to my "Why most PHP coders suck" posts: As a fucking php noob, you used * A fracking IDE instead of a glorified notepad, * PHPUnit, * Xdebug -- and probably even, gasp, breakpoints! * Object oriented programming, * You know what design patterns are, and used them. Crap! I'd be more willing to work with you after a day of cross-training than the majority of current and past senior PHP dev coworkers!~
It's not me. I just posted the link because I thought it was a very objective review of PHP. Also, I started out in PHP but currently use C# at work.
I'm curious, as a C# programmer, how different is it to pick up PHP in your opinion, I haven't tried PHP but I'm very interested in it, and how difficult was it for you to go from PHP to C#? (also I haven't read the article yet will do so soon) 
Use the [binary-coded decimal](http://www.php.net/manual/en/ref.bc.php) functions for money computations. Floating point is by its nature imprecise, so in this case you have two crappy options. Edit: A crappier third option: Use sql to do your multiplication.
I think I already explained, I know about bcmath but it only returns truncated numbers. It doesn't round, and it only returns fixed precision. Issues with that, with the bc math functions: 5.04/4 = 1.26 bcdiv(5,4,2) returns "1.2" 5/11 = .4545 repeating bcdiv(5,11,{any odd number}) returns "0.4545....4"
I cannot comment on how difficult it is to pick up PHP, but the experience of going from PHP to C# can vary wildly depending on the skill level. Because PHP is in such wide use the skill level of PHP developers also varies wildly. Some PHP developers know little more than conditional and looping structures, for example.
Beware, there are some mistakes made in this review. I started writing up a post to point them out but it was taking too much time. Here's a short list ... * He doesn't seem to understand methods are case-insensitive so the choice between PascalCase and lowerCamelCase is negligible. He could stick to the convention he knows and loves while the PHP community can stick to theirs. * He complains about the lack of a lambda/anonymous function shorthand (C# uses "=&gt;" apparently while PHP has "= function(){ ... };"). Totally unreasonable comparison, imho. PHP syntax is very forgiving. Using the more explicit syntax is an advantage here just as the shorthand used in C# is an advantage there because C# is not as forgiving. * His understanding of namespace usage in PHP is off (totally understandable, it's very different). Believes that "importing" namespace libraries is more tedious than it needs to be. * A brief glance at his source code he misunderstands how PHP uses values by reference (he has several methods where the parameter only accepts an object and a by reference &amp; is used, totally unnecessary). Some of his complaints were valid and I share them. Very cool post none-the-less.
Thats why I only partner with designers who do their own HTML. Make them their damn cut.
As I said, Markdown :)
Thanks for your input!
I just recently finished porting a good size db monitoring app from C# to PHP. The hardest part, by far, was the GUI. That was probably 99% of the time. Easy stuff like drag and drop required js libs and testing on all sorts of browsers. Even little stuff like dialogs became a hassle. The actual heavy lifting parts of the code were pretty easy, though I ended up dumping a lot of the OO stuff in favor of more procedural code. Fyi, my background is C/C++, but I have also done a lot of Perl. PHP to me is pretty similar to Perl, so it wasn't much of a stretch. &lt;edit, typo&gt;
Anyone know how to get this to work? I installed the beta version through pear, I created a simple git clone stanza: &lt;pre&gt; &lt;mkdir dir="./build" /&gt; &lt;property name="repo.dir" value="/tmp/build/buildperfectcredit.git" /&gt; &lt;resolvepath propertyName="repo.dir.resolved" file="${repo.dir}" /&gt; &lt;gitclone repository="git@github.com:username/repo.git" targetPath="${repo.dir.resolved}" /&gt; &lt;/target&gt; &lt;/pre&gt; I get the following error: Could not create task/type: 'gitclone'. Make sure that this class has been declared using taskdef / typedef. Any thoughts? 
schmalls, your review is by far the most objective and awesome review of PHP by any coder of another competitive language that I have ever read! In fact, it is the **only** objective of PHP review by a non-PHP engineer I've ever read ;O
Make sure your data source is UTF-8 encoded xml/JSON, etc. and that should fix your problems.
&gt; I could just pad with an immensely large number, but this still doesn't feel precise since it truncates at the end. You *do not* want automatic unlimited precision, because `1 / 3` would crash your server. What you can do is decide how much precision you want, add 2 digits and round. E.g. if you are interested in the first 10 digits after the decimal: $result = bcdiv('3.1415' , '2.71828183', 12); $result = round($result, 10); edit: If you are doing the kind of computations where 0.0000000000000000000000 != 0.0000000000000000000001, chances are you can reserve some budget to commission a PHP extension that you can use to perform these precise computations, if the bc* functions don't cut it ;)
I think his criticism of PHP's lambda syntax is valid.
Fixed it with this function function convertHTMLEntities(str:String):String { var ar = [ ["‘","&amp;lsquo;"], ["’","&amp;rsquo;"], ["“","&amp;ldquo;"], ["”","&amp;rdquo;"], ["›","&amp;rsaquo;"], ["‹","&amp;lsaquo;"], ["‾","&amp;oline;"], ["/","&amp;frasl;"], ["–","&amp;ndash;"], [" ","&amp;nbsp;"], ["¡","&amp;iexcl;"], ['"',"&amp;quot;"], ["'","&amp;apos;"], ["&amp;","&amp;amp;"], ["&lt;","&amp;lt;"], ["&gt;","&amp;gt;"], ["£","&amp;pound;"], ["€","&amp;euro;"], ["©","&amp;copy;"], ["®","&amp;reg;"], ["™","&amp;trade;"], ["À","&amp;Agrave;"], ["Á","&amp;Aacute;"], ["Â","&amp;Acirc;"], ["Ã","&amp;Atilde;"], ["Ä","&amp;Auml;"], ["Å","&amp;Aring;"], ["Æ","&amp;AElig;"], ["Ç","&amp;Ccedil;"], ["È","&amp;Egrave;"], ["É","&amp;Eacute;"], ["Ê","&amp;Ecirc;"], ["Ë","&amp;Euml;"], ["Ì","&amp;Igrave;"], ["Í","&amp;Iacute;"], ["Î","&amp;Icirc;"], ["Ï","&amp;Iuml;"], ["Ñ","&amp;Ntilde;"], ["Ò","&amp;Ograve;"], ["Ó","&amp;Oacute;"], ["Ô","&amp;Ocirc;"], ["Õ","&amp;Otilde;"], ["Ö","&amp;Ouml;"], ["Ø","&amp;Oslash;"], ["Ù","&amp;Ugrave;"], ["Ú","&amp;Uacute;"], ["Û","&amp;Ucirc;"], ["Ü","&amp;Uuml;"], ["Ý","&amp;Yacute;"], ["ß","&amp;szlig;"], ["à","&amp;agrave;"], ["á","&amp;aacute;"], ["â","&amp;acirc;"], ["ã","&amp;atilde;"], ["ä","&amp;auml;"], ["å","&amp;aring;"], ["æ","&amp;aelig;"], ["ç","&amp;ccedil;"], ["è","&amp;egrave;"], ["é","&amp;eacute;"], ["ê","&amp;ecirc;"], ["ë","&amp;euml;"], ["ì","&amp;igrave;"], ["í","&amp;iacute;"], ["î","&amp;icirc;"], ["ï","&amp;iuml;"], ["ñ","&amp;ntilde;"], ["ò","&amp;ograve;"], ["ó","&amp;oacute;"], ["ô","&amp;ocirc;"], ["õ","&amp;otilde;"], ["ö","&amp;ouml;"], ["ø","&amp;oslash;"], ["ù","&amp;ugrave;"], ["ú","&amp;uacute;"], ["û","&amp;ucirc;"], ["ü","&amp;uuml;"], ["ý","&amp;yacute;"], ["ÿ","&amp;yuml;"] ] var i = ar.length; while (i--) { str = str.split(ar[i][1]).join(ar[i][0]); } return str } 
To go from C# to PHP should not be much of a stretch in my opinion. It will require you to give up some of the most convenient features from C# though (getters/setters, enumerations, generics, extension methods, delegates). However you will do get a lot of things that are more magical than in C# (no variable declarations, magic methods). The biggest difference is the IDE integration. Visual Studio is extremely awesome. The best I have found is Netbeans, but it's just not quite as polished. Going to C# was very easy for me. It takes very little to pick up the differences, and anything that is strange can be quickly picked up from an internet search (Stackoverflow is a great C# resource). Of course, I did have a working code base when I started with C#, and I was able to pick up a lot from it. I could also see a lot that was wrong with the code because I had studied many advanced PHP object oriented topics. The worst part about my transition to C# was ASP.NET Web Forms. It is possibly the most poorly designed thing I have seen. PHP is **much** better in this regard. Fortunately in anything new I am writing, I am able to use ASP.NET MVC and have added the String Template view engine which gets me into much more familiar territory. The best part about C# is the .NET framework. I prefer it to the PHP libraries because I lean toward object oriented instead of the mostly procedural nature of PHP. I'm sure I could write a lot more about this topic, but this should be a good starting point. Feel free to ask me anything else.
Hey thanks! Yeah, I just finished a 40 course on C# and have a decent grasp on how to use it and make my own programs and We've just started with ASP.NET using C# and doing webpages after these next 40 days I plan on my christmas break to drive into PHP, and then maybe after I get my ASP.NET certification try and do either Pearl or Ruby but my brother said it'd be best to get my feet wet with PHP since it's used heavily and is the most higher-able next to Java and C#, there is a place currently in ST.Louis(where I live) looking for 40 Java programmers so I'm up in the air on weather I should get into PHP or go back to focusing on Java since I already know it pretty well.
I had to use Java for a few courses I took at school. I am happy I don't have to use Java anymore, but if you can handle it, more power to you. Do you know what kind of ASP.NET you'll be doing (Web Forms or MVC)? Hopefully you will get to work with MVC and never have to work with Web Forms. PHP is definitely a good skill to pick up. There are plenty of jobs you can find with it. The most important thing is to just to pick up good programming practices. A good programmer can pick up a new language pretty quickly if necessary. Most best practices are language independent. Another good language to pick up may be Python. I have only done a few things with it (mostly hacks to Trac). There is a lot of momentum behind it and as far as I can tell, it is a really well designed language.
&gt; He doesn't seem to understand methods are case-insensitive so the choice between PascalCase and lowerCamelCase is negligible. He could stick to the convention he knows and loves while the PHP community can stick to theirs. method names are case-sensitive in C#? if so that's horrible... edit - actually i guess it's probably not that big of a deal if you're using an IDE with auto-complete. but I just think of how annoying it would be for someone like me who codes mostly in notepad++ and tracking down such an issue.
Damnit I hate sites that put a ton of text in the ALT tags for links/images because it forces me to go through them all and read them
Well as for ASP.NET the courses is geared towards certification so I assume it will have a sample of just about everything, main focus is web site stuff like login, shopping carts, and I guess what Web forms, yeah that sounds right To save credit card data and among other things. I'll be picking up a PHP book of a sort have any suggestions there? 
not a bad little tutorial and it is a good exercise for wrapping your head around detaching your application from the terminal. However there are three things to consider if you are going to write something that you want in production. * First don't write it in PHP everyone else is going to laugh at you. * Second if you absolutely want it in PHP make sure you are using the most recent version of PHP the memory management is much better than previous versions. * Thirdly you will probably want to use a much more robust daemon so use the pear System_Daemon package.
It depends on how many digits precision you need to be aware of. The size of a float is platform-dependent, although a maximum of ~1.8e308 with a precision of roughly 14 decimal digits is a common value. 14 digits precision is normally good enough for most financial applications. There's 2 options. Spend hours/days/weeks/months getting 100% accuracy, or if you are happy that you wont need more than 14 digits precision, then just use normal floating point numbers. Whats the point of having accuracy to 14 digits if you never use more than 5?
If you know that you'll only be dealing in rationals, not reals, and you want infinite precision on repeating decimals, maybe you'd benefit from writing your own Fraction class. What are you using this math for?
I really like these series of articles. It's read something about PHP that isn't flame or how to write a login script.
I use SQL Buddy and it is awesome. Works for Sqlite databases too.
I've been using phpminiadmin for a while and I like it.
Great post, thanks. You should do a write-up on a handful of desktop MySQL clients like Querious (plus a tutorial on how to set it up).
Anyone who codes C# in notepad++ instead of Visual Studio (On windows anyways) is an idiot :D (Especially considering there is a free version of VS)
I figured it out. You have to use the svn nightly build, the beta version in pear currently does not support git. Thanks to cweiske in the irc channel for the help.
C# and PHP are my primary languages. I personally think they are very similar, including the OOP (Same one base class with interfaces). The real difference is that PHP is interpreted and a much looser language to program in. This means you have to be a bit more careful on what you do as there is less hand holding. Going from C# to PHP is probably better the going from PHP to C# as it's really easy to code awful PHP.
Thanks for the input!
Decimal number arithmetic recently bugged the crap out of me with a Concur integration project. Often off by a penny in 1 out of 300 or so line items. We thought up a couple of solutions (a couple of them involving strings) but I ended up going with: &gt;floor(round($dollars * 100 * getCurrencyExchange(), 1)) I round to the mill (which we don't care about) then truncate it with floor. If I didn't use round, floor would sometimes drop a penny where the $5.00 float was internally stored to ~ 4.999999999999 after a couple of multiplications. I think we may encounter an instance where rounding to the mill will take the value up a penny when it shouldn't, in that case I have a couple of options: Increase the precision of the round, or unfortunately switch to picking the currency apart as a string and casting the bits to ints.
In PHP, variable names are case sensitive. Why not class and method names? I guess in the case of our uninformed C# =&gt; PHP porter, it would suck to care about such things and not know they are case insensitive.
On the client side, I've always been in love with Squirrel. It's Java based so it runs anywhere and it works with any available JDBC driver you have, which is great since they are commonly available.
I realize this was posted to the php subreddit but if you can get ssh access its well worth the time to just setup a ssh tunnel and use a desktop client and forget server side scripts for db admin. You can also double tunnel if your db server is not in your dmz. I develop mainly on Windows and I've been using a combination of putty with tunnels saved in a config, Launchy with the putty plugin and SQLyog. It works very well.
Forgive me for asking, but can you point me somewhere where I can set this?
&gt; Adminer supports MySQL, PostgreSQL, SQLite, SQL Server, and Oracle It's cuz they use PDO and know about the Factory pattern. I use it all the time and highly recommend it.
Once again! Something from the PHP Dark Arts series that I did in PHP-Egg in PHP 3 starting in 1999 lol. http://sf.net/projects/php-egg/
No book recommendations. I have never bought a PHP book.
Actually case sensitivity is a great thing in my opinion. I will often name my private variables in lowerCamelCase and public ones with UpperCamelCase. This seems to be a pretty common paradigm in C# for having a private property and a public field to access it.
Could you help me understand how that is helpful over require()?
@Graydoubt: Awesome drill-down.
1. You obviously do not have the slightest idea what "encapsulation" is all about. 2. In my experience, you absolutely **have** to code a "contract" for your API, or be happy with it failing mysteriously when you or others code it improperly later (by accident or malice). 3. There is no other (known) method besides incomplete typehinting and is_numeric() type checks.
Valid point. Here's how you properly do SQL: $pdo = new PDO('mysql:host=localhost;dbname=mydb', 'db_user', 'db_pass'); $statement = $pdo-&gt;query('SELECT * FROM Users WHERE username=? AND password=?'); $statement-&gt;execute(array($username, $password)); $user = $statement-&gt;fetchObject(); Secure, safe, simple, portable.
Another desktop client: Quest's Toad MySQL freeware. It has schema and data compare options too. I would avoid the synchronize option as the resulting diff could be optimized (ie. dropping a whole table just for a simple alter column statement.. WTH?).
Wrapping it means you don't have to worry about file extensions, search paths, and you can throw exceptions etc.
Mmm, sites then? tutorials? and what not? or just us our trust google :P
I tend to learn best by looking at other's code. I would pick a good framework (maybe Zend) and just see how they implement different things. This will kill two birds because you will be learning the language and learning the best practices. Then when you need to do something that isn't covered by the framework, you can use Google to look up solutions to your problem. Now that you know the best practices, you can easily determine someone who knows what they are doing from someone who does not.
For Windows, I really like HeidiSQL.
Agree. Having any sort of db admin script on your server is a potential liability. And desktop clients are convenient and fast. And for GUI, MySQL has its own desktop admin clients available for free download. MySQL Administrator, MySQL Workbench, etc.
My favorite desktop client thus far: Sequel Pro. Only for OSX, but damn is it nice.
Thanks!
It was a great day in my dev career when I found Sequel Pro
SQL Buddy has a nice interface, but it has some quirks when entering data.
Oh god. I'm getting flashbacks to the time I had to use VB6 in school. Noooooo.
desktop tool for database work is much better than web based.
neither. i am illiterate. also, i am a cat.
Hit, I read it as a variable name.
I read "shit" because I thought it was a pun in an article title. If I were reading code I would have read it as "hit is now me" or something like that.
I always say "S -- hit equals me" for whatever reason I always say the $ as "S" when reading code &gt;.&lt;
I use SQL Buddy havent had a problem entering anything, what are you entering?
Dollar hit is me.
Hmm, you're going to need a signal handler if you're ever going to turn off that daemon. I hope the author follows up with this. (Or did he already cover signal handling in his previous articles on process control? Too lazy to look it up hehe)
Yup! "Just pass user_id to getUser so you can find out who they are" "Why the fuck are you passing passwords in GET?!?"
I think you may have done something wrong, given I see you downvoted in every php thread.
My employer has 3 senior engineers that spent 60% of their time each week keeping openx alive. We all dream of replacing it one day with anything else. Unfortunately best recommendation is to write your own, just keep it super simple.
Get off the internetz Cat. You don't belong there. You can't even type!
woah, upvoted for showing me this awesome application. Thanks.
Same.
I said, "PARSE ERROR!"
yeah that's probably what I'm going to end up doing
In my mind I call it cash
I read this as Notice: Use of undefined constant me - assumed 'me' in http://www.reddit.com/r/PHP/comments/dxcab/hit_me/ on line 1
One of the nifty things about supervisor is that the config file can include other config files and can work with globs. This makes per-developer setup on a shared machine insanely easy to set up and maintain. It also has an [XML-RPC API](http://supervisord.org/api.html) for easy monitoring and control. 
PHP-wise, [PHPDeveloper](http://www.phpdeveloper.org/) and [Zend Developer Zone](http://devzone.zend.com/public/view) are on my daily reads. The various "planet" collections for other tools you use in conjunction with PHP can be valuable, like [this one for PostgreSQL](http://planet.postgresql.org/). There's [one for PHP](http://www.planet-php.net/), but I vaguely recall it being unhelpful and stopped reading it. Maybe it's changed since then.
Can you explain what this part is about? foreach ($foos as /\*\* @var Foo \*\*/ $foo specifically, /\*\* @var Foo \*\*/ is this an artifact for documentation or something?
I had no idea what it was for o_O I'm going to have a read up so, whether its useful to me or not, I actually get its place in the universe.
Yeah I quite like that one too. Used SQLYog for awhile too but now it nags you to buy it.
&gt; Having any sort of db admin script on your server is a potential liability. If you watch your logs I can guarantee you'll see 404s to http://yourdomain.com/phpmyadmin as well as other common ones. Not sure if they plan to brute force it or if there's a known vulnerability but either way I've made a point of picking obscure paths when using phpmyadmin.
[Here](http://www.reddit.com/r/PHP/), obviously.
Check Sourceforge. They have a help-wanted section under Developers. If you find an abandoned project, they may even help you out in arranging with the old owners transferring the project to you.
thanks for the heads up... looks fantastic
Oh yeah, I've watched the logs. Endless daily attempts by China and Russia to find an admin script on my servers. I've set up a rule on the firewalls that looks for those types of requests and then blacklists the offending IP. It helps to keep the hacker spam to a minimum. Using obscure and unadvertised paths is definitely the way to go if you must use an admin script. But you can never be too careful. One day a web server vulnerability may arise that opens up your whole directory structure and allows a hacker to easily locate other vulnerable files. If someone has the key, they can open the door. It's best to just remove the door if possible.
C.R.E.A.M get the money.
http://www.heidisql.com/ is an awesome, free Windows MySQL desktop client.
[phpArchitect](http://www.phparch.com/) has some nice stuff. [ajaxian](http://ajaxian.com/by/topic/php) maybe
Pity EllisLab can't find a way to channel the great CI community. I'd rather more effort going into one kickass framework that 2000 CI-like frameworks. Sidenote, the source is on Bitbucket.
I read it as a syntax error.
That's truth.
The back and forth between Derek, Dan and Phil in the comments is very interesting.
and their grammar and spelling sucks
These are all very good. Recently I've been following [jonathan wage](http://www.jwage.com/)
Shit is me.
Dollar hit equals me
What are you doing in PHP that is so hard to debug in your head?
SQLBuddy FTW. Desktop SQL clients can be a pain, host may not allow remote connections, etc etc. SQL Buddy requires no actual install and works great.
If you find setting up debugging with Eclipse PDT too complex, you can always try Netbeans or PhpStorm. I'd also recommend installing [easy Xdebug](https://addons.mozilla.org/en-US/firefox/addon/58688/) to easily toggle the xdebug session cookie on/off. Xdebug needs to be installed wherever you're testing against. Don't install it on production servers however.
Getting Eclipse/PDT working with xdebug is worth it. You'll probably be using xdebug no matter what client you end up using. You could give netbeans a try, too, but IME it will hang (be really slow) and crash often when debugging code with a huge amount of data in scope. P.S. I also gave up the first time I tried to get xdebug working.
Yeah really. If your PHP is so complicated that you can't debug it with a print statement you are doing something wrong.
I use Xdebug with Netbeans. Netbeans has one feature I didn't find in Eclipse: it lets you choose the url to load at the beginning of a debugging session. This means I might be debugging myClass.php, which is actually loaded from several pages on the site. Or heck, I've got a controller that loads everything through index.php. Eclipse wants to load myClass.php directly, but I want to start the session with the correct params to get where I want to go. Netbeans lets me set some automatic path mapping or can ask me every time, which is what I do. Netbeans will also debug Javascript by loading a Firefox extension it can talk to. All that said, probably 99% of my debugging is still printing out data. I've got a global helper function that prints out anything I throw at it using var_dump and puts it in a div at the top of the page. Most of my debugging is just looking at what value some variable is, so this is quicker. Xdebug is useful for more complex code.
Definitely get xdebug working, but consider writing more / better unit tests with PHPUnit. You'll find that you don't need the debugger quite so much.
Kohana 3 needs better docs
NuSphere, and PhpEd
Well played, sir...
Yeah it really does, although once you get familiar with it, it's pretty easy to look into the API browser and figure it out.
Agreed. There's a lot of bitching in a I'm-not-really-bitching-but kind of way.
NuSphere PHPed is by far the best for debugging!! Zend Studio for external PHP Unit tests and profiling.
Yep, but doing that is such a time-consuming process, I don't want to hunt down by looking through code how to do something, almost defeats the purpose of using a RAD framework
Developing in a mixed Mac / Linux environment, I find myself going back to Zend Studio for this level of debugging. I've always found it to be pretty hassle free to get running. PhpEd may be worth checking into, but seeing that it's windows native, I've always skipped over it in the past.
NetBeans is usable and free. By far the best IDE I've used to date is SlickEdit, but be prepared to part with $300 after a 15-day trial, or $50/year if you're a student.
Another nifty thing is that you are starting to use Python!!! :D
I still haven't changed from Zend Studio 5.5.1 with Zend Debugger. I tried many IDEs and despite the numerous bugs of ZS 5.5.1, it's still my favorite IDE, especially for the debugger integration with Firefox. Most of the reasons why I prefer ZS are subtle, but they make a pretty big overall difference. It's definitely not recommended since it's a dead end and serious bugs creep up often. All subsequent flavors of Zend Studio are terrible IMO. So terrible that I was unable to actually use it on several occasions where I gave it a try. Sometimes it would just be unable to create a project at all, sometimes just munch up CPU in a loop for no visible reason. Aptana is supposed to be great for PHP but lack of time to follow on the complicated installation on Linux has stopped me from trying so far. I made a search 2-3 weeks ago to look at a replacement. The state of PHP IDEs is pretty pitiful...
 Error establishing a database connection 
Eh, I don't think using an application counts as using the underlying language. If that counted, we've been using Python for ages: Trac.
or throwing an error instead of content. FAST!
Or you could use [Kohana](http://kohanaframework.org/) like every other sane CI developer that has moved onto greater things.
&gt; I don't want to hunt down by looking through code Did you read the parent's comment? He said [API Browser](http://kohanaframework.org/guide/api), not attempting to be a code-sleuth and looking for needed functionality.
3. You should be using prepared statements for everything. prepare -&gt; bind -&gt; execute. It eliminates the need to escape your variables. Does every query need to be in its own try/catch?
I'm no Linux guru by any stretch of the imagination, but my Aptana "installation" was downloading Aptana_Studio_3_Setup_Linux_x86_64_3.0.0.zip from their server, unzipping and running "Aptana Studio 3/AptanaStudio3" and ... that's it. I keep switching back and forth between Aptana 3 and Netbeans 7 ... but I think Netbeans may win in the long run because I can't figure out how to edit FTP connections in Aptana 3 once I've already got them set. Plus Netbeans 7 let's me reuse the same connection across multiple projects and add subdirectory locations to them. Oh, and it lets me set CTRL + ALT + S and CTRL + ALT + D as upload/download without having to mess with weird keyboard shortcuts that aren't part of the core program.
&gt; 1: I prefer working with object results ... There should be effectively no performance difference between using fetchObject and using fetch with the object flag, if that's what you're asking. Can you clarify? &gt; 2: How do I return MySQL errors for malformed SQL statements? You should be getting back the complete error in the exception that PDO throws on an error. If you've switched it into warning mode, you can use errorCode() and errorInfo() on both the PDO object and on statement handles to get error information. errorInfo in particular should return the complete MySQL error string. &gt; 3: so should I stop mysql_real_escape_string'ing (or if I go query() route, quote()) my input Yes. Also, you *don't* need to use bindParam, you can pass params directly into execute: $sh = $db-&gt;prepare('SELECT foo FROM Bar WHERE baz = ?'); $success = $sh-&gt;execute(array( $something )); You'll still need to use quote() if you encounter a situation where putting together the query manually ends up being easier. This can happen sometimes. Placeholders just make quoting automatic when they're used, that's all. &gt; 4: What else do you suggest I read in addition to the manual? Practice makes perfect.
Ok, I was actually only try/catch'ing the execute, not fetch. I'll try that now I guess! And once I write out the code and test it and fix bugs, I usually remove try/catch'es ... from what I understand, that's the accepted practice, correct? No longer need to try/catch if you know it works?
Site down? [Google Cache](http://webcache.googleusercontent.com/search?q=cache:blogs.sitepoint.com/2010/10/29/faster-web-pages-php-buffer-flush/) Bonus: Try these [Google Bookmarklets](http://googlesystem.blogspot.com/2007/07/useful-google-bookmarklets.html)
What? I'm not being sarcastic.
Error info: http://www.php.net/manual/en/pdostatement.errorinfo.php If you use placeholders and replace them using bindPAram or passed in the execute there is no need to escape. If you use query, then you will still need to escape (but mysql_real_escape_string only works if mysql_connect has been called) so you will have to use http://php.net/manual/en/pdo.quote.php
1. Yeah, I was thinking it returns double the bytes (fetch and fetchObject) but I know it's simply dup. information. I'll stick with fetchObject then since it simply eliminates any questions about what information I'll be working with. 2. I'll try/catch the actual fetch query now! 3. I'm thinking for longer, more complicated queries, having everything plainly written out will work better in the long run, especially if I have to move WHERE's around ... but I can see that working fine for smaller, or set-in-stone queries. Thanks for the hint!
No, you should leave the try-catches in. Just because it works now in testing doesn't mean it will always work, or that it will work in production. Better to always handle errors gracefully.
Proper query formatting can make placeholders a breeze. Which makes it easier to spot the placeholders: SELECT argle, bargle, what, ok, itisnotbutter, rly, k FROM Amazing RIGHT JOIN Awful ON(Amazing.id = Awful.amazing_id) WHERE argle IS NOT NULL AND thing = ? AND (b = ? OR c = ?) AND pedantic = 't' or SELECT argle, bargle, what, ok, itisnotbutter, rly, k FROM Amazing RIGHT JOIN Awful ON(Amazing.id = Awful.amazing_id) WHERE argle IS NOT NULL AND thing = ? AND (b = ? OR c = ?) AND pedantic = 't' A downside to placeholders is that there has to be one and only one for every array argument. You can't pass in an array for one value and have it automatically expand the arguments. I've found this pattern to be useful: $some_values = array( 1, 2, 99, 436, -1 ); $questions = join(', ', array_fill(0, count($some_values), '?')); $query = "SELECT what FROM Things WHERE id IN({$questions})"; $sh = $db-&gt;prepare($query); $success = $sh-&gt;execute($some_values); No more need to manually string together the query when you need a variable number of arguments. By just pushing values onto the array, it also makes construction of variable WHERE clauses a bit easier. PDO also supports named placeholders, in the format `:foo`, and allows the array passed to execute or the value passed to bindParam to use that name instead of the numeric position. This also can make variable WHERE clause assembly easier. However, there are three downsides to this. First, the format used by PDO isn't supported by any database I've ever seen, meaning it has to emulate the prepare. PDO normally tries to use native prepared statements, if they're available. This isn't a huge problem most of the time, but it does mean that the database can't natively work with the prepared statement, and that can be a performance hit. Second, named placeholders can only be used once. You can't use `:foo` twice in the same query. Finally, you can't mix positional and named placeholders in the same query.
Seems pointless.
While I agree with what this article is suggesting, the reality is that if you're properly separating your business logic from your presentation code then all the time consuming heavy lifting in a page should already be done before you even start writing out HTML. Page rendering is relatively instant when compared to DB communications and data processing. Unless you're dealing with a page that has a LOT of content on it, this wont save you anything.
Yes, additionally if you use the trick of ["css in the head, js right before &lt;/body&gt;"](http://developer.yahoo.com/blogs/ydn/posts/2007/07/high_performanc_5/) then the gain is even further marginalized. This article is not very valuable advice.
Hey, thanks for introducing me to SlickEdit. I'll try it on my Gentoo box at home ^^
Zend Studio is **notorious** for munching on files + CPU for HOURS for NO REASON. 6.0 had a bug where it would use 100% CPU forever for no reason. It killed my solid state drive... i left zend studio open over the wekeend, came back, drive was dead. ZS was just continually rewriting over and over the file cache of some sort for its intellisense... hosed up the SSD. Did I mention it leaks memory 10x worse than Firefox? When I had to use it exclusively b/c of work a year 1/2 ago, it would rountinely leak 3 or 4 GB of RAM on a 4 GB box, causing my vm and browsers to crash and windows to repeatedly warn "Virtual Memory is low."
Or!!! OR!!! You're not making six figures doing stuff that no junior dev can possibly do. THEN and only then would you not need a debugger!
Here's part of what's wrong w/ the PHP community: haywire -12 points 5 hours ago[-] &gt;&gt;&gt; What are you doing in PHP that is so hard to debug in your head? timschwartz -8 points 4 hours ago[-] &gt;&gt; Yeah really. If your PHP is so complicated that you can't debug it with a print statement you are doing something wrong. timschwartz 1 point 47 minutes ago[-] &gt; What? I'm not being sarcastic. Or!!! OR!!! You're not making six figures doing stuff that no junior dev can possibly do. THEN and only then would you not need a debugger! permalinkparenteditdeletereply
&gt;Also, you don't need to use bindParam, you can pass params directly into execute: &gt;$sh = $db-&gt;prepare('SELECT foo FROM Bar WHERE baz = ?'); &gt;$success = $sh-&gt;execute(array( $something )); Heck with bind calls, passing the array into execute looks so much cleaner.
Right, I did. In some cases, you still may have to look through the code itself to see how to use it. The API browser looks pretty good, though
The nice thing about using bindParam() is you can specify a datatype for each value.
You can't specify an explicit type there though, and sometimes you need to (e.g. PDO-PgSQL's boolean support is lacking...)
I've just setup WAMP / Netbeans / Xdebug / [Xdebug helper](https://chrome.google.com/extensions/detail/eadndfjplgieldjbigjakmdgkmoaaaoc) , and it's totally changed the way I work. With Xdebug helper: * Specify the domains you want it to work with in the Xdebug helper menu - an icon shows at the end of the address bar for eligible domains. * Hit the debug button on Netbeans. * Hit the Xdebug helper button on Chrome - the next page request of any type will start debugging in Netbeans. 
You could also give Komodo IDE a try. I really enjoy dev'ing in its environment, and the built in debugger has helped me to sort out issues I've been having with some of my code fairly easily. 
Is this for a pr0n site? _Most of the other job offers I've seen in /r/php lately were for pr0n sites..._ /jk
Xdebug is _the_ industry standard. Get it to work, you can do it.
You could do slow work through callback functions deferred until the frontend tries to access the data, instead of putting it all in the controller, in which case this would be useful (the badly-written site this blog post is on might actually load if it used that method)
I agree, after working in advertising for a long time, and taking many long hard looks at the openX code, i find it needlessly complex. However feature complete, so its a tradeoff you have to decide on =/
netbeans' autocompletion of quotes and parens infuriates me sometimes.. sometimes it works well, other times it's not what i wanted at all.
I've been lucky enough to use my own framework in all my PHP jobs (all two of them!) which means I always get to have my favourite classes on hand.
Ha, no porn. My clients include a wedding gallery site, financial planning, and an image gallery host, among others.
*On a complete side note, that scr.im site is ridiculous.* 
the thing i hated most was when it auto generated tags for html, like you make a table and it makes row and cell tags. its nice when your starting one, but if for some reason you go back to edit it, then it inserts extra tags you dont need.
You can disable individual parts of the code completion in preferences. For things like HTML, you can setup templates to do exactly what you want. For example, you can have the abbreviation &lt;tbl turn into a full open and close table tag. This feature is particularly useful for code segments such as "if else" and "for each". It can automatically add in the variable names from the previous assignment. Pretty cool stuff.
if ($perms &amp; 8) echo "you have chat admin privileges!";
Or maybe that 8 should be 4 - I can't really follow the formatting in your post.
Fuck reimplementing the wheel. Use Zend_Acl. Seriously. * API docs: http://framework.zend.com/manual/en/zend.acl.html * Example/demo: http://devzone.zend.com/article/1665 With security in mind, you do NOT want to risk rolling your own code.
To expand, your schema will look like this: Users: id | username | roleID ---+-----------+-------- 1 | admin | 1 2 | hopeseekr | 2 Roles: id | name ---+-------------- 1 | administrator 2 | regular user Your code will look like this: /* This could really be a extended into a singleton. */ class SecurityController extends Zend_Acl { public function __construct() { $sql = 'SELECT name FROM Roles'; $stmt = $pdo-&gt;query($sql); $stmt-&gt;execute(); while (($role = $stmt-&gt;fetchObject())) { $this-&gt;addRole(new Zend_Acl_Role($role-&gt;name)); } } } In your front loader/controller, add something like this: $guardian = new SecurityController; $guardian-&gt;add(new Zend_Acl_Resource('viewName')); $guardian-&gt;allow('admin', 'viewName'); Then in your individual pages: $guardian = new SecurityController; if (!$guardian-&gt;isAllowed($user-&gt;role, 'viewName')) { throw new RuntimeException('PERMISSION DENIED'); } 
Other than the other issues already pointed out, I'd be wary about trusting an article that confuses user space output buffering (the ob_-functions) and the internal buffer for the SAPI (which flush() operates on). Bonus points for saying that output buffering (OB) is enabled by default and then linking to the man page describing that the default setting is Off.
Zend_Acl has already been mentioned and you should most certainly take a look on that. If you want to implement something yourself, I'd strongly suggest going the access / role / user route, where access is the resource/key the role has access to (such as article_admin, article_read, article_write, etc), and roles are groups of users. This is close to the same layout that Zend_Acl uses. The problem with bitfields is that it's hard to expand the responsibilities of several users, if you decide that forum administrators also should be able to moderate a chat. This would require you to either update all the existing forum administrators with a new flag or change the code; instead you can just give the "Forum Administrator" role access to moderate a chat.
sweet! I really needed this right now, miamiruby thanks for posting this
Yea, reddit kind of crushed the formatting of the original post. :(
I'm a 12 year [Zend Certified PHP 5 Engineer](http://www.zend.com/en/yellow-pages#show-ClientCandidateID=ZEND005639). You can download my resume [here](http://users.phpexperts.pro/files/tsmith/SMITH_THEODORE_RESUME+-+v8.doc). My "official" code portfolio, complete with 100% unit test coverage, is over at http://www.brokertools.us/user_directory/. I have also developed [xMule](http://www.xmule.ws/), [RedditMirror](http://www.redditmirror.cc/), and I own and operate the [PHPExperts.pro](http://www.phpexperts.pro/) domain for every certified PHP expert. I conduct training seminars for PHP developers, from beginners to professionals on the side. I'm in the process of developing my own blog software, [**RosettaBlog**](http://users.phpexperts.pro/files/tsmith/rosettablog-r49.tar.gz), that will interface w/ the DBs, themes, and (hopefully) plugins of Drupal, WordPress, and Joomla blogs. And it will be BSD Licensed, to compete w/ all three using the GPL. I have attached the code that is currently live on my own blog. It's doing some pretty cool stuff. I used [**bzr**](http://bazaar.canonical.com/) so you can see how i did this step by step. In addition, it includes two of my open source projects, under the BSD License: * PrettyException: A design pattern implementation of simplified exception usage ex: throw new ArticleException(ArticleException::ARTICLE_NOT_FOUND); and the exception will output a nice error message: "Cannot find article." * MyDB: PDO wrapper that supports MySQL, Postgres, and now SQLite, built in and **EFFORTLESS** replication, SQL error and/or timing logging, etc. MyDB was developed so that I could handle the load for my most popular website, http://www.redditmirror.cc/, which at times receives 100,000 users/hour (was top 300 on the Internet a few days in 2010 ;-) If your code speaks PDO, it is a *drop in* replacement for replication, just turn $config-&gt;hostname into an array of hosts like = array('127.0.0.1' =&gt; 'read', '127.0.0.2' =&gt; 'write'); (RedditMirror ran out of disk space so none of the recent links work, unfortunately).
Awesome! Thanks for the recommendation! I am a pretty lazy person lol, so adapting another module that works the way I want is ideal! Ever since writing a chat system from scratch I've been loathe to start a whole new module from scratch (though I kind of want to mod my chat system to use memory tables to avoid the load on the main DB).
Good or bad? I was looking for an email anonymizer I saw on reddit before, wasn't sure if scr.im is it or not.
from personal experience, i suggest writing separate classes/models for each role type. this approach may lead to redundant code, but IF statements for roles quickly turns code into spaghetti. personally, i think using bitmasks for ACL is overly complex. KISS. 
phpstorm's xdebug support is pretty good, got it working the other day. it also can work independant of loading a specific url... you just configure it, run it then load whatever page in question on your site and the debugger picks it up. this is useful for some frameworks that mess with routing and such.
We hear you loud and clear. A new docs is currently being worked on and is getting better day by day. This is only the test server, but something to look at: [http://michaeldpeters.com/userguide/guide/kohana/tutorials/hello-world](http://michaeldpeters.com/userguide/guide/kohana/tutorials/hello-world)
&gt; I'm a 12 year Zend Certified PHP 5 Engineer For 5 seconds I read that as "I'm a 12 year old Zend Certified Engineer ..."
roflmiao
I think that's actually openX's biggest fault, way to many conflicting features that make debugging somewhat of a nightmare.
My biggest beef with PDO is that each driver tends to lack in one place or another. The consistency it's supposed to provide isn't fully baked yet.
&gt; CMS: Joomal :) Might want to fix that. Nice portfolio.
Is this along the lines of what you're looking for? global $PERMS; $PERMS = array( "base" =&gt; 1, "forum_admin" =&gt; 2, "chat_admin" =&gt; 4, "create_account" =&gt; 8, "modify_account" =&gt; 16, "delete_account" =&gt; 32 ); function perm_isset($key) { global $USER, $PERMS; //If the requested key is valid/exists and //the bitwise is set in the user's perms if (!empty($key) &amp;&amp; in_array($key, array_keys($PERMS))) { if ($PERMS[$key] &amp; $USER['perms']) { return true; } } return false; } This way, if (perm_isset("chat_admin")) { will return true
&gt; This means I might be debugging myClass.php, which is actually loaded from several pages on the site. Or heck, I've got a controller that loads everything through index.php. Eclipse wants to load myClass.php directly, but I want to start the session with the correct params to get where I want to go. Netbeans lets me set some automatic path mapping or can ask me every time, which is what I do. How so? I can only specify the port and session ID? [Screenshot](http://i.imgur.com/qLupW.png).
It's per-project, so you have to right-click on the project and go to properties, then it's under the advanced menu.
Thanks, looks good. Honestly, I wish I had more time, because I would help out. But right now, I use my own "microframework" with namespaces/php5.3 features. It's a measly 4 files, and works with everything I need. But I have been wanting to get involved in the development of a big-name framework for a while, I guess I need to find the time for it
I was hoping to learn a new keyword "me" today.. :/
&gt;but I don't want to clutter up my database You are cluttering up your code. Which of these are you (as a human) going to have to read more often?
Thanks, I eventually discovered that. Have you had any luck kicking off a debug session from the browser? I've just installed *easy Xdebug* in Firefox. I can get it to start debugging, but NetBeans doesn't attach to the debug session. 
What's up w/ that first if() check, what's wrong with if(isset($PERMS[$key])){..}, single constant time look up instead of pulling the array keys out and marching through the list every check. Maybe it's just a personal think but it really irks me when I see the pattern if(&lt;boolean condition&gt;){return true;} return &lt;boolean condition&gt; is quite sufficient and, I think more readible.
* Permission : 0; * F-Admin: 1; * CAdmin: 2; * CAccount: 4; 0, 1, 2, 4. * 1+2 = 3 * 1+4 = 5 * 1+2+4 = 7 Think linux chmod. EDIT: If you need more, just make numbers that can't be made from the others. Not sure if there is a name for that type of technique. 
Netbeans has to be manually put into debug mode (listening for xdebug). This makes it less useful, but you can always default the debugging to a basic index page, then click your browser debug button and Netbeans should start debugging that page. I haven't done that in a while, but I think it worked pretty well. Make sure your browser extension uses the session id GET param that's set in your previous screenshot.
Thanks for that. Saves me a bit of time trying to attempt the impossible.
I don't use it for permissions (I use a database system) but I really do love using bitfields for certain kinds of configuration settings. Implementing it is very easy. Define some constants that will be your options- define('OPTION_NONE', 0); define('OPTION_1', 1); define('OPTION_2', 2); define('OPTION_3', 4); define('OPTION_4', 8); define('OPTION_ALL', OPTION_1 | OPTION_2 | OPTION_3 | OPTION_4); So now you've got the options. You can assign them to variables using bitwise operators- $setting[1] = OPTION_2; $setting[2] = OPTION_ALL ^ OPTION_1; // all but option one, using the Xor operator ^ $setting[3] = OPTION_3 | OPTION_4; // three and four, using the Or operator | Finally, you test them using some more basic bitmath- if($setting[$x] &amp; OPTION_1) doThing(); // Note the single &amp;, which is and And operator if($setting[$x] &amp; (OPTION_2 | OPTION_3)) doStuff(); // As always, the [php documentation](http://us.php.net/manual/en/language.operators.bitwise.php) is a great reference. 
Using bitmasks and bitwise operators is [much simpler](http://www.reddit.com/r/PHP/comments/dxw9q/account_permissions_bitfields_mind_mildly_blown/c13rx5o), as you just use powers of two in order to find your next number and you do't need to do all sorts of math just to see if something is set. 
I did not quite understand your quotation style, but I agree that there are a lot of reasons for this community to be more self-critical.
This has been done before. In an application I replaced. We jettisoned the bit-fields because of how inflexible they were, difficult to manage, and impossible for anyone else but the original author to maintain. You limit yourself and future development to the total number of bits in a 32bit integer as well. Want more than 32 permission points? Want fine grained, content-based permissions? Good luck. My professional, pro bono advice: don't. Follow hopeseekr's advice and implement Zend_Acl or some other system and save yourself some major heartache.
This is how a lot of old MUD engines did properties on rooms/items, specifically SMAUG.
Not sure why zend_acl is even needed. Permission based systems are so simple to begin with, why would anyone need something as bloated as zend in their code?
This is so true- I was epically pissed when Zend discontinued their own version and started working on that shitty eclipse plugin. Now that PHP5.3 is out using ZS is, unfortunately, just too outdated for me. I'm using Komodo Edit now, but there are a lot of things I don't like about it.
I wrote this class to deal with bitwise operations a while back. &lt;?php final class P_Bit { private function __construct() { } public static function is_on($flags, $mask) { if (($flags | $mask) == $flags) { return true; } return false; } public static function is_off($flags, $mask) { if (($flags | $mask) != $flags) { return true; } return false; } public static function on($flags, $mask) { $flags |= $mask; return $flags; } public static function off($flags, $mask) { $flags &amp;= ~$mask; return $flags; } public static function toggle($flags, $mask) { $flags ^= $mask; return $flags; } public static function intersect($flags, $mask) { $flags &amp;= $mask; return $flags; } public static function difference($flags, $mask) { $flags |= $mask; $flags ^= $mask; return $flags; } } ?&gt; edit: and I can tell that I wrote it a while back from the unnecessary if statements...
I really wish Twitter would open up OAuth2 support. It's so much simpler. No HMAC_MD5 crap, just SSL. It's so obvious, it hurts.
I don't know that Zend's necessarily bloated. It's loosely coupled from what I've read. Read the documentation on it. I actually did today. It's very flexible and extensible. So inevitably when you need more permissions or need to change granularity or add a new type of user you don't need to hack at your spaghetti code. Here: http://framework.zend.com/manual/en/zend.acl.introduction.html
It sounds like a good idea, but it's not. Clutter up your database, it's what binary (bit) fields are for.
**Don't use bitfields.** Unless you're getting 2000 hits per second, the micro-optimisation isn't worth it.
Well, if you plan to make your code expandable, you won't have to hack anything in. It's pretty easy to make sure you can expand when you need to.
Making a dynamic bitfield isn't so difficult, and they're actually pretty easy to manage once you write some utility functions to toggle/set/unset whatever fields you want. You can expand beyond 32 bits as well. It takes a little code magic, but it's not hard.
Chances are there's a database involved at some point, so I'd just use the decimal support in that.
Smaug had a pretty good system for room flags, of course when it was updated for extended bitvectors it became much more viable.
Any optimization is always worth it. You never know how popular something can become later on, and it's much easier to do an optimization like that now, than wait and have to recode it later and change every call to it.
I find the opposite - it seemed like everyone was gung ho for apache and php, and I was surprised when I used IIS and Visual Studio/ASP.NET/C# that I really grew to love them. To each their own.
I agree PHP was my first language and I have found ruby, python and c# to have a much larger learning curve. That being said those other languages can do things that can not. So I see both sides but there nothing wrong with starting with an easy language as your first.
I agree. PHP may have had some shortcomings in the past, but these days PHP has evolved into a really great language for rapid development of just about any kind. Of course the entry level is very low which results in a lot of bad code floating around the web, but it is definitely possible to write great PHP code if you know what you're doing. Especially now that PHP has anonymous functions, it is possible to write beautiful, concise and functional PHP code with a minimum of effort (in my opinion). It is still the language I feel the most confident coding in, despite having tried just about every other mainstream language under the sun. However if I were to give any PHP developer some advice it would be to learn a functional programming language and get familiar with its constructs; I believe it has really changed the way I write PHP for the better. Overall I believe it is the best environment for general web development.
&gt;It's very flexible and extensible. That's exactly why it's bloated. Any 'framework' that does everything and anything you might need, means it's got a whole bunch of features you aren't going to use, and it will do all kinds of validation and processing that has no use to you. A simpler more customized set of classes that do only what you need it to do will end up being much better. All that said, most php users don't build high performance websites, so my point might be moot.
Very nice, thanks
I really stopped paying attention to the arguments a long time ago because it's all self-defeating. It's mostly people who feel they need to bash something because it makes them feel better. The lower barrier-to-entry that PHP had for a long time resulting in, as people have said, a lot of bad and ugly code floating around. However, you'll find that in any language but it's just that the bad PHP is more visible than the bad C#or the bad Assembler which makes it a convenient whipping boy for the insecure. Now, yes, there are some strange methods in PHP, some of the naming syntax is a little odd, and there are a couple of shortcuts that can cause you some problems but if you avoid those then you can create some gorgeous and elegant code with it. It's not just the tool, it's what the craftsman can do with the tool. Ultimately, though what the flame wars always remind me of is people arguing about their favourite bands and calling everyone else an idiot because they don't like *their* favourite band and then they'll say things like: * all the fans of [band] are douchebags * [band] writes crappy lyrics * [band]'s guitarist sucks and can't play an augmented fifth (or some crazy musical notation) * if you like [band] you suck and everybody should listen to the band I like best because my taste is the best out there. * [band] wrote a hit song and made alot of money. They're sellouts. My favourite band is so obscure that nobody has ever heard of them which makes them great. Sound familiar? In the end, the arguments accomplish nothing so I really stopped paying attention. PHP development pays my bills, paid off my house, paid off my car, and bought me a bunch of really nice stuff and a growing retirement nest egg. If someone wants to insult it, why should I care? My ego isn't that fragile.
http://docs.google.com/viewer?url=http%3A%2F%2Filia.ws%2Ffiles%2Fbarcelona_2010_hidden_features.pdf
Ignorant and blind people don't like PHP generally, here is why: - Java developers who criticize PHP should take a look at their int vs. Integer problem - C# developers who criticize PHP should really take a look at their FTP class that can do magic when keep alive is true(which is the default) and so on... It's not like: - no other language expect PHP have inconsistencies in function/method names - you can't write crap in virtually all other languages - type safety saves you the trouble of unit testing and so on... If PHP gets the job done it's great, period. PHP programmers don't criticize other camps often, because PHP programmers are busy writing code and making money, I recommend others to do the same and don't confuse programing with religion.
http://lukewelling.com/wp-content/uploads/2006/08/programmer%20hierarchy.gif
Thank you.
Can anyone tell me in what possible scenario would the GOTO command be desirable over, say, a function call?
The slides definitely got more interesting towards the end. I'm glad to know about igbinary and a couple other extensions he mentioned in the end. \_\_DIR\_\_ is a very cool feature. I'm sure during his presentation he did a better job of explaining how useful it is than the slides do. The powerful part of \_\_DIR\_\_ is that it returns the directory of the script that references it - regardless of whether it has been included from a script running in a different path. This can be very different from the information you might find in $\_SERVER, where if a script is included from some other script, you'll end up getting the path to that some other script.
Some interesting things covered, would be interesting to hear/read the full talk.
Well, function calls change scope where goto may not (or may not be allowed?) I've never found a good use for it because continue and break always make more sense to me.
&gt;More and more I am reading things that basically imply "you are a shoddy developer if you use PHP". I'm just curious why it has such a bad reputation, yet it is so popular. Eh, some people like to be snobby. I think PHP deserves some of the negative feedback it deserves, just look at the 700+ functions packaged into the global namespace. But I don't think using PHP makes you a bad developer. It's a widely available and easily deployable language - probably moreso than anything else used to power the web. I think using it often makes good sense.
There has been one instance where I've used a goto to break out of a switch statement and go back to the block containing the switch statement (continue 2 only reiterates the switch). That's about the only use I've had for it though. Edit: Once = one
I never said they were hard to create. Bitfields are hard to maintain. They are an unnecessary obfuscation, especially given that we're working in PHP (if you're working in PHP memory and cpu are very low on the totem pole of constraints).
(Disclaimer: This is coming from someone who likes PHP and works with it daily) PHP is not a language. It is a pidgin, a conglomeration of sorts. Its a take off on perl that does little more than manage a group of components, each with their own set of conventions, which often conflict. Its also an interpreted language, which makes it an easy target.
While striving to write performant code is important, it needs to be weighed against the law of [diminishing returns](http://en.wikipedia.org/wiki/Diminishing_returns) and the dangers of [premature optimization](http://en.wikipedia.org/wiki/Program_optimization#When_to_optimize). Generally speaking, [you ain't gonna need it](http://en.wikipedia.org/wiki/You_ain%27t_gonna_need_it), so just [keep it short and simple](http://en.wikipedia.org/wiki/KISS_principle).
This is why people think PHP sucks: * PHP Developers 1. Do not know how to debug (use breakpoints, local windows, etc.) 2. (worse!) Know how and don't want to! 3. Prefer littering code with print_r()s and if (DEBUG_MODE) { error_log('debug info'); } 4. Don't use an IDE, prefering dumb editors (w/o autocomplete, syntax error checking, etc. etc.) 5. Don't know what Unit Tests are. 6. Don't know what Design Patterns are. 7. Don't know how Object Oriented Programming is supposed to work. 8. Have no fracking idea what encapsulation truly is. 9. Have no idea what XSS is or how to prevent it. 10. Have a slight idea of what SQL injection is but don't know what prepared statements are. 11. Have horrible coding styles. Hell! Over the last ten years, I hate working w/ the majority of my developer coworkers because they just don't know this stuff and refuse to. I prefer junior devs over them almost all the time (at least juniors listen and learn!). Then they don't like these things about PHP: * They have a hard-on about precompiled code and don't know about opcode cachers. * They think non-uniform languages are stupid, forgetting that English is dominant and is much more messed up (e.g. it doesn't matter much if it gets the job done). * They stopped being up to date w/ the status of the language sometime in 2005 and refuse to realize that it has grown tremendously.
Not here in Texas ;o it's the polar opposite.
For the most part, PHP devs **are** shoddy! I love PHP and hate the vast majority of the developers!
have to say, php-excel is awesome.
"hard to maintain" is the only point worth considering. Rolling your own no matter what introduces you to far more security vulnerabilities than using Zend_Acl. it's pretty stupid for anything that is going to end up in production.
O man, i hope i never have to work w/ you if you still have that attitude ;o
It's a palindrome which makes people uncomfortable.
I think most developers are shoddy, PHP or otherwise.
PHP is trash. Like all other languages. But it's list of fails is far longer than those of other languages. Especially if look at it's history and understand that most of the better parts are really young. Of course, using php doe'snt make you shabby. Most of us are forced to use trashy toys to earn our pay. But not understanding *why* a tool is trash, and why others are less, is a fail in skiils. For example, comapring the short job of setting up an working environment, with the daily work on a software other months and years, is a misleading way of thinking. Yeah, php is fast up to play for web-jobs. But that it's job. That's where it come from, where it lives. Other languages like python, perl or ruby are all-purpose-languages, which have *just* also web-abilitys. Settings up a normale scripting-environment, for shell-usage, is also as fast as a normal php-environment.
Yeah yeah, I fully understand that. With that in effect, still, any optimization you make is worth it, but not necessary. No one will ever call you stupid for making a program use less resources, unless they're an idiot. For this, using bitwise operations would be a benefit, it's a little more overhead, but if his game gets big, it'll be worthwhile.
Lol, I'm not saying go WAY out of your way to do something, but if it makes your program better, and it's not an additional 40 hours of coding, you might as well include it. I like to write good code, and I'm a perfectionist when it comes down to it. It saves me a lot of headache later on if I need to expand something.
I think they're extremely easy to maintain.
Well don't doubt it. PyroCMS uses CodeIgniter, I am still organizing CIOCN events around the world and my day-job/freelance projects are using CI too. Kohana is bloody brilliant and Fuel borrows (or steals) heavily from it in places, that said there are plenty of bits I don't like. Fuel is nothing life changing, just a merge of CI and Kohana that will be interesting and beneficial to fans of both.