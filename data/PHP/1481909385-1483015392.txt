Composer doesn't even work on 5.2 because it requires namespaces, a 5.3 feature. We can't really observe the long tail with it.
Yes, and that supports my point. There is a *lot* of PHP out there that Packagist simply doesn't know about. Probably more than the ones it *does* know about.
&gt; Wasn't their conference this year cancelled due to poor ticket sales? The Chicago conference was canceled, they still had one in London and Berlin, I believe.
Laravel 7
There's an argument for and against I'd say. On the one hand, if the actual exposed API doesn't change, I don't see the issue in not calling it a B/C break. Look at Symfony and how often it bumps the Twig 1.x minimum version, going by your argument you could say a lot of Symfony releases would require a major bump. On the other hand, if Taylor and Laravel's contributors did start changing the API (implementing scalar typehints would probably be the biggest offender) then I'd agree totally it's a B/C break and should be advertised as such. With that said though, it's been made clear in the past Laravel doesn't strictly adhere to SemVer so I doubt the version number alone will be used to communicate if/when breaks are made.
&gt; let us know if you really think it's not better than your current setup It may very well be "better" but my current setup is feature complete for our needs &gt; Waiting for Satis to rebuild after pushing code can be really frustrating Jenkins job handles this nicely as satis is rebuilt after a successful tagged release. &gt; how do .you make sure that an employee who leaves the company no longer has access to your private code Our code is hosted on an enterprise github instance integrated with LDAP. I'm not saying your tool is useless it just does not fit my company's needs. I do like the concept though. EDIT: Formatting
From semver.org: &gt; Major version X (X.y.z | X &gt; 0) MUST be incremented if any backwards incompatible changes are introduced to the public API. I'm inclined to agree with your conclusion, but I could see the argument that the API itself doesn't (necessarily) have a BC break and by the letter of the "official" spec and therefore doesn't have to be a new major version. Of course, I don't use Laravel and have no skin in the game. But I treated all of my 5-&gt;7 migrations as a major version.
That's totally valid. My requirements have been based around those of a major infrastructure company (99.995% SLA, IIRC) so those "short moment"s could really add up to actual costs (i.e. a year's worth of this service in a couple minutes). And Github in particular, especially being the target of frequent DDOSes, seems to have a major outage every few months. We looked into Satis and Toran Proxy but both introduced too much admin overhead to make it worth changing from `git add vendor/`. I think this would hit a sweet spot. There's absolutely no way I'd pay for it for personal projects though.
 &gt; I could see the argument that the API itself doesn't (necessarily) have a BC break and by the letter of the "official" spec and therefore doesn't have to be a new major version. I agree it's not a violation of SemVer, with its concentration only on API. I assert, though, that there is more to backwards compatibility than the API. If you'll permit me, I think the more broadly accurate way to think about it is this: - Will upgrading this package require me to change something, whether in my code or elsewhere in the existing system? If so, then it's not backwards-compatible. - Do I have to change something, whether in my code or elsewhere in the existing system, to upgrade this package? If so, then it's not backwards-compatible. Failing to maintain backwards compatibility in those ways strikes me, at first blush, as warranting a major version bump.
I'm seeing a lot of similar suggestions here so I'll post this just to give a bit of diversity and more options: A lot of these suggestions are for books or websites, but if you aren't in to that, I would suggest a YouTube channel called CodeCourse. Using YouTube tutorials usually isn't my cup of tea and should generally be avoided, but CodeCourse is actually really good. Not only does he have several videos and full series on the language itself, he has several series on practical usage and frameworks like Laravel and the like. He recently put out a series that shows all the new changes in php 7.1 which was a great little series to quickly learn the new changes
Laravel does not use semver
Looking forward to your report.
[removed]
This was clearly made by a Symfony fanboy. #5 on the bottom list is a stupid inclusion. 
Why are you even in this sub?
0 + 100%(0) = 0
[removed]
It's like diarrhoea all over my screen.
&gt; There are no complicated rules or limitations to follow. Except... * Mandatory fixed project structure * Convention over configuration * Our way or the highway * YAML or die
&gt; you 
[removed]
What kind of Pokémon would Golémon be?
&gt; unless you're shipping bundles That seems like a major caveat considering everything has to be shoe-horned into bundles.
Pretty sure that platform.sh are partners with symfony, so it's straight up advertising.
That really does make sense. Maybe someone from Morocco will chime in.
The migration guides are one of my favourite parts of the PHP manual, and I thought this might be useful, in case anyone had missed it.
&gt; If you upgrade X in place, and the upgrade fails because of a newly-introduced dependency or prerequisite, that seems like a BC break to me. Why? It doesn't break your code, it just means you cannot upgrade without adjusting your integration. The same way you cannot freely require any package (you may have conflicts), you cannot freely update any package. Semver has nothing to do with it, it's a matter of compatibility between packages and there is no way to handle that at the code level. Handling those issues are a reason of being of package managers, otherwise the only thing you can do is being reasonable about your deps. Another way to look at it, if you require a major version when upgrading some deps, projects of the size of say, Symfony, would quickly become unmaintainable. Bumping one major version after one another is a door for fragmentation, and if you need to maintain the older version it can very quickly become extremely time consuming for no gain. 
Heh, I see what you did there.
&gt; it's a matter of compatibility between packages This is exactly the point I am trying to make. The change introduced is a backwards-*in*compatible one. &gt; if you require a major version when upgrading some deps, projects of the size of say, Symfony, would quickly become unmaintainable Agreed, and I should have been more specific earlier. I would rephrase my statement to say that if you bump a dependency by a major version, you should probably bump the dependent package by a major version as well.
Incorrect.
Racine, WI. Laravel/Lumen depending on the project. There are legacy applications running on CodeIgniter, but they will be moved to Laravel.
FUCKFACE!
I really think they should split that massive page into manageable chunks.
Indeed. Why don't arithmetic operators work in a sting? Why function calls don't work in strings? Why aren't we writing the whole PHP program inside a single string? What a stupid language.
It sounds better when you say it than when I try to say it lol. But I do think it's a very valid philosophy and a refreshing perspective! Future proofing and over engineering often go hand in hand.
i can see how that is vaguely related
So, 2 (in words: *two*) platform projects use Symfony, and that makes them "the framework of frameworks"? It's a quite meaningless achievement. And on top of that Laravel is the slowest framework of the bunch, and Drupal got around 2-3 times slower after moving to Symfony. None of this speaks well about Symfony as an effort. Sure, it's well rounded, but also it's well rounded in that other sense. 
On Windows is it okay to just install 7.1 over the top of an existing 7.0 install?
Next time let styleci.io do it
Just get PhpStorm like any sane PHP developer does ^^
&gt;Why aren't we writing the whole PHP program inside a single string? You mean like Ruby?
Just forced this upon the seniors at work. It's great not having x repositories with the same lib/ directory -.-"
&gt; The way I approach the problem is that it is not the responsibility of the login code to also handle the errors. I agree, but why are you allowing potentially wrong/bad inputs to even reach that method? Shouldn't they pass a validation layer _first_? It's that validation layer I meant when I wrote that it "doesn't seem right". Because if your login method is throwing an exception, it must already do some sort of validation somewhere down there, no? That'd be mixing responsibilities, too. And how do you tell the code up the stack what actually happened? Error codes? A new exception type for each case? Yikes.
What I don't like about that approach is that, if the user made multiple mistakes (think a larger form), then they will only every find out the first error instead of all at once. So they couldn't fix them all at once, but only one after each submission. That's bad usability.
Same for me, but I'll have to see it with my actual code.
No it doesn't. A few years ago we migrated a very large codebase from a in-house framework to Symfony, and initially we didn't move our code into bundles. Symfony offers plenty of ways to keep your code in a different structure. 
That's a bit underselling it http://symfony.com/projects
Look at Laravel's more enterprise features like queues, command bus, middleware, DI container, realtime event broadcasting and tell me it is not simple.
I absolutely agree. I'm pretty sure their service is great and definitely adds value and I also understand that they want to earn money. But the pricing is definitely too expensive, especially for small teams like just 4-5 devs. I think something like 49 euros / mo for up to 5 devs and then 9 euros / month for each additional dev or something like that would sound more reasonable. But in the end, they will find out if people are willing to pay 199 euros / mo or not.
this seems pretty interesting comming from a phpstorm user.
It's a little outdated now but the Symblog tutorial was quite useful in getting an introduction. http://tutorial.symblog.co.uk/
Definitely go with composer. It will allow all the projects to re use the code but you can also use different versions and upgrade independently. As others have mentioned satis is a solid option for a private packagist repository . I have been using Toran proxy and have found it brilliant. Have not looked in to the newly released private packagist yet but that might be the easiest root to set up.
Great! Keep pushing forward.
Nah, I was in Canada at that point. Framework was written by a tiny little Persian dude. Maybe just an example of parallel devolution?
Nginx and php-fpm for the server. FastRoute is a great router. League Route has nicer ergonomics. Everything by League is quality, really. I think EasyDB by ParagonIE is awesome. Maybe also check out ReactPHP and Icicle if you want to experiment with async stuff. 
Sounds like a lot has passed you by. There is no single, "best" tutorial anymore. Think in terms of project requirements and look for as much info that matches what you'll need. Don't think in terms of specific database servers - learn PDO. Actually, the best thing you could do is research MVC frameworks. Do this and you will learn composer, database abstraction and overall best practices - all in one shot. Symfony is fantastic, but considering where you are at Laravel would be your best bet. 
Because `{}` in strings is sadly quite limited.
&gt; This is exactly the point I am trying to make. The change introduced is a backwards-incompatible one. I'm not sure to understand, if I change my deps in 3.1.0 making it impossible for a user to upgrade to 3.1.0 because he gets conflicts, then that's it, he just cannot forcefully update but otherwise he won't get anything broken thanks to Composer. I do agree however that you should not do that in a patch release unless forced to for some reason.
&gt; otherwise he won't get anything broken thanks to Composer Yes, tooling may help to prevent a backwards-incompatibility from affecting you. My (perhaps pedantic) assertion is that it *is in fact* a backwards-incompatibility. &gt; I do agree however that you should not do that in a patch release unless forced to for some reason. +1
Personally I'm more interested in the military side of flying. I'm Canadian and up here we have something called "Royal Canadian Air Cadets". Which is an awesome program supported by the Canadian Forces combined with a civilian organization. I got my PPL towards the end of my cadet life in 2011. The cool thing is the cadet program is entirely free which means I got my PPL for free. Of course this meant there was a lot of competition and exams and interviews to be accepted, but I got in. Unfortunately since then for mostly money reason I haven't been able to fly. But I work for the cadet program and I've been teaching to the younger cadets the theory side of flying so they can pass the exam and interview process. The thing is that to become a pilot in the Canadian Forces you have to be an officer and to be an officer you need to have a bachelor degree. I'm also a quebecois, which means I have to go through cegep. which is essentially pre-university. I've been studying computer programming for the last 3 years now and starting university in autumn 2017 for a software engineering degree. I'm starting to love programming more and more and I'll have to make a decision after all that if I want to be a weekend pilot or a military pilot. edit: Just a small example of successful cadets. Chris Hadfield got his ppl in the air cadet just like me. There was also Maryse Carmichael, which became the first women to lead the snowbirds (our version of the blue angels).
[removed]
While I agree, you don't know what you don't know.
I understand /u/bitfalls has a book about this: [Jump Start PHP Environment](https://www.sitepoint.com/premium/books/jump-start-php-environment).
Yeah I have the same issue right now, but I'm saving for eye surgery since it's now accepted in the CF. I do have a question regarding your framework. I'm relatively new to php, but my current .net projects are web api with an angular front-end. I was looking at doing a small project in php using the same idea of front-end/back-end setup. Not that I don't want to use your views, but I already know angular and I like using it so I would prefer doing it this way. Should I just dump my entire angular front-end in the public folder and make a route for '/' that's essentially giving the index.html of my angular app? Or do you recommend doing something different?
Alright thanks I'll try it out!
Absolutely, but I prefer them for readability. :-)
PM me and I can take a look.
Switch to Linux on the desktop, install phpstorm, look at using lxc containers for development work
There are a few docker or vagrant boxes you can use. My dev environment is vagrant running a command line Linux server.
&gt; I want to develop the right way, not the 2010 way, but it seems a bit overwhelming to determine how all these pieces fit together in the right order. How would one go about setting up a modern dev environment, given the above? One step at a time, really. Trying to learn six things all at once will likely leave you confused and frustrated, especially since a number of the things you listed require semi-specialized tooling to get working correctly/optimally. The good news is that they're mostly not dependent on each other, so it's totally reasonable to break things down and not try to get it all configured perfectly in ten minutes. And there will probably be three new versions of npm between start and finish. PHP5 vs 7 is relatively minor, believe it or not, and you can probably handle that just fine when learning a new PHP framework (that you installed with Composer). The rest I'd suggest doing piecemeal: learn $new_php_framework using the css/js techniques you're familar with. When you're reasonably comfortable, try LESS-ifying your CSS. Once that's working, break down some JS into React components. Then install PHPUnit and write some unit tests. And go from there. Do whatever order you feel comfortable with.
Ahh, that's nice. Finally some good excuse to rush my employer over the most than needed version upgrade.
Hmm, it's almost 2017 and now you're migrating to PSR-2 codestyle? Okay.
Where would be a good place to find people willing to dev review my code? I have written the basis for my system as open source, and was hoping to get community input.
Learn apache and nginx. Just learn them both. You'll find they have a lot of similarities and you'll end up picking a favorite and have the bonus of not being afraid of either. Learn to write .htaccess files and then learn how to migrate this behavior into config files loaded when apache/nginx start. It is good to know, and it is faster to migrate them into the config files. Learn to setup MySQL/MariaDB. There's no difference between the two. Just google for tutorials for this and the above. Really just google tutorials on everything. If the tutorial isn't built so you can follow along yourself (and therefore experiment as you go) don't bother. 
er .. but 5.6.29 works fine with just about any code going back for years and years .. which avoids a lot of tears. 
Go with what the world uses and therefore needs now. That means php 5.6.x is fine for a long to time to come. Apache 2.4.x is a necessity as well as some nginx but the big player is still apache. Also MySQL of course but getting into Oracle DB can be done with all the free stuff you can just download and run from Oracle. Also get the hell out of Windows. Seriously. Servers don't run Windows in the real world. The banking and insurance industry look for hard core Linux ( Red Hat Ent Linux and SUSE and then Debian are great skills ) as well as the big bad real UNIX. Getting some of that stuff going in Virtual Box is a great start. Then look at real world virtualization tech like VMware and central storage over NFS and iSCSI with some basic network skills. The CS50 course from Harvard is great fun and free and please see the Reddit CS50 sub.
I recommend Nginx over Apache. Easier configuration and they don't risk accidentally installing mod_php.
Homestead is too opinionated for me. We run Debian Stable in production but Homestead comes with bleeding-edge PHP versions.
Obviously mod_php is no good for production, but php-fpm is a pain to set up and configure permissions. I keep mod_php in my dev enviroment.
I appreciate the rhyme.
Why is this approach better than using vagrant/docker? Genuinely curious. I develop on Windows using combination of vagrant and docker, and currently see zero reasons to switch.
When you use PHP 7, you're in speed and performance heaven.
This small list describes a "minimum" stack which should be suitable for all PHP developers. * OS: Not important (Windows 10, Ubuntu, Mac) * XAMPP is still fine for local development (you don't need extra VM's, containers etc... if you use Continuous integration) * Learn PHP 5.6 or better 7.x * IDE: PHPStorm ($$$) or Netbeans (free) + SmartGit (free) * Use composer as dependency manager * Use PHPUnit for unit testing * Frontent: HTML5, jQuery (still fine), CSS3, Bootstrap with Font Awesome * Frameworks: (it depends!) e.g. Laravel, Symfony, CakePHP, Slim etc... * Follow common PHP conventions for object-oriented code, and established industry best practices: PSR-1, PSR-2, PSR-4 (http://www.php-fig.org/) * Use the PHPDoc Standard for comments (https://github.com/phpDocumentor/fig-standards/blob/master/proposed/phpdoc.md) * Practice: Semantic Versioning 2.0.0 (http://semver.org/) * Read: http://www.phptherightway.com/ * Create projects with the Standard PHP package skeleton: https://github.com/php-pds/skeleton * Learn about database migrations (https://phinx.org/) * Learn about: Environment configurations and Continuous integration (CI) and Continuous Delivery (deployment)
You do all your development in production? Thats.. brave.
Also worth noting PHPUnit 6 which releases in February is PHP 7 only. That's what spurred me to take Laravel that direction in July.
I'm a freelance backend dev, and you'd be surprised to see the number of clients I have seen who don't have a proper dev environment, and just FTP shit willy nilly. The first thing I do is help them put the code into a git repo, and setup a dev server on a cheap VPS. It isn't exactly a brave decision, but a rather lack of knowledge to setup a dev environment. There is absolutely no excuse for a developer to do everything in the production though.
I didn't say they're not simple. I said they're *only simple for simple tasks*. Take the DI container, which we're really pushing it to call an "enterprise feature" (seriously?). Any decent DI container supports some notion of modules, to avoid applications becoming giant monoliths of intertwined dependencies. Laravel's container is very simple, because it does not support modularity, it instead opts for bad practices which seem simpler on the surface. Anyway, I'm not about to start digging every feature of Laravel and discuss it here. You have a really big issue with people having less-that-ideal opinions about your framework. But you have *never ever* come to correct a Laravel fan giving a positive but *factually incorrect* opinion about it and its features. You're not here to set facts straight, you're just here because I said Laravel isn't perfect. Very immature.
I've made couple of projects with Laravel and Angular (1). I found that it works best if they are simply a completely separate apps, that's what i personally prefer - i.e. exactly what you described. I build a REST API with Laravel and then i build a standalone client app with it's own routing etc. At this point it's up to you how you serve those 2 apps. You can serve them from the same server, i usually use NGINX and i set it up to serve the client angular app from www.example.com while Laravel API is on www.example.com/api or api.example.com. Then the users visit www.example.com, they get the client Angular app, which in turn makes to requests to e.g. www.example.com/api. To me this is the cleanest approach and it's easy to build additional stuff on top of your API if needed (e.g. mobile app or whatever).
Of course not. :-) It is on a dev server. Devs have branches created there and edit files via sftp, and then commit. After commit to master, changes are deployed to production. 
Thanks for all the input. I think I'll just keep making them as two separate apps as it seems to result in the easiest workflow. I just wanted to make sure I wasn't missing anything obvious. 
Are you working with plain php, or are you using a framework?
I'm working with plain php. Haven't really tried laravel yet but have looked into it. 
The function on this page should help you to send a proper CORS preflight response http://stackoverflow.com/questions/8719276/cors-with-php-headers
Too radical? How?
PHP is already a fucking (hyper)text processor. And don't need another petty text processor inside. 
Though that's true some of the time, I'm concerned about your lack of rhyme. 
Gladly. No need a Russian doll of template languages.
They're still in beta, but I am really enjoying [Nanobox](//nanobox.io) where I was previously using Vagrant.
&gt;moodle &gt;taking seriously Lmao
You can run multiple versions of PHP.
Describe the "modularity" feature and give a code example.
Yeah, 10+ year old PHP code is known to have 100% test coverage, and segmentation faults are always easily reproducible.
I tried that, still have a dual boot, but I just couldn't make some things to work on Linux desktop, if I remember correctly, for example skype didn't allow me to share screen during talk, LibreOffice couldn't open some more complex doc files I received and had to work with, then there is no adequate replacement for Total Commander, etc. It was doable, but some comfort was lost.
I will admit I have googled it and can find no relevant information for what this feature could be. If you are able to provide a code example of what the feature allows I will make every effort to implement it in Laravel's container by the end of the day. If you are unable or unwilling to even provide a small code example of this feature then so be it.
* Phpstorm - update asap, it started supporting PHP7 syntax only recently. * Windows. Kill it. Not suitable specifically for PHP development. I've tried for many years and failed. Too many things work differently from production servers. Many tools are missing altogether. Building nonstandard extensions is pain, if possible at all. * Forget about SFTP. Deploy using deploy tools or shell scripts. Learn migrations and atomic deploys. * Set up a dev stack locally. Preferably containerized, so your project environments are isolated, reproducible and under control. Keep in mind Linux/Ubuntu is the only OS supporting Docker natively, other OSes require an additional VM layer. * Dump Apache, use nginx/fpm. Bonus points for building nginx from source. * Decide between backend and frontend. Not possible to keep up with both backend stack/tooling and frontend js frameworks with major updates coming every other month (or week?). 
~~You're the one condescendingly calling people "kids".~~ Edit: You actually weren't, I confused your usernames. Sorry.
It looks great to me as well, I was waiting for php7 support..do they have a roadmap?
Sorry I meant about Phalcon in general..PHP 7 is there already..more like php 7.1
So here's the thing: PHP is a mess. It's littered with bad interfaces, weird naming conventions, ad-hoc language features, ... Some of these things keep PHP from moving forward. We are many who don't want that, who wants a platform with sane interfaces and overall a good design. This is happening to PHP but it requires breaking backwards compatibility. You run legacy code. It wasn't kept up to date, you lack confidence in your QA practices and it sounds like you might even have some weird C extension in there since you're talking about segfaults. All these are due to either conscious decisions or inexperienced maintainers. But it's on you to keep your code working, not on us who do rolling upgrades of our software. Sure, there can be a maintained non-BC-breaking bugfix release to sustain your legacy application. That is always a possibility with free software. Fork and maintain it yourself, or upgrade your legacy code, or keep old insecure runtimes. I guess the fourth option would be to pay someone who can maintain a fork, like Zend or someone else entirely. PHP 7.0 was released a year ago. That is quite some time for you to upgrade your legacy app. And if you need more time you can just hold back on using the latest Laravel version until you have fixed your legacy code. Because I assume you do have a plan by now on how to upgrade that legacy code.
But you cn still run your legacy application on PHP 5.6 for two years until it reaches end of life. That have nothing to do with new applications developed for PHP7. You can have multiple PHP versions on the same server, or you can have another server for the newer Laravel/Symfony. I know it's not always easy to upgrade (and my unit tests rant was because I thought you were someone else). But it should be possible! If you have components you can't upgrade you must have some kind of plan for how to deal with them. You can't just give up and let the code rot.
you can build it yourself it's not too hard, if you post on the forum with your reqimrnat somone will probley do it for you,.
or i can do it but im wasted 
So what would happen if two people are working on the same file and one saves before the other - and the other saves without having the updated file, thus overwriting that file. It seems like it takes away the whole point of git if you are overwriting each others files before they've been committed.
private geek show :)
I've been reading about people moving off of Phalcon for this very reason for the last three years, but the project only continues to grow. To each their own.
Yes it is, on github no activity ? Maybe beacause you are checking master branch - check 3.0.x/3.1.x, there is a lot of activity, as well prs. Docs are kept being updated to new version, perhaps not all is updated but we try our best.
He it alive as it gets, guys. We develop and support it daily. Please refer to https://github.com/phalcon/cphalcon/pulse to see project pulse. * We have the active forum: https://forum.phalconphp.com/ * Slack: https://phalconchats.slack.com/ * Linux packages: https://packagecloud.io/phalcon/stable * Codeception integration: http://codeception.com/docs/modules/Phalcon * Blog: https://blog.phalconphp.com/
Phalcon works now and since the project just released its first LTS and switched to semver we are instead focusing on building up the Phalcon ecosystem by trying to make killer projects that people want to use. For example, Phalcon is more like Symfony than Laravel, in that its only the lowest level components.
No, we are not overwriting each other files. Every developer has his or her own branch. But for this project, we use svn, not git.
You are correct. SystemD by design prevents the inheritance from parent process to child process of the way I think it should work. But, that is a change of perspective that has started-- I'm unlikely to try and undo an idea people smarter than I am came up with to protect me now that I know a little better. Just see what I can do to work within the system to end up with something less bodged and won't let the script kiddies dance on my feelings.
Wasn't [Bolt](http://bolt.cm) built on Silex?
Well sorry for disappointing you, but programming in Twig is rather common practice. You definitely should try it yourself.
I keep forgetting that for this great sub I should explain every obvious bit of common knowledge. Well, if you have no idea what Twig is but have enough opinion to vote, there are - sophisticated [loops](http://twig.sensiolabs.org/doc/tags/for.html) alone - as well as [conditionals](http://twig.sensiolabs.org/doc/tags/if.html) - and whole lot of other [operators](http://twig.sensiolabs.org/documentation#reference) - not to mention some concepts like plugins, macros, inheritance, domain-oriented translations and other excellent tools intended to make that "markup" language best for expressing the display *logic* of your application. 
Terribly misleading title for anyone who (for some reason) cares about PHP5 support. Symfony 4 will require PHP7, but Symfony will run on PHP5 until 2021. Also, November 2017 isn't soon. Like being a spammer wasn't enough, you also had to misinform for the sake of baiting clicks. FYI: &gt; Feel free to post links to your own content (within reason). But if that's all you ever post, or it always seems to get voted down, take a good hard look in the mirror — you just might be a spammer. A widely used rule of thumb is the 9:1 ratio, i.e. only 1 out of every 10 of your submissions should be your own content. https://www.reddit.com/wiki/reddiquette
&gt; Wasn't Bolt built on Silex? You know, I think it is. Shame it isn't more popular. I've been trying to get my shop on it or something similar. 
That's cool. How does it work? Do you crawl the websites?
Yep its easily the most upgradable PHP release in a long time. That being said, I was able to take a 5.3 legacy system and tried it on 7. There were the few depreciation notices, but other than that it seemed to work fine, and considerably faster. No excuse not to use it really other than the time/money factors :)
&gt; PHP 7.0 was released a year ago. That is quite some time for you to upgrade your legacy app. Yeah except who's going to pay for that? Think of web agencies with large numbers of clients who've paid for a site and maintenance. That maintenance fee doesn't come close to covering the cost of moving a legacy app written 10 years ago. In the real world: - 10 year old codebases probably aren't in any state to be unit tested - Use a TON of deprecated and/or removed functionality - Have been paid for, and are now in maintenance (sometimes not even that, the client just pays for hosting) - Convincing a client to spend money when it works perfectly fine is going to be a near on impossible sell. In an ideal world we'd all be running 7. In reality, its not going to happen.
&gt; OS: Not important (Windows 10, Ubuntu, Mac) &gt; XAMPP is still fine for local development (you don't need extra VM's, containers etc...) Unless you deploy on Windows with XAMPP, you're developing wrong and shouldn't advise others to do the same. If you're going to advise developing on derp, the least you can do is emphasize how much more important CI/CD becomes, rather than just half-ass pointing it out as the last item on your list. "But that guy on reddit said it was fine" is what this guy will tell his boss when production is down and it worked on his machine.
This release is not violating semver anyway
This release doesn't violet semver anyway
You have to explain first, how it's supposed to have **multiple** values in a **single** cell? Better make it with actual Excel app, take a screenshot and post it here. If you want to store a free-form text in a cell then you have to set format for the cell as `PHPExcel_Style_NumberFormat::FORMAT_TEXT` in order to make it shown properly.
&gt; should they completely drop the ball. &gt; Which they sort of have. How so? 
That could be a bit of a grey area in semver I think. It may not technically be, but if it were my project and I were using semver, it'd definitely be a major version bump, as there are API changes - just not ones in the project's code perhaps. If you are forced to use things like the new error / exception hierarchy then that's a breaking change in my eyes.
You're out of the context for this very sub-thread.
No, I'm not. I'm explaining why your example is bad.
Alternatively, the minimum stack could be: - Vim or just to be inclusive; - notepad :-)
Possibly the best advice in this thread...
I asked almost the same question in a user group meeting in California, and almost every group was using a different framework or combination of frameworks. Also many companies/groups said the had/have multiple frameworks in use on different projects, including legacy frameworks they now wish they did not get married to. Some groups (I suspect the enlightened ones) now use internal frameworks they build and maintain themselves so they are not victim to a vendor suddenly changing things on a whim. I suspect this is especially true for larger corporations. 
Of course it's easy and and possible to use vagrant or whatever. But I think it's better (for teams) to "outsource" all these different "environments" into a CI system like Jenkins or Travis-CI. If you are more then one developer, you have to make sure that all builds and tests (with different databases etc...) are working in the same consistent way. You can reduce your local machine setup and let the CI-Server do the work :-)
No, it's not another layer. It's just for written whole framework easier. Not everyone knows C, zephir just compiles itself to C.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
You use implode() to turn it into a string. That you can store in a single cell. 
What's the code where you're saving it back to the disk look like? 
Is there a specific reason you are using that library? I used to use a library for making csv files, but I tried the built in fputcsv function, and I will never go back.
or for those who've not got a gold desk, run Satis on a cheapo $5/mo digitalocean box.
My guess is that they are making an excel spreadsheet as opposed to a csv file. fputcsv does not support multiple sheets, formatting, formulas etc.
Because it only allows variables and function/method calls, not expressions
Another week, another comparison. Every language has its place. Just like you are asking why wouldn't the php devs move to JS, one could ask why would JS not coke to the php world. Personally, I like the philosophy of the PHP community. Most of the devs are quite friendly, and fun to work with. Those with php.net and FIG voting powers actually want the better of the language. Compared to the pre-2010 that php was getting shit from others, the 2016 php is heading towards a great future. I don't want to leave php because I'm sure php will keep its place far enough. I'm not hating JS either. In fact, I have many things from JS world working well with php, from little grunt tasks to entire apps listening to odd ports in a Raspberry Pi. 
Sorry about the broken rule. I was too hasty and didn't read the sidebar. I tried your suggestion and I changed the line from: "extenstion=php_pdo_sqlite.dll" to "extension=sqlite3.so". Edit: I also tried it with "pdo_sqlite.so" It didn't do much. "php -v" command give a different warning: "PHP Warning: Module 'sqlite3' already loaded in Unknown on line 0", but when doing something with the database I get the same PDOException about not finding the driver. 
Symfony* the article you linked is 3.3 related btw.
If I were a web agency, I'd try to sell it as a speed update. Include statistics about load time and click through rate. But if an agency is selling long-term maintenance of 5+ years, and didn't calculate the cost of upgrading language versions that's on them
"Symfony2" (without the space) refers to Symfony 2 or higher. It's confusing, yeah, which is why they've reverted to just "Symfony".
Haha. Thanks my bad. 
Depends on what part of the world you're in, PHP is still very popular in a lot of the united states for small-mid sized companies which may be the market that the OP wants to be in.
Nice touches Rev 
You might want to add another search bar to the search results page. I attempted to do another search from the "filter results" bar because I thought it was a search bar.
Yes! I'll do that :)
I'd do this, but I'd definitely recommend using braces. Even on a single return statement. I also like to leave a comment on any `return;` to just let people know _why_ it's being returned, and that it's intentional and not a typo. if (!isset($_POST['register'])) { return; // bail, the user is not registering }
&gt; The reason I'm asking this is I'm wondering if I'm missing something, or basically the shared hosts are all there is to it. Everything you're saying that keeps you working in PHP is not unique to PHP, or PHP is not best at it, objectively. Does it matter? JS is not the best at everything. If a single language is best at everything, we wouldn't have this many languages. I'm coming from a Java background and a little C into PHP. PHP was just nice enough for me to work on. PHP wasn't better at many things compared to other languages. For any larger project, politics have a role, and sometimes wrong choices are made just because the team is familiar with a particular language. PHP -&gt; JS is only one transition people can make. Shared hosts support is probably a factor, but the modern PHP (PHP 5.6/7) support is scarce in the shared host world. Do you think the [34M installs](https://packagist.org/packages/phpunit/phpunit/stats) phpunit has are from shared hosts? &gt; The reason I'm asking this is I'm wondering if I'm missing something, or basically the shared hosts are all there is to it. Everything you're saying that keeps you working in PHP is not unique to PHP, or PHP is not best at it, objectively. Well, I am sure there is a lot more than just shared hosts for those who still and will use PHP. You can spin up a $5 VPS and run Cobol if you wanted to. Take the composer for example. Neatly namespaced, fast, pretty backwards compatible, and doesn't give you a node_modules directory that weighs 20MB after you install something trivial. It doesn't always have to be a technical reason. Sometimes people like a language just because that is what they are best at, and the task they want to accomplish it easier to do in that language. Or may be the the tatoos are [less painful](http://www.geekytattoos.com/wp-content/uploads/2011/06/PHPTattoo-500x666.jpg) because the name is shorter:) Just understand what each language is best used at. 
We spend maybe ... 1 hour a month maintaining our Satis instance. And that's mostly just adding packages and public keys.
So since you posted it here, where is the source code? I can't really give any good feedback without source.
This means OP is doing the right things if someone calls him a spammer for submitting his own, relevant content. :D
thanks for the partial help brother, i worked it out eventually with a day of hyperfocus.
Um maybe it's posted here because it's written in PHP? Why does he/she have to put the source? Just check it out. 
Are you slow? The reddiquette says that. I quoted and linked it. Here, I'll give you a hand:, Click OPs name, click 'submitted' and check out how often he spams his shit and gets downvoted for it. Textbook spammer. 
&gt;$50 a month for a small startup/side project thats not making project is a lot to put towards a service like this. I love the idea of it, and will be using it for work, but i'd love to use it for my side projects too. 
Out of curiosity, why does composer just not check for that, and automatically add the line to repositories for you? I'd be even more awesome if i didn't have to specify ANY custom repositories in my config.
Bloat is really about neither of those things. Symfony feels bloated because of all the ceremony required around what the developer assumes should be an easy task. Most developers are imaptient, they assume that since they have good analytical skills, know how to google and have seen some other framework before, they should be able to wrangle symphony in no time. This especially aples to those who like quick fixes and copying stuff from SO. Symfony really requires reading the manual and getting familiar with the API, otherwise it feels bloated. On the other hand it seems like other frameworks do quite well to avoid this feeling with a better learning curve, easier to read manual, etc. So you can't just shift all the blame to them.
Yeah mate, you're definitely not in the right place for this question. Your question doesn't seem specific to PHP at all. You'd be better off asking r/legaladvice; or finding a real lawyer which is likely going to be required anyway if you're doing this in a business environment. Since you're asking about how to legally have some one e-sign a PDF you need to figure that out first. Your questions about implementation don't really even come into play until you've got your legal concerns resolved. Unlike something like PCI or HIPAA compliance, which users here might be helpful with, this is something that you absolutely need to contact a lawyer for.
[removed]
What does "hydrate" mean in the context of Doctrine?
Because this is the PHP subreddit. Where we discuss PHP code and technology. This could just as well have been written in Node, Ruby, or any other server side technology. Without sharing the code, it's "just a website". And in that case it would probably be more fitting to post it on a more general subreddit, like /r/webdev
[removed]
Instanciating Model object from a query result.
How dysfunctional do you have to be to keep coming back here?
Laravel and Symfony here. Based in the US.
banking and lending institutions do e-signatures all the time. depending on your exact business there are regulations (for banks) so yea google around "electronic signature" and pdf.
This sort of sounds like the argument for Silex. Which is basically "pick and choose your own symfony components". Why start with Symfony and replace doctrine, form components, etc, instead of start with a microframework that allows you to pull in the components you need?
Tried it, but it is rather simple. HeidiSQL can do much more, like edit table like a spreadsheet, etc. But this could be handy for some quick queries, though.
Hmm, well I could argue that Laravel pulls quite a number of symfony components plus a whole host of external libraries, yet people dont call it bloated afaik.
[removed]
They do call it other things though! but that's a good point, maybe other people should write about Laravel's misconceptions or why active record, globals, and statics everywhere is not a bad thing, I'd frankly love to read that! I just don't see what you're getting at.
It's a *perceived* as bloated because of developers looking for the quick fix instead of learning how it works and understanding it's a full system.
Also take into account what laws apply to your locale. For instance I live in the USA. I know businesses registered in Delaware, but have arbitration in New York. Talk to a lawyer.
Symfony. 
I've mostly given up on using Silex because you generally need to start adding components and can end up in a weird frankenstein Symfony space. And then you have devs who spend a lot of time talking about the right framework to use and spend very little time thinking about their own code that they are going to shove into it. Things generally only become bloated once you add your own code.
Asking OP? No reason why not. Just sharing something I think it's cool to know.
Python &amp; PHP on the back end.
Laravel *is* an example of convention over configuration. A lot of it is modeled after Ruby on Rails and the methodology of David Heinemeier Hansson, who coined the phrase "convention over configuration" to describe that way of designing a framework. 
Currently writing something using pdo you think I should write it in an oo way following mvc?
I've used Thrift to bridge calls between Java, javascript, PHP, and Python clients and services. I'm not sure there'd be any need to reimplement such a thing in PHP itself.
Symfony is the implementation of all best practices and design patterns taken to the extreme. Try creating a single route and pick out a single cookie from the request, and set a new one. Try to trace how many levels of abstraction you have to get through just to do that. All in a language that's meant to build-up and tear down everything on every request. 
See http://wamp-proto.org and PHP implementation https://github.com/voryx/Thruway
If I were a cynical old crank I'd say this is just a way of greasing the wheels for a Facebook version of Amazon Echo, which they've almost certainly had a team of genius engineers working on for over a year. They'll probably even call it Jarvis. 
Because building an AI in PHP would be silly. Since all the libraries for building AIs are written in other languages.
The thing is that people believe it is an overkill to use a full stack framework for simple projects..but actually it is not..because it is up to you how you use it..but in long term if the simple project becomes complex thats the point where you get the benefits..we actually created just a 5 page presentational site in symfony because it was just super fast to do it..and went with the cheapest shared hosting..and it is working like a charm..now the customer wants and admin and features..and it is a matter of a few hours..
Give this guy an award! 
Give me a good reason why he should?
Most PHP apps would bottleneck on speed and IO before they bottleneck on RAM. PHP 5.6 already typically uses less memory than the same app written in Python, Ruby, or especially Java. PHP 7 uses less than half the memory of PHP 5.6. So I could consider it, but it changes very little in your day-to-day PHP usage. Also I've not seen benchmarks that point out how much memory is used. Just keep in mind that memory\_get\_(peak\_)usage in PHP doesn't return memory used by extensions, so your results wouldn't be valid. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Could you do a quick honest comparing between clojure, java, php for web dev? I have used clojure in the past but i am grew more demanding in term of tooling (debugging etc...) how would you compare your experiences in this regards between clojure, java, php?
I think the process is a reference to instantiating concrete objects from data values. Realistically this can be a bad idea as the `__construct` method is sometimes not called
For web dev specifically ? I didn't use clojure/java to do website, really. More like entreprise internal app (Soap...). And a stupid project of a java lexer/parser written in clojure for the javaception. Anyway... You would have to pay me a lot of money to come near spring (java framework). I remember spending most of my time wiring everything. Half of your code lives in freakin java annotation fetish. For everything, 10 layers of tools, protocols, ... And those compile times... I'm in love with php edit a file - reload your page speed. I used clojure for two things, middleware (like php middleware but at apache/nginx lvl, not symphony/laravel), and microservice-like app. I don't know, I might just not be a guy compatible with Java. It has it's use cases, definitly. But today I would consider having a php server sit in front of my java clusterf*** to deal with the webSITE part in a sane way. Plane is calling, gotta go.
And has to wipe his own ass
I can add that Yii is also very widely-used in Russia/post-soviet area and China, and due to my impressions it's more popular than even Laravel.
I suppose there's nothing truly original in Jarvis, but it isn't exactly a research project pushing the boundaries of AI. The article does outline that there are three AI systems in Jarvis - language processing, speech recognition and face recognition. Sure, all basic pattern recognition, but arguably these sorts of technologies represent a large portion of AI research so far. I guess different people might have different opinions about whether that is sufficient to make Jarvis 'an AI'. What else would you call it though?
Symfony is slow with virtual machines..but it runs on my mac without issues..I just have php installed with brew and not use vagrant or docker..if you still would like to use a vm you can't map you just need to avoid syncing your cache folders
If you were just implementing a path-finding system, sure, you probably wouldn't call it 'an AI'. It's just an algorithm that solves one very specific problem. But together with several other AI systems, and when part of a larger system that actually interacts with people, and uses those AI systems to solve problems - maybe then AI is at least somewhat appropriate. Breaking the acronym down to its words 'artificial intelligence' is very natural.. Jarvis isn't true intelligence, but it's artificially intelligent if you treat it as a black box that answers your questions and helps you around the house. 
This. For small projects many people recommend stuff like silex but I always needed routing / doctrine / forms / form validation / twig / mails etc for all my projects, even the simplest ones (I wouldn't even need PHP otherwise?) so might as well just throw a Symfony that has everything already done for me. Performances are solid and if it has to get bigger it will be easier with Symfony as a base, and code is consistent across projects.
Why was I an angry brat 1 day ago and didn't typed it like you did... Exactly what I wanted to say, despite my reply being aggressive and a bit too personnal.
They are expecting tony stark, building micro arc reactor(overly advanced tech) in a cave(with basic tools).
Great to hear you figured it out yourself :)
Framework performance is never the bottle neck..only if you did something really wrong..I mean if you start getting 2-3000 requests per second..it will not matter what framework you use..you will need to deal with horizontal and vertical scaling..the Framework is here to make it easier and faster for you to develop something..and Symfony does a great job here..and still the small site can start to become popular..you uncomment one line of code and you have Symfony's built in proxy (1600req/s)..even more audience, you install FosHTTPCacheBundle and add 1 config file for Varnish (20000req/s)..
He may have likely used the `nltk` python library, which is the closest thing resembling an AI.
You are nitpickining a bit. Calculator is not AI, buy if a program can learn to serve better results, the consensus is such a software is called AI. 
God damn, the **platform.sh** spam is starting to reach critical levels here. The **TL;DW** of this "interview" is: &gt; PHP7 is very nice. Not just faster, but also has nice things. We support PHP7, and we're testing PHP7.1. We're using Doctrine. PHP is nice, because so much of the web uses it today. PHP is nice.
It depends how well the format of your queries aligns... If it doesn't you'll be reading mostly NULL fields back, which one might ask "why".
If all you need is a single route, picking out a single cookie from the request and setting a new one, then you chose the wrong tool. Symfony fullstack is meant for fullstack applications. And it's way simpler to work with symfony for fullstack applications than it would be to do it all on your own. It's also way more flexible than probably anything your team would come up with, because it tries to be as little opinionated as a framework can be.
Check it again. It's Hack.
[removed]
Careful, your Ultron 1.0 is already hard at work on 2.0.
The await line shows it's Hack.
[Just like Jim James?](https://www.youtube.com/watch?v=IfLN3SVtZFA)
The build up/tear down argument is getting kind of old. Instantiating an object or even several thousands costs literally nothing compared to retrieving the actual data the user is requesting most of the time. Besides that, because of Symfony's HttpKernel, the whole build up/tear down can be prevented without a whole lot of work when using something like PHP-PM, if there's ever any stable release.
I just learned what /s means here, thanks ;)
You can load Symfony in a few files with only the stuff you need, did you not read the article?
You can do that too with Symfony but then use the full DI container instead of Pimple which is very limited compared to Symfony DI.
I like the in-depth tutorial. Nice. /s
Execution time is the sum all timings required by your application to execute its task. No matter how small, it will all matter, especially now that response times are measured in milliseconds, and costs are computed by the hour. Until PHP-PM because the mainstream way of hosting applications in production, all that stands for is as a proof of concept/experiment.
Have you used symfony as the framework for your app?! Not opinionated?! Are you kidding?!
What's wrong with posting a new project? I would say, judge the code and not the person :)
Your github project could use a Readme! Was looking for the code and thought I ended up in the wrong place ;)
Have you looked at &lt;https://github.com/ziadoz/awesome-php&gt;
Pretty much. If PHP modules would be as abundant as npm packages (or Python packages) and as easy to get working, I'd probably change my opinion. But as somebody who has more then once decided 'who cares about the language, I just do it in the language I know best; PHP' on a project, I can tell you that some things are just doomed to fail. As a little bit off topic example; I had a multiplayer javascript game working before all the fancy node.js and web socket stuff. Back in those days, I used long-polling to know when the state changed and mysql tables to save the state of each entity, and ~~I still have nightmares about it~~ *I liked it!* (no serioiusly, don't do this. Like, ever. Going multiplayer is hard enough using appropriate technologies. PHP, MySQL and polling are all nice and awesome, but they aren't appropriate technologies in such situations)
I wasnt aware of that. Thanks for sharing. That list has almost everything which can be covered. Great list. Also didnt see anything for sessions there. Am I missing anything or sessions related libraries are deliberately not listed?
[deleted] ^^^^^^^^^^^^^^^^0.8628 &gt; [What is this?](https://pastebin.com/64GuVi2F/69564)
That 2.0 I hear is quite a Vison.
why not? i have written SOAP and REST services effortlessly... but yes they were CRUDs mostly.
Chill out ya'll. I was referring to [this screenshot](http://i.imgur.com/rH6w60I.jpg)
Or he added Python there just not to be embarrassed by using PHP alone. I notice a lot of PHP jobs does this as well. Have Python in the job description but their stack is no Python.
https://github.com/xinix-technology/pants
FWIW, [Aura.SqlQuery](https://github.com/auraphp/Aura.SqlQuery) supports UNION and UNION ALL query building. (I am the lead on the project.) It *might* make your life easier in this case, building the query programmatically, and then taking the string (with bound variables) and sending it through whatever connection you already have. Cf. &lt;https://github.com/auraphp/Aura.SqlQuery#building-a-query&gt; for the UNION and UNION ALL methods. Regardless, good luck!
Thanks to the magic of PHP backwards compatibility going to something like PHP3, this will work.
I love PHP as much as the next guy but is he a sadist. PHP for this would be a pain IMO
Yup. 6 days ago OP posted to /r/blogging [Earn up to $20 per post on this tech blog](https://www.reddit.com/r/Blogging/comments/5i6mrz/earn_up_to_20_per_post_on_this_tech_blog/). The [contribution guidelines](https://www.datajunkie.me/contributions) really don't mention anything about quality, just no self promotion, 300 word minimum, and things like no plagiarizing. You earn 50% of ad revenue but only receive it if you earn more than $100 in a month. Basically incentives 300 word spam.
(Coming back to this after a few days.) Aha: the `src/` directory appears (from the research) to be for PHP code, and not all code for all purposes. I'll have to be more clear about that in the draft. Thanks for pointing it out. &gt; there is nothing in the spec that says you cannot make your own root level /resources dir Correct; the draft specifically leaves a lot of room for other directories and files.
Yeah, I agree. But that's definitely not worth being posted inside a "PHP tutorial" in 2016...
GOOD NEWS! GraphDS core is now ready for serious use (established through thorough unit testing), and supports the popular GraphML format for persistence. Planned BFS and DFS implementations. Please suggest further algorithms!
Yes. I've been working with Symfony since 1.4. Do you care to cite why you think Symfony is opinionated? It's been by far the least opinionated framework (except maybe for zend) I've worked with, and I've worked with many (CI, Cake, Zend, Symfony, Laravel).
Dealing with partial failure and "distributed consensus" (with distributed transactions etc.) is probably the most difficult part, because while it's all very doable, it adds a whole lot of complexity that we don't have to deal with in a local app where all of the key domain state is in a single SQL, say, database. SOA is the kind of architecture where at small scale it has only drawbacks, so you shouldn't fragment your app needlessly. But at large scale it's practically unavoidable. The trick is to know how to start with a "modular monolith" and slowly build yourself up to SOA as your app grows, not too soon.
Thank you
He knows PHP well and it's a large part of the Facebook stack.
Facebook is using a lot of technologies so I don't think using the whats seems like an okay stack for AI development, a problem.
What kind of chatbot are you planning to make? Making a chat interface itself is another project, so I think it's easier if you extend a current chat program. For example making bots for Slack. Here are some resources/frameworks that you can start with: - https://api.slack.com/bot-users - https://github.com/mccreath/isitup-for-slack/blob/master/docs/TUTORIAL.md - https://core.telegram.org/bots/samples - https://github.com/Program-O/Program-O - https://docs.botframework.com/en-us/downloads/ (Not PHP) I would start with something simple like a Slack bot that queries Google and return the first result, or a Slack bot that returns top 5 threads from a particular subreddit.
That sounds very convenient. I just want a practical idea of how AI bots work. I'll start there. Thanks!
Awesome!
&gt; Symfony has no ORM, but comes with Doctrine. Some say it's bloated, but you don't have to use it! Some say it's not flexible, but you can not use it when it's not flexible! Some say it's slow, but its debug tools show what queries it makes! **The author didn't address any of the points they themselves raised here.** How didn't they? The fact that Doctrine may be bloated has nothing to do with Symfony. Doctrine is an *optional* dependency. If you don't like it, don't use it - problem solved. --- &gt; Some say Symfony is too verbose. Yes it is, if you don't like verbosity, you're selected the wrong profession. **Argument raised, issue comfirmed, not addressed.** Symfony hides the magic the best it can. You can easily add the magic back in if you want. --- &gt; Symfony uses too much YAML/XML configuration. Yes you'll be doing lots of YAML/XML configuration, because what's the alternative anyway? **Argument raised, not addressed... You know, how about PHP for configuration? But I mean actual PHP, with strategy/delegate objects, closures, etc. not the restricted, verbose, and slow to validate YAML-in-PHP data tree which Symfony exposes.** Pretty much everywhere in Symfony that you can write YAML, you could write PHP instead. But that's pretty pointless because YAML configs are much easier to manage and are compiled to PHP anyway, so there's virtually no performance impact. --- &gt; Conclusion: if you're complaining about Symfony, you don't know it well enough, because you're in control. **Who's in control wasn't quite the title of this article, was it?** Not the "title", but that's kind of the point he is making. Sort of like his Doctrine quote: &gt; In my latest project, in which I tried out Doctrine, I hit several walls. It took me days to figure out a solution for something that I knew I could have written in SQL in a matter of minutes. That is soooo frustrating. *You're* in control. If you think there's a better way to do something, just do it! Symfony won't stop you. But it will give you a shit ton of tools and options to help you do it.
&gt; Try creating a single route and pick out a single cookie from the request, and set a new one. class FooController { /** * @Route('/foo') */ public function foo(Request $request) { $value = $request-&gt;cookies-&gt;get('foocookie') . 'bar'; return (new Response()) -&gt;headers-&gt;setCookie(new Cookie('foocookie', $value)) ; } } Boy, that was easy.
&gt; Not opinionated?! Are you kidding?! Show me an example of Symfony being opinionated.
&gt; The fact that Doctrine may be bloated has nothing to do with Symfony. Well I don't know why 1/3 of the article is about Doctrine either. But it was. Not my choice. I'm only summarizing. &gt; Symfony hides the magic the best it can. You can easily add the magic back in if you want. The part you're reacting to isn't about "magic" but about over-engineered, verbose APIs. &gt; Pretty much everywhere in Symfony that you can write YAML, you could write PHP instead. Please read what you're replying to. I already addressed the "PHP" you can write in place of YAML. &gt; You're in control. If you think there's a better way to do something, just do it! Symfony won't stop you. But it will give you a shit ton of tools and options to help you do it. Yeah, but this wasn't at all *the premise of the article*. The fact that Symfony is bloated, slow, over-engineered, was not only not rejected by the end of this article, but basically confirmed... I mean, if the goal is to write articles which are a parody of themselves, then I guess the author could append an "/s" in the title there, so we know not to waste our time. 
&gt; When it was in the development configuration I found requests painfully slow on my MacBook. I thought perhaps it was the vagrant configuration Yes, it is your Vagrant configuration. Symfony is very slow over file shares, because it has a lot of I/O to both the cache and log directories, especially in dev mode. I had the same problem. I literally shaved minutes off page loads *simply by moving the cache and log dirs out of the fileshare*. Now my development environment in Vagrant has ~200-300ms responses in full dev/debug mode.
Accepted. What's your mturk account. I need to send you $0.50.
&gt; Convention over configuration &gt; In the end, you’re letting the author of the framework dictate how you write your application. &gt;&gt; Yes. And ? Usually does the job too, and works. Or else I would use another framework. But then you end up with a highly-opinionated framework, like Laravel. I would rather my framework give me the tools to build something, but not tell me *how* to build it.
I don't think learning specific Symfony components is hard, although I'd have to see the code in question, which might change my mind, depending on how you're using them. You might not like what I'm going to tell you, but it has to be said. Getting reactions like *"there's no one in our organization that knows this except you"* are suggesting that your efforts might actually be detrimental to the organization. While you're entirely in the right to provide feedback to your boss about how to improve the company's process, you should take it easy and make sure the rest of the developers are on board with your changes, otherwise you're effectively turning your work into a snowflake that requires your unique bus-factor-of-1 attention, and this is not helpful. Don't forget that your boss is still paying you to contribute to his organization. He has the obligation to pay you, you have the obligation to listen to his direction. You have the right to provide feedback, he has the right to accept it or reject it. You also have the right to quit your job and look for a team that aligns with your PoV closer.
also with docker et-al (even system-d) you can kill the script after say 10000 runs and have policy dictate "auto-restart" so probably as stable as some python or java. TBH I'd still use someone else ESB so /u/filkt comment still stands unless you have much time (and budget) to replace an existing ESB
&gt; Well I don't know why 1/3 of the article is about Doctrine either. But it was. Not my choice. I'm only summarizing. Because the criticism was that Symfony is bloated because of Doctrine. &gt; The part you're reacting to isn't about "magic" but about over-engineered, verbose APIs. The opposite of explicit is implicit, aka magic. &gt; Please read what you're replying to. I already addressed the "PHP" you can write in place of YAML. I don't understand your position. The configuration is simple array-like trees. For what reason do you want to complicate that to the point that you need delegates, closures, etc? &gt; The fact that Symfony is bloated, slow, over-engineered, was not only not rejected by the end of this article, but basically confirmed... I guess we read different articles.
Check it again. [I'm on a horse.](https://youtu.be/owGykVbfgUE)
Apart from the `awesome-php` list which is an excellent resource, I try to maintain a list of impressive but mostly underrepresented libraries in the [sourcehunt series](https://www.sitepoint.com/tag/sourcehunt+php/) - a monthly list of projects that could use more attention, either in users or contributions. Might be a good wheel-reinvention-prevention if you see something there similar to what you intended to build, could be a good opportunity to contribute instead.
php ftw!
Leave if you can. If you have to stick around for some reason, suck it up, write crappy PHP for the time being and leave in 1-2 years.
&gt; The opposite of explicit is implicit, aka magic. The argument isn't explicit vs. implicit, but simple vs. over-engineered. &gt; I don't understand your position. The configuration is simple array-like trees. For what reason do you want to complicate that to the point that you need delegates, closures, etc? Because experience shows me I can often replace a metric shit ton of array configuration with a two-line closure. Also arrays are not typed in PHP, making any configuration issues a runtime error, as opposed to an error in your IDE. &gt; I guess we read different articles. Yes, I guess the title if yours wasn't "the myth of the bloated framework".
The thing that's slow with vm is shared folder. For symfony it's actually just the ton of dev logs it writes. Override AppKernel.php to write cache in /tmp and symfony will be very fast
&gt; You might not like what I'm going to tell you, but it has to be said. Getting reactions like "there's no one in our organization that knows this except you" are suggesting that your efforts might actually be detrimental to the organization. Thanks for providing that perspective. I am sensitive to his concerns about increasing the fragility of the application by using tools no one else has learned. What bothers me is the attitude that no one should take the time to learn them. If I wrote the routing component myself, from scratch, as we usually do for new projects, I feel like it would be the same problem, but with an even darker future regarding maintainability. As you say, I could always seek out more congruent perspectives elsewhere...
Sorry friend, it's probably time to leave the company. If you are in a position where the c-level is active in the code base, but has that kind of attitude, nothing is going to change their mind. You could either buckle down, write out-of-date code and collect your paycheck, or look for a company with leadership that embraces good development practices. 
The urge to save myself is indeed strong, but I would feel better if I could point the team in a better direction. I guess that's my main frustration.
I've exhausted my patience in being consistently somewhat misunderstood by you. If you don't understand what I'm talking about, then a decade of more experience give or take 5 years, you'll figure it out.
That's exactly what I'm talking about. There is no need to couple logic to your framework. Frameworks nowadays are just scaffolding for components. If your app has grown in size and you need more control over that scaffolding, you can drop the framework and just use the components you need if you kept things decoupled in the first place.
If it's the bot that you interest at, have you checked [smooch](https://smooch.io)? It let you integrate any chat interface they supported (messenger, slack, line to name a few). And then you can build your own bot with PHP and integrate it using webhooks or api.
and if anything goes wrong, they will blame you and pretend you had "big ideas that didn't pan out" instead of recognise the way they work was holding you back in the first place. They will never change
Convince the other devs to jump on symfony. If you're the only one, your boss has a solid point even if the alternative is crappy. Look at it from his perspective. You won't be there forever and when you leave he'll be forced to hire someone that knows symfony vs someone who knows PHP and he may be in a bind until he finds that person. Write better tests so that your stuff never breaks. If you consistently produce higher quality code than everyone else people are going to notice and that will bolster your argument.
Haha Bullshit. A company only cares about profits not if is embarrassing using an programming language or not
That's an excellent reason. I should've been less flippant in my comment.
It does appear to have a t-shirt cannon involved to "help" him get dressed, but god help you if you try putting on pants that way.
I'm sure the Founder/CTO wrote his own router in PHP. Copy/Paste that crap. When it doesn't work show him Symfony or League's Router implementations. I would bet my kids lives that they are faster, take less resources and offer more features/flexibility.
Me too, I want to know if he's spent any time updating his PHP skills since 2004/2005
I'm thinking of doing something like this (difficult, since most of us are remote, but not impossible). I'm basically just trying to gather some good resources here. What would you say?
That's a really creative solution, I like it. Unfortunately that would also require more learning for the team - I think I'm the only one that studied design patterns (most are self-taught).
I'm giving you pattern names in order to communicate the idea to you. To them, it's a custom-built simple component that's a wrapper, hiding the complex third party component. It's not like they need a degree in patterns to understand the idea.
Please be aware your boss wants to say no going in; he's made that abundantly clear. The slightest mistake and he'll say "I wanted to listen, but you've shown me how hard it will be." Unfortunately I use that tactic to crap on ideas I don't like all the time. The difference is I'm aware when I'm doing it, and I do try to return to people to ask them to show me again when I've got more time. The problem is not your ideas, it's likely the stress level of your boss, but the irony is that he won't become any less stressed until he listens to you. Out of interest, how is the pay? 
Not good. I could probably double it if I moved a few miles down to SF/San Jose. But then I'd pay double the rent, and give up some of the flexibility (Remote, 4-10s schedule). Although with premiums how they are, a medical plan would be great. A startup would probably have actual quantifiable equity shares instead of promises that "When we make it, we're taking you with us!". Oh yeah, no retirement plan here, either. Okay, now I'm just bitching... sorry.
I've never found a use for Ruby in the web world, must be useless, eh? Just because you personally don't use Python or lack the ability to, doesn't mean there aren't way more talented and experienced people out there that do. From a few of your posts it's obvious you are still learning, so why be a salty bitch about Python, a proven and extremely powerful language, when you literally don't have any use for it in a web environment? 
&gt; Just disappointing he didn't release the code Yes, knowing the source to his personal home system would be such a safe idea. I think he'd rather people didn't know how to break into his house and have to make it a full time job just to keep his fun little project from letting people find hacks and bugs in his code to exploit. I have a small setup similar to this in my RV, there's no way I'd want anyone to know my API access points, I didn't encrypt or secure any of my automation APIs because no one will ever find out how it works. But instead of my dinky little RV, Zuckerberg has a lot more to protect.
oh damn, thanks for noticing. The readme is there, in fact I generated the site docs from that readme. But I forgot to actually push it. Thanks!
Gotcha. So in other words, "my argument has no substance, so here's a personal attack". Cheers!
See, this is why I gave up. No matter how many times I gave you concrete answers, you kept shooting at completely random vectors, with the hope of reaching this predetermined conclusion, once I've had enough of you. So I thought, I'd save myself the effort...
TBF centos 6.8 has your back for some time even if you are running 5.4, but it's probably best not to plan to stay on it. What's upset me is the lack of generics although it's an RFC I don't think it made it in 7.1 along with generic arrays and I wouldn't know how they would be implemented. https://wiki.php.net/rfc/generics https://wiki.php.net/rfc/generic-arrays
This. If you're a team of developers then you need to make that decision together (or have it mandated for you). What if one dev used Symfony, another Yii, a third Laravel, a fourth Cake, etc? Doesn't sound like you pushed and then got approval, just you snuck it in there. That said, frameworks are great and you don't have to reinvent the wheel, but you also can't force it on people.
I don't understand the rage against Doctrine. I've worked with Java and using Hibernate, after your became familiar with it, was awesome. The same with Doctrine. It keeps everything CRUD related marvelously good to work with. "But the speed" well, if your want speed, SPEED, use some Go, Java or Node microservices. Doctrine is, for me, the best ORM tool on PHP. And your can use Eloquent if your want Activerecord. Symfony feels bloated because, the standard package, comes with everything your will need to built your application, system, erm, whatever. Your can built almost everything with the standard.package AND with best practices.(
He should know configuration over hard-coding config if he runs facebook. I don't hard-code at home so why should a billionaire with all the free time he wants input specific credentials or URL's? It's badass you have an RV (I love those) but your response was like Microsoft in the 90's decrying why nobody sane would use open source, it's a tired, misinformed argument.
I guess I meant it more from the perspective of his boss was emailing him about something that broke. Had he written better code, it possibly wouldn't have broken. But yeah, you're right chicken or the egg scenario.
There is a learning curve with frameworks and most programmers will be less productive before they are more productive. I would expect a CTO to understand this, but I've been in those small companies before, so I know people sometimes end up in positions they aren't ideally suited for. I believe your best bet is to get fluent with a framework, and then demonstrate what it can do. I've demo'd my personal framework a couple dozen times and never had anyone question the value (and truthfully Laravel is way better). The weaker the audience, the more profound the impact should be. Frankly, if you can't make this case effectively, chances are you aren't ready to be using the framework for real projects.
No need to be an absolute cunt. Pretty sure we're all still learning, I'm not ashamed of that. My comment was more to learn what others do use it for, not being a salty bitch. 
Hmm okay yeah. Sounds good, thanks! 
Yup, they are bargain basement, and they deserve to have angry clients when they can't keep the software to to date as they promise. Also, jeez. Makes me want to start my own agency...
Yeah, we're talking microseconds here though.
This has been my problem for the longest time. (like 15 years) You want to change the business, doesn't matter if it's for better or worse, most people/bosses/owners/managers don't like change. Find one that does, those are the ones that know how and why to embrace best practices like unit testing, scrum and a clear design phase. Even if a new job doesn't work out, it teaches you something about why it didn't work and usually a new job is an easy way to get a nice increase in pay. https://xkcd.com/1768/ 
http://www.phptherightway.com/
You can start with http://www.phptherightway.com
The point of writing a Facade is so you don't have to dig into it and see a third-party component. Maintaining a Facade is simpler than maintaining all uses of a third party component throughout the app, this is why it's useful. In my team when we split responsibilities, I'd often write some Facade interfaces for adapters I've not written yet. I just write some mocks, and the team gets going, calling the mocks. Then I get the adapters done, and we're set. This is a team of 6, where only 1 (me) had to deal with the awkward API of PHPExcel (in one example), and 5 could just use a simplified, reliable, consistent API throughout their code, and I fixed all the edge cases and oddities in the adapter. So overall, Facades are always a win in my book, unless you're willing to commit to a dependency so much, you are ready to make it a part of your platform (for ex. I do this with React and jQuery on the client-side). But that's a commitment one shouldn't do lightly, because if they do, it'll come back to bite them in the ass.
If there's one person with whom you should generally avoid arguing, it's your boss. This is especially true when your boss is also a/the founder. It's his company, his show, and you're paid to play the part for which you were hired. Instead of focusing on the code, focus on the needs of the customers. Unless your customers are looking at the source code (maybe they are but I'm assuming they're not), they don't give 2 shits whether your code base uses Symfony or procedural PHP, so long as the functionality they care about works as expected.
That doesn't sound like a good idea at all. I don't think these people are worrying about the size of the interface. They're probably loading a page, realising some route doesn't work. Opening the code and sticking some die statements to figure out what's going wrong (or just opening the code, seeing 30 classes and giving up). Adding additional layers of indirection would exacerbate the problem.
I get what you are saying, but his boss already has a strong bias and he will overreact and exaggerate his work and bugs so it confirms his bias. Other developers there probably create dozens of bugs, but the one that deserved extra scrutiny was his one. It's a shitty situation to be in and would be one that would make me think of moving on knowing that I was not going to evolve as a developer as much in that environment as I could elsewhere.
Senior BBC dev here. Just leave. You're right, he's wrong. Leave and find somewhere better to work.
Leave. Hopefully you'll be in a place to take some people with you.
Dude... if you can, start looking for another job. This job is going to stunt your growth as a developer more than anything else. It's one thing to not like frameworks, but, as soon as you said he didn't see value in stuff like unit testing, that raised a giant red flag. He has nothing to teach you and obviously does not care about the quality of his projects other than to berate his developers for making mistakes (that should have been caught with unit testing among other good practices). I can totally see that as a demoralizing environment. &gt; This is why I don't like frameworks. I really don't have time or desire to learn all this shit, so tag you're it. There's no one in our organization that knows this except you. This is such a laughable statement, I wouldn't know what to say in response. Symfony documentation is out in the open and maintained by a community of people using the same software. It is insane for him to say anything like this. Are his projects that well maintained and documented? Highly unlikely. Does anyone outside his company have any familiarity with your codebase? Only ex-employees... In all likelihood, even current employees don't know every line of code there is and there's only one dev who knows about a given chunk of code. And, referring to something ImprobableIT said in the comments below: &gt; Look at it from his perspective. You won't be there forever and when you leave he'll be forced to hire someone that knows symfony vs someone who knows PHP and he may be in a bind until he finds that person. This sort of mentality is very small minded and mostly likely from ignorance. Just because you are using Symfony (or components of Symfony) does not mean you have to hire Symfony people. The documentation is all out there. Any decent PHP developer can pick up a Symfony project and go with it. You don't need a Symfony certified developer for that.
The facade is just going to delegate calls to some other library. If you want to know what the interface is actually doing looking at the facade isn't going to help you. It's going to add indirection. You'll open the file and say "oh wow this class is pointless, it just delegates all it's methods to this othe....oohhh my god why are there 300 classes in this folder". 
He's a billionaire hacking away at home. Can't knock that.
&gt; The facade is just going to delegate calls to some other library. If you want to know what the interface is actually doing looking at the facade isn't going to help you. You're going back to the topic of debugging an implementation of the Facade. A "Facade" is a contract, an interface. It's documented what it does at the interface, and for its users **it ends there**. The goal of suggesting a Facade here is so instead of the application using complex components *all over the place* that no one wants to touch, but OP, preventing the team from *editing application logic*, we can separate responsibilities: - The needed functionality is exposed via a *simplified* Facade; OP can deal with the adapter *implementing it*... - And the rest of the team can use the Facade as is, so the application logic is free of complicated third-party components. Does this make the separation of responsibilities more clear? So just like you don't dig into the C source files of PHP on a day-to-day basis while writing PHP code and saying "oh my god why are there thousands of C files here", it makes no sense to talk how the team will be confused about how the adapter is implemented. 
I too would be considering moving on but in the meantime I'd try to make the situation better. Maybe it would improve before I left.
Man, chill out. No one has to have the same opinion than you goddamit. I LIKE OTHER THINGS. let's agree to disagree. You act like my grandma when I tell her I am atheist.... Which implies, like /u/1110101010, that I won't reply to you anymore on this matter.
What I'm saying is even if you could expose only one public method e.g. add a route as soon as this doesn't work as expected the user is going to ctrl+click through to the implementation and you're back at square one. They're still having to learn the underlying library to solve their problem (or sending a snarky message to the OP). The OPs boss is going to be exactly as pissed off at the situation. They're not going to say "Oh well, the used the interface as directed and it still doesn't work. Might as well just give up on this project forever since I cannot traverse past the impenetrable barrier of the interface".
I'm perfectly chill, man. You're free to have your own opinion and use what you want; I'm not trying to recruit for Symfony. I just don't want to see people deterred based on misinformation.
&gt; I've yet to find a use for Python in the web world. Yeah it can be tricky to find use cases to mix things like this. At my last place we had our main application written in PHP, which was used to record data and produce reports and the like. Whilst under the hood we used Python to generate the statistics and do our data analysis that was used in our reports and inside the main application. In our case Python was better suited to handle the analysis we were trying to pull off mostly due to the extremely nice statistical packages available for it. It was also quicker and easier to use Python with Lambda on AWS for that purpose.
I'm not saying I personally would do anything. I'm saying the person this thread is specifically about who has explicitly said they do not wish to use frameworks might not be thrilled to find out that hidden beneath an innocuous looking method call there is... surprise! a framework! You're arguing (nice argument to absurdity btw) that the company should be happy to silo all knowledge about how their software actually works at a PHP level (i.e. their job) in the head of a single developer because "separation of concerns". What if they want to add new features that were not considered in the original interface but the OP is on holiday. What if the OP does what he should and just leaves. Business continuity? separation of concerns! You're proposing a technical solution to a non-technical problem. edit: sorry ~~concerns~~ responsibilities. 
I'm proposing that instead of 0% of the app being editable, that 80% of the app are editable, and the 20% are separated into a library of thin wrappers in its own namespace, that can be dealt with separately. By OP, or whoever will come after him. But I understand you're not a 80/20 rule guy, you're a 100/0 rule guy. I think even OP's supposedly unreasonable boss is not as unreasonable as you're painting him to be. After all, he manages to run a business and turn a profit, which surprisingly happens with *separation of responsibilities*, which BTW is not a "technical solution", but an organizational solution.
I don't have anything further to add. I'm just posting this to get the last word. 
I have to agree you should leave. This comes from experience. 10 years ago in my first job as a developer our "CIO" of a then 20 person e-commerce company opposed the following things: - Source Control (SVN, GIT you name it) - Staging/Test server (we coded on the production server, thats not a typo, we coded on the production server) - Frameworks (they are bloated, we can code it better) - Unit Tests (no one outside of academia does that) Probably a few other things I've forgotten. This was my first job in development, so I stuck it out 3 years and then jumped ship, the whole team eventually jumped ship. The "CIO" was fired eventually after the CEO realized all of his senior devs were leaving. After the "CIO" was fired, one of the best engineers actually came back after the CEO reached out to him lol. TLDR; These things are easy sells, they shouldn't take much convincing. Run. Don't stick around over some misguided sense of duty or whatever. This guy sounds like a dumbass, wonder if he is the same guy. Are you in Utah?
Always looking for good developers https://nabancard.jobs.net not sure this helps but I like your attitude 
It's fast enough for me with NFS. I tried moving the cache folder to a local folder in the VM but I lost my integration with PHPStorm, which is crucial.
I wrote a really long sarcastic response filled with love and annecdotes but reddit has a 10k char limit so TLDR; the state of play is not what you are representing it is. I've nearly 15 years professional experience &gt; 20 years of programming and I still don't get it right all the time. Cut yourself and everyone else some slack and just write some tests! [Fantastic illustrative device](https://pics.onsizzle.com/but-without-human-sacrifice-concl-encl-who-will-feed-the-1184405.png)
You missed the point. The point wasn't about how easy it is to write, but how much needs to happen during runtime behind that code.
And that is a concern why? You realize this is a full stack framework, right?
If you've worked on one MVC framework, you can work on others pretty easily. I've never touched Symphony, Laravel or Zend. But I have worked extensively in Cake and Code Igniter. No doubt in my mind that I couldn't get up to speed quickly on a new framework, especially with a team of folks working on it daily. 
What does that have to do with the cache directory? I use that plugin also and service navigation still works.
There is also https://github.com/mailhog/MailHog which is written in Golang. 
no prblm, wheneva u want..
Is your nice code that only you can edit, modify or improve *really helping* your company? Sounds like to me if you are literally the only one in the company who can work with it *that's working against the company*. Whatever your intentions are or were you have to accept that even if it's a generally better way of doing things, if the 10 (or however many other) people on your team can't do anything with it then that's a really big liability. To answer your actual question: &gt; How would you convince your boss that libraries, frameworks, and unit-testing are good ideas? Don't try to convince your boss by sheer force or brilliance; that rarely works. Instead try to listen and understand where he is coming from. Thoughtfully consider his opinions. If at the end of a few conversations you can't see it his way and he can't see it yours then that is your clearly painted exit sign. These are people problems and are solved by people solutions, not technical merits. Good luck, whether you choose to stay or go.
&gt; I feel like continuing this way hurts our ability to compete, Do you mean compete as in time to market? If so then that's a valid argument, but a framework slows everyone down since they are learning it. The only way you can fix this is taking time outside the company and build or test tooling to support this. It's pretty clear the Boss doesn't value code quality so this will be the only viable way. &gt; or attract talented developers. This is subjective, there are developers that are fine with the way the boss wants it. In the end, no one wants programmers that only care about themselves, its about working as a team. Those that truly care about the company and products will stick around. However, enough people turnover then the boss will have no choice but to reconsider. &gt; I also feel like developing in this fashion is proving all the PHP critics correct, which turns my stomach. If you are about the company you work for, you have two choices as arguing will do nothing. You need to stand up and consider the following: - Leave the company and let them know why (poor development conditions) - Confront your boss and have a different discussion, forget about the code for the time being and get involved in different aspects of the business. Understand what the goals of the business is and what type of clients that can reach. Overall what you want may not be their current marketability. Here is what I did to change things around: Here is what I suggest if you still want to push, ask for permissions to improve company software outside of office hours unpaid. Note that you want to experiment with learning. Then take your own time getting better at X framework. Document as much as you can. Once you are ready present it to the company or those of interest. At worst, you spent time improving your skills. Get feedback on why its not better and work on those criticisms. Repeat this until you get most on board, as this will be the first real example of better software. If you cannot seem to push that software into the company then stop and look for another company. However I if had a second chance, I'd just find another job. I've put so much work into the company and its not even mine to start with. I'm better off starting my own company than trying to mold an existing company into what I want. Do note many companies to not like moonlighting and there may be agreements in place to prevent that.
Who is the target audience of this package? I feel like as a developer, I'd build my code to interface with PSR-7, making me in different to how end developer's psr-7 library chooses to populate the data. As the writer of a PSR-7 Library, why would I choose to this super niche market of users with this pecl extension?
Ask yourselves this question. Why do you use Php even when the whole development world have acknowledge that it is a toy language and should not be used for anything serious? Because it works for you, right? Now. Put yourselves in your boss's shoes. They don't want to change things because the current processes works wel l enough for them. So they don't want it to change. Now, If my comment sounds annoying and irritating to you, that is exactly how you will sound to your boss.
If you need external input to prove something is a good idea, may be it's time to ask yourself the question "Why is this a better idea?". If you can't plausibly answer that yourself, may be it's not a good idea and you should delve deeper into the concept until you alone can advocate the idea. I don't mean to be rude, don't get me wrong. I know the frustration and I know what you are suggesting is perfectly valid. I've been in the same situation and couldn't convince anyone of anything until I could convince myself. Note: If you can, leave!
&gt; using the antiquated procedural GET-param router that one of our senior devs copies and pastes in his projects is insecure, inefficient, inflexible, and difficult to maintain. Sounds to me that this is your argument. Provide proof of insecurity (on a copy of code which runs for his biggest account), proof of inflexibility (preferably with an actual requirement from a client which has been promised for a price, and the margins on it are razor thin because of the inflexibility), proof of inefficiency (by staying back late one night and re-implementing something which took days his way, but mere hours using yours).... Sounds a lot like the CTO doesn't want to let go of the tools. He likely sees himself as the best developer asset the company has and is conflating his authority (which is legitimate and earned) with his ability (which on the face of it seem inadequate). If there is a hope of him changing - and remember there's a good chance he won't so be ready for that - you need to provide clear objective proofs that his way is hurting his hip pocket. But in all honesty, I'd thank him for the opportunity to work with his team, tell him you have learnt a great deal, and give him notice.... 
You can't save the team with that CTO's attitude. Just get out. Pushing teams forward is difficult enough even if you have CTO support. In your case the CTO is actively pushing back and punishing you (tag, you're it). You can't win.
X-Post referenced from [/r/webdev](http://np.reddit.com/r/webdev) by /u/WouterDS [Quick Guide: Setting up PHP 7.1, NGINX 1.10 &amp; MySQL 5.7 with Docker](http://np.reddit.com/r/webdev/comments/5jfuzy/quick_guide_setting_up_php_71_nginx_110_mysql_57/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
I've seen an implementation of ESB in PHP used for a website serving millions of requests daily successfully. It wasn't particularly difficult and keeping everything PHP made it easier for a developer (with only PHP background) to pick up and develop new features.
Yeah, I get what a Facade is and how it can help in other cases - I just think this particular boss won't be happy when he finds out what's going on. &gt; The point of writing a Facade is so you don't have to dig into it and see a third-party component. That benefit only works when the Facade works properly, perfectly, and doesn't leak any details of the underlying code. At some point, there will be an issue. Because even if it's perfectly designed/coded the first time (no slight on anyone's skill but: unlikely) at some point there will be a future change in requirements, and then the Facade API might need work. A boss that supports Facade's will be fine with that. This boss? Hmmmmmm. Basically, the situation you describe in your own shop sounds great, but that's with full management support. OP does not have that, to say the least. It's a very different case. But looking at your other comments, I think we'll have to agree to disagree. I'm about to go off on holidays - hope yours (And OP's, more importantly) are good!
Might try this out soon. Could be really cool but it seems to me, although I can get it running in a few minutes, flushing out all the issues this approach brings with it is going to take a big more time. Definitely worth it in the end.
&gt; **If** git was that kuch of a fight, just let em die. Some companies can be open to suggestion if you present it correctly. Need to think about why it took 2 years to switch them to git? Did you present a well argued reason ? Did you plan the transition ? Did you take the responsibility on your self to support it ?
Ask your boss to watch this presentation: https://m.youtube.com/watch?list=PLo7mBDsRHu11ChvScWUE7MN1Qo5QVHQEz&amp;v=0RGW4TyN5hk It's worth noting that it's 4 years old at this point. It pretty much explains the world of php prior to psr-0 which is obviously the world your boss lives in. It explains and justifies why you did what you did. If he doesn't get it, find a place of employment that at least aspires to a level of proficiency and professionalism.
That's true, but as boss leading software project, and he opposes unit testing? That means he is totally out of the loop, clueless. And if his coworkers are the same, then I would question whether such an environment isn't detrimental to my career progress.
Not OP but like many others I'm in a similar situation and your post gives me a lot of clarity. 
&gt; That's true, but as boss leading software project, and he opposes unit testing? That means he is totally out of the loop, clueless. We actually don't know if he "totally opposes unit testing". You're bending OP's words, who might be bending his boss' words. I could be possibly described by someone zealous of unit testing as "having negative views of unit testing" despite there are thousands of tests in our projects. It might turn out his boss isn't fond of their shop moving to some of the extreme form of TDD, or write tests until they have "full coverage", even if aspects of their software which is best tested by QA (like UI), or other parts of their software are quick throw-away automation that won't be touched once it works. There are always two sides to a coin, so don't be quick to demonize the "clueless boss".
also thanks because it's author has done some work for me on another thread ;-)
As someone still struggling to leave a slapdash-development place, you need to give it your best shot but know when to cut your losses. Don't make my mistake. 
If the goal is performance, you don't need a trampoline, you can calculate that highly coveted Fibonacci number with a simple loop and zero closures.
It's easier than one would think really. You'll be amazed!
Pretty sure CI3 does support composer, unless I'm missing something obvious? https://packagist.org/packages/codeigniter/framework
 I gave a talk about this, about how 'lowly' programmers can make the value case for unit tests to more senior people: Slides here: http://docs.basereality.com/ValueCaseForUnitTests/#/ Recording here: https://www.youtube.com/watch?v=wb7tc0IxkyI "the antiquated is insecure, inefficient, inflexible, and difficult to maintain." I'm not at all sure what a router has to do with security...those should be completely different things. But you should be able to document how easy it is to setup new routes when using a better routing library, or document how much time you spend maintaining the old router, if that does indeed take up time. It is difficult to show how much time is saved by re-using library as it's difficult to point to work that has been completely avoided. &gt; How would you convince your boss that... frameworks,....are good ideas? I'm really not sure they are for a significant number of applications. Re-using libraries is a great idea, and you do need something to link them together. But this can be done quite simply without using a framework, and the added complexity that Frameworks like Symfony and Zend bring to the application aren't obviously a good trade off. 
To be fair, that's because NumPy doesn't do the calculations in Python
Yup hope there will be a request / response object in PHP some day in the future, the super globals are always a bit ugly to work with.
&gt; Symfony feels bloated because of all the ceremony required around what the developer assumes should be an easy task. What kind of ceremony is needed in order to complete a simple task? Because if you are using the fullstack edition, things already come wired up and there is no ceremony needed.
You DO realize there are HUGE projects, like YouPorn, written in Symfony, handling thousands of requests per second, right? Symfony is slow in its development environment because of all the profilers, debuggers and logs it writes. Those can easily be turned off (I mean, really easy, like a flag in the configuration files) and none of these have any impact in production. I run massive applications using Symfony, and I can assure you its production callstack is WAY smaller than its development callstack. Not even fine tuned, I didn't even go to extremes to make optimizations. You can see the great difference just by calling `app.php` instead of `app_dev.php`.
Also agree with this point as many others surely do. I'll share my experience. I had been working for a small scale IT business that developed websites with custom PHP panels to manage content on websites. I've tried my best to get them to use Git since we have had so many problems reverting changes that went awry with developers on our team. We only logged our tasks in tickets assigned to customers making it a headache trying to find problems and solve them. The shared hosting server we managed back then (july this year) was still running PHP 5.3. It took me a proper 5 months to express that we needed to upgrade our server and prepare for the changes necessary. During a big project with one of our biggest clients, the call was made to migrate to 5.6, among other things a lot of web shops and websites stopped working. No big surprise there for me, but my boss pretty much tried to put all the blame on me that we weren't prepared. During the whole migration attempt he kept hammering that I was the one responsible for it all. We lost a big deal of files in the migration due to some backup malfunctions and again he blamed me. I just kind of flipped the switch after all of this setled down. I realized that wasting time and effort on trying to convince someone to make a step in the right direction just wasn't worth it. A month after my resignation I got offered a new job with way more pay and pretty much in a new environment where Git is the standard for VCS, PHP7 on the server is up and running and projects that I'm allowed to work on to keep it as up to date as possible. They have offered to pay for a quick course in Laravel since that is what they plan on using for a new project right now. I've learnt so much at my old job, it was my first job as well. I lasted around 4.5 years. I'm not saying I was at my best the first 2 years but I wasn't completely stupid. Leaving the company for my current job was honestly my best move ever.
Symfony3 is like 1000+ req/s out of the box. Then once you start throwing things like APC, Varnish, maybe Redis, etc, you'll easily be in the 10k-20k range. I'm sorry that you have to work on giant turds.
Another dimension of AI that worth checking out is natural language processing. For example, there are multiple ways to ask the same question to a booking bot: Make a reservation at Olive Garden for 2 next Wednesday. I want to reserve a table for two this Wednesday at 18:00. While you could use PHP to look for keyword like "reservation", "reserve" etc. It's not easy to extract these data using regex: place (Olive Garden), people (2), date (Wednesday), time (18:00) Library likes API.AI does that for you. There are not a lot of tutorial for PHP out there, but this one should get you started: https://www.sitepoint.com/voice-controlled-php-apps-with-api-ai/
So, any vcs... ROFL
[no-framework-tutorial](https://github.com/PatrickLouys/no-framework-tutorial) Doesn't cover everything, but should give you the basics.
For #1 - You should be able to pass 'maxDate' to clientOptions array property of the widget and that will just work. For #2 - This should help http://plugins.krajee.com/file-input 
&gt; it could be XSS, arbitrary code execution, SQL injection, etc. The first one. And also the second, as XSS by definition is a client-side arbitrary code execution. &gt; how can I sanitize input from $_POST and $_GET in order to prevent these things? Nohow. Leave both alone. &gt; does the method of sanitization change based on the type of expected input? Obviously, it depends on the type of the **output.** So to boil it down. Use this function when outputting untrusted data into HTML. Anywhere else it will be either useless or harmful.
Use `htmlspecialchars()` when printing output, not to transform input. For storing user input, never modify it before saving or error you're stuck with the modified version until the end of time. Instead, escape it on output depending on the context in which you're outputting it. For SQL injection protection, use prepared statements.
If you are going to stay there (and you may live somewhere where finding another job isn't as easy as everyone here seems to think), then convince your other Devs. I did that here. We were still doing PHP4 style code on live servers with Vi. I got us baby steps to an IDE, vagrant, and version control and upgraded to much more modern coding standards (composer autoloading, some unit testing... were not perfect yet). My boss was not super excited about the learning curve taking time. My fellow devs didn't really want to change the way they were doing things, but I put together the list of reasons, and showed the advantages along the way, and dragged them along. Now we are much more productive, and I got the "lead dev" tag. It can work out. tl;dr; think about convincing the other devs to learn it. It would be good for their careers and then when the CTO says he can't fix it, you would have a team that could. 
Use http://twig.sensiolabs.org/
Should be worth noting that if you are planning on writing a bot that runs as a long running process, PHP is definitely not the best language.
I am really interested in that too. I started digging into Docker a couple of weeks ago with the exact intention of using it in production. I am not devops, but I managed to make a somewhat decent [setup](https://github.com/adiachenko/docker-laravel) for development. The real problem starts when you start thinking how this will work for more advanced use cases. I researched on Docker Cloud for a week, but figuring out the useful setup with zero-downtime deployment, database replication and the like made my head ache. And I haven't even got to scaling yet. It seems like Docker really pushes the production angle but every example in the docs is very simple and, more to the point, stateless. They don't show how to use it for real-life cases beside some rudimentary node.js maybe. 
Thanks a lot, that was fast. I must have been passing it to the wrong options, as I kept getting UnknownProperty thrown at me. The fileInput plugin looks great, will try it out. Edit: Speaking of ClientOptions - I've seen quite a few people having problems with dicerning between Options and ClientOptions. Are these interchangible now? Or is it somehow version related? Maybe I'm just bad at looking up stuff.
I already use bind param/bind variable, but i'm open to new opinions. It's easier to act like an idiot because it's usually the only way to get someone to provide a genuine quality answer
Ever play league of legends? They handle 100,000,000 players a month. Using Docker. https://engineering.riotgames.com/
https://github.com/mpociot/botman
Additionally, if you're not convinced by twig and prefer to work closer to the ground, you can include() a home.php and inside that, include() a header.php or nav.php but remember... your view/template files shouldn't contain any logic except that which directly pertains to how the page is displayed. No calculations, no queries etc.
I'm not assuming anything. If you write a web app that can only handle ~8 requests per second, you fucked up hugely.
If you plan on staying then you need the support of at least some of the other developers. Don't attempt to change all processes at once. Be selective in your approach. Be persistent. Where I work, if there is a new process or tech that someone wants to implement they present it in a workshop setting first. Sometimes it takes several workshops before everyone else feels comfortable enough to adopt it. Good luck.
yuck
Sure, super simple ones. But you run into a lot more issues to solve than you would from using another language that is more equipped to handle long running processes.
Pantheon uses containers for all of it's clients.
&gt; You can install CI3 via composer, but your developed app itself cannot support composer packaging to the degree that some other modern frameworks do. This is partially true, in that CodeIgniter &lt;= 3 itself does not utilize namespaces or Composer autoloading. If you want to use third-party packages that are autoloaded via Composer within the framework, you can just add the `autoload.php` file in one line and do just that. Easy. &gt; that composer package you are linking to is obviously hacked by someone to fit these classes into namespaces There's nothing hacked here. The package is just a mechanism to create/install a fresh CI3 app by using `composer create-project`.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I'm pretty sure he's just talking out of his ass at this point.
There's a phrase and a popular debate: "worse is better." Personally, I am to fix this phenomenon and ensure that in the future when people take the simplest, and easy path to get the job done that it results in secure rather than insecure code. But that's extremely difficult. You can't really stop overworked web devs from writing insecure code.
I already spend a lot of time outside work improving myself. At this job, I wouldn't grow much otherwise. I don't believe that I should build products for them in my free time, though. It's worth much more than that. Owning new projects is my only opportunity to present new techniques, and that's where I've been able to prove other techniques in the past (version control with git, OOP techniques). This time it got a negative response. I'm sorry you've been in a similar situation, I feel your pain. Please don't think that you're ever out of chances, our skills are very much in demand today. 
Anyone can read my documentation, or the Symfony documentation, and quickly get up to speed. By contrast, all the applications built from scratch are unique to each developer's style and opinions (aside from basic formatting rules) so the time and cognitive load is much higher. Your other points are right on the nose, and exactly why I came here looking for ways to move the conversation forward.
I've noticed this too.
Thanks for sharing. I've been there with you one the fight for moving to 5.6 - it took several new projects choking on EAccelerator (doesn't understand closures), which meant it had to be disabled, which meant no opcode cache, which meant his servers were crying. We still have one old 5.3 server out there for hosting legacy stuff, though. I've brought up 7, but as long as security patches keep coming out for 5.6 I don't think it'll happen here. Hey, at least you had a ticketing system - we use email.
Good point, it would be more accurate to say that he thinks spending the time to write tests when most of our projects are small projects for small clients, won't be worth the investment. I think if I could show him how sweet it is to hit one button and get an output that proves your code changes didn't break core functions, it would sway him a bit more. But making that investment up front is his big obstacle at this point. Proving the ROI is difficult for me, since it occurs over time.
&gt; Good point, it would be more accurate to say that he thinks spending the time to write tests when most of our projects are small projects for small clients, won't be worth the investment. It might be the case if one of these is true: - Your projects are small, mostly-static sites, or... - The dynamic parts are stable and reused from project to project 1:1, or... - Once delivered a project rarely sees further evolution, aside from the rare bug fix. &gt; I think if I could show him how sweet it is to hit one button and get an output that proves your code changes didn't break core functions, it would sway him a bit more. Well, I don't think "how sweet it is" is a business value. If you do manual testing, which can more efficiently be automated, now this is business value, because it makes you faster, and people are the most expensive resource in a software shop. But if you don't need testing, or the nature of your work defies automated testing (see bullets above), then writing unit testing might feel sweet, but it gives you no business value. So it's all about specifics...
you forgot the /s
Not really. I seriously want to know the answers because lately I have seen too many people using PHP-7 yet half of them say they are not ready to migrate to PHP-7 in production.
Not what you are asking, but If you want to try out Hack, you may want to look at https://nuclide.io/. It is made by and used by Facebook, as is Hack.
I think they are asking what everyone prefers as an IDE. 
Komodo Edit http://www.activestate.com/komodo-edit
Microsoft Word 2003. Want to upgrade to 2007, but whateva!
I know most people will prefer PHPStorm, but I find comfort in Sublime Text (with a number of add-on packages). It's simple, it's fast and it works well for what I do on a daily basis.
[removed]
 RUN apt-get update [Don't do this](https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#apt-get), it can cause caching issues on subsequent runs.
Atom, hackable, lots of great plugins (git, linter, autocomplete,...) see: https://atom.io/
&gt; If you can't plausibly answer that yourself, may be it's not a good idea and you should delve deeper into the concept until you alone can advocate the idea. Well said. I think because I haven't had the exposure here to prove it to myself, and my personal projects don't hit any sort of real-world scale. My problem is that I'm in a tribe of hunter-gatherers. I've seen that other villages do better by pooling their time and effort into something called agriculture. It takes a bit of land and planning, and most of the effort is up-front, but the rewards can be great for the patient. I'm too busy hunting and gathering myself to tend a garden or breed stock on my own. How do I convince the chief of my tribe that agriculture would be better for us? (He's a really good hunter).
As a good example of mature project which uses BDD is Sylius https://github.com/Sylius/Sylius/tree/master/features You can take a look into it, really good examples. However, I agree with you that BDD is not for everyone. And that's what is my next blog post will be about )
Phpstorm
Speaking to your points: * We don't do any static sites. * We don't have much reusable code. The devs that do, use a bunch of chunks of procedural code that they slice and dice (that's one of my main gripes in this situation). * That's true of some, but not all projects. We often maintain a healthy relationship with clients, so you never know when they'll need a new feature. Currently we do manual functional testing, but the responsibility is mostly delegated to our clients (or our helpdesk team, if it's an internal product) who must test before they approve the ship to production. I don't feel good about that shift in responsibility, and I think a few of them don't feel good about the shift in liability. All the time major issues get missed, or pop up months after a change has been deployed because of some edge case. After doing things this way for so long, though, I think they expect that as just part of the process.
I'm not sure where you got that impression.
woocoomerce
Netbeans
I like phpstorm, but honestly I probably use a fraction of what it's capable of...
sublime is rad for general work, I agree. I also use phpStorm on the daily though.
 VS Code with the PHP extension pack
Atom
Try tweaking your cv to highlight the experience and skills you do have there was a post the other day on web dev I think about how to apply for posts. I'll edit if I can find it. You'll get there! 
A common approach is to use a template engine that allows hierarchy. Have a layout view with content areas defined. You then reference the layout and blocks to populate in each view. This keeps things like title tags, meta descriptions, as well as the main content, and JS calls out of your controller. Laravel does this well, which uses Blade, although you can achieve the same in vanilla PHP.
Forgive me, I Know what behavior driven development is but I haven't heard of SDD before and googling it isn't coming up with anything. What is it, and why should I be researching it?
Why do people post this every week as if the top 10 replies *aren't* going to be phpstorm?
I had the same issue with recruitment agencies- they're basically looking for key words on a CV. I sent my CV in directly to the company - that I was interested in working for - HR dept, then called them weekly, then bi-weekly, then daily to find any job availabilities, letting them know I'm keen for an interview. Maybe I was lucky, maybe HR liked that I expressed I was keen. ¯\\\_(ツ)_/¯ it worked though. Been here 4 years. 
PhpStorm = Webstorm + Php stuff. Says so right on their website.
Might be a good idea to contribute to an open source project, something you can show on your resume. Or start a project and open source it on github 
PhpStorm
Notepad++
Some of my favorites: - ctrl + shift + F : global search for strings - shift (tap twice) : find functions, classes, files - middle mouse btn: takes you to the definition of a function, or var - back button on mouse: takes you to what you were looking at (amazing) - ctrl + space: code suggestions - the db ui is pretty nice - my co-workers swears by the GIT ui but i only use it for merge conflict resolution - xdebug on it is fantastic
What made your so persistent to work for that company? Or did you do it from them all? I'm applying for placements and finding it hard to get excited about a company so am struggling with the personal side 
When it comes to automated tests, I only partially agree. Tests that test single, isolated user stories quickly turn into bloat. Regression suites that are designed around measuring the health of your application are something different. If I have a suite of tests that hits my API in a variety of ways and verifies that it is up and running and that the basic features are present and working, then that suite can run against every build and you can gain some confidence that your previous functionality is working. You can't test for every possible bug with automated testing. Some things must be done with exploratory manual tests - I don't care who you are or what software you are testing, this is true and to think that you can is hubris.
i use most those, didnt know about the shift double tap thing though 
It depends on the client. If they need directly integrated payment gateways you will need to research whether the framework/software can comply with PCI DSS standards. As far as I know when I last looked woocommerce could not and could only satisfy a SAQ meaning iframe payment integration or off site only. (Happy to be proved wrong) Sylius I don't know so I guess the risk point here is speed to market, speed of modification and foreseeable length of time the project will be supported. I do a lot of Magento. It is convoluted however it has stood the test of time and so far (6+ years) has been supported in its 1.x variant with bug fixes and patches for the open source version. ymmv
pays good ? amazing magic of persistence
will look through, thankyou for your guidance
Like MVC Model View Controller ? imm pretty familar with OOP, i actually love OOP programming over procedual.
PhpStorm
As someone who uses it on a daily basis for pretty sizeable applications. I probably only scratch about 60% of the features it has out of the box. It does have a very defined way of doing things in order for you to gain advantages from using it and some people don't like it because of that.
It's all good. This is exactly why I have projects. The more developers that believe Symfony is perfect for every use case when done with some caching, the bigger my market base. I should actually thank you guys. 
That's *the* best shortcut on PHPStorm for me. 
You can create your own work experience. Contribute to an open source project. Find a non profit and donate your time to help with their website. The list of possibilities to create a resume full of experience without ever being hired is endless.
Being able to use MVC pattern is not OOP itself. The concepts you learn from OOP are applicable in most standard languages today (Java, C++, C#, Python, PHP \^_\^, Ruby, Swift, etc). Assuming you are a beginner, you won't need a mastery of these concepts, however being aware of them and considering them while programming should be a milestone for you. I would search for basic OOP principles and concepts if I were you. You can take a look at the Wikipedia article, however there's much more there than you'll ever need for the time being.
This will soon be voted higher than atom or sublime. That's the best part of the joke.
I use the ctrl + alt + arrows for back and forth nav, but may be better with a mouse.
PhpStorm
PHP Storm but Atom and VS Code are fantastic. 
That would probably be a negative, since this technique makes traces much harder to introspect due to the unrolling of the stack into a loop...
&gt; Full autocompletion (with the exception of Laravel and Eloquent, fuck Laravel and Eloquent) What's special about Laravel and Eloquent?
Obviously the favorite here, but is the new pricing still an issue, or has that been resolved to the community's satisfaction?
Which one? I love Code but miss IntelliSense
Pricing seems fair. Free for students and open source projects. You keep a perpetual fallback license with a i think one year subscription. Pays for itself in days. 
What was the issue with the pricing? I've always had it licenced through my employer so haven't really paid attention to that side of things.
SemWare's TSE Pro (e32.exe) for non IDE capable code and giant text files. Of course PhpStorm for new work and IDE. The Code Inspect found decade old bugs when I migrated the code to the environment. It made moving to PHP7 a breeze. Runner up, MS/VS Code for platform independence.. never like Sublime. VI for production shell access. Don't need no stinking vim.. even tho, I think its a symlink now.
PHPStorm / VS Code. 
He said it seemed like a fork of sublime. Not that it was. 
Are you simply a PHP-only developer? Do you also know HTML, CSS, JS, MySQL, and other things? If so, start calling yourself a Full-Stack Developer! I have a few ideas for you: * Do you have a website with a blog? Blog weekly about things relevant to the industry, your thoughts frameworks, content management systems, ideas, etc! Put your website on your resume. * Do some cheap freelancing jobs: freelancer.com, upwork.com - start with simple jobs to build your online reputation ($50 - $150 jobs) as no one will pay you a few thousand to do something if you don't have a reputation. Try to get people in the same country as you and at the end of the job, get their email or Skype and offer to be available for more work (even though you're not supposed to on those websites - they want you to keep paying commissions!). * Family and friends? Can you offer to do something for their businesses at a cheaper price, and then they give you a referral? (always be careful when working with family/friends - clear communication is important) * Start a few github repositories, put you github on your resume. Contribute to others, get onboard with the team. Volunteer with some open source projects: https://www.mozilla.org/en-US/contribute/ https://codex.wordpress.org/Contributing_to_WordPress * Show you are passionate too. People don't just want a developer these days, they want people who are in love with the industry, love building, and have a creative spark. Good luck and feel free to inbox me if you want a hand! 
What sort of things are in your portfolio? Since you say you have limited work experience, I wonder if you're perhaps applying for positions beyond the experience you're demonstrating with your portfolio. Maybe try to seek out more entry level positions, if so?
Whenever you want to embed text in HTML. You don't use it if it's already HTML (and since HTML is powerful, you trust it already). Unless you want to embed HTML *as text*, like in a source code listing.
I can't think of any good reason why you would separate genders of users into two tables. 
This isn't really a PHP question as much as it is a database question. Depending on how you intend users to find other users (heterosexual only?) it might be better to have them all as one table or it may still be more efficient to have separate tables. Nothing inherent to PHP will really answer that. It's more up to your business needs and what database system you're using. Hell, depending on what you intend your userbase to be (what sexualities do you want to accommodate) you may want something more general than a binary m/f split.
First: 1 table. Gender is just a property. User or person is your table. This is not a debate, trust me on this. Do you want to change 2 tables every time you decide to add birthday or shoe size? No. You wanna write 2 queries just to see your user count? Nope... This is basic stuff. 1 table. No doubt. Second: this is a SQL question not a php question. Try /r/sql. You need a crash course in schema design. Google database normalization. It's a rich and deep field that professionals spend careers on. Third: speaking of professionals... I have never met a programmer that didn't, at some point (when young and naive) try to build a dating site/Facebook copy/Craigslist clone/etc. Its a perfectly natural part of learning and growing as a programmer as long as you have fun doing it and learn a lot. Just try to see it for the practice project that it is, and don't get disappointed when it's not a viable business. You'll get better if you don't quit.
never tried phpstorm. happy with netbeans for years. am i missing out?
Use the same table. Just have a column in the table that can be M or F. Then to get all the men for example: SELECT * FROM people WHERE gender='M'
What he said ^ .. but also for genders, it might be better to have a separate table for genders and just reference user -&gt; gender by foreign key. That way you can easily add/remove genders as humans evolve into mythical beings with mutated genitalia.
You should have a gender_type_id (int) field in your users/members table and a separate table called gender_type that has a id (int) and a name (string) column that is unique. This is good practice, because you can use a foreign key to make sure the gender_type_id is valid value in the gender_type table. If you just use "M" or "F" in your users table, without the gender_type table and foreign key; you must force the application code to validate the value is "M" or "F". There is more than just "M" &amp; "F" See here for code to create the tables. http://stackoverflow.com/a/17366442/5264654 
I can't see what having it in two tables would achieve, really. They're all profiles, so just put them in a table for profiles. You don't want to have to be faffing around with both of them every time you want to add a column or change anything.
Over 8 years experienced php developer here, i have never seen or heard of anyone writing procedural in a company project
Probably my favorite feature of PhpStorm is multiple selection editing. A close second is code refactoring features.
What was the pricing issue? I personally think it is worth $200 but gladly pay less. I mean it makes me more than 100x that a year in side work. 
PhpStorm Non IDE I like atom or VS code. 
Yes you have. There are a lot of companies actively using procedural PHP if you consider how many sites are using Drupal. Drupal 8 is now OO, but it was just released a year ago and just beginning to gain traction. Drupal 7 and lower are predominantly procedural. Not too familiar with Wordpress customization, but I'm guessing it's not all OO either. Companies use both heavily for both internal and external projects.
Finally a fellow Vim user. Nothing against the obvious favorite here, but getting my environment up anywhere (including servers) in about five seconds is hard to beat.
IDE: PhpStorm Editor: vim
thanks for the feedback man, really appreciate it 
Don't companies just use laravel or other php frameworks ?
Please don't call yourself a full stack developer until you can take bare metal, rack it in a Datacenter, update your OS, build a site by yourself, and get your site on the Internet.
I know very few companies that refer to "full-stack" as anything much beyond basic SQL, a back-end language, and some front-end (html/css/js). It would be exceedingly rare to include OS-level knowledge in that term, and never require any physical hardware knowledge.
Have (or would) you considered an internship? Most software interns are paid unlike some other industries, and it's kind of the de-facto way to "solve" this kind of problem. Also, when you say recruiters, are you referring to companies recruiters or someone you are working with directly (more of a headhunter)? They're generally more of a talent scout type role searching for certain keywords, but often aren't a gatekeeper to getting the job. Try searching for a manager of a company you'd like to apply at on linkedin and message them directly.
Which kind of gets to my point, do you think OP can spin up instances and install packages? My point is, calling yourself full stack implies that you have done each of those things in a professional capacity. Hopefully more than just once. It implies experience. If you go into an intereview with full stack on your resume and you've only built a few sites, from basic SQL to CSS, then you're going to reget it. In my opinion. If I were interviewing you it wouldn't go well.
What I was mainly going for here was to not call yourself just a "PHP Developer" and instead show you're comfortable with the backend, frontend, and database - aka full-stack. You also barely find yourself working with bare metal in the web development industry, everything is usually on virtual machines, and vertically scaled if necessary. 
Yes, you are.
All of the jetbrains ides are just intellij with some branding and a different default set of plugins. Get intellij ultimate and you effectively have access to the entire set of IDEs via the plugin repository.
It's actually really very easy to spin up an instance and install packages! Heroku has it down really well. I'm sure OP can easily learn if not, I guess it would be great to have some background knowledge.. even though thats not something a full-stack developer would be in charge of. This is usually handled by a senior, or a deployment team. 
My point is the skillset you're describing is more than what's commonly meant by a "full stack web developer". Having more skills is always a good thing, but by no means necessary to succeed in a position with that description. Then again, it's always good to clarify what the company is actually looking for, since it's such a vague term that's open to a lot of interpretation.
Installing it this way takes a while and only supports versions that are in gems repository (mail catcher is not that good at updating it). Here is my script for creating package for latest mailcatcher on github and all dependencies: https://gist.github.com/perk11/f12a875b14ae2a008d420f3bf64f618a It worked on 14.04, commands executed manually. 
I've paid 64euro for a 2 year renew last time. Also, I'm using the EAP (early access programming) this is for free afaik.
Just got done building a massive D7 site using tons of module hooks and theme suggestions. Can confirm.
Apply to more companies and broaden the type of companies you're applying to. Don't just apply to the hot software companies in your area, if that's what you're doing. I was working in the pharmaceutical industry but wanted to switch to PHP development so I basically talked a non-profit into hiring me as their sole developer. I spent three years there building my skill set and that made finding my next development job a lot easier. If recruiters are the bottleneck for you, apply directly. Also check out university hiring sections. Every university needs developers and they usually do their own hiring. 
Perpetual fallback license?
Religious healers get lots of business too. Don't let that validate you. Your customers don't know enough CS to understand you're a fraud.
All this time I though I was alone
If you don't renew your yearly license, to keep PhpStorm up to date with the latest version, you get a perpetual license (ie. you don't need to renew it) for the version you paid for.
When I got started I worked my butt off doing freelance jobs. This gave me a portfolio. Not only that it gave me a list of 10-15 people who I could email to see if they had any odd jobs available. Though one of them I got a nice part time gig which turned full time. I am not certain this is the best way. I worked a lot for not that much money for a good year or two. That said I was young, didn't have many commitments and didn't really mind. The alternative route is to apply for junior positions. The pay is low but so are the expectations. Six months to a year in a junior role allows you to hop into a better paid job. The fact is companies don't want to give a lot of money to an unproven developer. I am not sure this is the place to do it but showing your cv / portfolio and perhaps be a bit more specific about the job you are going for could lead to more constructive feedback.
Hey, I hear what you are saying here. At a previous place I struggled with this myself. I had a manager/developer/director (yes, the same person) who did not want to write tests (didn't want to wait 5 days for tests to run and if it worked in the browser, what could go wrong?), use a framework (ran to slow and they were bloated), best practice and so on... The main part to realise here; they are threatened by you. It may sound daft but at my last place I would put a suggestion forward to help solve a problem and it was dismissed immediately. I was dismissed when ever I spoke of a solution or gave a different approach. I suggested using Slack in the first few months of being there, it was dismissed and then HE suggested that the business use it, made him look good though so doesn't matter, right? ;) I become very tired of arguing everything and became very negative which effected my home life with my wife and daughter, and was generally not a nice person to be around, I struggled with trying to show them the benefits of things, it took me 3 months to convince them that testing was a good idea and that a framework would help us build our product quicker and easier as that was the reason I was hired; to help rewrite the code base in an OO &amp; modular way. You sound passionate with what you are trying to achieve but don't waste your energy. Believe me when I say it will destroy you outlook on your career choice. I have wrote about this a few times and have even done a talk on it. It is hard to deal with. People are shit at being people. Chances are your boss/CTO/founder is inexperienced, in the sense that he left Uni and went straight into a job thinking he knew *everything* and looked good because the people he worked with knew nothing, which made him look good. Then, sometime down the road he decided to go it alone or join forces with someone and wanted to make money. You are not going to change or impress him unless you do as he says. My advice, when it is possible... get out. These are conditions where people are "resources" to getting the job done. There is a revolution in certain companies that will hire engineers, problem solvers, allow people to grow in the business and give back to the business and allow discussions to reinforce methods and practises. You are not alone in this. The PHP community is a great place and helped me a hell of a lot. If you can not get out due to what ever reason, use this place to try and get to conferences, join local user groups, get on Slack teams or IRC channels, Twitter and so on and communicate. Try and use this place to learn how *not* to do stuff. Another note, generally it is easier to ask for forgiveness than it is to ask for permission; however do this with small things at first. I tried it once or twice and worked okay and don't forget, if you don't feel comfortable doing something where you think it could be detrimental to the business you can say no. These places will shift the blame when problems arise as the "managers" don't like to take responsibility or blame. For example, I once worked with my "manager" to implement a piece of business logic and when he review the code his response was "not sure what it is doing, but looks okay". Around 6 months later, he come to me with "Erm, you've put a bug in this code so could you fix it please!". This is all toxic, and this can leak into your personal life and clash with any other possible struggles you have. You can stay and learn as much as you can or you can get out. You can so you don't agree with X, but if that's what they want then just do it - it will all be experience, bad or good. My posts whilst I was struggling: http://futurepixels.co.uk/experience/coming-of-age-as-a-php-developer http://futurepixels.co.uk/experience/being-a-professional-developer http://futurepixels.co.uk/experience/Making-a-career-in-programming-is-hard-enough-to-kill-it I wish you the best of luck! Hope that helps?
Okay so there are use cases for other programs that I fully acknowledge. But if you're not using PhpStorm for your PHP projects you are really making a big mistake.
Sylius is a really great project..even more if you know a little Symfony..as far as Symfony goes I really like how Elcodi looks..also worth looking at..but Sylius will provide you pretty much everything you need..try to join their Slack channel and ask questions there :)
Sorry, was asleep, so late reply. It was my situation of needing a job, and the company being very successful. I figured it would give me an opportunity to learn and move up, which it has. When you have a pool of x companies to submit your CV to, there's at least one you feel you'd enjoy more - be it the type of projects they build, the way they write their job descriptions, what their website portrays about them - just the general vibe you get from learning about the company.
I've not encountered anything that you can do in SublimeText that PHPStorm doesn't do better. That being said in my experience running PHPStorm on a large enough project without a really fast quad core CPU and an SSD is suicide.
Yep, for my age and location, pay is excellent - though it started off mediocre, but 4 years later, it's great.
I used NetBeans, then PHPStorm and now VSCode. vim plugin always enabled ;)
Company I work at is 21 years old, only recently (last year) have they moved to a framework.
I've not encountered any issues - what doesn't make it perfect for you?
I used to be a NetBeans guy too, but swapped to PHPStorm about 2 years ago IIRC. Quick question - how can you develop on a white background :/
usually i assemble the passed data ,then via switch select the action,get the output data , select the template and pass the data to that template which then depending on the passed data via inheritance fills the footer,header etc.kinda this : assemble_getpost($whatever) -&gt; select_data_view($getpost) -&gt; show($output,$template). the $output has the array with the data on which the template engine can go dependend in selection of its children. i don't know if it's that sophisticated but it's easy readable. maybe helpful : ) And like the binary guy here told, if you try to stick to schemes and theoretical models you probably will get nuts. I also prefer to have a lot of main templates instead of inhereting everything, to me it's a torture to go through 5-6 layers of template to find an error.you can have x maintemplates and then go and have one headertemplate template file in which you can sort out the header pro template.the $getpost also only filters the direct action of the controller, everything else is just used directly in the functions of the model or on the db layer , where you can then make the input secure first.else youd have to push all post-get eg. through the whole process and that sucks.
Sexuality != gender.
I must've really hurt your feelings. It's all good. Symfony's the most awesome thing about PHP. 
Still can't beat the PhpStorm meme going on in this thread.
&gt; Laravel &amp; PhpStorm don't go well together, without the use of external tools. It's an IDE plugin and and artisan command. Not really a huge deal. &gt; use facades such as \Log, and whatever more It also generates documentation for your eloquent models so you can do the stuff you say you can't do. http://imgur.com/a/tmpKe &gt; Laravel has the most awful documentation I disagree, the documentation goes over all of how to do things. It also has a detailed and separate [API documentation](https://laravel.com/api/5.3/)
Most people I've met that call them self full-stack, are frontend-devs who think they can do backend to (usually using javascript).
Get a subscription to laracasts. Seriously, it's worth its weight in gold. And with all due respect, I think it'll help you out really well. 
Yet another PHP myth just born. 8 fucking per cent for the app that does absolutely nothing but a function call means that for whatever real life application you won't be able to feel any difference. Yet he calls it a "performance killer". That dude took Christmas for the Fool's day
You wouldn't make as much using vim?
&gt; because the latest release was so bugged on Linux (debian). Had to restart my editor 10 times a day because of an open "editor loses focus" bug, then finally switched. Weird. I'm using netbeans on debian as well, and I haven't restarted it for weeks.
Here, you dropped this \\
More like knowing about SOLID principles. Understanding dependency inversion is the key to creating good abstractions. These skills transfer over to other object oriented languages, I definitely think that knowing how to create good abstractions is way more important then knowing the syntax of the language you're going to be working with. If you were some sort of genius Java developer you could easily land a job as PHP dev.
Woah. Easy there. Are your wife and kids okay? You need help, mate? 
It's not a myth. Whether it matters in real applications is a different topic.
I never said it was built on Sublime, I said it seemed like a fork, that means it's almost identical in terms of functionality and features, just more polished in some areas! Badly worded by me.
Yeah, I've noticed recently how retarded Doctrine is with large datasets. But the remedy is not this sort of nitpicking but a complete rewrite to raw/array/whatever.
We applied many of these fot 3.x components of ZF3 achieving pretty much a 2X speedup on the typical "hello world" synthetic bench. The optimisations were all tiny, but all stack up, a lot. Also, use siege please ;-)
&gt;So, yeah Redundant, superfluous language conveying no useful information, right from the start. &gt;they are not even considering my portfolio No punctuation at end of sentence. &gt;i Does not capitalize proper nouns. &gt;laravel, wordpress Irrelevant technologies; does not respect canonical capitalization of product names, e.g. Laravel, WordPress, despite claiming familiarity with them. &gt;lad ? Space before punctuation. 0/10 would not even consider hiring out of desperation nor sympathy.
He should of used two. 
Solid advice.
This is encouraging.
I've used both, started with Netbeans and switched to Storm in my previous job for 2 months and now back on Netbeans. As far as I can see PHPStorm offered me nothing over Netbeans, literally nothing. When you ask people what Storm can do better than Netbeans no one can give you a valid tangible answer. A lot of people reference keyboard shortcuts but you can also use Netbeans completely with the keyboard. Feature wise there isn't a difference. PHPStorm attracts a zelot like following, I too would be pissed off and defend something to the hilt if I had paid a premium price and find something else is competitive for free so I understand the anger and the bigot nature around Storm.
I saw a while back they went to a subscription model, but the price seemed reasonable and it had the option that if you pay 12mo you get a forever licence for that specific version (which should work for the people who like to buy one version and use it for a number of years).
Netbeans for me, I have yet to see any editor or IDE that has anything to offer over Netbeans and I've tried pretty much all of them over a 10 year span
Not sure if others would agree, but personally I would refrain from saying something like "I love OOP over procedural". As you get more experience you will come to realize that each paradigm has its own pro's and con's, and that different situations may be better suited to different ones. As an analogy, I think it would be like interviewing a construction worker and them saying "I love hammers over screwdrivers".
For a small one the optimization in question won't be of any effect. My point was not about Doctrine being retarded but about real optimization that is not nitpicking with function calls.
Great job!
https://marketplace.visualstudio.com/items?itemName=felixfbecker.php-pack The intellisense is still under development, but it works pretty well.
It doesn't hurt to try does it? The most popular projects are often the cleanest and well-organized code. In most of them, there is no strict inner circle and maintainers are happy to accept PRs as long as the tests pass, adds coverage, and goes with the project philosophy and code style. Everything counts: even fixing some typos in comments. It at least shows you paid attention to the code. 
This is more a DB/SQL question than a PHP.... with that out of the way..... **I'm going to disagree with everyone on this thread**, in 2016 there are over 40 recognised genders in the UK, Facebook has over 70 different recognised genders and I believe some US states have even more than this. If you go down the route of having a single column where a user can input a gender the data will become messy and inconstant very quickly. The best way to go about this is to have a link table with a one-to-many relationship, a user can have one gender and a gender can have many users. The beauty of this is when new genders are formed (and believe me the LGBT come out with new ones all the time) its much easier adding them to a single table and have the user table pick up that possible relationship. 
Me too. However, I set a strict php 5.6 or later requirement and most of the custom code is good OOP. It's easier to replace the Drupal's basic autoloader, and you can get yourself a nice PSR-4 autoloader. Composer didn't work well with 7.x, but I'm sure my modules are easy to port to 8 wjenever we want. 
Collaboration tools nowadays are pretty good, with Slack combined with hooks to VCS, CI, Issue trackers, etc. I'm a freelancer myself, but the work is not really that isolated as one might think. 
Thanks! Remember to ping me on Twitter with the hashtag if you find any good candidates, I'll continue the series into 2017.
Damn, this is exactly the one I'm currently using :x Thank you anways!
Ok I walked into that one. To clear up I'm looking for suggestions on tables and attributes and how they would interact to show the availability. I've hit a mental block
I'm looking for suggestions and recommendations that i can learn about and then implement. I've hit a block and can't think how you would go about processing the information to derive the a availability 
Thanks for the insight. :) Yes I've got a list going of the ones I want to work with most. It's just hard to keep applying to other places when there is a role that you really want and are waiting to hear back 
FWouldn't every other namespaced, interpreted Language have a similar performance penalty? It's not like nothing is happening here, PHP is checking for functions overridden in a namespace, something any language that allows you to make functions on the fly would have to do. Edit: Also -- I'm not 100% sure what they do but wouldn't an OP Cache make this problem a total non sequitur?
&gt; call_user_func('foo'); Oh man...Fully-qualified function calls **AND** single-quotes around strings ?! Aren't you afraid your server goes back in time, with such HUGE optimisations ?
It was an obvious exaggeration, but it would be comparable to a construction company using power tools vs using only manual tools. Regular hand saw or a circular saw, power drill or screwdrivers and hand drills, backhoe or a shovel/spade. Definitely made me more money than I paid for it and I have been using it for over 2 years. 
Me? Definitely not. I suck with Vim. Plus I use Visual Studio with resharper all day at work which is pretty equivalent to PhpStorm, so the familiarity helps out a lot. 
Sorry I should have made myself clearer, apologies. I'm a student so salary isn't needed currently and it's for placements. Also the hard part is filling in the bs of why you want to work for the company etc when I don't really but need a back up. I think I was just ranting :) Thank you for your time :) 
Thank you! That's given me some ideas to look at and hopefully I can ask a more structured question from there :) 
[removed]
[removed]
Thanks
Wait a second. So there's this function which does so little work that its call time is a significant part of its run-time. Yet this function gets called so often that multiplying that by 0.15μs makes a dent in the application's runtime. Hmm... if only there was an obvious solution here. ... GET RID OF THE FUNCTION We have enough dumb optimization myths (ﾉಥ益ಥ）ﾉ ┻━┻
PhpStorm
I am guessing it is specification driven development. The behat tests are the spec, in that sense.
Too late for that, I already have the login, registration and logout code running. I have an interesting marketing plan too... what else you got for me... anything else?
I like how you've continued to dodge every obstacle put in front of you. It sounds like you just have a personal vendetta against Symfony for some reason. How about you answer this one question? If you can't, you're clearly full of shit and just talking out your ass. **Give me the workload of one project that you've rewritten which only got ~8 req/second with Symfony, but instantly jumped to 10's of thousands with your hand-written masterpiece.**
Do you have a local PHP meetup near you? The people at that meetup do what you want to do. They work for companies that hire people like you. They are probably sitting on 3 open jobs right now looking for you. Hit that meetup, network with your fellow developers. It's pretty rare I attend a meetup where open positions aren't announced. Good luck
I know hes right, I'm saying its a completely out of proportion reaction to a comment on the internet, he really needs to chill out a bit. His wording was very aggressive that 'noob's should know these things, well we all didn't know things at one potint, there are noobs in every walk of life. Needs to stop being so butt hurt by things
So? OP asked for IDE/editor. 
When I linked you to the reddiquette the other day, I didn't mean you should start posting junk from other sources too so you could meet the 9:1 ratio. I meant stop spamming overall.
Well, I stopped buying my own license and just reuse the license my work pays for on my home machine. I was a shit flipper. I will not pay them anything myself anymore, even if I do love the product.
Yeah right. But hey, this is reddit [where everyone is aggressive and your point don't matter](https://www.youtube.com/watch?v=yTEhEUoTzqo) :D
Numbers game my friend, I just applied to every and all php positions within my skill set. Thankfully being in NY there are loads of opportunities and new jobs so it only took 4-6 months. Been working at my job for 3 years now and they wan't to relocate me across the country to continue my career!
When I made the change to PhpStorm, NetBeans was having huge memory and lag issues. At the time PS ran like a native application. Perhaps NB is greatly improved since then. The fact that I loathe Oracle keeps me from trying it out again.
In my beginning, my full 6+ years of web development experience was based of self study and ~2 years of starting my own business. In the eyes of recruiters, this was like having no experience at all, no matter how big my experience is compared to people that actually have years of job experience (when I see the code and work of many.. I have to medidate not to puke, rage and do a satanic ceremony to cure my self. So I guess that many "coders" actually have no clue what they are doing). I searched a long time, was lazy as fuck and also was inexperienced in the whole recruiting process at all. I simply couldn't sell my self. I even had to work ~3-6 month in a medical business.. but just as the guy who cleans the devices. Worked with two other women who were my "boss". Luckly I have no problem with a women telling me what to do, but I have big goals in my life and just the knowledge that I am doing such thing that probally everyone could do and earn like no money at all.. this was very demoralizing and for this time of my life I feared very much about my future being. So you see.. everyone has this time of his life where he is a unsolved rubic cube (https://s-media-cache-ak0.pinimg.com/originals/51/9f/44/519f443bf3ee4156f799e4da99f4c57d.jpg) The important thing is to never giving up, no matter what happens! I was still searching and suddenly.. I found some recruiters at Xing (German LinkedIn) who were VERY pleased to meet me and liked my experienced. They actually listened to me and not just looked at the paper (they still needed my CV. They have to show the user profile to their customer). The first one.. damn.. I said a very big number as my salary. We made out a first telephone meeting. They liked me on the phone, so we made another day out for a 1 day test phase. It was very cool and they seemed to like me too! We talked and at the end he asked me about the salary. I told him what I expect and why I expect that and what I was planning and willing to do so I am actually worth the money. He didn't twitched at all and no "bad" facial emotion, just a "Hmm, okey, nice". So at the end of the day, he seemed to be very happy and that they will report back to me. Badly after a few weeks, I got the most emotional in depth "nope" ever. They were very sorry, but after a long time of deciding, speaking and discussing, they had to decline with a broken heart, because there was another one that was a slightly better for their needs. Well, damn. The salary would really kick in ;D So I knew, this Recruiter at Xing thing is a good one. I wrote a few other recruiters and they responded! Nearly everyone was very happy to meet me and tried to find something. I found another job, met them and after doing all the process again, they said "yes" and send me the contract! I just had to sign and send back and I would get the job. At the last day (friday) I got another phone call with a job. Well, on the phone the dude I was talking too (one of the two leads in my current room) was like "well, if you want, you can come and make a test.. it will take 5 hours, but if you don't want.. it's your decision. But it won't be easy." I was VERY curious. I mean I already had a job for next week, but damn.. it's a very known and big Company in Germany and I REALLY wanted to success this test. So I could know where I am standing.. how much worth I actually am. Well, I went there, succeed the test and... they suddenly was like "Well, ... you know,.. if you want, you can sign in now and start next week." I never knew this is a thing.. My experience is that this will take a couple of weeks.. at this time I would be at the other job, but like getting a "yes" instantly?? It was a bit less salary than the other one, but I liked the guys.. I liked the big name of the company, so I said yes. Dude, the hardest time to tell the other company "well, you said yes and I liked to join, but actually I now found another one and I can't come next week..". @TL:DR 1. Never give up! 2. Use Xing/Linked In Recruiters! 3. Try so that they like you! The more they like you, the bigger they will make you on their customers (the company who wants to hire) 4. Go big or go home! Try out a bigger number! Why not? But not an arrogant way. Try to explain why you should earn this money and what you want to do for all that. 5. Speaking! The better you can "manipulate" the other with social skills, the higher the chances are. It's not a coincidence that the most worse guys have the highest job status and salary. 6. Selling your self. Think about: Why should I recruit my self? 7. Google for recruitment tips! Goole how you have better success and things like that. 8. Become self-confident as fuck! The more confidence, the easier the talking and doing Things like that 
A lot of good advice in the post above! I have one bit of contrary advice to it though: unless you have an advanced skill set in front end development, design, database architecture, and web server administration, please don't call yourself a full-stack developer. I've been an engineering manager hiring at various skill levels, and it's irritating to interview someone whose valuation of their own skills is too high. That usually comes with arrogance, but I don't get that impression from you (which is good!) "Full Stack" can be a loaded term, and it's fairly overused. I'm also guessing you're not in the States, which is where I'm located. I don't know if it's the same where you live, but recruiters are garbage in the US. I tell folks to avoid them and try to find direct opportunities on job aggregation sites like Monster and such. If you want, you can PM me your CV and I'll take a look. Not sure I'll be much help, but I'll give you my honest opinion.
I know, I get so annoyed with people who try to tell you where to post questions. ..why can't they just answer the fuckin' questions. You would think the person asking the questions killed their cat or something with the way they try to usher you out of the subreddit and speak to you with such disdain.
Tried these under 3v4l (no XDebug). Currently writing a small inliner (so it becomes trivial to apply the optimization/migration for libraries) and some more meaningful benchmarks (since reddit really loves shooting the messenger :-P )
PhpStorm
&gt; The fact that I loathe Oracle keeps me from trying it out again I have to agree on this point but Storm is written in Java......... so the vicious Oracle circle continues. I also believe Oracle are giving up control of Netbeans over to Apache but its still written in Java never the less. It uses a huge amount of memory in fact it seems almost identical to the memory usage of PHPstorm (which leads me to think large parts of the core might be shared? they seem to work in a very similar way). There is lag when its reading in projects especially when you have a massive dependency list. My biggest issue with Storm that really pissed me off and slowed me down was not being able to have multiple projects open in the same window, when working in a micro-services architecture this is a killer to productivity. I do believe storm can now do this or its at least in a recent Beta version. The other thing that really annoyed me was having the functions navigator in a hidden tab, not so much an issue with newer projects following SOLID principles but most of my work is with really old code bases with 6000+ line classes so being able to quickly visualise the class and jump through it is a huge productivity boost for me. I'm not against paying for software at all but it makes no sense to me to spend money just to with the cult if it offers nothing of note over a free product 
&gt; for whatever real life application you won't be able to feel any difference Yup. See also, [conserving (or optimizing) on the wrong resource.](http://paul-m-jones.com/archives/6429)
I know. Not trying to be a snob. Just saying that the west a lot that php storm does that sublime doesn't. Used sublime for years before switching. Love both but php storm is infinitely more powerful. 
This is actually not a great advice. You should use SELECT COUNT(column), or COUNT(*) (which mysql has special optimizations for) to see if there is a match with your condition. With the first initial way by selecting all columns mysql needs to build internal table with all results, with the second by selecting only one column and limit it by 1, mysql has to do the same, but only with one column (LIMIT is applied __after__ the whole query is executed and the internal perhaps very big table is built). If your table and condition result is very large, this will use much memory in mysql itself. If you use COUNT() it doesn't need to build a internal table for the result set, uses less memory and is faster (as it has special routines/optimizations for queries with only one column that is COUNT()) - and actually, exactly what you want.
Kinda expected him to know that already, bummer :(
Ok I'll be direct. What is it with all the assholes? I've got a problem that I want to solve and just can't quite figure out the logic to solve it. Now on a platform like this I'd have expected a few people to have developed a solution to this very problem and be able to give me guidance or point me to a resource that might help. Also as anyone, including yourself, has taken their time to read my problem and answer, even if that answer isn't helpful, I am grateful that they took the time. soliciting a free solution to your problem All I am looking for is a hint. Look here, try this, try looking at it this way. How is anyone supposed to improve if all you do is complain about them and give no constructive feedback. And just coz the answer might be obvious to you doesn't mean others can't get stuck 
The main reason I made my comment was to dispute the argument you made for using eclipse not so much for switching to PHPStorm. I also know that a lot of features currently in PHPStorm are essentially ported to eclipse. The fact that PHPStorm and other JetBrains products are paid solutions gives the company incentive to always have the best product. In general new features are constantly being added to PHPStorm and it takes weeks/months/years for eclipse to catch up. This is my abstract reason for preferring a paid product over an open source one. As you can tell from my cop out answer so far I haven't used eclipse in a while. One of my colleagues did until he recently switched to PhpStorm. I don't exactly remember the reason. That's why it's hard for me to make a direct comparison of features currently present in PHPStorm that Eclipse is lacking. I'll still attempt to answer the question by listing a few features that I think Eclipse doesn't have that I use in PHPStorm to improve my productivity. * In the latest version 2016.3 attempting to create a class in a namespace that doesn't yet exist will cause the appropriate directories to be created. (This relatively minor feature has traditionally been lacking in all editors I've tried) * You can mark a directory as test root and you can quickly create unit tests in the appropriate namespace (automatically creating directories) * The refactor feature allows you to rename methods project-wide almost flawlessly * Extract interfaces from classes. * Pull members up and down between classes * Extract a method from existing code and automatically define and type hint the parameters needed to extract that method. It can also automatically replace occurrences of the same code with a call to that method. * A very nice tool that allows you to connect to all types of database servers (through SSH if needed). * It recognizes SQL inside PHP files and allows you execute those SQL queries directly and reformat independently. * Some people swear by their git integration and mergetools (I have yet to practice this) * Cool and easy to setup build in way to run UnitTests for the whole project or just the class you're currently working on. * The Symfony and PHPAnnotations plugin is the best thing about PHPStorm although I know those are also available in eclipse I'm quite sure that they are developed for PHPStorm so you always get the latest features first. * Multiline typing (like in sublime text) was not available the last time I used Eclipse. * As far as I know they have written their own PHPLinter that's much better at finding errors in your code and suggesting ways to fix them. For instance autocomplete works much better if you have syntax errors in your code (because you weren't done typing on some other line). Another example they now have autocomplete for variable names that are **not yet** defined. * Composer intergration I might just give Eclipse a try next week and see what features I'm really missing, or if basically everything has already been added. There are so many more things that I take for granted, it's hard to come up with all of them. 
What's the license? If its GPL Compatible then no, if its closed source/GPL Incompatible then yes because its a derivative work off of WordPress.
$num_rows is definitely often useful, just not in this case. And PDO has the similar rowCount (though I think it's database-specific and in the case of mysql probably just a wrapper for num_rows.
Whilst I understand what you are doing, I'd advise against it. If mailcatcher wants to update, they will. If they don't, then they won't. Part of using a third party product is trusting in it. Part of open-source is trust and helping. You could contact them, raise an issue and potentially help them to release with what looks like a nice start to a release process script. Unfortunately it needs to be part of a solution like travis or jenkins and go through pre-flight checks before you just build, package and release which is maybe why it takes them a while. Also they have no revenue so it might take longer for them to find time. Even if you don't contrib to them, please use a more formal process, that way you can avoid risks and you can distribute a VM or a Docker image for others to benefit. Or do none of the above and continue, it really doesn't affect me, but I think it might help.
Edit: I had somehow mixed up `SQL_CALC_FOUND_ROWS` with `num_rows` and am completely wrong. Ignore this major brainfart. ~~Agreed that COUNT is good when just getting a count, but I have found a decent use case for num_rows, paginated views.~~ ~~You get your LIMIT'd data/page from MySQL, and then you get the total results free without a second new COUNT query and roundtrip! So now doing "Displaying 11-20 of 720 items" is easier to do. :)~~ ~~Admittedly it is the only use case I have on hand, but paged views are also pretty common in a lot of things I've worked with (primarily CMS's and administrative interfaces)~~
I bounce between Vim, Sublime, and Coda. And Coda / GoCoEdit on iOS.
&gt; $num_rows is definitely often useful Pray, name just a single case? That's not a sarcasm, I really wish I knew a case where num_rows call is not superfluous/harmful or at least not useless.
I know it sounds a bit SJW, but you fail to account for people who don't consider themselves male or female.
Licenses and copyrights are two different things. The license defines the way you are allowed to use or work the software. The copyright defines ownership of the work. "Derivative Works" is a legal term that means that the new creation is still owned and copyrighted by the original copyright holder. To make a non software analogy, if I write a song and you arrange it for your barbershop quartet, I own the arrangement. The license tells you what you are allowed to do with the work. If it's licensed under the WFTPL, then you are obligated to follow the rules of the license. Likewise with GPL, MIT, or Apache. Read it and ask an attorney if you have questions or "what ifs." IANAL. 
In most cases, I think any of these will be pretty darn fast, especially if it's a table. A complex view might be such that one of these would be faster than others, sometimes `count()` will be slower than `limit 1`, so if you just want to know if there is at least 1 row returned by a view, it **might** be faster. This option with `EXISTS(SELECT 1....)` will be probably the fastest, though. If your query is slower than you think it should be, indexes might be a good way to try to gain some speed. In your initial example, I would definitely consider not selecting "*", but a single field (an id?) or constant (like `1`). If you happen to have a large text field or something in that table, mysql will return all that data back to your application only for it to be discarded.
That's just a nasty rumor. Everything you said is applied to any query, without any preference to `count(*)`. If you have your DB optimized, you have `count(*)` optimized as well. select count(*) from t where is=1 is perfectly optimized even for a scaring innodb Yes, there is a hack for MyIsam tabes to get the number of rows in a table. But unfortunately, people take your statement as "count(*) is not optimized" which is simply not true. In essence, this statement is just doesn't worth to be mentioned.
It has to be open sourced
&gt; You are not required to distribute them at all, however. This is important to note for developers that do plugins. What it practically means is that if you're writing a plugin/theme/etc for your work that isn't distributed to others (used only internally) you do not have to publicly release the source code. If however your company (or the company you're doing the work for) decides to distribute WordPress with your plugin to someone else they must also make the source code available.
thank you
Does Clippy lint your code?
No, but it can make a sad face to make up for it :)
This is silly. If you are just coding to an abstract API you are not violating a license. Nobody owns APIs (unless Oracle has their way.) However, you are not allowed to ship your plugin with WordPress as the combined work would be a derivative work and you are not allowed to encourage other people to break the law and combine your plugin with WordPress to make an improperly licensed derivative work. So, in practise this doesn't make that much difference unless someone makes a clean-room differently licensed reimplementation of WordPress.
read the license it came with, respect the license. Its easy. 
I am part of the PHP community, and I *encourage* you to reinvent the wheel often and with gusto. Why? Because *everything* is for "learning purposes". You will come out the other side knowing more than you did before. You will better understand what hard choices the other wheel makers faced and often empathize with the decisions that they made, even though you may have previously thought they were "dumb" or "counter-intuitive". Why else? Because if nobody ever "reinvents" the wheel then efficiency, safety, and resilience may stagnate. But... Before you choose to reinvent a particular wheel, there are some things you should keep in mind. 1. Your timeline and budget. Designing a robust and fully functioning wheel takes time and often a lot of it. We all know "time is money", so consider whose money you are spending; if it isn't yours, are you being a responsible professional or are you needlessly spending somebody else's money? 2. Understand the road. Make sure you truly understand the curves, potholes, and blind corners that you will have to face. 3. Examine the other Wheels. Take some time to see how others addressed the challenges of your road. It doesn't matter if you agree or disagree with their decisions; you'll probably change many of those opinions once you dive into it. 4. Keep your fix-a-flat nearby. If you hit an unexpected nail, there may not be anybody else around who can help you patch that hole. 5. Be ready to accept the fate of your wheel. Other brands may have deep foothold in the market. Your wheel may be better but it may not be "better enough" for others to incur the cost (measured in time and familiarity) or risk of implementing it. 6. Resistance is [maybe] Futile. Realize that your design may reach a point where it is better for you to take the best aspects of your wheel and contribute them to a widely adopted library.
Is it odd that single quotes are preferred? I don't mean for "performance", but just as a convention. I always use single quotes.
Using ``COUNT(*)`` is optimal under all major databases / engines (which includes InnoDB for MySQL). The link in your comment refers to the fact that the total row count is stored (i.e. "cached") separately on MyISAM, so it's like looking up a single number, which is virtually free performance-wise. This does **not** mean that alternate ways of counting rows is somehow faster, i.e. ``COUNT(foo)`` won't be faster on InnoDB, it'll actually be slower as you risk the engine deciding to check if there are rows where ``foo`` is null, which wouldn't count. 
You just stole sht from John Morris and post it as your own.Funny thing the original video is linked on the right.
What about "SELECT 1 FROM table WHERE stuff LIMIT 1"?
 &lt;?php echo "hello, world"; ?&gt;
Check out Eli The Computer Guy's PHP Class on YouTube. That's how I got into PHP. https://www.youtube.com/watch?v=27dR_sLaM74 
Check out the free courses on https://shippingdocker.com, should get you up and running pretty quickly for development in a way that teaches you how to build/use images with different versions of PHP and MySQL. * https://shippingdocker.com/docker-in-development/ * https://shippingdocker.com/dockerized-app/
Sorry, what I meant is that due to the (in this case constant) overhead of XDebug, the relative difference between using an unqualified and fully-qualified function call becomes smaller. PHP optimizes this by caching the resolved function on first call. Of course this is not entirely correct, because the namespaced variant may only be defined after the first call. Once this inline cache has been initialized there is little difference between an unqualified and a fully-qualified call at the function call initialization stage. However, for calls where the callee can be resolved at compile-time we also early-bind the argument send instructions (to avoid checking for by-reference arguments at runtime) and additionally specialize the function dispatch to internal and userland functions. (And of course, lower certain functions to VM instructions.) As such, the case tested in the article is the case where there is the smallest difference between using an unqualified and a fully-qualified name. More complicated calls involving arguments, and especially involving variable-like arguments, which require use of a callee-dependent fetch mode, benefit more.
Thanks, very interesting! I wonder, is the mechanism of fallback for functions, seen as an unfortunately decision internally for PHP core devs? I remember I felt it's a very unfortunate choice, as it'd prevent a robust function autoloading happening in the future, and complication of implementing the fallback (even if it's optimized, the optimization itself is extra complexity). What are the odds that the semantics of fallback *could* change in a future major release of PHP to remove this unnecessary complexity?
It's useful any time you need to know the row count up front but still want all the data. For example if you have a lot of rows you want to process, and don't want to load the entire set into memory. 
Exists is a very good way of doing this, and any WHERE condition where you just need to proceed with one match. The SQL backend knows to bail as soon as anything is found. In most cases this will just be able to check if an index has some information and that's it.
Laracasts has a whole section on just PHP. https://laracasts.com/skills/php
Yeah single quotes are easier to type and look slightly cleaner. 
Depends on your keyboard layout, but that's certainly true for the US and UK layouts.
Laracasts has heaps of resources for just PHP. It's not _just_ Laravel
I also used Larry's PHP and MySQL books. They gave me a very good starting point for all of the basics I needed to get started. +1
Yes, we definitely think it was a very unfortunate decision. It's not just the performance impact, but, as you already mentioned yourself, it makes things like adding function autoloading a lot more complicated than they should be. However, I personally doubt this is ever going to change. It's certainly not the most commonly used feature (for the simple reason that namespaced functions in user code are rather uncommon in PHP), but changing this is still going to break lots of code (if nothing else, people abuse this feature to hijack core functions for tests). There would have to be more motivation for this than function autoloading and some complexity reduction. If we ever resolve this issue, it's probably going to be by working around it somehow. The article proposes a declare option (and in combination with namespace-scoped declares this might be feasible). Maybe a move to a "proper" module system would resolve this. Something like HHVMs RepoAuthoritative mode would at least mitigate the performance impact. Etc.
I have a shameless keyword spam section on my resume just for this. Not for resumes I'll hand to people, but for any I submit online.
Thanks for the feedback!
&gt; but i have no professional work experience. That's fine... start contributing to open-source :)
This is not true. Only users of your software are entitled to the rights of the GPL. The user in this case is the client. You have to provide the source to youe client, and your client is thereafter free to modify, copy and distribute it according to their rights under the GPL. If they choose to distribute the software, which you can't prevent, then your client have obligations towards those users' rights, not you. The misunderstanding here is that you must provide the source to anyone who shows up at your doorstep. That is not the case. First they have to be a user of the software, and as long as you distribute the source code together with the software you don't need to provide anything on demand later. What millions (probably more like thousands but okay) of developers do today is to infringe on the GPL by stipulating that the software cannot be redistributed. Such clauses are a breach of the GPL and the devs who try this might ens up under scrutiny for copyright infringement. Another common tactic is trying to obfuscate or minify the code, and/or the system requires some non-standard build software. Futile according to GPL because the user have the right to the human-readable version of the source code and all build scripts. 
The GPL clearly says that any contract clause that inhibits the user's protected rights are void. You can try to add in a technical license check/DRM but remember that the user have the right to the human-readable version of the source code and all build scripts, so they can easily drop the DRM if they know how.
Maybe this is better ;) hello, world
I finished up a more detailed benchmark (feel free to add your results too) at https://github.com/Roave/FunctionFQNReplacer Tool also replaces FQN references, but there was already https://github.com/nilportugues/php-backslasher for that. Oh well, was a fun evening :-)
👌
&gt; I am part of the PHP community, and I encourage you to reinvent the wheel often and with gusto. You are one of the few and VERY VERY VERY VERY VERY VERY VERY far between people who say this hahaha. I congratulate you :D 
I might - thank you :)
Not totally true. Drupal is keen to protect the license, culture and ecosystem. You can't upload a project to Drupal.org unless it's under GPL. And if there was an egregious infringer, then the Drupal Association would probably take action to protect Drupal. 
What about AGPL? I'm becoming increasingly a fan of agpl as it's very transparent and the whole thing about "what if people see our code" shouldn't be an issue in 2016 because * we should be using libraries we can update * we shouldn't be hardcoding things * lay people probably won't bother to look * competition and malicious actors via terms of agpl will have to release code back to you and their users &amp; visitors.
So, let me get this right: 1. I notice a problem, and offer an improvement. (And the initial offering is in fact an improvement.) 2. Someone else points out that there is an *even better* improvement, and I incorporate it into the post. 3. Others point out that there are improvements even upon that. And this is bad ... how?
&gt; These loan agreements are dynamically generated to PDF's and always contain information that's tied to that specific loan. Maybe this is a question for a lawyer, but what would deem a signature like this legal? IANYL but for us (we take digital signatures) we have created systems for experts to offer testimony via web-app in the past and use e-signatures internally. Log as many details of the request as possible, capture the commands to the signature box rather than the signature itself, force SSL and store timestamp on each point / action to the canvas box (we felt this matched the research on identifying IRL signatures as well as adding to the security which we decided was meritorious. We've never got any legal challenges nor conclusive advice on the subject that wasn't in some way hand-wavy). JS canvas is one way, ours was made in 2012 &amp; 2013 so we also had a flash fallback. It's super expensive and a risk to take image uploads to your app, by just storing the actions we found for us it reduced bandwidth and allowed us to offline process the generation &amp; download. We did save the output on the server and disabled updating (CRD only). If you need edits I'd advise storing on S3 as it supports revisions, so gives a nearly free lunch history if you use it correctly. Again, just my business experience; don't run with it, there is no warranty or liability implied or otherwise etc etc...
Yes.
You should not discourage people blogging about what they learned. I don't believe anyone is expert in everything. People blog about things either for themselves or to help others learn what they learned. There may be numerous tutorials and outdated posts. But the opinion of the author would have changed in the month / years. It is the responsibility of the person who read the post to look into the date and verify the integrity of the posts.
You better remove that (which mysql has special optimizations for) part. the case is too odd that the statement is rather misleading. 
[removed]
[removed]
There was a time when people wrote articles about optimizing their code by using single-quotes instead of double-quotes. Just as OP's article, this was true. But the difference was so thin that it didn't make much sense for the people used to using double-quotes to get out of their way. tl;dr : Advocating for micro-optimisation is fucking stupid. It was, it is, and it will always be.
Thank you! Very informative. I always asked myself what is the point of AGPL if GPL enforces copyleft on web apps. So the trick here is the legal grey area. I think there is no case where a modified GPL web app was clearly ruled as an infringement. The AGPL makes things clear. The GPL is fuzzy for the web and as the page says, "we feel strongly that plugins and themes are derivative work". Basically "feel strongly" is not legal binding but AGPL is.
My first programming job was for a tiny agency who did basic stuff for small businesses. It was badly paid and stressful but I (mostly) enjoyed it and learnt so much stuff there (a lot of which I had to unlearn). And having a CV that said "I made this, and this and this" got my foot in the door. Anyway, I got that role because they apparently were happy to employ anyone who could demonstrate they could put together a website.
&gt; Gender is just a property Gender is just a social construct.
Because you don't want disgusting men getting mixed in with all the pretty girls, especially on a dating site. That's just common sense.
&gt; I already have the login, registration and logout code running. Wow you're almost there.
They don't belong on a dating site, nay, this planet.
What about if you have your own independent classes? Those don't rely on WP so you could make that part of the plugin a different license, and only make the WP API parts GPL.
Thing about reinventing the wheel - people have continuously reinvented the wheel literally - wheels aren't logs sliced up any more, they've got tyres and spokes and stuff. So yes, if it's better, do it.
Don't be a dick. Paul has a goldmine of advice on his blog and has probably achieved a lot more than you or I within PHP. He posted an article, where the premise was correct, just slightly wrong on the details. He accepted the correction with good grace (rather than deleting article and submission) and even updated the post acknowledging the correct and crediting the user who gave it. This is behavior we need to see more of, not your negativity. 
Some random developers told you that there is a legal requirement and you don't think you should ask a lawyer if they're right? Considering Google won a court battle to copy the API another copyrighted application kinda shows just using their method signatures is not enough to claim copyright or derivative work. But seriously when it comes to legal stuff, hire a lawyer.
Because...because it's easy to deploy apps to remote server?
No you can't because the GPL says such a clause is void.
My only issue with docker is that it doesn't seem approachable comparable to vagrant/vb. I install vagrant/vb, grab my favorite box (trusty ubuntu 14.04 64), vagrant up -&gt; vagrant ssh -&gt; spend 5 minutes installing nginx/php7 and mysql from terminal and I'm done. Just by reading this article and most articles that try to convince me to try docker there's just a lot of editing and trying to understand all the docker specific syntax on top of shell code that I try to avoid in the first place. Maybe I'm just afraid of change, or too lazy to really sit down and deal w/ docker. Then again there will probably be tools that come along and automate all that stuff for me where I won't need to care about the underlying docker syntax at all.
Do you have any examples of 'something special' ? It's true that its a game of interviews! How many interviews do you think you had to go through before getting an offer?
The HttpFoundation Component comes with different session handlers: * https://github.com/symfony/http-foundation * https://symfony.com/doc/current/components/http_foundation/sessions.html Example: use Symfony\Component\HttpFoundation\Session\Session; use Symfony\Component\HttpFoundation\Session\Storage\Handler\NativeFileSessionHandler; use Symfony\Component\HttpFoundation\Session\Storage\NativeSessionStorage; $sessionConfig = []; $storage = new NativeSessionStorage($sessionConfig, new NativeFileSessionHandler()); $session = new Session($storage); $session-&gt;start(); // set and get session attributes $session-&gt;set('name', 'Bob'); $session-&gt;get('name');
As someone who has started migrating away from PHP and toward Node.js, even the path you consider "easy" sounds like a hassle compared to how easy the Javascript community has made it to spin up a server. This is not a slight at you, it's just crazy how slowly the PHP ecosystem has evolved compared to Javascript. Initial setup has seemed like a thorn in any new PHP developer's side for as long as I've been studying it (4-5 years).
I am actually not entirely sure of what you mean by PHP built in server, and at this point I have never actually deployed a Node app to production. Sounds like you may have more experience with servers than me, to be honest. Wanna point me toward more info regarding the built in server stuff?
LGPL works can be distributed as GPL within a GPL work.
http://php.net/manual/en/features.commandline.webserver.php
I'm very happy to be educated here. I would often retrieve a recordset, and then loop through it with `while ($a = $rs-&gt;fetch_assoc())`. When doing so the easiest way to get the row count (especially if you want it before running the loop) is to use `num_rows`. Should I have always been `fetchAll()`ing instead, and then using `count()` and looping through an array rather than a recordset? If so, why?
thanks
I genuinely don't understand the benefit to using docker. All of our code runs in EC2 instances that are simple to setup. Locally, code runs in a VM using vagrant. I understand if you have a crusty old baremetal server with god knows what installed on it, then you could get a sane environment on that server. But EC2 instances and VMs are simple to create and destroy. Why add the docker layer?
Yep, almost there. So, what are you building right now?
...that's sort of the plan ....at least in the beginning.
&gt; sounds like a hassle compared to how easy the Javascript community has made it to spin up a server *apt-get install nginx php7.0-fpm* *Enter &gt; y &gt; Enter* Done. Working. What could be easier than that?
Is it complicated to deploy php apps without docker?
PHP filters are for validating and/or sanitizing data. Sanitize does not refer to sanitizing for MySQL database. Say you want to validate user input and make sure a user entered a valid email (a topic that deserves it's own debate), you can use a PHP filter to check if the user input is a valid email address. To sanitize data to use with a MySQL, use PDO and prepared statements.
If you're talking of a web page, you definitely have to use fetchAll, simply because database interactions should be separated from the presentation logic. If you're talking of any other case, I need to know why do you need the number of rows in he first place
Here's how you protect against all kinds of injections: Every time your data passes into a new context (SQL, HTML, Javascript, XML, JSON, shell command ...) you apply the appropriate escaping method. But wait, there's an even easier way! Hide the escaping method behind a parameterized interface, so you pass your data in raw form. Every database call should be similar to this: DB::query('INSERT blahablaha VALUES(?, ?)', [$email, $name]); You implement the query function once and then you never have to bother about SQL injections ever again. You might have learned that SQL queries should be built like this: $email_escaped = mysqli_real_escape_string($email); $name_escaped = mysqli_real_escape_string($name); mysqli_query("INSERT blahablaha VALUES('$email_escaped', '$name_escaped')"); Experienced developers doesn't do this. It's an antipattern. You *will* forget to escape a variable somewhere. And you will have to constantly keep track of what context you have escaped for (SQL escaping is not safe to insert into an XML document). So always use prepared statements, and always aim for building functions that hide the escaping for you so you don't have to bother. The filter functions does not have anything to do with security. They try to see that your data is validly formed. So that a valid e-mail address can be sent an e-mail. This is to make sure you can use the users' input later. If their input is not valid you show them an error message and ask them to input in a valid format. All this *before* you even think about databases or SQL. You still need to escape the data (or use prepared statements!). But I usually find PHP's builtin filters unsatisfactory so I use my own regular expressions instead. The filters are more for convenience than for security.
&gt; are good for what? For validating and sanitizing. Your CO here :D &gt; protection against sql injection most likely Try filtering with different flags, there are 7 of them for the sanitize_string alone. And don't forget to use prepared statements - 'cause it takes several steps to prevent sql injection.
Microservices within microservices.
Congratulations, you benchmarked PHP's ability to [cache namespace resolution](https://bugs.php.net/bug.php?id=64346).
&gt; bad ... how? Because your blog post *still* doesn't contain the [best solution](https://www.reddit.com/r/PHP/comments/5jr62p/efficient_use_of_mysqli_resultnum_rows/dbidkq5/), so you're spreading misinformation. Someone might read your post, think they've found the optimal solution, and stop looking.
But you're completely missing the point of docker. Just provision a VM with Ansible or Salt.
Nope. There are plenty of other options that are just as easy.
So the huge advantage with Docker is the separation of the containers. It becomes easy to run multiple applications on the same server, even if they're running different versions of PHP and different or even mutually exclusive dependencies. Everything is segregated and let's you run any combination of anything, which in production is incredibly useful as you can neatly stack as much as possible onto each host and only run what you need right now with much less overhead than starting a new VM and then provisioning it. It can really help speed up/cleanup local development work too, if done right and you're clever with the layers in your Dockerfile. Outside of microservices I personally think the best application of Docker for me is as a Jenkins build environment. I have Java, Go etc Build Containers that have the complete set of tools to compile what I need, meaning my Jenkins jobs can use different Java versions or different PHP versions simply by using a different tag. It also means that my team no longer need to run those two or three different Jenkins agents with different PHP, Java or Maven versions etc.
The GPL is designed so that schemes to work around the GPL do not work. Pretty much all the ideas that you can imagine have been tried and failed. Those holes that have been found have been plugged in GPL v3. It's worth reading the GPL FAQ. In the privacy of your own house or business, you can put GPL software together with any other software. The issue of licence only arises when you distribute... You can distribute a library under a non-free licence. If you distribute that independently or any GPL software, and people can use it together with some free software by installing it themselves, then there isn't an issue. You will face political pressure from the community. If you also distribute a GPL or LGPL piece of software, which works without your library, but also works with it, then you would probably be ok as far as the GPL is concerned, with regards to whether your non-GPL library was dependent upon the GPL code in terms of the functionality. But you still need to deal with licensing... You can distribute GPL software with non-GPL which has a compatible licence, if they work together to make a larger work. A compatible licence is one which doesn't infringe any of the terms of the GPL because those terms apply to the larger work. Or you can distribute GPLed software with non GPLed, if you include an exception clause, to the larger work - which you are allowed to do under the GPL. This is the probable route you'd take with your external library. But that doesn't mean you are out of the woods. There is still a chance that you'd have a problem, if one of the authors of the GPL work that you are working with, has an issue with your code... If they believe that your code is not an independent work, then they are able to argue that you are breaking the terms under which they licence their work to you. Upon breaking the GPL, your licence is withdrawn. Distribution of an infringing item is subject to copyright law, which in many jurisdictions is a fearsome thing. If they have the money, they may choose to take you to court for infringement. In both WP-land, and Drupal-land, there are people who value the GPL. With regards to Drupal and WP, there is a further problem - non GPL code is not welcome, and it won't be available through the drupal.org and wordpress.org websites because they will not accept non-GPL work. TL; DR: it's not worth the pain to try to work around the GPL, but you can combine works if it's clearly genuine.
One of our servers at work hosts 6-7 sites in Docker. Except they're all hosted in the same container. Just...why...
I know I'm gonna get destroyed here, but I'm gonna suggest alternatives you can learn now or after you learn PHP. Learn PHP or these suggestions: 1. Elixir 2. Python (useful as hell) 3. Node (trendy I know blah blah but useful too even in combination with PHP) 
Atom has improved so much, its not as slow now. Give it a shot.
Uhuh
&gt; This is why I don't like frameworks. I really don't have time or desire to learn all this shit, so tag you're it. There's no one in our organization that knows this except you. That's gunna be the case for any code you didn't write yourself. What makes this dickhead think he's going to automatically know code you've written yourself from scratch? The only difference is that frameworks are more documented &amp; tested. But he just sounds like a cunt of that's how he worded his message. Even back in the days where I discouraged use of stuff I didn't understand, I wasn't a prick about it. There's gunna be no convincing him.
we would ask this silly question in /r/phphelp
Get PHP7.
Used Zend Studio before switching to PhpStorm a few years. Best IDE I've ever used 
Yes - they don't expect you to know everything, they're just finding the boundaries of what you do know
This is the best advice because nerds in general, but especially young nerds, earnestly believe their worth is predicated on their knowledge. The sooner this myth is dispelled the better of they will be.
We were interviewing for a mid level front end position and none of the candidates (three) who were asked what the HTTP Response code for permanently moved, or server error could answer correctly. Hell they didn't even know what an HTTP response code was. So I'm just gonna say review the basics. You'd be surprised how many people don't have a solid understanding of the fundamentals. Difference between types, what's the difference between a for, foreach, while and switch? These are PHP 101 and I would assume you'd get checked on them 
Recently interviewed for a junior. Top of the list was somebody passionate who wanted to learn. As a junior you're not expected to know everything, but you should have at least learnt the basics, otherwise they're not going to believe you really want it. Be honest and don't try to guess what something means if you don't know the answer. Good luck. 
Well don't just say I don't know, follow up with questions on getting the problems solved. Hints on algorithm, data structure... Etc.
Fizzbuzz. Know it. Love it. Hate it.
So, uh, I guess no one thinks this sucks at least? Word.
Http response code for permanently moved seems a little obscure. I guessed 303 which was close but wrong. Not really something I use particularly often. I find the best questions involve actual code. Could you show me the programming errors in this code sample? How could you write this more concisely? I have a short spec to build simple thing. Could you design a class structure to do this? Questions like this I find help weed out the people who actually know their stuff from people who seem to cram answers to technical questions in night before the interview
Dev for 11 years. Can confirm. 
Your advice would be take in considered.
&gt; most people wouldn't be able to tell you off the top of their heads the code for permanently moved Depends on the projects one's been working on. I had a lot of SEO-related issues in one of my projects, so even if you wake me up at 3 AM I'll tell you that "permanently moved" is HTTP 301. Any research on "how to REST the right way" also makes you remember a lot of HTTP-related things, including response statuses. But of course, you can also google it anytime you need. &gt; Expecting people to know it by heart is at least strange, when talking about mid-level frontend devs :)
I also used to do a lot of SEO stuff, and as soon as I read it, I knew it was 301. ha ha
&gt; I would bet most people wouldn't be able to tell you off the top of their heads the code for permanently moved. Most people who aren't web developers, correct. I would expect any mid level or higher web developer to know 200, 400, 403, 404, 301, 302, 500, 502, 503 at a bare minimum. I would assume most PHP devs write APIs that require giving correct responses and handling them appropriately.
I was like, "This fucking guy... oh... ok."
Do people still use this?
Can totally concur with this answer. If you don't fit in you probably won't get hired even if you're an amazing developer unless they are in dire need or something.
Ah! The Reddit app on iOS doesn't render the markdown well
Yeah be willing to say you don't know. And if they explain, try to relate it to something else. Making connections will show you are actively taking in the answer and show some abstract thinking. 
I expect web developers to know the common HTTP response codes. There's like 8 common ones, and they're easy. I don't care if an Android dev doesn't know them, but I expect my web developers to have experience in developing for the web. It's ok if you mix up 301 vs 302 off the cuff, but not knowing that HTTP response codes exist, or not knowing the general layout and being able to talk about them intelligently is a red flag.
Agreed. Don't care if an Android dev knows them, but a web developer should know the basic HTTP response codes! If they don't it makes you question what they've been doing to deal with those situations.
It's definitely not obscure. 301 is what you're supposed to do if you move a page permanently (like from /about-us to /about), which I think every web developer has done at some point. 
I would expect my mobile developers to at least know 2xx is good, 4xx is bad and likely the apps fault, and 5xx is bad but is the server's fault. But further than that, I agree with you.
I was fizzbuzzed for months ago
&gt; I was fizzbuzzed for months ... That's a long time to be fizzbuzzed.
Yes, and show that you are taking steps to learn as well. I hate when I interview a jr Dev who says they "don't know but can learn" yet they don't have a single project I can look at that shows they are pushing themselves on their own (outside of work/bootcamps/traditional edu).
&gt; algorithm, data structure CS student confirmed.
What would you suggest for a boss who refuses to learn the basics of OOP in php? I tried the mental exercise of: &gt; If you were asked to write a program but were not allowed to use any **one** of the following: &gt;* variables * functions * arrays * loops * include/require &gt; You'd tell that person to fuck off with their stupid limitations because you know those features are *vital* to productivity and writing easily understandable code and losing any 1 of those tools would be a nightmare. OOP is the next level of tools built on top of the tools you already know and love.
https://jpauli.github.io/2015/03/05/opcache.html
Don't show up hungover
I started today a tool to simplify the visualization of etsy/phan reports. It's available here: https://github.com/fabianofa/phan-viewer Phan is a static analyser that helped me a lot to upgrade an application from PHP 5.3 to 7.0, but the reports as text were hard to read since there were so many issues detected. Then, I decided to create a simple report viewer of reports with json extension. Any feedback is more than welcome!
It's not a grey area. The GPL does not enforce copyleft on the output. What a user sees is output. Distribution is the act of giving someone else the program, so that they can run it. When you use a web app, you have not received the binary, or the source, so distribution has not taken place. 
That's when you chuck the unit tests out the window. Even tests that have been designed to be as loosely coupled to the implementation still have some inevitable level of coupling, so will likely need to be changed during a refactor *anyway*.
About a third of what I look for is gauging whether or not the person displays an aptitude for leaning. If they aren't teachable, they aren't worth our time.
Yeah. I recently upgraded an application at work that was initially completed in 2001 and has had a multitude of different conventions, styles, and methodologies applied to it throughout the years, during many additions and several larger feature-specific refactorings. We were running 5.4, I upgraded us directly to 7. Areas that HAD unit tests at all were better than the ones that didn't, because then I could at least garner what the general goal of the code was. Undocumented functions, lack of editor type hinting, you name it, I dealt with it. Entire upgrade took me a solid month, maybe a bit more. It was really enlightening though, because it showed me the world before we as a culture had developed good conventions, conducive to major refactoring or ease of acquiring domain knowledge in a new app
One of the biggest problems, and to be honest I was one of the ones who voted; is that until like three days before the vote closed, I didn't know many of the people up for a vote. I had to poke around their twitters and for some people try and figure out their Github accounts to see what they are up too. It would have been better to have the candidates do a profile for themselves prior to votes opening. The other problem, is that the fig is run by those who show up. While I personally believe it's time for Cullum to step down, it doesn't affect that those who were nominated were done because they were ones willing to be involved. People like Taylor Orwell, Marco Pivetta and others who would have been great have previously stepped down so what's the point of nominating them? Edit: Just to make sure no one thinks I wanna remove Cullum cause of anything malicious. Its not that. He is essentially the Fig's Tim Cook. He stepped up and steadied the ship. But we've seen the Fig lose valuable input/votes from big projects such as Guzzle, Laravel and Doctrine for example. Similar to Cook and the botching of the Mac line. Its time to allow another visionary and push the Fig to something more. 
[removed]
That's precisely what a router is. It's a controller, which creates a more specific controller. There's no limit to how many levels that goes, so feel free to architect this the way your gut tells you.
[removed]
Have you used the official documentation? I was reading it the other day and was making good progress. The docs also recommend a site with video tutorials. http://knpuniversity.com/screencast/symfony/first-page
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Authorization is business logic. Why are controllers changing based on a user role? 
The fact that the leaders of the two most popular PHP frameworks Symfony and Laravel weren't even nominated suggests you're correct.
Sure. The way the OP is written makes it seem like they are creating controller objects based on an auth check, not through a routing lib. If that's the case I'd be curious to understand why. 
I'm not sure what you mean by "create." Like instantiate as an object? My work project has three role levels of access: member admin super_admin We have a folder under the Controller folder which is /admin. In our routing.yml we have that setup with the prefix /admin, routed to AppBundle/Controller/Admin. In security.yml we have this set so that only admin and above (super_admin) has access. Within the AppBundle/Controller/Admin folder each controller has security authorization checker to see who can do specific things --admins can create and edit, but only super_admin can delete, etc. Are you using a framework? We're using Symfony and a lot of this stuff is already baked in. 
Ask questions. Maybe ask about tooling, automation, or other processes that are commonly used in the company. Show an interest in how they do things and that you look forward to fitting in and learning. Also make a 418 joke. Back end guys love 418 jokes.
I disagree with that. People blogging about what they just learned is usually not the best solution, nor does that automatically mean it's a good solution. Example: Someone still uses the mysql-extension, finds out that it's not available anymore in PHP 7 and then writes a blog post that he recommends the usage of mysqli. He then posts code examples for using the extensions, both including SQL injections. Why is that? Because he's still a learner, he solved one important problem for him (mysql extension not available anymore in PHP 7), but he's still spreading bad information (SQL injections). And really, how often have we seen something like that already? Sure, Paul is definitely not a beginner at all. But still he's blogging about a topic he himself knows he's not an expert at. There are already tons of good websites, e-books, etc. out there. Why not just recommend the stuff from experts and instead write your own blog post then? I really don't get the point, why everyone always have to write an article about everything.
Yeah, all of those controllers render different view.
Businesses do centre around the concept of delivering value, but often people miss the fact that reducing technical debt can tie in with reducing delivering value. Explain the value of making writing tests are code is delivered, there is a ton of research that support this. After you have tests, start to refactor mercilessly as you encounter a problem to ensure the solution you provide is the simplest one possible. If your company isn't allowing you to standardise having tested software, it may be time to have that heart-to-heart with your manager and explain you aren't getting the support to help you deliver value and you need your boss to remove these barriers.
Somehow you have to make sure you cover all scenarios in the old tests. If you just chuck them out, aren't you putting your refactoring at risk? I maintain an application with badly designed tests, but even though changes are painful in the tests, they provide me with security that all previously found edge cases do not break. I'd be very afraid to just throw them out.
https://www.udemy.com/introduction-to-web-development-with-symfony2/ https://www.udemy.com/symfony-development/ 
A helpful post about migration towards Symfony: https://stovepipe.systems/post/migrating-your-project-to-symfony
What kind of work do you do then? HTTP response codes are pretty crucial to the kind of work I do that is mostly backend API related. Didn't take me long to memorize all the important ones.
&gt; You got too much logic in controller. Why not build the logic in some classes? Like... some controllers?
Select a problem and then try to solve it with PHP. Something not to complicated like sorting a list of items and then generating a table from that.
No words necessary. I bookmarked :)
Feel free to skip the post if you don't like :-) . We don't have control over someone. If you feel you are expert write a counter post mentioning how to solve the same. Thank you.
The app should have checked for bad input. Either way, I probably should have said "app side" not "app fault".
4xx means it's the user's fault. They should not send the same request again without modifications. 5xx means there was an error on the server and it's the server's fault. source: http://restcookbook.com/HTTP%20Methods/400-vs-500/ 
&gt; How can a controller handle another controller as its view? Basically it's a controller that also implements the view interface, say, method render($model). It doesn't directly produce any view, it delegates this to its views (and so imagine this as a tree, where only the "leafs" at the end are true dedicated views, not controller/views). &gt; It can forward the request to another controller and that controller than renders the view..or how did you mean it? This would be just delegation, which is what OP needs in this case. The "request" in classic MVC is the event, which originated from a view down the chain. I.e. mouse moved, clicked, or in our case, form submitted, AJAX call sent etc. So when you pass along an event/request to an object, expecting it to handle it, you're treating it as a controller. But if you pass a model to it, then you're treating it as a view. Both approaches achieve a different effect. An example of a HMVC that works this way is ReactJS. People tend to think about it as the "view" only, but because you can define your own components, which are also views, you're essentially passing a model (state/properties) to a React view which is entirely abstract and domain specific, and as the model travels down the chain, it becomes increasingly more presentation specific, and less domain specific. Likewise the events up the HMVC start very presentation specific (i.e. "mouse clicked") and becomes more domain specific at the end ("launch nukes"). HMVC is typically more useful in interactive applications, less so in server-side apps, where we're used to just think about flat controllers and then "templates", but with the right type of project...
Controllers have a specific role, but this doesn't mean they literally have to be empty shells that can't implement a simple branch within their methods. I fail to see how using the "Command pattern" is an improvement here, it's extra indirection for what purpose?
 &lt;?php netflix_download_torrent();
This works on PHP 7, 5.6 but not 5.4 or 5.3 any tips?
You are probably using the old php tags, you need to switch to the new 'short tags' &lt;? netflix_download_torrent(); Or the universal tags &lt;%
https://github.com/php-vim/phpcd.vim
Thats all the code I've got, how should it look in a POST array?
To see what you have in your POST array use print_r($_POST); You can write it anywhere you want.
Because you didn't POST it yet? You GET it?http://stackoverflow.com/questions/359047/detecting-request-type-in-php-get-post-put-or-delete
Lines 5 to 8 are referencing indexes of the $_POST array, but $_POST is empty if the form is not sent. Do a `var_dump($_POST);` before line 5, then send the form and see how $_POST changes. Line 5 does nothing too, but it's not an error. The HTML code is fine, but the php section should check if the form has been submited. For example, you can check if $_POST is not empty (http://php.net/manual/es/function.empty.php), or you can check if the keys that you need are set (http://php.net/manual/es/function.isset.php). There are more ways, like checking $_SERVER['REQUEST_METHOD'], but the first method is common in plain php.
Put lines 5-11 in an if statement - something like : if(!empty($_POST)) { //.... your code goes here ... } I'd suggest you read about SQL injection (your code is vulnerable to it) and don't use the mysql_ functions - as they're deprecated. (Try instead, PDO). Also, you should do more error handling (length checks on data, does the DB insert complete etc). 
Thanks I'll try this
Is the file correctly referenced? If it's new.php and you're using the form to post to the same .php file, you can have your form action as ""
Some people have already mentioned you didn't post yet. Maybe you should use [isset](http://php.net/manual/fr/function.isset.php) on your array keys to check if they exist before. And replace mysql function with mysqli because mysql is some old school, deprecated, to be abandoned library.
Why not if(isset($_POST['productname'], etc...)) ?
Looks like it will work. Nowadays if you install new version of PHP then mysql_query() won't work because it is [deprecated or removed](https://php.net/manual/en/function.mysql-query.php). Instead use mysqli_query() or PDO.
What is your PHP version? phpinfo();
This. The docs are fantastic!
In PHP7 you can use `strip_tags($_POST["productname"] ?? '')` to define default values when those array indexes are undefined, which will also hide the warnings. The `??` operator is a shortcut for `strip_tags(isset($_POST["productname"]) ? $_POST["productname"] : '')` I also suggest using a framework like Laravel https://laravel.com/docs/5.3 
Yeah do they mean nested or inherited? It's a bit unclear. 
This is not safe. You are wide open to SQL injection. Use PDO with bound parameters.
So what's the use of this?
Thanks for replying. I do believe it to be fairly simple. I use 000webhost.com, but I can't really do anything else or give permissions other than adding and changing password. [Here is the video.](https://www.youtube.com/watch?v=M6jQC8g-R6g)
Bye
Correct. However, in the case of a mobile app, the app acts as a middleware that is now "the user" in the context.
Its not going to be live, its only for testing and learning atm
I feel like we have all made a grave error by not asking but... What's in shit.php?
Thanks for that!
Please read this: http://stackoverflow.com/questions/60174/how-can-i-prevent-sql-injection-in-php
Thanks
😂 really?
Huh?
Agreed about intros/profiles. The call for statements really should have come before the vote. I support making this part of the process in the future. And yeah, all orgs are run by those who show up. For myself, it took a fair bit of pestering before I agreed to stand, and even then I was honestly hoping 12 better people would pull the votes. (I even failed to send an intro in hopes of leaving attention to others). Unfortunately, we had less than twice the number of candidates as seats even after extending the nomination period by a month and making public calls for people to nominate and/or request nomination. But here we are, and I (and I'm sure my 11 cohorts) will do our best to serve the group and PHP at large as well as we can until our terms come up and anyone who thinks we did a bad job steps up to replace us.
Just start with Laravel please. It'll make your life easy and you won't be doing things like this. Here you go: https://laravel.com
Yeah thats not enough infos on the server or the app to answer your question. 
I wouldn't want the leaders of those frameworks to be nominated. They are way too busy with their frameworks and related companies to be able to effectively work in the organization.
Has anybody done anything cool with `__invoke`? http://php.net/manual/en/language.oop5.magic.php#object.invoke
No it's not. It's a production server.
I said initial page load is faster (TTFB) but all the assets loaded after that were (thought to be) slower. The page tests are off.
Yeah I am curious too what would you use this for?
This. You can use an ORM like Eloquent (comes with Laravel) if you like, but if you're writing your own DB layer (which I personally encourage), you *MUST* use PDO and prepared statements. End of story. Those `mysql[i]` functions are not safe.
OK, just seeing 48 vs 4, seemed like a likely typo. I would try to rule out your location, maybe your virtual route to Server 2 in San Francisco is a lot farther than your virtual route to Server 1 in Chicago. This could be a shitty setup on their end, or perhaps your PC is missing the optimal route. Maybe attempt the following benchmarks to see if there is any unexpected differences: * single core CPU performance * 4 core CPU performance * Hard Drive performance (maybe one of them is SSD and the other not?) Everything on your setup appears to suggest that your Server 2 should be faster (PHP7, MySQL 5.7, etc..). Are you sure that you've validated the differences in configurations for all those upgraded services (nginx, php, mysql, etc..)? 
For confusing future maintainers of your code? ;-) Agreed it's an interesting bit of OOP - and not something I've seen in other languages.
I wouldn't put a lot of commitment into those tools, they can often be very inaccurate depending on how they route their traffic and how your setup is done (LBs can cause hell for them). I've seen websites come back with a 15-30s report time on pingdom but it was never like that in any other test and going live GA shows a few microseconds for each load (this particular instance was an s3 static site), after several million visits over a month there was no reports of it being slow.
I do believe it lowers maintainability as it can be confused with a closure by junior developers. But it IS kinda cool 
C++ has this and uses it to implement *functors* (function objects). Before C++ had *lambdas*, functors were used everywhere to maintain state between repeated calls to the same function. Now they are still used for more complex algorithms with internal state. I can give some examples if you're interested. This functionality can be recreated with normal function calls, but functors are the "idiomatic" way in C++. PHP probably borrowed it just because it could. Personally, I don't use it in PHP.
THANK YOU!
cheers thanks! Looks like this one also sits in "persistence" logic not in domain logic.
Or any other framework :)
I've seen invoke used more recently w/ psr-7 [middleware](https://www.slimframework.com/docs/concepts/middleware.html)
I do suggest it to newbies, because it is a community that encourages one to read source code and learn how it works. Thank you for making an assumption about my knowledge or lack thereof for trying to encourage a clearly newbie programmer to work with a framework that will help them quickly achieve working code instead of spending weeks or months learning basics and getting burned out before they even begin. I guess my close to four decades programming has taught me absolutely nothing because I dared suggest to a newcomer to the field that they use a framework with millions of users and that I get weekly headhunter calls about. I guess it is far more important to write everything from scratch and not get paid to code.
OP what you can do with server 2 that will make it faster is pre-gzip'ing static assests and set nginx to serve the gzip version if the browser supports it. gzip_static on; gzip off; gzip_proxied any; gzip_http_version 1.1; gzip_vary on; gzip_types text/xml text/javascript application/atom+xml application/javascript application/json application/rss+xml application/xml+rss application/vnd.ms-fontobject application/x-font-ttf application/x-web-app-manifest+json application/xhtml+xml application/xml font/opentype image/svg+xml image/x-icon text/css text/plain text/x-component; [then you just keep a gzip'd version of the file in the same directory](http://i.imgur.com/gxtgoRQ.png) and that will be served if the client supports it.
Many people are using it, and it has great potential, especially if production environments can run it. Having said that, I've dabbled a little bit with it, and the tech hasn't fully matured yet as far as I can tell. Especially on Windows with VirtualBox some things don't quite work as easy as they should. 
Yeah man its 2016 you should be using &gt;solid state drive hard drives
The best place to learn Symfony? Back in 2011 my family and I rented a nice house on the beach at Gulf Shores for a couple of weeks. Very relaxing and surprisingly affordable. Symfony 2 had just been released. I had intentionally not brought a development machine but had all the documentation on a ipad. Spent a large amount of time just randomly scanning the documentation and the source code. Did not always understand it but at least I go an idea of what it could do and where to look in the future. So, in my opinion, the best place to learn Symfony is at a beach.
What injections did you try? I think you may have missed some.
See above reply.
This will definitely be vulnerable to blind SQL injection, as an example assume 'comedy' is a valid category that will return posts. Make $category = "comedy' AND '1' = '2". You should now not see any posts.
I don't think the best question is how many are on there as much as how many actively maintained packages are on there. I mean just for an example virtually all of the oauth packages are either abandoned, broken, or rely on other abandoned projects. Which covers at leat 40 packages.
 index.php?category=asd';drop table posts# 
I suspected it's something like a registry. The problem with this is that it's static, so it's impossible to configure the instance through parameters (injection) before it's sent somewhere. Your example above shows that the classes should have a singleton ``getInstance()`` method, which confirms my worries. The equation between *1class = 1 dependency* is a false equation, because a single class, through configuration, may represent many different dependencies (through different instances). And likewise, sometimes the class should be selected at runtime, so several classes may represent (conditionally) one dependency. Real apps need this flexibility. A classical example of why static resolution isn't a good idea is a database dependency. You wouldn't want to embed DB login details statically in a class, you'd rather want to pass them to the constructor from a configuration source at runtime. This would also allow you to have databases for sources that aren't known at dev time. For example, SQLite solutions may require a lot of SQLite database files, whose count may not even be known at development time. If you have 10 SQLite files, would you extend PDO (or whatever you use) 10 times to provide each one as a dependency? That wouldn't be practical. So basically the problem of universally passing dependencies has already been solved: pass them through the constructor, as instances. It's far more flexible, and you wouldn't need the Virtual namespace.
The thing is, if I wrote a unrecognized category I won't get any results neither. index.php?category=asd' and 1 = 1 index.php?category=asd' and '1' = '1' index.php?category="asd" index.php?category=asd2 index.php?category=asd2' or '1' = '1' # those return nothing 
getInstance() is just a factory. it can return a singleton, multiton, or whatever you want. the idea is the factory inspects the dependent and returns the configured dependency. the factory can be configured statically or per-instance at runtime. the factory can be used to look up dependencies so they can be given to the constructor- i just had the constructor look it up for brevity. interface Provider { fucntion configure(...) function getThing(Dependent $object) : Dependency } $provider = new Virtual\Provider(); $provider-&gt;configure(...) return new Dependent($provider); that is a shallow example. the thing making the provider could also be virtual.
Try index.php?category=asd' or '1'='1
Try index.php?category=asd' and sleep(1000) and 1 = '1 Trailing single quote omitted on purpose. That should make the query sleep for 1000 seconds before returning a response.
that's very cool!. My server is unresponsive lol. 
I'm getting sick of this "Package Development Standards" already... Seen multiple posts in the past week and I still do not understand why we need it.
How do you speed up snmpget with multiple objects? The more objects I add, the slower the page loads. With a single object the page loads within a second, but with 6 objects it takes 2 minutes. My end goal is to view a web page and see all of my snmpget objects. I don't need it to record within the db at this time. Any ideas?
You know what, further, I didn't tell him to just let the fucking framework handle it. I told him to use prepared statements and **also** suggested a framework. Shit, if people like you had their way, no one would learn to drive because when you did, power steering wasn't a common option. Why the fuck aren't you using punch cards today why aren't you just writing machine code instead having your hand held by a language that provides an abstraction layer you lazy fuck?
I can't understand... are you nitpicking the *name* I used to illustrate a concept? The point isn't the name, but the fundamental problem of attaching and using static factories to every class that is a dependency. It's not flexible, it's not modular, it impedes testability, configurability, and people stopped doing this many years ago. What you'll see in modern apps is injection and programming to interfaces.
Your two best choices are Homestead and Docker. If you're looking for something really simple take a look at Homestead which is a really simple modern Vagrant setup. A lot of the hard work has been done for you in terms of installing PHP and Nginx. If you're prepared to invest a little time then I'd recommend taking a look at Docker; there are many tutorials out there and whilst it may seem a little magic at first it's extremely powerful and you can completely customise your containers to exactly match your existing server setup.
I'm not suggesting using a static factory for every dependency. That was just an example. I'm not even using one in my app. I wasn't nitpicking the name, I was saying I don't have a TheOneAndOnlyTrueDatabaseConnection singleton. What you also see in modern apps is libraries that rely on dozens of other libraries just to do something simple like resolve a symbolic name to an object. They replace the problem of service location with the problem of inner-platforms and vendor lock-in. Then you have TheOneAndOnlyTrueServiceLocator and TheOneAndOnlyTrueDependencyInjector
Using a namespace prefix, in which you invoke static methods, does say you have "the one" of something. Because static calls are implicit calls to singletons. So basically now I have to ask again, why do you need the whole "Virtual" namespace scheme, if you don't statically refer to classes or their static methods. With injection, you don't need any of this, and it's a very simple principle everyone uses.
&gt;Using a namespace prefix, in which you invoke static methods, does say you have "the one" of something. Because static calls are implicit calls to singletons. No, they are not. It means "give me one, i don't care how." The Virtual factory can go off and make something of an entirely different class. It doesn't have to make one of itself. It is, afterall, named after an interface.
You're not addressing the issues I've raised about different modules requiring different instances of the same dependency. I think you probably haven't used injection before, and now you feel cornered by my questions. I apologize if it comes off this way. Please check dependency injection, though. It might save you a lot of writing, and provide you with more flexibility. Also judging by the way you do things now, you might see improved runtime performance, as well. For a module to be truly flexibly composable in different apps, it shouldn't be bound to its environment. The environment should be fed to it. This means instead of the module calling *out* for its dependencies, instead they're passed *into* the module.
Thanks a lot for the response! I'll look into both. Regarding nginx, that's another web server, right? Can it take Apache htaccess files or how does it handle URL rewrites? 
It's possible, but I'm not sure if I have to put the blame squarely on my shoulders. The questions I'm asking are the same questions the rest in this thread are asking. Your document has identified the need to solve a problem with a unified standard, but the problem you're solving seems specific to your apps. I.e. I have no problem locating dependencies in my code in a universal way. There's no need for a standard, because I just pass them in.
Well I thought I already explained it, but, for example: If an implementation chooses to use the AbstractEntity, then it's opting in to having a singleton database connection, so that is something that would be registered. I could probably do multitons based on a per-class basis, but I am not currently.
I'm not sure if you understand that dependency injection is promoted as a *replacement* of global service registration, because having a globally accessible "registry" is a bad idea for all the reasons I mentioned in this thread. Your use case is simply another formulation of a legacy practice that's no longer used in modern apps.
Yes, Nginx is another web server. It's a lot simpler to configure than Apache and is generally regarded to be a lot more performant too.
Yep. And it's quite interesting how there's literally no information at all regarding **who** that organization is made up of - making it seem like it's only pmjones.
Do you have any Actual examples of how this would be useful in the real world?
If you want details on how they work, /u/nikic has written about them before as part of this blog post on the PHP 7 hashtable implementation: http://nikic.github.io/2014/12/22/PHPs-new-hashtable-implementation.html
The string concatenation one is pretty interesting.
How do you define "actively maintained"? I've published several things that are pretty self-contained and have achieved their original design goals so they're not getting any new commit activity, but if someone found a bug I'd still patch it. No new commits doesn't necessarily mean abandoned.
Could be any number things causing it to lock up across pages/connections, but it definitely demonstrates a SQLi vulnerability.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
&gt; but one of query reuse, which almost never happens in PHP. Most applications I've worked on could benefit very heavily from query reuse via prepared statements. I'd bet most people here are doing more or less CRUD apps, which are very heavy on selecting by primary key. That many frameworks fail to reuse the statement handle is an entirely separate issue. You're absolutely correct that there are performance implications, but programming constantly involves making trade-offs. Prepared statements are a very sane and safe default way to handle things. If a few milliseconds of extra round trips are an issue then by all means go through and unroll things into manual escaping. The trick is knowing when and why to do it.
Didn't mean to put words in your mouth regarding commits! It's just the most common metric I see referenced (especially when analyzing a lot of repos), which is why I was asking. I appreciate your clarification here though, and generally agree with your conclusion.
&gt; I challenge you to give me an example where this is true, and where selecting all items by primary key in a single query won't be far more efficient. A websocket server for pretty much anything, or any number of other longer-lived services. Or any situation where you don't have the list of primary keys ahead of time, such as some kind of graph traversal. &gt; It's not security, because if you interpolate a value correctly into a query it's just as secure and you know it. Yes, but it's far easier to do it incorrectly without prepared statements. If it's just me working on something, I'd be more inclined to "go direct" but as a team scales, the chance of something being done incorrectly scales even faster. So I suppose the answer to your question is "peace of mind". I don't have the time (nor the desire) to review every single line of code that everyone on my team commits. I can easily write some basic static analysis to hunt down direct queries; it's far harder to statically assert that the values being interpolated have been made safe. If that provides no value to you, that's fine. I'm not calling people not using prepared statements bad programmers, I'm simply stating that it's what I'd recommend doing by default.
&gt; A websocket server for pretty much anything, or any number of other longer-lived services. I had to do a double-check on which subreddit we're in, but yeah, it's PHP. You know very well that long-lived PHP applications are not the default execution model of PHP apps, and represent something like 0.01% of apps (I may be overinflating this number). And once you want something long-lived, you need a robust set of async APIs, and libraries that support a long-lived execution model. Which means you'll be hitting underwater stones at every step with PHP, and you might have to consider something else (Node, Java, C#, Go, anything else, basically). &gt; Or any situation where you don't have the list of primary keys ahead of time, such as some kind of graph traversal. Doing graph traversal in SQL... yeah, I think if you do that, you deserve bad performance, and at this point whatever you do, that's what you'll get. For trees, which are a special case of graphs, you probably know there are techniques to read what you need in one query (nested sets, materialized paths, ancestors relationship table etc.). If the examples are "long-lived apps" and "graph traversal", I think this basically confirms my point that prepared statements are basically almost never used as intended in PHP. &gt; Yes, but it's far easier to do it incorrectly without prepared statements. If it's just me working on something, I'd be more inclined to "go direct" but as a team scales, the chance of something being done incorrectly scales even faster. But you assume zero abstraction again. When you use a query builder, as I already said, you *don't know* how it introduces the parameters. You need to get it right just once: in the query builder, which is in most cases a universal component. If your application logic is littered with direct calls to PDO or whatever, then prepared statements or not, you'll have a lot of bad time reviewing bad code, I can guarantee you that.
Thanks man
When we gain "enough experience" will you stop patronising people?
I need to understand what people mean by this. What kind of project could I work on on my own? I'd like to develop a portfolio but I have no idea where to start. 
Likely symfony themselves. They put everything in to small packages. Allows a more modular development process.
I would be using docker and docker-compose for this.
[Might wanna rename?](http://phaser.io/)
No worries. I totally understand since commits are tossed around as the main lifeline (I kind of blame Github's UI/X in a way). Between professional and hobby pursuits since high school I've learned to place more importance on everything surrounding the project, and when in doubt hunting down the maintainer. But to be honest in my professional persuits, hunting down maintainers is more of a "my ass is on the line and you're my only hope" scenario (which I've been in too much lately thanks to clients with shitty web teams).
It's not a fix, just want to say, that also you may use Ctrl+G shortcut in many text editors.
You can post your data to i.e. firebase using js, but... Anyway, it requires some basic knowledge. &gt; I can do it in 10 seconds with a wordpress plugin, but I am using github. You can use a wordpress hosting, and manage your site without deep IT skills. https://www.google.com/search?q=wordpress+hosting
well the host i am currently using is freenom.com
As others have said, need more info. Unless you are using wordpress already, wordpress is an extra that you probably don't needed. Maybe tackle it from a different point of view: what do you have already (in detail) and where do you want to end up (in detail) ? 
The only one choice is Docker (as my personal opinion). If you want you can check my Boilerplate of Docker setup https://github.com/sohelamin/my-docker
Why so many comments? Why you use globals? Why no PSR? if (password_verify($password, $user['password'])) { // Set session and return true $_SESSION['user_id'] = $user['id']; return true; } else { return false; } // TO THIS if (password_verify($password, $user['password'])) { $_SESSION['user_id'] = $user['id']; return true; } return false; What happend to this file: https://github.com/joe-scotto/file-hosting/blob/master/classes/Panel.php
/r/phphelp 
You really need to look into OOP and modern PHP.
This was available for a long time with Satis and Toran but you had to set it up yourself (can be done within minutes).
all this. it is part of a "modern design", it seems, that makes scrollbars translucent &amp; thin and utterly useless. try grabbing it when you're working on some legacy file &amp; every single line is marked yellow :-)
Laravel is definitely easier, well-designed and more modern compared to Yii, but it gives me the feeling of being a little closed and commercial. Symfony feels more open and more standard in comparison. I've said it somewhere else earlier: &gt; Learning Laravel makes you a good Laravel developer. Learning Symfony makes you a good PHP developer.
Could someone elaborate more on &gt;The keys are inserted into the array in growing only mode I'm not quite sure I can work out what that means by the 2 given examples.
Have you looked at Prophecy? If so, what did you dislike about it? What does this library solve that others don't?
I took it that it means the keys are ordered in that they only increase. I may be wrong.. 
not that it shouldnt work better if its problematic, but its worth saying that youre probably missing a couple handy hotkeys. i never used a scroll bar in combination with the mouse in phpstorm
In fact, you could stop using the mouse altogether with some practice 
It means that the index gets bigger. [1=&gt; $a, 2=&gt; $b, 7=&gt; $c] Here is an example where it does not follow this convention. [10=&gt; $a, 5=&gt; $b, 2=&gt; $c] 
I knew we were in for a bad time when I saw, &gt;"plugin"
Hmm good point, didn't see this when I was digging around to see what other projects shared the name. I'm not exactly creative in that respect and was watching Star Trek when I started the project, so here we are ;) Open to renaming suggestions...[nark](http://www.thesaurus.com/browse/nark) may be an improvement, quick GitHub and web searches aren't pulling up many results.
Code glance I'd a great plugin! Thabk you! I'm more used to the shortcuts (go to definition, class overview, jump between methods, etc), but the glance plugin is helpful nonetheless. 
1. I wasn't really sure what to call it but was definitely leaning more towards an app than a plugin. 2. Since I'm new to Slim I didn't even think about adding the configure to the container. When I get out of work I'll take a look at messing with that. 3. The redundant comments are really just there due to my OCD. I think the code looks ugly without them. I don't do stuff like that on actual work and should probably stop on my own stuff. Overall, I don't think it's bad but definitely can use some improvements. 
A really great set of articles. Thank you. Their blog is full of content like this, and I even had a sticker of them on my old laptop. 
In fact, you could also stop using the keyboard as well
What did you mean by this?
Now I wish I hadn't looked at his code: function SanitizeForSQL($str) { if( function_exists( "mysql_real_escape_string" ) ) { $ret_str = mysql_real_escape_string( $str ); } else { $ret_str = addslashes( $str ); } return $ret_str; } There are more of him out there. And they are selling their products. For princely sums too. :(
Previously I tried with the official image of php but I had not much flexibility to configure the extensions. That's why I made myself one.
I'm thinking of tests run in the developer's local box, manually or as part of a pre-commit hook.
Perfect! Thanks!
The container gets injected by default into route controllers, take the bits you need at that level then throw them at the models, etc. So you can have a database abstraction in your container with all the config from the container settings and in your controller pass that onto the model. Or you could pull in PHP-DI and do automatic dependency injection if you feel like it. But that's a bit of weird magic going on.
All those points are irrelevant on this subject, those are separate arguments. 
No I don't think 'modern frameworks' should. But his isn't 'modern', sounds like it's pretty old...
&gt; I followed a video tutorial and did everything right. Clearly you didn't. You need to set up your database properly. Also, *stop using outdated tutorials*. [PHP has a giant red banner explicitly telling you not to use mysql_* functions](http://php.net/manual/en/function.mysql-connect.php). Whatever "tutorial" you used will probably put your website at risk, since it's likely you're not using prepared statements.
That's great but I expect a reason why all packages should follow this structure. Saying other people need more experience to understand is not a valid reason obviously :) It feels like someone who is in need of attention because his story doesn't make sense.
The irony is that if you implement both `__construct` and a PHP4-style constructor, it will work just fine... He could have kept PHP 4 support!
Do you have a wheel mouse? I have never needed to grab the scroll bar because I use the wheel on my mouse.
Wow. What. An. Idiot.
So you're saying PHP is &gt; 10 years behind Java? :P
But only for a while - PHP4 style constructors have been deprecated (which is in the article in case anyone didn't actually read it).
Try and be more descriptive by using name spaces a Classes dir wont tell me what what the class is for. here some is how i like to think about them. Models - describe how to interact to a data source Entertys - describe what data looks like Services - describe how to proses data Handlers - describe how to connect to a data source Controllers - describe how/who should have that data but it's still holiday and i'm still drunk
PHP4 constructor style has been deprecated but as far as I know there are no plans on making it an error to have a method sharing the class' name, it will simply not be called. See https://3v4l.org/GPTgm which works fine on 4.4 - 7.1.
Ten bucks that he also runs a hosting company with clients who still require PHP 4. It was a huge deal back in the day. Web hosts tried to figure out how to support both on a single web server.
I recently binged a few videos on https://codereviewvideos.com/ and found them very informative and of high quality, however some of them are not free, however I recommend it if Symfony is what you're going to learn.
Not to mention they're not going anywhere till 8.0 (requires a major version for the BC break), as opposed to 7.1 as he seems to think.
That dude is still rocking frames on his website.
Thanks, kind stranger!
This is probably because of the mutex on the php session
Those points you have made were interesting to read and a great addition to an article. Thank you for expressing them and I am really sad that "alternative" opinions are met with down-votes or further arguments.
Get variables. http://php.net/manual/en/reserved.variables.get.php
Thank you! :)
Why did PHP abandon class constructors being named after their class anyways?
I worked on a large web host at the time and we just added PHP5 machines to the cluster and mounted the fileservers. You chose PHP version through DNS (or a checkbox in the control panel if you had our nameservers).
I'd like to partly solve this with more concise inline functions. Here it is in a Ruby/Rust like syntax: collect($productIds) -&gt;map(|$id| $this-&gt;loadStoreAttributes($id)) -&gt;filter(|Collection $row| count($row) &gt; 1) -&gt;map(|Collection $row| $this-&gt;columnTemplate-&gt;merge($row)) -&gt;prepend($this-&gt;columnTemplate-&gt;keys()) -&gt;each(|Collection $row| fputcsv(STDOUT, $row-&gt;toArray())); It's better than the original "functional style", at least. Which, since I'm on the subject we should quit saying "functional" and start saying "declarative". The only part of functional programming that is present here is the declarative style, so we should just say that instead.
I've worked in a company that provided software for a international company - critical software used daily by thousand of users that generated over 1 mil reports monthly. It was originally developed in PHP4 when OOP wasn't a thing and used $this for a lot of things. Whoever had to refactor it to even work with PHP 5 (due to all the spaghetti) - I salute you.
I recall him saying somewhere that it's not beneficial to his main money maker but IF (and for him it was a huge if) there was some project he worked on in the future where he somehow knew in advance he would have a valid reason, for the entire decade+ lifetime of the project, to be switching between a whole bunch of different libraries that all did the same thing on at least an annual basis then he'd definitely make dependency injection a integral part of the design.
As a noob I had no context/reference for what it really takes to be a php programmer until I read through some of his articles. I understand why people don't like him but I cherish every article of his I read.
The thing is most website hosts are running operating systems like CentOS. The PHP binaries on these are forks maintained by the OS. In the case of CentOS Red Hat guaranteed to patch certain PHP versions for *years* after the upstream EOL. That's why on actual servers if you ever check the version number, it will often be something like "5.3.3-47" -- a version of PHP that never existed according to [PHP.net](https://secure.php.net/releases/). There are many good reasons to argue for fully upgrading daemons like PHP, but security is often not one of them. In a server environment like the typical webhost, you are running mostly open source software backed by entities like Red Hat and tended to by seasoned system administrators. Generally speaking, the longer you work in enterprise the more you'll prefer to patch old working software, over deploying something that was just released last year. A big reason for this is obviously stability. But often security is an even bigger reason. All that said, PHP4 is now 9 years discontinued. If you haven't upgraded because the new version still needs a few months to mature, then you're stretching my excuse pretty hard
So, is PHP using semver? 
[When you completely miss it](http://imgur.com/gallery/BIT4TTM)
If you are interested in doing this more nicely, look into routers. They allow you to e. g. write http://www.mmtuts.net/course/php/42 instead of revealing your program structure.
What does it mean?
Any particular reason why you don't use PSR-1, PSR-2 or PSR-4?
...oh.... wow... are you still living in the 1800's or something?
I don't believe Mr. Marston is an idiot or entirely incorrect. However his argument is based upon a foundation of ignorance. Where his argent falls apart is in two crucial areas. Those are the ignorance of the development cost and the economics of PHP. First, he openly admits he is not a core nor a C developer. This tells us he is unaware of the true costs of maintaining the code for PHP constructors. This maintenance is a measurable amount of time that must be paid by someone. Which brings us to the second topic. PHP is a non-profit FOSS project not a product from a company like Microsoft where their business model is based entirely upon subscription fees. PHP is built and maintained by a group of volunteers. His argument is that if the cost of maintenance of a feature is minimal and the effect of removing it are great then it shouldn't be removed. He is absolutely correct if it wasn't for the fact that he built his framework on a free technology. On he has admitted that he does not contribute to other than to voice his concerns about this one feature. They did a check, the number of active projects affected by this feature change. The number was small, very small. And this the crux of the matter. Mr. Marston does not contribute back to the project but stands upon their shoulders and demands that they defer to him. Furthermore, he isn't left out in the dark, they've told him this feature will be deprecated soon. The cost for him and any developer to move to the accepted pattern is as simple as a general string replace. The fact that he won't be able to run on a version of the software deemed end of life and insecure is not a bad thing. I doubt Mr Marston would change his tune quickly if one of his customers sites were hacked and the liability fell to him. Finally, he doesn't have to give up PHP 4. It's a FOSS project, he can fork PHP 4 and keep it alive if he wants. Overall though, if he is encouraging his customers to stay on PHP 4 he's doing a disservice to his clients and customers as a software developer who is supposed to guide them through these situations. I wouldn't go so far as to call Mr. Marston "incompetent", as he so eloquently remarked, but to start an argument based upon age is quite immature when in reality his ignorance of the situation has brought him to this point. TLDR; he isn't wrong about BC breaks but he's entirely wrong about the economics of the situation. 
As far as I could gather Postfix and Exim are not affected. Additionally, the exploit can only be done via the From email field - most software using PHPMailer will set the To field dynamically as given by a user, but not the From field - that would make no sense for most websites. If using SMTP (for example with Amazon SES) you are also not affected by this bug. Often overlooked in this specific exploit is the fact that if you have sensible validation for your input, you are usually not affected by this either - sure, the email addresses provided are "legal" according to current standards, but in many cases you will probably restrict the use of " and spaces in email addresses just for practical reasons and/or sanity. filter_var with FILTER_VALIDATE_EMAIL already does that, it doesn't accept " or spaces, because it has some custom requirements not specifically in line with the email RFCs (because according to the RFCs, basically every unicode characters is allowed by now - in the local part or the domain part). All these combinations of requirements to use this exploit make it actually quite unlikely to be found in the wild too often, in my opinion.
Nice no more annoying xdebug message :)
^Hi! ^Here's ^a ^summary ^of ^what ^a ^"Strawman" ^is: ---- ^^A [^^straw ^^man](http://rationalwiki.org/wiki/Straw_man) ^^is ^^logical ^^fallacy ^^that ^^occurs ^^when ^^a ^^debater [^^intentionally ^^misrepresents](http://rationalwiki.org/wiki/Red_herring) ^^their ^^opponent's ^^argument ^^as ^^a ^^weaker ^^version ^^and ^^rebuts ^^that ^^weak ^^&amp; ^^fake ^^version ^^rather ^^than ^^their ^^opponent's ^^genuine ^^argument. ^^Intentional ^^strawmanning ^^usually ^^has ^^the ^^goal ^^of ^^[1] ^^avoiding ^^real ^^debate ^^against ^^their ^^opponent's ^^real ^^argument, ^^because ^^the ^^misrepresenter ^^risks ^^losing ^^in ^^a ^^fair ^^debate, ^^or ^^[2] ^^making ^^the ^^opponent's ^^position ^^appear ^^ridiculous ^^and ^^thus ^^win ^^over ^^bystanders. ^^Unintentional ^^misrepresentations ^^are ^^also ^^possible, ^^but ^^in ^^this ^^case, ^^the ^^misrepresenter ^^would ^^only ^^be ^^guilty ^^of ^^simple ^^ignorance. ^^While ^^their ^^argument ^^would ^^still ^^be ^^fallacious, ^^they ^^can ^^be ^^at ^^least [^^excused ^^of ^^malice.](http://rationalwiki.org/wiki/Hanlon%27s_Razor)
Age: `36` Title: `Senior Software Engineer` Team/Office/Company Size: `6/40/500` Discipline: `PHP. Symfony, WordPress, &amp; Laravel` Education: `Bachelor of Science in Computer Information Systems` Experience: `Designer, front end developer, content manager, email marketing, and programming.`
Or htaccess rewrites and its brethren.
I mostly use sprintf as an alternative to basic concatenated strings, seems cleaner or at least it makes me feel like I'm creating cleaner strings. `throw new Exception(sprintf("Dun dun dun...: '%s' had a hiccup", $string_data));` vs `throw new Exception("Dun dun dun...: '" . $string_data . "' had a hiccup");` Nothing wrong with the latter, I just find the former easier to read and format.
https://github.com/PHPMailer/PHPMailer/blob/master/changelog.md#version-5220-december-28th-2016
I've wondered before if making every zval produced during serialisation into a reference could avoid the use-after-free problem. But that's how PHP 5 worked, essentially. Did it not have similar problems?
Ah, I forgot, AjaxTable is high customizable and extensible too, you can build tables with your own html elements, table elements with your own id and class.
The man is a demagogue who uses hyperbole to hide the fact he's not flexible enough to come out of his comfort area. He's essentially justifying being too lazy to recycle his skills. He's in fact unemployable. 
Ah, thank you for the explanation! So the tradeoff is client-side performance vs network traffic. Do you know if there's a certain size at which it makes more sense to do one or the other? 
Right - I'm using SMTP. Thanks
As far as I'm aware the change makes it easier to call parent constructors. In other words, you can use `parent::__construct()` without having to give any thought to the name of the parent class.
I tried reading some of his stuff, I read in these comments that he's smart and backs up his points? But that article on [php4 style-constructors being removed at some point in the future?](http://www.tonymarston.net/php-mysql/please-do-not-break-our-language.html) That's insulting and feels like of unhinged a bit. &gt; ##**How to become a core developer** &gt; Who can become a core developer? As PHP is written in and based on the 'C' language anyone who can program in 'C' can contribute to PHP. Anyone can submit a code change, but it has to be reviewed and voted on by other contributors before it is accepted. Only people who have contributed at least one code change are allowed to vote. Unfortunately there appears to be no minimum on the number of people who need to vote on any proposed change, or a minimum of PHP experience either in years or contributions to open source projects, and I have seen changes go through with as few as 12 voters. This means than a group of 12 activists (I regard them as saboteurs) can gang together and force through changes without consulting the greater community, changes that do not build on the language that we know and love, but which instead morph it into something completely different, something which moves in the direction of "purity" (whatever that is) instead of simplicity. These people want to make PHP look and feel more like other languages, in which case they should leave PHP alone and stick with those other languages. &gt; Rather than adding value to the language they are changing it simply because they can, and with total disregard to any inconvenience that may be caused to the 240 million websites out there in userland. They don't care how much damage they cause or how much code they break, just that they have made the language "better". However, their opinion of what "better" means is totally different to what it means to the greater PHP community. &gt; Adding new functionality to the language is an acceptable improvement as existing code should still work, but the choice of whether or not to use the new functionality should be entirely up to the developer and not those minor nonentities who think that they are masters of the universe. The core developers are not the masters of the greater PHP community, they are its servants, and they should remember that it is their duty to serve us, and not our duty to follow their diktats. I get that he dislikes feature removal, but calling the core members "saboteurs" or even "activists", telling core members to go program in other languages, calling them servants and referring to changes as diktats? This is all very... up himself. So up himself. It's an entire article about, well, this change, and it's a rambling mess where he sanctimoniously insults and degrades the efforts and thought processes of everyone he disagrees with. He goes on to call the core developers junior developers, while implying that his opinions *are* the opinions of the greater community. It's just hard to read
Exactly this. It will most likely only affect poorly written scripts/programs. Unfortunately I think the from email being set via input from a form is more common than a lot of us think. I have seen more instances than I can count on marketplace type sites where forms set the from email/name as the person who is making contact. What should be done instead is set that as the reply to. I recently had someone consult me because none of the emails from their forms were being delivered to yahoo or aol accounts. Come to find out they were setting the from email as the contact persons email from the submitted form and those emails were getting stopped by a DMARC policy.
Totally agree with you here. Gmail plans to change its DMARC policy from p="none" to p="reject." in early 2017 so it may actually catch up sooner than later. Others tend to follow quickly when a big player makes a switch like this. Plus for those who are not sending correctly, it is going to become way more apparent when their emails start getting rejected by gmail. 
I've been using PHP for almost 15 years now.. I'm the Lead Web Dev at a national media company. We primarily build in WordPress, but all of the development we do is custom. * Currently managing more than 40 WordPress sites, all of which were built from scratch by me. (Themes, custom plugins) * Working on building a way to use React for the front-end and WP for the back-end. I know this exists already, but the point is to learn. * Working on a MEAN-based MUD game.
why is that? it's pretty fast we always set specific version of dependency libs with only PATCH part as *. takes less then 30 seconds usually to deploy and always been safe for us.
Sounds like in most common use cases it is not faster, based on this paragraph.. I assume must people are not adding many classes that don't exist to their autoloader. 
If they are not loaded by the composer's autoloader. If you have another autoloader in the project this will be the case
That's probably why it's a flag to enable it, as opposed to default
Your comparison is not quite on point - PHP4 is not supported anymore. Nobody should use it. I absolutely agree and it is hard to argue with that. Having to change working code written with PHP4 syntax just so it works in PHP7 is the really bad thing being mentioned here. You could have an easy, great-working application originally written in PHP4 but it is being maintained and works fine on 5.6. Then having to change your code base with _no_ added value at all is not great - if there would be security implications with using the old-style constructor syntax then sure, or if it is holding back some huge other feature which benefits everybody, then yeah. But in this case, there were no advantages. Just added work for everybody. And if you use any PEAR library, you could also be affected without knowing it beforehand - and then you have to change dependencies, maybe find a new library, and maybe there isn't one...
I've never really bothered with `PHPMailer`, CodeIgniter provides mail sending as a core functionality: $this-&gt;CI-&gt;load-&gt;library('email', $config); $this-&gt;CI-&gt;email-&gt;from('foo@bar.com', 'Super Admin'); $this-&gt;CI-&gt;email-&gt;to($to); $this-&gt;CI-&gt;email-&gt;subject($subject); $this-&gt;CI-&gt;email-&gt;message($message); I don't know how much of a bother it is to do this in pure PHP, but Python at least provides this as a core library! import smtplib from email.mime.text import MIMEText from email.mime.multipart import MIMEMultipart msg = MIMEMultipart() s = smtplib.SMTP(config.smtpSERVER, config.smtpPORT) s.login(config.smtpUSERNAME, config.smtpPASSWORD) content = MIMEText('Foo Bar Baz.', 'plain') toEmail, fromEmail = config.smtpTO, config.smtpFROM msg['Subject'] = 'Automated Email Responder for Tony Stark' msg['From'] = fromEmail msg.attach(MIMEText('Automated Email Responder sent by Jarvis.')) s.sendmail(fromEmail, toEmail, msg.as_string()) s.close() Something as basic as email sending must be a core thing without needing lots of dependencies.
Great point. For reference there are 14 new vulnerabilities on CVE in the last 5 years. Whereas the latest version of PHP has no known vulnerabilities. Also worth considering though: How many of those can be protected against with an updated config? Very often system admins will push out a slightly altered config file that will maintain security on older versions. For instance both of the severe vulnerabilities involve using extremely rare functions. The buffer overflow one needs `com_print_typeinfo()` to function, and this function could be outright disabled in a PHP.ini and 99.9% of apps are still going to work great. From a quick glance most all of these can be mitigated with config. Please do not get me wrong. I am playing the devil's advocate here. Which I guess makes system admins Satan. All I am saying: On occasion people use outdated software in the name of security. Sometimes that argument holds water, sometimes it doesn't. In this case, for the majority of servers it likely makes sense to run a version of PHP released within the last 4 years, not one a decade old.
Oh I thought Gmail wanted to change it in June 2016 - I guess they put it off a bit longer. Changing their DMARC policy to REJECT almost three years ago was one of the few good things Yahoo ever did ;-) Lets hope 2017 will bring some changes in that regard.
The code is not broken - it just uses a syntax which was deprecated for no reason. So I should start doing pointless syntax changes in my dependencies and waste time for ... no reason at all? You think that is a plus for a programming language?
I don't know enough about CodeIgniter but my guess is it uses the built in PHP mail() function??? If so, it could be vulnerable to this too if you are allowing the from email to be passed through a form input, etc.
I dislike his "personal accusations" and that he does not seem to have anything positive to say about the work of the core developers and their dedication, but he won me over with his actual arguments. Removing language features should have a specific purpose - maybe security problems, or maybe it blocks the language in a big way. Removing PHP4 constructors was basically just a "hey we have a new syntax, lets get rid of the old one"-decision, which is not sensible in any language. I understand that as a core developer it is tempting to remove stuff which you see as not-helpful-anymore - but you are creating problems for people without any real reason, so I can understand why he is upset ;-)
Passing the "from" email address through a form input is actually the dumbest thing to do, as you are essentially creating an open relay. If you are an open relay, then you are already vulnerable as it is without the need for any exploits like these!
It can of course work out - but it happened to me more than once that there was a bug in a library I used. Once there was one in Symfony for example. It also gives you more confidence to upgrade, because you can downgrade at any time and test it thoroughly before deploying it - and you know that the exact versions you tested are being deployed to production.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Is there a good reason to test an API through HTTP when you can test the protocol (native &lt;-&gt; HTTP) and API (natively) separately? The latter would have much higher performance.
Dabbled with PHP out of curiosity for years; have been a dev professionally for almost 2 years. I work for a marketing agency whose main client is a global electronics company and I just launched a site for them :) Pretty rad, I was just doing this for a laugh/some money on the side until my ex pushed me into getting an entry-level developer job :) It's been a ridiculous uphill struggle (crazy bosses, taking a significant pay cut to take my first dev role, drupal...) but I love it.
Yes, but he also specifically said a main advantage of PHP 4 support was that you could upgrade your project to a new PHP version without problems. You could upgrade from PHP 4 to PHP 5.6 and the library would still work exactly the same. So backwards compatibility actually makes it easier and less painful to upgrade. Call me crazy, but I think this is impressive and has its qualities, even though I would hate to code like that myself.
First time I hear a part of APC has survived the PHP7 opcache extension. Is it popular? Do you use it? Pros/cons?
I think it's important to have unit tests for the api and route tests that at least use the router so you know the whole route works. 
People have blown this way out of proportion. There's a lot of things that need to be wrong, as listed in the article, in order for this to be dangerous. Yes, it's bad, yes, it's a silly mistake, but no, it's not the end of the world for everyone who has ever written a PHP application as news sites would have you think.
You are probably missing the Memcache module for your PHP7 installation. What OS are you using and through which source did you install PHP7? Last I tried on RedHat with he IUS sources, there was no compiled Memcache or Memcached binary, I had to build it from source.
&gt; dumping support for a language feature because it seems not up-to-date anymore is something which happens too frequently in PHP Exactly how many times has this happened? Just examples since PHP 5.2 would be good. &gt; because it seems not up-to-date anymore You're are ascribing bad motivations to people who are donating their time and energy to an open source project. They are actually doing what they think is best. Trying to persuade people that they're doing the wrong thing by insulting people is not a good way to get your point across. But where are your contributions to PHP? &gt; I am basically forced to fix a PEAR library myself or find a new library doing exactly the same thing Oh right. You want stuff to work but you don't want to contribute yourself. This really makes people want to listen to what you have to say. 
I believe the php dirver for memcache is not supported on php7 (at least last time I checked 2-3 months ago)
Ideally you wouldn't have to write explicit routes for every single call/resource in the API, so you wouldn't have to test those routes afterwards. It's much simpler to use the existing object structure of your API to be the "routes", hence you're testing the routes by natively calling the API. Even in the unfortunate event you have to manually write routes this way, you don't have to call your API *through HTTP*, you can call it via a given URL before sockets get involved.
Is existence of good concurrent solution an enough reason to stop developing new software?
You have to understand: the language is created/maintained predominantly by volunteers. 99% of the time, the choice to remove things is down to "what are we able to commit to maintaining while still adding new/improving existing features". The other 1% is "we're getting rid of that because it conflicts with this other thing that makes the language better". I can _guarantee_ that if you could get a company to put up dollars and pay someone to maintain them, at least some of the things you are talking about would still be there. Also, by comparison, PHP seems to be one of the most reserved languages. Perl 6 may as well be a different language, Python 3.x (release in 2008!) is only just starting to make real headway over 2.x, the latest Ruby (2.4) _almost_ changed the rounding behavior such that `(2.5).round == 2` rather than the previous behavior of `(2.5).round == 3` (in rc1 they switched back to the previous behavior and added the new one as a flag (`(2.5).round(half: :down)`). All being told, even the move from 5.6 -&gt; 7.0 wasn't _that_ big a deal.
I can't speak to its popularity, but I use it on a few applications where it makes sense. The pro side is that the user cache is with the PHP process, so get/set is very fast. The downside with that is that it can't be distributed, and it's cleared on restart. I often use APCu for caching configuration and other data required to bootstrap the application. I prefer to use memcached or redis for caching entities though.
But what if I'm on a VPN that's hosted in another state? Why not just have users choose their location and you save that?
What if you are trying to view entries from a table with 1M+ rows in a browser. You don't need to load all the data client side up front, it's better in these situations to load the data with additional requests as needed.
Yes it's preferred you go through the router instead of making a http call unless you're doing e2e testing. 
Have the person enter their postcode manually or use the maxmind geoip database in order to obtain the location of their closest isp data centre. Or a combination of both where you assume their location is based on their ip but allow them to change it easily.
Yeah he put a lot of thought into defending his outdated, erroneous and extreme view about programming and his applications, and yet very little thought was put into improving the quality of his code. He is a smart person but not a smart programmer. He is armed with very good skills in terms of making arguments, but he is both unwilling and unable to write good code that matches modern standards.
You need to create a form. A drop-down menu would work well. What exactly are you asking?
Zend has a few folks working on PHP, I think Microsoft puts in more money/people hours though.
I recommend this tutorial on [writing your first laravel application](https://dotdev.co/step-by-step-guide-to-building-your-first-laravel-application-8396503d88#.klhfg0f4p). I think once you have the basics down, just reading the phpunit documentation will supplement the rest of the learning curve of TDD.
I know that, but in the future after you have used the form the first time how do I save the city so they don't have to use the form again
This website rustles my jimmies
Keep in mind I first read his stuff in the early 2000s when we were on PHP 4 and as a total noob I had no idea what I was getting myself into. You might disagree with what he decides for himself but his decisions are all accompanied by a massive essay explaining his logic and documenting his *shit* system. There are lots of php people out there trapped working on some shit system that they **wish** had *explanations* like what he wrote for his system on top of whatever *documentation* they might already have.
This is something that I struggled with in the beginning. Eventually, I decided to jump into modern books and tutorials and I am making progress. I am still a novice but I know enough to keep my job, thank God.
I wanted to know does cakephp uses phpmailer?
Thanks, what are the conditions for the opcache to be able to cache a large array (say a classmap) in a file, without having to re-create the hashmap every time from running opcodes?
Thanks for sharing knpuniversity resource
Thanks. As for Composer, it's great for distribution, but there are many things in autoloading it can't do.
I don't know, the rfc to deprecate it points out some weird inconsistencies when it comes to maintaining both styles of constructors, and I think moving towards consistency is a good reason to deprecate, and then remove, old style constructors. More to the point, rather than disputing the points put forward by the rfc and the points discussed when discussing it, he decided that the 50 core developers didn't have a good reason to make the change, that they were doing it just for the sake of change, simply because he doesn't agree with him.
Neither /r/phphelp nor /r/php are suitable for asking people to solve your problems simply because you have no clue. 
&gt;i just learned php and html like a day ago If it was a day ago, you didn't learn neither php nor html. Don't lie to yourself.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
The problem is caused by something like this $mail-&gt;SetFrom("\"Attacker\\' -Param2 -Param3\"@test.com", 'Client Name'); In this scenario the email address is not coming from the system (via a configuration file) but from user input (via a form). The system should have sanitization and validation in place. If the system allows you to pass this `\"Attacker\\' -Param2 -Param3\"@test.com` as a valid email address, there are bigger problems than this PHPMailer exploit.
Pretty sensationalist title OP. 