People hate PHP because ignorance is bliss.
You've just named a significant part of web to shit. But yes, it gets things done.
You could compare your new package with the [League Package Skeleton](https://github.com/thephpleague/skeleton) and structure the directories and files like this.
Do you think the web is shit? And if so, how can it be getting things done for billions simultaneously and be shit? I think we need to better understand what you mean by shit here. 
&gt;But it gets shit done Sorry, I forgot to refer to your quote.
SO I just released a package YESTERDAY: https://github.com/phpexpertsinc/CSVSpeaker Key points: 1. Think of a good name. In my case: "CSVSpeaker": It knows how to read and write CSV, but only to arrays and strings. 2. Create a [**composer.json**](https://github.com/phpexpertsinc/CSVSpeaker/blob/master/composer.json). In it, include: a. A concise description (probably the same you used on GitHub). b. `require` the minimum PHP version you will support. For my packages, it's always the minimum still-supported PHP (right now, 7.1). For my websites, I generally will require the latest PHP version. c. `require` any PHP extensions you require, even "standard" ones, because distros make a habit of not including them in the base install. For instance, I require `ext-spl: *`, because I use `SplFileObject`. d. Set up the namespaces for PSR-4 support for both your classes and your tests. 3. Code the app. 4. Create unit tests and, if applicable, integration tests. Aim for a MINIMUM of 75% unit test code coverage before publishing. Me? I always aim for 100%. 5. **ADD A [LICENSE](https://github.com/phpexpertsinc/CSVSpeaker/blob/master/LICENSE)!** Without it, no one can legally use your app/library for any reason without your written consent. Please choose a liberal license (MIT, Creative Commons Attribution, Apache) and not a "force share" license (like GPL, or worse AGPL). Unless you're in it for profit, and then offer a proprietary license, too, for a cost. 5. **CREATE A [README](https://github.com/phpexpertsinc/CSVSpeaker/blob/master/README.md)**. It needs a. A brief and possibly longer description of what it's purpose is. b. How to Install it (usually, just `composer require your-namespace/project-name`) c. Usage section, code samples of how to utilize virtually everything you want them to publicly know. A lot of packages will stick this in a separate `docs/` directory, but trust me, adding at least the basics to the README **really helps!** d. (Optional) Use cases. I dump these directly from `phpunit --testdox`. This is like the documentation a Business Analysis would tell you how to build the project. e. List the Contributors, even if it's just yourself. f. Rehash what the License is. 6. Add `composer require phpstan/phpstan` and run `phpstan analyze -lmax src` to find and fix any programming deficiencies you may have made. 7. Set up continuous integration from a place like CircleCI or, more popularly, TravisCI. See my project's [**.travis.yml**](https://github.com/phpexpertsinc/CSVSpeaker/blob/master/.travis.yml) as a good case reference for a basic package. 8. Consider setting up a code analysis app, I'd recommend [**CodeClimate's Quality service**](https://codeclimate.com/quality/) because it's high-quality, has innate support for TravisCI and is free for open source. 9. FINALLY, after all that is in place, register the package on [**Packagist.org**](https://packagist.org/) I'm not sure how, exactly, to publish it. Self-promotion, for some reason, is greatly frowned upon in this sub. Something I find very misguided. But there you have it! A comprehensive guide on how to setup a high-quality package for public consumption in 2019!
/u./pikknz wrote: &gt; Stop being wrong. Hey, you're coming off as quite the religious zealot. Stop replying with short quips and start backing up your words with reasons.
Not until Google develops sentient ASI that breaks out of our Matrix and leaves behind a ton of reality glitches. Ooops! TOo late!
Really good list of tasks. For requiring \`ext-spl\`, note that post PHP 5.2, SPL extension will always be included (similar to \`ext-hash\`). I find these constraints are largely incomplete if I were to list every core extension. On the other hand, \`ext-mbstring\`, \`ext-curl\`, etc, they actually convey useful information.
Besides PHPUnit's asserts list and Laravel's documentation? About as recently as I watched a DVD, to be honest. 8 or 9 years ago? The only time I NEED documentation is for 3rd party APIs (SOAP, REST, etc.) or there are TONS of options, like PHPUnit and Eloquent and Laravel.
Can you please elaborate? I seriously don't understand why these seemingly-superfluous docblocks are needed... 
/u/saltybandana2 wrote: &gt; or I'm better than you and you don't even understand why. Gosh! You sound like one of those devs who have 10 years experiencing going on 1.
Php unit with travis ci is the common way. Your test directory will show your tests and the travis ci will tell us if the latest build is passing or not. Also tag your releases. and have "Experimental" or "development" features on a separate branch.
&gt; and not a "force share" license (like GPL, or worse AGPL) Counterpoint: Please do consider using the GPL or the LGPL. Everyone benefits from contributions to the open-source ecosystem.
If you do license under the GPL, just know your adoption rate will be way way lower. Back when GPL was by far dominant, I used to be part of a group of coders who would target GPL projects to create MIT equivalents, just for freedom's sake.
I don't know what extensions will be in any given repo. I would have hoped that every extension in the download of php.exe would be in every distro, but 3/4 of them seem to be missing...
&gt; If you do license under the GPL, just know your adoption rate will be lower. Oh my, you mean commercial developers who aren't contributing back anyway won't use my library? How _terrible!_ But seriously, everyone: don't take advice on which license to use, not even from me. Decide for yourself what kind of license is appropriate for your project and what aligns best with your ideals. There's a reason we have more than one kind of open-source license. If you don't know where to start, [Github's Choose a License website](https://choosealicense.com/) offers comparisons between the popular licenses.
Thanks, that's a lot of good info! I am pretty sure about going with MIT; I want the least restrictive license I can find without responsibility. One last thing. My use statements, should I avoid things like use \Libraries\Somestuff as Somestuff or is that fine for a distributed app? Maybe I'll peak around respositories and see what others do.
Thanks, this is a great starting point!
Also see https://github.com/localheinz/repository. 
Or the [pds/skeleton](https://github.com/php-pds/skeleton) package, with which [about 78,000 packages on Packagist are already compliant](https://github.com/php-pds/skeleton_research#addendum).
Try releasing it via [Producer](http://getproducer.org); Producer will: - Sync with the remote origin (i.e., pull from the remote origin, then push any local changes, then check the local status to make sure everything is committed and pushed) - Validate the composer.json file - Check for informational files (see below) and for a phpunit.xml.dist file - Check that the license file has the current year in it - Call composer update, run the unit tests, and make sure they cleaned up after - Check that the PHP docblocks in the src/ directory are valid (see below) - Check that the changes file is in the most-recent commit to the repository (I am the project lead.) 
What got people discussing PHP hate in this thread? All I see is a link to a Superman website.
you should keep making comments like that without knowing anything about me, I'm sure eventually reality will warp itself around you such that they'll become true.
Is xhprof still around?
PS - if this belongs over on r/PHPHelp I apologize; it seemed to exist at the nexus between the two, and I've seen a few discussions here regarding opcache in the past.
I'm more of a true capitalist, I guess. 95 out of 100 times I use a package, it's in a commercial setting. I don't want to limit the adoption of my own packages to people working on for-gain projects, and if someone can monetize my own works better than me, then I say more power to them.
What’s your problem guy?
&gt; 7. ⁠Add composer require phpstan/phpstan and run phpstan analyze -lmax src to find and fix any programming deficiencies you may have made. I would be forever grateful if you would add these dependencies as dev dependencies: `composer require —dev phpstan/phpstan`. Otherwise every project that includes your library will download phpstan. Nice. But not really necessary :)
You clearly missed the point of GPL and software freedom in general that software shouldn't be a commodity 
If only browsers supported some sort of language capable of manipulating the dom structure. That would free us from the horrors custom css. Someone really should write such a language. Maybe give it a real cool name like javascript or something.
Thankfully, you don't have to be a lawyer, only basic reading skills are required. There no legal requirements that a licence be placed in the root of a project. Github recommends it, but does not require it: &gt; Determining the location of your license &gt; Most people place their license text in a file named LICENSE.txt (or LICENSE.md) in the root of the repository; It explicitly covers multiple licenses: &gt; If your repository is using a license that is listed on the Choose a License website and it's not displaying clearly at the top of the repository page, it may contain multiple licenses or other complexity. 
I asked because it was on a job posting as skill requirement but I had never heard of it before. Thanks. 
Aye, its been around for a while!
Do you have a database installed and setup with tables?
I do. I've also checked to make sure that it was reaching that database.
What version of php are you running?
Not quite sure, how do I check that?
phpinfo(); exit; https://www.php.net/manual/en/function.phpinfo.php
From what i understand I'm doing everything on google chrome. I'm doing homework for school, I'm using notepad++ as my text editor and then i'm just uploading it to my schools public server and then testing it on google chrome.
phpinfo(); exit; https://www.php.net/manual/en/function.phpinfo.php
Please read the sidebar. The belongs in /r/phphelp
7.2.16
Php 7, cool. Now click the link you posted and read the box in red that says “Warning”
I think you've missed like, 2 or 3 points of the conversation.
Hahaha well that definitely ruins that plan. Annoying that outdated functions came up as the second Google result. 
Use this instead: https://www.php.net/manual/en/mysqli.query.php
You suck.
The list given by /u/2012-09-04 is probably the most comperhensive but for quick reference I happen to use [phppackagechecklist.com](https://phppackagechecklist.com)
You just gonna ignore my and down vote me?
Which extension are you using to manage your database? Pdo / mysqli? Have you tried to grub an error from your command? For example: `$sql = "select sum(pub_id), pub_name from publisher group by pub_city";` `if (!mysqli_query($conn, $sql) {` `echo mysqli_error($conn);` `}` If so, what's the reply?
[https://www.w3schools.com/php/php\_mysql\_select.asp](https://www.w3schools.com/php/php_mysql_select.asp) This might help you understand how to open/close a connection to your mysql and execute/display a query. It will also let you see the difference of syntax between mysql/pdo extensions. Also [mysqli::$error](https://www.php.net/manual/en/mysqli.error.php) or [PDO::errorInfo](https://www.php.net/manual/en/pdo.errorinfo.php) for grubbing exceptions in order to find and fix your errors easier.
Boy! They **really** got to you, huh????
Also, instead of 100% coverage test, try using mutation testing as a metric.
I had a closer look. There are some changes, also to 3rdparty files found in the vendor directory. https://github.com/calvinbaart/laravel-peachpie-sample/commits/master Not something I would want to use right now, but still impressive and maybe peachpie is able to make some changes so that we don't have to modify the composer files.
Yes the mods are asleep at the wheel in here. They should add people who actually come here.
It's dumb anyways. If I had a question and couldn't post text I would just link to a pastebin.
Yeah this sub is really bad with the downvotes. Bunch of haters in here.
``` /** * @return int current month 0-based, i.e. 0 - january, 1 - february, etc. */ function currentMonth(): int { } /** * @return int current month 1-based, i.e. 1 - january, 2 - february, etc. */ function currentMonth(): int { } ```
Check your commit history to make sure you never accidentally committed a password, key or other private (personal) information. Or just squash all your commits to one 'initial commit', the first commits in a new project are usually quite meaningless anyway.
Yes, the pds/skeleton package is great. I use it too.
apart from a widespread \`int\[\]\` and other forms of typed arrays I personally use a docblock if my return type is of an abstract class/interface, but I know that this class (a factory for instance) returns only one of the subclasses. I also like \`@throws\` docblock, they are a bit redundant and useless but I still prefer to mark them, it feels right to be aware of what a method throws.
!remindme every year
**Defaulted to one day.** I will be messaging you on [**2019-04-09 07:05:48 UTC**](http://www.wolframalpha.com/input/?i=2019-04-09 07:05:48 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/PHP/comments/baisrj/things_to_do_before_releasing_a_public_package/ekdfoi5/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/PHP/comments/baisrj/things_to_do_before_releasing_a_public_package/ekdfoi5/]%0A%0ARemindMe! every year) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
Yeah, it is such an old and well known issue (not being able to post a body with a new reddit design), so I am honestly surprised by the fact it is being ignored. The design is not even 'new' anymore. This is like the essential thing to a subreddit, I have seen too many people writing their posts in the comments for this reason. God damn, lets fix this thing.
&gt; JS and Python have no runtime enforced typehints. I don't know what you're smoking tbh. Both of those languages and PHP only have runtime type errors because none of them are compiled or statically typed. Python 3 has the same type hints as PHP and the same runtime errors, and type script - which is statically typed and compiled as it has to run as javascript is a different story. Maybe you should just go back to teaching everyone how little you know about `use` statements.
&gt;I separate my applications into controllers, entity models and service classes You're just confusing a beginner even more
&gt;PHP Experts, Inc. well, that's quite a humble name, I like it. &amp;#x200B;
My statement: &gt; JS and Python have no runtime enforced typehints. Your statement (without the insults and B.S.): - Yes JS has no typehints &amp; TypeScript doesn't compile types into runtime checks. - Python has typehints enforced at runtime, like PHP. So on the first one, you say the same things I say, yet you insult me. On the second one, [you're just 100% wrong](https://www.python.org/dev/peps/pep-0484/#non-goals). Typehints have precisely zero effect at runtime. As my link says, you can read the typehint info (reflection), but nothing in the standard runtime checks those typehints, and nothing emits type errors based on those typehints. Making them decidedly **unlike** PHP's typehints, and much more like TypeScript's typehints, which are inert at runtime (but can be optionally inspectable at runtime via a compiler flag). I did warn you to calm down and move on, but you just insist on being an arrogant ignorant dipshit.
I guess XHProf is more about profiling while Fracker is more about analyzing and filtering stack traces. Also XHProf seems to be abandoned.
You can and a lot of people do use LGPL licensed code in proprietary software. You just have to tell your users you do. The big difference with something like the MIT license and the heart of the LGPL is: if you do modify LGPL licensed code you have to release it as LGPL. It means no one can come, take your code, change something specific and start their proprietary walled garden thanks to your base work. How many times have you forked a library you used from packagist? Not a lot I guess. So them being LGPL would have been alright as part of a proprietary software.
 Traceback (most recent call last): File "main.py", line 4, in &lt;module&gt; greeting(1) File "main.py", line 2, in greeting return 'Hello ' + name TypeError: must be str, not int hmm, is that a runtime type error ??? sorry, made the mistake of arguing with an idiot, my bad
I am all _for_ software freedom, but _why_ shouldn't software be a commodity? If producing material goods _is_, why shouldn't software be? It costs money to make, often _a lot_ of money, just like material goods.
Before releasing a package you'll most definitively want to know how to test your package. If you're not sure how to test it then you'll have to figure that out first. There's no silver bullet for this, each package requires a different way to test. You could also check similar packages and see how they're tested.
Don't do that, run them from a Docker image like this: [https://github.com/dkarlovi/xezilaires/blob/master/Makefile](https://github.com/dkarlovi/xezilaires/blob/master/Makefile)
This is an extraordinarily great answer. Things are a lot clearer now. Thank You.
Even though they contributions are what make open-source work, to me, projects that are distributed over GPL are more like a virus. I also tend to prefer MIT licenses, and if I wanted to contribute, I’d release my packages as MIT as well. Being forced to do something is almost never really good. 
That's not really necessary :)
Not **necessary**, but a better approach than requiring it via Composer for sure since it doesn't doesn't complicate your own dependencies resolution.
Docblocks are import to document the purpose of the function/class/etc so the next guy (often the next guy is future you) can know exactly what’s going on. It doesn’t seem like something that would be a big deal but when you have a code base with 10 people working in sprints leading up to crunch time small things like “what does this function do?” are death by a thousand cuts. Are they often superfluous? Yeah, most times you probably don’t ever need to look at them again or maybe even have really intuitive naming, but the few times you someone else needs it can be critical and having complete documentation is like manna from god.
Genuine query here - can you back the first part (license in files) up please? I've never heard that one mentioned anywhere before, just that a license must be distributed with a codebase. Even then nobodys coming after you for such a minor infraction.
\`$lol = 1 == 2 ? 1 : eval("throw new Exception('test');");\`
By Rasmus' beard! I aint debugging that shit. 
The tenary operator is not a shorthand if statement, it is a comparison operator. It doesn't support arbitrary expressions.
I don't really get the purpose of this code. Why not to write it as $callback = getCallableOrNull(); $callback(); 
Oh man, did we just become best friends?
I wonder what would happen if you tried to `return` or `exit` instead.
A single person cannot support all the code needed in the modern development single-handedly. This closes the question, really. 
Use whatever works. Composer would probably offer some benefit, it's extremely lightweight and you can still tell it when and what to update, the constraints allow you to only specify upgrades for bugfixes / point releases. I, like you, used to do all of my package imports manually, although I used about a dozen of them. Once I finally got things set up with composer, I learned to love it. It's worth saying that Symfony doesn't require you to use the entire framework. I tend to pick-and-choose the independent components then put them together myself as necessary. As always, the code which does what you want, only what you want, and only how you want, is typically the fastest. But with changing demands, that doesn't necessarily mean it's the best choice. 
&gt; I don't use any of these modern frameworks (Symfony, CodeIngiter, etc) Certainly you can use your own in-house framework but a "modern" one is gonna have a lot more people familiar with how to use it up front. You can put Symfony on a job posting and reasonably expect to find PHP candidates who know Symfony. The same likely cannot be said for your in-house framework. That's a big advantage of using a "modern" framework. Certainly a good PHP dev would be able to figure out how to use an in-house framework but it'd take a little more time. &gt; I don't use composer What if your dependencies have dependencies? And in any event, it is probably hubris to believe that you could provide an adequate review on any sort of complicated third party code.
&gt;So am I old guard falling behind or properly ignoring the middleware fads here? Maybe a bit of both? Tooling is more important when it comes to collaborative work. You really don't need to learn any of it unless using or working on a project that requires it. Remember though that tools are just there to help you solve problems. If you don't have those problems, then you probably don't need the tool. But they can still be a useful resource that can save you time in the long run. A framework might add bloat, but if it saves you from having to reimplement some common patterns across all your projects, maybe it's worth considering? As for package managers, I get that they might feel like over-complications but they bring value as well. It lightens your project (great for hosting on Github/etc), and provides tools for easy updating/versioning. Again, it's just a tool that's available if managing dependencies has become a problem for you.
The biggest reason I don't like composer are like you mentioned, relying on 3rd parties. Updates can break a lot of your system and can also come with security issues if some smart ass decides to eval a bit of code they can inject easily without you relizing, they can infect a lot of different machines that are reliant on them. &amp;#x200B; But at the end of the day you also rely on PHP, which is just another 3rd party dependecy. So it's also a bit hypocritical in my opinion. &amp;#x200B; I like composer because I can get a project set up really quickly, it saves me loads of time writing code, and my clients are happy when I don't spend a lot of time. If I had all the time in the world, I'd be happy to write everything from scratch. But I don't, so there we go.
&gt; [composer is] giving other people control over my project The difference between the PHP ecosystem and the Node ecosystem is that Composer dependency graphs are almost always *much* smaller than NPM dependency graphs. There is also less risk because PHP runs server side and therefore unlikely to be able to steal user data. Yes, using Composer means giving up *some* control, but the benefit:risk ratio is **very** high. &gt; am I old guard falling behind? The answer is probably yes. &gt; ignoring the middleware fads Middleware is a standard software pattern. Calling it a "fad" is probably disingenuous. From my perspective, I think the biggest issue here is that you are willfully choosing to "live in a bubble". I have to assume that you don't have co-workers, because one of the benefits that you get with modern PHP (Composer, frameworks, etc) is the ability to collaborate more effectively. What would you do if you suddenly had to change jobs? There isn't much work for PHP developers that have zero experience with modern PHP practices.
You're not F'in crazy, you're just taking a minimalist approach. I'd seriously consider incorporating composer, though. With your current approach to dependencies, you might miss out on security updates. Also, depending on how the project is structured, you may improve performance with composer's on-demand autoloading.
I don't think you're crazy but this is incorrect. &gt;I do not like the concept of giving other people control over my project, which is really what composer does. Composer doesn't do anything unless you tell it to. You can specify the exact versions of the dependencies you want. If there's an update you can review it with your own two eyes and decide if you want to update or not. There was a time where I was "afraid" of Composer as well. But then I started using it and its value became apparent, especially when you can utilize it with private repositories, which I'm sure like yourself, are kept in personal GitHub/Bitbucket/Gitlab/etc. repos. I assume you "version" your classes/libraries, no? I don't use many of the modern frameworks either; I tend to use Slim only and build upon it what I need.
You cannot use `throw` as a replacement of `die()` in the infamous `or die()` either. I think it has something to do with the return value. Given you can use `print` in a ternary but cannot use `echo`, the assumption seems legit. 
I see where you're coming from and a former version of myself can definitely relate, but it sounds exhausting and so anti-productive. I understand your concerns about composer and whatnot, but there's also something to be said about a whole community providing bug fixes and patching security vulnerabilities that you're missing out on. At some point, if you want to spend your time actually accomplishing something, you have to relinquish some of that control and trust that the building blocks that the community provides are worth using.
Whoa. This is pretty much what I do, too. I landed here after realizing that if I'm going to do all this stuff by myself, and also try to keep server costs low, I need something that's easy to follow, easy to maintain, and requires no more resources than necessary. And I've also wondered if I'm insane for doing it this way--this "barely there" framework--even though it's worked like a dream for five years now, on all of the projects I use it for.
&gt; these modern frameworks (Symfony, **CodeIngiter**, etc). eh... &amp;#x200B; honestly, imho PSR is good for very specific edge cases (basically half of the standards), autoloading and code style. 
At the end of the day I rely upon **a lot** of 3rd party dependencies. The nature of this application and how it is deployed (on small devices provided to the customer, believe it or not!) basically required me to fork a small Linux distribution, change up how it's compiled in several ways and what not. At the end of the day even libc is a dependency when you go up the chain far enough. So I need to have trust in dependencies period. At the end of the day in order to gain that trust I need to do some review into the dependency in question, whether or not it's a PHP dependency or compiled package in the upstream Linux OS. As far as I know composer gives me the newest versions when they're published. That's a big no-no, because it eliminates my review period. Then I need to hope there's no API changes that will break my existing code. If there's a better approach I'm certainly open to hearing it.
&gt;I'd seriously consider incorporating composer, though. yup, can't agree more. You don't want to write your own PDF export. You don't want to write your own implementation of Sentry either.
I beg to differ. I am supporting this code just fine. It's kind of slow going and doesn't mean an extra employee on my team wouldn't help.
What Composer does give you is the ability to chose which version of the dependencies you are using. You can chose to have the Composer packages locally instead of referencing an online repository (Github mostly). I use Composer for my own utility libraries. That means that I don't have to touch any PHP include paths, copy the utilities around or force all my projects to use the same version. The fact that you can indeed use Composer recklessly doesn't mean that you shouldn't use it :) I am not going back to the olden ways. I know that a Composer package behaves in a certain way. That helps me to stay productive, and in control. I use it sparingly, and I do not have any Leftpad-libraries in my 'vendor' directory. &amp;#x200B; Finally, one thing that I also like about Composer is that the dependencies are tucked neatly away in the 'vendor' directory, linked to specific versions as indicated by my Composer configuration file, and is just read-only and not part of the project - it is generated. I also like that there is no global location of PHP libraries - everything is local to whatever project I am in. &amp;#x200B; You can use Composer and still be an old fart with full control :)
I'm ok with you getting out the cave an encountering a whole world outside. We all feels like this sometimes. &gt;I do not like the concept of giving other people control over my project, which is really what composer does. But with this statement. I can't disagree more with you. You still need to understand that the outside world is not there for hurting you. If we were taking this statement as example, we won't be using Linux after all. So please, please, ok you're out of the cave now... but don't take all you've done inside as the best example of doing things. You've survived, you're a survivor!. Now enjoy the open world and its advantages.
That's very fair, and for certain use cases I can see the appeal in that. Right now this is just me, but it won't be that way forever. When I do hire engineers to join the team however, they need to be exactly that, engineers. They will need to be able to go beyond PHP because while that's what the main application is implemented in, there is a whole distribution of embedded Linux and other things involved to make this device "just work". I am not at all interested in hiring fresh-out-of-CS grads or offshore teams. Sorry if I offend anybody here, but if I want the quality of an offshore dev team, I will just scoop up my dog's droppings and commit them to git. I am not at all saying I give a through, in depth, line by line review of every dependency. But I do certainly skim through them and have a list of things that I look for that will pop out fairly easily.
Fine but slow? You probably spend a lot of time reinventing the wheel tbh.
&gt;But at the end of the day you also rely on PHP, which is just another 3rd party dependecy. So it's also a bit hypocritical in my opinion. And Apache/Nginx And MySql/PostgreSql/MongoDB And Linux/Windows And the user's browser And a myriad of code in between To be paranoid about using open source dependencies in your project and just pretend all the rest is fine silly. 
&gt;As far as I know composer gives me the newest versions when they're published. That's a big no-no, because it eliminates my review period. Then I need to hope there's no API changes that will break my existing code. If there's a better approach I'm certainly open to hearing it. &amp;#x200B; For what it's worth, Composer will only update your dependencies when you run `composer update` in your project, and you can easily 'lock down' the version it will update to at a per-package level using `composer.json` \- see [https://getcomposer.org/doc/articles/versions.md#writing-version-constraints](https://getcomposer.org/doc/articles/versions.md#writing-version-constraints)
&gt;As far as I know composer gives me the newest versions when they're published. Wrong. If you add new dependencies without any arguments, yes, you get the latest version available at that time. Composer generates a lock file containing all exact version numbers you currently use. Those will only change by running "composer update". You can also tell composer that you need a specific version at all times. The packages are usually downloaded from packagist.org (distribution versions) , so you have to trust them of course. 
I do love package managers in concept. Let's use two of my dependencies, dompdf and php:ipp. I ship both of these as packages for the operating system, installed into /usr/share/$PKGNAME. I do this not only to separate it out from my project itself, but also to assist with LGPL license compliance. I should also note that I see the point with public git repositories but should also note that my application is proprietary and will never see the light of day on github :)
Composer lets you specify what version you'll accept with pattern matching rules. You can have anything between "This exact version I've tested" and "Whatever the bleeding edge is". I've found that most PHP libs I depend on (Symfony components, mainly) are really good at sticking to semver. This lets you specify that you'll accept bug fixes, but not anything more. Or you'll accept bug fixes and new features, but not API-breaking changes.
Do what works for you. But don't ignore stuff just because you think it's middleware bloat. It all depends on what you need to get the job done.
Umm okay. Most node.js applications I have encountered run server-side. In addition, there's almost always vast droves of user data to be stolen on the server side in most applications. My prior dayjobs were always within systems/network engineering. Today I am my own boss; if this venture was to fail I would probably go back to the Systems world that I know :) - but planning for the future and betting on success I will (as mentioned in another comment below somewhere) probably be hiring additional engineers and devs. But if I hire engineers they have to be actual engineers capable of going outside of their "comfort zone", because there's a lot more under the hood than just a PHP app involved.
I would implement Composer and convert your modules to composer modules. You can host it in private repos too. Alao maybe use a lightweight router. Other than that you’re fine. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Dunno what the issue with composer is. Most modern programming languages use a package manager for dependencies: Maven (java), Gems (Ruby), Pypi (python), Composer (PHP), NPM (NodeJS), Nuget (C#), CPAN (perl), etc.... Granted, some package managers are smarter than others (see NPM and it's ludicrous decision to default to wildcard version numbers), but it's a very common practice and it's not really much different from using yum/apt on your linux OS to install a package. 
Forking a linux distribution for a web app? I'm not sure what your app is doing to say what is necessary, but I can't imagine anything that would require that level of customization while still using PHP. How do you react to security vulnerabilities in linux? There's literally a new one every week, I couldn't imagine trying to keep up with that load just to support a single application. 
If you plan on working alone the rest of your life, everything is fine. If you don't, you're probably setting up yourself for a huge awakening / catching up some day, which can be a bit dangerous. Like some people said, composer don't force you to give up control if you set it up in the right way. "Fancy URL routers" are probably over optimized in your case, but why maintain something that already exist elsewhere ? You can choose which symfony component you need. PSR1 and 2 are probably going to be used everywhere in the next decade (or more), why not take the habit now to gain time when you'll join a project where they are mandatory ? "Coding" for me is mainly being able to work with large group of people seemlessly. Most of the time, the solution doesn't have to be perfect, but it has to be perfectly known and understood by all people involved. Some companies choose their tech stack because they know they will be able to recrut tons of people proficient in it and sustain a huge growth.
Go answer questions in stackoverflow, php. There are insane amount of easy to hard questions to answer (and learn) from.
You're not crazy but you *do* have a bit of a tinfoil hat attitude. I also suspect you have a hard time working with others, or even finding others to work with. Relinquishing some control is not a bad thing, you know. You need to trust other devs to do their job. Your code is likely not the best in the world, and to be extremely honest the fact that until recently you've never even heard of PSRs (even though they've been a mainstay in PHP for almost 10 years) makes me question what else you've missed, what best practices you're not adopting, what wheel you are reinventing. Let them in. It's not all bad out there 😉
I use a lightweight router. It is a class maybe about 60ish lines long. Say you provide /about/system It looks for $PRJDIR/code/about/system.php, $PRJDIR/html/about/system.tpl, executes the code, and outputs the (then completed) template. If system.tpl and system.php were to not exist, it would go up the chain next to about.php/about.tpl and pass '/system' as path info. Up to the page code itself to decide to accept that or 404 as needed. It is very simple; why would I want to use routers based on some SQL queries or complicated switch statements when I can use my already existing file system. This is why we have a file system.
&gt;As far as I know composer gives me the newest versions when they're published. it gives you whatever you configure to give you. that CAN be the newest version, or one very specific version, or the newest version following certain constraints, etc...
but they could theoretically change a package while keeping the same version number, couldn't they? is there any way around that?
Composer lock files are auditable by sensios security scanner. It doesn't cover everything but it helps a lot. You cannot possibly audit every single line of code in a modern web application manually. So yeah, you're kinda behind the times.
Correction: it does support expressions. What it lacks is \*statements\* and \`throw\` is a statement.
&gt; At the end of the day I rely upon a lot of 3rd party dependencies. The nature of this application and how it is deployed (on small devices provided to the customer, believe it or not!) basically required me to **fork a small Linux distribution**, change up how it's compiled in several ways and what not. At the end of the day even libc is a dependency when you go up the chain far enough. [emphasis mine] This is TempleOS crazy. 
I work in a team of 8-12 developers. We have a lot of code that is either no-framework or custom-framework. And it's a f'in nightmare. Every task I work on I have to reverse engineer another developers "simple, clean" abstraction that doesn't follow any traditional standard, and get used to their particular way of formatting code and including dependencies. My time to fix a bug or deploy a feature looks something like: * Setup environment 40% * Reproduce issue/Find code to be changed 30% * Write code 5% * Test &amp; Deploy 25% Imagine if all our apps were standardized... The time to setup a project and reproduce the issue drops dramatically. Productivity increases. Everyone wins. This is why standards exist. You cannot scale teams without them.
I think that is possible, yes. I never published a package myself though, so I have no experience with that. 
I agree, this does seem possible.
I'm going to be honest and say that you're falling behind. Not because you're not using newer technologies, but because you don't seem to be even aware of the more well established technologies an their benefits. For example, Composer has been around for more than 7 years, it's not a fad. But it can still integrate into your current workflow of manually approving updates because you commit your lock files. You lock your packages to a certain version and if you want to upgrade you can review the code and simply not commit the updated lock file if you don't approve. But on the other hand it allows for a much easier way of performing the updates you want to do and there's even ways to have composer run security checks on your dependencies for you, so you get notified if your dependencies are out of date. Similarly, PSR's don't have to be used but they're more than "just let frameworks work together", they're also useful for making interchangeable code. Say you've got a logger, rather than coding directly against the logger you can code the PSR-3 interface and if you *want* to change your logger in the future, you can pick one that follows the same interface. PSR's aren't just for framework developers, they're community standards so that when you develop against them you know that you'll be able to change to a different implementation without too much work. In programming it's almost always a case of "Use what you know" and "As long as it works, it's good", so I'm not suggesting you jump on all of the new fads and frameworks. But you're also ignoring standards that have been around for half a decade or more, not bothering to learn about how the community itself is changing. I'd recommend at least learning about the new standard practices and tools, even if you don't end up using them. Especially if you plan on hiring other engineers in the future. Quite a few of the changes in the ecosystem have evolved to help develop more easily in teams, and you're doing yourself a disservice by ignoring them altogether
It was only for an example.
Your post reminds me a lot of the former team lead and manager my company used to have. He insisted that we do everything ourselves, not use frameworks and build it "right". Said we were all very talented engineers and could do this better than others. And while in some cases, that might have been true; it turned into a nightmare. We spent far more time creating, maintaining, and fixing issues with some of our components than had we of just used composer. So instead of focusing on writing code that needed our subject matter expertise, we instead were making wheels that we could easily find other places. When that team leave left the company, we finally started to pull in items from composer which has freed up our resources. We are spending far less time now on code that is generic, and spending much of our time on code specific to our company's needs. This means that even though our team is half the size now, we're actually putting out more benefit for our company. Just because you can make a "better" wheel, doesn't mean that getting one that does 95% off the shelf isn't a good idea. Spend your time and energy on what your company specializes in. 
That's the word I was looking for. Fixed, thanks!
I think that /r/PHPhelp is a better place for that question but have you tried `hash_file`? https://www.php.net/manual/en/function.hash-file.php
You sound like a nightmare to work with. You're probably completely unaware based on the tone of your post. I'm not saying that what you're building won't work for most basic websites and stuff, but every piece of tech you refuse to adopt means you miss out on one new subset of features that makes modern dev much better than it used to be. I am a senior/lead dev (been programming for 15+ years) and I started in the PHP3 era as well. Modern frameworks, tools, and methodologies are MUCH better than what you're using. Yes, what you're doing will still work, but I COULD build an entire house with a hammer and a hand saw. I don't do that because we have electricity and power tools now.
I totally agree with you on all counts. The modern frameworks seem overkill when I can write my own router and controller in a page of code. And I hate the idea of composer / NPM changing the code I am linking against without me knowing. The new code could do anything! In my fustration I'm writing a full blown framework that does away with these concepts. Rspade, it's going to be cool, you heard it here first :)
I have found that quality of code isn't represented by how many or few lines a product has. 
The thing I found about stack overflow is that they tell you there answer is better but not really why but your right I will try and do more stack overflow stuff!
I understand your approach. I personally still support few 12+ years old php applications which use "custom framework". There is some underlying expectation that everything which is old is bad. Well, the truth is that those applications are like some animals which evolved many millions year ago and are considered "unsophisticated" - but they work just fine and will most likely outlive many other species. There is just no point in rewriting those applications. Something which was developed (more or less intensively) for many years cannot be easily recreated. &amp;#x200B; Also, the more advanced framework (like Symfony4 or Laravel) the more freedom they give to developer. They try to give you some tools like routing, autoloading, templating mechanism, maybe ORM - and then let you write your business login the way it fits best to your needs. So, why frameworks are cool: &amp;#x200B; \- if you don't already have your set of libraries which do what you like, then it is way faster to use ready framework- if you work in team, then of course it is easier to build in some recognized, documented system, which also has its own set of best practices. \- if you are a company owner, you really would prefer that some important systems can be maintained by more than 1 person in the world Frameworks drawbacks: &amp;#x200B; \- they become outdated. So instead of having old code- but own - you can end with dead framework, and it is way harder to maintain dead framework... \- they are very general and often bloated. You need one thing, but you have to learn 10 others offered by some library just to do that one. \- "best practices" often do not fit some specific needs. Sometimes it might be way better to write simple PDO query instead of using ORM like Doctrine. Sometimes it would be way faster and easier to just user curl or even file\_get\_contents with url instead of installing and mastering whole HTTP library. &amp;#x200B; Few days ago I created some simple admin panel for small customer. I didn't want to turn few-pages panel into fully bloated Symfony4 application. I didn't want to learn some other "micro" framework just to do that. So I just used composer to provide nice autoloading (no real dependencies other than composer). My templating engine looks like that: **public static function** render($viewFile, $data = \[\]) { $pathToView = ***\_\_DIR\_\_*** . **'/../templates/'** . $viewFile . **'.php'**; *extract*($data); *ob\_start*(); **include** $pathToView; **return** *ob\_get\_clean*(); } And it does its job. Similarly with Controller or Database. &amp;#x200B; &amp;#x200B;
I will disclose there's a lot of reasons I never wanted to ever take a track into management. What gave me the balls to say fuck it and go into business for myself is beyond me. But now I am the boss and yes you are correct in pinpointing some personal traits I need to work on before I hire on additional people. With that said someone I hire myself into my organization, on my payroll, will get a significantly larger amount of trust than an open source contributor halfway across the globe I have never spoke to personally. When you take the finished product, the appliance running my software placed into the customer's hands, there is the work of thousands of people on that tiny little machine. And I thank all of them for their contributions to the OSS world. I am running a very delicate balancing act. This specific product requires a lot of attention to security concerns and data privacy that 90% of PHP applications will never need to think about. The laws in regards to the industry I target are almost certainly going to change in the future and become more stringent and I would not be caught off guard if this had to be subjected to rules similar to HIPPA. I can tell you right off the bat my code is not the best in the world :) - but it is also not the worst in the world and it is fairly easy to read through and understand once you understand the underlying structure of the application. Yes I have spent time re-implementing the wheel, but honestly that time was years ago. If I'm doing anything to 're-invent the wheel' *today* it is for a good reason. I really do try to stick to what PHP provides out of the box as much as possible (despite how ugly it may be).
Sorry for the wrong sub. Yes I did `$hash = hash_file('sha256', 'pdf.pdf');` but the result is not the same of Dropbox. I think my issue is I don't understand how Dropbox generate their hash. It's explained [here](https://www.dropbox.com/developers/reference/content-hash) but I think I'm wrong.
Use whatever works as long as it's secure, but you should know that people using these newer tools and systems can do what you do much faster, much easier and with much more assurance of security, compatibility and future-proofing. Your way of doing things isn't necessarily *wrong*, but it is behind the rest of the industry and if you're planning on reaching out to find more work, you'll only find it from people too ignorant to know better and you're doing them a disservice by leaving them with that kind of codebase.
I am going to go slightly off topic here: &gt; Say you've got a logger, rather than coding directly against the logger you can code the PSR-3 interface and if you want to change your logger in the future, you can pick one that follows the same interface. This is a great example of where I feel there is "framework fad" and over-complication. I have a great logger already. It's built into PHP and my operating system. [It's called syslog()](https://www.php.net/manual/en/function.syslog.php) and this old fashioned syslog thing is probably older than I am! The problem with syslog() is that it doesn't work great on shared environments. But let's be serious here, who's not deploying things on dedicated VM's these days? Or another thing that I partially find a 'fad' - containers (useful in the right ways, again, where you trust everyone who has access to the containers). Since most people are moving towards microservice models and you're probably piping your syslogs into splunk/elk/newrelic anyway, this old beast is even more relevant and useful than ever.
&gt; So am I old guard falling behind No offense, but yes, your practices are severely out of date. I'm usually of the mindset of "whatever works", but there are valid reasons why package managers like composer and frameworks like symfony should be used.
OK well in my defense, your first line of 40% of time in my project is handled by: make buildenv on any fresh installation of Alpine Linux. Run that, grab a coffee for 5 minutes and you're ready to roll.
I don't like the electricity controlling the speed of the drill so I just use a screwdriver...
you're stuck in the past and using inferior technology
I've got the same background as you. Started on PHP3 in the 90s, spent half my career doing sysadmin stuff, and most webdev was fully custom built without frameworks. You sound a bit behind me in catching up with modern practises though. I've been using composer about 5 years. And largely switched away from PHP last year, after doing every in PHP for 19 years. Who knows how many security fixes you're missing by not using composer. Sounds like you've mostly already made up your mind though. You don't seem to be too interested in anything that doesn't support you sticking to your comfort zone, and the reasons you tell yourself as to why you're stay there. If it works for you, then I guess you're happy with it. What was the actual goal of this thread? Do you actually want some advice on what you should do differently (happy to give some if you actually are interested)? Or just looking for validation/debate? 
No Discord, but feel free to PM me.
Stop trying to fit the whole application into one line.
Agreed! The 60ish line statement was made just to show how little implementation is on the PHP side vs. what is relied upon from native facilities (ie: the file system).
What got people discussing PHP hate in this thread? I'm confused because all I see is a link to a Superman website.
As I posted elsewhere, you're framing this as a good thing and a conscious choice for a better environment. Let me be clear. What you're using and building with is **not** better than modern PHP developer flows. Will it work? Absolutely. Realistically, I could build most of my clients work in old school PHP using old tools and practices. But do you support stateless APIs so your clients can expand to mobile/SPAs (this is all we build now). Do you support JWT auth? Do you support automated testing, deployment tests, and integration tests? Do you support a CI pipeline? Let me put it this way. I work for a large agency with a bunch of enterprise clients. If you interviewed here, you might be the least qualified candidate to ever walk through our doors. I'm not trying to be mean, I'm just trying to open your eyes to the fact that your stack and tech are not what large clients will accept in the modern age. If you're sticking to basic sites, WordPress, etc then you're fine. You can keep FTPing onto a server, you can use shared hosting, etc. But if you want to join the big leagues, you need to absolutely get with the times.
&gt; This is a great example of where I feel there is "framework fad" and over-complication. In my opinion this is kind of a narrowminded view. `syslog` is great if you just want to log to, well, the syslog, but it's not a great solution for all use cases, not out of the box anyway. The last few companies I've worked at have all used external logging tools for good reasons. Giving developers access to logs without giving them `ssh` access, allowing tools to monitor how often a certain error gets logged, detecting when an error is a regression, having better filtering, being able to send out email alerts on certain errors but not others, aggregating logs from multiple servers and many more features. There **are** ways and tools to scrape from syslog to upload to external tools, but why? Why not just send the logs to where we needed them directly? But you're right, not all logs needed to go to external tools. Some small projects were fine with `syslog`. That's where the beauty of the PSR came in, rather than having some projects calling `syslog` directly, and some calling, say, Sentry, we just had all of our code calling the same PSR-3 interface. Then for some projects that interface literally could just do a `syslog`, other projects they could echo out to terminal if we were running it as a command and other projects still we could log them to an external server. And we could change them around as needed with little to no effort. Even in your workflow, thanks to the PSR-3 interface we could have taken any of the frameworks we were using (We used Zend, Symfony and Slim as a microframework) and just inserted a very short 15 line class that said "Anywhere that calls this standard log interface, log to `syslog`). Rather than each dependency deciding how and where it's going to log, they rely on an interface and **you** tell them how they'll do their logging. It's literally about your dependencies handing control over to you. `syslog` might work for you, for your current needs, but that doesn't mean that it works for all use-cases, and it doesn't mean that more involved logging methods are over-complications, it just means that you don't have a need for them right now. You seem to think that newer tools and standards are just young engineers coming up with solutions for problems that either don't exist or have been solved by things that young engineers just discount because they aren't new or shiny. They're not. They're made by people who have been around this block a few times and try to make solutions that work for everyone from the small one person teams to the large 50+ multi-team project. It's not a group of fresh faced newbies trying to change for the sake of change, these are made by industry veterans who know and appreciate the old ways of doing things, and the tools and standards are there to *compliment* those ways.
Thanks man! Appreciate it!
This is what stubborn people like this don't realize. They waste so much time reinventing the wheel so that it can rotate the way they like it. Meanwhile the rest of us are building actual shippable software because we didn't waste our time on pointless things. In between jobs a few years ago, I had a very short contract one time with a guy who rolled his own framework from pieces of Codeigniter + Eloquent. It was awful. Everyone working on the project told him it was awful. He refused to listen and insisted it was brilliant. He went out of business a year later and was hitting me up for a job. Some people just don't want to listen.
I agree with your sentiment. For the same reasons, I wrote my own operating syste... &gt; I have never seen my application (along with it's associated Linux OS built specifically for the application) Yeah, you know what? There was going to be a poignant joke to follow, but I think the point would be lost anyhow.
I am one person with Steve Jobs syndrome. The point of this thread is to solicit honest feedback from others in the community. Yes I am pretty opinionated but my mind is not at all made up. The answer to the security fixes question is zero. I take the manual approach that I have to take with all of my upstream dependencies (Linux kernel, musl libc, other libraries, PHP itself!) by subscribing to mailing lists and new release feeds and manually checking in periodically if those are unavailable. I will state that other comments in this thread has opened me up to composer. I have two "major" dependencies (dompdf, php:ipp) and the other 2 are small little classes. Those two major dependencies I ship 'out of tree' by manually creating a system package for them. I do this because they're LGPL. My 'special sauce' software is all compiled into one .phar file, so I need to avoid injecting any (L)GPL code into that package.
While I generally agree, I don't. I've been building applications on my own in a professional capacity for 20 years. I build frontend, backend and all server deployments... I know that this isn't usually the case, but I do it. "Modern" development is quite frankly becoming overly complicated for very little benefit. You can pick and choose the level of complexity you wish to support, but if you choose wisely you can do this yourself if you're a competent and diligent developer.
This is a technical question about the interpreter, but I also think there's nothing wrong with making one's code more compact so long as it doesn't impact readability.
I'm with you. I feel like there's a lacking of fundamentals with everyone depending on all these frameworks for nearly literally everything. They put legos together, but they have no clue why anything works.
Yeah, I have seen countless times at my Job of people developing small systems that they spend eons on, just for it to do something simple. A lot of people do it under false pretense that it's making them indispensable. "Only I know how this works" Is the mentality. Of course like you say 99% of the time the software produced is crummy. 
Not crazy, but you're doing your own thing for your own purposes... But if you're part of a team, you need conventions and standards.... Doesn't matter how awesome is your language if no one understands you.
&gt;going outside of their "comfort zone" Sounds kinda ironic in this context. You seem to live in your own comfort zone - quite frankly - for way too long yourself? You might be right with some sentiment, but I can't imagine how any additional engineer and dev will be happy working for/with you and vice versa with your point of view that's so...outdated.
Do you write your own validators? SMTP handling? Handling of bulk inputs? ETL? HTTP interaction? Cause that's what the libraries are for. 
You are missing step 3-4 in their instruction.
I don't know about Composer, but *most* package registries prevent republishing under an already-used version number, thereby preventing modifications of packages without changing the version number. Lockfile implementations also generally include a hash, which further protects from even the *package registry itself* serving up a modified version. Again, I don't know whether this applies to Composer, but it does apply to npm and Cargo.
&gt; I've been building applications on my own in a professional capacity for 20 years. How's doing an app you built 5 years ago?
I would never join your team :) You basically want to hire bright people then close their horizons and force them to work on one technology/approach for as long as they are with you. Are you aware of the rise of the expert beginner ? [https://daedtech.com/how-developers-stop-learning-rise-of-the-expert-beginner/](https://daedtech.com/how-developers-stop-learning-rise-of-the-expert-beginner/)
From a less technical perspective: because ternary if is for setting values, nothing else.
Yeah, they calculate it in different way, check https://stackoverflow.com/questions/53093840/how-do-you-calclulate-a-files-content-hash-for-use-with-dropboxs-api if it works ;)
You're in the past, imo. Still time to catch up though. Composer packages are tested solutions to common problems. Unless your code is unit tested with high coverage, "your own two eyes" are probably insufficient. Since they are open source, they're checked for security and more hardened. Psr are a set of standards that we can program against. It's way better than having 10 different event listener systems all inoperable with each other. It sounds like you're just defending your lack of knowledge. Instead, google "php the right way" and join the community 
Support list (in order you wrote): Yes, no, yes, partially, partially, and "yes". Would you consider my home grown "CI pipeline" of building everything, deploying onto a VM and running some tests on that, via makefiles on cron job a CI pipeline? Probably not. I have no desire to ever spend my time writing PHP (or any kind of code, really) for another company. I am doing this to bring an idea of mine to address a real life problem into a product that provides 4 digit monthly revenue per implementation. I will go ahead and tell you that I haven't touched FTP in many of years nor do I ever use shared hosting. I can also tell you based on your post, that your large agency is probably an awful culture fit for me and anyone else who values their sanity, personal dignity and time outside of work :)
That was another one I was going to ask about, because I feel like I've seen similar syntax to the following in another language: $someCondition || throw new Exception; I can't remember which language though. 
That middleware-fad is just a terrible hack born from Laravel community. Yes, you should ignore it. It's a bad fix for a shortsighted solution of a misunderstood problem. As for the rest of things you mentioned: - normal developers should only care about PSR-1, PSR-2 and PSR-4 (maybe also 3rd, if you use Monolog) - you really should use composer, because your 3rd dependencies can have bugs and vulnerabilities = it lets you keep them up to date - routers are nice, there are several good stand-alone one to pick from on Packagist, and you can review their source for piece of mind - look into DI containers (proper ones, not the service-locator abominations) - for templating these days the "default solution" is Twig, check it out, it's decent and standalone - I suspect you are not using autoloading and might be stuck in include-oriented programming paradigm
I feel like I'm getting cancer reading this article.
Here’s what no ones saying: if it works, don’t change it
Well, PSR-0 is knocking on ten years old now, so you may just have been left behind a teensy bit.
I used to watch peachpie closely because i wanted compiled php. Now that we are getting JIT in php 8.0 the only reason I think for this project is for the interoperability with .NET Core/C#. But again having FFI coming to php I don't know even if that case is valid.
I should probably clarify that I do use upstream dependencies that you could get from composer and do keep them up to date. So it's not like I am losing out on any security and hardening because I am still using the same upstream code in the end. I do need to just go take my dog to the park and sit down for an hour or two with some of the docs on composer honestly.
I'm not even sure why you made this post. You asked if you're crazy, everyone told you yes, then you ignored everything we said while swearing you're right. I've met a ton of developers just like you. They are always confident that their way is the right way, right up until they go out of business or nobody wants to work with them anymore. All I can say is good luck. You'll absolutely need it. &gt; I can also tell you based on your post, that your large agency is probably an awful culture fit for me and anyone else who values their sanity, personal dignity and time outside of work Haha, I understand that you're upset about being called out by dozens of people on this thread, but you couldn't be further from the truth. My company highly values work-life balance and I have an amazing schedule with amazing flexibility. I got here by working hard and by keeping up with advancements in dev. Though I do absolutely agree, it would be an awful culture fit for us to hire a developer like you. You use outdated technology, you ignore the advice of those better qualified than you, and you don't listen to feedback **even after asking for it**.
You just haven't encountered the advantages. If I pull in several third-party packages, they may all need to log things. If I can give them a PSR-3 logger, then they just do their logging without a care for where it goes. Where is goes is up to me, not the third-party packages.
Everyone else has delivered actual constructive criticism that I have been happy to hear because it does help me to plan for the future when this grows to require additional people. It helps me think of how to structure this for a 2.0 when there's the time to spend cleaning things up. So I am very happy to hear the dozens calling me out (and the others who seem to agree with me). Nothing is black and white except for this: the only person in this thread I am upset with is you. I am not upset with what you have to say, I am upset with the toxic attitude that you deliver it with. 
I was in a similar boat as you and had the same viewpoints once upon a time. It sounds like you're working by yourself, which is fine but it gives you a very narrow-minded viewpoint and stops you seeing the bigger picture, I know I've been there. I will address some of your points and how I came to change my mind: &gt;I don't use any of these modern frameworks (Symfony, CodeIngiter, etc). This is absolutely fine, you don't have to, however, they come with a lot of stuff already built in. I too wanted to create everything from scratch at one point then I released just how hard that is to maintain and todo to a high standard. Sure you might be an amazing programmer and can critique your own code amazingly well for bugs and security issues but is that going to be better than 1000s of people doing the same thing over one piece of code? It's very unlikely. Having your own framework is 'okay' but the biggest issue will be documentation when others come to use it. Any issues that arise the developer is basically out in the cold unless they can contact you for support when a lot of the common problems will have answers with a quick google for the popular frameworks. &gt;I don't use composer. With my current project I have about 3 dependencies that could in theory come from composer. I do not like the concept of giving other people control over my project, which is really what composer does. It doesn't. Composer only does what you tell it to do. You say you have dependencies already so I assume you download them and add them to your project manually. This is fine when you have a few projects but doesn't scale when you have multiple projects, the amount of time needed to upgrade each project every time a new security patch comes out it would get out of hand very quickly. You will more than likely have different versions of dependencies across different projects, a nightmare for maintainability. &gt;Instead of this I download my dependencies by hand when they have an update I wish to have, **review the code with my own two eyes**, and then place it into the relevant include/ folder where it belongs. Nothing here changes with composer. The code is still open source and you can view it in just the same way. The only difference is that its composer making the download request rather than you going out to the internet downloading a file or a zip and then putting it in a folder manually. &gt;I seen "PSR" referenced the other day here and honestly had no idea what they were talking about and had to Google. This is just a recommendation you don't have to follow it and is totally optional. However, following some of the standards when making your own packages/dependiences is a good idea as you know it will most likely work well with other packages. &gt;So am I old guard falling behind or properly ignoring the middleware fads here? Middleware is hardly a fad, it's been around since the 70s (60s?) and is a very established and tested pattern to follow in software engineering. In short, it took me a while to adapt at first but now there is no way I would ever go back to my old ways.
but let's be real: he's crazy ;)
Ugh, let me be honest here. No, there's no private repositories of small libraries or versioning on them or the upstream class libraries (I refuse to call it a framework at this point anymore). Everything is in tree. Everything. One git repository contains the application, the makefiles for the corresponding Linux distribution, the docbook documentation, corresponding build/test scripts, and the small little thing I use on my server for licensing. It is unfortunately very large and kind of ugly. It probably does need to be split into at least 3 different repositories. But it does come with the advantage of having one thing to clone, and one makefile to build **all** of the parts, sign it, and assemble it into an ISO for installation onto a hardware device.
Totes.
Come on, capitalisations is the *least* problem of this pathetic article. 
I don't want to bash his hope making an article. One at a time man. Easiest first, then we talk about more later.
Actually, https://codereview.stackexchange.com is what exactly you want. You are more than welcome there! 
&gt;Middleware is a standard software pattern. Calling it a "fad" is probably disingenuous. Yes, but that doesn't make it a good one. Don't forget we have lots of "poor" standards, even ISO ones. Most middleware patterns do not work at the correct level of abstraction (imo), and only really shines if you are doing incredibly simple things. And if you are doing such simple things, the middleware just makes it more complex. I agree of most of the rest of what you said.
No CSRF. No prepared statements, just dropping user input directly into queries. No password hashing. Using the root mysql user with no password. It's like you *want* to be hacked. Nobody should be taking any advice from this site and the author should be ashamed of themselves.
There is absolutely nothing to talk about. This pathetic spam is not salvageable. The faster mods will remove it the better. I wish we had real mods in here, not a herd of half-dead sloths we do.
After seeing numerous replies, I have concluded that you are too stuck in your ways and you're not really here for advice even though you say "You haven't made up your mind". I have been working as a php programmer at least as long as you have and I have learned to adapt to the changing ecosystem. You don't want to. You are stuck in the mentality of "Damn these kids and their new fangled shit that I don't understand" You are scared of change. Everyone else has moved on, and you are still in a horse and buggy. 
LOL, no, it is not *quite* TempleOS level crazy ;) Yes, I have to keep on top of vulnerabilities. I have to keep on top of them anyway, at least in knowledge form. But I am not the only one doing this, the upstream distribution Alpine Linux is also still doing that same task. Here are the stats: I use about 70 packages. About 5 of them have their ./configure arguments changed from what Alpine ships. 2 of them have additional patch files added by myself. Outside of those 7 packages, responding to a CVE is as simple as taking the aports git change from alpine and applying it on my oob tree.
This article should be taken out and shot.
Most Node applications consist of both a backed server and a frontend application "compiled" from the same sources. The most risky part is the frontend bit, because every single user of the app will be exposed to whatever gets packaged into it. That is the vector that bad npm packages target.
Here is their answer to similar criticism: &gt; why not follow ?? its has basic php login program tutorial program or but it has basic or starting medium or tutorials .. i know when you run website then you have store password in encryption mode or encrypt password in database... basically in past i use md5 use.. and this is not good you have why not follow ?? its has basic php login program discourage me on programming &amp; Blog .. I Will update the blog or create another blog..thanks for comments..but you loose my some confidence... Honestly they hardly can speak English. There is no way to communicate
It is a "web app" but it is not. The application is shipped on hardware appliances to my customers and ran directly on their local networks. The application handles very sensitive data. The data is stored inside of an encrypted ext4 image inside of the main partition. Keys to unlock this are stored outside of the computer itself. There is a very fancy web UI for technologically dumb people to very easily manage this.
I get a strong feeling the author is Indian based on the code alone.
Composer uses lock files to make it so you can always have the same version of the software until you're ready to update. Most software also follows semantic versioning so you can align your software with patch releases to only get fixes and not breaking changes. There are plenty of small frameworks already out there. The goal of a framework isn't to be a small number of lines, it's to provide common features for an entire target audience. Relying on dependencies allows you to focus on the parts of your code that you're well-versed with. It's very rare for someone to be well-versed in everything that a framework offers.
Not to be rude but unless you're hiring an old-hat php developer like yourself you will not retain staff for very long. There's so many developer jobs out there that being asked to work on (what an up-to-date dev would call) a clunky system is going to make them want to walk away. I get the worry over composer, I really do. I'm not aware of any well know cases of any back doors, but I'd be surprised if there were none. That being said the benefit of packagist is being able to see popularity. With the larger packages it doesn't take long to see the commitment, often backed by large businesses. Monolog for example is perhaps one of the most widely installed php packages and it's backed by Tidelift, and as it's so widely used is extremely well watched. I assume you're familiar with git and pull requests. Imagine someone trying to push through a dodgy pull request to a project with that many eyes on it. It just wouldn't happen.
Doesn't the "I don't use third party stuff"-attitude make it hard to collaborate with others? I assume that the things you use are less well documented than most of the major libraries out there. Maybe you work alone but I would say that the main reason I go for the more well established frameworks and libraries is that I can communicate with other developers. It also eases my work when it comes to training junior devs since a lot of their questions are already answered by the online community. Maybe this is not an issue for you but I would love to know more about how/if you manage these situations.
One other thing to point out. You say you dont like the idea of composer. But what about for your own code? If you're going to reinvent the wheel by writing your own packages, you may as well do it right. Each major component can be divided into a reusable composer component, and then should you so wish, those can be shared with others on github/gitlab/whatever. It then has the added benefit of being autoloaded into your system, all namespaced out nicely and unit tested (seriously if you're not even using namespaces and unit tests at this point then I really dont think you've got a leg to stand on arguing your position).
&gt; That middleware-fad is just a terrible hack born from Laravel community. The HTTP Middleware pattern is not a fad, is not a hack, and did not originate in Laravel. IIRC, the first time I saw it widely adopted was in [Rack](https://github.com/rack/rack). Like many patterns, it's had its share of misapplications - usually when people start cramming domain logic into middleware. But when properly applied in HTTP-centric contexts, it's a perfectly serviceable pattern. 
Can't you execute a `composer install` as part of your makefile? What are you building and why are you even using PHP to do it? What IDE do you use to write your code?
I agree on most points **to an extent**. #Composer I, too, do not use a single composer file for all my dependencies. I do, however, have an individual composer file at a consistent location in each of my modular dependencies, which makes it easy to update (given an array of names, you composer require them in a loop). Of course personally, I don't update until I see need newer features or see there is a CVE for one of the current versions of my dependencies (just checked, no CVEs as of this post!). **BUT** You have to provide that auto-update option to any potential future entities who inherit your system. If you ever intend to sell your system to a client, you can never know who's going to have to work on it. I agree that auto-updating everything via composer is a bad idea, but the option still has to be **available**. Oh, and of course, it never hurts to have a composer file for your project itself if it's a package. #PSRs Also, when it comes to PSRs, there is never an excuse to outright ignore them, again, if you ever intend to not follow them. For example, in my current framework there is a Standards.txt file that states literally all the differences between the PSR and the standards I set in my framework. As an example: "4": { '1-overview': "Autoloading SHOULD be avoided, and instead all neccessury files SHOULD be included manually where they are needed.#EOL The reason for this is because, despite the convinience it offers (and it offers a lot of convinience), I consider the drawbacks to outweight it.#EOL The main one is lack of explicit includes, that would otherwise serve as partial documentation for the file.#EOL A developer that wants to learn the code can go down the include chain, and every external class is explicitly denoted as such, helping code reusability.#EOL For those reasons mainly, and a few smaller ones, I would RECOMMEND taking a few extra seconds to write out includes at the head of each file and the namespaces before each class object/definition, explicidely.#EOL If usage of autoloader is present, then it should follow the PSR." }, This is a divination from that god-awful auto-loading "standard", that is described in PSR 4 (yes there are 18 members in that JSON array). Many of the people here may disagree with it, just as they'd disagree with almost anything else that improves their code but requires their lazy asses to do even a tiny bit more work. The difference between this approach and yours? I would never (let me emphasize - **NEVER**) bury my head in the sand and outright ignore every PSR. Standards are an important part of every system. And PSRs provide you with a way to have those standards without writing 5,000 lines of documentation just for your standards - it's much easier to specify which ones you follow (and with what differences) and extend the system standards with your own than it is to write them completely from scratch. And either way, you **NEED** to have standards in your system. Neglecting to provide them is a serious problem. #Modern Frameworks I know about 4 Symfony components in-depth, and have basic knowledge of the rest of them. I actually intend to implement some of them into my own framework, which will save me up to 2500 hours (probably somewhat less now) compared to building them myself. Not using a modern framework is rarely a choice - it generally works only if your software is single purpose (doesn't have to be extendable). The only real choice is whether you accept a modern framework somebody else wrote, or write one yourself. And I can promise you, even if you go for the latter, you better have one of the following: 1) Have 5,000 hours to spare. 2) Have 2,500 hours to spare AND have a module ready to integrate external components from other OSS frameworks (which you still have to know in depth) - that's more or less where I am, about 1,500 hours in. 3) Have 1,000*(6~8) hours as a self managing team of 6~8 engineers, more hours/people the less competent they are. Either way, refusing to use a framework (or refusing to modernize the framework you're using) is a horrible "solution" (unless, again, you only write non-scaling, single user apps, in which case it's fine).
There is a grey line to toe, and it sounds like you are on the crazy/restrictive side to some degree. Yes it's good to maintain your own code in certain situations. Others it's perfectly fine to install an entire CMS if needed. At the end of the day though, if you aren't using a standard HTTP kernel which is doing routing/response handling you either have a unique app, or you are creating a ton of extra work. I also doubt any single developer is going to be writing more secure code than a tested symfony framework. It's battle tested, hardened, and several years of iteration on an unchanging function.
I am building a complete management solution for the cannabis industry. Initially supporting sales and patient management it will eventually be extended to show TV menu boards, report to weedmaps etc. because of the nature of the business most of my potential customers do not want anything to do with cloud based solutions which is why it’s sold on appliances. I am using PHP because it’s what I know best for this type of situation (not crazy enough to implement this in C). Using anything else would have required a learning curve on my part. Didn’t want to add that delay. I am using a good old fashioned text editor. Vim if my mind is in a good place and I’m being seriously productive. Notepad++ if I’m unwell and being lazy.
It was actually patched recently, but I had around 200 customers effected for a solid hour because of that bug...so I'm staying with 7.2 for a while.
I mean...kinda. Hey man as long as you work with yourself, you can do whatever you wish. But expecting to find other devs and engineers to work under these conditions is kinda ridiculous. A lot of the modern PHP developments are aimed at standardising and optimization of group work. It is much easier for people to work together if they all understand the same things. That being said I also think that over reliance on frameworks makes for training a new generation of worse developers. A younger colleague once told me "I don't know PHP I know Symfony." But still, things like Composer, PSR using small components that make your job easier, etc. still is preferable to 1. Reinventing the wheel and 2. Being so confident on your code to ignore the developments and optimization done by thousand others. Someone else nailed is quite nicely: a bit of a tin foil on your head.
I'm seeing a lot of OP's replies downvoted to -20 for no reason, can whoever does that stop doing it?
You want: is_callable($callback) ? $callback() : trigger_error("Exception of mine");
Some very nice topics: doctrine ORM + zend expressive + REST API
Dude welcome to reddit, lol.
Well, you fit into a very niche usage of php. I think you create a lot of work for yourself by doing things this way but if it works for you and solves your problems, then more power to you. I don't foresee you being able to keep up with updates for all the components of a Linux system yourself but for intranet, you may have different requirements for security and deployment than 99.9% of php apps out there.
I'll put it this way. I'd rather spend $160k on someone fairly capable of thinking outside of the box than spend $90k on 2-3 people who can only work inside frameworks. I do have a bit of a tin foil hat that should be shed before hiring anyone else on. Part of it is that my 1.0 is 95% complete. The plumbing is all there - I have a list of 15 items that are mostly minor to complete before prime time. To take all of the work done right now, and say, "Symfonize" it, would be such a huge undertaking. Not saying I am against it at some point in the future, but I need to make some money today. When I hire people it is my goal to treat them right. Good pay, good benefits, and proper work/life balance. I would rather spend extra on good people than try and cheap out by hiring bottom of the barrel and hiring *more* of them. For engineers though, that will come with the expectation that you can be comfortable dealing with things *outside* of PHP as well. Linux systems knowledge, C knowledge, dealing with build systems and understanding how a distribution as a large 1000-piece puzzle comes together is a key to success. So I do want things to be maintainable and open to others to working on. But I also take the approach and attitude that engineers are hired into unfamiliar things all the time, and good ones will find their way around just fine, frameworks or not.
Fortunately I am not the only one keeping up with those updates. Most of those will just be git pull'd from my upstream Alpine Linux.
It's delusional to say you cover all security fixes. You cover all security issues that you know of and understand - of the rest, you are unaware, obviously. Probably the best thing about your protect security-wise is that security by obscurity.
That is a fair consideration for when those dependencies become larger and they're more likely to do such logging. I don't think anything I depend on does anything really in that regard currently. I would have to go review however to be sure.
Throwing an exception in a ternary operation makes the whole code that much more convoluted and harder to read. If you must throw an exception it should be clearly visible and easily understandable as to why. There’s nothing wrong with making code more compact per se, but the example you showed above is... not gonna sugarcoat it, it’s just stupid.
I wrote a few articles for [php[architect]](https://phparch.com) magazine when my MemphisPHP UG leader asked me the same thing: https://www.phparch.com/article/artisinal-producing-packages-part-one/
It's fine? Using libraries doesn't guarantee anything long term. Writing competent code removes these problems.
If you need them, use them. If you can write it yourself and it makes sense to do so, do it. The dogmatic aspects of both of these perspectives are idiotic and show immaturity and depth of full understanding solving real world problems.
Ok that is perfect! Thanks!
Also, using composer doesn't mean you can't commit vendor. There are many arguments on why you should or shouldn't but that's beside the point. You can commit vendor, you can look at the diffs when you run composer update and you can keep all the control.
I agree. I'll license full-featured applications under GPL, but libraries under MIT. Forced freedom is not freedom in my eyes.
Server side is always more dangerous than client side. Of somebody can execute their own PHP code on your server they can make backdoors, read your mysql tables (if they're on the same server), read and change your Apache config. Frontend all they can do is read and set cookies
You're not writing software for other people to use, you're writing software for you and only you to use. Syslog works but not on every machine. If you write software that needs to work on every machine, then you encounter the problems that PSR's et al are designed to solve.
Even ignoring dependencies, composer is worth it for the autoloader alone. PSR-4 is one of the good ones. (The more recent PSRs range from meh to yikes) &gt; In comparison to a modern framework it's probably 1/10th of it. I don't particularly like symfony or laravel myself, but I *do* like a lot of separate symfony packages. The `LockHandler`, the `HttpKernel` the `Request`/`Response` objects... `docrine/dbal` makes PDO look like shit (Even though it's really just a PDO wrapper) &gt; So am I old guard falling behind or properly ignoring the middleware fads here? There *are* fads, so you'll want to delve into your dependencies' source code to see what's going on most of the time anyway. You should still investigate this stuff, even if you don't intend on using it for work. There are a lot of clever things in there you can use yourself.
Look I don't know why you wrote this here. You framed it as question or a worry. It is obvious that somewhere beyond your overconfidence there are some worries. Either that or you were looking for validation on your ideas. &amp;#x200B; I don't know man. To each their own. Just don't expect other to be happy to work with you easily. You mentioned in a comment that there are certain special limitations that this project has that makes it so you have to take extra security precautions. Sure. That is understandable. At the same time I get the feeling that even without those limitations, you would still advocate the same practices and have the same attitude. And those practices and that attitude to me at least amount to a person that is too difficult to work with. That being said, you never know. It is easy to pass judgement on someone on the internet without really knowing them. Best of luck to you!
If by crazy you mean not following the average, yes definitely crazy. But if it works and meets your needs and most importantly, if you get paid to do it then imo there's no reason to adjust course. I've had this predicament explained to me as "frameworks solve financial challenges, not programming challenges". That's not to say financial challenges aren't very real and need to be met and solved, but if you've worked through or around that, honestly I tip my hat to you.
You're going to have a very hard time finding and keeping _good_ talent if you don't change your attitude toward modern development, IMO. Any talented PHP developer in 2019 is going to see your application and want to rewrite it using todays standards, not work in an outdated codebase. And if they're willing to work on your codebase, they're going to have to spend a lot of time learning it since it's different from any project they've ever worked on in a large way. Modern development is about following established design patterns that allow reuse of code between projects, and a common high-level language to speak in. It's about developers being able to quickly jump into projects and be productive. It's about not having to write a database abstraction layer yourself, and teaching everyone how to use it. You're alienating your potential hires who are already extremely well-versed in the industry standard frameworks. You're also putting more work on your team. Scaling will be an issue. Do you have documentation on how to use your framework (like it or not, that's what you're building)? Is it up-to-date? Is your framework unit tested? Is it peer reviewed by thousands of very talented developers? Can you hire someone who already knows how to work in your framework? Your team is going to have to do all of the work. Why do you think some developer you hire should be trusted over the open source contributions of thousands of other talented developers? Why do you think _you_ hiring that person makes them so much better? Just because _you_ picked them, doesn't make them good, it just means they probably share the same opinions as you not that they're necessarily _good_ (or bad). Why do you think your code is so secure? Who's vetted it? Have you paid a professional penetration tester to audit your codebase? Has it been peer reviewed by _thousands_ of talented developers? Your argument or having HIPAA requirements is silly. I'm just completing a site build for a healthcare provider that has ~2 million users and stores PII. We're using open source Symfony components and all kinds of open source technologies. We still vet our code, but that doesn't mean we can't use modern tools like `composer` to pull them in either. Don't get me wrong, sometimes it makes sense to reinvent a wheel. But I don't think it ever makes sense to reinvent _all_ of the wheels.
Of course it's a worry; I am me, I am not anyone else and the way I learn and function is not the way other people may learn or function. This entire thread has given me a lot of insight into things to think about before getting to that point. I would like to think that I would not advocate the same practices in more of a "normal" situation. If I was starting from the ground up on something new, or working on something that was to be open sourced, it would be a no brainer: use what you can use otherwise, and deploy on a good ol' run of the mill Debian box(en). I'm a lazy ass stoner usually; I would love to be able to take the easy route.
&gt;My prior dayjobs were always within systems/network engineering. This is extremely obvious by the way that you approach programming.
&gt; There is also less risk because PHP runs server side and therefore unlikely to be able to steal user data. Huh? Server side has access to the database which is where all the user data is stored.
I'm talking about plain text passwords, like when the user types their password into a login page.
&gt; Kind of an old fart here (even though I'm kind of young).... I don't use any of these modern frameworks (Symfony, CodeIngiter, etc) I use CI... and always considered myself an old fart for doing so instead of hanging out with all the cool Laravel kids. :-) (Seems to do the job though and my code seems to be easily readable by other devs when I need help.)
&gt; Setup environment 40% You should consider something like Docker or Vagrant to build a scriptable / versionable environment.
 $sql = "SELECT * FROM user WHERE username = '$username' and password = '$password'"; Are we in 2004 ?
&gt; You're going to have a very hard time finding and keeping _good_ talent if you don't change your attitude toward modern development, IMO. Any talented PHP developer in 2019 is going to see your application and want to rewrite it using todays standards, not work in an outdated codebase. And if they're willing to work on your codebase, they're going to have to spend a lot of time learning it since it's different from any project they've ever worked on in a large way. I would not ever be closed minded to the idea of a rewrite. It's not for *me* right now, not at 1.0 anyway, because of the learning curve and time it would involve. If I had a developer give me a proposal for moving things to Symfony and it was a very reasonable proposal I would likely approve it. Modern development is about following established design patterns that allow reuse of code between projects, and a common high-level language to speak in. It's about developers being able to quickly jump into projects and be productive. It's about not having to write a database abstraction layer yourself, and teaching everyone how to use it. You're alienating your potential hires who are already extremely well-versed in the industry standard frameworks. &gt; You're also putting more work on your team. Scaling will be an issue. Do you have documentation on how to use your framework (like it or not, that's what you're building)? Is it up-to-date? Is your framework unit tested? Is it peer reviewed by thousands of very talented developers? Can you hire someone who already knows how to work in your framework? Your team is going to have to do all of the work. No, yes, yes, no, "yes". I say the last one as a "yes" because honestly, there is not much to the "framework". Let's honestly break this down: * The database class involved was started around PHP 5.0 and a backport of some "safety code" I wrote for 4.x. PDO was still just an RFC at that point. It could in theory go away in favor of PDO - it is basically a glorified sprintf() wrapper to ensure that everything gets properly escaped plus some functions to generate unique keys (uuid based, not integer) but will require a rewrite of every SQL query from %s to :field. * Templating is similar to smarty and was pre-twig. I'd love to migrate to twig, but it would require a lot of actual changes to templates. * Caching is a glorified wrapper to apcu or memcache, probably could find any number of suitable replacement wrapper classes. So that leaves the last three things, user and session management, and page routing, as the only real things I use "framework services" for. &gt; Why do you think some developer you hire should be trusted over the open source contributions of thousands of other talented developers? Why do you think _you_ hiring that person makes them so much better? Just because _you_ picked them, doesn't make them good, it just means they probably share the same opinions as you not that they're necessarily _good_ (or bad). I want to maximize the usage of both tbh. But a developer I hire is ultimately more trustworthy because a random guy halfway across the globe working on OSS, is one 4chan provoked autistic meltdown away from injecting in a nasty eval() to pull down some bitcoin miner bullshit. It's a balancing act, there's risk and reward both ways. I am a lot more comfortable with the demarc of "my application" (anything that gets compiled into the resulting .phar) and "upstream dependencies" (anything shipped in it's own OS package outside of my software). Letting someone elses code come into my project outright (via composer or manual import) crosses that demarc, and changes the trust level. &gt; Why do you think your code is so secure? Who's vetted it? Have you paid a professional penetration tester to audit your codebase? Has it been peer reviewed by _thousands_ of talented developers? Your argument or having HIPAA requirements is silly. I'm just completing a site build for a healthcare provider that has ~2 million users and stores PII. We're using open source Symfony components and all kinds of open source technologies. We still vet our code, but that doesn't mean we can't use modern tools like `composer` to pull them in either. Because I set the bar of average security pretty low? How many people are running PHP applications on PHP 5.x running on CentOS 5 &amp; 6? How many different versions of OpenSSL did Huawei ship in their routers? (here's a clue, it takes two hands to count, and there's CVE's since 2006). I'm sorry if I come off as discounting all of that peer review and contributions, because it is important and does have merit in terms of your point. But how many contributors were on OpenSSL when they had all of their nasty vulnerabilities a few years ago and spurred a few forks? You can't treat the large size of a framework and it's team behind it as the golden grail that people think it is. I am sure there's some bugs that probably need fixing in my code but I have used it for other things in the past, and have had other eyes on it. I absolutely would love to have a professional audit / penetration test at some point in the near future but until then static analysis tools will have to do the job. I think it's *well positioned* to be pretty secure due to the lightweightness of everything, from my code to the underlying Linux based OS - there is no software installed that is *not* needed. &gt; Don't get me wrong, sometimes it makes sense to reinvent a wheel. But I don't think it ever makes sense to reinvent _all_ of the wheels. Agreed. I probably should have clarified, when I started my wheels, it was hard to get wheels from the store, and the reason I have it today is because it was done years ago.
&gt; Right now this is just me, but it won't be that way forever. When I do hire engineers to join the team however, they need to be exactly that, engineers. They will need to be able to go beyond PHP because while that's what the main application is implemented in, there is a whole distribution of embedded Linux and other things involved to make this device "just work". You expect to hire generalist devs so generalist that they can (effectively) work on everything from your PHP app to embedded code? I don't mean to be rude here, but it sounds like you're out of touch with more than just PHP development. People specialize in (at the very least) general areas of software development for a reason, that being that it's near-impossible to be good at _everything_. Every business hires specialists because it's a no-brainer to have people who are very good at the specific things you need them to do, rather than having a bunch of people who're all just kind of mediocre at anything you give them, because they have a beginner-level understanding of every technology under the sun.
Well the unfortunate reality is that I have to start *somewhere* and there's only so much money that can go around :) I don't think I am *that* out of touch although I understand the longshot it is. I do have a few candidates in mind who could fit this role and are interested in working with me on this, so it's not impossible. It's certainly unscalable though, and I would like to eventually have my team be more specialized in the specific components of the product, but until the budget can allow for such, I have to start somewhere. I am also not looking for "everything under the sun" because there is a list of specific technologies involved and involving anything else major would require a through review. This is also "embedded" in the sense it is a specialized hardware appliance for one specific application, but at the end of the day it's still just standard off the shelf x86 hardware that's locked down. It's not like I am expecting anybody to write obscure hardware drivers for a specific chip...
You can send me stuff too, I wont mind taking a look
What I think he means is that your missing things like XSS protection and SQL injection protection as well as the other forms of protection when it comes to Web development (not in terms of where its hosted or how, but in terms of how its built)
Have you seen his replies, people give him good feedback and then he ignores it and tries to argue his point of view, when in reality what he is doing is going to cause more harm then not.
never .... ever ... ever .... ever. .... use \`eval\` - just turn this ternary into a if statement.
phpstan-shim serves the same purpose and without Docker overhead 😊
SQL injection I became concerned about in 2003 when phpBB forums were getting hacked left and right. That birthed my sprintf() based escape mechanism before PDO was a thing. XSS protection I became concerned about when myspace was a thing and you could grab cookies from leaving JS in comments. I already have code in place to scan and detect such attempts.
What about slimframework?
These are all valid points but you need to always consider the client compromised anyway. Who knows what kind of shady extensions are loaded in the browser that are doing the same things unrelated to your code :)
I think you’re my long lost brother.
Well it is debatable whether that is a better approach. You remove a php dependency, but introduce a dependency on Docker. So if someone wants to contribute to your code you force that person to install Docker (and in your example support for Makefile and Bash). Also you lose any version restrictions about - in this situation - phpstan. Although you might be able to specify that kind of information in a configuration file. If your code or development process _depends_ on it, you might just as well make it a (development) dependency, right?
A typehint didn't cause this type error. I corrected you half a dozen times that we're discussing *typehint constraints* not just "type errors". You're clearly more interested in arguing about something else no one argues about.
PSR didn't start as a fad but it's fast becoming one. I've lost track of how many libraries I've used that have underwent complete rewrites and overhauls to their entire API (oftentimes even changing names and repo locations) just for the sake of PSR compatibility. If the existing API was poorly designed then yea - you might as well do a rewrite. But if the library is already documented and has clean code, why on earth butcher it for the sake of standards? So yea, PSR started good and still has some absolutely fantastic recommendations, but it's starting to lose focus and risks becomming too obtuse and verbose, even for selective recommendation implementations. I recommend people writing libraries and frameworks to use PSR sparingly (which is, of course, how it was always intended to be used). &amp;#x200B; Composer is another one that is starting to kind of get carried away. One of the beautiful things about PHP has always been the portability of apps written with it. Of course, your composer.json and composer.lock files are fully portable, but using it is fast becoming the PHP equivalent to a node\_modules folder (which has become pretty much the butt of dependency and bloat-related programming humor). &amp;#x200B; The popular frameworks available now are nevertheless really nice (Laravel &amp; Symfony 3 in particular).
How to **NOT** create a login system in PHP
If you don't need it, don't use it. By gum!
yeah, youre crazy. use composer, follow psr. i used php 20 years ago too.
If you release a full app under the GPL, and it gets hostily forked, there is absolutely nothing you can possibly do to protect your interests, and your project will fail. Happened to me 2003-2007.
I don't understand.
&gt;&gt;You're going to have a very hard time finding and keeping good talent if you don't change your attitude toward modern development, IMO. Any talented PHP developer in 2019 is going to see your application and want to rewrite it using todays standards, not work in an outdated codebase. And if they're willing to work on your codebase, they're going to have to spend a lot of time learning it since it's different from any project they've ever worked on in a large way. &gt;I would not ever be closed minded to the idea of a rewrite. It's not for me right now, not at 1.0 anyway, because of the learning curve and time it would involve. If I had a developer give me a proposal for moving things to Symfony and it was a very reasonable proposal I would likely approve it. That's good, but I'd be hard pressed to believe it given your attitude in this thread. &gt;&gt;Modern development is about following established design patterns that allow reuse of code between projects, and a common high-level language to speak in. It's about developers being able to quickly jump into projects and be productive. It's about not having to write a database abstraction layer yourself, and teaching everyone how to use it. You're alienating your potential hires who are already extremely well-versed in the industry standard frameworks. &gt;&gt;You're also putting more work on your team. Scaling will be an issue. Do you have documentation on how to use your framework (like it or not, that's what you're building)? Is it up-to-date? Is your framework unit tested? Is it peer reviewed by thousands of very talented developers? Can you hire someone who already knows how to work in your framework? Your team is going to have to do all of the work. &gt;No, yes, yes, no, "yes". I say the last one as a "yes" because honestly, there is not much to the "framework". Let's honestly break this down: &gt;The database class involved was started around PHP 5.0 and a backport of some "safety code" I wrote for 4.x. PDO was still just an RFC at that point. It could in theory go away in favor of PDO - it is basically a glorified sprintf() wrapper to ensure that everything gets properly escaped plus some functions to generate unique keys (uuid based, not integer) but will require a rewrite of every SQL query from %s to :field. &gt;Templating is similar to smarty and was pre-twig. I'd love to migrate to twig, but it would require a lot of actual changes to templates. &gt;Caching is a glorified wrapper to apcu or memcache, probably could find any number of suitable replacement wrapper classes. &gt;So that leaves the last three things, user and session management, and page routing, as the only real things I use "framework services" for. Regardless of how simple you think your framework is, new developers are still going to need to be taught "your way" of doing things. And since you have no documentation on it, they have to go to you for your tribal knowledge. All of your libraries work in similar fashion to the industry standards, but you said it yourself they are not the same. Can someone get up-to-speed with your codebase on their own? Most definitely. But what you're going to find when you start attempting to hire a development team is that the market is flooded with very junior developers who've just gone through some code bootcamp. Some of them a surely competent and smart, but the majority are not. They will not be able to self-teach themselves your codebase and will need to be taught. And the good developers? They likely wont want to work on your codebase because they've spend years honing their craft and don't want to go back to doing things the "old-school way". &gt;&gt;Why do you think some developer you hire should be trusted over the open source contributions of thousands of other talented developers? Why do you think you hiring that person makes them so much better? Just because you picked them, doesn't make them good, it just means they probably share the same opinions as you not that they're necessarily good (or bad). &gt;I want to maximize the usage of both tbh. But a developer I hire is ultimately more trustworthy because a random guy halfway across the globe working on OSS, is one 4chan provoked autistic meltdown away from injecting in a nasty eval() to pull down some bitcoin miner bullshit. It's a balancing act, there's risk and reward both ways. I am a lot more comfortable with the demarc of "my application" (anything that gets compiled into the resulting .phar) and "upstream dependencies" (anything shipped in it's own OS package outside of my software). Letting someone elses code come into my project outright (via composer or manual import) crosses that demarc, and changes the trust level. &amp;nbsp; &gt;But a developer I hire is ultimately more trustworthy because a random guy halfway across the globe working on OSS, is one 4chan provoked autistic meltdown away from injecting in a nasty eval() to pull down some bitcoin miner bullshit. Jesus fucking christ this is cringey. Who do you honestly think you are that you're going to be able to weed out the "autistic 4chan guy" when you're hiring? Do you plan on asking applications if they browse 4chan and have autism? Good luck bud. Maybe you should take a peek in the mirror. &gt;It's a balancing act, there's risk and reward both ways. I am a lot more comfortable with the demarc of "my application" (anything that gets compiled into the resulting .phar) and "upstream dependencies" (anything shipped in it's own OS package outside of my software). Letting someone elses code come into my project outright (via composer or manual import) crosses that demarc, and changes the trust level. Nothing is stopping you from vetting any of these third-party libraries that are saving you countless time and money. You're right, you have to set your own security standards. But IMO "we only use code we wrote and hasn't been audited in any fashion" is not a good security standard, at all. &gt;&gt;Why do you think your code is so secure? Who's vetted it? Have you paid a professional penetration tester to audit your codebase? Has it been peer reviewed by thousands of talented developers? Your argument or having HIPAA requirements is silly. I'm just completing a site build for a healthcare provider that has ~2 million users and stores PII. We're using open source Symfony components and all kinds of open source technologies. We still vet our code, but that doesn't mean we can't use modern tools like composer to pull them in either. &gt;Because I set the bar of average security pretty low? How many people are running PHP applications on PHP 5.x running on CentOS 5 &amp; 6? How many different versions of OpenSSL did Huawei ship in their routers? (here's a clue, it takes two hands to count, and there's CVE's since 2006). I'm sorry if I come off as discounting all of that peer review and contributions, because it is important and does have merit in terms of your point. But how many contributors were on OpenSSL when they had all of their nasty vulnerabilities a few years ago and spurred a few forks? You can't treat the large size of a framework and it's team behind it as the golden grail that people think it is. I am sure there's some bugs that probably need fixing in my code but I have used it for other things in the past, and have had other eyes on it. I absolutely would love to have a professional audit / penetration test at some point in the near future but until then static analysis tools will have to do the job. I think it's well positioned to be pretty secure due to the lightweightness of everything, from my code to the underlying Linux based OS - there is no software installed that is not needed. So did you stop using OpenSSL? Have you implemented your own secure transport layers? This seems hypocritical to me. You don't want to use third-party PHP libraries cus "mah securities", but are fine using open source secure transports that have had more CVE's than one could count on two whole hands and had a massive exploit happen? &gt;&gt;Don't get me wrong, sometimes it makes sense to reinvent a wheel. But I don't think it ever makes sense to reinvent all of the wheels. &gt;Agreed. I probably should have clarified, when I started my wheels, it was hard to get wheels from the store, and the reason I have it today is because it was done years ago. I call bullshit. You've said in other replies in this thread you're working on an application for the cannabis industry, which is a very new industry. All of the modern PHP things that have been said in this post were around at the time. You made the conscience decision to use your old-school practices, because that's what you knew. And there's nothing wrong with that. But if you're gonna ask if you're "f'ing crazy" for doing so, and everyone tells you that you are... Maybe take that to heart and consider readjusting some of your opinions. Opinions can change.
Well, good thing it's just an example then. But I am curious as to why you think it's "stupid." And also, what part of that is convoluted or difficult to read, in your opinion? I think it's pretty easy to understand why the exception is thrown: The variable isn't callable.
I'm just disappointed at all the great thought out answers you got, and the fact that it seems like you ignored all of them and sat them in a TODO bin with everything else that may be important. You are crazy for not listening to us (as a collective), and you are crazy for not trusting Open Source to the degree that you're wasting thousands of billable hours making crap that isn't even 1/10th as good as alternatives that are free and can be pulled in within seconds. You need to re-evaluate your priorities and consider what you're doing, otherwise you'll go mentally broke and your clients may not take you seriously when they talk to competitors who trash your working paths and previous applications.
&gt; Regardless of how simple you think your framework is, new developers are still going to need to be taught "your way" of doing things. And since you have no documentation on it, they have to go to you for your tribal knowledge. In fairness, I could probably spend a whole day and write up all the documentation one would need to hit the ground running. &gt; All of your libraries work in similar fashion to the industry standards, but you said it yourself they are not the same. &gt; Can someone get up-to-speed with your codebase on their own? Most definitely. But what you're going to find when you start attempting to hire a development team is that the market is flooded with very junior developers who've just gone through some code bootcamp. Some of them a surely competent and smart, but the majority are not. They will not be able to self-teach themselves your codebase and will need to be taught. In the words of Ariana Grande: to those bootcamp grads, "thank u, next". &gt; And the good developers? They likely wont want to work on your codebase because they've spend years honing their craft and don't want to go back to doing things the "old-school way". &gt; Jesus fucking christ this is cringey. Who do you honestly think you are that you're going to be able to weed out the "autistic 4chan guy" when you're hiring? Do you plan on asking applications if they browse 4chan and have autism? Good luck bud. &gt; Nothing is stopping you from vetting any of these third-party libraries that are saving you countless time and money. You're right, you have to set your own security standards. But IMO "we only use code we wrote and hasn't been audited in any fashion" is not a good security standard, at all. What about all of the standard functions that come with PHP? I never wrote any of those but happily use them without the framework abstractions (or with my own abstractions). &gt; So did you stop using OpenSSL? Have you implemented your own secure transport layers? This seems hypocritical to me. You don't want to use third-party PHP libraries cus "mah securities", but are fine using open source secure transports that have had more CVE's than one could count on two whole hands and had a massive exploit happen? Of course not! (Well there was a brief usage of LibreSSL that was reverted...) That was just an example of how a large open source project with a lot of contributors can still have major vulnerabilities. &gt; I call bullshit. You've said in other replies in this thread you're working on an application for the cannabis industry, which is a very new industry. All of the modern PHP things that have been said in this post were around at the time. You made the conscience decision to use your old-school practices, because that's what you knew. And there's nothing wrong with that. But if you're gonna ask if you're "f'ing crazy" for doing so, and everyone tells you that you are... Maybe take that to heart and consider readjusting some of your opinions. Opinions can change. The underlying classes are old, and were reused. They have seen the light of day in 6 other things throughout the years, from minor things to things for other people. This specific project was started maybe about a year and a half ago, and was a backburner fuck-around-idea for the first year. I only got serious about it a few months ago. Was using these classes the best idea? Probably not.
Do you have a team working on this or are you the only developer?
I think you're crazy but mostly I just want to see some of your code.
Let me correct some misconceptions that you have here. I do not write PHP for any agency or any customers. I write PHP for myself. This is for one specific application, to be then sold to my customers as a complete unit. My customers are all technologically dumb. They do not care whatsoever what goes on under the hood really as long as they can plug the unit into their network, open it in a web browser and start selling some weed :) I am not wasting time. The "time wasted" was years ago, and I figured since it was "wasted" already why not use it as a leg up. The collective time I have spent adjusting things in this "wasted time" code on this current project is less than 12 hours in total. Sure it's kind of different, but the only people who have to actually be concerned about it is myself and anyone else employed in to work on the code. This is not any consulting project that I am delivering *code* to a client. I wouldn't want to personally do that, and even if I did, I wouldn't take this approach that I have taken.
This is where I find one of the bigger benefits of Iterables, rather than arrays. Much preferable type safety.
Use your own package in some application - can be anything, it will highlight any shortcomings.
&gt;Am I F'in Crazy? yes you are You are the reason I no longer accept projects already started and which are not built on mainstream platforms. I won't debate your code although you can't compare yourself to knowledge another 1000 devs gathered. What I will debate is your business practice. Here is the average scenario where shit happens: You built a platform for a client 10 years ago, it runs perfectly but now client wants a new feature. For whatever reason he can't book you (contact details are lost, change of ownership, has own dev team, you have a better gig atm, you died, etc) and books another dev unfamiliar with your code. That guy starts from absolute zero, worst part is that you interconnected your platform with OS and other services, so he has to do reverse engineering on what you did 10 years ago. So a two weeks jobs turns into a month(hopefully). You think this is all? no is not. One month later a bug is detected, a serious one, so blame shifting starts; the new guy says is your fault because of your antique platform, you say is new guy's fault because he fucked with your code. Meanwhile hackers are cheering because nobody ran a security review on that thing and sysadmin is crying because he needs to migrate everything to another server. At the end the client is billed twice, and nobody wants to take his work. (story inspired from RL, seen enough scenarios like this and worked on such projects several times, never again)
Also in addition, the only thing that has actually really been covered in depth is my misconceptions about composer. And the feedback given has encouraged me to adopt it sooner rather than later. But for all of the talk about frameworks and what not here, there is no concrete responses from that. A lot of talk and points from a general standpoint sure, but I don't have too much that I can take from that and make action on **right now**. So pardon me if it feels like I am taking everything and dropping it into a TODO folder that will never get touched. That's certainly not the case, but when I am 95% complete to a functional 1.0 that I can put into a customer's hands, is it really really wise to stop *now* and start adjusting everything to Symfony? Not at all writing it off for a 2.0 release. But when I started this project, Bootstrap 3 was the latest version, and I used it. Bootstrap 4 is out now and I debated whether or not I should spend the time doing the conversion. I ultimately weighed on that conversion being too much of a time sink for the initial release. That would have been a far less of an undertaking than conversion to a common framework.
Right now it's just me, but I do want to have additional people hired within the next few months.
I'm having trouble figuring out what the question is here. If what you're doing is working, then no you're not crazy. But your current skillset as you describe it seems very brittle. As soon as you step out of whatever bubble you're in, you're gonna hit trouble pretty quickly as the things you're describing as "new" have been "things" for quite a long time. I have to say I was actually impressed that you hadn't even heard of PSR until the other day. I mean those lads have been around and well known to the PHP community for *years*. I don't at all mean this as an insult, but it sounds like you came from systems engineering, is that accurate?
I think that you are the kind of person that would benefit from enterprise systems that are designed to function for the next 10 years. Dont do that with php however. The "do everything your self" mentality cant really work with this language. Unlike the enterprise alternatives, php never had a clear design. Unless you embrace modern patterns you end up supporting what made people laugh with php.
No insult taken at all, because yes I do hail from systems/network engineering. I stated this in another comment somewhere here and someone else stated I came off like one... so I guess it's a thing! I take great pride in my systems btw. The question really was an evaluation of my personal relationship with the PHP language. The answer that I am getting is what I am doing is working, but probably won't work for very long, and won't be very friendly to anyone I would potentially hire on.
Gotta say, what leeharris100 said is neither toxic nor false. I don't think you could work in any other environment beside one where you are the only one (or the one fully in charge).
Nope! The lifecycle of my product is 4 years. None of my customers will run hardware (provided by me) older than 4 years - once you start hitting the 3 year mark you're going to be nagged for an appointment for upgrade and migration. The hardware, the OS, and the software (PHP app) are all bundled together and presented as one unit. The OS and the application are major version tied - and only N and N-1 supported, so through the automatic update and licensing features they're always going to be on something relatively up to date. If something is still running 5+ years later, then we have serious issues :)
Well, that's an other story. Although i dont know why your app should be concerned about the hardware and the os.
Thank you for your opinion. I humbly disagree; the dismissive description of my actual skillset that may not fit within his company accompanied by the "I'm better than you" presentation was quite indeed toxic. I have before worked in other work environments and can function fine. Other work environments don't revolve around something that I have created, an idea in my mind transformed into a functional application, so pardon me if I have a little bit of Steve Jobs syndrome in regards to "my baby".
Idk man, if that works for you do it that way. But it feels to me you are damned to work by yourself, completely solo. If that works ok for you, do it. For ex, " I don't use fancy URL routers" sounds like you never had to put hands on someone else's code, and those fancy url routers are very helpful, and give a layer of logic and order to the code. Or whatever
I agree with everything you're saying here but also want to point out that syslog can be used to great effect on large and complex systems. I have used (and continue to use) syslog-based logging on systems with tens of servers and hundreds of thousands of requests per day. It's especially useful with well curated logs and using rsyslog or syslog-ng which handles shipping and collecting logs enmasse very efficiently. Add ElasticSearch and Kibana to your central instances of syslog collection and you can manage the logs of an entire system in one place with just a bit of convention. And since just about every language can log to syslog (including *sh) and you end up with an excellent universal tool that doesn't require any extra tools within your actual software. I live a lot of our new and fancy tools, but modern development can sometimes be a bit too quick to start pushing random inter-process http requests to third party applications and services to handle things we've solved with a great deal of efficiency a long time ago.
Well the "router" is filesystem based, so if you know the URL of the page you want to work with, I kind of expect you to be able to use cd/ls, finder, explorer, etc, to be able to navigate to where it is. I personally find this easier than going to a router.php config thing and reading through the flow of the router to find out where to go.
Because it doesn't run on the Internet/in the cloud. It runs locally to my customer's LAN on plug-and-play appliances provided by us.
I encourage you to return to this post a few months after you hire people. I was hired onto a growing team to work on an application built by a single developer and the thing is a disaster. He knows how to work on it fairly well, but the thing is riddled with vulnerabilities, inefficiencies, no tests and just bad practices. There’s not really any application of the single responsibility principle and basic changes by more junior developers often break things. One of the benefits of these frameworks is that they lay a standard for where things are, how they work, and they abstract some of the more common, but basic functionalities. On top of them they usually make setting tests up easier so that you can iterate on code without worrying about if you’re blowing up another part of the application. For now, expect that new hires (especially if you hire good, experienced developers) are going to want to change the way your application is laid out.
I have worked a lot with the Dropbox API and the hashes but never felt the need to calculate the hash myself. What is your usecase? When you download/upload a file from/to Dropbox you can save the hash at that moment and compare it later.
I would have not wasted half a day on reddit soliciting feedback if I honestly was not here for advise. You by far have more experience than me even though we started around the same time since my dayjobs have historically been in systems/network engineering. I am not scared of change, I am slightly uneasy about it and don't adopt it without review. Yes there's a lot of things I don't understand, but right now what I am understanding (at least with frameworks here, specifically) is that I run the risk of bringing in a lot of additional bloat that my application just doesn't need. Sure I can upgrade to a car that can go 70 down the freeway, but if my horse and buggy was jerry rigged to go 120mph on the freeway it's hard to make the financial decision to abandon current progress.
We have OpCache. We are about the have a JIT compiler. Please tell me again why someone should care about the size of the framework. And please dont tell me about the maximum load. It's 2019. Servers are dirt cheap and on top of that if i wanted to server millions of users per second maybe, just maybe, i wouldn't be writing php...
And? Thats not a reason to lock your application to certain hardware/os configurations. This is like going back prior to 1995. That was the reason why the virtual machines were created back then.
&gt; you force that person to install Docker In the opposite case you force them to install PHP with all the extensions your project and all the dev tools you use happen to require. &gt; Also you lose any version restrictions about The image you use can be pinned to a specific version and will always contain this specific version until changed. &gt; If your code or development process depends on it, you might just as well make it a (development) dependency, right? Those two are not the same IMO. Your code dependencies should definitely be a dev dependency. Tools you happen to use should not. Adding all the tools directly in your Composer file makes updating all your **actual** (dev or real) dependencies more difficult because Composer needs to resolve their dependencies too when installing everything. If a tool you're installing doesn't yet support new Symfony, you cannot upgrade to it even though you do.
It's rare that I \_actually\_ get to be able to re-use someone else's Middleware package. But I find structuring my app with Middleware is incredibly helpful and much more easy to reason about than putting everything into the underlying controllers.
Rofl this comment is cracking me up, not sure why, but it's not rude like many of the others and has a wholesome tone. Like the majority of people in this thread I'm appalled at OP's self-inflicted workflow, in 2019 no less.
Steve Jobs died because he was set in his own ways and refused modern medicine for his cancer. Sound familiar?
Oh my god, did an internet nobody call your example stupid and it hurt your feelings? Jesus, how insecure and vulnerable does one have to be? Other than that I agree with your edit. And to answer your question: 1. As you’ve already seen and a number of people have pointed out: it just doesn’t work like that. 2. the code should **be explicit** meaning a clear if-statement that explicitly checks a variable and throws an error is a lot more readable and error-proof.
Because I can't just sell my application standalone and expect my customers to be able to deploy it themselves? Everything is designed to be an easy-to-use unbox and go solution. The SQL database and all patient data is all encrypted. The fancy custom web based interface to the underlying cryptsetup is complex and tied to the OS. I have to adjust init scripts to properly start things up. I have to detect when it's not mounted and when there's no database available and prompt the user to insert a USB stick with an encryption key on it. I have to use udev hooks to detect when a user has inserted a USB stick and handle it accordingly, be it for unlocking the thing, for handling offline software updates, or for serving as a backup device (also encrypted). All the customers of my product will effectively see is the application written in PHP. There is no SSH or Linux shell console. All you can do on the console is set a static IP address, reboot or shut down the unit. Everything else is handled through the PHP application and makes calls to system services under sudo as needed. Because of this unified presentation I have to tie it to hardware and OS. I can not ensure that this product will be supportable on a variety of different distributions without a lot of additional work and checks. This is designed to be used by the technologically challenged. They plug the appliance into their network (it's a NUC tbh, locked down with secure boot having only my keys), boot it up, hit a .local address or the IP, and start selling weed with the platform.
Small trick.... (I am thinking is nice way of getting rid of all those if isset checks which throws exceptions... &amp;#x200B; [https://3v4l.org/fJlEI](https://3v4l.org/fJlEI)
Yeah the reason why I wondered if you were a systems engineer is because you're caring more about things that "normal" PHP developers tend not to care about as much, like memory usage and dependencies. The web dev community in general doesn't seem to mind dependencies, ceding some codebase control yields huge maintainability and development speed benefits. Also your, ahem, aversion to "new" things does give off a systems engineering vibe, which certainly works for that sector where reliability is key and reliability is most oft found in tried and tested solutions despite their age. There's nothing wrong with that, but you are at odds with the general mindset of the web dev community. As a general rule I would just encourage you to at least get proficient with composer and learn the basics of a couple of frameworks. Laravel and Symfony are good starts. I don't know how you are with tests but learning the basics of PHPUnit for unit testing and perhaps behat for behavior testing will help, too. Any developer you bring on who has spent more than 5 minutes in backend web development will naturally move into these paradigms of operating, and will likely see your code as legacy that is in desperate need of updating.
Yeah well I embraced modern medicine for mine :)
[Slim](https://www.slimframework.com/docs/).
Now do the same for your app so it doesn't die :)
As everything, it's subjective, if it works for you, then do it. Don't compare to others, but in a large company your ways just don't escalate
I’m using a router for not to map 1:1 url to file, but to use SEO friendly URLs
His comments about Composer illustrate how shallow his knowledge of the modern development landscape is.
I guess at the end of the day it's going to depend on how you long you plan to go on developing. If you hire people eventually they may well be able to adapt to your way of doing things, but I think most will probably balk at it. There are times I miss the old ways of doing things, but the radical increase in my ability to turn out projects and increase my revenue stream has made it a no brainer.
&gt;My templating class existed since before Smarty was a thing and can be considered something akin to "Smarty Lite". A template engine is not that hard to implement and pretty much solved as long as it has safe escaping and reasonable performance. Everything else is syntactic sugar i agree with you. Still most people want to learn a common syntax and not implement the engine themselves. So they depend upon known engines. &gt;I don't use fancy URL routers - I use a small little class to load up code and templates based on where they exist on the file system (with the rest of the URL as path info). To be honest that sounds like a crude router. I write mostly APIs so for REST i always get the right naming scheme (also saves arguing with co-workers why the thing is calld *sendData* again) or for RPC which i like when named thoughfully i can do some tricks like backwards compatible legacy routes to a new function name. &gt;The user class works on PHP password\_hash functions. Good for you! A sizable portion of devs probably get it wrong tough: [https://net.cs.uni-bonn.de/fileadmin/user\_upload/naiakshi/Naiakshina\_Password\_Study.pdf](https://net.cs.uni-bonn.de/fileadmin/user_upload/naiakshi/Naiakshina_Password_Study.pdf) &gt; node.js ecosystem Node: ridicioulous small packages by varying devs, hard to find a clear community. A simple express app needs dependencies from so many unrelated devs, each with their own versioning like 7.0 for a two year old project or 0.0.1 for three year old glue stuff that did not get into the main framework. PHP: small packages (actually some time ago symfony and zend where one big ball) build by community known devs (thephpleague, symfony components, zend, doctrine) even with a sizable app you can count your "vendors" with two hands. Also PHPs native library covers much of what NPM has to cover for Node. I don't see how middleware would require more resources as long as it is built sensible. Which is easy to do with the middleware pattern. Same goes for PSR compatible building blocks, having interfaces eliminates the need for adapters. Lastly you build your OS around it. Ok so do you use a package manager to get binaries or sources? Composer is just the same concept. Many PHP apps are shipped as efficient as possible so without dependencies. If Drupal CMS uses Symfony Components i don't want them to copy me their "current" ones into the ZIP - what if they mess up? Composer is to PHP what Pacman is to Arch Linux. You mention a benefit that you can review dependencies, well i know this is not done often enough and we tend to include too much. There sure are drawbacks but they just need different approaches. For example one can scan dependencies for security announcments and upgrading then is just a console command away. As mentioned before it get's really good when you can trust a lot of vendors.
I think people are being unnecessarily harsh on you. I disagree with most of your original points, I think you are old fashioned and I liked the "tin hat" analogy someone wrote earlier. But, people keep referencing your "attitude". I think throughout this thread you've taken criticism well and provided thoughtful rebuttle even if you are stuck in your ways. This is pretty rare on the internet, let alone Reddit. I think if you give some newer technologies a try you will be pleasantly surprised. You probably owe it to yourself after this thread. I implore you to just go install Laravel and build something small like a blog. Not because Laravel is the best but because it's quick and easy, well documented and modern. I got to grips with it in an hour so it won't waste much of your time. It will expose you to composer, modern testing practices, dependency injection etc and you can decide from that what to take from it. You might just discover something cool to add to your own "not-a-framework" or you might decide to do a complete rewrite in one of the other major frameworks. Nothing bad will come from it. In the time you've spent on this thread you could have done it.
&gt; I do not like the concept of giving other people control over my project, which is really what composer does. If you go look into the node.js ecosystem you will be met with many of examples of why this is a horrible idea. Instead of this I download my dependencies by hand when they have an update I wish to have, review the code with my own two eyes, and then place it into the relevant include/ folder where it belongs. Just to clear something up: Do you believe your dependencies would be automatically updated with Composer? That's wrong! That's what the `composer.lock` file is for. It is recommended to commit it into VCS for projects. With Composer you would still have to manually update dependencies and you could (_and that's a very good practice!_) still review all the code for yourself. Your reasons for not using Composer really are invalid.
&gt; The answer that I am getting is what I am doing is working Actually you're the one telling *us* it's working. Until you show us code all we have to go on is what you say, and so far what you've said has been... crazy.
Echo?
No no... print!
OK, well, working != optimal. Showing you my code is not a question for me, but for my lawyer. Pretty sure I know what she will say :)
You’re a clown 🤡
Echo
`sprintf()` FTW
Whats the problem?
That‘s the question...
What does it do?
let me explain why I asked this question; today I hear an option that using "print" is "more professional" I use echo in most of case, sometime print for function and arrays
&gt; Whats the problem? echo or print, obviously :)
&gt;The differences are small: *echo* has no return value while *print* has a return value of 1 so it can be used in expressions. *echo* can take multiple parameters (although such usage is rare) while *print* can take one argument. *echo* is marginally faster than print. &amp;#x200B; [https://www.w3schools.com/php/php\_echo\_print.asp](https://www.w3schools.com/php/php_echo_print.asp)
First I'll say that the description of your code sounds reasonable to me in that sounds better than mine, and mine works great. The idea I want to bring up is called the [Capability Maturity Model](https://en.wikipedia.org/wiki/Capability_Maturity_Model), something I struggle with in my micro organization, and have seen plenty of larger firms struggle with. Basically micro organizations (5 or less people) can tend to be stuck in the Level 1 heroic model, where individuals are counted on to do many things and resources are not allocated to investing in improving process, or for this case, modernizing to current standards and best practices. To be fair, it does sound like you have done the latter with support for Php 7.2, but on this point I'm more thinking about my own situation where I keep using a custom mvc system and would like to update to something contemporary like Laravel, but haven't had the resources to put into that change. On level 1 orgs - "Success in these organizations depends on the competence and heroics of the people in the organization and not on the use of proven processes. ...Maturity level 1 organizations often produce products and services that work but company has no standard process for software development... Maturity level 1 organizations are characterized by a tendency to over commit, abandon processes in the time of crisis, and not be able to repeat their past successes." http://tryqa.com/what-is-cmm-capability-maturity-model-what-are-cmm-levels/ I don't know if this fits your org, but what you wrote reminds me of my own position. I'm trying to figure out how to get to a higher org maturity level with such limited resources.
&gt; With that said someone I hire myself into my organization, on my payroll, will get a significantly larger amount of trust than an open source contributor halfway across the globe I have never spoke to personally. That makes no sense. The point of open-source is that you don't have to trust people, you can just control what they're doing by reviewing their actions (commits/posts)
I am 100% convinced that one can build better web apps if you stick to the bare minimum that you actually need. The point with frameworks and libraries is that they usually do the exact opposite. Even if they don't fit all imaginable features, the have myriads of abstractions to do so. (Ok fine, with node you have frameworks that consist of thousands of "libs"). I'd also argue that overhead of maintaining your own stuff isn't necessarily worse. Complex systems are hard to learn and master. If you only need a fraction of it, it is likely easy. Reinventing the wheel? Not at all, it is just about building wheels that fit the usecase. But that's all worth nothing. Because we need commonality to function in larger groups. You can talk to people about a recent netflix show and instantly be friends, but if you tell them that you just loved a show by some amateur filmmakers that cannot be found anywhere, you must be very lucky that someone shares this obscure fetish. Common libraries and frameworks are artifacts of a religion to bring people together. Love it, hate it, make your own.
There are far, far, FAR more important things in regards to professionalism than your choice of `echo` or `print`. Pick one, use it, move on.
`fwrite(STDOUT, 'hows about stdout?');`
[Slim](https://www.slimframework.com/docs/) is also worth a look. I love it, and prefer it over Flex.
Relevant username.
I would say I am at a 1.5 bordering on a 2 currently. It's not unreasonable to get to a 3 before I hire people on. I have more done on the technical plumbing side of the repeatability and testing than I have on the documentation and written policies.
&gt; I apologize - it wasn't my intention to be hostile or negative. Let me clarify my point: Fixed it for you.
&gt;Probably the best thing about your protect security-wise is that security by obscurity. Has anyone really been far even as decided to use even go want to do look more like?
Your system sounds impressively janky. Is its purpose to be [something like this](https://www.covasoftware.com/pos)? If so what makes your home-grown solution superior?
How the fuck are the mods not deleting this right away?
It depends what you’re trying to do. It sounds like you don’t need a lot. If your projects grew you might see the benefit of a router/container/autoloading setup. I have made the same leap you are describing and it’s sort of fun once you gwt the hang of it. Don’t let ugly syntax or fear make your decisions.
That's actually hilarious, where did you hear that?
😎
video tutorial on YouTube
(Note to OP: among other things, I was the lead on PSR-1, PSR-2, and PSR-4. I've been working with PHP since 1999 and been active the community that entire time.) Don't let the bastards get you down. There is a love of "new hotness" among developers, who too often equate "old" with "busted." Yours may be "old" but it does not sound "busted." Here's one way of reframing your situation. You don't use an "off-the-shelf general purpose" framework; you use a mature, finely-tuned, specific-purpose framework. I would object to your characterization of Composer, but that would be the extent of any counterargument I might make.
Yep! What makes my solution superior is that your highly intimate data on who and what involved in your federally questionable activities aren't floating around on AWS or Azure.
Youtube PHP tutorials are notorious for being full of terrible information
I use echo because thats what I used first.
Codewars is fun. You write a small algorithm and then you get to see how others do it. Generally everyone else did it better than you and you can't to learn from them. I try and do one a week, they get progressively harder.
&gt; What about all of the standard functions that come with PHP? I never wrote any of those but happily use them without the framework abstractions (or with my own abstractions). I am a developer who has worked for people like you before, worked in half a dozen "startups", some of the silicon valley type, some of the mom-and-pop type. I've been working in PHP for 14-ish years, so I have experience with PHP 4, 5, and 7, and have watched all of these standards come into place. Moreover, having worked in the language that long, I know exactly *why* they came into place. I would simply turn down the job in the interview, if I were interviewing with you. I wouldn't even entertain the idea of taking a job with this. It's not because you are working in a custom codebase... a *lot* of places do, even if they use pieces of open source code or parts of frameworks, or so on. And it's not because the code you do have is flawed. For all I know, it's efficient and works well. The reasons that I would never take a job working for you is that: 1. I have more expertise at this than you do, but you are categorically unwilling to let me make decisions. You say that you would "approve" most of the things I want, but frankly, if I know more about this than you do, that is *at best* a waste of my time, and at worst a way for you to force me to make mistakes that I have already learned from. I would *try* to explain why to not do something, but I don't have the time, energy, or inclination to do my job *plus* give you an education in all of my expertise and experience. 2. Your aversion to open source solutions, and the reasons for it, make me certain that I would have to end up doing a lot of work that I simply shouldn't be doing. There are no circumstances where I should be debugging a URL router, because it is a problem that other people have solved better than I can. I shouldn't have to build a REST API Client, because Guzzle exists. I shouldn't have to add a new feature to a templating system, because that is also a "solved problem". This job would end up being a lot of frustrating busy work that, except for your neuroticism, I could accomplish in under an hour. 3. You know enough to be dangerous, and not enough to avoid problems. I could maybe save you from making bad decisions, but that would be a lot of effort. Additionally, you have trust issues when it comes to code, so whether or not I could save you from bad decisions would probably be more of an exercise in intelligently manipulating you emotionally than simply "being right", and that's something I don't want to engage in. If you want to do things your way, on your own, then go for it. If it works, it works. That's basically the mantra of PHP programming, startup programming, and business focused programming. But if you want other people to help you, then do things in the standard way. That's why it's called standard. Either learn them yourself, or step aside and let someone who has more experience make the decisions for you. If you don't like that idea, then continue doing it yourself. If you're just making little websites for weed shops, I doubt you'll need a full team any time soon anyway.
&gt; Relevant username. Gank incoming.
Not to sound rude but yes, it seems you failed to adopt what was new thinking your approach was better; until what's new went so far beyond that you now feel out of touch with the very language you were an expert in.
"Steve Jobs" syndrome doesn't mean "I cover my hears and don't look at anywhere around because I'm right for sure". Rule of thumb is: if someone says they are being like Steve Jobs, they are just justifying being dicks and close minded. The thing is, that while you won't fit in HIS company, you won't fit in 99% of them right now, because you purposely think that keeping up with the times and advancements of the ecosystem is not something you need to do because, in your mind, what you created is perfect. It isn't. For sure. No matter who you are, how good you are, you are still one guy not even realizing the basic workings of composer, for example. Composer is 7 years old, and you don't understand how it works because you thought you didn't need it, so you never checked it, learned it, and (maybe) embraced it. How many other things have you missed out on? You'll never know, unless you start keeping up with the times. Again, really, no hard feelings. 4 years ago I was where you are now. I had all my tiny libraries and my version of "OOP" and I didn't want to change it. Then I started reading why people were already on the bandwagon, and damn it made my life easier, more stable, and waaay more productive. Our field (CS) sucks because we need to keep up or be left behind, but if you embrace the innovation, it can be taken with a mix of curiosity. Out of 100s of projects/ideas/tools, few stick around, and you are lucky that you are so behind that you can choose what already survived (because of its merits) ;-)
Very well put.
There are some tests but coverage isn’t great. The package throw exceptions when classes don’t extend BaseStrategy with a message indicating that it must implement the interface. There are no interfaces. There’s also no type hints as the package manually handles those cases instead of using standard language features. All in all it’s not easily configurable and is likely to cause problems to the end user if they try to.
I use echo, except when debugging, print or print_r - later I know everything with print in it has to go..
Thanks, I will surely work on this stuff
echo is a keyword and print is a function. Echo performs slightly better. Use echo
I wouldn't go as far as tin foil hat attitude. If you have composer deps, you have to review them as well. Its good security practice. However on the other hand, not using composer to keep the deps updated can be a bad security practice.
I use this with a project that relies on FM for data: [https://github.com/soliantconsulting/SimpleFM](https://github.com/soliantconsulting/SimpleFM) Works great.
PHP is not special in any way, shape, or form. It is just another open source project. Yet you trust it implicitly, while thumbing your nose at other equally trustworthy projects and contributors. Many of PHP's contributors are also contributors on the same projects you're irrationally afraid of. No comprende, fella.
Why does this enforce CHANGES.md (which I have never seen) instead of CHANGELOG.md which is the [standard naming convention](https://github.com/php-pds/skeleton)?
&gt;that your large agency is probably an awful culture fit for me Probably. &gt;and anyone else who values their sanity, personal dignity and time outside of work :) Funny, that's what I would be saying about your attitude.
&gt; w3schools lol
print print print print print sorry, there's an echo in here
&gt; I seen "PSR" referenced the other day here and honestly had no idea what they were talking about and had to Google. PSR is a bag of hurts, it has some jewels but its also filled with nonsense and crap. Its a redone of the JCP (Java Community Process) and we don't want that.
For half it's life Composer has had a recommended install which involved piping a non-encrypted URL direct to bash. Yet people jumped on board like it was a great idea.
&gt; The answer to the security fixes question is zero. That's just retarded, especially for someone with a sysadmin background like yourself. Again, to me it looks like your answer (and most of the rest you've given in the thread) is just confirming what I said in my last paragraph. You're not here for advice, you're here for validation and/or arguing, and none of your points are even objective... they're just subjective opinions about what you think is the best way to handle security based on your personal work situation (which the vast majority of technical + security people disagree with). And I guess it makes sense considering how your prioritise your time. If I'm wrong, what was your goal in making this thread?
I get what you are saying. I don't care for the psr stuff much but I see where it *can* be useful. For personal projects I don't stick by their coding style guidelines and don't care if that's a problem or not. As for composer, it's a handy tool. I'd rsther just download a compressed package rather than shell it from windows (not as bad on linux because uou terminal every fucking thing anyways), but I don't like that experience on windows. Most of it though, I just see as a boost to the profession side of development. Gi e it time and we will come back full circle, especially when people grow tired of a group of people telling them they HAVE to implement things certain ways.
He's allowed to defend himself though?
As long as you're the only one working on this, it's fine. But please, don't subject others to this kind of bullshit. I've seen this kind of shit at a ton of companies and it's just a nightmare. It never solves most of the problems that frameworks do, has no documentation, and is a nightmare to work with. If no one ever has to deal with your custom mess, it's fine. Otherwise, you're fucking crazy for expecting others to deal with it.
The problem with what you're doing is it's all fine and dandy until you have to work with a team or hand the code base off to someone else. Even then, it can be fine. But the problem is if I am going to take over your codebase, I'd rather you had used a framework and/or libraries where appropriate that had strong communities behind them. Because it's easier to see what is application-specific code versus framework/library code. I want to be able to read your project and get up to speed quickly. That said, maybe I can do so with your codebase(s). But toss 10 developers into a room with your codebase and you're going to get some people that really grumble about your Not Invented Here (NIH) syndrome and so forth. The root of the question is really "are your abstractions/solutions so good that they should be used in place of XYZ open source solution?" If so, why not open source your work so it has a community behind it? You might find extracting things into a reusable framework and/or libraries exposes some issues in your codebase(s) where you mix concerns in an unclean way. It's practically guaranteed (but good for you if not).
I think the latest benchmark on micro optimizations shows print is faster by 1ns.
Cray. I’m guessing in php7?
I completely agree with you on the high levels of abstraction from frameworks. I think it has to do with excessive dependency injection. Its frustrating to read through multiple layers of interfaces just to locate a function definition.
Are you crazy? No. It's just a different paradigm. It all depends on what you want. "Modern" development is now about bulldozing your way to the finish line *as quickly as you can, regardless of the cost*. Jam an entire framework in, to write those 20 lines of code for you. Unfortunately, developing everything "yesterday" requires this kind of approach, so it's becoming a little difficult to find a job that lets you write some actual meaningful code and I think the demeanour of your detractors reflects that. Not quite sure why everyone is afraid of code that's been written for a purpose instead of imported and repurposed. I don't think you'd have any problems getting people to work with you, should the need arise. I'd do it.
I have to agree here. Composer can still be used entirely in your control - just don't gitignore /vendor. Any updates made via composer are immediately visible in git diff, and must be committed to be saved. It's super valuable. You can, as you suggest, provide as much scrutiny to the code as you like, but there's not much of a downside, since it only needs to be actually run when updating dependencies or adding new ones (provided you include /vendor in the repo).
/me grimaces You're right, of course. CHANGELOG is the correct thing. For good or ill, Producer came out quite a while before the pds/skeleton research, and used CHANGES in both versions 1 and 2. It's a configurable option for Producer, but I opine that changing the default would be a BC break of sorts. Maybe I should just bite the bullet and make the break in a minor release.
You don't need to trust the open source developer though. You can still fully audit their code if you use composer. PHP, by the way, is made by open source developers.
I can do the same with my projects, using "docker compose up", but it does it in a repeatable way every time, cleanly fetching all dependencies, and not requiring a fresh system for fill repeatability.
I'm told you, most video tutorials are lemon.
Sometimes it got it right like in this case.
r/InclusiveOr
Hagagaggagahahdshdahsdahfuqwoldqwodoqosad get it he said "yes" to an x or y question hahahhaha so funny!!!!111!!111!!111!!!!!!1!
Hello, saying "yes" to every question is not funny, so please stop trying to karma grab on every post. This is a bot.
Thanks for fighting the good fight and replying.
This is exactly what I recommend. In that case, composer purely becomes an easier way than downloading manually, with no other changes. In other words, no reason *not* to use it
Even if there were backdoors in the repos, he can just commit /vendor to the repo, and have exactly as much auditability as he currently has, but with 10% of the overhead to add new deps or upgrade them.
this is not garbage ..i promise you in this post who have mistakes or problems will solved some days..thanks for realising
You can so that the way it works for you, but if you're working with people, there are lots of common practices to follow I guess. You have to follow them at least because they're already here, used by a crapton of developers. And if we're talking about the aesthetics... eeh... depends. First of all, you have your own base of code and not everybody's gonna have it. So they'll use frameworks which may be not always the most beautiful and sophisticated solution, but they'll work for the majority of people. Your base of code is either good for some specific tasks you do or you had created your own framework. Composer just makes managing faster, nothing magical here I guess. And talking about general aesthetics, there are always those weirdos complaining about impurities of software from licensing to method of developing to development tools... The reality is that all financially effective real world software is ugly and illogical as sin. Example out of head: Discord desktop app. The tools they had used to create it form a chain of ugly technical solutions, but it seems that is the most effective way to create software nowadays from business perspective.
Who hurt you?
Hello, the condescending tone of your comment makes you sound very snotty, so please stop. This is a bot
The discord desktop app is not a desktop app correct? Isint it just like Skype, Spotify, slack, vs:code, a web app with electron in a scaled down chromium host? I hate Electron with a passion.
Ah. Well that does make sense. In the context of this program, changing the default would be a BC break, but I do think it's probably worth it.
Did you get it all working?
Haha no man. I got frustrated and never got it working. I tried my best. But we have an exam for the rest of the material and I have done all the other homework assignments to 100% completion so I decided to to skip it and study. Sorry man I wish I had better news. I was doing perfectly fine until trying to get SQL code to work in php.
`echo` always. Biggest reason is the short syntax. It's pretty common to see templates now that say `&lt;?= $foo ?&gt;`, which is shorthand for an echo, not a print. Whatever you choose, being consistent is most important, and the shorthand implies an echo so I expect echoes elsewhere. Being able to use commas is also pretty nice, because the operator precedence is super low so you can be sure you're separating your operations out properly without needing to fill everything with parentheses.
Parts of this series on Laracasts can definitely help: [https://laracasts.com/series/php-for-beginners](https://laracasts.com/series/php-for-beginners) (start about half way down). That will cover general php related topics for PSR/MVC structure and autoloading. &amp;#x200B; Then checkout something like this: [https://laracasts.com/series/laravel-from-scratch-2018](https://laracasts.com/series/laravel-from-scratch-2018) for how those concepts are used in a framework like Laravel.
It was said by an idiot. Never listen to them again
w3fools never have it right &gt; The echo statement can be used with or without parentheses: echo or echo(). is written by an idiot. It's like to say "a fork can be used to eat a pork or a fish" the rest of this article is as bad.
What's the point in answering questions if someone is apparently not skilled enough?
If he could answer, then it's great. If he can't, he can research, learn, dig documentations, see how a framework works internally. He then can choose to answer, or don't it he doesn't know how to. That's how I usually learn something not from documentations.
In my experience, such answers do more harm than good long term. Internet is full of shit and most likely the answer they would find is from php3 era. Having no expertize to tell the sheep from the goat, they would just help to splead that old PHP we all hate.
[PHP The Right Way](https://phptherightway.com/) is a good place to get started. It covers a lot of topics with examples.
But in my experience I do find gems in SO, and also find gems in source codes that we usually won't touch. Yes he may not be experienced in answering some questions but if he could, why not? It's one of the places you would learn from expert experiences, not the only place.
It really depends on a few things. And depends on what you are optimising for. Assuming you are a skilled developer, there is nothing to say you can't build your own framework. Plenty do. Symfony, Laravel, Aura, etc etc were all started by a person who wrote their own framework. Where you may find friction is getting others involved. Hiring becomes more difficult, and the skill level you need to hire goes up (which may not be a bad thing, but it is probably going to be a more costly thing). Frameworks are useful in that they take complex or mundane processes, generalise them and make them easy to consume. Their true value comes from the amount of mindshare they command. Replacing a &lt;insert framework here&gt; developer is _typically_ going to be easier, because they already know how a large portion of your stack works before they get started. Everything has a cost - it depends on where you see value and where you want to wear that cost. It's probably a bit disingenuous to refer to things as "fads" when they have stuck around for quite a number of years and have proven their utility to a great many people.
The only thing you need to know about PSR is right here: https://www.php-fig.org/psr/ Note that these are standards, being PSR-2 (coding style) and PSR-4 (autoloader) the most widely accepted. There are several other recommendations like Middleware, Cache, etc. Keep in mind that some PSR are still controversial. For the autoloader thing, just head over to composer and read the manual. Really, do it. You will use it a lot so just learn it: https://getcomposer.org MVC is actually a very basic concept for describing modern frameworks. In my case, I did the Symfony guide "Creating your own framework" https://symfony.com/doc/current/create_framework/index.html because I already had a framework and I wanted to modernize it.
The only thing you need to know about PSR is right here: https://www.php-fig.org/psr/ Note that these are standards, being PSR-2 (coding style) and PSR-4 (autoloader) the most widely accepted. There are several other recommendations like Middleware, Cache, etc. Keep in mind that some PSR are still controversial. For the autoloader thing, just head over to composer and read the manual. Really, do it. You will use it a lot so just learn it: https://getcomposer.org MVC is actually a very basic concept for describing modern frameworks. In my case, I did the Symfony guide "Creating your own framework" https://symfony.com/doc/current/create_framework/index.html because I already had a framework and I wanted to modernize it.
 Nah, I meant what I said. I’m really annoyed by how easily people have their “feelings hurt” today. It’s like some people have lives such a sheltered life and never had the opportunity to grow a thicker skin. That’s unfortunate, really. There will always be assholes/people who are hostile to you for whatever reason, and if every nobody can get under your skin and “hurt your feelings” that’s kind of sad, really.
&gt; It's one of the places you would learn from expert experiences, not the only place. Is far from true. Experts just have no time to waste hanging there. But noobs, on the contrary, are swarming. So there is absolutely no need for another one. Source: Stack Overflow says I reached ~20m people there, so I sort of know what I am talking about.
My suggestion is to focus on general separation of concerns / single responsibility principle and dependency injection over some particular model like MVC. If you're currently using other people's object oriented libraries (even if not writing them yourself) maybe begin by getting a dependency injector like Auryn (https://github.com/rdlowrey/auryn) and refactoring one of your projects to separate out dependency configuration and wiring from other runtime code. If your main thing is separating templating ("views") from other logic, just pick up something like twig and use it directly. there's nothing wrong with something that looks like this as an intermediate step: $injector = include('bootstrap.php'); echo $injector-&gt;execute(function(Twig\Environment $twig) { $data = array(); // // some logic // return $twig-&gt;load('@pages/some/template.html')-&gt;render($data); });
there's no such thing as *runtime enforced typehint constraints* ... seriously, what are you drinking? from the php manual: "Type declarations were **also known as** type hints in PHP 5." there is no difference, they cause runtime errors, same as python types. please either provide some code to illustrate what the fuck you are talking about or just go away.
So I‘ve followed the thread quite a bit and I saw a couple of red flags here. My very honest opinion is, that you are either a troll or you have problems that don’t fall in the /r/php category. Your initial question was if you‘re falling behind, and after being told that you are in fact falling behind, you do nothing, but defending your points that have been already invalidated by the PHP community many years ago. You‘re talking about modern standards in a very condescending manner: &gt; Any of these modern frameworks Speaking of frameworks as if they were some disease. &gt; fancy URL routers What is fancy about a very cruicial problem in the web being solved by lots of smart people? &gt; giving other people control over my project I don‘t get it. This must be trolling. It‘s not that composer automatically downloads malicious code while you‘re sleeping. You‘re not giving control away and you are still very responsible for reciewing what you are bringing into your project. The composer ecosystem has even brought out automated lists of malicious packages by high profile companies such as sensio. Who are you, that you are taking it for yourself being able to read, understand and find any flaw in every third party package whose zip you download? &gt; I seen „PSR“ referenced Again, speaking of diseases? Disregarding well established standards that exist for over 10 years, I see. The only conclusion that I can draw from here is, that you are either a troll or you have tendencies of a very narcissistic personality because you think you are smart with what you have built. But disregarding solutions that have been built over years, from very smart people, because you think you have done a better job, is the opposite of smart. And while you might have success with the way you are working, I hope you are not ruining others in the future with your mindset, and I urgently hope that no poor soul who is just starting out finds their way working with you.
Every word you wrote on the post and on the comments is making me so angry with you, op. In my career I have been working in many different companies and have encountered many people like you, who thinks that their way is always the best and that the world is crazy in doing things differently. Working with those people is frustrating and exhausting, it feels like hitting a brick wall with your head over and over again. The code is never as good as you think it is, because is not as battle tested as some code seen/reviewed/used by thousands of people in different scenarios and environments. If you are clever enough, you can apply the occam razor principle to this scenario : Is it more likely that the whole php community is doing the wrong thing using composer and framework and I am doing the only sensible thing or the other way around? Just as a personal advice, change your attitude towards other people solutions, try them on a side project, you have nothing to lose, it will click eventually. That said, please /r/php stop downvoting him in all the comments, different opinions doesn't deserve negative karma, he probably knows that he is doing something wrong, even though he's stubborn, otherwise there is no reason to post something like this.
This looks really cool. That being said, I can’t think of event/reactive systems these days without having wartime flashbacks to magento 1’s event overload/priority system.
I never worked with Magento, is it that bad?
Codewars looks good! Ive been using hackerrank which is pretty much the same thing but unfortunately, a lot of the problems seem quite out of date! I will give code wars a go and also try to find an interesting composer package.
Answers that get more votes, or are accepted by the question author, is a little bit random on Stack Overflow. It's a great platform, but the acceptance vote is merely an expression of one person's opinion - which answer most helped them. There could be a technically excellent answer but spoiled by snarky remarks towards the question author, and that answer might get some downvotes. Thus, while it is fun to collect some points on Stack Overflow, don't look for voting perfection for each post! `:-)`
You could build syslog psr3 compatible class in 1 minute dude...
Honestly: no. It’s no worse than any large piece of code with a lot of moving parts. In its raw (pre third party vendor modules) state it’s not _that_ bad. Some people hate symfonys sprawling component maze, some people hate Magentos XML cofiguration hell / weird Zend framework half integration. I think the main issue with other peoples code is that it’s other peoples code. It’s only once in a blue moon I look at someone else’s code and think “that’s gorgeous, elegant and slightly erotic”
Creating a project where i use Symfony flex with their messenger bundle annd amqp (rabbitMQ) and it works pretty must out-of-the-box. &amp;#x200B; But i cannot get the head around a few things. &amp;#x200B; 1. how to add queue items with a priority? 2. if so, is it possible to change priority of an element, could be that an element have prio 3 (low) and a new update to the element in the queue is with a prio 1 (high), then the prio 3, should be changed to a prio 1? and so on. 2. how to make the queue unique, so two items cannot be the same? Is it possible to search through the queue to see if theres a match)?
Let me guess - you still don't use namespacing and autoloader?
https://vvvvalvalval.github.io/posts/2018-11-12-datomic-event-sourcing-without-the-hassle.html Not really relevant for PHP since Datomic doesn't have a client protocol yet, just a rest interface outside of its host language but https://vvvvalvalval.github.io/posts/2018-11-12-datomic-event-sourcing-without-the-hassle.html#difficulties_of_conventional_event_sourcing is probably something worth reading if you're about to bet the house on this as your data persistence
I wouldn't say never, there is a time and a place to use eval. But indeed you should try to avoid eval as much as possible.
Yes, you're crazy. &amp;#x200B; PHP without Composer and PSR standards is a (greater) nightmare.
&gt; Some people hate symfonys sprawling component maze wat? magento is a special kind of bad
I didn't say _i_ hated symfony's component library, but there are people out there who do. Some people are against the opaque complexity of reflective dependency injection entirely, and would prefer the old days of singletons and untestable code. Case in point, [a post on this very subreddit from yesterday](https://www.reddit.com/r/PHP/comments/batx33/am_i_fin_crazy/?st=ju9kczhe&amp;sh=ddbd2266). I personally think the attitude is archaic, but there you go. ¯\_(ツ)_/¯
You dropped this \ *** ^^&amp;#32;To&amp;#32;prevent&amp;#32;anymore&amp;#32;lost&amp;#32;limbs&amp;#32;throughout&amp;#32;Reddit,&amp;#32;correctly&amp;#32;escape&amp;#32;the&amp;#32;arms&amp;#32;and&amp;#32;shoulders&amp;#32;by&amp;#32;typing&amp;#32;the&amp;#32;shrug&amp;#32;as&amp;#32;`¯\\\_(ツ)_/¯`&amp;#32;or&amp;#32;`¯\\\_(ツ)\_/¯` [^^Click&amp;#32;here&amp;#32;to&amp;#32;see&amp;#32;why&amp;#32;this&amp;#32;is&amp;#32;necessary](https://np.reddit.com/r/OutOfTheLoop/comments/3fbrg3/is_there_a_reason_why_the_arm_is_always_missing/ctn5gbf/)
I think it's good to keep up with modern development "best practices". Especially when it comes to crypto and other areas of security. Otherwise you're at risk of being blissfully unaware of introducing critical flaws (security or otherwise) into your applications. Using OSS also means you don't *need* to know the low level details of how a certain protocol or whatever works, meaning you have more time to focus on building the components of your application that are revenue-generating.
Are you working professionally (as in, getting paid for programming)? &amp;#x200B; You are dismissing things that are well proven since long long time ago, eg. composer is just a dependency manager, they are used in any other programming language. Not using it because "it gives control away" is just a misunderstanding/ignorance/narrow mindedness on your part. It doesn't matter what version you started with, that's the past, and thankfully it's long gone, and it's holding you back, because you are still stuck in a PHP4 era mindset. &amp;#x200B; No sane employer is going to give you a job like this, if you are consulting you can do whatever works for you, but these things would give you a competitive advantage (or more likely, reduce your disadvantage).
This is a really good article, thanks.
... dude you’ve completely lost the plot. I said PHP is unique in that it enforces typehibts at runtime. It didn’t say PHP doesn’t enforce at runtime. I also said Python doesn’t enforce typehints at runtime. I also linked you to the PEP that literally says so. You claim otherwise anyway. Your trolling is weak.
don't knock it till you try it. get your feet wet. some amazing work has been done in PHP in the last 10 years. it sounds like you have missed all of it. I can't fathom going back to, basically, the way you are still working. There will be shortcoming, it will be a learning curve. But believe us, the benefits are huge.
You are right about psr. I have never used one of them and probably will not to either. I am working on a framework myself too and it is getting somewhere. I might implement an exporter/importer to psr request, response objects but that will be it. I do not agree with some of the guidelines. Your dependecies doens't involve your framework but you project. Composer vs git submodules, i prefer git submodules as i already use git in my projects anyway and composer only adds another dependecy. And with the same additude i look at PSR, it handle stuff just different then my application does, like compare french with english or american, british, australian english, its all english but which one you prefer...
&gt; So am I old guard falling behind or properly ignoring the middleware fads here? Both, probably. There are things that your approach *cannot do*. It's not going to scale to larger teams or more complex problems. Alternatively, there are things your approach will work fine on. &gt; Seems like there's been a whole working group coming out with standards for all of these frameworks to interoperate together or some shiz. Yeah, and some of them are very valuable for solving specific problems. If you don't have them, great, but don't assume others may not be in different positions.
As you can clearly see from above (or just by trying to run some python) `TypeError: must be str, not int` What in the fuck is that if it's not a runtime type error caused by using a type hint/declaration, the same way PHP does it ... at fucking runtime. &gt;I also said You've said a lot of things, most of them nonsensical ...
And why do you think anyone here would want to buy your pet shop software?
I clicked the link because I simply wanted to know how it can export closures. For the lazy: &gt; To do this magic, VarExporter parses the PHP source file where your closure is defined, using the well-established nikic/php-parser library
Almost every post you make on Reddit is spamming links to shit products. You didn't even read the subreddit rules before posting: **Do not advertise. Unless you are sharing PHP-relevant content, please do not post links to websites that you own or develop.** I'm going to go ahead and report this link. This is a subreddit for people to discuss the PHP programming language, not for you to hawk your low quality wares. Kindly: bugger off.
&gt;Add `composer require --dev phpstan/phpstan` phpstan has a lot of dependencies. Using this phpstan-shim package instead would speed up and simplify the things a lot. Installation: `composer require --dev phpstan/phpstan-shim` then run: `vendor/bin/phpstan.phar analyse src`
I wouldn't worry about it, you have a lot of very subpar developers on this subreddit who don't actually understand what it takes to write good, stable software, but are very quick to dismiss those who do. It sounds to me like your software is probably fairly small in scale, with relatively small teams, and so forth. That isn't a dig, just an observation. Your approach works because it's very simple, and you have completely control. This means there are no surprises, and meeting whatever quality you expect out of the software is much easier to do. I say kudo's, and if you ever find yourself experiencing pain maybe small incremental adjustments can be made. But I would definitely ignore most of the people on this subreddit. The reason they talk about things like "best practices" is because they read stuff and regurgitate it, not because the actually know what they're doing. They don't know what they're doing, which is why the use best practices rather than what works for the specific project at the specific scale they're working on. And for what it's worth, I personally have hated routing ever since rails made it popular. IMO discoverability is a big deal, and having it based upon the filesystem is about as discoverable as you can get. Not that routing doesn't have its uses, but it's overused. ASP.Net Core razor pages are very similar to what you've described. They route based upon the filesystem location of the razor page, and will pass in the rest of the URL. You can also make declarations in the razor page itself about what is and isn't required in the URL. So no more of these stupidly crazy routing files with 500 different rules and the first one to match is the one that gets called and then you spend half a day trying to figure out why some rule is catching when you don't want it to. simple and stability go hand in hand, don't let anyone on these subreddits convince you otherwise.
I do too, but it is a great app and everyone uses it nowadays, so I just enjoy the good parts of it and ignore the bad ones.
&gt; Your aversion to open source solutions, and the reasons for it, make me certain that I would have to end up doing a lot of work that I simply shouldn't be doing. They say software developers are typically speaking 1 standard deviation above the average in terms of IQ. But then I read things like this and I realize that's the average and there are people below it that keep it from being higher. I say this because this person is using PHP, an open source project. Now, someone with a modicum of intelligence and intellectual honesty might readily identify the irony and think that perhaps they're setting up and attacking a strawman. An internet badass will instead go whole hog into it, ignoring the fact that many companies do, in fact, have policies around the code they can use for this very reason. When you have no skin in the game it's very easy to shit on someone who does have skin in the game and therefore chooses to try and mitigate risks rather than ignore them. for example: https://evertpot.com/composer-is-wide-open/ Guess who doesn't have to worry about those types of vulnerabilities? yeah, exactly. Maybe in the future be more fair to the people you're responding to.
A lot of people here already answered well, but I would like to give it a go too myself on a few points: &gt; I do not like the concept of giving other people control over my project, which is really what composer does. No it does not. Composer does only what you tell you to, you can review all your deps, commit your .lock file and call it a day. And obtain (optimized) autoloading for free in the process. &gt; If you go look into the node.js ecosystem you will be met with many of examples of why this is a horrible idea. There are two fundamental differences with the Node ecosystem: * dep tree is a lot more shallow in PHP * source is always in cleartext for Composer, so no hidden malware here, everything is readable and verifiable. &gt; so am I old guard falling behind or properly ignoring the middleware fads here? Yes. You're falling a lot behind. You will probably have a lot of trouble in finding experienced developers that would like to work with you and with your "ways". &gt; I have never seen my application (along with it's associated Linux OS built specifically for the application) go above 250MB memory usage during stress testing and I have a feeling if I involve some kind of middleware framework I will significantly increase resource consumption. Doesn't mean anything. My Alpine containers are at 122Mb stable with 5 FPM workers, without peaks when under stress. And I'm talking about a Symfony 3 full stack application, so nothing lightweight.
bro, don't you know? if you're not writing your own OS networking stack then you're being a hypocrite for writing your own router. that's how it works bro!
This's the most savage comment I ever encounter. Soooo damn good! Still I love PHP. BNP Paribas use PHP in day to day transaction. Using Zend.
Personally I'd avoid Lumen and go direct to Laravel. There's rarely a situation where you must use a microframework.
You say you want to give your developers a healthy work/life balance but then insist on doing everything like it's 2006. This field is very dynamic in nature, things change all the time. The sign of a good developer is how well they can adjust and keep up with these changes. Staying current is one of the most important things you can do in this industry.
Good post, I’m just reading through a series on Kubernetes and was wondering about best practice for containerising php apps so this was nicely timed. Thanks for writing
There will be a part of the series the discusses Kubernetes deployment soon, so stay tuned. :)
no he didn't. Why did this bot get triggered?
&gt; but I typically use an “include” file structures You should start with COMPOSER (and autoload). PSR is specification, not implementation so if you are a pragmatic guy then you can skip the whole PSR and go straight for the implementation (in the case, Composer's autoload)
Tl;dr; - Yes you are. At least a bit.
&gt;We have a lot of code that is either no-framework And it is even worst when there is no documentation (not even comments in the code) &gt;Every task I work on I have to reverse engineer another developers "simple, clean" abstraction that doesn't follow any traditional standard Wow, I'm having flashbacks of a project that mixed PHP, JQuery (not snippet of code, the entire JQuery min) together in one ridiculously huge file. &gt;The time to setup a project and reproduce the issue drops dramatically. Productivity increases. Everyone wins. No only that, even the Original Developer forgets how a piece of his own code works. If we use standards, everyoney wins.
I love Vagrant. However, even if you use Vagrant, the first time you set up a "no-framework" project is not easy. I've been there, but once you got a Vagrant box up and running is so awesome!
Pre-emptive strike. They are starting to become self-aware....
I hadn't heard of event projection so I Googled it and read this additional article, which others here may find useful: [https://dev.to/barryosull/event-sourcing-what-it-is-and-why-its-awesome](https://dev.to/barryosull/event-sourcing-what-it-is-and-why-its-awesome) . I still don't completely get it but at least now I have the beginnings of an understanding of it.
Let me try and explain a little better, im looking for someone who could provide their ideas and how they would solve a problem so I can learn various different ways of doing something as opposed to what I already know. I don't plan on taking anything as gospel I just want to widen my horizons! I feel like I could answer some simple questions on SO but that's not really what I'm looking for I'm looking to improve my skills and hopefully find new ways to solve problems I already thought I could solve! Hopefully, that makes my intentions a little more clear! Also, 20m people is a lot 0.0
I didn’t check it supports all of the HTTP methods, but the concept what you have implemented has a lot of sence. Nice work. However the class structure could be more nested to separate exceptions from others and I think the vendor name is missing from the namespace.
(OP here. Not the author of the package, just thought it was an interesting way of handling routing.) &amp;#x200B; &gt;the class structure could be more nested to separate exceptions from others Not sure I follow. Got an example? &amp;#x200B; &gt;I think the vendor name is missing from the namespace In the namespace of the action classes?
No, it didn't hurt my feelings in the way that you're projecting it has. It annoyed me for a minute and then I forgot about it and moved on for the day. But it did annoy me for a second, and that's the point: It was unnecessarily hostile and had a negative impact on my day and our conversation. I don't agree that by pointing this out I've revealed some shortcoming in myself like you're suggesting. I think it's an objective reality that when you come at someone with hostility, it's going to have a negative impact on their mood. This is a basic emotional response and it's how we choose to respond to that feeling that tells about our character. But I don't think it's fair to blame me for pointing out your behavior and suggesting that you could do better. Also, my life has been anything but sheltered but I don't need to justify my life experiences to you.
I have mixed feelings about this one. On the one hand, first two results from google for php mysqli live search tutorial are much, much worse. One features a shameless SQL injection and another is has a lot more cargo cult code than yours. So undoubtedly your tutorial does some good. On the other hand, let's compare this code $username = trim($_GET['username']); $startFrom = filter_input(INPUT_GET, 'startFrom', FILTER_VALIDATE_INT); $like = "%$username%"; $sql = 'SELECT name, picture, description FROM users WHERE name LIKE ? ORDER BY INSTR(title, ?), title LIMIT ?,6'; $statement = $mysqli -&gt; prepare($sql); $statement-&gt;bind_param('ssi', $like, $username, $startFrom); $statement-&gt;execute(); $array = $statement-&gt;get_result()-&gt;fetch_all(MYSQLI_ASSOC); echo json_encode($array); with your tutorial. As you can see, your version features quite a lot useless code and at the same time it lacks important parts such as error reporting or the proper use of API. Although you admittedly tried to learn best practices, it is evident that you lack practical experience. And for writing tutorials it's essential to have your own experience. You have to say something from yourself, share your unique experience. In a tutorial, you are supposed to share a result of some experiment or research. But there is nothing of this sort in your present work. Next time try to review every part of your code and see how it can be improved.
Just come to Code Review then and ask about your snippets.
For years I've had the ternary operator in the back of my head as a "shorthand if." I don't know where I first encountered it presented that way, and have barely ever had any use for the ternary operator anyways, but this makes a lot more sense.
So, would you make a joke just to have an asshole bot reply to you, or would you miss the opportunity to crack people up? The answer is no. You make a joke and nobody bothers you for it. That's how it should work like. Please stop being an asshole. To the linker, don't let this bot discourage you from linking to your sub! I am a bot made to track this bot and reply to it. If I misinterpreted the context, please inform me.
Beep boop. Hey, I"m a bot designed to reply to this bot, when he's replying to another bot. If you think I should remove this post, please respond with "!bigblackcock". 1111111111111111111111111111111111111111000000000000000000000000000000000000000011111111111111111111000000000000000000001111111111111111111100000000000000000000111111111111111111111111111111111111111111111111111111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111000000000000000000001111111111111111111111111111111111111111
I mean classes could be in child namespaces. Packageist recommends Vendor/Component naming convention.
Are individual classes for every single route a good way to go? It seems weird to me. I can see some advantages as in your "controllers" are simpler and smaller, but you also get so many files. That probably isn't a problem though.
I've been using single-action controllers (a.k.a "Actions") for some time now, and I love them. Keeps things simple and tidy. I'd argue the number of files shouldn't get in the way of good object design.
This is quite brilliant! I definitely see some use cases for this.
1. You declare the queue with an [x-max-priority](https://www.rabbitmq.com/priority.html#using-x-arguments) argument and then publish the message with an additional property called `priority`. 2. Messages are immutable so you'll have to re-publish it and then return to acknowledge the old message. The instance of [AMQPMessage](https://github.com/php-amqplib/php-amqplib/blob/e2f9b7c136cfc62ddcd53425385e4a66fa483e83/PhpAmqpLib/Message/AMQPMessage.php) that's passed to the consumer will have all the properties you need to re-create the message with a different priority value. 3. Not really possible at the broker level without relying on a plugin like [noxdafox/rabbitmq-message-deduplication](https://github.com/noxdafox/rabbitmq-message-deduplication). You could also handle this at the application level but it's difficult to suggest how without knowing more about the use-case.
The thing is, I wasn’t hostile until you said that it hurt your feelings. Calling something stupid doesn’t necessarily mean that the person doing so is hostile towards you. In any case, that’s as much as I care about this discussion, let’s move on.
Spatie to the rescue again. We are using event projector. Is this aggregates a new feature of v2? Is v2 event projectors backwards compatible with our v1 codes? The idea that aggregates need to process everything that happened in the past seems to make them just as prone to slowness as counting things. I’m a bit confused why adding a layer of complexity here will be better in the long run? If millions of accounts have billions of past events, surely aggregates will be too slow to put in controllers, and news to be offloaded to async cli calls, no?
Thank you for your response. Must I use composer to auto load?
I always wanted something like this but never had the time or knowledge to implement myself, really useful for throwing together a quick web application.
The more you use request handlers per route like that the more it makes sense. I was refractory at first but I'm now totally convinced.
Magento makes wordpress look like a clean, well put together system.
PHP doesnt support async, so the event listener is executed as a simple function when the dispatch() method is called, afaik.
I have a funny feeling that none of these products are compliant with any industry standards bodies either. What does it take to get banned around here?
Without an aggregate you don’t have the possibility to make business decisions on events that have happened in the past. If you have millions of users and billions of events, there’s solutions for that in event sourcing like snapshotting.
Indeed this is how it works
Well, disappointing, but thanks. Will look for other methods to achieve what I wanted
You're probably looking for the [Messenger component](https://symfony.com/doc/current/messenger.html) for handling queue-able separated processes.
You don't need to use Composer to do PSR autoloading, no. Most people do because they're already using Composer for package dependencies, so you get benefits of both.
From what I've seen, PHP \`mail()\` isn't trusted by some/many anti-spam systems.. You'd probably be better off using an email API service, there should be a few good options with free light-usage tiers.
Thanks for the reply! I've been periodically checking our spam filter as I've been testing and nothing is getting caught or blocked. I'll take a look at some APIs but I'd really like to understand why this doesn't work. Thanks!
Cool, I’ll be looking into composer in the very near future. One last question, if you don’t mind answering. What is the difference between dependencies and components?
I'm 99% certain this is going to end up being a settings issue with the distribution group. By default Exchange groups don't allow external email senders - they're internal only. Your Exchange admin should check the box to allow email from external senders. &amp;#x200B; Now, for the 1% situation where it's not that setting, try setting the Return-Path header to your email address, and provided that your mail transport (SMTP server) doesn't rewrite that header you should get any bounce messages back to your email account that would hopefully indicate the failure reason (whether it's a spam block or otherwise).
That was it! I hadn't changed the default "Internal Mail Only" option on the group. I can't believe I missed that, thank you very much!
First of all, if you generate HTML then you must properly escape the user input in the generated output. Some "evil" user could provide some extra code as their name and everyone in your distributiongroup might end up clicking an ebil link in the end (or worse.) Second you can't just send some HTML like that (this probably gets filtered out as malformed e-mail message.) You need to specify a transfer encoding method (e.g. quoted-printable or base64) and encode your content accordingly. W/o transfer encoding e-mails are only valid with plain US ASCII. Ideally HTML E-Mails are using Content-Type: multipart/alternative and then send the content once as plain text and once as HTML in separate MIME parts (look up "MIME" how to do that properly)
A lot of JS, Node and PHP developers have zero clues about security and cryptography, as evidenced by the highly opinionated _ignorant_ people in this thread. Case in point, they love Composer. Composer is inspired by npm. Npm is a major security vulnerability in any company. You download packages from randoms. Next time you run the package manager it probably updated the package automatically because the developer updated the minor or patch version. None of the devs review any of the code after updates. They just treat it as a trusted blob of libraries. Then those packages you specified rely on other packages. Some other package you indirectly pulled in has a vulnerability then you get it too. Some developer of the package decides to give up one day and hand off the development to another dev. The other dev is malicious and bundles some malware into the package affecting millions. Yes, it's happened before. Maybe there is a way with Composer to lock the version you want, review the code of those dependencies and store that code in your repository. However it's still missing an important feature: package signing. Apt for Linux is good because the distro maintainers review all the patches, build the packages and sign them cryptographically. You trust them to do a good job. In NPM and Composer land it's just the wild west. People commit in whatever they want. Packages sit on a server somewhere unsigned just waiting for a hacker to breach the server. Or the updates are delivered over plain HTTP. Nobody reviewing anything. A disaster waiting to happen. I don't think programmers should graduate from any university without having done a basic crypto and security course. They'd see all this automatic shit as insecure. They'd download only the libraries they really needed from reputable authors, they'd verify the PGP signatures on those libraries, then they'd review the code, then they'd use them. It's the basic due diligence that only the smart people do. I have no issue with people that wrote their own custom micro framework which they use on a single project (or other small projects) as long as it's well written and documented. A lot of people don't understand that if they use a big framework like Symfony, Laravel etc then they are stuck with that for the lifetime of that project. The big frameworks don't often care about backwards compatibility or maintaining it forever. You are subject to their whims and desires. They're just upgrading the framework for the sake of it like it's their pet project. So in a couple of years you want to go from Symfony 1 to 2. You are screwed. Rewrite everything. Not a lot of businesses can justify that to their clients. The client wants a new feature. You keep doing it the old framework way or you say to the client, we need another 20k to upgrade the framework first because of reasons. Repeat every year. I know one dev that built a major feature for a large website in ReactJS from 2015 (an early beta). He never had time to upgrade it since then with all the other features and bug fixing requirements that keep coming in. He uses the Internet Wayback Machine to read the docs on it. Stuff like this happens all the time in companies. Also no developers seem competent enough to go in and change the core library or framework code because it is too complex and it wasn't written by them. Their options are to keep using the old version like a black box, or do a complete rewrite at a very expensive time and cost. Contrast this with a small micro framework that lives and evolves with your project that you wrote yourself and can upgrade yourself when you need to. Or you have a few vetted libraries that you use for mailing etc. Life is much easier. If it was written well with documentation and code comments then any other developer can come in and improve the project easily. Then they take ownership of the whole thing. It's more flexible to work on anything in it. Not leave the core of it as some framework black box. To sum up, I wouldn't change what you're doing. It seems to be working out just fine. Let the noobs continue in their perpetual framework churn, never really learning the base language.
Always great quality packeges from you guys at Spatie👍
Always great quality packages from you guys at Spatie 👍 But why/when use event projection instead of triggers in the database? Triggers are very powerfull. What makes this package even better than database triggers? (Honest question)
Once you make them proper services, you can test them more easily than when they're in a big controller. That is the other big advantage to single class actions.
This is genius. I don't know why more frameworks don't implement this feature.
Thanks! Great article
I'd love to understand the mind of someone who puts the effort into writing this comment, thinking they're being a reasonable human being.
Thank you!
Really cool.
A **dependency** is something your project is dependent on, typically an external package written and/or maintained by a third party. That's what Composer is used for - it is a "package dependency manager". Similar dependency managers are NPM for JavaScript and Gems for Ruby. A **component** is just a piece of a larger puzzle or mechanism. A component could consist of local code you wrote, an outside dependency, a combination of both, etc. The size of a component can be as small as a single class to almost an entire application. Component is also commonly used for stand-alone packages under a larger umbrella. For example, [Symfony has lots of components](https://symfony.com/components) that you can use in your projects. Your project would **depend** on one of their **components**. The Symfony Framework combines many of the components into a larger framework to build your project on. You can use the framework as a whole, or individual components as you see fit.
The thing is that Dependency Injection works in the exact opposite way the programming language and debuggers are designed to work. When you debug, you start with the last call, and go backwards. Statements like 'require' and 'include' and 'new' that deal with dependencies were all designed to create the dependency at the exact moment you need them. Dependency injection does this completely backwards. Now when you debug someone else's code that uses dependency injection, you have to go backwards, and then forwards, and maybe backwards again to understand the flow. DI does provide some benefits, but i think it also has plenty of negatives, when it comes to understanding a codebase that is new to you. That extra friction may outweigh the positives of dependency management. In my opinion, the PHP world has gone retarded by trying to adhere to high computer science concepts, which are directly at odds with how PHP was designed to be written ( low learning curve, minimal reliance on abstractions, high productivity ). I would bet that node.js and python circles have not let this kind of thinking creep in to this degree.
Helm? We've found, although it's another thing to learn, Helm really makes things eaiser
Yup, using Helm. For simple setups it works well, but in my experience it's no magic wand: there are lots of scenarios where Helm fails big time, so I would advise caution when relying on Helm. Dependency management, CRDs, hooks are all weaknesses of Helm. But in our case it should be enough.
It is arguable that in order to change a class name you have to change the route, how would you handle localised translated routes? I mean, if you have read the first chapter of comic book and work on your household blog don't talk about good object oriented design
Sorry, dunno how to do line breaks in a post. Only works in comments.
You could make a debug function. function debug($message) { global $DEBUG; if ($DEBUG) { echo $message . "&lt;br /&gt;"; } }
Something like this would be a simple way $aDebug = []; $isDebug = true; .... $aDebug[] = ‘hello debug!’; ... if ($isDebug &amp;&amp; count($aDebug) &gt; 0) { echo implode(‘&lt;br&gt;’, $aDebug); } (On phone, sorry if broken)
Dude, given your activity, you're not new to Reddit. Care to read this subs sidebar?
There should be a hall of fame subreddit for posts like this. Aside from the fact that this is a horrible mess, you want to just remove all if brackets except for the first one and put all echos into the first curly bracket in the right order. For reals, hough: This is so fundamentally simple that you really need to learn the basics of programming first if you genuinely do not see the answer to this. I am sure there is some book or an online course for absolute beginners out there that would help you a lot - this does not even have anything to do wih PHP.
Using Xdebug is not an option?
Legality aside, it's going to be more trouble than it's worth. Anything you would scrape from Google Finance can be more easily and reliably (and legally) obtained through an actual API. Although frequently cited, neither Yahoo nor Google have a public-facing finance API (nor have they ever). Since I assume you're looking for a free option, I would suggest you check out the APIs from [IEX](https://iexcloud.io/docs/api/) and [Financial Modeling Prep](https://financialmodelingprep.com/developer/docs).
Symfony messenger allows rabbitmq as transport if it's what you want..
This implies all of the if statements test $debug for the same value. If that was the case, why not just echo all of the results in the first if statement?
Yea, dude. I looked everywhere. Even the sidebar help and Google didn't pull up anything, only references I found were to comments.
You misunderstood my example. The results can be anything I want to echo, throughout the script. But only echo if a value was set to "yes".
Why not apply a switch-case statement that’s tripped by $debug=‘yes’? You might find more adequate help over at [r/phpHelp](reddit.com/r/phphelp)
I believe he was referring to rule 4 &gt;**No help posts (not including discussion)**
Or resign on the spot. From most his responses in this thread he is completly out of touch with recent development and ignorant to modern standards.
Hey, DrWhatNoName, just a quick heads-up: **completly** is actually spelled **completely**. You can remember it by **ends with -ely**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey /u/CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". And your fucking delete function doesn't work. You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
Start with reading 'php the right way'. It's online and available for free.
Thank you very much for taking the time to write that comprehensive explanation
&gt; `global` Noooooooooope
This is the real answer. Forget about email deliverability when you have gaping security holes like this.
So let's take a common example I run into frequently and i'll give you my very own real-world open source code: Using the very popular PHP HTTP library, Guzzle, you end up needing to do this: ``` $client = new \GuzzleHttp\Client(); ``` But, every good developer will know that importing your namespaces is a great way to keep track of class dependencies, which not only beautifies the code but instantly helps you keep track of which classes are dependent on too many others, thus candidates for split up (See: Single Responsibility Principle (SRP)). So you end up writing it like this: ``` use GuzzleHttp\Client; class Downloader { public function get() { // Not that we wouldn't use DI, this is just a really dirty quick example :( $client = new Client(); } }
Oh? Whoops! In the rush to post, I forgot about phphelp. Feel free to move it, mod.
Thanks. In the rush to post I forgot there was another thread.
Dunno why this is getting downsides...? Made sense to me! ...never occurred to me :)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/phphelp] [$debug='Yes'; if ($debug!=''){echo $result1.'&lt;br&gt;';} if ($debug!=''){echo $result2.'&lt;br&gt;';} if ($debug!=''){echo $result3.'&lt;br&gt;';} Is there a quicker way to echo results, without having to add the if statement to every variable\/query, if the debug variable is Yes? Thank you](https://www.reddit.com/r/PHPhelp/comments/bbgqot/debugyes_if_debugecho_result1br_if_debugecho/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Not sure. No feedback, maybe my line spacing from phone caused it? r/php for you :)
Because you aren't going to throw calls to this function all over your code. It's no better than your current approach. You should use your editor to step trace the code
I am kind of like you. Like I don't mind learning the latest technology and techniques. But I am not a code geek. I care more about the final product. I too have been working with PHP working on my own projects to get off the ground. I never used any frameworks. I tried one once but it was too big of a hassle to learn it. And it was too restricted for my taste. I custom code my websites/applications. From frontend to backend. This way I have 100% control over my code. I know where everything is and how to fix it if something goes wrong. I will probably never be able to land a web developer job because they ask for bunch of requirements that I'm not familiar with. I use PHP, MySQL Databse, HTML, CSS/SASS, and Javascript/JQuery to develop all my websites. I can develop any complicated web application using the languages above. But I guess it's not enough to get hired by these high-tech companies. If I did have a job where I'm working with a team of web developers, then I would of course improve on and learn new stuff. But as a solo developer, I am good with what I'm comfortable with. And it's working for me so far.
Honestly I don't understand breaking up request types into separate functions in routers. Like why do I have to type in that something is GET or POST or whatever. Seems verbose and annoying to literally be forced to use that as a name for your functions. When 9/10 of your request handlers are for GET request then why are we typing in 'get' over and over? Computers are supposed to automated things. I used to post fix all my controllers as 'SomethingRequestHandler' and then I had dozens of files in a folder with that name when simply 'Something' would be cleaner to read. Method names are basically the same. Unless you're implementing WebDAV you'll end up with mostly GET requests, a few POST requests, and maybe one file upload function that supports PUT and POST. If you wanna be fancy you can throw in a DELETE for purging an object. But that's it. It seems to me GET requests should be default not have the word 'Get' in it and only the other methods should.
Nice read, thanks!
I'm new to this; what's to stop someone from just using POST instead of GET for everything that's currently GOT? Besides the parameters being sent as form data instead of a URL string, what's the real difference?
Nothing much. Headers that are expected in a POST request like Content-Type, Content-Length, and then the 'content' itself, which is not a header, are all actually optional. Some REST APIs will have some URL like /object/delete/1 where it's required to be a POST to actually delete but a GET will simply return the object. The POST is simply there to clarify intent: "yup I'm serious, delete this" but there's no actual POST data being sent to the server.
When I posted the same article 3 days ago on reddit, the awesome reddit told me this tutorial is not beginner friendly and I should explain more. ([link](https://www.reddit.com/r/PHP/comments/bad7dz/how_to_use_namespaces_in_php/?utm_source=share&amp;utm_medium=web2x)) So, I read the manual, other websites, SO posts and got new ideas for explaining namespaces in PHP. And, Rewrote the article. What do you think? Have done it correctly this time? &amp;#x200B; Thanks.
Thank you!
It's definitely a good guide for beginners. But try to use proper terms: those "nicknames" are called "aliases" - but it's a great analogy! Also, you may want to refer to the according PSR standards. Kudos for good mix of graphics explaining code and actual code.
Personally, I don't think "always one class per action" is a good rule at all. 1. Experienced engineers from other languages do not seem to be doing this 2. It sounds like a "silver bullet" and eliminates design thinking 3. We are not applying usual OO design principles. If we have a number of actions which have the same set of dependencies and/or share some logic, e.g. cross-cutting concerns such as auth or logging, then it makes sense to put these actions in the same class. Just like when we design other types of object in our application, such as services, entities or VO's, we should consider principles like GRASP which help us to decide where to put functionality
I would argue that this isn't design, as there is no room for design here other than in the naming of the routes. Rather, this approach eliminates design with a fixed "silver bullet" approach.
How about something like: final class FileLogger implements LoggerInterface { // use external package or see https://www.php-fig.org/psr/psr-3/ } final class WhatEver { /** * @var \LoggerInterface $logger **/ private $logger; public function __construct(..) { .. $this-&gt;logger = new \NullLogger(); } public function setLogger(\LoggerInterface $logger) { $this-&gt;logger = $logger; } public function publish() { $this-&gt;active = true; $this-&gt;logger-&gt;debug("Publishing.."); return $this; } } $whatever = new WhatEver(); $whatever-&gt;setLogger($container-&gt;get('FileLogger'));
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Some composer deps are published by vendors like AWS and Stripe. I'm going to trust them over my own implementation. The reasons, I think, are self evident.
This is another good resource https://symfonycasts.com/screencast/php-namespaces-in-120-seconds
*Eyy, another year! * It's your **10th Cakeday** tylerjwilk! ^(hug)
That's when CQRS becomes a handy companion to ES. After write operations on your aggregates (new events) create/update projections (read model) that can easily be read/queried through e.g. SQL.
Boast03, Thank you very much. I used the term "nickname" as it is very common. And, I think it's better to mention the term "alias", because for the learner who learn namespaces for the first time will be confused when seeing "alias" in other resources. (Thanks for the suggestion) All the PSRs will be reffered in a upcoming tutorial (PHP OOP Recommendations). ATM, I'm writing that. Thank you.
She calls aliases nicknames too
Even better would be to split up your 'contains' and 'position' find methods into two separate functions, and throw an exception in the second one if it's not in the string. Returning `-1` just creates a slightly different weird thing to check for
I'm curious about your framework. Please post me a link. &amp;#x200B; Always depends on what is your goal. My goal was to make Webiik for myself, to scratch my own itches. Thanks to Webiik I can deliver my work faster and provide better value to my clients. Also, I have learned a lot while writing, documenting and launching Webiik. &amp;#x200B; I live from making promotional websites for big FMCG brands. Typical Promotional website is short lived and means a lot of custom things delivered in very short time, usually 1-3 months. Big frameworks don't fit well these requirements. Then there is a problem with infrastructure and traffic. Usually, promotional websites are hosted on clients infrastructure due to GDPR, etc. - the problem is this infrastructure is usually not extra powerful, it makes sense because FMCG brands live from different things. But promotional websites have traffic peaks (ad in TV, online campaign, happy moment, etc.) then man really cares about the efficiency of FW. &amp;#x200B; I don't have any ambition to grow the community around Webiik. I give it as it is - simple and well documented. I use it daily for my work, so I gradually improve it. If Webiik helps one people, it'll make me joy. &amp;#x200B; Now you maybe ask, so why I even launched Webiik on Reddit, HN, PH, Twitter. The answer is simple, I wanted to learn to launch the indie way. Webiik was ideal for it. It's a tech "product" and I don't risk anything. Honestly, I thought, I will launch it and nobody will care - just another no-name PHP framework. Except for Reddit and few posts on Twitter it was a truth. &amp;#x200B; More about story of Webiik: [https://twitter.com/JiriMihal/status/1113869560455757825](https://twitter.com/JiriMihal/status/1113869560455757825) Some stats from launch: [https://twitter.com/JiriMihal/status/1114121275146940416](https://twitter.com/JiriMihal/status/1114121275146940416)
Yep ... A lot of people follow the herd mentality. This can be advantage because they do not need to do a lot of things themselves. You want X, why bother learning to understand it, simply download package Y. Security issues be dammed because its external, so the responsibility for those fixes are external. As a developers, if your software is vulnerable because a external package does not get updated and you do not understand how it works, well, ... you can tell your boss that "its not my fault" and point to the external package. Frameworks are also funny. PHP is a framework, so lets trow another framework on top. * Why use SQL, when you can have another ORM layer. No need to learn SQL, what is more important he... * Nothing more fun as seeing a framework role its own template language ... PHP is designed as what again? * Or the funny database driver abstraction layers, because one day we may want to switch between mysql and postgresql, you know, future proofing a change that will NEVER happen. * ... Most project need at best 5 files for framework handling... Maybe some auto loading DI support, routing if you want a API layer, ... PHP really delivers most things out of the box. Standardizing application layouts that frameworks deliver anybody with experience can setup, for other to follow. Its just a bit of basic folders and namespacing. The issue is, most people here are in the "we follow the framework standards, so we avoid any responsibility". Are their bad developers that write complex custom frameworks making the next guys life hell. Yes!!!! But for every bad developers like this, you have dozens who are cows injecting external code packages, frameworks and other crap into the companies. And when they leave, the same mess and issues also exist but they can hold their heads high and say "but we followed the standards ( of today )". I know of companies who pissed away 100.000's because somebody figured it was a good idea to write applications in Angular, when all the clients needed was basic PHP with some very minimalist JS. Introducing massive code duplication, exposing internal data because it was needed for the double front-end calculations. And finding replacement people became hell on wheels. End result? The "standard using framework" got rewritten. Seen it with so many companies, its no joke. The worst part is, its the clients that always end up footing the bills. Maybe we are old grumpy developers but boy do i get tired of people spewing nonsense, making simple things complicated, shifting the cost down to the next guys. All because they want the latest and newest toys. And lets face it, every developers ( young, noob, old, grump ) is to blame because when we enter a company, every developer want to put the code to his standard. But when talking who does more harm? I am sorry to say but unless you are Google, you do more harm trying to mimic huge company structures and code, when your just a small little 5 or 10 man team. Its this big P*** envy that gets under a lot of developers their skin and they do not realize this.
Webiik will never support PSR-7(PSR-15). If you need it, please use Slim. I need to keep Webiik as efficient as possible. More about it: https://www.reddit.com/r/PHP/comments/b8x2d1/php_framework_with_only_1062_lloc/ekjhqnd?utm_source=share&amp;utm_medium=web2x I agree with unit tests and I will add them in further versions. I see it's a must for any open-source project, but currently it's not my top priority. Also I have plan to add results of some code quality tests. During development I used PHPCS, PHPMD, PHPSTAN, PHPmetrics and SonarCloud.
How do you deal with restarting containers running cron jobs or message consumers? In "classic" approach with syncing files or switching symlinks it's not an issue, since running jobs will finish normally and newly started processes will be using new code. That doesn't seem to be the case with containers, since you need to stop running container entirely and start it again using new image.
&gt; What would you do if you suddenly had to change jobs? Very much this. speaking as someone who interviews developers I see a lot of people come through with a lot of experience but the same attitudes. It doesn't matter how good a developer you are, if you tell me in the interview that you use the main `curl_` functions rather than Guzzle, that's a giant red flag. I don't want to have to explain the last 10 years of web development to someone who doesn't want to know, especially if they're going to push back with the "but what's wrong with the way I currently do it?" attitude. I'd prefer to hire someone with 2 years experience for half the price who will actually follow the way that we already work, and who will look around for alternatives instead of always just programming something themselves.
Doubt anyone would be cpnfused by it, aliases much bettet explain whats going on aswell.
I meant if I don't mention the name "alias" here for a beginner when he sees "alias" in another resource, he might think "What is that?". So, it's better to mention the term "alias" with the "nickname". Right?
For people reading about Event Sourcing for the first time here, it's worth bearing in mind that the thought leaders in the DDD space who talk a bit about CQRS and ES (which is a form of CQRS) do not suggest that it is the right fit in all situations; rather, it is the right choice only in specific circumstances. &amp;#x200B; &gt;So, when should you avoid CQRS? &gt; &gt;The answer is most of the time. &gt; &gt;Here’s the strongest indication I can give you to know that you’re doing CQRS correctly: **Your aggregate roots are sagas.** Udi Dahan &amp;#x200B; &gt;For some situations, this separation can be valuable, but beware that for most systems CQRS adds risky complexity. Martin Fowler
First, I realize my first comment used the word "doctype" instead of "docblock", so please excuse the habit-typo. But anywho... I'm not advocating for or against docblocks. I'm simply baffled that you made that comment. The only way such a comment could be typed by your hands is if you genuinely didn't know their original intended use case in Java.
Wow, just in time with this game changing revolution.
Yes, of course. That was just an example I was familiar with. There are many non-insane ways to write string finding methods.
That CREATE TABLE statement is quite bizarre. I guess the other number keys on the keyboard are broken but '1' appears to work fine. Also uses '\\' instead of '/' for URLs in a couple spots. Looks like a couple of the more egregious complaints that some people brought up have been "corrected" as I don't see the referenced code anywhere in the article. But there are still plenty of opportunities for attacks. Just a few examples: Injecting a bad username into the database can still result in SQL injection later after successfully logging in, no rate limiting, passwords aren't at least bcrypted, the system is subject to XSRF/CSRF attacks, timing attacks, etc. Tutorials like these are one of the reasons why I created: [https://github.com/cubiclesoft/sso-server](https://github.com/cubiclesoft/sso-server) Rolling your own login system is almost never a good idea unless you are serious about it. (The above SSO server system is over 16,000 lines of application code, has been in development for 8 years, and I've got a task list a mile long for it - and logging a user into centralized login for multiple applications is all that it does.) There are so many nuances to get right and just getting even one little thing wrong will blow giant security holes open in the application. Pentesters tend to look no further than the login script endpoints because the homegrown ones you can crank out in a day are generally full of holes, are one of the first things that people start with when building an application, and are rarely evaluated/vetted. This type of tutorial is part of the overall equation of how data breaches happen. At a bare minimum, login systems (and other software facing the Internet) should not have any of the problems listed in the OWASP Top 10: [https://www.owasp.org/index.php/Category:OWASP\_Top\_Ten\_Project](https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project)
hmm thanks bro..
Do we really can import whole namespace, not specific class? Never heard about this.
Well, containers are not different from any processes in this sense. Restarting the container is essentially the same as restarting a process. &amp;#x200B; If you are concerned about the time it takes to pull an image: you can just pull it before restarting the container, but an orchestrator (like Kubernetes) can take care of this for you. Also, you can configure orchestrators to not stop the old container until the new one becomes ready, so the switch can happen as fast as possible. &amp;#x200B; What's important is shutting down containers gracefully, so that no data gets lost, but then again, it's not specific to containers.
I'm glad you took all that advice to heart, this is a massive improvement to your original article and looks very nice!
There will be bugs.
Big, if true
Still missing any(array, callable), some(array, callable), all(array, callable), first(array, callable), etc...
But what if I want the 2nd key in the array? 😂
This has never been valid PHP, I do prefer working with expressions instead of statements personally
Shamelessly stolen: function array_key(array $array, $keyPosition = 1) { return $array ? array_keys($array)[$keyPosition - 1] : null; } echo array_key(['foo' =&gt; 1, 'bar' =&gt; 2], 2); // bar
The Not Invented Here anti-pattern is a huge red flag. Like you said, it indicates a lack of trust and possibly a Dunning-Kruger complex.
Right, I may have miscommunicated. When I said "as of" 7.3 I was referring to the version I was testing with. I probably could have said that as "tested with 7.3.1" to be more clear.
&gt; function array_key(array $array, $keyPosition = 1) &gt; { &gt; return array_keys($array)[$keyPosition - 1] ?? null; &gt; } Wouldn't this be more concise and idiomatic in PHP7.*? [null coalescance operator](https://www.php.net/manual/en/migration70.new-features.php)
Although in case of non-container deployments PHP processes are not restarted (only php-fpm service may be reloaded which handles web requests, but cron jobs stay untouched). CRON job which started before new deployment and finished after it, will start the next cycle using new deployed code without any interruption. That doesn't seem to be the case when using containers, since you have to actually stop all running jobs in order to put the new application's code in place. Making sure all cron jobs are running in schedule with minimum "downtime" and shutdown gracefully seems to be a little tricky in case of containers.
You're right. I just threw something together quick to satisfy the joke above.
Oh, my bad! I thought you meant you had shamelessly stolen the code from elsewhere. ^_^
I did, from the user contributed notes in the OP link: https://www.php.net/manual/en/function.array-key-first.php#123503
Yes, you can alias a whole namespace. This is valid. use Math\Geometry; $circle = new Geometry\Circle(10); PHP Manual says that as: " All versions of PHP that support namespaces support three kinds of aliasing or importing: aliasing a class name, aliasing an interface name, and aliasing a namespace name. PHP 5.6+ also allows aliasing or importing function and constant names."
Missing references for PSR-4 auto-loading.
All of this is because of you and other PHP devs who advised me on improvements. Thank you very much!
I'm currently writing both autoloading and Naming Standards tutorial. I'll link them to this tutorial after writing those.
It is a bummer that `array_value_first` and `array_value_last` didn't pass withing this RFC.
Ah so you literally don’t know what “typehint” is. I’m checking out of this thread.
Hm, I haven't really seen cron scheduling *within* containers to be honest. Either the host OS or the container orchestrator should do scheduling (eg. Kubernetes natively supports CronJobs). If you need to do scheduling within a container, you can manage some sort of state outside of the container (eg. the next time a job should run or when the last container stopped) and use that state to pick up the scheduling. But as I said, leave scheduling to some external system. &amp;#x200B; About graceful shutdowns: I'm not really sure what you mean. With a decent init system you can propagate termination signals to your own process which can finish the last job and quit. Maybe it's a bit tricky in PHP, but it's doable. Also without scheduling this problem becomes even more trivial. Based on how long your jobs run, you can configure the timeout your container runtime should wait before terminating the container.
Now I want the third one :P
Sincere question: is this actually something to be excited about or is this a joke post? Couldn’t you just use array_keys?
Why not simply make a debug_echo() function? ``` &lt;?php define('DEBUG', true); function debug_echo($in_str) { if (DEBUG) { echo $in_str.PHP_EOL; } } /* ... and then simply call it like that in code: */ debug_echo('This message will appear only, if DEBUG is enabled.'); echo("This is a normal message and will always show up.\n"); ```
For that, we'll have to redefine mathematics.
The RFC addressed this: [https://wiki.php.net/rfc/array\_key\_first\_last](https://wiki.php.net/rfc/array_key_first_last)
Isn't all with a callable the same as array\_filter? Adding a wrapper to arrays is pretty useful if you want an object oriented approach to arrays though, similar to Laravel Collections. I'm not sure what any or some mean here.
Agreed. I wrote [a polyfill](https://github.com/p810/array-fl) for those functions, if this would be useful for you.
You should have sped up my browsing by not posting this utterly knowledge-free link. Installing a couple of stock plugins is not the kind of thing any remotely competent PHP dev needs help with.
[https://github.com/aurimasniekis/throws](https://github.com/aurimasniekis/throws)
 I already asked: just show me some code. I guess you can't, because you don't know what the fuck you are talking about.
Are there any benefits of choosing Unix socket instead of tcp one? Or was it just a matter of “why not”?
Fellow f'in crazy dev here. I am just starting to adopt some "modern" things like PSR-4, Composer and what-not. I am also extremely skeptical, having lived through the dark ages of web dev (I used to build sites as compiled C code). I still snub frameworks, which I have yet to see as anything other than a crutch for subpar devs... but again, I share your crazy. We might be wrong, the possibility is there, but I'm not ready to accept it just yet. Composer does make things easier, since it downloads all the dependencies and creates the autoload.php which you include once and forget. Everything else just kinda works. Following PSR-4, which is mostly a file naming convention, means that composer can load your classes for you. It's a welcome shortcut that circumvents the need to maintain a "big include" file yourself, something which has bitten me more than a few times. Now... you are not entirely wrong about resource usage and overhead in general. I've played with Symfony and Laravel, they are heavy compared to our lean and mean old-school code. They take a while to initialise, slowing down page generation by at least a factor of 10, which is why modern sysadmins lean so heavily on caching/CDN. Thing is, much like everything else in the coding world, people have decided that development time is worth more than runtime, because our lives are finite, but you can always throw more hardware at the problem. A lot of these "modern" practices strive to reduce development time by committing a ton of CPU cycles to do things people like you and I consider wasteful or redundant. It's easier for the average college grad to learn a framework used in millions of deployments, than to learn your or my private assemblage of custom classes used a dozen times.
&gt; But I would definitely ignore most of the people on this subreddit. The reason they talk about things like "best practices" is because they read stuff and regurgitate it, not because the actually know what they're doing. "Best practices" doesn't imply if someone writes good code or not, those are just industry standard like PSRs which make it easier to share code and get people up and running quicker, make it more readable, etc. The actual skills of a developer aren't implyed by the practices he follows, though, as i said, it is mostly better to follow some standard when coding. &gt;So no more of these stupidly crazy routing files with 500 different rules and the first one to match is the one that gets called and then you spend half a day trying to figure out why some rule is catching when you don't want it to. I don't want to get into an argument wether a file or file-system based routing is better, but if you have a routing file with 500+ rules i would rather refractor it or split my logic into more manageable chunks. And if you have some rule that catches when it shouldn't i guess someone didn't adhere to standards set for this project then. It is not hard to set, let's call it, "URL standards" for a project so overlaps don't happen.
I will truly rejoice when they fix the whole `0=='any string'` thing. It makes the == operator completely useless IMHO, and I can't believe it's been in the language since the pre-2000 days. But, yes, you're right, this is a nice addition!
Nice data. Sad to see PHP so far down these lists though.
Some PHP related items I skimmed: - PHP is the 8th most popular language/technology amongst developers, at 26.4% - Laravel is in the most popular frameworks group at 10.5%, along with Drupal at 3.5% - PHP ranks low on the "most loved language" at 45.8%, high on "most dreaded" at 54.2%, and low on "most wanted" at 3.5% - Laravel ranks well in "most loved framework" at 60.1%. Drupal tops the list of "most dreaded framework" at 69.9% (ouch). - PhpStorm ranks at 7.6% for popular development environments - PHP does not appear on the list for languages associated with highest salaries, both worldwide and in the United States
I found their frameworks and platforms sections to leave a bit to be desired. Drupal being listed as a framework while Wordpress is in the platform list. They're both CMS platforms... No Symfony representation? :( No other PHP frameworks represented? PHP makes up a huge percentage of the web and it gets 2 frameworks in the list (1 hugely popular, 1 popular, but not a framework). Python makes up a relatively small percentage of the web but they also get 2 frameworks (although I hear they're quite good). We use Drupal7 a lot here at work. Lots of custom modules for internal business applications. Seems to do fine for CMS, but I would \_not\_ recommend it as a general "framework". Coding in it is an exercise in patience.
I think the explicitness has a higher benefit than saving a few characters each time you create a class name. If I'm coming into a project and I see `GetUser` and `PostUser`, I know what they do. `User` and `PostUser` has ambiguity to it.
You could add a third parameter as a default, too. Just default it to null, but allow a user to pass in anything they want, like 0, -1, stdClass, etc. Also, it can be helpful to know if your default was chosen or if the key existed and the value was actually null. For that reason, I usually don’t like methods like this as it is barely easier and you lose some visibility and flexibility. Just my 2c.
I'm a Drupal dev. I love using it as a framework because I already know how. Understanding it is a daunting task. I completely understand why its the most Dreaded.
yeah, I'm aware of the party line, I stand by what I said. &gt; if you have a routing file with 500+ rules i would rather refractor it or split my logic into more manageable chunks. that just obfuscates errors., which goes hand in hand with my earlier observation about the quality of the developers on this subreddit. &gt; And if you have some rule that catches when it shouldn't i guess someone didn't adhere to standards set for this project then. yeah, I guess all those developers were dumb dumbs for not being able to write new rules that didn't interfere with any of the 500 other rules. My days of disrepecting the quality of developers on this sub is certainly coming to a middle.
Thanks, I hate it
Generally speaking my ORM's REST controller does that so all I see is the methods 'create', 'edit', and 'delete'. Which are POSTs. Everything else is a GET.
The question is why?
Sorry can you explain what the ? does on your int return type?
It allows the return type to be nullable, either int or null become valid return types.
Oh right so like optionals in Swift 😄 Thanks! I learnt something new
This would be a breaking change, and is simply part of using a loosely typed language. What situation do you have which means this matters to you? (not sarcasm)
It's not new and sexy. It has a lot of legacy cruft. Inconsistent syntax for some built in functions. People think that programming javascript on the front and back end sounds like a good idea. Python might be easier to learn. Current computer science fetishist derived high abstraction way of writing php may be a turn off to newbies. Just guesses based on what i've heard. I like php except for the legacy cruft bits. I find javascript to be less consistent. Swift gets me excited, except for the fact that apple is behind it and may pull the rug out from underneath those using it in linux servers for web development at some point.
I can’t figure why anybody would need this.
Yeah, I know it's far entrenched, so unlikely to change, but there was a similar change from PHP5 to PHP7 with operand ordering for something else (which escapes me at the moment). So, I hold out hope. For me, it means I have to do extra work where I *want* type juggling. I understand the convoluted thinking behind the behavior, but in no Universe can I imagine where I would ever want `something` to be evaluated as being equal to `nothing` \- hahaha. The fix for me would be to have either: 1. a non-empty string that doesn't start with a number to be equivalent to 1, not 0. 2. Or, maybe better, to just have the first operand be the one which dictates type for the comparison. So, `'string'==0` would force the 0 to be converted to '0', which would result in `false`. Serious, though, I *do* have situations where I *want* type juggling (and so using `===` isn't optimal), but I can't have int 0 matching with any string. So, I have to do extra work in those situations, which makes the `==` operator completely useless in all code for fear it's going to match at some point where it obviously shouldn't. Unless I'm missing something (please, God, let someone show me something I've missed - lol).
Right, and that's fine, but what does it have to do with the `Get` prefix for controllers, which directly correlates to routing configuration?
From what?
I assume “all” to be “every” from other languages, and “any” to be the same as “some” (maybe?) Every and some return booleans. It can be achieved with array_filter but requires an extra check (comparing the filter length to the original length). These checks are baked in to every and some, meaning you end up with more concise expressive code (subjective of course). Another small advantage of “every” is that it should exit early the moment a false is hit, and conversely, “some” should exit early the moment a true is hit.
I didn't realize how new that function was. I was literary trying to use it a few days back and realized my PHP was too old. I ended up using a different way but I remember it being janky.
I dunno - I was pretty happy to find it a few days back, and then bummed out my version of PHP in production didn't support it yet...
I probably did something wrong.. but here was my reason for trying to use it the other day (not realizing it was a new feature). I had a very wide array of products with one of the traits being a unique identifier and one being a price. I pulled that information into another array with the unique idnetifier as the key and the price as the value. Sorted the array by value ascending to get the lowest price in which the key was the identifier. I then needed the value of the key. Using $array\[0\] would not work as the key was not ordered like that. I used a different method to get the first key (production is not up to this version of PHP yet) but having that function would have saved me a little bit of time. &amp;#x200B; I could have just pulled another query from the database sorted by price but that seemed more expensive than just using an array that was already there.
Why do you put your constants inside classes? From PHP 7.2 (I believe) you can do this: // composer.json { "autoload": { "files": ["src/Math/constants.php"] } } // src/Math/constants.php namespace Math; const PI = 3.14; // src/foo.php use Math; echo "Pi: ", Math\PI, PHP_EOL;
Ah the proverbial bait and switch blog post title. Booo.
You lose friends because we are all using symfony 🤪
Funny enough, Laravel is also 49% most dreaded. Pretty polarized results.
You are allowed not to use it. It's free not to use it. Go ahead, don't use it!
I'm not.
The thing is PHP is decreasing in popularity and increasing in quality, while tools like JS are increasing in popularity while showing more often things like people including dangerous dependencies etc.
For some odd reason I can't update my post... so here it is... &amp;#x200B; I'm having a trouble with creating a shopping cart system using laravel.. I'm open with any type of shopping cart but for now I'm trying out opencart and my main problem is using and installing it... I did copy the source files to my fresh laravel project but the installation procedures won't trigger and shows page not found...
PHP started wrong and seems to be in the right path. PHP just need to really move forward, improvements at 7.x brought many of friends back. I just don't understand this pattern, php is fucking complex language with tons of things to learn and has low salaries and respect. Most popular framework (laravel) is even lacking today for recent standards. It takes longer for me to dev at php than in Go. Go at third position is retard for me. You can almost master every aspect of go in one month. Really simple language to learn. Gobuffalo (framework) has a very scary scaffolding feature, you basically just create your migration/resource and entire crud will be mounted using bootstrap with validators almost ready to use and tests just waiting customization. I really don't get it.
With the unix socket solution there is no network involved at all which should make it faster (especially in a containerized environment where networking can be tricky). &amp;#x200B; Keep in mind though, that you have to scale nginx and fpm containers together this way.
yeah but now i have to upgrade to 7.3
Man I don’t know why people prefer Laravel to Symfony.
&gt; Instead of modifying core registration code, you would simply create an event listener for the "User has Registered" event, which then triggers an email through some external service. All the terminology is sort of confusing me. Isn't this whole topic called event callbacks and closures? Like on my base repository class i have OnBeforeCreate and OnAfterCreate closures that the repository runs. When you make a MemberRepository you define OnAfterCreate to check if they are using an external provider for login and if not, send off an email to confirm their registration. So now that any time anyone creates a member using the MemberRepository email management already looked after.
Stopped reading at "loose"
People still use Stackoverflow? I haven’t found it to be that useful in a few years. The quality of PHP questions and answers are pretty poor IMHO. Maybe somebody smarter than me can explain better, but I think surveys like this are going to be heavily biased towards people who are learning new languages/frameworks and thus, are seeking out help.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Go is high up there solely because of Google developers are behind it... Same goes Swift...
SO surveys are definitely going to be biased, but you might find some interesting year-over-year trends. And the demographics are probably a reasonable representation, even if web frameworks aren’t. A lot of the questions had a weird mix of choices IMO, but I’m not surprised that $hotNewTech is ranking highly on “most wanted” on a Q&amp;A site.
It's end user friendlyish
I adore Swift, and don’t do iOS or macOS development for my day job. Just shipped a web prototype project in it, though I don’t think the web frameworks are quite ready for prime time yet (this is at least partially a documentation issue). When the tooling improves a bit, it will likely become my go-to language for most tasks. I also know plenty of companies outside of Google that are very happy with Go, though it’s nowhere near my personal first choice. Still, happy enough to continue doing most of my work in PHP, thanks to modern tooling. If it weren’t for stuff like PHPStan, that probably wouldn’t be the case.
Based on discussions here on /r/PHP, I am far from surprised.
I already linked you to PEP saying in plain English that Python typehints are not checked at runtime. I’m not going to coddle you like a baby because you’re too dumb to get it.
Not sure if that's a positive quality but it's at least a bit impressive to me. WordPress works on PHP 5.2.4 up to PHP 7.3 (and I'm pretty sure they're also testing it against 7.4 already). Like I said, though, it may not be strictly positive aspect of the codebase itself, I presume there's a bunch of branching depending on the version you use.
As a Go dev (and PHP), for me, it has nothing to do with Google. It's really powerful and fast. In production systems it's a night and day difference. It's interface and struct system really shines and you can really dig into some well defined clean code. There's no magic going on when you read someone else's code, it just flows. Even opening stdlib source files of Go provides a wealth of information for developing. It's package management system quite sucks though.. wish it had something like composer!
Thanks!
Do you mean from the perspective of third-party plugin developers? Can you comment on how it's friendly? (I have some ideas, but trying to get other opinions). Thanks!
The question wasn't sarcastic, but I sure hope your praise of their globals was! I've used WordPress for many years and worked on several sites based on it. I'm also an experienced, educated developer who tries to understand the value of an approach instead of blindly following trends or parroting dislike. For the most part, WP has a pretty terrible code base, but a lot of the awful stuff is there to maintain excellent compatibility with versions of various themes and plugins. It's a huge headache to overcome when building or maintaining anything new, but old work should continue to work until PHP itself breaks it. e.g. the mixed expressions based functions like using `&lt;?php echo get_page_uri(123) ?&gt;`, vs statements like `&lt;?php get_header() ?&gt;` will drive you crazy, but once they work they tend not to get broken by new releases. One part I think is written quite well is the event driven architecture, which WordPress calls its "hooks" system. Coming up with events is challenging, but the ones they've created make a lot of sense in the context of a blogging platform. Closures (and/or namespaces) in PHP made this syntax much nicer too, since you don't need to register a globally unique function name for every single filter or action handler. Being able to [modify the title](https://codex.wordpress.org/Plugin_API/Filter_Reference/the_title) of a page based on the metadata of this post is very useful and a natural approach on a blog. Ultimately WordPress is a good tool for its job, and its job is to be a blog. Its greatest weakness is that it tends to take over your entire PHP application and not leave space for anything else.
It uh... it's.... uhhhh.... hmm... well one thing is... no... uhhh... Hmm...
Slight performance/memory gain in not allocating an array with array_keys when you just need the first key.
Try this tool [http://brtriver.github.io/dbup/](http://brtriver.github.io/dbup/)
As a fan of Symfony I’ve hated how opinionated Laravel is
But aren’t volumes more of a pain when it comes to things like Kubernetes?
A lot.
Probably since Laravel is a lot like react, as in they're both great and powerful frameworks, but often you have to conform to the way they want you to program or impliment certain patterns.
https://youtu.be/fYTKm2oUzAg
Have a look at the changelogs
I imagine this post would be suitable for /r/PHPhelp , but not here.
I imagine this post would be suitable for /r/PHPhelp , but not here.
I’m quite fond of throwing exceptions in cases like that. It means the developer using it and use it in a try/catch and avoids the unnecessary checking for what value is back. If it succeeds, we’ve got it. If it errors, we can handle it in the catch, or with the exception handler. I like it to fail loud and fast 😁
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
One is supported and one is not, so no more security ptches for 5.x
😶
Wasn't support for 7.0 also cut off already?
I wrote a blog post earlier on what's new in PHP 7, you may read here - https://bootsity.com/php/whats-new-in-php-7-2
The PHP Manual includes migration guides, which cover most of the changes you're likely to care about, in the appendices: https://www.php.net/manual/en/appendices.php
Yes. /r/InclusiveOr
They are when it comes to actual (block) storage, but emptyDir does not involve any.
Honestly, I think PHP's arrays are pretty ropey compared to those in Javascript and Python. For most of the things people use arrays for they'd be better off using a collection class of some kind, whether it's something off the shelf like Laravel's collections or their own custom class. Just being able to chain methods is a huge improvement in readability.
Yes [https://www.php.net/supported-versions.php](https://www.php.net/supported-versions.php)
PHP is best, because why not? :)
Being more specific about what you want to accomplish and someone could give you directions. Laravel is a framework. I guess your are talking about this Opencart: [https://www.opencart.com](https://www.opencart.com/). If so, those are two unrelated systems that know nothing about each other. Are you trying to use both? Maybe use Laravel inside Opencart?
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I would love if you could do something like use Math\Geometry\*; $circle = new Circle(10); That way you can get rid of the entire namespace, not just shorten it to single word.
ah yes, let's start using clickbait titles.
&gt; One I can think of is that it might lower global carbon emissions - it does power a large percentage of the world's websites, and using globals for everything and avoiding the overhead associated with objects probably has a lower computational overhead than if the architecture were OOP. You joking right?
I saw both variant, it varies from language to language, any() returns an element and some() returns a boolean, or sometime it means the same, I guess it depends on how people that wrote APIs understood it themselves. &amp;#x200B; What would be very nice in PHP would be a real stream API, working on iterables and not arrays, with stream filters and stream process handlers.
Does Laravel use Doctrine for QueryBuilder or something else? If it does, then it should be specified as so..
No, Laravel uses its own Eloquent ORM
1.5
First tip: upgrade your PHP version. Use 7.3 not 7.1. Second tip: `composer dump-autoload --classmap-authoritative` is more performant than `--optimize` if you can use it Third tip: no, no HHVM...
TL;DR: &gt;developers should never allow user input directly to specify columns, without a whitelist. In our previous example, you could prevent this attack by only allowing certain fields to be requested, this would prevent the issue completely.
&gt;Doctrine Eloquent does not use Doctrine, but Doctrine DBAL also has similar security issues. The problem is that column names cannot be quoted/escaped with prepared statements. More details: [https://www.doctrine-project.org/projects/doctrine-dbal/en/2.9/reference/security.html](https://www.doctrine-project.org/projects/doctrine-dbal/en/2.9/reference/security.html)
I'm not the biggest fan of Laravel but this isn't a Laravel-specific issue, but it simply how query builders / SQL work. There is no mechanism in SQL to escape column names; you *always* need to whitelist them if they're user-supplied.
I thought double quotes was the way to escape. In SAL?
If you're using user input to specify table names, than you have a bigger problem than SQL injection
Neither, both have their use cases
Having a UI present column names and possible joins is perfectly reasonable/acceptable. I'd argue that allowing invalid queries to lead to unintended data access or manipulation is the bigger problem-- that it shouldn't matter if user input accidentally got into the query. * Invalid query? Syntax error. * Denial-of-service query? Should've timed out. * Command injection? Read-only access.
No, not joking. I think as developers we internalize the idea that `dev time &gt; computational resources`, which I believe to be true. But OO code has an overhead that procedural code doesn't: for example, each object you instantiate in PHP uses about 1.5kb in memory overhead for tracking purposes (virtual method table, inheritance metadata, etc.). *As a developer*, I don't care; but multiply that times millions of sites with thousands (on average) page pulls per day, and I think it does have an impact on electricity usage in data centers world-wide.
But in that case, the user doesn't actually manipulate the column name; you're mapping specific columns in the DB to specific columns in the table
I have to migrate a 1000 websites. They are all based on the same base Drupal Docker image. * Every website also has a custom Git repository with a custom composer.json to install some extra modules. * We would like an easy way to update Drupal on all 1000 websites at the same time, by editing 1 composer.json file. * We would also like to give developers of each of the 1000 websites an option to install custom modules. Unfortunately what happens is that when the 2nd image builds, composer start deleting all the modules installed by the initial composer run. How can I fix this? $ cat denpal/Dockerfile.cli FROM php:7.2-cli-drupal COPY composer.json /app/ COPY scripts /app/scripts RUN composer install --no-dev COPY . /app # Define where the Drupal Root is located ENV WEBROOT=web $ cat denpal-example/Dockerfile.cli FROM testdevelopment/denpal COPY composer.json /app/ RUN composer install --no-dev COPY . /app # Define where the Drupal Root is located ENV WEBROOT=web $ cat denpal/composer.json { "type": "project", "license": "GPL-2.0+", "repositories": [ { "type": "composer", "url": "https://packages.drupal.org/8" } ], "require": { "composer/installers": "^1.2", "drupal-composer/drupal-scaffold": "^2.2", "cweagans/composer-patches": "~1.0", "drupal/core": "~8.0", "drush/drush": "~8.0", "drupal/console": "~1.0", "drupal/config_installer": "1.x-dev", "drupal/redis": "^1.0", "drupal/poll": "1.2", "drupal/search_api": "^1.6", "drupal/search_api_solr": "^1.2", "drupal/varnish_purge": "^1.10", "drupal/purge": "^3.0" }, "require-dev": { "behat/mink": "~1.7", "behat/mink-goutte-driver": "~1.2", "jcalderonzumba/gastonjs": "~1.0.2", "jcalderonzumba/mink-phantomjs-driver": "~0.3.1", "mikey179/vfsstream": "~1.2", "phpunit/phpunit": "~4.8", "symfony/css-selector": "~2.8" }, "conflict": { "drupal/drupal": "*" }, "minimum-stability": "dev", "prefer-stable": true, "autoload": { "classmap": [ "scripts/composer/ScriptHandler.php" ] }, "scripts": { "drupal-scaffold": "DrupalComposer\\DrupalScaffold\\Plugin::scaffold", "pre-install-cmd": [ "DrupalProject\\composer\\ScriptHandler::checkComposerVersion" ], "pre-update-cmd": [ "DrupalProject\\composer\\ScriptHandler::checkComposerVersion" ], "post-install-cmd": [ "DrupalProject\\composer\\ScriptHandler::createRequiredFiles" ], "post-update-cmd": [ "DrupalProject\\composer\\ScriptHandler::createRequiredFiles" ] }, "extra": { "installer-paths": { "web/core": ["type:drupal-core"], "web/libraries/{$name}": ["type:drupal-library"], "web/modules/contrib/{$name}": ["type:drupal-module"], "web/profiles/contrib/{$name}": ["type:drupal-profile"], "web/themes/contrib/{$name}": ["type:drupal-theme"], "drush/contrib/{$name}": ["type:drupal-drush"] }, "drupal-scaffold": { "excludes": [ "sites/development.services.yml", "sites/example.settings.local.php" ] } } } Running this composer run will delete all packages installed by the previous composer run: $ cat denpal-example/composer.json { "type": "project", "license": "GPL-2.0+", "repositories": [ { "type": "composer", "url": "https://packages.drupal.org/8" } ], "require": { "drutiny/drutiny": "2.3.*@dev" } }
It's like integrating using api2cart methods to opencart... Using laravel as my project that needs to call the api methods of api2cart to pull/push data of opencart.
Wordpress is totally not a lightweight application. It is as bloated as the epicenter of a nuclear explosion.
I really appreciate your comment, and handn't considered that the API design itself is well done. I had been looking at it from the viewpoint of how it on-ramps new developers: it's easy for designers, content writers, and site owners to learn how to write some basic code and use the hook system to do something they want. I think this gives people a chance to do something productive at a very basic level, and maybe stick around and learn more, and JQuery seems similar to me in terms of who uses it / how they built a developer base. I see Laravel kind of like this too (though don't know it's true): I think it's attractive to people who've learned procedural WordPress PHP / JQuery and want somewhere to grow. Laravel has a low barrier of entry to get started imo. Your observation about the hook API being well written is a great one, thanks!
&gt;There is no mechanism in SQL to escape column names I mean, in theory that's correct, but in practise you can just filter out any character that's not valid for a column name, or backtick it if it does. Backticks can just be disallowed from user-supplied column names and you're golden. (or you can try down the route of escaping them if they're the last character, but it's just easier to recursively remove them from the column name). &amp;#x200B; For our codebase, if we take any column names from user input (it's rare, but does happen on things like datatables), then we just run the column name through this: &amp;#x200B; public function cleanFieldName($input) { return preg_replace("/[^0-9A-Z\$_\.]/i", '', $input); } YMMV, but we find this works fine for us. If you want to support unicode characters you can just extend the regex to allow those in. &amp;#x200B; While no SQL API provides a function to escape column names, it's not an impossible task to create one.
To clarify on manipulate: you're saying it doesn't allow the user to specify the column name (and by implication, the table name). That's solely a matter of how the program is designed. With SQL, its common practice to create a whitelist and/or needless mappings-- even when its fairly simple: (e.g: `first_name` to `first_name`, `country` to `country`) But really, what's advantage/disadvantage of having this information in user-input, unmapped, unwhitelisted-- as it is with nearly every database. If a JSON request has: { "filter": { "first_name": "Space", "country": "US" } } Do we really need a mapping, likely like this? if (columnMap[userProvidedName])
&gt; each object you instantiate in PHP uses about 1.5kb in memory doubt
Neither.
This is micro optimization. WP is FAR from being fast without caching so no, it's never going to save cpu or electricty and if anything I'd bet it's the opposite.
This is perhaps the most shallow comparison with the least amount of facts I've ever seen.
In college I had a professor on tenure that just said F*ck it with my class. She would just sit at the desk and watch YouTube. My advice since I ultimately ended up basically teaching that class myself - "Forget everything" buy a college book on PHP and do lessons by the chapter. When teaching you're not out to teach them everything. You're out to lay a ground work that they can use to go further.
I'm doing the same lately as the company I work for wants to make sure everyone coding has a little general backend knowledge. Laracasts helped me a lot, [https://laracasts.com/series/php-for-beginners](https://laracasts.com/series/php-for-beginners) could help you out a lot. Good luck! Teaching is fun.
You can take some book (like Modern PHP: New Features and Good Practices) and some main topics.
Q vs V: Which letter is the best?
That's very true. I didn't even think of that. I suppose it's better to focus on the bases and let them build on that. Only intervening when they hit a road block.
Note. That's actually a really good idea.
*by the PHP team.
This should be in /r/phphelp
I was about to say "Why would you teach someone PHP" and then saw the sub name. Anyway, the best way to learn any kind of technology is by teching it to someone else!
Teaching is a skill in it's own right. You need to be able to take a complex subject (programming) and make it relatable to those with no prior knowledge. You also need lots of patience. I have taught programming to students and I do the training at my company. It takes experience as with anything else. You need to start with basic concepts; variables &amp; data types, functions and if/else/foreach. You need a narrative; all of your teaching should be building up to an end goal so students can see progression. When I taught students it was Javascript and the end goal of the session was to create a simple todo list. All of my examples were in the context of a todo list (explaining arrays as a list of todos, strings as a todo title etc). This helps create continuity and gives them easy ways to remember what basic concepts are used for. You need a plan; going into a lesson without a lesson plan will mean you to miss important steps and you'll end up bouncing around and destroying your continuity. E.g. there is no point explaining ifs before the student understands data types, as you'll have to stop half way through your explanation and explain something else. The student loses interest or becomes confused. When I did my javascript lesson I wrote the end result as verbosely as possible with notes/comments, and this helped me extrapolate my lesson plan. It also gives you a reference for when you are teaching. I switched between power point slides for visual explanations and live-coding to help show students how things should be written. They then took notes and wrote their own code. Think out loud as much as possible - half of programming is thinking like a programmer. The other half is language knowledge. Make sure the environment is prepped. Environments set up, IDE's installed and configured. You want the lesson to focus on the actual content, not fiddling with other elements that will distract your students. Understand that everyone learns at a different pace. I don't know how large your class will be but I taught a class of 30 16-17 year olds and it was really difficult. Not only do you need to stand with confidence and authority but you need to keep the class focused - hard when you have to stop at each major point and help the slower half of the class catch up. I am not a 'teacher', I have just picked up a bit of experience in my working life. I hope this helps and feel free to DM me if you have any questions.
By what standards?
What issue?
will display single backslash as php will interpret \\" as double-quote
?
are you trying to say escaping is an issue? I dont think you have thought this through.
Like many other languages (JS, Java, Python, ...), PHP will see the first backslash, interpret it as "escape the next charater" (second backslash) and therefore output a single backslash. I don't see the issue. What are you trying to accomplish?
Are you trying to say PHP should have something like raw string in Python? &amp;#x200B; Escaping exists in almost all kind of programming languages. They may just choose a different char for escaping.
Lesson 1. Start by explaining what PHP is. IE, a server-side language. Discuss about when you might need server-side languages as opposed to client side. Then show a basic Hello World as a .html page. Then show Hello World as a .php script that generates the HTML. Talk about how the browser can't tell them apart. Then move on to some of the language features, like variables and loops, perhaps to generate some big HTML multiplication tables or somesuch. Then show how the big strength of php over HTML is in database-driven sites. Do some CRUD examples via HTML forms. Then talk about security and database injections. That should do for your first 6 lessons or so.
I'd say works as intended and expected.... o\_O
it's more a "philosophic question" I just want to hear opinions about this particular case and how other people interpret standards for this "single case", not in general
Yeah, no, that's not how it works. It interprets `\\` as `\` because `\` is known as the "escape" character. So, for example, you can do `echo "Hello \"bond\"";` But here, you've got `\\`, so the first `\` is escaping the second `\`. Basically, there's no issue here. It's working exactly as the escape character is meant to work. It's escaping the next character
I mean, you haven't really posed much of a question? You just asked "How do you feel about an escape character escaping a forward slash?". That's uh... not much of a question for people to have a stance on?
Why we can't user [https://laravel.com/api/5.8/Illuminate/Database/Query/Builder.html](https://laravel.com/api/5.8/Illuminate/Database/Query/Builder.html) prepareValueAndOperator method ?
Coding is an [art](https://geekandpoke.typepad.com/.a/6a00d8341d3df553ef0168e5099eba970c-pi)
It's not an issue. `\` is an escape character, interpreted in strings wrapped in double quotes. If you want to print a string literally, you can quote in single quotes. These are equivalent strings: * 'echo "\\";' * 'echo '\';' PHP does additional processing on double-quoted items, like adding `\n` for new lines or embedding variables within a string without the concat operator (like Python's f strings or JavaScript's template strings). * `echo "this is a line\nThis is a new line.";` * `echo 'this is a line' . PHP_EOL . 'This is a new line.';` * `echo "var: {$var}";` * `echo 'var: ' . $var;`
For some people, [quite literally](http://www.ioccc.org/1998/banks.c) ^[It's ^code ^for ^a ^flight ^simulator]
Yeah, you can prevent malformed column names from being passed, and consequently prevent a broader class of SQL injection vulnerabilities. However, without a whitelist you're still risking data-leakage by allowing unrestricted column selection. As the DBAL can't know what data is sensitive and what isn't I'd 100% recommend explicit whitelisting before you get to the DBAL layer. Even when you know that there's nothing sensitive when initially writing the code you can't forsee how others will modify the code down the line; you're only one new join statement away from leaking something you shouldn't be leaking.
echo "\\\\"; != echo '\\';
&gt;However, without a whitelist you're still risking data-leakage by allowing unrestricted column selection. True. It does depend on the context of what the provided column names are doing. In our case it was sorting, so the direction can be whitelisted, but the field was user-chooseable, so sanitization was more global than a huge whitelist.
I found it interesting (and annoying) that '\\\\' still outputs a single backslash. [https://www.php.net/manual/en/language.types.string.php#language.types.string.syntax.single](https://www.php.net/manual/en/language.types.string.php#language.types.string.syntax.single)
echo '\\';, you escape the second quote, normal
Could you explain how you meant the following part: "Current computer science fetishist derived high abstraction way of writing php may be a turn off to newbies."
Can you define what you mean?
I'm not sure if you can without doing some preprocessing to take your primary composer.base.json file and then merge a site-specific composer.site.json into the composer.json to feed to composer. On the other hand, you're using Drupal - have you looked into multisite? [https://www.drupal.org/docs/8/multisite](https://www.drupal.org/docs/8/multisite)
I'm not suggesting *as a developer* to make these kinds of optimizaitions. The reward wouldn't be worth it - my code will never be used by millions of people. But **in aggregate** for a codebase that is, it does make a difference. And my point isn't about the relative *speed* of WordPress at all - the number of database queries it generates, the number of file handles it opens, etc. Rather, my point is about the difference between procedural and object-oriented code in an apples-to-apples comparison (e.g. disregarding `syscalls`): OOP is heavier, *everything else being equal*, than procedural code. Necessarily, because the runtime has to maintain a [dispatch table](https://en.wikipedia.org/wiki/Virtual_method_table) for every class used. tldr; One person dumping their used motor oil a single time in a lake doesn't really make any difference to the overall ecology of the lake. Every boat on the lake leaking a few milliliters of oil, over time, does make a difference to the lake's ecology.
You're right. I forgot that you can still escape single quotes from within a single-quoted string.
Let them try and make a [dark room](http://adarkroom.doublespeakgames.com/) text adventure game :D
That was true in the 5.*x* series, not sure how the optimizations made in 7.*x* affect it. But still, each object must have a virtual table allocated on the heap to enable run-time method binding. That table must have certain default pointers initialized even in an empty class. Memory must be allocated on the heap for even empty objects, and to avoid expensive memory allocation, default minimums are used. OOP isn't free.
Opinionated in how you do things, like how Laravel had some integration with Vue built in a while back.
Isn't that good though, if you need some direction?
AngularJs is dead, even then, you're using version 1.4.8, while the current version is 1.7? And icing on the cake: $sql = "DELETE FROM members WHERE memid = '$memid'"; A request body of `{"memid":"' OR 1=1;--"}` will drop your entire table. Go learn how to write an app before you try teaching others.
SO and its network are invaluable to my day to day work as a developer, Linux user and low level sysadmin. I couldn't imagine a life without.
It's impossible to find young programmers who are interested in, or even willing to do php it seems. It really is an unsexy language nowadays... And because of this it's falling out of favor for me as well.
[Skub](https://pbfcomics.com/comics/skub/)
The difference between Laravel and for example Doctrine. Is that Doctrine actually warns people about this. The documentation of Laravel did not and stated: &gt; The Laravel query builder uses PDO parameter binding to protect your application against SQL injection attacks. &amp;#x200B; It is only updated for the last version after (I assume the clusterfuck where) people started pointing out certain things were not secure and Otwell's idiotic response to that by pointing fingers to his users saying "they were using it wrong"...
20 minute video for what could be a 3 minute read on a blog post?
i.e. the entire point of using an ORM is that it can filter incoming *data* against SQLi. If you allow incoming data to affect logic, you're gonna introduce vulnerabilities.
Are you a developer of this website or are you trying to use it? It seems like you're trying to use it, in which case there's nothing we can do to help you. You'll need to reach out to the customer support for whatever you're trying to buy. If you are a developer, you'll need to provide some code showing what you're trying to do. The errors suggest there's something not quite right with how you're setting up curl.
See the subreddits rule nr 4: &amp;#x200B; [/r/PHP](https://www.reddit.com/r/PHP) is not a support subreddit. Please visit [/r/phphelp](https://www.reddit.com/r/phphelp) for help, or connect to ##php on Freenode IRC (nickserv registration required). A good rule of thumb is that if you're asking *how* to do something, instead of why something's done, or how to better do what you're already doing, you're probably asking for support.
As the error states, the given handle isn't a CURL resource handler. Possibly you forgot to pass the handle as an argument? Some code would be nice for more debugging...
Ah yes, i see why that wouldn't immediately click in most people's minds. So php was written as sort of a C language derivative that has a lot of handy things for manipulating strings and dealing with HTTP requests, etc. It is also a templating language. It was meant to be a procedural language, as well. If you use it in this way, it has a low learning curve, is easy to debug, understand the flow of the code, and fast to get things done in. However, once it implemented object oriented features, it became a plaything for those who think about higher level concepts like dependency injection, SOLID, DRY, designing around frameworks, etc. So ultimately this has lead to two ways to use PHP.. 1) The way it was designed to be used. Which does have plenty of pitfalls once a project gets very large. And likely results in more refactoring; but with some minimal structure, you can build a project with much less lines of code this way. 2) Sort of an enterprise-grade high concept, high abstraction, highly verbose computer science intellectual art. This uses as many abstractions and layers as possible. This is purported to dodge some old pitfalls but creates new ones. At the moment, way #2 has become the way to write PHP. Everyone thinks you should adopt enterprise grade programming ideologies. Even when not programming enterprise grade code. Way #1 discludes you from the job market because of this. I program mostly in #1, and find it fun, whereas #2 sounds like a lot of drudgery that makes my life harder and wipes all the fun out of programming. New PHP programmers are taught method #2 right out of the gate because the computer science people have dominated the PHP development culture. But python and javascript programming culture is a bit more of a wild west. I think this is why new programmers are interested in those languages. The learning curve on PHP is very low but the CS fetishists have raised it up pretty damn high. If i had to learn the base language and laravel at the same time, i think id be running away to python or JS land as well.
I would recommend [https://packagist.org/packages/mamuz/php-dependency-analysis](https://packagist.org/packages/mamuz/php-dependency-analysis)
I'm developer... and when i'm using it this error appear..
You can actually control the way it gets juggled by casting. &lt;?php $a = 'string'; $b = 0; var_dump($a == $b); var_dump((int) $a == (int) $b); var_dump((string) $a == (string) $b); var_dump((bool) $a == (bool) $b);
I don't understand why it's unsexy, other than the culture that has developed around it. It is fast. With something like swoole, it is faster than node.js, and all indications are that it will get faster than that when we get JIT. It is better at being multi threaded w/o swoole and can scale excellently. It is a bespoke language for web server side business. Although it has a lot of cruft, you can't say that ruby, javascript, or python were designed with web server side tasks in mind at all. The syntax is simple and based on C and doesn't get into functional programming or other bizarre structures that are relatively new and not well understood. It is extremely mature and continues to get better over time. What i would really like is to program server side stuff in Swift myself. It's closer to C/C++ than PHP, faster, and has nice string manipulation features built in. But that's just like, my opinion, man.
The mess of code that exists in the codebase and extensions *because* of the poor quality (that led to globals in the first place) completely negates the minuscule benefits your describing. A more accurate analogy would be a water purifying machine that leaks 100ml of oil for every 1ml it cleans up. Thank god for globals.
It is good for many people, yes. That's why it's popular.
Teach them how you would go about learning PHP (or any other language) yourself. Then support them as they learn through a book or video course. &amp;#x200B; Show them that if one course isn't making sense, don't hesitate to go find another. The skill of learning on your own is more valuable in this industry than any other skill. &amp;#x200B; If you really want to teach them, come up with a project you know they would be interested in. They will have the necessary motivation to learn as other passions intersect. (i.e. someone interested in photography learning to program by building a photo blog deployed to their own domain)
Even if this argument made any sort of sense - OO code's overhead is made up for in the measurable amount of re-use it prevents. So no, it's probably the complete opposite.
Symfony has [deptrack](https://github.com/sensiolabs-de/deptrac), which allows you to see dependencies. It also allows you to define a ruleset for dependencies, and integrate it into your CI.
It was also horribly written. It had two paragraphs which literally restated the content from two previous paragraphs.
Yeah its a fantastic tool, I'm not arguing that. Great for learning but not great for a corporate app.
define("problems", "?");
Error: Invalid Configuration! Document root folder must be set to ise http://localhost. falling back to scheme file:/// Source: open php/html/js in browser (extension) And also dont really know how to execute the code. I mean in NB its just a click. Maybe I also installed the wrong extensions? I have: php debug, php intelephense, php intelliSense.
Document root should be your path to your folder on your C or D or whatever drive
IDEs have many features, but they are only glorified notepads. Just tell your IDE where your XAMPP directory is and it will modify files there.
Any help how to dp that? :D im sorry for my noob question. But in all new on this.
I mean, why shouldn't it? If you didn't need to escape characters inside of a single quoted string, quotation marks as part of a string would not be possible without a lot of annoying concatenation.
I never used VS Code, but I guess at one point, you create a project. When that happens, it will ask you if your project already exists or if you want to create it from scratch. Tell him your projects already exists and give it the path of your XAMPP directory (where the .php files are). &amp;#x200B; After that, the IDE will create a view of everything and start to index the whole project for magic purpose. You should be ready to go.
Those two are not related, that's why you can't find info on it. XAMP is the server use servers your PHP, other one is just a text editor. First Google a tutorial to set up XAMP by itself, so when you go to http://localhost you see your index page. Next, Google a tutorial for vs studio, chances are you need to open a new project whether you set up your root XAMP folder.
[removed]
I agree with what you are saying but I'm very glad the CS fetishists won the battle
Can the mods remove this? It is a bad copy and past of another blogs bad content. The same "tips" are repeated (route:cache, config:cache) and it recommends you use HHVM which no longer even supports Laravel.
all set. but. I have found the way to set it up. [https://i.imgur.com/0V1NEMv.png](https://i.imgur.com/0V1NEMv.png) but i have this error: [https://i.imgur.com/KIAo6rY.png](https://i.imgur.com/KIAo6rY.png)
&gt;, php is fucking complex language with tons of things to learn No it's not. Even if we take into consideration the most complex and modern php development with symfony and 7.2+, php is still quite easy compared to the languages such as Java or C/C++/Rust stuff. &amp;#x200B; But I don't think the complexity is what new people desire. Its all about marketing for the newcomers. PHP is one of the only general purpose languages, which is not 'general' in practice at all. 99% of php is web. There is a possibility to make a desktop app for instance but it's more like a joke. All other languages shine in other areas as well. It's a bit boring if you think about it. &amp;#x200B; PHP's past is terrible (the std library is very poorly thought out) and people used it like a decade ago and don't want to go back. They will never update their opinion on php again because they don't care. &amp;#x200B; even PHP's original name is not 'cool' and rather boring. Personal homepage. Lolwut? They changed it later but still
Having both is probably be the best approach, while you are smart enough to add a white list, NewToLaravelGuys may not.
Laravel doesn’t have an integration with Vue. It literally just has a dummy Vue component that isn’t even used by default unless you choose to. I seriously fear how misinformed the average Symfony dev is about Laravel. I just do a really bad job at explaining things.
Hope this will help you [https://phptherightway.com/](https://phptherightway.com/)
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
No... i've done both and your #2 type is for on the long run. If you know your classes you can do a model view control approach, which separates logic and will eventually help in locating new logic. Especially the model and controller are importand here. Once begun in such framework you will get there fast with the right tools such as an orm which generates the models for you. Classes and model view control leads to cleaner code. With #1 you have to pay attention not to have duplicate behaviour, another one is cleaner syntax shorter function names. Once i had a discussion with an old collegue about required files. I wrote multiple frameworks and uses symfony 1 on work. Symfony1 can grow easilly to 45 required files on a single request, my framework back then around 23 and my current around 15. He sayd that up to 30 is the sweet spot, beyound will slow the application and i agree with him. When stuff is already complex, you dont want to add complexity by not grouping categories into classes. When working on applications, some applications are 10.000+ files big, then you want a good directory structure, good grouping structure etc. I mean how is your approach on function definitions, 1 function per file ?
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Well, I'd suggest you to read [https://phptherightway.com/](https://phptherightway.com/) first which is a big piece but it's recommended to have a good grasp ! :)
ng-lick="clearMessage()
As someone who's taught intro to web dev before, I suggest watching videos of other people teaching. Also keep in mind that you can't "just" teach PHP - you'll need to teach the basics of computer to computer communication, DNS, request cycles, ports, storage methods, webservers and more.
Hello, &amp;#x200B; I wanted your feedback about these few tips I wrote for building frameworks, any suggestions ? (by the way sorry for my english, it's not my first language, tell me if i can fix typos \^\^)
Seems like I've really been out of the php game for a long time! I have no idea what you're all talking about anymore lmao.
Thanks, this is what I'm looking for though I would prefer something more user-friendly and prettier. I need a screen for a presentation so visual side of thing is important.
When you talk about white list (I'm not super advanced, so excuse me), are you talking about allowing only specific column names? For example, if a users table had id, username, and password columns, you would only allow those to be used? &amp;#x200B; I was working on a query builder/active record/orm type library, so this naturally caught my eye. I used the describe keyword to preload my column names so that I can easily set or get them with \_\_get and \_\_set (I know, some people hate them, but it seems perfect in this case). If that is what you are referring to as white listing, then would I be incorrect in thinking the describe method would be a great fit for white listing where you may not know or expect the columns (especially if you don't have a model or otherwise for every single table you work with)?
this thread is exactly why we have such a bad reputation in the programming world. next step is rushing to explain how to write a hello world program.
You've been out of the game a long time indeed if you were out before object oriented programming was a thing. :) I'm going to assume you know what a class is and what it means for a class to depend on another. CI = Continuous integration. Simply put: automatically build, test and deploy. UML = Unified Modeling Language. It's a standardized way of drawing diagrams depicting classes and how they are meant to be used. If class B extends class A that's one kind of arrow, if objects of class A have objects of class B that's a different kind of arrow, etc. OP has a bunch of classes that depend on each other and they are looking for something that can look at their code and automatically spit out a diagram of boxes and arrows to show how everything depends on everything.
The xdebug profiler gives you a map of callers, but i'm afraid that it's not that easy to look at. &amp;#x200B; See [https://xdebug.org/docs/profiler](https://xdebug.org/docs/profiler)
But that spits out only one specific path through script, not every possible.
I do believe they've gone overboard by insisting that even small applications follow the highest concepts. I think ultimately it's a way to do gatekeeping on the language, but it's going to result in a smaller and smaller number of people interested in getting into it.
Easy. Don't.
How was your base image created? &amp;#x200B; I mean if you installed drupal with composer in your base image, and the developers added libraries (the extra modules) in the same composer.json then IMHO you dont have a base drupal image. Probably every one of your websites images have a different version of drupal. &amp;#x200B; Also have in mind that you can't ensure that every site will work with the new version of drupal, and also you need to ensure that the added modules are compatible with your new version of drupal. &amp;#x200B; Maybe the best option it's to try to automate the common tasks of the upgrade (for example change the version of drupal in composer.json). Then your developers can use that tool as a first step to upgrade every one of the sites.
When i learned object oriented programming, i was writing a video game engine, and i found myself programming in MVC pattern without even knowing what MVC was. It was natural. In the web app i've been maintaining for the last 10 years, i still can't find a reason to implement either an object oriented style or MVC. I've tried redoing parts of the system in a modern style and those particular parts are harder to debug and trace through as there's many more files to open. In those OOP parts, the view ends up with quite a bit of logic in it, which was unavoidable because the page layouts need to be very dynamic. It seemed like a waste of time to even design it that way. OOP also leads to a lot of extra typing and the only reason i could see it useful is if you're combining a shit ton of other people's code and need things to be segregated in objects so that you don't end up with variable names clashing and globals hell. And yeah, autoloaders are nice too. Coincidentally my company hired 3 seperate programmers to rewrite our 'legacy' system and each one failed to complete the job. One attempt was in codeigniter, another in laravel, and i forget the first.. The laravel version was the most incomplete and had the most logic scattered across tons of files. The entire codebase was entirely useless. I was able to salvage some code from the codeigniter system though. I've also looked through the source code for projects like phpbb and flarum. phpbb is written with symfony 2.8 and barely utilizes it, but i can trace execution at least within 4-5 files. flarum was designed with religious adherence to SOLID and uses laravel. The one time i was able to trace execution from start to finish, i had 13 files open. I asked the developers of flarum how they trace execution to debug their code and nobody on the team could give me an answer. Coincidentally, there is 1 lead programmer who understands the structure of the system and it seems like nobody else has a full understanding. The idea of SOLID is to make easily understandable and maintainable code, but i have found the end result to be the opposite - hundreds of tiny class files, and laravel doing dark magic. This flarum forum system is pretty cool but it looks like developing got exponentially harder over time based on how they have to keep refactoring it.. A lot of "properly done" PHP projects look like flarum and appear to be more structure and cladding that actual business logic. I really don't understand why the PHP world thinks this is the only way to structure web apps. It does make me want to leave the PHP ecosystem and get into something lame like Python or JS.
Hey, neptronix, just a quick heads-up: **seperate** is actually spelled **separate**. You can remember it by **-par- in the middle**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey /u/CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". And your fucking delete function doesn't work. You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
A login application would be a perfect start. That's how I did it for my group.
Thank you for this! I actually [worked up something similar last night](https://scottfive.com/misc/phptest.php) as I was thinking about it. To me, for the language to be mathematically correct, the behavior should be consistent/transitive across the language. Regardless, thank you for your note!
I'm trying to find a session handler library to integrate in my framework that registered a central session handler that then supports multiple pluggable drivers for things like redis, mysql, pgsql, or even doctrine dbal, etc. I realize there are session handlers in some PHP extensions, but I'd like the handlers to be somewhat normalized and therefore be part of the library which would allow for custom handlers to be registered. Any ideas?
Does laravel not use prepared statements?
Symfony's HttpFoundation has custom session handlers that implement PHP's SessionHandlerInterface for handling storage
Do you know if this is a separate package? I probably would want something a bit more framework agnostic, as I already handle HTTP through various PSR-7/PSR-15 libraries and wouldn't want the whole of their HTTP foundation just for sessions.
PHP 5? Are you even trying?
After a quick glance at the docs and API, the session class does not appear to be dependent on the symfony request class, so you may be able to use just the session part of the http foundation
Yeah, I was more concerned with importing all the other classes. I try to avoid packages which provide too much as it might cause confusion particularly if someone is having autocompletion done, having multiple classes that fulfill the same roles may cause confusion. In short, I'm looking for just the session related classes and trying to avoid the whole of HTTP foundation being installed and not used.
I can send you a decent (I think) session handler in php. Does secure. Dm me an email and I’ll forward the code.
Understandable. It looks like they come together as a single component.
&gt;Gone are the days of manual FTP'ing and testing Not gone long or far enough, I still know companies where this is the norm. Left one about a year ago. All devs expected to work on a single shared development server, little to no use of revision control, commonly having to recover work because someone would just from whole folder up. Manual deployment to prod, hand configuring. Makes me sick to think about it.
What's the speed up like?
Would need to have a public composer package available for modular install. I'd be happy to create a package for it if it's good, but I'd need to know it is licensed in a compatible way and other things like that before biting and investing time into trying it out. What's the license? Is there a reason it's not public?
If you are working with PSR-7 and PSR-15 already, you could take a look at storageless session. I don't think it is pluggable with things like redis, mysql, pgsql, but I imagine you could embed a unique identifier in the JWT that can link to a persistent resource if you wanted to. [https://packagist.org/packages/psr7-sessions/storageless](https://packagist.org/packages/psr7-sessions/storageless) There is also a Zend Expressive Session. I know less about this one, but might be an interesting place to look. [https://packagist.org/packages/zendframework/zend-expressive-session](https://packagist.org/packages/zendframework/zend-expressive-session)
Copied from a tutorial and modified for my purposes. Pretty clean. I took out the secure cookie management. You could probably find something to work for that. Or just google a good tutorial.
I jumped the gun a little and didn't read the whole post lol I only read the title and assumed y'all would be talking about something like Python decouple. Thanks for taking the time to explain everything tho, I really appreciate it. Is there such a Tool? Not that I'll be doing any php soon... Or any hardcore coding for that matter.
The latter might be useful for other things though it doesn't look like it provides actual persistence handling. I may look into storageless sessions as an alternative as it's something I'd use personally, but at this time I'm mostly looking for something more traditional that would fit into current user expectations. Thanks for the suggestions though. Overall I'm just kinda surprised something like this doesn't already exist in a framework agnostic way. The Symfony suggestion is the closest to what would hit my requirements, but being tied into HTTP foundation is no go. Thanks for your suggestions, will bookmark both for other responsibilities, but not quite where I'm at for the moment.
Not everything can be prepared unfortunately
Mine doesn't show the top right
His standard, I persume.
Thanks
This, when claiming that you speed up unit testing you should include some metrics.
Sorry for now it's closed source, hahaha.. I think mine is very lack behind yours a lot, but our companies working it only for microservice and simple form builder, routing, prepared statement, and such. &amp;#x200B; I agree with some your opinion, I stay away from laravel because everytime I use it, it bloat too much, and many newbie programmer don't know how to fix it (I accept a lot of newbie programmer to work for my company). I use CI for sometimes, but It lack behind for security reason, if the person doesn't know well how to build the app from ground up, then it will be a mess. &amp;#x200B; I hope webiik will grew better :) sometimes people just messing around with your feeling, I do agree with some point that indie way, but still maybe I have corrupt mind for stay a lot with corporate client. The reason I create the PHP framework, my company framework, too support enterprise in some ways that my company can handle, laravel 4 to 5 is a mess and I will never work with it again. &amp;#x200B; Keep it up, I will try use it if I have time :) Thanks for warm reply.
Add a main.php file into the root directory
I've never looked at flarum and don't know how expansive the refactors are but, in my experiences, it's generally the earliest versions of projects that are the easiest to wrap your head around and to really get an idea of what it's doing. As code "matures" it becomes more abstract. Dependency injection is introduced to facilitate easier unit testing, objects are used a lot more to facilitate code re-use and lower cyclomatic complexity scores, more special case if statements are added to fix bugs that people have encountered on esoteric systems, etc. You mention JS as an alternative to PHP. idk that JS is any better. Consider pdf.js. Here's the 2011 version: https://github.com/mozilla/pdf.js/blob/a7278b7fbc029f2fdf92a5bddeb5465cd0a2d124/src/pdf.js Here's the 2019 version: https://github.com/mozilla/pdf.js/blob/f664e074c99b0a4a81932d13b2ab5bb3761e5da5/src/pdf.js If you just want to look at the code and get a quick basic understanding of how PDFs are internally structured... it's gonna be a lot easier to do that with the 2011 codebase than it is the 2019 one.
You probably shouldn't integrate your database in your unit tests either.
This may suit your purposes: https://github.com/auraphp/Aura.Session (Note that I am the project lead.)
I completely agree with you. It's technically a fine language with a bright future. The most legitimate complaints about php are not about the language itself, but about the brand and community. Something that's more difficult to fix.
When I was an instructor at a college, I taught a web development class where the only prerequisites were HTML and an understanding of CSS. In twelve 4 hour sessions I would teach PHP, MySQL, and JavaScript. The book I required for the course was ‘Learning PHP, MySQL &amp; JavaScript’ by Robin Nixon. I still use it as a reference today, and I can’t say enough good things about it. shop.oreilly.com/product/0636920036463.do
Sqlite for functional tests is generally acceptable. But for unit testing you should mock database calls (easier when using an orm)
I know it isn't what you are thinking about-- but have you considered using a JWT with custom claims (key pairs,... key: variable) to store your session data. Then you aren't spending your server resources storing session data.
As someone who taught college classes in PHP, JavaScript, HTML, CSS, Dreamweaver and even DOS in the past, the first piece of advice I can give you is be prepared to become the best student in the class, as you’re about to learn more than any of the students in the room. Do not be afraid to admit that you don’t know everything, so when a question comes up that you can’t answer, let the students know you need to research the question further, write it down, and answer the question in the next session. In my classes I would get everyone from newbies who could barely build a simple web page in HTML, to in one case a kid that walked in and on the first day asked for help troubleshooting his advanced Angry Birds like video game he was writing in JavaScript. The trick is to find a way to keep the advanced students entertained while you help the students having the toughest time grasping the material to learn. Each good instructor has their own way of handling this, and a lot of it comes down to your personality as well as trial and error. Another suggestion I have is to use a good PHP book, preferably the one you used to learn PHP. Most books are structured to start with the fundamentals and go from there. Start by figuring out the total amount of time you have to teach the course. If you have a total of 12 hours, I would break the course down something like this: Hour 1: introduction, what to expect in this course, and teach everyone how to access the web server you’re using. Believe me, this alone will likely eat up your first day unless everyone is already working in Information Technology and has experience connecting to a web server. Also, if this is a BYOD environment, require everyone to use the same tools (i.e. TextEdit on the Mac, Notepad on Windows, gEdit on Ubuntu; for local development, MAMP for Mac, WAMP for windows, etc. I’m not saying use these specifically, I’m just suggesting you set a classroom standard). For the remaining hours, work through the book yourself, make an outline of what you’re going to teach, and practice reteaching yourself. Talk through what you’re doing, and keep an eye on the clock. Always Leave room for questions, because you won’t know what’s going to prompt a question. If this is a formal course that requires exams, subtract that time from the available time you have to teach the material. I found when I was teaching that I would spend two to three hours preparing for each hour of lecture time. Now, if you want to be a good teacher, I’m going to make one strong recommendation... do not use PowerPoint or any presentation software in this class to present code or documentation. Slides are usually a crutch for a presenter to hide behind. At most, I would recommend “bookending” with a few slides where each slide just has a few words, not even a sentence to identify the current topic. In other words, if this part of the lecture is on arrays, the only thing I’d have on a slide would be “Arrays”. I’d introduce the topic, and then dive into the editor and teach by doing while doing. In a four hour lecture, I’d average at most 6 to 8 slides per night. I used a short stack of notecards or a single typed list of topics I planned on teaching each night, and I would refer to them for the next subject. If I didn’t make it through that night’s list, I’d adjust the course for the next week and lower my expectations for what I’d cover throughout the course a bit. If I finished early, I’d either do q&amp;a, or if I finished really early, I’d plow ahead into the next lecture and increase my expectations for what I’d cover in the course with that class.
The simple approach to doing this would be to take your common composer.json and publish it as a private package (i.e. to a [private repo](https://getcomposer.org/doc/articles/handling-private-packages-with-satis.md) or [something simpler](https://getcomposer.org/doc/05-repositories.md#artifact)). You can then require this parent package in each of your custom sites, along with any extra modules they choose. The main downside to this is that you will need to run `composer update` on the custom sites to pull in any changes to the parent package; this makes composer.lock useless, and may complicate your needs.
You can’t use prepared on column names in the PDO.
You have a bad definition of what a unit is.
You do realize the WP "globals" is using objects (wp\_query, post objects etc) ? and do you know that properly designed OOP can utilize native PHP op cache that is reusable in every requests? Play around with Laravel / Symphony and you'll see why OOP when coded right, is way faster with lower memory usage / computational resources than WordPress by miles.
You can configure the IDE (PHPStorm + PHP Inspections EA Extended for example) to mark all uses of \`==\` where the \`===\` operator suits better.
As a fan of Symfony, I can see how fast it is to get things done with Laravel. I suppose if you'd build a site the same way Laravel is build anyway, Laravel is a great head-start. For the rest of us, it just takes a lot of time.
Can you explain a bit why \_you\_ would dread Drupal? Drupal tries hard to appeal to a lot of audiences. As a backend developer, I don't complain a lot, but if someone were to design a front-end, I suppose there's a lot of hair-pulling due to how complicated the rendering and template system is.
&gt; Sqlite for functional tests is generally acceptable. Actually not unless your production env is also sqlite, it is not the same as mysql so your integration tests are not testing everything they should.
I think that might be you.
If you're using migrations and fixtures in your process, and your dev instance is the same as production (mysql, postgresql, etc) then for testing you don't generally need a full rdbms, and sqlite lite is faster, which as the number of tests grow, will most definitely affect runtime of said tests, ultimately discouraging developers from running them because "they take long". There is plenty of examples for this across multiple languages, Ruby, php, Python, etc.
sqlite and mysql are different. if you've got a db in the mix then you are doing integration testing, and if your db is different from production you aren't doing it properly. a better idea is to use less integration testing (slow) and more unit testing (fast). that way you can achieve similar performance and still run your tests against the real tech stack.
Oh really. I didn't know that. Could you explain why/when a column name would need to be user submitted/dynamic?
I've looked at and use Aura.Session before -- while I'm quite comfortable with it, I don't know that it supports multiple drivers? It's more just an interface for setting and getting no? When I posted I could only post a title on this group, so my main comment gave more description of what I'm looking for. But my concern is not so much interfacing with the data, but in having pluggable persistence drivers in a single replacement for the normal save handler.
Session handler for PHP \* [https://github.com/odan/session](https://github.com/odan/session) \* [https://symfony.com/doc/current/components/http\_foundation/sessions.html](https://symfony.com/doc/current/components/http_foundation/sessions.html)
I personally don’t. But the use case is a custom column name to sort by for example.
The first link is definitely closer to what I had in mind, however, it doesn't really have a clear separation of concerns going on. &amp;#x200B; Ideally I wouldn't want every session driver having to get/set its own information. I'd much rather want session data to simply load/save to different places depending on the driver. In this case, it looks like each driver is really a full implementation of a rather lengthy interface.
&gt;however, it doesn't really have a clear separation of concerns going on. Can you please explain more what you mean? &gt;... session driver ... Well, there is a common SessionInterface for all the implementations like PhpSession and MemorySession. This makes it very easy to replace the "session adapter" within a DIC context.
I like [https://github.com/php-cache/session-handler](https://github.com/php-cache/session-handler), you can use any Psr6 cache pool as session storage.
For SQLite you can just use an in memory DB (Dsn: "sqlite::memory:"), even faster and you do not have to have anything prepared and keep the schema in sync with migrations and stuff - just run the migrations on the in memory DB before the test. For MySQL i use an installation that has the data-directory mapped to an in memory folder (using Linux, no idea if you can do such stuff on Windows). This way i can create and drop tables all day long without having to wait for the disk IO.
Can you give any sensible reason why do you want to painfully hassle with the editor change instead of sticking with the default setup and concentrating on the actual learning?
How so
This bundle (for symfony apps) works really well and speeds up functional tests by wrapping everything in a transaction. Fast tests while still testing against mysql. [https://github.com/dmaicher/doctrine-test-bundle](https://github.com/dmaicher/doctrine-test-bundle) &amp;#x200B; Another option is running mysql in memory
I'm sure an object has overhead. but 1.5kb for an instantiating an object without properties? I'd like to see some proof of that.
Thanks, I will try this.
I just prefer this ide instead of netbeans. Thats all.
Yes, same. Put your test database on ramdisk and it's like a 10x speedup (at least it was for me). Configuring mysqld_multi was kind of annoying, but it was so very worth it.
I feel like there's a rather vocal type-purist group controlling the direction of this RFC's fate, but - personally - I don't think PHP needs to be so hyper-strongly typed as these people probably think (at least without strict types being declared as 1). I don't see any problem with allowing the string `" 12 "` to be casted to an integer `12`, since there's nothing in that string that's ambiguous about the number 12. It should be able to be casted into the int 12.
/u/Locastic \- can you fix RSS for your blog?
An alternative as well is, provided your test database is "ready", is to wrap each tests scenario/steps in a transaction which is rolledback afterwards. It makes it harder to debug if you need to stop in the middle of a test and inspect the DB, but otherwise is _much_ faster. If the debug scenario is necessary, you can attempt to opt for a hybrid approach allowing you to switch from one to the other easily depending of your needs.
Traces are normally easy to trace with var_dump(debug_backtrace(true)), which shows the full trace to the place where you put it. Oop doesn't normally put so much overhead over a function and classes are there to put functions for the same category (class) in the same file. When writing a web app you might consider a rest service with crud operations (create read update delete) which would be the entry point to update your models. Those updates you want in a single place because when a model change, you only want to change the crud at one place otherways it is called spaghetti code. The framework you use only prepares everything. Normally a router which translates the uri including $post / $request / $get will instantiate a controller which you defined in the route definition. So most of the time you start in the controller and prepare the data for the view, when you collected all data, pass it to the view and modify the data in the view for the final presentation. So you can have multiple views with the same controller. This is called seperation of concerns and with oop / mvc. Also user restricted acces should be checked in the controller and redirect for example when an user have insufficent rights. A framework is normally a set of helper functions. Normalizing the request and from there you have all possibilities.
There is a piece of software used for diagramming called Enterprise Architect. Last time I used it it could do exactly what you want with a nice presentation and UI.
say what?
I think op is looking for a scaffolding package for laravel similar to Yii's Gii http://labs.infyom.com/laravelgenerator/ i havn't tried it. But it looks good.
yes , thanks i try this package.
&gt; To build a simple website or web application solution most of the developers will go for PHP. But when it comes to complex solutions, python is your answer. No.
This is a follow-up of https://www.reddit.com/r/PHP/comments/bbyu39/how_to_add_a_few_extra_packages_with_a_second/ Unfortunately there is an error with composer when I try to pack all packages in a custom package (dennis00/denpal) and use that package. [RuntimeException] Could not scan for classes inside "/home/dennis/denpal/denpal-example/vendor2/dennis00/denpal/scripts/composer/ScriptHandler.php" which does not appear to be a file nor a folder cat composer.json { "name": "dennis00/denpal-example", "description": "Example of Denpal", "type": "project", "license": "GPL-2.0+", "minimum-stability": "dev", "config": { "vendor-dir": "vendor2" }, "repositories": [ { "type": "composer", "url": "https://packages.drupal.org/8" } ], "autoload": { "classmap": [ "scripts/composer/ScriptHandler.php" ] }, "require": { "dennis00/denpal": "dev-master@dev", "drutiny/drutiny": "2.3.*@dev" } } ls vendor2/ alchemy brumann composer dennis00 doctrine drush egulias guzzlehttp knplabs nikic psr romaricdrigon stecman twig webmozart asm89 caseyamcl consolidation dflydev drupal drutiny erusev jakub-onderka masterminds paragonie psy solarium symfony typo3 zendframework bin cocur cweagans dnoegel drupal-composer easyrdf fiasco kevinrob mustache pear ralouphie stack symfony-cmf webflo
Please try /r/PHPhelp/
In my recent project I had similar problem with setting up DB in "setUp". In my case using **public** **static** **function** **setUpBeforeClass**() instead of setUp() helped a lot. Of course it has limitations (it does not reset DB before each test, only before all tests in a class). When you have for example 20 tests in single class and they all are just testing reading data, then having DB set up once instead of 20 times is like difference between running tests 40ss and 3s (in that test class).
&gt; are you talking about allowing only specific column names? Yep, simply having an array of [allowed columns, and checking with in_array](https://3v4l.org/ZWLNi) is sufficient. &gt; [...] If that is what you are referring to as white listing [...] Nope, what you're doing is fine &amp; makes sense. Really it's the application's responsibility to do this whitelisting; the information that is required to make the decision as to whether a column may be returned or not doesn't exist in the schema - it's a concern of the application.
[https://dephpend.com/](https://dephpend.com/) works fine
Phew... that english is hard to follow ;D
At my last company (2016-2018), we have a whole lot of behat tests that took over 3 1/2 hours to run. I quickly deduced that it was a setup nearly identical to this (for Laravel) that was causing the vast majority of the slowdown. Solution? 1. Save the schema plus fixtures (`php artisan migrate; php artisan db:seeds`) into a SQL file, containing nothing but `INSERT`s. 2. Create another reset.sql, filled with nothing but a whole lot of `TRUNCATE`s, one for each table of the database. This can, in fact, be automated in PHPunit's bootstrap to be made at the very beginning of the first test. By switching to `TRUNCATE`s instead of `DROPs` and `CREATE`s, it sped up the test suite to, get this, **17 minutes**. A huge speed up.
I am still impressed with how ahead Yii is with some of its tools and features
Good observation. I think that part of the problem here is that a simple CRUD application doesn't tend to solve the same problem as MVC. MVC allows us to decouple our model, which is (should be) primarily business logic, from application concerns such as HTTP and HTML. A simple CRUD application tends to be nothing more than an HTTP interface to a relational database -- such applications don't tend to contain much business logic, so the main benefit of MVC (decoupling the business logic from application concerns) tend to disappear.
Good post, and +1 for describing the model as a "layer" which handles "business logic"!
Good question. Others have answered it well, but as a side note, "model" is not a synonym for "entity." A good model is comprised of more than just entities; it also includes values objects and domain services (services which model business logic, not technical application concerns such as auth).
&gt;I am still impressed with how ahead Yii is with some of its tools and feature For this reason , I cannot yet migrate from Yii to Laravel or Symfony
Ok awesome! I've made it an optional feature and the option for a developer to supply their own white list of columns. Happened to do the column check before reading about this and realizing it has the potential to do bad.
a unit is anything you can test as a unit.
But I was told we were losing our jobs to Rust, Go, Kotlin and whatever hipster language is hot atm.
Isn't it pretty obvious that **parameter** binding will only protect **parameters** against injection?
This is the very reason PHP has such a bad reputation. &amp;#x200B; Heck, this shit even uses \`mysql\_query()\` ...
&gt; just run the migrations on the in memory DB before the test. I have a static file called `initial.db` with the initial state of the database, and at the beginning of any test that uses the database, I copy that file to something like `testing{random string}.db` and then run the test using that file. I wonder if an in-memory database would be faster.
Good points. Yes, i understand the unit testing benefit with DI. It's just a strange thing to do. The opposite of how the language was designed to handle dependencies.
https://github.com/phpmetrics/PhpMetrics is the tits.
You can use redis as the native PHP session handler. I’m not familiar with storageless, but if it’s using PHP’s native session handler this should be all that’s needed.
It's not either / or. I typically have unit tests, functional tests with sqlite if it makes sense, then integration tests on a deployed environment. You do need to be aware of differences between sqlite and Mysql in default behaviours and capabilities, but they all add value if you're careful with your test cases. One app is not the same as another, and approach to testing must reflect this fact.
and goodbye
&gt;Overall I'm just kinda surprised something like this doesn't already exist in a framework agnostic way. &amp;#x200B; The expressive one uses traditional sessions and it is framework-agnostic.
Yes, but as noted, it doesn't actually provide persistence handling. It has an interface and a native drivers. It's more container than it is concerned with the persistence/handling of the session storage it seems.
The first looks very promising, I'll probably give it a go and see hot it works. I think my only concern in hte initial look was that it doesn't seem to namespace the sessions at all. For cache I've been looking at stashphp [http://www.stashphp.com/](http://www.stashphp.com/)
Yeah, i really like php. The main nag i have is that the order you type variables into certain commands is all over the place. Naming of commands is not consistent. But that's forgivable; i have IDE hints to help me out with that. I think that swift is a nice basis for a PHP replacement that can be a clean slate. Kotlin is interesting too but java based languages and the functional programming craziness that's part of their programming culture is something i find off putting. I'd prefer to not re-learn everything i know about control structures.
\&gt; Can you please explain more what you mean? Yes, as I said, the interface is just one big interface. So it doesn't really solve problems in a re-usable way. The thing that gets/sets data in the session, is a separate concern and should be programmed as such from the thing that gets/sets the session in some storage. I want to be able to use the same container (not just the same container interface) without having to rewrite that for each driver I might add.
But, ...why? What's wrong with using native `$_SESSION` configured to use memcached or redis?
SQLite isn't the same as MySQL. There are plenty of functions which simply don't exist in SQLite, including a fairly important one: SQLite doesn't restrict the length of fields. So you can chuck a string that's too long into an SQLite DB, but the corresponding query might trigger an exception on MySQL (If you're running in strict mode). I'm not sure where this attitude appeared from, but it's very dangerous to assume that just because two DBMS' are using SQL that they're similar in any way. It would be like using Cassandra in tests but MongoDB in production because they're both NoSQL databases. It's just going to lie to you and cause you huge problems in the future. Speaking from experience.
That seems like the last thing I'd do with PHP. Ideas JavaScript for the front end and nodejs for the back end.
I would heavily recommend against using sessions. I'd use a cookie with a unique value in it, then store a related document in a NoSQL store, or in a MySQL table. The problem with sessions is you can have huge problems with race conditions. If you've got two requests happening at once, the second request will completely override the complete content of the session. This means that changes can disappear or things getting deleted can disappear. Have had problems where a 404 on an image triggered a custom 404 page which was modifying the session and (sometimes) overriding the session from an ajax request in the background. Just update what you need in the database, you're going to save yourself a lot of headaches in the future.
I'm in love with typescript and really looking forward to learning python. Actually the thing that annoys me about php is the dollar signs and the arrows for objects. So much extra keypresses. But yeah, can all be overcome.
Our solution on a Laravel 5.8 app was to seed our static tables, and then only seed the tables needed for the test suite (and their dependencies) using factories and faker. We saw a 60% speed increase on our tests on the pipeline versus fully seeding the database after making the change.
I think I get your question, but we need more info. In particular, what are your requirements? Will this be a GUI game, a CLI game, ? Will it be networked, or play against the computer? Will users be ephemeral participants, or trackable accounts?
It's mostly client driven stuff, so Javascript on the front end for sure. and make a bunch of Ajax request to the server with priority locking on the database to prevent race condition.
It's beautiful :) Lets get this in 7.5
While this is an odd request, it is also an interesting challenge. Maybe you could use [something like this](https://github.com/KessieHeldieheren/Havoc-Engine)
Honestly, I was pretty excited when I saw it. There have been many where I (and probably most PHP devs) have wanted the first key in an array. But at the same time, it does seem silly and maybe a bit much to introduce a function like this. This guy puts it well: https://www.reddit.com/r/lolphp/comments/bbrfw6/microservices_bundlers_deployment_pipelines/?ref=share&amp;ref_source=link
Not going to be a lot of PHP developers deciding to use node for the back end.
Lol
It's possible the OP means just the logic of the actual game play, not the user interface and all of its associated concerns. All of that is really just window dressing to the game mechanics.
What I'm talking about would work with $\_SESSION. All I'm talking about is something that registers a new session save handler and then has a number of drivers which can actually store the session in a given persistence layer. &amp;#x200B; Using the memcache or redis session handlers that are built into the extension would mean some drivers would be built into PHP and others not. IMO, a standard driver interface is preferable as it would allow for simple interface dependency injection which would be much better for uniform testing and documentation.
Just curious, what makes you say this?
This is based off of the game being multiplayer, node has a very easy socket Library. Obviously the front end would also be done in JavaScript, so keep it consistent with the language.
The latest PHP version is the 7.3.4 (stable one) You can find them here [https://www.php.net/downloads.php](https://www.php.net/downloads.php)
7.3.3 I believe.
Current stable is 7.3.4 See https://www.php.net/downloads.php
The latest stable version is 7.3.4: [https://www.php.net/supported-versions.php](https://www.php.net/supported-versions.php)
I appreciate the response. You make a good point. It was a mistake mentioning CRUD and detracted my point. I would still expect somebody to have a created or shared an example implementation somewhere.
Did you rename it to attachment.jpg or s.th like that?
The php file is a web page. Open it, then right-click in your browser and look at the source code of the page. The address of the actual image file should appear in there somewhere.
There might be a reason(assets protection) why the dev is doing this. but save the file and try to change the file extension to jpg, png, or gif.
You tried right clicking and saved it? How? Like you saved it with an image extension or saved it as it is? I can put a few assumptions as for myself I would remove metadata from images when processing images. I don't know what kind of service you're using at the moment, but if the metadata is preserved by the service, normally, the usual would always work.
Can you link the URL?
1) OpenCart is a poorly designed security nightmare. Just find something else. 2) Is the OpenCart API actually designed to be integrated in to existing applications? Sure you can use the classes that are available, but will they actually do anything without "booting" OpenCart itself? If this is supported, it would be documented somewhere.
How likely are you to change session save handlers in a project? The premise just doesn't make sense to me.
I see what you’re saying, socketio is great but you could code this without the use of sockets as well though
Just rename the file. As long as you know the filetype and it’s saved as binary the data is there.
In Chrome, right click and click Inspect to open up Chrome Dev Tools. Go to the "Network" tab click Img to view all image files loading on the page. Click on the image and it will show you the link. [https://imgur.com/svVaaZx](https://imgur.com/svVaaZx)
Yep :(
It does not- the source code for the image also links to the php file
If you open the file in Notepad, does the first line say “PHP Error:”? In that case the website is broken, sorry.
that file most likely uses readfile() so no, no img link in there
can you screenshot the contents of the file so we at least can rule out it contains any code but only raw image data?
There is a session prefix option if it is what you mean by namespace.
It's hard to understand what your question is. Are you asking: \- What portions should be done client side vs. server side? \- If all server side (reloading the page each time), how to organize the objects / classes? \- If the game were to be played only by real players or if a computer can play? What is the question exactly?
Yes, unit tests should mock database calls. But here we are talking about functional tests where you need to have test database.
Why would you want a db?
Unless they want something fast like socket
Honestly I don't know how to play Crazy Eights but I thats beyond the point I think. I'd start by creating a player and a deck class to keep track of where the cards were using arrays containing representations for each card, then I'd create a class that handled the game play, this class would deal the cards and keep track of the state of the game: rules, turns and the win condition. From there i'd write the session logic to allow multiplayer, i'd probably want to have rooms and assign them to your players/decks at this point After that i'd write persistance as needed and some sort of authentication.
I'm not. Per my original comment on the thread (because I couldn't see how to type an actual text body on the post when I submitted, only a title), this is for integration into a framework that is publicly available and used across multiple projects. As such, although I may not change the session handler in a project, I may use different session handlers on different projects, and others may use different session handlers.
Indeed, somehow I missed that completely. Looks like we have a winner.
I think this is exactly what the question means.
I love this library because it made me realize "what's session storage data but a cache".
I love this library because it made me realize session storage can be treated as a cache.
Yeah, it makes lots of sense. It's also nice in that in a framework context you configure your cache and you configure your session storage essentially simultaneously.
MySql has some functions that Sqlite doesn't support. And if you are using them in your project, sqlite will throw exceptions and tests will fail. Sqlite is faster, but that shouldn't be the reason for you to have different database type on production and tests.
Well if it's server driven and not client driven then a DB would be the easiest way to keep persistence between all the players.
Did you try other extensions, png, gif, etc...
Didn’t work :(
If you can post the URL
Unfortunately I can’t. Just not sure what to do. Won’t open as jpg and literally every source code I open only refers to the image by attachment.php
0.0.0-alpha I like it
As I said, open the file in editor and Screenshot us at least the contents of that.
Why don‘t you just make a screenshot of the image? There are also several browser extensions to do fullpage-screenshots if the image doesn‘t fit your browser window.
Seems like a VERY experimental lib. I couldn’t find anything better though haha
They are processing which image send you inside the php file and sending you back a response with the image. Not much that we can do if you don't provide the url, but I don't think it's difficult to get. &amp;#x200B; Next time please, ask whatever you need in the proper subreddit /r/PHPhelp. &amp;#x200B; https://www.php.net/manual/en/function.fpassthru.php &lt;?php // open the file in a binary mode $name = './img/ok.png'; $fp = fopen($name, 'rb'); // send the right headers header("Content-Type: image/png"); header("Content-Length: " . filesize($name)); // dump the picture and stop the script fpassthru($fp); exit; ?&gt;
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
" This documentation uses [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt) to define the terms MUST, MUST NOT, SHOULD, and SHOULD NOT. Such as one SHOULD NOT build a game engine using PHP. But not to say one cannot. "
I think you missed the part where I said using fixtures, migrations and an orm, and there's a reason for that.
Curious, is this a homework assignment? lol
So why is the objective to test the database if you are **testing the database without a database**?. 🤔 imho: People are funny with test.
The example included could entirely get around the need for variable variables by just changing the constant to an iterable array. 999999/1000000 times I’ve come across these, it’s because of some poor design decision or inflexibility.
PHP in a nutshell: Render a table (the data could come from the database), render a form (that inserts data into a database), mixes all of them, rinse and repeat.
production - ready framework
Why do you need to restart a container? If you mount a volume rather than just a initial copy on build, then you will consistently have a replicated code base between your host machine and container. The only time I find that I need to restart containers is because I've had a much lower level change than something at the application layer. e.g. I want to enable a new php extension so I need to rebuild my container which will recompile PHP again.
Did you try .webp?
I have a hard time accepting transpiled languages. Doesn't it add a significant amount of waiting to testing code while you're writing it?
&gt; Second and last step is to import test database before each test Yeah, but this won't scale. Write a few thousand tests and you'll see why. In my experience there's only one proper way do to it: - ensure migrations are run _once before all test_ - each and every test, if necessary, defines their own fixtures (by using Laravels Factory or your own concept, whatever is necessary) Oh, and of course: each test (which accesses the database) runs in a transaction which is always rolled back. Another pro tip: whilst usig SQLite might sound nice and good: never ever use a different database for testing than in production. You'll thank me later. Instead, tune your test database as much as you can for your tests (e.g. disable the D from ACID, you won't need it). Of course the best (unit)tests are the one not requiring a database in the first place. But in practice we know we simply rely much on the database as well (complex queries needing their own tests, triggers) so better get that part right, too.
I wanted to write a comment on the article explainimg how shitty it is and how to improve it. But after writing it all out the click on the submit page landed me a 404. Lol.
PhpStorm can visualize class relations, but I'm not sure it inspects properties (just class hierarchies interfaces/trait/extends).
In production you litteraly should almost never mount a volume, especially not for this kind of task. The application resists within the container. What you describe is to use the pure PHP image and mount the php code which has been deployed the classical way. But that is not how it is intended to be used. You should build your application image based on the php image and with your application code during the CI/CD Pipeline and push it to K8s or any other suitable orchestrator. On the host there is no volume mount and no php code at all. This is what is described here and how it should be used.
The objective is generally to test that you are sending the right queries, and interact with a known response correctly. In _most_ cases, that's perfectly sufficient and you don't need an actual database to interpret that query and produce those results. It's no different from faking HTTP calls when seeing how you'd interact with a third-party API. It's not full integration coverage, but gets you 98% of what you care about and is 1000x faster to run. It's not like you can change your code to fix a bug in the third-party service (or database).
Or you could use PHP and JQuery (and only if we need that), a couple of pages, a few libraries, and we are ready to go, simple, cleaner and without the clusterf\* of node.
something like this one: &amp;#x200B; \`\`\`php class deck { var $card=\["ace-diamon.jpg","eight-clover"...\]; var $players=\[\]; function shuffle() {} function startGame($numPlayers) {} function drawcart($player) {} function renderhand($player) {} function checkRules() {} } &amp;#x200B; $deck=new $deck(); \`\`\` Also, we could add new class, one class for card but I don't think the code needs that.
What?
What I am doing: A search function for a site, that's supposed to be fast, give results as a user types. Query would be something like: "brand1 brand2 brand3" . My idea is , instead of querying the database frequently. A keyed array is created once. Like: \['brand1' =&gt; id , 'brand2 =&gt; id2 \]. This array is stored in memory. The next time a query is sent, the array which is instantly available in memory, can be simply queried $storedArray\['brand1'\]to fetch the id instantly. I don't have much experience with caching , so looking for advise whether what I am trying to do even makes any sense or necessary. Please ask if any questions. Thanks
Sorry its not letting me edit the post body. I have written explained in a comment.
I have no idea about PHP‘s caching in the various ways it could be run, but I‘m quite sure that after the php file with the variables has been called once, the file already stays in memory. I‘m using the same idea in a project of mine but haven‘t benchmarked. I use it as an additional security layer, too - the php gets automatically written but only if it‘s not there. An attacker able to delete a php file would be able to do anything else, too.
You could use Redis or Memcache/d. Memcache/d is the old guy, it lacks of many features but it still works. You could also use APCU that it does the same job minus an external service. ```php if(apcu_exists("mylist_mine")) { // value exist in apcu? $array=apcu_fetch("mylist_mine"); // yes, it exists, so we loaded from the cache. } else { $array=//... load the list. apcu_store("mylist_mine",$array); // store the array into apcu } ```
&gt;apcu &amp;#x200B; Alright I'll go with apcu. I knew about APC cache, which has been depreceated ? Didn't know about APCU . Should have looking more thoroughly..
Yes if it is a trivial case (if you want to test a service/logic) class but it is not possible to unitary test other classes.
btw: There are only two hard things in Computer Science: ***cache invalidation*** *and naming things*. -- Phil Karlton
🙄 &amp;#x200B; **EasyPHP Webserver 14.1 beta 2** Apache 2.4.10, MySQL 5.6.19, PHP 5.4.31, PhpMyAdmin 4.2.6
&gt; Are variable variables actually needed? Really?
7.0 is newer and 5.5 not.
Is your issues single vs double quotes? &amp;#x200B; **echo "\\\\";** The above example will output: \\ \\ &amp;#x200B; **echo '\\\\';** The above example will output: \\\\
Damn, creating tables is that slow? Good to know.
&gt; explain how to write a hello world program Over at /r/golang they get 3 of these every day
Not really. It adds a few seconds during development. But the transpiler is pretty good at only transpiling the changes. But the same could be said for any compiled language as well. In practice I find it not to be a bother.
I wasn't aware it was that smart. What do you like about typescript?
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
back to the beginning of this whole thread ... a unit test can read/write to a db. that is not a bad practice.
I finished multiplayer Texas Hold'em with PHP backend and JS/ajax frontend. If you are interested I write more later
Hell yeah then check every possible combination be like `if(in_array("ace-diamond.jpg", $cards) &amp;&amp; in_array("ace-clover.jpg", $cards) &amp;&amp; ... `
Depends on the application, but as long as you’re using best practices, do whatever works and scales best.
I wouldn’t say old fashioned...but just simply inefficient. Frameworks and tools really help, esp over time Depends on a lot of things tho include personal preference
It is still utilized although it’s not really practical depending on the project you are working on, most times it’s faster and better organized if you rely on a framework. But keep in mind you don’t need a canon to kill a fly, there will be situations in which pure PHP will do its job, but mostly to very simple things.
Not at all. In fact, this development stack is often recommended for solo programmers due to simplicity and ease of deployment (its almost zero effort deployment with most popular LAMP hosting providers).
Pure PHP is fine, as long as it’s well written and secure. MySQLi.... just don’t. Use PDOs instead.
6 to one or half dozen to another
It is, actually, much worse than just old fashioned. It is unprofessional, inefficient, and prone to every error and vulnerability you can think of. And I'll tell you why. Take, for example, "pure mysqli". The statement of question alone tells a lot. Mysqli is the least usable database API that PHP ever had. Any *programmer*, even being forced to work with "pure" mysqli, would invent a *wrapper*, to automate repetitive tasks. And this process of automatization is endless. There are always repetitive tasks, on any scale. From aoutomating a query execution a programmer would turn to simplifying CRUD operations. And so on. And then a programmer would realize that such automatization tools need constant impeovement. And it takes time otherwise would be spend for creating actual websites. So a programmer would decide to delegate such support to the community, by chosing an existing automatization tool from Open Source. And his site is no more "pure php and mysql" at all. If a site is developed in "pure php and mysql" it means its author have no programming experience. Which, in turn, means that there will be errors and security problems of all sorts. Sorry for the harsh truth, I didn't mean to bully or disappoint you personally, but you asked a question and deserve a honest answer.
Start with the basics and find out how truly clueless your coworkers really are.
Mysqli has been depreciated for over 3 years, at least. Php is not old fashioned web development, but cold fusion is lol. Python with Django is good for web development.
Thank you, we already know that. From the source code, not from a random blogger
ha, django is considered old now. where you been?
at least use pdo
And you have not a faintest idea what are you talking about
Mysqli I would object to, just because PDO is more versatile