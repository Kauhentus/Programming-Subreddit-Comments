&gt; Yeah when doing unit tests I try to not even use the database at all as normally you are creating an object and testing a single method. That definitely helps as it prevents the whole ORM from being loaded. Absolutely the goal to strive for. I can say however, in practice: maybe &lt;5% of our tests can operate like this :/
I wonder Taylor was thinking...
Because it's faster.
Do you've a link to that? Would like to give it a try as an upgrade option for some projects.
ITT: Pro Symfony developers who created nothing of their own criticizing code used by tens of thousands of developers.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Thanks for saving me a click
Thanks for idea! Will implement it soon.
I'm really thankful to commentators, totally forgot about responsibility for correct usage. Thanks guys!
Please explain to me how global functions that have the exact same functionality that PHP already has is a good thing. This was created just to tightly couple you to Laravel and make it harder to break the framework dependency.
... another article I can tell you didn't actually read. From the conclusion: &gt; The EBI pattern is to the back-end what MVC is to the front-end. They are not an alternative to each other, they are complementary. If we would put them together in a single pattern we could call it something like View-Controller-Interactor-Entity. 
This is possible, you'd need to recursively parse the object looking for the desired key. It should be like recursively searching the file system.
I think the PHP reflection getProperty method is what you want. http://php.net/manual/en/reflectionclass.getproperty.php
I don't use Gearman.. but I do use Rabbitmq. I would probably combine Gearman with Rabbit or another queuing service. If Gearman crashes, your job will nack and can be pushed back into the queue. 
$obj-&gt;$prop also works in newer versions of PHP.
There were no good arguments against DTOs , other than people afraid of decoupling and writing a bit more code. It's not less maintainable, it actually makes life less complicated, especially when you nest forms or reuse form types. It also plays rather well with command busses and form handlers (hostnet/form-handler-bundle). 
Sometimes the timing is just too perfect xD I wrote a library some days before to do the same thing but without losing the docBlocks because we really want to keep these: [https://github.com/Setasign/php-stub-generator](https://github.com/Setasign/php-stub-generator) There are still some things that I have to build in like trait support. There is also missing a way to setup external libraries. At the moment you have to configure all classes which are used in the class tree and all configured classes will be build into the stub file.
How does it look like with internal classes? I tried with https://github.com/Roave/BetterReflection/pull/101 and I gave up: the PHP manual is too inconsistent, and I just needed to find all constant value defaults to generate the stubs in userland :-\
What would happen if you have $myObject-&gt;Father-&gt;Name = "John"; $myObject-&gt;Mother-&gt;Name = "Mary"; and you ask for this? echo aFunction($myObject, Name);
Maybe this is what you want? https://github.com/adbario/php-dot-notation I guess I don't understand that the shortcut is that you want to take.
I'm fine with Zend Expressive at the moment. I like to test many framework and see how it works, not interested in taking a side or engaging in a flaming wars but it's sad to see how ppl are so close minded on this subreddit :(
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I didn't tested it yet for internal classes because it just wasn't the main purpose. But the formatter part is only speaking with instances of \Reflector so it could work but this will definitely need more testing.
(could probably be cleaned up and not sure how intensive it is, but it works) function aFunction($haystack, $needle ) { $haystack = get_object_vars ($haystack); foreach($haystack as $key=&gt;$value) { $search_value = false; if( (is_array($value)) || (is_object($value))) { $search_value = aFunction($value,$needle); } if($needle===$key) { return $value; } if($search_value !== false) { return $search_value; } } return false; }
I hope you find your answer, but I'm curious as to WHY you want to do this. I can't think of a reason the standard `$object-&gt;property-&gt;subproperty` would be undesirable (except for deeply nested objects requiring a long chain of properties).
Yeah, I find it really interesting, mostly from a historical point of view. This EBI was published 10 years before DDD, and of course before Ports&amp;Adapters, Onion and CQRS, but I think the author already had a fantastic vision about this. I feel that guys like Trygve Reenskaug and Ivar Jacobson, although not so well known as Uncle Bob and Martin Fowler deserve our recognition for their ideas.
Fixed! Thanks again.
Wow, I saw it right before the removal.
I was asking because `\Reflector` doesn't really work well with internal classes, so I personally had to do a mix of reflection + XSLT transformation from the php-src manual :-\
I read that. Saying "... but on the backend" doesn't make this a different pattern. I've already said many times that any real-world MVC implementation ends up hierarchical (see PAC or HMVC), it's still MVC. We don't need a different name for a pattern every time we move it to a different part of the app. Do we have different names for "Strategy on the server" and "Strategy on the client"? "Singleton on the server" and "Singleton on the client"? "Adapter on the server" and "Adapter on the client"? "Factory on the server" and "Factory on the client"? I think you get the point.
Summary of this thread: - Me: "Laravel does this specific thing, among many, that makes it inefficient" - You: "Nah it's not inefficient!" - Me: "See benchmarks" - You: *INTENSIVE HAND-WAVING*
Why are all these functions global (https://laravel.com/docs/5.4/helpers)? At least make them classes so they are easily testable with your code. It's also confusing and makes you wonder is this function Laravel specific or is a native function. People say the way you code in Laravel isn't tightly coupled to the framework. Seeing this proves the exact opposite. Refactoring this to another framework or project won't be easy.
The reason your example doesn't auto complete is because the array passed to the function can be *any* array. There is zero correlation between that and an array declared outside the function that happens to have the same variable name. The third example works because you're referencing that same variable which is in scope. The class examples all work because properties are defined in one way or another. I don't see any way around your issue besides using a proper class. 
Sounds like either your query isn't returning multiple rows (no where clause?) or when you're referencing the rows returned, you are referencing the first row explicitly. Tough to say without seeing the code.
http://imgur.com/8GBlDZz Here is my code 
you have a bug in your code (amongst other glaring problems). but the line where you do if ($row[2] = 'XXXX' that will always be true because you are assigning it a value. you need to use `==` if you want to check the value instead. The other big problem is that you should be using prepared statements. your code is at risk for sql injection. Also, at the top of the code where you have a while loop for no reason. if you just want the count, you can just fetch the row like $result = mysqli_query($conn, $sql); $row = mysqli_fetch_row($result); $count = $row[0]; I like to use `mysqli_fetch_assoc` instead because it's much more readable and less error prone because columns you select can change the index. for instance $row = mysqli_fetch_assoc($result); $count = $row['COUNTER']; 
Better use classes than arrays. It will define better your domain objects 
Nailed it. Move along. 
I tried the mysqli_fetch_assoc($result); earlier and I got a syntax error, Ill try again later on and I'll try the easier method of counting , php is defiantly hard to grasp when you're learning it on your own and I appreciate the help 
It's only ever using the first result because inside the loop over the results you've called header() and exit to redirect to a different page.
If you were running the code across multiple servers and sharing the files with a network file system such as NFS or Gluster, all that extra file statting does matter.
There are better ways to share code such as https://gist.github.com/ I can't read your screenshot on mobile.
That's what group by does. If you want all the films for a day you're either going to have to run a different query for each day or order by the date created and do something in your loop when the date changes. 
Just as a tip, you can actually typehint parameters in functions: function test(Mom $mom) {}
[removed]
Is it better to use O(1) rather than count()?
that is not what I said, I said it is not as relevant as you make it. Small difference, but not very usable in your hatred against Laravel crusade. 
1. /r/phphelp 2. get rid of group by and mysqli_query 3. USE [PDO](https://phpdelusions.net/pdo) with [PDO::FETCH_GROUP](https://phpdelusions.net/pdo/fetch_modes#FETCH_GROUP)
If you had a syntax error, that means your code was formatted wrong (e.g. missing semicolon `;`, missing bracket `(` or `)`, or perhaps something else in your code. Usually php will give you syntax error line numbers so you can track it down.
I think the SOLID principles are actually the best startingpoint in creating reusable and testable code. https://www.google.nl/amp/scotch.io/amp/bar-talk/s-o-l-i-d-the-first-five-principles-of-object-oriented-design
Or Haste/Paste bin
Relying on array keys should ring a bell that something's wrong with the design. This is a good website to read about all kinds of best practices: https://sourcemaking.com/refactoring/replace-array-with-object It's possible you're getting this array from an external source. You'd still be able to wrap the array into an object, not only allow for autocompletion, but also giving the insurance the correct properties are set. class MyDataObject { public function __construct(array $data) { $this-&gt;foo = $data['foo'] ?? null; $this-&gt;bar = $data['bar'] ?? null; if (!$this-&gt;foo) { throw new \InvalidArgumentException('`foo` is a required property'); } } } (Note: for the sake of the example, I ditched the private class variables and getters)
Test the MVP you have now first. If it works and you have nice feedback on it you'd be kinda sure you're not wasting your valuable time under the hood. 
That's the permanent question in mind. I think the best way to tackle this is by doing it gradually. Focus on implementing features and fixing bugs, along with building sophisticated tests for your application. While you're doing that, try refactoring in small steps. Rename a variable there, rename a class here, extract a method there. That way your code will enhance over time and no major rework needs to be done at once. And if you decide that it's still necessary to rework the whole architecture in say a year or so, you won't have big trouble doing so, since you've got enough tests to make sure things are still functional after the work is done, even if you've already grown a user base. Edit Typo
Is it good enough to get you the marks you need?
Depends on the requirements
yes
This is pretty cool stuff, Blacksmith is a very useful idea. I really like the idea of Managed Hosting providers and especially that their APIs are exposed. I also did a similar stuff for a client, He wanted to become the reseller hosting, so I used Cloudways managed hosting API to build a simple prototype for them and it's in development. Cloudways is also a well-managed platform for laravel like forge. But it's more cheaper, as the price of the server is also included in their managed plan. And they support vultr as well. take a look at a demo. Here is the demo video of the project: https://www.youtube.com/watch?v=OiWDrwFTxXY&amp;feature=youtu.be And here is the link for the project: http://phpstack-77728-318823.cloudwaysapps.com/
CRM was exactly what I've done for my final year. It should be fine with UML schemes, database schemes etc. Also, my CRM had specific requirements, like post pre-moderation that requires multiple moderators review for a post to become public.
Alright, thanks for the input!
Thanks!
You probably want to order by created date. Also, you should identify films by some kind of id as the primary key. This allows for duplicate titles and makes your queries faster.
StartCom used these. What makes you think they're not supported? They're not widely implemented in day-to-day sites, because they require a manual installation in the browser and that browser remembers that certificate then and wouldn't allow others to authenticate on another person's system.
Aren't you talking about a CMS like wordpress? OP said CRM which is a customer relationship management.
My opinion is that you should use your final year project to focus on something that could give you marketable skills for a job. I did that as a way to learn Symfony and it helped me land a job soon after college. 
No because there's no science behind saving and loading text.
However there is science behind discovering trends and making predictions from all the data you have on your customers.
There so much more related to a CMS than this...
my colleagues at school always done som CRMs CMSs bank systems and other boring projects.. I always did simple games and the teachers always loved it.. be cool and do a game :)
This is the age old question. In my experience, your guide should be "release and refactor" not "refactor and release." You run the risk of never releasing anything if you hold yourself to the standard of perfection. Follow good standards, do your best, but by God, release.
I use Laravel but to be honest I like *Services* aproach in Symfony instead of global functions. I know maybe it's not a logical opinion but I hate global functions *because of Wordpress*, eww. I usually create a service folder (e.g. app/Services) in Laravel and write my own logic.
In a year from now, you'll look at your refactored code and want to change it again.
here's the dirty secret of every single software project anyone has ever written: our code sucks. it all sucks! you're constantly learning as you go so the eyes you read your code with today are not the same eyes you had when you were writing the code. take a pragmatic approach to refactoring. make notes about where your technical debt is, try to rank and prioritize them, and then do the highest priority refactors if and only if it makes a meaningful difference for the project. 
What about going public, but list your refactoring ideas as issues in Github. This shows potential users your project, shows them you have an interest in maintaining and carrying the project forward, and may even get you a little help with your refactoring.
Thanks. I knew that. I used @param to show that autocomplete was possible without being strict. In PhpStorm I can even inline it if I put `/** @var Mom $mom */` above the variable.
Thanks!
Thanks. I know why my example doesn't autocomplete. I was asking if there was a way do to it. [Pimple](https://pimple.symfony.com/), for example, uses array keys to define container objects. I often find myself working around this with [PhpStorm Advanced Metadata](https://confluence.jetbrains.com/display/PhpStorm/PhpStorm+Advanced+Metadata). (for factories and such) My question was more if there is a PhpDoc style stynax (or IDE specific syntax) that existed to add meta to array keys. 
Thanks. I don't disagree.
Yup. Sounds like they both mean CMS.
Yes and Yes. Release and Refactor. Refactoring should be the permanent activity over a codebase. Small step not changing behavior, just enhancing design. So, before and after you release your code, you'll be refactoring. Notice that refactoring is different than adding features. So, the only thing you want to assets before releasing is if the current features set is useful. If that's the case: Release now. And keep refactoring.
PHP has been dying a "slow death" for the past.... I don't know....... 15 years?
B
In my experience when the thought "should I refactor now?" comes to my head, I should've refactored a long time ago. Also, every 6 months you can look at your own code and go "shit did I write that?". That's normal I suppose. 
I didn't think it wasn't supported or was, I thought "It would be a good idea if I could just sign up with a public key and access a web-interface without a password". The thing I was talking about was very specific. Basically what is done via SSH, but done in a browser, sent to a specific website as an authentication method.
And then completely rewrite in whatever the hottest new framework is...
If it's open sources, the community will gladly help out. 
Nah I won't switch frameworks just for the sake of it. Symfony is a mature PHP framework, with years of experience. No need to change just for fun.
Okay! 
Thank you for the input! 
&gt; but list your refactoring ideas as issues in Github That's an awesome idea!
One year ago, I didn't really know what components the project would need. The project just grew. Looking back now, knowing the full scope of the major release; I know a few things need refactoring. It might indeed be a bit too late.. Guess that experience grows with the years :)
Usually you can do most of this kinda stuff in SQL, but in your case you want the output in a very specific way. If you don't have too many records just reformat the results to your liking like this: $data = array(); while($row = mysqli_fetch_assoc($query)){ $data[$row['date']][] = $row; } 
https://gist.github.com/anonymous/8c118ac132f0b40855d3998ce736b277 This is the link to my code using the above link
I get a "undefined offset: 3 which is the position of $row[3], not quite sure how mysqli_fetch_assoc() handling the results of the query 
That function, as per documentation (and name), returns an associative array. You can reference your fields by name. $row['field_name']
Thank you for that advice it ended up working :) I guess I got a little overboard with the security when it came to trying to boot any unwanted users.
oh alright that can come in hand for sure.
You didn't even say what the fuck it is. There's every possibility you're the only one that thinks it's good and useful.
Read the book on refactoring by Martin Fowler, it's a really good guide as to the correct way to refactor, but it does start with ensuring you have high code coverage on the code that you're refactoring
Good tip!
If I said what it is, people would be complaining that I'm self-promoting the project. What it is doesn't have anything to do with the question asked here. I've also had some colleagues and friend look at it, with positive reaction. If you're curious I'm happy to send a DM with more information, but it would feel cheap to post links here.
Will you have fun with that? I think fun is one of the most importing things for your final year project. Something that will keep you motivated along the year. CRMs are not funny hahah in my opinion. Choose something simple and that you really like, think about your hobbies and pick something with that. After you're done, you can use it for your own personal use, and you will be more passionate developing that and talking about that in the final presentation. Maybe you will have many success and can create a big community. Like a social map for climbing locations, or an app that saves good routes for wlaking your dog and meet people that walk dogs (haha). The message is, do something for you that you like. Complexity comes with utility, and if you know a thing you will find many many uses and things to implement, complexity comes with that. My comment may be confuse, its hard for me to express my thoughs in english.
Putting aside the question of releasing your code, I would suggest that you should always be refactoring. What I mean by that is that you should take every opportunity that you can to review your code and identify areas that can be refactored (simplified, modularized, rewritten if necessary, etc). The reason is that as time goes on, you have learned new techniques, and/or technology has improved, and your older code could benefit from the changes. With that said, it is important to develop the ability to draw a line between code that should be improved and code that is good enough that it doesn't need to be unnecessarily changed. Changing code for the sake of change is unproductive, and you risk breaking code that was otherwise not broken. In the beginning of a new project, I like to stop and evaluate my project every few weeks. I do this because I want to try and catch bad decisions early to make refactoring as painless as possible. Over a couple of iterations, I should have a solid foundation, and I can spread the refactoring further and further apart. A nice side effect of this approach (for me) is that it gives me a break from the normal flow of coding. Once I'm done with refactoring, I also go back and look at my priorities to see if the refactoring has changed them in any way. Sometimes it adds more work (short term), while other times it reduces work. 
Thank you for the thorough reply! Helps me a lot!
I'm a little skeptical about the GitHub oauth scopes - why full read/write including hooks and services? 
It matters because if it's useless the decision is moot. You're acting like the decision is even consequential when you haven't published anything, which it is not. As if the moment you publish it, half the PHP ecosystem is going to start depending on your solution, which it is not. If it is, in fact, the case that the nature of the project is inconsequential then it is likely to be because the optimal decision is the same in both cases rather than because the nature of the project is irrelevant. That is, it is probably the case that you'd be better off just publishing it regardless of whether anyone will ever use it or whether it's the best thing since sliced bread but in an imperfect state, because at least that way you'll be able to gauge whether or not it would be worth the effort spending any more time improving it. And FYI nobody complains about self-promotion here since there are automated threads dedicated to such promotion. You should just publish it and provide the link for everyone and stop acting so shy about it.
You can import any type of repository - public or private. We also offer webhooks to get updates from your repositories. If you enable them, you don't have to sync manually. 
How did you get all that information - which tool? And this image was chosen as an under construction background lol, I intend to update it so that it feels less like 2003.
I think I should make a distinction here. If you actually mean "refactor" then the end user shouldn't be affected by anything you're doing. If you're changing the API then you're not refactoring but actually rewriting it. You should always be refactoring, but not as a deliberate task. Just leave things a little cleaner than when you found them. Do you have anything to gain by rewriting it now? Is it going to be too difficult to rewrite later? If you can't answer these questions then you don't need to rewrite it. https://martinfowler.com/bliki/DefinitionOfRefactoring.html 
&gt; You should always be refactoring, but not as a deliberate task. Just leave things a little cleaner than when you found them. +1 for the boyscout rule. I'm rooting for that rule to all my team-mates. And especially to myself. 
By then we'll have the `noFramework` framework. So it'll all be fine.
Yeah, Symfony is nice and if it works for you then there's no need to switch. My personal favourite PHP framework is Laravel but to each their own. :) I agree with others, don't refactor a lot at once, you should continually be refactoring as you go.
Than what? That was the reason everyone stopped using it in the first place, at least in the PHP world. Do you have any actual sources to cite? 
Oh wow, this is great! I'll add a link to this :)
"If you are not embarrassed by the first version of your product, you've launched too late." Reid Hoffman
You know you can disable htaccess scanning, right?
It really depends. Whatever you end up releasing, you should constantly refactor. The only reasonable way to be able to constantly refactor and still do frequent releases is to do TDD. If your code base is currently not a good fit for TDD, you are looking at maintaining legacy code if you release it as is, and that is a real pain to do without proper tests already in place. But even if that is true, it might be better to release it as is and refactor and add tests to what you have instead of starting over if you already have projects that depend on this one, or if this project itself is something you depend on. What I mean is, you should only start over if starting over really means starting over. If you will have to maintain both versions, or if you will forever be in a race to get the start over version to be as capable as the original, then it is probably better to stick with what you have. If you can start over and quickly release something of use that you iteration upon, and then just pretend the original project never existed, then I would recommend that approach. But if you do start over, definitely do it from the perspective of building something very simple at first, release it right away, and then iterate upon it. If you are not sold on TDD, I really recommend looking up Uncle Bob's talks on YouTube and his blog. He single handedly convinced me to get back into TDD, keep getting better at it, and stick with it, even though I already had much knowledge and experience with it and even though I had already read a lot on the topic and already understood a lot about it. Once you have seen a few of his talks, including the three laws of TDD, look up his talk about the transformation priority premise. The simple version of the principal he expresses in that talk is every time you add a test, you make your tests more specific, and every time you change your production code, you make that more general. If you can figure out a way to do that, not only on a class and function level, but at a higher level where that is true about the entire application and the tests for it, it would probably only be possible to work that way if you do start over, but it could be very powerful. And if you do somehow work on such a powerfully high level, you will definitely want lots of tests in place to keep you grounded. That is what I am about to attempt with my next personal project. Of course that last part is not actually professional advice, it is very much so just inspirational and experimental as opposed to battle tested advice.
This is just a crazy idea, but you might be able to put debug_backtrace() to work for you. Here are a couple of unrelated projects that use it in interesting ways: https://github.com/axiom82/PHP-Contract https://github.com/spatie/once
PHP for back end, bootstrap and jQuery for front end could be the new go .. I am just getting back into it all myself. Since v5 though, you might want to check out the deprecated lists to see what doesnt even exist anymore. For example, a few of the session_*() functions are gone and replaced with $_SESSION[], mysql functions are now mysqli, things like that.
mysqli isn’t exactly mysql, but it’s very close. mysql functions have been deprecated and iirc removed in 7.x. In any case, use PDO with prepared statements unless you have a very specific reason to use mysqli. For what’s up check all the change logs and to have a view of current best practices check http://www.phptherightway.com Frameworks have changed a lot, most popular now are Laravel and Symfony, been a while I’ve heard of a new project in ZF, CI or Cake. The most common way to run it now is with PHP-FPM.
Ahh nice. What are the reasons for using PDO over MySQLi? I've used both in the past, but PDO only for connecting to SQL Server, it seems a lot more cumbersome
It's still the fucking wild west friend, just wing it and make stack overflow your bitch.
Laravel is a great framework to use and laracasts for some excellent tutorials. 
Abstraction from a specific RDBMS &amp; (personal preference) nicer API.
Commenting to re-read when 5.5 actually ships and I can put this to use!
Just to balance things out, I definitely don't love them; stop 'em from coming!
Depending on how up to date you were at the time of 5.4, they introduced traits with that version. Traits are a very interesting language feature. You "use" a trait from inside a class. Doing so has nothing to do with types or inheritance. You can basically think of it as copying and pasting the code from the trait into that spot. Actually, I personally think of that as the purpose behind traits, a way of getting the benefits of copy and paste without the drawbacks of copy and paste. You see, we are often tempted to use inheritance as an easy way to avoid copy and paste, but that is often unclean because your case might not fit an "is a" relationship. Or it might fit it, but still not be a good fit for inheritance since you should only use inheritance if it makes it compatible with other code that works with that type you are inheriting from without it needing to know anything about the class that inherits from it. It's quite interesting that PHP has now evolved from a template language that accidentally evolved into a real language to being a somewhat well designed one. Most things that used to be errors can now be caught as an exception by catching the Throwable type. Personally I think using more exceptions and less errors makes PHP a much nicer language than it used to be. Probably the main way in which PHP is still lacking is in functional programming features. The programming community as a whole has become more interested in functional programming, but PHP has been slow to adopt functional features. It does have some, but using them feels clunky. As you say, this is now a "new JavaScript world". JavaScript is very popular, probably almost entirely due to the fact that it is the only full featured programming language understood by all major browsers. And of course it can now run on servers as well in the form of Node.js. But just as much as JavaScript has exploded, the language itself has also become disliked by many and transpiling to JavaScript has become a very popular way of utilizing JavaScript without actually having to work with the language directly. TypeScript is probably the most popular language that transpiles into JavaScript, and might be the most "liked" language right now. Surprisingly, this means Microsoft has changed from a company that is looked down on by programmers, other than the Microsoft fanboys and girls of course, into the company that made their favorite browser side language. Visual Studio Code is also widely recognized as the best out of the box TypeScript editor / IDE (they call it an editor, I call it an IDE). Visual Studio Code is even written in JavaScript (or possibly TypeScript, not sure), and it runs on Windows, Mac, and Linux. But the VS Code development team do not use Windows as their main development machines. But my comments about the popularity of TypeScript point to another interesting trend. The industry has become into more statically typed languages now that our rebellion against Java is far enough behind us. And indeed, that is one of the main things TypeScript adds, a more strongly typed language. The benefit of stronger typing, and yes I'm intentionally using an ill defined, generic term there, is you can see more errors at development time in front of a developer, instead of production time in front of a user. Stronger typing also allows tools to show you more errors statically. It also makes it possible for tools to offer more refactoring tools to you, since they can safely make more assumptions about your code. What does this have to do with PHP? PHP 7 has introduced more type declaration options. Basically, where they are used, PHP expects you to use those types, and throws exceptions when you don't. You can even put a ? in front of the type to indicate it might be that type, or it might be null. You can even place a declare(strict_types=1); at the top of all your .php files to make PHP more strict about types. That has turned PHP into a very interesting language, where the typing can be very dynamic and loose when required, and somewhat strict and static in other places. PHPStan is an amazing static analysis tool that really takes advantage of these type declarations to show you possible bugs in your code. A really good example of a modern language for code that is designed for the browser, transpiles to JavaScript, is statically typed, and is functional, is Elm. In my opinion, Elm is currently the most practical language for writing code that will run in the browser. It borrows its concepts heavily from Haskell, but is greatly simplified and made to be much more user friendly and easier to learn. Elm has the greatest compiler messages I have ever seen, and they keep making them better and better. This is a slight exaggeration, but they almost tell you "Go to this line of code and change this code to be this other code and it will work." Like Haskell, once you successfully wrangle your code into compiling, it usually does what you want, or at the very least, it almost never crashes or throws errors or exceptions while the JavaScript is running in the browser. Elm also tends to produce very fast JavaScript code. Because of its types and functional nature, Elm very strongly pushes developers toward writing, clean, well architected code. You don't have to put as much effort or training into getting developers to write good code with good design because the nature of the language makes it very natural to do. Some other tools have been inspired by the "Elm architecture" for use in other languages, but in Elm this architecture just forms naturally in your code without even trying. When there is something that you can't easily get working in Elm, it also has JavaScript interop. What does this have to do with PHP? Well, there is no supported way to write your server side code in Elm yet, so you could use PHP if you want, although they are extremely different languages. This was probably already the case before, but if you want to be a modern PHP developer, you really should learn how to use composer to manage your dependencies. This will make it easy to try out, and keep up to date PHP libraries, frameworks, and tools created by other people. Laravel is probably the most popular PHP framework, and people that use it tend to like it. Symfony is also very popular, and all the other PHP frameworks seem to rely on it at their core. My suggestion is if you are starting a new project from scratch, try out a framework and see how you like it. If you are supporting a legacy app, don't bother trying to make it work in a framework. Instead as you fix bugs, change behavior, and add features, make small refactorings in that same part of the code to leave it just a little nicer than you found it. Is PHP still relevant? Sure, lots of people still use it. It is showing its age in some ways, and there is a lot of PHP hate now, but it also has a lot going for it, and in my opinion we have not yet found the holy grail of server side languages, so nothing has made PHP obsolete yet. The language itself is actively maintained and improving. It supports an interesting combination of static and dynamic typing. It has support for runtime reflection. I like that I can run my PHP code and it feels like it starts up instantaneously, no waiting around for some environment to load up. The code itself also tends to run fast once it is running. Those two traits combined helps create a very fast TDD loop, which I consider absolutely critical. PHP has some pretty nice tooling. PhpStorm is a nice IDE. PsySH is a great REPL and interactive terminal debugger. PHPStan is a fantastic static analysis tool, that combined with type declarations makes PHP feel more modern and safe. I'm also a huge fan of PHPMD for helping you write clean code and PHP_CodeSniffer for enforcing and converting to the PSR-2 code style. If you want to have lots of servers that work together or take full advantage of processors with multiple cores, PHP is probably not the most natural fit that type of scaling.
Show this application to someone, get some comments on it. I strongly believe you will have a better idea after that. It always helps to improve from someone else's input while developing a hobby application. Then you can start refactoring slowly.
Fantastic write up. Really informative and pretty much exactly what I was looking for. Thanks!!
That's a good point! I'll keep this in mind!
This is very good advice! Although I do write tests for everything, they are written after the code, instead of the other way around; but still within the same commit. I don't think that counts as real TDD right?
It is "more cumbersome" only if you aren't using prepared statements while you absolutely should. And mysqli with prepared statements is a pain in the ass. And in fact PDO's got a very sleek interface, for example $count = $pdo-&gt;query("SELECT COUNT(*) FROM t")-&gt; fetchColumn(); Will give you the number of rows in the table in one move, while with Mysqli you will need another command. I wrote a nice [PDO tutorial](https://phpdelusions.net/pdo) which no doubts will convert you into PDO.
I consider Jquery to be legacy. It doesn't bring much over vanilla JS, and does not play nicely with modern build tools such as Webpack. And the plugin system have always been a mess. I would hesitate to include Jquery in a new project. Ten years ago Jquery was world-shattering. Today its ideas have been incorporated to JS.
That's a very good statement, thanks!
Just use Reddit for a quick boost back to the top.
If you keep saying it someone might believe you.
Use Admin LTE . They have a free and commercial version both. https://adminlte.io/
Read the migration guides here: http://php.net/manual/en/appendices.php = ["I know PHP 7.1"](https://www.youtube.com/watch?v=6vMO3XmNXe4)
Sadly, not many web host support PHP7 at the moment.
Didn't really get me psyched either before. I did, however, find some links to other themes on that page like [Ample Admin](https://wrappixel.com/ampleadmin/ampleadmin-html/ampleadmin-minimal/index.html) and [Material Dashboard](http://md-pro-angular2.creative-tim.com/dashboard?affiliate_id=97705).
Wut? What does PHP7 to do with anything from the above?
isn't PDO only in PHP7? Nevermind, just googled it. Sorry I'm new to PHP.
I think the main reason to refactor code is to make it more maintainable. Working from that idea, if you refactor now, you do so without actually knowing what parts people are going to request changes or features to, and so which parts really need to be "maintained" if you follow my meaning. Release it and then see what things are being requested, and refactor those areas to make it easier to maintain going forward. Don't fix what ain't broke. 
which would be a stupid fucking thing to do that only a complete fucking moron would consider, wouldn't it? Who the fuck wants to pay you good money to write your own personal snowflake version of existing code?
The .htaccess files are needed for the application to function properly. Otherwise they would have been deleted already
Notepad++ ok but classic notepad?really?
There aren't "parallel native PHP functions" for these. The idea of "helper" functions are that they shortcuts to the way you have to write it yourself over and over on top of the existing native functions. There's not much "clever" code in these if you look under the hood. They are common, everyday tasks to help free you up from writing the same code any college kid could do. It gets really tiresome to listen to a bunch of people who bitch about anything with a "Laravel" stamp on it without engaging their brains first. Long before most of you were born the people over at Borland were making good money selling CDs with lots of "helper" libraries of common tasks in C++, and it has been the way things have been done ever since. In fact, if you stop and think about it - that's the whole *point* of functions, isn't it? to reuse common code easily? if you find yourself writing the same code more than once, you put it in a function. if a framework finds people writing the same function more than once, they put it in a helper or on a class. you want to be a fucking interchangeable code monkey for the rest of your lives, competing on price and only get paid for how many minutes you spend with you hands on the keyboard while all the "soft skills" people keep getting promoted above you, then go ahead and waste your time looking clever with trolling. you want to *design systems* and become invaluable - and maybe even rich, God forbid! - get over your bullshit fantasies that those 3 extra microseconds every one of your daily 5000 users experiences makes a difference, and learn to appreciate the benefits of being able to get a new feature out in a few days instead of a month.
PDO is PHP5 and already 10+years on the scene :)
Legend! Thanks for the tutorial, I'll have to go through it sometime soon!
Oh! Maybe I mistood what it was when I searched it, when I searched jQuery recently to get how to do a get/post it came up with the following, is this just vanilla? Is there a better way to do this kind of thing!? $(document).ready(function(){ // user signup form $("#signup_button").click(function(){ $.post("user_signup.php", $("#signup_form").serialize(), function(data,status){ // check the output if (data == "OK") { // show the alert $("#alert-success").removeClass("hidden"); // write the message $("#alert-success-text").text("Success! You have signed up for a new account, please proceed to log in."); // reset the form $("#signup_form").trigger("reset"); } else { // show the alert $("#alert-danger").removeClass("hidden"); // write the message $("#alert-danger-text").text(data); } }); }); 
&gt; &gt; &gt; Most things that used to be errors can now be caught as an exception by catching the Throwable type. Personally I think using more exceptions and less errors makes PHP a much nicer language than it used to be. Why are exceptions better than errors? Because you can throw and catch exceptions thus you can handle them better than errors (not at all)? Thank you for such a detailed post.
PDO allows you to have a consistent API despite your underlying database choice, and thus you can change the database much easier without having to worry as much about your PHP code.
That is jQuery, but from what I understand a lot of jQuery's functionality is already in vanilla JS despite vanilla JS being quite different syntactically.
I've created a quick landing page for people to register their interest, should you wish to do so! [blk-smith.com](https://blk-smith.com)
&gt; "release and refactor" not "refactor and release." totally agree!
angular does it in less than half that though
Is there a difference between loading data from inside a Twig template vs. sending it during render? What would be considered best practice? Example: Option 1: {% set data = Entity.readAll() %} Option 2: $data = Entity.readAll(); $Twig-&gt;render('tpl.html', array('data' =&gt; $data)); ? 
Source? Benchmarks? Why did you post this?
https://www.reddit.com/r/PHP/comments/4bi9a4/why_is_mod_php_faster_than_phpfpm/
I like [CoreUI](http://coreui.io). It's a lot like AdminLTE (both visually and in functionality) but the code is IMO less convoluted and that's why I use it.
But that looks exactly like [Prime](https://genesisui.com/demo/prime/bootstrap4-ajax/#main.html).
We aren't bitching because it's "Laravel", we are bitching the way they are implemented. Answer me this, why are the global functions and not classes? Now quickly tell me which one of these is a default PHP function and which is a Laravel "helper": str_contains, str_split, str_limit, str_replace, str_is, str_repeat. That's going to be a pain when I refactor or change something to a microservice. These are extremely tightly coupled to Laravel and that's not a good thing. Besides that, why aren't aren't they classes so I can easily mock them for tests? Lets take the dispatch function: https://laravel.com/docs/5.4/helpers#method-dispatch. How to I test if it succeeds or fails, how do I know if my code handles this correctly?
I'd much rather have it as an external library/classes that I can add to any PHP project, not have it coupled to just Laravel.
I am sincerely asking, what wrong with it? And, please read the whole article out mentioned below &amp; tell me is it contrary to the norms of this sub-reddit? https://www.itjungle.com/2017/04/05/speedy-php-7-now-available-ibm/ 
@emilvikstrom, are you saying you consider non single page apps legacy in general? for sites that vue/react/angular aren't a great fit for, what do you use? I'd like jquery to be legacy, but it still seems pretty relevant for non SPAs.
If PHP is the wild west, what is JS? =D 
But why didn't you put that article in your post if that was your source? Your original post was so vaguely worded that I actually thought this article was going to say that PHP7 on IBM architectures was 3x as fast as PHP7 on some linux system. Instead, it turns out that PHP 7 on IBM is faster than PHP 5 on IBM. Instead of an amazing performance gain, this is a huge nothingburger. Of COURSE it speeds it up massively when you go from 5.4 to 7.1. It did that everywhere...
Also, if you develop on windows, laragon is an amazing environment to develop in. And of you are on Mac, then laravel valet
Generators are fantastic. Look at the \nikic\iter library for more uses of them. They basically make working with database cursors very nice indeed. PHP now has type hinting, I love it. I don't know how big composer was when you were doing PHP, but I wouldn't imagine a project without it. Frameworks are going more and more micro, where you basically pull in your own components as needed instead of a full framework. The main frameworks are Zend, Laravel, Symfony and Silex/Slim. Symfony 4 is looking super exciting, check it out. Doctrine ORM is one of the more used ORM's in my opinion. A lot of things are becoming standardised with a group of projects forming a group called PHP FIG a while back. Regardless of your opinion on them, you'll find their usage easy interfaces good for swapping libraries. For example, they have an interface for Requests and Response. Use these and you should be able to write your controllers so they don't need changing if you change frameworks. I don't know if you used PhpStorm before, but it's the One True IDE at the moment. It costs monthly, but it's worth it. Check out their EAP program if you want to try it out. It's basically beta builds and it's free. I still prefer PHP to JS for backend, but some don't. JS is getting better each year and so is PHP, but I'm still waiting on proper async built in for PHP without needing Hack. Also Hack is a thing. It's a fork of PHP. That's my list
And costs about 29$ less too! Didn't realize you were also looking for paid themes as well. I can't help you then, I only ever use open source ones. Good luck.
Some of these will probably echo /u/still_dreaming_1 * traits &amp; namespaces if you were not using them * the ability to catch `Error` types or both Exceptions and Error's using `Throwable` * `finally` keyword to compliament `try`, `catch` * strict typechecking (optional, but IMHO better than PHPDoc annotations) * `intdiv` method for integer division * `random_int` &amp; `random_byte` functions * no more throwing salts about, better authentication using `password_hash` * `hash_equals` method to check two hashes generated with `crypt` * null coalesce `$var2 = $var ?? 'default';` instead of `$var2 = isnull($var) ? $var : 'default';` * spaceships have landed to help us compare values making min, even, max sorting clearer var_dump(5 &lt;=&gt; 4); // 1 var_dump(5 &lt;=&gt; 5); // 0 var_dump(4 &lt;=&gt; 5); //-1 * you may have missed closures function lessThan($initial) { return function($val) use ($initial) { return $val &lt; $initial; }; } $lessThanFive = lessThan(5); var_dump($lessThanFive(7)); var_dump($lessThanFive(4)); * if not, the ability to assign scope to closures using `$closure-&gt;call($obj)` can be useful for sharing internal functions between objects * generators (have to admit I don't have a use for them to mind) * a void return type so that you can say explicitly "This doesn't return anything" * $someClass-&gt;$var has to now be $someClass-&gt;{$var} * nullable types for when a function might return a type or null (evil IMO) * you don't have to use `list` method, and can instead destructure using array syntax * you can pass array keys to `list` i.e. `list('name'=&gt;$name, 'age'=&gt;$age) = $people[0];` or `['name'=&gt;$name, 'age'=&gt;$age] = $people[0];` * no more `array( /* items */ )` needed, now it's `[ /* items */ ]` * `__debugInfo()` magic method for classes to alter contents of `var_dump` and `var_export` * class constants can have visibility declared * using pipe char `|` to facilitate multiple Exceptions sharing a single case * negative offsets in strings to mean from end. * HTTP2 server push in CURL * Scalar type declarations (instead of MyType[] you declare a function that takes an argument of type then use ellipsis) * Argument unpacking using ellipsis `$arrValues = [2,3,4,5]; var_dump(max(...$arrValues));` (probably worlds worst example) * the ability to define with array values, and have constants with array values (still not objects AFAIK) * anonymous classes (if you've ever had to program android and Java you've been subjected to this horror callbacks ftw) * unicode codepoint escape so you can read docs using and use yourself `"\u{0000aa}";` * zero-cost assertions in production code [read this](http://php.net/manual/en/function.assert.php#function.assert.expectations) * the ability to import multiple classes or functions using group syntax (similar to *nix cli, comma separated) [see here](http://php.net/manual/en/language.namespaces.definition.php) * use of exponentials `var_dump(2**8); // 256` * string and array dereferencing I've probably missed something, but for lovers of bullet-lists like me ;-) **Edit:** formatting
Why do you need syntax highlighting and line numbering if you're only making minor changes every so often?
That is indeed jQuery code. "Vanilla" JS would use `XMLHTTPRequest` or `fetch` directly, with probably `querySelector()` and `classList`. The three biggest things jQuery brought to the table (IMO) were Ajax, improved element selection, and cross-browser compatibility. The element selection is now browser-native, Ajax is arguably handled better with fetch (or a much smaller wrapper/polyfill), and cross-browser compatibility has improved immensely over the years. On the flip side, jQuery's view of the world makes it really easy to get your UI in a weird state, since it's generally event-driven rather than declarative. Contrast that to newer JS UI frameworks like Vue, React, Angular, etc which are basically `(state) =&gt; UI` and keep things in sync for you. They're also generally structured to help you avoid callback hell, although that's really more of a problem with all of the jQuery example code floating around than anything else. jQuery was great for its time, but it's definitely showing its age. It's still fine if you know it and just want something working to put a page together. But if you're trying to build a complex web application (and it's totally fine if you're not!), you'll probably find it's harder to use and maintain than the newer tooling.
If you're using Laravel, AdminLTE is packaged up as Backpack, which is an awesome CRUD interface too!
JS is taking your teen daughter to a boy band tradeshow
Well that's why I said I thought I would cut a couple corners and I was wondering what everyone is actually using and everyone's thoughts on the different frameworks. Thanks for the real help though. Probably the most helpful comment in the post. Thank you so much for the real help. 
What problem does Jquery solve? Considering how heavy Jquery is, it must add something to the table. A lot of the functionality is built into browsers already (document.querySelector, for example). For the rest there are more lightweight libraries, depending on what functionality you need. We use build tools regardless of site, so even when we don't use Vue we still use Webpack. It's good for more than single-page "apps".
Wrong wrong wrong. Absolutely wrong. Here is a challenge: Take any of your existing apps no matter how simple. Now try changing the type of database used and adjusting the PDO database type. Won't work. End of story. The only way an app can support multiple databases is if you design it to support multiple databases from the ground up. Adjusting the connection is a tiny trivial almost meaningless part of the process. 
If you into development why not just install Linux into separate partition and dual boot instead of using these shity abstractions. Ive never got that. 
Echo'ing or not. I'm a bullet-lover. This is so perfect. :D 
What lighter weight libraries resolve the functionality of JQuery API? I really just ask because it sounds like you're main problem is that it isn't great with webpack, you haven't offered much else. Size isn't a true concern is it? It's 20kb more than vue. Different functionality I know, but just saying it's unlikely someone would draw the line for a library over 20kb. It's nothing new and shiny, but I wouldn't consider it legacy as its still the most used lib out there. It's even a dependency for the most popular front-end (css/js) framework.
Your final year project is your chance to show off what you've learnt - I'm fairly sure you could do something really simple quite easily (e.g a blog) .... as long as it shows off various parts of your degree that you've learnt - i.e. design, architecture, technology considerations, requirements, testing, user interface design .... etc etc. "back in the day" [2001] ... we could do a final year project on anything ... but it almost certainly needed to be something you were interested in, given it was expected to take up a third of your final year and accounted for a considerable portion of your overall degree. 
If your goal is to match the Jqeury API, sure, use Jquery. I don't know what problems it helps you solve. I don't need to match the Jquery API, I need to solve problems. One of them is meeting a frontend time budget for my visitors. 20 KiB is still 20 KiB that needs to be downloaded, parsed and compiled (EDIT: apparently Jquery is 32 KiB, and that is after gzip). Frontend asset compilation is one of the things that takes most time and battery power for visitors. The more complex the worse. For me one of the lasts things I used Jquery for was Ajax requests, but there are Ajax libs down to less than 200 bytes. Makes it hard to justify spending 100 times as much time for Jquery. Why do you use Jquery? 
https://github.com/kicken/gearman-php
Pretty good pdo writeup. Cheers!
Shout out to https://github.com/BrandonShar/stack-overflow-buddy
&gt; There are two major caveats &gt; &gt; You need to keep in mind to use the power of 2 when calculating the next permission’s bit value [..] Not a caveat. Simply use hexadecimal. The pattern is simple: 0x100, 0x200, 0x400, 0x800, 0x1000, instead of 256, 512, 1024, 2048, 4096, etc. .. You can also add leading zeroes to indicate a max value. Eg if you have an unsigned SMALLINT in a db, write 0x0010, 0x0020 etc to indicate that 0x10000 won't fit.
 The results: Apache + mod_php: 10885 req/s, 9 ms per req. Apache + php-fpm: 5694 req/s, 17 ms per req. Nginx + php-fpm: 8193 req/s, 12 ms per req. That is: Nginx is faster than Apache given that both run FPM. However mod_php is faster than FPM according to that result.
Right. Hopefully you're tests are still thorough, in which case you are still behaving professionally, but it is not TDD unless the tests are written first. The main problem with writing tests after is there is always the temptation to stop testing before your tests are complete. It is also tempting to do manual testing before you write the tests, which will greatly increase the temptation to not write tests. Full TDD is where the tests fully drive your process, which is probably the best way to feel you can rely on them to tell you when something is broken. So to do full TDD you would literally write just enough of a test for it to fail, and then you write just enough production code for it to pass. Then you refactor and repeat, making the tests more specific and the code more general.
my favorite is metronic http://keenthemes.com/preview/metronic/ 
wat? Laravel is a PHP framework, it has nothing to do with the operating system.
This is a fantastic comment. Thanks for the awesome summary!
It's a proven technology with good support and a lot of modules. There are the usual pluses and minuses between the two, but it isn't like Apache is obsolete or something.
I think option 2 is better. Your view shouldn't care how the data is acquired. If you change data reading later, it should only be in one place in a .php file...
Yeah, I agree with you now that I think about it. It makes more sense to acquire the data in a php file, not a template :)
I'll definitely look into Uncle Bob you've mentioned before! Thanks for taking the time writing about this!
How is this php related?
Privacy policy? I don't understand why I'd use this over google translate (which sucks, obviously) if this is automated. How do you think you're better than google translate?
Lets imagine localization file with 1000 strings for translation, with LangTool you will spend 1-2 minutes, and how much time will you spend with manual translation through google translate? what if you need several locales? You can use it in guest mode without signin, I'll copy private policy from some resourse later.
Well there's this... https://cloud.google.com/translate/ Pretty easy to hack together a script that sends it all through that API
Does it support [gettext](https://en.wikipedia.org/wiki/Gettext) standard `PO` files?
**Gettext** In computing, gettext is an internationalization and localization (i18n) system commonly used for writing multilingual programs on Unix-like computer operating systems. The most commonly used implementation of gettext is GNU gettext, released by the GNU Project in 1995. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.26
Tbh there's an article under the video
There are huge risks. I will give you an example with Magento (ecommerce) where users can inject js code in the header/footer of non-patched older versions of Magento. And what do you think they insert? They are inserting a code that is stealing the users bank account credentials. So, do you still ask yourself the question if the data should be sanitized/validated? The answer is of course, every single time!
Even if the site has no other function but to generate these files? No logins, no user management? I'll sanitize anyway, but I can't think of a real world risk in the above example. 
can a user watch / play games created by another user ?
Timing info from the Chrome developer tools, for the compression related numbers I have searched for "gzip file size" I believe, I couldn't find the same but here is another one for example: https://checkgzipcompression.com/; also there are tools like Google PageSpeed which will show you a lot of other speed related things that you should care about: https://developers.google.com/speed/pagespeed/.
I ran the same source (a ZendExpressive app) on an IBMi partition and on a Raspberry Pi and the raspberry was twice as fast. Personally, I would only suggest using IBMi if there are extremely big architectural constraints: for everything else, just get a Linux server.
What's your test code and its output?
Ah, good news: it's me being a stupid idiot. I've tested it and it works as expected: https://3v4l.org/ij8Rl Sorry for waisting your time. Should I remove the post?
If they have the url, they can play as the resulting game is simply a index.html file and a .js file. 
renaming is easy and fast using the right tools, so I would say definitely do that. refactoring depends on the time you have and how bad it is...
Google api is not free
not yet, I'll implement support for django's PO as soon as possible
;-) btw It covers a bit more than the non-bullet
Not if you tell us why it didn’t work!
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Wow laravel invented the `-&gt;` operator? laravel is really so cool right guys.
Security is a process, not a state. It's a ratchet we tighten one notch at a time. Breaches generally happen when two or more bugs which are mostly harmless on their own line up in such a way that someone can abuse them. A common example might be one bug that lets you upload a file to a server, and another that lets you execute that file with escalated privileges. Dude who knew about the first bug: "it's fine, we don't do anything with those files". Dude who knew about the second bug: "it's fine, it's only us using that machine". Dude who discovered both bugs: "r00t!" So by asking "could this cause any problems?" you're kinda asking the wrong question, because you can't possibly imagine all the security holes this one could be mix and matched with. Better to ask "how can I make this more secure?" In your case, a way to share unsecured javascript with your friends sounds perfect for combining with an XSS bug in a browser. But the fact that I can come up with a hypothetical is immaterial - just be a good internet citizen and fix the security hole.
The thing is, that refactoring can get you of the track of making usefull stuff. (Refactoring is just repainting the car you already have.) So what I do (because I improve too), is make a list of stuff you want to refactor (with the reason why), and when you have time left, pick one of the things of that list and refactor that. (the list will grow overtime, and you make it shrink overtime, but you will always feel the need of improving.) You will see, that when the time is there to improve something, you have perhaps better ideas in how to improve it.
Yeah and as there is no reasonable way to run mod_php using Nginx the conclusion would be that using Apache you are able to get faster results.
You seem to have communication and/or learning and developmental difficulties.
"Loading..." I mean, if you're linking to an article, what else than serving the article do you need to load?!? Anyway, closed the website after 3 seconds. I don't know if the article is good or not.
Probably malware.
Don't forget to rate limit your login page otherwise you are in danger of ddos.
This article is FOS, only sublime (a fine text editor, but an ide at a stretch after a lot of fiddling), netbeans which is slow and cumbersome, and Eclipse which I've personally never been able to get working 100%, which may say more about me than the IDE. Netbeans I made full use of but kept getting bogged down in, sublime I use as a fast editor for reviewing files and minor changes if I don't want the penalty of waiting for my preferred editor to load, which is PHPStorm. Like it or not, it's the best editor by a country mile. The refactoring features and tight docker integrations alone make this indespnsible for me. It's paid for, but if you do PHP programming professionally you really need to consider that too.
camel_case class_basename ends_with kebab_case snake_case str_limit Nowadays laravel has good scope. Learn combination PHP MySQL and Laravel is really useful for future. http://zenrays.com/php-training 
Unclear how the decision on the 3 ide's was made. Sublime is not an IDE according to their own site. 
A template should always be used as a way to present the data (to render the data in a presentable way). It should have no knowledge which object(s) delivered the data to be rendered.
What if I download the js-file, and replace some js code inside it and run it. Would you have the idea I can't mess with "the system", because you got the system covered? Then you are probably safe. But you know... there are some smart dudes roaming the earth and not all are member of "the good guys". Think again... What can I do to mis-use the system?
What is it that users can create? Do they write code or do they send in parameters to your engine? In the second case I would serialize the parameters to JSON and let the JS engine interpret the JSON. All user input will then stay as data, never code.
It's quite error-prone as in easy to mess things up IMHO.
Thank you 
Is the user's form not just data/configuration? Why not pass that to the game so the game doesn't change - just all of the options and configurations passed to it?
As others have said, you're setting up a bad security model to start with. I have some suggestions, that my no means you should take to be as good practices or things that make you safe, but they can't hurt: - Have your main application on one domain, and "publish" the static pages to another domain entirely. That prevents same-domain privileges. - Read about cross site scripting attacks. Learn how to prevent them. ie: Imagine a scenario where a user publishes their JS that executes a call to your main page to publish another "game". You can effectively make a "worm" like program that goes nuts on your interface. - Spammers WILL find it. They'll find ways to host things on your domain. Phishing attacks, random links, so call "seo" hacking. You name it. Don't neglect security. - Easier mitigation (in addition to, not as it's only means) would be to present the user with the full source code, ask them to review and vote on it, and then launch it. People will be lazy though, and will just want to see what it does. Filtering JS will be a very fun and long project for you to figure out, and you're almost guaranteed to miss something and have a vulnerability. Again, none of this is a good idea.
They literally just choose various options and text. No code. The submission is ultimately combined with code and outputted as a single .js file. However, it's not quite as simple as passing variables to the engine. The submission is complex enough that the script is generated dynamically, so the resulting .js file can be quite unique. 
It's not quite as simple as passing variables to the engine. The submission is complex enough that the script is generated dynamically, so the resulting .js file can be quite unique. That said, the user doesn't provide code, just selects various options and text. 
I'd love to be able to choose mysql or postgres!
Thank you for your feedback! I will definitely add postgres in a future release. Feel free to open an issue :-)
I plan to experiment with this. I don't have much experience of docker, but in vagrant-land you can get plugins that manage the host's host file. Is there nothing like that for docker?
Django is not the only framework using PO files, CakePHP does too :)
Clickbait!
Hi PersistentBadger! I don't have any experience with Vagrant, so I can't tell you what are the differences with Docker :-/ I guess there are some Docker images which could help you with that, but I'm not sure. 
From your readme: &gt; Now open your hosts file......and add the following lines at the end of the file: I *think* I'm proposing you use this instead: https://hub.docker.com/r/grachev/docker-hosts-updater/ 
Oh sorry! I've totally missed your point Actually you could simply use http://xip.io/ if you do not want to update your hosts file. From the documentation: "Tip: Don't want to update your hosts file? Set virtualhost.local with your-virtualhost.127.0.0.1.xip.io in your project.yml file. Your applications will be available under *.your-virtualhost.127.0.0.1.xip.io/!"
&gt; I've totally missed your point Wasn't you.... I've fixed my original post.
Is it possible to share a bit of the code that does the generation and 2 examples of its output? It seems like there must be a way for the generator to - not eval code - but enable/disable and configure different modules.
will do both :)
&gt;might definitely lol
Awesome :D haha
&gt; Find your passions and avoid burnout as much as you can. This is true. But, it doesn't really help when you have a lot of passions concentrated into one area, and very few (if any) outside of one area of interest. I'm not sure if this is *indicative* of being on the autism spectrum, but I've met several who were that only had one or two real obsessions in life, and had little regard for anything else. What can we say or do when one of them begins to burn out? This is a bit more extreme than what Joe describes, but the same problem rears its head: "Find your passions" is correct, but not actionable.
 &gt;You should always be refactoring, but not as a deliberate task. Just leave things a little cleaner than when you found them. &gt; Unless you are Modernizing a Legacy Application in which your technical debt is earning interest faster than the national debt. 
Edited my post :-p
WordPress supports po as well. Back in the day I used PoEdit to manage them.
Do you plan on supporting CSV files as well?
Could you give an example?
Thank Goodness, you had me worried. I implemented this and *thought* I'd tested exactly that case.
Sure. Here is the simplified version of the code I had: class Ancestor { protected $prop1; protected $prop2; public static function buildFromArray($data) { $instance = new self; $instance-&gt;prop1 = $data['prop1']; $instance-&gt;prop2 = $data['prop2']; return $instance; } public function jsonSerialize() { return get_object_vars($this); } } class Child extends Ancestor { public function jsonSerialize() { return [ 'prop2' =&gt; $this-&gt;prop2 ]; } } Note the static `Ancestor::buildFromArray` method. Since it's defined in `Ancestor` class, even if it's invoked from `Child` class, it will still return instance of `Ancestor`. $childInstance = Child::buildFromArray(['prop1' =&gt; 'foo', 'prop2' =&gt; 'bar']); var_dump(get_class($childInstance)); // outputs 'Ancestor' So, `Child::buildFromArray($array)` will return `Ancestor`, since `self` used in `buildFromArray` method points to the class in which it's written. Late static binding to help: I replace `self` with `static` - and it works as expected. class Ancestor { ... public static function buildFromArray($data) { $instance = new static; // Here is the magic $instance-&gt;prop1 = $data['prop1']; $instance-&gt;prop2 = $data['prop2']; return $instance; } ... } class Child extends Ancestor { } $child = Child::buildFromArray(['prop1' =&gt; 'foo', 'prop2' =&gt; 'bar']); var_dump(get_class($child)); // outputs 'Child' Two lessons I learned: 1. Debug without haste, don't just look at the resulting JSON or HTML (which I did). 2. I thought late static binding is something I'll never use - I was wrong. Learn better.
To clarify: I am referring to the laravel JSON `where` notation (which is translated to various other server specific grammars) https://laravel.com/docs/5.4/queries#json-where-clauses It does poor escaping in some cases when crafting the final SQL.
do you have examples of using csv for storing translations? any documentation?
Just come work with me. We're still maintaining a 5.3 app, so you'll be ahead of the curve!
"Technologies such as airplanes, personal computers, and open-source software programs have been developed by networks of hobbyists, not firms or other formal organizations. This paper models individuals who develop a technology. In the model, agents called “tinkerers” have an exogenous interest in improving a technology according to their own criteria, and do not see a way to profit from it. Under these conditions, tinkerers prefer to make an open-source technology agreement than to work alone. The members of the agreement form an information network with economies of scale. Specialists in the group may devote their energies to expanding or managing it rather than working on the technology itself. Endogenously there are incentives to standardize on designs and descriptions of the technology, and to specialize in a particular aspect. A tinkerer in the network who sees how to produce a sufficiently profitable product may create a startup firm and choose to exit the network. Thus, industries can arise from avocations, as has happened in the aircraft, personal computer, and open-source software cases." http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.553.5488&amp;rep=rep1&amp;type=pdf 
As long as you make sure you are in charge of generating the code you should be good. For example, instead of setting `element.innerHTML`, create a DOM text node and insert it. Instead of blindly looping `for(;i &lt; $user_input;)`, type cast `$user_input` to an integer and make sure it is in a valid range. The first example is exactly the same as prepared statements for SQL queries; you use a parameterised interface to pass data. The second example is similar to escaping and validation. And of course, never let users trigger external files or URLs without validation. If they can upload an image, make sure it actually is an image. Don't let them link to external resources at all. Edit: Just wanted to add that you seem to reason well about what you are doing. That's a great start! The Magento security issues someone else mentioned was mostly based in the mindset of developers who blindly trusted user input. Magento used to have an `eval` in their core routing engine. When they removed that they replaced it with maybe three lines of code. So they originally used a huge-risk function to save maybe two lines. Don't be like them. Those issues have cost webshop owners around the world tens or hundreds of thousand dollars due to shoplifting, and the Magento team have had to put a lot of manpower on cleaning up such bugs the last few years. 
Superpower by 2030.
I like to get as far away from a keyboard as I can with my hobbies. Hiking, biking, fishing. Recently got into hammock camping too.
&gt; reverse-proy Is that a reverse proxy? or is there something known as a proy that I know nothing about? Also, why is is so convoluted? Like if someone is struggling to get to grips with docker, is this helping them?
I think the example given might be trying to improve those devs by saying "instead of having multiple boolean fields or a one&lt;-&gt;one relationship with some meta-table, why not simply use one field and set bits?" It's space efficient for storage, and also makes more complex logic possible. I've been using status bit's in most database tables for years (even if you don't use immediately just set it to default to zero and save yourself a migration / change). What it needs to talk about is that it's fairly unsuitable for beginners without a CS background to use, and the storage form doesn't need to be the same as the API form (they don't have to be different either, but they don't have to be 1:1).
What are you doing that's so complex you can't just spit out a JSON object?
There was a talk where EBI is combining with MVP. In that talk, Robert C Martin showed multiple boundaries. https://www.youtube.com/watch?v=o_TH-Y78tt4 Beware he's not talking about PHP. Often I see him talking about Ruby these days, even mentioning Rails 
hahahaha love it! 
Using magic methods like this can be fun to play with, but I think the usefulness of this is limited by a few things: 1) This is like 32 lines. Let's not be javascript and have libraries this small. Better to just have a tutorial showing people how to implement this sort of thing. 2) This treats private/protected/public properties as all the same. Why even use setters/getters then? Might as well just have all properties public and use the -&gt; to access them directly. 3. IDE cannot autocomplete the setters/getters because they aren't concrete methods. 4. Why a trait? Why not an abstract data object class of some sort that objects extend? This is a personal preference, but I'm not a huge fan of traits. Basically this saves you the trouble of the boilerplate getter/setter code, but at the cost of'clean' OOP. And if your using PHPStorm hitting Generate-&gt;Setters/Getters does all the boilerplate for you anyway.
Hi codesign2! Thank you for your feedback! Indeed, it was a typo; the README has been updated! :-) I'm sorry to hear that you find it twisted. My primary goal was on the contrary to provide an easily configurable stack, even for someone who has no experience with Docker. Maybe the documentation is not clear enough? Do you have any suggestion? 
Semver reserves 0.X.Y for not-yet-stable dev versions: &gt; 4\. Major version zero (0.y.z) is for initial development. Anything may change at any time. The public API should not be considered stable. &gt; 5\. Version 1.0.0 defines the public API. The way in which the version number is incremented after this release is dependent on this public API and how it changes. I would release version 0.0.1 and call it a day. No need for an alpha label at that stage. People already expect the public API to change between versions in the 0.x.z lifetime. Be as arbitrary as you want! After version 1 you start having other people depend on your public API so that is the stage where you have to start worrying about correct semver usage. I would maaaaybe consider 1.0.0-alpha.1 if I am certain that the public API is stable but the release itself is not (I'm not going to rename or semantically change anything in the public API, but there are bugs to squish before the stable release). 
Same here, pretty much the only reason I am a developer is to have enough to spend on all the camping and biking equipment I want.
I just ordered myself one of these: https://dutchwaregear.com/hammock-gear/hammocks/chameleon.html Can't wait to try it out :)
For context, I'm coming from a web agency perspective, where there's often framework level dependencies on JQuery, like Bootstrap, or CMS frameworks like Drupal. If it's already there, it makes no sense using anything else for general dom manipulation and ajax requests. It's more difficult not to use it in cases like these in terms of cost, skill, and maintainability to shoehorn in latest trend. You're making this argument over 8 kb and maybe not idiomatic to modern JS but it can be loaded fine with modern tooling. Sure it's irrelevant to some project, but actually the best option for others. It's a relevant proficiency the OP probably has and it's one that is still valued by many shops that maintain sites built on current frameworks.
depending what you need, you could just use the enter sql and use something like FOREIGN KEY `Name` REFERENCES `Table`(`Name`) note: this either goes in a table build or edit
I'll try it later and I'll update what happen. Thanks a lot.
Modernizing a legacy application: go through the entire code base looking for and fixing one simple concept per pass. Once it's "modernized," then you can and should Boy Scout rule your code. See http://mlaphp.com/ for more details. 
http://devdocs.magento.com/guides/v2.1/frontend-dev-guide/translations/xlate.html
[LMGTFY](http://lmgtfy.com/?q=how+to+create+a+relationship+with+tables+in+phpmyadmin)
Yes they are. And that was a great article IMO.
Dutch is the man!
well done sir, i think its alright. if we have to hold hands and anticipate every blocking concept we're getting nowhere. if you really want to be helpful you could have some the short paragraph about docker and linking to a tutorial or 2 but i wouldnt do it if i were you. if someone is interested and would like to know more they can google, like on this /r/. but splitting up the main readme would probably be a good thing. have the absolute mandatory things on the readme, and the rest in a docs folder.
Hey, thanks for sharing, It's not the documentation that I found strange. It was the choice of tools, and the range of tools, which I believe for the intended audience or stated intended audience is unnecessarily complex. For example, the reverse proxy seems to add nothing that a lets-encrypt certificate generation (through any client) docker container couldn't have added as an optional dependency. The reason I pick this rather specific seam, is that it can somewhat seamlessly integrate into for example an entrypoint script detecting cert files, be turned off and on using sed to uncomment a few lines, and string substitute would work. Further, it would be idempotent and would allow transmission of built-artifacts to production. Other choices like generating a docker compose.yml also seemed a little strange to me (it was the first thing I noticed and I had to use the search feature within the repository to find the template). I'm a fan of using templates to make content more reproducible and would concede that anyone that does take the time to learn orbit might find some utility or higher level understanding. Had you considered maintaining pre-built editions? Essentially all it requires is you using orbit to generate some outputs, and moving some logic to an entrypoint script using environment variables rather than rigid baked in config (which is also another reason I'm not so sure on generating docker-related configs; when done right docker doesn't need that).
some points for expansion upon this (hopefully others have more) * multi-staged builds * docker by default struggles with balancing resolving dependencies (often dev dependencies) and providing a runtime. * you can in recent docker versions have multiple FROM clauses for stages of your container so that it's cleaner to shed cruft * you can alias `FROM image:tag as shortidentifier` * you can then use the `COPY` command providing the name of the prior stage, the source and destination path * Implementation decisions * some MySQL images require a re-build to change credentials * they certainly don't have to, most choose to * this is in-order to lower complexity and decrease startup times on consecutive runs * flags * `--restart` policy flag (I like always) for `docker run` * other helpful flags such as `--no-cache` for `docker build` * when perhaps you use the `RUN` directive with `wget` or `curl`, instead of using the `ADD` command with a remote URL * nuance * permissions &amp; misc settings with docker such as setting `--shm-size $X` * recently relayed to me regarding running firefox nightly in a container `X=2g` * also fixes some builds that were failing under docker for me with segfaults (shakes fist at shm default to 64m) * weird things people do to reduce volume layers such as chaining commands and using backslash to line-break * the need for commands to return code zero and workarounds for misbehaving apps 
share publicly use everyone.
You're not giving us specifics about what you're configuring and looking for a generic solution. You should be careful with generic solutions: they tend to end up being implemented as (pseudo) singletons, (pseudo) static registries and locators and so on assortment of tightly-coupled global-mutable-state spaghetti architecture. Let's break apart some of the requirements. - You need to parse config from a file - You need to configure an object. This has no reason of being one thing. It's two things. For parsing config files, you can have IniParser, XmlConfigParser and so on, which return an array or DOM-like representation of the configuration, and you can even optionally apply a schema to the config which the parser validates for you. For configuring objects, you should make sure the configuration is not tied to any assumption about the environment. An object doesn't care what project it's used in, it doesn't care if its config comes from a "config store", a file, environment, HTTP headers or whatever. An object should only see what it needs and nothing else. My personal choice in implementing this is builders. Not saying it's the best one, but it has two benefits: 1. The builder is a compact, easy-to-use, type-safe approach to configuring just about anything. No "stringly typed" configuration! 2. It frees up the object constructor to be "low-level" and efficient, so you can feed it configuration in the most direct format possible, and then bypass the builder and pass, say, config from a cache, or a dependency container. . class Server { /** * The constructor is intended for advanced use cases, if you're * constructing a Server instance "by hand", use Server::builder(). * * @param ... * @param ... */ function __construct(... long list of low level settings ...) { ... } /** * @return Server\Builder */ static function builder() { return Server\Builder(); } } $server = Server::builder() -&gt;listenHttp('127.0.0.1', 80) -&gt;listenHttps('127.0.0.1', 443) -&gt;docRoot($docRoot) -&gt;handler('.php', function ($file) { require $file; }) -&gt;ttl(60 * 5) -&gt;timeout(60 * 5) -&gt;build(); This is very user-friendly, Server doesn't depend on any "config container", it's independent, and it still allows low-level construction of Server objects (directly via the constructor), should you need it. Here are two more important reasons why you should **never directly tie** file config to code config: - Notice how I tightly configured a PHP handler up there with a closure. When you read from a config file, you can't pass objects, you can't pass closures. That's a **huge** detriment for your configuration flexibility and will results in tons of "plain text" settings which could have been a single object you pass in. - The settings you need to set from a file are not the same settings an object needs to set in code. You only need to put config in a non-PHP file if you expect non-PHP programmers to deploy your software, or if you expect the same config format to be used across multiple platforms (say you wrote the same Blog engine on PHP and Ruby, and now want to support the same config file for both). 
Generally I keep my configuration itself as its own object which is then passed into or integrated into bootstrapping code. The object reads simple configuration data files and has methods to query configuration values in a uniform way. How I've done bootstrapping code has varied throughout the years, but my latest revision has convinced me that simply pulling this into DI delegates/providers is the way to go. That said, I do abstract these delegates now with distinct classes that implement interfaces. Generally the configuration object is fed to them, they query the config, setup the dependency and return it. So the application itself only has the most minimal code for setting up this paradigm.
Not that I use magic properties in PHP, but some corrections and feedback: &gt; This is like 32 lines. Let's not be javascript and have libraries this small. Better to just have a tutorial showing people how to implement this sort of thing. The author doesn't obligate you to use this via Composer. If you prefer to copy-paste, then copy-paste. Presenting it as a Tutorial doesn't help you in any way. &gt; This treats private/protected/public properties as all the same. Why even use setters/getters then? Might as well just have all properties public and use the -&gt; to access them directly. This argument doesn't make sense. You're saying that encapsulated public properties (encapsulated via the get/set methods tied to them) is the same as unprotected, unvalidated public properties? Uhh... no? We have three access levels. - Magic properties encapsulate public access, the most vulnerable one to encapsulation violations. - Private access is never encapsulated, because there's no more "private" than "private". You can't protect a class from its own code. - If you want to allow subclasses to be encapsulated from accessing the raw property directly, make it private, else make it protected. So everything is as it should be. &gt; IDE cannot autocomplete the setters/getters because they aren't concrete methods. It can, via the `@property` annotation (there's also `@property-read` for read-only properties). It's supported by all big IDEs (PHPStorm, Eclipse PDT, Zend Studio, Komodo, NetBeans, etc.) and works exactly like native properties. &gt; Why a trait? Why not an abstract data object class of some sort that objects extend? This is a personal preference, but I'm not a huge fan of traits. "I'm not a huge fan of traits" is a poor explanation of your preferences. A trait is the correct solution here, because if you make it a class, then you **block any class that has a parent from using Accessors**. Imagine you want to make a user-friendly `PDO` class with Accessors. So you need to extend PDO. If Accessors is a trait - you can! If it's a class... oops. Think about it like this. Using traits is like having friends. You can have many friends, and it's not very dramatic when you lose some and gain some. But inheriting a class is like marriage. There's only one, and divorce is expensive, painful and messy. So choose your superclass carefully, it's not a light decision. &gt; Basically this saves you the trouble of the boilerplate getter/setter code, but at the cost of'clean' OOP. There's nothing dirty here. The only real trouble is that magic get/set in PHP is quite slow, because it works as a fallback once everything else fails (i.e. it checks for class property, then a runtime object property, then checks if handlers are defined, then runs the handlers, which runs __get, which then runs getSomeAttribute()... painful). In a better world, get/set properties would be declared properly and be as fast (or faster) than using get/set methods: class Foo { private $_bar; public $bar { get(): Baz { return $this-&gt;_bar; } set(Baz $val) { $this-&gt;_bar = $val; } } }
Great guide this is definitely something I will use, read through half will read it again when I get home.
You know that MariaDB is a drop in replacement for MySQL right ? Do you realize that means the exact same code can run on both ? Also I'm still using MySQL on most of my production servers because it works fine so I have no reason to change.
There could be some problems with this implementation: 1. You want to hide some attributes from Child without changing visibility to private 2. Beware the order of attributes from inheritance For example: You have 2 attributes in Ancestor. (prop1, prop2). If you json_encode Ancestor you will get extra this order (prop1, prop2). However: if child gets a new attribute, this attribute will be prepended in your json - which should not be a problem. But for some cases, maybe you iterate things and expect a certain order, this might cause problems. I assume that you use this for any kind of model with a simple data structure. For anything else i was always going for a simple toArray method with json serialize. This way you can also use the array representation of the object. (You can also just use the ArrayObject - not the plain one but maybe from Zend or any other framework) public function toArray() { return [...] } public function jsonSerialize() { return $this-&gt;toArray(); } 
Thank you for the kind words! Indeed, I'll update the documentation by splitting it in a future release.
Thanks for the input! Very useful information in your reply! To give a more concrete example, this class: https://github.com/brendt/responsive-images/blob/master/src/Brendt/Image/ResponsiveFactory.php (note I know there's a lot to improve here, please don't judge :) ) This class basically will take the path to an image file, render multiple sizes of that image and return an object containing the needed data to render that responsive image in HTML with `srcset` and `sizes`. This class needs to be plugged into multiple projects, with different kinds of configuration. A few examples are which driver to use, where to store rendered images, what the max file size must be, etc. Because I don't want the class to be concerned with configuring itself, or the constructor be swamped with arguments, I decided to use a "configurator" which can configure an instance of this class when it's constructed. That happens here: public function __construct(ResponsiveFactoryConfigurator $configurator = null) { $configurator = $configurator ?? new DefaultConfigurator(); $configurator-&gt;configure($this); // ... } So that's the context I'm working with. This approach actually feels kinda wrong to me.. But I can't per definition say what exactly I'm looking for. I was hoping there was just one pattern someone could point me to and say: "use this". Edit: another approach I've used is to add all config parameters to the DI container, and then use them as parameters in the dependency config file. Not sure either if that's a sensible thing to do, although Symfony's documentation did mention it from time to time.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [brendt/responsive-images/.../**ResponsiveFactory.php** (master → c3ba0c6)](https://github.com/brendt/responsive-images/blob/c3ba0c66abf404db34a1d683470b58595433471e/src/Brendt/Image/ResponsiveFactory.php) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dm9sd7r.)^.
Thanks for this. I've heard of docker a lot but being pretty happy setting up my own environments never bothered to learn about it so it's nice to have this overview. One thing, what's the performance like compared to running a traditional stack? Is there much overhead for the docker and containers? And can you still manage system resources, e.g. allocate ram to mysql etc?
Actually, you can disable almost all modules (aka tools) if you don't need them: only the reverse-proxy, NGINX and PHP-FPM are mandatory. There are options in the file `config/modules.yml` which allow you to do that. Concerning the reverse-proxy, it allows to have many environments on the same host, without having to worry about ports mapping. Also, it helps me to provide the automatic HTTPS on local environment: I use the Toolbox container to generate the self-signed certificate and I just configure Traefik to use it. I agree you could use NGINX for that, but I prefered to keep its scope to "serving the PHP application" with PHP-FPM. About generating docker-related configs, I could indeed use an entrypoint per container to update its configuration using environment values. I think it may also make the containers reusable outside the kickoff project. That's said, it was easier for me to generate containers' configuration files, as its something I'm used to work with. Anyway, thank you for your inputs, greatly appreciated! :-) 
Or just run dnsmasq only under linux / mac though not sure what dns you should run under linux. I use this setup with nginx reverse proxy from jwilder. https://gist.github.com/cdekok/8df671c859b7cc5aa6f44fb9e2ccf85b Or ubuntu / debian `sudo apt-get install dnsmasq sudo touch /etc/dnsmasq.d/localhost-tld sudo -i echo local=/localhost/ &gt;&gt; /etc/dnsmasq.d/localhost-tld sudo -i echo address=/localhost/127.0.0.1 &gt;&gt; /etc/dnsmasq.d/localhost-tld sudo service dnsmasq restart docker run -d --name nginx-proxy -p 80:80 -v /var/run/docker.sock:/tmp/docker.sock:ro jwilder/nginx-proxy`
That would be quite logical. [What is meant by a number after “break” or “continue” in PHP?](https://stackoverflow.com/q/5167561/285587) 
Indeed its a nice option! But as this project have also to work under Windows, xip.io seems more suitable.
Performance - very near to native - as it shares the same kernel (it's not a virtual machine). You can configure applications inside containers just the same as outside - so if you want to tell your MySQL container to use 10GiB of RAM then fine... Containers also allow you to cgroup restrictions on a container - e.g. placing a limit on how much memory or cpu time it can use. 
I'd just suggest : * docker build --pull --rm -t TagName . (--pull - fetch latest parent image, --rm remove intermediate containers ) 
Ah yeah. I don't find that I have to use it often but when I do, it's dead handy.
I've skimmed through the code and seems like you could use a builder here, as the Configurator seems a bit redundant (i.e. the factory takes it in, it takes the factory in, and calls its setters). With a builder, those setters can move to the bilder, and then become constructor params on the factory. It doesn't matter how many arguments the constructors needs, just put them there, and then make an intuitive API for providing them via the Builder. **EDIT**: Also it seems that overall your problem is "how to get a preconfigured instance of ResponsiveFactory". And this is basically the role of the dependency container (a.k.a. "composition root", a.k.a. "main factory"). When you're writing an app, you'll have one class which builds and returns such objects for you to pass around. Technically you're already prepared for this even without the configurator. But if you don't need to mutate the configuration *as the object is used* it'd be cleaner to move the configuration setters to a Builder object, so the lifetime stages of the object doesn't get muddled. Right now it's: - Configure and use ResponsiveFactory at the same time in any order. Someone might try using the factory before it's (fully) configured. But with a Builder it'd be: - Configure a ResponsiveFactory &amp; build a valid instance. - Use the instance without further messing with the config.
So does `continue`.
Can't believe I'm saying this but I think goto is more reasonable and maintainable than break with arguments. 
If you use docker4mac you will have a great performance impact when sharing a lot of files over volumes (for example symfony, vendor etc.)
I think the main problem would be using multiple nested loops. If you ever have to use `break 3` or higher I'd seriously reconsider my algorithm. 
Because you can catch them. treat them and in some cases even continue your code, with errors your code would die, or am I mistaken and errors before 5.3 were not all fatal errors?
&gt; One thing, what's the performance like compared to running a traditional stack? Is there much overhead for the docker and containers? It was originally built on top of Linux LXC, which in turn was a wrapper around Linux cgroups, Docker was then yet another wrapper around LXC. So it's nothing new, which is a good thing as cgroups/LXC has been around in the Linux ecosystem for about 10 years. They pulled LXC support and wrote their own from scratch a few years ago. How their own implementation compares to something as mature as LXC in terms of performance I'm not sure. I'd just take a look at LXC and miss out all the fluff.
Yeah, definitely seems like a solid case for method extraction or something else to reduce nesting. 
Cool!! I love his talks! Indeed he never talks about PHP... Tkx for the link, i'll watch it for sure!
&gt; By mapping the container's port 3306 to a host port, you are able to use a more powerful tool like MySQL Workbench using 127.0.0.1 (or your server IP) as host and the port defined in the variable MYSQL_HOST_PORT_TO_MAP in your .env file Bad advice and shouldn't be encouraged. Do not put your database on a public facing port. Please stop promoting such a practice it's security 101 not to do that.
Seems like the way this is meant to be used in real project is that you should gitignore generated files, touch only .blueprint files and regenerate real files after each change? Problem with this is that I will be then responsible with maintaining these blueprint files, which adds complelxity to the project - and there already is bunch of code in them to support features I won't ever use. Such code makes it harder to do modifications. I can imagine after some lifecycle of your project, a lot of the code will be added - to cater to requirements of various projects. Removing all of unneded code by a user will require learning all of the configuration options - options specific to your project. I don't know what's the solution for this, but please take this in mind when this project evolves. Don't bring support to obscure features and make your template files crystal clear for unfamiliar reader.
Hi twiggy99999! I'm far from a security expert, so thank you for the feedback! You're suggesting that only the CLI should be used on production environments? Could you elaborate so I can update the documentation with good explanations? Thank you!
Hi gadelat! The generated files are actually already gitignored. But you're right, you have to regenerate them before starting the containers (if you've updated the configuration of course). For avoiding this, CODESIGN2 suggested that I use entrypoints in my containers which handle the configuration thanks to environment values. It would reduce the amount of blueprints and generated files. I've tried to make the configuration files as simple as I can but I've struggled to find a good balance between useful and optional features. What are the features which you think are not required? Thank you for your feedback!
Wouldn't this be considered restructuring rather than refactoring? https://martinfowler.com/bliki/RefactoringMalapropism.html
I've noticed that this post gets heavily downvoted. Maybe I should delete it? Edit: wow it was 54% at some point, don't know how it became 84%.
Hello, It's a very wide and in depth topic, much more than I can cover in this post. So I urge to you give this document a read (it's not too long) to give you an overview. http://www.sans.org/reading-room/whitepapers/application/making-network-safe-databases-24 &gt; You're suggesting that only the CLI should be used on production environments? Not always the case but it's a good start. If you need access to the DB then SSH access into the server (IP and user restricted with SSH keys). Putting your database out on the internet where anyone can make calls to port 3306 (changing the port is not enough in the way of protection) is just asking for trouble, don't do it.
So I've been learning. My other hammock is an eno knock off, barely 9 1/2 feet. I ordered a ridge line and whoopie suspension a couple of months ago for that. I love the metal clips and hooks he comes up with
Thank you for your inputs! I've added an issue to address this.
Clearly the best one is get_instance()-&gt;config[...] Jk. I prefer doing it with something like Pimple so instances are configured lazily on first use and that configuration is encapsulated in, at least, a closure. But when necessary I'll use a global object that's read/write so it can be overridden easily during tests. Mainly for really global configuration stuff like an app port number or asset directory that it makes no sense to change during runtime.
I don't see features which are not required generally. I think you have done good job with that. It's just that some features are useful for some projects, but not useful for other projects. If I am in camp B, I don't want code for such features in my repository. Most of the features also become useful only once project reaches certain stage. For example, I don't want in my repository code for supporting rabbitmq if I'm not using it. It immediately gives impression to new team members that we use it and it needs to maintain. Plus even if we don't use it, it's still used when building and so slows down the build process. Another example. If I already once switched on docker-sync support, I don't think I'll ever switch it off, therefore switch code becomes not useful. Things like that. Another feedback regarding the usage of this is: I don't like the folder structure much. Most users would probably start with git cloning this, but they most certainly want their own project's readme in root of their repository and don't want to have scattered build files/folders in their root. More fit would be to leave app/ in root and all the rest of files move to build/, maybe except of main build index file (orbit.yml?)
Apparently, you [are wrong](https://bugs.php.net/bug.php?id=75036) as "This is a very strange behaviour, and completely functionally useless," But.....yeah. I prefer to use goto's for that behaviour where required.
Indeed, this is the kind of thing where I can see if you're implementing a really specific algorithm there might be a reason to use it, for example in complex parsers. This is something you use _maybe_ once in your career. In which case, as /u/assertchris said, `goto` is still probably a better option than `break 2`. In almost all cases, refactoring is going to be a better move than either `goto` or `break` with an argument.
Why should you? Doesn't harm anyone.
Completely agree, but if you're writing a standalone package, like that image library, you can't possibly include a dependency container, right? But I still need a way to enforce many parameters being fed into the class. Putting those required parameters in the constructor solves the issue, like you've addressed before. This feels like bloating the code to me, but that might as well be just a feeling not worth taking into account. Btw thanks for the effort put into your feedback!
Indeed, they are some modules that you may not need. The v1 of this project started with a simpler stack: Apache, NGINX as a reverse-proxy and MySQL. I told the users to extend it with new services if needed. But as we used it a lot at TheCodingMachine, they were some struggles about adding new services (configuration and so on.). That's why I've decided for the v2 to propose more services, which you can disable if you don't need them (`config/modules.yml` provides options for that). Of course, you have now to update your README to tell new team members that one or more services are disable. Good to know though: if a service is disable, Orbit will not take it into account in the build / start / stop processes. Concerning Docker Sync, I've offered the possibility to enable it or not, as we have developers who are working on Linux, others on Mac, and a few others on Windows. Also, I think it's mandatory on Mac, but not on Linux. The folder structure has been updated since the v2 beta release. It was previously more like you described (see [here](https://github.com/thecodingmachine/kickoff-docker-php/tree/v2.0.0-rc3)). I think the new folder structure is more understandable, but as I've been working on it a lot, my point of view may be biased ;-) Hope I've answered some of your concerns! 
Ah I don't quite use it like that. I usually only `break 2;` to get out of 2 loops.
I don't really get the bad rep over goto. It can lead to bad code, but so do ifs when you nest them like crazy. Btw, I would take a goto over nested ifs any day of the week. 
I looked at Docker a couple of years ago and one of the bigger issues I came up against was the '1 process per container' vs running supervisor. Is there some sort of standard yet? The clearest example of something that I couldn't see a clean way to do in Docker was Cron Jobs. Do I have a separate Docker container just to run cron? Do I run supervisor and run Cron alongside PHP, Apache, etc? I'd be curious to know what everyone here does?
The main reason is that there is almost always a better way of refactoring your code that doesn't require either `goto` or heavily nested ifs and as soon as you're using `goto` across different scopes or contexts it becomes a quagmire of unintended side effects and difficult to follow code very quickly. There are a very few places where `goto` might be the best option for readability, given a lot of constraints, but those situations don't occur in the overwhelming majority of code people write for the web (or indeed, system/application code) and so it's easier just to discourage their use entirely, because if you're writing code that actually benefits from it you probably understand the trade-offs you're making and know you can ignore that general advice.
&gt; Completely agree, but if you're writing a standalone package, like that image library, you can't possibly include a dependency container, right? Yup, but the container here would be a simple factory method, it's always easy to write on the spot for the app. &gt; Putting those required parameters in the constructor solves the issue, like you've addressed before. This feels like bloating the code to me, but that might as well be just a feeling not worth taking into account. Hmm, not sure where the bloating would come from. If you don't plan to be building ResponsiveFactory "by hand" around the code, you can skip the Builder. In fact I also don't have a Builder for every single class, only for those I construct very often and on the spot (say a very complicated value object). When you plan to configure an instance centrally and leave it at that - all you need is the constructor, and then you can remove the setFoo() methods as well, which should result in *less* code and bloat, not *more*. Am I missing something?
`0.0.1` is regarded as stable by composer, while `1.0.0-alpha1` is not. In other words, it’s easier for the end user to install `0.0.1`. It’s up to you to decide what kind of behaviour would you like to encourage.
[removed]
https://github.com/n7olkachev/laravel-accessors/blob/9ddc3ac494fb5e2cae508310faee25a73ae123db/src/Accessors.php#L28 $method = … ucwords(…) … Method names are not case sensitive.
You're actually right.. Removing the setters removes a lot of unneeded code. I was referring to eg. this as "bloat" public function __construct( $driver, $includeSource, $publicPath, $sourcePath, $rebase, $enableCache, $optimize, $scaler, $stepModifier, $minFileSize, $maxFileSize, $minWidth, $maxWidth, $sizes, $optimizerOptions ) { // ... } But this together with a builder or factory does indeed seem like a good solution. Also important to note is that there are some parameters which shouldn't be in the constructor, because they are optional or have sensible defaults.
A shame that Composer does not follow the spec then.
Hehe, that does indeed look a bit scary, although to tell you the truth I *do* go for such constructors and it doesn't bother me (as long as there are easier ways of building or getting the object). I see the constructor as the last resort for making an object (first resorts being: injection, factories and builders). There are various techniques for making this more palatable. For example you can move many of the details to an assoc. array and leave only the "big settings" as individual arguments. Also as you evolve the class sometimes you notice you can use a chunk of the code in another place, so you may factor it our. For ex. ImageRenderer. And then instead of 5-6 of those settings (for ex. $driver, $enableCache, $optimize, $scaler, ...), you pass one ImageRenderer, which contains those 5-6 settings. Etc.
Yes, Docker tries to persuade you to have one container per process - and it's probably best to stick to that if possible as all docker tooling expects that. However you could obviously use supervisor as that one process and then have it running a number of processes (e.g. Apache, Cron etc) -but it will become harder to scale up your application once you do this - What if you need to have 10 instances of the application running - should there really be 10 cron jobs that run at 6am? So you're probably best having a 'cron' container which you can restrict to there only being 1 instance. 
Eh. Both are fine.
&gt; I don't really get the bad rep over goto. Memes rule the world. Once you get a meme going, logic and facts become irrelevant.
Nah. The post is OK. Also it's currently at +11.
One process per container is the standard. I've not had to do cronjobs within a Docker container yet. Like /u/TheGingerDog said the 'proper' way would be to have a separate cron container. Depending on what you do in the cronjob this could just work with a shared docker volume for file system operations. For more complicated things you'd need to go the route of remote commands. 
Sometimes you just need to wait it out. Especially if you post it in the middle of the night U.S. time, once they all wake up and do some morning Redditing the votes can sway pretty quickly.
Looks handy, thx :) Perhaps having Hassers/Issers would also be nice. You can check [PropertyAccessor](http://symfony.com/doc/current/components/property_access.html) component from Symfony for ideas. class Person { private $author = true; private $children = []; } (new Person)-&gt;isAuthor(); // true (new Person)-&gt;hasChildren(); // false 
Just use a break. 
The name of the book is *Modernize Your Legacy PHP Application* **Get your code under control in a series of small, specific steps** and the guy who wrote it knows more about coding strategies and patterns than I do, so I'll defer to his decision of the difference between Refactoring and Restructuring. 
https://github.com/vlucas/phpdotenv
Yes, that last one I've already been doing lately in other projects: factoring things out, bundling configuration into a separate class, which can be used by other classes. For the array approach.. I'm scared of this. Because you're not enforcing any parameters to be set, so the only thing you can do is check for keys at runtime, and throw exceptions. Is this right or am I missing something?
One of the software teams at my work recently switched from using Vagrant to Docker and said it was faster for them (they use Macs). On Windows and Mac, Docker containers run in a virtualized environment. On Linux our DevOps guy told me it runs natively (no virtual environment), so for production Docker is extremely fast. The list of companies that use Docker or are trying it out is a whos-who of the Fortune 500. Everything at Google runs in a container which ultimately spawned the software Kubernetes that Google uses for managing containers. ##Sources: https://www.infoworld.com/article/2608021/paas/google-plunges-in-to-docker-management.html https://www.informationweek.com/cloud/infrastructure-as-a-service/google-docker-does-containers-right/d/d-id/1319146 https://www.contino.io/insights/whos-using-docker https://www.docker.com/customers https://en.wikipedia.org/wiki/Kubernetes ## All the major cloud computing providers support Docker containers: Amazon - https://aws.amazon.com/getting-started/tutorials/deploy-docker-containers/ Microsoft - https://docs.microsoft.com/en-us/azure/container-service/dcos-swarm/container-service-deployment Google - https://cloud.google.com/compute/docs/instance-groups/deploying-docker-containers 
[removed]
&gt; my CRM had specific requirements, like post pre-moderation that requires multiple moderators review for a post to become public Why would a CRM have such a feature? 
They said CRM not CMS
The way I've done it with a Laravel scheduler was an infinite bash while loop in its own container that runs the scheduler in the background and sleeps for 60 seconds. Laravel provides a fluid scheduler API so you only have one cron running every minute and the scheduler looks to see what needs to run. You can run a cron with docker, but I personally haven't had to do this yet. I am creating a guide with a book/video that I am editing right now that goes into stuff like this and hope to release in the next month or two. Right now the landing page is on Leanpub (not released), but will be on my own site in the end - https://leanpub.com/docker-for-php-developers
article has moved: https://johnothecoder.uk/tutorials/setting-up-private-packagist-bitbucket-or-github/ article also has no screenshots as a visual guide to where the different settings are etc. p.s. no mention of bit bucket's deployment keys, unless anyone who has used private packagist knows if there's a need for write access via ssh.
Ignore the weeb hate. It's everywhere. Probably just down voted because "they knew that" or something.
&gt; I don't really get the bad rep over goto. Have you ever used goto in a language which doesn't have automatic memory management through garbage collection? In PHP, and other memory managed languages, using a goto is pretty safe to do. In C, and other languages that you have to free memory by hand, using a goto makes your code quite vulnerable to a class of bug: int foo() { char *bar; // lines of code here // lines of code here // lines of code here // lines of code here // lines of code here // lines of code here // memory allocation here // lines of code here // lines of code here // lines of code here // lines of code here if (x == NULL) { goto end; } // lines of code here // lines of code here // lines of code here // free memory here // lines of code here // lines of code here // lines of code here // lines of code here end: } In this code, some memory is allocated, and the place in the code where the memory is freed, can, under some circumstances, be skipped by the goto. This kind of bug can either be introduced by the person adding the goto, if they don't notice the free below it, or by the person adding the free, if they don't notice the goto above it. It's because of that, in languages that you need to manually free memory, that avoiding goto where possible is worth doing, as it avoid this class of bug. 
&gt; Because you're not enforcing any parameters to be set, so the only thing you can do is check for keys at runtime, and throw exceptions. Is this right or am I missing something? Yup, it's only checked at runtime, but don't forget this is in the context of "constructors are a low-level detail, if you plan to construct the object manually a lot, use a factory/builder which is type-safe". A Builder object is a form of optimization for *your* time: it optimizes the effort to construct a complex object without reading documentation at every step, and without making lots of errors that you'll find out at runtime only. But like any optimization, it's only worth it if the thing you optimize is a "hot spot". If you'll be configuring this object once (or 2-3 times) per project, you might as well not bother, because it won't be wasting a lot of your time. You can have the array now, and later if you find yourself "jesus I type this more often than I thought" then you can seamlessly add a Builder with zero backwards compatibility breaks (the builder will just produce the array and pass it to the constructor).
If I have a cron container, would that container not also need its own PHP installation if I have CLI php scripts? 
Thanks for all the input today! Learned a lot!
Ironically, I'd have used manual memory/resource management as the primary justification for goto to exist at all in a structured programming language (unwinding allocations upon failure).
There's a nice little app called [Supercronic](https://github.com/aptible/supercronic) that is designed to solve the cron problem. I run it in a separate mini-container along with my app, sharing volumes between containers if/when required. One of the main benefits is that the job output is logged to `stdout` / `stderr`, so it remains compatible with `docker logs` and Docker's various logging drivers. 
Why on earth are you posting this here? I'm sure only 10 people will randomly click on it and actually speak "hindi"
[removed]
early returns can cause this, so do breaks, continues and even ifs. goto is not the cause of the bad behavior. 
Man, when I go home at the end of the day, the *last* thing I want to do with my free time is sit back down at a computer and write mode code.
I'm new to Phalcon and working through multi-model forms. I'm interested in your formbuilder and how it works as well as how you integrated the AJAX POSTing in your Phalcon projects. Any help would be appreciated greatly!
This is not constructive. If you have an issue with what someone is posting that goes beyond our posting guidelines, please send a modmail.
Meh. Having just had to use a loop label in go vs. using a multi-level break from PHP, I prefer the PHP method.
I've never needed a `break 3`, but have certainly done a `break 2` more than once.
I felt a disturbance in the force and came to find this. 1996 me would be shocked and appalled, maybe even a little terrified.
Is anyone actually using this permissions based setup in a real application? I would think it would make it extra hard to look through the database and know what was going on.
Maybe you should delete your entire account.
Interesting read, I agree with the author's points, although sometimes its indeed a tough trade-off between code quality and meeting the deadline. I for myself have a bottom-line of how much quality can be sacrificed in order to meet the deadline, before I . In general, I dont have a problem finding the balance, but in rare cases when the manager is completely ignorant of the merit of code quality, holding meeting deadline as a bible, I quit. In the business world it is necessary to meet deadlines, but if you try to meet deadline blatantly, it will eventually come to a point that, new deadlines can no longer be met. In the very end, the project cannot go any further without a complete rewrite. There may be another reason why in the author's case, good developers turn out to write terrible code. The code has obviously be written and maintained over the course of years, so a good chance that the original development team consisted of programmers quite different from the current developers team. Perhaps, the terrible codebase was initially written by the ex-developers with poor skills. Then the new and competent developers came in, just to accept this messy coding style and move on, instead of gradually refactoring the bad code. If I inherit a codebase with full of spaghetti code, I would like to refactor it but reality is, there may not be enough time to do this, or the code has reached a point of no return. 
Thanks for sharing, Oliver Marv - I've moved my blog as I wanted to do some other things, and WordPress.com became a bit restrictive I've not done screenshots and stuff because I didn't need them personally, it was more in the hopes that someone who's going "erm, what? Why's it not working" could just get a really quick flavour for what it might be that's wrong with their setup - as the article's aimed at architect/lead developer types I didn't think the screenshots would add much value I'll be perfectly honest, BitBucket's deployment keys and various other bits became more confusing and frustrating (as well as I don't think being featured on GitHub? But I could be wrong) than anything else - I have write access on my SSH key, but production servers I generally just give read access - Packagist itself just has just read access as well I appreciate you taking the time to read the post and post a comment though :)
Which is much more complex than a CMS, so my affirmation still stands.
Yes - it could be the same image that you use in your PHP application - it's just it would only run 'cron' and not also Apache/Nginx/whatever. (When launching a docker container you can tell it what command it should be running to override the default)
He wants to post his content from time to time, and I think that's fine as long as it's not exceedingly frequent (as we've seen from others, but not him, he posts in moderation). But he's forced to add this pointless filler to meet your posting guidelines. That's counter-productive and results in more noise in the channel, so maybe the rules should be updated. Is this constructive? I think it is.
Composer doesn't violate the spec. You can have more or less stable versions in the 0.x.x range just as with 1+. The 0.x.x range is for initial development, as the spec notes, "the API should not be considered stable" is for the entire project at this point. While if you have 2.0.0-alpha2 the API is not stable for this particular branch. It's recommended to still have 0.x.x-alpha and 0.x.x-beta and 0.x.x release versions and then Composer will sort them accordingly.
I found this: &gt; [There are races on refcount for strings, introduced with NG ... 7.2 interns strings in ZTS, interned strings ignore refcount, problem solved.](https://twitter.com/krakjoe/status/887753135820853251) I'm not expert in php internals field. How can this issue affect in other scenarios?
PHP uses non-atomic refcounting, so sharing refcounted structures across threads causes race conditions. As such, any structures shared between threads must be interned or immutable, in which case they don't use refcounting. This is how strings and arrays stored in opcache SHM work. However, ZTS mode prior to PHP 7.2 did not support (non-opcached) interned strings. As such, certain permanent strings were shared across threads, even though they were refcounted. In PHP 7.2 interned strings are supported in ZTS and these permanent strings will be interned.
Depending on the project structure you could set up Laravel in a subfolder. For example if you put Laravel in `/feature/` then requests for `/feature/whatever` will go through Laravel but other requests (like `/profile.php` or whatever) will go to the legacy app.
This may make your life easier: https://github.com/pyrello/sox-php
&gt; he's forced to add this pointless filler I am "forced" to do nothing, Tanks; I appreciate your kind concern for the well-being of this sub-reddit, but I think you are overwrought here. I found the article interesting; I shared it here directly; and I blogged it in summary at &lt;http://paul-m-jones.com/archives/6654&gt;. Now, if *you* find it uninteresting, well, that's your prerogative. 
Ye I was thinking about that. But the problem is that the company has like 20 different projects. And they want to eventually roll the dashboard, that I will be making, out on all of them. Your solution will work wonderfully on one project but it will not scale well because a programmer will be forced to change all of the different dashboard subfolders.
OK, another option would be to "replace" the whole project with Laravel and have the legacy code as a fallback. In other words, all requests go through Laravel first - if it's something your L code can handle then do it. Have some generic catch-all route in L that does a `require` on your legacy script. 
That will be a ton of work. The project is a decade old. And I don't see how that will solve my embedding issue.
No online demo?
JavaScript has labelled `break`/`continue`: some_loop: while (true) { while (condition()) { if (condition2()) { break some_loop; } } /* … */ }
goto only takes it to the next level.
If you're not logged in but you want to show any model that relies on ```UserTimezone``` then it will break.
Great post and great follow up comments from the community! Thank you all for this. One question though, I noticed that in you repo example, in the docker compose file, you open the php container port 9000. Why do you need to do that?
It's also possible that good devs may simply not care. Projects they work on in their free time are no doubt projects they care about but projects you're being paid to work on? You don't own the code and and you're liable to get in trouble the moment you think you do s it's best not to care that much. And if no one on the dev team cares... then there you go.
Does that not ram your CPU up to 100%?
No, sleep doesn't use CPU and is optimal in this case because it runs in the foreground. In my case, the command sleeps for 60 seconds and then kicks off a scheduler process in the background (which will use CPU). The scheduler process exits when complete, but the bash loop with sleep runs infinitely in the foreground keeping the container running. In practice, my containers are replaced almost daily through deployments too.
All the more reason to have one?
I’ve used this before. It’s not elegant and probably means you SHOULD refactor but sometimes in the real world you just have to get shit done quickly. 
PHP doesn't let you use goto across different scopes or contexts.
Everyone tries to dive right in putting everything in Docker right away, conclude it's a pain in the ass and want to move on, I did but I kept coming back. Wade into it slow. Start with things like MySQL or MariaDB and maybe Redis, then start adding on bit by bit. Figure out what you need and what works. --- &gt; To shut down docker, just hit Ctrl+C in the window running it. If you ever get it a situation where "docker-compose up" isn't working because ports are already in-use (see Gotcha about Mac's above), then that might mean Compose wasn't shut down properly. Navigate to the last project you had running and do a You could just run Docker Compose as a daemon `docker-compose up -d`, so you can property shut it down with `docker-compose stop`. Also, `docker-compose down` deletes the containers when it's done, so if you don't want them deleted, use stop.
In PHP &lt;=5.3 you could even use a variable like `break $n`.
&gt; Do I have a separate Docker container just to run cron? I'd do separate container. We, at work, use separate servers to run cron jobs so they don't interfere with production sites. Separate server -&gt; separate container. As other have said, one process per container is a standard, but not a must. A very common combination is nginx/fpm, under supervisor. Outside of that configuration, I hadn't found a real reason to deviate from the one-per standard.
no demo. no screeshots. no preview. how do I know what I am getting myself into before getting myself into it?
Good question! The answer is you don't. Xdebug uses port 9000, so that was my attempt at making sure Xdebug would work with an editor running on the local machine. I just never went back and removed it from the demo. For Xdebug/Docker info there's this long thread with answers near the bottom: https://forums.docker.com/t/solved-how-to-setup-xdebug-and-phpstorm/13641/23
FYI there's also `lvh.me` which maps to `127.0.0.1`, so that can be used instead of `127.0.0.1.xip.io`
A nice solution for this is a `phpmyadmin` container, or include https://www.adminer.org/ or something similar. Since that will run inside the container, and in those cases you'd just point to `db` as the host (the service name) due to docker networking. Still though, the allowed IPs should be locked down as much as possible to prevent attacks. It's not a fully alternative to just locking it down to only CLI/SSH, because you're pretty much just "moving" the access point. It does mean that it'll be less vulnerable to crawlers just attempting to connect because it's over HTTP rather than MySQL's TCP.
&gt; This is like 32 lines. Let's not be javascript and have libraries this small. Better to just have a tutorial showing people how to implement this sort of thing. Why would I want to implement it every time?
We have like the same "old shit" here on our company :) We are using an old framework (developed back with php4 or smt) which has a huge code base. We wanted to use a new api structure so we decided to use aura router and replace the old one. But the impact would be too high to replace just everything with it. So what we did was: - Located the top most entry point into the api (e.g. request path /app/api) - We build in a switch to this deciding which endpoint will get called, and if its a new or old endpoint - Go with ne new endpoint structure and routing This way we only had to make sure every "old" request is still working and every new one will just be parsed by the new extension. --- Another way would be to kind of try and "reroute" your dashboard using nginx/apache (whatever you are using). So you could add a specific location where your code has n simple entry point.
You could just use Caddy to replace both Traefik and NGINX for most cases, unless you specifically need the service discovery from Traefik.
Sorry, yes that could have been clearer, I was speaking more generally about why `goto` is traditionally considered a bad practice in the first paragraph.
You can use a combination of integrated web server and a web scraper ( BroserKit or goutte ) to integrate into your test cases. this way you can scrape the website without the heavy selenium and assert some things exist, forms can be submitted, and so on ... In addition, you can utilize http://codeception.com/, it supports several kinds of testing in a unified interface and it is easy to use. 
Hi MaxGhost! Never heard of this, thank you!
Actually `phpmyadmin` is provided on `local` environment. I didn't enable it on others environments for... security reason. But true, the allowed IPs should be locked down as much possible!
Indeed, Caddy is great tool! Though, the main reason I use Traefik is to allow having many environments on one host, where its discovery service helps a lot!
Hello SQL injection, I understand that this article is for rookies, but cmon guys. Edit: this example is bad in so many ways SQL injection, code-html structure, error handling.
Yeah, it was confusing me because in my experience when i open port 9000 like that, thats when xdebug wont work because phpstorm complains that the port is already being used. To my experience, as far as xDebug is concerned, we dont need to open port 9000. XDebug will just send info to port 9000 on our host and phpstorm will listen to it. I don't know how phpstorm then sends info about stepping, etc, back to xDebug but it just works. I can only guess that it can do it because the communication channel is already open by then... Tkx for replying, i was wandering if there would be some other/better way of setting it up. :)
[WHAT NINE THOUSAND!?](https://www.youtube.com/watch?v=CW8h_GfQOVA)
There are different types of tests, [here](https://stackoverflow.com/questions/22414134/different-types-of-testing-eg-unit-functional-integration-etc-document) are a few definitions. What is important to know about unit testing is that your code needs to be actually testable. In your test you would instantiate a controller, pass different data to it and expect certain output. Since you're only testing the controller or a public function within the controller without going through the entire system (request handling, router, kernel, etc. ) this is called a unit test. Now a controller usually calls functions that perform database queries, and these can become very expensive when you have many tests. This is where mocking comes in. Mocking is basically using objects within this controller, say a database connection, that acts as if it does a connection, accepts the required parameters, returns the expected result, but doesn't actually perform a connection. But how do you make the controller use this "fake" object instead you ask? That's called dependency injection. Which is a subject on its own. A popular php testing framework to do such tasks is phpunit. Hope this points you to the right direction. 
I smelled CSRF and SQL injection vulnerabilities even before I clicked the link. As /u/comiljou said, this article is for rookies, but security has to come from the rookie stage; it's not a feature you add later.
Lets not forget the delete on GET. It just takes one web-crawler, pre-fetch browser plugin or some other automatic link following code to delete your entire database.
To be honest, in such tutorials I don't expect any code structure/error handling quality. But SQL Injection? Seriously? It's 2017 man! I'm tempted to "have a look" at all of the authors live projects. 
Don't follow this tutorial
please do that, I'm interested in your script but first I want to see a demo
good read for a very introductory developer...
It depends on how your controllers are setup, and how fat they are. Modern frameworks use controllers that can be instantiated and have their actions called with request objects without any dependency on the rest of the framework. A thin controller won't do much more than extract request variables, pass them into a service method and form a response from whatever the service method returns. The following code is an example of how this can be handled in a test where we mock the service. $service = $this-&gt;prophesize(DoThingsService::class); $service-&gt;doTheThing()-&gt;shouldBeCalled()-&gt;willReturn('foo'); $controller = new MyController($service-&gt;reveal()); $response = $controller-&gt;doTheThingAction(new Request()); $this-&gt;assertInstanceOf(Response::class, $response); Personally, I don't bother testing controllers as they do so little. I find more value in acceptance testing with codeception where you also test the routing and parameter binding at the same time.
Isn't it delete on AJAX call actually? 
I'm indeed aware of mocking and DI, unfortunately our framework isn't set up to handle this.. So I guess that's where we're stuck for now.. Luckily I'm moving to Laravel soon, so it should be easier than. Thanks for the input!
I have the feeling our current setup's controllers are way too fat; with too much tight coupling to underlying parts of the framework, making it way too time-consuming to write proper tests.. Thanks for the input though!
Thank you! I might look into Codeception indeed!
Kind of, the AJAX call is a GET request to a delete endpoint with the ID in the querystring. I had assumed that the URL was in the row for each element, and the Javascript was adding a confirmation box on top of that - but it is not. I'm not sure if that is better or not, as a crap spider won't delete all your content but the page doesn't work with javascript disabled which can be an accessibility issue.
The title says "How to use VUE JS with Laravel 5 Framework". After reading, I still don't know how to use VUE JS with Laravel 5 Framework.
[Never do this](https://github.com/AdamCox9/nickelbot/blob/8b5a5e7fb6f5f99e370d044d8b8bf966fa9398fb/adapters/okcoin/OKCoin/Rpc.php#L71-L72) You're basically throwing away the certificate authentication of TLS if you do this. What you're doing is saying "I don't care *who* I talk to, I just want to talk TLS with them". While this would stop a passive attacker, it'll open you up to MITM attacks. [You seem to be inconsistent with doing this too.](https://github.com/AdamCox9/nickelbot/search?utf8=%E2%9C%93&amp;q=CURLOPT_SSL_VERIFYPEER&amp;type=). Consider using composer to bring in something like guzzle so you don't have to make a few hundred curl requests.
far too complicated, it can be simplified much more in just 1 class
Given that non-ajax confirmation is a pain in the ass, I assume JS is a good tradeoff. There are many issues in this shitty article but I don't think that the actual confirmation code is that bad. 
If you have some control over the server (and all the projects are on the same server), instead of creating an actual `/feature` directory, you could create one central directory with the new project and use [a directory alias](https://httpd.apache.org/docs/2.4/mod/mod_alias.html#alias). That way, only one directory needs to be updated.
For people who may be confused about "ref counting": http://php.net/manual/en/features.gc.refcounting-basics.php Related: How PHP stores values (zvals): http://php.net/manual/en/internals2.variables.intro.php Further related resources: * http://www.phpinternalsbook.com * https://nikic.github.io/2015/05/05/Internal-value-representation-in-PHP-7-part-1.html
It does not have to be nested loop. You can use switch statement inside a loop for instance.
These types of test are to coupled to the implementation and fragile. In the worst case you can break your application but all your unit tests are passing. For example when you change the return type of your service from an object to an array and you forget to change the behaviour of your controller function from $service-&gt;doTheThing-&gt;getFoo() to $service-&gt;doTheThing()['foo'] your tests will pass until you adapt the behaviour of the service mock to the real service in the controller test. But your application will break. I've run into this by myself and my learning was to only test the behaviour, not the implementation of a function or class.
That is unfortunately not the case, we have multiple servers.
This may be a silly question... but what does it *do*?
Looks like a unified interface for various crypto exchanges ala XChange, combined with some methods/scripts for manipulating the data.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Even that might not be an issue if you setup a [reverse proxy](https://httpd.apache.org/docs/2.4/howto/reverse_proxy.html). You could host your dashboard on its own (sub)domain on one server and then configure a proxy rule for each of the projects.
I would hope that if the mock is returning the wrong type of data, that the test would fail elsewhere when attempting to use that return value; the controller in this sample would use the return value of the service to assemble the response object, which would probably fatal error if it received the wrong type of data, or assertions on the response would not contain the correct content - if not then you have to question why the method is returning anything in first place. This seems to me an issue with mocking in general, the moment you mock any object at all you run the risk of having the implementation of that object change while your mock objects do not. I would love to know how you would test just the behaviour of my sample action. I would mock the service to return a mock object with a known 'getFoo' return value, I would then call the method and assert that $response-&gt;getContent matches that known getFoo value. How could I write better tests that ensure the method is working as expected? public function doTheThingAction() { $thing = $this-&gt;service-&gt;doTheThing(); return new Response($thing-&gt;getFoo()); }
Without more information (brand, model, etc) it's impossible to tell you either way. You might also want to ask this over in r/PHPhelp.
Ask the vendor ?
[Laravel News Post](https://laravel-news.com/laravel-5-5) and [Video](https://www.youtube.com/watch?v=I8chAg9RxWc) [Laracasts' What's New in Laravel 5.5](https://laracasts.com/series/whats-new-in-laravel-5-5/) [Documentation](https://laravel.com/docs/5.5) [Changelog](https://github.com/laravel/framework/blob/5.5/CHANGELOG-5.5.md) And for /u/LtAramaki, the `tap()` helper [documentation](https://laravel.com/docs/5.5/helpers#method-tap).
Even though it is not released, I recommend checking out cypress.io, https://www.cypress.io/ I guess it is somewhere in the middle of scraping and Selenium, but far more easier than selenium in terms of setting up and writing tests etc.
&gt; Laravel's versioning scheme maintains the following convention: `paradigm.minor.patch`. Minor framework releases are released every six months (January and July), while patch releases may be released as often as every week. Patch releases should never contain breaking changes. Read that again, and ponder it.
I was wondering about the wording there, previously both Laravel and /u/taylorcodes in tweets and elsewhere have referred to these as major versions, which makes far more sense, given they have always included breaking changes. `paradigm.major.minor` would seem to be clearer so that while it doesn't match the structure of SemVer, the documentation that's explaining how it differs at least matches the terminology used by SemVer: &gt;MAJOR version when you make incompatible API changes, &gt;MINOR version when you add functionality in a backwards-compatible manner, and &gt;PATCH version when you make backwards-compatible bug fixes.
1. /r/phphelp 2. [Relative and absolute paths, in the file system and on the web server](https://phpdelusions.net/articles/paths)
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Is that a custom framework, or a public one? Mainly asking if there’s one to avoid…
This [article](https://www.typemock.com/aspnet_unit_testing_page/2009/9/11/unit-testing-aspnet-mvc-applications-with-typemocks-aaa-synt.html) helped me a bit back in the day I started working with MVC before getting my hands dirty.
Yeah, I think I will change that wording to `paradigm.major.minor`. Thanks.
Plot twist, OP is just a bad dev and has yet to figure out how to prevent SQL injection. Also, 7 adverts aren't enough you need yo have at least a gazillion! Edit: I was right, OP is bad dev his github is filled with similarly vulnerable code : https://github.com/savanihd?tab=repositories
document-root is the root-address of the current document. The internal address and the external address are not the same thing though. 'mydomain.com/locationofscript/example' usually translates to something like '/public_html/mydomain/locationofscript/example' internally. When working with fopen and other file-system based functions, you will always have to use the internal address. 
thanks. Unfortunately, there's no opportunity to edit the post. The website has the right version.
&gt; ...internship...decade old project...legacy code... Does your boss code? It doesn't sound like he does. You're setting yourself up to fail here. A better way would be to start introducing best practices into the current code base. First step is dump it all in git. Then look at the HTTP response and request classes, then getting a router in there. You may then want to get to the point where you could move it over wholesale to Laravel. Here are a few links to get you started: * https://www.phproundtable.com/episode/how-to-convert-a-legacy-codebase-to-modern-php * http://tech.yappa.be/symfony-components-in-a-legacy-php-application * https://github.com/mattstauffer/Torch * https://www.google.co.uk/search?q=refactoring+legacy+code+php And I'd strongly recommend you read [Fabien Potencier's guide on creating your own framework using Symfony's components](http://symfony.com/doc/current/create_framework/index.html). Good luck! This would be a difficult project for a seasoned developer. I think as an intern you may be diving in at the deep end. 
will you stop spaming?
I think the point of requiring php7 is to move php forward so more people start using php7. This is similar to how the php community lobbied to get hosts to stop supporting php4.
Although a quick browse through the release notes doesn't immediately reveal anything that necessitates moving up from 5.6, I can hazard a guess. 5.5 is not only a major release, which lets the framework break compatibility, but also an LTS, meaning it needs to be supported for 2 years. Rebasing 5.5 to PHP 7 means that anyone moving up from the previous LTS (5.1) is in for a major performance upgrade. It also generally lets all the adopters play with all of PHP 7's new features - support for argument and return type declaration being my personal favorite - without worrying about compatibility issues with the framework.
PHP 7 has been available for 18 months now. It's time to move forward. We also use anonymous classes and a few other features of 7.0 internally. Horizon requires PHP 7.1 for async process signals.
FFFFFFFFFFFFFFUUUUUUUUUUUUUUUUUUUUU
A shame. It's just delaying the inevitable. The root namespace is obnoxiously full.
PHP 5.6 is already end-of-lifed. Why would you even provide a tool that would encourage people to start projects on EOL versions? PHP 7 itself only has active support itself until December of this year! I'm almost surprised L5.5 didn't jump straight to PHP 7.1, but I can appreciate the balancing act these decisions represent.
I've deleted the previous link since there was a misprint in the heading. Do you think a php digest link published within the php community is spam? 
http://behat.org/en/latest/
Makes much sense, because it's an LTS release of 2 years. PHP core developers won't support PHP 5.6 after Dec 2018. Why should Laravel?
zfort.com was trying to post a gist of /r/php back to r/php for a long time already. every time without any luck. so I am wondering will you ever stop
well, I'm really sorry you didn't like the digest, all the luck to you.
Thanks! I'll look into that!
&gt; PHP 5.6 is already end-of-lifed. This simply isn't true. 5.5 is EOL. 5.6 is EOL on December 31, 2018, still 16 months away. 7.0 will be EOL before 5.6. http://php.net/supported-versions.php
Custom, but they're moving to Laravel, so that's that.
it's not a digest, it's a blatant blogspam
I was glad to see Michael Feathers gets it ;) https://twitter.com/mfeathers/status/869889514151587840 &lt;3
What do you think about Yii2? 
This has nothing to do with being useless at PHP, and is more about your (apparent) ignorance of computers in general. You need to take a step back and learn some basics before trying to get into web development. Basic file paths and directory structure is a pretty important concept to understand.
"no active support". I don't want to be starting projects on a platform that has no active support. That I might get some security patches isn't really where I'd want to be starting a new project. If you've got old laravel projects you're trying to upgrade for new features, you'd probably want to upgrade the php version as well (again, because there's no substantive support, but presumably you'll be supporting/using what project you're working on).
Actually Codeception can run behat stories described with gherkin
[removed]
Much better; at least "major" is more indicative of where breaks will occur. Might need a fourth number to indicate "patch" releases.
I love both the new routing methods. Between `Route::resource`, `Route::view`, and `Route::redirect` my routes file is gonna look nice as.
You should commit your .env.example file
But at least you know that the reason for its popularity: "The advantage of this framework is that their is absence of pedigree in it."
I'd suggest break and continue have less ways of going wrong rather than goto. People are pretty freaking creative when it comes to "clever" code.
Seeing as Laravel has never had a patch release, that is, Laravel includes both backwards compatible features and bug fixes in minor releases, why would it be necessary to have a fourth number that always remained at 0?
I would probably don't unit-test this function at all. If the service throws an exception and the controller then returns a 404 response, i would test that with a service-mock because this is behaviour of the controller. But this function does always the same. I think your code integrates a service component (business-logic) into an MVC Controller (presentation). Maybe there is time for an integration test to verify that the presentation layer uses the business-logic correctly? Probably it depends on personal preference. I don't want to see my tests failing after refactoring, because i've not adjusted my mocks to the new implementation. You can avoid that somehow by writing your own mocks wich are implementing an public interface and therefore would be refactored by your ide automatically. In this context, this is an interesting read: https://testing.googleblog.com/2013/05/testing-on-toilet-dont-overuse-mocks.html
[removed]
Models (and APIs) have a **machine interface**, while site View/Controllers together define a **user interface**. So it's no surprise then that models can be tested by **machines**, but your Views/Controllers are best tested by **users**. Not everything can be automated. Some things take good old-fashioned QA teams following test scripts (yes, people can run scripts too). What other people propose here, like Selenium etc. (and I can throw in PhantomCSS) - those are useful for regression testing sometimes, but tests written those tools are *extremely brittle*, and often only create the *false appearance of testing*. For example: - With PhantomCSS you can make sure your styles don't change accidentally. But change your navigation border or padding somewhere (intentionally) = *all tests broken*, start over. - With Selenium, tests are often written like "check if there's a div with id `foobar`". No user will actually see "a div with id `foobar`" - they see a user interface. And no automated test sees your user interface, it only sees a soup of markup in your request/response content. And again: decide (for a good reason) to change id `foobar` to `barfoo` = *all tests broken*, start over. Automation of UI testing only makes sense if your UI is *extremely stable*, changes to it are *extremely rare and conservative*, and you don't have QA team (or the time to allocate for other people in your company to do QA) to test things properly. But it's sub-optimal.
[removed]
PHP 5.6 has ended development now and is on end of life until the end of next year. It doesn't make any sense what so ever to start a new project in anything less than PHP7, I really don't see your point.
Thanks for the insight. I stated in my original comment that I don't test controllers but use codeception to test the whole stack at once. At that level I want to ensure that the routing and request object construction is also being performed correctly from the raw request.
Actually did a lol. What a shit spammy article 
The question is very poorly constructed with very little information. If you're talking about programming RFID cards used in door locksets, then yes there are libraries out there for this. Do I think this sounds like a job for PHP? No. Take a look at something like Python, it's perfect for this use case where it needs to interact with external hardware.
Ah, so.
You couldn't even be bothered to put audio on your video, take your spam elsewhere please 
Yeah in my younger days I used to come home from work and program way late into the night, get up and repeat. Now as I hit my 30s there is nothing worse I can think of than sitting in front of a computer when I get home, this includes playing games which I used to love.
Eloquent will only update the data that has changed, if your changing everything than you'll need to ensure that your instances within the worker are updated prior to saving. It's not Eloquent's place to handle race conditions between your workers.
There's no way around it with the currently popular ORMs like Eloquent and Doctrine. Unfortunately those ORMs are built upon a lie: that accessing remote, concurrently updated data is the same as local, serially updated data. It's not. Just to be clear: - The concept of data mapping from SQL to OOP is sound itself. - The concept of updating local objects from multiple processes and "flushing" them to a remote storage, isn't. What you can do as a workaround is: start a serializable transaction on the connection Eloquent uses before every series of operations, then commit at the end, and manually flush all model caches. From quick Googling it seems Eloquent's API for flushing cache is quite convoluted... 
&gt; It's not Eloquent's place to handle race conditions between your workers. Try to explain why it's OK for Eloquent to allow race conditions between instances of itself. Your application code is in an even less suitable position to resolve these race conditions.
Thanks for the suggestion. Unfortunately his code is just a (broken) wrapper for what I'm already doing.
Burnout is one reason. When people burnout their code quality reduces. They lose passion and interest in the project. Usually when this happens the code base has turned into a huge mess that everyone on the team hates working on. So they patch things together to get it working for the client. The client doesn't care either. If the project works as expected nobody is going to complain about messy code until a problem arises. As a sidenote Google, Facebook etc are notorious for burning programmers out. They churn and burn them so they don't care. But for smaller companies where it's a small development team working through a burnout sucks. Messy code is a problem for development and maintenance. We can all agree with that. But, messy code doesn't always equal poor, inefficient or vulnerable code. Not always anyway. I've seen code with for loops nested into oblivion, dependency hell, looping MySQL queries on tables that are not indexed, failed attempts at OOP, incorrect use of design patterns etc. That stuff scares me. But, in production their app is working fine and generating revenue. I once worked with a client some years back. He ran a large bitcoin gambling site. I had to implement some new features. Price was right, I could do the job, so off I went. He sent me over the codebase and it was a horrendous mess. Code repetition everywhere. This was the guy who was looping MySQL queries on non indexed tables. They had a cache, so they probably didn't notice the slow queries and the socket server was a different codebase that I didn't have access to. It would have been fun to see that. I had to increase the development time from my initial quote. I'm a neat freak, and clean code makes me feel happy. Working with messy code doesn't. It was so hard to add the features because I had to go against the grain and contribute to the mess. I did it. Afterwards, I suggested he has his codebase rewritten, or at least cleaned up a little. I proceeded to tell him what was wrong and how I could guarantee an increase in performance. He laughed and said "It works. Why fix what isn't broken that will cost me more money?". And that was that. The site is still up and running today. I can see his point though. To the client it must feel like they're taking the car in for an oil change but the mechanic is insisting on replacing all stock parts with top of the line brands. Truth is, nobody cares except for us passionate programmers. We can judge a persons skill level based on their code quality. Most clients can't. They judge a persons skill level by how fast they can get something done for the cheapest price that works to spec. There's plenty of shoddy coders to fill that market. They always undercut me on freelance sites. But seriously, people should give up inventing frameworks. Many good ones already exist (Phalcon is my fav, but Slim3 most of the time for small scale stuff). Steep learning curve for lots of rewards vs. Invent your own and have a million problems. To be fair, if you can't use/understand existing frameworks forget creating your own. Makes no sense to me why people reinvent the wheel.
There are two common solutions to your problem, optimistic locking and pessimistic locking. Optimistic locking uses systems like version numbers on the record, you have to test the lock while you write to the database and fail if the lock-check fails. EG: You SELECT with a version, and then if the version has changed before you UPDATE the record the the record is invalid and the UPDATE should not be performed. Pessimistic locking performs a lock on the row at the database level. In MySQL this is performed by performing a "SELECT FOR UPDATE" query within a transaction which write locks the row - other SELECT FOR UPDATE queries from other workers will pause until either the original transaction is commit (or rolled back) and then load the latest data. You should be discarding your entity at the end of the transaction, as at that point you have to consider the information stale. I don't know how Eloquent supports these locking patterns, but I find when it comes to stats then abandoning the entity pattern and falling back to regular SQL is advantageous. You can make queries like "UPDATE stats SET field = field + 1;" which performs the stat update server side rather than overwriting a stat with a potentially out of date entity value or use other syntax such as ON DUPLICATE KEY UPDATE that typical ORMs don't support.
No, it's a legitimately useful recap of the interesting happenings in the PHP community in the past couple of weeks. If you don't like it, just ignore it and move on.
If your last two release announcements have to explain why you don't use semver then you may as well use semver. That said I can't wait to try out the new hotness!
1. You can recap it easily in one click right here on Reddit. 2. I will decide myself what to ignore and where to move on, if you please 
Dude, this is Reddit. Do you complain on every single thread for topics you don't care about? You're not alone in the world. Other people care about things that you don't care about.
Thank you for the feedback. I do want to make a single consistent reusable query class that all the exchanges use. I will look into composer/guzzle.
Please stop fucking with my browser's default scroll behaviour.
[removed]
The reasons for bad code quality are numerous and varied. Many simpletons think it's just a question of a lack of skills or a lack of discipline. I guess I would like to thank you for your comment...
Is this meant to look like this? http://imgur.com/a/4mJ7W
[removed]
Thank you :)
Dude, this is Reddit. I do comment anywhere I'd like to. Anyone telling me otherwise just fucks straight off.
Just wanted to thank you for all your work. I started working my first front end job on laravel projects, and oh boy it is a wonderful framework to work with. 
I don't agree with your semver comment.. People considering upgrading need to be informed before they do so. 
Thank you to /u/TaylorCodes for another great release, which no doubt took a lot of blood, swear and tears to finish. 
This submission has been randomly featured in /r/serendipity, a bot-driven subreddit discovery engine. More here: https://www.reddit.com/r/Serendipity/comments/6x1ser/laravel_55_released_xpost_from_rphp/
That's very true. Anyone upgrading a system needs to be aware of changes that could affect their app, and all dependency upgrades should be tested in a non-production environment before roll-out. It's the provider's responsibility to provide a changelog that describes changes and how to handle potential BC breaks. Laravel is pretty great with upgrade guides and release announcements. Adopting semver is a way to assert that a change will introduce a BC break, introduces a non-BC breaking feature, or fixes a bug or security issue. Locking dependency requirements to versions along semver's guidelines make application management easier. If we all follow the same versioning rules then it's way easier to manage our applications. 
Any reason I should switch from Symfony to Laravel?
What's `Route::resource` do? It doesn't appear to be [documented](https://laravel.com/docs/5.5/routing)
It's documented here: https://laravel.com/docs/5.5/controllers#resource-controllers It should also documented in Routing imo 
Isn't that feature really old? https://laravel.com/docs/4.2/controllers#restful-resource-controllers
Does it include everything I need to know about visual debt?
And why I'm not ok with it: - I hate to bind too much my models to my persistence layer or an ORM - I hate to pollute my models with DB queries, especially as they grow bigger - I hate to mix my domain code with DB configuration - More specific to Eloquent: - the lack of metadata makes it awkward to use the ORM with generic solutions like done in ApiPlatform to serialize the data in an efficient and standard way - it's easy to break something or cause some side-effects when you make your core classes inherit a 3KLoC base class from a third-party library It's a nice alternative to Doctrine, but let's not pretend it's an easy or innocent choice either.
Is there a reason you are not using namespaces and autoloading?
There are higher priority tasks.
I fixed the verify host issue and removed the unused adapters/libs.
Not sure if you mean to but you seem to have posted this reply three times You make valid points, but it's not often I find myself needing to write queries, very rarely, actually I don't find I have that issue, personally, with the domain code and DB configuration; though of course there's always going to be some cases in which Eloquent isn't the best solution, of course, I've just not yet found one where I've thought "actually, Eloquent isn't the right solution for this" With regards to the metadata, I can't say I've been disadvantaged by this personally, I've not come across a time when this has caused me any real issues. I think you make valid points, but I just can't agree with you on your point about breaking things and side effects, I've found as long as you extend and don't try to overwrite (which follows SOLID itself) then I'm generally okay. I think from my perspective a lot of the time there are commercial constraints and things which make building anything from scratch unviable in itself and the speed at which Eloquent allows me to rapidly develop maintainable, effective code (and the lack of times I've had any issue) had made it a kind of obvious choice for most things It's a nice alternative to the other ORMs I've used, but I have to be honest and say I do think it's an easy choice. The innocence of it I struggled with when I was (and hindsight is 20/20) I think oversubscribed to SOLID; when I got easy with the breakage of what felt like a core fundamental then I could appreciate it for what it is. As I've said in the post though, it's always going to be something that is going to be hotly debated. And that's fine, I think it's healthy to have conversation (arguments and flame wars less so, haha) Thanks for your reply though - I do enjoy decent conversation
&gt; Patch releases should never contain breaking changes. Perhaps OT, but isn't a any patch or bug fix potentially a 'breaking change' from someone's perspective?
If I'm reading the original post by /u/fajne_zaporizhzhya correctly, calling [`increment()`](https://laravel.com/api/5.4/Illuminate/Database/Query/Builder.html#method_increment) directly on the column would work for writes, and there is only a single model being used, so calling [`fresh()`](https://laravel.com/api/5.4/Illuminate/Database/Eloquent/Model.html#method_fresh) should be all that's required to update the model cleanly. In which case, I wonder if simply using `increment()` for all writes and calling `fresh()` before the worker needs to read the latest data would be a suitable solution. Of course this isn't remotely atomic, and the fresh model could be stale before the data is even read once, in which case the ORM approach probably isn't best, so this depends entirely on what the actual requirements for the workers are and why they need to have an up to date copy of the model. Perhaps if the OP can explain a bit more about what the workers are doing with the data, a better design may present itself.
I would guess yes, if you look at the corners on most elements.
And mental debt?
I haven't seen how they handle major remotely exploitable security vulnerabilities, given that they really haven't had any, but there probably should be a protocol in place for security patching that doesn't involve "ship another minor release because of an emergency".
Great curation and content, but the styling of this site... Yikes. 2005 called, they want their styles back.
Get on the train, son! Choooooo!
That doesn't make any sense. Even when I ran PHP 5.3 on an iSeries (quad core PPC 6 CPU I think, don't remember the exact speed) it was just as fast as or Linux boxes. The only show parts were the shitty DB2 implementation they had at the time, which made it quicker to write RPG programs that returned data than to query it directly. 
This seems a strange way to phrase things. It's ok for Eloquent to allow race conditions because they exist even without Eloquent. Eloquent simply isn't solving a problem in the way you'd like. It seems **quite** unlikely (though admittedly possible) that Taylor sat down and decided to introduce a race condition where non was possible before. Added: "quite" for emphasis.
Docker on Mac's performance is bad mostly because of Apple, not Docker. The xhyve I/O implementation sucks. Docker is working with Apple to help improve it. Docker on Windows works fine, just as fine as OSX and Linux. I've used it under Windows 10 as a daily driver, and have even given full day training courses under with it. I've had less issues with it than the Mac version. Does Docker the company itself kind of suck sometimes? Yeah. They break stuff all the time, release things unfinished, etc. But if you are going to bash it, bash it for the right reasons. 
¯\_(ツ)_/¯ I'd rather not have to work on that environment anymore, but if I have to, I'll make another comparison and write it down.
¯\\\_(ツ)\_/¯
 Hi! This is just a friendly reminder letting you know that you should type the shrug emote with three backslashes to format it correctly: Enter this - ¯\\\\\\\_(ツ)_/¯ And it appears like this - ¯\\\_(ツ)_/¯ --- *^If ^the ^formatting ^is ^broke, ^or ^you ^think ^OP ^got ^the ^shrug ^correct, ^please ^see [^this ^thread](https://www.reddit.com/r/john_yukis_bots/comments/6tr5vq/u_you_dropped_this_a_shrug_fixing_bot/)^.* ***^Commands:*** *^!ignoreme, ^!explain* 
I thought Laravel was so easy to use that you didn't need a certification for it.
Yeah I thought it was taken out at some point for being to magicy
I personally hate to use switch statements. The syntax required isn't to my tastes and usually it means the code I've written should be written in a cleaner way (less branching in the same function, probably some kind of adapter pattern or special-purpose functions are required). Obviously depends on the context and developer preference. I'm basically just gabbing on about nothing at this point...
Oh, now that makes me want to write a macro that will allow the same thing in a PHP environment...
I wonder why Taylor Otwell (creator of Laravel) does not recommend us using PHP storm and instead recommends sublime text...
No
Why? Do you think it will make you more productive?
Seems like a lame excuse for not doing something that is pretty much de facto standard for modern PHP development. 
yes 
Do what makes you happy man. Laravel makes me happy so I use it.
huh? he doesn't recomend any ide. he just uses what he uses.
&gt; This seems a strange way to phrase things. It's OK for Eloquent to allow race conditions because they exist even without Eloquent. The problem is coming straight from Eloquent (and just to be clear, the same happens with other ORMs like Doctrine and Hibernate), because it presents a misleading leaky abstraction to people, and the results don't match the abstraction. The problem doesn't exist without Eloquent, because without Eloquent it's very clear that you're invoking a remote API to run a query at a point in time, and then issuing a set of commands to a remote API in another point in time to update/delete/insert etc. This remote API also offers a series of sophisticated tools like 4 levels of transaction isolation (with dozens of options most PHP devs have never heard of unfortunately), and explicit locking tools like SELECT ... FOR UPDATE, to eliminate race conditions where and when you need them. Eloquent (and so on ORMs) take most of those tools away from you, and tell you "just imagine it's all in your memory: tweak the objects just as you would and you only have to *save*/*flush* them from time to time!" Alas, it doesn't work this way. ORMs own all the race conditions and performance problems they introduce, because they don't provide an adequate abstraction over SQL, but try to paper over it and present it as something it's decidedly not.
&gt; In which case, I wonder if simply using increment() for all writes and calling fresh() before the worker needs to read the latest data would be a suitable solution. Maybe in basic situations. Thing is optimistic version locking helps to prevent basic write skew (although not atomic across rows as you add), but it doesn't do anything to prevent read skew (i.e. the data you write has often been produced by reading other data which is outdated the moment you read it, as you acquire no pessimistic lock over it). &gt; Of course this isn't remotely atomic, and the fresh model could be stale before the data is even read once, in which case the ORM approach probably isn't best I'm struggling to figure it out when is the ORM model best, frankly (as implemented by ActiveRecord and Hibernate spinoffs). The ORM model is best in a situation which never occurs in PHP: single-threaded application needs to persist its state from time to time to disk. That's how ORMs started and they've been since bent to try and address scenarios they were never meant to address. That's a long conversation which can't be had over a series of Reddit comments, but the entire paradigm of object mapping needs to change. SQL requires explicit queries/commands, and result sets are explicitly snapshots in point of time. REST/SOAP/etc. APIs also require explicit queries/commands, and results are explicitly snapshots in point of time. The only odd one out is ORMs with its "saving" and "flushing" behaviors. The remote communication aspect can't be hidden when concurrency and parallelism is involved. It should be explicit.
I don't entirely agree with this, in as much as the purpose of an abstraction is to abstract away from the minutiae of multiple contexts into an API that works the same way every time (or at least tries to). Locking is one of those things that small scale applications never need to worry about, because data isn't being read and written quickly enough. Most people (or rather most applications) care less about locking than the abstractions do. I feel like these abstractions own the locking problem as much as cars own the problem that abrupt stops kill more. That because cars help one to move fast they should also be responsible for how quickly one stops. But they're not. They aren't giving drivers a problem that wasn't there before - they're only making the problem clearer at the high-end. But I'm really tired, so what do I know..?
&gt; I don't entirely agree with this, in as much as the purpose of an abstraction is to abstract away from the minutiae of multiple contexts into an API that works the same way every time (or at least tries to). Well it risks race conditions the same way every time. Goal achieved. &gt; Locking is one of those things that small scale applications never need to worry about, because data isn't being read and written quickly enough. That's a very strange attitude. If an application is so small that it doesn't need concurrent database access, then ORMs should *enforce serial access* by default, and make it impossible to have a race condition, leaving the high-performance options to those with the knowledge to use them properly. Before you say "naah", just search your heart for wisdom and tell me I'm not right. Why ship a product that *by default* risks data corruption, and then *hope* that your app is not used enough for you to run into it? That's just silly. &gt; Most people (or rather most applications) care less about locking than the abstractions do. Most people don't care, because they don't know. Misleading abstractions help them not to care. The fun always comes much later, in production, when strange instances of behavior and invalid data start to crop up here and there. And they're always impossible to reproduce in controlled environments when you follow the steps the user gives. It's so much fun! &gt; I feel like these abstractions own the locking problem as much as cars own the problem that abrupt stops kill more. That's non-sense... cars are actually chock full of mechanisms and designs for ensuring safety in case of abrupt stop, are you kidding: - Seatbelts - Airbags - Brake anti-locking mechanism - Crumple zones - ... ORMs don't even employ the safety mechanisms handed to them *for free* by SQL. **If ORMs wanted to enforce serial access as I described up there, for all the "small apps" you think are the audience, they could very easily do it.** They don't do it. 
Our industry suffers from widespread and toxic ignorance and indifference on the topic, resulting in countless subtle and not so subtle data corruption bugs across components and applications. When I see someone carelessly approve and encourage this ignorance, I do tend to correct them as I do here. As I told you, the solution is absolutely trivial, *especially* if the only goal is addressing the "small applications" as you say. To opt for data-corruption-by-default is illogical.
I believe the idea is to have a way to know if people have at least read the documentation or built an app before adding "Laravel Expert" to their CV. I may be wrong...
Yes I know, sorry if that wasn't clear from my description!
I'm not writing this for you. I get it: you don't care. I don't want that spreading to others who stumble upon here. 
I find Selenium tests useful is cases where there is a complex form in multiple steps, depending on a lot of parts in the system. Automated tests for just these forms sped up our deployment process for certain projects immense. Furthermore, we can be more confident that if the tests are green, critical parts of our UI still work. If IDs our markup was to change and break our tests, it would still be beneficial to have them, and fix them. But those forms are only a small part of the UI, and the problems you raise are rightly so. The difference between machine interfaces and user interface was very well explained, thanks! 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Why is the pricing in euros? I'm an easily confused American and had to look up the euro symbol. Is Taylor trying to buy a right-hand drive Camaro?
This is something I touched on in a [post a while back](https://www.reddit.com/r/laravel/comments/6u9n01/_/dlskrt7) and I messaged /u/taylorcodes again about it recently, though my post was really about the bare minimum of improvements to the existing approach. The lack of a robust security incident protocol is my major concern with Laravel. We're fortunate that Laravel has yet to have any major remotely exploitable issues, but it is unlikely that there won't eventually be one unearthed somewhere, and currently all our internal policies are based on a lot of assumptions and previous very minor security releases.
This isn't organized by Taylor. The company that organizes it is based in Europe, which also sorta explains the FAQ about tax.
With the exception of characterization testing, I agree. "Make sure UI has this element, given this context" is exactly what characterization testing excels at. Writing tests with Selenium is horrible, I feel.
Thank you for your reply @assertchris, I really do appreciate it. But, it just seems that the Laravel folks keep putting their hand out for cash a lot the last few years and it makes me wonder where all of this going? There are not very many Laravel jobs where I live in Phoenix, 9 listed on Indeed, and it seems like a hot start-up technology, and not used by many of the top trafficked sites of the world. Is the framework really one that will be used by the Amazon's, Slack's, and governments in the future, or will it continue to be used only by the Joe Schmoe's of Schmoe.io, or will they just keep asking us for another $200 for something they think we need every year?
Schmoe.io gave me a good chuckle! :D Not sure about elsewhere, but there's a huge demand for it in NZ and ZAR. Also, governments will use anything with an LTS and certification. This is a good thing for the legitimacy of the framework, in their eyes. I'm hopeful it'll be a good thing for developers too, but I have no inside knowledge about that. Guess we'll have to wait and see...
The question is what does "make sure UI has this element, given this context" gives you. I'm not saying it has no uses, but it's dangerous when it gives you the false security that: - UI has this element, therefore this element is visible. - UI has this element, therefore it looks as it should. - UI has this element, therefore it's placed where it should visually. - UI has this element, therefore it shows the exactly right information. - UI has this element, therefore it interacts precisely as specified with the user. - UI has this element, therefore it sends back the right events and data to its control logic upstream. All of those are false, but someone might be tempted to say "close nuff" and call this feature "tested", while it's anything but. If the above mistakes aren't committed... then sure.
You see: - You said it's not ORM's problem if race conditions occur, as they can't stop them. - I said ORMs can easily prevent the problem by making access serial (and keep cache transaction-local). You didn't reject this, you didn't show it wrong in any way, you just switched to "suddenly I don't care" mode. I'm not debating the "cause of the problem", **I identified it and I gave a concrete solution**. Handwaving is pointless.
I hear you. For me, the value is that characterization checks validate UI code that changes based on context. So; if I only want to show an admin menu if an admin is logged in then checking for the presence or absence of the markup is a good first step. It doesn't replace limited manual testing, but it is good for catching simple errors before they get to that point. When combined with visual regression testing and good tooling (read: that generate the snapshots and screenshots), it's a lot nicer and more useful than manually-written Selenium tests.
&gt; So; if I only want to show an admin menu if an admin is logged in then checking for the presence or absence of the markup is a good first step. Showing the admin menu UI if no admin is logged in should be a zero-risk bug if the models upstream are tested not to give non-admins access and control to admin APIs. I'm not sure it's worth firing up Selenium just for *this kind of tests* when the UI still has to be tested manually anyway.
&gt; I don't care for your abuse, and I still do not agree with you that ORMs are to blame for race conditions. Race conditions are real, we agree. We disagree that the blame lies squarely on the shoulders of an ORM. Look let me break down the race conditions that occur: - ORMs don't wrap their sessions in serializable transactions (and advisory pessimistic locks for some DB), while they could. - ORMs (some, not all) reuse cache (i.e. stale data) across transactions, while they should not. If both of the above are implemented, **race conditions disappear**. Both of those are ORM flaws and choices, and it's up to them to fix that. The user is not in control to fix it. The SQL server is not in control to fix it. ORM introduced the problem, they're in control to fix it, they have to fix it. It's not about "agree" or "disagree". Facts are not up to anyone's opinion and those above are facts.
I hope someone was educated from this conversation, if not you.
&gt; This carries many assumptions, both in how the UI code is written and how the permissions are managed. I'm assuming the architecture of said app is sane. Putting your security logic in the UI layer wouldn't be.
:)
Now we know who puts their security logic in the UI :)
I'm making a joke, based on your choice to start insulting me. It's funny, let's laugh.
Can we see board of advisors certifications please? Not sure if I would want to buy it from uncertified people.
Sigh, time for an English lesson: &gt; Sane (adjective) 1. Of sound mind; not mad or mentally ill. **2. Reasonable or sensible.** So I'm guessing we should skip the part of this unit testing discussion that refers to [sanity checks](https://en.wikipedia.org/wiki/Sanity_check), huh? 
**Sanity check** A sanity test or sanity check is a basic test to quickly evaluate whether a claim or the result of a calculation can possibly be true. It is a simple check to see if the produced material is rational (that the material's creator was thinking rationally, applying sanity). The point of a sanity test is to rule out certain classes of obviously false results, not to catch every possible error. A rule-of-thumb may be checked to perform the test. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
never trust user input! - consider this a law
Ok this went really far. I appreciate the replies and i hate ppl fighting over the topic. Let me explain some of the issues. Select for Update won't work since between actual select and update may be few minutes apart. fresh() method may be a solution i will have to give it a try, but from what i can see its a whole new level of problems, since it needs to be called on the access of model's fields once so often. Serializing/versioning of the object was an option, until I looked at the scope of changes needs to be made. With all the handling of update "errors" due to outdated version on particular object that would add up a 2 - 3 extra queries on any given update (try to update, fail on version, then change data according to DB changes etc) would end up as a mess 
IIRC that was `Route::controller` (https://laravel.com/docs/5.0/controllers#implicit-controllers).
From experience, adding that to my CV would probably be more of a hinderance.
Lots of new features. Good job! You should consider lanching a LTS each two years. That's what Symfony is doing.
[removed]
This is useful for persons who apply to jobs that require at least 6 years of experience in PHP and at least 8 years of experience in Laravel :D . See this post to understand what I'm saying: https://twitter.com/aviknigam/status/876141737265078272
1. [Configuration Values Are Dependencies, Too](http://paul-m-jones.com/archives/6203) (2005, Paul M. Jones) 2. [array-config](https://github.com/mrkrstphr/array-config) (2005, Kristopher Wilson)
That, and the background image makes links un-clickable without js.
Yeah, definitely, [Responsable](https://laravel-news.com/laravel-5-5-responsable) looks awesome!
Paging u/ocramius for comment.
No.
This "digest" is a blatant case of self-promotion, intended to promote the services sold from the site. This is zero-effort, zero-added value copy-paste from the list of top Reddit posts.
Of course no, because if we have to choose between *good benchmarks*, and *no race conditions*, we should obviously choose *good benchmarks*. Benchmark numbers speak loudly. While data corruption, eh, the users will blame themselves, screw 'em.
It was "No, I got shit to do".
The only important perspective is the API. A framework/library should clearly state what is its API (using PHPDoc and access modifiers) and it should be extensively documented. If you rely on something that is not part of the API you shouldn't complain when your project breaks. Also you should definitely complain when API changes in non-backward compatible manner in MINOR or PATCH. I like the concept of .NET assemblies - internal vs. public modifier.
Ahh, yep that's right
¯\\\_(ツ)_/¯
(⊙_◎)
Thanks for your contribution.
&gt;Is the framework really one that will be used by the Amazon's, Slack's, and governments in the future, or will it continue to be used only by the Joe Schmoe's of Schmoe.io Top highlight.
[UPGRADING](https://github.com/php/php-src/blob/php-7.2.0RC1/UPGRADING) [NEWS](https://github.com/php/php-src/blob/php-7.2.0RC1/NEWS)
Thanks for good contribution. Could you elaborate, please on version numbers of records? Is there a common reliable way to implement that?
Eloquent is easy and quick to implements. But it quickly breaks down when building complex application which require logic in your model. If I take your example : // Within your User model class public function activate() { $this-&gt;is_user_active = 1; $this-&gt;save(); } Let's say we should only have a value of `0`or `1` as a rule for the `active` attribute, what prevents another part of the code of doing this : $user-&gt;active = 2; $user-&gt;save(); It's just a simple example to demonstrate that simplicity can come at a cost. I had to develop applications which weren't that complex and using Eloquent became really problematic due to its leaky nature. In short, I wouldn't consider it for more than a simple CRUD app. 
Sure, You have some sort of versioning field on a record, this is typically either a revision number or a timestamp that gets set to a new value when the record changes. Before you perform an update you compare the value of the version field in the database to the one you have in memory, if they don't match then the entity you have in memory is considered out of date. It is up to you to decide what to do at this point based on what you are trying to do. The process may be recoverable if you simply refresh the data, or perhaps you throw an exception and abandon the whole thing. I've dealt with the exact situation you have; recording stats in long-life workers. In the end the best method we came up with of dealing with concurrency was to make the 'Stats' entity read only, add methods to the repository for stat recording and refresh the 'Stats' entity before using it. EG: "$statsRepository-&gt;recordMetric()" would execute the query "UPDATE stats SET metric = metric+1", this way the increment is performed in the DB and will always store the correct value even if other workers have altered the value and the Stats entity is out of date.
My view, having use Docker for about a year, is not to be too religious about this guideline. It's a good rule, but the world isn't going to stop rotating if you violate it. Originally I resisted it, since I felt that adding a new container for some small thing was wasteful, but now I realise that lots of small containers (versus a small number of large ones) makes making changes easier. For example, if you put your web server and some cron jobs into the same container, but wish to restart the container to reset the cron jobs, you'll have to bump your web server, even though that is not desirable. I tried Supervisor, but it is rather bloated on BusyBox-type guests like Alpine. I've switched to Monit and it is much smaller. 
Mutators can protect this for you or extend eloquent to allow for validation before saving. 
&gt; This is like 32 lines. Let's not be javascript and have libraries this small. What an awful thing to say. It's as if you have some undisclosed minimum code volume threshold for which all libraries must cross in order to be considered valid by you.
&gt; This is like 32 lines. Let's not be javascript and have libraries this small. What about libraries with [0 statements](https://github.com/ScriptFUSION/StaticClass)?
That's right, even if it feels a bit hacky. Another example that comes to mind, let's say you have a `Product` that can only belongs to 5 `Categories` max. How can you prevent attaching more than 5 categories this on a sync() method on a `belongsToMany`relationship ? I could go on and on with real life examples. 
Congratulations. This is some of the worst code I've seen in a long time, mainly because I don't habitually go out of my way to look for code this bad.
Quick question: Does anyone have any code for automatically handling an HTTP HEAD request? My routers respond to GETs, but not HEAD. Is there a way to disable the HTTP response body, so I can just handle the request the same way?
That's the path they're on. I haven't ran across a schedule for the next LTS, but 5.5 was planned to release 2 years after 5.1 LTS. https://laravel-news.com/laravel-release-process .
What do you use and how does it handle these situations? Pretty much every DB abstraction will fall down with complex and application specific situations - it's something I just expect to have to deal with.
Doctrine mostly. You enforce the integrity in the model class using protected properties and getters &amp; setters. Less magic that's true, but far more flexible on the other hand. 
&gt; given that they really haven't had any I mean this one seems big: https://www.reddit.com/r/PHP/comments/2lv1e2/csrf_vulnerability_in_laravel_4/
In my personal opinion that's the importance of developing strong public interfaces early doors; really the point I was making is that you wouldn't want to have ever exposed the $user-&gt;active property in the first place, instead hiding that functionality Though, whilst I do understand your point, I have to disagree with your point regarding not using it for more than a simple CRUD app; no matter what you use bad code will always break it. The example was deliberately simplified, it makes the assumption that is_user_active is strictly a bool; I've used it in far more complicated scenarios than that and have had no issue Simultaneously I've used a number of other supposedly fantastic solutions (some bespoke, etc) for managing data and the same problem always applies: No matter how good your core software, etc, bad developers, bad habits and bad code can always cause problems
Do yourself a favor and throw a var_dump($con); after your MySQL connection attempt. You will probably find that it's equal to Null as opposed to False (which is what !$con checks for). 
Those will only return an error if the following happens: * It cannot connect to mysql server host with the provide credentials. If this happens. the first echo statement will output and exit the script. Remember the value of `if (!$con)` translates to if the $con is equal to null. * It can connect to the mysql host with those credentials, but it cannot select the database `gift`. Most likely because the database doesn't exist or the user doesn't have permission to it. If this happens. the second echo statement will output and exit the script. Again, remember `if (!mysql_select_db("gift"))` translates to if the value of mysql_select_db("gift") is equal to null. If neither situation occurs, you should then only see the output of your final four echo statements. 
Nginx + FPM all the way. I have never used apache since I was a young dev using shared hosting. Ever since I do my own deployments, I use Nginx.
Speaking for my self here, But I dont care about fix releases. Try posting when 2017.3 or 2018 come, with significant feature additions then I will care enough.
Remotely exploitable meaning: SQLi, LFI, RFI, RCE, etc. CSRF exploits require a confused deputy (e.g. an authenticated user whose browser can be tricked into executing the action for you).
Thank you!
The article fails to mention that you can run Apache + FPM as well: https://wiki.apache.org/httpd/PHP-FPM
Most of the advantages mentioned are because of FPM over mod_php aren't they? Wouldn't Apache+FPM would offer the same benefits?
&gt; Fixed bug #75124 (gdImageGrayScale() may produce colors) Hurrhurrrhurrr.
Of course there is no perfect solution and that bad code will always cause problem. Wouldn't argue with that. I've been a laravel developer for years, and seen the community shifted from strong SOLID advocates to nearly dismiss the pattern (which is more a set of principles than a pattern in fact). I believe one of the reason for this is Eloquent being criticized for not following SRP, and that it's more a defensive mechanism from the developers than a truly honest statement, at least that's what I feel. Following these principles have definitely improved my code structure and maintenability, without any doubt. With that said, i'm pretty sure if an ORM existed that has the simplicity of Eloquent and the flexibility of Doctrine, it would be a winner (ok chasing unicorn here). 
Does somebody know how much it costs? Or does it depends on the Project?
From the sidebar: &gt;/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC (nickserv registration required). 
I think you're absolutely right here, you have to have some trust in the people you're developing with; the same as foolish users, bad developers will always find a way to ruin things I personally am a really strong advocate of SOLID, but within reason. The biggest problem I have with SOLID (and some other principles too) isn't actually a problem with SOLID, but more a problem with people treating it like hard and fast rules, and using it as an excuse to flame or over-abstract functionality. I follow SOLID almost like a Bible and as a definite standard/default point - on occasion I don't have a problem with bending those rules though; if it's in the best interests of the software itself. But then, to my understanding, at least, that's the point of a principle - it's a principle, not a rule
`!$var` is a loose comparison, not string. That is, it's the same as `$var == false` and not `$var === false` `null == false` is true `null === false` is false
If you're going to spend a good part of your time in Laravel, it's worth it to get certified. It sets you apart from other applications. Now swap Laravel with each of the OTHER major frameworks that offer certification (Symfony and Zend) and the statement is still 100% True. Also as /u/pmjones is often quoted in his talks when asked about certification (And I've come to appreciate the comment/saying): ~"Getting the certification shows your employer and potential employer you are a professional and willing to put forth effort in your industry"
Are you using a custom router, or a mainstream router package or framework?
&gt; "Getting the certification shows your employer and potential employer you are a professional and willing to put forth effort in your industry" Yes, I have said that (and variations thereupon) about the Zend Certified Engineer certification repeatedly; I said it before I was on the advisory board, and I continue to say it after having written questions for the certification. EDIT: Note that ZCE is a general-purpose PHP language certification, not a framework-specific one.
Now, having said &lt;https://www.reddit.com/r/PHP/comments/6x0cv7/laravel_certification_is_alive/dmdw6ln/&gt; earlier, I would hope that the Laravel certification covers not only the specifics of Laravel usage, but also some of its idiosyncratic terminology and how it differs from the wider programming world. I know that Laravellers are tired of hearing about it, but it would be a disservice to them if the test did not include at least one variation on each of these two questions: 1. How does a Laravel "facade" differ from the "facade" design pattern? 2. How does a Laravel "pivot table" differ from a data-processing/OLAP/Excel pivot table? For the latter, cf. &lt;https://en.wikipedia.org/wiki/Pivot_table&gt;. The value of a Laravel cert *qua* Laravel usage might not be influenced by them, but the value of a Laravel cert *qua* more-widely-read-developer might be.
**Pivot table** In data processing, a pivot table is a data summarization tool found in data visualization programs such as spreadsheets or business intelligence software. Among other functions, a pivot table can automatically sort, count, total or average the data stored in one table or spreadsheet, displaying the results in a second table — the pivot table — showing the summarized data. Count-based pivot tables are unweighted cross tabulations. The user sets up and changes the summary's structure by dragging and dropping fields graphically. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
It's a custom router. https://github.com/delight-im/PHP-Router The framework is quite excellent. Very minimal. Everything works as plain-old-php (or twig). There are no special command line tools or pseudo-languages to learn... I know I can work with that router to handle HEAD requests. It seems like the ideal thing would be to simply disable the output and behave just as if it were a GET... Or else, it could reflect back on the server and make the corresponding GET request. Then only return the headers...?
Is it a whitelist or a blacklist?
I assume it's a blacklist or a little bit of both. E.g. using regex. That will basically never be secure. I have built an editor where the result is saved as SVG, that then is published to end-users/publicly. What I did then was to traverse the DOM (SVGOM) with [domDocument](http://php.net/manual/en/class.domdocument.php), read content into various objects and then generate a new SVG from those objects. Entire tree structure defined by many rules and the expected/allowed attributes per element validated. I believe that is secure if done correctly. It was also beneficial because I could apply other optimizations, read some values into a database etc. One issue with HTML is that it's much more irregular than SVG, depending on source of course. 
&gt; One issue with HTML is that it's much more irregular than SVG, depending on source of course. This is a very important point. Valid HTML could be invalid XML. HTMLPurifier attempts to handle HTML gracefully.
If configured well, HTMLPurifier is pretty powerful on what you can whitelist/blacklist in HTML. Follow the documentation closely, and build custom filters if needed. If including it with composer, be aware that it will write cache files in your vendor folder if you don't tell it to use another folder.
Frankly I've been disappointed with the 2017.2 releases. For some reason they have real problems with our large codebase and PHPStorm frequently seems to just give up, leaving error markers all over perfectly valid code. My EAP reports list still has pages of unresolved reports.
Thanks for sharing!
Clearing caches and restarting fixed the problem for me (From the File menu).
Doesn't here. That's another thing that annoys me. Is it really so hard for PHPStorm to automatically clear caches on updates so I don't have to do it manually?
&gt; Note that ZCE is a general-purpose PHP language certification, not a framework-specific one. This is exactly why people should consider ZCE instead of laravel certification. I do like laravel very much, but at the end of the day it is a very specific tool and certification for it is meaningless. I cannot imagine anyone sane asking for it for a job position.
IIRC, caches are cleared on major releases (2017.2 -&gt; 2017.3), but not in minor releases.
its not a problem because its for some reason a big misconception that you should have only 1 process per container, its one SERVICE per container. So its completely fine to have your app running php and all its cronjobs and even webserver in the very same container
Tbh. I think you go the right path. You are searching a replacement for yourself. So the person which gets your position should be able to solve this. 1. Test Pretty easy. Don't know why people are taking more than 5 minutes with it. There is only a single method which might not be clear. But then again, people are stressed on this tests, i know it, been there before ;) But you can pretty much google the solution instantly. 2. Test This one is not that easy if you can't break down your steps. People tend to stress out when they can't see the solution. They always want to solve the issue right away, not step by step. To see all the small steps in the bigger picture comes with years of knowledge/practise. So in the end. I think you should keep looking, as hard as it may sound. Edit: 1. Just to give the solution. strpos returnes zero so falsy value 2. I would go for an regex approach here. Get 3 groups from the input. explode first and third group. merge array. something like that ;)
What is your role? Personally I believe that in most situations programmings tests are a bad way to establish the skills of a candidate since they rarely represent the actual required skills for the role being hired for. Maybe in very junior roles they might have a place. Are you primarily working on business type applications (i.e. mostly CRUD) or are your developing systems software (e.g. high performance distributed database engines, i.e. compsci oriented software). Both these roles require different forms of interviewing. If you're not Google and you're not solving Google scope problems then don't try to be Google and don't try to hire as if you are Google (i.e. compsci puzzles). Are you able to have a conversation about building software with a candidate? Often tests are used for a lack of interviewing skills on behalf of the hiring party. When you do have a test, don't expect everyone to feel warm and fuzzy about it. E.g. if a candidate has a resume that clearly demonstrates their ability (and a public Linkedin profile and maybe a GitHub account to back it up) then a "test" might actually come across as an insult. E.g. asking a 15+ year professional software developer to do your (silly) programming test kinda shows a lack of respect on your behalf (not saying you did that, just as an example). Put yourself in the shoes of the candidate. A simple conversation starter is; "The last project you worked on, can you tell me about one or two specific problems that you solved?" The way a person talks about their work often says a lot more. I have had even to most socially awkward guys talk enthusiastically about their work by just asking that simple question. 
&gt; I would go for an regex approach here. Get 3 groups from the input. explode first and third group. merge array. something like that ;) Or, you know, `str_getcsv()` 
2nd test, yes but really it was meant for the candidate to google "how to parse csv php" and you get this http://php.net/manual/en/function.str-getcsv.php
I think you are doing fine -- if your candidates don't want or know how to navigate to php.net and search for "strpos" or "csv", you probably do not want them.
It's mostly CRUD, some interfacing between different apps. Nothing really difficult, the only part is that deadlines are always tight and there is no one else developing than me, no QA no nothing. I am looking forward to getting a real dev job. Yes, I do talk with the candidate about their previous projects and building apps in general. Before the test. If I had any reason to think that the test is unnecessary I wouldn't offer it to them. But so far most candidates failed miserably and one needed significant hints for both tasks. One of the candidates came in with one portfolio app zipped outside of source control and described it as a mess of spaghetti code, he couldn't solve the test. The quality of the candidates here is the problem, it's not a very attractive job, being a lone fullstack dev for a small growing business. I had a candidate today which had 8+years of Team leading and programming experience. He did know about software architecture, but he couldn't make the test in an hour, with me severely hinting. I felt bad about declining him, because he seemed nice. But this silly test is meant to be passed by anyone.
or hand crafted: http://rextester.com/MLH97575 - took me 5 mins but it's shitty. Obviously in prod systems, use mature solutions :D
CONGRATULATIONS! You got to the second round :D Wanna work for us? We're desperate :D /jk
I think this library configured well, but I prefer using the PHP functions to achieve my goal. For instance, filter_input, htmlspecialchars and htmlentities functions.
That's exactly what semver is for...
While building this kind of captcha is a great academic exercise, noone should be using this kind of captcha in production. They've been [broken since at least 2007](https://blog.codinghorror.com/has-captcha-been-broken/). (You're also breaking reddiquette by posting a link your own content: this could be considered self promotion)
Fair enough. If the quality of candidates seems to be low, then were do the candidates come from? Same source? I do think your questions are borderline puzzle. Have you considered to use some questions from the Zend PHP Certification exam instead. Maybe having more smaller scoped questions rather than a few puzzle ones might be more balanced: https://www.slideshare.net/carlosbuenosvinos/zend-php-53-demo-certification-test The other interesting thing you mentioned is that you looking for a replacement for yourself. This is a little bit dangerous territory I'd say. You can not replace yourself. The person coming in after you will be very different and will do things different than you. Should you even be hiring your replacement? Who hired you? Technically it's the responsibility of the business but I'd understand your on friendly terms and obviously don't want to cause them problems. Last thing, and I obviously don't know the circumstances in which you've decided to move on, but... if you're really that concerned who comes in after you and what happens to your work and/or the business, should you be leaving at all? 
I took the job as a student, it was my first job. I've learned a lot working for this company, more than I would have learned just in school. Probably less than I would have learned in a junior dev position somewhere. I am leaving because I now have enough funds to finish the last year of the school. I leave behind mostly well documented and readable code, but also several ugly hacks I had to make because one of the 'frameworks' is really bad and partly of course since it was my first dev job. I've rewritten most of the bad code from the beginning though. I am trying to find a competent person who can do the work required, I have friends who studied with me who I would gladly recommend for the position without any second thoughts, but they already have jobs. So I know people that can do the job must exist. They just don't come to our interviews. I've looked trough the Zend exam, some of them could be used in the test. Will give that a thought. Although I personally dislike questions for static code analysis, but I see the value in them. I don't really know where the HR person gets the people, I know it's several sources. No recruiting agencies though. edit: grammar
well... didn't know of that one :D But ok. Learned smt :P
fair enough :)
&gt; I don't really know where the HR person gets the people, I know it's several sources. Ah OK. Is HR filtering before candidates get to you? If so, maybe they are filtering on the wrong thing. In the past I've seen HR peeps are simply looking for a keyword match on a resume and simply discarding those who don't match enough keywords. I assume you wrote the role description? Check with HR what is actually advertised. Maybe it's worth talking to HR and to see if you could be more involved in the process. 
The first question is great. I would expect most people with PHP experience to get the first one right away. It's a good question and answering it demonstrates an understanding of how PHP type system works and the idea of "truthy" / "falsey". I would personally assume I am not allowed to use `str_getcsv` or `fgetcsv` in the second question. It feels like cheating and not the answer you're looking for. I would think you're wanting them to write the function. Which, I personally think is a great task for an interview. Somewhat non-trivial, and shows they can work through a problem and think about edge cases (e.g. accounting for delimited vs. non-delimited values). If I was allowed to use `str_getcsv`, my thought would be this is a dumb question, why am I writing a function that simply calls another PHP function. Just use `str_getcsv` in the first place.
Nono, I get all of the applicant's CVs and I filter them. We are a small company and the HR person is one desk over. I approved the final role description which is then put on multiple sites. Is it worth trying to go trough recruiters?
&gt; I do think your questions are borderline puzzle. Have you considered to use some questions from the Zend PHP Certification exam instead. Maybe having more smaller scoped questions rather than a few puzzle ones might be more balanced: I have to disagree here, neither of these seem remotely like puzzles, they're both problems that you would expect to encounter in day-to-day programming whether working with legacy code or building a new system and in many ways should be easier for someone with PHP experience to solve than implementing something like Fizz Buzz, which requires thinking through the logic of it and has many possible implementations with varying degrees of elegance. The first question relies on fairly simple debugging skills, even if you've never used `strpos()` before or can't recall how it works. My steps to solve the first would be: 1. Run the code, check the output against the input and work out what is going wrong. 2. See that the test for `a` isn't working right, realise that `strpos()` is returning a falsey value for it's location, and change the condition to `strpos($haystack, $needle) === false` 3. Or if I didn't know how `strpos()` worked or why the bug was there, echo out the incorrectly passing condition to see what it's returning and then if need be, Google `strpos()` to find out how it works. The second question is answered by implementing the function as `return str_getcsv($csv, $delimiter);`. As long as it's made crystal clear that neither test has any tricks and that Googling is absolutely okay, even if they think it's something really simple, I don't think these are puzzlers at all. EDIT: Having looked through some of those example Zend questions, I think most of those are *far* worse questions to ask in an interview setting than the problems /u/meltea has suggested, other than the questions that are quite similar in nature to the posted problems, in fact, question 11 is almost identical to the first problem posted by the OP. Many of them rely of having knowledge of specific keywords or functions that aren't encountered day-to-day and that many PHP developers, especially juniors, would just Google if they needed to know them. 
Yes you are allowed to use str_getcsv, it was really meant as a dumb question. I thought it would spark discussion, perhaps why I didn't include the $enclosure parameter in the definition. It was my intention to let the candidate write a homebrewed solution if they were competent enough to raise doubts about anything about the task. So far it's been a string of failures to even google str_getcsv... One person used explode and gave up after it failed the tests. Even prompted them to use google.
These are entry level questions. If applicants can't solve them keep looking. I and others ITT solved them w/o using google or any documentation. So someone with those tools could surely solve them quickly if they knew what they were searching for. And that's the real issue. If people aren't solving these, the issue isn't that they don't know whether needle comes before or after haystack, but that they really don't know what they're doing at all. Keep looking. 
I don't want to sound rude but I'm curious why you came to the conclusion to use regex to parse CSV when if you Google "parse csv in php" the first answer is what you've been told I see this a lot at work and I am very interested in people's approach.
You shouldn't feel like cheating because you're using built in functions that have been tested and proven and are (mostly....) bug free. The less you write the better and reinventing the wheel doesn't score any great marks unless you're specifically asked to (e.g. Write the bubble sort algorithm) These "simple" questions were out the jokes, as the OP is struggling with 
Man, I really like your test. The 2nd one is harder and if you know a few things about CSVs most code will not handle this edge case where someone has escaped quotes. $csv = 'a,b,c,"d,To quote John \"He was great\"",f,g,'; For interviewing candidates I use this guide. I noticed many candidate can answer many of my questions, but bomb in the test. https://www.joelonsoftware.com/2006/10/25/the-guerrilla-guide-to-interviewing-version-30/ And I give my candidates this test in PHP. • Write a function that determines if a string starts with an upper-case letter A-Z • Write a function that determines the area of a circle given the radius • Add up all the values in an array I probably have given this test about 20 times. Fastest candidates were about 4-5 minutes (yes we hired) Some around 10 minutes - they generally googled the whole question and copy and pasted it. (not hired). Lastly many, many around 20+ minutes... Many said they had 8 years of development. We hired a few of these, some were better than others. What I get from this test • Do they know how to run a php file with functions, eg PHP cli, or do they try and do it via a web browser • Do they know regex or can find a way to solve the first question. • Do they know maths (commonly I hear "oh maths", this is a big warning sign for me). • Do they know array_sum, or do they sum in a loop. • Do they understand why echo'ing a boolean results in 1 or blank. (many don't use var_dump()) 
I've seen this as well on a fairly large code base - I start to make a change, PHPStorm "highlights" the bad syntax (since I'm not done yet), and once it's fixed it continues to show the error markers pretty much from that point on for the rest of the file. One thing I have found that sometimes fixes it - I do a "reformat code", which basically breaks it further, then I just "undo" and it all comes back up correctly. Doesn't work every time though. It's annoying as I run into it probably 3-4 times a day. Older versions of PHPStorm used to suffer from this same issue, and it seemed to get really good in PHPStorm 8/9, but has come back in the 2017 release.
If starting new development or wanting to test out new features in PHP 7.2 (for example, to use libsodium or to use Argon2i / PASSWORD_ARGON2I with password_hash), [serverpilot.io](https://serverpilot.io/) added 7.2 support starting with RC1.
Are you new to reddit? People link to their own stuff all the time. Why even point that out?
/\^[A-Z]/g - I am actually a bit proud to have come up with this one without google, since I don't like regex and use it only when required (almost never). The area of the circle, well since this isn't a maths test, I would just use google, which would be orders of magnitude faster than trying to dig it out of my brain. Unless you're hiring for a maths heavy position, I don't think it would be that bad. Where is the line between knowing the area of the circle equation from the top of your head and knowing how to find a normal in four dimensions. At some point you have to admit that you can use other peoples, in this case mathematicians, work. Do I know array_sum? Yes. Have I ever used it? Don't think so. CRUD stuff usually does not require summing arrays. On the other hand, I keep myself well read on software architecture and development approaches, even if I rarely get to design something from ground (framework) up...
I had to give up on updates a while ago because there was no way to fix issues with i3wm and each release made them worse.
Those are good questions to assess basic PHP and problem solving skills. I do think a competent developer would be borderline insulted. 
I maintain an RSS reader which uses it extensively. Never had a problem, other than initially not whitelisting enough tags so it would kill the source formatting. The internals and API are... not the best. But as far as the results go, I believe it’s the safest choice right now. Just start off by whitelisting as few tags as possible. 
These questions seem really easy. I use stripos all the time so I saw the issue instantly. For the second one I would probably have to google the csv function but if I recall correctly it's fgetcsv. 
What's the issue? I'm using phpstorm on i3wm (arch linux), no complains so far.
Why are you not setting a test for them before they even get to interview? Why waste time meeting people face to face if they cannot even code? And depending on the developer level, I would say that this test is far too easy. Give them something harder to do before they're even given an interview, and have them come in and explain their code, reasoning and ask questions about what they've done to ensure they wrote it themselves.
To expand upon my [tweetstorm earlier](https://twitter.com/CiPHPerCoder/status/903431083580170240) about this release: sodium_compat is a pure-PHP re-implementation of most of libsodium. It was meticulously designed to [mitigate all known causes of side-channels in PHP code](https://paragonie.com/blog/2017/02/cryptographically-secure-php-development), although it's entirely possible that there are unknown sources of data leakage. Until version 1.2, however, sodium_compat only worked on PHP with 64-bit integers. If you're on Windows, this means you'd have to use PHP 7.0 or newer. To put it lightly, supporting 32-bit PHP was not an easy task. This took me a month of *virtually all of my spare time*. For comparison: I probably spent less than a week of equivalent time on every release up to and including v1.1 of sodium_compat. However, this means that if an open source software project wants to add sodium_compat in a non-major release *without* adding risk of breaking backwards compatibility with users on weird servers, they can now safely do so. (However, PHP 7 is still very strongly suggested because of performance reasons.) Between PHP 7.2 and sodium_compat, I estimate that [about 82% of websites on the Internet](https://w3techs.com/technologies/overview/programming_language/all) can now use modern elliptic curve cryptography, even if their users cannot install PHP extensions.
But why did you use the `g` option? 
I was much more successful in writing custom stuff for Symfony serializer. It's designed well. JMS on the other hand... I had lot of trouble writing custom stuff for it. In Symfony serializer you have encoders, normalizers, name converters... JMS's handler thing is too weak as an extension point. I also didn't like readability of JMS serializer's code. There was too much magic and context switches.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
100% agree with you. I would absolutely never reimplement a built in function in userland, and that was my point. The question is "write a function that does literally the exact same thing as a built in function". That would have therefore made me think "`str_getcsv` already exists and is what we would use in real world code. There is zero reason to have a `parseCsv` function that does nothing other than just call str_getcsv. Therefore, the interviewer must be looking to see how I would write my own csv parsing logic." Sounds like that wasn't the case though, candidates were just bad. My second point was this that it *is* allowed, and that would turn me off from the job a bit. // ... $parsedArray = parseCsv($csv, ','); // ... function parseCsv(string $csv, string $delimiter) { return str_getcsv($csv, $delimiter); } Would not pass code review. I would say remove this pointless function and just use str_getcsv: // ... $parsedArray = str_getcsv($csv, ','); // ... If I wanted to know if they could google a function, instead of putting a function they had to implement, I would ask something like "How would you go about parsing CSV string into an array in PHP?"
Your test is not too difficult nor is it unreasonable to ask a candidate to write code/solve problems in an interview. I had to pass a test for my current job. Surprisingly a decent amount of engineers who we interview aren't able to pass even basic tests. Normally they have 'relevant' experience, but I guess they don't have to crank out strategic development the way I have learned to do. But to be honest with you, you might want to give a little more flexibility. For instance, let the candidate do the test or a test at home and then explain their solution. I only say this because your job description sounds like a job description I would run away from. Being the only developer to maintain the previous sole developers strung together open source library's. Oh, and that previous developer was a college kid who more than likely wrote a lot of hacky code because it made sense at the time but wasn't engineered to be maintained. At a wage that a college kid is happy about. Seriously no offense, you sound like your doing a great job and props to you. But you are probably not going to be getting very many great leads.
your test is reasonable for an easy on-site for junior devs. if they're failing at such a high rate maybe work on sourcing better candidates, and using a more rigorous pre-screen so you can weed out the non-programmers on the phone instead of in person. save yourself a bunch of time that way.
Ha, I think I would've aced those questions honestly. I like those. From when I was a kid, I think the area of a circle equation is the one I remember the easiest to this day. `pi * r^2`, I always read it (in french) as "Pi-R-2" -&gt; "Pierre Deux".
&gt; If including it with composer, be aware that it will write cache files in your vendor folder if you don't tell it to use another folder. What the hell... 
&gt; Why am I writing all of this? Well two candidates complained that they weren't expected to solve such difficult and tricky questions as this. One of them even left in a very bad mood. You gave them a test environment, and access to Internet. That's fairly liberal. The problems are **easy**. The first is a basic problem that would stick out to any skilled PHP developer, the second is... a function call, and they'd be able to solve them instantly even without Internet. &gt; I think I am going mad. Are these tests too difficult? Nope, just shitty, entitled candidates. If someone else complains, don't doubt yourself, just tell them they have to work more on their skills and kick them out.
&gt; 1. Java 2. Python 3. PHP 4. JavaScript JavaScript is two spots after Python? I don't think this makes a lick of sense. 
Another workaround for it to stop highlighting bad syntax after you fix it: copy the code block (usually the entire method for me), then cut and paste it in place. Still extremely annoying though.
Simple use "{$array[0][0]}".
I think it is because Java and Python are languages you can use for all kinds of development, and are quite popular in serverside applications (also in tools and stuff). Javascript is only used in web-environments, so a lesser market (not everything is internet)
TIL that php has str_getcsv 
My 2 cents, Caddy + FPM, because I like the easiness of HTTP/2 and Auto HTTPS, etc.
We can retroactively rationalize this in all kinds of ways. Let me give it a try: &gt; 1. JavaScript 2. Java 3. PHP 4. Python I think it's because JavaScript is the single language available on the most popular application/content platform in the world: the browser. It's also heavily used on the server-side (Node.JS), for command-line utilities, it's even available on embedded devices. JavaScript's low bar of entry and extremely high-availability (it's literally **the one** language compiler/runtime to be guaranteed to come on every computer and mobile device in the world!) means most people are familiar with it, and would reach for it for any basic scripting needs. Java is undisputed ruler of enterprise software and more complicated backends. PHP is the most popular language on web-hosts worldwide, so like JavaScript, this gives it an edge on the web/browser platform. As for Python, it's a general-purpose script, it's used by scientists and for general tasks, but nothing stands out. Yeah, makes sense it's in 4th position. /s ----------------- Kidding aside, current GitHub trends actually show **JavaScript** on top: http://githut.info/ I don't know how this article combines TIOBE and GitHub data, and TIOBE is basically based on search engine queries (which isn't very accurate IMO). I think the GitHub picture is more representative of overall community activity. Heck, GitHub currently is **the** community for programmers.
PHP is best for website design and development READ MORE https://www.ewebbyte.com/php-web-site-development/
I don't like it that the codeception suites are "3 hardcoded types" inside phpstorm, while we can have an unlimited number of suites. I would rather see that they used the suites that are available in de test/codeception directory. :-(
&gt; Write a function that determines if a string starts with an upper-case letter A-Z [yolo](https://3v4l.org/X1IeY)
Yeah, GitHub probably is for opensource, but a lot of users use other git repos too. So it's just an "estimated guess". But it's never too late to learn a new language on the side ;-)
A slight improvement in readability and reduction in complexity would be: &lt;? define("ACTION", 0); define("LABEL", 1); $routes = [ ['Home','/home'], ['End','/bye'] ]; ?&gt; &lt;? foreach($routes as $route): ?&gt; &lt;form method="get" action="&lt;?= $route[ACTION] ?&gt;"&gt; &lt;button&gt;&lt;?= $route[LABEL] ?&gt;&lt;/button&gt; &lt;/form&gt; &lt;? endforeach; ?&gt; Some explanation: * Instead of having flying hardcoded numbers which you will 100% forget, do your best to come up with good variable names * For that reason you can make use of the [define method](http://php.net/manual/en/function.define.php), else you can just as easily do the same with 2 variables: $action_key = 0, $label_key = 1 * [&lt;?php is not required in recent php versions](http://php.net/manual/en/language.basic-syntax.phptags.php) instead you can use &lt;? and ?&gt; * array() can be also [shortened with square brackets](https://stackoverflow.com/questions/17772534/php-difference-between-array-and) * The reason your first example is not working is because [of this](https://stackoverflow.com/questions/11420745/php-embedding-array-element-inside-string-with-curly-braces), also be sure to learn [the difference between php single quotes and double quotes](https://stackoverflow.com/questions/3446216/what-is-the-difference-between-single-quoted-and-double-quoted-strings-in-php) * PHP is first executed and the output is placed on the HTML, this is why you can mix both PHP and HTML languages. I think this one takes the most time to fully comprehend, especially when sessions and submit forms are involved etc. * There is also a shorthand for &lt;?php echo which is &lt;?= [stack overflow](https://stackoverflow.com/questions/2020445/what-does-mean-in-php) * Foreach is yet again a more convenient loop in your case. My best advice is to focus on code readability ! If your code is easy on the eye, it will be easy on the brain, you will have a stress-free learning, and you will advance in no time ! Cheers 
why the @count though?
Nice stuff, but what if somebody fails in parsing XML or json or.... You can't test everything, and yet you want to rule out the fakers. What I normally do, is to give a person a test to write at home. Like make a phonebook application with framework X (what we use, and the applicant claims to have knowledge about). In the instructions I have 1 piece of wrong information, so they should ask about that specific thing. And before they are presenting it , I want 1 extra feature, which they have to build at my office in in 15-30 minutes. (they know something like this is going to happen.) What will they score on: Good explanations, documentation (also good docblocks etc.), being capable of asking questions and being communicative, and the easy how the additional request was made. 
&gt; really the point I was making is that you wouldn't want to have ever exposed the $user-&gt;active property in the first place And yet, the first bit of code you show is this: $myRecord = RecordFactoryOrSomething::getTheRecord(); $myRecord-&gt;field = 'Updated Value'; $myRecord-&gt;save(); And a similar example from [the Laravel documentation](https://laravel.com/docs/5.5/eloquent#updates) $flight = App\Flight::find(1); $flight-&gt;name = 'New Flight Name'; $flight-&gt;save(); So yes, sure, you can encapsulate those properties (well not really, as far as I'm aware every property is always publicly writable in an Eloquent model), but as long as the main documentation doesn't show that users getting started with Eloquent will never do this.
&gt; Less magic Which is its own very good thing and doesn't even need the "defense" of saying "far more flexible on the other hand". Mutators are fun and all, but if I [see](https://laravel.com/docs/5.5/eloquent-mutators#defining-a-mutator) `$user-&gt;first_name = 'Sally'` how am I supposed to know there is a mutator somewhere doing some magic? I will be seriously confused to see "sally" instead of 'Sally' in the database. If the code I had seen was `$user-&gt;setFirstName('Sally')` then I would just navigate to `setFirstName` and I would directly see what is going on.
I think your thought is good here. A junior would probably just throw in the str_getcsv into the function they were creating blindly. I know I would have in my first role. A mid level or higher developer would question why do this? While I believe a senior would find this insulting. 
Oh there are definitely some hacks, but I've rewritten most of the bad code from the beginning. I leave behind mostly well documented and readable code. But I agree, the job position is not great. The opensource packages I was talking about are: PrestaShop (which is awful) and SuiteCRM (which I like, they have a really solid upgrade proof extension and module system, even if it's not the most recent design). Apps for tasks I've written myself for company use I've mostly done in Laravel. And are simple enough that anyone could maintain them. 
&gt; Javascript is only used in web-environment ??? Nodejs stuff is quite popular. It's way more useful than php outside of webdev. 
The benefits of nginx is it's a single thread per CPU core, whereas Apache uses "processes" by default. So 500 clients means 500 processes. You might then say "but Apache can do single threaded workers too" etc. I think the main reason for switching from Apache to Nginx is somewhat simplification of the configuration files. Otherwise Apache and nginx are functionally equivalent with the PHP-FPM being removed from the equation.
GitHub? I prefer Source Forge. Can your GitHub show hot singles in your area in an attractive 300x250 large pane?
Yeah I often find myself in need of cutting the block I'm working with and pasting it right at the same place so PHP Storm gets it right again. That's how I fix it anyway...
This was 2-3 years ago, and not really looked at the landscape since, but JMS and its annotations was much better for de/serialising complex object graphs with lots of nested children. I used it to implement a wrapper around complicated XML service (Open Travel) that didn't behave with a wsdl generator. My bet is if you needs are simple, and they sound it, then go Symfony.
It’s not an excuse, it’s an explanation. They would benefit from using more standard tools and solutions, but if they don’t know them, that would be counterproductive to delivering their product / library.
Because i didn't google the first one ;) I simply put these things down from memory. So yes, if you google it right away you are right, that you would come to a solution in like 5 minuten over all.
Just scrolling through the source there is something like $router-&gt;any(['HEAD'], '/', function () {}); or just simply $router-&gt;head('/', function() {}); Which you probably already using, but instead of going with the same endpoint as your GET, I would go with another one which is **not** returning any body information. Or you will have to kind of see what request is incoming when you handle HEAD/GET with the same endpoint.
haha, I knew that, but it's popularity is based on webdev, not on the node.js usage, since that is still a fraction.
I'm not sure about the second one...if someone asked me in an interview to implement the function `parseCsv()` then I really wouldn't expect them to be happy with just delegating to `str_getcsv()`. I like to think I'd have the presence of mind to clarify what they'd want, but my initial thought would be to get lexin' and a parsin'.
I was in a very similiar situation to you recently. We had two tests for candidates: Given any range of numbers (from -100 to 100), ignore the negative numbers and sum the positive numbers. Quite simple, sumPositive(-5,3), the answer would be 6. Really not difficult? Given an array of numbers, ignore any number containing a 7 and return the amount (not the sum!) of numbers left. So [65,66,67,68,69,70,71,72,73,74] would return 4. Again simple, use a a loop or bonus points for array_filter. We held 10 interviews. 3 managed to past those tests. All of them claimed to have experience and some of them had development jobs. It is quite scary how many 'programmers' have zero coding ability.
&gt; my initial thought would be to get lexin' and a parsin'. It's OK if it's your initial thought. If your subsequent thoughts don't change, that'd be a problem. :-)
Considering the charset is not specified, that's valid.
Could be because of the current machine learning craze and many of those frameworks are in Python.
&gt; Is it worth trying to go trough recruiters? If you want to pay a lot of money. Just a note: All my jobs have been via recruiters, but they don't exactly "vet" you outside of looking for some CV/LinkedIn. The only benefit to a Recruiter is they actively go out of their way to find candidates (because they won't get paid otherwise), the quality of the candidates may not change. I've put on my CV: "NO WORDPRESS/MAGENTO JOBS" and guess what a recruiter will still send me :D
TIOBE has C and C++ on top positions, i can't believe there are more C developers than PHP, Javascript or even WordPress developers
[A PHP developer when is told that PHP is dead](http://2.bp.blogspot.com/-b0CLD1bmZRM/ULVDiYntQJI/AAAAAAAADgo/wmCK4mzRNZM/s1600/Woody-Harrelson.jpg)
&gt; This took me a month of virtually all of my spare time. Why?! Don't get me wrong, it's great that you did this, but is there a market for it?
The TIOBE rankings are determined by typing ["`&lt;language-name&gt; programming`" into Google and counting the results](https://www.tiobe.com/tiobe-index/programming-languages-definition/). I am not making that up.
God bless your company, they have you. Otherwise it will end up like this [I am trying to write a PHP based gallery for a client and it is my first time programming in PHP](https://www.reddit.com/r/PHPhelp/comments/6wz71e/im_literally_getting_nothing/). 
You keep using the phrase "Single Responsibility Principle". I don't think it means what you think it means.
&gt; I really wouldn't expect them to be happy with just delegating to `str_getcsv()`. Tests like these should **always** start with an explanation that there are no trick questions, in my opinion. If that explanation is given and you still think `str_getcsv()` won't do, then you're overthinking things (which would be good for the interviewer to know).
i think 1st one would be to use !== and === 2nd one i don't get it what parseCSV does is it removes , from the given string ? if so then the $parsedArray[3] === is "de" not 'd,e' what does the @ do too ?
I have a feeling this is an error in their core software, across all the IDEs (although I could be way off as I don't have knowledge of the responsibilities of each part), because I've had the same issue in Rider. It'll just stop recognise my chunks of code, or whole classes where they're referenced. I find making a small edit and undoing it fixes the issue. 
The illusory fear of breaking backwards compatibility for hypothetical users running 32-bit (i.e. PHP 5 on Windows) is enough to make open source projects never adopt it. I wanted to make sure that FUD over backward compatibility didn't get in the way of improving security. If your "why?" is more abstract: I wrote about my goals and motivations [first in 2015](https://paragonie.com/blog/2015/09/state-cryptography-in-php), then [at the top of the year](https://paragonie.com/blog/2017/01/let-s-make-2017-year-simply-secure-php-cryptography). It turned out that a lot of work got done in the first half of the year, so before DEFCON I wrote a [superseding post](https://paragonie.com/blog/2017/07/it-turns-out-2017-is-year-simply-secure-php-cryptography) describing where to go from here. TL;DR? PHP powers most of the Internet, so by making secure crypto available to all PHP users, we can greatly improve security. I'm aware of at least one product that was able to commit to libsodium (instead of RSA+AES) as a direct result of sodium_compat.
check if(count($post-&gt;categories) == 5) return "sorry buddy can't set more than 5 categories to this post " else $post-&gt;categories()-&gt;sync() ?
TLDR: PHP is for poor people.
That's not strange at all. You can compile C and CPP to absolutely any platform, run on anything, you doesn't need 200MB of ram for an environment alone. Games, consoles, IoT. C and CPP high position shouldn't be a surprise for anyone. 
A nit: &gt; PHP also allows for short open tag &lt;? (which is discouraged since it is only available if enabled using the short_open_tag php.ini configuration file directive, or if PHP was configured with the --enable-short-tags option). Short open tags are an abomination. Their existence proves there is no God, or that there is a God and he is Evil.
Also, JS has been experiencing something of a boom in recent years. It would be surprising if Python was somehow surpassing it now.
Why is CodeIgniter so heavily correlated with lower-GDP countries?
Language popularity rankings are meaningless. Use what makes sense for the problem at hand. Sometimes it's PHP. Sometimes it's not. Never make a choice based solely on what's popular.
Yes, I totally agree. I remember in this sub someone talking about tests in interviews, and some of the value being observing how well they comment their code, are they using TDD etc. If you ask me to write a merge-sort and then mark me down because I didn't use TDD to do so then please DIAF.
Yeah GitHub doesn't even add malware to the software you download. Worthless. 
This. Quote: "The “S” in the “SOLID” principles. In short, this means one class should have one job." This isn't exactly correct. The “S” in the “SOLID” stands for: "There should never be more than one reason for a class to change". It's a subtle difference, but an important one.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Yes that's what we would do, but the point is, there is no way to enforce this in the model itself. 
CodeIgniter was the first framework I really managed to get to grips with. If I had to guess why, it's probably because of how simple it is - I look back at what I was doing and am a bit amazed, seeing as I was basically dropping spaghetti everywhere and it was all fine. I think the bigger frameworks (Laravel, Symfony etc) basically all but force you to start using an IDE and to write nicer, OOP style code.
I'll politely disagree with you on that one
You're right, they are all accessible so could be updated from wherever, and that's okay in a lot of cases but where you're carrying out a specific action that's potentially tied into more functionality, it's worth the encapsulation Of course it all, as everything does, relies on [a] developer documentation so they know the rules to follow and [b] developers who will read and follow that documentation
I'm on Ubuntu and have not seen these issues either. Maybe OS specific? 
Not to be a debbie downer, but maybe you aren't on the right sub for this. From the sidebar: "/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC (nickserv registration required)."
ty!
I've had no issues with i3wm, scrotwm, or bspwm aside from having to fix reparenting
http://niceme.me
Which source would you use?
&gt; PHP powers most of the Internet, so by making secure crypto available to all PHP users, we can greatly improve security. &gt; I'm aware of at least one product that was able to commit to libsodium (instead of RSA+AES) as a direct result of sodium_compat. Ah, right, makes sense! My thought was "Who's going to implement libsodium if they haven't made the move to 64-bit and/or PHP7 yet?", targeting OS projects didn't occur to me :)
&gt;!strpos There's your issue.
&gt;The average failure ratio is about 40 minutes That's not a ratio.
Yeah, now that you mention it I do remember hating those some years ago. I guess not mixing php and html for years has put my guard down :D
I'm not disagreeing with you at all; I was more concentrating on the wider definition of SRP ("every module or class should have responsibility over a single part of the functionality") It wasn't my intention to educate about SOLID/SRP in itself - my assumption (probably a bad one) was that the people reading the article (who were much higher in number than anticipated) already had their opinions on the topic and as such already had the baseline understanding of the topic - I included that bit in case people who didn't have this had the tools to Google it themselves I was joining in a long running conversation I've been having with some developers I know about how, whilst it may break SRP - especially in their opinion, that doesn't make it unusable. I may have just gone a long winded, and convoluted way around that point of, "just because you think it breaks a principle/practice, doesn't mean it must be banished from codebases for ever"
It's not about how good C or C++ is, The TIOBE Programming Community index is an indicator of the popularity of programming languages. How can C be more popular than PHP, Javascript or Python? I bet you can find 10 Wordpress developers for every C++ game developer out there, the fact that they are probably less qualified and unexperienced just contributes to the idea that it should be more "popular". 
Why would anyone use this over a dedicated mailjet, mailgun, etc api wrapper package? :o
1) function sumPositive($low, $high) { return array_sum(range(max(0, $low), max(0, $high))); } 2) function countNoSevens($arr) { return count(array_filter($arr, function($item) { return strpos($item, '7') === false; })); }
I think this problem would go away if people weren't so hung up on the word "Model". Don't like putting domain logic in your database abstraction layer? Don't do it. Use the Eloquent Model to simply pull data from the database and put it back in. Use Transformers instead of accessors. Use services instead of tacking methods onto the class.
And that's why you would fail.
why ?
While it's nice for us app developers out there, his focus in all of this has been in getting the major OS projects on board. Just imagine how much impact securing Wordpress could have on the wider Web.
And Android. But I have a feeling it has zero to do with PHP as language and 100% to do with the fact that the PHP documentation is translated into lots of languages.
Yea, apache's xml configuration is a ballache. I used to run my own unrealIRCd network and C style configs are much easier to read and edit.
as a poor country resident i just got 1 question for the wealth guys why you go to coding bootcamp ? every thing is already on the internet why you pay so much for some html css js php basics ?
Number of questions and/or pageviews on stackoverflow?
This is a good example. The code itself fails most SOLID principles however.
Popularity can have an impact on what's most appropriate for "the problem at hand". Usually, at least one of the qualities one might look for is "ability to get support for XYZ", and something having a history of being popular plays in to that. Also, existing knowledge of a team. You may argue up and down that C# is a "better fit for project X", but if you've got a team of experienced PHP and Ruby devs sitting on the team for project X, it's silly to do the project in C# and ignore the years (decades?) of onhand experience.
Just finished a small app for a client with Lumen. That was really enjoyable! Can't piss on PHP, it's so easy to start and get things going, and PHP is getting better each versions!
TIL snake charmers are contributing to the TIOBE ranking of python.
Because you clearly don't understand the question. If you can't understand the question, then how do you expect to pass? This should be the easiest PHP question you've ever been asked in the past couple years. If you can't answer it, then you wouldn't be hired for this job. You shouldn't need to ask additional questions to understand what's being asked of you here.
I would love if you can help me to improve... :)
The indentation needs to be fixed on your source code, also you don't need the ending `?&gt;` But really good job, thanks for this.
It provides guidance on what are important concepts, and is (for many people) faster than trying to teach yourself. A lot of our jobs, especially more entry-level ones, also tend to expect having gone through some level of formal education, and coding boot camps are a good way to get that. That said, I’ve interviewed lots of people that have done them and have seen very mixed results. I expect the people that did them could have also done well independently if they had a good starting point and direction. 
I've got a couple examples of potential side effects. - it's very possible that multiple parts of your application are acting on different instances of the same data model at any given time - the Model class depends heavily on magic methods that can trip you up behind the scenes. Extending Eloquent is a mess when it comes time to upgrade. Backwards incompatible changes are common with his releases. Depending on extending Model is a huge risk. A big point (of mine) that you're article mentioned is that data mapper is mapping a table to a class. This is correct in a general sense but it is also incorrect. It is more-so mapping query results to a single class. IMO Where Eloquent really falls short is its inability to handle complex polymorphic relationships. It is difficult to argue for extension and OOP practices when Eloquent fails to effectively support polymorphism. It doesn't provide STI and eager loading extended relationships on polymorphic relationships must be done by hand. Eloquent has been good enough for small applications but has fallen short of my expectations when creating complex systems.
Whatever makes you feel better. C/C++ and Java are as well. The article outlines more realistic reasons. 
Thanks for the feedback, Indentation updated... Can you please explain a bit, why we skip the ending ?&gt; 
This looks a lot more like the Strategy pattern
its just the main job is biased on googling and searching even if you master you will still look for that function name check a documentation or a github package to get it working i was shocked to hear the prices of these coding bootcamps 
In files containing php code only, it's preferred practice to skip the ending ?&gt; to avoid sending stuff before headers by mistake
maybe i don't understand the word parse mean because english is not my mother tongue ?
ahan... Thanks man (Y)
Parse is a programming term, we are hiring people from outside our country too and english and programming english is a requirement.
rate*
Strategy Pattern is more likely to select one from multiple options.... and Decorator Pattern decorates our class with additional features.
I don't know since I did not write that line of code. Ask meltea :-)
But I did not do the first test and I am not from US. :D
This is actually an adaptation of the JS adaptation of Clean Code. And over the years, the open source community has injected their own thoughts into it -- sometimes for the better, sometimes not. Which means parts of this adaption didn't come from Martin's Clean Code, parts of Martin's Clean Code aren't in this adaptation, and most code examples don't resemble Martin's. Personally, I recommend you avoid this game of telephone and just read the original book.
after a bit search i got it that you want every element (parsed) to be variable and the second argument is what separates a variable from another and str_getcsv is the function i think 
Great, any chance you're in central Europe?
Correct.
My point was that people upgrading need to be aware that Laravel does not follow semver. 
Aye, but "popularity" and "skill of staff on hand" are two different categories.
Oh my sweet summer child.
Thank you.
yes, although I do find they are sometimes (often?) correlated. the staff may also be more willing to get up to speed on something that has more popularity around it (and learning from a larger community is also easier as well). You didn't use this phrase but "right tool for the right job" gets thrown about a lot, usually without much emphasis put on the human aspect of the equation.
Good solutions :) Obviously you're using some of the nice functions provided by PHP, but I wasn't even wanting them to do that, but most of them could barely do loops. It was truly shocking.
PHP is popular there probably because of cheap shared hosting plans. Android because the iPhones are expensive.
I agree. I would even add that the code examples are not that clean or SOLID. Unclear naming, instantiation in weird places, missing typehints/lack of interfaces...
I'll acknowledge that popularity of a language has correlation with availability of expertise and support, but that's not always the case (e.g., Go). You make good points.
&gt; You make good points. I try...
No, searching for documentation is a facilitator, not a function. The main function is problem solving. Problem solving can be taught, but it's rarely the focus of bootcamps or Internet courses. Only universities devote appreciable time to the development of problem solving ability.
&gt; Personally, I recommend you avoid this game of telephone and just read the original book. I urge programmers, especially new ones, not to discredit OPs post because it would be better to "just read the original book". It is still a good primer for adopting good principles. 
If you really want to learn Clean Code and SOLID programming just read the following books: * The Pragmatic Programmer * Clean Code(The one mention in this topic) Read the books in the above order once the last one refers several times to the former one. Now that you have read both books, get back to this one and write down the differences. 
Or just what is this type of Ajax chain called so I can more effectively search for this. 
/r/phphelp
thanks 
As all Selenium alternatives tool this one looks absolutely unreliable. It produces generated JS code which is really hard to maintain.
Would you care to elaborate what you think is not part of Martin's Clean Code Code and what's missing ? I think the repo owner would gladly accept any PR providing improvements if you find time for it. This an ongoing effort to allow quick and easy access about the philosophy. I agree everyone should read the book and the repo content is far from perfect but it's a start and everything making a developer writing "better code" in our php ecosystem should be encouraged imo. 
The DateTime class.
DateTime is not part of the SPL.
SplFileObject for object oriented CSV file manipulation
SplObjectStorage. It's a set and a map, all in one.
Besides taylor and joe Ferguson idk anyone else 
Not exactly. You'll most likely need to use javascript to open the download in a new window (target=_ blank) and then redirect the original page to the url using window.location.
$20 per 1,000,000 characters
Somewhat disagree with the example given for *Function arguments (2 or fewer ideally)* section. Wrapping that config as an object is good, but you are not doing anything to actually enforce the object's integrity. Presumably, something like the `title` property is required, but the way you've constructed this example, someone could pass an invalid `MenuConfig` object into the function, where it would blow up (or give buggy results) when used, unless you added a bunch of validation to that function. But validation shouldn't really be a concern of that function since that's what the `MenuConfig` type contract is meant to do. Thus that validation belongs in the value object itself. That means the `MenuConfig` value object's constructor should take its required fields as arguments. If that means more than 2, so be it. The advantages of having an explicitly defined, self-validating value object outweighs the minor cognitive cost of a lot of function arguments. 
&gt; SplFileObject for object oriented CSV file manipulation I'm somewhat uncertain why I need this, it's just the veneer of OOP without the value of it. This, unfortunately, applies to many of the built-in PHP objects. 
&gt; But I have a feeling it has zero to do with PHP as language and 100% to do with the fact that the PHP documentation is translated into lots of languages. The only effect PHP's documentation translation has for me is that I always have to click "English" on top when I load a doc page. Translations are incomplete, heavily oudated, and in some cases *show English content, but old*, just for extra confusion.
It's a scam for the gullible and desperate. Just like you can't go on a one-week "gym camp" and come out a body-builder, you can't expect to go on a programming bootcamp and expect to come out a programmer. Anyone with basic Googling skills can get their initial pointers, information and resources online. Free. From that point on its months and years of practice that do the trick. But hey, them "wealthy guys" (as in, a middle-class US citizen, not really wealthy) have some money. And there are plenty of other folks looking to take that money. So they make bootcamps!
Because they don't care. That's literally the answer. I've seen this especially in the "WordPress industry" so to speak. It's as if the phrase "I don't give a f\*\*k" could be converted into a business, WordPress sites would be that business.
Please try the phphelp subreddit for support on PHP issues. Please also clarify if you have issues with properly formatting or populating data with PHP or that the problem is with rendering results after it has successfully populated your data structure. Depending on your answer, a different and more specialised forum for this question likely exists.
One thing I fail to see is the use case for this. Even during a deployment or scheduled task in a framework, your code probably doesn't have the rights to do this. The point where you have to elevate this is outside of PHP, which makes the whole thing superfluous again. So a couple of good use cases would add real value to your readme, as well as the description of this post.
Yet,... isn't it? `DateTime` is a part of PHP core *(the docs say that)*. Isn't that - by definition - what standard library is? ;P
Not too fussed about having this stuff written in C, but hey, Richard did some amazing work to respect reflection and type-checking on the API, plus we really need UUIDs :+1:
You’re too kind. ☺️ I will change it to be PHP, if they functionality ever lands in core to do so.
I love this proposal!
The question made me wonder what I use from SPL, so I [went here and checked what it has](http://php.net/manual/en/book.spl.php). And frankly looks like I'm not using a lot of it: - Incidental uses of `new RecursiveIterator(new RecursiveDirectoryIterator(...))`. - Incidental uses of `SplObjectStorage ` and `spl_object_hash`. - I'm using `spl_autoload_register` because `__autoload` was deprecated and doesn't work with Composer. That's it. I think SPL's problem is that the author wanted to add his favorite Java stuff to PHP, without the honest assessment whether it makes sense in PHP and in the same shape and form as it exists in Java. For example, the SPL exception types (which are lifted basically 1:1 from Java)... I see people keep pushing their use, but a lot of them never made sense, their description is a bit comical: &gt; RuntimeException: Exception thrown if an error which can only be found on runtime occurs. Like... which exception is not runtime in PHP? In Java "RuntimeException" is the root type for unchecked Exceptions. In PHP all exceptions are unchecked.
Solid proposal. Looking forward to having this in core.
Good point. Will add some into the readme. I use this mainly for cronjob purpose in my projects. Also there are some checks that are executed for monitoring the server. Or simply complex tasks I have writing some weeks ago for restoring a database backup where I have to stop some services. 
About time we had a standardized API for UUID generation.
Great article! I really feel like I can step up my game now.
This is quite good but you're missing an explanation for the most important bit. The key part of the Decorator pattern is passing instances of your class into each Decorator subclass. It's in the code but you don't explain it at all.
I can see where you're coming from on this, that's not to necessarily say I agree. I will concede there have been one or two occasions where I've thought "this isn't exactly ideal for this particular microtask" - particularly when I had a transactional table; but to be honest the pain (which really is a bit of an exaggeration as it was about 20 minutes of thinking "hmm, how am I going to achieve that?") was low compared to the ease of sorting the simpler bits of the database out. I have on very rare occasion found myself creating methods/static methods to do handle something where I want to dynamically do a bunch of things and it started to feel slightly less than perfect, but as I've mentioned in a couple of other comments elsewhere on the thread, I ended up either abstracting to a class which used the Models to do various bits, (support ticket updater, where lots of things have to happen, for example); but with documentation it still didn't feel particularly painful I'm sure the time will come when I'm building something that is just that tiny bit too complex for the project (whether I realise this before I start or not, of course, remains to be seen) and I may well change my mind on it at the minute. I've been on complex applications and so far haven't had issues, but that's not to say it won't happen in the future!
Matt &gt; you want to make sure you only ever use one specific instance WAT R U DOIN &gt; quick and easy way to do it Matt &gt; Particularly useful in things like Database connections, loggers/debuggers and things like that. STAHP 
Beside the quick an easy tutorial. There should be a notice somewhere that singleton is considered an antipattern 
&gt;I also though it potentially best to avoid something as controversial as my last post about Eloquent and the Single Responsibility Principle &gt;singleton Welp.
Repo is talking about 'function arguments (2 or fewer)', gives an example of how to do it and you talk about the MenuConfig implementation, which is not relevant :D
I could've put a disclaimer in there about the fact that you should almost never do it. I'd prefer this to DI containers though, if I'm honest. There are a couple of use cases I can think of, but they are seriously limited in number
Hey, I'm not advocating them; there are a couple of use cases, I'm not saying you should widely use them for everything (that would be terrible! No arguments there) It's something I was asked to do, and something that has occasional uses; it's not like I've done a quick and easy guide to genocide or anything like that lmao
It would appear something as generic as this is still quite controversial in this channel, whoops!
Huge apologies for not raising this at a more appropriate time, but I've only just noticed your decision to not support generating v1 uuids. One of the things uuids are very well suited for is creating primary keys for database entried - the problem is that random values don't play very nicely with b-trees. A test comparing v1 and v4 uuids (on postgres) shows the latter inserts ~20% slower, and creates an index ~25% bigger than the former. Ok, not the end of the world, but these are columns that are guaranteed to have indices, and likely more than one as they are referenced by FKs. Most of the security concern is surely from including the MAC; using a random multicast MAC is permitted and addresses that concern - so as long as you don't have to avoid leaking any timing data, this should be sufficient? PS. Great work anyway, thanks!
Do you actually understand the problems with singletons? &gt; Particularly useful in things like Database connections, loggers/debuggers and things like that. That above makes me say no, you don't. 
Thanks for your feedback. The insertion slowdown is true, however, how often are you required to insert 100, 1,000, or 1,000,000 million rows in one go? Run a benchmark for randomly selecting your v4 UUIDs from the database, and you should notice that those operations are slightly faster (be sure to use `BINARY(16)` as your format). This is because the randomness is actually a good thing for the tree. Yes, it needs to rebalance during insertion, but the resulting tree is smaller, and thus it is faster to search in it. This is at least true from my observations with MySQL. v1 can be added later if people really have a need for them. I personally only see problems stemming from it and v4 and v5 are far superior.
&gt; I'm not advocating them; Once you said something is "Particularly useful for x" without even touching on the problems they introduce you are doing exactly that: advocating them.
Nobody is actually using Go, just a bunch of people use it in sentences.
There are plenty of problems with them, the same as there are plenty of problems with a lot of things; that's not to say you should never use them
Okay, so let's go with semantics; I'll retract my previous comment and instead say "I'm not advocating their universal usage"
Ok. Can you name the problems. And explain why they wouldn't be problem for: database connections, loggers/debuggers?
We effectively already do. ramsey/uuid. 
Let's see what the article proposes: class MySingleton { private static $instance = null; private function __construct() {} public static function getInstance() { if(is_null(self::$instance)){ self::$instance = new self(); } return self::$instance; } } Too long! class MySingleton { private function __construct() {} static function getInstance() { static $i; return $i ?: $i = new self(); } } Ah, there. Now this is so short, you can make everything singletons. Everything. ------ ^^^^DISCLAIMER: ^^^^I ^^^^shall ^^^^not ^^^^be ^^^^held ^^^^liable ^^^^to ^^^^and ^^^^shall ^^^^not ^^^^accept ^^^^any ^^^^liability, ^^^^obligation ^^^^or ^^^^responsibility ^^^^whatsoever ^^^^for ^^^^any ^^^^loss ^^^^or ^^^^damage ^^^^arising ^^^^from ^^^^your ^^^^reliance ^^^^on ^^^^singletons.
This seems well-thought-out and the class is quite comprehensive. I like how self-contained this feature is, too, so it's a yes vote from me. One nice reason to have this in core is that we could potentially integrate our database layers with it in future. Wouldn't it be nice if grabbing a UUID out of a PostgreSQL database gave you a `UUID` object? (I know, it probably won't happen.)
Does this refer to https://www.reddit.com/r/PHP/comments/6xl2wj/quick_and_easy_singleton/ ? Don't take it so personally: it is a known anti-pattern and you blogged about it without providing any real advantages that aren't the superficial ones described by the pattern "from the book" itself. I do work as a code reviewer daily, so it is pretty much my job to find this stuff and comment on it. On reddit, I try to do it in a relatively joking/silly way: it's not meant twist the knife in the wound.
I didn't say I would show when to do it, just how, which I did...
I have the feeling this came out of your recent post about singletons. Everybody in there as far as I can see judges based on technical merits and nothing more. if you don't tell people the downsides of something you write about it's our duty to make it clear to the community at large. Also don't confuse bias with experience please. If you don't want people discussing things you write maybe not make it public like this?
Hi mate, no not at all; though I do admire your candor (if that's the right word). Someone mentioned to me the heated debates on some of my Reddit threads (someone quite new in the career who I've guided with some of their stuff) They then told me about some times on various sites (GitHub, Stack Overflow, the usual places) where they've been pulled pillar to post by people trying to help - and from what I gather they then ended up in a flame war, but really he was the one who lost out; because he just didn't know what to do From what I gather he's basically given up on the idea of writing anything open source - that's the bit I was unhappy about People commenting and discussing is great, it's what makes (imho) the open source language community stronger than some others. But when it puts a young developer off, that upsets me a touch. Personally, I'm all for a good chat; I like the intellectual fencing of it all :) - I especially like it when it challenges my own perceptions and helps me learn things I perhaps didn't know before, it's one of the reasons I partake in online discussion
I've just replied to ocramius about this - it's not off the back of that thread. I'm keeping this one short just because I've already said basically the same thing above. Completely agree with your point about pointing out the downsides and duty though
"If you don't want people discussing things you write maybe not make it public like this?" - didn't see this bit before Again, I've just said it ocramius' so I don't want to repeat myself too much as it'd be irritating. I love the discussion, it's the reason I post things publicly 
I also didn't discuss when to do it, I just made your version shorter. ------ ^^^^DISCLAIMER: ^^^^I ^^^^shall ^^^^not ^^^^be ^^^^held ^^^^liable ^^^^to ^^^^and ^^^^shall ^^^^not ^^^^accept ^^^^any ^^^^liability, ^^^^obligation ^^^^or ^^^^responsibility ^^^^whatsoever ^^^^for ^^^^any ^^^^loss ^^^^or ^^^^damage ^^^^arising ^^^^from ^^^^your ^^^^reliance ^^^^on ^^^^singletons.
&gt; I also didn't object to when to do it, I just made your version shorter. &gt; Now this is so short, you can make everything singletons. Everything. Kind of looks like you did?
Thanks for clarifying. Your mention of singletons and and the timing of the post threw me off. Sorry for making assumptions.
No need to apologise at all. I can see why the assumption was made, and that's entirely rational/logical
Thanks so much for the positive words. :)
Not sure if giving a commentary on a conversation (literal or hypothetical), or directly telling me to go hell If the latter, not sure why, but fair enough; I'll save you a bunk haha :)
Something is making c/cpp more popular. I gave you my idea why. It doesn't have to be true. But if some TIOBE said c/cpp is more popular than php then there must be some logical reason behind it.
Ah gotcha. In that case, I absolutely agree with your sentiment; and have said as much previously. I've also watched people storm out in fantastic, almost fabulous, fashions following similar conversations. Entertaining if not for the tone of the previous conversation
&gt; Wouldn't it be nice if grabbing a `UUID` out of a PostgreSQL database gave you a UUID object? Send a patch do `doctrine/dbal`? ;-)
&gt; I'd prefer this to DI containers though, if I'm honest. Why? That makes it harder to test/mock and makes your code really tightly coupled.
Yes, I am.
This made me chuckle.
I couldn't disagree more. But that's probably my own bias, everyone I've ever seen using DI containers has done so that makes adding any kind of class anywhere, or modifying any functionality a real ballache. And everything ended up even more tightly coupled than it would've been before. I'm an advocate of "use the thing(s) you need, and don't write terrible code" - I also think that, to be honest, ease-of-testing isn't a good enough reason to tie something to you code so hard that maintaining it is excruciatingly expensive (in terms of time/human resource)
No, the nomenclature is a bit confusing. The PHP core has an extension called "Standard PHP Library" (SPL) that contains a number of classes, interfaces, and functions for things like various data structures, iteration, file handling, and autoloading. DateTime and the SPL are separate pieces of the core -- this is in contrast to other languages like Python where the Python Standard Library covers almost all of the basic functionality -- `time`, `os`, `math`, etc... 
Absolutely, it's when it ends up just an argument or a monologue of one person telling someone else why they're, essentially wrong/stupid that it just becomes pointless.
Interesting article. I don't think it's exhaustive by any means, but definitely a good set of steps for someone who wants to up their game
What are the reasons to vote for "no"? 
Good article and it cover Facading really quite well, but Shadowhand's earlier comment is right; SOLID principles are a good thing to subscribe to in order to end up with maintainable code. This assume you, or your organisation, subscribe to these principles as not all do
It is relevant, because it's a strawman example otherwise. Using one bad design as an example for how to avoid another defeats the purpose of the example :D
The main argument of those who vote no is that they think this should not be a class but rater procedural functions that return strings. The following is from today: https://externals.io/message/100347
I'm the worst programmer period. I just skim stack overflow for what I generally need and start copy/pasting code over until it works. Very rarely do I take the time to understand how it works.
Yeah of course, but it's not *official*. But yeah Ramsey's package is basically the defacto standard.
&gt; everyone I've ever seen using DI containers has done so that makes adding any kind of class anywhere Adding the class you are injecting to a config file and then just passing it to the constructor is a real ballache? &gt; And everything ended up even more tightly coupled than it would've been before. I didn't know when I passed my Request class to my controller, I can switch it out easily for any class that adheres to interface. Same thing with my database/cache classes or my loggers. That's the beauty of DI and interfaces. There are PSR standards that are making switching things in and out super simple (http://www.php-fig.org/psr/). &gt; ease-of-testing Yeah but if you write your code well, if you change something, but everything still adheres to interface, you don't have to update your code. &gt; so hard that maintaining it is excruciatingly expensive But that's a benefit of testing. I'm free to change any file and I know right away if what I did breaks anything else in my code.
When it comes to speed I am the worst, I am a slow ass developer. 
That is called future management level programming. You will be a team lead some day.
Pssh, I don't do it as a job. Pretty sure if I did I would have already committed suicide.
Please don't think I don't love automated testing, I do; I just don't see the automation as a good enough reason (on its own) to justify the container &gt; injecting to a config file I know this is possible, just in practicality it's not how it's been implemented in the couple of places I've been that use the containers &gt; PSR standards that are making switching things in and out super simple I agree with you; unfortunately I find people are often too tempted to base their dependencies on concrete classes, and it becomes a bit more problematic than (I know) it should be 
I don't know how to do anything else... if I didn't have programming I would kill myself. 
Well I'm merely suggesting a potential possibility. I'm not suggesting it should be done. ------ ^^^^DISCLAIMER: ^^^^I ^^^^shall ^^^^not ^^^^be ^^^^held ^^^^liable ^^^^to ^^^^and ^^^^shall ^^^^not ^^^^accept ^^^^any ^^^^liability, ^^^^obligation ^^^^or ^^^^responsibility ^^^^whatsoever ^^^^for ^^^^any ^^^^loss ^^^^or ^^^^damage ^^^^arising ^^^^from ^^^^your ^^^^reliance ^^^^on ^^^^singletons.
I merely suggested Singletons could be useful, and where they could be useful, I didn't say it should be done either :P
Programming, for me, is a hobby that comes around maybe once or twice a year. By the time I'm up for it again I'll have to relearn the basics.
No upvotes for sarcasm? Oh well...
That's great! ------ ^^^^DISCLAIMER: ^^^^I ^^^^shall ^^^^not ^^^^be ^^^^held ^^^^liable ^^^^to ^^^^and ^^^^shall ^^^^not ^^^^accept ^^^^any ^^^^liability, ^^^^obligation ^^^^or ^^^^responsibility ^^^^whatsoever ^^^^for ^^^^any ^^^^loss ^^^^or ^^^^damage ^^^^arising ^^^^from ^^^^your ^^^^reliance ^^^^on ^^^^singletons.
Singletons are an anti-pattern? What a strange concept. If for example I only need one database connection to process a request then why on earth would I create a new connection each time I needed one? When only one instance of a class is needed then it makes perfect sense to only only create one. It is possible that you are talking about globally accessible singletons. Or perhaps singletons accessible through a service locator. In which case I would more or less agree with the anti-pattern statement. But singletons themselves? Perfectly fine.
&gt; No operator overloading, instead the standard PHP comparison for objects is used So if I do `UUID::fromBinary("\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1") === UUID::fromBinary("\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1")` I will get `true`? How can this be implemented in PHP?
Interesting - I just tried a benchmark on postgres, and index lookups on v4 took 50% longer than v1. Strange that two DBs using presumably very similar algorithms would exhibit such different behaviour. Of course I'm reluctant to place too much trust in quickly hacked-together microbenchmarks. FYI, my methodology was to create two tables with a single indexed uuid column (using uuid type, which is stored as 128 bits), populated with 2M rows. I then timed a self-join on each table, having "persuaded" the query planner to execute that as a nested loop with index lookups - resulting in 2M index scans covering the entire index. BUT as you say, this can easily be changed later if deemed important, so is in no way a blocker to getting this version in.
**SplFileObject and a stream resource are not interchangeable.** Anything done using SplFileObject could be achieved using a stream resource and a your own OOP implementation but the reverse is not true. The file SplFileObject can be very useful, it's file implementation of SplIterator is v. useful.
No, this creates two different objects which are **not identical**. However, the two objects are **equal**, and that is exactly how you should compare value objects, with the equality operator: assert(UUID::fromBinary("\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1") == UUID::fromBinary("\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1")); Note that it would be possible to implement it that the two instances are also always identical. Simply via the fly-weight pattern, however, that would be totally counter productive.
The comparison that we made back than was between `BIGINT` and `BINARY(16)`, not between UUIDv1 and UUIDv4. That could explain things.
[SplDoublyLinkedList](http://php.net/manual/en/class.spldoublylinkedlist.php), so much usefulness.
I can't stand these procedural functions that do wayy to much, like how the old mysql functions did... I much prefer class, like how Reflection is done, it is very clear and makes auto-complete such a breeze as you don't need to remember anything but the class name.
I've no idea what you said. ¯\\\_(ツ)_/¯
I wholeheartedly agree with you. The ability to *discover* the available possibilities through a well designed API beats the procedural approach, always, hands down.
Value objects are undervalued and really help to enforce required arguments. If a function requires 5 arguments and will fail without them, wrap them in a value object which will throw an exception when it is created if this values are not there. Then you can simply type hint the value object where the 5 arguments are required.
I have heard a lot of PHP devs say they can’t be bothered reading java books on best practise. Anything that makes learning these lessons easier should be welcomed. I for one think this is a great idea. If people stopped complaining about small issues and perhaps suggested improvements then this would eventually end up as a great resource for php devs wanting to become better at their trade. Edit: PHP not PHO.
Why does it boast about there being no reason to implement it in C despite the fact that it's implemented in C?
I see zero reason why this should be in the core. It's easy enough to do `composer require ramsey/uuid` if you need a `uuid`. Things that can be done in userland don't need to be in the core (unless performance is a concern, then pecl is the perfect place). Also, I think having it in core would encourage people doing things you shouldn't be doing, like using UUIDs as primary keys when you actually have no good reason to do so.
There were lots of arguments back then when I started the discussion that there are no reasons to implement it in C, and that it rather should be done in PHP. I added this section to account for all the critiques. It is possible to implement this in PHP, heck I did for the polyfills, however, it is not possible to have this in the standard module in any other language than C. Well, at least not now.
There is currently no replacement for `uniqid`, and that one is really bad. This RFC is also meant to establish a real alternative that works, and is proofed to work. See *Future Scope* of the RFC.
You'd be very kind to share some of the usefulness of a linked list in the context of PHP web apps. 
I have web app in which I have a queue of sales to be shipped out, my client sometimes needs to send sales in a certain order (send Mr Bloggs after Mrs Jones) and sometimes in the order they come into his shop. Using a doubly linked list I can insert an item at the end of a queue, I can insert the item at the beginning of the queue or even place it after/before any other item, using the SplLinkedList object means I don't have to do as much work to implement. Another common use is message queues.
&gt; just in practicality it's not how it's been implemented in the couple of places I've been Sounds like you're working with bad developers and they are doing it wrong. It's literally how Symfony, other frameworks and other containers do it. I'm not even sure I could figure out another way to do it without some super hacky workaround.
So I guess those are more scenarios for a persistent PHP process, less for a PHP script serving web pages from FCGI/mod_php. I thought it's something like this :) In those scenarios there are many interesting uses of a linked list indeed. Thanks for sharing.
Mm...I think it can do the all in one package wrapper. And it also a lazy package to someone who want to use these APIs directly.
Okay, sorry I should have been clearer. So lets say I want to stream a csv file, I could do this $handle = fopen(base_path() . '/database/data/sales_order_items_data.csv', 'r'); if ($handle) { $headers = fgetcsv($handle); while (($line = fgetcsv($handle)) !== false) { ///do something } } And that's fine, but no lets say I only want just one entry, Well I could spend some time, writing that in and I could make it nice OR I could just do this $file = new SplFileObject(base_path() . '/database/data/sales_order_items_data.csv'); $file-&gt;setFlags(SplFileObject::READ_CSV); $file-&gt;seek(210); dump($file-&gt;current()); //outputs an array from line 210 The SPLIterator object allows this functionality.
Actually, some of the discussions on this topic have reminded me the best thing about the SPL, it all links up together well, SPLIterator is used by multiple othe SPL classes, SPLFileObject can be used in a SPLDoublyLinkedList or SPLObjectStorage so you could quickly build a file store. The list goes on of other useful remixes :)
Whilst it's not in my nature to criticise someone else's development, I'm not going to disagree with you on the points you've made there
Well... $file = fopen(base_path() . '/database/data/sales_order_items_data.csv'); for ($i = 0; $i &lt; 210 &amp;&amp; $line = fgetcsv($file); $i++); dump($line); //outputs an array from line 210 Now, you might say, somewhat fairly, "that's an odd looking loop". But I can say the same, "that's an odd flag and functionality to have on a general-purpose file object". In a proper OOP design you wouldn't fuse the functionality of generic file I/O with CSV reading. It's just not extensible, not composable, and it's not expected too, which results in very low discoverability (*who* would know to look for a flag like this? I'm guessing no one). Ironically the procedural API of PHP does a better job at being SOLID and discoverable than SPL does. Because I can implement, for example, `fgetxml($file)` and I can immediately use it on any file handle I'm given, and seek to the element I want with a basic `for` loop.
Singleton is a design pattern with a specific implementation. The fact you're colloquially calling something else a "singleton" doesn't make it a "singleton". Whether your particular implementation is bad or good depends on your context and implementation.
I enjoyed the content of your article, but I want to ask an off-topic question to satisfy my own curiosity: my mouse scroll wheel doesn't seem to work on your site; is that by design or is that just happening for me, or...? Just curious :)
I enjoyed the content of your article, but I want to ask an off-topic question to satisfy my own curiosity: my mouse scroll wheel doesn't seem to work on your site; is that by design or is that just happening for me, or...? Just curious :)
No good reason to use them as primary keys. Can you support that claim please?
That's a new one on me, it seems to work fine on mine and nobody else has mentioned it; so I can only assume it's specific to your machine/browser. Also, thanks for the compliment re: the content of the article :)
😂 
&gt; Just imagine how much impact securing Wordpress could have on the wider Web. The only way to do this is to encrypt its source and lose the key.
Well to be fair you don't **have** to use the flag you can just $file = new SplFileObject(base_path() . '/database/data/sales_order_items_data.csv'); $file-&gt;seek(210); dump($file-&gt;fgetscsv()); I got used to using the flag because it allows me to set keep the same implementation of using '$file-&gt;current()' on files of different types. And sorry I missed one of your key issues, you said &gt;it's just the veneer of OOP without the value of it at the beginning and to an extent the first part is true, in fact that is what I was trying to answer when I said &gt;Anything done using SplFileObject could be achieved using a stream resource and a your own OOP implementation but the reverse is not true. You absolutely can argue that SplFileObject is a OOP implementation of standard php functions, and that is because **that's exactly what it is**, in fact so are all of the others. If I may quote the documentation &gt;The Standard PHP Library (SPL) is a collection of interfaces and classes that are meant to solve common problems. File seeking, iteration and reading multiple types of file with a single implementation are extremely common problems. 
Well in that instance there is a web front end which accesses the list, allowing my client to remotely send quick shipping orders to the guys in the warehouse which go to the top of the queue. In the original implementation that I did the queue was managed on the web server and accessed from the warehouse via the same site. Now I have the queue implemented as a separate api service, my client has tablets with scanners that access the api and a hook to update the sale information at every queue event. That got over-explainey, sorry
[removed]
Despite the populist fashion trend to label Singleton an anti-pattern, I personally don't see it that way. The pattern itself is not the "anti-pattern", more so than people's misguided abuse of the pattern. A Singleton is simply a tool in a programmer's toolbox. Like every other design pattern, there is a right way and a wrong way to use/abuse it. For Singletons, you should use it very judiciously. It is also very important to understand why you need to use it, as well as what consequences you take on from using it. Why would you use a Singleton? Everyone seems to understand the "why": because we only need on instance of something. But, I believe that's where everything starts breaking down. What constitutes a _good reason_ for using a Singleton ("Nothing!" Ha! Beat you to it… ;))? Well, anything that would be considered _expensive_ to instantiate (Duh). The hard part that a lot of people gloss over is what is considered expensive. Unfortunately, there is no universal answer to that question. This is something that is both system and application dependent, and probably should be discussed with fellow teammates. "Databases" are not always expensive to connect to (especially if they are on the same network). The same can be said for caching layers, filesystems, etc. But, they could be. Again, it really depends on the working environment. The biggest argument I've seen against Singletons has to do with their testability. And frankly, it's a damn good argument. The only safe way to test a Singleton is to run tests using separate processes, so that each test gets a fresh copy of the Singleton. Or, you could deviate from the Singleton pattern and add a way to reset it–but then again, it's no longer a Singleton. Lastly, I'd like to point out that Singletons are not limited to objects. If you had a 100mb file to read into memory, you'd probably take care to only do it once, and then pass around a single reference to said file (maybe a file handle??). If you stop to think about it, you might realize sometimes you use Singletons more than you'd like to admit. Do what is best for your situation. Just know what you're doing when you do it. And don't do it/avoid it just because the hive-mind says to… we are all (hopefully) smart enough to decide our own tools. 
^ This. So much this.