I didn't know about it :)
If it works it ain't broken.
if you get to the Q&amp;A part, you'll see that he still has the same stance, though he accepts the fact that they are needed to get things done quickly. he just wants frameworks to be faster, and be purpose-specific, or at least can be made to be purpose-specific.
There's no connection between PHP and bad programmers. I worked with PHP for the last 15 years (still working), and a have met lots of lots of programmers in this period, who work with PHP and other languages. I have only one conclusion regarding this subject: bad programmers will stay bad programmers no matter what language they are using. They will sometimes tell you an excuse like "If i would have written this component in Ruby it would have less bugs". that's a lie, bad programmers use the PHP language to cover their poor skills of writing code, because it's easy to attack PHP, because of PHP historic path. Whoever works with PHP on everyday basis knows that today with versions 5.5 and 5.6 (soon) especially it became one of the most powerful, fast (compared to interpreted languages) and offers most advance and modern language features, the kind many other languages can only dream. Every language has it's ugly things, C++, Java, JS, you even can find stupid things even in Haskell and Scala.
According to the first part of that talk, PHP started out as a template extension for C (we've all heard this before). So, if you think about it, pushing PHP as far as it is today is actually pretty amazing. It would be like if Twig became it's own programming language today.
Watch the QA part of the talk (last 15 min) and you'll see that he's asked that question "What do you think of frameworks". His answer was "They all suck!" and then went on to say way. Very good points he makes there that framework devs could learn from.
Eh, if I have to spend time googling and learning a bunch of functions, and figuring out why I'm unexpectedly getting output buffering errors because of how Wordpress dumps its data to a view, then it's kinda broken. Not totally broken, but kinda. To be fair, the problem with Wordpress isn't Wordpress, it's clients who think Wordpress is Drupal and insist it be used, thereby requiring you to muck around in its code to write custom content types and add conditional sidebar/widget logic. That's when life gets miserable. If you want a blog that you can slap a theme onto, Wordpress is great.
The reason I don't take PHP seriously is that it is stuck with this backwards compatibility crap, making you able to do stupid things in stupid ways. There is too much cruft in the language and I don't want to deal with other people's code because of it. Also, it fails it's own unit tests.
&gt; Playing with frameworks is just the first step of many in learning a new skill. It's one step, sure. But beware: an amateur building an app with a framework will still make amateur mistakes that have to be corrected later.
I've been interested in replacing Perl in my organization with Ruby but I was unsure on the Gem availability. That and we have a few developers who can blow through Perl code in seconds. I tend to write my Perl code in a readable fashion and try to avoid the terribly difficult to follow aspects.
I use phped sometimes on windows. It works and feels like a windows application. Php storm is good but the keyboard commands feel alien to me.
A good carpenter can build an awesome house with [poor tools](http://i.imgur.com/82Mip6e.jpg) when he has to. A bad carpenter can't do it with the best tools, and with poor tools it's a shit-show. As craftsmen, we don't always get to choose our tools. Sometimes tools are dictated by legacy systems, etc... I spent 10 years writing PHP, because for all it's faults it really was the best way to get a dynamic website up and running for quite a while. The web world has moved on, tools have improved. I would never choose PHP as my language of choice for a new project. However I have worked on many great PHP projects in my time. I'm out of PHP now, and I know the language has evolved, but it still carries many of the same warts it always did. It's a tool in my box, but it's definitely getting rusty down there in the bottom drawer ... mouldering there next to Classic ASP.
I am in between learning ruby and python. I have done a little bit of both but I am not sure which one I should go ahead and go for it. One thing is for sure, Ruby was much more easier to pick up.
I find that most people who hate on php have only worked on new big projects. Anything that is currently handling tens or hundreds of times the scale it handled initially and is 5-10 years old will have older and less cool ways of doing things built in. Oh, this isn't as cool as django ported to ruby run on top of go in a grails container piped through node or something ( I know this is ridiculous, it is intentionally so )? It has scaled to handle millions of dollars in transactions and can be run on commodity hardware in almost any environment and sysadmined and/or programmed by a huge talent base across the globe, giving it vendor and platform independence. You know, so there is that.
I used to think that way, but I realized that it's really not that hard to write conditional PHP code or custom post types, than mucking around with the tangled mess that is Drupal's Views/Fields/Field Collections/Blocks/etc. And frankly, ACF &gt; Drupal fields, even if it does cost a couple of bucks. I built relatively large (several dozens of different templates/areas) sites in both Drupal and Wordpress, and this former Drupal fanboy is starting to get tired of their shit. I hate having to override seven different templates to change the markup of a single page, and then giving up because it requires overriding some convoluted theme function that I don't want to mess with. I hate installing twenty different modules to achieve basic functionality, and then start messing with patching them, because they're alpha-level code. And Wordpress' API is pile of crap, but Drupal's API is a haunted Escher painting. And when you think you kinda, sorta understand it, they change the architecture again. I really wish Drupal moves from attempting to give non-programmers the sort-of, kind-of ability to build a complex site, to a simpler PHP code + templates sort of model. Until then, I'll keep returning to Wordpress, as thoroughly shitty and buggy as it is. 
Thanks for the input. Yes, I had a close look at the work you'd already started and knowing how stacked you are on a load of other features thought we could try and crowdsource some sane APIs since this making it into the core is probably a while off. We're trying to start building some comprehensive tests at the moment, the array ones are in progress here: https://github.com/rossriley/php-scalar-objects/blob/master/tests/ArrayHandlerTest.php I agree about the basic number operators, add, minus etc, that was just chucked together as a quick example and there's already a few issues raised to remove it. I was kind of hoping that this clean slate might be an opportunity to be stricter with type checking so that we can have a more unified API, doing it the old style is as simple as: $a = "123"; $a-&gt;toInt()-&gt;pow(4) But saying that if it' too big a step to get it into the core then we can let that go. 
PHP takes a lot of heat because it has weak points. These are weak points that make the programming language more dangerous; not less useful. If you know what they are and code accordingly, you should never have a problem.
&lt;!-- --&gt; or // or /* */ would be my guess
Um, this is just a link to the store page for a book? No thanks.
&gt; Java/JavaScript scalars are objects Can't speak for Java, but in JS they are not objects -- they're simply converted to objects when you attempt to use them like objects. Small difference really, but it does make a difference. This is true for strings, numbers, and bools; [here's a relevant MDN doc explaining it](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String): &gt; String literals (denoted by double or single quotes) and strings returned from String calls in a non-constructor context (i.e., without using the new keyword) are primitive strings. JavaScript automatically converts primitives to String objects, so that it's possible to use String object methods for primitive strings. In contexts where a method is to be invoked on a primitive string or a property lookup occurs, JavaScript will automatically wrap the string primitive and call the method or perform the property lookup.
What he's not telling you is that operations like this never exist solely using php. There's a very good chance they're using a variety of languages and technologies to make this happen. Not to detract here. PHP is more useful than its critics give it credit for, but if you're only using PHP in a complicated project you're probably doing it wrong.
I don't think he's trying to say "this is a problem!". What he's attempting to do is to shed some light on why things are the way they are. Rasmus is a C guy who has an obsession with performance, and what he did in PHP reflects that.
Programming language debates aside, it's too bad MailChip never open sourced their framework. &gt; We’ve built a framework for developing applications in PHP specifically designed to allow for fast innovation in the high-load, high-performance environment we live in every day while still keeping the API extremely simple to deal with. This isn’t your grandfather’s PHP, or even your slightly older brother’s. I can say without doubt that it is the most sophisticated framework for this environment that I’ve heard of except for perhaps what Facebook uses. Our architecture is heavily sharded, fast, and scalable to handle the absurd amount of growth we’ve had in the last few years. This blog post is from 2010, I wonder if they'd still say that compared to modern PHP frameworks.
Has anyone used both Doctrine and Eloquent fairly extensively? How do they compare, especially for complex queries and ensuring eager/lazy loading? After using CakePHP Models for a few projects I'd rather not go back to the active record pattern and having to create complex queries with long function chains/arrays. I like Doctrine's DQL for that, though it has some limitations.
But are they really "weak" points? If a mom-and-pop shop wants a quick website built, PHP is an awesome choice. If they don't really need all the cruft of OOP, MVC, etc that makes code management better in larger projects, they can easily get a 10 page website built in Drupal or Wordpress in a few hours with a more or less already-developed theme.
It would be nice to have a new `getDebugInfo` method on the `Exception` class as well.
Absolutely great tool! Longest post title I think ever?! :p
&gt; Has anyone tried going all out with their dependency injection? The entire [Aura](http://auraphp.com) project is "all DI all the time." As with all things, there are tradeoffs to be managed. I attended the same presentation as /u/chris_burnham and I recall thinking at the time that the *container* should not be managing factories in quite that way. Instead, I advise creating your own factory classes and injecting those. At least then you can type hint the injection, instead of depending on a generic callable. We talk about this a little in the [Aura.Di "factories" section](https://github.com/auraphp/Aura.Di#factories-and-dependency-fulfillment) of the readme file.
Would be very happy to take suggestions on that; I am clearly not a graphic designer. If you do consulting perhaps we can arrange something. Also, I'm glad that's the only thing you felt the need to complain about. ;-)
It looks like a really nice tool, but I normally use [GenerateData.com](http://www.generatedata.com/#generator) 
Oh, I dunno, you can use Python, Perl just seems more natural to the command-line to me.
Any idea if the PHP equivalent would work the same way, or are they objects on initialization?
Roughly, yes. Why don't you [take a look]( https://github.com/fluxbb/fluxbb )?
Why does it have its own "autoload.php" file?
I've used Vagrant before, briefly, but didn't have something quite this complete back when I tried it out. This is awesome! I'm not entirely sure what the workflow I'll use will look like, so I need to do a bit of exploring, but I appreciate the tips!
+1 for Faker, one of the most generally useful tools around.
Dammit I shall be using that legs analogy all the time from now on. 
Also https://github.com/nelmio/alice . I wish I had seen this a few weeks ago.
Mostly working in Ruby ... some python.
Mostly working in Ruby ... some python.
*"How do you deploy your applications?"* and *"What other options do I have?" (excluding git)* are two tricky questions, as you can tell most of us (who are answering) use git for this. In my particular case, I use git to push directly into the test server. After any needed tests go green, the deployment process is made using a `git-shell-commands` shell and hooks to save the current state of the live server and merge any changes from the test server. I'm not sure but the bitterness you got from git might be from the fact it does not couple as smoothly under windows as it does under *nix systems. I'm on a mac, just open a terminal and enjoy running two or three commands to know the status of my repo, saving changes or undoing. Bonus joy when you can see those changes in a task manager like github.
I'm leaving these posts here: http://kunststube.net/encoding/ http://kunststube.net/frontback/ **TL;DR:** UTF-8 is fully backwards compatible with ASCII (that's what PHP uses internally). Also, even with using ASCII only, you're still fine storing cyrillic letters, Chinese characters and so on. PHP handles them fine, you only need mbstring stuff for converting between encodings / making sure it's the right encoding (the latter is unnecessary if you know your application handles UTF-8 consistently). Just heed these two points: 1. Never, ever, mix UTF-8 with other multi-byte encodings, like BIG5 or JIT. Horrible stuff happens. Code Points get messed up. You can restore, but only if you know what exactly happened. 2. Don't do stuff like shortening strings or doing substring operations, since you could chunk a multi-byte character in parts (not *that* terrible, but you get some invalid code points). If you ever must do stuff like that, use [proven libraries](https://github.com/facebook/libphutil/blob/master/src/utils/utf8.php). --- Still, a few points from that website apply. Do configure your editor to use UTF-8, and set the right headers and meta-tags. Ensuring your DB table collation &amp; connection is a variant of UTF-8 doesn't hurt too, though do research on that, since some do differ from each other.
So, I was interested enough in this to go ahead and install your scalar_objects extension, and everything is working ok with the tests passing and all, but when I try to duplicate the test output in `php -a` or `boris`, I get `Call to member function pop() on a non-object`. Is the extension written in such a way that it won't work in user land code, just in the tests? I tried debugging to figure it out, but got lost in junit. fml
MasterCard's have their first digit as a 5 Also, 4485480221084675 isn't a valid number.
That particular forum software looks rife with SQL injection vectors. No prepared statements? EDIT: PHP4 compatibility. . .I see. . .
Forum software is kind of a specific variation of the standard "CRUD" (Create/Read/Update/Delete) design. It tends to focus on the create/read part, not so much the update/delete. It's relatively easy to build a forum ([I've done it](http://wtboard.com)), but it helps to [pay attention to best practices](http://phptherightway.com). Forum software is some of the most attacked/hacked software on the planet. So, to answer the question "How is forum software made?", the industry standard appears to be ... "Poorly".
I know what you mean. I did WordPress development for several years, and thought I hated it so much, until I moved into a Drupal heavy position, now I hate Drupal much more. I still don't like WordPress though, and while I realize the utility of a CMS for somebody with no Dev skills or an organization that needs a Publication workflow, many if not most projects don't need a CMS at all (IMO, anyway). I'm a huge fan of static sites when I can. When dynamic sites are necessary, simple, lightweight frameworks are just fine (and the same goes, IMO with other languages - I prefer Flask over Django for instance). When doing a cool App, why not go the SPA route? *At my current job, one team is using Drupal as a RESTful API which has caused and is causing numerous delays. They could have been done in half the time (or greater) with a better toolset better suited to their needs. I really hate the "Everything looks like a Nail" problem that so many CMS fanboys tend to develop. This project has not only a Web interface (which is going to be a SPA anyway), but an android app and iOS app interfacing with it as well. 
Those 2 links are great! Thank you.
I'm sure many of you have already heard of this, but I didn't see it was posted here previously. The project is just about a year old, and has come up with some pretty clever middlewares (code between the incoming request and your application response that can act on the request and mutate the response). It's pretty useful, and given the widespread adoption of Symfony's HttpKernel among PHP projects, you can use these middlewares in a lot of places. Laravel, Drupal, Silex, Symfony and hopefully soon in Joomla Framework based applications.
Likely you just haven't loaded the extension using the other executable (different ini file maybe?) You could try to explicitly load it using `php -dextension=/path/to/scalar_objects/modules/scalar_objects.so -a`.
ty
I don't think so, but I gave it a shot, and it confirmed it was loaded: `Module 'scalar_objects' already loaded` Also, `extension_loaded('scalar_objects')` returns true. I'll have to play with this some more. I'm not really sure what's going on. It's like it's not registering the handler or something, I don't know.
ty, much appreciated
thanks!
I don't disagree with you that the fact that it's a one man show COULD be off-putting. That's about the only thing in that list that really has any merit. But let's step back and look at how far Laravel has come under it's current working strategy. Perhaps a web framework of this size is possible for one man to manage. Especially given the current gen tools that we have now for collaboration. Robbo (Rob Clancy) is notorious for being that way. He's probably the only crude one out of the community... Have you been to /r/programming lately? You'll be lucky to walk away from any comment section there without a "Robbo" reminding you they're better than you. Overall, I have to say I do not agree with your conclusion. Trying to say that Django and Rails will be around for decades simply because they have teams of people directly working on them doesn't mean that a team couldn't step up in Laravel and fork the code in Taylor's absence. But perhaps there doesn't even need to be one. It's not like Taylor doesn't give props to the people who have been directly helping him over the years. To your other point, the framework is definitely production ready.
Maybe a few years ago you could say that, but now WordPress is a generic CMS/SaaS platform with an easy to use hook/action/filter system and well documented API. It can do SPA/REST/whatever...because it's PHP. Drupal and Joomla cannot keep up with WordPress; have you ever wondered why? A tool is not broken simply because you don't understand it or haven't learned it yet.
A lot of people misunderstood Taylor's "one man show" comment, and don't know the context around it. He made that comment during an ongoing discussion about what to name an interface that, when implemented, makes DI Containers interoperable. The opposing viewpoints went round and round, with Taylor leaving one comment there. Then, he tweets, in frustration with that process, "I'm glad Laravel is a one man show". https://github.com/container-interop/container-interop/issues/1
on the other hand its very easy to program bad with php code. 
I met a php and he still thought PHP is the same as in version 4... . I get more amazed by php every new version.
To my mind, it's about picking the right tool for the job. There are always going to be people who knock it, and sure PHP has it's faults, but it gets the job done, and gets it done well. This article is over three years old now, and in that time PHP has sped up development massively, and really made some headway into solving the things people tear it down for. Sure, they're sticklers for backwards compatibility, but certainly in the earlier years, they didn't want to lose support because they broke everyone's applications each time they upgraded. That said, if they ever finalise the spec for PHP 6 (I believe they're arguing mainly about encoding, if I remember rightly), they could take the chance to break away from previous revisions of the language at that point. PHP has matured more than enough to warrant a 'from-scratch' version anyway. Also, some people who code in C#, Java, C++ etc. will complain about how a lot of the backend of PHP is obscured from you because it's written in C. You don't have to worry about memory management as much, and it's loosely typed so yes, you can write sloppier code than you can in, say, Java. But to me that's a moot point. If anything it's a positive thing because I know one thing for certain - if it's someone's job to worry about making the backend efficient, then they're almost certainly going to do a better job of it than I am if I had to do it as an aside to whatever project I were working on. By handling as much as possible for the developer, PHP lets you crack on with writing your application without worrying too much about the nitty-gritty, in the same way as a framework does - it obscures the generic stuff from you so you can concentrate on business logic, which is exactly the direction programming should be going. Sure, there are times you want and need to delve into the core, and it should always be possible to do so, but there's no need to force it down your throat so that development takes an age. As you can probably tell, I'm a PHP developer, so yes I'm biased. But I've seen PHP do some pretty amazing stuff - and if you've been to Facebook, so have you (as the article says). For something as big as Facebook, yes, of course they care about what's powering PHP, and that's where things like HVHM came from, but at that point it's more about scalability than anything anyway, which is more of a systems architecture problem than a language one. 
Will address some of these. I've told several abrasive issue commenters to be quiet several times, and did again after this was posted. Regarding issues and pull requests: Laravel is open source. Grab an issue or pull request, test it, suggest fixes or alternative approaches, etc. Laravel actually has **way less** open issues than other popular open source frameworks. Regarding BC breaks, we thought we could make a change without breaking backward compatibility, but we found out quickly we couldn't, so we reverted it. We saw an error and quickly fixed it. I wouldn't call that a "downside". The part of commercial expansions is way off. Only 1-2 people have any idea what I will be revealing at Laracon, and if you did, you wouldn't be complaining about it. Also, Laravel isn't a one man show. We use 27 components from the PHP community to power a variety of stuff. Laravel is "collectively" authored by all of those people. Also, "grown up" frameworks aren't exactly sanctuaries of semvar worship: https://github.com/rails/rails/issues/9979 Regardless, always room to improve!!! I will take any feedback to heart and try to make improvements where possible. Thanks!
I had the same issue, couldn't get it to work in shell. It works fine if you run a php file though. php -f ./file.php I did a similar example here: https://github.com/rossriley/php-scalar-objects/blob/master/examples/strings.php 
Yep. This.
I'm a little disappointed because I made several edits to this post and Reddit doesn't seem to be accepting them now. Essentially what you're trying to say is "One man cannot do what a team can do." My argument back is, well look at what he's done thus far. Your implying that Django and Rails do not (or do it significantly less) break backwards compatibility but I do not believe that to be true. Again, I think you're just trying to say that a team of people is going to be able to check and double check this better than one person could. If an update to the framework broke a package, there's a chance those packages may have also done something wrong (or perhaps Taylor or whoever drafted the PR). Furthermore, this is mitigated by the packages explicitly saying "Works with this version". All of your conclusions are based around the idea that this can't be a one man show. At the heart of it, it isn't. It's a community. Taylor has the final say on what code gets the Laravel seal of approval. http://en.wikipedia.org/wiki/Benevolent_Dictator_for_Life
I'll continue to use it for as my preferred web framework. Down the road if a serious problem with Laravel comes up in this current model then a dedicated group can easily fork the code and begin anew. The community always finds a way.
You shouldn't be letting the client choose the technology you use. If you had a house built you wouldn't dictate materials or building techniques. If they're paying you they should respect your expertise and trust you to use the most appropriate technology for the job.
Considering the difficulty the PHP community has making decisions I think keeping it a one man show is your best bet. You're doing a fine job. 
Please folks, don't mind the troll. Redditor for 1 hour, one post, anonymously put a gist on github, move along.
OK - I just tested a custom string handler in a file, and you're correct, it does work exactly as expected. I wonder why it's not working in PHP interactive mode?
&gt; you wouldn't want people to just see the PHP code that they're uploading That's how open source software works. The source code to PHPBB for example is open source. If the source was hidden (which isn't really possible except for with something like ioncube which I think has been reverse engineered) then it would be relying on security through obscurity. The files that you upload for phpbb are the same files you can view [here](https://github.com/phpbb/phpbb) and they are the same files that the system uses.
I didn't spend any time debugging but I assumed that interactive implementations of PHP do something clever to prevent fatal errors like calling methods on non-objects from actually breaking the execution flow. So maybe it's checking the syntax in a way that doesn't hit the extension.
From the article: &gt;with proper caching Symfony can deliver pages with fairly reasonable processing times. Average processing times with &lt;10 concurrent users is ~80ms. This is in sharp contrast to Web Framework Benchmarks at http://www.techempower.com/benchmarks/ With proper caching, *any* system can deliver pages reasonably quickly. But at that point, you are benchmarking the caching system, not the dynamic responsiveness of the framework. For example, if you use Framework X to build and cache a whole page on the first hit, the second hit will run at the speed of the web server, which is independent of the responsiveness of the framework. There are nuances to this, of course, but that's the general issue. For more information and background, one may wish to see my benchmarking archives at &lt;http://paul-m-jones.com/archives/category/benchmarks&gt; and specifically this post &lt;http://paul-m-jones.com/archives/315&gt;.
I have a CakePHP project you might enjoy. I'm trying to make a platform for open-source thinking. Hit me up if it sounds interesting (:
Yeah, I love it. I initially got involved myself as a learning exercise for converting Ruby code to PHP. So far I've fully converted one Rack middleware to Stack, called StackRobots - https://github.com/thephpleague/stack-robots I'm working on another one that I think will be _super_ useful, and that's called StackAttack - https://github.com/thephpleague/stack-attack - It's a port of Kickstarter's Rack::Attack that they use to whitelist, blacklist and throttle requests.
&gt; Laravel is a one man project run by Taylor Otwell exclusively In fairness, a lot of projects are like that. They may have many or few contributors, but there's almost always a single decision-maker at the top of the chain who has final say over contributions. &gt; no intent of following semver (semantic versioning) If true, I think this is an unprofessional choice on the part of the decision-makers. The related narrative about breaks between sub-minor versions seems to buttress this point, but as I'm not familiar with the specifics I cannot comment further. EDIT: &gt; https://twitter.com/taylorotwell/status/422837742716727296 Heh -- I hadn't seen that one. I agree that the lead does not seem to deal well with criticism, at least from "the old guard" who apparently haven't done anything useful in decades (!!!), but that character trait appears to be a feature and not a bug in some circles.
To clarify in case you are confused: general users can't see the PHP source code of what you put on a website. PHP is a server side language that output HTML. If you are talking about open source software, then it's generally agreed that it's *more* secure by being open, because anyone can look and find security flaws. And typically they get fixed quickly.
thanks. 
thanks. 
I'm sorry but I despise Wordpress' design. It works great for so many people, but I just can't stand it. No hate on the community though.
that's the biggest problem IMHO. It's an awesome language, but sooo easy to shoot yourself into the foot with it. same with JS
I must disagree, just because they use PHP doesn't mean it's the right tool. And I'm someone who prefers PHP over all languages. It's like saying "I'm gonna use C++ to write a simple blog because everyone at the company uses C++"
Wrote my own port of the Perl library before I realised one already existed for php, but I had alot of fun doing it [My Faker Port](https://github.com/icomefromthenet/Faker). One day I might even write better docs, even I forgot how to use my own creation. 
I think it really depends on what you do. I absolutely loathe how some people build actual web apps with Wordpress or Drupal - and even worse, ask *me* to do it. But on the other hand, most sites that I personally make are classic CMS sites. You know, a blog, a company portfolio, a contact form, some way to add pages, and that's about it. Wordpress' UI works very well for them. But the API is so bad... I'm seriously considering trying to build a CMS admin package for something like Laravel (I love Django, but my clients won't go the Python route), just to keep me sane. &gt; At my current job, one team is using Drupal as a RESTful API which has caused and is causing numerous delays It won't really help you now, but apparently the Drupal folks realized people were doing it, so they're actually providing built-in web-service support in the next version. Will it be good, or another over-engineered mess? Remains to be seen.
WP still relies on mysql_*
&gt;you can get an equally intuitive and developer-friendly framework out of Django or Ruby on Rails...and with the guarantee that these frameworks will have a lifetime of up to decades So is your post a subtle way of saying PHP sucks? Hard to take you seriously when you start pushing other languages and their frameworks, along with the completely ridiculous assertion that they'll be around for decades. You should really just take that out as your complaints likely stand on their own, but this paragraph is a big hit to your credibility in my eyes. 
For a company, the only sane choice right now is Symfony2. We were in a similar position a few months ago (trying to ditch Codeigniter 2) and then this was posted: http://symfony.com/doc/current/contributing/community/releases.html which introduced LTS versions of the framework (which will have 3 years of support). Laravel may be great for MVPs and quick projects where long term maintenance is not really an issue, but otherwise I wouldn't pick it for a project. 
Top response! Thank you for this, been driving me crazy with the mixed info i got from Google on the issue! 
Can I get a side-by-side comparison of CakePHP and Laravel? I'm new to frameworks in general and sometimes it feels like I'm just selecting one at random and hoping it does what I want to do three months before I know I want to do it. 
Perhaps a third-party will pick up the job and offer LTS on legacy Laravel versions. People do this with Rails. As far as release stability, now that we have adopted a 6 month release schedule, with sane upgrade paths, things have smoothed out a lot from say a year or two ago. Thanks for the feedback!
If used with say some MVC-variant, would these middlewares be executed before or after the Controller and its corresponding action has been called?
To hell with Laravel - stick with the big guys, Zend Framework 2 and Symfony. Why? Because I have yet to find somebody who is hiring anybody with Laravel experience.
That's interesting. I know a couple larger companies in Sydney that are looking for PHP devs with exposure to Laravel.
In Chicago and LA, I haven't come across any positions that mention Laravel. Oddly enough, I saw a few companies using CakePHP.
I couldn't find a good comparison online, so I made one for you. http://imgur.com/7cKYlmS :) In all seriousness, the differences are such that a comparison wouldn't really make any sense. It'd be like comparing a 1999 Toyota Corolla to a brand new 4x4 truck.
I've seen a few contract positions for Laravel work. Doesn't seem to have huge penetration yet but I imagine lots of new companies are starting out with L4 for their sites at the moment.
I'm sure there are a few positions in certain markets.
Middelwares wrap the request and response. So, both. You can intercept the request and do things with it and, and then either halt the application (if you're using a request filter middleware) or pass it on to the next middleware in the chain. Then, after your application has ran and returned a response, your middleware can modify the response. A good example of both of these is StackRobots. You can see from the [handle method](https://github.com/thephpleague/stack-robots/blob/master/src/League/StackRobots/Robots.php#L43) that it first checks if the request is in the specified environment. Then, if the request is for `/robots.txt`, it stops app execution and returns its own response. If the request isn't for `/robots.txt`, it lets the app run, but then modifies the response headers by adding an `X-Robots` tag. As you can see, it's pretty flexible.
The major difference here is the fact that symfony is a company, laravel is a dude who has some time on his hands once in a while. So Symfony can provision employees to provide support for past versions while Otwell has to focus somewhere given he is only one dude. But LTS versions would be a huge plus to Laravel.
I believe every framework (supported officially by a compnay or not) is going to have trade-offs. I personally enjoy the 'feel' of Laravel as a framework coming from an environment that regularly worked with Zend and Codeigniter, but I do see the overall concerns. In fact, we recently moved a few of our production applications to 4.1 and did hit a few hiccups. However, we protect ourselves with a solid development process for handling this issues. We were building 4.1 as soon as development releases dropped and had most of the kinks worked out. This is really no different than should be expected in any application-space. In my opinion, the REAL problem is when you let a framework become a giant squid, working its tentacles into every aspect of your application domain and choking it out (thanks @chartjes for the analogy, I've used it a ton). This is a problem with how all frameworks can be used, no matter full-stack, mini, etc. I believe the effect is lessened with a component-based framework like Laravel, Symfony, etc. simply because at least at that point, you have the opportunity for more control in how you interface with each component. For example, Laravel's facades are a topic of heated discussion recently it seems (from posts I've seen on reputable blogs). In my opinion, Laravel's facades are a helpful hint to abstract the interface between your application and some foreign package. Laravel promotes ideas you'll find in reputable literature (SOLID Design, DDD) but is not forcing anything down developers' throats. It's almost like a "framework for best practices". That said, Laravel (to me) is like a sword being forged by a lone blacksmith (and a bunch of apprentices! :smile:). It's been pulled out of the flame for perhaps the last time and is now being sharpened and honed to perfection. It's got enough of an edge to cut through the bush, but at the same time, enough of an edge to cut the swordsman if not wielded correctly. When I cut myself cooking (with my sword), I don't blame the sword. I blame myself and realize that I have not achieved mastery. Likewise, placing ultimate dependence on a framework to the point that we're blaming Laravel when we back ourselves into a corner makes no sense. Instead, it's the communities job to point folks who have not yet mastered the skill-set to the appropriate literature. It's our job to write packages that embody these best practices. In the end, I completely understand the hangups in "schizophrenic development" and other things you've listed above. However, I believe it better to solve the root of the problem. A stricter development process fixes the "unexpected issues" between framework upgrades. More experience in software architecture solves the problem of framework dependence. All in all, I love Laravel to death RIGHT NOW but I am already prepared (as are my applications) to move to the next hotness if the need arises. Every good thing comes to an end. Thanks @taylorotwell.
Keep up the good work. I'm more than satisfied. https://gist.github.com/anonymous/8565929/#comment-991715
Hi! San Diego here - always looking for help. Cheers.
&gt; Symfony can provision employees to provide support for past versions while Otwell has to focus somewhere given he is only one dude We're saying the same thing. And because of this, Symfony2 is the best (only?) choice for projects that live beyond an MVP/2-3 months. This might be hard for the young, hip PHP crowd to understand, but people who have been doing PHP development for more than a summer know that backwards compatibility is essential. That is why so many shops still refuse to abandon Codeigniter because it's rock solid and was rock solid for 5 years now. While Laravel broke backwards compatibility in every version, except the last one. That's not something a company can invest time and resources in. A hobby/freelance developer maybe.
&gt; who apparently haven't done anything useful in decades (!!!) In his defense, he said they hadn't 'innovated' in decades.
Just need some tests and stack-attack is ready.
And the version after this one. And the next one, etc. We're on a six month release schedule with very minor BC. People upgraded from 4.0 to 4.1 in a matter of minutes. 4.2 will be the same way, as will 4.3, and also 4.4 in 2015, etc.
Agreed. You _can_ write all of your background jobs, cron jobs, monitor processes in anything else in PHP, but I don't know why you would. You want to implement whatever tool is right for the job at hand. Some of that is PHP.
So copyright, that's a thing that's probably important. Apparently there is a slight tendency to close commits from people without merging, but then actually copy and paste the code into Laravel e.g. https://github.com/laravel/framework/commit/ee97de894c179d2401179331921b124156a2e3fb - I haven't searched through to verify or refute that "*Taylor's done this same thing with multiple pull requests*", but no one seems to deny it in that thread. This sucks and is evil, because the PR that the person asked to be merged will not appear in the history of the Laravel. Although this is an open source project and people are happy to share code, submitting code to a open source project does not remove the right of the author of the code to be identified as the author, which is one of the 'moral' rights under the [Berne Convention](http://en.wikipedia.org/wiki/Moral_rights). It's unlikely to cause that big of an issue, but it is stupid taking people's code without attribution just it allegedly saves a few minutes merging the PR or reformatting it (both of which I find hard to believe are actually true) as it not only pisses people off, it does open the project to risks of having copyright infringement allegations made against it. If the PR isn't acceptable, Laravel should have maintainers touch up the PR until it's acceptable, then merge it into the project, rather than play fast and loose with copyrights. 
This is the curse of "backward compatibility".
Definitely a novelty. Why would you use php as a compile to target?
I've done the same _several_ times on various projects, packages and applications. If somebody sends me a PR and accidentally screws it up due to line-endings being incorrect, auto-trimmed whitespace, too many commits in one, etc, I will often (depending on the size) just copy it over myself. Assuming there was some evil intend at play here was the cause of several peoples frustration. Because it doesn't matter. At all. **Edit:** A few people seem really intent on making a big deal out of this, so let me be a little more verbose. 1. Stealing code is bad. 2. Attribution for code is really important. 3. Clicking merge, or bringing the code down is always nice when you can. I was however backing up Taylor, saying that it is not completely alien to do this. He could have done better to make the poster feel special, but he was acting like a gentle flower from the get go and even admitted to being overly-dramatic himself. I have had it done to me and done similar to others. Asking is important (Taylor knows this know) and asking means people don't normally care. [I was asked, and said go for it](https://github.com/itsgoingd/clockwork/pull/12). Sometimes you can't get in touch with folks to ask. You have 100 issues to get through and that one has been sat there forever. If they aren't replying, and their commits are so destructive that trying to pull, tweak, rebase, rework, modify, then push back would be half an hours work then _obviously_ it would be quicker to merge. If you have another 99 to go, then it's barely unreasonable. If they won't reply with your suggestions to fix it, then... what? Ignore it? Close it and never fix the bug? Or thank them and implement yourself, and let them get in touch with me if they are unhappy. This has **never** happened to me. Now, I said I do this "often". Often in the grand scheme of things is probably about 30 times in the last 5 years. Whole features like Taylor here? Nope. But I'll do it for bug-fixes or other trivial stuff. So, there is literally no problem here. No need to go crazy. Nobody has ever complained about my PRs, or about code theft on my part, and most of my code is DBAD so we're hardly going to have a legal battle about contribution rights. Zend and Symfony are going to have different legal issues than Fractal, the CodeIgniter-RestServer or some other package I spat out in a weekend and shoved a DBAD license on. I think generally speaking people need to take it easy. There is a really weird trend happening recently in the community that everyone wants to freak out about something, call somebody names, and get their name mentioned by a PHParody account. It's silly. :)
One good place to start would be to create some routes to views. Take a look in your app/routes.php file. You likely still have the default one routing to a controller with a view response. The view will be stored in the app/views directory. Try playing around with changing some basic HTML so at least you can visually see the changes. From there you might want to look at the [routing docs](http://laravel.com/docs/routing) and add some more routes to your router.php file. From there you might want to enter your MySQL database info in the app/config/database.php file and take a look at how to use [Eloquent](http://laravel.com/docs/eloquent) to make queries to a table. This will likely lead you into how models work. Feel like I'm in that store about ["If You Give a Mouse a Cookie"](http://www.amazon.com/If-You-Give-Mouse-Cookie/dp/0060245867/ref=sr_1_1?ie=UTF8&amp;qid=1390451130&amp;sr=8-1&amp;keywords=if+you+give+a+mouse+a+cookie) Feel free to ask any questions though!
Honestly, I've only used Ruby for gems so I could install a SASS-type tool (usually Compass), and I highly dislike Python simply for the fact it locks formatting (things like tabs) into the syntax, and most of the time, it looks like VB code. Again, if the combination of Python, Ruby, and bash are what works for you, by all means go for it. Like I said earlier, it's all a matter of preference.
Hmm, yeah "startups". Enjoy working long hours for "equity".
Horde? http://dev.horde.org/routes/manual/
https://github.com/chriso/klein.php
Just take the sensical feedbacks to heart. There's no way to please everybody. Thanks for your work on Laravel! 
so... cakePHP rocks?
&gt; Well, phpsh is also mostly written in Python. Which is a little silly, I sort of expect the REPL for a programming language to be provided by or implemented in... the programming language itself. Which is more an indication of how unsuited PHP is for CLI scripts than anything else.
I'm using [the wesen fork](http://github.com/wesen/phpsh), which, granted, still hasn't seen activity in two years. But it also works perfectly fine for me. \*shrug\* Anyways, that's a perfectly fine reason. But it should at least be stated in the README.
Graet answer and very structured, I like it. So for development, is your setup capable of allowing developers to immediately see their changes after save without having to commit and push to the `development` branch? If so, how does that work in your environment? I'm trying to think of a good setup wich facilitates the following (possibly incompatible) general requirements: 1. The ability to save and refresh and view changes without a commit 2. Easy (or no) step to allow for "designer friendly" use (i.e. not requiring them to be familiar with setting up a local dev server or using command line with something cool like vagrant), possibly using dynamic virtual hosting rerouting requests via automatically setup domains 3. Remote access from home, could be possible either via WebDAV share or maybe VPN or both (not sure, could be super slow with IDE's like PhpStorm) 4. Obviously, segmentation per user so people are developing on their own copy of the repo without stomping on eachothers work with different domains (e.g. site.person.devdomain.com), ties into #2 5. Would like (but may not get without locally setup dev/VPS/vagrant) segmentation on the database without major modification on site code per user (would have hundreds of sites each with different code bases). I'm having a hard time finding a good balance between all these points. However your post covers other very good points that I've migrated towards, such as the ability to deploy using whatever method is available (in many or most cases only FTP, but SSH would be preferred for example). 
I tried klein, but callbacks aren't working on my php 5.4 localhost for some reason.
That's weird, do you get an error? Got any example code? They've worked for me when I've used them.
&gt; Honestly, I've only used Ruby for gems so I could install a SASS-type tool (usually Compass) Oh, you've gotta try it next time you need to do some text munging. Ruby has many downsides, but it's the only language that's **fun** to write. I kid you not - I get downright giddy sometimes while writing Ruby, and I've talked to several other people who have independently expressed the same thing.
I believe digg did in its heyday as well. I don't think anyone can knock that combo on scaling. 
If you make a design that can shard your database...that plus php basically == near infinite, easy scaling.
MySQL does support sharding.
So does Facebook. And a shitload of other large companies.
Yea I don't get the surprise.
&gt;What do I do when I have Laravel installed? You should be asking what do you want to do first in terms of your project. Then you can ask, how to do **that** using Laravel.
But your tables and databases do not.
Basic example didn't work and I had the htaccess setup fine. Even w/out the 'GET parameter, still didn't work. Running it on Wamp 2.2 PHP 5.4.3 $klein = new \Klein\Klein(); $klein-&gt;respond('GET', '/hello-world', function () { return 'Hello World!'; }); $klein-&gt;dispatch(); What's weird is the following worked: $klein-&gt;respond(function() { return 'works'; }); $klein-&gt;dispatch(); I was debugging the code to see if the routes were actually being set and responded to the url path provided and they were finding the routes, just the callbacks weren't being executed, for what ever reason.
Well technically Facebook uses a modified version of PHP based off the open source HHVM. But it's still PHP at the core. Tumblr use PHP and MySQL too, and they have an extremely large write load with hundreds of thousands of posts per minute. 
That's a problem with your environment, that code works fine when properly configured. I wouldn't touch WAMP with a bargepole though so I can't really help there, perhaps try Stackoverflow for help with your configuration, unless your apache error log has anything? Try: var_dump($_SERVER); at the top of your index.php and then visit the /hello-world and see what you get, is REQUEST_URI showing as hello-world? 
Just goes to show the dynamism of the language. Can it be used for utter shit? Sure. Can it be used to make something awesome? Definitely. Same with concrete or any other building material.
Sorta wish we could just stop circle jerking about it. PHP gets used in a lot of things - we know already.
You can shard by putting different tables in different instances. There are several ways to shard. Do that, and it doesn't matter what database you use. It's a coding issue.
 [REDIRECT_URL] =&gt; /LightExt/hello-world [GATEWAY_INTERFACE] =&gt; CGI/1.1 [SERVER_PROTOCOL] =&gt; HTTP/1.1 [REQUEST_METHOD] =&gt; GET [QUERY_STRING] =&gt; [REQUEST_URI] =&gt; /LightExt/hello-world [SCRIPT_NAME] =&gt; /LightExt/index.php [PHP_SELF] =&gt; /LightExt/index.php No idea what's wrong, but like I said in the original message, I tested to see if the the route function was actually triggering for the tested routes attempted and they outputted the request type, route name, etc.. only thing that didn't work was the callbacks (closures) never triggered . No idea why or if there's a PHP 5.4.3 conflict.
So does Mailchimp. This is why I don't get into religious arguments. Any language can be used well or badly. PHP has some… idiosyncrasies, but people are getting real, awesome work done with it. (Same with RoR)
I was under the impression that sharding specifically means splitting a table by rows across multiple instances? 
The problem is your subdirectory, did you follow the subdirectory guide on the Klein wiki? It's not mentioned on the docs homepage unfortunately, catches some people out. Here's a link: https://github.com/chriso/klein.php/wiki/Sub-Directory-Installation Klein routes based on the REQUEST_URI, yours is "/LightExt/hello-world" meaning you'd need to prepend each route with "LightExt/" for it to work, unless you follow that guide, eg: $klein-&gt;respond('GET', '/LightExt/hello-world', function () { return 'Hello World!'; }); If you change the route you have that responds to all requests to: $klein-&gt;respond(function($request) { var_dump($request); }); and then search again for REQUEST_URI, that is the string that klein is working with, so the problem isn't that the callbacks aren't being executed, it's that the route isn't being matched.
I wonder why people always feel compelled to point out that Facebook "isn't using PHP", because they have another implementation with a few language extensions. After all, nobody would say "They aren't using JavaScript, they're using V8!"
Oh, that's useful to know. But won't it mess with my joins?
Probably is technically, but I've seen it both ways. I've seen databases split into groups of related tables. That's what you need to make sure of. That you won't ever need to set foreign keys against tables across multiple instances. So, Users, Roles, and User Roles in one table. And Quotes, Orders, and Invoices in another. Just make sure none of your QOI will ever have a User attached to it, or you won't be able to set a foreign key and your joins will take that extra time to retrieve. Now, I don't know if this is an official version of 'Sharding', but I have seen it done this way and we did call it sharding. 
Definitely will. You just have to choose groups of tables you know will operate independent of each other. Or be willing to take the double database call hit. So if you save a lot of documents, and it doesn't really matter who the user is on it, for example, you can stick the documents table in it's own instance and the users table in another. Just know and plan for that if you do need the user, you will have that extra hit. Is this officially 'sharding'? Not sure. But I do know I've seen it done this way and we have referred to it as sharding.
regarding tumblr: [a little bit outdated but still highly interessting](http://highscalability.com/blog/2012/11/19/gone-fishin-tumblr-architecture-15-billion-page-views-a-mont.html)
Oops sorry. Just thought it would be interesting to share how Imgur implements and optimizes their PHP/MySQL stack.
This is great and all, but I really wish that when people benchmarked a framework they supplied their configuration for that framework. Particularly in the case of Symfony, where production configuration can be done poorly and have a massive bearing on throughput. The OP doesn't share the application code that he benchmarked (fair enough, probably because it's his own personal website). EDIT: This goes for all framework benchmarks, and the same reason that "hello world" style benchmarks just don't mean anything.
PHP gets an unfair amount of criticism for not being a 'proper' language. You don't need to worry about the nitty-gritty, such as memory management, and the language itself is of course loosely-typed, meaning that sure, if you don't know what you're doing, it'll let you follow a lot of poor practices. But then again if I gave you a hammer and you hit yourself in the head with it, then you're the tool who can't use the tool I gave you properly. When all is said and done, clearly PHP has incredible capability and scope as a language and once you know how to work with it, it's as good as any other. 
For sure, no need for 'sorry' - but this is rather old news for many (or maybe not all?).
&gt; it would be like saying action script 3 is like javascript in another year or two, this statement will likely be true, though. ;-) (for anyone who doesn't understand why: ActionScript 3 is essentially ECMAScript 3 with some bits from 4, and a lot of the functionality everyone's excited to see in ECMAScript 6 - like real "classes")
See, all I got out of this was "Ooh! Shinies at Laracon!" I'm a simple creature. 
Committees get things done, amirite? Can we get a vote here on whether I'm right? I'd like to table the issue of whether I'm right and establish a proper protocol for determining rightness in a given situation. I feel this would facilitate future discussion about whether or not someone is right. Move to vote on a resolution to further discussion of rightness? All in favour?
yay! Enjoy Klein :-D
So the better solution would be to have no helper functions altogether?
I'd say yes. If you take a look at the basic examples on [Pimple's website](http://pimple.sensiolabs.org/) they're passing around configurations. // define some parameters $container['cookie_name'] = 'SESSION_ID'; $container['session_storage_class'] = 'SessionStorage'; // define some objects $container['session_storage'] = function ($c) { return new $c['session_storage_class']($c['cookie_name']); }; $container['session'] = function ($c) { return new Session($c['session_storage']); }; I know this makes programming difficult, but it makes your code a lot easier to test and maintain. If you're dead set on helper functions, a couple days ago there were some posts about Laravel's Facades. A home baked version of Laravel's Facades might help you. It works similar to your static::getInstance call but it also comes with a static::setInstance method which allows you to supply mock objects for testing purposes. This is a very very short explanation of how Facade works and gets some things wrong; but it explains the heart of what it does. 
Head over to [Laracasts](https://laracasts.com/). It's a video screencasts site created and maintained by Jeffrey Way, a guy well known as "The Teacher". It's focused on Laravel and the number of videos provided in it's short existence is huge. There are some beginner videos wich should work for you, some intermediate and advanced lessons, for example SOLID design in Laravel. The site is accessible by subscription, but I think everybody can handle 9 bucks per month. You can try it, there are also some free videos without sign up. Current lesson count: 106 videos from approximately 10 to 20 minutes each.
I like the part where the person, who when criticized, basically puts hands over ears and goes lalalalalalalala says Taylor can't take any. From tweets. Probably out of context. LOL. http://paul-m-jones.com/archives/4757#comment-3067
&gt; "standard" CRUD Makes me wonder, aren't all dynamic websites more or less a variation of CRUD? Are there any applications that do not fall under this classification and aren't static web pages?
Very little in programming has a lifetime of five years, let alone decades...
I agree with Taylor to a point on innovation. So long as we don't confuse innovation with imitation.
Yeah. It's spelled LAMP for a reason. They just work so well together.
I dont see how that clarifies it at all, to be honest. Or are you suggesting that it was a joke, and that he doesnt actually think that? At face value it seems exactly as it is laid out.
Work on reading a few gigs of csv file and you definitely have to worry about memory management in php... 
I love lamp
I'm famous!
He meant that its a managed language (garbage collection).
I know stuff like node.js blew up big time in 2013 but if you're surprised that &lt;insert site here&gt; uses PHP &amp; MySQL then you need a bit of a reality check!
The author was credited with the commit on his original PR. https://github.com/laravel/framework/pull/2094 
SORT_ASC is a constant. When you put quotes around SORT_ASC in your instantiation of $varSortOrder you are creating a string.
Not really - just use a while loop with fopen and generators. 
Remove the quotes around SORT_ASC and you'll be golden. As /u/t3hchipmunk said, you're making it a string so that doesn't work. If you must keep it a string, instead of wrapping it in {}, just wrap it in `constant($varSortOrder)`
I'm quite aware of who Phil Sturgeon is; however, I don't see on the sidebar of /r/php that I'm supposed to agree with everything he says. And good for you, your agency uses Laravel. To be honest, most do not. If you take a 100 firms, maybe 10 will focus on Laravel, the rest will be Zend shops.
"Have fun storming the castle!"
Its *perceived* weakness. 
&gt; Wordpress' API is pile of crap I'd love to hear any improvements you can think of! :) What would your ideal API look like?
Personally I don't think it's even that -- I think that since the bar to learning and using PHP is so low that it attracts a far wider variety of people interested in getting their hands dirty, many of which have no interest in Good Practices(TM) and the concept of Best Practices(TM) is completely useless to them. As such, statistically speaking, the sheer volume of unskilled users and low-quality code drags the average down a fair bit.
Can you use a cron job? If so then look into using rsync. I guarantee it will be faster than PHP's copy function. http://rsync.samba.org/examples.html
This argument doesn't really hold up any more, either. You're not doing memory management in C# or Ruby either. Having used both C# and PHP professionally, I just don't get it. All the C# devs were convinced that PHP was absolute shit, but I just found C# to be wildly over-architected.
rsync will be faster because it downloads new files and the changes to existing files. I'm going to guess that the flv videos don't change often, so it might be a good way to just grab new files without having to figure that out yourself. OP should look at using curl to copy the file, might be faster.
10% sounds like more than 0. :)
Thanks for the defense dude, but I can argue in comments for myself. I appreciate it though! :)
It'd be like saying CoffeeScript or TypeScript is the same as JavaScript. There's language syntax changes in addition to the runtime changes. There's some talks on it on YouTube I think. There's things that ease some of the pain points of PHP, such as object-oriented data structures (Set, Vector, Map) so you can do $blah-&gt;filter(...)-&gt;map(...) rather than array_map(array_filter($blah, ...), ...) I absolutely agree that it's still PHP, but it's nicer PHP. I guess it's kinda like ES6 vs current JavaScript 
Which doesn't get listed in the history of the Laravel project unless someone specifically goes to that PR. So if you tell a company that you're hoping will hire you that you're a committer to the Laravel project, they go to the committers page, they will not see those entries.
Absolutely on these occasions I might throw the authors name into CONTRIBUTING.md and move along - unless it was trivial as fuck at which point I'd just thank them. But to suggest that anything out of order from Taylor happened in this thread is insane. This was the order of events: 1. Original PR dev asked why he was not included in an admittedly overly-dramatic way. 2. Prominent community member pointed out an explanation, that Taylor did it for him as the code didnt follow the style guide and linked to the rules explaining contributions. 3. Starts acting like a bit of a gentle flower, and complains about PSR-1 not being comprehensive. 4. Amy Stephen swings by trying to give him a hug 5. Community memmber tries to explain what PSR-1 is. 6. Random guy from the internet swings by to troll and complain about everything. 7. Well known Laravel community troll is rude as fuck, as he often is. 8. Amy Stephen sticks her oar in even further, starts being patronizing as hell and escalates the whole thread. 9. Everyone else who spotted the #phpDrama tag dived in to give their 2¢ because what else are you gonna do on a work-day afternoon for giggles? 10. Taylor makes his entrance to say "you're right, i probably should have just pulled your branch down and fixed what I wanted to fix. i'll keep that in mind next go around." He later apologizes further. Your last paragraph has no relevance here. Not to me, not to Taylor. It didn't happen here, isn't never happened with my products either.
People always seem surprised that the most popular sites use the most popular language -_- This isn't some hipster's portfolio written in Ruby because he picked the wrong language to learn to find a job. 
That, for me, is the biggest strength of languages like PHP and Ruby (I've only played with rails). It's accessible. You can pick up the basics in a few hours and hit the ground running. It's entirely possible to follow a basic tutorial and wind up with functional applications very quickly. That's where the mass appeal comes in, and to be honest I think that making programming more accessible can only be a good thing. You're always going to have the elitists who think that they're better than most simply because they have to work harder to do the same thing, and have to consider the trickier aspects of computer programming such as - like I keep referring to - memory management. Also, languages like C++ are much more difficult to learn and code in. They're not necessarily lengthier in terms of lines of code - I've seen bash scripts do incredible things with a single character, but it's so complicated to learn and it's little more than a memory game. But sure, there is the notion of superiority present when someone's task is more difficult than yours is - they've worked harder. But frankly I don't want to have to spend time and energy worrying about the tiny details which the 'stakeholder' and I simply don't care about. And who would? Who honestly *wants* to spend more time on something than they need to? It's inefficient, so unless PHP absolutely can't do what you want it to, why would you go in search of a solution which is technically more complex whilst achieving the same goals? A good example would be Java. For anything web-based I'd use PHP, but for desktop applications I think Java is a great language. It's harder to learn, stricter and it really does put you through your paces as a developer when compared with PHP, but it's good at what it does and gives you more control over the things you care about on a desktop app - memory management, native OS UI integration and so on. Again, it's picking the best tool for the job. So yeah, for me, the trade-off in low-level control is more than worth the simplicity and ease of development you get with PHP, and that's before we start talking about community support which is - in my personal opinion - absolutely incredible. It's so easy to find the answer to your questions on the internet with PHP. Just head to StackOverflow and I challenge any beginner to be unable to find an answer to their question on there already. On top of that, you have the frameworks available to you, which are also very good and exceptionally wide-ranging, from micro-frameworks to, well, let's face it, Zend. Sure, the OO model in PHP is a little 'jammed-in', but it works very nicely. Sure, PHP lets you do bad things, but that's the trade-off with accessibility, and experience should get developers out of bad habits. Again, I have to reiterate that I am solely a PHP developer and I've never yet hit a problem I couldn't solve. We even have fully functioning threads in our PHP system where I currently work. That wasn't terribly easy, but they work damned well now. My point here being that even when you think you've found a limitation to PHP, the chances are that there is in fact a solution. 
Which makes this an exact equivalent of emailing in a patch file, which was the only form of contribution to many OS projects for decades - and for some still is.
If I can say one thing for the FIG and internals, is that having a huge committee of people working on something makes it smooth, elegant, efficient, productive and beneficial to everyone. Laravel could learn from this.
Whats your error? 
Every implementation of a language comes with some language extensions. GCC implements the C language, even if it supports a number of extensions ([quite a lot actually][1]). SpiderMonkey implements JS, even if it supports stuff like generators, list comprehensions, etc. HHVM implements PHP, even if it supports stuff like generic typehints. [1]: http://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html
That's true. I guess when I refer to "PHP" I only mean mainline PHP. Custom extensions and implementations aren't as common in the PHP world compared to something like C. 
ok, btw. you should escape the input or at least cast the type of the input, i.e. $sql = 'DELETE FROM CUSTOMER WHERE cust_ID = ' . (int)$cust_ID;
How is this /r/php material? When a developer who uses PHP for a project does something completely unrelated, does it really warrant discussion here? What's even worse is that a mod posted this...
Because no one could possibly learn more than one language or use a framework because they just wanted to. Reddit is written using Pylons and is one of the most popular websites around. It also uses PostGres and Cassandra instead of MySQL and Redis. Are the devs here hipsters? And apparently the CIA uses Plone/Zope for its website. Walmart switched over to NodeJS for whatever valid reason. Apaprently eBay uses it for HTTP Gateways. And Paypal developed a framework for it and uses it exclusively for new projects. Hulu and Github are both apparently run by Rails. Though, no one's every heard of them and seems like only tech hipsters would be bothering with those places.
^ I found the guy who uses Ruby
Isn't Apache 2.2 no longer supported on PHP 5.4?
OK, fair enough, my point was while Laravel is a nice framework (although I do agree with the article from OP about Laravel being a one-man show), to me it's not worth investing a huge amount of time with it considering the majority of larger firms are usually asking for Zend.
You can not just pick how you think it pleases you best for your argument. If a PR was offered, talking about patches send in via email is just unrelated. And better take a look, it's git, there is author next to committer. Which is normally properly done by those who commit patches they receive by email to fully ruin your argument, but, well, what should I say? Perhaps learn from the pros?
Sorry, but when this is Wordpress' own official solution for switching development environments, then I must disagree with you when you say it's not broken: http://codex.wordpress.org/Moving_WordPress
You should most definitely be escaping user input, not just blindly passing it to SQL. Also, /r/phphelp
Actually, nope. I think Ruby is ugly as shit, it's like Perl's aborted baby someone found in a dumpster still alive. I've been told it's a wonderful language and a lot of things it does is amazing, but I can't move pass the syntax. :/ I prefer Python, myself.
When Taylor can actually address the points in that article, we can have a reasonable conversation related to it. I will admit to a bit of impatience when he makes points that have little, if anything, to do with the original article. As far as tweets, he is presented (via link) in full context using his own words; I say nothing either positive or negative about it. The points I make in that post have nothing to do with Laravel (or any other specific framework) other than to say that eventually the framework will fail you, no matter what it happens to be. One has to be careful not to confuse a "mention-in-passing" with "persecution".
I think you're probably misinterpreting my point and just assuming the worst without context. If somebody sends in some two-line fix for some 3 class package, gets it wrong (not a screwed up merge on my part, but their commit or PR is shitty) and does not bother to fix it then just doing it manually doesn't hurt. I'll either put them in CONTRIBUTORS.md myself, or suggest they do it in another PR so their name goes down on the scroll of epicness, and they will become rich and famous for having their name in there... or whatever you people think happens. They are always thanked on the PR, and I have never had one single complaint from anybody about my actions merging PRs for CodeIgniter, PyroCMS, or any of my packages which I have had as open-source for the years. If its a larger feature then obviously I'll ask them to keep at it. They sometimes ask me to just do it myself. I sometimes ask the same of others: https://github.com/itsgoingd/clockwork/pull/12 OH NO MY NAME ISNT IN THERE IMA GONNA CRY!!! ;) As long as people aren't upset, there isn't an issue. If somebody is upset, you apologize and fix it. I've never had to fix it, because nobody has ever been upset with me about the way I handle PRs. So, what exactly is it that you find unacceptable?
Also note that I defend Taylor in my very first point above, but apparently that doesn't rate with /u/robclancy.
&gt; When a developer who uses PHP for a project does something completely unrelated, does it really warrant discussion here? Evidently, yes. Not sure why you didn't just hit the downvote and move on. I mean, that horse you're riding should be capable of helping you gtfo pretty quick.
Python's probably tied with PHP as my favorite language.
&gt; In my opinion, the REAL problem is when you let a framework become a giant squid, working its tentacles into every aspect of your application domain and choking it out (thanks @chartjes for the analogy, I've used it a ton). &gt; ... &gt; When I cut myself cooking (with my sword), I don't blame the sword. I blame myself and realize that I have not achieved mastery. Preach it, brother. 
 &gt; So, what exactly is it that you find unacceptable? The fact that you broke the license.
People just need to hate on something.
If you don't already know git_template, it is a set of mostly php related hooks. This one is language agnostic though.
That seems to work nicely. Thanks! Usually when I do searches for things like there there are a ton of links of people with the same problem. For some reason I couldn't find anything. There must be more idiots out there with the same problem, lol. Maybe I didn't use the best keywords in my search.
No problem. Keep on developing and learning!
Which license? 
How so? 
Hmm, an ideal API? Off the top of my head, probably something more akin to modern MVC frameworks, like Laravel or Django, with clean separation between templates and logic, an actual ORM, and routing (perhaps even definable through the UI, like in Drupal) - instead of using the "code in a page's template file" hack. Literally every Wordpress site I've seen could've been much better if that was the case. It certainly wouldn't heavily rely on a global state ($post, $wp\_query), and wouldn't have an inconsistent mess of get\_/the\_/wp_ functions (I personally hate the whole get_term/get_terms/get_the_terms/etc. the most), and a strange mix of OOP and procedural code. But it's not really feasible, IMHO. It would literally be another system with the Wordpress UI on top. Wordpress' API clearly grew up from a minimal blog system, and its backwards compatibility is both the worst and best thing about it. I don't want them to go the Drupal route, and start slowly turning their 1980's-style procedural code into an unrelated OOP/MVC one with every new release. I hope they'll just take the lessons they learned from it, their great UI, and make a good, modern CMS (as opposed to another minimalistic blog system like Ghost).
I was going to suggest wget because it is easier to setup (in my own uneducated opinion, never really messed with curl except in a script).
&gt; I mean, that horse you're riding should be capable of helping you gtfo pretty quick. How is this a superiority complex? All I said was /r/php is not the place for non-PHP topics. Isn't this why we have subreddits in the first place? I'm honestly baffled...
I don't understand, why would I use cron jobs? The downloads are not something scheduled, or something that I manually do. The website asks the user for the .flv link (so the remote host could be whatever), downloads it on the server, and modifies it with FFMPEG (mostly converting to MP3). The original .flv is deleted after the conversion has taken place. So the copying should be done via PHP. Also... I have no idea how to use that, sorry. I only know PHP (kind of a beginner too). I guess that it is something I am supposed to install on my server?
 Do you really love the lamp, or are you just saying it because you saw it?
What's wrong with this procedure? I've used it several times and it isn't broken. Also, how is this any different from [moving Drupal](https://drupal.org/node/776864), where you are basically doing the same thing with the base_url, files and database?
How many times will this be posted in reddit?
hello sir, thank you greatly. I will try these and get back to you!
&gt;should be able to download stuff faster than it is actually doing it Are you sure about that? Try downloading these files directly and compare the times with how php does it. If you are getting these files over a HTTP request, CURL might give you some better results.
You think it's ok to rely on a 3rd party called http://interconnectit.com that does a search and replace on a DUMP of your database to make it possible for your users to migrate domains or development environments, rather than coding it to properly support development environments in the first place?
I love building web apps with WordPress. The backend comes with good core features - user management/login/restrictions/commenting/publishing, single/bulk content management, one-click updates and activation, etc. All these things work well together at the core level; the code is mature and time-tested. The backend is extensible to any degree, making it a quick task to offer up new settings and management capabilities for the web app, putting them in a familiar place with restricted user access without the need for third party tools/plugins/hacks. Good luck on your CMS. Just don't forget there are hundreds of people working daily on the CMS capabilities of WordPress, and they are all quite competent programmers...why not let them build/improve your CMS while you build/improve your app?
Python was my escape from PHP. I'll admit that PHP is useful and powerful in the correct situation. For example, how easy is it to deploy a PHP webapp vs a Python app? It's comically trivial -- assuming you don't have to setup the server yourself, but how often does that happen? However, for general programming tasks, I prefer Python. Especially combined with virtualenv. And PHP has made great strides since I started using it back in 04 (or so). Composer seems to a huge step up from PEAR (though, I haven't used it). And a lot of the shit that PHP gets is from the fact that it's really easy to get started with and get your hands dirty without learning best practices. For example, it's just as easy to create a SQL injection with a Python script as PHP if you don't know the best way to build raw queries. Iunno, I just prefer Python to PHP. I don't feel morally superior to PHP developers, especially because there's plenty of PHP devs that could -- and would -- code circles around me and leave me in the dust.
Never heard of it. Search and replace should be done in your text editor. WordPress does properly support development environments as I currently have about 5 of them, and regularly migrate from dev to live.
I don't see what's wrong with sharing this. Let the up/downvote determine things :)
It's perfectly related actually. Person A: "Here is some code" Person B: "Thank you, I have implemented your code." Everything else is just a fancy YAY MY NAME IS IN THERE reporting tool which means basically nothing. After that you said a bunch of stuff to try and be rude, so I'll ignore that.
&gt; Never heard of it Then you didn't read the original link I posted. &gt; Search and replace should be done in your text editor Nope. Wordpress stores a serialized array of configuration data that includes the current domain you're working on, in the database. If you search and replace the domain, you break the serialization length for that particular index, and your site won't work. Mind you I'm not talking about absolute URL references in content entries. I'm talking about the CORE OF WORDPRESS storing you root URL/domain in the database for absolutely no good reason. Storing the domain in the database **at all** is poor practice. You shouldn't HAVE to do a search and replace in a dump of your database, especially one that requires a more complex regex to ensure the serialization length gets corrected, to migrate environments. I don't understand why Wordpress doesn't follow a development standard of a global config file, and a local config file, and then just references those.
For global helper functions, it really depends how you want to do it. If the function is referencing a static class method, then that one is easy. If it's referencing an instance of a class, it get's tricky. Usually you'll store the instance in registry/container and re-use the same instance, but even then, the registry/container must be static itself, or a singleton.
I'm using and maintaining [Respect\Rest](https://github.com/Respect/Rest/#respectrest-) for a couple of years. It's focused on a clean API that can evolve when complexity is needed and proper HTTP/REST standards implementation. It can be used as a standalone component or as a base for [larger RESTful projects](http://ontology.it/tools/botk4/core/#RespectRest). 
I use a self-modified version of the 15 step method just below that. I've never had an issue with serialization/length, and did you read what it says? You have the option of using the script or doing it manually. &gt; If you do a search and replace on your entire database to change the URLs, you can cause issues with data serialization, due to the fact that some themes and widgets store values with the length of your URL marked. When this changes, things break. To avoid that serialization issue, you have two options: &gt; &gt; 1) Only perform a search and replace on the wp_posts table. &gt; &gt; 2) Use the Search and Replace for WordPress Databases Script to safely change all instances. (If you are a developer, use this option. It is a one step process as opposed to the 15-step procedure below) Once you've done a few dev to live migrations you will realize it's pretty much a non-issue. I *would* like to know what specific themes/widgets do that so I can simply avoid them. Drupal is not incredibly different either. From the Drupal guide: &gt; The data in the database may contain some hard coded links which will not necessarily work in the new site (it depends on what you are doing). You can use SQL queries on the reconstructed database to change these, or you can edit at this intermediate stage with a text editor - the .sql file is human readable text. Using a text search has the benefit that you may find unexpected areas to change in fields and tables you were not aware of.
This is an amazing resource. [Jeffrey Way](http://jeffrey-way.com/) is a brilliant gentleman with a knack for educating. I subbed up a few days ago and I've learned so much - and I thought I knew it all before. Even if you only go for a month if money is tight, it's totally worth it.
This is the best answer to the question. The other's seem to focus on learning Laravel. This answers the question of why. Laravel is a tool - an amazing tool - but still a tool. You need to do something to use it. If you don't have an idea then make something easy like a blog - those are still in... right? Failing that, heck, a static page about an animal, a hobby, whatever you want. Point is do something and use laravel as a tool to get it done. You'll learn best by doing.
Yeah, rsync wouldn't work for what you're doing. You probably want to use PHP's curl function. http://us2.php.net/curl
Exactly this. My preference of PHP is simply from a professional standpoint and not personal preference. Putting all my focus in PHP is best for business as pretty much every client and employer needs something in PHP. If I had to pick, Python is more flexible and fun for everything I do outside of web dev for clients.
My point is memory management still matters. Just not on the same level. You should still profile your code and know how memory intensive your programs are. Too little php developers are aware of that. Even knowing minor things like when to use array vs fixed array can make a big difference.
and also you should separate html from php logic into two files ; )
Yep - agreed. Wget is pretty lightweight - that would do a pretty good job of using all your available pipe. You could throttle it too - to leave some bandwidth for your actual website - assuming it's all on the same host/server. 
I never reply to these Laravel threads. But, most of us hope that Laravel loses some features, instead of adding more. 
People just love to hate CakePHP. 
&gt; You take criticism far worse, that was my point. Yes, you have totally seen past my facade.
How am I defending him? I am saying you are worse. With evidence. But hey, put your hands on your ears and keep going lalalala and then when you try think of something witty to say write it here.
Devs gonna dev. What the heck is the problem? What's any surprise? Ain't nothing wrong with using the tools you know.
I dunno man, what other stuff did you use? Did you try RoR/Django/Laravel? Imagine being in complete control of the URL structure, never having templates that are an unholy mess of code and markup, having a simple, intuitive way to address the database (with Wordpress, it's either WP_Query, or horrible, raw SQL), and not being bound by the inherent assumption of a blog. And stuff like Authentication/Authorization, Comments, etc. are available either as core features, or as popular addons, so it's not that much of a killer feature. What Wordpress has going for it, and these frameworks lack, is a great CMS UI. I mean, they have some sort of an Admin interface plugin (Django's is built-in), but it's not really on the same level, IMHO. But yeah, I know the cost of reinventing the wheel. That's why I didn't do it yet. But I've seen people on /r/programming and HN who moved from Drupal/WP to a pure framework and never looked back, so it might be an interesting experiment. And btw: what do you mean by "web apps"? You mean, essentially, web sites + some custom functionality? Because while I use WP all the time for CMS, I don't see what it gives you if you didn't want to build, well... a content site.
May I jump in? &gt; I've never had an issue with serialization/length I did. Stuff sometimes randomly don't survive the transition, such as the sidebars disappearing, site options randomly resetting, and so on. Look in the database. The *meta tables are littered with stuff like: a:5:{i:0;s:10:"wpseo_meta";i:1;s:10:"postcustom";i:2;s:16:"commentstatusdiv";i:3;s:7:"slugdiv";i:4;s:9:"authordiv";} Any time one of these strings happens to be your site's URL, and it doesn't happen to be of the exact same length as the Dev environment's, you're screwed. Btw, going on a tangent: why the fuck is the serialize() format like this? Why the hell do you need to store the length of the strings, as if you're reimplementing raw Pascal strings? JSON doesn't seem to need it. And neither does XML or YAML. Does anyone know what motivated the PHP devs here? &gt; Drupal is not incredibly different either I think that's what s/he meant by &gt; Mind you I'm not talking about absolute URL references in content entries. I'm talking about the CORE OF WORDPRESS storing you root URL/domain in the database for absolutely no good reason The only time Drupal stores the site's absolute URL is when the user entered it in some content field (something you obviously have little control over). And in that case, the recommended solution is to use a Text Format called Pathologic, that automatically converts user content URLs into the current site's. I've made quite a few Drupal sites, and I never had to touch its SQL dump at all.
Phil Sturgeon wrote: &gt;There is a really weird trend happening recently in the community that everyone wants to ... call somebody names, Phil Sturgeon wrote: &gt; Original PR dev asked why he was not included in an admittedly overly-dramatic way. &gt; ... &gt; Starts acting like a bit of a gentle flower, I don't think anyone else called anyone by names - it was only you. 
It's also very easy to program horrible, horrible things in C. The difference is that PHP will do its darnedest to run that horrible thing, and C will just vomit all the segmentation faults all over you.
As a fun thought experiment, you could always reverse engineer Wordpress as a brand new CMS in the language of your choice. While working with Wordpress isn't the most elegant thing ever, the team over there has patched a lot of holes and fixed a lot of mistakes. It's what happens when software matures, and that's something that no new language or rewrite can ever do on its own.
"On the other hand, exceptions are cases when our system may function in an unpredicted way, wrongly, or not at all if some specific data is provided in a wrong format. For example, in the above example, if the username already exists on the system, it is a case of an exception." I disagree. Firstly, having people forgetting they have an account on a website is "predictable". Unpredicable things are: not being able to save a file to disk due to file permisions, not being able to connect to the database etc. Secondly, I don't see why domain models can't have validation rules and, in case the model is not valid one might pass the error messages from the model to the form. There's no need to make your models throw exceptions when we know (100% predictable) that an invalid model should not be persisted.
Rewrites are always a tradeoff between time and maturity and more elegant and powerful code. On the one hand, you don't want to rewrite everything every time, on the other hand, if nobody wrote CMSes, we would still be using PHPNuke or some other abomination. And it's not like Wordpress can't be improved, so I'll end up re-implementing it. And I'm not thinking of using another language, btw. Just PHP + some framework. Seriously, look at how something like Laravel or RoR does things, and you'll see my motivation here.
Wow, you really are quite good at the trolling thing. How long has it taken you to get to this level of expertise? I must admit I am impressed.
Not sure if serious. You're not right? I'm tired and don't get jokes.
This might be way out of your comfort zone but you should look into queueing systems and work with one of those. Beanstalk is beginner-friendly and has a PHP library (Pheanstalk - https://github.com/pda/pheanstalk/) that's fairly well-used The way this works is you send the command to copy and convert the file into the queue and it will send that to a worker which processes the copy and conversion operation independently. You can have the worker send your users an email or something when the processing is completed.
I saw that the flags contained integer values and I tried to use that value but my method was unsuccessful. constant($varSortOrder) seemed like a good enough solution for my purposes. Thanks for replying. Learning a lot.
You're right that 3-5 are mostly non-issues (although Wordpress isn't just like Facebook just because it's MySQL/PHP ;), but I don't really agree with 1 and 2. If you look at the WP API it's clearly geared towards blogs, with a very specific page/post/taxonomy structure. People managed to hack it into a CMS, and slowly, they started somewhat accommodating that use case (custom post types for example, didn't exist before WP 3), but it stills shows its root *very* heavily. That's why you still have separate *_page/*_tag/etc. functions, why you can't set anything as the front page but pages or remove the default page or post types (except with ugly hacks), why the easiest and most common way to implement custom non-content pages is by creating a "page" with a custom "template" and so on and so on. As for the mess, I really don't think it's just misunderstood. When it comes down to it, it has a mostly procedural API (with silly things even for such an API, like the the\_* vs. get_\* functions), guided by a couple of global variables. It doesn't try to make separating templates and logic easy, and in some ways, encourages you to mix them. It has no real solution for routing, and its DB layer either a single gargantuan object that queries its default tables, or a mediocre wrapper for raw SQL queries. These are not misunderstood bursts of genius, they're flaws, borne out of its particular history and initial mindset. Mind you, I'm not saying that over-engineered crap like Drupal is any better. But if you compare WP's "framework" part to something like Django or RoR... it's just clunky as hell. And I asked about web apps, because you said you love writing web apps in WP. I don't think you'd redo Nest in WP, right? I mean, what would it give you in this case?
Format
if you were a pro you wouldn't care about your name being beside some line of text like some kid who needs his internet points
It seems that Quotes, Orders, and Invoices should all have Users attached to them, no?
Well, it was just an example to illustrate what I was talking about. As a hypothetical, pretend they don't.
Yes you may. &gt; I've never had an issue with serialization/length I realize that statement was too broad, as I do recall one time when I had issues with serialization/length after I changed the admin username directly through phpMyAdmin. Since then I've been using the Admin Renamer plugin which doesn't cause any problems. I don't really understand why they do serialization like that either, maybe it was a convention the developers used before adopting JSON. Since I do a lot of custom themes and plugins using JSON stringify() instead of serialize(), that might be why I've been able to avoid a lot of the serialization headaches during migration. &gt; a:5:{i:0;s:10:"wpseo_meta";i:1;s:10:"postcustom";i:2;s:16:"commentstatusdiv";i:3;s:7:"slugdiv";i:4;s:9:"authordiv";} Yes I am aware of serialization. That looks like Yoast SEO plugin stuff. Some of the problematic serializations (hard urls) can be avoided by activating plugins after the site has been migrated. &gt; Mind you I'm not talking about absolute URL references in content entries. I'm talking about the CORE OF WORDPRESS storing you root URL/domain in the database for absolutely no good reason There are a few discussions regarding this: [1](http://wordpress.org/support/topic/discussion-why-does-wordpress-store-the-tldabsolute-url-in-the-database) | [2](http://wordpress.org/support/topic/why-is-url-stored-in-database) | [3](http://yoast.com/relative-urls-issues/). Probably legacy code/backwards compatibility, or *if it aint broke don't fix it*. But to reiterate, it's not something that I've had to worry about. Karma suggests that my next site will suffer badly from this problem though.
Equality should rarely be checked unless you are expecting an actual value, and in that case you would use strict equality. In most cases, you can simply check for truthiness (your first example), which is anything but 0, false, null, empty string and empty array. To answer your questions. 1 - Yes, it's a bit overboard. Rarely need to typecast, PHP will do it automatically. 2 - Like previously, no need to typecast since PHP does it internally for comparison. 3 - They are equivalent. 4 - The former because it's faster and much cleaner. On a side note, databases usually return all values as strings. So your integer checks would be incorrect, just use weak comparison (==).
&gt; But if you compare WP's "framework" part to something like Django or RoR... it's just clunky as hell. It's not a framework, but the core devs are aware that it's evolving towards one and people are increasingly using it as such, so I wouldn't be surprised if it becomes an application framework sooner or later. &gt; When it comes down to it, it has a mostly procedural API (with silly things even for such an API, like the the_* vs. get_* functions), guided by a couple of global variables. These are signs of good backwards compatibility in my opinion. It's really difficult to re-factor core code when so many existing themes/plugins rely on it staying intact, so instead they introduce new patterns and function sets on top of old ones and everything continues to work. They could just throw out all the old crap in 4.0, but I don't think it would be wise. I'm sure they'll figure something out, and if things get worse I'll just switch to something else. &gt; And I asked about web apps, because you said you love writing web apps in WP. I don't think you'd redo Nest in WP, right? I mean, what would it give you in this case? What would it not give me? I'm mostly interested in the huge amount of end users and open source contributors, both of which are very willing to try new things and share their thoughts. In the end I would aim for something cross platform. I would share my current WP web apps but they're under NDA until completion/deployment.
You crazy bastard :) Love it.
From the subreddit FAQ: "Posts must be related to PHP, even if indirectly." I think the post qualifies as indirectly related.
A while back I even wrote test cases to see which was fastest. The first example that checks for truthiness is always fastest, and easier to work with. https://github.com/titon/titon/blob/master/tests/titon/ExprBenchmarkTest.php
use git-ftp to upload your changes. what it does it uses git to track changes, you can commit, add etc.. (use all the git features) then it only uploads what you have changed with this command. git ftp push -u yourftpusername -p - ftp://domainame.com/ note: git keeps eye on your files. whenever you change something it stores it. you can see what you have changed and turn back to it if you want. If you share your project with others on the git-hub website they can change stuff and you can see these changes. until you commit those changes it won't effect your project.
Yup, that's exactly how our environment works. 1. We use Vagrant and each person has a local install of the application running their own version from git (be it develop branch or their own feature branch). 2. Unfortunately they will still need to use Vagrant in our scenario. However if you build it correctly, you should only need them to install Vagrant/Virtualbox just like any other application, and then just run "vagrant up" after cloning the repo (which could be done using the Github application rather than command line). 3. We just have our public keys placed on the server from our chef build. Then as long as we have our laptop we can access all of the servers. Then in Amazon we can whitelist IPs to the MySQL server if needed. You can also setup a VPC in Amazon which allows you to use a VPN. 4. This is exactly how git works, especially on local machines. You never need to sync every change with the central server, so each person will have their own copy. You can also work on separate branches until you are ready to merge the work into master/develop. We have one staging environment that our develop branch gets pushed to which is for final QA before pushing live. Everyone just develops locally on their own branch. 5. Locally, each person has their own database. Staging is just one database that everyone shares (since it's just for final testing and QA).
It's for porn, isn't it.
I think the more important question is what you are going to do with it.
It's a very nice way of injecting anything into the request/response. I took some time today to dig more into it, the only complain I have is how much complicated this looks for PHP. I never touched any Ruby and understood Rack quite immediately by looking at the codes and example (including modules). I've been doing PHP for many years, and the HttpKernel/Stack it's so not easy to grasp. I much prefer the Rack way of just passing a plain old array of 3 values (HTTP code / headers / body string) from one middleware to another, because I see clearly what's happening. 
I'd be offended if you took that seriously. :)
Out of the names that people threw at me on Twitter over this today, and after the names being thrown around in the original PR, I don't think saying somebody is acting like a "gentle flower" is particularly offensive. I don't think it's EVER particularly offensive. Good try though.
I agree with the bad developer part, but I don't think a good developer could produce good code in anything.
I don't think that it does work great for so many people. Most users who are on it aren't aware of the alternatives.
This can be kinda tricky but there is a lot of code out there to help you these days. [OAuth 2 Server](https://github.com/thephpleague/oauth2-server/) This is a very spec compliant library which will help you set up a server. [OAuth 2 Client](https://github.com/thephpleague/oauth2-client/) This will help you get tokens for your Facebook users. The general way it all works together is that you have the following tables: oauth_* users credentials The credentials table stores the Facebook access_token, expires info, and a link to the user_id. Regardless of how they signed up (Facebook or native) they have a record in "users". They just have a `null` password, or a random one. Having null is handy, because you can avoid requiring them to "Confirm password to change account details", which is bloody frustrating if you don't have a password and can't set one without logging out to use the forgot password tool. As for _your_ oauth stuff, you again just attach stuff to the user. Your users have oauth_session_access_tokens entries or whatever the tables end up being called, and that has a link back to the user too. Ask away with questions, I've done this all about 20 times so I'll be happy to help. That brain-dump might not have got it covered first time around.
I think there is a connection, but it's more of a self-fulfilling prophecy. PHP developers have a reputation as being poor coders, so developers who want to be good are attracted to other languages. The ruby + python communities start filtering in better developers, which prove the assumption correct. I'm saying this as someone who started in web development going from Java to Ruby on Rails, then only after being forced to started to learn PHP in earnest. After actually learning PHP properly (and seeing its potential in projects like HHVM), I can really see the value of PHP. Still, if I go to the average Rails gathering, it's full of brilliant people. The average person who puts 'PHP' as a skill on their resume, however, is probably not up to the same level.
Oh Phil -- please stop trolling me - You are starting to creep me out.
Not sure if the downvote button means 'disagree' here, but unlike others I happen to sort-of agree with you on this. I do see a lot of clients push for technologies that they don't really understand, simply because they had "experience" with it in the past. A non-technical person really has no reason to push for say, drupal, since they don't even know why they'd want that technology. They could have no existing drupal assets, or even partner with someone who does, nor have any actual experience using it, and you could recommend strongly against it for a certain project, but a belief that it's what they need can somehow win the day. Dealing with that kind of stubbornness can be infuriating. (no offense meant against any drupal lovers. I'm not a big fan but am starting to get a bit excited for drupal 8)
Not natively, nor in a truly scalable and redundant fashion. You can accomplish it, but it requires load balancers, fail over, and a application level logic (or a proxy) along with being very, very smart about joins. NoSQL data stores scale much, much better, but come with their own mess of "it's not relational" and "what schema?" problems.
Specifically, use gearman to process the background jobs. Solid PHP intregration and plenty of examples out there. You can query gearman for state (if you care) or use a db to track that -- which ever. Then you can use ajax on page to periodically to check the state.
\*shrugs\* When I took a MySQL class, we didn't actually do it because we were just using a single virtual machine on our laptops, but we learned about MySQL's sharding options. It was native and built into MySQL. I can't talk about how well it works or anything like that, but I know it exists.
Again, you are mistaken. Mysql has *partitioning* which is not *sharding*. They are conceptually similar, but very different in practice. MySQL Cluster (a different application than just mysql) has true sharding, but comes with a whole host of it's own baggage which make it very dubious to use in many (most) situations.
No, we covered sharding and partitioning separately. They were separate options, and the sharding options were definitely labeled for sharding. I never used it, I'm just saying what I learned and what was covered in class.
You find me a link to the mysql server docs which says anything about sharding, because it doesn't exist.
Now we just need to see a load test :) ab -c5 -n1000 http://192.168.178.21:20000/
OOP is Objected Oriented Programming. cakePHP is a Framework thats happens to be also written this way. In other words OOP is a 'way' to program, whereas cakePHP is a prebuilt set of libraries and file structure to reduce the time to get going and help you focus on the important stuff. Look here and you can see that the Controllers in cakePHP are classes (OOP): http://api.cakephp.org/2.4/class-Controller.html One of the main reasons I like frameworks is because in addition to doing a lot of the heavy lifting, they just kind of remind you of all things you need to think about when developing a real website. That is, they will have facilities for logging, unit testing, MVC stuff, SQL building library, ORM, etc. Just trying to remember all the things you should be concerned about is sometimes confusing. 
Why?
a personal question with ur career in software dev are you self taught or do u have a degree? the reson i ask becaue i do not have a technical degree but i am looking for a software dev intnersip. i have been teaching myself with hopes of making it in software dev
Both self taught and I also have a B.S. in computer science. I learned BASIC programming as a kid from like 9-13, then stopped computer stuff altogether until I was 22 (1997). Taught myself web programming and got a job doing it in 1999-2002. Then I went back to school (2002-2007) and concurrently had a entry level C++ job (became advanced) that I had for ten years (2002-2012). I then went back into web dev in 2012-present, but am looking for a new web dev job. Just keep it up, it is hard at first, just stick to it. I'm no genius but have made a good career out of it.
I think it got fixed in the source but not in the docs. protected static $cardParams = array( [..] 'MasterCard' =&gt; array( "51##############", "52##############", "53##############", "54##############", "55##############" ), [..] ); I also see some LUHN-10 calculation in the same files. 
Just a quick edit, but reddit was first made using a very early version of web.py, but both codebases have changed dramatically since then edit: nvm, just saw the source and see references to pylons
So amateurs should just stay away from all keyboards right? 
In some cases it doesn't even allow good habits.
This is awesome. I too do something similar with my android phone, instead of lugging around my laptop, I bring my phone and hdmi cable to work and just plugin to the monitor with mouse and keyboard support, but Im running full blown linux.
&gt;I have a pretty decent server from digitalocean which should be able to download stuff faster than it is actually doing it. Did you account for the bandwidth of the source? It does not matter that you have a fast bandwidth. If a user posts a link from abc.com, then you can only download as fast as the server at abc.com can send it. So actually you need to use the same source when you compare download speeds from php and via directly downloading (via wget or something..).
Thanks so much Phil. I bought your book with this in mind to hopefully get it right ;) I'm still a little bit confused about how (once signed into FB) the iPhone exchanges the FB token, FB user id, expires info and email for a valid Oauth token. Would I need to create a custom endpoint for this task? Once my server has received and stored the FB token from the device and validated it with the FB api, creating a new user record if necessary, I need to respond to the device with an Oauth token. As this exchange isn't in the Oauth2 spec, I would need a write a custom endpoint, but how would I go about generating the Oauth token? Would I need to extend the Oauth server library to generate and store a generic token that hasn't been granted through a traditional Oauth exchange? I noticed the LOEP/Oauth server library supports custom grant types. I guess I could write one to work with a FB token exchange? After the Oauth token has been granted (by whatever means) I can keep it in the iOS device keychain and slap it into the request headers for my API calls. The server-side app will just check the validity of the token with each request. Thanks again. Edit: Grammarz
Makes sense.
&gt; I've told several abrasive issue commenters to be quiet several times I can't believe that didn't work!
&gt; we thought we could make a change without breaking backward compatibility, but we found out quickly we couldn't, so we reverted it. We Why do you keep saying "we" if it's just you?
I'm glad someone took the time to explain *why* Laravel is shit, but that still isn't going to decrease the amount of marketing this subreddit will see of it, and if anything, this is just giving it *more* publicity.
I did at first :/ Then I felt like a moron. In my defence I was very tired.
Pirate Box with a android phone? One possible use for it, no? 
&gt; Because I have yet to find &gt; most do not &gt; If you take a 100 firms, maybe 10 Your empirical standpoint is unassailable. 
PHP in it's current state would not be the best choice to learn programming from. lots of changes going on in the language, stable POSIX multi-threading just arrived to PHP, and my guess the language gonna go through couple of more changes until the next major version of PHP, it might take like 2 years or so (PHP in need of bundled JIT component, HHVM does not solve everyone's problems, but it's a good start). so I understand that for a lot of new programmers all this changes can be very confusing and frustrating. people should remember PHP is a language that was transformed from a language that did not focus on OOP into a language that offers pretty advance OOP features and it will continue do develop in this direction in the coming years. I personally don't like when people compare Rails with PHP, Rails a framework, not a language, you cannot compare the two just because PHP offers web features on the language level. that's what gives PHP an advantage over other languages when it comes to web. I came to PHP from TCL/Perl/C/C++ background, at the time PHP offered a lot of help and cool stuff much like, for some, Ruby offers today. I actually put my focus back on C++, because it offers performance, type abstraction, and and type checking, much needed for some web applications.
I appreciate your reply. There may be a misunderstanding because I learned PHP by toying with frameworks myself so I may not know some of the elementary level stuff. For example, I never wrote spaghetti code caused I learned MVC/OOP before learning PHP, I never included or required a file (had an autoloader), I probably never used `echo` in my entire life. I would simply pass parameters to view engine and output them using handlebars syntax. I always thought it was the correct usage because it made alot more sense to me. Same goes for PHP warnings, notices, silencing output, diplaying errors etc. They are so confusing and I don't know much about them. I always had a handler (basically a mini Whoops) in the custom framework which would convert everything into exceptions. With that said, I'm sorry if I ask questions like a real newbie. Those may be elementary level stuff. &gt; Auth::user()-&gt;authority === 255 This doesn't work on unix environments. How would you solve it? Loose comparison? Type casting? Something else? I got myself going with type casting, but as we both mentioned, it's becoming a hell lately. &gt; Similarly (and most relevantly) an empty string, 0, "0", false, or null are all things PHP considers to be false. I always checked for true, false and null. Should I compare null to null, or null to false? &gt; It seems to me you did that instead of fixing the problem. For example, it seems that you're using multiple different environments, developing on windows and then hosting on a Unix machine, or vice versa. Seriously, don't get me wrong. I always keep hearing this line. (I'm already developing on my Vagrant VM but that's another story...) Sometimes I need to test stuff on windows environment because some of my customers will have windows environment. I need to test if my application is stable on windows environment. But, I seriously wonder. Why some people think "syncing our production and our dev environment" is the actual solution? It doesn't make any sense. Shouldn't a good application work anywhere? If there is a problem about windows returning integer data from database columns, and linux returning string data from database columns, then isn't it better you fix the actual issue (probably casting to correct types and comparing them - it's an integer data, so it must be int, not a string) instead of equalizing production and dev environment? I may look newbie comparing to alot of pros in this subreddit, but this line never made sense to me. 
Everybody run "make test" and submit the results.
&gt; This doesn't work on unix environments. How would you solve it? Loose comparison? Type casting? Something else? I got myself going with type casting, but as we both mentioned, it's becoming a hell lately. I'd just do the loose comparison in this example. I've got no idea what Auth::user()-&gt;authority is spitting out, but if it is a string and you are doing === then I suspect this is why it isn't working for you. &gt; I always checked for true, false and null. Should I compare null to null, or null to false? if you are checking the truthiness or falseiness of something then don't compare it to anything... just: if ($isThisTruthful) { } will do just fine. refer to this: http://www.php.net/manual/en/language.types.boolean.php#language.types.boolean.casting 
`use function` requires you import functions one by one?
`use function` *allows* you to import functions one by one.
Not a book, but recommend it. http://fabien.potencier.org/article/50/create-your-own-framework-on-top-of-the-symfony2-components-part-1
The article, written by an anonymous coward, makes several non-points such as "oh it isn't a community project" (because community projects are so successful) and "it doesn't use semver" and then launches into a bunch of personal attacks on the character of the person who wrote the thing.. and this somehow shows "why Laravel is shit"? wow. 
Sorry, I meant there's no way to import all functions in a namespace unless you do it one by one or you import the namespace and call the functions with the namespace prepended?
full disclosure: i am the author of guard-codeception.
&gt; Yes, you have totally seen past my facade. In light of recent conversations I couldn't help but see this as quite a funny pun :) see past my facade.. chortle chortle. 
Knowing the context behind a statement is very important to _true_ understanding of what was actually meant. Some people's reaction on twitter was "Oh yeah, well f*ck that guy then, I guess contributors don't matter." Without the context behind it, then ya, I can see how they could take it that way. But once you learn the context, you see what he actually meant.
&gt; For example, I never wrote spaghetti code caused I learned MVC/OOP before learning PHP, I never included or required a file (had an autoloader), I probably never used echo in my entire life. I would simply pass parameters to view engine and output them using handlebars syntax. I always thought it was the correct usage because it made alot more sense to me. Yep! That's totally fine. But it sounds like you might have skipped some basic stuff, and that is combining with your previous experience in other languages to give you a mindset that isn't helpful in PHP. &gt; With that said, I'm sorry if I ask questions like a real newbie. Those may be elementary level stuff. Don't be. Your approach is actually good, it's just that, like I said, your mindset isn't PHP-correct. &gt; Auth::user()-&gt;authority === 255 &gt; This doesn't work on unix environments. How would you solve it? Loose comparison? Type casting? Something else? I got myself going with type casting, but as we both mentioned, it's becoming a hell lately. Well, I'm not sure what that code does, specifically. I've just asked Laravel for the user and its authentication, I've never bothered getting an authority level out of it. I can't help wondering if that's some code you added in or if it's an internal Laravel thing? In any case, it looks to me like something that should be actually using a bitwise comparison, rather than a straight comparison. It looks like a permission bitmask. Regardless, I think the problem is is absolutely that you're doing a `===`comparison. Ask yourself... why? Why the hell do you care whether it's 255 or "255"? What difference does it make to you or to your code? I guarantee you that 99% of your `===` usage is either doing nothing, or doing harm. There are places it's genuinely useful to make the distinction, but they're relatively few. &gt; I always checked for true, false and null. Should I compare null to null, or null to false? You should compare whatever you have to what you need it to be. Most of the time the question you're asking in PHP is not "what type did this return". It's "Did I get anything?" Whether that's a null, a 0, a false, or an empty array (all of which are "falsey") makes no real difference. I mean, it's possible that in some cases there IS a difference. False might represent an error, while an empty array or anything else represents a successful, but empty result. &gt; Sometimes I need to test stuff on windows environment because some of my customers will have windows environment. I need to test if my application is stable on windows environment. I would say wherever possible DON'T host on a Windows environment, but I do acknowledge that there is a commercial reality. And yes. You have to make it work, and maybe that does mean working with several different environments, but minimising it is crucial. &gt; Why some people think "syncing our production and our dev environment" is the actual solution? It doesn't make any sense. Shouldn't a good application work anywhere? Why? Seriously. What's "anywhere"? Dude got PHP5 running on an android phone... you going to support that? Hosting with only PHP 5.2? Does it work the same on Linux? Which versions? What about Mac OSX? Which versions of IIS will you support? What features will you disable to make it work with IIS? Are you going to disable htaccess rewrites? Will you support Nginx? What about directory structures. Some hosting allows certain structures and others don't. Will all your database features work? Do you have mysql? Or might you end up with oracle? The system needs to run on the environment it's going to be hosted on, and the environment it's going to be developed on. Anything else is pointless. If it works (a Laravel application should be pretty movable, for example) then great. But obtaining some sort of omni-compatible environment is pointless. And if you're developing on Unix and making it on Unix, then you spend a single second making it "Windows friendly" then you're wasting everyone's time and money. IMO (and I acknowledge this is controversial) PHP has no place on Windows. Everything from line endings to filenames to directory locations eats a dick in Windows. I say this as someone who used and developed on Windows for years. I just don't think PHP hosting is its strong suit. &gt; If there is a problem about windows returning integer data from database columns, and linux returning string data from database columns, then isn't it better you fix the actual issue Seriously, though, what IS the actual issue? If the columns work the same, whether you're getting back 1266 or "1266" does **not make the faintest bit of difference**. If it ain't broke don't fix it, and you only think it's broke because you're doing it wrong. I should probably point out that I'm not actually saying you SHOULDN'T make the two servers return the same type. There might be some benefit in doing so. There's a really big difference between "this would be better if it was consistent" and "everything breaks if these aren't identical". &gt; (probably casting to correct types and comparing them - it's an integer data, so it must be int, not a string) instead of equalizing production and dev environment? This is the problem here. Why would you cast the strings? Like... at all. This is the core of your problem. You think you need to do that. You don't. You **do not need to cast the values**. Here's an illustration for you: $s_amount = '9.95'; $s_quantity = '3'; $i_amount = 9.95; $i_quantity = 3; $s_total = $s_amount * $s_quantity; $i_total = $i_amount * $i_quantity; $m_total = $s_amount * $i_quantity; echo 'Total as strings: $' . $s_total . '&lt;br&gt;'; echo 'Total as ints: $' . $i_total . '&lt;br&gt;'; echo 'Total as mixed: $' . $i_total . '&lt;br&gt;'; Here's the output: Total as strings: $29.85 Total as ints: $29.85 Total as mixed: $29.85 Your experience in another language has taught you defensive programming, and strict comparison and typecasting is part of that. It does not apply in PHP. It does more harm than good. You need to stop doing it.
Auth::user()-&gt;authority is `int 255` on win, `string "255"` on unix. Yeah, I thought about doing a loose comparison, but somehow a strange feeling inside me tells me to use type casting with strict comparison. Not sure why, maybe I have a dictator mentality. Is there any chance a low level programming language doesn't support loose comparison so it stuck in my mind like this? I want to be aware of the data types I'm comparing. &gt; if ($isThisTruthful) { } Yeah, `Auth::check()` is one of those cases I can write as that. Is there a standard about it, maybe written in PSR, like "Don't use comparison operators while comparing thruthiness of the value."? 
i really need another book as well. i went through headfirst php/mysql which is nice for learning syntax and such. now i need another book and im having a real hard time finding a good one. i want it to be oop but i just havent found a good one out of the many i have downloaded. maybe my next step is a framework book, no idea so id like to see some comments
Because I was actively talking about the issue with other core members of the Laravel community on IRC as it was happening?
Christ, Taylor, just how many accounts do you have?
What phone do you have? I've always wanted to do this since I had a Bionic that was running Web Top.
can you please explain how you do this? I'd love to have a go..
I've no idea why it is a string on unix and an int on win... But really, go with it. PHP is not strongly typed. I only attempt to coerce type where I absolutely have to. This, on the face of it, isn't one of those cases... 
I don't know. I was told on Stackoverflow that it was a PDO related issue. In my opinion databases/drivers should return the datatype set on columns. I don't know much internal knowledge about why it doesn't. (or why it can't) 
The value of something like 1 + 1 or two strings concatenated will never change though. You still can't use a function call or something like that as a constant value, as far as I understand.
did they mess the first example?, they output the THREE constant which contains 3 and put it as a string 'THREE', code: &gt; &gt; &lt;?php &gt; const ONE = 1; &gt; const TWO = ONE * 2; &gt; &gt; class C { &gt; const THREE = TWO + 1; &gt; const ONE_THIRD = ONE / self::THREE; &gt; const SENTENCE = 'The value of '.THREE.' is 3'; &gt; &gt; public function f($a = ONE + self::THREE) { &gt; return $a; &gt; } &gt; } &gt; &gt; echo (new C)-&gt;f()."\n"; &gt; echo C::SENTENCE; &gt; ?&gt; &gt; The above example will output: &gt; &gt; 4 &gt; The value of THREE is 3
In general I think it does (although i've not actually encounted this particular issue). But PHP ultimately cares very little about type. In this particular case if you use loose comparison it should clear up the problem you are having. don't use the casts unless you absolutely have to (there are places where you will absolutely have to...but mostly you wont)
Have you tried the stuff at http://www.codecademy.com/tracks/php ? It's not a start-to finish app, but it breaks things up so logically that it lends itself to disjointed work.
They are still constant but you can use basic expressions. This would allow you to do something like `60 * 60 * 3600`. Obviously there is more you can do, but that's a basic example.
Yup, == does a 'loose' comparison (does internal typecasting to the same type) and === does a 'strict' comparison (compares type as well).
Yeah, shouldn't it be: const SENTENCE = 'The value of THREE is '.self::THREE; 
There's an Apress book about PHP and MVC which focuses on one web site.
The assumption is that PR's fall under the licence of the host project and grants a permanent copyright license/assignment (otherwise why would they make a PR knowing it would be merged into such a licence). In return for attribution...
Phil, never said the last paragraph applied to you. I simply stated what the wrong response would be in general terms. ;)
I'll have you know that the squid like spaghetti monster is a bone fide deity. Careful what you say ;). Yes, any framework that leaks (esp. with those damned service containers) into the domain will strangle you later.
Once defined, a constant is constant. I'm ok with that. :) I figure it can be abused (and certainly will) but allowing 24 * 60 * 60 with no speed loss is certainly a benefit, instead of having magic numbers in there.
Why Not? 
You know, I noticed you kept saying "type casting" rather than strict comparison, and I meant to clarify, but figured you must be type casting them THEN comparing them. :) That will really make a big difference to you. And yes, to clarify: === absolutely does not cast, quite the opposite. $id = '42'; if($id == 42){ // yep, this will run - // near enough, right? } if($id === 42) { // this totally will not - // strict comparison checks for TYPE } if((int)$id === 42 ){ // this will also run // the variable has been converted to an int // THIS is type casting }
It should indeed. I'll fix it up tomorrow — that would be why it's a draft. :) Thanks! *Edit: fixed, should be up on docs.php.net in the next few hours.*
Cool. Yeah all of those things sound bad.
This has been my dream since smartphones first came out.
&gt; The most memory efficient you'll get is probably by storing everything in a string, packed in binary, and use manual indexing to it. That's an interesting solution, can't say that I would've thought of that.
Also not a book, but here's a lengthy post about [making a blog from start to finish](http://www.daveismyname.com/tutorials/php-tutorials/creating-a-blog-from-scratch-with-php/). There are probably more guides like this one if you Google hard enough. You might want to stick with the ones that use PDO instead of mysql_connect to connect with the database though as the latter's been deprecated. 
That makes two of us. Bookmarked that question for future reference.
yeah i could see this being used to make constant times much easier to work with. 
How much would you pay for said book? What type of app you like to see built?
I think `num` should be `numeric` and behave similarly to `is_numeric`, to make it a bit more familiar, similar to the `callable` type hint and `is_callable` function. While this type of strict type hinting would be my preferred implementation, I know /u/nikic [doesn't like it](http://nikic.github.io/2012/03/06/Scalar-type-hinting-is-harder-than-you-think.html), which is a shame.
I've used this one a few times now: https://github.com/joelvardy/routes
I switched to Linux a year ago because it was so hard to have PHP 5.5 on Windows. They are a bit late :/ (and I don't regret it even slightly)
There's the Symfony Routing component: https://packagist.org/packages/symfony/routing http://symfony.com/doc/current/components/routing/index.html Projects using the Routing component: http://symfony.com/components/Routing
[Here's a dead simple example](https://github.com/rmasters/stack-timer) if you're wondering how it works. If you wrap your app (or an app wrapped in middlewares) with that middleware it will time how long it takes all of the enclosed middlewares to run, and then inject a note into the response.
My thinking was to show the question for context and then the natural progression was to read the answers. But in retrospect it could have been presented better. In the future I will try to do better! 
On further consideration, your comment indicates an interesting admission. You don't deny my point "the lead does not seem to deal well with criticism" you just say "well, you're worse!" So it seems we agree on my point about the lead not dealing well with criticism. As for me being worse, well, on that we still disagree.
http://www.packtpub.com/article/agile-yii-php-trackstar-application Yii has been updated since this is written, so sometimes the current syntax is slightly different than it was in the book, but this covers installation of framework, building the app from scratch, building unit tests, and so on.
That. 
https://github.com/h4cc/AliceFixturesBundle A symfony2 bundle that allows you to generate fixtures for your doctrine entities easily and fill them using allice/faker
I would just like to know why the fuck this hasn't been put in place already.
Nice!
Your answer OP's question is basically: "yes".
Do you need to know symfony2 before getting started with that?
Nowadays, anything like this has to make a case why its better than using a VM with a tool like Vagrant and automating the provisioning therein. I suppose if you're on a really underpowered computer that can't adequately run a Virtual Machine this would be OK.
you can read about each component as you go along the tutorial (i am reading it now, but i dont know symfony2, although i am already familiar with it because of laravel)
My advice would be to find a project you want to build yourself. As problems arise you can head to the web and do the research. A good real world example is the best way to learn IMO.
Yeah, I love PHP but the people making the decisions make me shake my head and consider switching languages quite frequently. Give me the ability to enforce strict typing and method overloading and I'd be giddy. :/
It allows for PHP to keep working like PHP does, as a loosely typed language. Where 1 == 1.0 == "1". If I can't pass those values anywhere and `int` is expected, then it breaks the loose-type-ness (?) of PHP. However, after rereading /u/nikic's proposal (linked to above by /u/mnapoli), I actually like that, as it allows for multiple user land implementations.
no. however, you'll learn much about it's components
And I got listed :) Thank you!
This RFC is closest to what I want: Accept a value of any type, as long as it can be cast to the target datatype **without data loss**. The RFC is still a bit too lax, it must also reject strings with leading numerics as numbers and some other minor details. Apart from that I'm fully behind it ;) 
Exactly. The whole getter/setter rfc being rejected because some thought it unnecessarily complicated syntax. Complete rubbish. The great thing about these is that you don't have to use them. Don't want to type-hint a function? Don't do it. You do want to enforce primitive types coming in? Great. If the language is going to continue to try to please everybody, then that is just sad. 
I'm sure that every single php-src developer has one or two patches for scalar typehints lying around ;) Just doesn't seem to go anywhere, ever \^\^ My preferred implementation is [this RFC](https://wiki.php.net/rfc/scalar_type_hinting_with_cast), just a *tad* bit more strict. Having it as an ext is nice, but rather limiting, as it doesn't allow default values.
&gt; backward compatibility Don't see any BC breaks in use Some\Functional\Namespace\*; =)
&gt; It could break _If_ that wasn't your intent to import _all_ the functions in the namespace, or if you didn't know that the namespace declared all those functions (for one reason or another)
Nice screencast! Taylor, how would you inject "Illuminate\Routing\Redirector" through controller's constructor? It seems that it requires some setting up like it is done in RoutingServiceProvider in order to work...
"It allows for PHP to keep working like PHP does, as a loosely typed language. Where 1 == 1.0 == "1". If I can't pass those values anywhere and int is expected, then it breaks the loose-type-ness (?) of PHP." it will be ok (for php to behave like loosly typed), if we didnt mention the type in the function def. if we did mention the type(int,str,float) then it should behave like a strong typed system. (i do like the __toScalar part though)
Does anyone else have the issue with HHVM saying [password_verify()](http://www.php.net/manual/en/function.password-verify.php) is undefined? Running under PHP-FPM I have no issues, but with HHVM my login functionality breaks with the HipHop Fatal Error: password_verify() is undefined.
while this is a great improvement.. I still find the lack of `const C = call();` disturbing
+1 for that RFC. I also like the scalar box type hinting concept but the proposed RFC seems more realistic. After strict type hinting is implemented I'd personally like to see some generic scalar magic for objects. https://gist.github.com/codenamegary/8604032
are there plans for functions' autoload? I know there was a RFC..
Yeah, and in many cases they seem more interested in catering to the people who give PHP a bad name by writing shitty code. IMO it would be more beneficial to cater to the professionals among us. PHP gets a bad reputation because of these people, and in many well respected/large organizations is not even on the list of languages to consider because of this. They need to make smarter decisions on who they want to be the ambassadors of the language. If it was me, I'd pick the people working at high-profile companies who want to write good code. I like PHP for the most part, but I know other languages as well (C/C++, Java, Ruby, Python, Perl). I work at one of the largest tech companies in the world. I write good code that would be considered good code regardless of what language you port it to. However, I could write even better code if you gave me some of the tools available in other languages. Don't make me do things like check parameter types and weave a maze of conditional logic when it's much simpler, clearer, and more concise to use overloaded methods. So my statement/question to PHP core is: I've stuck with you for years and years, hoping that you'd get over yourselves and work to improve the language. Instead, you're bleeding good developers to other languages like Python/Java/Ruby more and more. Lately, there is hardly a single day that goes by where I don't consider changing languages because of only a few features that you simply refuse to add. I see what you are doing to keep the programmers on the lower end of the spectrum....what are you doing to keep people like me? I want to love you, and I want you to love me back.
My school sucked, but I was always taught that a string is typically just an array of characters. In many languages, you could even access a letter in a string by something like $fourthLetter = $exampleString[3]. Sure, strings are often objects now, but I would have thought that the characters themselves would just have been in a simple array in the object. 
&gt; If that wasn't your intent to import all the functions Well it definitely was, since you used `use NS\*;` syntax.. But yea, &gt; it could break didn't think about it
Shameless plug: I have a [buffer](https://github.com/nikic/buffer) PHP extension, which implements typed arrays JS-style, using "buffer views". You create a fixed-size buffer and can then create views of different types on it. E.g. you can interpret it as an int32 array or a (half as large) uint64 array or even a float64 array. This requires low memory usage and the reinterpreting of data with different types is useful for some things. (The extension was developed as an example for the [PHP internals book](http://www.phpinternalsbook.com/classes_objects/implementing_typed_arrays.html), but it's also practically useful.)
/r/phphelp
Link for the very lazy: [Pro PHP MVC](http://www.apress.com/9781430241645)
Sounds reasonable enough. Do you think (for example) that passing a float to an int should warn, but then carry on? Or do you think that should be a flat NOPE?
http://shop.oreilly.com/product/mobile/9780596157142.do I learned a lot from this book, and could easely recommend you any oreilly book, or lynda video. They are great for bigginers
You must be referring to that aastle guy who neither named nor linked the book he referenced. 
I have this book. I bought it to learn the Yii framework. The book is ok. There are some errors in the text which take time to resolve. Also, it is very much about using test driven development (TDD) which really should be a book of its own. It is annoying to have to use TDD when you really want to just learn the framework. Installing PHPUnit and Selenium can be time consuming as well. So if you get distracted easily OP I would be careful with this book because the first few chapters are all about setting up an environment for TDD, which is boring and maybe not what you are looking to do. 
That's basically the only place I'm not sure about: What to do when a float is not exactly representable as an integer. I'm leaning towards the flat nope. Floating point arithmetic, especially as relates to accuracy, is not particularly intuitive and we shouldn't do guessing here. The user should specify the action he wants (round, truncate, ceil, floor), rather than PHP choosing some (probably wrong) behavior.
Not sure what you mean... the accepted answer is not really the same as accessing a string's characters by their offset like you would an array (and which has always been possible in PHP): &gt; $s = 'foobar'; &gt; echo $s[5]; r The accepted answer actually serializes the data as binary. &gt; Sure, strings are usually objects now Um, no they're not? At least not in userland they're not.
Same reason backdrop cms was formed. "I don't want to change or learn or move forward. I like my stuff the way I like my stuff."
So Googling "Apress PHP MVC" is too much strain for the average redditor?
The funny thing is that *you* brought it up and yet *you* couldn't bring yourself to provide a link by googling "apress php mvc." See, *you* are the very, very lazy. Get it?! It's snicker-worthy, at least.
But copying and pasting the link and formatting with reddit's markdown code is extra work.
The HHVM featureset is a hybrid of 5.5, 5.4 and 5.3. They probably haven't implemented `password_verify` yet. Consider using [`password_compat`](https://github.com/ircmaxell/password_compat) in your code until they fix it.
/r/phphelp
I would argue that learning TDD is a good practice, but you make a fair point.
A better question would be: "Is there a PHP book that builds one web app from start to finish WELL." I personally have yet to see one.
Does terrible things on multiple occasions, like most of these tutorials do: * pointlessly allows NULL in database fields - no, NULL is not the same as an empty string * no indexes on anything except the primary key - not even on dates * hard codes credentials in constants - this is not what constants are for! * mixes business and presentation logic extensively - no use of templates * pointlessly catches exceptions and throws away stack traces - don't catch it unless you intend to handle it properly * uses submit buttons to check for the presence of a POST - causes problems with some older browsers * validation on inputs is weak and only consists of whether a field has data * no output entification at all - rife with XSS issues * destructive operations performed with GET instead of POST - this is a big BIG no-no 
But that wouldn't be a constant then. Would it?
If you have basic HTML/CSS knowledge, hit codecademy.com It really helped me out.
Does it have to be in memory? Depending on what DBA extensions you have installed on your server, you may be able to read and write the data to disk, keeping your memory footprint low at the expense of a slower lookup. I was curious myself and I wrote a quick command line script to compare the speeds: [https://gist.github.com/anonymous/8607102](https://gist.github.com/anonymous/8607102) The DBA (using the 'ndbm' database) method was about 12 times slower than the in memory version. This was done on a 2.3GHz Intel Core i7 Macbook Pro. It may work differently in your situation, and you would have to see what DBA extensions are available on your server and try them out. Also, if you don't have command line access to your server, you will have to mangle the above script to get it working. 
Dude, I've been there, and honestly, if you're anything like me, this approach won't help. What you need to do is come up with a medium sized project and break it down into small chunks. Then make sure you only focus on one chunk at a time, learning as you go. Why do I say the "one book, one project" approach is bad? You'll find it dry, and boring, the book(s) will drift off onto concept stuff and theory and best practice, when, if you're easily distracted like you say, you need something to keep you engaged. Also, people who are easily distracted tend to need challenges and puzzles to solve, which is where books fall down, their is no puzzle or challenge, the answers are right there, in the book! Here's a simple one for you, consider making a custom dynamic personal blog, something for yourself, something which you'll never actually use other than to make 5 or 6 posts before you get distracted from trying to update it regularly and slowly drift onto the next project. As negative as my description sounds, this project will teach you PHP programming basics, PHP sessions, PHP cookies, MySQL (or Postgres) Database architecture and interfacing, CSS and HTML markup (if you don't know them already), using Javascript frameworks and off the shelf components. So, lets break it down into bit sized manageable chunks, I'm not going to point you at tutorials etc, that's half the challenge you'll want to address to both keep you engaged and give you the independence you need: * 1 - A way to put data into a database. You'll end up creating one table of probably four columns, and a single PHP page that does nothing except allow you to enter data into it, hit submit, and see in phpmmyadmin that yes, there is now data inserted into your new pristine database. * 2 - A way to display the information from the database. You'll now work on laying out multiple records from a database, formatting it into something that's moderately pleasing (or at least vaguely acceptable) to you. * 3 - Security, you'll look into how to create some method of authenticating with the system and doing so in a secure manner (salts, hashes, etc) * 4 - Advanced editing, you'll look at implementing something like TinyMCE or FCK editor, and then you'll consider what about if you need to let other people add content, so you'll start considering data validation and SQL injection attack mitigation * 5 - After researching the stuff from point 4 you'll realise that although you followed PHP MysQLi code examples and methods as there were more examples and it was easier, you now really need to update all of your database code to use PDO to be secure, and it no longer looks quite so frightening (even if most of the examples do still use Object Orientated Programming (OOB) syntax and you still don't quite understand). At this point you stop, and realise you've just made a completely database driven website from scratch, learnt PHP, SQL and a number of other things along the way, didn't lose interest and saw it through to the end, and it only took a weekend. Now you just need to choose a project you want to actually write, break it down into bite sized chunks and charge in! Bearing in mind, you will hit points of frustration, you will realise half way in that you made a massive mistake in working out the complexity of something and now it seems far easier to leave it till later and load up Bioshock Infinity until so much time has gone by that you've let your project be forgotten about and gather dust and when you look at the code you wrote it all looks like greek. Take it from me, I've been there, I do this, I'm a hobbyist coder, I don't code for a living, I have to try and force myself to not get distracted from my projects, in fact as I'm writing this I'm distracting myself from my current next idea (http://wat2doo.com), but stick with it, follow the basic steps I outline above to learn the basics, and then fail 5, 10, 20, 50 times or more before you finally develop that one site that might make you a decent return. **edits and addendums:** * I know I may get knocked for this from proper devs and this is just my opinion, but, unless you're already comfortable with OOB programming techniques, then leave them for now, yes, they're beneficial, but for someone just starting, or maybe just me, they're a lot harder to get your head around than basic and simple PHP programming. * Avoid the frameworks, you don't need to know about controllers, and views, and models right from the day zero, these a bigger concepts you can learn in time, for now, focus on making something robust that works. Frameworks are something you can look into a year down the line when you're already comfortable with coding basic PHP sites from scratch and you can now start to understand the concepts.
I get where you are coming from, totally. I have certainly had a debate like this in my mind, which would be better. I appreciate the details you've included.
$30-40. Basic crud operations with an eye toward maintaining business layer, presentation layer, and data wrangling.
&gt; Apress PHP MVC [this one I assume.](http://www.apress.com/9781430241645) oops, link below i see. thanks. 
In all fairness, I was just mentally splurging my own process that worked for me. From your brief description you sounded like myself and so I thought my learning lessons might be of benefit.
That's not the same...
Pfft, Geenstijl...
&gt; I would have thought that the characters themselves would just have been in a simple array in the object. Nope, that's woefully inefficient. If there's any language that does it that way, I'm not aware of it, unless you mean in the C array sense of being a list of bytes you can index into.
[/r/phphelp](http://www.reddit.com/r/phphelp)
Sorry didnt see that one ill delete this and repost it there thanks!
I'm more surprised that developers implement the first example in the first case.
I was unhappy with the only existing library (very low quality, no namespaces, no tests) so I wrote this one following TDD, DI, PSR-4. This library also parses both YAML *and* Markdown. The package uses Symfony YAML parser and Parsedown for Markdown, but any parser can be used thanks to an abstraction based on very simple interfaces.
I can't believe I've never heard of this. All that wasted time... 
Or just write Java or C# or Scala or something. PHP is a dynamically typed scripting language. Adding runtime typing may be attractive to some, but it also departs from the long-standing tenets of PHP.
What's the correct implementation?
This is why imperative programmers should explore functional programming. It isn't completely averse to OO and it can make your code far more terse and readable.
Frankly if Wordpress were rebuilt from the ground up keeping much of its functional reactive/actorish logic in place, I'd be fine. It is just a damn backwards compatible mess.
A foreach in your template *is* logic in your template.
It's not going to be significantly slower, and if it does you worry about it when it's a provable performance issue.
Terse sure. More readable? Debatable.
You're right, I'll explain what I meant. I think if/else and loops are okay in templates. I don't think setting variables or doing arithmetic operation is okay. You should use a presenter or something. I always forget that if/else and loops are called logic too. 
&gt; this god forsaken format Why's that? I can't think of a structured format that's easier to read than Yaml. 
It is easy to read, but in terms of parsing, I couldn't find a single worth while solution. Some libraries wanted to give me a proprietary response while others didn't even work.
I see. Would you call the example in OP's post business logic? Seems like presentation logic to me, but the kind I don't like. 
This is the sort of thing someone writes in an hour. I mean, congrats and all, but lets be real here. You took two well designed libraries that were written by other people and duct taped them together with about 100 lines of code and you're trying to make it sound like a "I saved the day" major accomplishment.
It's presentation logic, and there are definitely other ways to do it. You should do it the way that makes sense for you.
TIL I am a fool.
By making a special point to tell us about how the "other" library was "low quality" and then throwing in as many programming buzzwords as possible. Isn't it enough to just pop in and say "Hey, I made this thing that does X/Y/Z, it saved me some time! Maybe it will save you time?".
The other library has no tests and no namespaces. I thought it was useful to explain how this one is different. I hate the useless multiplication of trivial libraries doing the same thing, and I know it's the first question you get on Reddit (and it's perfectly valid): **why?**, or "how is this one different". So yes, I said TDD because I took care in the testing (particularly handling weird cases). I also said DI because I took care of abstracting the underlying YAML and Markdown libraries behind interfaces so that one could provide any parser of his choice through dependency injection. That's useful to know (IMO). Yes PSR-4 was a "buzzword", it's fairly new I thought maybe some redditors will be curious to see it used in the while. Sigh... You don't have to be all negative.
If it makes you feel any better, you did do a good job. It just seems like many people here have a special interest in showcasing the trivial and expecting praise for it.
He/She is grabbing two lots of 32 bits (4 chars is 4 bytes, 4*8=32). By doing the shifting &gt;&gt;32 on the way in and ORing on the way out they are encoding the high half and low half of a 64bit number in 8 chars. So the limit isn't 0xFF because they are using the full 64 bits, it's 9223372036854775807. 
Well those who accept patches via email (who were connotated as "the pros") actually note the author of the patch per each git commit in the author field which is different from the committer field. You perhaps didn't know, even you talked about accepting patches by email. So hopefully this is useful information to you, which is not really fancy at all but just keeping track of changes in a common and useful way.
I guess that would be useful if people still used PHP for templating.
I guess you'd have to since nobody's going to buy that shit.
I think I'm in your camp with this too. There's an argument to be made for respecting PHP's traditional weakly typed philosophy, but surely the primary use case of enforcing some kind of type hinting is targeted at library / package developers. Now if I create a re-usable library I'm choosing type hinting to enforce standards that other people's code consumes in which case when I create: public function foo (string $bar) { } The contract is essentially saying, this particular part of the library requires a valid string type to be passsed to function correctly. Now as a library developer I've specified my requirements, it's then down to the consumer of the library (ie the end user) to fulfil that contract. They are more than welcome to cast before calling the method.. $run = new Library; $run-&gt;foo((string)$someArbitraryVal); But as the library developer I want to be able to set the rules.
Would you say this is out of pragmatism, ie what is going to get past the old-school internals members or out of actual language design. As I mentioned below in this thread, this is a feature that is surely aimed at package / library developers that want to enforce a contract with the users. So if my maths library has the following.. public function fibonacci(int $i) {} Then I'm trying to pass the error checking onto the library and ask the consumer of my library to provide a valid integer as input. The user is welcome to cast his array / string before consuming the library but that would surely be an option down to the user's discretion, not the PHP engine to make arbitrary conversions. 
Out of actual language design \^\^ I think that PHP's approach of considering "123" and 123 and 123.0 to be "about the same" is quite okay, especially as the language often deals in context where everything is a string (HTTP, RDBMS, ...) The big problem in PHP is that while those conversions make sense, other don't in the least. E.g. "foobar" being about the same as 0 is pretty ridiculous, as is " 123 foobar" being the same as 123. If you get rid of all those weird cases, the automatic casts are fine. Actually, if you force people do to an *explicit* cast you will make everything much worse, because explicit casts have nearly zero sanity-checking and you can cast nearly every type to nearly every other type. If you are forcing explicit casts you loose the type safety.
If you have nice (good/middle/low) knowledge level of the Laravel4 just use it. Don't use framework which you don't know. It's may lead to problems. &gt; I was going to use Laravel but here in my country there are very few devs who use it. why is important? :)
As laravel in many parts use sf2 components I don't see why symfony developer won't get laravel. At least if they call themselves a real programmer. I for myself use sf2 in business and got all concepts of laravel and how what workmen and in what way it worked at first glance. I also really like laravels orm after seeing the first examples. A bit different than symfony default orm's but as laravel is constructed to be easy understandable there is - in my opinion - no problem using it. In fact you will safe your current job if there are less ppl's knowing what's up. But to remind you. Never use my last argument to satisfy bad programming in general. But in this case I used it there should be no problem. ^^ But sf2 shouldn't be so hard to understand either. You may look at it and if you get the concepts after reading their really good book like documentation then try to use it and if it fits I. Your style use it. Otherwise stick to laravel. 
It's not something I run into very often, but I'm pretty adamant about not mixing presentation and structure. IMO, if you want to create rows, each holding 3 items, you should be handling that with CSS, and not markup. My reasoning being that the website might undergo a redesign sometime in the future in which that grouping would become a linear list, or maybe rows of 4 items in each. I try to create markup which is fairly design-agnostic, which saves me the nee to rewrite it in future iterations of the website.
&gt; ab -c5 -n1000 http://192.168.178.21:20000/ You asked for it :) 1000 requests to phpinfo() (internal php webserver) on my CUBOT-GT99 http://i.imgur.com/gsOUPvF.png Load while under phpinfo() test: http://i.imgur.com/DqBRXG3.png 1000 requests to plain html http://i.imgur.com/MyNR5GM.png 
I'd say skip the survey and just put it up on github, then link it here. If people want it, they'll use it, fork it, star it, etc. If they don't, at the very least you're doing it for yourself :)
Awesome! Did better than I expected.
The response to the survey has been very positive so far. It’s not in a publishable state at the moment, it’s just a proof of concept.
Can I just ask, as a non-Python person... what's the difference between Django and one of the many existing PHP frameworks? &gt; I really miss logical framework like Django By saying that you're saying all PHP frameworks are illogical, and Django-like is the only logical approach? Have you actually used PHP Frameworks at all? Serious question.
You need to do a much better job of explaining what *Django-like* means before you get anyone to invest.
It’s impossible to describe the difference(s). You’d really have to know a little of Django to get it. It’s generally the way Django implements its API. It just makes sense. Yes, I have used most PHP frameworks. I’m not saying all other frameworks are illogical. I put it wrong — sorry. What I meant was that with Django everything seems to make sense to me. Some PHP frameworks are fundamentally bad (CodeIgniter); some over-engineered (Zend); some are good, but implement things in a way that tend to make me think “I would’ve done it differently”. It doesn’t happen with Django. It’s a really well thought-out framework. Hope that answers your question. Thanks for your input!
Certainly an interesting problem! Thanks OP. One of the few examples these days where every byte counts.
True it is debatable. I find the use of array transformations much more readable and reliable than a smattering of loops and index dependent logic. Array_chunk does what it says. The first example is far more fragile.
I've been using http://teamtreehouse.com and I just did this. It literally walked you through how to create a T-shirt store online. I'm eating back into PHP and it was a great refresher with arrays, functions, objects, etc. There are also more advanced tracks which build applications with MySQL. For me this approach worked week because the video tutorials were broken up by code challenges and quizzes. Dinnertime I had to go back and re-watch snippets to see exactly how I could do something. I was lucky to have gotten a two year student account fur free through their 'scholarship' program, but it is an online learning tool I'd pay for. So much to learn and the teachers seen to know their stuff. 
&gt; Is there any chance a low level programming language doesn't support loose comparison so it stuck in my mind like this? ABSOLUTELY. In fact, many, many languages such as C, C++, Java, C#, just to name a few, do this. In those languages, if you compare two variables of different types, your code may not so much as compile unless you do an explicit type cast. There's a lot to be said for that but PHP people are used to the loose typing and that has a lot of advantages too. I can certainly see why this would be confusing to you, if you're coming from a nicely rigidly type-checked environment as the ones mentioned above. As others have pointed out, though, it doesn't work that way in PHP and you are really better off going with the flow as opposed to trying to introduce type strictness in a fundamentally loosely-typed environment. Of course, this does come with having to think about your types more in terms of security: for instance, you need to escape your numbers in database queries if they could be strings. But as long as you always think about what you're doing (and you certainly seem like you do) you should be fine. I've seen a C#/.NET guy put comments all over legacy PHP code just so he'd know what type the arguments of a function should be. These days, you can type hint, but when this code was written, there was not yet any such thing in PHP. The loose typing drove him nuts. I'm sure there are more stories like that around. So you're not the first!
Yeah, thanks alot for the valuable information. Much appreciated!
I would personally use a keystore (like Redis) and store all my numbers there, in a set or a sorted set, then fetch them when I need them. That way, you can scale to much more than 600k numbers if, at one point, you need to increase. I just read that the guy asking the question couldn't change his memory_limit, so he probably didn't have a Redis server somewhere. Oh well.
Build a simple cms. It'll teach you a variety of different core attributes to web development with php. Be sure to break down the project into manageable chunks that you could complete on a regular basis. Saves you from getting over frustrated and burnt out. 
Start coding. Don't worry about doing it "the right way". You'll never do it the right way the first time, and even then there's always debate about what's "right". I'd also avoid unit testing for now. It's just another hurdle getting in the way of you writing code and getting results on your screen. The biggest hurdle to getting any project done is the crippling fear of not doing it perfect the first try. You could study for months, and never write a single line of code, or you could pick a project, and start writing. It will probably be bad and "wrong", but you will learn SO MUCH. Stuff like IoC doesn't really click until you discover how it's useful in a practical context in an application you're writing. The best way to ease yourself into Unit Testing is when you find yourself writing a complex piece of logic - especially something that deals with lots of different conditions and has to react in a lot of different ways. Pick a project. Maybe there's something tedious you do at work that could be made easier with a tool to streamline it. Maybe you need something to help you budget better. Maybe you need something to help track who lent who what between your friends. Write something you'll use. That will motivate you to keep improving it.
IMHO it doesn't make a blind bit of difference if lots of developers in your country use Laravel or not. Any half-decent developer can pick up Laravel in a week or two without problems, and any developer who can't, probably needs to start looking for a different job.
I think a better thing to do would be to ask yourself "would I like to see a django-like framework for php?". Do it for yourself if you need to scratch an itch. If others like it, they will adopt it. Most people around here already have a favorite framework that works for them. This doesn't necessarily mean that it would preclude them from trying something new but you can't expect people to jump on a bandwagon without some understanding of what the bandwagon is about.
There's no backwards compatible way to do that with css. Many of us still care about that. 
However he does it, obviously. 
Hoa looks quite interesting but I must ask, why use unicode for function names? That seems like a pain in the ass.
You are so full of BS
The original template was written in Laravel's blade templates. I replaced the @foreach with &lt;?php foreach(): ?&gt; so that it was more universal.
It's not that difficult to use e.g. Doctrine with Laravel if you prefer something else that Eloquent (the Laravel ORM), but still want to use Laravel. Then again, there is quite a few things you can do to optimize Eloquent's queries as well (although it still might not be quite as efficient as some others)
Before all, thank you to stay polite… So first, actually, you have to wrap the execution in a specific environment in order to monitore the execution. Also, the execution has to be isolated. That's why we write code (from lines 23 to 74). Next, I do not ignore coding styles… Since when using a foreach without brackets is “unacceptable”? Same “question” for a multi-line statement. Also, 30 LOC for a function is not “huge” as you mentionned. It's perfectly reasonable according to the service it offers. Why a closure? Would you prefer a function instead? Or an object with a static method? Why is it a problem? I think you miss the fact that this is a POC, a proof-of-concept, to show how to mix and combine technologies in a simple way to go further with our lovely language.
No, not really. Plain regex URL routing and active record models isn't exactly the kind of solid foundation I want to build an app of any complexity off of. That's not to say that Django doesn't have its place, mind you. I'm sure it works wonderfully well for lots of folks and lots of projects, but it's not innovative or outstanding enough to clone, in my opinion. If you're going to put the work in to create *an entirely new framework*, you should probably have a raison d'être, and "liking the API" doesn't seem like a very good one to me.
Of course there is (depending on how far back you're talking). Responsive grid systems in modern CSS frameworks rely on this.
Of course. There's no reason to fly off the handle just because our opinions differ, and I do understand that it's a POC. I think what's irking me is that this IS a cool way to push the language forward, but it does a disservice to itself by using styles that would be considered bad practice in most cases. * For line 23 - 74, could you not use `file()` to write the script to `writeAll()`? You could interpolate the variables in that data. You could also do something like this (though again, probably bad practice in most cases): - &lt;?php // HOA harness code ob_end_clean(); ob_start(function($script) use($master) { $master-&gt;writeAll('&lt;?php ' . $script . ' ?&gt;'); return null; }); ?&gt; // Write your php code here, minus opening/closing PHP tags. declare(ticks=1); ob_start(); // ... &lt;?php // rest of your code ?&gt; * I didn't say not using brackets on a foreach is unacceptable. If that's your preferred style, that's fine. What I do feel is unacceptable is the multi-line `else` statement that is bracketless. At first glance, it just looks incorrect. Perhaps that's just me, but if I see multiple lines in a bracketless statement, I have to investigate to be sure something isn't wrong there. Regarding the foreach, it bothers me that one is not using brackets (and wrapping a lengthy block of code), while the second one is not bracketless. Why not write it like this, if you prefer bracketless statements? function commentOutput($output) { if(false === strpos($output, "\n")) return ' // ' . $output; else return "\n" . '/**' . "\n" . ' * ' . implode("\n" . ' * ', explode("\n", $output)) . "\n" . ' */'; } foreach($_trace as $file =&gt; $outputs) foreach($outputs as $output) $code[$output[0] - 1] .= commentOutput($output[1]); * I personally feel like that complexity of the closure warrants not using a closure, or at least not an anonymous function. You're passing in 5 variables, and you're doing quite a bit of work there, including sending data, receiving data, parsing input, and formatting output. Would that not be more manageable as multiple functions at the very least? Preferably a class (you can do this without static methods)?
Thanks for sharing.
With this book you basically build an blog from scratch: [PHP for Absolute Beginners](http://www.amazon.com/Absolute-Beginners-Experts-Voice-Source/dp/1430224738).
I think that given most frameworks consist of the same frameworks, the learning curve for any after learning one won't be as steep as it would be if you didn't know any frameworks. You know the components you need to use to do things, you can research those things when you come across them and will likely understand then when you do. I've been using Symfony2 for a while now, but I do remember it being fairly easy to get started with. There are lots of tutorials, and lots of help available online.
Do what I've done: get yourself some HTML + CSS skills (basics are okay), download a framework (Bootstrap or Foundation are perfect) and built small webtools. 
A good example of not knowing the language API. // 1st piece of code obviously
&gt; I've never heard of this Lear builtin libraries, you'll find so much useful stuff ;)
Resubmit the link when it's in english until then: No comment.
I think that the idea is that by avoiding joins means that more queries hit the query cache – a join means that a change to any of the tables will invalidate the whole query (in MySQL anyway). Whether that is correct for your application depends on many things.
Yeah, but that's just mysql.. which I also avoid like the plague. Postgres is where it's at... at least where an RDBMS is needed
Eager loading isn't what I want.. so I just do the raw db queries. 
While I don't necessarily disagree, you have to keep in mind that PHP has over 5,000 built-in functions
I might be wrong, but I think that this might also apply to postgres.
Your welcome! I hope to build a bunch of base boxes for some more projects to help spread awareness. I hope some day that any language, platform, software, etc can just share around the YAML files to get a dev box going in minutes.
This might be interesting, but I can't draw my eyes away from the logo to read any of the material...it's a giant pink cock, isn't it?
I can understand that view point and I get it, but im not sure if it's the "PHP way". The rule here is "if it can type cast, its allowed in. If a type-cast wouldnt work, then fuck that input." It keeps it entirely with PHP's weak typing, but allows the method to work with the data with absolute certainty of its type. That sounds super powerful to me. The other suggestion is to have default weak with other syntax in there for strict. function (string! $foo) Or something.
He may not be at that company forever, and he wants the devs that later have to support it to be able to do so with ease?
For example its misuse of objects. CI treats objects like namespaces. This is a fundamental problem.
What I meant is it’s impossible to compare frameworks in a Reddit comment. It’s not a bullshit cop-out response. Me explaining differences between Django and PHP frameworks is outside the scope of this simple survey. It’s directed at people who know something Django.
This is a very constructive response — exactly what I expected. Thank you. What’s wrong with “plain regex URL routing” (it’s not really that in Django) and active record? These are two of many features whose implementation in Django I really like. I don’t agree that liking the API is not a good enough reason. API defines how you write code. It’s all the reason to choose one framework over another.
I agree with /u/dadamssg that Symfony2 is more complex than Laravel. However when porting a legacy project it might be a better idea to slowly introduce one Symfony2 component after another (I'd start with HttpFoundation or Twig). This way you don't end up with the everlasting state of "some is written in the old way, some in the new way" but make the whole code base better with every iteration. By continuously deploying what you have you also make sure you don't have any regressions.
&gt;I’m not trying to get anyone to invest &gt;Would you help fund its full-time development on Kickstarter? &gt;* No * Up to $10 * Between $10 and $50 * More than $50 OK buddy.
http://www.youtube.com/watch?v=acjvKJiOvXw
The only french is in the news section. Perhaps you should have considered literally not leaving a comment. Everybody wins.
Many thanks! Does this focus specifically on PHP? Because that's what I'm looking for.
Of course there is. 
* Why would I want to use this instead of nginx or Apache? * How does the caching mechanism differ from a standard opcode cache in terms of performance? The idea of optimising my application so that it works with only one webserver is a little scary.
&gt; The rule here is "if it can type cast, its allowed in. If a type-cast wouldnt work, then fuck that input." No, that's not the rule, because that rule is practically useless: PHP supports typecasts from every type to every other type, with a few minor exceptions perhaps. Allowing everything that "can be cast" would be roughly equivalent to "allowing everything". I think the whole scalar-typehint-with-cast thing only makes sense if the cast is *sane*, which I'd define as invertible (__toString notwithstanding).
IT doesn't because Postgres doesn't have a query cache, it has a buffer cache which functions in a much different way, and caches rowparts themselves instead of query results.
The least they could do would be benching something like rendering a phpbb forum thread on pancake vs nginx w/ php-fpm Otherwise, I have no idea why I'd need to try it.
GNU L V3, it's Donationware :) no need to "buy" - but author accepts donations 
Cool - that sounds like it would be better in many cases.
The CodeCache actually looks worse than regular opcode. It's only useful for keeping static classes in-memory between requests (which opcode caches do anyway). I don't see a point, but maybe someone with more knowledge can chime in. https://github.com/pp3345/Pancake/wiki/CodeCache%20technology
http://www.amazon.com/PHP-Object-Oriented-Solutions-David-Powers/dp/1430210117
No, but PHP 5.3 has a robust OOP implementation so it should be applicable. 
how about a downloadable ebook?
Says there is a kindle version.
HHVM just released a FastCGI interface a month or two ago actually. So it's a near drop in replacement for php-fpm if you're already up on nginx. _(Granted, HHVM != PHP Native yet, extensions, features, etc, etc)_
This is essentially an hour long talk about how to architect in a way that allows for properly testable applications. While this is a very important set of concepts that any OO programmer should be intimately familiar with it *assumes* you already know something about OOP and thus will not be a good way to initially learn OOP. All the same, anyone with prior OO experience that doesn't test should definitely watch this video. It's well presented, easy to understand, and while it does use java for examples the java is very easy to read. Most of the talk is largely language agnostic. PHP has all of the features necessary to implement these ideas.
&gt; The idea of optimising my application so that it works with only one webserver is a little scary. Why?
No complaint about the resource, it's really good. I just don't think it's aimed at beginners. This will be better for him a few weeks down the road when he gets his base concepts squared away.
While it screws up the code examples, Google translate does a fine job with the existing documentation already: [http://translate.google.com/translate?sl=fr&amp;tl=en&amp;u=http://hoa-project.net/En/Literature.html](http://translate.google.com/translate?sl=fr&amp;tl=en&amp;u=http://hoa-project.net/En/Literature.html) (Thus a simple language link might do, considering the versed target audience.) Also please fill in a few categorizations on [http://matrix.include-once.org/framework/view.php?name=hoa](http://matrix.include-once.org/framework/view.php?name=hoa), if you got a little time. Hoa provides quite a few unique and neat features apparantly.
I really like this. This is actually what I'd love out of an IDE. @OP How complex could my could get? If I included a file, created and object, called that object's function, would it print everything correctly?
The argument is obvious for an application that you distribute: you can't choose downstream's stack for them. For a first-party application, it's still an advantage to have flexibility in deployment. Imagine: * Pancake, for whatever reason, is no longer developed. Security flaws are discovered. * On some new hardware you bought, a different webserver performs 20% faster. * Some new developers you've hired only have experience with a different webserver. If you depend on an implementation rather than an interface, you lose the flexibility to solve problems.
No, they have to learn somehow. But their mistakes will have to be corrected at some point.
&gt; The argument is obvious for an application that you distribute: you can't choose downstream's stack for them. Of course you can. Not everyone does. Commercial products almost always do this. More than 1 available platform is a nice to have. &gt; If you depend on an implementation rather than an interface, you lose the flexibility to solve problems. There's no evidence of that. For most marginalized webservers Zues (defunct), G-Wan (write your own modules), LightHttpd (circa 2005), IIS, they all have features supported and not supported which you take into account, as a developer, when using them. Your builds either take their features into account, or they don't. There's nothing about targeting a platform that impedes your ability to solve problems. You often have to work harder or differently to solve them.
I would probably look at reworking it a bit. It's a bit distracting and the "HOA" text is sort of difficult to make out.
My apologies, you're right. Write a product that only works with Pancake and let me know how you go.
When writing procedural code, did you group similar functions together into separate files, "libraries" to keep your projects organized?
Then don't type hint your print method if you want it to print anything? Or use a cast when calling? print((string) 5); That's the point - type hinting is purely an opt-in affair. If you want to opt into a strict type then you should be able to. Of course allowing function overloading would be helpful. function print(int $a) { // code for printing integers } function print(string $a) { // code for printing strings } print(1); // calls the first method print("a string"); // calls the second That would be rather badass. Nobody is arguing for PHP to become a strongly typed language. The argument in this case is against continuing down the road of idiosyncratic behavior. If as a developer I have a method signature which expects a string it should only accept strings. Period. The value of scalar type hinting becomes diluted when you start doing "type hinting with automatic casting". I would suggest the addition of a "numeric" type hint which accepts floats OR ints to get around the whole function foo(float $bar) { } function foo(1); // parameter 1 is not a float thing and allow type hinting of any numeric type. I would of course also like to see strict hints for int and float for cases where you want ints and floats to only be accepted. We work with PHP's idiosyncrasies daily but that is no reason to advocate further expanding those idiosyncrasies in new capability.
&gt;&gt; And if the server you're optimizing it for is one-man show &gt; Whatever that means. https://github.com/pp3345/Pancake/graphs/contributors
The components are abstracted away by the laravel components that extend or use them. You rarely interact directly with the symfony components when developing in the laravel framework.
[PHP Objects, Patterns and Practice](http://www.amazon.com/Objects-Patterns-Practice-Experts-Source/dp/143022925X/) This is a fantastic book that might be exactly what you need. The first several chapters are about the syntax and language details of PHP OO. Then there's a chapter about procedural vs OO, benefits and drawbacks, and how the same problem might be coded in both styles. Then there's several chapters about OO design patterns, so that you're not just learning syntax, but also learning how to *think* in OO.
&gt;this is how you do it now, this is how to do it with OO It's not that simple, if it were you could just "namespace" all your methods by wrapping them in a class. OOP isn't specific to PHP so it might help to google without the language qualifier - I'm saying this because there are vastly more resources out there for other more established languages, e.g. you won't find any Uni level OOP text books written using PHP. Aside from that I'd recommend you use one of the micro frameworks (silex would be my favourite) in a project. It should abstract most of the OOP design decisions away while letting you get your feet wet using OOP and perhaps get a better understanding of things like interfaces, statics, inheritance, etc.
You are describing a strongly typed feature but PHP is weakly typed. Making this feature work strongly is more confusing, not less. Look at the function signature for [strlen](http://ca2.php.net/strlen) in the manual. It says `int strlen ( string $string )` and you can do this: echo strlen(123); // prints "3" It would not be smart if scalar type hinting didn't match the already existing behavior in PHP. Another reason for avoiding strong hint matching is that it will force PHP developers to use casts. Casts in PHP so are permissive that you eliminate the benefit of the type hinting. Take example above but make it variable: print((string) $foobar); In this example, `$foobar` can be almost any type in PHP -- integer, float, array, resource, etc -- and this code will run without error. With weak type hinting, there is no need for casting so the hint can be more useful. 
Since you have access to ImageMagick, why not just have your script use that? I've personally never used webp before so I can't say how well PHP's internal webp functions handle the format, but I just used ImageMagick's 'convert' to convert 3 different webp images to jpeg and they look identical. Reference webp images that I used: - http://files.jjcm.org/webp/1Mcolors_webp.webp - http://files.jjcm.org/webp/beach_webp.webp - http://files.jjcm.org/webp/bmw_webp.webp 
ahh thank looks promising! I'll give it a shot.
It detects output around echo, var_dump etc. Everything that writes on the output buffer actually. So, normally… yes!
Adding type hints does not magically make php no longer a dynamically typed language. And long-standing tenets are often wrong or no longer valid.
Right. I made the exact same point about Pancake being a "one-man" show. There is pretty much only one contributor and I've never heard of him anywhere before. I'm not saying his work sucks, he may have the most fantastic and amazing optimizations ever. But what happens if he drops the project? What if he dies? Do I know how to code a web server? No, I do not. Can I patch it if there's security problems and no one else cares about it anymore? No, I can't. Is it not a LITTLE scary, then, to invest time and effort into making your app dependent on a specific web server platform made by who-the-hell knows for performance gain? This isn't hard to understand. I would only do such a thing if I knew the team behind the platform was really solid and that it had a good chance of a long future ahead. Or if I knew that, if the small development team folded, I could at least keep the software working for years to come. Otherwise, it's just a high risk to take.
If someone is interesting to review our translations, we have currently these ones: https://github.com/hoaproject/View/pull/3 and https://github.com/hoaproject/Zombie/pull/1. More to come obviously. Thank you for the feedbacks!
If you want it to be able to print non-strings don't tell the damn function that it only accepts strings. It's not rocket surgery. If it's not important, don't type hint it. That PHP is loosely typed is totally fine. But in the rare context it does actually matter, type hinting should at least make sense.
Sorry, Phil, I usually agree with you, but in this case I don't get it at all. It seems to me that if you're going to have scalar type hinting they should be strict. Otherwise why even bother having them at all? I suppose the question is: what is the point of type hinting? Is it so that the function can be certain of the type it's receiving? Or is it so that the caller can be certain of the type it needs to send? It seems to me that the sanest, cleanest, least-surprising option is that typehints strictly enforce type, and shit the bed if type is wrong. Surely if it doesn't matter what the input is.. just don't use a typehint at all?
If it doesn't work out for you, let me know and I'll try to come up with a quick bit of code that should do it. Basically all it will do is use one of the PHP program execution functions (http://www.php.net/manual/en/ref.exec.php) to execute 'convert' with the source filename and a destination filename. If you don't explicitly tell ImageMagick what output filename to use, it will use the extension of the destination file. For example: - convert x.webp x.jpeg - This converts to a JPEG - convert x.webp x.png - This converts to a PNG And so on. It's worth becoming familiar with ImageMagick's command line options as it's extremely powerful and can probably do everything you can dream of when it comes to images. In the above example, remember to replace 'convert' with the full path to the 'convert' program, such as /usr/local/bin/convert (it's up to you to figure out where it's installed).
i had a lot of issues with the gd image library. a lot of color issues. my images looked like there color palette was reduced to 20 colors. then i rewrote my code to imagemagick and it all looked good. the documentation isn't always so nice tho.
&gt; I think the entirety of software development might disagree with you. Software development isn't a unified or scientific concept. It's a process that's loosely defined as "whatever works".
Or apache2, which is now the common case for me. It's gone splendid.
i see. this is still great, nonetheless. thanks for implementing it and pushing it through :)
Check out fuelphp. It's the modern codeigniter. It uses composer so you won't be missing anything that st2 or laravel uses. 
There seems to be ongoing development on a [v2](https://github.com/pp3345/Pancake2) repo.
You must be from the US?
Lightweight? I wonder if that doesn't come with a cost, specially in terms of security and reliability... and when you check out the date of the last commit, well... yeah.
Some example code - wrap it in helper methods to make it look nicer. public function testSomeApiThing() { $response = $this-&gt;call('get', '/api/v1/foo/bar'); $this-&gt;assertEquals(200, $response-&gt;getStatusCode()); $data = json_decode($response-&gt;getContent()); $this-&gt;assertInternalType('array', $data, 'Invalid JSON'); // do assertions against data... $id = $data['something']['id']; $response = $this-&gt;call('post', 'api/v1/bar/baz/'.$id); $this-&gt;assertEquals(200, $response-&gt;getStatusCode()); $data = json_decode($response-&gt;getContent()); $this-&gt;assertInternalType('array', $data, 'Invalid JSON'); // do more assertions against data }
The study of software development is certainly scientific, and everyone studying, or otherwise involved in that "process", agrees that tight coupling is bad. Or at least did, until in Jan 2014 when Jack9 argued incredibly poorly on the internet that it wasn't and everyone woke the fuck up and realised how stupid the entire of everywhere had been without Jack9.
I had a look at the source code and it looks pretty bad. Uses its own weird autoloader with weird requirejs-like syntax (`from('Hoa')-&gt;import('Hoa.Routing')`) instead of the standardized composer, really ugly if/else structuring (lots without brackets) and, of course, no tests.
Using from/import is not necesarry, this is just for our own static analyse purposes, but it's perfectly PSR-0 (and -4). See composer.json everywhere :-).
All configuration reference is here, broken down by the bundle/component: http://symfony.com/doc/current/reference/index.html
Would it not be possible to test via an application interface? By that I mean a dummy application that integrates with all API endpoints, simulating a real world application, and you can test this using selenium (made easy with Behat + Mink). Then you're not so worried about the specific JSON responses, but more focused on whether the app itself is behaving properly with those responses, which is the real purpose of behavioural testing. 
True. I found this a great introduction into how to benefit from using OOP beyond PHP 
You should definetly try auto-testing. Testing API's is really easy compared to front-end, it's a good point for a start.
I don't see how else to test an API. APIs are not meant to be human read so you can't easily do acceptance testing (CodeCeption's style of "I click this button, I expect to see this text" etc). I guess you could just bring in whatever API client you're making and just let that do its thing and see if there are any errors or unexpected behaviour? But then it's an API client test more than an API test.
Books and such has never really been the primary means for me to learn something, I have to get my hands dirty. The way I got a small grasp on what OOP is all about was by using the CodeIgniter framework. But that is really only a starting point, as it only teaches you how a class looks and how to use it. CodeIgniter will also teach you MVC, which doesn't have much to do with OOP and it is important to not get the two confused.
Well, actually we do have functional tests that you are talking about. The web front-end is tested by protractor + cucumber-js. But those only cover part of the API, they do not verify http status codes, they do not cover negative scenarios. Those scenarios are for project-managers and product-owners. What I'm talking about is test/spec describing API intended for use by front-end and mobile developers. It should tell them about response/request formats, possible status codes returned, how errors are handled and the actual business-logic of the API.
Yes, that's what I mean ;)
I can see your point, but for me when I was starting out, the OOB examples just confused the hell out of me, whereas the functional programming examples were easy to follow. I actually write OOB code now, but found it easier to make sense of once I already understood the PHP syntax, commands, functions, etc. But this is just my opinion of what worked for me, I don't think there is a right or wrong that works for everyone :)
Hey, developer of Pancake here. Just wanted to say a few words on the ongoing discussion. First of all, Pancake 1.5 isn't really actively developed anymore. However, as someone mentioned before, I am working on [Pancake 2.0](https://github.com/pp3345/Pancake2). If necessary, I will still fix bugs (especially security ones) until Pancake 2 is released. I hope to finish a stable version in summer, but I really can't guarantee for that. So, what are the actual differences between Pancake and other SAPIs like fpm? Pancake has a different approach in PHP request startup and shutdown and some SAPI-internal features which should be a bit faster than what all other SAPIs do, thus giving higher throughput rates for PHP requests. Next, CodeCache isn't exactly the same as an opcode cache. An opcode cache will compile the script and load the compiled opcodes every request instead of fully recompiling as PHP does without opcode cache. Files in CodeCache will be compiled and **loaded** once (actually before any requests are happening) and it is possible for the developer to say that he wants to keep objects and variable values across requests, thus giving the ability to avoid unnecessary loading of application data again and again on every request. However, I have to admit that the way CodeCache is currently realized in Pancake isn't the best. Pancake 2 will probably feature two PHP execution modes, one that behaves mostly like normal SAPIs (without something like a CodeCache; only Zend Opcache if the user wants to use it) and another one that works more like an application execution mode -&gt; load the whole PHP application once and invoke a callback in the application every request to serve what the client wants without the need of loading and reinitializing the application every time. Just to make that clear: you'll get better results if you optimize your application for Pancake, but that does not necessarily mean that it won't run on other webservers. An application can be optimized for Pancake but can still work with fpm or apache2 or whatever other SAPI. Even though I am the developer of Pancake, I'd recommend to wait for 2.0 if anybody is really interested. Non-PHP features like static file serving or FastCGI are quite a lot faster in P2 and, unlike in P1, PHP isn't necessary for Pancake to work anymore. P2 will also feature a much more flexible configuration and a better rewrite engine, better SSL support (P1 does not support SNI and (EC)DHE), HTTP proxying support and some other improvements. I admit that I've made some wrong design decisions in P1 and therefore hope to do everything better with P2.
Do you know about Codeception? It might be what you are looking for to test REST APIS. It would allow you to write something like this.. &lt;?php $I = new ApiGuy($scenario); $I-&gt;wantTo('create a new user by API'); $I-&gt;amHttpAuthenticated('davert','123456'); $I-&gt;haveHttpHeader('Content-Type','application/x-www-form-urlencoded'); $I-&gt;sendPOST('/users', array('name' =&gt; 'davert' )); $I-&gt;seeResponseCodeIs(200); $I-&gt;seeResponseIsJson(); $I-&gt;seeResponseContainsJson(array('result' =&gt; 'ok')); ?&gt;
I knew about codeception, but I think I've missed its API-testing capabilities. I'll take a look, thanks!
Set yourself a target, something *you want* to create, and don't stop until you reach it. If you can't think of something you want to build then you wasted your time reading.
How about behat? http://behat.org/. Here's an example from one of my feature files: Scenario: Will return a 201 when a card is successfully created and the user does not have a stripe profile Given I am authenticating as "bob" with "bob" password And I generate a stripe token from the following card details: | number | cvc | exp_month | exp_year | | 4242 4242 4242 4242 | 123 | 08 | 2014 | When I send a POST request to "/users/bob/cards" with the generated token Then the response code should be 201 And the response should contain json: """ { "card_type_name":"Visa", "number":"**** **** **** 4242", "exp_month":8, "exp_year":2014, "id":1, "default": true } """ And exactly 1 stripe profile should have been created for user "bob" And the following cards should exist for user "bob": | id | number | cardType | expYear | expMonth | | 1 | **** **** **** 4242 | 1 | 2014 | 8 | And the card with id 1 should have been persisted to stripe for user "bob" EDIT: Let me know if you want to see more as this project is open-source so i'm happy to send you a link EDIT2: Just actually read your whole post, my bad. Addressing a few of your behat-based concerns: Taking someone from last request and pasting in the new one: You can see I actually do this is the above example with the generated stripe token. So far I haven't found a **great** way of doing this but I just set the response as a class variable and access it in the next step. Works well enough for me. Server-generated IDS / Dates: I reset AUTO_INCREMENT on these types of tables each time so I can reliably predict which ID will be generated. With dates I create a new function which replaces the date with todays date in the step definition. It's actually easier than it sounds. Generating DIFFs: I actually use PHPUNIT assertions WITH Behat, so I can easily get these diffs. Take a look at https://github.com/Behat/CommonContexts/blob/master/Behat/CommonContexts/WebApiContext.php to see a great example of this. 
I do this on my nexus 7 and galaxy s4. 
For a team of one, I'm sure that would work fine. The question is more aimed at larger teams and automation that helps to look out for problems.
Once you have a destination the journey will work itself out. You should find something you want to build &amp; build it using the new ideas you've learnt - given that you mentioned unit testing maybe an ancillary goal should be 100% coverage. Nothing solidifies a lesson like immersing yourself in the application of it.
use PHP's curl functions, json_encode/json_decode, and some assert statements.
Regex for escaping? Run.. Run and don't look back.. It may be worth it for you to read the databases section here: http://www.phptherightway.com/#databases
Gets worse, `ereg_replace`. It's been deprecated as of 5.3.
Wow, this is nice! Thank you!
If you really want to be sure about preventing SQL injections, put the extra effort in to use prepare statements. Better yet, use something like Doctrine2 or PHPActiveRecord.
Dude, use [prepared statements](http://en.wikipedia.org/wiki/Prepared_statement).
This is exactly the reason as to why I don't think unit testing is as powerful as most people think it. The ROI for unit testing is extremely low compared to native software unit-testing. By it's nature, the web has no state. Thus each request is separate and cannot be linked to another request unless specifically stated by the developer just like anlutro's example shows. My point is that you can use unit testing to validate your API's functionality, ex. unit test that certain input generates the right outcome. However, you cannot test a chain of requests based on each other's results unless you do it manually or through a written script such as the above example. If you do find a library that does such a thing, please let me know. I would love to take a look at it. 
Fair enough, edited.
Upvote for accuracy. 
I prefer [PostMan for Chrome](https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm?hl=en) It allows you to easily modify requests, view output and header information, best part, export/import/share the entire request with a friend. We can save particular tests with project files for use later.
&gt; The study of software development is certainly scientific, The study is not what I was talking about. But ok. I can name 1 paper that (kinda) shows proof of a best practice. Show me a scientific study that shows "tight coupling" in the application level is bad (for some value of bad, it's up to you!), or even in your language de-jour.
Testing "chains of requests" is as easy as doing multiple requests in your test. I don't see why that's any more difficult than testing state-based behavior of any other code. Think of a collection class, for example. How do you test that your add() method works? Exposing/asserting the private state would be brittle, at best, and usually impossible. But we don't really care about what's inside the black box, do we? All we care about is that after we add() something, subsequent get(), count(), etc. methods reflect that. So to test it, we make two or more "requests" in our unit test. Ditto all of this for testing an API.
Those tools are for debugging, not testing.
+1 for codeception; i've recently been responsible for building a complex REST API as part of a project and codeception tests are what we chose - as well as verifying the JSON responses we use the database component to verify state changes made by API requests.
Everything about this is godawful. It uses ereg_replace, which is woefully unnecessary for what this is doing, not to mention deprecated. It's used in combination with mysql_real_escape_string which is also deprecated. None of this is good. Use PDO, not mysql_ extensions, and use prepared statements.
Definitely. I think I am getting downvoted because of my inability to articulate myself. I don't mean that you can't/shouldn't do that. What I am saying is that you can test a function's behavior. Example: test in case the generated result by the add() method checks out to be true. However, this is just a function test. API testing for me means that the testing platform understands the relationships between results from multiple requests. Which cannot be inherently done unless you as a programmer specifies the relationship in your test case. Ex. The testing platform does not/can not understand that the field BookID (which was retrieved from /API/books/getALL) is related to /API/books/BookID UNLESS you specify that yourself in your test case. Am I being unclear here or are we talking about different things? 
&gt; Really? how? Is it less confusing that an argument is being described as a string and will just gleefully accept an integer or a float or a boolean? It seems counter intuitive to me. Yes, because the behavior of PHP everywhere is that almost anything can be used a string. Every built in function, every operator, etc. You are suggesting behavior that is very un-PHP like. In my opinion, you're thinking of this feature the wrong way around. I think it's more important that a type hint ensures that inside the function the passed in parameter is the correct type. This is contrast to your opinion where you want to ensure the function is called with the correct type. Those are subtly different goals.
I've had to use it on occasion to suppress warnings (in particular about files) which I then of course manually check for the false response of the function and fail in a more graceful way.
Regarding Drupal... In my 200+ Drupal sites, there was one time I used an @ to suppress errors, and I put in a note to get rid of it once a certain core patch that fixed the reason for the error was committed—which happened a week later. Drupal core is developed with the philosophy of no errors, notices, warnings, etc., or it's labeled a bug. Some poorly-coded contrib modules (which are fewer and fewer as contrib development improves) may cause errors, but those, too, are bugs, and should be reported in the appropriate issue queues. I am of the mindset that every notice, error, warning, etc. should be displayed in development environments, and the @ should never be used. It can mask some of the most pernicious and time-wasting bugs. I know from experience... Don't use it as a crutch!
Let me give you an example. Often times I will write some code just to process a data set or perform some calculations on it and perhaps insert it into the database. This code will never see the light of day, once it works at all, it will never be used again. That said, am I going to write it up to the latest perfect standards? Of course not. Its easier to get a function to shut up than to write in error handling. I do this because I know what I am putting into the code, and what I expect to come out. If this is similar to your situation, go for it. If this is production code, or will interact with user input at all ever, don't use it, and handle your errors appropriately. Or better yet, stop the errors from happening at all.
Great!
It's a mistake for the reasons you've given, but it's not a mistake overall. The `@` character in PHP is like `goto` or other controversial programming constructs. You can definitely misuse/abuse it and do dangerous things with it, but you can also do very, very constructive things with it. For example: [`mysqli::set_charset`](http://ca1.php.net/mysqli_set_charset) raises an error when it fails to set a character set. At work we have code that needs to run across a few servers which -- for historical/legacy reasons -- run different versions of MySQL Server. Some of these servers have a new enough version of MySQL that they support the character set `utf8mb4`. Some of them don't. `utfmb4` is preferable to the older `utf8` because it has complete Unicode code space coverage. But if I try and set `utf8mb4` as the character set, and then fall back to `utf8`, I get an error. Except `mysql::set_charset` returns `false` **for a reason** -- so you can test for exactly this condition. So when I call `mysql::set_charset` in my code, I use the `@` symbol, check the return code, and then if I can't set `utf8mb4` or `utf8` **I throw an exception**. That last part is important. Rather than using some out of date error handling system, **I still acknowledge and handle the error**. Just glazing over errors is why `@` is considered harmful. Using it to transform those errors into exceptions should **not** be considered harmful.
There are circumstances where you have no choice but to suppress the error but you should catch and handle the errors rather than suppressing them.
&gt; I keep googling for an answer and looking in my PHP book, but I can't locate a solution. Because it has nothing to do with PHP. Presentation is in the domain of CSS. &gt;how to center it text-align: center; &gt; place it at the very bottom of the page. So move the snippet to the bottom of the page. 
To me, type-hinting says "in this method I want to work with an X." If the user passes in a Y, and it can be converted to an X, then you have an X. If its not something that can convert, then you have an error. I'm not saying I definitely want it that way, but its the most PHP Way, and might be an easier battle than completely strict. I wouldn't be sad either way, as long as we get one of them.
I think my "rule" was badly worded. I don't mean if its a float then let it in as a float because its close enough, i meant convert it. * want array, passes object? Fail * want an int and `"11234fudge"` is passed in, then you get `11234` * want a float and `"toffee"` is passed in? Error. It's not completely insane, it's what Anthony Ferrera suggests, and is certainly a PHP Way™ of doing things. Either way to me is fine, as folks can (and obviously should) always typecast their data to match whatever the typecasts specify. 
"Your way" kind of seems like a wtf in the making, IMO, if the conversion is unknown or unexpected. I'm not sure "massive derp" should be considered "the PHP way" :) We can certainly agree that this is needed, though. Such a simple thing that's been rejected repeatedly. 
For your unit testing, you should be mocking your API's data-source and providing your own, hard-coded data. The BookID is coming from *you*, not retrieved from your code. The steps for such a test, would look something like this: * Mock the API's data-source. * Create some set of known good data that you'd like the data-source to return. * Stub the necessary data-source methods to return this data from the mock. * Make your request to the /API/books/getALL endpoint. * Assert that your data from above is represented as it should be in the response. * Make your request to the /API/books/BookID endpoint. * Assert that your data from above is represented as it should be in the response. Of course, you gave a bad example, since the results from these two endpoints have no stateful dependency like a create/retrieve combination would. These are both retreive requests, and so they aren't dependent on each other at all (and thus, could/should be tested in different tests).
Really the way you are going to learn best is by starting to do it and then sticking with it. You will make mistakes, you will be frustrated, but if you stick with it, you will eventually figure things out bit by bit and learn from it. &gt; Can anyone recommend a dead-simple, straightforward explanation of how to change my thinking from procedural to OO? No, because there's not direct mapping from procedural -&gt; OO. There is no "one way" or "this old procedural code in an OO way" You have to look at what you're trying to accomplish, and then think about how to do it in an OO way, instead of a procedural way. The only way you can begin to see OO ways of doing things is to start using it. Stick with it, work past the the frustration. Don't sabotage yourself. This time, justify the investment.
The obvious misdesign of that function is the code duplication; it could have just recursed for the array processing. The escaping undoing with stripslashes also seems somewhat pointless. And where did the notion of "prepared statements are more effort" come from? It's much less work, [if done right](http://stackoverflow.com/questions/12859942/why-shouldnt-i-use-mysql-functions-in-php/20767765#20767765). 
We use phpunit, powering an extensive unit test suite. 1. What server-generated ids are you getting back? Responses should be predictable, particularly if you have access to the underlying data store. 2. If they're using JSON, they should be ok reading JSON. 3. Tests are not an appropriate substitute for hand-written documentation.
This is the how I use..
Never not use prepared statements!
I use it it one spot, where a user uploads an office file, and the server converts it to a PDF, and then grabs a jpeg of the first page. Occasionally the class that converts to PDF throws an error about the doc being in a funny format. The process still works, but I suppress the error because its not actually hurting anything. 
The `&lt;center&gt;` tag is [deprecated](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/center), and should not be used.
 // THIS is your alternative: $foo = v_check($_GET['foo'], 'default value'); // With extended options: $foo = v_check($_GET['foo'], 'default value', 'empty'); // specify a function to use along with isset() /* * function v_check($var, $defaultValue, $function) * Companion function to v_default - does not change $var. Usable with object properties and magic values. * * Returns variable value or a default value based on isset() and optional specified function. * Acts like an extended isset() / is_*(). Shortcut/"clean code" function. * * $var can be any value, even a variable that isn't set. * * $defaultValue can be any value which you want returned, should $var fail the checks. * * $function [optional] can be the name of any function which returns true/false (common uses are 'empty', * 'is_numeric', 'is_date', or it can be a custom inline function. The function must take one parameter * ($var) and should return a boolean or something which can evaluate as a boolean (ie ints are fine - * 0 is false, anything else is true). * * @param $var Variable to test * @param $function Function or 'function_name' to test variable with. Must take one paramter ($var) and return bool. * @param $defaultValue Value to return if $var is not set or fails $function test * @return mixed */ function v_check($var, $defaultValue, $function = null) { // This could be much shorter with ternary statements, but gets really hard to read! if (isset($var)) { if (is_callable($function)) { if ($function($var)) { return $var; } else { return $defaultValue; } } else { return $var; } } else { return $defaultValue; } } "Companion" function v_default is the same, except $var is passed by reference (&amp;$var) and return $defaultValue becomes return $var = $defaultValue; So if the variable you pass it doesn't exist or match the specified function, it will set it. 
This is just lazy error checking, your alternative, already exists, as you've demonstrated, so simply use it. Do not promote laziness through the unwillingness to properly validate empty and set strings.
&gt; https://drupal.org/taxonomy/term/100 Note that 99% of those fixes are for contributed modules... and most of those are modules that are hit-or-miss with code quality. Always be picky about what contrib modules you use!
Your book will not solve the problem. Find something better to do with your time.
yes it's bad Using is_set is good. Set your PHP to show warnings as errors, and fix your code until they are all gone.
The API itself, PHPUnit unit testing is satisfactory. Treat the frontend application access the API as a completely separate application. With the frontend app you can create the Gherkin scenarios using whatever language your frontend app is using. You don't need to run `assertJsonStringEqualsJsonString` with PHPUnit, you need to create the scenario, make the request and test that you get the appropriate information back and the frontend appears as it should.
Or you know, you can simply write a function that does the full form...
I once read [an article](http://blog.rodneyrehm.de/archives/12-Improving-Disk-IO-in-PHP-Apps.html) that made the case for error suppressions to improve Disk I/O in PHP Apps. [The advice](http://blog.rodneyrehm.de/archives/12-Improving-Disk-IO-in-PHP-Apps.html) is contested (in the comments) but at least it shows that @ symbol can be desired and used on purpose.
I also use PostMan a lot. You can easily add all your custom params / headers, file uploads, basic auth, oauth and many more. Save your global params as enivronments, save all data and so on.... Very useful!
PHP when running as an Apache module receives data via environment variables and stdin, and the output sent to the browser comes from stdout. That is the CGI standard. You can do the same with a CLI program so there is no difference.
Not really, you exchanged request information for arguments passed from the command but thats about it as far as the language goes. The real difference is how you approach the code you are writing. All of the sudden responding as fast as possible is no longer a concern. You crunch a lot of data without a user that is waiting for the page o load.
*Chants PDO*
Those credentials are not for ssh, they're for ftp. If the password prompt comes up, then you are connecting to ssh but your credentials are not correct. Either the password or the username is wrong. You should contact your hosting provider. Also the reason why it will accept any username and ask for the password even if the username doesn't exist is because SSH tries to leak as little information as possible. Saying "that username does not exist" would give away information about the accounts on the system, which is bad. Also this is the wrong subreddit for this and you should not purposely post stuff to the wrong subreddit as it clutters things up etc. etc.
If that's what you want to do and you think you will benefit from it then do it. Not sure if it would sell. If you're giving it away for free, then free resources are always appreciated. 
I never unit test the echoed output since I have the REST output logic wrapped in a method that's known to work; however, I will unit test the data I pass to the XHR response method, usually in PHPUnit. Still, if there's an error the unit test isn't catching, I'll execute it from SoapUI or even from inside the browser, but those occurrences are rare.
Can anybody give *any* examples of where this particular usage could actually cause an issue?
You want to talk about software development but ignore the study of software development? &gt;Show me a scientific study that shows "tight coupling" in the application level is bad (for some value of bad, it's up to you!) Let's define "bad" as "worse than the alternative". If you could achieve the same thing with a loosely coupled app as a tightly coupled one, then you would use the former. Therefore tight is bad, in general, and in this specific case, fucking retarded.
Sounds like you're not a fan of editing .htaccess.
Thx for your time. I'm using Cygwin so that I can use what little linux-fu I have on my new Windows machine. I realize there are other places to post this, but it is tangential to PHP, and I just thought there would be more traffic here.
Take a look at the [Command Line Interface](http://www.php.net/manual/en/features.commandline.introduction.php) section of the PHP manual. Your mention of I/O options can be described [here](http://www.php.net/manual/en/features.commandline.io-streams.php) and also [here](http://www.php.net/manual/en/reserved.variables.argv.php). Personally, I have used PHP CLI scripts to take care of various scripting and automation tasks. For better or worse, this has prevented me from learning something else like Python, because this suits my needs just fine.
&gt; You want to talk about software development but ignore the study of software development? I don't want to talk about the study. How it's studied is irrelevant. You say it's scientific, but present no evidence of that. Computer Science is scientific. You experiment and measure. It's repeatable on any turing machine. Software Development, where is the science being done? Irrelevant. All I want is the evidence. The concept of "coupling" is a metaphor. If tight is bad, why couple to an OS at all? At what point is coupling bad versus necessary? What are you trading? This idea that applications shouldn't target binaries because tight coupling is "bad" is a simple practice (that applies to a subset of the application logic) taken to an inappropriate extreme. &gt; worse than the alternative What does "worse" mean? You just switched words.
I know that *one* of those formats is for FTP (I was just trying everything) .. but this is normal ssh, yes? ssh username@mySite.com I didn't think it was so far off topic, since this is a part of a "php/LAMP workflow" ... I took a risk, I know. I hope I haven't offended any religions by posting here! I promise I will bring my children up better! Makes sense about always asking for passwords .. thx!
I guess this is my next step. I seem to have tried all the variations. I just dread support.
Sorry. It just gives me 3 password attempts and then "permission denies" me. But I only have one username (plus the confusion of my host using my site address as loginName, and then referring to that as userName a few times) .. I guess I just gotta call support. I just have never been able to SSH (my *last* host didn't allow it on the plan I was on, and it took me ages to figure that out, all the time thinking I was doing something wrong)... and so I don't really have a "successful mental model" to compare anything to for troubleshooting. It has always been a fail case with me and SSH. :(
Your ssh is working perfectly, there is nothing wrong with it. The credentials they gave you specifically say ftp, and they don't work on ssh. So you have the wrong credentials. There's nothing else I can say to help you. Contact your provider, you pay them for support! A lot of things are part of a php "workflow," doesn't mean they all belong here. It's not about being offended, it's just about keeping things at least somewhat organized.
Thanks for the tip with the -l option. So are you generally going to have user/passes for "cpanel/ssh", "ftp", "database" .. and potentially "cms", too? That would be pretty typical, I imagine? I'll experiment with some other interfaces, but I am trying to get it with command line .. and I think I'll just call support. I've tried all the obvious permutations.
Based on what you're asking, I suspect your web host allows you to use "SCP" (a secure file transfer protocol that uses SSH as the transport) in place of FTP. I also suspect that SSH shell logins are disabled for your type of account. To test if this is the case, download putty and attempt an SSH connection, if that doesn't work, then try an FTP client that supports SCP such as WinSCP. If WinSCP works and Putty doesn't then this is what's going on.
Start writing it up as a series of blog posts and see if you get any traffic. If yes, it might be suitable as a complete package. If not, people are probably not asking those questions. And if you've written it, publishing it as an ebook would allow you to gouge interest early on.
Yeah its potentially odd, but in line with the way everything else works. The whole point of lose or weak typing is that it will keep on trucking without caring about a specific type. If a method requires a specific type then they should get that specific type, but to complain that `"1"` is not `1` flies in the face of what PHP is currently all about. If the method dev wants an int they should get it. An int (or something that can be and *is* converted to an int) is acceptable input, just like 1 + "1" is. &gt; php &gt; var_dump("1" + "1something"); &gt; int(2) I'm not arguing that this is the best solution, but I do want to make sure it is considered, because it's not completely insane. Just consistent. :)
PostMan
&gt; Yes, because the behavior of PHP everywhere is that almost anything can be used a string. Every built in function, every operator, etc. You are suggesting behavior that is very un-PHP like. from the outside looking in, implicit casting of an explicit type hint looks like another PHP WTF. so what if it is un-php like? is it just possible that the language can move forward from a legacy of bad decisions and do something in an expected/unsurprising way? &gt; you're thinking of this feature the wrong way around. thanks for telling me what i'm thinking. &gt; I think it's more important that a type hint ensures that inside the function the passed in parameter is the correct type. This is contrast to your opinion where you want to ensure the function is called with the correct type. Those are subtly different goals. the whole point is to allow the author of the method to specify what he or she expects to be passed to the method. And what happens in a future where we get proper method overloading, which allows us to define a method of the same name with a different signature within the same class: public function foo(string $bar) { // do something with the string $bar } public function foo(int $bar) { // do something with the int $bar } if PHP is trying to cast stuff all over the place for you, how does it chose which is the correct foo to execute? (Ok it is unlikely we'll get such a feature in the future... but who knows. Perhaps someone will be nice and allow it in). It might not be "The PHP Way", but that isn't the point. I'm actually stating "The PHP Way" is "The WTF? Way". With the benefit of experience you can understand it and work around its idiosyncrasies and do amazing things with the language. I love it for that. But I don't think anyone should continue advocating for a bunch of silly logic for historic reasons. It's a moot point anyway. The internals team wont agree on how it should be done for the foreseeable future, and what they come up with will be a pile of idiotic compromises. Such is the nature of design by committee. 
Dammit, the extension code looks *sooo* nice! And why? Because HHVM uses C++ instead of C for its implementation, that's the only reason. I really can't understand why some internals people (like Pierre) don't get the overwhelming benefits C++ offers for a project like PHP.
&gt; Now you want to ask why someone would write Windows specific software? I'm asking why one is "bad/worse/rigid" and one is not, to the point of "don't do it" because of some metric that you aren't articulating. &gt; You were telling someone that tight coupling of a web app written in PHP to a web server isn't a bad thing. I did mean to say something like that. I believe (in the face of no other evidence) there's nothing wrong with coupling an application to specific dependencies. You might say "tightly" because the original post was about writing code that uses features of a binary that are uncommon to an existing ecosystem. Ever written an app for erlweb? Someone implied it would be "scary" to tailor a webapp for a dependency and I asked for the reasoning with a simple "why".
&gt; The same thing that happens in other languages with some automatic conversion of types (like C++, Java, etc) -- the best option is chosen. But method overloading is probably not going to happen in PHP. The thing is that the strategy that would be applied would be "can I pass this value into this function? nope. Can I cast it to a compatible value? yep, run that function". The second function wont be executed under any circumstance because everything can be cast to a string (which, I'm fine with. But I'm not fine with the type hint doing the cast because I've explicitly asked it not to). And I agree, method overloading is probably not going to happen in PHP. But then, neither is scalar type hinting and yet here we are arguing about that. (for what it's worth, method overloading would be incredibly useful and it would be a damn shame not to see it in the language). &gt; Basically you're saying that you don't want weak typing. actually, no, I'm not saying that. But nice try. I'm saying *if i chose to opt into a scalar type hint* (and lets be clear, it would be entirely optional), then I expect the parser to do what it is told. This would, to me at least, adhere to the Principle of least astonishment. &gt; Adding scalar type hinting (in either form) would drastically reduce the number of idiosyncrasies that come from some of PHP's specific implementation of weak typing. But there are plenty of languages with weak typing, it's not really that unusual. And weak typing makes sense for PHP because it's mostly working with strings. Again with the arguments about weak typing. I know what PHP is. I'm not asking for it to be any different. I'll say it again, adding strict scalar type hints to php doesn't change the nature of php from weak to strongly typed - mostly because they would be completely opt in. However if I as a developer chose to opt in I would **reasonably expect** that the parser will obey my wishes. Anyway, i'm out. We can argue around in circles for days and neither you or I are going to change our minds.
I learnt OOP by learning how to code in java. There is no procedural coding in java, only objects. Even still you can code in objects in a very procedural style if you wanted to. So, on top of that I would learn how to make some simple classes that you use all the time, such as a dictionary or list. Or think about writing a simple game, where every character is a different object, but they all inherit from a base class.
The start page doesn't explain exactly what hoa is about. The about page is as useless in that regard. From the "codes" around I've seen; is it a framework? is it something like Aura? And what does this even mean? "Hoa aims at being a bridge between industrial and research worlds."
I keep it as a global function in an include file. Why would it need to be in a class? It's no different in usage than isset() or any other standard PHP function. In my Yii project I have it as /protected/extensions/utility_functions.php and included at the top of my config file. 
I know how you feel. This definitely wasn't in my repertoire of `array_` functions used. +/u/dogetipbot 10 doge verify
 &lt;?php include('protected/extensions/utility_functions.php'); // file containing v_check() error_reporting(E_ALL | E_STRICT); $_GET['hi'] = v_check($_GET['foo'], 'test'); print_r($_GET); Result: Array ( [hi] =&gt; test ) No warnings, no errors. Try again? 
I actually just open-sourced my newest project: https://destruct.co/
&gt; because of some metric that you aren't articulating You're asking in a general case and expecting specific answers. In general tight coupling is bad (surely this is self evident), in any specific edge case? it depends. &gt;and I asked for the reasoning with a simple "why" Because it introduces complexity and creates technical debt. You should be "scared" of that.
Another flamebait thread. Do they never get tired of shutting PHP off?
PHP being a 10 year old language, your book doesn't offer any new or interesting approach to learning the language. There's so much brief and concise tutorials on the web that'd suit beginners better. But it's your decision anyways so
Really? We've been waiting for PHP 6 for decades? 
&gt; You're asking in a general case and expecting specific answers That's true. I'm hoping to get more than I have given. &gt; Because it introduces complexity That's false. A specific function call that isn't a wrapper (to decouple the interface) is less complex. That's the advantage (more information for less code). Changes are usually more involved when you've designed a contract with an interface and code on that dependency because you have to rework the channel and even the strategy if the performance isn't there. That's the disadvantage. I'm not affiliated with this company, but this is a typical product: http://www.inclick.net/images/deployment-diagram.gif Do you think this product has tightly coupled dependencies for their system? I clicked around 2 times and... http://www.inclick.net/pageid/requirements.html Can you use something else (postgres?), probably...with a facade for the bits that are specific to their stack targets. Databases have become fairly homogenized, so you can say "we might switch databases" with a straight face. Why introduce the complexity of decoupling for an unforeseen eventuality? Just don't. Tight coupling, in infrastructure, trades possible future change complexity for that simplicity at inception and maintenance. Some might call it technical debt. I think it's only a debt if you don't want to make that tradeoff anymore. Application dependencies are selected based on their ability to address the problem they are solving, at the application level. This is a job for NoSQL or this is a job for ZeroMQ. Tight coupling is the common case for the vast majority of application design because it's simpler to work with known targets.
&gt; The assertions of responses. You cannot simply run PHPUnit's assertJsonStringEqualsJsonString because of server-generated IDs. Why wouldn't you just take the response, json_decode it, and do your asserts on what you're actually checking? I have a pure JSON API and my 550ish units tests were a breeze with PHPUnit.
This is very cool. It's so amazing what Facebook is able to do with PHP.
&gt; You have far limited options what you can expect in terms of inputs and outputs. In what way limited? If anything you have more options via the CLI interface than with mod_php.
This. I am writing a book and this is how it started. You develop a readership before you even take it to a site like Leanpub. I would recommend not using Laravel. It's great, but these concepts are not Laravel specific. You're likely to inspire more questions than you answer by dropping in a needless framework dependency.
Will it add undiscovered knowledge to the community? Probably not. Will it help OP learn? Undoubtedly. That's a great use of time.
they let you write extension code that humans can read! somehow, i'm hoping that they spin off of PHP totally and keep improving the language without consideration for PHP compatibility.
The main difference is that you dont need to answer to clients over the network, thus $_GET, $_POST are pretty useless. You can stil read input from $argv, files, or STDIN; but that depends on what you program is doing.
Thanks for the reply. I'm using Cyberduck, .htaccess is definitely missing (also checked directly through the CP, no parent directories with .htaccess files either). I honestly don't know if Nginx is proxying Apache, that actually went over my head a little (time to do some research). The host is ASmallOrange, they did ask if I wanted them to disable Nginx caching on my account entirely, not sure if that would do anything though. And you're right, that is adding .html, was using [this](http://alexcican.com/post/how-to-remove-php-html-htm-extensions-with-htaccess/) as my source.
I tent to use procedural style when dealing with "data", but objects whenever there's "state" involved. I dont see stickying with only one style as a benefit.
Nice ! Actually I wrote one too . It's inspired by mocha a javascript bdd test framework. It supports the well-known rspec syntax as well as qunit , testify syntax. https://github.com/v2e4lisp/preview
It sounds like nginx is being used as the front end, and calling apache for static content, This does mean apace shouldn't have any knowledge of PHP though But this is going to sound like a stupid question, but apache has been restarted right, so it has to research for .htaccess
Unfortunately I have no way of restarting Apache since it's a shared box. 
I would recommend if you haven't done any OOP then the first one is change your database methods to OOP t The PHP tutorial / manual on PDO gives an almost perfect example on how to do it And because it's your database, your going to be changing 90% of your scripts, you will then start to realise which parts of them can go into classes And by the end if the exercise you should have moved most of your code into classes, and then your doing OOP as standard
Not sure how I like the new language features. On one hand they're pretty cool, but on the other hand once you use them you are tied to HHVM, and your program won't run using Zend.
We implemented generators after HHVM did, for example. The implementations don't match in the details, but then again, HHVM doesn't match PHP particularly well in any of the details...
The implementation details don't matter so much - the behaviour though would be useful to match if HHVM gets traction. Code will be "out there" in the wild and introducing competing syntaxes and behaviours would potentially drive a wedge between the projects. I'm not saying "do stuff the HHVM way", but more "are you guys talking to the HHVM guys to agree on a consistent way forward". And also...generics in vanilla PHP... pllleeeeeeeaaaasseeeee :) 
The OP wants to write the book for those that fail the FizzBuzz tests not to learn. There is a thing called "cost of opportunity" which means that when you decide to do something even if it costs nothing in terms of money it still costs you the time that you could use to do something else. Even if the OP will learn something I still think there are better ways to learn, hence the "you have something better to do with your time"
I think they means don't use a framework you don't know for an important project or tool, and I would kind of agree.
The syntax is slowly becoming more like C#, haha. The asynchronous async/await syntax was based off C#, as was the syntax for generics. I believe the Hack team may be working on C#-style lambda expressions too. 
Maybe so, but HHVM isn't going anywhere in the near future (Facebook's existing PHP code base is massive), and I doubt the mainline PHP implementations of these features would differ much in terms of syntax, if they ever get around to implementing them. 
Generics look the same in Java too.
I'm on mobile right now, so I'll help later.. It's probably on myimouto/app/assets/stylesheets
On one hand, stuff like HACK (with strict scalar types etc.) looks really nice, but then there are horrible stuff like XHP (mixing PHP with XHTML? *eww...*) Still, this is miles ahead of Zend and I do hope HHVM becomes the defacto default implementation in the future.
Some things change very quickly. Rewriting hundreds of thousands of lines of PHP code is not one of them. It's going to be around for a while. 
I haven't used Java for a long time and couldn't remember if the syntax was similar, which was why I didn't mention it. I'm much more experienced with C#. I remember there being some subtle differences between C# and Java but couldn't remember what they are :(
This talk is from PHPBenelux a few days ago; if they put a recording up it's well worth watching. 
Yeah, HHVM is. But Facebook already have set a standard for totally changing how things work.
I use [Codeception](http://codeception.com/)
There are few better ways to learn than by teaching...
What version of PHP are you running? I just took that exact same code and got no error. I'm on 5.4.4-14. The alternate version - v_default - accepts by ref (and sets to the default value if it doesn't exist / doesn't match). v_check was added to be able to work with class properties and magic values that can't be passed by reference. 
I'm on 5.5.8, but it's not related to the PHP version, because it's the basics of the language, trying to access an array key that does not exist in the array, produces a warning. If this wasn't the case, there would be no need for v_check at all, because you could just do: $value = $foo['key'] ?: 'default';
After I felt that I had the basics down I created a Social Media site... I ended up learning A LOT. In about 6 months of solid (hours daily) work I had a complex fully functional site that I could show at a job interview. You get a chance to learn tons of php to SQL interaction, lots of template/include/require tricks, session/cookie stuff, all sorts of content sanitation and it's a great place to use OOP. Just take some time and make a smaller, simpler, Facebook.
beats bash and can handle long running tasks!
Strange. From what I looked `file_put_contents` indeed support streams, but `file_get_contents` [never returns one](https://github.com/php/php-src/blob/master/ext/standard/file.c#L557)... Could you elaborate a bit more?
and mysql_real_escape_string is deprecated in 5.5
Yes, thank you!
&gt; What do you prefer , concatenating strings ? It's not an "either or" question. The real answer, like other languages, should be templating engines (Twig etc.). &gt; &lt;rest of your post&gt; I agree that HHVM will end up being the superior choice (in some areas, it already is) and yes, sadly it will be Python3 all over again. However, unlike Python3 HHVM is a one-company operation and due to the CLA requirement, it is unlikely there will be outside contributors to develop it further. Sure, Facebook might not abandon HHVM in the future, but they could very well abandon HHVM-the-open-source-project and that's why people should think really hard before investing in an HHVM-only project...
This is not for testing, it's for debugging. While useful, if you're not writing proper tests you're doing it wrong.
&gt;Am I being unclear here or are we talking about different things? Different things. You should be unit testing, but you also need to be performing functional tests as well which are different. You're getting downvoted because unit tests are powerful for their intended purpose, but your problem with them is you're trying to use them outside of their intended context. You need to learn the differences between unit tests, functional tests, and acceptance tests. When used in concert testing makes a lot more sense.
&gt;Checked for the correct number of fields. You should check all fields, not just do a count on the $_POST array. This includes: * checking that all required fields are present * processing inputs * validating inputs Also, sanitize upon output. &gt;Assigned to local variables. You probably want to read the following: http://www.php.net/manual/en/security.globals.php &gt;Sanitized using preg_replace Sanitation is context-specific. Simply using preg_replace for everything is no good. &gt;Validated using various checks including length and format checks that coincide with DB field structure You're doing a direct-to-database mapping from $_POST? &gt;Are passes through a mysqli prepared statement. Yup, though I'd personally go with PDO since its API is a lot nicer. &gt;Blowfish/bcrypt Randomly generated salt Hashing and encryption is not the same thing. Hashing is one-way, meaning that it's a process which cannot be reversed. Encryption, however, is two-way. As an example, hashing is appropriate to use when dealing with passwords (however, not all hashing algorithms are suitable for handling passwords - they should be specifically designed for such a purpose, such as the case with bcrypt). As an example, encryption is appropriate to use when dealing with files, where you want to be able to access the data using a key. &gt;Md5 verification code for email verification As long as you use sufficient entropy for the generation of the underlying code that you feed to MD5. &gt;Cap users at 10 failed logins, with an automatic 1 second * # of failed logins sleep to slow down brute force attempts., [Yeah, no. Don't do that.](http://www.reddit.com/r/PHP/comments/1aitay/simple_powerful_and_easy_to_use_authorization_and/c8xwswq) &gt;Log IP on login. You can store away an "identity" in the session data for you to match against upon each request. Examples of an identity could be storing the IP, or the user agent string (or a combination of both). If the identity does not match, you prompt for a password and add the new identity to the session upon authentication. &gt;If next login is &gt; than 50 miles away, verify account via phone vericode if feature is enabled. Yeah, that's not going to be a good solution. IP2Geo can is not exactly reliable and should only be considered a guess. It can report that you're straight across the country when all you're really doing is hopping between hotspots across the block. &gt;Sessions - I'm a little newer to these, and not entirely sure on how to go about them without limiting functionality. You should also be regenerating the session id upon logging in to prevent the possibility of session fixation. Also, use HTTPS. You should read up on CSRF, XSS etc while you're at it.
You're on the right track with some of these, but: * if you use prepared statements, you should **not** escape your data * if you use prepared statements, you should **not** sanitize data before insertion * save sanitization for *displaying* user-generated data * never assign user-generated data to local variables * use PDO, not `mysqli` * I would use SHA1 instead of MD5, no matter the context * geo-decoding IP addresses is not 100% accurate (eg. every site I've checked thinks I'm in another province right now), better to use a "remember me" token cookie * users behind an annonymizing proxy or a Tor-style network will have to verify their account every single time they login. * a short-lived verification code that is texted to them might be better and less intrusive (and less expensive to implement)
I use a software called [LICECap](http://www.cockos.com/licecap/) to capture my GIFs (on OSX). It's not perfect but it gets the job done :)
Would an empty file not be better? 
I don't see any mentions of PDO. I've been using it for a while now and the API is really friendly. Also, for the sake of sanetizing, check out the [filter_input](http://php.net/manual/en/function.filter-input.php) function and it's various flags.
I apologize, some of my terminology may have been a little off. I'm completely self taught and tend to throw words around incorrectly. I don't escape my data; however, I do validate it. For example, a password can't be larger than the max length VarChar type in a database, usernames must be all letters/numbers, etc. I have yet to add in features anywhere that could contain special characters (comments, titles, etc.), but when I do, I will make sure not to escape that data. Following this, would I even need to sanitize data that is served up to my users? Why can I not assign user-generated data to local variables? $_POST['username'] as $username is easier to play with and should be just as safe? What am I missing here? Is there any direct benefit to using PDO over mysqli? I thought the only advantage was that PDO could interect with a larger number of database setups? SHA1 for the vericode instead of the MD5? I can do that. Is it easy for a user to steal a session with a "remember me" cookie? I'm unfamiliar with the implementation of this concept.
&gt;I don't see any mentions of PDO. There's been two mentions already ;p
You may change your mind once you have to start performing tasks like deployment to multiple servers with different roles. Don't discount the usefulness of other languages so quickly - if you've never bothered to look, it's hard to know what you're missing.
&gt; PHP IS a templating engine. how do you think Twig works ? By using `extract` &amp; `eval` and then `echo`ing the entire result. Unlike XHP, at no point PHP &amp; HTML are mixed inside the source code. 
&gt;So... $username = $_POST['username']; is bad. No, but having post data map automatically to local variables is. See the example code for register_globals as to why that is: &lt;?php // define $authorized = true only if user is authenticated if (authenticated_user()) { $authorized = true; } // Because we didn't first initialize $authorized as false, this might be // defined through register_globals, like from GET auth.php?authorized=1 // So, anyone can be seen as authenticated! if ($authorized) { include "/highly/sensitive/data.php"; } ?&gt; &gt;By checking fields against the database, I meant $password cannot be larger than the max size of a VarChar field. That would be unnecessary since the DBMS wouldn't allow you to insert data which violates its constraints; It would yield an error. &gt;Is there a benefit, other than the ability to use other database types, with PDO over Mysqli? Well, like I said, its API is a lot more convenient to use. &gt;Should I be recording the session ID to validate it on each page load? You shouldn't be recording the session id, that's handled automatically. You should be recording some identifying information for the user such as IP and/or user agent to validate against. &gt;How do I force the session ID to regenerate? session_regenerate(); &gt;If every page has a login bar at the top, how do I use HTTPS? Doesn't HTTPS cost a decent chunk of change? Switch to https:// in the URL. You'd want to get a SSL/TLS certificate as well. Additionally, you might want to have a look at [Secure and HttpOnly](http://en.wikipedia.org/wiki/HTTP_cookie#Secure_and_HttpOnly)
An IP address contains only 32 bits of information, making it trivial to reverse most hash functions applied to it. If you want to preserve privacy consider dropping some bits from the IP address before storing it. I.e. `123.45.67.89 -&gt; 123.45.67.0`
Yes, that may work, but I gave the above example because I know it will work.
Set up all your tools (phpunit, phpcs, phpmd etc) and run grunt watch. Never manually run them ever again.
lol
Interesting... I'm mostly used to people using Grunt as a build tool for a JS-based stack, not for other languages. I'll have to look into it :)
Two words: Drupal 8.
I would add a time component (and a user specific component, if available/beneficial). Thats a very small set of potential hashes. Also, use mt_rand wherever you might use rand. Its faster and more random.
Challenge accepted. http://psysh.org now has at least seven reasons you should use it instead of phpsh :)
I have not been keeping up w/ Zephir since trying it last year. At the time it did not have any native/FFI support which was a deal-breaker for the type of extension I was trying to develop. Has there been any status updates wrt FFI and communication w/ C libs?
We use it at work for the whole stack, for deploy we have Jenkins run an adjusted set of config options through the same tasks, it's very good. We tried guard for a while but unfortunately the phpunit guard is unmaintained so it got awkward.
Time is still relatively easy to guess. Use `openssl_random_pseudo_bytes` for solid randomness.
Validation is fine and good, and it should be done on both the client-side via Javascript and on the server as well (better UX if the client can do some validating first, without requiring a page refresh). Sanitizing user-generated data before sending it to a browser is considered vital, as Nicoon was saying. Unless you're displaying the results of content with HTML (like from TinyMCE or the like), you need to properly encode that output (`html_entities()`, for example). Also, if you do allow HTML input at some point, use a whitelist library for it. Do *not* use regexes to filter HTML yourself - it won't work. PDO is the newer library. MySQLi is the older one. It has a number of advantages (written about elsewhere, like http://net.tutsplus.com/tutorials/php/why-you-should-be-using-phps-pdo-for-database-access/), not least of which is that it won't be deprecated anytime soon. Prepared queries are pretty much a free immunity to SQL injection (as long as you're careful with them). I won't repeat what Nicoon has said - I agree with him on those points. Take a read through [OWASP Top 10](https://www.owasp.org/index.php/Top_10_2013-Top_10) and make sure you're addressing those issues in your code.
I am sure someone will disagree with me on this, but regarding SQL injection, you can do away with sanitizing if you use [prepared statements and parameters](http://www.php.net/manual/en/pdo.prepare.php). 
To just extend on this; md5() isn't some magical function that makes things unguessable by itself, it depends on the input you're giving it. rand(0,1000) means that you'll just generate 1000 different hashes, all easily being reversed (just try googling for one of them) to their original value. If someone really wants to find out how you're generating the hash, it'll be rather easy to reverse it and generate the small number of requests needed to validate a random email address. openssl_random_pseudo_bytes can help, as well as generating a random string from a predetermined alphabet of a-zA-Z0-9 of a given length.
Is this necessary for a one time use only email verification code?
Not necessarily. MySQLi was designed for MySQL, yes, but PDO was designed for programmers. Save yourself a headache and switch to PDO. You'll thank yourself later.
Without commenting on the rest (use filter_*, prepared statements, escaping on display with the context of what you're using the data for, etc), &gt; Blowfish/bcrypt &gt; Randomly generated salt Use [the password API](http://no2.php.net/password) to generate and verify passwords if that's what you're using it for. If you're not on PHP 5.5, use [password_compat](https://github.com/ircmaxell/password_compat).
This. And +1 for PHPStorm.
Unless you want bots to be able to create user accounts, you do need to supply sufficient entropy, yes. More information: http://phpsecurity.readthedocs.org/en/latest/Insufficient-Entropy-For-Random-Values.html 
&gt;theres always stuff in projects you only do to suit the law (And theres a lot of them over here in europe, especially in germany) What else are you thinking of? Besides Impressumspflicht..
just a note on saving ips: You can save his ip if he allows it. I used it a lot in Webshops where we save Ip to orders.
I liked the idea, thx
Vim is great for some basic editing and procedural code but when you start getting into multiple directories and files in a project, and IDE has a lot more benefits. Just my thoughts though.
Thanks, I think I'll get your book some time later.
Do I get bonus points for remembering the parameter orders in the `array_*` functions?
&gt;any data I recieve back from the database, or any SQL that relies entirely on DB pulled values, does not use a prepared statement. Be careful about this. What if a user gives you data that you insert (safely) into the DB using prepared statements, only to pull it out and dump it straight into a query at a later date? You should use prepared statements for any data that *ever* came from the user. In this case you say you are sanitising the data too, which would ideally make it safe, but it undermines your use of prepared statements if you don't always use them.
Well, the only thing not responsive is overflow on the pre blocks. Not that bad IMO.
Hmm... This is a good point. Thank you for this comment.
There is an error in the **while list** solution, it isn't actually incrementing the value: $y[$k] = $v; needs to be $y[$k] = $v+1; 
Pretty good opening test on developer's knowledge of PHP. I consider myself an experienced PHP dev and I certainly couldn't have provided all the different types of solutions off-hand.
I know the function names and what they do, but parameter orders are my downfall. Also, I never know if you are passing the array by reference or if it returns the modified array.
Or if you are a terminal guy, you can replace postman with [httpie](https://github.com/jkbr/httpie). Although both are more suited for debugging rather than testing.
Well, generally, no.. but, if you're querying data that doesnt change, using queries that don't change, a query cache could perform better.. but it's basically a less granular caching. The buffer pool can cache the most used rows instead of the most used sql statements.. additionally, the memory managment is easier.. as a row falls off the cache, you only use 1 row.. in a query cache, I'd imagine that an entire query full of results fall off at the same time. Also, it's obvious that a query cache is better for smaller queries than large ones.
Thank you, that's fucking lovely. I'll use that when I have to debug stuff over the CLI and can't use Postman, and don't want to use curl.
There's one thing to remember. Variadic functions keep the variadic part at the end of the parameter list. So array_map can take multiple arrays, and apply a function to all of them at once, like zip. There's one function and several arrays, so the function is first. All other array methods, walk filter and reduce, only take one array and one function, so the array isn't variadic and comes first.
I think hackerrank.com had a PHP section
I try doing questions like this when hiring php devs. I tell people that I don't care about the specific syntax. I don't give bonuses for getting syntax perfect nor to I dock for being somewhat off (at least not much of one). If I can tell what they are trying to accomplish, I credit them for the process. Generally people can google the appropriate syntax.
Well, in most cases that are just fine, I would say, I mean deciding whetever you should use one single array_map or array_walk definitely seems like premature optimization. 
I dont think it is. The question is not "how many ways of doing this can you think of?" - you can only pick one. I would have picked the first foreach. There is very little reason to do it any other way, in practice. This article is not the best.
I tend to hold the view that there's absolutely no shame in googling, or having a browser tab open with php.net loaded. In fact, if I were looking for a job, and a potential employer were to hint the opposite, then they're probably not a potential employer anymore as of that moment. If there's one thing I find annoying, it's reading other people's code and going, why didn't this person RTFM? I certainly wouldn't want others to feel that annoyance about me!
I would do it like this: echo preg_replace_callback( '#int\(([0-9]+)\)#', function($matches) { return 'int('.($matches[1]+=1).')'; }, call_user_func(function(){ ob_start(); var_dump(array( "one" =&gt; 1, 2 =&gt; 1, "three" =&gt; 1, "four" =&gt; 1, 5 =&gt; 1 )); return ob_get_clean(); }) ); edit: or possibly like this: &lt;?php $a = array( "one" =&gt; 1, 2 =&gt; 1, "three" =&gt; 1, "four" =&gt; 1, 5 =&gt; 1 ); $b = json_decode(preg_replace_callback('#\:([0-9]+)#', function($matches) { return ':'.($matches[1]+=1); }, call_user_func(function() use ($a) { return json_encode($a); })), true); var_dump($b); When do I start?
Yeah, I don't think this is a particularly good way of testing a programmer. This is all well and good, but if I don't know what unit tests are or test driven development is and yet I score well on this test, I'd argue you'd be ranking a poorer programmer higher than a potentially good one. I prefer to see code samples for problems they've solved. In my last job, I was in a hiring role, and the only technical question I had was some sample code I wrote that produced the expected output to the screen but was particularly poorly written. I would show that to them and ask them A) What's wrong with this code? and B) How would you improve it? The answers to that question, as well as seeing their code, gave me all I needed to know to make an informed decision. 
Yep. I walked out of an interview a couple of years ago when they asked me to do their technical test. They were about to leave me in the room alone with just a pen and paper. I decided that was stupid and asked them point blank for access to google - they said no in a scoffing kind of way. I stood up, shook their hands and thanked them for their time. Totally pointless. In a real environment I'd have access to google and an IDE that provides excellent code hinting. There's no shame is using either of these tools, so asking me not to use them in a test environment tells you precisely nothing about what I'd be able to do for your company in practice. I don't want to work with unreasonable people, so anyone who does this gets a no from me straight away.
And at that point, I, as the interviewee, would begin to suspect that the guy interviewing me was no expert at all.
The article is highlighting how to look for a good PHP Developer, not just a good programmer. IMO, this is a great way to see how deep someone has gone into PHP. Any other language though and I'd completely agree with you.
&gt; want an int and "11234fudge" is passed in, then you get 11234 Good god, why would anyone want that? Yes, PHP already does stupid things like that but can't we all agree that it's just a bad idea. 
 array_walk($x, function(&amp;$v) {$v++;}); I don't think this is a very good test of skill to be honest.
Why? Asking someone to iterate through an array in more than one way seems like a good way to test the depth/fragility of someone's knowledge of the language. Even if there is a single best way to do it, someone who claims to have used php professionally should be aware of other ways to do it. My choices would be: foreach by reference, foreach by copy, and array_map. Again, this question doesn't tell the interviewer whether or not you are an expert. It allows the interviewer to distinguish between the people who have done some work in PHP, the people who copy &amp; paste basic language constructs, and the people who just wrote PHP and Symfony2 on their resume.
from cookie laws to vorratsdatenspeicherung to datenschutzbeauftragten to certain TUV certificates to using RHEL if you need insurances etc ... sucks^^
If you look elsewhere in the thread, I've posted further reasons and explained what I think is a better approach.
I really like your question because it can apply across many different languages as well; it tests more of an understanding of Object Orientation versus just using the tools PHP gives you, but it does provide you with plenty of opportunities to demonstrate knowledge of those as well. In other words, I see your point and I like this question better haha.
For free is an issue. But the biggest test/certification I know of is the Zend Certification: http://www.zend.com/en/services/certification/ If you're applying for a job, a Bachelor's in CS or demonstratable applications will probably go farther. If you're developing your own projects, an abstract expression like "How good am I at PHP" on a scale of 1-godly isn't as relevant, you just need to be concerned with knowing current good standards of PHP development and the various tools/libraries available if you need them. A couple things you probably want to look into (hi google): Frameworks (Symfony, Laravel, CakePHP) Dependency management (Composer) Unit testing/test-driven development (PHPunit) 
Folks on PHP internals will never agree that it is a good idea. Consistency is not a bad option, when compared to the alternative: some stuff works like A, some stuff works like B. If keeping type-hinting consistent with other areas of PHP will help get it past the vote, then that seems great. There is already talk of "strict mode" being worked on in general which would change this sort of functionality on a file-by-file basis, which sounds like it could fit in with this nicely. By default it does the weird conversion thing, but if its in strict mode then an int is not a float and f**k you for trying. **Edit:** Oh and while the 11234fudge thing is gross, supporting the usual PHP conversion helps out a lot as any integers coming out of MySQL are strings. Getting a value from an integer column in the DB and passing it into an integer argument, but being told its a string is going to murder junior devs. Maybe throwing them in at the deep end is great, but it sounds a lot like the "cannot convert char[10] to string" bullshit I had to deal with in C++.
I would add a few other points about PDO: * Yes, you can easily switch to another database engine if necessary, but obviously you'll need to check compatibility with the queries you're running * PDO is written in C and compiled directly into PHP, so it has a nice performance boost. I've seen many, many people recommend it as well. * PDO's prepare function nicely sanitizes inputs and helps protect against *most* injection attacks. You should still try for additional sanitizing, but it takes care of a lot of this for you.
Hehe Thanks :-)
Just to clarify: &gt; * never assign user-generated data to local variables You're saying don't do $username = $_POST['username']; And instead do something like: $username = sanitize('username'); Or something to that effect where you're sanitizing the user's input before you assign it to a variable?
Yeah, I'm actually fast arriving at that conclusion myself. I'm using CodeIgniter at work, learning a lot. I've used Composer a few times because I'm learning Laravel, but I don't think I'm really grasping its potential yet. Next step will probably be the PSR's and PHPUnit.
I'll take this over the strict type hinting but it still seems like there is an opportunity to improve things here rather than just to what PHP currently does. Especially since type hinting is an error detection system; allowing "1234fudge" as an integer dilutes the usefulness of that error detection. I find it funny that the only two options for dealing with types in PHP seem to be a) The wrong way PHP currently does some conversions/comparisons or b) Completely strict so that even floats and ints aren't compatible. Am I crazy for thinking the correct pragmatic solution is somewhere in between?!? Hell, I would argue that any correct PHP program isn't going to be relying on these types of crazy incorrect conversions anyway. So disallowing them won't affect any correct program and give incorrect programs the error message they desperately need. 
I was going to use CodeIgniter until I found out it hasn't been updated in months and Ellis Labs is looking to sell it. A shame, because I really liked the feel of CI.
Somewhere in my post history (last week) is a comment where I went into a little more depth about this. 
Ok i just did it. Do you really think he will do anything about it?
I usually roll my eyes on the interview questions popping up here, but this one is really good, thanks.
just be aware of this almost 10 years old pitfall in php: https://bugs.php.net/bug.php?id=29992 (just checked on the vm that is running 5.4.9 - still happens)
I say forget about singletons and look into IoC containers instead.
As a substitute, or in addition to factories?
Adding some basic version control information would be good too - I'd cover the absolute basics + branching and merging at the very least.
 $y = unserialize(str_replace('1;', '2;', serialize($x)));
Well my PHP skill level is apparently zero.
That was my first answer and the most obvious I'd hope. Then I came up with array_walk, array_map, and arrayiterator. I couldn't think of the last two then when I was shown them I did a face palm. I didn't think of them, because why would you ever do that? Foreach by reference has been considered bad practice for a while now (or was the last time I checked) and list() inside of a while?! 
&gt; There's no shame is using either of these tools Even more important for a business is that there's no *value* to *not* using those tools. Being a walking php reference is a low-value skill; minute in value compared to being able to design a strong solution.
Makes sense if you read the explanation in the comments. This will never be "fixed" because it's not actually a bug.
Definitely. An important skill is to produce readable code so you'll more easily know "WTF was I thinking?" later on when you go to revisit your code.
Oh, this will be awesome... How about we come up with the most complicated ways of solving the same simple problem and then see who wins. It'll be like a PHP version of a Rube Goldberg machine competition.
full disclosure: i am the author.
Some more things: * In general following a coding standard as mentioned. * Fix the indentation. * When using single quotes inside a string use double quotes around it and vice versa. * Don't include the closing PHP tag `?&gt;` in code files. * Etc. * Remove the unused member variables `$prefix` and `$suffix`. * Add getter/setter methods for `$firstName` and `$lastName`. * User::get_person_by_last_name() is very weird. It should probably be a static method that accepts a last name by parameter. * String values are not properly escaped when interpolated into SQL queries. Right now this isn't a huge problem as the strings used happen to be safe, but it's an accident waiting to happen especially once we start accepting user input. * Preferably use parametrized queries. You're using `mysqli` already. * Consider switching the character set of the page and table to utf8. * Don't connect to the database with the root user. Make a dedicated database user for the application with only the permissions it needs. * The database connection could be moved to the constructor, but I'd rather see it injected into the object somewhere. * The `first_name` and `second_name` fields in the database are restricted to 30 characters. Unless there's a good reason for this it should be extended to 255. Either way the limit should be documented in the API and consider also throwing an exception when longer values are given. * Add lots more documentation in general. At least for the class and its members. * Similar to your point about 'user' and 'person', 'last name' and 'second name' should be used consistently as well. * Consider using `IF NOT EXISTS` for the `CREATE` statement rather than a blind `DROP`. * Remove `AUTO_INCREMENT=4` from the SQL `CREATE` statement. I think I'll stop there. That's hardly even considering accepting user input.
Sorry man wrong country :)
http://coderbyte.com/ has exercices in several languages including php
str_replace() ?
`str_replace()` works on strings and arrays of strings, and thus falls under a different set of rules (not that I know what those rules are). It's behavior also requires a replacement parameter.
Except, a good developer would go with the simplest answer, not the most knowledgeable one.
I would advocate for PSR standards anywhere I worked.
I realize this article is trying very hard to play devil's advocate for singletons, but every point where he says there's an argument for singletons is blatantly false. There is never a need for singletons, and there is no way to "implement it properly" that makes it OK.
Sure, but you don't suddenly decide to reformat an entire project because you think it's more right than what's there. That's a good way to piss off every other developer on that project.
Which is a fair criticism, the purpose of the article was to present singletons the problems that are related to their usage and yes I did try to play devil's advocate. And to be honest I did struggle to come with possible examples.
Sigh. I can't believe this is serious. "How many different ways can you accomplish a trivial array operation?" That's how you hire?
These types of tests are not fair assessments. I'm not a savant that can recite all the nuances of PHP from the top of my head. I rely on access to php.net, this community, and SO for development and *I have a Computer Science Education* (as in, that's not nearly enough). I think a formal background or college education in understanding computer programming, OOP, principles and design patterns is a completely different metric than understanding web development. To be a great developer, you need something from *every* category. To have potential you need to understand the fundamentals - the Tao of the Web Developer. Anyone can pick up php and get creative with it, but to be a rock star you need to know why things work the way they do. It's like the difference between a Cook and a Chef. A Cook can prepare a meal from a recipe and knows his way around the kitchen. But a Chef knows what ingredients go together and why they work and what tastes like crap. A Chef knows the chemistry, a Chef is an artist. tl/dr; It's late and I'm cranky and I'm currently working on a "PHP Test" for a job interview. It's not going well.
Major contributor to the PHP.net website here. I'm glad you expect the best from the PHP.net website but honestly it's built from contributions by people pretty much like you. Sadly I've been too busy lately to contribute much but that's exactly why we need more people committing to the project! 
Just to clarify, most IoC containers make heavy use of singletons. Pimple, for example, uses singleton instances by default unless you specify otherwise. Laravel Facades resolve instances out of the IoC container and also makes singletons out of them. The IoC itself also has a singleton method for creating shared services. Just wanted to point out that IoCs and singletons are not mutually exclusive concepts.
&gt;Just to clarify, most IoC containers make heavy use of singletons. No, they don't. IoC containers are part factories, part object registries. A registry is quite different from a singleton, and the former doesn't prevent the creation of new instances, if one needs them. 
You might find [**this approach**](http://stackoverflow.com/a/11369679/727208) somewhat useful.
Interesting to see Guard instead of Grunt. One would think Js is more up a PHP developer's alley than Ruby. 
Well phpbb was not born yesterday...
Singletons amount to putting your code in global scope. Globally scoped code is unanimously harder to test and edit. Strictly procedural php code also exists in the global scope and therein isn't any better or worse than singletons. Essentially you must ask yourself why use object orientation for essentially global code therein immediately violating object orientation principles. You have global code in a local scope. This is bad. The only argument **for** using singletons is to take advantage of autoloading and essentially compartmentalizing that globally scoped code in namespaces. But frankly you need to refactor that code before worrying about autoloading it.
&gt;Am I missing something? Yes, you are. An IoC container is a registry which has factories registered to it. Here's an example: $container-&gt;set('Bar', function () { return new MyBar(); }); You then retrieve an object, like so: $container-&gt;get('Bar') Which you use to inject into your classes, e.g.: $foo = new Foo($container-&gt;get('Bar')); The factory can also pull other dependencies from the container to wire itself up, e.g.: $container-&gt;set('Bar', function ($c) { return new MyBar($c-&gt;get('Baz')); }); That's the basic gist of it. Then you can have containers with reflection etc to handle the wiring for you.
&gt; I'm using CodeIgniter at work Willingly? 
Yeah I'll keep bugging him until he does. :)
&gt; Installing a virtual machine to run PHP on ( thinking step by step guide of ubuntu vm here using vagrant ) Seems a bit overly complicated for FizzBuzz. Why not just get them to install PHP locally?
Hehe ;-) OK, let's go nuts: &lt;?php $x = array( "one" =&gt; 1, 2 =&gt; 1, "three" =&gt; 1, "four" =&gt; 1, 5 =&gt; 1 ); ////Your code here $descriptorSpec = array( array("pipe", "r"), array("pipe", "w") ); $command = "perl -pe 's/(=&gt;\s+)([0-9]+)/$1 . ($2+1)/e'"; $process = proc_open($command, $descriptorSpec, $pipes); if (is_resource($process)) { list ($inputPipe, $outputPipe) = $pipes; fwrite($inputPipe, var_export($x, true)); fclose($inputPipe); $phpCode = '$y = ' . stream_get_contents($outputPipe) . ';'; fclose($outputPipe); proc_close($process); eval($phpCode); }
Can you explain what it exactly does and how it works? ( I checked the repo already but didn't find it) Tkx.
https://gist.github.com/anonymous/8659044 Well this is the solution. Its only a couple lines of code. Is there a way to submit css suggestions to the site? I thought the contributions were more for php examples.
So basically [Guard](https://github.com/guard/guard) is a ruby gem that triggers events on changes in the filesystem, Guard itself doesn't act on those events, instead [devs have built extensions](https://github.com/guard/guard/wiki/List-of-available-Guards) to Guard. A good example is the [SASS](https://github.com/guard/guard-sass) and [LESS](https://github.com/guard/guard-less) extensions, both of these will only listen to changes to .less and .sass (.scss) files respectively and then perform actions on those changes, most commonly to compile the files to CSS. Guard-codeception is another extension to Guard that listens to changes in php files and then will run your [Codeception](http://codeception.com/) tests automatically for you instead of having to run `vendor/bin/codecept run [options....]` every time you want to run codeception. Getting started is pretty simple. Make sure you have both [Ruby](https://www.ruby-lang.org/en/) and [rubygems](https://rubygems.org/pages/download) installed and run `gem install guard-codeception` to install the plugin (it will pull all dependencies automatically). Then in your project folder where your codeception tests are sitting run `guard init codeception` which will create a Guardfile with the default template which will just listen to any changes made to PHP files, nothing fancy. Then just run `guard` to start Guard up. Then make a change to a php file and watch the magic. Hopefully i explained it well enough but feel free to reply or PM me if you have more questions. 
&gt; To be honest with this question I'd probably be a little annoyed by any answer other than; I actually think array_map is cleaner for tasks like this. 
U explained it very well, tkx! You should put this in the readme file of the repo :) However, does it act on ALL php file changes or can we configure when it should run automatically? IE, when we commit?
cool, tkx
The same dev of Postman recently created a new tool for testing called Jetpacks. You can check it out here: http://blog.getpostman.com/index.php/2014/01/16/ridiculously-easy-api-testing-introducing-jetpacks-for-postman/ For manual testing I'm using Postman, it's a really great tool.
I have, but usually I cant reliably guess method dependencies without actually trying to implement it. I must say that this is obly true for rather complex stuff. Simpler stuff I can do with any approach.
&gt;unless defined otherwise. Then it wouldn't be a singleton. ;) Point of the matter is, a singleton is a very specific pattern which restricts the instantiation of a class to a single object. That's not what a registry does. A registry simply stores objects for later retrieval. If we're going to conflate the registry pattern with the singleton pattern, then a simple variable holding an object instance would also be a singleton. Though, I think we would all agree that such a definition would be ludicrous. 
&gt; But I thought you were telling you could use IoC container to do the job of factories when you said this. I was talking about singletons. Nevertheless, you *can* have IoC containers do the job of factories via the use of [reflection](http://www.php.net/manual/en/book.reflection.php), if the container is built to handle that. 
I long since hung up my developer boots and moved into the world of project management in my professional career, but I am a huge fan of "emergent architecture". I think, if I may venture an assumption about the way you work, the problem you are having is here: &gt; Whenever I think I have architecture figured out, I find myself scratching it after about an hour into implementing it. I get the sense that you are trying to figure too much out. Start with a requirement, nothing more, and build an entire vertical slice of your application around that requirement. Rather than building up "layers" (which is typical of a big design/architecture first approach), just solve that one problem - then move on to the next, and the next, all the while refactoring the slices you have built along the way. You'll find you end up with emergent design - you didn't "set out" to write it in a particular way, you just solved individual problems and moved on. Using that approach combined with TDD (and/or BDD) is immensely powerful. TDD really is just "red/green/refactor" - so you write a test which describes part of your 1 problem, you write code until that test is green, you refactor that code and on to the next test, until you finish one requirement and area ready to move on to the next requirement. The goal should be that at every step each requirement can stand on its own and "work" (though it mightn't be particularly useful on its own). When you initially take on this approach you might find it is slow and odd and you are rewriting loads of stuff. It does feel unnatural. The tendency is to plan for every contingency and have a mental model of everything in your brain before you start. Resist it! all that exists is that one requirement. I've coached people who work on projects with me in this approach and they've gone from being "I can't TDD it is too strange and my brain doesn't work like that" to "How did I ever work without this before" in pretty short order. Now I don't necessarily believe this will work for everyone but it has worked for me and people I work with in the past. Give it a go :) 
I've heard about Vagrant, but never really looked into it. Will check it out, thanks!
smarterer.com has a bunch of tests
This is your averge PHP programmer.
So you're going to write a book that builds up to the fantastic fizzbuzz conclusion? That's truly phenomenal work, I'm sure it'll be a best seller.
Read through the tutorials on w3schools and count how many times you throw up a little in your mouth.
Why are you pull-quoting your own shit immediately after writing it? Are you that much of a narcissi- wait, you have a blog, what am I asking.
&gt; I'm very confident with CodeIgniter Dropped.
Hurrdurr how can I apply patterns for the sake of applying patterns? Great question, OP, keep programming.
...did I miss something?
I looked into Python a while back but I didn't find much joy in it. May go back to it eventually, thanks for the advice. :)
I'm a 21 year old UK PHP developer currently on an internship on my university course and the best piece of advice I can give you is: This field (like many others) values experience far greater than qualifications. I'm at university for Web Applications Development however out of all the interviews I've had only a couple wanted me to talk about my course. Most wanted to know what actual experience I've had. An online portfolio showing off what you can do will benefit you greatly. You can just make up some project and build it, doesn't have to be real. Don't worry about your salary, as long as you're willing to learn and are good at what you do you'll be taken care of. Graduates right out of university seem to start on around £25k which quickly gets bumped up after a year or two of experience. Like another guy said, don't focus 100% on PHP. Employers want you to know the fundamentals of programming, not the fundamentals of PHP. Once you pick up those it's usually pretty easy to apply them to any language which makes you versatile. On top of that, learn some linux administration. Install Ubuntu Server on a VM and just mess around. Install a LAMP/LEMP stack, add/remove users etc. Basic sysadmin goes hand-in-hand with what we do. Lastly, source control. Mainly git. A lot of companies will be put off from hiring you if you've never heard of or used Git. I guarantee you'll fall in love with it once you've got the hang of it. Put all your portfolio projects on GitHub also so you can show off the code.
I'm glad to hear that qualifications aren't everything. I know it's cliché for somebody of my age, but I'm kinda getting bored of education - I want to get out into the big world! I will definitely install Ubuntu tonight. I'm already familiar with git, I should probably add that to the OP... Thanks for taking the time to reply, appreciated!
Yeah, I really want to avoid university if possible. I use Javascript fairly frequently, I never took it seriously though. As for Java, I'm familiar with it, but I've never used it for web development. Python, I'll definitely look into. Thanks for the post, really informative - appreciated!
Pssst ... sorry can't write too much now, for now, here's a little tip from an older guy, focus on learning and understanding and getting work done, don't worry too much about the particular language or technology, learn computer science and the deep stuff while you are young and capable. By the time you are 26 you'll know 15 different languages and be miles and miles ahead of the competition. Here's an actionable suggestion: * Get shit done, and put it on github and your personal site (either start your own project, or contribute to already existing ones) Once you have done that, many future steps become easier, because you are young, you are more vulnerable to being dismissed as a kid, so it's even more important that you have some real stuff to show. Put some solid work in, and learn stuff (if you can do online courses from famous universities that's great too), once you hit 18 you can approach companies, show your work, and get a great job, might even be possible earlier on but being above 18 makes things simpler. Hope that helps
There's a lot of PHP dev jobs going at the minute, perhaps a little less so for juniors (although my company is hiring juniors, we're in Manchester). It sounds like you've got some good knowledge already, OOP, TDD and version control are a real plus. A lack of qualifications probably wont hold you back all that much. In the north of England, to the best of my knowledge, junior devs earn £16-20k dependant on skill and the company that's hiring.
Thanks for the reply! I'm in the NE of England. I don't intend to apply for any jobs just yet, but I've been looking around out of curiosity and was pleasantly surprised at the amount of web dev jobs going at the moment.
No problem. You sound nice and proactive which is what employers like so I'm sure you'll have no problem when you do come to apply for jobs. If you haven't already work on a few PHP projects for yourself so you'll have something to show off your skills when the time comes.
Love the interface. 
My problem with TDD is that the tutorials out there are lacking. I want to see a tutorial on TDD for PHP that has smooth transitions and covers stuff like 'How to think in TDD' and how to mock up data for MySQL. Maybe something like build a framework with TDD and develop apps with that framework using TDD also.
I don't think it matters too much, just be sure to use good OOP and good design patterns (you may want to read up on those), probably put it on GitHub too so they can see your use of git.
As others have noted, there's a few things wrong with the way you're doing it in this code. * You're using ereg_\* * You can actually just do that outright replace with str_replace, passing the array of items to be replaced as an array * You're using mysql_\* functions. Easy fix is to use mysqli_\*, better fix is to learn how to call OO-style mysqli, best fix is to use a proper DBAL * You're stripping slashes which can ***undo*** the work of mysqli_escape. Yes, you're allowing people to inject \n, \r, \x00, and other \\ related escapes because mysqli will escape slashes with \\\, and stripslashes will replace \\\ with \\, effectively undoing them. (as an aside, the regex would fix this, but then that raises more questions than answers. Your regex is destructive to the data and not how one would want to save data) Suggestions: * Go read http://www.phptherightway.com/#databases * Go read http://php.net/manual/en/book.mysqli.php * Use a framework or other library PHP code that has some degree of a DBAL * Never outright use a regex unless you know why you're needing a regex, and you've checked to make sure that there's not a way to do it with built-in string functions. * Keep asking questions! It's a good thing you've thought to ask if you're doing it right, as this has prevented you from assuming you've done it right. If you're ever unsure about the correct way to do something, or just need people to bounce ideas off of, consider joining ##php on freenode or asking in /r/phphelp (as noted on the sidebar!) 
This reminds me of a free version of new relic: http://newrelic.com/
Good points.
I gathered, but I don't understand how simply having knowledge in a framework would sabotage a job opportunity?
You may be interested in Jeffrey Way's [Laravel Testing Decoded](https://leanpub.com/laravel-testing-decoded). It is Laravel specific though .
You're fine sticking with Laravel and Symfony for now. CodeIgniter is simply not going to be developed any longer. It would take a full rewrite to get up to speed with the way modern php frameworks are going and that's not going to happen.
Ooh, can I play? &lt;?php $a = array( "one" =&gt; 1, 2 =&gt; 1, "three" =&gt; 1, "four" =&gt; 1, 5 =&gt; 1 ); eval(str_replace('1', '2', substr($tmp = file_get_contents(__FILE__), $start = strpos($tmp, '$a = array'), strpos($tmp, ';', $start) - $start+1))); var_dump($a); ?&gt; Not as good as yours IMO, but I tried :-)
This looks nice indeed. I wonder how much work it would be to *agentize* the checks so you could have the same dashboard but covering multiple hosts. Would be nice. Also, as I rarely run a full LAMP stack on a single box, easy to kick off quickly: git clone https://github.com/afaqurk/linux-dash.git cd linux-dash php -S localhost:8000 And open your browser to http://localhost:8000/
Hey mate, I'm, currently a php developer in the UK. I would say you are still very young but when you turn 18 and you are confident with your skills you can very easily get a junior role for 20-25k/year considering the salaries today. On the other hand the truth is that there are a lot of devs out there who can write php and the salaries on higher levels are not so good compared to other languages. One more issue is that you should also have a "full stack" knowledge on building web apps. PHP is an aspect of it but for example there are veeeery few devs (I'm still not one of them) who can write good sql.
Ohhhh! My mistake. I thought he was talking about me, not the framework. Apologies, BilgeXA.
That would be a problem. There needs to be one that is framework agnostic, even though I said in my example to build a framework ("mvc"). By building up a framework you learn how to test the framework it self, then the app built in the framework. Then this knowledge would be easier to apply to which ever framework.
&gt; Yeah, I really want to avoid university if possible. Education is critical. University is not. Just keep that in mind and don't ever stop learning.
This is amazing, i love everything about it. There are some issues with your named anchors linking to the wrong parts of the page. Also instead of just jumping to specific sections, would it be possible to have pages with more specific details for each component, networking for example could show all connections and such?
No worries. If there is a problem then it should be fixed. Knowing who can help is half the battle.
Languages are mere tools. If I were you -or younger myself- I'd focus on understanding information technology and the problems it's trying to solve. And when you do that, you'll soon notice that PHP is a small part of the answer. And that it's risky to bet your future on such a small part of the answer.
&gt; Do not estimate in hours. Estimate in days or weeks. If you quote 120 hours and it goes to 144 hours, the client will freak out. If you quote 15 work days and it goes to 18 work days, they'll be a lot less bothered by it. If you quote 3 work weeks and it goes over by 3 work days, it won't even register. It's all the same amount of time, but the framing is different. &gt; &gt; ... &gt; &gt; And regarding developers being optimists, this is *so true*. I regularly point out to junior developers that they are insufficiently pessimistic. A highly-intelligent developer finds it easy to rationalize after-the-fact why things didn't go as planned ... &gt; &gt; &gt; Overconfidence, insufficient pessimism, ignorance of history, and the desire to be one's own customer all lead developers easily into rationalizations that "this time will be different" when they attempt a rewrite. &gt; &gt; These are all totally natural behaviors for developers, especially the very talented ones. 
BDD is really great. It lets you write the tests high level enough that you don't have to worry about the backend architecture from the get-go. Scenario: Users can save images Given I am on the image listing When I click save on an image Then an image should be in my profile BOOM. We just wrote a test that doesn't give two shits about how it is implemented on the backend.
&gt; What sort of qualifications are required? Sweet F-A. What matters is relevant experience and a sort of passion, that's why the first nut is always hardest to crack. It's a vocational field, not a theoretical one. &gt; What's the job market like for PHP devs (specifically UK)? Massive quantity, you won't go hungry once you land your first job. Unfortunately, because PHP is so easy to get started with there's a imperial butt-load of bad code around and there are a lot of companies who make their living just churning out shitty wordpress sites. Don't get me wrong it's not like that's an invalid way of making money, it's just soul destroying for anyone who takes pride in their craft. You will probably have to bite your lip and take what you're given for the first 3-5 years, but after that you can expand and start to be more selective about your employers. &gt; (Roughly) what do they earn? Depends. In the sticks for virgin junior devs it's usually about £18k. My first job was in Central London and I earned £23k. Once you take into account the commuting/living costs there isn't much difference but if you are frugal and careful with your spending you can probably make £1-2k more simply by working in a city centre. A more experienced developer like myself makes £30-40k in London. A super-experienced lead dev can be about £45-60k. Project managers even more than that. After that your options are contracting or freelancing, both of which require solid experience, business skills and a healthy disregard for sleep. I can't speak for freelancers but contractors earn between £200-450 a day. &gt; What sort of skill level is required? Not much honestly, not for a starter job anyway, you'll be suprised at how quickly you learn working on it full time, what matters is how capable you are.
If your hiring strategy depends on questions like this, good luck. 
Awesomeeeeeeeee!!!!! Haha, thank you very much!
you could use GetSimple CMS :) http://get-simple.info/ I have heard good things about it from someone using it... beyond that I have no clue if it really is simple.. :)
Although it is a huge mess, it gets the job done.
&gt; build an entire vertical slice Confirmed. This guy is definitely a project manager.
Thanks for the reply! I don't mean to pry, just being curious: at what age did you take your first job?
Being one of the developers behind it, I'm completely biased, but [Bolt](http://bolt.cm) would surely do what you need, without getting in the way too much. http://bolt.cm
As somebody who has done TDD but writes unit tests in the way that /u/dracony suggests, after the fact, I disagree with the title and theory of this article. Dracony asserts that there is a psychological predisposition for TDD and that many developers fit this model. I was willing to agree at this point, maybe there is some predisposition that makes one "better" at TDD. But later he states the reason he doesn't like TDD, he's writing tests for classes he's eventually going to throw away. This has nothing to do with psychology. A TDD purist believes that tests are part of the code itself, not a separate portion; skipping the tests would be akin to forgetting a semi-colon. Dracony believes that tests are separate from your code, a non essential element; skipping tests would be akin to not putting a semi-colon in js statement. Chances are you're fine, but you know you should go back and add it later. Dracony didn't stop doing TDD because he's a sensing emotion impulsive [more words here] developer, he stopped doing TDD because he felt he was wasting time writing tests for code that was going to be deleted.
Ircmaxell already made one - https://github.com/ircmaxell/PHPPHP A PHP VM implementation written in PHP. If that is what you were asking
There's [PHPPHP](https://github.com/ircmaxell/PHPPHP), but it's mostly an educational tool. I'm not sure if there would be any benefits to it, if PHP would be [Self Hosting](http://en.wikipedia.org/wiki/Self-hosting).
#####&amp;#009; ######&amp;#009; ####&amp;#009; *Here's a bit from linked Wikipedia article about* [***Self-hosting***](http://en.wikipedia.org/wiki/Self-hosting) : --- &gt; &gt;The term **self-hosting** was coined to refer to the use of a computer program as part of the toolchain or operating system that produces new versions of that same program—for example, a compiler that can compile its own source code. Self-hosting software is commonplace on personal computers and larger systems. Other programs that are typically self-hosting include kernels, assemblers, shells and revision control software. &gt;If a system is so new that no software has been written for it, then software is developed on another self-hosting system and placed on a storage device that the new system can read. Development continues this way until the new system can reliably host its own development. Development of the Linux operating system, for example, was initially hosted on a Minix system. Writing new software development tools "from the metal" (that is, without using another host system) is rare and in many cases impractical. &gt; --- ^Interesting: [^History ^of ^compiler ^construction](http://en.wikipedia.org/wiki/History_of_compiler_construction) ^| [^Self-interpreter](http://en.wikipedia.org/wiki/Self-interpreter) ^| [^Vala ^\(programming ^language)](http://en.wikipedia.org/wiki/Vala_\(programming_language\)) [^(about)](http://www.reddit.com/r/autowikibot/wiki/index) ^| *^(/u/bopp can reply with 'delete'. Will delete if comment's score is -1 or less.)* ^| ^[Summon](http://www.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
19, I got lucky though. I was in university doing a jack-of-all-trades foundation degree and i just so happend I was the best coder in the class (because there were no other coders) and one of the tutors friends was looking for a junior recruit and he put a word in for me. I did get very, very lucky though. I didn't have to do what mode people do and get a decent portfolio together, I bought a rag-tag, very simple, shitty CMS I made and showed it to the (non-techincal) business owner. She was impressed because they do a lot of work on custom CMSs and I interview well so I go the job. Very shocking to see the caliber of work that was expected of me on my first day though, the lead developer had to essentially mentor me for the first month.
Word of caution if you decided to skip uni: Usually universities do a decent job at teaching core computer science stuff (algorithms, data structures, etc.) and this is something what a lot of self-thought developers miss. Unfortunately this is not something you can pick up from a quick web tutorial and without this you are unlikely to progress to senior positions. So I would still recommend you to invest in some books and perhaps take a comp sci course on Khan Academy or something. Here's a list of books I would recommend to a person who is going to study software development on their own: * The Pragmatic Programmer by Andrew Hunt * The Practice of Programming by Brian W. Kernighan * Joe Celko's SQL for Smarties: Advanced SQL Programming by Joe Celko * AntiPatterns: Refactoring Software, Architecture and Projects in Crisis by William J. Brown * Compilers: Principles, Techniques, and Tools by Alfred V. Aho * Test Driven Development by Kent Beck * The Mythical Man-month: Essays on Software Engineering by Frederick P. Brooks Jr. * Programming Pearls by Jon Bentley * The Art of Computer Programming by Donald E. Knuth * Design patterns : elements of reusable object-oriente​d software by Erich Gamma * Head First Design Patterns by Eric Freeman * Refactoring: Improving the Design of Existing Code by Martin Fowler * Code Complete: A Practical Handbook of Software Construction by Steve McConnell (Paperback) * The C Programming Language (2nd Edition) by Brian W. Kernighan (books are in no particular order and massively vary in difficulty)
I'm not 100% on skipping uni yet, but it really doesn't appeal to me, so chances are I'll give it a miss. Thanks for the list, will definitely check them out!
&gt;To this I would add: Do not estimate in hours. Estimate in days or weeks. If you quote 120 hours and it goes to 144 hours, the client will freak out. If you quote 15 work days and it goes to 18 work days, they’ll be a lot less bothered by it. And to this I would say: **Bullshit**. If you go over budget they are going to bitch about it. It doesn't matter if the estimate is in hours or in days. This is not a sustainable way to work if you intend to keep happy clients. Instead, do the responsible thing and notify them in due time and let them know that you're going to need more time to complete the work. Normally, the client isn't going to argue about an increased budget, as long as you tell them about it beforehand. Otherwise, you'd risk fighting over a bill and ending up with an unhappy client. 
Fair point; I'm not talking "billing" so much as "scheduling".
Hey, I'm a 17-year-old self-taught developer as well, just wanted to say that there's no need to wait. If you make some small projects and put them in a portfolio, you can start going on freelancing sites doing small projects for other people. Use your portfolio to show them what you're capable of. Even better, if you happen to have a great website idea, don't wait! Work hard on it and publish it. Don't sit around and wait until you're done with school or whatever. You'll learn lots about load balancing and server management. If it grows bigger you will be able to make some money through advertisements. And if it doesn't, it will always be nice to have in your portfolio.
Hi, My Background: I'm a 27 year old CTO that started life as a PHP developer in Manchester, UK To answer your questions: * Qualifications are not required to gain an entry (or even senior) level position as a PHP developer, in an interview you will normally have to complete a small task or have an in depth PHP chat with your interviewer. I'd even go so far as to say "apply for jobs that ask for a degree" in the UK as it is generally a minor point when it comes to hiring. * PHP developers have been in big demand for the past few years in the UK, I'm actually recruiting for a few juniors in Manchester now, (inbox me if interested). * That’s really dependent on location and experience, the salaries below are for Manchester, add 10k or so for London. Entry Level - 17k - 30k Senior PHP - 30k - 45k PHP Team Lead - 40k - 55k LAMP CTO - 50k+ * If you have a good handle on OOPHP5, know GIT, and TDD you will be fine. You can always add to your arsenal by learning Symfony2 or Zend2 as this is what employers are shouting for at the moment. Also, I really am recruiting for both our Berlin and Manchester office, PM me if you are looking for something immediately. 
No problem at all, give me a nudge when your looking for something, I'm almost constantly recruiting. Symfony2 is the way forward at the moment, I've seen some silly salaries being offered for a 2 year symfony2 dev, I would highly recommend you direct your efforts there. Also, take a look at MongoDB with it if you want to be "cutting edge".
Looks pretty good! I'm glad the PSR community has decided to make a move on this one. It seems like every framework has it's own HTTP Message interface (Guzzle, Symfony, React, etc). I think this, along with the original Log PSR, are two very important standards documents for the framework community.
I was thinking this would get people doing things the right way. With vagrant being as simple as providing a box and running vagrant up the learning curve isn't too steep. That being said there's then the problem of editing and deploying code but this could do be simplified by using vagrant shared folders. Thanks for feedback!
Good points, I feel too many people still don't know how to do vc. Thanks for your feedback.
You're welcome to write one.
Nice. Added it to my vim setup. Thanks!
Actually not even that. Writing the tst is actually pretty fast so I wouldn't mind doing that even for classes I throw away. What I mind is mocking, some classes require a lot of it, and mocks depend on architecture. And my biggest fear is having a green test taht is only green because the mocks are out of date. And here is where the article comes in: since I can't reliably predict the architecture writing tests is kinda wasteful. I guess a better article would be on separating design (actually coming up with an architecture) from implementing it (where TDD would be awesome). Perhaps a better way would be writing some clasees to get a feel of the architecture to come, then when having strong ideas about implementation delete everything and start from scratch using TDD
You won't be triggering the zombie apocalypse by using a singleton. Like a lot of things in software engineering, it's a trade-off. Plenty of people don't find its benefits to outweigh its drawbacks, and that's okay. But, as long as the relevant developers understand that it can make testing more complex and code more tightly coupled, then it's absolutely okay to use singletons. Vilifying it just because it has drawbacks - even big ones - is ridiculous. I can pick through virtually *any* app and find patterns and code that have drawbacks.
Licensing info? /pedant *edit 1*: I wasn't the only one, two issues in the issue tracker also requesting specifics. *edit 2*: Licensing has been added, issued under MIT license.
&gt; Plenty of people don't find its benefits to outweigh its drawbacks Except is has no benefits. Only drawbacks. So why would you intentionally work something in that is flawed by design in the first place? To date I have not seen a single reasonable argument for singleton use.
http://www.amazon.com/Test-Driven-Development-By-Example/dp/0321146530/ref=sr_1_1?ie=UTF8&amp;qid=1390934397&amp;sr=8-1&amp;keywords=test+driven+development+kent+beck
Menjo- I started PHP around 13 and rocked it for a few years. Built some large scale projects and gained DB/Administration experience along the way. As everyone else is saying- learn your tools, stay flexible, language is mostly syntax and semantics :) I'm 22 and just started a gig as a Program Manager a while back. It's a bit of a different field but my development experience has been extremely beneficial. I see your anxious to get out there and work, I do recommend picking up a college degree. You can intern in the summer and study something interesting during the semester. You can definitely benefit from theory and "learning how to learn" that comes with advanced studies. I studied EE/CpE as I figured CS was what I'd been doing for years. My current job has nothing to do with current flow or systems programming but it was 4 years well spent.
You should first finalise PSR-6 (or alternatively announce it's dead)
I disagree. I don't know about what kind of clients you work with, but that just wouldn't jive over here. What's more: 1. Clients want to be able to do cost projections. 2. It's a deceptive tactic trying to make it sound less by changing the scale. 3. Talking about days or weeks misconstrues it to mean time of completion rather than the amount of time needed. 4. It might work against you too. There are often more than one resource needed in a project, and if misconstrued to mean time of completion, it could mean that the client misinterprets it to mean that some deadline would have been missed, which could cause you to lose the contract. 5. Trying to accurately estimate time works to your benefit as well, as you'd be able to schedule your projects more efficiently.
Seems like a stripped down Observium
while(list()) is bad pratice. You shouldn't use stuff like that in the context it's being used. List not being used like that sure, but not like that. It makes baby jesus sad.
yeah, for a medium/big project I wouldn't recommend wordpress
&gt;I consider myself as an intermediate with a good grasp of OO techniques and TDD Be careful. Most kids I talk to who claim this really don't know as much as they think they do, and they have even less idea how to properly design apps so they can handle scalability and load. Unless you're actively reading/studying books on design techniques and proper architecture the chances are very good that what you think is a "good grasp" really isn't.
that doesn't mean it isn't simple, just means that it has huge libraries (maybe unnecessary for the job) but if for the user its simple usage and theres another benefit if it uses common libraries if he want's to make anything extra it will have more help from community than if it was all custom code... However it's the first time I've hear of bolt, from a fast overview it looks really nice, but can't say advise on it ;)
&gt; Instead, do the responsible thing and notify them in due time and let them know that you're going to need more time to complete the work. Normally, the client isn't going to argue about an increased budget, as long as you tell them about it beforehand. Otherwise, you'd risk fighting over a bill and ending up with an unhappy client. So much this. I do my best to estimate, am sometimes close but overall I find consistent and clear communication about the completion status of deliverables is (generally) more important than adhering strictly to some arbitrary budget. EDIT: There are also have been plenty of times where I've been asked to fix some random issue or add a feature to an existing product. I just estimate like a day of effort up-front for research and review, then give an estimate later. Most clients are ok with that. It's really unreasonable to think that a freelancer or somebody unfamiliar with a given codebase can just jump right in and give any kind of reasonable estimate on adding a feature or fixing an issue inside something they've never seen.
I could not find any benchmarks w/ a quick search. The most important piece of information no where to be found. 
hmm, although it would make the requested job, I didn't like when I've tried. Also there is a demo here [GetSimple CMS](http://www.opensourcecms.com/demo/2/269/GetSimple+CMS) you can try it But still for something simple wordpress is probably the best since you will have a load of free themes and plugins (it might do everything you need without any extra code) PS: I'm not a big fan of wordpress, but for blog/simple websites, and if you don't wont to spend much time on setting up, wordpress is a good choice for that
You crazy kids and your "PHP". Whatever happened to hacking the gravity function in gorillas in qbasic and screwing with "nibbles"? And what about logo writer and turbo pascal and commodore 64s and TRS-80s? And scorched earth? You're so spoiled. Good luck with whatever you pursue! Like somebody mentioned below, try not too focus too much on a given language, always be a programmer first.
showing CPU/RAM/... stats is *very* far from what new relic offers though
No problem: call_user_func(function()use(&amp;$y){ foreach ($y as $dummy=&gt;&amp;$value) { $value++; } });
htttp://i.imgur.com/PpKRQQc.gif edit: downvoted because I didn't understand a joke
The problem is the state... not how you create these objects &lt;?php class Singleton { private static $state; public function __construct() { if (null === self::$state) { self::$state = createExpensiveState(); } } }
Sorry, that was a typo. I meant "foreach by reference", not "list by reference" (which doesn't make much sense, as list doesn't support refs...)
rather misleading title. it shows you how to add headers to emails sent via php. yay.
I think you missed the part where you actually configure the logs for all emails sent in PHP ...
Coming from PHP, Python is a gift from God
&gt; There are also have been plenty of times where I've been asked to fix some random issue or add a feature to an existing product. I just estimate like a day of effort up-front for research and review, then give an estimate later. Yeah, we do feasibility studies as well. We also include risk analyses, identifying and estimating the likelihood of various risks, as well as the severity of their consequences. That way the client knows the uncertainties of the project, and areas which might require more time. Our estimates are also the result of three-point estimation. 
Have a future in software development, not PHP. 
Yeah, my host has an automagic one click install for wordpress (among other things), so when I need a quicky CMS thats what I reach for.
&gt; I find it a massive waste of time. Cool. Like I said, I don't necessarily believe the approach will work for *everyone*. I will say that I found testing to be incredibly useful when I was writing code professionally, and I find it useful in the teams that I work with now for a myriad of reasons, and I continue to find it useful on the infamous "personal projects". In my varied experience, and personal opinion, I don't find it to be a massive waste of time. Sure it takes longer but the savings over the whole life of a code base are, in my opinion at least, worth it. Also, testable code tends to be well written code. The discipline of writing unit tests tends to help prevent things like god objects and big balls of mud taking hold. This is particularly helpful when working on a team with juniors. &gt; Your approach seems to assume that tests are trivial to code. It should be. If it isn't I'd suggest your individual tests are testing too much. Decomposing the problem into the smallest bits is of course non-trivial and requires discipline and experience, I will grant you that. The overall approach of TDD or BDD is not "easy" - but the tests themselves should be trivial. &gt; What testst the test code? Nothing. The test code should be able to be described as "too dumb to break". The job of the test code is to verify that the real code is running properly. There is rarely if ever anything in the way of complex logic inside a test. You set up your SUT (so create mocks, instantiate your object), you run the bit of code you want to test, you assert that the code behaved as expected in that specific circumstance. &gt; I finding it often harder to get the test right than it is to get the code right. Then your tests are brittle and probably know too much about the actual *implementation*. That isn't to say you never modify your test code, but it really shouldn't be an enormous maintenance overhead if done properly. &gt; I have the lowest defect count around too. Most automated tests are not really about making sure the defect count is low - they are about making sure the behavior of the code doesn't change from one build to the next. It is insurance against regressions. If you are working on a team and you have written some code which passes all tests, and a colleague makes an addition which required some refactoring they can run the suite of tests to prove that their changes haven't altered the way the program works. In a sense the tests are just a programmatic representation of how the developer understands the requirement. If that understanding is incorrect, or the requirement is incomplete (because stakeholders seem to take great joy in not telling us everything that needs to be done) then your build can still be green but it will be wrong. So your defect count might be very low, and that is wonderful, but without a suite of tests to back it up you or someone else who is inheriting your code cannot refactor it with the confidence that they changes wont introduce issues. 
I suggested earlier today that the working group in charge of PSR-6 should put it to Review. Sadly people have jobs, lives, partners and drinking to do. :)
&gt; if misconstrued to mean time of completion Perhaps I have been unclear. I *am* talking about "time to completion" (not about the number of man-hours involved). See my note above about billing vs scheduling.
&gt; I find consistent and clear communication about the completion status of deliverables is (generally) more important I completely agree here. Setting and maintaining expectations is paramount. Speaking in terms of days and weeks (not hours) regarding a completion schedule is of great assistance when doing do.
If you were, then this paragraph no longer makes any sense: &gt;To this I would add: Do not estimate in hours. Estimate in days or weeks. If you quote 120 hours and it goes to 144 hours, the client will freak out. If you quote 15 work days and it goes to 18 work days, they’ll be a lot less bothered by it. If you quote 3 work weeks and it goes over by 3 work days, it won’t even register. It’s all the same amount of time, but the framing is different. 
Well, for starters it speaks of estimates, quoting, hours and work. It doesn't make much sense talking about a specific point in time when the project is supposed to be completed in terms of hours. If you meant time of completion, then you phrased that article in a *really* odd way. Also, I don't see why the client would freak out over you finishing two days later. You never ship/launch a product on the date of completion, you have a period of time where you make adjustments and making sure that the product is stable and tested before releasing it. 
The title could also be read "How to identify an email as spam using PHP," when the actual title would be better written "How to configure PHP so that you can identify where a spam-sending script lives."
You're right. Just because we use some "huge" libraries, doesn't make the product itself necessarily more complicated. In fact, we favor well-known, well-tested libraries that are under active development over something that might have less lines of code, just because it's smaller. tl;dr Less lines of code != simpler
&gt; The problem is that we think of estimates in a different way to our clients. When asked to estimate we inherently know that all we're doing is providing an educated guess. Clients however see an estimate as an exact cost. Preach it. 
That's is why they make validation libraries.
&gt;I agree! This is why I say one should speak to clients in terms of days and weeks, not hours. Uh. Giving an estimated date of completion in remaining hours is like responding with the number of remaining minutes when asked when your birthday is. It simply doesn't happen. I don't see why you felt the need to point that out? &gt;they build their buffers in terms of hours. When speaking in bigger units of time, the expectations are more coarsely-grained, and they build their buffers accordingly. If you're talking of buffers in terms of money, then we're absolutely back to talking about man-hours. 
Congratulations on the release! Just skimmed through the code and examples, your code style looks splendid. ;)
Let's see if I got this right in a few years... But my bet is that the future of php is HHVM.
I don't know what a "buffer of time" is supposed to mean, if it's not a buffer of money intended for additional costs (man-hours).
Clients have been known to prepare themselves for the unexpected; they know (at least if you have managed them properly) that sometimes projects go long. They will then build some buffer in their own schedules where a later event depends on the project being done on a certain date.
&gt; Except is has no benefits. A design pattern doesn't get to be as popular (across basically *all* languages, by the way) as singleton did without having *some* benefit. In this particular case, the primary benefit is pretty obvious: it enforces a single instance of a class globally, and that's desirable in a lot of situations. Can you use different architectures to achieve the same benefit? You betcha. You can use dependency injection chaining to pass a single instance from your bootstrap through the object graph, for one. Is this *better* than using a singleton? Like most better/best questions in software engineering, the only correct answer is, *it depends*.
"Maybe add more nested conditionals and see if the problem goes away? – Charlie S"
Best of vote. 
I love how people think assigning a variable sanitizes it.
You're right file_get_contents doesn't return a stream, so it should be: file_put_contents('/my/file.flv', fopen('http://example.com/file.flv', 'r')); Thanks for pointing out.
This is awesome! Great work! .... but I gotta say, Mercurial and BitBucket? Damn man. :P
I couldn't agree more. In the end, it really is the programmer's responsibility to hold up his end of the deal. If you take more time than you estimated to complete agreed upon features, that extra time is either negotiated at that point, or on the house with your sincerest apologies.
What is session protection?
&gt; The test code should be able to be described as "too dumb to break". There is, IME, no such code. I’m very much a write and test once and then don’t fucking touch it ever kind of person. I understand the value of repeatable regression testing - especially in a team environment. But 1) I don’t generally work in team environments and 2) when I do, the shifting requirements tend to make tests irrelevant very fast and then you spend a bunch of time trying to decide if a test still makes sense. Just my $0.02
Mercurial...yeah I see your point. But what's wrong with BitBucket? I've never understood that. Unlimited private repos? What's not to like?
The problem here is that the author has no clear idea of what he wants to do before he does it, so he feels that TDD is a bad fit for him. He has no idea of what he wants to do because he's not following the process. This isn't a reflection of TDD, it's a reflection of him. Tests are only part of the TDD process. You have to gather requirements before you can start writing tests. There are many times when I don't know exactly how I'm going to implement something. That's ok, sometimes I'll write code off the cuff in order to prototype the idea to the point where I do understand what I'm doing. The correct thing to do at this point is to remove the untested code you wrote, write your tests, and then write the minimum amount of code required to make the tests pass. This may seem like a redundant action, and it is to some degree. However by doing it this way, I ensure that my coverage is reasonably tight and the code acts exactly the way I expect it to.
This is solid advice. A lot of people underestimate the power of creating visual depictions in order to understand complex structures while writing code.
&gt; my biggest fear is having a green test taht is only green because the mocks are out of date. If you have proper coverage, something is going to fail at some point. if nothing is failing it means your coverage is incomplete and you missed a test. This happens to all of us at some point I think. Getting 100% coverage is not always easy, edge cases can and do show up that maybe you didn't consider. TDD is not fool proof, it's *fool resistant* ;)
Definitely. Write lots of code, get up on github, write a game in your spare time, volunteer for friends. Get some real world experience. I do not have a degree, but I do very well as a PHP developer and have never had any difficulty finding work.
Very interesting.
&gt; I have no idea what you're talking about anymore. Ok. Perhaps "asking questions to determine intent" would have been a more productive avenue than "yelling bullshit" at the start.
Minecraft server admins...
...and those tests should also be backed up by unit tests.
&gt; I have the lowest defect count around too. Bullshit. You're doing it wrong.
I like how he's at least salting his password hashes yet straight up building a sql query with unparameterized post input
&gt;This is awesome! Great work! Thank you! &gt; Mercurial and BitBucket? I love Mercurial. I am a little sad that git has taken over the DVCS world ). 
You mind if I PM you sometime in the near future to pick your brain a bit?
Ah, there's nothing really wrong with it. I just personally like GitHub and it seems to be the spot where most projects are nowadays. No harm. :P
Completely agree. I just said it reminded me if it. Server stats in a Web interface.
Sure :) go right ahead 
Again, I'll point to where I don't necessarily believe it will work for everyone. But it has worked for all the teams I have been involved with. I can only speak to my personal experience :) 
My God... I'd shoot myself if I had to maintain that.
Formchecking, everyone's favorite pastime, amirightguyz? Last time I had to do something similar, I just had everything check and push errors to an array. Empty array? No errors? Array not empty? Output entire array in readable format.
or you could just refactor it :)
I'm not arguing with you, it's more of commiseration that started with what you said [here](http://www.reddit.com/r/PHP/comments/1w1fz6/poc_scalar_typehints_for_php/cezdnth). If I wasn't already juggling too many projects, I'd love to work on something like [TypeScript](http://www.typescriptlang.org/) for PHP. It would be interesting to have a tool that adds static typing to PHP and compiles to regular PHP (and if smartly designed doesn't mess up the line numbers). Maybe something like would help direct future PHP development in the right direction. 
I'm sure, if one considers (*cough*) haiku, that's actually beautiful.
&gt;It is worse that you are demanding the reader to "ask questions to determine intent". When one admits, at the end of a discussion, that one does not understand the other any more, it does seem reasonable to go back to the beginning of the discussion and examine one's premises. For all the agreement I found with /u/Nicoon, he was still unable to understand. That tells me his opening gambit of **BULLSHIT** was ... well, poorly-chosed. &gt; If I were you, I would be thankful for the time /u/Nicoon have spent discussing your post. Oh, I am. It's always nice to see when someone spends (how many hundreds of words?) trying to assign meaning to a comparatively short post, instead of simply asking "What did you mean by X?"
He's not saying it's acceptable, he's saying he's seen it.
It certainly sounds interesting. Put that on the "list of code to write someday" list.