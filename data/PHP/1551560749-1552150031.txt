What about full and proper unicode sopport without needing external libraries?
you're trying to buy followers with a small plush animal?
SRP is, for sure. I find the others all very objective, though.
Not at all. When you overuse DRY, for example, you end up doing the exact opposite of what SRP suggests: you glue together unrelated parts of your code because "parts" seem similar. You end up with excessively parametric and entangled system in attempt to avoid repeating yourself. OCP is so vague, people have no clue if it's intended in its original (and by now completely useless) definition which specifically refers to *extending a class* (i.e. inheritance), or it also includes more preferable techniques like composition and aggregation. Also the distinction between "modification" and "extension" becomes absolutely meaningless if you get several opinions about it from your teammates. ISP is literally "SRP, but for interfaces", which is kind of implied in SRP already. My guess is Uncle Bob thought "SOLD" doesn't sound as cool. DIP is also universally misunderstood. First, half your colleagues will be absolutely clueless about the difference between these and mix them freely in conversations: - Dependency Inversion Principle - Dependency Injection - Inversion of Control - Dependency Injection Container - Inversion of Control Container Those are five absolutely different things. Yet have someone define them for you off the top of their head (good luck with that). Bob defines DIP this way: - High-level modules should not depend on low-level modules. Both should depend on abstractions. - Abstractions should not depend on details. Details should depend on abstractions. So I can summarize this to a single rule actually: - Abstraction is good! Decouple implementations through interfaces! See, that's... way simpler definition, achieves the same affect, but it doesn't sound so pompose as DIP. Also, again, I suppose Bob just needed that "D" there, so. The thing is, just like the subjectivity of SRP is when to stop "separating concerns" before you go mad, at some point you need to stop "abstracting" and you need to rely on specifics. And this line that shouldn't be crossed is absolutely subjective. If we really wanted to remove subjectivity from those principles, they become rather mundane, let me try it for you: - DRY: Deduplicate similar code! But not so much it stops being pragmatic! - SRP: Keep classes simple! But not so simple it stops being pragmatic! - OCP: Keep things configurable! But not so configurable it stops being pragmatic! - LSP: Follow LSP. Just follow it. It's the only clearly defined principle here. - I: Keep interfaces simple! But not so simple it stops being pragmatic! - D: Depend on interfaces! But not so much it stops being pragmatic! Fine, we de-obfuscated those Monumental Rules of Design, and tried to remove the subjective aspects in them. But there are two problems here: - What remains is so dumb and simple, anyone with a basic clue of what a "class" is and what an "interface" is intuitively understands they should *try* for this. They still don't know *how* to achieve it, through. - The line of "pragmatism" remains as subjective and elusive to definition as always. And that'll never change, because pragmatism is found through practice, through trial and error. Not through catchy slogans and dogma. 
This is a small project I have been doing in the previous weeks, is a work in progress and it's widely open to changes. Is a small MVC framework with some extra functionalities. Currently the documentation is completed if you want to know how to use it. Any constructive feedback will be well received as I'm not a pro programmer. Thank you :)
I would spend a lot of time reviewing https://phptherightway.com/ to see how modern PHP applications are designed. It's good that you're doing something to learn, though.
Turn on warnings and notices. They might be your first teacher. And then read OWASP about PHP. I‘m being serious.
Aside from what /u/leftnode said which is definitely valid. You don't "install" a framework, you install a CMS. What your install does should be contained in config/env and not require an install script - unless you're developing this as a CMS. I noticed you also [suppress errors](https://github.com/Usbac/Wolff/blob/master/install/index.php#L14) with @ This is definitely far from usable, given you are starting, I guess it's a start.
&gt;Any constructive feedback I shall try 1) you don't follow PSR. You ought to 2) `public static function` smells of &gt;I'm not a pro programmer you must try to get rid of those statics. They do have their purpose to exist, but not just for making a procedural code look oop (which is what you're doing). 3) you don't use autoloading. This is obvious because of the `1)` . You ought not to use `includes` for loading classes. Instead read about autoloaders. 4) you don't use composer. You should 5) you're `echo`ing strings inside your code. Why? Should I use your framework and should an error occur, it would be just printed to the user? You need to use a logger of some kind. 6) you should use proper argument and return type hinting instead of `@param` You may want to use `declare_strict` also 7) you need to read about Dependency Injection and why we need it. 8) you define several constants in config file and then just magically use them throughout the code. What if you don't include your files in a correct order? Then it just fails. So your classes depend on some magic file you need to include before them. You got it, didn't you? 9) just noticed. You don't use namespaces. You MUST 10) you should not use `count()` inside a for loop. It will call on each iteration and slower the code execution, you should call it before and then use the result. 11) $dir = explode('/', $dir); $function = array_pop($dir); $dir = implode('/', $dir); this is just inefficient. Why not `substr($dir, strrpos($dir, '/') + 1);` 12) `die('Conection failed: ' . $mysqli-&gt;connect_error);` you have exception system for a cause. You really shouldn't use any of die/exit in a production code. 13) you use `@` a few times in your code. Why? It may (and will) lead to a possible debug nightmare. 14) wow `${$key}` . This is just scary tbh. 15) `eval(' ?&gt;' . $content . '&lt;?php ');` :(
Who are you talking about when you say the PHP community? Also, can you provide some example a of the abstracted interfaces?
It's kind of a pain but unlikely to change. I'd rather have more speed improvements.
As others said, strict adherence to these rules may backfire sooner than you expect. They matter more in complex projects, and from my experience most PHP projects are not that complicated. I'd say the two rules that matter for me the most are KISS and writing tests (not necessarily TDD).
This is an extremely useful comment, thank you so much. While I was aware of several points, I didn't know about others. I will try to apply them for the next commits. Again, thanks you!
I think the proper approach to some of these would be to introduce scalar objects (is that the correct term?) with methods. E.g. `$array-&gt;map(...)` and `$string-&gt;substrPos(...)`, etc. This way we can keep loads of compatibility, while introducing a sane approach for new codebases. Of course, I am not intimate with the PHP internals so I can't say how possible this would be in the first place though.
That’s actually helpful, thank you.
Definitely, I believe that'd be the best solution.
Looks like homemade CodeIgniter.
This should have been a link post
Honestly, it doesn't matter. Like you said IDE takes care of it and PHP isnt a low level language so "consistancy" IS keeping it as is. Changing the needle and haystack would be inconsistent with a language that isn't any other language, so to copy their correct usage of needle and haystack would be a slippery slope. Might as well just start over and write PHP in Python instead of a language written before computers were invented. It even starts with the same letter, so why not?
mb\_ functions already offer proper unicode support, I do agree however that the extension still needs to be installed in order to work
Id say psr is definitely needed. Also unit tests
I like the way you did the router, reminds me of the one I rolled myself for a project. https://pastebin.com/7fn8GZWP Then it gets called with: $controller-&gt;$action($params); I'm aware there's a possible exploit in there somewhere, but this was awhile ago and is not in use anymore.
&gt; PHP isnt a low level language Language level has nothing to do with how consistent a language is internally &gt; Changing the needle and haystack would be inconsistent with a language that isn't any other language, so to copy another languages correct usage of needle and haystack would be a slippery slope. I'm nor arguing for the cleanup because I want to make PHP more like language X. I'm arguing for it because any language needs consistency **within itself**. &gt; Might as well just start over and write PHP in Python instead of a language written before computers were invented. It even starts with the same letter, so why not? Cool strawman
Some years ago there was a proposal for this: [https://wiki.php.net/rfc/consistent\_function\_names](https://wiki.php.net/rfc/consistent_function_names) But the author didn't have the time to do it. If you have time to work on the RFC, maybe you can make it work. At least, for me this add little value to the language, there are better things to do :)
Sorry, I was under the impression you had to be subscribed to the list to take part in it. I thought you were already subscribed and couldn't figure out how to send to the email. That was my mistake.
Ya, it's a pretty bs question 
It's probably the same thing as other women focused tech organizations. They are specifically focusing on increasing the interest of women in the PHP ecosystem, since women are fairly underrepresented in CS.
I like your idea OP, I do find these inconsistencies annoying, but it might mean PHP 8 will never be adopted on web hosting services because it literally breaks everything written in PHP. I think they need to do plan this in a really long term fashion, provide an alternative n 8, and display deprecation notices of reworked functions maybe in PHP 9?
Types, strict mode, and more types. 
That's a sweet logo
DRY as a religion is just bad. 
This would be nice, but I seriously doubt it. &amp;#x200B; Off topic; but callbacks are always nice as the last argument ;-)
I admit I haven't looked at PHP code quite yet, but changing some function names around doesn't seem too daunting of a task. Creating aliases might be a whole another manner, though. And getting a PR accepted is yet another issue.
I would agree... Mine isn't SUPER complete. It just wrapped the half/dozen functions I used a lot and I never normalized more beyond that. I appreciate the sentiment though! I do feel like just including some library that normalizes them all would be pretty rad though. the "php isn't designed well" argument is bullshit. It's got some annoying quirks no doubt, but to claim it's poorly designed is asinine and unproductive. Learn your toolset and shut up, lol. If you don't like it, use something else, but for all means, stop whining and bringing ego into this. It's computer code for fucksakes, lol :)
Upvote for this library. This is 100x more complete than anything I'd upload.
It would be the only function in the whole PHP world that works like this. Variadics haven’t been around for a long time here and they shouldn’t be used for syntactic sugar like this (imo). A better solution would be having separate functions to map a single array or multiple arrays. Take a look at array_map and check its return type. It drops keys when you pass multiple arrays and keeps them when you pass a single one. That’s not a good case for variadic arguments, it’s a case of SRP violation and should be split into to separate functions.
Lol go read about something called Angular and Angular 2 and talk to me about consistancy of of non low level languages. PHP does those functions the way it does, changing that would make it not PHP. It's not a strawmnan argument, youre just confused about what you're talking about. It's ok, I still think you're a great person but you should gain some more practical experience first, you must be new to PHP and programming. PHP is a web framework language, of it wants to have needle and haystack not consistant that's how it works. If you're going to chnage the order of core functions, you might as well just use Python, like I said, it would be as easy, if not easier than changing core PHP C functions and not killing the entire language. If every developer is going to have to rewrite ALL of their systems, changing to python would literally be the only reason developers would even consider the idea of changing every client they have. Again, you lack practical experience, one day your bright eyed naive optimism will settle down and you'll start thinking practically. It takes time
Also, like I said, the inconsistency of php IS constant. Changing it now would be inconstant of PHP, 20 years of not changing it IS consistant. Welcome to PHP, I can share some links to tutorials. 
I must say, it's kind of refreshing. I rarely find people as condescending as you. It's a nice change of pace. 20 years of doing things wrong doesn;t make them right. There's no magical threshold of years something incorrect needs to exist to become correct. &gt; Welcome to PHP, I can share some links to tutorials. Thanks, but I got out of the phase of reading tutorials three or so years ago.
Twitter needs a downvote button.
Manageable TDD is impossible without SOLID. DRY is true within boundaries. Now spend 10 min arguing the boundaries. But I would be happy if developers would just name their variables, functions and classes correctly.
First of all, that's a very good result for a few weeks job. But there is a long way to go. There are some essentials that are wanting in this framework. For starter, *it will kill the database server under any real payload*. Simply because every model object will create its own connection to the database instead of sharing a single connection. And the Too many connections error will be inevitable. For your current setup it would be natural to create a [static single instance provider](https://phpdelusions.net/pdo/pdo_wrapper#static_instance). The example shown is for PDO, and I would also strongly recommend it for the database interaction instead of mysqli. Once you refactor your code based on /u/helloworder 's feedback, you will need a Dependency Injection container. It will create your Model objects on the fly, injecting the database connection (and all other required services) as a *constructor parameter*, instead of creating them all afresh in the constructor. Also, like he said, the error reporting is completely flawed. I've got a handy article on [PHP error reporting](https://phpdelusions.net/articles/error_reporting) which will give you some pointers. 
I will start to condense my thoughts on my blog more often and posting them here.
I used to share that opinion 100%. But after almost 15 years of experience I can see a difference between over engineering and proper design. SOLID is a pretty difficult principle and can easily be misinterpreted and/or misused as an argument. Following SOLID (in a proper way) will lead to more maintainability but also to more files. And that last part might give the suspicion of over engineering and “fuzzy architecture”. 
But which version of major Guzzle? 
This comment is actually outrageous. Taking about CI back in the day and calling Laravel full of anti patterns. You can create perfect DI code if you want with Laravel while CodeIgniter back in the day itself was an anti pattern.
Up voting for actually making useful criticisms and how to address them - we need more comments like these and less negativity, especially for beginners like me.
That is my point, its still not integrated. $foobar[4] on Unicode would fair as well, for example
r/titlegore
I just want to say that helloworder's comment is extremely good and valuable. On point 2 you could argue that using static is a form of namespacing here in pure procedural code. On point 7 one could argue that we don't really need that. Nevertheless, all points (including 2 and 7) are very valid considerations.
/u/Usbac, I'd probably add these things as well: 1. Class properties and their visibility modifiers should always be explicit. [This](https://github.com/Usbac/Wolff/blob/c255fc912bf2ea8a7ffbb0b06d3cba08b611bd98/start.php#L9) makes no sense, especially since the property isn't used anywhere else. It might be better to remove it altogether. 2. The casing of class names is really weird (see https://github.com/Usbac/Wolff/blob/c255fc912bf2ea8a7ffbb0b06d3cba08b611bd98/install/controller/install.php#L3). It's not a big issue if you don't use PSR, but you should at least be consistent (this looks like a weird mix or Pascal case and snake case). 3. You shouldn't be using the superglobals such as `$_POST` directly. Pick a third party library such as `symfony/http-foundation` instead. 4. Related to the previous point - don't modify the superglobals like you're doing in https://github.com/Usbac/Wolff/blob/c255fc912bf2ea8a7ffbb0b06d3cba08b611bd98/install/controller/install.php#L71 unless you _absolutely_ have to. 5. Your framework is tightly coupled to MySQL (e.g. https://github.com/Usbac/Wolff/blob/c255fc912bf2ea8a7ffbb0b06d3cba08b611bd98/install/model/install.php#L6). What about people who use PostgreSQL, Sqlite or other RDBMS? 6. Don't use `.html` extension if your files contain PHP code as well - `.php` or `.phtml` should be used instead. Otherwise it's not immediately clear what will those files contain without actually opening them. 7. What's the point of using a form submit button instead of a link like you're doing [here](https://github.com/Usbac/Wolff/blob/c255fc912bf2ea8a7ffbb0b06d3cba08b611bd98/install/view/install.html#L58)? It makes little sense. 8. Your forms should use CSRF protection. 9. Your class names don't match the file name they're in. 10. [This](https://github.com/Usbac/Wolff/blob/c255fc912bf2ea8a7ffbb0b06d3cba08b611bd98/main/controller/home.php#L14) is just bad. The less magic there is, the more maintainable the code is. 11. Your models (which aren't really even models since M in MVC is a layer instead of a class) don't make much sense. See [this](https://github.com/Usbac/Wolff/blob/c255fc912bf2ea8a7ffbb0b06d3cba08b611bd98/main/model/home.php#L5) for an example. 12. Related to the 6th point - don't use non-HTML syntax in HTML files like you're doing [here](https://github.com/Usbac/Wolff/blob/c255fc912bf2ea8a7ffbb0b06d3cba08b611bd98/main/view/404.html#L5). It looks like a templating language is used, but it's impossible to figure out which without seeing the rest of the code. 13. Don't use misleading DocBlocks like [this](https://github.com/Usbac/Wolff/blob/c255fc912bf2ea8a7ffbb0b06d3cba08b611bd98/system/connection.php#L7). It's clear that the return value will always be an instance of `mysqli`, yet you're using `object`. IDEs such as PhpStorm will use the DocBlock information instead of the method content which will disable the intellisense. [An another example](https://github.com/Usbac/Wolff/blob/c255fc912bf2ea8a7ffbb0b06d3cba08b611bd98/system/loader.php#L8) - in this case the return type should be nullable. 14. Don't use DocBlocks as a replacement for declaring the class properties explicitly (see https://github.com/Usbac/Wolff/blob/c255fc912bf2ea8a7ffbb0b06d3cba08b611bd98/system/controller.php#L4). 15. There are inconsistent return types in several places such as [this](https://github.com/Usbac/Wolff/blob/c255fc912bf2ea8a7ffbb0b06d3cba08b611bd98/system/loader.php#L60). Either a method always returns something, or it never does. Nothing in between. 16. DocBlocks don't contain all of the required information. For example, [here](https://github.com/Usbac/Wolff/blob/c255fc912bf2ea8a7ffbb0b06d3cba08b611bd98/system/loader.php#L82) one of the parameters is missing. 17. [This](https://github.com/Usbac/Wolff/blob/c255fc912bf2ea8a7ffbb0b06d3cba08b611bd98/system/loader.php#L127) is just horrible. 18. The most important - no tests. I'm not touching a third party library without a good code coverage with a ten-foot pole.
&gt; dependency Injection container CakePHP is one of the biggest php frameworks and has as well not a di container. You can do di completely without a di container. The container just helps you to do di easier.
I think the idea is for you to analyze their code and spot potential problems. Find a list of “best practice” for security and see which conflict. Find security features from other frameworks like Symfony n Laravel, Cake Look for things like cookie/session encryption, csrf protection, powered by headers, template escaping. I guess it’s a bit tricky if your not aware of a wide variety of potential issues in the first place
For however long you live in this world, do not ever say "don't use static functions". They're extremely useful, beautiful &amp; concise ways to write logic that's...logically tied to a class, without having to go through all of the object hoops. "Oh, but what about testing?". Fuck off, static methods are testable and even if they weren't, if you need to test for them in relation to the object, **you're doing something wrong, they're not supposed to be tied to the object in any concise way, just logically.** Reading SO answers really doesn't do you any good if you don't understand the whys.
I think the only problem is that PSR 7 is designed "immutable". There were many concerns raised during the voting face but they were mostly ignored. Providing no upgrade path for existing frameworks means no adoption. Also it is only partial immutable since you can always change the body. So I think basically PSR-7 has failed on the server side. Maybe Symfony will create also a set of HTTP server request/response interfaces which could fill this role.
Steer away from the suggestions for AJAX - don’t follow these suggestions if you need anything to scale. Imagine 500 users, with 2 tabs open, an Ajax call firing every 5 seconds for an update. You’ll end up DOSing your own server. The modern recommended approach would be to use Websockets. On the page the user connects to a web socket (pusher is free for certain use cases) Then when there is a change in your backend it broadcasts an event to your web socket server. The websocket server will then push a notification in real time to your front end JavaScript which you can then use to either Ajax in your update to display to the page. The reason for doing it this way would mainly be that the users are not hammering your server for changes when nothing’s happened. Source: personal experience with large traffic apps with lots of real time feedback
You also need to hate yourself to use Magento, it was designed as a catalyst for goths and emos to push them into darker depths of their mind causing torment and distress daily. An anagram of magento is “soul killer” — On the plus side, BigCommerce has a real nice simple theming system if you need pure medium sized commerce :)
No. All the C devs would feel at a loss in this new version of friendlier Perl. (Seriously look it up ;) ) &amp;#x200B; At best we can hope for unified names in separate standard lib.
You can’t make the same thing in the same amount of time :)
More files =&gt; more folders. **Fixed like in 50's** *However there is real cost to applying DRY to such a code, and if significant but "auxiliary" concerns are misplaced (think nested loops inside functions whose name do not suggest that multiple things do happen) then the refactoring is costly. But can be done by just undoing the split into file and inlining till the code have good sized chunks.*
Include + no functions. Alternatively include + single class + single method. &amp;#x200B; But it pays well to rewrite...
DIP warning: Java crowd uses interfaces to shave off compilation and recompilation times!!! What is acceptable cost to them, may not be to us PHPers who do not (yet) have such strong couplings between files. &amp;#x200B;
Poeple still use Cake PHP? 🤔
Nope 😎 e.g you can have Models in client side JavaScript. No database there!
What else? &amp;#x200B; Laravel has the worst OOP and uses a lot of Anti Patterns. But hey a lof of self taught wordpress php devs like it because it's easy and get's the job done fast. &amp;#x200B; Somfony best OOP structure and design patterns but very verbose and complicated. I like it but not all people. &amp;#x200B; CakePHP is between Laravel and Symfony. A nice merge out of both worlds.
This is actually full of crap. The Laravel features that people consider anti patterns are entirely optional and you could build using the same anti patterns in Symfony if you want. I like and use both frameworks, but it's completely doable to write a well structured Laravel application.
&gt; When you overuse DRY, for example, you end up doing the exact opposite of what SRP suggests: you glue together unrelated parts of your code because "parts" seem similar. You end up with excessively parametric, complicated and entangled system in attempt to avoid repeating yourself. The cure becomes worse than the disease. Trying to DRY up code by gluing together unrelated parts is a sign that you don't understand the code, requirements, vision, and/or goals of the business/project well enough to make the call; not that application of DRY itself is subjective. If you know the business/project well enough, DRY is completely objective. The relevant parts of your code that you're considering consolidating either have reasons to change independently in incompatible ways, or they do not. If they do, then no matter how similar those parts appear to be superficially, they are not candidates for DRYing. Where developers get themselves into trouble and end up making an "excessively parametric, complicated and entangled system" is when they routinely step around this consideration, and focus instead on the superficial similarity of the code, which you absolutely cannot do when applying DRY. &gt; OCP is so vague, people have no clue if it's intended in its original (and by now completely useless) definition which specifically refers to extending a class (i.e. inheritance), or it also includes more preferable techniques like composition and aggregation. Also the distinction between "modification" and "extension" becomes absolutely meaningless if you get several opinions about it from your teammates. The original had hyper-specific problems in mind to solve, but OOP has evolved over the decades, and this is one of those cases where someone stumbled upon a good idea long before they knew how generally applicable it could be. So, while I agree that its textbook definition has changed over time and that causes a lot of confusion, the current, more general concept makes it very difficult for you and your teammates to arrive at differing opinions on whether a given module adheres. Such disagreements are usually a result of someone trying to apply the more rigid and granular earlier concept, but this is more about "what actually is the principle?" and not "how should it be applied?". Once you know that it's a general principle that can be applied to more than one specific language construct or paradigm, its application is very objective. Luckily, OCP is, in my experience, the principle that developers are most likely to adhere to without realizing they're doing so, which means that discussions about it basically never happen in practice. &gt; ISP is literally "SRP, but for interfaces", which is kind of implied in SRP already. My guess is Uncle Bob thought "SOLD" doesn't sound as cool. I can see why you would say that, but I find ISP to be more a good bit more objective than SRP. Whereas there is almost an infinite number of definitions of what "responsibility" should entail for SRP, division of interfaces is much less open to interpretation thanks to the nature of dependency. If you let dependency drive your interface design, rather than the other way around, interface division almost becomes a side effect. Given the same code with the same dependencies, developers will almost always split their interfaces in the same ways. Problems with ISP can basically be summed up as a sort of "premature optimization" - where you're trying to predict what dependencies will be needed before they're actually needed, and divide interfaces before they're depended on. That leads to disagreements with other developers who may predict things, and thus, divide the interfaces, differently than you do. &gt; DIP is also universally misunderstood. First, half your colleagues will be absolutely clueless about the difference between these and mix them freely in conversations: Ignorance of what the principles/concepts actually _are_ may lead to differences in applying them, but that's not subjectivity. I completely agree that all of these concepts are one of the most poorly understood things in modern software engineering, but if you understand them and their differences, applying them is pretty objective. &gt; The thing is, just like the subjectivity of SRP is when to stop "separating concerns" before you go mad, at some point you need to stop "abstracting" and you need to rely on specifics. And this line that shouldn't be crossed is absolutely subjective. "When to stop" is not subjective at all with SRP - single means one, and that's as concrete as can be. Rather, the subjectivity in SRP comes down to the impossible task of agreeing on what a "responsibility" entails in the first place. You should only abstract the things that you need to abstract. Abstraction for abstraction's sake is a non-starter. In that sense, "when to stop" is highly objective: if you need more abstraction, you haven't gone far enough yet. You may think determining that need itself is subjective, but as with interface division, you can let dependency guide you instead of trying to predict it before it's needed. &gt; If we really wanted to remove subjectivity from those principles, they become rather mundane, let me try it for you: You didn't remove subjectivity from them; you _added_ it to them. Those overly simplified principles are even more open to interpretation than the originals.
I don't think you you can really say if something has bad OOP. OOP as far as I know is simply using object oriented programming, I don't think that entails use of PSR or needing it to be high quality. OOP is OOP. Generally you have OOP or procedural. Anti patterns... Ok. Laraval IS the largest framework going, and thousands of people would disagree with you. You would rather have complexity than ease of use? I get paid to build stuff, I'm not going out of my way to use Symfony, which is way more "complex". Getting the job done fast while still well built gets me more money, keeps the boss happy and keeps the client happy. Also to note a business first priority is money. Not taking your sweet time to meet your stupidly high expectations. 
&gt;Also to note a business first priority is money. I am out here. We build software at the best possible standard. Money is not relevant. The code needs to be maintainable and 100% correct. &amp;#x200B; Here some useful links: \- [https://www.reddit.com/r/PHP/comments/3bmclk/why\_experienced\_developers\_consider\_laravel\_as\_a/](https://www.reddit.com/r/PHP/comments/3bmclk/why_experienced_developers_consider_laravel_as_a/) \- [https://www.reddit.com/r/PHP/comments/96bid5/why\_do\_i\_see\_alot\_of\_you\_guys\_use\_symfony\_over/](https://www.reddit.com/r/PHP/comments/96bid5/why_do_i_see_alot_of_you_guys_use_symfony_over/)
Read: &amp;#x200B; \- [https://www.reddit.com/r/PHP/comments/3bmclk/why\_experienced\_developers\_consider\_laravel\_as\_a/](https://www.reddit.com/r/PHP/comments/3bmclk/why_experienced_developers_consider_laravel_as_a/) \- [https://www.reddit.com/r/PHP/comments/96bid5/why\_do\_i\_see\_alot\_of\_you\_guys\_use\_symfony\_ov](https://www.reddit.com/r/PHP/comments/96bid5/why_do_i_see_alot_of_you_guys_use_symfony_ov)
I should have mentioned I'm in an agency. But still. Business main priority is money. 
Have you tried Symfony 4 with flex and maker? You can get jobs done VERY fast.
[Imagine finding s post in your history that claims in a perfect world you would indeed use Laravel](https://www.reddit.com/r/webdev/comments/9jlz22/if_you_need_to_build_a_website_with_an_individual/) Funny how you argue against it now though. 
Almost all of the documentation for Laravel uses Facades in the documentation examples. This is not necessarily bad, but it's definitely not object oriented (class oriented != object oriented). Does this make it anti-pattern? In the "regurgitated lingo" use of the term, yes, Laravel is anti-pattern. In a practical use of the term, no, it's not. Phalcon, Symfony and Zend are the only popular PHP frameworks at the moment that use a true OO pattern by default. This doesn't mean they're better - in fact I think PHP's most productive when it's written in a hybrid form of object oriented models (for encaspulation) and procedural view models.
I just told you I like and use both frameworks and you supply me with these random links with opinions. This is fine. Having a preference is fine too. Just echoing random Reddit opinions is not helping discussion here. What I will agree with, though, is that you need more discipline to write well-structured code for larger applications with Laravel. However, I think lots of applications will never reach this stage. For a lot of less demanding developers it's fine to use facades, helper functions and Eloquent. When you say Laravel 'uses' these 'anti-patterns' (and imply you are forced to use them) you are simply wrong.
It's still wrong, simply because it's in the documentation doesn't mean you are forced to use it. If there's a perfectly clear example to use DI with the container in a very flexible way, doesn't that negate your entire point? Laravel is not an anti pattern, but the developer can use anti patterns with it.
I used the term Laravel because it's famous and has the biggest marketshare. Just an easy way to address this question to a lot of ppl. It's just easier to say Laravel then the ppl. just know of what are you talking about. As well I mentioned CakePHP just saying. &amp;#x200B; \&gt; argue against it now &amp;#x200B; We used Laravel for three years. Now we know better that Symfony is way more advanced.
&gt;random links with opinions. You can't call it opinions if they point out facts. How is this an opinion: "The Model class is an absolute god object. [252 methods](https://laravel.com/api/5.6/Illuminate/Database/Eloquent/Model.html) in a class may be a new world record." &gt;When you say Laravel 'uses' these 'anti-patterns' (and imply you are forced to use them) you are simply wrong. I like to have a framework where I can use all parts of from. If some things are flawed like "facades, helper functions and Eloquent" then these things should not be in the framework.
My reply wasn't in disagreement. I'm simply stating that the term "anti-pattern" is subjective. Purists usually accuse Laravel of either being anti-pattern or encouraging an anti-pattern workflow. These purists are 100% correct if you define anti-pattern as anything that isn't strictly object oriented. But in a practical sense of the term, I don't think Laravel is anti-pattern.
Your entire post is focused on preemptively justifying SOLID as perfect, by listing imaginary failings of those who implement it without success. This honestly only makes my point that these rules are highly subjective. If they weren't subjective, there'd be a set of objective rules to follow, which you can qualify, instead of writing a little book shifting blame to just about everyone and everything, but the sacred buzzwords. 
Is that really a security issue with the CI3 framework or the way a programmer writes the code?
OP is just trying to troll the CI3 framework!
From the start, I noticed a few things. Classes should always be “StudlyCaps” and all methods are “camelCase” never written with underscores in either. Index.php is located in root. Which means you’d give access to the entire world all of your framework files. That could be lead to security issues and possible leaks if you create storage items, like caching, user uploads etc. Should have public resources located in a “public” directory. Due to the lack of composer, you’ll have an incredibly difficult time trying to get anyone using this. Your framework will no longer get easy updates when you patch it. And installing 3rd party packages will need to be “rigged” in. You’ve not used namespaces within your files either, I love small frameworks, I’ve built a few in the past myself. So I do understand the fun it is to have that control. But it’s far from being a modern solution, due to the few things above, it’s already out dated. 
The framework itself is so light, minimal and time-tested that there is hardly any chance of finding any current vulnerability (CodeIgniter is the Flask or Sinatra of the PHP world). The security issues like XSS and SQL Injection result due to programmers writing bad code and CI3 not doing anything inherently to prevent them from that. In fact, you are just as likely to fall for XSS/SQL in pure PHP as in CI3!
I like to have a framework that gives me the tools to create good applications. I don't care if I choose to not use something because that thing has a different use case if it doesn't limit me in creating said applications. Facades, helper functions and Eloquent aren't flawed, they are intended to be used in a certain way. And that is: quick prototyping, building functional applications quickly. They are all fine for that. When I use the framework for an application that won't be like that I don't use those features. Anyway, use Symfony if you don't like these features, I often do as well. Symfony and Laravel are way more similar than people often think while Laravel provides more features to lure in novice developers and people that prototype a lot. 
The Symfony documentation uses the service locator pattern in multiple places as well. Instead of Laravel's facades, they pass the entire container into a object and then pull dependencies out of it. So no, there's not really a difference there.
&gt;If some things are flawed like "facades, helper functions and Eloquent" then these things should not be in the framework. Symfony's documentation uses the service locator pattern in multiple places (passing the whole container to an object, and having the object pull it's dependencies out of it), which suffers from the exact same problems as facades. Whether or not these things are flawed depends entirely on what you're using them for and how your using them. For the many simple CRUD systems that the average PHP developers build, Laravel's facades probably won't present any actual problems in the real world. I work with a large number of Laravel and Symfony projects and my code guidelines require developers not to use facades or directly access the DI container in either, as we have some enormous, data-heavy systems that would suffer from them. But conversely, there are many projects where they wouldn't really present any problems, we simply don't use them for consistency.
Where? Github-Link or Doc-Link?
I disagree with #9 (namespaces). Even though it goes against PSR and triggers purists, to this day I still prefer pseudo-namespaces via class name prefixes in PHP. They essentially accomplish the same thing of preventing naming conflicts and encapsulating components, while still allowing you to use shorter class names via aliases. I know it's an unpopular opinion but whatever.
&gt; I am out here. We build software at the best possible standard. Money is not relevant. The code needs to be maintainable and 100% correct. All well and good if you're financially secure. I quite like to keep my job, so I stick to deadlines and compromise standards a bit.
I haven't even heard of CakePHP as a consultant for a very very long time - and even when I did hear about it being used - it was very rare.
If you need "standard" caching, go for PSR-16 (this should be the default "go to" in my opinion). If your library has advanced caching needs (like being able to react on an expired item), go for PSR-6.
yeah, somehow some or a lot of developers affected by the criticisms of PHP 4. Ruby and python didn't face the same thing. 
"TDD is like Santa for adult" . Everyone talk about but no one really follow this approach. I would be happy if people just increase test coverage :D
/r/PHPhelp When you go there make sure to be specific about where you are stuck because right now this reads like asking someone to do your homework for you.
&gt; Your entire post is focused on listing imaginary failings of those who implement SOLID without great success. They are very much _real_ failings of developers who don't understand the principles. Ignorance of how to adhere to SOLID is not the same thing as objectivity in applying them once you understand them. You can't hand-wave away this difference. &gt; Precisely this confirms how subjective these rules are. If they weren't subjective, there'd be a set of objective rules to follow, like an algorithm, and it'll lead to consistent results, regardless of the supposed character flaws of the developers. I'd say this applies to LSP. It's a basic rule of subtyping. You can objectively say someone follows it or they fucked up. No full world-encompassing knowledge of all the vision and requirements is needed for LSP. You'd be shocked at how many developers who claim to understand LSP fail at actually adhering to it properly. That aside, there is very much a set of objective rules to follow for these other principles. Take ISP, for example: 1) Create A, which depends on B 2) Create X, which depends on Y 3) Create implementation M which is a composition of B + Y 4) Realize that A does not depend on Y, nor X on B 5) Create interfaces I(B) and I(Y) to satisfy B and Y, respectively 6) Split implementation M at exactly the I(B)/I(Y) boundary into new implementations M(B) and M(Y) &gt; Instead of such objective rules to follow for the rest of those principles, you wrote a little book shifting blame to just about everyone and everything, just to protect the sacred buzzwords. You seem suddenly and irrationally angry that your opinions have been challenged, and that's not a very appealing trait... &gt; The idea that at any point anyone working on a business or a project has full understanding of the vision, requirements etc. is absolutely misguided. Those things evolve due to internal and external feedback all the time. I never said that it was required to have all-encompassing knowledge. When considering DRYing up some code, schema, etc. you only need adequate knowledge of the relevant portions of what you're about to change at the time you're changing it. In other words, you can't go trying to DRY things you don't fully understand just because the literal syntax appears to be the same or similar. Whether or not it changes in the future and you need to un-DRY it as a result of shifting business/project requirements is completely irrelevant to the application of the principle in the first place.
This should be one of the simpler things to do even if you're learning. Start by cutting it up into smaller pieces that need to be done. A system is just a bunch of interoperating parts. What parts do you need? None of the parts needed for this project are very difficult. It's just hard wrapping your head around the entire system at once. There are many a tutorials online, like this https://www.youtube.com/watch?v=5DifzPbAhMU it's old and dated by now, so a lot of the code is deprecated or no longer good / best practice, but watching a tutorial or two before starting a project will give you more ideas on how to proceed.
&gt;passing the whole container to an object, and having the object pull it's dependencies out of it Do you have a link for me? Can't find this practice in the docs or on github.
6.\*, they are currently working on 7.\* which will require php &gt;= 7.1
&gt; Create A, which depends on B &gt; Create X, which depends on Y &gt; Create implementation M which is a composition of B + Y &gt; Realize that A does not depend on Y, nor X on B &gt; Create interfaces I(B) and I(Y) to satisfy B and Y, respectively &gt; Split implementation M at exactly the I(B)/I(Y) boundary into new implementations M(B) and M(Y) ISP is about splitting interfaces, not about splitting implementation, thus once again confirming that while everyone praises SOLID, barely anyone understands it. Furthermore in your example M appears artificially and for no reason. Why would M implement two interfaces *for no reason*. And if it was *for that reason*, then you can't split it in two without *addressing that reason*. Therefore we're back to square 1 here. &gt; You seem suddenly and irrationally angry Not angry :) &gt; When considering DRYing up some code, schema, etc. you only need adequate knowledge of the relevant portions of what you're about to change at the time you're changing it. "Adequate knowledge of the relevant portions of what you're about to change at the time you're changing it" is an extremely fuzzy requirement that can't be baked into a universal principle of software design. By that same measure we could just replace DRY and SOLID with "you must know what you're doing and write reasonable code, I mean, come on."
Given that Codeignighter was a stepping stone in a world where HTML and PHP were mixed like cookie batter. It was a step in the right direction. Patterns were just being introducted to PHP devs.
Try ejabberd. It power, mature and can easy installed on own servers and configured. This have allot clients on desktop, mobile (pidgin for example) and servers packages (composer, npm, github ...) 
¿porque no los dos?
I recommend to learn more tutorials, examples, demos Useful resources for this: * https://en.wikipedia.org/wiki/Design_Patterns (see examples for php) * https://en.wikipedia.org/wiki/Abstract_factory_pattern#PHP_example * https://www.dofactory.com/net/design-patterns (can be adapted to PHP) * http://rosettacode.org/wiki/PHP 
Some PHP related resources: [https://odan.github.io/learn-php/](https://odan.github.io/learn-php/)
This is was very useful for me. After learning these principles, it resolve most my programming problems by using DI, IoC. Also I want to add YAGNI to learn - it's help to keep the resources.
Go for Symfony.
That doesn't mean that CodeIgniter wasn't just a giant headache and that you can build well-made applications with Laravel.
mmm a bit of both.
I’m of the opinion that the general rule should be “Don’t use static functions _with side effects_”. Static functions that take a set of input and just produce a single output are fine — say for constructing, validating, formatting, etc. Once a static function starts manipulating things outside it’s own context (e.g. calls to database)— you are begging for trouble. 
Getting involved with some projects is probably a good bet, but just because it's on github, doesn't mean they have good practices either. I think one of the most important things to becoming a better PHP programmer, but really a better programmer in all, is to study language-agnostic patterns. PHP has become very object oriented, so studying concepts (SOLID, DDD) and design patterns that apply to OOP is useful. You'll find a lot of overlap between Java, C#, and PHP. &amp;#x200B; Don't just study though, study, then try to apply those concepts. But jumping into a large project that employs a lot of these patterns may prove to be difficult if you don't have a basic understanding of the pattern or motivation behind the pattern.
Sure you can make apps with it, and many people do, but when the core is purposefully filled with stuff like SRP violations in the name of being easy, it's hard for me to want to use it personally when I want to make sure I follow SOLID principals and use patterns properly (and correctly named). That way the core is easy to understand and maintain and the useage doesn't sacrafice things in name of "convenience". 
This and people not including a simple way to autoload their libraries without Composer are the things that really tick me off...
Not in Symfony4. The only service-locators now is for controller with most used services like Twig and forms. 
my biggest question would be, how do you find a function you are looking for, especially if its backend in lagacy code with no documentation or code comments. Like e.g. there some backend fnc that moves files and someone wants a condition added to it. How would you find it? like all the files and paths are parametrised, all ftp users are parametrised. And parameter/class functon names are used unconsitent or interchangable with other stuff. Plus there are a lot of functions accessing and doing stuff with FTP credentials or within the file paths of that file which is getting moved.
http://on.geeklearn.net/336ec91b9b 
/u/zmitic correctly pointed out that these have mostly been removed as of the Symfony 4 docs and services on new application default to private since 3.4. I haven't had a thorough read-through of the Symfony 4 docs so hadn't noticed the change, my mistake.
Thank you for the correction, you're quite right I hadn't read through the docs in their entirety in a while and the Symfony systems I work with tend to be behemoths still on Symfony 3. I've ammended [above](https://www.reddit.com/r/PHP/comments/awn0mn/wolff_my_own_framework_looking_for_feedback/ehphh2p/).
A surprising way to get much better at PHP, is to study another language. Nearly all professional PHP devs are also at least a javascript dev. You don't need to get amazing at another language, but even writing some simple beginner apps in C# or Java would help you start seeing the overlap. Really the way to level up is to become a better developer, not just an expert in PHP.
This. It's not the language you write in, but your ability to construct thoughts and put them down into code.
I’d recommend either 1) Learning another language, preferably a compiled one, so you can understand the sacrifices PHP makes and why. Or 2) Write a small MVC or ORM framework from scratch so you’ll understand why the larger frameworks work the way they do. Use [Psalm](https://psalm.dev) on its strictest setting to mimic the experience of writing strictly-typed code. Also stay away from frameworks that use a lot of magic (e.g. Laravel and WordPress) until you understand that magic.
Thanks a lot. I find JavaScript frustrating, but have done a bit of Ruby and found it to be a nice language.
First time I've seen Psalm. That's great! 
[https://github.com/RobCod/Stoyez-Chat-PHP](https://github.com/RobCod/Stoyez-Chat-PHP)
Captain Obvious confirms.
Written in Go. Hm. Are we offended now?
lmao you moderate /r/EvilsOfIslam/ which is bad, like your code
Nice work! Can you tell us what license your code is released under I didn't see any mention on the GitHub web site.
license??? I'm new to this I have no idea lol
So is this like PHPStan but in Go?
https://choosealicense.com
Thanks, The chat is : use it, modify it as you wish I don't care, as long as you don't take credit for making the base code the chat works on I couldn't care less.
lol what?
This is pretty cool
wanna give some advice rather than saying some random stuff that I don't even know about.
Why are all the frameworks posted here clearly inspired by a ten year old version of codeigniter? No wonder PHP has a terrible name
I checked very quickly what you have done. Nice code. But I noticed you wrote on view.php, many time the function mysqli_connect, you can call it once for the page or even better create a page db.class.php and you create the connection for the dB only once. 
Holy shit... Please tell me you haven't got this hosted anywhere
Fantastic artwork! How did you make it?
oh thanks, I'll make that change!
Nope, I'm just working on it and adding features as I go and fixing any issues, can you make a suggestion for the bad code so I can fix it?
Big ones are XSS and SQL injections. With your current code anyone can execute JavaScript on other users' machines, and can run any SQL statement they want.
This is why understanding your layers is important. Utility functions for me rarely appear in the business logic layer of my code, so "code duplication" or "same syntax" is really the implementation details of the business rule. My task is a business process or business rules. By DRYing it up, I can ensure that my business rule is applied the same way to any data/information it needs to. Separate your WHAT functions from your HOW functions. OverDRYing happens when you mix the two because like you said, they're thinking code/syntax duplication (because this should be a duh moment for them... it's the same language, but they're not accomplishing the same thing, of course it's going to use the same code syntax), not information, or the purpose of the code. 
Honestly, the only reason I made this is to push my limited knowledge of php, and to restrict myself to php and html only without adding any additional scripts. I want to learn more PHP and I thought this was a good way of learning.
I thought I added a string to all inputs, how do I fix that?
JS is a good one to practice up thinking asynchronously, or in event-driven architectures. As a direct example, a lot of PHP devs do work on WordPress (though seldom their first choice), which is an event driven architecture itself (the hooks - actions and filters). You probably won't work with it closely enough as a pure PHP dev to develop much skill in EDAs, but you'll quickly become an expert with them as a JS dev, then be able to use them to their full effect. Really helps a lot to understand if you want to write themes and plugins, which is still a pretty lucrative space. Lots of clients out there who'll pay top dollar for someone who can integrate some new features into their existing WP. JS is also good just so you know what things you shouldn't bother with doing server-side. Plenty of features that take way more work to write, are less reliable, and cost more to host than a few lines on the js side. rb is good for learning how to apply the single-responsibility principle to class methods. Sloppy PHP often has excessive, run-on method definitions (100+ lines), while lots of ruby practice will have you writing methods that do one thing, and are clearly written. It's also good for understanding the relationships between classes in OOP. Another language you're probably using already is SQL. Many devs avoid it like the plague and let the ORM manage every part of it, and while that's often a good idea, it's helpful to know some SQL if you need some complex query, a migration script, or to fix a performance bottleneck. I've mentored a lot of devs, and interestingly practicing SQL is a great way to learn how to write good templates. Good templating is really about strong *declarative* programming skills, which SQL really drives home. I notice sloppily written PHP templates right away, because they're heavily imperative: do these things, then this, if, if, if, all the way down. Impossible to point to one point in the code and figure out how you got there. Good declarative code will have you thinking "what do these things look like?", which is perfect for writing good templates.
How many years has it been since the last major version bump?
Use prepared statements
Do you mean `htmlspecialchars();`??
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
&gt; Study PHP the right way PHP is such a hodge-podge of code, it's pretty much a joke. &amp;#x200B; I am going to start a revolution where instead of PHP 8, they go for PHPx. &amp;#x200B; A rewrite of the language to have consistency between functions, such as: strpos ( string $haystack , mixed $needle ) in_array ( mixed $needle , array $haystack ) Do you look for a needle in a haystack, or look in a haystack for a needle?
1) Work on and launch a production application relating to something you enjoy, book-club with users, D&amp;D character management, anything. You'll find yourself refactoring and debugging your own code after a while. 2) Practice test driven development and work on testing in a major way with full test coverage. Phpunit is nice for this. You didn't mention testing - it's absolutely key. Production app with feature launches will help with this - regression testing, unit, feature, etc. 3) Study algorithms, data structures, and mathematics. If you're self taught, you likely missed the opportunity to really dive into programming and engineering. You'll want to make a focus on algorithm complexity and how to make efficient algorithms. These are advanced topics, but will help immensely. 4) Don't sell yourself short. :) Sounds like you've got a better understanding than most Juniors we hire. 
Good luck with that. They won’t do it, they had their chance a long time ago. 
What taught me to be a better Php programmer, and a better programmer for everything else: Elisp Clojure (also lisp) Haskell Ruby C Next up on the list: Forth Erlang OCaml (through ReasonML, more specifically) Shenlang More Prolog If anyone has some very novel programming languages to add to the list ( I once heard of an ...array based language? But I have not followed up on it) please let me know
PSR-6 has the nice ability of being able to "commit" the changes, so if for whatever reason that's useful for you, choose 6 instead of 16. In my case that was a nice thing to have, so I chose 6. There are wrapping libraries though, which act as bridges between the two. Symfony Cache actually handles both standards without problems.
Not the same interfaces
Make sense, Thanks
Don't repeat others. There are very mature Projects like roundcube for mailing that solve your problem. Maybe a chatting solution like Jabber with converse.js could be enough. Integrate a 3d party software for that problem and focus on the main features. Implementing a trivial feature like messaging sounds very easy but it will be a technical debt for you and suddenly you're spending a lot of hours on bugfixing, maintaining, developing &amp; documenting a messaging system 
I use VSCode as my editor. That's what I was using before I began learning PHP so I've stuck with it and I've read that many PHP Developers use it including Jeffrey Way of laracasts. However, there are some weird quirks I'm noticing now. If I tab it will sometimes tab 4 spaces even though I have it 
Beautiful logo! Who made it?
Mix of tabs and spaces in same file?
I'm glad to announce that almost all the points made by u/helloworder, u/AfterNite and u/HauntedMidget have been applied to Wolff and are now in the repo. The other remaining points that the others have made clear here will be applied in the next commit. Thanks to everyone! :)
Thanks! I made it with Adobe Illustrator using mainly circumferences and gradients :)
Thank you! :) I made it myself with Illustrator, I'm a graphics designer in my free time.
&gt; ISP is strictly about splitting interfaces, not about splitting implementations, thus once again confirming that while everyone praises SOLID, barely anyone understands it. If you don't understand the example, I'm more than willing to elaborate. All you need to do is say that it wasn't clear enough. There's no need for petulant condescension (and uninformed conclusions). As I mentioned in my previous reply, when creating interfaces, you need to let the dependencies drive the design. Creating the interface first without knowing up-front what the code that's going to be using it actually depends on is a good way to end up with god classes and worthlessly large interfaces. In my example, A and X are the modules that depends on things, and this is why they come first. Since they come first, now you know what your use-cases are and what the dependencies need to do (B and Y), so you can get to work. For further clarity's sake, let's say B is geocoding functionality and Y is reverse geocoding functionality, meaning A needs to geocode things and X needs to reverse geocode things. A naive developer might know that most 3rd-party location services offer both of these functionalities, and since they are related, may consider housing them under the same umbrella (M - an implementation, because designing interface-first is a good way to ensure you need to refactor the interface after your first implementation turns up things you inevitably didn't consider). Thus, they end up creating something like `GoogleGeocodingThing` (or worse - something like `GoogleApi` or `Google`, but I digress), which wraps the Google geocoding and reverse geocoding APIs in one class. It's at this point where one of two things happens: 1. You realize the problem and continue on the path to correct it (as I noted previously) by splitting this up into separate classes - M(B) (`GoogleGeocoder`) and M(Y) (`GoogleReverseGeocoder`), for which you create separate interfaces I(B) (`Geocoder`) and I(Y) (`ReverseGeocoder`) and make the relevant updates to A and X to depend on these separate interfaces. Good on you. This is ISP adherence. 2. You _don't_ realize the problem and create a single interface (`GeocodingThing`) for your `GoogleGeocodingThing` covering both geocoding and reverse geocoding functionalities. Shame on you. This is ISP violation. Geocoding and reverse geocoding are two totally different (but related) processes, and your modules A and X that both very clearly depended on one, but not the other of the two functionalities are now forced to depend on _both_ via your `GeocodingThing` interface. &gt; Furthermore in your example M appears artificially and for no reason. Why would M implement two interfaces for no reason. And if it was for some reason, then you can't split it in two without addressing that reason. Therefore we're back to square 1 here. M (`GoogleGeocodingThing`) does not implement two interfaces. In this particular example, `GoogleGeocodingThing implements Geocoder, ReverseGeocoder` would be (in my opinion) a pretty clear-cut SRP violation, even though it would _not_ be an ISP violation. The better approach would be splitting `GoogleGeocodingThing` at the `Geocoder`/`ReverseGeocoder` boundary into two implementations instead. &gt; "Adequate knowledge of the relevant portions of what you're about to change at the time you're changing it" is an extremely fuzzy requirement that can't be baked into a universal principle of software design. I don't find it fuzzy at all. The knowledge itself will, of course, vary from situation to situation, but the concept of "having adequate knowledge" does not. Knowledge is the _prerequisite_ here, not part of the principle. &gt; Conversely LSP is very simple: a subtype should be able to stand for its supertype without additional logic at the object user's code. "Adequate knowledge" here only assumes going to the superclass / interface and seeing how it's supposed to behave, then relying just on that when requesting that type. Correct; LSP doesn't require prerequisite knowledge about the code in question. It's one of the (very) few design principles we can say that about. &gt; And BTW because of LSP, your ISP example is incorrect, because of course you can pass M, no matter it implements additional methods. A and X can't see or use those methods because they should abide by LSP. The example was correct, but I'll chalk this comment up to the earlier confusion, which I've hopefully now cleared up. Just for posterity's sake - code can absolutely be compliant with LSP while simultaneously violating ISP, and this happens quite frequently in the wild (e.g. #2 from my above geocoding example).
Message me and we can work on something together, but you should remain dedicated to it and not flake like 9/10 developers.
How long have you been learning and working on this stuff?
Rust.
I just uploaded a V1.0 where I fixed the XSS security issue with the help of ntzm, I also restricted what characters users can use for their username and passwords. I also cleaned up my mysqli connect lines of code that dmn54 suggested.
Love it :) How can I hire you?
I started programming in 2004 if that's what you're asking. I started branching in every language and technique I could find much later, in 2014. If you're asking because that part seems strange, don't worry, it felt like that to me for a long time, until I finally started trying to learn other things in .. er, well, 2014, and realized that the biggest humps are in the beginning. In a way, programming can be a very logarithmic process, where the first programming language takes years, the second months, the third weeks, etc (minus the nuance of every language and ecosystem that will, naturally, take a life time). If that's not why you're asking, n-nevermind
I'm not sure if I understand the question, but code organization and documentation is really the only key here. There's no set way to organize, but having an understanding of the application design, like MVC and how the dependency injection is handled, would certainly help. If the application is an MVC design and it's not obvious where the FTP logic is encapsulated, I think the only thing you can do is work outside-in from the request. You should have the request URI, so you can look at which controller/method that route is handled by. From there, you should be able to find how the FTP actions are performed. Since files could be managed in various different contexts, I'd expect in a well designed application that the controller would be using an interface, so you'd have to look deeper into the implementations of that interface and also decide if the condition is something that should be handled by the interface, or handled by the implementation (something FTP specific).
It's a very simple case, just caching a cli result ([example](https://github.com/soluble-io/soluble-mediatools/blob/1420734d43b8ed20d2bed28e9580cc08cb399933/src/Video/VideoInfoReader.php#L50)). Supporting one standard or the other does not make a big difference. Just thinking about what is generally used or available in frameworks, I'll have a look to the bridge. Thanks &amp;#x200B;
Any reason to pick Psalm over phpstan in your experience?
If you keep working on this , you’ll eventually want to separate your model and view code into separate files (PHP and HTML in your case). A first step in that direction would be to move all your PHP code up to the top of each file, and then the HTML portion at the bottom would only utilize specific variables, not build its own data inline. For example, your admin.php file has PHP querying your database within the HTML. Instead, run all your queries at the top, store the needed results prepped in an array, then your view code (HTML) only has to perform a simple loop. Then, when you realize it would be better to split the logic from the view entirely, or you decide you want to use Twig or some other template engine besides straight PHP, it will be easy to do so. 
Well I'm open to new works and projects, so you can write me a PM if you want.
Will do :) thanks
Haha! Great response, I've worked with a few languages so far, I've been a dev for 3 years professionally. Self taught and just ticking along, my main job uses Laravel but I don't consider myself a PHP dev. I'm visiting comp science basics lately, I wish I had more time off just to fucking learn. I find that I get one day a week to really have professional growth and that's normally Sunday.
Thanks for the suggestions
please take a look at phptherightway.com - the way you aproach things is very... uncommon. ;-) using some oop and autoloader might be worth a try. 
I added in a License for you and anyone else that may want to add to it.
While I love the idea of tools like this, external dependencies make it a non-starter for my day to day use. Could be useful if bundled into an IDE or some sort of SaaS tool though. 
A lot of code review is based on discussion. If you are considering a mentor, I would also advice you to find someone of your level, and discuss code together. What do you think could be better? What would be a better approach?
Edit #1: Found out [https://github.com/php-cache/simple-cache-bridge](https://github.com/php-cache/simple-cache-bridge) to get a psr-16 (simplecache) from any Psr-6 implementation. could not find the opposite way. &amp;#x200B; As both standards are popular, I guess 'out-of-the-box PSR-16' is the way to go for broader audience/compatibility. At least if the lib does require complex features. Am I completly wrong ? :) 
Yes.
I am testing my php project in docker for well known Linux distributions using the official docker images of these distributions, see: https://github.com/mevdschee/php-crud-api/tree/master/docker Some people might argue it is not what docker is designed for. They say Docker is not a VM and that it is designed to run a single application. Nevertheless this usage is extremely valuable to me. I do agree that Vagrant would work equally well (albeit slower) in such a case.
Thanks. I really like SQL and designing databases. There's something addictive about cleaning up a database and making it quicker to access. 
&gt;static single instance provider I started by using a database singleton but everyone says that it's wrong and does not implement DI and it's not testable. Which way is it? how do you have currently 12 upvotes when iv also seen people downvoted into oblivion for suggesting exactly the same thing?
I am used to programming in java so maybe thats what your seeing lol, I'll take a look
I agree with apathetic012. That belongs on logopond.com 😉
Because everyone who knows how to properly program wouldn't even think about attempting to write their own framework. From my experience thinking about writing a framework is something mostly junior devs will do
Writing tests before developing a single line of code following Test Driven Development changes the way we inherently think, and allows us to generally write less buggy code. This is because you have to consider how the user will screw something up before accounting for it. The accountability drives code rather than fixing bugs that won't be found passively. This is considered feature testing. Sure, buggy code can be spotted by passive testing systems, but that's not going to stop a user entering 'lizard', "June 27, 1000", or "5" as their birthday. The reason we write test cases like this is to cover all scenarios so that when we eventually change major parts of the codebase, were not regressing into old bugs or authoriztion/input problems (regression testing through unit/feature testing). Passive testing can find whether or not there is a problem with your code - missing bracket, etc. -, but will not likely check whether an un-authenticated user is able to view a locked page or not. Also, whether a change has broken those test cases from previous iterations. 
I don't agree that we write tests to check if our freshly written code does what it supposed to do and nothing else. Tests are there to help you refactor existing code or add functionality to check if your newly introduced code did not break something elsewhere. Or that your refactor maintains the contract. And TDD generally doesn't offer an advantage here. And what's that part about accountability? How not doing TDD that is tests comes in advance before you write feature code changes that? Sounds like a slogan. There seems to be lack of empirical data to actually even support the case for TDD as a mean to ensure less bug prone code. Other than such prominent figures like Robert C Martin having strong opinions on it. Which somehow managed to sneak in CS literature unsubstantiated. So if you gonna insist on TDD please bring on conclusive evidence. You would expect we would have it by now. But other than few studies with small sample sizes which claim to demonstrate it, and numerous which suggest that there is no difference we have .. zip. Also, what Psalm has to do with TDD to begin with?
https://phpdelusions.net/pdo Read all of that. remove all of this: `mysqli_query($mysqli, $result2);`
Ah I actually am currently a Laravel dev too, its actually a junior position since this is my first professional programming job and its so hard to explain (mostly to the non programmers) 'uh guys, I've been programming for almost 2 decades, I know I'm young but ..I'm not really junior, minus the fact that I will not have many Laravel-specific details memorized, but that's not really any different from normal programming as it is'. The other problem is knowing certain aspects of computer science real well, how do I sell those? If I directly name them, it will just be jibberish to the other person, if I directly explain them, ..it will also be jibberish. One thing I will say about computer science is I think when it comes to programmers brushing up on 'computer science', we are often pointed to a more narrow definition of computer science that is very heavy with the computer science of low level programming (ie, programming in resource starved environments, programming with hardware, etc). This is very good stuff, my point isn't about to be *against this*, only that 'there are other areas as well that get overshadowed that will be fulfilling to study, its ok if you end up enjoying some of those instead'. I don't know if it matters what areas you study, but just know that its ok to study less vanilla areas, and that you will recieve tools for your toolbox no matter where you go, and that you often will have no way of predicting what area will give you the golden pickaxe you will later need for a problem. I will warn I suppose that if you study less mainstream areas, it will be harder to communicate about them; no one is going to quiz you on them in an interview, and if you proactively tell someone about, say, lens or arrows (https://www.haskell.org/arrows/), they won't know wtf you're talking about. Most of my comp sci interests being less vanilla with things like compilers, programming language design, programming paradigms (in depth), I feel like this has been a recent barrier. Study the areas you like, though, because they have definitely given me unique gems of insight and they're fun.
Need a dockerfile or registry !
That’s your problem. Replace them all with spaces. 
In my opinion dont make your own framework start using all the ones available out there. Start going down the rabit hole and check under the hood to see what is going on and how it works. If youve started using Wordpress, stop. Learn complimentary technologies e.g html templating, testing, ci/cd. Design patterns. 
I'm not sure I follow. How do I prevent the improper formatting in the browser when it is properly formatted in the editor? 
I'm looking to update large chunks of code with a major framework upgrade, this mainly involves changing a database query builder from using strings, to building a query from individual SQL generator classes such as joins, columns and values. I'm hoping to find a static analysis tool that can scan a codebase and then provide a scriptable interface for re-writing it, ideally one where the tool itself is written in PHP, as my Java is extremely rusty, so writing a plugin for PHPStorm would take a long time. The code is well documented, almost everything is fully typed either directly in the code or using @param / @var. I'd like to be able to locate all instances of a member being used, parse their arguments, and then replace those arguments with different code. Any suggestions?
The browser almost certainly has a different representation for tabs. You may have configured a tab to be shown as 2 spaces, while the browser is probably showing 8 or more. 
Very interesting. Can you provide example before/after code?
&gt; I check php docs then packagist because someone's already solved my problem for me This is probably one of the most accurate statements of a modern PHP dev's workflow I have ever seen.
I see. So there is no way to fix this? It doesn't do this with my CSS, HTML, JS files. Just with PHP.
I'd suggest brush up on the basics: Completely master `isset` and `empty`, along with all their edge cases. Get really good with composer. Familiarize yourself with phpunit. Get good with a framework. Being able to code is one thing. Completing tasks quickly is another thing. Avoid deeply nested curly braces. Instead do all your edge case checking at the beginning of your functions so you can return early. Get good with an IDE, I'd suggest phpstorm. When you're put onto a new project, an IDE will allow you to move around more efficiently. Get good with phpdoc. PHPDoc is especially handy for helping IDE's understand code. Outside of PHP, I'd also suggest get good with SSH. Being able to ssh into a server and do a git pull is a pretty standard way to deploy. You can also check out tools like CircleCI, Travis CI, Jenkins, and Ansible. Then finally I'd suggest get really good with Linux. While you can develop on whatever OS you want locally, production usually uses some distribution of Linux. There's great benefits in using the same OS locally so you gain more experience with that particular OS and can move around more efficiently when interacting with a production server. Aside from these things, completely mastering a language is one thing. Being able to prove you're a pro is another thing. Get some code on github so others can see where your coding skills stand.
&gt; says that it's wrong and does not implement DI So does my comment say.
Thanks, I'm pretty much done switching everything over now, its just gonna be logout, admin and view that is a pain.
https://www.plivo.com/pricing/ This one is free to receive sms and has a php sdk
Strings should just be iterables of bytes/codepoints/graphemes (the user can pick what he needs). Then we can deprecate the string function and make new functions which work on any iterable. So they also work for int[] and whatever you can think of. 
Which framework are you working with? If it is Laravel, have you looked at Shift? [https://laravelshift.com/shifts](https://laravelshift.com/shifts) Slightly more expensive, but you can also get them as Docker versions as well. [https://laravelshift.com/docker](https://laravelshift.com/docker) There are Shifts for generic PHP, too, so it isn't just Laravel. But, if you're talking about a specific other framework, I doubt any of the stock shifts would work for you. I haven't personally heard of too many projects that do this sort of thing automatically. If you end up needing to build this yourself from scratch, I'd probably check out PHP-Parser. [https://github.com/nikic/PHP-Parser](https://github.com/nikic/PHP-Parser)
How are you viewing PHP code in your browser? Are you referring to markup you echo/print from the server side PHP? If you're seeing PHP in your source on the front-end, your server is misconfigured and PHP is being served as text content as opposed to being executed.
Use EditorConfig: https://editorconfig.org/ VSCode Plugin Here: https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig
Um, okay. I'm happy for those who are still in that community and are able to upgrade.
Do anyone still use it?
https://github.com/RobCod/Stoyez-Chat-PHP/blob/master/Stoyez-Chat-V1.0/post.php#L27 You missed (at least) one. Please, look into prepared statements.
Oh thats not the updated one lol, I actually have them switched over in V1.1 which I haven't put up yet, wanting to add some more stuff with that fix. V1.0 I only fixed the XSS vunerability
Read other people's code. Don't build another frameworks it really doesn't help. Try to find refactored code were somebody applied a design pattern.
I thought it was not in development anymore...
i just check the routing and controller from the documentation. it's pretty horrible.
New update is up if you wanna check it out and see if I did it right
I honestly don’t have to say anything, anyone reading your thoughts on the subject will be horrified to work with your code and the way you misunderstand SOLID. 
Well if it's still under active development, the answer is usually, yes. 
It went on hiatus for a short time, while the owners found someone suitable to take over. 
Just checked it. It _is_.
You may want to look at rector: [https://github.com/rectorphp/rector](https://github.com/rectorphp/rector) &amp;#x200B; I'm not sure I got what your exact use case is but it seems similar to what the tool does.
So, you complain about external dependencies and then suggest wrapping this tool in a SaaS, so that if you need it, you're forced to be online to use it? Sounds reasonable.
No, I’m saying I wouldn’t use it locally, but it could fit in well in something like a CI process - which isn’t local in the first place. 
Just because it runs in a CI context, it doesn't necessarily mean it has to be a SaaS integration. I use composer, phpunit and other tools in my pipelines the same way I would use them locally.
as much as i hate codeigniter, why is laravel so widely used? its magic and use of globals, along with eloquent is nearly as bad. for phpstorm to be able to map everything you have to use composer to install a bullshit file just so a bunch of functions and static methods are understood.
If only. :(
Some projects do not involve maintainance. Usually smaller apps for small to medium businesses. Saving e.g. month in development time in start up time is then entirely in client interest. However, I will point out that framework benefits are secondary to framework proficiency in short projects ;)
We use phpstan level 4 as first step into our travis CI to crash our build before even running any unit and functional test. It's really powerful.
That looks like it might get the job done. As some people have guessed, it's an internal framework that doesn't have existing upgrade tools, so it's a build-from-scratch kind of deal. It would change something like &gt; $query-&gt;join('table_1234', 'ON (table1.t1_id=table2.t2_id)') into something like: &gt; $query-&gt;add(new Join('INNER', 'table_1234', new JoinOn('table_1234.id', 'table_5678.id')))
Do you have any favorite php framework?
well, you commented as i made an edit :) i actually really liked symfony2. symfony 3/4 i think also has to much magic with autowiring. Autowiring I admit is really slick but I think the more magic people add, people just get dumber.
&gt;Don't build another frameworks it really doesn't help If your sole goal is to learn how to build a web application with PHP, I'd say building your own framework is a good way about that. Of course, don't build a framework as a beginner for the purpose of it being adopted into projects.
&gt;you should remain dedicated to it and not flake like 9/10 developers Maybe it's not the project they were flaking on, but your passive aggressive tone.
&gt; Levelling up on PHP? Perhaps you need experienced level from advanced beginner, although employers do not rarely need newbies. 
dunno if anyone cares, but im sick of php core not wanting to fix the things everyone shits on, ie needle/haystack and function naming. kinda wanna fork and just.... do what they dont want to.
https://github.com/barryvdh/laravel-ide-helper
yeah, thats the thing i mentioned as being lame.
Yes at work :(
What's the point of this? It seems like they did a complete re-write (tried to clone Laravel), and that it would not be a simple upgrade form ci3?
Why so much hate for Codeigniter? You don’t have to use the same framework for every project. If CI works for it: great! If not: use something else! I find CI to be great for many projects and it’s still very lightweight.
Isn't this the same example that you find whenever you do a Lumen API example search?
&gt; Roadrunner There's also Caddy Webserver, written in GO. It's not specific to PHP applications obviously, but it's a tiny gem, really simpple to setup, and it also automatically manages SSL certificates generation through Let's Encript
Yes, version 2 in fact.
Better question would be why does anyone still use it?
It is horrible, because ... Some link or explanation?
Instead of breaking things, why can't we suggest new approach to these... trivial "problems"? Why change `strstr` and other crap that quasi-programmers cry about? Why not create a built-in `String` class and fix the issue that way? ``` $string = new String('hello world'); $string-&gt;find('hello'); // Returns integer offset $string-&gt;replace('world')-&gt;with('earth is flat'); ``` And so on. Why introduce breaking changes if we can use object paradigm to approach the problem from a different angle? 
Because we aren't OOP-nazi. It's use of global helper functions and active record is justified by the fact that it keeps the user code footprint really small and configuration to a minimum which is really good for getting your _not-rocket-science_ CRUD MVP stuff to market fast, instead of debating all the ways we might break SRP and where we might need an extra abstraction layer or pluggable modules.
Laravel is a web app framework, Symfony a PHP framework. You dont need this file with PHP Storm if you dont use facades. Laravel is widely used because it's good, fast and effective. There's no point to hate a tool if you don't like/know it (it's childish).
I don't get it. So the chosen ones who actually wrote THE frameworks DO know how to properly program or not? I'm not going to be able to sleep without an answer.
No tests?
Thank you so much dude, you're a hero.
Thousands visitors per second, million dollar AD revenue websites have been done using Codeigniter and other "no wonder PHP has a terrible name" related stuff. Oh, and also pretty good private web applications that serve mission critical day to day operations. Please get out of your bubble...
It´s more like taking the same ideas in a PSR and composer friendly way, I think. You cannot have that with the old versions architecture, with the CI instance, the $this for interacting with everything and so on. They aim to maintain the small footprint and other conveniences in previous versions with in a more modern take on PHP possibilities. We´ll see if they actually deliver and find a spot in the frameworks landscape.
Just because it works doesn't mean it's good code-wise. I don't care if it's bringing in £100000 a second, if the code is so terrible that you can't hire anyone to maintain it, what's the point?
&gt;Laravel 5.7 5.8 is out now. &gt;come with friends or family members and want to always be on the same team. https://laravel.com/docs/5.8/eloquent-relationships &gt;the rating system (1-10) is a bit too basic and maybe this needs to be expanded to multiple areas? Speed, strength, defence, attack, passing, shooting - average of all these scores is the total score. function getScore() { return $this-&gt;speed + $this-&gt;strength + $this-&gt;defence + $this-&gt;attack + $this-&gt;passing + $this-&gt;shooting; } &gt;the winning team every week, the players get a slight stat boost? I don't know if this is worth doing, but something to think about. I don't think that's a good idea. You'd get players with maxed out stats. Use another property to keep track of winning streaks. &gt;player positions is another important one. We have people who prefer defence, goal keeping, striking, mid fielding. Another thing to factor in when generating teams $match -&gt;players -&gt;groupBy('position') 
Hey Michael! That's a fair point and my comment was more tongue in cheek than anything :)
Before I even go into looking at the about page, is it pronounced "fap"?
Hmm...I mean writing a parser combinator library in PHP has kind of been an act of angry self gratification ¯\_(ツ)_/¯ I have no opinion on how it should be pronounced.
Is it possible that examples actually look more like a development of a new language instead of foo, bar? I guess this is important because the use I could made to this kind of project is to make pseudo-languages and better examples are desired. Said that I see that the project looks really nice, documentation is enough to start out something from scratch. I've tried to build a parser with a teammate for a project in PHP some time ago and after becoming crazy... It became obvious that a library like this is needed to avoid reinvent the wheel. Other solutions don't look as nice as this. And seems that something that could become like a standard... Really looking forward to it.
You might want to start by making your site mobile-friendly. When I can read it I might have some opinions. 
Here's the [relevant page](https://codeigniter4.github.io/userguide/incoming/controllers.html), you are welcome. Why? I'm used to Symfony's clean and convenient solutions not for adding any extra code to tweak it. Think of it like configuration over coding.
I personally like to do all my PHP projects with Symfony and Doctrine. Symfony is super fast and is really modular, which I personally really like. Doctrine on the other hand is really feature complete and works like a charm, even though it might be a bit slow, but can be tweaked. I never uses laravel, but I have heard good things about it. But I think (from what I heard) it is more suited for full stack apps. Where as symfony really shines in services and rest based systems. Also you probably don't need micro services. You can very well create a good api with a monolith. Yes it is not fancy, but it works like a charm. If you ever need Symfony to do rendering, Twig is a great template engine and language.
If you tap the three horizontal bars on the top right of the sidebar, then the sidebar will close. I'll make a ticket for myself to make it less obnoxious now It other than the sidebar being a bit big it seemed okay to me. Did you have any other problems with it?
I won't even dare touch the framework choice. One can only get flamed for it. Personally I'm heavily leaning towards very small architectures using Middlewares and whatnot. Zend Expressive is my choice here. Laravel also can run very lightweight on Middlewares. Symfony as well. Truthfully, if YOUR architecture is strong, the choice of framework really doesn't matter that much. It's just an "accessibility" layer on top of your application. No more than that. When it comes to ORM, check out Doctrine. Since you're already familiar with Eloquent, learning Doctrine will become quite simple to you as Eloquent basically took Doctrine and made it fit their Active Record needs (probably will get shred to pieces for that statement as well but whatever). Certainly, today I wouldn't run with anything that's not Doctrine or Eloquent as they are the two dominant players on the market. Well, I guess Active Record Pattern still has Propel, but why'd you use it when you have a better one available with Eloquent either way.
I also read good things about the modularity of Symfony, which is one of the reasons why I'm leaning towards that rather than laravel. Also, I guess a monolithic / service-oriented architecture is the best choice, at least for now that i get to work on this alone. --- Thank you for your feedback!
Hmm, that's a good idea. Maybe an example of making a JSON parser, or a simple lisp interpreter?
&gt; Truthfully, if YOUR architecture is strong, the choice of framework really doesn't matter that much. It's just an "accessibility" layer on top of your application. No more than that. That's an interesting point, and i wholeheartedly agree: it's more a choice of "mindset" to follow, so that my colleagues can tag along without asking me every infrastructure choice in every little detail. &gt; When it comes to ORM, check out Doctrine. Since you're already familiar with Eloquent, learning Doctrine will become quite simple to you as Eloquent basically took Doctrine and made it fit their Active Record needs I will probably give doctrine a try, and if it sticks to my finger-tips' muscle memory like eloquent did, I'll keep it. Really, the cross-context-boundary nature of the entities i'll be working with is my main detractor from using Eloquent and other Active Record ORMs.
I've never found anything that ci would've been a better fit for than another framework. I've had the misfortune of inheriting a ci project that was complete garbage, tho that was probably more the fault of the previous programmers than the framework. 
&gt; Doctrine on the other hand is really feature complete and works like a charm, even though it might be a bit slow, but can be tweaked. &amp;#x200B; I think that Doctrine is almost never going to be the bottleneck of your application though. It's certainly fast enough and its usefulness far outweigh any perceived performance penalties (which I've never really experienced). Especially since it's its so easy to bypass Doctrine and run a native database query where needed. &amp;#x200B; But fully agree on your more general point.
&gt;I think that Doctrine is almost never going to be the bottleneck of your application though. I am absoluty with you. But I had major performance hits with Entity Framework and after tweaking it worked faster. From that point on I always tweak from the beginning :D &amp;#x200B;
Try not to be too ambitious at first glance just something newbies like me can understand. JSON parser looks nice as an intermediate example. As a fun exercise you could make a limited (obviously) PHP parser.
Out of curiosity, what kind of tweaks are we talking about?
Entity Framework or Doctrine?
I'd be interested to see the author's thoughts on the Laravel DI container, as as far as I can tell, most of their criticisms in the article don't apply to it. * Configuration is all done using plain type-safe PHP in a similar manner to their own examples of a "hand-written container" * It's easy to refactor with an IDE * There are no specific service ID requirements and most will simply use the name of the class or interface through the use of `::class` * I've yet to find a case where you need to adjust your service definitions to aid the auto-wirer * As it's plain PHP, there are no issues with more complex configuration when passing a service scalar values * There's no inherent binding between file location and whether or not it's a service * Binding different implementations in different environments is very straightforward and the configuration for this can remain in the same location as the general service configuration * Making a service act like a singleton is optional * You can inline instantiation of other dependencies if it's appropriate
Doctrine, but from your reply I guess your "tweaking" was referred to EF, wasn't it? 
I think a lot of people are pushing you towards using PDO instead of mysqli, and to use prepared statements. I don't see a V1.1 version so not sure if you fixed this already but a PDO version might look like this: https://github.com/RobCod/Stoyez-Chat-PHP/blob/master/Stoyez-Chat-V1.0/post.php#L27 $query = "INSERT INTO messages". "(poster, text, postdate, poststatus) ". "VALUES(:poster, :text, :postdate', :poststatus)"; $query_params = array( ':poster' =&gt; htmlentities($username), ':text' =&gt; htmlentities($textCleaned), ':postdate' =&gt; htmlentities($date), ':poststatus' =&gt; htmlentities($send_to) ); try { $stmt = $db-&gt;prepare($query); $stmt-&gt;execute($query_params); } catch(PDOException $ex) { die("Failed to add new message to chat: " . $ex-&gt;getMessage()); } Ideally you want to use a robust sanitisation function rather than just `htmlentities` but this is just a basic example. Also, try to keep your variables and table fields matching, and use descriptive names. `$result1`, `$result2` is not a good practice.
No not really. I check for a ORM what the recommended things are to do to increase performance. One of the things I stopped doing is to get the whole object every time. I always write DQL queries to get the specific data I want, seems obvious but isn't for most projects I worked on.
Architecturally I'd go for a complete separation of business and web logic. I'd have the business logic in a separate repo which can be pulled into the web app via composer. I'd strongly recommend following semantic versioning for the business logic and version pinning this within your web layer. This means your business logic will stay nicely separated and framework/environment agnostic. It'll also be good for TDD as you'll naturally gravitate towards loosely coupled components that you can test in isolation.
[http://php.net/manual/en/function.json-decode.php](http://php.net/manual/en/function.json-decode.php) ?
Specific queries are a good idea to keep in mind, thanks!
I work in a team of 20 people. In earlier stages, we had no framework. We were adding features without any kind of plan, and it was a mess. We adopted Laravel in its infancy, at the very start. Since then: - our code is standardized - it's easy to find where code is (route, service provider, lib. installed via composer etc.) - getting new people in doesn't require teaching them "the way we do it here" It would be a financial suicide not using a framework in given environment. Blog posts like the one I read are applicable to solo players, or if there's another person working on the project. To a company that actually makes money, using a framework means saving a metric ton of money. Real world is, sadly, vastly different to purist programmer world where one needs to satisfy imaginary beast that criticizes everything that's being used. I respect people's opinion and I welcome posts like this one. Reason: because I don't agree with them. When we employ people, we need to get a feel what they're doing, how and why. When candidates quote reasons why they didn't use something and when that reason resembles something to this blog post - that's a clear indication that we should refuse that candidate. For that very particular reason - I'm grateful. It serves as a way to save even more money. Because of that - I thank you.
You can use json_decode function in case you have commas separating fields. Just saying :)
 As I said, the GUIs will be done with VUE js and treated as different projects, through those I will consume the API of the main app. Would you suggest all that even if the presentation layer (your "web logic") is a simple JSON API? Thanks for the feedback :)
It's a shortcode, not JSON.
No problem. Hope it goes well. And don't forget security. Read up on how to sanitize input, if you don't know this already, or you'll be hit by SQL injection attacks.
&gt; I've tried a couple of things so far Try to read the sub's rules and ask in /r/phphelp People there addicted to writing silly regexes for anyone who asked. 
I have been using hand-written service containers for a while now, with very positive effects. Cf. the one in [Bookdown]( https://github.com/bookdown/Bookdown.Bookdown/blob/1.x/src/Container.php) and the "main" one in [Atlas 2](https://github.com/atlasphp/Atlas.Orm/blob/2.x/src/AtlasContainer.php). What's interesting is that you can combine the hand-written service container rather easily with another one, if you want to offload the creation of specific objects to other containers. The Atlas ones do so in v3 via a factory callable; cf. the Atlas 3 [TableLocator](https://github.com/atlasphp/Atlas.Table/blob/1.x/src/TableLocator.php) (itself a container), specifically the `newTable()` factory method at the end.
Yes, I see that it outta noir a valid json. Out of my head... use preg_match, Regex hint: /"(.?)"/U
Personally I'd always suggest that approach for a few reasons: * Business logic will never become tied to the web layer, i.e. you won't have business entities polluted with JSON annotations * Same as above but for the database layer * Easier to avoid web or database logic sneaking into the business layer, e.g. services throwing exceptions that are tightly coupled with a particular web state * You can reuse the business logic elsewhere, e.g. in a command line app or in a separate web service - just add it as a dependency. It's so reusable because it has no context of its environment * if you need to switch web frameworks it's much easier because you only have a thin layer to switch. This doesn't happen often but I experienced it in my last job and the whole application was so polluted with the framework we essentially had to rebuild it It's possible to have all of these benefits with your business logic embedded within your web app of course but you need more process in terms of peer review and PR approvals. It's also very easy to let things slip. I'd say it's worth throwing together a simple proof of concept and seeing how it feels. It may not fit your development process but for me it's the best way to build out applications. 
oh wait, I forgot.... PHP is used for things other than the web. Oh no, I lied. Thats almost all its for. I know laravel, its a bad tool. 
active record is fine. the implementation however is not, IMO. 
&gt; Autowiring I admit is really slick but I think the more magic people add, devs get dumber and are too reliant on frameworks. It's kind of a double edged sword; the less hard grunt work we have to do, the easier it is to get into and there is a potential for more people calling themselves developers; however I'd argue that anyone who can use Symfony properly is not a dumb developer. If you understand the concepts behind Symfony and can use that to build an application, you're still a developer. You don't need to understand hardware design and machine language to be good at using a computer; you don't need to understand a compiler to be a good programmer; you don't need to know how everything works in a framework to use it well.
What is "_a shortcode_"? To me, it looks like malformed JSON. If this is a format you cannot change (i.e. an externally provided data stream) then you obviously need to find a solution, but if you _can_ influence the format, you should definitely use JSON or something similar that can be natively decoded with ease.
Hell, I still use Kohana 2.3, although I have modified it quite a bit. Haven't found anything else I like nearly as much that doesn't have a steep learning curve.
&gt;People there are addicted to writing silly regexes for anyone who asked. Made my day &amp;#x200B;
Short format code users can insert into an editor - Used to paste in a long list of products from a template, as an example. I can not change the format.
Okay its not json... [https://stackoverflow.com/questions/15735258/parse-wordpress-like-shortcode](https://stackoverflow.com/questions/15735258/parse-wordpress-like-shortcode)
You can use my open source Shortcode library which is specifically designed to handle the shortcode / BBCode syntax, also with custom tags. The repository is here: [https://github.com/thunderer/Shortcode](https://github.com/thunderer/Shortcode). Your specific use case will be handled by the following code: &amp;#x200B; **&lt;?php** **declare**(strict\_types=1); **namespace** X; **use** Thunder\\Shortcode\\HandlerContainer\\HandlerContainer; **use** Thunder\\Shortcode\\Parser\\RegularParser; **use** Thunder\\Shortcode\\Processor\\Processor; **use** Thunder\\Shortcode\\Shortcode\\ShortcodeInterface; **use** Thunder\\Shortcode\\Syntax\\Syntax; **require** *\_\_DIR\_\_*.'/vendor/autoload.php'; $syntax = **new** Syntax('{', '}', '/', ':', '"'); $parser = **new** RegularParser($syntax); $handlers = **new** HandlerContainer(); $handlers-&gt;setDefault(**function**(ShortcodeInterface $s) { **return** 'name '.$s-&gt;getName()."\\n".'bbcode "'.$s-&gt;getBbCode()."\\n".'args '.json\_encode($s-&gt;getParameters())."\\n"; }); $processor = **new** Processor($parser, $handlers); $text = '{search:"blue pants" minus:"black" limit:4}'; **echo** $processor-&gt;process($text); Output: &amp;#x200B; &gt;name search &gt; &gt;bbcode "blue pants &gt; &gt;args {"minus":"black","limit":"4"} &amp;#x200B; As you see, you get access to all the data you have and feel free to customize the handler. You will find more in the documentation in the README - if you have more questions then comment here or open the issue on GitHub. Let me know if it worked for you! :)
I don't told "web" but "web app". Laravel has an entire rapid and efficient ecosystem to build quickly large web apps with a ready to use notifications (email, sms), queues, events, mailing, social authentication (socialite) that I use in all of my projects. Then, you have solid tools and package like Horizon (jobs monitoring), subscription management (cashier, spark), app management and deployment (envoy, forge, envoyer), logs monitoring (telescope), e2e tests (dusk), search (scout), etc... I also use Symfony (both certified with Symfony and Laravel), you just need to take the right tool for the right job.
I'm using a style like this: ``` //'/\[(YOUTUBE) src=(.+) width=(.+) caption=(.+)\]/', "/\[(YOUTUBE)[\s+](.+)\]/", ``` You can see [its class code here](https://github.com/canax/textfilter/blob/master/src/TextFilter/TShortcode.php), initially it was the same structure that WordPress used for their handling of shortcodes. Perhaps you can make some use of it. 
There's pretty much zero things that CI would be a better fit for, for a new project, than say Symfony. You can pick only the libraries/components you need from Symfony and get a faster, more lightweight, more modern framework with better features and security. CI was cool way back in the day, before we got better OOP features, but it's obsolete now.
You can just turn autowiring off and do it the same way you have always done it. Personally I think it's pretty fantastic because I don't have to waste a bunch of time copy/pasting generic service definitions.
All that stuff is *great* until you have to do actual coding work, and then Laravel just gets in the way and fucks you a lot. I still consider it a toy framework and would never use it on a serious project. That's what Symfony is for - getting shit done.
Rector looks interesting and looks sorta like an open-source version of Shift. It also looks like at least some of the "rectors" are using [PHP-Parser](https://github.com/nikic/PHP-Parser ). The problem is, given this new information you've shared is that it isn't just PHP code that needs to be rewritten. You are interpreting potentially arbitrary SQL snippets and mapping those to new PHP code that didn't exist before.
There's a lot in your post, not all of it in my area of expertise. I can ofer an architectural point-of-view: only go with microservices if your project needs high scalability or builds around a central system. Microservices seem like the way to go for many projects, just because there's so many separate parts floating around. Breaking it up into individual components seems nice, as that separates concerns. The issue is that this only works if each part is large enough on its own. You have to remember that microservices, as they originated, are an architectural pattern for scalability and multiple development teams. Not only that, but they often have a team of architects, product owners and whatnot to worry about the specific details of the high-level design. Over time, the pattern has become more widespread. It turns out to also be really useful in having a single large system (i.e. SAP, Salesforce, etc.) and building a host of extra features around it. For everything else, microservices are most likely too complex to really bother. I'm not saying you shouldn't do it if you really wanted to, but I'd advise against it due to the complex nature of microservices. They tend to become complex webs of dependencies, with 'dumb' pipelines and every service requiring graceful failure methods for each service it depends on. I would advise [microservices.io](https://microservices.io/patterns/microservices.html) for more on the challenges/benefits/alternatives.
Because you can skip the boilerplate and go straight into building business logic. Also known as the part of the code that actually matters. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
The individual functions I think I'll be fine doing. E.g. working out the average score of a player and adding a position. Was going to create two new MySQL tables. One for relationship of players and another for storing statistics. The problem is actually combining all of this to actually split the teams and give me a fair and even two teams of 9 players each side taking into account relationship, average skill and position. 
Hey man, thanks for the feedback. I think microservices are adding a level of complexity without giving me enough advantages. This project has got to scale in the future, but not to the degree of needing that kind of architecture. I think I'll stick to a monolithic style. Thanks for the link, I'll study that for sure!
I am doing a side work gig to help a company transition from PHP 5.6 to 7.2 onto new servers and then doing some minor updates and feature enhancements. I believe they are going to want new things in the future but after looking through the code it is a hot mess. I think we have all seen this type of thing before and im curious how to explain to them that they need to start thinking about rewriting in the future. Some of the issues I see: &amp;#x200B; 1.) No framework or libraries whatsoever. No composer.json file or anything 2.) No clean URLs. Everything goes to /whatever.php 3.) The code to store sessions in databases completely broke on the migration and I had to revert back to file sessions just to be able to log in. 4.) No testing at all 5.) The php files consist of what we all have probably seen: include some global files, execute some database query on a laughable custom DB layer, loop through the results and display it with HTML, add some crappy jQuery at the bottom where they wanted to be fancy and AJAX stuff. Then also some logic to decide whether or not you just submitted a form etc 6.) No controllers or MVC structure at all. 7.) Forcing HTTPS with PHP instead of htaccess 8.) 7 GB database 9.) Hundreds or thousands of unused files &amp;#x200B; Just the typical stuff that you would expect from someone who just started learning PHP and probably thought frameworks and libraries were "overkill" or couldnt grasp the concepts of MVC. &amp;#x200B; I digress. One thing I am having trouble with is they are asking me to put timelines to adding or fixing bugs when its nearly impossible to do so because by the time you figure out how this stuff works you have found the bug and will fix it. One of the biggest problems in a model standpoint they have a huge number of forms, application, and workflow so to redo this it would take a decent amount of time. Also not to mention I cannot guarantee security in the slightest in its current form. Then mentioning e-commerce just makes me shutter. &amp;#x200B; Has anyone had to transition from a custom PHP while maintaining the old code? How did you do it?
Thanks, but I was expecting some \*reasons\* about THAT way of routing and doing controllers are bad, and not just because you're used to Symfony ;P
If you want to improve the situation I'd say your number one priority should be to try and get some automated end-to-end tests set up if you can. It would be very difficult/risky to refactor or replace anything without any tests. Once you have a test suite you can gradually refactor into a framework with more safety.
Going with microservices from the start is usually something I advice against. Especially at first you want to be able to deliver stuff quickly. With microservices you'll run into hurdles quite quickly. More often than not the boundaries we've defined at first turn out to be different. Moving these boundaries over from one microservice to another is not simple and the early separation often forces you to design in a particular direction. This is a very expensive form of accidental complexity (or solution induced design damage). It also forces you to create multiple deployment lifecycles, which more often than not need to be kept in sync for the first period anyway, so why separate? However it is good to keep a focus on where the boundaries in your system are for when you actually are at the scale when microservices make sense. It's always cheaper to redefine a boundary in a single codebase than across multiple. &amp;#x200B; Side-note: using "PHaggots"is not super appropriate.
I've been exactly where you are right now. I just had to maintain it as the owners didn't want to redevelop it properly even though it would make everything simpler to develop and debug. Even though I couldn't rewrite the base at first I made sure that any addition, where possible, would be modular (connect to the main crappy code as little as possible) and I'd have to slowly build an API from their rubbish legacy code. Eventually most new products/features were completely separate and wouldn't bug out a 100th of the bugs on the legacy so then I got the go ahead to rewrite the base. &amp;#x200B; I'd like to add that the guy that created it, so called manager, was getting serious money for building something so broken and badly coded.
You'll have to tweak the process until it seems right to you. Here is an idea: Give a goalie to each team. Then go position by position getting players by two. Assign the player with the higher score to the team with the lowest score. After this process you should a sort of balanced couple of teams. Check if there are unsatisfied relationships in team A. If there are try to swap them with the same position on team B taking into account the score difference the swap would produce. 
&gt;CI \[...\] it's obsolete now So maybe that's the reason they're doing the 4.0 version?
Yes. Will comment in depth later today when I get time.
Yup! There's even a name for this: The Strangulation Pattern. (Make less and less connections to the broken code until you have none and can remove it). &amp;#x200B;
This seems to skirt over what happens when your application becomes more complex and you can't just 'inline' everything. What happens when many of your services require other services which also have parameters? Your interface will fall apart also because your mocks will have a different method signature to your concretes. For example your mock emailer service doesn't have any parameters but almost any actual implementation would need parameters, meaning they can't share an interface. Not to mention I can't see much benefit from being able to mock out a container, if that's useful to you then you may be using a service locator by mistake. I definitely agree with a service container that is 'coded' and not written out in yaml, but without things like injection I don't think a handwritten container would scale.
I worked with code igniter professionally, it's a total POS. I've also worked with laravel professionally and was extremely productive even when accounting for then crazy plugin. It handles so many workflows it's ridiculous.
Good job dude! We all started doing things like this. I spent 18months doing a chat in scala and i can tell u that is not easy :) Keep going!
You know, the code may be terrible using any framework. As with PHP, the fact some frameworks are more popular for newbies has something to do with that too. You can find terrible codebases with Laravel or Symfony too
Have you looked into https://codex.wordpress.org/Function_Reference/shortcode_parse_atts ? &gt; # Description &gt; Accepts a string of shortcode attributes and returns an associative array of key/value pairs. &gt; The attributes list has the attribute name as the key and the value of the attribute as the value in the key/value pair. This allows for easier retrieval of the attributes, since all attributes have to be known. 
There is also a name for "rewrite everything from scratch". It's called: bankruptcy.
If everything is going to 'whatever.php', are there any common elements between these files that you can look at abstracting out into classes, etc.? No MVC structure isn't really a problem, you can certainly look at moving the HTML into Twig templates and then abstracting that outside of the many whatever.php files to clean them up substantially. Forcing HTTPs with PHP vs .htaccess isn't an issue either, why do you think it is? Surely you can just put in a .htaccess and remove the PHP check? It'll take five minutes, right? 7GB Database? Why is that a problem? Databases commonly run into hundreds of gigabytes. Unused files can be investigated in two ways in my opinion, one is to create a function in one of the global includes to email you or log whenever that file is used somewhere, or simply move it to another 'i_think_these_arent_used' folder. Once you've cleaned up the business logic from the HTML and abstracted out common code to simplify the whole thing, you'll have something far easier to work in and this process isn't something I'd consider particular complicated for any project.
I work with mostly beginners for projects to try and teach them things I've learned. Most people flake because of timelines and work based commitments or the fact they seem to actually hate coding but never knew it. You read one comment on a board and are making a wide assumption about my personality congratulations you've profiled me in less than 13 words.
Bankruptcy is also what happens when you're drowning in so much technical debt that you're completely incapable of responding to changes in the market in a reasonable timeframe, and probably also pissing off existing users/clients because your software is slow and unstable.
My approach would be to duplicate it as soon as possible in a sensible framework, such as Laravel. In the long term, you will have much less grief than trying to maintain badly designed, crappy code.
That is exactly what I thought, thank you for giving me a feedback on the matter. This is how I wanted to proceed: - start with a monolith - practice DDD and pay attention to contexts and boundaries - let an eventual separation of a service emerge later on: once a bounded-context has proven itself to be indepentend enough, i might want to make a service/microservice out of it; or maybe not, i'll let time and events tell me what to do -- &gt; Side-note: using "PHaggots"is not super appropriate. Oh come on, It's a joke! Sorry if I offended you, I didn't mean to :)
Whats the best way to do that when the PHP code is entangled with the templating?
Thanks!
Very good points and I was thinking the same. Good to hear someone else is thinking that way also.
I think I would put laravel in the spot where you want a simple website, but want enough flexibility with code for the server-side processing. I don't think it would scale as nicely with complexity as some other frameworks such as Symphony, but it looks like that is not really what Laravel is aiming for IMO. I also like their packages and their documentation. &amp;#x200B; But I do agree with OP's points. Their implementation could be better.
A lot of those things are not problems per-say was just pointing them out along with the other things. Thank you for the recommendations also those are valuable!
End to end testing doesn't require for that to be untangled. Basically you'll want your tests to make a request to your application, you'll then want to assert against the response. Ideally you'd created a test harness to spin up a test database and insert some fixtures, you probably don't want a persistent test database as your suite will be flakey. How you implement this, i.e. what testing frameworks etc is up to you. I'd suggest using something like Symfony's testing library where you can run a selector on the response and use that to assert that parts of the page have been rendered correctly. i.e. you'll hit /welcome.php and then assert that you've got a 200 code back and the body shows the app menu or something. In fact for an even quicker win you could add tests just to assert that each page returns the expected response code (e.g 200). That would at least give you some warning if you accidentally break something.
Your local setup should be able to mimic your live setup as best as is possible with the resources. &amp;#x200B; We enforce the initial setup of the local environment on each developer's PC using ansible to configure a vagrant box which will run the platform locally. This solves the majority of the issues. &amp;#x200B; If you're running into the "but it works fine on my machine!" problems, then that's a clue you need to have more structure in the local environment setup. &amp;#x200B; If you're talking about things like editor choices (themes, fonts, layouts, etc of the IDE), then that should be up to the developer as long as they are effective in their tool. For a while we had a developer that worked in VIM, and they were just as effective as we were in PhpStorm (back in \~2015).
Tbh I'm not "used to Symfony", I was just tried to give you an example about why people can feel CI is outdated. I could've said Laravel as well. The point is that this seems unnecessarily complicated (for me, at least).
Sure. Of course the original question does not mention any of those things except perhaps the technical debt. So I'm not sure of the relevance.
Great article! I used to do something similar! My project had several thousand classes and maybe 70 different service containers. The containers were great for refactoring and static analysis but having to find the specific container that contained the method to created the specific dependency would also cause much confusion for myself and others on the team. Including singleton / shared instance functionality and involved a lot of boilerplate in each factory method. &amp;#x200B; Now we use league/container with service providers in the container config to split things up ([https://container.thephpleague.com/2.x/advanced/#service-providers](https://container.thephpleague.com/2.x/advanced/#service-providers)). &amp;#x200B; It's much easier to just call $c-&gt;get(MyClass:class) in the service providers and not worry so much about finding the correct service container method. One the definitions are defined then it's just a matter of asking for the class. &amp;#x200B; I will go even further and say that in some of our laravel projects, the auto-wiring has been really enjoyable to work with and I haven't really needed to make too many custom definitions. I really like the approach of auto-wiring even with the trade-offs.
The project I'm working on doesn't even know the concepts of composer or even the autoloader. The code is littered with `require_once`. :-(
Hey, thanks for the reply. And some more information, we don't really have issues with "it works on my machine!". We are a consultant company and have over 200 clients with different platforms, languages etc. so I struggle to see how to maintain a local environment for every of this different solutions, for example I love vagrant and ansible, but then you have people that prefer docker or even some other custom solutions. Keeping everyone happy without disrupting work flow seems like a monumental task
Can we not do this in every goddamn thread? How is this a productive, relevant discussion.
\&gt; We are a consultant company and have over 200 clients with different platforms, languages etc &amp;#x200B; This is one of those situations where a container-style setup might work best then, as you need to combine multiple discrete version choices, etc. &amp;#x200B; I find vagrant works fine if you can still classify them into groups (such as apache + PHP7, apache + PHP 7.1, etc) and then have different vagrants for databases (depending on how much RAM your machine has!). The cost of this is switching between the vagrants for the projects. I guess it depends on how often that happens. &amp;#x200B; This is why I much prefer to have a single platform for everything! :D
You don't have to use the magic if you don't want to. My Laravel projects would survive just fine if a gremlin went into my code and tore out the source code of every Facade in the framework.
Question, is this a public application or it's going to be logged in by customers only?
&gt; What happens when many of your services require other services which also have parameters? You can just call `$this-&gt;dbConnection()` or whatever needs to be injected. &gt; Your interface will fall apart also because your mocks will have a different method signature to your concretes I don't see how this would happen from implementing what's in the article? Care to explain?
* PHP CodeSniffer will help a LOT in the early stages. It can find style issues in the code base, and fix some of them, helping make it easier to read * If it doesn't have migrations, set them up ASAP. Phinx is a good solid standalone migration library * The sooner you can shoehorn Composer in, the better.
Hey! Comparing with other frameworks Yii is not so popular. But I can say that yes is the best. I read some useful info on the [page](https://mobilunity.com/blog/hire-yii-developer/) about Yii benefits and use cases. According to the article we can see the popularity of Yii is growing so fast. Even the name of framework means ‘simple and evolutionary’.
More on this https://12factor.net/dev-prod-parity
It does require a log in. On the front end you can register for an account but the majority of the application requires you to be logged in.
It's in everyone's interest to settle on one way of setting up their local development environment (by which I don't mean their IDE but rather strictly software-related aspects like PHP version, database setup and all of that jazz) to reduce redundancy instead of coming up with their own solutions for no good reasons. I would even go as far as argue that, for example, Docker vs. Vagrant is not a real discussion since Docker is clearly superior, at least from my point of view and my perception of where the industry is moving. However, I am just some guy on the internet, so maybe come together with people at your company and discuss why Docker or why Vagrant may be better suited for you and then set up one common solution for everyone. It kind of reminds me of that time when Git was relatively new and some people still "preferred" SVN even though Git is clearly the better tool and now practically no one uses SVN anymore, I assume that's where Vagrant vs. Docker is headed long-term but others may see it differently.
&gt; never use unlink Wait... what's the reason for never using unlink? I haven't touched it in forever, but pretty sure that's what I used to clean up old CSVs belonging to www-data.
It removes files from the filesystem. I never have to do that directly.
Ok what Ill start doing is, organising the players by rating. This way I'll have an array of 18 players listed best to worst. Then I'll start by looping through the array by position, goalkeeper first. Put one on each team. Then defenders, one on each team. And so on. Then I'll do a check to see if there are any broken relationships and move players to the respective team with their linked players. Then final check to see if team averages are similar. Man, this is going to be a pain lol But dude, thanks for your help on this. Really appreciate it. 
Yea I suppose I was thinking that each dependency would explicitly call its requirements out in the method signature, rather than grab them from the container. So you'd have a service that looked like this: abstract class ServiceContainer { abstract protected function mailer(SmtpConfig $smtpConfig): Mailer; } So instead the signature is blank and all the dependencies are implicit and fetched within the method? I definitely prefer to have a container that is written in PHP like that, but I'd prefer to use a library that provides me with injection and automatic resolution of dependencies. I prefer dependencies to be explicit.
Is the wheel round finally?
First things first, segregate the site out. As everything is probably just in one directory which has full access to the internet, add a `/public` directory, put FastRoute in it, and manually map each route to its corresponding `/whatever.php` file: ``` $r-&gt;addRoute('GET', '/whatever.php', function() { require_once __DIR__ . '../whatever.php'; }); ``` Now that you have a base to work from, you can start to abstract logic upwards into sensible places. Find all pages which require authentication and put the rules into your Fastroute Router. This file will get pretty big at first, but you can refactor it out into Controller classes later. Whenever you're asked to add/update features, triple your initial estimate, and make sure the company is aware that you need to do this from a security standpoint to ensure there are no flaws in the application. If they're an EU company, mention GDPR and that should get you enough leverage to actually make this application better. Create a simple script to find all the instances of `require_once` in a project and find the files which are required the most. If these contain classes, abstract them out into your standard `/src` directory and switch the autoloader to use composer (which you've already done when you installed fastroute). Now you can just look for every `new YourClass` and put an import statement at the top, removing all the instances of `require_once` to that file. Don't fall into the trap of wanting to rewrite it all from scratch. That's going to be a much bigger project than you might think, remember this application will have been around for long enough to get a large amount of seemingly meaningless bug fixes, but this functionality might be important!
A local environment should not be dictated by the company because it makes no difference how you run the application locally as long as it works in production. The company should be dictating the test environments, staging environment, and CI processes but I see no reason why it would matter how a developer produces the results, just that the results are produced. I could see a Vagrant file or Docker file being maintained as a good solution to providing developers the option to run that, especially if the developer seems to be producing code that's failing tests, but it sounds like the real problem is an inconsistent test environment, or maybe just a lack of tests. 
No problem. Don't do it all at the same time. Wait to do the relationships part after you've finished with the scores and positions part. It'll be easier. &gt;This way I'll have an array of 18 players Use *collections* so you have at your disposal the methods that arrays don't have https://laravel.com/docs/5.8/collections P.S. what happens if there is only one goalie?
&gt;Don't fall into the trap of wanting to rewrite it all from scratch. Good advice. We programmers \*always\* underestimate. Don't rewrite the full app if you want to show progress the sooner the better. Also, you need to master the framework you're going to \*progressively\* move stuff to. It could be "your own framework" and I mean putting together any router, template engine, etc. that you choose just to "sanitize" the mess, as /u/tie_salter proposes. If you are really going to "eat the elephant" instead of a rewrite (which is worse), be prepared to make step after step. I've been there and had an "index-mvc.php" alongside the original "index.php" so the new stuff got the new front controller, for example. &amp;#x200B; If it helps, those were literally my notes for a big mess project, that was pretty the same you're describing: **PLAN AHEAD FOR PROGRESSIVE, SMALL CHANGES (Refactoring instead of a complete rewrite)** We’ll end having 3 status of \*working\* code, aiming for full refactored code (3) at some point in future. 1. **Old code (aka clusterfuck)** 1. php files echoing html / js / css at anytime... 2. no MVC pattern, old-style "include/require" mess 3. raw mysqli calls... 4. some forms → php process → Location header 2. **Partially refactored** 1. raw mysqli calls migrated to library calls → faster testing &amp; debugging 2. mysql queries are centralized on functions → improves change of data logic → move to “model” later 3. partial usage of \[template engine of choice\] → better separation of presentation chunks → must keep “menu” and layout aligned with full use of \[template engine of choice\] 3. **Completely refactored** 1. Full implementation of MVC pattern: controller → models → view 2. Use of URL routing, anything not a file/directory will be routed to a Controller 3. Use of classes → almost all libraries are classes, controller-loaded 4. Complete use of \[template engine of choice\] (layout + presentation chunks) \[...\] For the point 2.3 or 3.4, using ob\_start / ob\_get\_contents surrounding \*old\* HTML with @begin@ / @end@ tags for example, helped to get working mess forms/html into new, refactored layout templates, for example, until things can be completely refactored. Hope that helps. Progressive refactoring is also a big amount of work, but better than a complete rewrite. &amp;#x200B;
Looks like other people have given you some solid suggestions, so I'll just add on with a few specific things I wish I could have or would have done when I went through this. Create a /public directory, move everything in there, and then update your server config to point to that directory. This way, you can start to pull files that don't belong in public view up a level into somewhere more private. You can also start to `composer install` whatever you need and refactor the old code into more modern services that the old code could then start to use. Your priority should always be on improving and eventually migrating the pages that you get sent to work on as part of doing whatever it is that you're doing for the business, be it bug-fixes or new features. This way, the cost of cleaning up the mess is subsumed in the day-to-day. Once you've been at this for a little while and the effort has started to yield dividends on your time, mention to management that you've been cleaning up as you go, that it's saving you time and that you're now faster at doing things for them for it, and that this pattern of improvement will continue as the code gets better. This demonstrates the business case for why they should care about spending time on code quality. It's an investment in speed. It also does so once they have already saved net time on your efforts, so there shouldn't be any resistance. If you're intending to eventually strangle the old code with a framework, which I think you should, moving to /public sets you up to simply install the framework right underneath the old code. Your only real difficulty would be in updating the old index.php to not conflict with the framework's index.php. Since whatever.php would still be present, it wouldn't fall through the rewrite rules into the framework. Chip away at the old edifice as much as you can over time, simplifying at every turn, until you're able to justify moving a page fully into the framework. I'd hold off on modernizing much of the JavaScript until you've gotten the server-side cleaned up, aside from simply disentangling what's there from the markup into .js files.
Yeah, it definitely depends on the use case, and for most things we have cron jobs or something do it. I can't even remember where I used it, but for the specific task it seemed the best option. Just curious if there were any specific reason to never ever use it.
Nothing specific. We have a file manager built into our framework so never have to handle files directly.
This is another problem, id have to factor in singular positions. Maybe I could favour the better defenders to the team that don't have a goal keeper for example 2 good defenders on Team B whilst Team A have one defender and one goalkeeper or something. As for collections, that's exactly what I needed! Thanks for sending it over. I'll upgrade to the latest framework tonight, don't think there's any breaking changes tbh so should be fairly easy. Again, thank you. 
Am in this situation as well, albeit on a smaller scale. I put the new framework in front of the old app. Have your new framework handle all the requests and defer to the old app for the stuff that hasn't been rewritten yet. This allows you to go at your own pace and not risk breaking anything.
/u/dean_c it should be much better on mobile now. Thanks for the heads up
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I think the company should have a standard recommended way (that way people can help if something goes wrong or someone gets stuck), but if you devs want to vary from that it's up to them to make sure it's working, and they are pushing stable, tested code. 
&gt; Has anyone had to transition from a custom PHP while maintaining the old code? How did you do it? I have; so often that I wrote a book about it: [Modernizing Legacy Applications in PHP](https://leanpub.com/mlaphp). Your description sounds like exactly the kind of situation the book deals with.
Some good advice here, especially re the strangulation model, and putting some sort of email feature into the files so that you can check when/if they are actually being used. Although you could probably also do this by writing a little tool that compared the contents of a directory listing with the contents of an apache log file, to see which files were being called. One more thing. Use some sort of version control. Or take a full backup hourly. Or both. Because you're going to break stuff often, and you won't know how you did it.
That's a great advise when it's about performance and contained context 👍 Once experience of this I had was overuse of selecting only specific fields *which end up in models*. These models would then be passed around, *giving the impression* they are complete; but they weren't. This was a huge mistake so the following rules where enacted: * only select specific fields when in a contained context; such partially loaded models must not escape the designated used context * see rule #1 Basically partially loaded models would have to be confined for a user in a context and must not leak it, as this would just cause problems down the line. Just a story of experience, YMMV!
I once had an issue where code worked locally, but failed on the load-balanced servers. The issue was that the devs were storing session data on the hard drive, while the load balancer was spreading their requests across servers. So yes, the devs should care about those details. Even better if they can have those same setups in their local envs, so they can test and debug stuff like that.
Wish you would come back in 6-9 month and write about your experience :-)
I think it’s an interesting idea, but of course I see some issues :) When your application grows typically so does the amount of services. And so your container will grow unless you break it up in smaller files. And I’m struggling to find a nice solution for this without giving in on the idea of having no “magic” in your container. Another “issue” I see is the danger of adding to much logic in the container. Of course this should not happen, but there’s always that colleague that is tempted to take a shortcut :) Finally routing; if you change your container from a service locator based container to a method based container _and_ you want to keep the benefits described then you will most likely need to switch your route configuration to plain php as well. Luckily routes typically don’t reuse different routes so Traits might be a viable solution for this situation. As said I actually like the idea and I think I play a bit with it our application. I wouldn’t mind removing some steps from the build process.
I will try to remember. How does that remind me bot work?
RemindMe! 6 Months "feedback on my experience"
I will be messaging you on [**2019-09-04 19:37:18 UTC**](http://www.wolframalpha.com/input/?i=2019-09-04 19:37:18 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/PHP/comments/ax5zks/new_project_id_like_some_suggestion_from_you/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/PHP/comments/ax5zks/new_project_id_like_some_suggestion_from_you/]%0A%0ARemindMe! 6 Months ) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
&gt; Don't forget that almost every piece of tech we use on a daily basis is free and open source This guy clearly lives in the forest by himself, planting his own crops to survive.
To safely let the user format the some html.
I have no idea why they're doing a 4.0 version. It looks like CI and Laravel had an ugly baby, to be honest. Should have just let it die.
I'm not sure how you plan to easily deploy a load balanced set up in a local development environment, it sounds like this is something that you should catch in your testing environment. It's also a reason why you use abstraction, since a local environment could use a local file session driver and a production environment could use a redis driver, you also only have to change one file when you switch session drivers on production.
Poor RMs. Are we going to end up needing to do a GoFundMe to convince some poor soul to do it?
I prefer KISS: A minimum number of files, a minimum number of boilerplate and everything as plain as possible. For example, Magento, Magento is the example of a code that is not KISS. SOLID instead adds some arbitrary rules and some of them works but not don't. And DRY, it is possible to create a DRY-KISS project but usually DRY and SOLID are incompatible. 
I find it interesting that you spent all that time explaining why you won't use Laravel anymore, but you never once mentioned what you plan to move _to_. Are you using a different php framework? Going to CMS? Or perhaps a whole new language?
**In reality, developers/customers don't care about test coverage**. Test coverage finally is just a number. We don't want bugs and it is not the same. We could have a code with +80% test coverage but the code doesn't work correctly, it's non-intuitive and it's ugly if not slow. 
 &lt;ul&gt; &lt;?php foreach ($mad as $hell) : ?&gt; &lt;li&gt;&lt;?= $hell; ?&gt;&lt;/li&gt; &lt;?php endforeach; ?&gt; &lt;/ul&gt; Above is an example of what it will look like if I view source or look at it after I upload it to github. It will vary. That's just one snippet. I did not type it out like that. But that's how it's outputting when I upload it or even if I view it in my local workspace.
Thanks, I'll take a look. This is known to fix these kind of editor issues with PHP?
&gt; will lead to more maintainability but also to more files At some level, more code impacts the maintainability of the code. 
Awesome I will look into this.
What makes you think those load balanced servers weren't my test env? Yeah, I wasn't suggesting to set up load balancing locally (though you could probably work something out with docker-compose). But it's more that devs should care about these details. As much as the devs and I wanted the ideal you're preaching, we have to put up with the real world sometimes. Even with abstractions, you can still run into performance issues where one implementation performs significantly better than another under the given workload. Abstractions are helpful, but not a panacea.
What's complicated about it? http://example.com/&lt;controllerName&gt;/&lt;methodName&gt;/&lt;extraParams&gt; Seems pretty simple to me. And then they give you more control over it if you want to use your laravel-style routes as well: https://codeigniter4.github.io/userguide/incoming/routing.html#setting-your-own-routing-rules
This is nothing complicated, this is a pretty standard ZF-like routing system. It can get tricky/messy when it comes to customization, pattern-based matches/validation. Did you take a look at Symfony's documentation or just bitching here?
I think devs should care about the fact that an implementation can change and maybe the current implementation (if they have to build the driver themselves but often times this is already done in a package), but my point here was that implementations change, sometimes often. And often times in enterprise applications or large companies, the team deploying the app is not the same team developing the app, which is why abstractions can be important. Sure, if you're developing the redis session driver, you should have redis installed to test it, but in a team of 50 devs, do you really need all 50 to be running redis? The only time it's practical to have a similar environment in local and production environments is for small apps or at the very beginning when your application is confined to one system, beyond that, you're treating a symptom, instead of the root cause, the root cause of your problem was a session interface wasn't being used.
There are tests: $ git clone https://github.com/VKCOM/noverify $ find ./noverify/ -name "*_test.go" ./noverify/src/phpdoc/parser_test.go ./noverify/src/linter/lazy_test.go ./noverify/src/linter/basic_test.go ./noverify/src/linter/oop_test.go ./noverify/src/solver/solver_test.go Go programs don’t need as many tests files as PHP projects, because Go has strong typing, many of the bugs that you would find in a scripting environment _(JavaScript, Ruby, Python, PHP, etc)_ do not exists in Go. However, if you would like us to test something specific that’s not included in these files, please let us know and we will consider adding more.
This is the normal process for RM selection. There really isn't anything to see here. A call is put out for volunteers. 2 RMs are selected - this allows for less experienced people to come into the RM process and learn from those who have done it before as well as providing a backup in case anyone goes AFK for any reason. See, for example, the 7.3 RM selection thread: https://externals.io/message/102031
Is it possible to be logged in just clicking on a link? Stop that first.
The controller looked fine to me, and the routing, if looking at the controller page, was not the routing, but the router overriding if I'm not mistaken. The router should be in another part of the docs. 
I'm no expert on the tool but its author /u/tomas_votruba use reddit sometimes. Maybe he will be able to respond to your use case &amp;#x200B;
Thanks for the positive comments! :)
Glad it was of help. If you build with modularity in mind you can always switch to microservices later on. It will be an investment, but considering it now will make it a smaller one. Although if you get to the point you need that investment it's not just you anymore, so there'll be more resources too.
Not super appropriate still means it's still appropriate, but not in a super kind of way ;)
&gt; The only time it's practical to have a similar environment in local and production environments is for small apps or at the very beginning when your application is confined to one system Having worked for a fortune 500 company, I have to disagree with that. We did a pretty good job of replicating the prod env locally on that project. Even without docker/vagrant, it wasn't all that hard. The differences were load balancing and the OS, so aside from the odd case-sensitive filename issue, it worked pretty well. This wasn't the previous project I mentioned with the session issue. I like your ideas, but I don't think they're always realistic. You say the real problem is that a session interface wasn't being used. But in my experience, the real root problem is usually that the cost of refactoring the code to allow for session interfaces is considered too high. Sometimes they're even right about that.
&gt; 2.) No clean URLs. Everything goes to /whatever.php Why is this an issue?
Your CTO should be responsible for making sure your devs follow company practices for development, including local setup, coding standards, git workflow etc. Everyone needs to play from the same rule book. IDEs, text editors, terminals etc can be personalised.
I had a very similar experience. I used to use [my own handwritten container](https://github.com/tarantool-php/jobserver/tree/902c1245d8860882e33c567dce3f65ed5d689f58/src/Di) but found that it works well only for small size projects and eventually switched to using Symfony DI.
After a quick glance, I'm not a fan of the _remap function, as that should be handled by the router and is mixing up the logic. router.php: Route::connect('/myCustomRoute', [controller =&gt; 'Test', 'method' =&gt; 'test_method']);
Opening a new connection for every container seems a bit antithetical to DRY principals. I appreciate that we're still "injecting" a configuration for the DSN to make it easy, but it seems like adding LOC and required testing for little gain over the alternative. Just my 2 cents.
Hey. It sounds like you're trying to to individually recompile the FTP extension, or make another extension that hooks on top of that. You might have an easier time if you compile PHP as a whole and edit the FTP extension within the codebase, rather than trying to build a separate library.
https://github.com/bigcodrob/Stoyez-Chat-PHP/tree/V1.1
Ask Tim: tecreations.ca
What I would suggest is using phpcs and get a compatibility checker to verify what you have to fix for 5.2 compatibility. Based on the amount of code that is problematic that will give you an idea of how big this task is. I would suggest avoiding to add features or fix major issues. If they really want you to fix major issues or add features, suggest a rewrite of the website and then give a high time estimate for the tasks. Justify the high estimate for work to be done by the state of their codebase. You have to be honest with them and explain to them that their codebase is in bad shape and that it will likely be hard to maintain due to that. There is not much else you can do than be straightforward to cover yourself.
Must we protect our IP/ both ways at least so I have security that I already said to it.! Yet, you don’t want to think like tim.
I'd recommend you to check phpixie.com, it's a great framework, has a great orm module and supports mvc pattern. Also includes templates support, routing, security, and a lot of common utility libraries, and supports adding extra via composer. 
Go your way then. I point to Christ. Then tanya donnelly, then Tim./ tecreations.ca Tim here ready for ai
A-are you the original coder..?
Usability probably, maybe no routing.
Wut..?
WTF!
Sorry i just got around to read this and it makes a lot of sense. I think I have an idea how I would do this on the current system. I appreciate the advice!
Lulz
This is wonderful advice and i can picture what to do with this advice. I will probably use something like slim for the fast router.
This sounds exactly like the code base I am working on. Your advice is much appreciated.
Its an issue just because it demonstrates no front routing. Each route is pointed to a specific php file in a specific directory which ended up with hundreds of /whatever.php in various directories throughout. Makes it a nightmare to maintain because each file then has its own includeds / requires and spaghetti code of html/php/js. 
&gt; Don't fall into the trap of wanting to rewrite it all from scratch. That's going to be a much bigger project than you might think, somebody tell my workplace. Spent the last 9 months making 70% of a site with Modern Framework A, but since we're a little behind schedule (not because of coders, but because all the requirements and design assets and data imports and third party API endpoint dependencies have been late), now some new bloke has come in to 'rescue' it and declared we should rewrite from scratch in Modern Framework B. Bizarrely he has managed to convince management we can do a total rewrite in a framework we don't know, quicker than finishing the job in the one we do know. Needless to say I have transferred my efforts into job hunting
You don’t want to protect your digital assets? Code, designs, implementations, You don’t want to get paid for your work? I do!
Yeah I totally disagree with this. When you on board new developers it's your duty as a team to provide the new team mate with the tools to be successful. Throwing them to the wolves is not the correct way to on board. &amp;#x200B; Any good team will have standards and best practices including standardized tool sets. When you choose a technology for local development and standardize on this then you can provide guidance for anyone new to the team. Team members can help each other out. When everyone is using something different its every one for themselves. 
Thanks for the ping. Rector handles anything that can be written in PHP 5.3+ syntax and in diff format (before/after). To get the idea what Rector can do, just check all Rectors: https://github.com/rectorphp/rector/blob/master/docs/AllRectorsOverview.md
Just create an issue there and I'll try to help you: https://github.com/rectorphp/rector/issues 
Well normally VSCode lets you set Spaces or Tabs per project or per file. You're not really supposed to use tabs and spaces in the same file but generally the editor should convert tabs to spaces if you set it use spaces. There's no real way to convert spaces to tabs unless they are all perfectly aligned. EditorConfig basically lets you set rules per file type so for PHP and JS you can set one rule set and for HTML you can set another if you so choose.
You mean me? It's more like everyone else is eating the neighbours and it's poisoning the village.
Lol Magento is Enterprise level, do you know what that word means? If Magento is too high of a burden, it's because it's overkill for almost all small businesses and your client probably just picked the first thing when they googled "best e-commerce PHP". Idiot.
Is impossible, can confirm. Might as well just print out the website and start from there
I'm our company's senior programmer. The bossman is looking to hire someone to handle some of our smaller projects. It's a pity you don't live in the United States because we'd hire you in a heartbeat. You're not experienced enough to be stubborn/arrogant, and you're not green enough to be clueless. You learn fast and take advice. Sheesh I wish we could find someone like you here in the United States.
Which might implement psr-18 and at that point we are full circle :) Source: https://github.com/guzzle/guzzle/issues/2186
I'll give it a look, thanks!
Pretty sure there are tons of plugins out there to manage and fill up these quirks. 
Nothing new here. That's just writing factories.
Watch out for 10'th issue that is log files and/or other temp files inside codebase. Use some dir analysis tools to find suspiciously large folders and suspiciously large files.
Just use E-Mail then. Don't overcomplicate.
That's what the Strangulation Pattern tries to avoid. You re-write the bits you're working on, not the whole thing in one go. You system stays opperational.
&gt;I would even go as far as argue that, for example, Docker vs. Vagrant is not a real discussion since Docker is clearly superior, at least from my point of view and my perception of where the industry is moving. Like any tool, there's usecases where Docker makes sense and usecases where Vagrant makes sense. They have different aims and objectives. &amp;#x200B; Git vs SVN is different, as Git encompasses all that SVN can do, but does more and does it better. (Eg, you can check out a git repo, go offline and work in it locally, and then push when you're back online. You can't do that in SVN).
Copying [Matthias Noback's reply](https://matthiasnoback.nl/2019/03/hand-written-service-containers/#comment-4364667718) from the article here for anyone who was interested: &gt;Thanks for mentioning this here; I have no experience with the Laravel DI container, but based on what you write about it here, I think this solves a significant number of the usual issues. Looking at the docs now, I still think the indirection of the configuration isn't necessary (well, it is, because it supports auto-wiring), but at least it doesn't leave too many aspects of the configuration implicit.
That’s absolute rubbish. It’s almost like you consist SRP and code abstraction to be an irrelevant distraction. What I’m sure you are aware of, but perhaps briefly forgot during an unfortunate brain fart, is that SRP stops developers creating monstrous, unmaintainable god classes that do everything.
I actually ran into performance problems with doctrine. It was 2015 and we were building a site using some bundles, and we ended up with over 500 doctrine objects from various queries (ballpark 50-150 queries, two dozen types of different entities). The time to execute the SQL was an order of magnitude lower than the time needed to hydrate the objects. I ended up switching ORM to arrays and simple Value Objects. Maybe the database was much faster than the CPUs I had in that environment (it was a staging env pre-launch), but the fact remains, that Doctrine was the bottleneck. I agree with the overall advice — don’t be afraid to use an ORM and optimize when needed. 
Why not just throw the whole thing out?
Hi, I´m looking for some feedback for my framework inferno. I looked into many frameworks to learn more. Currently there are no tests or documentation. you can find a demo repository here: [https://github.com/infernophp/demo](https://github.com/infernophp/demo) &amp;#x200B; It requires php 7.2, has bugs ;-) and is not feature complete. It´s just on an early stage. Thank you! &amp;#x200B; Regards Carpenter
Add some whitespaces between functions. 
what is the purpose of this project? Is it a learning exercise or are you building something you think people will use? If so what is different about your framework compared with more established projects like Symfony and Laravel?
I've use Clickatell before (years ago) and they were quite good. &amp;#x200B; [https://www.clickatell.com/](https://www.clickatell.com/)
[https://jmsyst.com/libs/serializer](https://jmsyst.com/libs/serializer)
Use [api-platform](https://api-platform.com/). It's based on symfony, has all you need.
You think so? Acording to https://w3techs.com/technologies/details/pl-php/all/all 70% of all PHP sites are on PHP 5, and they just don't give a shit) It's epithomy of "if it's works don't touch it".
You guys really think all PHP in the world now is 7+? Half of internet works on PHP 5. Do you really think that much people upgrade their php on production servers?
It's cool to see it uses strict type! I always like the projects what try to make a step away from the Symfony flock and take challenges. Some PHP unit test with travis ci would be nice. The demo repo could contain a much more detailed description about the framework.
No problem, I can see me in your shoes back then
I'm not sure if you read the 2nd paragraph, but docker and/or vagrant files can (and should) be provided, but they shouldn't be dictated. There's a difference between providing support for new devs and forcing all devs, especially senior devs, to use the same setup.
That seems like quite a bit of effort and downsides to accomplish a similar result as [Upsource](https://www.jetbrains.com/upsource/), a product JetBrains made specifically for having Code Inspections in your CI process. Except Upsource also has a tonne of other really useful features like being able to browse and review the code in your browser *with those inspections showing*. Or having an easier time reviewing PR's from PHPStorm.
I think my point more was that the RM role is one that people seem reluctant to take, and although I don't have an immediate quote to it, I seem to remember that the RM position has been brought up when discussing ways of directly funding PHP development. 
Use user groups permissions on the server? I'm sure I cannot access other people's home directory unless I'm root user. Encrypting the secret keys/passwords are useless imho.
Does composer PSR-4 autoloading really need an entire blog post?
How would this translate to Windows? The client is exclusively Microsoft-based. I think in Windows a server admin would be able to view any user's folder, woludn't they?
Try Git Crypt: https://github.com/AGWA/git-crypt &gt; Where git-crypt really shines is where most of your repository is public, but you have a few files (perhaps private keys named *.key, or a file with API credentials) which you need to encrypt.
Root/admin user has all the rights to view everything so no there is no way to completely hide away what you are trying to do/decrypt. You can only make it slightly difficult but impossible to avoid it. There are a few obfuscation application out there like the good old ioncube but it's a little bit overkill.
I did try that at one point, but that's when I was getting compiler errors and whatnot. I think I'll try again with what knowledge I have now, but also, I'm still curious to know if it's possible to hook into that extension's functionality in a separate extension, since I may open source the finished result.
This sounds neat but in the description it says it hasn't reached maturity and I know the client won't go for that. But even if the client did, would the PHP code be able to read this file and pull out a value and use it? Like an LDAP password, for example? Because the description sounds like it's just so you can store sensitive data in your Git repos, which is not the aim here.
Looks like you have worked so hard for this, congrats! But I have difficulties to understand how did you produced so much codes without testing haha Anyway with a good README you might answer folks questions "what is the advantage of inferno over Lara or Symfony" :) cheers
&gt; Lol Magento is Enterprise level, do you know what that word means? Yes, and I've implemented more Enterprise level projects than you can probably count. That said, the open source version is very much not Enterprise level. &gt; If Magento is too high of a burden, it's because it's overkill for almost all small businesses and your client probably just picked the first thing when they googled "best e-commerce PHP" If running an open source Magento shop is too hard for you, you don't belong running your own e-commerce store. The burdens of security and maintenance will be well beyond your ability. &gt; Idiot. Stay classy. 
TTD is not the only development paradigm...
If you're getting undefined symbol errors in linking when you've added new C files, it's because the build system isn't building them. grep in the ftp extensions directory for the name of an existing C file in the extension and you'll find what needs updating. As for having a separate extension, I think it would be difficult to do but don't know off the top of my head. If it's something of general utility you could open a pull request and possibly get it merged into mainline PHP.
If you don't demand TDD from a developer of a framework you are going to use you act irresponsible.
&gt;They want to do this to allow us access to the stage server. Currently the stage server uses certain passwords and API keys that we are not privy to. If you have access to the application on the staging server that consumes these credentials along with the files containing the credentials, there is no feasible way to perfectly secure these credentials from you. The application must be able to decrypt or receive the credentials in some manner and if you can access the application code you would be able to see how this is done. If you don't need access to the application that consumes these credentials, is there a particular reason you need admin access to the server, rather than just a separate user account that cannot access the application or credentials?
Based on some of the edits; user/permissions would also likely be enough here. As long as the people logging in can't read the files (permissioned to the webserver user) then that might be good enough. ---- The longer answer to this is no, it's not entirely possible. When you get right down to it, the server needs to be able to autonomously access these values and use them (ie; to do it's freaking job, like connect to the database). There are _absolutely_ things you can do to mitigate this risk, however. Hashicorp Vault, for instance, has a very smart setup specifically for a mysql database. In short, you give the server a token, the server uses the token to ask Vault for a username/password to the database. Your policies and permissions on Vault (a different server) will go and **create a new mysql account** and return those credentials. It will also track the TTL for the account and automatically kill it if the TTL expires or the token is not refreshed (all highly configurable). In this fashion there is no permanent user/pass on the machines so any compromise has a limited window of opportunity. You can assign particular tokens to a particular machine (if that has value for you) and control the ACL's off of the "publicly exposed" machines. As noted in the opening, though, none of this is fool-proof because you want the system to be automated. It's plainly unreasonable to expect a human person to type in credentials every time you application needs to connect to the database, so the machine must have a way to get at these credentials automatically. And if the machine can do it automatically, a compromised machine can do so as well. --- Alternatively, you could use a secondary server to run the API operations. For example, imagine you are trying to hit GitHub.com from your application. They require some a token in the header, `X-Github-Token`. Normally you'd toss that in your application and use it directly. With a proxy, you instead skip that part and route your request through the proxy server. The proxy server simply passes this request along, but injects the token header. In this fashion, the proxy is very "light weight", but it also hides the token since it's then never present on the application server you're talking about. This of course, has a fuuuuuuuck-ton of nuances to it (can it even work in certain scenarios, added layers of complexity, is the error from github vs. your proxy, can you use a generic purpose proxy or do you have to develop your own whole app thing, etc, etc, etc). 
Yeah you are right. They can't 100% stop us from getting the credentials if we have access because we could simply echo the values or log them to a random file. We've brought this to the attention of the client and waiting to hear more. Typically they give us "access" by either RDP or a network share than we can map (or both). I've asked which they intend but have not heard back yet. We don't really need access to the server. They haven't really told us why but I suspect it's because product owners don't like how slow the platform owners are when approving and deploying code and want us to be able to do it as well. That's my guess anyway.
Cool. Sorry, it wasn't apparent there were tests when I quickly had a look.
My team maintains a new web applications whose architecture is a typical product of the kind of well-willing amateur that chooses PHP in the first place. Couple of things. First, of all, even if the code looks like a big ball of mud, there are often patterns in the code that may not be obvious at first. For example, we have a lot of stuff where they would just randomly include other PHP files inside a function. These kinds of patterns are often a function of the original author's ignorance or misunderstanding of the tools available to them. *Don't try to fix these!* Patterns, even terrible anti-patterns, will help you reason about how the code works, and allow you to make some assumptions about where to find things. If you try and fix them, it's unlikely you will fix them everywhere, and then you're left with a mix of two different patterns, which is an even bigger mess. Second, in your heart of hearts accept that the code is bad. Don't go around and try to re-architect or re-write big parts unless you really, really, *really* have to. That's not what you're being paid to do. Even things that are disorganized but functional are still valuable to your customer. They don't care that half the code is tab-indented and the other half has spaces. Since the code is bad and does not have tests, doing major re-architecture work will only introduce bugs and you will produce negative value for your customer. Third, *write tests*. Start with end-to-end integration tests, using something like Selenium if you have to, and add tests for each new feature you add or bug you fix. This is to prove to yourself and your customer that the work you are doing is complete and delivered. If you are worried that a piece of code you're touching could break other things, add some basic tests first, before you make the change, and verify they still pass after. When you fix a bug, first write a test that reproduces the bug, then fix the bug, not the other way around. Finally, add documentation for the next poor sob that is going to be in that code base. It doesn't have to take much of your time, just a couple of comments here or there in the code explaining some wild contraption or poorly named function is already a huge help. Good luck out there! :)
Does Upsource have PHP inspection? My understanding was it was Java.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Wasted a lot of time on this not knowing what the heck was going on
In addition to HashiCorp's Vault there's also CyberArk's password vault. CyberArk can also rotate passwords for you etc, so fairly similar in that regard.
Storing a password in a file on the server is bad no matter how you do it. It makes things like password rotation difficult.
What is psalm
It’s a static analysis tool for PHP: https://github.com/vimeo/psalm. Try it online here: https://psalm.dev
Yes. I introduced Upsource at work and it definitely performs inspections on PHP code. (Subject to the same `.idea/` folder behaviour as the original article says, so for best results, you'll need to keep certain parts of your `.idea/` in version control.)
Does it also support inspections introduced by plugins? Thanks
Seen that, you need to send em as integers. Sux
Last time I checked, the answer was "no".
Thank your for your feedback. /u/WArslett Initially, I created it to learn something. I hope someday people will like it and create something with it. For now it is a far way until it is stable and tested enough to use it in production. What\`s the real difference between Laravel and Symfony? Using Doctrine instead of Eloquent etc. Ok. I think at the end for the most people it is just a pesonal preference. But that's not the question or the discussion I want to have now. /u/btcMike Could you specify that? Where should I add some whitespaces? /u/khalyomede, /u/cyrusol I agree. At the end there should be tests and documentation. I will work on that. &amp;#x200B;
/u/orklah /u/DCoder1337 The answer officially is "no", but in reality, yes. You can basically just put the plugin files in the right folder and [you can use most plugins](https://youtrack.jetbrains.com/issue/UP-9148). Even more interestingly, you can do this to enable inspections for even more languages than Upsource supports. Something that the developers seemed surprised to find out. I meant to do an article on it a year or so ago, but got lazy and didn't
Hey 👋 not a maintainer, but product manager / designer on Gitstore (are we even allowed here?)Here to help and answer questions about the product and the concept of paying OS maintainers, selling code as a product itself. 
Silent Failure (Anathema new album)
Cool, I'll have to check that out. Thanks.
This is pretty cool! I know there are similar efforts going on with [deco.network](https://deco.network), but more in the blockchain space. So essentially you are providing access to source code. What are your requirements for participants? Do you limit to Open Source projects only? By participating, doesn't it essentially qualify the code as closed source? Do you have any existing projects using your services? &amp;#x200B; I'm the founder of [CodeFund.app](https://CodeFund.app). As such, I'm a huge fan of any effort to help fund and sustain open source. I do believe that developers should be able to charge for their code in many different ways. I truly hope this project takes off!
It's a nice one. I found nothing seriously wrong on the first glance (15 min). &amp;#x200B; Your config... Maybe do some nesting instead of using big comments? ;) Your twigs share code (like loading jQuery) - you can do better here. Maybe get some webpack\_encore running and stop loading from external sources?
Lots of great questions! - Participants require a GitHub account, at least 1 repo with at least 1 tagged release, and a Stripe account. We currently have an opt-in work-around for the Stripe account part of it. That's all. - There's a subtle difference between open source and free, which comes down to the license the repo is published with. If the license says it can only be used with subscription then it's not open source. The alternative is that open source (and free) repos can still be funded through Gitstore, via donations. The setup process is no different from close source, in this regard. - We have some maintainers over at [enjoy.gitstore.app/maintainers](https://enjoy.gitstore.app/maintainers), some of whom have already started raising funds. Most of the repos there are open source and free, so the funding is more like a donation than it is a subscription access. Thanks, also, for your encouraging words. :D
Any idea how easy/hard this could be fixed ? Seems weird that it had been ignored for such a long time.
It's very hard to get high quality test code without TDD though.
I think this is not a bug in PHP. The problem with the code example is that the database has nothing to update. The first record contains the same data as the update data. [https://3v4l.org/21tR1](https://3v4l.org/21tR1) &amp;#x200B; As soon as we change the data, the update works. [https://3v4l.org/XAvnb](https://3v4l.org/XAvnb) &amp;#x200B;
Try it with MySQL instead of SQLite
True, but if we have set the correct PDO settings it will work with MySQL too. Just set \`PDO::*ATTR\_EMULATE\_PREPARES* =&gt; **true**,\` and you will see it :-)
That is one possible work around however there are other design considerations that might make it a nonviable solution for some people. Details here https://phpdelusions.net/pdo#emulation
And it's really good. Much better than any others I've tried. If you aren't using it you should give it a shot. The other PHP static analysis tools I've tried mostly find violations of whitespace opinions. Psalm will find actual problems with your code. I've heard good things about phpstan, but I couldn't get it to work so psalm is my faves.
Hey, co-founder of Deco.Network here. We are now focusing on a freelance marketplace, so the GitStore-esque functionality that we had was removed. GitStore looks really neat!
BTBV1R0CZR-eyJsaWNlbnNlSWQiOiJCVEJWMVIwQ1pSIiwibGljZW5zZWVOYW1lIjoiTXVzaGZpcXVyIFJhaG1hbiIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiJGb3IgZWR1Y2F0aW9uYWwgdXNlIG9ubHkiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDIwLTAyLTA1In0seyJjb2RlIjoiQUMiLCJwYWlkVXBUbyI6IjIwMjAtMDItMDUifSx7ImNvZGUiOiJEUE4iLCJwYWlkVXBUbyI6IjIwMjAtMDItMDUifSx7ImNvZGUiOiJQUyIsInBhaWRVcFRvIjoiMjAyMC0wMi0wNSJ9LHsiY29kZSI6IkdPIiwicGFpZFVwVG8iOiIyMDIwLTAyLTA1In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwMjAtMDItMDUifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAyMC0wMi0wNSJ9LHsiY29kZSI6IlJTMCIsInBhaWRVcFRvIjoiMjAyMC0wMi0wNSJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDIwLTAyLTA1In0seyJjb2RlIjoiUkQiLCJwYWlkVXBUbyI6IjIwMjAtMDItMDUifSx7ImNvZGUiOiJQQyIsInBhaWRVcFRvIjoiMjAyMC0wMi0wNSJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDIwLTAyLTA1In0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwMjAtMDItMDUifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjAyMC0wMi0wNSJ9LHsiY29kZSI6IkRDIiwicGFpZFVwVG8iOiIyMDIwLTAyLTA1In0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDIwLTAyLTA1In1dLCJoYXNoIjoiMTE4Nzc1NzkvMCIsImdyYWNlUGVyaW9kRGF5cyI6MCwiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-YaS2iTRlTq7158ZKFQJLh9Tq5j3KAsprefqL7tMZiheg9YzxvZExk+Q8A761NCNk/V4WjdSnSzkidvPAjH0MaKbMvJpw/vddGb9j1kp9NUCpR+zXge1dfHyAQLJySFn0TVZcq+M1duDHYl1lAzP4gFc9Eo8t0Pw/Ll0wZ06xT5KIdyjSi+gHsfYbkzRgzXR5JZcKzz7ArBnUPzd9bZgKE46Y/XBQcvZ4QAY5HjtyMlvgtkh+uuKNtJcUraqGy91C1bo3rY3qOWDfGGLvMdvHF6eY+wx5cTVu4siXtJWO153/vtGctlKXpTqsu/RcymGa2xeN+8lLy51bCnrELeqM0A==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow== For more please visit [PHPStorm Keys](https://ayehaye.com)
It really is a matter of properly setting up your data base connection... &amp;#x200B; That article is borderline misinformation. Or to better phrase is points people to the wrong thing imo.
Your key if "For educational use only" and belongs to Mushfiqur Rahman. Please don't post spam like this in here.
Other people can use this key if they don't have.
Exakat has version by version compatilibity checks for 8 frameworks at the moment. It scans the code for classes, interfaces and traits that are not available from one version to the next. That is very helpful when migrating. 
For what exactly did he need to provide arguments? It's not like you brought up any.
Is '13 years old' a legal object name?
Something like this is what I’ve always wanted. However, from their docs and videos I get the impression that the tools integration with CI systems is the other way around where CI would report to upsource about build status whereas I and the original article want the build to fail if phpstorm inspections find issues in commited lines. Can upsource be used that way? Can you point to some docs how I would set this up?
I mean... if it raises awareness about that these things exist the post fulfills a purpose. I've seen quite a lot projects that still employ requires all over the place or ship their own autoloading.
I guess. Just the way it is written comes off as a bit blog-spammy
Looks great!
You should really not look for obfuscation technique but for how to achieve filesystem security.
Why not use an ant/phing script in Jenkins to run PHP Codesniffer, Mess Detector etc? This seems very long winded.
That's a good point, and a use-case I hadn't considered. As far as I can see, you're right, it only integrates one way. Upsource is meant to be where you perform your reviews, so rather than it acting as a CI server that throws an error, it will show a red mark next to branches that have failed inspections. It looks like the answer to that specific problem *should* be TeamCity, but TeamCity doesn't support any PHP Inspections out of the box. I wonder if it would be possible to install PHP Inspections as a plugin the same way you can with Upsource, but I don't know... It looks like you're right though, I misunderstood the use-case that the article was going for, and I don't think Upsource supports that
is it really open source anymore if you are charging for access?
I give a longer explanation elsewhere, but... 1. Open source !== free, it depends on the license. 2. Even if open source and free, you can still accept donation-like funding on Gitstore.
I've seen projects use Bountysource for this as well. Are you familiar with it? If so, what are the major differences that gitstore.app offers? https://salt.bountysource.com/
PDO was a pet project that should have never been added to the language. It is not supported and should not be used.
That's funny cause every time I show my framework which does not use PDO binds people complain.
JSON parser... json_decode()? :/
It's only my opinion, and worth exactly what you paid for it. The concepts are strong, it was just a pet project that has lost its maintainer.
Hey! You might want to adjust your pricing grid copy. It doesn't quite scan: &gt; For established high volume businesses &gt; Gitstore offers affordable &gt; - Custom pricing &gt; - No repo or subscriber limits &gt; - Includes all features
You're a filthy, snivelling, vile and disgusting """""""""""""""REDDITOR""""""""""""""".
LOL. Linux was a pet project The web was a pet project The fucking airplane was a pet project 
A json parser with comments . . . . and trailing commas
Whomsoever starred this should just delete their GitHub account.
CodeIgniter was homemade.
Thus is the framework paradox. 1. Know nothing, attempt to write a your framework, learn something. 2. Know something, do not attempt to write any frameworks, learn to use them. 3. Know ~~everything~~ why current frameworks are incomplete or unfit and know enough to solve it, actually do improve an existing or write a new framework.
I can only presume you mean, *PhpStorm*. Don't worry, I don't expect a """""""""""REDDITOR""""""""""" to pay attention to detail, since programmers don't need to pay attention to details, but you would do yourself and everyone else a disservice not to pay attention henceforth.
https://externals.io/message/104590
There are two recommended ways. A not recommended way is to just set up your local machine as a server. There needs to be some virtualisation involved. 1. Vagrant/VMs. Using Virtual Machines is a great way to serve local dev enviroments. Vagrant/ansible makes it configurable so you can ensure every developer is using the same VM setup. The downside is if you have hundreds of clients then maintaining and managing that many VM's is incredibly unwieldy as well as resource intensive and you will always end up just having one Main VM setup that you use for every project. This is good if your only goal is to make sure every dev is using the same local environment. But it is bad if your many projects use different versions of things, or have different hosting setups required to run. Which is generally the case. 2. This is why Containers are becoming more and more used. Docker being the leading implementation of this by a ridiculously very large margin. Containers allow you to have a different dev environment configuration for every project. And they are very light weight so will take very few resources to run and can be booted up and destroyed very quickly. Storing the hosting requirements as a docker config file in your projects git repo is a convenience that you have to experience to believe. Its just so much easier to keep organised and to make sure dev environments are the same as production. I read in this thread that you have 200 projects on the go. Option 2 would be the recommended route for your company. But depending on how homogeneous your production environments are you could maybe settle for Option 1. Important to note that containers require Windows Pro so there is that added expense if that matters. The important thing is the host dev machine your developers use can be whatever they want. It is important to give developers freedom in this regard. Operating systems, IDE's, text editors and other software are very much personal preference and allowing developers that freedom to choose is important for morale. The options listed above give the company control over dev environments that is actually needed without infringing on developers freedoms.
I synced my GitHub, but only two repositories have appeared in my dashboard. Any idea where the rest are? All my repos are public and nothing strange should be going on.
What do you use?
mysqli :\^)
While I certainly understand the desire for consistency, I think, perhaps, that this RFC seeks to do so in the opposite way to what makes most sense in the long run. IMHO it would be much better for the long-term health of the ecosystem to tighten up the definition of numeric as much as is practical, rather than expanding it. To that end I would be in favour of denying implicit conversion for any string that contained either trailing or leading whitespace, or any other character which was not part of the accepted numeric set (including exponents, decimals and 0x). I'd certainly like to see a "stricter numeric conversions" RFC go up against a vote first. My rationale is simple, the stricter such things are, the more confidence I can have, over time, that both my own code and third party packages will be less vulnerable to either accidental or malicious manipulation of the parsing and implicit conversion process.
It’s a weird song prayer Catholics sing
you forgot to escape something. or did you?
Have you tagged releases for all of them? That's the most common solve
I don't really get the point &lt;?php $total = 0; foreach (file("numbers.txt") as $number) { $total += trim($number); } seems to me a legit solution to the problem. 
Going by their [FAQ copy](https://github.com/bountysource/core/wiki/Salt-Frequently-Asked-Questions): - There's no minimum charge to customers. They can spend as little as $1 at the time, and there's not account credit to make up a minimum charge on their account. - We don't touch the money people pay you. BountySource takes a 10% minimum from the payouts you request. The only person you pay a per-transaction fee to is Stripe. - It doesn't look like BountySource deals with the concept of selling access to private repos, either. That's something Gitstore does well. - Gitstore also provides embeddable purchase/donation flows, so people can give you money on your own site.
Oh hell no... we have plenty of magic in the language which is slowly being killed. Any implicit conversions should be eventually eliminated. We already have a way to do what you’re asking for explicitly- it’s the trim() you mentioned. 👎 from me.
&gt; I honestly don’t have to say anything, anyone reading your thoughts on the subject will be horrified to work with your code and the way you abuse SOLID. I'd be willing to bet that the only thing anyone's likely to find horrifying here is your growing immaturity with each subsequent reply. &gt; "SOLID is very simple, just do exactly as I believe and say, everything else is a violation that makes you a bad and naive programmer" is not a productive approach to software architecture. This is a blatant strawman. &gt; It's a social powergrab, you want to sound like an authority by latching onto SOLID and declaring any different opinions to yours as "violations". I have no need for whatever you think a "social powergrab" is in this context, nor do I have any intention of "sounding like an authority" by explaining how several of the SOLID principles are objective in their applications. &gt; It's especially egregious since, again, you don't even understand what ISP is about. It doesn't matter how long you explain it, splitting an implementation is absolutely unnecessary for ISP. I never said splitting the implementation was necessary for ISP (quite the opposite, in fact - see my previous reply where I pointed out that `GoogleGeocodingThing implements Geocoder, ReverseGeocoder` would be ISP-compliant). You've misinterpreted something, somewhere. &gt; First, ISP suggests nothing of the sort. "A client will not be forced to depend on methods it doesn't use". A and X were being forced to depend on methods from `GeocodingThing` that they did not use. Thus, the code ended up looking something like this in the ISP-violating case: interface GeocodingThing { public function geocode(...); public function reverseGeocode(...); } class GoogleGeocodingThing implements GeocodingThing { ... } class A { public function geocodeSomething(GeocodingThing ...) { ... } } class X { public function reverseGeocodeSomething(GeocodingThing ...) { ... } } ...and this in the ISP-adhering case: interface Geocoder { public function geocode(...); } interface ReverseGeocoder { public function reverseGeocode(...); } class GoogleGeocoder implements Geocoder { ... } class GoogleReverseGeocoder implements ReverseGeocoder { ... } class A { public function geocodeSomething(Geocoder ...) { ... } } class X { public function reverseGeocodeSomething(ReverseGeocoder ...) { ... } } ...and this in your favorite "you don't have to split the implementation" ISP-adhering-but-SRP-violating case: interface Geocoder { public function geocode(...); } interface ReverseGeocoder { public function reverseGeocode(...); } class GoogleGeocodingThing implements Geocoder, ReverseGeocoder { ... } class A { public function geocodeSomething(Geocoder ...) { ... } } class X { public function reverseGeocodeSomething(ReverseGeocoder ...) { ... } } &gt; Second, LSP says you can't have special treatment for subtypes (which implementations are for their interface). This has no relation to anything I've said. &gt; Third, DIP says you depend on abstractions (interfaces) not on implementations. The example _does_ depend on abstractions and not on implementations.
Please don't do that, you're just begging to be hacked.
MySQL doesn't have bool
I thought you were 13
This blog post boils down to: "Read about how to do PSR-4 autoloading via Composer here: [https://getcomposer.org/doc/04-schema.md#psr-4](https://getcomposer.org/doc/04-schema.md#psr-4). By the way, it works with Slim Framework, too. Like mostly anything else."
Thanks for this advice.
So you have no idea what they are doing with 4.0, but you're saying it's obsolete.
What does it have to do with Slim Framework particularly? It just explains autoloading basics. and this &gt;I have the src folder in which I added the “classes” folder. ouch. You oughtn't to teach about autoloading and use 'classes' directory. The whole purpose of namespaces is diminished by this 'classes' dir. &amp;#x200B;
I don't have any Symfony experience, but it has been recommended a couple of times. Can you elaborate on why you think it would be good to learn for improving my PHP skills? Thanks a lot. 
Our eBook, "[PHP 7 Explained](https://php7explained.com/)", is currently available for just 10 EUR (because we are celebrating our tenth anniversary as a company).
[removed]
First file I looked at was vulnerable to SQL injection. Use prepared statements! Also, don't use md5 for hashing passwords, use `password_hash`
I only scanned your DB set up but you should look into relational data and foreign keys.
The pull request consists of adding two `case`s to a `switch` statement: https://github.com/php/php-src/pull/3921/files
 if(isset($_GET['profile_username'])) { $username = $_GET['profile_username']; $user_infos = mysqli_query($con, "SELECT * FROM users WHERE (username='$username')"); $user = mysqli_fetch_array($user_infos); $num_friends = (substr_count($user['friend_array'], ",")) - 1; } I'm just looking at profile.php and there are so much bad practices there * don't read user input that way, without sanitization and validation * don't use mysqli\_ functions and query build as concatenated strings, this leads to all sort of injections (and someone did it on the demo already) * long if-elseif blocks are unreadable/unmantainable * html and js code echoed inside a php file is not a thing in 2019. Learn a templating system like Twig &amp;#x200B; My suggestions: * learn about architectural and design patterns. Separations of concerns (model-view-controller) will be your first big step forward * learn the basics of secure coding: how to avoid to be exploited by common attack methods * (later) learn a major framework, and force yourself to do things how its documentation says they're to be done. It may be hard at first, but it's time well spent &amp;#x200B; &amp;#x200B; &amp;#x200B;
Oh my god, please no.
Magento vs Prestashop, if you mean free solutions.
Nice work! BTW You can also inject the dependency on the controller method signature as well as class constructor. A common example is to inject Request instance: ```php &lt;?php namespace App\Http\Controllers; use Illuminate\Http\Request; final class MyController { public myAwesomeBug(Request $request): string { echo "🐞"; } }
Please forgive but i don't understand quite how this works. I understand its now running with DI but now don't you have the horrible chain of `new a(new b(new c))`
This sounds very intriguing. Any chance for GitLab support in the future? 
Thanks to you for these feedbacks, I will try to correct all these points! I am still a beginner in PHP (3 months of exercises)
Yes, it's definitely coming. As is PayPal support.
You should try to focus on a topic instead of try to learn php. However, and in any case, you must learn the basic but, it's easy to learn the basic if you have a focus too. &amp;#x200B; For example, a good example is to create a form, and a second good example is to create a table. Mixes all together and you will get practically all business projects. &amp;#x200B;
not my project, just wondering what it's worth to have a webview in PHP
First, keep up the learning attitude, my first school project looked a bit like that. But now, I need to be a bit harsh. Not that I take pleasure in it. *You need to take the demo site down, right now.* It's way too far from being secure enough to be publicly on the web. There is currently ways to hack your site, and potentially harm/steal anyone browsing the demo. Like everyone else, you don't know what you don't know, so I'm not saying you are a criminal or are a terrible human being. But now that we told you, you know. In this case, you really need to keep learning, before putting php websites out. In the very short term, look at (in no particular order) : * MVC, or code organisation * Front controller and routing * SQL injection (short answer, prepared statement) * proper password handling (short answer, `password_hash`) * XSS (always escape/sanitize on output) * using csrff tokens Another problem is file placement : Today you have : root (which is the public directory) |- close_account.php |- comment_frame.php |- index.php |- ... |- assets/ |- ... |- config/ |- config.php |- includes/ |- header.php |- classes/ |- ... |- form_handlers/ |- ... |- handlers/ |- ... Look at https://laurent-dev.fr/social_network/includes/header.php, a file I have no business accessing. On this case, all I get is an error. But I'm pretty sure that if you continue using this structure, one day I'll see the database credentials, or secrets I shouldn't have, just by testing the outputs of these files. You might be tempted to edit your apache/nginx config, or add `die` statement everywhere. It's not the solution. You should just move includes and config up one directory : root (not public anymore) |- config/ |- config.php |- includes/ |- header.php |- classes/ |- ... |- form_handlers/ |- ... |- handlers/ |- ... |- public/ |- close_account.php |- comment_frame.php |- index.php |- ... |- assets/ |- ... Then update the relative paths, for example in `index.php`, `include_once("includes/header.php");` must be changed to `include_once("../includes/header.php");`, then point your webserver to the root/public directory instead. There is more, but start with that, on both this social network and the other blog project you made.
Replying to my own post. I see overnight that Nik posted (https://externals.io/message/104594) seemingly in favour of the proposed RFC. To me it reads as if he feels his wider RFC is more effective / likely to pass if trailing whitespace is allowed. Personally I would prefer to see all the changes in Nik's RFC *and* leading whitespace stripped. I would certainly hope this would have a strong majority in favour but as with any BC break, you can never be too sure. That's why I think a RFC to strip leading whitespace is required first. Then, if it fails to pass a vote, pass the trailing whitespace RFC to add the consistency, immediately followed by the saner conversions RFC. What I don't think makes any sense, in the light of the (very positive) trend towards greater strictness, is making developers go through this process twice. I expect that support for leading / trailing whitespace will eventually need to be stripped. Maybe in a years time, or maybe in several. I'd rather just get it out the way now with a depreciation in 7.4 so that when 8.0 hits, people have already prepared for it in the same round of testing as they did for saner conversions. In for a penny... in for a pound. 
Sure, I've looked at it. It's still the same giant singleton architecture underneath. Doesn't look like too much has changed really, just updated to modern syntax features.
&gt; Symfony &gt; &gt; &lt;?php &gt; &gt; $result = $this-&gt;get('some_service')-&gt;someMethod(); This is wrong. It was (encouraged) like that in Symfony 2.x but ever since Symfony 3.x was released - quite a few years ago - you would instead be encouraged to configure your services for clean DI. This is Symfony today: $result = $this-&gt;someService-&gt;someMethod();
*YOOOOOOOOOO!!!!* It's your **7th Cakeday** TheReverend403! ^(hug)
That was the point being made.
Exactly
That's called "action injection" and it's a code smell: &gt; The explicit reason for using Action Injection is “to reduce dependencies or overhead” when constructing an object. You don’t want to have to pass in a dozen dependencies, when only three are used in every method, and the others are used only in specific methods. &gt; &gt; But the fact that your controller has so many dependencies, used only in some cases and not in others, should be an indicator that the class is doing too much. Indeed, it’s doing so much that you cannot call its action methods directly; you have to use the dependency injection container not only to build the controller object but also to invoke its action methods. -- http://paul-m-jones.com/archives/6589
Reducing or removing the use of the incorrectly-named "facades"? Excellent.
Is there a way to browse a listing of all the projects available?
It's [here](https://enjoy.gitstore.app/maintainers). We're working on surfacing that on the marketing site, but it's still early days.
The chain of new a(new b(new c)) is already there in the container, all a Facade is is a class with a static method that then calls the defined service in the container. These container services can also be injected in to constructors automatically as Laravel uses reflection to "autowire" your services without you having to use Facade bullshit. If you look in any ServiceProvider class you may see something like the following: `$this-&gt;app-&gt;singleton(MyService::class, function ($app) { return new MyService($app); }); $this-&gt;app-&gt;alias( 'my.service', MyService::class );` This means you can now inject MyService in to any other class and autowiring will take care of it, or you can create a facade that will call 'my.service' from the container.
Thanks! It's code smell so does facáde. When using facáde it is more likely you will forget how many dependencies you have. I think it is still useful during refactor.
Actually this is not "injection", but passing the request object. Like middle-wares, so it's correct. But I see in Laravel community, both are called "injection" incorrectly. So +1 for you comment!
Do you mean this one https://github.com/rectorphp/rector/pull/1143 ? :)
Granted Facades (misnomer) use \`::\` to call instance methods, but where does one use \`-&gt;\` to call static methods in Laravel? You have no idea how many times I've explained the Laravel Service Container and Facades to coworkers, experienced PHP devs, who still do not get it. That is a sign of a mess right there, and I say that even as Laravel is my preferred PHP framework.
What stops me from sending a POST request to `/includes/form_handlers/delete_post.php`?
All of which have active maintainers.
A PDO-like abstraction layer (because as mentioned, the concepts are strong) that doesn't use PDO underneath. We use an Oracle back end, so we're really just talking about an abstraction over the oci_* functions. It's what Oracle recommends, since PDO's author no longer works on PHP and as this bug points out, it's not being maintained properly.
So the real code smell is having a million dependencies in your controller. What if you use "single action"/"invokable" controllers and inject dependencies through `__invoke` (or whatever method you're using) instead of using `__construct`? Would you still classify this as a code smell, because it relies on the container to call your method?
NULL is not a magic value. It is explicitly for this use case. Whereas \`0000-00-00T00:00:00\` is a legal value, and not the value that you mean.
Not sure why all the fuzz, but why not use [https://laravel.com/docs/5.0/container](https://laravel.com/docs/5.0/container) ?
Well, it's a bit difficult to migrate a project from CI to Laravel particularly if there are millions of lines of code. It's nice to see continued support for CI for older project support. If all your code is bespoke anyway, it's not like it matters if you use CI or anything else, they all seem to perform closely the same however Laravel is much easier to deal with when scaling. But if you're to start a brand new project, I don't know what 4.0 will offer that is better than Laravel or any other framework but I would definitively weigh in the differences. Anything you choose today is just the flavor of the month and one day people will say "People are still using Laravel?" instead of "super sweet framework of 2022". Just be thankful there's still support for security and performance improvements, who knows? Maybe 4.0 is like a rebirth in the right direction?
Because it's not bad if you already have a project that is running perfectly fine with it. It was once the best available on the market and free to use no less. It got PHP 7.x support and other things got improved in 3.x making it pretty useful without having to migrate everything over to a different framework which costs a lot of money to do. I wouldn't start a new project with codeigniter, but I don't mind supporting old projects with it because I know it very well. But if someone were to hire me to migrate it to a different framework, I'd gladly accept the offer. :D
I wish? lol.
I think it does use the container.
Took them long enough.
Tell them it will take 3 years and go on a nice vacation after spending months fixing it piece by piece. Every month tell them "it's difficult because of the bad programmers who originally made it but it is getting done" and every few months just keep repeating "It's coming" like you're George R.R. Martin talking about his next book release. I'm kind of joking, while ethically I can't do this, I have seen two companies do this very thing to the department of education here. Millions of dollars spent on a project that could have taken maybe 3 months do. Literally, 3-5 months (tops) but took 5 years. No one got in trouble for it due to political reasons but it was disgusting to see it all unfold.
Keep in mind that Xdebug is a free and open source project that everyone has the luxury of benefiting from at no cost. There's no reason to be rude to the many contributors putting in their free time so that we can have a better debugging experience.
In my case let's say the team was able to do progressive refactoring, keeping the live app working and adding missing/new features. The summary was 8 months somehow wasted, +6 months of refactors and migrations, until the project was saved. Extra months were needed... I don't know if you're validating that is better to refactor than to rewrite, but those are my two cents. Anyway as with everything, I guess it depends on the project..
Nothing.
Youtube has all the information you need to get started and then google every little problem you encounter. Eventually you'll learn how to debug your own code and understand what the error messages mean. One day you'll have a t-shirt that says "I don't need stackoverflow to make it work". lol
What I meant to say is: why modify Laravel, when it already provides dependency injection?
Hehe nice idea ! 
Please no. 
I see the example uses *ResponseFactory* to load views. If I were just getting into laravel, how would I know that I would need to use ResponseFactory? Suppose I wanted to change _Auth::login()_ calls using DI - how would I know what DI class to inject?
Check [here](https://laravel.com/docs/5.8/facades#facade-class-reference) and [here](https://laravel.com/docs/5.8/contracts#contract-reference).
This doesn't modify Laravel. It simply replaces Facade usage with explicit dependency injection.
Finally!
Ah. It's not about modifing Laravel core code, but converting non-DI Laravel code to DI form. What could I write better in the post to make that clear? It's written there, but I probably missed something.
&gt; Would you still classify this as a code smell? Maybe -- but my first question would be, "Why are you using a class at all in that case? Just a plain old function would do."
This post could not exist without https://medium.freecodecamp.org/moving-away-from-magic-or-why-i-dont-want-to-use-laravel-anymore-2ce098c979bd by amazing *Niklas Schöllhorn*
Does this mean I can simply add a space at the end of a string to keep it from randomly turning into a number?
If you are having such a problem I really wouldn't recommend “fixing” it by that means, and it won't work in all cases.
Not 100% sure, as I never use bool in the database, but I think it sounds like PDO should have a notice/warning/exception there.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
You will have the ability to work with a Framework that built Larval Framework, built Drupal.. You will experience dependency injections, building services with Interfaces and abstracts that will enhance your PHP OOP, a window to the architecture of the Symfony application’s kernel, A strong event system with Listeners or Event Subscription , HTTPKernel with events that follow the HTTP lifeCycle, event that follow the controllers. You can use An ORM like doctrine that interacts with your DB layers, a fine DQL, querybuilder and lot more... Symfony is a school for PHP read the source code and follow how things are built behind the scenes, read about the HTTPFoundation, creating Framework using Symfony.....
'''$serviceContainer = new ServiceContainer(); if ($request-&gt;getUri() === '/finalize-invoice') { return $serviceContainer-&gt;finalizeInvoiceController()-&gt;__invoke($request); } // and so on''' Why call the invoke method instead of a regular method?
Thank you for your reply. That helps. 
The point is to increase consistency, and make it possible to remove the confusing distinction between well-formed and non well-formed numeric strings in the future without a huge BC break.
There's definitely room for optimization, esp. speed-wise - https://onilab.com/blog/magento-2-performance-speed-optimization-guide/
Classes are just a lot easier to work with, I guess. Directory and namespace structure, autoloading, inheritance/interfaces/traits, caching route resolution, properly separating your routes and controllers etc. are all more difficult or impossible using plain functions/route closures. I'm not sure what a good implementation of controllers/actions using plain functions would look like.
I can understand why you would prefer an RFC that disallows leading whitespace. What are the chances this would pass, though? It would be a significant BC break. By allowing trailing whitespace, this RFC makes the language more consistent without breaking BC, and opens the way to \*increase strictness\* by removing the well-formed / non well-formed numeric string distinction, and no longer treating strings like "123abc" as a number.
&gt; What are the chances this would pass, though? It would be a significant BC break. That I don't know, which is why I think it makes sense to RFC it. Combined with saner strings I would certainly hope there would be support for a wider overhaul based on a 7.4 depreciation + 8.0 forced change. If there's no support for the BC break, then IMO internals must pass the trailing whitespace RFC instead, but I think that is just kicking the can down the road, and opportunities such as a major version are very, very rare, and ultimately leading and trailing whitespace both need to die, so why not do it in 8.0 when everyone will be doing major testing passes anyway. To do otherwise kinda feels like a doctor saying they're going to chop off your left arm, so you're not as unbalanced when they need to amputate your right left.
This lagging behind release sounds like the developer could have a hand from from some sponsors or patreons...
Imagine being a shitfucking """""""""""""REDDITOR""""""""""""" and posting virtuous shit like this just for Internet upboats.
Yup! That's exactly what I'm trying to get at with [https://derickrethans.nl/xdebug-experience.html](https://derickrethans.nl/xdebug-experience.html) and [https://www.patreon.com/bePatron?u=7864328](https://www.patreon.com/bePatron?u=7864328) — and I'm working on sponsors too!
Hey Derick. Thank you for your amazing contributions over the years! Have you approached Jetbrains to see if they would be interested in sponsorship of some kind? Improved debugging in Intellij / PHPStorm I'm sure would be something they would like to offer. 
&gt;however Laravel is much easier to deal with when scaling And that's supported by the following fact ... Oh, wait.
Thank you for all your efforts!
Yes, it is pretty much like PHPStan, but in Go. The trick is that it is much much faster (although has less checks, but that is not why it is so fast). Also NoVerify does not physically include files and does not require any kind of autoload or other things to work in order to analyse project. I am the author by the way :).
&gt;The point is that this seems unnecessarily complicated (for me, at least) Not bitching, you said that and then.. &gt; nothing complicated, this is a pretty standard ZF1-like routing system So we're confused
So only gods can build good frameworks, then huh? I've built a full stack framework that our entire dev team uses. It's as feature rich and clean as anything else out there, but it's precisely because of people like you that we've never released it as open source. You aren't worth my time to support and take advice from.
It seems that any PHP project, new or old, is going to be crushed here if: * is not written like Java / using Symfony or Laravel * doesn't follow PSRs * doesn't use DI \*because it's good OOP and facilitates testing\* * doesn't use PDO and/or prepared statements /irony
You shouldn't be offended by that. Or you don't use PHPStorm daily that is written in Java... :)?
I'm trying to push the company I mainly work for to support it. I wonder if you'd be willing to offer some kind of "paid" one-off license option? That way we can write it off as a business expense. I already donate via Patreon, but I'd be happy to chip-in if a larger round of fund-raising was done. 
I have a question on this statement. The only information I can find about not have a maintainer for PDO was from 2015 [https://www.phproundtable.com/episode/how-the-bus-factor-may-negatively-impact-the-php-ecosystem](https://www.phproundtable.com/episode/how-the-bus-factor-may-negatively-impact-the-php-ecosystem) Is there any recent news on this? The last thing I see is the internals on PDO [https://wiki.php.net/internals/pdo/brainstorming](https://wiki.php.net/internals/pdo/brainstorming) &amp;#x200B; I assume while the original author is not present there is an effort to maintain PDO in the sense it works in the next release.
Been there. Done that. The only positive is job security.
For who? New bloke is a temp contractor, that's the craziest bit. Assuming he does deliver a product in the alternative framework, he immediately moves on and leaves a deskilled and demotivated team to maintain it
This is the kind of things that we don't need in OSS... man go do it yourself.
A bug this trivial to address staying open for more than a decade says all I need to hear.
symfony
Learn both, then decide which one you are more productive with and prefer.
Laravel (we all have our biases though) 
Learn how to Google. This exact question is asked here monthly.
I don’t think symfony has been seen as “just for large projects” for quite some time. Especially with Symfony 4. Really only you can decide. Build some projects in both. By the time you get done you’ll know which you prefer. Personally, I tried both; loved Symfony, didn’t care for Laravel. Some people are the complete opposite. 
Everyone will be highly openiated on this one. Best thing to do is learn both, build same app on both and see which one you prefer. 
Which one do you prefer?
Symfony4 is super-easy to start so make sure you are not watching some old videos on KNP. People say that Symfony is far more complicated; sure, it can be. But it is because it is super-big and has tools for everything so it is actually a good thing. Luckily, docs are great and google is your best friend. Once you master it, writing code is a breeze. Keep in mind one thing; for beginners, you will have to use console to generate entities, forms etc... It takes few days to learn full namespaces so for a start, use \`\`generate\`\` set of commands. PHPStorm settings-&gt;command line tools and add new config. Later, press ctrl+shift+x and you will have autocomplete of all commands.
I personally learned Symfony first and then trying to learn Laravel I just didnt really enjoy it. Symfony and I clicked on understanding. I was happy to choose Symfony too because I am primarily a Drupal developer.
&gt; I'm not sure what a good implementation of controllers/actions using plain functions would look like. Slim is pretty good at is using just functions (anonymous, to be sure, but still pretty good).
I have never used Laravel, but I have a PHP script that reads phone numbers from a flat text file and sends a text to each number. The numbers are added via a text join from the user, and removed via a "stop" keyword. I came here on /r/PHP looking for someone that might want to work with me on this. Sure, I could just pay someone, but I want to learn and improve my lack of PHP skills. &amp;#x200B; My friend wrote the script, but I hate to bother him to update it. It's been working great for several years, but I would love to streamline it and make it more efficient. 
You should give it a try! Laravel is awesome 
With Symfony 4, use the 'make' bundle. It shows you best practices for the simple things. Then you can take what you learn to the next level.
&gt; It can get tricky/messy when it comes to customization, pattern-based matches/validation Learn to read, please
&gt; I feel like for my purposes, Laravel would be more appropriate since is “quicker to learn” and “easy to be productive with”. The use it. If it doesn't work out as you expect it to be, switch back to Symfony. You could've been working on projects already with the time spent overthinking this. Good luck!
"Symfony is for large projects" is really a common misunderstanding. Symfony makes sense when you need slightly more granular control over some underlying utilities, but there is nothing inherent to Laravel that would prevent it from being used on large projects. I'm using Laravel to rewrite a gaming community that has more features and more complex domain requirements than most enterprise products I've worked on, and there are precisely zero issues with it. It all comes down to how you use the tools at your disposal. 
You didn't censor out the name that purple was responding to twice
Same here. I really love coding using Symfony
Purple is wrong. 9 in binary is `1001`, 19 in binary is `10011`.
Green is 100% correct in this case. The binary representation of 9 is 1001. Purple clearly got this question wrong in a Codality interview, and is searching for justifications why and latched onto the fact that Information Theory uses a the same word for a slightly different meaning. However, colloquially to programming a bit representation would be binary.
I think one is talking about the number 9 and the other about the ASCII digit.
Laravel, simpler, more modern, faster quickstart, great integrations
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
&gt;forcing all devs, especially senior devs, to use the same setup Agree. I'll do my own Linux box -if needed- that mimics your environment for the sake of being pragmatic, and be sure I'll put a PHP debugger extension ([xdebug](https://xdebug.org/), [dbgphp](http://www.nusphere.com/products/dbg_wizard_download.htm)...) to do remote, interactive debugging from my IDE. I'll be more productive that way than reading code and doing var\_dumps here and there just because I have to follow someone way of doing things.
It’s not like it really matters because it takes about one second to find this on stackoverflow: https://stackoverflow.com/a/28094803
Check the job openings in your area and see whats more popular around you.
I don't know why he's talking about information theory at all. This isn't even a remotely complex question - it's perhaps less familiar, but numeral systems are one of the first things anyone learns at the beginning of math. Even a 2 year old learns them, we all just start with base 10. All you're doing in binary is setting the max numeral to 1 instead of 9, which is as easy as 1, 10, 11!
Symfony
Outlook has a webhook for this: https://docs.microsoft.com/en-us/previous-versions/office/office-365-api/api/version-2.0/notify-rest-operations
Right, thanks, it is \`\`make\`\`, not \`\`generate\`\`. The power of autocomplete makes you forget things like this :)
Oh boy: // We are using a pointer to save on memory $this-&gt;data[$item] = &amp;$this-&gt;stub;
Mark for later
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Aaah, did not think of that at all. That explains the behavior. I wonder if untagged repos could be added at some point as well, as some pre-release work could benefit from monetary supporters as well (e.g. bring some Kickstarter-like functionality to Gitstore).
PHP doesn't have a set data structure because PHP has associative arrays that is the hearth of PHP. &amp;#x200B;
really, laravel qualifies as "more modern" now? I also disagree with the other arguments, but "more modern" is just grade A BS
Very exciting. I might play around with that this weekend!
It wasn't actually meant as a negative comment. But what can you do without a body language?!
Ditto
* 1001 is indeed a representation of binary so it's hard to understand what the OP wants. * Maybe he wants (binary)1001 (but PHP doesn't have such thing) * Or maybe he wants str_split(decbin(9)); [1,0,0,1]
It's not insane, is it? It's just "&gt;". I suppose it could be called "greater", but that doesn't seem like a huge difference. https://libvips.github.io/php-vips/docs/classes/Jcupitt.Vips.Image.html#method_more Other libvips bindings use operator overloading for things like this, but you have to use chained method calls in php.
a) you should update your composer. Example: &gt; composer update Loading composer repositories with package information Updating dependencies (including require-dev) Package operations: 0 installs, 4 updates, 0 removals .... - Updating phpunit/phpunit (8.0.3 =&gt; 8.0.4): Downloading (100%) Writing lock file Generating autoload files &lt;-- this one. b) delete the whole vendor/composer folder and run composer update again. b) in the folder vendor/composer there is a file called classloader Replace this function and adds a var_dump ``` public function loadClass($class) { if ($file = $this-&gt;findFile($class)) { var_dump($file); // it will show what file is trying to load. includeFile($file); return true; } } ``` 
This is actually really interesting topic, since PHP's variables are working really really weird prior PHP7: [https://nikic.github.io/2015/05/05/Internal-value-representation-in-PHP-7-part-1.html](https://nikic.github.io/2015/05/05/Internal-value-representation-in-PHP-7-part-1.html) Based on this it really doesn't matter if you use referencing in PHP5 - it's same zval anyway. And on PHP7 it's actually causing more overhead on smaller dataset but may be efficient after some tens/hundres of thousands entries. (as it should)
Hi fellow Drupal Dev :) if you don't mind me asking, were you green to symfony before D8? And if so, how'd you find the learning curve?
References are never more efficient in PHP in terms of basic usage, because PHP7 keeps the "it's the same ZVAL" behavior of PHP5, only fixing a few edge cases that would cause unexpected internal duplication of data. References are indeed slightly less efficient in PHP7, on paper. In practice it doesn't matter if you reference or not, what matters is what you intend to do (if you modify a reference, all references get modified, while without a reference, you modify your own copy only).
Realistically speaking, you'd need both. Both have excellent documentation. It's a lot faster to bootstrap a laravel app though. It comes with vuejs integration too so if you are into frontend as well you can really take it off Both are PSR-compliant and both were in the php-fig group until recently but have since parted ways with it. So what's left for you is to really just become a better programmer and to write modular, testable code. Quick apps will always bite you in the ass if they grow up rapidly, regardless of the underlying framework
Hmm
Ditto
Laravel is a bit easier for beginners, but Symfony is not that much harder, to be fair. It is probably more profitable to use Symfony, because it can be customized more. Also Laravel was made on Symfony components. Now that Flex has come out, it's a lot easier to learn because the installation of any bundle is done without you having to do anything complex. Regarding the "Symfony is for big projects", can't agree with that - with Flex you only use the components that you need.
Other than the hook mentioned by u/Stanjan you could also write a script to fetch mails from an imap account. Then use cron to run the script periodically. &amp;#x200B; We got a very old application that automatically fetches mails like this.
/u/tomas_votruba, have you also thought of refactoring helper functions? Much like `View::make()` and `Auth::user()`, you can use `view()-&gt;make()` and `auth()-&gt;user()`. Both methods hide the dependency you are using and could be refactored in the same way.
In laravel, routing won't be cacheable anymore with an inline closure instead of `MyController::class`. Closure ain't that easy to serialize/unserialize.
I had toyed around with Symfony a bit before Drupal 8 so it did help out a lot understanding Controllers, Dependency Injection etc. But I am no expert in Symfony and do Drupal all day. But as far as fundamentals of Symfony I do understand them. &amp;#x200B; Also I once built a custom PHP thing myself just for fun using the Symfony components and not the entire Symfony stack. So it helped me understand a lot on each individual pieces of it. Its good to see another Drupal Dev out in the wild!
First willing victim found :-)
Tag those `0.x.x` releases! :D
Love your answer, so true! I end-up with Symfony, but first I tried Nette and Laravel. At least for time being :)
I do not think there is a generic answer that will cover all products. Even just looking at Drupal if you were to [ask Pantheon](https://pantheon.io/blog/drupal-multisite-much-ado-about-drupal-multisite) when multisite is appropriate the answer would be never, then if you start looking at [Acquia they seem to be all for it](https://docs.acquia.com/acquia-cloud/develop/drupal/multisite/).
Hmm
Is Mercure pronounced like the planet Mercury, or like "myrrh cure?" 
Ditto
The latter (it's French for Mercury though)
So OP you're purple in that image. Have you been convinced you were wrong? Also you should really avoid being that condescending to someone who is trying to help you understand why you're incorrect. Why do I think OP is purple? Purple's username is Jack Nicholson(you can see it in the OP's pic and on the topic itself.). Their profile links to their Twitter. Their Twitter says they run "steamtimeidler.com". Pop OP's Reddit username into https://redditcommentsearch.com and search for "steamtimeidler" will pull up several results [like this one](https://www.reddit.com/r/Steam/comments/5kn3tp/steamidlerimer_is_it_real/dbpog8j/?context=3) where they claim ownership of steamtimeidler.com.
You should learn Symfony components, as both frameworks are built using them. Then you can decide which Framework you like better.
&gt;Implementing the ArrayAccess interface allows us to loop around our object as though it were an array, and can come in pretty handy. This is not what ArrayAccess is/does. You're thinking of Iterator &amp;#x200B;
Uh oh, this is starting to smell like an Ad 2.0 campaign.
I'm posting on reddit in a forum **dedicated** to a web development language. Does it surprise you that I maybe run a website? The question was was **4 years ago**. I was young. I went through my old questions/answers and I'm looking to anywhere where I made a mistake to correct myself. Thanks for posting all my personal information in your message though. I really do not appreciate it. I would however appreciate it if you would remove it as I tried to do so in my image. I'm protecting myself and you are basically posting my dox.
On a mostly empty subreddit? Does it surprise you that people own websites who post in /r/php?
Please may you remove the direct link
&gt; I'm posting on reddit in a forum dedicated to a web development language. Does it surprise you that I maybe run a website? Did I act surprised anywhere? The website is inconsequential aside from linking your Stack Overflow and Reddit accounts. &gt; Thanks for posting all my personal information in your message though. I really do not appreciate it. I would however appreciate it if you would remove it as I tried to do so in my image. I've not posted any information that you haven't made explicitly and easily accessible to anyone with an internet connection. &gt; I'm protecting myself and you are basically posting my dox. That's not what a dox is. &gt; slang: to publicly identify or publish private information about (someone) especially as a form of punishment or revenge. &gt; - Merriam-Webster Dictionary None of this information was private. The only information that may be identifying is if you used your real name as your Stack Overflow username. In that case it's information that's freely and easily available. If you're concerned about privacy then I'd suggest you take some time to clean up your online footprint.
Been playing with it today seems pretty sick. Will replace my ratchetphp 
Collecting public information and putting it together is called doxing. It doesn't matter if the data was originally public or not. You are collating it. That is where the issue lies. Please respect my privacy and remove the information. Regards
Slower subreddits with somewhat moderate subscribers would get higher impression counts, and augmented advertising is not completely foreign to this subreddit. However, I'm willing to give you the benefit of the doubt, sure.
I completely disagree that this is doxing. Mainly due to the fact that all information posted are things that you've explicitly chosen to make public as a way to identify yourself. If you'd have posted your real name in a random comment under the username "aye-yo-i-run-steamtimeidler-dot-com" somewhere online I would agree that is a form of doxing. I've only posted your Stack Overflow username, a link to a comment on Reddit, and what information links the two accounts.
&gt; I'm willing to give you the benefit of the doubt Oh how kind :P Nothing was even said about it or even mentioned or even linked to AND I tried to censor information in the image (That had nothing to do with it anyway!). Like yeah, duh, obviously I'm advertising my obscure website that is completely unrelated and offtopic!
So basically you refuse. What a mature adult you are.
I had been working on a Node.js solution, leveraging redis as a data store to cross-communicate with an existing Symfony application, but this sounds far easier to maintain. Now I just need to convince my client that it's worth transition our Node.js beta leverage Mercure instead. 
How is this different from other things like Laravel and Pusher? Is it just that it is not based on a websocket?
Hi @CoderReader, Have you required the autoloader? E.g. "require __DIR__ . '/vendor/autoload.php';". If you have do you get any warnings/errors? You can also try "composer dump-autoload" &lt;--- that will regenerate the autoloader for you without having to run "composer update". Aside from that please paste as much as you can (make sure to remove any information that you use to connect to your server). [https://pastebin.org](https://pastebin.org) works well for that, it will give you a link that you can paste here.
I've stated and discussed my reasoning. Yes, that's the mature thing to do.
You deleted the form file, but did you also delete the file that's the action/target of the form? That's what spammers are probably calling.
I never used this kind of tool, Mercure seems really easy to use, was it ?
Obviously compared to pusher it's free right?
Is the Spool empty, perhaps they have generated so many Mails that the Mailserver send the generated Mails... I had to generate some thousand B2B Mails each about 10MB (Mainly Catalogs), the Mailserver was behind a 2MBit Line, so that the sending took some Hours. And there where Mailservers which where really slow. &amp;#x200B; My suggestion is too look in the Mailspool and If the Script which had done the initial sending still there, like /u/bagelmountain said.
The irony is that censoring the information created a mystery, and if I've been taught anything about Reddit by "The Safe", and the Boston Marathon bombing, its that Reddit cannot permit a mystery. 
Hahaha that's very true!
Why not wrap your Code with ReactPHP. Then you have write 2 lines to habe a SSE Backend Server which is working on the same source code you already got. That includes Authentication and all thing you already needed. Just connect the sessions to a long living session in the background and connect the socket. Its no magic.
&gt;Of course, don't build a framework for the purpose of it being adopted into projects. FTFY &amp;#x200B;
I think it's the french pronouncation. On the other hand, Kévin Dunglas reverences Freddy Murcury a lot in his presentation about Mercure: https://dunglas.fr/2019/03/official-push-and-real-time-capabilities-for-symfony-and-api-platform-mercure-protocol/
There is also an option to forward all email coming to that account to a service like Mailgun, you can setup an incoming email address and all mail sent to that email address can be forwarded to your API.
Please use https://www.reddit.com/r/phphelp for that. This sub is *about* stuff relating to PHP; not a helpdesk.
I lean closer toward the "never" side of this camp -- if you have different sites doing different things with different security considerations and different data access patterns and different audiences, its probably a different piece of software with a different software development lifecycle and different release schedule, even if both things are worth solving by the same CMS/whatever software. For instance, if I have a security update for my X-site multisite install, sure it's less work (press one deploy button, instead of X buttons), but the work isn't the expensive part, it's easily automated. The thing that security updates cost me is risk -- risk when I haven't applied them and risk that when I apply them that they'll have broken something. If I can apply updates to different sites at different times I am allowed to make that trade-off more intelligently. A site which has to store PII gets patched immediately and tested afterward. A site which has no sensitive data in it, but has business critical landing pages that cost big money if they are busted gets patched in staging and thoroughly validated before deploying those patches live. Another example -- maybe I have some sites which have very spiky traffic patterns and few logged-in users, and I have other sites with a very sustained level of almost entirely logged-in users. The first will be cheapest and fastest with a CDN and an autoscaling group of small instances. The latter might be cheapest with in-memory cache and a reserved level of medium instances. Maybe another site isn't worth running its own dedicated infrastructure for at all, and the obvious choice is to hand it to Pantheon to host -- and they don't do multisite.
Very nice, I like that supports http/2, authentication and connection reconciliation (that in many case I've managed with similar framework was very messy on my experience). I'll try, 
Laravel has a free open source pusher replacement.
I am not a huge fan of multisite, I am on my second multisite project that has been hosted on Acquia and while it leaves something to be desired it does not totally suck. Both of the multisite projects I have worked on used the same set of modules and the same base theme for every site so having one code base to maintain and keep updated is a big benefit. I have never really worked with the Pantheon platform (when I looked into it they quoted me $45k a year for hosting) but everyone I talk to who uses it loves it so obviously they are onto something.
Just stop the PHP process on Your server. If you are on Linux, my guess would be that You may try running "service php-fpm restart" if You use FPM of course 
I really don't get what ReactPHP has to do with anything here... Mercure is a protocol built on top of SSE. So yes you could do what Mercure does with long-lived processes and SSE, but the whole point is to simplify that (and not be just about PHP)
I'm no expert, but I do like the idea of managing my own Mercure instance as opposed to paying to scale a Pusher account. In that regard, the only limit to growth is my own infrastructure, rather than paying another monthly fee once my service outgrows Pusher's free sandbox plan
Laravel is focused more on stream lined dev experience and rapid development. Symfony is more suited for giving more control and doesn't compromise on flexibility, although not as quick to prototype in. Symfony can be a bit harder to learn. Once you do Laravel won't be an issue to use other than getting familiarize with API's. That cannot be said about Laravel to Symfony switch though.
Not saying you're wrong, but maybe I'm missing something: Isn't the whole point of the linked Symfony package just that - extending the source code you've already got with a simple connection to a background Mercure server?Then you have real-time duplex communication built on top of "...the same source code you already got". &amp;#x200B; Right? &amp;#x200B; Maybe you wouldn't switch from an existing ReactPHP solution to this, but if you're coming to this with nothing, this seems like a great integrated solution for extending an existing Symfony application with push updates.
But pusher costs money...
Thanks I appreciate your help.
Thank you, I appreciate this suggestion.
Thanks I will investigate.
Honestly, it's going to depend on your philosophy on programming and just overall personal preference. We used to use Symfony and Silex but now use Laravel and occasionally re-evaluate to see if that's still our best option. I would recommend building a small, few-hour project in both. The project I always make my devs work on as an introduction to Laravel is a simple blog: a page for displaying a list, a page for displaying a post, a page for creating a post, and login. If you're not bothering with styling or anything, it can take 3-6 hours to get to a point where you've done enough to actually start evaluating what you've done. Such a project in both platforms would show you pretty quickly which one fits your needs and desires best.
What is the benefit over `composer create-project`?
Didn’t finish setting it up but from the little that I’ve looked at it, it seems pretty straight forward. I struggled a little with ratchet / autobahn js to get stomp for realtime push and in all honesty it doesnt feel as stable as mercure. This looks a lot better but it doesn’t talk about performances. I definitively wouldn’t deploy a mercure instance on the same server as a monolith app.
`composer create-project` will need you to require a package if i'm not mistaken. On the contrary, my tool lets you start from scratch with no dependencies and also adds a few extra files to your project's root folder.
I will.definitely play with this. I was kind of getting tired of ratchet and always wanted something official from.symfony . This is great .
If you want proper data structures I would recommend https://secure.php.net/manual/en/book.ds.php (or it's PHP userland polyfill)
Checked out what this Mercure is. As I understand it, it is server sent events. So, support is entirely based on browser and version. And the coverage is not fully there. So, you will need socket (nodejs) as fallback anyway
I don't know Laravel, so nope. Could you create an issue at Rector repo with before/after code example? This pretty easy to implement
Meh, I'd say go for Java, C# (.net) rather than PHP. Going from python to PHP must feel like going from driving a Ferrari back to a POS french car.
Sure, why not? At worst, you've learned a language you'll never use again. 
PHP7.x.x is totally fine.
I wasn't expecting him to learn 5.2, thank you.
&gt; Going from python to PHP must feel like going from driving a Ferrari back to a POS french car. No, it's really not.
I think you misunderstood. https://github.com/beyondcode/laravel-websockets is a reimplementation of the Pusher API, that you run yourself. Compatible with any Pusher frontend libs (i.e. Laravel Echo).
https://github.com/beyondcode/laravel-websockets is a reimplementation of the Pusher API. No need to pay for anything. Uses ratchet for the websockets part.
Don’t listen to this knucklehead, I went from Python to PHP and haven’t looked back. I personally find it easier to work with and, in my area, way more jobs.
I'd say go for it, there's no reason not to.
What’s wrong with Django? 
I would argue that your goal is completely possible with Python and Django as much as it is with PHP and one of the many frameworks created with it. There's also the argument where learning another language will help you become more competent in anything previous. So yeah, learn PHP. Get good with it. Learn its ugly sides. Its pleasant sides. Keep using Python. Pick up another language. Just never stop learning as it is the main thing that will help you reach your goals and allow you to set new ones.
Its quite possible that your PHP code isn't actually using the `sendmail()` program but an internal library such as `PHPMailer` to shoot the mails. In fact, that's the default configuration in most PHP apps I've seen these days.
I know both PHP &amp; Python-- I don't regret picking up either. I definitely prefer building API endpoints and database access layers in PHP. I prefer using Python as a sibling to NodeJS and bash...
Do I have to do all the work? [laravel pusher replacement](https://github.com/beyondcode/laravel-websockets) Pusher not required but the Sdk is, but again pusher as a service is not. Care to try your comment again now that I’ve done all the work for you?
Seems very similar to [nchan nginx module](https://github.com/slact/nchan) -- It's cool to see symfony adding this kind of much needed functionality. 
Is there a chance your server is compromised?
I'm way more productive in PHP. Using PHP is almost like being in the closet though. All your coder friends will openly trash people who use PHP and you'll find yourself leaning toward Python for anything you release publicly out of a desire to be accepted (despite actually wanting to use PHP). That said I don't use any major frameworks. I've effectively built my own over time and have patterns that I routinely use because they work best for me. I also have a strong grasp of HTML and CSS so I don't really lean on code that generates markup. The amount of PHP I use on the CLI is also kind of shocking to most people (they're surprised for example that you can write a proper daemon and do signal handling in PHP). I've been using PHP since PHP 3 though so maybe it's just familiarity at this point. I like the C style syntax better in general. I also like variables using a prefix of `$`. I really like the level of out-of-the-box integration with Apache and just being able to access most of what I need through superglobals. I do wish PHP had better built-in regex handling like Perl does with its `=~` operator and I do wish that it also had some of the slice operators that Python has since a lot of PHP ends up leveraging `substr()` and `strpos()` (or related functions). I'm not a fan of some of the more recent things like the PHP namespace implementation and the push to use Composer for all things.
PSR-2 
A set implementation with any degree of usefulness should require its content to implement a `Hashable` interface. You cannot blindly assume every object you insert can be cast to an int or string. ``` interface Hashable { public function getHashCode(): int; } interface Set { /** * @param string|int|Hashable $value */ public function add($value); } ```
I was in your boat: started with Python (owing to a background in academia) and moved over to PHP as my interests shifted to web projects. PHP is a language that has suffered bad PR incommensurate to its (albeit real) flaws. Luckily, it’s kind of decent now, thanks to major efforts to smooth its rougher edges and make it run faster. There’s also a good package ecosystem now. I find Composer (PHP’s package manager) a lot easier to use/faster than pip, and I like being able to pull in a project’s dependencies without globally installing them. There’s endless discussion about PHP frameworks online, but I feel that frameworks (in the traditional sense: huge, coupled libraries that for all intents and purposes become your application) in this day and age aren’t strictly necessary. If you don’t like Django, I’d stay away from Laravel (it’s fun to use but has some similarities with Django: oodles of magic, one-liners that do tons of stuff, and an ActiveRecord implementation than can get you into trouble). If you like Flask I’d look at Slim or Zend Expressive, which offer something similar in terms of flexibility and light footprint. They give you the basics for building an application: http messaging objects, routing, dependency containers, and optionally HTML templating. Beyond that, it leaves it all up to you. Good luck!
&gt; You can use Composer to create new projects from an existing package. This is the equivalent of doing a git clone/svn checkout followed by a `composer install` of the vendors. It requires a package to exist, just like your solution. If it works for you then that is cool, but I don’t really see any additional value in your solution.
NTS
No need to the shitty. I misread your comment as saying pusher was a free open source alternative to this 
Nope the browser needs to support the eventsource interface. Right now only edge and ie don't support it... but theres a polyfill for that! https://www.npmjs.com/package/event-source-polyfill
My company is currently finishing a Multistore magento 2 store, customer has a store on several nordic markets. But only one catalog, so main office creates products for the catalog in english locale and then each region changes the content to their native language, this way the stores share the same inventory etc. And anytime we need some code changes we only need to do 1 deployment, it works quite well. Another scenario we have is with WordPress multisites, here we used them mostly for customers that have either multiple markets so they can change all content with one login or for customers that create a early report website or any recurring event that requires a new site. Again one login to manage al content is by far the greatest pro. 
Yes, start using PHP and Laravel, see if you want to go back.
Never 😂 unless the site is 100% is identical apart from content - do the respectful thing and give each site its own install. Loads of benefits for keeping separate such as migrations down the line, if 1 website gets hacked they all get hacked, if one goes down they all go down, if 1 needs version X of plugin whilst 1 needs version Y. It’s just overly complicated unless your running a massive network 
Try to learn both. Pick which ever one suits you best Pick which one you enjoy using best Pick which one gives you the best job prospects in your area Pick which one your better at
Wat?
Is there a way to use this in a symfony 4 application?
@OP [StackOverflow answer for context.](https://stackoverflow.com/questions/1623914/what-is-thread-safe-or-non-thread-safe-in-php)
I changed my backends to Slim PHP couple years ago and never looked back. It's lightweight and simple to use, you can spit out APIs in no time.
Both. Python is great if you need to write local scripts for automation etc.. I use it for network automation and gathering facts. Pythons multithreading really shines in that regard (although with swoole etc the future looks bright) Api endpoints and web guis are best written in php. :)
If client runs multiple, basically, identical sites, just different contents (say regional stores or something to that type of deal) - then okay, makes sense. If you mean multi-site as in multiple clients running from a single install each having their own database - no, these days with cloud hosting, containers and cheap VPS makes no sense to do that. Security and data protection being one of the bigger reasons, but also just technical challenges and feature development segregation - clients that are serious about building up their projects will eventually come to the custom feature development and at that point you are required to have separate installs.
&gt; Django is absolutely fucking horrible. Flask is decent but it is so uncommon that it's completely unrealistic to use for complex backends. Whatever language you learn, if you keep going to the most popular framework you'll be dealing with shit. Just saying it like it is. You can create arbitrarily complex backends in Python, PHP or just about anything if you learn to combine components and build your own architectures.
Well, I do agree it requires a package to exist. But...only once. Then you'll have it as a terminal command to scaffold new packages. Anyway, it was just an experiment that might turn out interesting for someone. :) Thanks for your feedback mate!
Haha thanks for the answer.
I’m trying get to TDD. Can you please explain me what TDD concept I broke in case?
Why do you think you broke anything? This post is useless as you are not providing anyone with any information.
&gt;I find Composer (PHP’s package manager) a lot easier to use/faster than pip, and I like being able to pull in a project’s dependencies without globally installing them. You don't globally install a project's dependencies in Python, you put your project in its own virtual environment to keep its dependencies self-contained away from the global installation of Pyhton.
In my example all TDD paradigms are satisfied (as far as I understand them). But you can tell that something is not all right with the code. So maybe I misunderstood something. And I'm asking for help to point out where I made a mistake. This is the goal of my post. Sorry, for not making it so clear.
Nice attempt, but did you even test it? $s = new Set(['a', 'b', 'c', 'c']); echo '[' . implode( ', ', $s-&gt;values() ) . '] length = ' . $s-&gt;length; echo "\nAppend d: "; $s[] = 'd'; echo implode( ', ', $s-&gt;values() ); echo "\nforeach: "; foreach ( $s as $i ) echo $i . ' ';
You are supposed to "cheat" until the "correct" implementation is the simplest. Until then, add tests. In your example, using dataProviders instead of writing a new test each time will make "cheating" a lot harder, thus pushing you in the "correct" direction.
What's not right with it?
What would restarting the php process accomplish in this case?
If the file is deleted that doesn't stop process from running in system memory 
Ah, I see what you mean, well, if this was in a daemon maybe, but that's pretty uncommon for PHP processes, and not common at all for FPM or forms.
Yeah you simple have to start that giant go blob. Very simple.
Best practice is to use a virtualenv, but I see global package installs far too often in production environments
Well, Swoole isn't something you can just plug in to any PHP project. You'd first have to install their extension, then replace existing components with swoole components. Therefore, it's only viable for someone in control of their full environment. If you are using swoole\_http\_server, you need to build your application around the idea of long-living processes where you need to be much more concerned with statics and globals. Having fooled around with Swoole, I think it is a great way to get the most performance out of PHP applications, but it's definitely not for everyone.
Yup, check out the docs!
For the setup that is pretty much taken care of, with a reusable container setup. Could you elaborate the part about long living processes. We mainly work with Php frameworks like Symfony and Laravel among others, what would I need to be careful about ?
Well, as far as I know, unlike the traditional PHP environment where memory is confined to one request, in Swoole, or any system that uses a long lived process, memory can span multiple requests. Therefore, when you define a global, or define a static property, those values could live for multiple users/requests.
If you ever read any articles summarising the benefits of PHP over other technology they will always talk about the fact that PHP runs one thread of execution per request. It starts, handles a request, then exits. This means if there is an issue with handling a single request, it doesn't effect all subsequent requests. Tools like Swoole and ReactPHP are essentially designed with precisely the opposite approach which is that your program starts and then continues handling requests until it is stopped. This is more like how frameworks like Ruby on Rails and Django work. There are pros and cons to both but it does always strike me how these new technologies are designed to get around what is often hailed as the primary benefit of PHP.
Nice component! &amp;#x200B; I'm not comfortable with: `$publisher($update);` Any advantages over `$publisher-&gt;publish($update)` besides shortness?
Alt+J to select the next occurrence with multiple cursors makes refactoring simple.
Awesome - I never knew that existed, and I already know I'll use it before the day's over.
That is indeed correct. Memory is shared inside a worker process. Swoole spawns up multiple worker processes that handle incoming requests. This is also on of the reasons it’s much faster: everything will already be bootstrapped when the request comes in, compared to a traditional request lifecycle where everything needs to happen starting from the moment that the requests comes in. Because of this, global and static variables live in the scope of the worker. This means that different requests handled by the same worker, share the same memory space. Not regular variables though, swoole takes care of cleaning them up. As to how hard it is to convert a traditional app to swoole, well not too hard from my experience. You probably shouldn’t use global variables anyway and checking your statics also is very easy. The only tricky one is converting your singletons into something that does not use statics, or reset them after the request has finished.
Ctrl+G to add next occurrence of what you have highlighted to your selection as another cursor (multi-select). I also use Cmd+E instead of tabs and Shift-Shift to open files. ❤️ Intellij
This post about PhpStorm sure looks like an ad for PhpStorm about PhpStorm the #1 PHP editor for editing php documents. Get your copy of PhpStorm today!
You can't use pdo postgresql because it's blocking
My comment will look like an ad for PhpStorm, but I'd like to say that PhpStorm doesn't really need spambots to advertise. The product speaks for itself. &amp;#x200B; &amp;#x200B;
I guess I can understand that, though that was not my intention. &amp;#x200B; I was standing at my workstation (visual evidence in link) working on an update, hit ctrl-d to duplicate a line, hit "ctrl-w" to highlight the jQuery selector string to modify it, and thought - man I like shortcuts. That made me wonder about shortcuts I might not even know exist. [Another day at work](https://imgur.com/tqySvqi) &amp;#x200B;
Spambot? I really am a guy...no Beep bop boop here. &amp;#x200B; Let's see...how to prove that without the two of us sitting down for a Turing Test. &amp;#x200B; I posted an image of my workstation, but I suppose someone could fake that. My new refurbed Lenovo P520 is on its way today (just random info that I don't think a spambot would throw out there). I think Mega Man could bean Iron Man in a fight. And I think your post in r/startrek asking about whether or not the science position still exists in TNG+ era is a valid one, since no one on the deck of TNG's Enterprise seemed to carry the title.
I always hated ctrl w, not for the functionality but in every-other-editor-ever-created it means close tab. 
1. CTRL + F12 - show class members and methods 2. Highlight text, CTRL + SHIFT + N -&gt; find file dialog with highlighted text in it - I'm 99% sure most of us PHPStorm users use this one 3. ALT + F12 - bring up the terminal window 4. Classic, CTRL + click the symbol (function, class, variable, etc), go to definition 5. SHIFT + F6 - rename selected file
Valid point. I guess I never used it enough in other editors to warrant re-assigning it.
Because why would it be something useful, such as "Share your shortcuts for the #1 PHP IDE out there", right? It simply must be looking like an ad, and you simply must be a witty, funny guy with fuck all to contribute. Because it's so hard to make yourself useful for 5 seconds. Thanks for gracing us with your amazing pattern recognition, I'm surprised it only took less than an hour to start derailing this. Good job, 5/7 and 1 internet point for you. Spend it wisely.
You should try taking a few deep breaths. Are you having a rough day?
I said you aren't a spambot. I think you misunderstood my post. I said PhpStorm doesn't need spambots, so they don't use any.
CTRL+B for me, going instantly to function, variable or class definitions. 
Ahhhhh...I see. You were responding to the other comment that implied I was a bot. My bad!
Ctrl + F, Ctrl+Shift+F
I know it's simple, but the amount of times a day I 'Ctrl + Shift + F ' to find string occurences across files, it's definitely worth a mention. 
I was extremely happy when they fixed the focus bug with the double-shift. 
double left shift to search everywhere
Not a php storm user here, and though I have to say that the functionally sounds nice, why does it have to be ctrl-w? That short cut is fairly universally used to close tabs
Also, middle mouse button down
If youre working with PHP professionally and not using PHPStorm, youre doing yourself a disservice... coming from a long time advocate for VSCode.
Ctrl+alt+v to extract statement to a variable. Ctrl+alt+m to extract a chunk of code to a method.
I've been using vim for about 15 years I'm good, thanks. 
It's obviously your workstation developing on PHPStorm at intelliJ, what else could it be!
You can remap it. Honesty, at this point I can’t remember if that’s the default or if I remapped it. 
You can freely remap it.
You're free to map it to whatever you want.
It's alt+up and alt+down on mac and cmd+w closes tabs. One of the few changes about shortcuts I like on mac.
Dear internet friend, if I roll my eyes on mental bullshit that you posted - it doesn't mean I have a bad day, it just means I shat on your post and that's all :) Relax, you're not that important.
Ctrl / to comment. I miss that when I go to some other IDEs
I'm sorry if my joke offended you, I hope you have a good day!
I’ve found myself hitting in when in other editors without even thinking about.
Thanks everyone for all of the great advice. I think I figured out the issue and it appears to be solved. The form in question was copied and accidentally added to another of my client's sites (by me for reasons), and that is where the spam submissions were originating. I was able to figure this out once I learned how to look at the entire email header information. All this time it was my own dumb fault. Again, I appreciate all of your suggestions and help. 
Shift+Alt+Up to move a line or selection up. Shift+Alt+Down to move a line or selection down.
Just thought of one myself that I use countless times each day to format my code: **ctrl+alt+f**
How can I only give you one?! There are so many!! CMD+ALT+L to reformat a file. I do this reflexively as I pause and think about what to write next! CTRL + D to delete a line. CMD + up arrow / down arrow to move a line/selection up and down. I love these when refactoring. CMD + 1 to toggle the file tree navigator CMD + 4 to toggle the terminal CMD + 5 to toggle the debug window CMD + 7 to toggle the code structure window &amp;#x200B;
Dear internet buddy and PHP user, I'm very sad because I realized you don't know what being offended means. If I were to be offended, it would be because you and I are of the same species, not because of your useless and misplaced joke. No worries, I mean nothing bad. We can shake hands and go our separate ways after this exchange, have an awesome day! :)
**Ctrl + Q** (Not its original, its a remap) for "**Navigate -&gt; File**". Start typing in partial directory structures/names and it'll come up. Ex: a/f/c/cus can pull up app/front/controllers/Customers.php &amp;#x200B; **Ctrl + Shift + F** for "**Find in Path**". Finding the text string / method in the entire project is incredibly useful.
I'm very partial to `Ctrl + F10` and `Ctrl + F9`. I write unit tests when I fix bugs as a way of consistently hitting the bug while I work on it, so rerunning over and over, especially in debug mode, is really really nice. Then again, `Alt + Enter` is pretty amazing. I use the Intentions for so much from quick fixes to spelling renames to automatically initializing variables after putting them in my constructor that being able to just open the intentions menu from the keyboard is great. Since I've become spoiled with an IDE, I can't remember parameter order anymore. Even for functions I **just** saw the parameters for. So, while I'm busy putting parameters in, I **love** that `Ctrl + P` shows the parameter order and, more importantly, *what parameter I'm meant to be putting in now*. Fuzzy search everywhere has become my favorite method of jumping between classes, even when I already have the file open, so `Shift + Shift` gets used a *lot*. In the less used shortcuts, I like to use the Code Generations and Terminal often, so `Alt + Insert` and `Alt + F12` are basically stuck in my brain now. I think those are my favorite default mappings. I also use the IdeaVim plugin, so I've got some nice vim shortcuts I like, 
Similarly, Ctrl+Alt+Shift+J, to select **all** occurrences.
Also, Ctrl + Left Mouse Button.
I set up my middle mouse wheel plus ctrl and shift to split my view. I use this constantly so I don't have to jump back and forth between files. Ctrl + Button2 = vertical split Shift + Button2 = horizontal split Ctrl + Shift + Button2 = Close split
my condolences
&gt;I'm sorry if my joke offended you At this point, I'm offended by your stupidity. Not by your pointless previous post.
CTRL + ALT + L for auto formatting code. 
I am biased towards Laravel as I did few project with it and then tries symphony to see how its like. And most importantly, I never got job asking for Symphony so Laravel it is for me. 
Source? I've been using PDO in coroutines without any issue, but it was MySQL and not Postgres. What did you find, where's the source and how to reproduce it? 
the multiple paste is nice, if you had something in your clipboard and accidentally copied something there's no need to go back and search for the thing you previously copied, just do **cmd + shift + v** and there will be a list of recent copies
The biggest con is that you need to be aware of what you're doing and why. This means you have to know about process control in order to wrap your head around it. We, programmers, start with a problem and then we find the best tool to smack the problem with. In an ideal world. Nowadays, we've got tools such as swoole so we keep coming up with problems to smack them with this new tool and that's what's wrong. We use the wrong problem for the wrong tool. Setting that aside, the biggest technical issue that I experienced was lack of documentation and resorting to reading the source in order to get answers. When it comes how it works, whether there are gotchas or something similar - I haven't encountered it yet I've been using swoole for ~6 months now, my use case is an async service worker. I know it's a buzzword and people roll their eyes as soon as "microservice" or "background service worker" or "async" are mentioned. Idea is that I fire an event over the network and one of the workers picks it up, does the work and awaits the next payload. No response involved, ZeroMQ used for transport. I used a different stack prior to swoole, it consisted of a supervisor process, pthreads extension and LibEv extension to expose system's event loop and a *lot of* "wtf, how, I'll pull my hair, I fucking hate this shit". Swoole elegantly solves a ton of issues I had. I managed to glue Lumen to swoole and to my surprise - it actually works well, even when you try and break things like persistent connection to MySQL etc. (log in to mysql terminal and kill the connection process towards php-fpm, expected: "MySQL server has gone away", received: Lumen actually reconnected) However, PHP-FPM is: 1. tested 2. passed the test of age 3. well supported 4. works 5. scales easily (you can scale swoole the same way but still) 6. I'm aware of its gotchas 7. documented And it performs fast enough. Sure, you can use swoole and serve http traffic and get huge RPS that I don't need. I believe that using it for websocket server and async task gobbler is an excellent use case, in my experience - that's where I got most bang for the time invested. 
Whoa
I hated it the most when I used Cloud9. So used to expand current selection, I ended up closing the IDE tab again and again until I stopped using it :( Also, VSC doesn't support it!
I've had a moment in my life, when FPM and/or web server glitched out and didn't stop running in the background, that's why I proposed this. Sure - You are completely right, it was just a harmless suggestion from previous experience 
I find \`CTRL + SHIFT + ALT + INSERT\` really useful for quick JSON sketches
Shout out to anyone who swears every time they're working on a document in GDocs/Word/Notepad that tries to highlight a line to wrap quotes, deleting what they wrote. I am a cursor curser. My favorite, I have lost and can't remember how I mapped it, was CTRL+RtClick+drag to put a cursor on every line you drag through.
**Cyclic Expand Word** (and it's "Backward" variant): `[shift+]ctrl+alt+cmd+space` (custom key binding) I use this waaaaay too much. It basically "autocompletes" the letters under your cursor, and cycles up (or down) through words using fuzzy-matching in current and/or open files. It saves me lots of time when writing spec tests and code (like quickly typing out parts in a function name, string values which don't have a constant [yet], ...).
[They advance as does his chance, very yellow white flash. ](https://youtu.be/S3fTw_D3l10)
I could certainly get behind listening to more of these, even though I think I was personally on the receiving end of a slightly frustrated sigh about 6 and a half minutes in, haha. 
Ctl+Alt+L =&gt; Quick reformating Ctl+D =&gt; Duplicate current line or selected code Alt+Tab =&gt; Remove one tab spacing at beginning of line Ctl+Shift+N =&gt; Quick Search File by name Ctl+Shift+Arrows =&gt; Move the line (or selected code block).
I recently learned double shift to take me anywhere in my app and it's glorious.
Shout out to the [Key Promoter X](https://plugins.jetbrains.com/plugin/9792-key-promoter-x) extension, which can help you learn keyboard shortcuts for things you do via clicking / menus.
Wow that would be my #1 concern, is being able to find a job. 
If swoole installation is too complicated, try this one: [https://github.com/spiral/roadrunner](https://github.com/spiral/roadrunner) &amp;#x200B; I got crazy performance improvements with Symfony, even in dev. It is easy to install and in docs, you can find how to restart it on file change. &amp;#x200B; My next project will definitely be running under RR, just need some more testing before doing that. &amp;#x200B;
I remapped ctrl-w (and ctrl-shift-w) to the mouse wheel. I also mapped cut and paste to my mouse-4 and mouse-5 side buttons, this makes for some super productive editing... Try it out!
When you need to format some code block you have in your clipboard (I use mac): Cmd+shift+N -&gt; select the correct scratch file type (PHP, SQL or JSON) -&gt; ctrl+v -&gt; cmd + alt + L (format) Voila, whatever code you had in your clipboard is formatted in a scratch file. Useful for prettifying JSON, queries or code you are analysing.
Going to install it right now. Thank you!
Saving this for later
i prefer shift+f6 for refactoring
That's rad
So they're using the "TAG SPACE" character - https://www.compart.com/en/unicode/U+E0020 It's weird because it shows for me in some contexts and is invisible in others.
I installed it - and it seems great - but I'm not sure it adds any more information than the IDE's UI already provides. If a menu action has a keyboard shortcut then it shows that next to the menu item in the menu already. 
Good bot
Love it
Is it bad that ctrl+x is my favourite mostly for deleting blank lines to tighten code.
it's not April Fools yet 
That's good, especially when renaming a class or method, but Alt+J can be used for more, like renaming both a method and a variable at the same time on verbiage changes, changing strings, almost anything in an HTML context (links, text, etc). There's a lot of times I find myself needing to cross boundaries and symbols when refactoring.
For finding files, Ctrl-N is better, because it searches for classes and files, not file content. 
Nice! Great initiative!
Ctrl-Alt-P extracts as a parameter of the current function/method (and places it in all calls). 
That's pretty annoying on Ubuntu because it overlaps with OS lock screen. I remapped it to K
IIRC it can move whole methods too if cursor is on the signature 
Working along today, I just thought of another one. While editing a file, this series of strokes: &amp;#x200B; Alt+F1 then hit Enter &amp;#x200B; Alt+F1 opens the Project context menu, then hitting enter on the default selection means "Find this file in the Project View", which immediately focuses the project file window on the file I'm editing. I use it a lot. If I'm editing a class file and I know I need to look at another class in the same namespace, then this immediately moves the Project Window's file view right to where I need to be. &amp;#x200B;
CMD click on Mac
Or you can use save actions plugin and do the formatting after save 👏
If you are using PDO then your blocking the request until the query is complete. PDO does not support async commands, this is where you call your queue, and have some callback for when its ready with results. MySQLi has support for Async queries, but MySQL connections are still not asynchronous, so there is a cost to opening and closing MySQL connections. Normally you'd use pooling, with a way to ping, or check if the connection has closed, but I've not run into a single library that does this well enough in PHP land. So unless you push queries into its own process, then your blocking the event loop. &amp;#x200B; I do not know of a worker type process that can block, by being moved out of the Swoole event loop. At least that Swoole supports out of the box. On the JVM there is Vert.x that supports blocking request so old database libraries like JDBC, which was never designed to be used in an event loop, can be used. [https://vertx.io/docs/vertx-core/java/#blocking\_code](https://vertx.io/docs/vertx-core/java/#blocking_code) If you know of something Swoole that supports this, then it would be nice to know.
Do you have a link to this plugin?
I can vouch for `Cmd + E`. Seeing someone else use the tabs just seems horribly inefficient now.
AFAIK Visual Studio Code uses the same shortcut. Not sure about other IDEs and editors though.
WHY WOULD YOU WILLINGLY INFLICT THAT MADNESS UPON YOURSELF???
Absolutely! https://plugins.jetbrains.com/plugin/7642-save-actions
Here are some i have become accustom to using frequently. (Windows Shortcuts BTW.) `Alt + Ctrl + Shift + Insert` Create scratch file. `Ctrl + Shift + N` Quick search by filename. `Ctrl + Shift + U` Switch selected text between upper/lower case (Although, [String Manipulation](https://plugins.jetbrains.com/plugin/2162-string-manipulation) plugin is a plus for camelCase/PascalCase/snake\_case stuff (Quick pop-up via `Alt + M` and using num-pad navigation)). `Ctrl + Alt + S` Settings (Cursor automatically goes to search box too). `Shift + Delete` Yank a line (similar to cut). `Ctrl + Shift + V` Paste history. `Ctrl + Alt + Shift + V` Paste WITHOUT formatting/escaping (More of a system wide shortcut). `Alt + Ctrl + L` Reformat code to style.. `Ctrl, Ctrl + &lt;Up or down arrows&gt;` Column select with cursors (Quick Double tap and hold Ctrl). `Alt + Left click` Multiple Cursors (With click held to select, will do column selection). `Alt + Shift + &lt;Up or down arrows&gt;` Move a line up or down (or section if selected). `Ctrl + Alt + T` Surround with ... ( foreach / while / Editor fold / etc.. ) `Alt + \`` VCS operation pop-up. I've found that most scaling shortcuts (`Ctrl, Ctrl + Up`, `CTRL + W`, `Alt + J`, `Tab`) Will work backwards if combined with `Shift`. Also, massive shout-out to [Key Promoter X](https://plugins.jetbrains.com/plugin/9792-key-promoter-x) which will recommend keyboard shortcuts as you work.
I don't see it as a primary benefit. That is why you get 50ms minimum on a Symfony request, because on each request apache must read include and evaluate ALL files each time. That approach doesn't scale. You have heavy languages like Java, that have a lot faster response times, simply because everything is loaded in memory, and nodejs handles x10 more requests in a single thread. &amp;#x200B; This is a limitation that I personally hate. Swoole is a good way around that limitation.
I assume you're on 16.04 or earlier? I'm on 18.04 and the lock command has changed there (presumably due to the switch to Gnome as a DE?). Lock is Super+L on there so Ctrl+Alt+L helps make my code not look so god awful on the regular. That and having grumphp in my projects.
Great topic, I’ve learned lots of neat shortcuts already. Cmd-[ (go back) is probably well known, but is a fav for saving me so much time.
There are projects that devoted to running symfony-laravel with Swoole and you should not have any limitations/problems. But if you are going to use swoole as a web server, there are more appropriate ways to run your app, like ppm [https://github.com/php-pm/php-pm](https://github.com/php-pm/php-pm) In my tests I found that symfony runs faster with ppm than any other setup (Apache swoole etc). Apache was a close second and performs excellent, only problem is it takes to much memory, so scaling can be a problem. 
I work on linux, so I'm wondering, is that **"Last edit location" shortcut**? For me it's **Ctrl+Shift+Backspace**, and I use it hundreds, maybe thousands of times a day. I use it so much it's become a part of me and is probably why I didn't even think about it. To me that command is as essential as the space bar.
I miss out many oft those cool kids shortcuts because I use IdeaVim :( I simply use my VIM-foo though because I use IdeaVim :-) It's not perfect but gets the job well done.
Tried it a year ago, but it immediately turned out to be too annoying, unfortunately.
i alternate between mac and linux, and that shortcut always messes with me.
I’ve had times when I subconsciously start typing vi commands in PhpStorm, then have to delete the “yy” I just typed in my code. Whatever works for you!
A top 10 list from a youtube spammer? No thanks, go somewhere else.
Mh to be fair I had that issue before on 16.04, I remapped it and never changed it back, so you're probably right. 
For science.
haha it me
What she said. Not that I'm one to talk, using the sheep character as an alias for a clone function, but at least that's visible 😂
Remap it. I've already remapped a few phpstorm keys so that they match Sublime Text for me :)
same as F4
Exactly why I remap it to ctrl+alt+f (Also - “f” for format makes sense)
I haven't actually seen postings for Symfony jobs in my area, but there's a decent number of Laravel jobs. Take that as you will.
:q
Usually Shift + F6 for me. Guess that tells a lot of what I usually do :)
Why? Vim is perfectly fine and arguably more productive once you really get used to it and adjust it to your liking, although the learning curve is quite steep. Personally I can't see myself using anything other than PhpStorm, but some of the best developers I've worked with were using Vim exclusively.
Once you're on your 20th individual installation that you need to maintain multisite starts looking a lot nicer. Updating 1 multisite install on a Drupal zero day patch drop is relatively quick, doing 20 separate updates? Less so. It's arguably a lot nicer now that Drupal can be managed by Composer though.
You forgot to finalize the tuple: we can extend the tuple and adjust it. I think if you make the class final, you have your tuple...
I don't think I've used an editor that doesn't have this keybinding?
I've not voted, but your post isn't offering nuanced and constructive criticism - it's just angry flamebait intended to cause trouble. We get zealots here from time to time preaching the good word according to St. Awesome Tech, and I think it's a waste of time - don't be one of them. 
Good catch, thanks!
Don't confuse TDD with test coverage. TDD is a way of writing programs which requires that no production code gets written before there is failing test covering it. Meaning you write the test case it fails. When you write the code. When code is green you continue with the test case it fails, you implement the code. And while it sounds rather strict and that it may ensure quality of code .. we still don't have conclusive evidence that it actually does. Some prominent figures in programming like Robert C Martin just likes to talk about it a lot and that made it to some relevant CS literature unsubstantiated. Now that's not to say that unit tests don't help. Make sure you write the unit tests to cover the code you commit. But whole TDD schtick, might not be all that helpful as it's proponents report to believe.
Preferable: &lt;?php const TUPLE = [1, 3, 5, 7, 9];
LOL, it doesn't even list mine.
https://media.giphy.com/media/fCTrE63iVlpn39V0vF/giphy.gif
I wish I understood these jokes :(
Nothing against Vim, it's more the attitude connected to that guy. It's just fitting. Hes appearing to me as the usual 40yrs old dev writing PHP4 unable and unwilling to change his ways taking the slightest positive/useful thread about an IDE he doesn't like/know as an offense.
I'm surprised that the majority here seem to be Windows users.
Don't sweat it, you'll get there, it just takes time and experience. A tuple is basically an array that can't be modified after it's been created. I borrowed the idea from Python (which isn't its origin but that's where I was introduced to it). I made this package as a proof of concept, just for fun. I added a function called `tuple()` that returns an instance of a class I wrote that acts as an array thanks to PHP's [`ArrayAccess`](http://php.net/manual/en/class.arrayaccess.php) interface, and restricted the functionality that allow someone to remove or update items in it, effectively making it immutable. Like a tuple. Today I had the idea to add a function that has a blank Unicode character as its name and returns an instance of my tuple class. This way it would look like the developer was only typing parentheses, which is how you can declare a tuple in Python. The joke in this is that a function with this name is a bad idea because someone else will see it, and it will trick them and cause confusion. Here's a Python example of tuples: ``` foo = (True, False, None, 'hello world') print(foo[3]) #=&gt; 'hello world' foo[1] = True #=&gt; will throw an error ``` And PHP, using my package: ``` &lt;?php $foo = p810\Tuple\tuple(true, false, null, 'hello world'); echo $foo[3]; //=&gt; 'hello world' $foo[1] = true; //=&gt; will also raise an error ``` Hope this makes sense. I can explain further if you want.
I was doing the same thing with nginx-push-stream myself. nchan does more tho iirc.
r/learnphp
Thanks I learned so much.......................
How did I live without this!
Yes
Interesting approach, I like it.
&gt; thanks to PHP's `ArrayAccess` interface PHP's ancient "kind of an array but not really except sometimes" structure is one of my biggest remaining gripes about the language. 
Framework: custom symfony skeleton based on initial conditions and needs. You will be able to extend it as you're needs grow. It allows to keep your initial dependencies lean while not shutting away options for extension if you may need to make architectual decisions later. API: Not sure about API platform being very flexible solution. And that might corner you in at some point when you'll find that you need some more complex interactions between your services, like auth flows, especially given that you mentioned microservice architecture (more about that later). Better solution might be something like Swagger, there are plenty of client generators for it. In our company we made a choice with RAML in earlier days and while it lost to Swagger in popularity, we use internal tools to generate boilerplate of entire bundles with entities, controllers, normalizers, basic validators etc, not just JS/PHP client libs. ORM - Doctrine. You've mentioned complex business logic. And if you are intending to register application state changes while executing it, AR doesn't scale very well. Make a convention to flush only at controllers / commands / listeners though. Architecture. Avoid microservices. I'm rather baffled how it became such a hyped buzzword. To this point I don't think a lot of people who use it quite grasp how it became a thing. The reason you would do distributed services is when you have distributed teams so that they can safely parallelize and not get into each others way in CI &amp; CD flow. This puts huge strain on communication and adds quite a lot of complexity to your infrastructure. Microservices do not add speed or reliability by themselves. They are, however the only way to scale for distributed teams. So simply go monolith. If going monolith doesn't make sense entirely you can split your application in few meaningful parts like auth server, integration layer / gateway (with 3rd parties), and your api layer. But try to keep it as tight as possible. There is absolutely no need to overcomplicate things when you have a team of a handful of people.
I have go back to last edit and the opposite binded to my mouse thumbs button. So useful.
It's the default. I have: - ctrl w: close tab - ctrl shift w: close all tabs - ctrl alt w: close all except current - ctrl shift t: reopen last closed
What framework?
Stick with symfony for now, then later on learn laravel. It's not either-or, and if you want to make a living off php you're going to need both.
They did. HttpFoundation wouldn't work for streamable request and response bodies and had a number of inconsistencies, but PSR-7 did pluck a lot from it IIRC from the initial design discussions I followed shallowly. The one thing PSR-7 failed on in my opinion was what PSR-17 is now solving - diff implementations of PSR-7 vary on the constructors, and streams do require a lot of boilerplate to instantiate. Using PSR-7 is great, but creating PSR-7 objects has very poor developer experience.
i used to do this, but now i use ctrl+shift+i to get a pop up window to just peek at the function code — that’s what i’m usually doing anyway and then i don’t have to navigate back. works for php built in functions too! 
Alt+F7 to find all places a function has been called from 
&gt; top 10 list &gt; poor quality &gt; Indian accent 
It should be noted that tuples have nothing to do with whether they are immutable or not, it just so happens that many newer languages do it this way. In c++ and many other languages its common to be mutating tuples.
Great power comes with a great responsibility
This isnt necessary for a tuple, unless you're trying to copy pythons exact implementation. Tuple by definition as a term is completely unrelated to its mutatability. 
Sounds like me, except it's an endkess cycle. I started with php, went to python, started java, went back to php, went back to py, then javascript, then godot, back to php...
I hate python ... but I want to learn it
you could start by looking at existing solutions like https://easyappointments.org/
Thank you very much, I'll have a look into easy appointments and see what I can do. Your help is very much appreciated!
i have this sample request from [https://www.dataaccess.com/webservicesserver/numberconversion.wso?op=NumberToWords](https://www.dataaccess.com/webservicesserver/numberconversion.wso?op=NumberToWords) &amp;#x200B; POST /webservicesserver/numberconversion.wso HTTP/1.1 Host: [www.dataaccess.com](https://www.dataaccess.com) Content-Type: text/xml; charset=utf-8 Content-Length: length &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;soap:Envelope xmlns:soap="[http://schemas.xmlsoap.org/soap/envelope/](http://schemas.xmlsoap.org/soap/envelope/)"&gt; &lt;soap:Body&gt; &lt;NumberToWords xmlns="[http://www.dataaccess.com/webservicesserver/](http://www.dataaccess.com/webservicesserver/)"&gt; &lt;ubiNum&gt;unsignedLong&lt;/ubiNum&gt; &lt;/NumberToWords&gt; &lt;/soap:Body&gt; &lt;/soap:Envelope&gt; &amp;#x200B; how do i convert it into something useful in php that can be sent into the webservice ? 
I hope a PHP patch will break this before people get injured.
Learn an MVC framework like Laravel ... local dev using laravel homestead + Sourcetree + Github + Laravel Forge &amp;#x200B; That would be a great use case to learn laravel with .... and thing like authentication are built in ... super easy to make DB CRUDs
I shall look into it, appreciate your comment. I'm a web student and your recommendation looks great so far. Thank you!
Feel free to msg me with any questions
Oh, that's just 𝕌𝕟𝕚𝕔𝕠𝕕𝕖 for ya.
I like the keyboard shortcut that makes it index every 2 minutes and lock up the mac. 
&gt; on each request apache must read include and evaluate ALL files each time I mean that's not really true, it only needs to do that on the first request served, then afterwards it's just loading the code from opcache which is in memory. It used to be like you described, a long while ago, and PHP was much slower because of it.
ctrl-t This is great if you work with multiple projects/vcs roots open in one window. It's "Update Project" and end up being "Pull all projects". Also * ctrl+alt+shift+insert for a scratch * all the refactoring ones. just learn the all. f6 vs shift f6 is important, move vs rename, and it applies to namespaces. extract: variable=v method=m God, so many others
It lefts me with cntrl+shif+a, search and execute any command/setting.
Does it have to be XML? The API in question allows Json as well: ``` POST /webservicesserver/numberconversion.wso HTTP/1.1 Host: www.dataaccess.com Content-Type: application/json; charset=utf-8 Content-Length: 3 { "ubiNum": 124 } ``` And you get ``` HTTP/1.1 200 OK Content-Type: application/json; charset=utf-8 Content-Length: 28 "one hundred and twenty four " ``` straight into your ``$_GET`` superglobal.
And yet, when you change a file, it is automatically updated. So that means that the files are read, again, on each request and new files are evaluated. On every single request. If you have lots of requests, that is a problem. I have seen it.
We need to restart fpm in order to 'see' our new files after a deploy. Perhaps you didn't configure your production server right?
https://morioh.com/p/2576bf4bb153/build-a-simple-rest-api-in-php
The one I didn't like (before I remapped it) was `Ctrl+Y`, deleting an entire line. That's what Redo it's in a lot of programs I use. I moved it to `Ctrl+Alt+Shift+something` so that I'd only hot something like that if I meant to.
I have to say, this post is pretty nostalgic. Feels like going back about 15 years with a time machine to see how things were handled back then in PHP. For starters, I would avoid just using md5 on passwords. There is a password_hash function now, which handles all the underlying hashing stuff and uses secure defaults.
Insecure password storage. Author should read ”PHP the right way” before even thinking of writing anything public.
Let's see.... well at least it's not using the removed mysql_ functions - a good start! Might actually work in PHP 7! "Create registration page".... oh dear, here we go: * Mangle data with completely unnecessary stripslashes * Mangle the password even more - stripslashes, real_escape_string, THEN md5 it?!??! (peeks at login.php further down - well at least they mangled it in the same way there - I guess that code "works" then) * Does not use the password_ functions. md5 is broken for security purposes and has been considered so for (checks) TWENTY THREE YEARS ([since 1996](https://en.wikipedia.org/wiki/Md5#History_and_cryptanalysis)). Do not use it for passwords! * No prepared queries - we have to remember to explicitly escape everything * Manually inserting a date into SQL when we could just use NOW() * Zero error handling - Apparently we're just going to return the user to ~~~the login page~~~ - not even that - a blank page, without saying anything if there's any kind of error (temporary network glitch, DB server is busy, DB service / server is rebooting) * User is returned to a blank page if the username or password is incorrect I think I'll stop there... Another terrible tutorial you definitely should not follow
Yes, all developers should run projects in same environment. Use docker. Automate the dev environment set ups to a few commands that other developers would just have to write few commands to interact with that environment and set up everything in working order. &amp;#x200B;
No, it's Navigate: Back. I didn't know about 'Last edit location' until now. The difference is that Navigate: Back takes you back (and can do forward too) to where you where last looking. So if you follow an execution path through the code you can reverse your way out. 'Last edit location' is based on where you have made changes.
ok so i assume you have to implement the client side of things? 1. Please use [http://php.net/manual/de/book.soap.php](http://php.net/manual/de/book.soap.php) 2. Please create a small wrapper class for the service - do not pass SoapClient around in your business logic. (that way you can fix all SOAP oddities, which often depend on the service provide not the protocol itself). I hope this works for you: // let's see if it works $soapClient = new SoapClient('https://www.dataaccess.com/webservicesserver/numberconversion.wso?WSDL'); print_r($soapClient-&gt;NumberToWords(['ubiNum' =&gt; 1337])); // now wrap that up nicely class NumberConversion { const WSDL = 'https://www.dataaccess.com/webservicesserver/numberconversion.wso?WSDL'; // TODO: putting the file in your source code will speed up things // const WSDL = __DIR__ . '/numberconversion.wsdl'; protected $soapClient; // dependency injection yeah public function __construct(SoapClient $soapClient) { $this-&gt;soapClient = $soapClient; } // this encapsulates the soap oddities public function numberToWords(int $ubiNum) : string { $params = ['ubiNum' =&gt; $ubiNum]; $result = $this-&gt;soapClient-&gt;NumberToWords(['ubiNum' =&gt; $ubiNum]); return (string) $result-&gt;NumberToWordsResult; } } // now it is usable as if it were local class written by ourselves $numberConversion = new NumberConversion(new SoapClient(NumberConversion::WSDL)); var_dump($numberConversion-&gt;numberToWords(1337)); &amp;#x200B;
following script: echo PHP_VERSION.PHP_EOL; echo 'start'.PHP_EOL; goto foobar; echo 'ignored?'.PHP_EOL; foobar: echo 'end'.PHP_EOL; prints: 7.3.2 start end 
The file isn't read to do that. System calls are dispatched to check if the last modified time of the file has changed. If so, then it'll delete the old copy from cache then cache the new version. Those system calls are way cheaper than doing a file read. You can also set rules in PHP config to change how this behaves. E.g. make it so in prod you need to do the cache invalidation yourself, and then no system calls will be made at all. Lots of ways to tweak performance that way based on your needs.
The file isn't read to do that. System calls are dispatched to check if the last modified time of the file has changed. If so, then it'll delete the old copy from cache then cache the new version. Those system calls are way cheaper than doing a file read. You can also set rules in PHP config to change how this behaves. E.g. make it so in prod you need to do the cache invalidation yourself, and then no system calls will be made at all. Lots of ways to tweak performance that way based on your needs.
Interesting... Putting an html wrapper on it and uploading to my host I get the error **[09-Mar-2019 05:31:35] PHP Parse error: syntax error, unexpected T_STRING in /xxxxx/test.php on line 11** In the error log and if I comment out the foobar lines irt runs and gives me **5.2.17 start ignored? end** 
Goto is still there. https://3v4l.org/nr7Nc
&gt; 5.2.17 start ignored? end So... you're actually running 5.2.17?
Paid for hosting so I have little control. It all worked up to the 7th and I assumed they did an update.
more like a downdate? 
Actually I thought it was running 7 so I'll look at the .htaccess et al
More like a downgrade. 5.2.17 is ancient. Most hosting providers have a "control panel" kind of thing where you can configure the PHP version. Or contact their support and ask them to change it.
Reverse update. :)
Kick around on the providers setup and get **7.2.15 start end ** 
Fixes to the setup now in place and reverted the code and it works! Thanks guys.
"7.2.15" is an anagram of "5.2.17"... someone must have confused something? :)
Trust me when I say use Unix timestamps for date/time storage. I also recommend storing in UTC. Also, consider using a library such as Carbon to help with date handling.
I appreciate the suggestion with the long names. But I can’t see it flying with many teams. 
Double-shift FTW
 &gt;Meh, I'd say go for Java, C# (.net) rather than PHP. Just use type safe php and you're fine &gt;Going from python to PHP must feel like going from driving a Ferrari back to a POS french car. Yeah no, not true at all. 
Not exactly on topic, but close. I was setting up mappings some time ago and somehow deleted the mapping for "do this" or "execute/run" or whatever it's called, which is normally mapped to the `enter` key. I have looked all over for what this action is called so I can set it back, but can't find. What is the name of the action for the enter key by default? Like in the Evaluate Expression dialog, I want to type it and hit enter, but have to click 'evaluate', and that sucks. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Ctrl+N searches for classes. For files you must use Shift+Ctrl+N. Or double Shift for universal search.